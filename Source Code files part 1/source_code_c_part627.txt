S_OK;

    *pbMatch = FALSE;
    
    BSTR ServiceType;
    hr = pService->get_ServiceTypeIdentifier(&ServiceType);
    if(SUCCEEDED(hr))
    {
        if(NULL != SearchCriteria) // if the caller provides a name then we search for it
        {
            if(0 == wcscmp(ServiceType, SearchCriteria))
            {
                *pbMatch = TRUE;
            }                            
        }
        else // otherwise we enter the special search case
        {
            if(0 == wcscmp(ServiceType, g_szWANIPConnectionService) || 0 == wcscmp(ServiceType, g_szWANPPPConnectionService))
            {
                VARIANT OutArgsGetConnectionTypeInfo;
                hr = InvokeVoidAction(pService, L"GetConnectionTypeInfo", &OutArgsGetConnectionTypeInfo);
                if(SUCCEEDED(hr))
                {
                    VARIANT ConnectionType;
                    LONG lIndex = 0;
                    hr = SafeArrayGetElement(V_ARRAY(&OutArgsGetConnectionTypeInfo), &lIndex, &ConnectionType);
                    if(SUCCEEDED(hr))
                    {
                        if(V_VT(&ConnectionType) == VT_BSTR)
                        {
                            if(0 == wcscmp(V_BSTR(&ConnectionType), L"IP_Routed"))
                            {
                                VARIANT OutArgsGetNATRSIPStatus;
                                hr = InvokeVoidAction(pService, L"GetNATRSIPStatus", &OutArgsGetNATRSIPStatus);
                                if(SUCCEEDED(hr))
                                {
                                    VARIANT NATEnabled;
                                    lIndex = 1;
                                    hr = SafeArrayGetElement(V_ARRAY(&OutArgsGetNATRSIPStatus), &lIndex, &NATEnabled);
                                    if(SUCCEEDED(hr))
                                    {
                                        if(V_VT(&NATEnabled) == VT_BOOL)
                                        {
                                            if(VARIANT_TRUE == V_BOOL(&NATEnabled))
                                            {
                                                *pbMatch = TRUE;
                                            }
                                        }
                                        VariantClear(&NATEnabled);
                                    }
                                    VariantClear(&OutArgsGetNATRSIPStatus);
                                }
                            }
                        }
                        VariantClear(&ConnectionType);
                    }
                    VariantClear(&OutArgsGetConnectionTypeInfo);
                }
            }
        }
        SysFreeString(ServiceType);
    }

    return hr;
}

HRESULT CSharedAccessDeviceFinderCallback::GetStringStateVariable(IUPnPService* pService, LPWSTR pszVariableName, BSTR* pString)
{
    HRESULT hr = S_OK;

    VARIANT Variant;
    VariantInit(&Variant);

    BSTR VariableName;
    VariableName = SysAllocString(pszVariableName);
    if(NULL != VariableName)
    {
        hr = pService->QueryStateVariable(VariableName, &Variant);
        if(SUCCEEDED(hr))
        {
            if(V_VT(&Variant) == VT_BSTR)
            {
                *pString = V_BSTR(&Variant);
            }
            else
            {
                hr = E_UNEXPECTED;
            }
        }

        if(FAILED(hr))
        {
            VariantClear(&Variant);
        }

        SysFreeString(VariableName);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    TraceHr (ttidError, FAL, hr, FALSE, "CSharedAccessConnection::GetStringStateVariable");
    return hr;

}

HRESULT CSharedAccessConnectionEventSink::StateVariableChanged(IUPnPService *pus, LPCWSTR pcwszStateVarName, VARIANT vaValue)
{

    HRESULT hr = S_OK;

    if(0 == lstrcmp(pcwszStateVarName, L"ConnectionStatus"))
    {
        CComObject<CSharedAccessConnection>* pSharedAccessConnection;
        hr = CComObject<CSharedAccessConnection>::CreateInstance(&pSharedAccessConnection);
        if(SUCCEEDED(hr))
        {
            pSharedAccessConnection->AddRef();

            NETCON_PROPERTIES* pProperties;
            hr = pSharedAccessConnection->GetProperties(&pProperties);
            if(SUCCEEDED(hr))
            {
                INetConnectionRefresh* pNetConnectionRefresh;
                hr = CoCreateInstance(CLSID_ConnectionManager, NULL, CLSCTX_SERVER, IID_INetConnectionRefresh, reinterpret_cast<void**>(&pNetConnectionRefresh));
                if(SUCCEEDED(hr))
                {
                    pNetConnectionRefresh->ConnectionStatusChanged(&CLSID_SharedAccessConnection, pProperties->Status);
                    pNetConnectionRefresh->Release();
                }
                FreeNetconProperties(pProperties);    
            }
            pSharedAccessConnection->Release();
        }
    }
    else if(0 == lstrcmp(pcwszStateVarName, L"X_Name"))
    {
        CComObject<CSharedAccessConnection>* pSharedAccessConnection;
        hr = CComObject<CSharedAccessConnection>::CreateInstance(&pSharedAccessConnection);
        if(SUCCEEDED(hr))
        {
            pSharedAccessConnection->AddRef();

            INetConnectionRefresh* pNetConnectionRefresh;
            hr = CoCreateInstance(CLSID_ConnectionManager, NULL, CLSCTX_SERVER, IID_INetConnectionRefresh, reinterpret_cast<void**>(&pNetConnectionRefresh));
            if(SUCCEEDED(hr))
            {
                pNetConnectionRefresh->ConnectionRenamed(pSharedAccessConnection);
                pNetConnectionRefresh->Release();
            }
            
            pSharedAccessConnection->Release();
        }
    }

    return hr;
}

HRESULT CSharedAccessConnectionEventSink::ServiceInstanceDied(IUPnPService *pus)
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netman\classman\sharedaccess\cmsabcon.h ===
#pragma once

#include "nmbase.h"

class ATL_NO_VTABLE CSharedAccessBeacon :
    public CComObjectRootEx <CComMultiThreadModel>,
    public ISharedAccessBeacon
{

public:
    BEGIN_COM_MAP(CSharedAccessBeacon)
        COM_INTERFACE_ENTRY(ISharedAccessBeacon)
    END_COM_MAP()
    
    CSharedAccessBeacon();
    
    // ISharedAccessBeacon
    STDMETHODIMP GetMediaType(NETCON_MEDIATYPE* pMediaType);
    STDMETHODIMP GetLocalAdapterGUID(GUID* pGuid);
    STDMETHODIMP GetService(SAHOST_SERVICES ulService, IUPnPService**);
    STDMETHODIMP GetUniqueDeviceName(BSTR* pUniqueDeviceName);

    HRESULT SetMediaType(NETCON_MEDIATYPE MediaType);
    HRESULT SetLocalAdapterGUID(GUID* pGuid);
    HRESULT SetService(ULONG ulService, IUPnPService* pService);
    HRESULT SetUniqueDeviceName(BSTR UniqueDeviceName);
    HRESULT FinalRelease();
private:
    
    NETCON_MEDIATYPE m_MediaType;
    GUID m_LocalAdapterGUID;
    IUPnPService* m_Services[SAHOST_SERVICE_MAX];
    BSTR m_UniqueDeviceName;


};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netman\classman\sharedaccess\enumsa.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       E N U M S A. C P P
//
//  Contents:   Implementation of Shared Access connection enumerator object
//
//  Notes:
//
//  Author:     kenwic   8 Aug 2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "enumsa.h"
#include "saconob.h"

LONG g_CountSharedAccessConnectionEnumerators;

//+---------------------------------------------------------------------------
//
//  Member:     CSharedAccessConnectionManagerEnumConnection::~CSharedAccessConnectionManagerEnumConnection
//
//  Purpose:    Called when the enumeration object is released for the last
//              time.
//
//  Arguments:
//      (none)
//
//  Returns:    Nothing
//
//  Author:     kenwic   8 Aug 2000
//
//  Notes:
//

CSharedAccessConnectionManagerEnumConnection::~CSharedAccessConnectionManagerEnumConnection()
{
    InterlockedDecrement(&g_CountSharedAccessConnectionEnumerators);
}

//+---------------------------------------------------------------------------
// IEnumNetConnection
//

//+---------------------------------------------------------------------------
//
//  Member:     CSharedAccessConnectionManagerEnumConnection::Next
//
//  Purpose:    Retrieves the next celt SharedAccess connection objects
//
//  Arguments:
//      celt         [in]       Number to retrieve
//      rgelt        [out]      Array of INetConnection objects retrieved
//      pceltFetched [out]      Returns Number in array
//
//  Returns:    S_OK if succeeded, OLE or Win32 error otherwise
//
//  Author:     kenwic   8 Aug 2000
//
//  Notes:
//
STDMETHODIMP CSharedAccessConnectionManagerEnumConnection::Next(ULONG celt,
                                                       INetConnection **rgelt,
                                                       ULONG *pceltFetched)
{
    HRESULT     hr = S_FALSE;

    // Validate parameters.
    //
    if (!rgelt || (!pceltFetched && (1 != celt)))
    {
        hr = E_POINTER;
        goto done;
    }

    if (pceltFetched)
    {
        // Initialize output parameters.
        //
        *pceltFetched = 0;
        ZeroMemory(rgelt, sizeof (*rgelt) * celt);

        if(FALSE == m_bEnumerated)
        {
            m_bEnumerated = TRUE; 

            CComObject<CSharedAccessConnection>* pConnection;
            hr = CComObject<CSharedAccessConnection>::CreateInstance(&pConnection);
            if(SUCCEEDED(hr))
            {
                pConnection->AddRef();
                hr = pConnection->QueryInterface(IID_INetConnection, reinterpret_cast<void **>(rgelt));
                if(SUCCEEDED(hr))
                {
                    // We should only get here if there is a shared access connection and this would essentially
                    // mean that homenet is running
                    CComPtr<INetConnectionUiUtilities> pNetConnUiUtil;  // check group policy
                    hr = CoCreateInstance(CLSID_NetConnectionUiUtilities, NULL, CLSCTX_INPROC, 
                                          IID_INetConnectionUiUtilities, reinterpret_cast<void **>(&pNetConnUiUtil));
                    if (SUCCEEDED(hr))
                    {
                        if (pNetConnUiUtil->UserHasPermission(NCPERM_ICSClientApp))
                        {
                            *pceltFetched = 1;                            
                        }
                        else
                        {
                            hr = S_FALSE;
                        }
                    }
                    
                    if (FAILED(hr) || (S_FALSE == hr))
                    {
                        (*rgelt)->Release();
                        *rgelt = NULL;
                    }
                }
                pConnection->Release();
            }
            else
            {
                hr = S_FALSE;
            }
        

            if(SUCCEEDED(hr))
            {
                if(1 != celt)
                {
                    hr = S_FALSE;
                }
            }
        }
    }
done:
    Assert (FImplies (S_OK == hr, (*pceltFetched == celt)));

    TraceError("CSharedAccessConnectionManagerEnumConnection::Next",
               (hr == S_FALSE || hr == HRESULT_FROM_WIN32(ERROR_DEVICE_NOT_CONNECTED)) ? S_OK : hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSharedAccessConnectionManagerEnumConnection::Skip
//
//  Purpose:    Skips over celt number of connections
//
//  Arguments:
//      celt [in]   Number of connections to skip
//
//  Returns:    S_OK if successful, otherwise Win32 error
//
//  Author:     kenwic   8 Aug 2000
//
//  Notes:
//
STDMETHODIMP CSharedAccessConnectionManagerEnumConnection::Skip(ULONG celt)
{
    HRESULT hr = S_OK;
    
    if(0 != celt)
    {
        m_bEnumerated = TRUE;
    }


    TraceError("CSharedAccessConnectionManagerEnumConnection::Skip",
               (hr == S_FALSE) ? S_OK : hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSharedAccessConnectionManagerEnumConnection::Reset
//
//  Purpose:    Resets the enumerator to the beginning
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK
//
//  Author:     kenwic   8 Aug 2000
//
//  Notes:
//
STDMETHODIMP CSharedAccessConnectionManagerEnumConnection::Reset()
{
    HRESULT hr = S_OK;
    
    m_bEnumerated = FALSE;

    TraceError("CSharedAccessConnectionManagerEnumConnection::Reset", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSharedAccessConnectionManagerEnumConnection::Clone
//
//  Purpose:    Creates a new enumeration object pointing at the same location
//              as this object
//
//  Arguments:
//      ppenum [out]    New enumeration object
//
//  Returns:    S_OK if successful, otherwise OLE or Win32 error
//
//  Author:     kenwic   8 Aug 2000
//
//  Notes:
//
STDMETHODIMP CSharedAccessConnectionManagerEnumConnection::Clone(IEnumNetConnection **ppenum)
{
    HRESULT hr = E_OUTOFMEMORY;

    // Validate parameters.
    //
    if (!ppenum)
    {
        hr = E_POINTER;
    }
    else
    {
        CSharedAccessConnectionManagerEnumConnection *   pObj;

        // Initialize output parameter.
        //
        *ppenum = NULL;

        pObj = new CComObject <CSharedAccessConnectionManagerEnumConnection>;
        if (pObj)
        {
            hr = S_OK;

            CExceptionSafeComObjectLock EsLock (this);

            // Copy our internal state.
            //
            pObj->m_bEnumerated = m_bEnumerated;

            // Return the object with a ref count of 1 on this
            // interface.
            pObj->m_dwRef = 1;
            *ppenum = pObj;
        }
    }

    TraceError ("CSharedAccessConnectionManagerEnumConnection::Clone", hr);
    return hr;
}


HRESULT CSharedAccessConnectionManagerEnumConnection::FinalRelease(void)
{
    HRESULT hr = S_OK;


    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netman\classman\sharedaccess\conmansa.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       C O N M A N S A. C P P
//
//  Contents:   Implementation of ICS connection class manager
//
//  Notes:
//
//  Author:     kenwic   8 Aug 2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "conmansa.h"
#include "enumsa.h"
#include "cmsabcon.h"

//+---------------------------------------------------------------------------
// INetConnectionManager
//
CSharedAccessConnectionManager::CSharedAccessConnectionManager()
{
    m_lSearchCookie = 0;
    m_pDeviceFinder = NULL;
    m_pDeviceFinderCallback = NULL;
    m_SocketEvent = WSA_INVALID_EVENT; 
    m_hSocketNotificationWait = INVALID_HANDLE_VALUE;
    m_DummySocket = INVALID_SOCKET;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSharedAccessConnectionManager::EnumConnections
//
//  Purpose:    Returns an enumerator object for ICS connections
//
//  Arguments:
//      Flags        [in]
//      ppEnum       [out]      Returns enumerator object
//
//  Returns:    S_OK if succeeded, OLE or Win32 error code otherwise
//
//  Author:     kenwic   17 Jul 2000
//
//  Notes:
//
STDMETHODIMP CSharedAccessConnectionManager::EnumConnections(NETCONMGR_ENUM_FLAGS Flags,
                                                    IEnumNetConnection** ppEnum)
{
    *ppEnum = NULL;

    CComObject<CSharedAccessConnectionManagerEnumConnection>* pEnum;
    HRESULT hr = CComObject<CSharedAccessConnectionManagerEnumConnection>::CreateInstance(&pEnum);
    if(SUCCEEDED(hr))
    {
        *ppEnum = static_cast<IEnumNetConnection*>(pEnum);
        pEnum->AddRef();
    }

    TraceHr (ttidError, FAL, hr, FALSE, "CSharedAccessConnectionManager::EnumConnections");
    return hr;
}

HRESULT CSharedAccessConnectionManager::FinalConstruct(void)
{
    HRESULT hr = S_OK;
    
    TraceTag(ttidConman, "CSharedAccessConnectionManager::FinalConstruct");

    m_DummySocket = socket(AF_INET, SOCK_DGRAM, 0);
    if(INVALID_SOCKET != m_DummySocket)
    {
        m_SocketEvent = CreateEvent(NULL, FALSE, TRUE, NULL);  
        if(NULL != m_SocketEvent)
        {
            if(0 != WSAEventSelect(m_DummySocket, m_SocketEvent, FD_ADDRESS_LIST_CHANGE))
            {
                hr = E_FAIL;
            }
        }
        else
        {
            hr = E_FAIL;
        }
    }
    else
    {
        hr = E_FAIL;
    }

    if(SUCCEEDED(hr)) // start up the first search on a background thread, this shoud fire immediately
    {
        // note that there is no addref here because it would keep the object alive forever.  In FinalRelease we will make sure we won't get called back
        if(0 == RegisterWaitForSingleObject(&m_hSocketNotificationWait, m_SocketEvent, AsyncStartSearching, this, INFINITE, WT_EXECUTEDEFAULT))
        {
            m_hSocketNotificationWait = INVALID_HANDLE_VALUE;
        }

    }

    TraceHr (ttidError, FAL, hr, FALSE, "CSharedAccessConnectionManager::FinalConstruct");
    
    return hr;
}

HRESULT CSharedAccessConnectionManager::FinalRelease(void)
{
    HRESULT hr = S_OK;

    TraceTag(ttidConman, "CSharedAccessConnectionManager::FinalRelease");

    if(INVALID_HANDLE_VALUE != m_hSocketNotificationWait)
    {
        UnregisterWaitEx(m_hSocketNotificationWait, INVALID_HANDLE_VALUE); // we must block here since we are not addrefed
    }

    if(INVALID_SOCKET != m_DummySocket) // the event wait must be unregistered first
    {
        closesocket(m_DummySocket);
    }

    if(WSA_INVALID_EVENT != m_SocketEvent) // the socket must be closed first
    {
        CloseHandle(m_SocketEvent);
    }

    // After the other thread is shut down, the device finder and callback won't change any more so we don't need a lock.  

    if(NULL != m_pDeviceFinder)
    {
        hr = m_pDeviceFinder->CancelAsyncFind(m_lSearchCookie);
        m_pDeviceFinder->Release();
    }

    if(NULL != m_pDeviceFinderCallback) 
    {
        m_pDeviceFinderCallback->Release();
    }


    TraceHr (ttidError, FAL, hr, FALSE, "CSharedAccessConnectionManager::FinalRelease");

    return hr;
}

HRESULT CSharedAccessConnectionManager::StartSearch(void)
{
    HRESULT hr = S_OK;

    CComObject<CSharedAccessDeviceFinderCallback>* pDeviceFinderCallback;
    hr = CComObject<CSharedAccessDeviceFinderCallback>::CreateInstance(&pDeviceFinderCallback);
    if(SUCCEEDED(hr))
    {
        pDeviceFinderCallback->AddRef();
        
        IUPnPDeviceFinder* pDeviceFinder;
        hr = CoCreateInstance(CLSID_UPnPDeviceFinder, NULL, CLSCTX_INPROC_SERVER, IID_IUPnPDeviceFinder, reinterpret_cast<void **>(&pDeviceFinder));
        if(SUCCEEDED(hr))
        {
            
            BSTR bstrTypeURI;
            bstrTypeURI = SysAllocString(L"urn:schemas-upnp-org:device:InternetGatewayDevice:1");
            if (NULL != bstrTypeURI)
            {
                LONG lSearchCookie;
                hr = pDeviceFinder->CreateAsyncFind(bstrTypeURI, 0, static_cast<IUPnPDeviceFinderCallback*>(pDeviceFinderCallback), &lSearchCookie);
                if(SUCCEEDED(hr))
                {
                    LONG lOldSearchCookie;
                    IUPnPDeviceFinder* pOldDeviceFinder;
                    CComObject<CSharedAccessDeviceFinderCallback>* pOldDeviceFinderCallback;

                    
                    Lock(); // swap in the new finder and callback
                    
                    lOldSearchCookie = m_lSearchCookie;
                    m_lSearchCookie = lSearchCookie;

                    pOldDeviceFinder = m_pDeviceFinder;
                    m_pDeviceFinder = pDeviceFinder;
                    pDeviceFinder->AddRef();
                    
                    pOldDeviceFinderCallback = m_pDeviceFinderCallback;
                    m_pDeviceFinderCallback = pDeviceFinderCallback;
                    pDeviceFinderCallback->AddRef();
                    
                    Unlock();
                    
                    if(NULL != pOldDeviceFinder) 

                    {
                        pOldDeviceFinder->CancelAsyncFind(lOldSearchCookie);
                        pOldDeviceFinder->Release();
                    }
                    
                    if(NULL != pOldDeviceFinderCallback)
                    {
                        pOldDeviceFinderCallback->DeviceRemoved(NULL, NULL); // clear out the old callback, so netshell gets cleaned up
                        pOldDeviceFinderCallback->Release();
                    }
                    
                    hr = pDeviceFinder->StartAsyncFind(lSearchCookie); // don't start the search until the new callback is in place

                }
                SysFreeString(bstrTypeURI);
            }
            pDeviceFinder->Release();
        }
        
        pDeviceFinderCallback->Release();
    }

    DWORD dwBytesReturned;
    if(SOCKET_ERROR != WSAIoctl(m_DummySocket, SIO_ADDRESS_LIST_CHANGE, NULL, 0, NULL, 0, &dwBytesReturned, NULL, NULL) || WSAEWOULDBLOCK != WSAGetLastError())
    {
        hr = E_FAIL;
    }
    

    WSANETWORKEVENTS NetworkEvents;
    ZeroMemory(&NetworkEvents, sizeof(NetworkEvents));
    WSAEnumNetworkEvents(m_DummySocket, NULL, &NetworkEvents);

    return hr;
}

void CSharedAccessConnectionManager::AsyncStartSearching(PVOID lpParameter, BOOLEAN TimerOrWaitFired)
{
    if(FALSE == TimerOrWaitFired)
    {
        CSharedAccessConnectionManager* pThis = reinterpret_cast<CSharedAccessConnectionManager*>(lpParameter);
        
        HRESULT hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
        if(SUCCEEDED(hr))
        {
            hr = pThis->StartSearch();
            CoUninitialize();
        }
    }
    return;
}



HRESULT CSharedAccessConnectionManager::GetSharedAccessBeacon(BSTR DeviceId, ISharedAccessBeacon** ppSharedAccessBeacon)
{
    HRESULT hr = S_OK;

    *ppSharedAccessBeacon = NULL;
    
    CComObject<CSharedAccessDeviceFinderCallback>* pDeviceFinderCallback;
    
    Lock();
    
    pDeviceFinderCallback = m_pDeviceFinderCallback;
    
    if(NULL != pDeviceFinderCallback)
    {
        pDeviceFinderCallback->AddRef();
    }
    
    Unlock();

    if(NULL != pDeviceFinderCallback)
    {
        hr = pDeviceFinderCallback->GetSharedAccessBeacon(DeviceId, ppSharedAccessBeacon);
        pDeviceFinderCallback->Release();
    }
    else
    {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    }
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netman\classman\sharedaccess\cmsaclbk.h ===
#pragma once

#include "nmbase.h"
#include "upnpp.h"

class ATL_NO_VTABLE CSharedAccessDeviceFinderCallback :
    public CComObjectRootEx <CComMultiThreadModel>,
    public IUPnPDeviceFinderCallback,
    public IUPnPDeviceFinderAddCallbackWithInterface
{

public:
    BEGIN_COM_MAP(CSharedAccessDeviceFinderCallback)
        COM_INTERFACE_ENTRY(IUPnPDeviceFinderCallback)
        COM_INTERFACE_ENTRY(IUPnPDeviceFinderAddCallbackWithInterface)
    END_COM_MAP()
    
    CSharedAccessDeviceFinderCallback();
    
    // IUPnPDeviceFinderCallback
    STDMETHOD (DeviceAdded)(LONG lFindData, IUPnPDevice* pDevice); 
    STDMETHOD (DeviceRemoved)(LONG lFindData, BSTR bstrUDN); 
    STDMETHOD (SearchComplete)(LONG lFindData); 

    // IUPnPDeviceFinderCallbackWithInterface
    STDMETHODIMP DeviceAddedWithInterface(LONG lFindData, IUPnPDevice* pDevice, GUID* pguidInterface);

    HRESULT GetSharedAccessBeacon(BSTR DeviceId, ISharedAccessBeacon** ppSharedAccessBeacon);
    HRESULT FinalRelease();

private:

    HRESULT FindService(IUPnPDevice* pDevice, LPWSTR pszServiceName, IUPnPService** ppICSService);
    HRESULT FindDevice(IUPnPDevices* pDevices, LPWSTR pszDeviceType, IUPnPDevice** ppChildDevice);
    HRESULT FindChildDevice(IUPnPDevice* pDevice, LPWSTR pszDeviceType, IUPnPDevice** ppChildDevice);
    HRESULT GetServices(IUPnPDevice* pDevice, GUID* pInterfaceGUID, ISharedAccessBeacon** ppSharedAccessBeacon);
    HRESULT IsServiceMatch(IUPnPService* pService, BSTR SearchCriteria, BOOL* pbMatch);

    
    HRESULT GetStringStateVariable(IUPnPService* pService, LPWSTR pszVariableName, BSTR* pString);
    ISharedAccessBeacon* m_pSharedAccessBeacon;
    
};

class ATL_NO_VTABLE CSharedAccessConnectionEventSink :
    public CComObjectRootEx <CComMultiThreadModel>,
    public IUPnPServiceCallback
{

public:
    BEGIN_COM_MAP(CSharedAccessConnectionEventSink)
        COM_INTERFACE_ENTRY(IUPnPServiceCallback)
    END_COM_MAP()
    
    STDMETHODIMP StateVariableChanged(IUPnPService *pus, LPCWSTR pcwszStateVarName, VARIANT vaValue);
    STDMETHODIMP ServiceInstanceDied(IUPnPService *pus);
private:
    IUPnPServiceCallback* m_pSink;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netman\classman\sharedaccess\enumsa.h ===
#pragma once
#include "nmbase.h"
#include "nmres.h"
#include "conmansa.h"


extern LONG g_CountSharedAccessConnectionEnumerators;


class ATL_NO_VTABLE CSharedAccessConnectionManagerEnumConnection :
    public CComObjectRootEx <CComMultiThreadModel>,
    public CComCoClass <CSharedAccessConnectionManagerEnumConnection,
                        &CLSID_LanConnectionManagerEnumConnection>,
    public IEnumNetConnection
{
private:
    BOOL m_bEnumerated;

public:
    CSharedAccessConnectionManagerEnumConnection()
    {
        m_bEnumerated = FALSE;

        InterlockedIncrement(&g_CountSharedAccessConnectionEnumerators);
    }


    ~CSharedAccessConnectionManagerEnumConnection();

    DECLARE_REGISTRY_RESOURCEID(IDR_SA_CONMAN_ENUM)

    BEGIN_COM_MAP(CSharedAccessConnectionManagerEnumConnection)
        COM_INTERFACE_ENTRY(IEnumNetConnection)
    END_COM_MAP()

    // IEnumNetConnection
    STDMETHOD(Next)(ULONG celt, INetConnection **rgelt, ULONG *pceltFetched);
    STDMETHOD(Skip)(ULONG celt);
    STDMETHOD(Reset)();
    STDMETHOD(Clone)(IEnumNetConnection **ppenum);

    HRESULT FinalRelease(void);

public:
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netman\classman\sharedaccess\conmansa.h ===
#pragma once
#include "nmbase.h"
#include "nmres.h"
#include "upnp.h"
#include "upnpp.h"
#include "cmsaclbk.h"

#include "hnetbcon.h"
#include "winsock2.h"

class ATL_NO_VTABLE CSharedAccessConnectionManager :
    public CComObjectRootEx <CComMultiThreadModel>,
    public CComCoClass <CSharedAccessConnectionManager,
                        &CLSID_SharedAccessConnectionManager>,
    public IConnectionPointContainerImpl <CSharedAccessConnectionManager>,
    public INetConnectionManager,
    public ISharedAccessBeaconFinder
{
public:
    CSharedAccessConnectionManager();

    DECLARE_CLASSFACTORY_DEFERRED_SINGLETON(CSharedAccessConnectionManager)
    DECLARE_REGISTRY_RESOURCEID(IDR_SA_CONMAN)

    BEGIN_COM_MAP(CSharedAccessConnectionManager)
        COM_INTERFACE_ENTRY(INetConnectionManager)
        COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
        COM_INTERFACE_ENTRY(ISharedAccessBeaconFinder)
    END_COM_MAP()

    BEGIN_CONNECTION_POINT_MAP(CSharedAccessConnectionManager)
    END_CONNECTION_POINT_MAP()

    // INetConnectionManager
    STDMETHODIMP EnumConnections(NETCONMGR_ENUM_FLAGS Flags, IEnumNetConnection** ppEnum);

    // IBeaconFinder
    STDMETHODIMP GetSharedAccessBeacon(BSTR DeviceId, ISharedAccessBeacon** ppSharedAccessBeacon);

    HRESULT FinalConstruct(void);
    HRESULT FinalRelease(void);

private:

    VOID static CALLBACK AsyncStartSearching(PVOID lpParameter, BOOLEAN TimerOrWaitFired);
    HRESULT StartSearch(void);
    
    LONG m_lSearchCookie;
    IUPnPDeviceFinder* m_pDeviceFinder;
    CComObject<CSharedAccessDeviceFinderCallback>* m_pDeviceFinderCallback;
    WSAEVENT m_SocketEvent;
    HANDLE m_hSocketNotificationWait;
    SOCKET m_DummySocket;
    

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netman\classman\sharedaccess\saconob.cpp ===
#include "pch.h"
#pragma hdrstop

#include "nccom.h"
#include "ncnetcon.h"
#include "ncreg.h"
#include "saconob.h"
static const CLSID CLSID_SharedAccessConnectionUi =
    {0x7007ACD5,0x3202,0x11D1,{0xAA,0xD2,0x00,0x80,0x5F,0xC1,0x27,0x0E}};

static const WCHAR c_szConnName[]                 = L"Name";
static const WCHAR c_szShowIcon[]                 = L"ShowIcon";
static const WCHAR c_szSharedAccessClientKeyPath[] = L"System\\CurrentControlSet\\Control\\Network\\SharedAccessConnection";

#define UPNP_ACTION_HRESULT(lError) (UPNP_E_ACTION_SPECIFIC_BASE + (lError - FAULT_ACTION_SPECIFIC_BASE))


CSharedAccessConnection::CSharedAccessConnection()
{
    m_pSharedAccessBeacon = NULL;
    m_pWANConnectionService = NULL;
}

HRESULT CSharedAccessConnection::FinalConstruct()
{
    HRESULT hr = S_OK;
    
    ISharedAccessBeaconFinder* pBeaconFinder;
    hr = HrCreateInstance(CLSID_SharedAccessConnectionManager, CLSCTX_SERVER, &pBeaconFinder);
    if(SUCCEEDED(hr))
    {
        hr = pBeaconFinder->GetSharedAccessBeacon(NULL, &m_pSharedAccessBeacon);
        if(SUCCEEDED(hr))
        {
            NETCON_MEDIATYPE MediaType;
            hr = m_pSharedAccessBeacon->GetMediaType(&MediaType);
            if(SUCCEEDED(hr))
            {
                hr = m_pSharedAccessBeacon->GetService(NCM_SHAREDACCESSHOST_LAN == MediaType ? SAHOST_SERVICE_WANIPCONNECTION : SAHOST_SERVICE_WANPPPCONNECTION, &m_pWANConnectionService);
            }
        }
        pBeaconFinder->Release();
    }
    return hr;
}

HRESULT CSharedAccessConnection::FinalRelease()
{
    HRESULT hr = S_OK;
    
    if(NULL != m_pSharedAccessBeacon)
    {
        m_pSharedAccessBeacon->Release();
    }

    if(NULL != m_pWANConnectionService)
    {
        m_pWANConnectionService->Release();
    }
    
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSharedAccessConnection::GetConnectionName
//
//  Purpose:    Initializes the connection object for the first time.
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK if success, Win32 or OLE error code otherwise
//
//  Author:     kenwic   8 Aug 2000
//
//  Notes:      This function is only called when the object is created for
//              the very first time and has no identity.
//
HRESULT CSharedAccessConnection::GetConnectionName(LPWSTR* pName)
{
    HRESULT     hr = S_OK;
    
    HKEY hKey;
    
    // first get the user assigned name
    
    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szSharedAccessClientKeyPath, KEY_READ, &hKey);
    if(SUCCEEDED(hr))
    {
        tstring strName;
        hr = HrRegQueryString(hKey, c_szConnName, &strName);
        if (SUCCEEDED(hr))
        {
            hr = HrCoTaskMemAllocAndDupSz (strName.c_str(), pName, NETCON_MAX_NAME_LEN);
        }
        RegCloseKey(hKey);
    }

    // if that doesn't exist, construct the name
    
    if(FAILED(hr))
    {
        IUPnPService* pOSInfoService;
        hr = m_pSharedAccessBeacon->GetService(SAHOST_SERVICE_OSINFO, &pOSInfoService);
        if(SUCCEEDED(hr))
        {
            BSTR MachineName;
            hr = GetStringStateVariable(pOSInfoService, L"OSMachineName", &MachineName);
            if(SUCCEEDED(hr))
            {
                BSTR SharedAdapterName;
                hr = GetStringStateVariable(m_pWANConnectionService, L"X_Name", &SharedAdapterName);
                if(SUCCEEDED(hr))
                {
                    LPWSTR szNameString;
                    LPCWSTR szTemplateString = SzLoadIds(IDS_SHAREDACCESS_CONN_NAME);
                    Assert(NULL != szTemplateString);
                    
                    LPOLESTR pszParams[] = {SharedAdapterName, MachineName};
                    
                    if(0 != FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY, szTemplateString, 0, 0, reinterpret_cast<LPWSTR>(&szNameString), 0, reinterpret_cast<va_list *>(pszParams)))
                    {
                        HrCoTaskMemAllocAndDupSz (szNameString, pName, NETCON_MAX_NAME_LEN);
                        LocalFree(szNameString);
                    } 
                    else
                    {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                    }
                    SysFreeString(SharedAdapterName);
                }
                SysFreeString(MachineName);
            }
            pOSInfoService->Release();
        }
        
    }
    
    // if that fails, use the default

    if(FAILED(hr))
    {
        hr = HrCoTaskMemAllocAndDupSz (SzLoadIds(IDS_SHAREDACCESS_DEFAULT_CONN_NAME), pName, NETCON_MAX_NAME_LEN);
    }

    TraceError("CSharedAccessConnection::HrInitialize", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSharedAccessConnection::GetStatus
//
//  Purpose:    Returns the status of this ICS connection
//
//  Arguments:
//      pStatus [out]   Returns status value
//
//  Returns:    S_OK if success, OLE or Win32 error code otherwise
//
//  Author:     kenwic   8 Aug 2000
//
//  Notes:
//
HRESULT CSharedAccessConnection::GetStatus(NETCON_STATUS *pStatus)
{
    HRESULT hr = S_OK;

    if (!pStatus)
    {
        hr = E_POINTER;
    }
    else
    {   
        BSTR ConnectionStatus;
        hr = GetStringStateVariable(m_pWANConnectionService, L"ConnectionStatus", &ConnectionStatus);
        if(SUCCEEDED(hr))
        {
            if(0 == lstrcmp(ConnectionStatus, L"Connected"))
            {
                *pStatus = NCS_CONNECTED;
            }
            else if(0 == lstrcmp(ConnectionStatus, L"Disconnected"))
            {
                *pStatus = NCS_DISCONNECTED;
            }
            else if(0 == lstrcmp(ConnectionStatus, L"Unconfigured"))
            {
                *pStatus = NCS_HARDWARE_DISABLED; // REVIEW: better state?
            }
            else if(0 == lstrcmp(ConnectionStatus, L"Connecting"))
            {
                *pStatus = NCS_CONNECTING;
            }
            else if(0 == lstrcmp(ConnectionStatus, L"Authenticating"))
            {
                *pStatus = NCS_CONNECTING;
            }
            else if(0 == lstrcmp(ConnectionStatus, L"PendingDisconnect"))
            {
                *pStatus = NCS_DISCONNECTING;
            }
            else if(0 == lstrcmp(ConnectionStatus, L"Disconnecting"))
            {
                *pStatus = NCS_DISCONNECTING;
            }
            else 
            {
                *pStatus = NCS_HARDWARE_DISABLED;
            }
            SysFreeString(ConnectionStatus);
        }
    }

    TraceError("CSharedAccessConnection::GetStatus", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSharedAccessConnection::GetCharacteristics
//
//  Purpose:    Returns the characteristics of this connection type
//
//  Arguments:
//      pdwFlags [out]    Returns characteristics flags
//
//  Returns:    S_OK if successful, OLE or Win32 error code otherwise
//
//  Author:     kenwic   8 Aug 2000
//
//  Notes:
//
HRESULT CSharedAccessConnection::GetCharacteristics(DWORD* pdwFlags)
{
    Assert (pdwFlags);

    // TODO when get have a place to save the name, allow rename
    HRESULT hr = S_OK;

    *pdwFlags = NCCF_ALL_USERS | NCCF_ALLOW_RENAME; // REVIEW always ok, group policy?

    HKEY hKey;
    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szSharedAccessClientKeyPath, KEY_QUERY_VALUE, &hKey);
    if(SUCCEEDED(hr))
    {
        DWORD dwShowIcon = 0;
        DWORD dwSize = sizeof(dwShowIcon);
        DWORD dwType;
        hr = HrRegQueryValueEx(hKey, c_szShowIcon, &dwType, reinterpret_cast<LPBYTE>(&dwShowIcon), &dwSize);  
        if(SUCCEEDED(hr) && REG_DWORD == dwType)
        {
            if(0 != dwShowIcon)
            {
                *pdwFlags |= NCCF_SHOW_ICON;
            }
        }
        RegCloseKey(hKey);

    }
    
    hr = S_OK; // it's ok if the key doesn't exist
    
    TraceError("CSharedAccessConnection::GetCharacteristics", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSharedAccessConnection::Connect
//
//  Purpose:    Connects the remote ICS host
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK if success, OLE or Win32 error code otherwise
//
//  Author:     kenwic   8 Aug 2000
//

HRESULT CSharedAccessConnection::Connect()
{
    HRESULT hr = S_OK;
    
    VARIANT OutArgs;
    hr = InvokeVoidAction(m_pWANConnectionService, L"RequestConnection", &OutArgs);
    if(UPNP_ACTION_HRESULT(800) == hr)
    {
        hr = E_ACCESSDENIED;
        VariantClear(&OutArgs);
    }
    
    TraceError("CSharedAccessConnection::Connect", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSharedAccessConnection::Disconnect
//
//  Purpose:    Disconnects the remote ICS host
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK if success, OLE or Win32 error code otherwise
//
//  Author:     kenwic   8 Aug 2000
//

HRESULT CSharedAccessConnection::Disconnect()
{
    HRESULT hr = S_OK;
    
    VARIANT OutArgs;
    hr = InvokeVoidAction(m_pWANConnectionService, L"ForceTermination", &OutArgs);
    if(UPNP_ACTION_HRESULT(800) == hr)
    {
        hr = E_ACCESSDENIED;
        VariantClear(&OutArgs);
    }
    
    TraceError("CSharedAccessConnection::Disconnect", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSharedAccessConnection::Delete
//
//  Purpose:    Delete the remote ICS connection.  This not allowed.
//
//  Arguments:
//      (none)
//
//  Returns:    E_FAIL;
//
//  Author:     kenwic   8 Aug 2000
//
//  Notes:      This function is not expected to ever be called.
//

HRESULT CSharedAccessConnection::Delete()
{
    return E_FAIL; // can't delete the beacon
}

//+---------------------------------------------------------------------------
//
//  Member:     CSharedAccessConnection::Duplicate
//
//  Purpose:    Duplicates the remote ICS connection.  This not allowed.
//
//  Arguments:
//      (none)
//
//  Returns:    E_UNEXPECTED;
//
//  Author:     kenwic   8 Aug 2000
//
//  Notes:      This function is not expected to ever be called.
//

STDMETHODIMP CSharedAccessConnection::Duplicate (
    PCWSTR             pszDuplicateName,
    INetConnection**    ppCon)
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSharedAccessConnection::GetProperties
//
//  Purpose:    Get all of the properties associated with the connection.
//              Returning all of them at once saves us RPCs vs. returning
//              each one individually.
//
//  Arguments:
//      ppProps [out] Returned block of properties.
//
//  Returns:    S_OK or an error.
//
//  Author:     kenwic   8 Aug 2000
//
//  Notes:
//
STDMETHODIMP CSharedAccessConnection::GetProperties (
    NETCON_PROPERTIES** ppProps)
{
    HRESULT hr = S_OK;

    // Validate parameters.
    //
    if (!ppProps)
    {
        hr = E_POINTER;
    }
    else
    {
        // Initialize the output parameter.
        //
        *ppProps = NULL;

        NETCON_PROPERTIES* pProps;
        hr = HrCoTaskMemAlloc (sizeof (NETCON_PROPERTIES), reinterpret_cast<void**>(&pProps));
        if (SUCCEEDED(hr))
        {
            HRESULT hrT;

            ZeroMemory (pProps, sizeof (NETCON_PROPERTIES));

            // guidId
            //
            pProps->guidId = CLSID_SharedAccessConnection; // there is only ever one beacon icon, so we'll just use our class id.  
                                                           // we can't use all zeroes because the add connection wizard does that
            
            // pszwName
            //

            hrT = GetConnectionName(&pProps->pszwName);
            if (FAILED(hrT))
            {
                hr = hrT;
            }

            // pszwDeviceName
            //
            hrT = HrCoTaskMemAllocAndDupSz (pProps->pszwName, &pProps->pszwDeviceName, NETCON_MAX_NAME_LEN); // TODO the spec says the same as pszwName here, is that right
            if (FAILED(hrT))
            {
                hr = hrT;
            }

            // Status
            //
            hrT = GetStatus (&pProps->Status);
            if (FAILED(hrT))
            {
                hr = hrT;
            }

            if(NULL != m_pSharedAccessBeacon)
            {
                hr = m_pSharedAccessBeacon->GetMediaType(&pProps->MediaType);
            }
            else
            {
                hr = E_UNEXPECTED;
            }

            hrT = GetCharacteristics (&pProps->dwCharacter);
            if (FAILED(hrT))
            {
                hr = hrT;
            }

            // clsidThisObject
            //
            pProps->clsidThisObject = CLSID_SharedAccessConnection;

            // clsidUiObject
            //
            pProps->clsidUiObject = CLSID_SharedAccessConnectionUi;

            // Assign the output parameter or cleanup if we had any failures.
            //
            if (SUCCEEDED(hr))
            {
                *ppProps = pProps;
            }
            else
            {
                Assert (NULL == *ppProps);
                FreeNetconProperties (pProps);
            }
        }
    }
    TraceError ("CLanConnection::GetProperties", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSharedAccessConnection::GetUiObjectClassId
//
//  Purpose:    Returns the CLSID of the object that handles UI for this
//              connection type
//
//  Arguments:
//      pclsid [out]    Returns CLSID of UI object
//
//  Returns:    S_OK if success, OLE error code otherwise
//
//  Author:     kenwic   8 Aug 2000
//
//  Notes:
//
STDMETHODIMP CSharedAccessConnection::GetUiObjectClassId(CLSID *pclsid)
{
    HRESULT hr = S_OK;

    // Validate parameters.
    //
    if (!pclsid)
    {
        hr = E_POINTER;
    }
    else
    {
        *pclsid = CLSID_SharedAccessConnectionUi;
    }

    TraceError("CLanConnection::GetUiObjectClassId", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSharedAccessConnection::Rename
//
//  Purpose:    Changes the name of the connection
//
//  Arguments:
//      pszName [in]     New connection name (must be valid)
//
//  Returns:    S_OK if success, OLE error code otherwise
//
//  Author:     kenwic   8 Aug 2000
//
//  Notes:
//
STDMETHODIMP CSharedAccessConnection::Rename(PCWSTR pszName)
{
    HRESULT     hr = S_OK;

    if (!pszName)
    {
        hr = E_POINTER;
    }
    else if (!FIsValidConnectionName(pszName))
    {
        // Bad connection name
        hr = E_INVALIDARG;
    }
    else
    {

        HKEY hKey;
        hr = HrRegCreateKeyEx(HKEY_LOCAL_MACHINE, c_szSharedAccessClientKeyPath, NULL, KEY_SET_VALUE, NULL, &hKey, NULL);
        if(SUCCEEDED(hr))
        {
            hr = HrRegSetSz(hKey, c_szConnName, pszName); 
            if (S_OK == hr)
            {
                INetConnectionRefresh* pNetConnectionRefresh;
                hr = CoCreateInstance(CLSID_ConnectionManager, NULL, CLSCTX_SERVER, IID_INetConnectionRefresh, reinterpret_cast<void**>(&pNetConnectionRefresh));
                if(SUCCEEDED(hr))
                {
                    pNetConnectionRefresh->ConnectionRenamed(this);
                    pNetConnectionRefresh->Release();
                }
            }
                
        }
    }

    TraceError("CLanConnection::Rename", hr);
    return hr;
}

//+---------------------------------------------------------------------------
// IPersistNetConnection
//

//+---------------------------------------------------------------------------
//
//  Member:     CSharedAccessConnection::GetClassID
//
//  Purpose:    Returns the CLSID of connection objects
//
//  Arguments:
//      pclsid [out]    Returns CLSID to caller
//
//  Returns:    S_OK if success, OLE error otherwise
//
//  Author:     kenwic   8 Aug 2000
//
//  Notes:
//
STDMETHODIMP CSharedAccessConnection::GetClassID(CLSID*  pclsid)
{
    HRESULT hr = S_OK;

    // Validate parameters.
    //
    if (!pclsid)
    {
        hr = E_POINTER;
    }
    else
    {
        *pclsid = CLSID_SharedAccessConnection; // we just use our guid since there is only ever one saconob
    }
    TraceError("CSharedAccessConnection::GetClassID", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSharedAccessConnection::GetSizeMax
//
//  Purpose:    Returns the maximum size of the persistence data
//
//  Arguments:
//      pcbSize [out]   Returns size
//
//  Returns:    S_OK if success, OLE error otherwise
//
//  Author:     kenwic   8 Aug 2000
//
//  Notes:
//
STDMETHODIMP CSharedAccessConnection::GetSizeMax(ULONG *pcbSize)
{
    HRESULT hr = S_OK;

    // Validate parameters.
    //
    if (!pcbSize)
    {
        hr = E_POINTER;
    }
    else
    {
        *pcbSize = sizeof(GUID);
    }

    TraceError("CLanConnection::GetSizeMax", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSharedAccessConnection::Load
//
//  Purpose:    Allows the connection object to initialize (restore) itself
//              from previously persisted data
//
//  Arguments:
//      pbBuf  [in]     Private data to use for restoring
//      cbSize [in]     Size of data
//
//  Returns:    S_OK if success, OLE error otherwise
//
//  Author:     kenwic   8 Aug 2000
//
//  Notes:
//
STDMETHODIMP CSharedAccessConnection::Load(const BYTE *pbBuf, ULONG cbSize)
{
    HRESULT hr = E_INVALIDARG;

    // Validate parameters.
    //
    if (!pbBuf)
    {
        hr = E_POINTER;
    }
    else if (cbSize != sizeof(GUID))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = S_OK; // we don't need this guid, but we have to implemenet IPersistNetConnection
    }

    TraceError("CLanConnection::Load", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSharedAccessConnection::Save
//
//  Purpose:    Provides the caller with data to use in restoring this object
//              at a later time.
//
//  Arguments:
//      pbBuf  [out]    Returns data to use for restoring
//      cbSize [in]     Size of data buffer
//
//  Returns:    S_OK if success, OLE error otherwise
//
//  Author:     kenwic   8 Aug 2000
//
//  Notes:
//
STDMETHODIMP CSharedAccessConnection::Save(BYTE *pbBuf, ULONG cbSize)
{
    HRESULT hr;

    // Validate parameters.
    //
    if (!pbBuf)
    {
        hr = E_POINTER;
    }
    else
    {
        CopyMemory(pbBuf, &CLSID_SharedAccessConnection, cbSize); // REVIEW can we eliminate this?
    }

    TraceError("CLanConnection::Save", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSharedAccessConnection::GetInfo
//
//  Purpose:    Returns information about this connection
//
//  Arguments:
//      dwMask      [in]    Flags that control which fields to return. Use
//                          SACIF_ALL to get all fields.
//      pLanConInfo [out]   Structure that holds returned information
//
//  Returns:    S_OK if success, OLE error code otherwise
//
//  Author:     kenwic   6 Sep 2000
//
//  Notes:      Caller should delete the szwConnName value.
//
STDMETHODIMP CSharedAccessConnection::GetInfo(DWORD dwMask, SHAREDACCESSCON_INFO* pConInfo)
{
    HRESULT     hr = S_OK;

    if (!pConInfo)
    {
        hr = E_POINTER;
    }
    else
    {
        ZeroMemory(pConInfo, sizeof(SHAREDACCESSCON_INFO));

        if (dwMask & SACIF_ICON)
        {
            if (SUCCEEDED(hr))
            {
                DWORD dwValue;

                // OK if value not there. Default to FALSE always.
                //
                
                HKEY hKey;
                hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szSharedAccessClientKeyPath, KEY_QUERY_VALUE, &hKey);
                if(SUCCEEDED(hr))
                {
                    if (S_OK == HrRegQueryDword(hKey, c_szShowIcon, &dwValue))
                    {
                        pConInfo->fShowIcon = !!(dwValue);
                    }
                    RegCloseKey(hKey);
                }
            }
        }
    }

    // Mask S_FALSE if it slipped thru.
    if (S_FALSE == hr)
    {
        hr = S_OK;
    }

    TraceError("CSharedAccessConnection::GetInfo", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSharedAccessConnection::SetInfo
//
//  Purpose:    Sets information about this connection.
//
//  Arguments:
//      dwMask      [in]    Flags that control which fields to set
//      pConInfo [in]    Structure containing information to set
//
//  Returns:    S_OK if success, OLE or Win32 error code otherwise
//
//  Author:     kenwic   6 Sep 2000
//

STDMETHODIMP CSharedAccessConnection::SetInfo(DWORD dwMask,
                                     const SHAREDACCESSCON_INFO* pConInfo)
{
    HRESULT     hr = S_OK;

    if (!pConInfo)
    {
        hr = E_POINTER;
    }
    else
    {
        if (dwMask & SACIF_ICON)
        {
            if (SUCCEEDED(hr))
            {
                // Set ShowIcon value
                HKEY hKey;
                hr = HrRegCreateKeyEx(HKEY_LOCAL_MACHINE, c_szSharedAccessClientKeyPath, NULL, KEY_SET_VALUE, NULL, &hKey, NULL);
                if(SUCCEEDED(hr))
                {
                    hr = HrRegSetDword(hKey, c_szShowIcon, pConInfo->fShowIcon);
                    RegCloseKey(hKey);
                }
            }
        }

        if (SUCCEEDED(hr))
        {
            INetConnectionRefresh* pNetConnectionRefresh;
            hr = CoCreateInstance(CLSID_ConnectionManager, NULL, CLSCTX_SERVER, IID_INetConnectionRefresh, reinterpret_cast<void**>(&pNetConnectionRefresh));
            if(SUCCEEDED(hr))
            {
                pNetConnectionRefresh->ConnectionModified(this);
                pNetConnectionRefresh->Release();
            }
        }
    }

    TraceError("CSharedAccessConnection::SetInfo", hr);
    return hr;
}


HRESULT CSharedAccessConnection::GetLocalAdapterGUID(GUID* pGuid)
{
    return m_pSharedAccessBeacon->GetLocalAdapterGUID(pGuid);
}

HRESULT CSharedAccessConnection::GetService(SAHOST_SERVICES ulService, IUPnPService** ppService)
{
    return m_pSharedAccessBeacon->GetService(ulService, ppService);
}

HRESULT CSharedAccessConnection::GetStringStateVariable(IUPnPService* pService, LPWSTR pszVariableName, BSTR* pString)
{
    HRESULT hr = S_OK;
    
    VARIANT Variant;
    VariantInit(&Variant);

    BSTR VariableName; 
    VariableName = SysAllocString(pszVariableName);
    if(NULL != VariableName)
    {
        hr = pService->QueryStateVariable(VariableName, &Variant);
        if(SUCCEEDED(hr))
        {
            if(V_VT(&Variant) == VT_BSTR)
            {
                *pString = V_BSTR(&Variant);
            }
            else
            {
                hr = E_UNEXPECTED;
            }
        }
        
        if(FAILED(hr))
        {
            VariantClear(&Variant);
        }
        
        SysFreeString(VariableName);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    TraceHr (ttidError, FAL, hr, FALSE, "CSharedAccessConnection::GetStringStateVariable");

    return hr;

}

HRESULT InvokeVoidAction(IUPnPService * pService, LPTSTR pszCommand, VARIANT* pOutParams)
{
    HRESULT hr;
    BSTR bstrActionName;

    bstrActionName = SysAllocString(pszCommand);
    if (NULL != bstrActionName)
    {
        SAFEARRAYBOUND  rgsaBound[1];
        SAFEARRAY       * psa = NULL;

        rgsaBound[0].lLbound = 0;
        rgsaBound[0].cElements = 0;

        psa = SafeArrayCreate(VT_VARIANT, 1, rgsaBound);

        if (psa)
        {
            LONG    lStatus;
            VARIANT varInArgs;
            VARIANT varReturnVal;

            VariantInit(&varInArgs);
            VariantInit(pOutParams);
            VariantInit(&varReturnVal);

            varInArgs.vt = VT_VARIANT | VT_ARRAY;

            V_ARRAY(&varInArgs) = psa;

            hr = pService->InvokeAction(bstrActionName,
                                        varInArgs,
                                        pOutParams,
                                        &varReturnVal);
            if(SUCCEEDED(hr))
            {
                VariantClear(&varReturnVal);
            }

            SafeArrayDestroy(psa);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }   

        SysFreeString(bstrActionName);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netman\classman\sharedaccess\saconob.h ===
#pragma once
#include "hnetbcon.h"
#include "nmbase.h"
#include "nmres.h"
#include "HNetCfg.h"



extern LONG g_CountSharedAccessConnectionObjects;

HRESULT InvokeVoidAction(IUPnPService * pService, LPTSTR pszCommand, VARIANT* pOutParams);

class ATL_NO_VTABLE CSharedAccessConnection :
    public CComObjectRootEx <CComMultiThreadModel>,
    public CComCoClass <CSharedAccessConnection, &CLSID_SharedAccessConnection>,
    public INetConnection,
    public INetSharedAccessConnection,
    public IPersistNetConnection
{

public:
    DECLARE_REGISTRY_RESOURCEID(IDR_SA_CONNECTION)

    BEGIN_COM_MAP(CSharedAccessConnection)
        COM_INTERFACE_ENTRY(INetConnection)
        COM_INTERFACE_ENTRY(INetSharedAccessConnection)
        COM_INTERFACE_ENTRY(IPersistNetConnection)
    END_COM_MAP()

    CSharedAccessConnection();
    
    HRESULT GetStatus(NETCON_STATUS*  pStatus);
    HRESULT GetCharacteristics(DWORD* pdwFlags);
    
    //
    // INetConnection
    //
    STDMETHOD(Connect)();
    STDMETHOD(Disconnect)();
    STDMETHOD(Delete)();
    STDMETHOD(Duplicate) (PCWSTR pszwDuplicateName, INetConnection** ppCon);
    STDMETHOD(GetProperties) (NETCON_PROPERTIES** ppProps);
    STDMETHOD(GetUiObjectClassId)(CLSID *pclsid);
    STDMETHOD(Rename)(PCWSTR pszwNewName);

    //
    // INetSharedAccessConnection
    //
    
    STDMETHOD(GetInfo)(DWORD dwMask, SHAREDACCESSCON_INFO* pConInfo);
    STDMETHOD(SetInfo)(DWORD dwMask, const SHAREDACCESSCON_INFO* pConInfo);
    STDMETHODIMP GetLocalAdapterGUID(GUID* pGuid);
    STDMETHODIMP GetService(SAHOST_SERVICES ulService, IUPnPService** ppService);


    //
    // IPersistNetConnection
    //

    STDMETHOD(GetClassID)(CLSID *pclsid);
    STDMETHOD(GetSizeMax)(ULONG *pcbSize);
    STDMETHOD(Load)(const BYTE *pbBuf, ULONG cbSize);
    STDMETHOD(Save)(BYTE *pbBuf, ULONG cbSize);

    //
    // Overrides
    //

    HRESULT FinalConstruct(void);
    HRESULT FinalRelease(void);

private:
    HRESULT GetConnectionName(LPWSTR* pName);
    HRESULT GetStringStateVariable(IUPnPService* pService, LPWSTR pszVariableName, BSTR* pString);

    ISharedAccessBeacon* m_pSharedAccessBeacon;
    IUPnPService* m_pWANConnectionService;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netman\conman\cmdirect.cpp ===
// This contains all the functions that are currently directly called inside the class managers from netman
// In order to move the class managers out later, these functions should stop being used.

#include "pch.h"
#pragma hdrstop

#define NO_CM_SEPERATE_NAMESPACES

#include "nmbase.h"
#include "cmdirect.h"

// Don't try moving these function to an inline in cmdirect.h. It won't work - it requires
// access to CDialupConnection in the root namespace, which is not defined unless
// NO_CM_SEPERATE_NAMESPACES is defined.
namespace CMDIRECT
{
    namespace DIALUP
    {
        HRESULT CreateWanConnectionManagerEnumConnectionInstance(
                NETCONMGR_ENUM_FLAGS    Flags,
                REFIID                  riid,
                VOID**                  ppv)        
        {
                return CWanConnectionManagerEnumConnection::CreateInstance(
                Flags,
                riid,
                ppv);

        }
        
        HRESULT CreateInstanceFromDetails(
            const RASENUMENTRYDETAILS*  pEntryDetails,
            REFIID                      riid,
            VOID**                      ppv)
        {
                return CDialupConnection::CreateInstanceFromDetails (
                pEntryDetails,
                riid,
                ppv);

        }
    }

    namespace INBOUND
    {
        HRESULT CreateInstance (
            IN  BOOL        fIsConfigConnection,
            IN  HRASSRVCONN hRasSrvConn,
            IN  PCWSTR     pszwName,
            IN  PCWSTR     pszwDeviceName,
            IN  DWORD       dwType,
            IN  const GUID* pguidId,
            IN  REFIID      riid,
            OUT VOID**      ppv)
        {
            return CInboundConnection::CreateInstance(fIsConfigConnection, hRasSrvConn, pszwName, pszwDeviceName, dwType, pguidId, riid, ppv);
        }

    }
}


#include "nmbase.h"
#include "conman.h"
#include "cmutil.h"
#include "ncras.h"
#include "diag.h"
#include "cmdirect.h"

// These functions are exported from class managers
EXTERN_C
VOID
WINAPI
NetManDiagFromCommandArgs (IN const DIAG_OPTIONS * pOptions)
{
    Assert (pOptions);
    Assert (pOptions->pDiagCtx);
    g_pDiagCtx = pOptions->pDiagCtx;

    INetConnectionManager * pConMan;

    CMDIRECT(LANCON, HrInitializeConMan)(&pConMan);

    switch (pOptions->Command)
    {
    case CMD_SHOW_LAN_CONNECTIONS:
        CMDIRECT(LANCON, CmdShowLanConnections)(pOptions, pConMan);
        break;

    case CMD_SHOW_ALL_DEVICES:
        CMDIRECT(LANCON, CmdShowAllDevices)(pOptions, pConMan);
        break;

    case CMD_SHOW_LAN_DETAILS:
        CMDIRECT(LANCON, CmdShowLanDetails)(pOptions, pConMan);
        break;

    case CMD_LAN_CHANGE_STATE:
        CMDIRECT(LANCON, CmdLanChangeState)(pOptions, pConMan);
        break;

    default:
        break;
    }

    CMDIRECT(LANCON, HrUninitializeConMan(pConMan));

    g_pDiagCtx = NULL;
}


#include "raserror.h"
//+---------------------------------------------------------------------------
//
//  Function:   HrRasConnectionNameFromGuid
//
//  Purpose:    Exported API used by iphlpapi et. al. to get the connection
//              of a RAS connection given its GUID.
//
//  Arguments:
//      guid     [in]    The guid id representing the connection.
//      pszwName [out]   Pointer to a buffer to store the name.
//      pcchMax  [inout] On input, the length, in characters, of the buffer
//                       including the null terminator.  On output, the
//                       length of the string including the null terminator
//                       (if it was written) or the length of the buffer
//                       required.
//
//  Returns:    HRESULT_FROM_WIN32(ERROR_NOT_FOUND) if the entry was not found.
//              HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)
//              S_OK
//
//  Author:     shaunco   23 Sep 1998
//
//  Notes:
//
EXTERN_C
HRESULT
WINAPI
HrRasConnectionNameFromGuid (
    IN      REFGUID guid,
    OUT     PWSTR   pszwName,
    IN OUT  DWORD*  pcchMax)
{
    Assert (pszwName);
    Assert (pcchMax);

    // Initialize the output parameter.
    //
    *pszwName = NULL;

    // We now need to enumerate all entries in this phonebook and
    // find our details record with the matching guidId.
    //
    RASENUMENTRYDETAILS* aRasEntryDetails;
    DWORD                cRasEntryDetails;
    HRESULT              hr;

    hr = HrRasEnumAllEntriesWithDetails (
            NULL,
            &aRasEntryDetails,
            &cRasEntryDetails);

    if (SUCCEEDED(hr))
    {
        RASENUMENTRYDETAILS* pDetails;

        // Assume we don't find the entry.
        //
        hr = HRESULT_FROM_WIN32 (ERROR_NOT_FOUND);

        for (DWORD i = 0; i < cRasEntryDetails; i++)
        {
            pDetails = &aRasEntryDetails[i];

            if (pDetails->guidId == guid)
            {
                // Only copy the string if the caller has enough room in
                // the output buffer.
                //
                hr = HRESULT_FROM_WIN32 (ERROR_INSUFFICIENT_BUFFER);
                DWORD cchRequired = wcslen(pDetails->szEntryName) + 1;
                if (cchRequired <= *pcchMax)
                {
                    lstrcpynW (pszwName, pDetails->szEntryName, *pcchMax);
                    hr = S_OK;
                }
                *pcchMax = cchRequired;

                break;
            }
        }

        MemFree (aRasEntryDetails);
    }
    else if (HRESULT_FROM_WIN32(ERROR_CANNOT_OPEN_PHONEBOOK) == hr)
    {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
    }
    TraceError ("HrRasConnectionNameFromGuid", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netman\conman\cmutil.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       C M U T I L . C P P
//
//  Contents:   Connection manager.
//
//  Notes:
//
//  Author:     omiller   1 Jun 2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "cmutil.h"
#include <objbase.h>
#include <ncmisc.h>

// Create an instance of CMUTIL so that we can be global
//
CCMUtil CCMUtil::s_instance; //ISSUE: Evil, evil, evil. This can throw and cause a crash.

CCMUtil::CCMUtil() throw(SE_Exception)
{
    InitializeCriticalSection( &m_CriticalSection );
}

CCMUtil::~CCMUtil() throw()
{
    DeleteCriticalSection( &m_CriticalSection );
}


//+---------------------------------------------------------------------------
//
//  Function:   GetIteratorFromGuid
//
//  Purpose:    Retrieve the guid, name and status of a Hidden connectiod
//
//              Connection Manager has two stages: Dialup and VPN.
//              For the Dialup it creates a hidden connectoid that the 
//              folder (netshell) does not see. However netman caches
//              the name, guid and status of this connectedoid. Both 
//              the parent and child connectoid have the same name. 
//
//  Arguments:
//      guid   [in]   GUID of the hidden connectiod to search for
//
//  Returns:    S_OK -- Found the hidden connectoid
//
//  Author:     omiller   1 Jun 2000
//
//  Notes:
//
CCMUtil::CMEntryTable::iterator CCMUtil::GetIteratorFromGuid(const GUID & guid)
{
    CMEntryTable::iterator iter;

    // Search through the list of hidden connections
    //
    for (iter = m_Table.begin(); iter != m_Table.end(); iter++)
    {
        if( iter->m_guid == guid )
        {
            // Found the hidden connection that maps to this guid
            //
            return iter;
        }
    }

    return NULL;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrGetEntry
//
//  Purpose:    Retrive the guid, name and status of a Hidden connectiod
//
//              Connection Manager has two stages: Dialup and VPN.
//              For the Dialup it creates a hidden connectoid that the 
//              folder (netshell) does not see. However netman caches
//              the name, guid and status of this connectedoid. Both 
//              the parent and child connectoid have the same name. 
//
//  Arguments:
//      guid   [in]   GUID of the hidden connectiod to search for
//      cm     [out]  A copy to the hidden entry
//
//  Returns:    TRUE -- Found the hidden connectoid
//
//  Author:     omiller   1 Jun 2000
//
//  Notes:
//
HRESULT CCMUtil::HrGetEntry(const GUID & guid, CMEntry & cm)
{
    CMEntryTable::iterator iter;
    HRESULT hr = S_FALSE;
    CExceptionSafeLock esCritSec(&m_CriticalSection);

    iter = GetIteratorFromGuid(guid);

    if( iter )
    {
        cm = *iter;
        hr = S_OK;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrGetEntry
//
//  Purpose:    Retrive the guid, name and status of a Hidden connectiod
//
//              Connection Manager has two stages: Dialup and VPN.
//              For the Dialup it creates a hidden connectoid that the 
//              folder (netshell) does not see. However netman caches
//              the name, guid and status of this connectedoid. Both 
//              the parent and child connectoid have the same name. 
//
//  Arguments:
//      szEntryName   [in]   Name of the connection to look for
//      cm            [out]  A copy to the hidden entry
//
//  Returns:    S_OK -- Found the hidden connectoid
//
//  Author:     omiller   1 Jun 2000
//
//  Notes:
//
HRESULT CCMUtil::HrGetEntry(const WCHAR * szEntryName, CMEntry & cm)
{
    CMEntryTable::iterator iter;
    CExceptionSafeLock esCritSec(&m_CriticalSection);

    for (iter = m_Table.begin(); iter != m_Table.end(); iter++)
    {
        if( lstrcmp(iter->m_szEntryName,szEntryName) == 0 )
        {
            // Found the Hidden connectoid that maps to that name
            //
            cm = *iter;
            return S_OK;
        }
    }

    return S_FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   SetEntry
//
//  Purpose:    Stores or Updates the guid, name and status of a Hidden connectiod
//
//              Connection Manager has two stages: Dialup and VPN.
//              For the Dialup it creates a hidden connectoid that the 
//              folder (netshell) does not see. However netman caches
//              the name, guid and status of this connectedoid. Both 
//              the parent and child connectoid have the same name. 
//
//  Arguments:
//      guid          [in]   Guid of the Hidden connectiod
//      szEntryName   [in]   Name of the Hidden connectiod
//      ncs           [in]   Status of the hidden connectiod
//
//  Returns:    nothing
//
//  Author:     omiller   1 Jun 2000
//
//  Notes:
//
void CCMUtil::SetEntry(const GUID & guid, const WCHAR * szEntryName, const NETCON_STATUS ncs) throw (std::bad_alloc)
{
    CMEntryTable::iterator iter;
    CExceptionSafeLock esCritSec(&m_CriticalSection);

    iter = GetIteratorFromGuid(guid);

    if( iter )
    {
        iter->Set(guid,szEntryName,ncs);
    }
    else
    {
        m_Table.push_back( CMEntry(guid,szEntryName,ncs) ); // can throw
    }

}

//+---------------------------------------------------------------------------
//
//  Function:   RemoveEntry
//
//  Purpose:    Removes a hidden connectiod from the list
//
//              Connection Manager has two stages: Dialup and VPN.
//              For the Dialup it creates a hidden connectoid that the 
//              folder (netshell) does not see. However netman caches
//              the name, guid and status of this connectedoid. Both 
//              the parent and child connectoid have the same name. 
//
//  Arguments:
//      guid          [in]   Guid of the Hidden connectiod
//
//  Returns:    S_OK -- Found the hidden connectoid
//
//  Author:     omiller   1 Jun 2000
//
//  Notes:
//
void CCMUtil::RemoveEntry(const GUID & guid) throw()
{
/*
    CMEntryTable::iterator iter;

    EnterCriticalSection(&m_CriticalSection);

    iter = GetIteratorFromGuid(guid);

    if( iter )
    {
        m_Table.erase(iter);
    }
    
    LeaveCriticalSection(&m_CriticalSection);
*/
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netman\conman\conman2.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       C O N M A N 2 . H
//
//  Contents:   Connection manager 2.
//
//  Notes:
//
//  Author:     ckotze   16 Mar 2001
//
//----------------------------------------------------------------------------

#pragma once
#include "nmbase.h"
#include "nmres.h"
#include "ncstl.h"
#include "list"

typedef list<NETCON_PROPERTIES_EX*> LISTNETCONPROPEX;
typedef LISTNETCONPROPEX::iterator ITERNETCONPROPEX;

class ATL_NO_VTABLE CConnectionManager2 :
public CComObjectRootEx <CComMultiThreadModel>,
public CComCoClass <CConnectionManager2, &CLSID_ConnectionManager2>,
public INetConnectionManager2
{
public:
    CConnectionManager2() throw() {};
    
    ~CConnectionManager2() throw() {};

    DECLARE_CLASSFACTORY_DEFERRED_SINGLETON(CConnectionManager2)
    DECLARE_REGISTRY_RESOURCEID(IDR_CONMAN2);

    BEGIN_COM_MAP(CConnectionManager2)
    COM_INTERFACE_ENTRY(INetConnectionManager2)
    END_COM_MAP()

    // INetConnectionManager2
    STDMETHOD (EnumConnectionProperties)(
        OUT SAFEARRAY** ppsaConnectionProperties);
	
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netman\conman\cobase.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       C O B A S E . C P P
//
//  Contents:   Connection Objects Shared code
//
//  Notes:
//
//  Author:     ckotze   16 Mar 2001
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "cobase.h"
#include "netconp.h"
#include "ncnetcon.h"

HRESULT HrSysAllocString(BSTR *bstrDestination, const OLECHAR* bstrSource)
{
    HRESULT hr = S_OK;
    if (bstrSource)
    {
        *bstrDestination = SysAllocString(bstrSource);
        if (!*bstrDestination)
        {
            return E_OUTOFMEMORY;
        }
    }
    else
    {
        *bstrDestination = SysAllocString(NULL);
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     HrBuildPropertiesExFromProperties
//
//  Purpose:    Converts a NETCON_PROPERTIES and IPersistNetConnection to a
//              NETCON_PROPERTIES_EX
//
//  Arguments:  pProps [in] The NETCON_PROPERTIES to convert from 
//              pPropsEx [out] The NETCON_PROPERTIES_EX to covert to. Caller allocated & free
//              pPersistNetConnection [in] The IPersistNetConnection used to build the NETCON_PROPERTIES_EX
//
//  Returns:    S_OK or an error code
//
HRESULT
HrBuildPropertiesExFromProperties(IN  const NETCON_PROPERTIES* pProps, 
                                  OUT NETCON_PROPERTIES_EX*    pPropsEx, 
                                  IN  IPersistNetConnection*   pPersistNetConnection)
{
    TraceFileFunc(ttidConman);

    HRESULT hr = S_OK;

    Assert(pProps);
    Assert(pPropsEx);

    BYTE* pbData;
    DWORD cbData;

    hr = pPersistNetConnection->GetSizeMax(&cbData);

    if (SUCCEEDED(hr))
    {
        hr = E_OUTOFMEMORY;
        pbData = new BYTE[cbData];
        if (pbData)
        {
            hr = pPersistNetConnection->Save (pbData, cbData);

            if (FAILED(hr))
            {
                delete [] pbData;
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        hr = E_OUTOFMEMORY;

        pPropsEx->bstrPersistData = NULL;
        pPropsEx->bstrName        = NULL;
        pPropsEx->bstrDeviceName  = NULL;

        if ( (pPropsEx->bstrPersistData = SysAllocStringByteLen(reinterpret_cast<LPSTR>(pbData), cbData)) &&
             (SUCCEEDED(HrSysAllocString(&(pPropsEx->bstrName),       pProps->pszwName))) && 
             (SUCCEEDED(HrSysAllocString(&(pPropsEx->bstrDeviceName), pProps->pszwDeviceName))) )
        {
            hr = S_OK;

            pPropsEx->guidId = pProps->guidId;
            pPropsEx->ncStatus = pProps->Status;
            pPropsEx->ncMediaType = pProps->MediaType;
            pPropsEx->dwCharacter = pProps->dwCharacter;
            pPropsEx->clsidThisObject = pProps->clsidThisObject;
            pPropsEx->clsidUiObject = pProps->clsidUiObject;
            pPropsEx->bstrPhoneOrHostAddress = SysAllocString(NULL);
        }
        else
        {
            SysFreeString(pPropsEx->bstrPersistData);
            SysFreeString(pPropsEx->bstrName);
            SysFreeString(pPropsEx->bstrDeviceName);
        }
        
        delete[] pbData;
    }

    TraceHr(ttidError, FAL, hr, FALSE, "HrBuildPropertiesExFromProperties");

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrGetPropertiesExFromINetConnection
//
//  Purpose:    Get the extended properties from INetConnection2, or get the 
//              properties and build the extended properties
//              
//
//  Arguments:
//      pPropsEx        [in]  The Properties to build from
//      ppsaProperties  [out] The PropertiesEx to build from. Free with CoTaskMemFree
//
//  Returns:    HRESULT
//
//  Author:     ckotze 05 Apr 2001
//
//  Notes:      Caller must free ppPropsEx with CoTaskMemFree
//              
//
HRESULT HrGetPropertiesExFromINetConnection(IN                INetConnection* pConn, 
                                            OUT TAKEOWNERSHIP NETCON_PROPERTIES_EX** ppPropsEx)
{
    TraceFileFunc(ttidConman);
    
    HRESULT hr = S_OK;
    CComPtr <INetConnection2> pConn2;
    
    Assert(ppPropsEx);
    
    *ppPropsEx = NULL;
    
    hr = pConn->QueryInterface(IID_INetConnection2, reinterpret_cast<LPVOID*>(&pConn2));
    if (SUCCEEDED(hr))
    {
        hr = pConn2->GetPropertiesEx(ppPropsEx);
    }
    else
    {
        NETCON_PROPERTIES_EX* pPropsEx = reinterpret_cast<NETCON_PROPERTIES_EX*>(CoTaskMemAlloc(sizeof(NETCON_PROPERTIES_EX)));   
        if (pPropsEx)
        {
            NETCON_PROPERTIES* pProps;
            
            ZeroMemory(pPropsEx, sizeof(NETCON_PROPERTIES_EX));
            
            hr = pConn->GetProperties(&pProps);
            if (SUCCEEDED(hr))
            {
                CComPtr<IPersistNetConnection> pPersistNet;
                
                hr = pConn->QueryInterface(IID_IPersistNetConnection, reinterpret_cast<LPVOID*>(&pPersistNet));
                if (SUCCEEDED(hr))
                {
                    hr = HrBuildPropertiesExFromProperties(pProps, pPropsEx, pPersistNet);
                    if (SUCCEEDED(hr))
                    {
                        *ppPropsEx = pPropsEx;
                    }
                    else
                    {
                        HrFreeNetConProperties2(pPropsEx);
                        pPropsEx = NULL;
                    }
                }
                FreeNetconProperties(pProps);
            }

            if (FAILED(hr) && (pPropsEx))
            {
                CoTaskMemFree(pPropsEx);
            }
        }
    }
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netman\conman\conman.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       C O N M A N . C P P
//
//  Contents:   Connection manager.
//
//  Notes:
//
//  Author:     shaunco   21 Sep 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include <dbt.h>
#include <ndisguid.h>
#include "conman.h"
// #include "dialup.h"
#include "enum.h"
#include "eventq.h"
#include "ncnetcon.h"
#include "ncreg.h"
#include "nminit.h"
#if DBG
#include "ncras.h"
#endif // DBG
#include <wmium.h>
#include "cmutil.h"
#include <shlwapi.h>
#include <shfolder.h>
#include "cobase.h"
#define SECURITY_WIN32
#include <security.h>
#include <wzcsvc.h>

#include "rasuip.h"
#include "cmdirect.h"

bool operator < (const GUID& rguid1, const GUID& rguid2) throw()
{
    return memcmp(&rguid1, &rguid2, sizeof(GUID)) < 0;
}

static const WCHAR c_szRegKeyClassManagers [] = L"System\\CurrentControlSet\\Control\\Network\\Connections";
static const WCHAR c_szRegValClassManagers [] = L"ClassManagers";

volatile CConnectionManager* CConnectionManager::g_pConMan = NULL;
volatile BOOL                CConnectionManager::g_fInUse  = FALSE;

bool operator == (const NETCON_PROPERTIES& rProps1, const NETCON_PROPERTIES& rProps2) throw()
{
    return (IsEqualGUID(rProps1.clsidThisObject, rProps2.clsidThisObject) &&
            IsEqualGUID(rProps1.clsidUiObject, rProps2.clsidUiObject) && 
            (rProps1.dwCharacter == rProps2.dwCharacter) &&
            IsEqualGUID(rProps1.guidId, rProps2.guidId) &&
            (rProps1.MediaType == rProps2.MediaType) &&
            (rProps1.pszwDeviceName == rProps2.pszwDeviceName) &&
            (rProps1.pszwName == rProps2.pszwName) &&
            (rProps1.Status == rProps2.Status));
}

const DWORD MAX_DISABLE_EVENT_TIMEOUT = 0xFFFF;

//static
BOOL
CConnectionManager::FHasActiveConnectionPoints () throw()
{
    TraceFileFunc(ttidConman);

    BOOL fRet = FALSE;

    // Note our intent to use g_pConMan.  We may find out that it is not
    // available for use, but setting g_fInUse to TRUE prevents FinalRelease
    // from allowing the object to be destroyed while we are using it.
    //
    g_fInUse = TRUE;

    // Save g_pConMan into a local variable since we have to test and use
    // it atomically.  If we tested g_pConMan directly and then used it
    // directly, it may have been set to NULL by FinalRelease in between
    // our test and use.  (Uh, which would be bad.)
    //
    // The const_cast is because g_pConMan is declared volatile.
    //
    CConnectionManager* pConMan = const_cast<CConnectionManager*>(g_pConMan);
    if (pConMan)
    {
        pConMan->Lock();

        IUnknown** ppUnk;
        for (ppUnk = pConMan->m_vec.begin();
             ppUnk < pConMan->m_vec.end();
             ppUnk++)
        {
            if (ppUnk && *ppUnk)
            {
                fRet = TRUE;
                break;
            }
        }

        pConMan->Unlock();
    }

    // Now that we are finished using the object, indicate so.  FinalRelease
    // may be waiting for this condition in which case the object will soon
    // be destroyed.
    //
    g_fInUse = FALSE;

    return fRet;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionManager::FinalRelease
//
//  Purpose:    COM destructor
//
//  Arguments:
//      (none)
//
//  Returns:    nothing
//
//  Author:     shaunco   21 Sep 1997
//
//  Notes:
//
VOID
CConnectionManager::FinalRelease ()
{
    TraceFileFunc(ttidConman);
    
    // Use INVALID_HANDLE_VALUE to block call until all outstanding event notifications have returned
    NTSTATUS Status = RtlDeregisterWaitEx(m_hRegNotifyWait, INVALID_HANDLE_VALUE);
    if (!NT_SUCCESS(Status))
    {
        TraceError("Could not deregister Registry Change Notification", HrFromLastWin32Error());
    }
    m_hRegNotifyWait = NULL;

    if (m_hRegClassManagerKey)
    {
        RegCloseKey(m_hRegClassManagerKey);
        m_hRegClassManagerKey = NULL;
    }

    if (m_hRegNotify)
    {
        CloseHandle(m_hRegNotify);
        m_hRegNotify = NULL;
    }

    // Unregister for PnP device events if we successfully registered for
    // them.
    //
    if (m_hDevNotify)
    {
        TraceTag (ttidConman, "Calling UnregisterDeviceNotification...");

        if (!UnregisterDeviceNotification (m_hDevNotify))
        {
            TraceHr (ttidError, FAL, HrFromLastWin32Error(), FALSE,
                "UnregisterDeviceNotification");
        }
    }

    (VOID) HrEnsureRegisteredOrDeregisteredWithWmi (FALSE);

    // Revoke the global connection manager pointer so that subsequent calls
    // to NotifyClientsOfEvent on other threads will do nothing.
    //
    g_pConMan = NULL;

    // Wait for g_fInUse to become FALSE.  NotifyClientsOfEvent will set
    // this to TRUE while it is using us.
    // Keep track of the number of times we sleep and trace it for
    // informational purposes.  If we see that we are waiting quite a few
    // number of times, increase the wait period.
    //
#ifdef ENABLETRACE
    if (g_fInUse)
    {
        TraceTag (ttidConman, "CConnectionManager::FinalRelease is waiting "
            "for NotifyClientsOfEvent to finish...");
    }
#endif

    ULONG cSleeps = 0;
    const DWORD nMilliseconds = 0;
    while (g_fInUse)
    {
        cSleeps++;
        Sleep (nMilliseconds);
    }

#ifdef ENABLETRACE
    if (cSleeps)
    {
        TraceTag (ttidConman, "CConnectionManager::FinalRelease slept %d "
            "times.  (%d ms each time.)",
            cSleeps, nMilliseconds);
    }
#endif

    // Release our class managers.
    //
    for (CLASSMANAGERMAP::iterator iter = m_mapClassManagers.begin(); iter != m_mapClassManagers.end(); iter++)
    {
        ReleaseObj (iter->second);
    }

    TraceTag (ttidConman, "Connection manager being destroyed");
}

inline
LPVOID OffsetToPointer(LPVOID pStart, DWORD dwNumBytes)
{
    DWORD_PTR dwPtr;

    dwPtr = reinterpret_cast<DWORD_PTR>(pStart);

    dwPtr += dwNumBytes;

    return reinterpret_cast<LPVOID>(dwPtr);
}

//+---------------------------------------------------------------------------
//
//  Member:     WmiEventCallback
//
//  Purpose:    Our WMI callback function that is called when WMI events are 
//              received. This is registered using 
//              CConnectionManager::HrEnsureRegisteredOrDeregisteredWithWmi
//
//  Arguments:
//              Wnone               [in]
//              NotificationContext [in]
//               
//  Returns:    nothing
//
//  Author:     ckotze    2001
//
//  Notes:      Must match type of NOTIFICATIONCALLBACK
//
VOID
WINAPI
WmiEventCallback (
    PWNODE_HEADER Wnode,
    UINT_PTR NotificationContext)
{
    TraceTag (ttidConman, "WmiEventCallback called...");
 
    TraceTag(ttidEvents, "Flags: %d", Wnode->Flags);
    
    if (WNODE_FLAG_SINGLE_INSTANCE == (WNODE_FLAG_SINGLE_INSTANCE & Wnode->Flags))
    {
        PWNODE_SINGLE_INSTANCE pInstance = reinterpret_cast<PWNODE_SINGLE_INSTANCE>(Wnode);
        LPCWSTR lpszDevice = NULL;
        LPWSTR lpszGuid;
        GUID guidAdapter;

        lpszDevice = reinterpret_cast<LPCWSTR>(OffsetToPointer(pInstance, pInstance->DataBlockOffset));

        lpszGuid = wcsrchr(lpszDevice, L'{');
        
        TraceTag(ttidEvents, "Adapter Guid From NDIS for Media Status Change Event: %S", lpszGuid);
        if (SUCCEEDED(CLSIDFromString(lpszGuid, &guidAdapter)))
        {
            CONMAN_EVENT* pEvent;

            pEvent = new CONMAN_EVENT;

            if(pEvent)
            {
                pEvent->ConnectionManager = CONMAN_LAN;
                pEvent->guidId = guidAdapter;
                pEvent->Type = CONNECTION_STATUS_CHANGE;
            
                if (IsEqualGUID(Wnode->Guid, GUID_NDIS_STATUS_MEDIA_CONNECT))
                {
                    pEvent->Status = NCS_CONNECTED;
                }
                else if (IsEqualGUID(Wnode->Guid, GUID_NDIS_STATUS_MEDIA_DISCONNECT))
                {
                    pEvent->Status = NCS_MEDIA_DISCONNECTED;
                }
                else
                {
                    AssertSz(FALSE, "We never registered for this event ... WMI may be having internal issues.");
                    MemFree(pEvent);
                    return;
                }
                if (!QueueUserWorkItemInThread(LanEventWorkItem, pEvent, EVENTMGR_CONMAN))
                {
                    FreeConmanEvent(pEvent);
                }
            }
        }
    }
    else
    {
        LanEventNotify (REFRESH_ALL, NULL, NULL, NULL);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionManager::HrEnsureRegisteredOrDeregisteredWithWmi
//
//  Purpose:    Register or deregister for NDIS Media Connect & Disconnect 
//              with WMI
//
//  Arguments:
//              fRegister [in] TRUE to register, FALSE to deregister
//
//  Returns:    nothing
//
//  Author:     ckotze    2001
//
//  Notes:
//
HRESULT
CConnectionManager::HrEnsureRegisteredOrDeregisteredWithWmi (
    IN  BOOL fRegister)
{
    TraceFileFunc(ttidConman);
        // Already registered or deregistered?
    //
    if (!!m_fRegisteredWithWmi == !!fRegister)
    {
        return S_OK;
    }

    m_fRegisteredWithWmi = !!fRegister;

    HRESULT     hr = S_OK;
    DWORD       dwErr;
    INT         i;
    const GUID* apguid [] =
    {
        &GUID_NDIS_STATUS_MEDIA_CONNECT,
        &GUID_NDIS_STATUS_MEDIA_DISCONNECT,
    };

    TraceTag (ttidConman,
        "Calling WmiNotificationRegistration to %s for NDIS media events...",
        (fRegister) ? "register" : "unregister");

    for (i = 0; i < celems(apguid); i++)
    {
        dwErr = WmiNotificationRegistration (
                    const_cast<GUID*>(apguid[i]),
                    !!fRegister,    // !! for BOOL to BOOLEAN
                    WmiEventCallback,
                    0,
                    NOTIFICATION_CALLBACK_DIRECT);

        hr = HRESULT_FROM_WIN32 (dwErr);
        TraceHr (ttidError, FAL, hr, FALSE, "WmiNotificationRegistration");
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrEnsureRegisteredOrDeregisteredWithWmi");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionManager::NotifyClientsOfEvent
//
//  Purpose:    Notify our connection points that this object has changed
//              state in some way and that a re-enumeration is needed.
//
//  Arguments:
//              pEvent [in] The event to dispatch to all the clients
//
//  Returns:    nothing
//
//  Author:     shaunco   20 Mar 1998
//
//  Notes:      This is a static function.  No this pointer is passed.
//
// static
VOID CConnectionManager::NotifyClientsOfEvent (
    IN  const CONMAN_EVENT* pEvent) throw()
{
    TraceFileFunc(ttidConman);

    HRESULT     hr;
    // Let's be sure we only do work if the service state is still running.
    // If we have a stop pending for example, we don't need to do anything.
    //
    if (SERVICE_RUNNING != _Module.DwServiceStatus ())
    {
        return;
    }

    // Note our intent to use g_pConMan.  We may find out that it is not
    // available for use, but setting g_fInUse to TRUE prevents FinalRelease
    // from allowing the object to be destroyed while we are using it.
    //
    g_fInUse = TRUE;

    // Save g_pConMan into a local variable since we have to test and use
    // it atomically.  If we tested g_pConMan directly and then used it
    // directly, it may have been set to NULL by FinalRelease in between
    // our test and use.  (Uh, which would be bad.)
    //
    // The const_cast is because g_pConMan is declared volatile.
    //
    CConnectionManager* pConMan = const_cast<CConnectionManager*>(g_pConMan);
    if (pConMan)
    {
        ULONG       cpUnk;
        IUnknown**  apUnk;

        hr = HrCopyIUnknownArrayWhileLocked (
                pConMan,
                &pConMan->m_vec,
                &cpUnk,
                &apUnk);

        if (SUCCEEDED(hr) && cpUnk && apUnk)
        {
#ifdef DBG
            CHAR szClientList[MAX_PATH];
            ZeroMemory(szClientList, MAX_PATH);
            LPSTR pszClientList = szClientList;

            ITERUSERNOTIFYMAP iter;
            for (iter = pConMan->m_mapNotify.begin(); iter != pConMan->m_mapNotify.end(); iter++)
            {
                pszClientList += sprintf(pszClientList, "%d ", iter->second->dwCookie);
                if (pszClientList > (szClientList + MAX_PATH-50) )
                {
                    break;
                }
            }

            if (iter != pConMan->m_mapNotify.end())
            {
                pszClientList += sprintf(pszClientList, "(more)");
            }

            TraceTag (ttidConman,
                "NotifyClientsOfEvent: Notifying %d clients. Cookies: %s)",
                cpUnk, szClientList);
#endif
            for (ULONG i = 0; i < cpUnk; i++)
            {
                INetConnectionNotifySink* pSink = NULL;
                BOOL                fFireEventOnSink = FALSE;

                hr = apUnk[i]->QueryInterface(IID_INetConnectionNotifySink, reinterpret_cast<LPVOID*>(&pSink));

                ReleaseObj(apUnk[i]);

                if (SUCCEEDED(hr))
                {
                    hr = CoSetProxyBlanket (
                        pSink,
                        RPC_C_AUTHN_WINNT,      // use NT default security
                        RPC_C_AUTHZ_NONE,       // use NT default authentication
                        NULL,                   // must be null if default
                        RPC_C_AUTHN_LEVEL_CALL, // call
                        RPC_C_IMP_LEVEL_IDENTIFY,
                        NULL,                   // use process token
                        EOAC_DEFAULT);

                    if (SUCCEEDED(hr))
                    {
                        switch (pEvent->Type)
                        {
                            case CONNECTION_ADDED:

                                Assert (pEvent);
                                Assert (pEvent->pPropsEx);
    
                                TraceTag(ttidEvents, "Characteristics: %s", DbgNccf(pEvent->pPropsEx->dwCharacter));

                                if (!(NCCF_ALL_USERS == (pEvent->pPropsEx->dwCharacter & NCCF_ALL_USERS)))
                                {
                                    const WCHAR* pchw = reinterpret_cast<const WCHAR*>(pEvent->pPropsEx->bstrPersistData);
                                    const WCHAR* pchwMax;
                                    PCWSTR       pszwPhonebook;
                                    WCHAR LeadWord = PersistDataLead;
                                    WCHAR TrailWord = PersistDataTrail;
                                    IUnknown* pUnkSink = NULL;
                            
                                    hr = pSink->QueryInterface(IID_IUnknown, reinterpret_cast<LPVOID*>(&pUnkSink));
                                    AssertSz(SUCCEEDED(hr), "Please explain how this happened...");
                                    if (SUCCEEDED(hr))
                                    {
                                        // The last valid pointer for the embedded strings.
                                        //
                                        pchwMax = reinterpret_cast<const WCHAR*>(pEvent->pbPersistData + pEvent->cbPersistData
                                            - (sizeof (GUID) +
                                            sizeof (BOOL) +
                                            sizeof (TrailWord)));
                            
                                        if (pchw && (LeadWord == *pchw))
                                        {
                                            TraceTag(ttidEvents, "Found Correct Lead Character.");
                                            // Skip past our lead byte.
                                            //
                                            pchw++;

                                            // Get PhoneBook path.  Search for the terminating null and make sure
                                            // we find it before the end of the buffer.  Using lstrlen to skip
                                            // the string can result in an an AV in the event the string is
                                            // not actually null-terminated.
                                            //
                                            for (pszwPhonebook = pchw; *pchw != L'\0' ; pchw++)
                                            {
                                                if (pchw >= pchwMax)
                                                {
                                                    pszwPhonebook = NULL;
                                                    break;
                                                }
                                            }

                                            TraceTag(ttidEvents, "Found Valid Phonebook: %S", (pszwPhonebook) ? L"TRUE" : L"FALSE");

                                            if (pszwPhonebook)
                                            {
                                                pConMan->Lock();

                                                ITERUSERNOTIFYMAP iter = pConMan->m_mapNotify.find(pUnkSink);
                                                if (iter != pConMan->m_mapNotify.end())
                                                {
                                                    tstring& strUserDataPath = iter->second->szUserProfilesPath;
                                                    TraceTag(ttidEvents, "Comparing stored Path: %S to Phonebook Path: %S", 
                                                             strUserDataPath.c_str(), pszwPhonebook);
                                                    if (_wcsnicmp(pszwPhonebook, strUserDataPath.c_str(), strUserDataPath.length()) == 0)
                                                    {
                                                        fFireEventOnSink = TRUE;
                                                    }
                                                }
                                                else
                                                {
                                                    TraceTag(ttidError, "Could not find Path for NotifySink: 0x%08x", pUnkSink);
                                                }

                                                pConMan->Unlock();
                                            }
                                        }
                                        else
                                        {
                                            // Some other devices do not use this Format, but need to be sent events.
                                            fFireEventOnSink = TRUE;
                                        }

                                        ReleaseObj(pUnkSink);
                                    }
                                }
                                else
                                {
                                    TraceTag(ttidEvents, "All User Connection");
                                    fFireEventOnSink = TRUE;
                                }

                                if (fFireEventOnSink)
                                {
                                    TraceTag (ttidEvents,
                                        "Notifying ConnectionAdded... (pSink=0x%p)",
                                        pSink);

                                    hr = pSink->ConnectionAdded (
                                            pEvent->pPropsEx);
                                }

                                break;

                            case CONNECTION_BANDWIDTH_CHANGE:
                                TraceTag (ttidEvents,
                                    "Notifying ConnectionBandWidthChange... (pSink=0x%p)",
                                    pSink);

                                hr = pSink->ConnectionBandWidthChange (&pEvent->guidId);
                                break;

                            case CONNECTION_DELETED:
                                TraceTag (ttidEvents,
                                    "Notifying ConnectionDeleted... (pSink=0x%p)",
                                    pSink);

                                hr = pSink->ConnectionDeleted (&pEvent->guidId);
                                break;

                            case CONNECTION_MODIFIED:
                                Assert (pEvent->pPropsEx);

                                TraceTag (ttidEvents,
                                    "Notifying ConnectionModified... (pSink=0x%p)",
                                    pSink);

                                hr = pSink->ConnectionModified (pEvent->pPropsEx);
            
                                break;

                            case CONNECTION_RENAMED:
                                TraceTag (ttidEvents,
                                    "Notifying ConnectionRenamed... (pSink=0x%p)",
                                    pSink);

                                hr = pSink->ConnectionRenamed (&pEvent->guidId,
                                        pEvent->szNewName);
                            break;
                        
                            case CONNECTION_STATUS_CHANGE:
                                TraceTag (ttidEvents,
                                    "Notifying ConnectionStatusChange... (pSink=0x%p)",
                                    pSink);

                                TraceTag(ttidEvents, "Status changed to: %s", DbgNcs(pEvent->Status));

                                hr = pSink->ConnectionStatusChange (&pEvent->guidId,
                                            pEvent->Status);
                                break;

                            case REFRESH_ALL:
                                TraceTag (ttidEvents,
                                    "Notifying RefreshAll... (pSink=0x%p)",
                                    pSink);

                                hr = pSink->RefreshAll ();
                                break;

                            case CONNECTION_ADDRESS_CHANGE:
                                 TraceTag (ttidEvents,
                                    "Notifying ConnectionAddressChange... (pSink=0x%p)",
                                    pSink);

                                 hr = pSink->ConnectionAddressChange(&pEvent->guidId);
                                 break;

                            case CONNECTION_BALLOON_POPUP:
                                TraceTag (ttidEvents,
                                    "Notifying ConnectionStatusChange... (pSink=0x%p)",
                                    pSink);

                                hr = pSink->ShowBalloon(&pEvent->guidId, pEvent->szCookie, pEvent->szBalloonText);
                                break;

                            case DISABLE_EVENTS:
                                TraceTag (ttidEvents,
                                    "Notifying DisableEvents... (pSink=0x%p)",
                                    pSink);

                                hr = pSink->DisableEvents(pEvent->fDisable, pEvent->ulDisableTimeout);
                                break;

                            default:
                                TraceTag(ttidEvents, "Event Type Passed: %d", pEvent->Type);
                                AssertSz (FALSE, "Invalid Type specified in pEvent");
                                break;
                        }
                        TraceErrorOptional("pSink call failed: ", hr, (S_FALSE == hr) );

                        if ( (HRESULT_FROM_WIN32(RPC_S_SERVER_UNAVAILABLE) == hr)  ||
                             (HRESULT_FROM_WIN32(RPC_S_CALL_FAILED_DNE) == hr)  ||
                             (RPC_E_SERVER_DIED  == hr) ||
                             (RPC_E_DISCONNECTED == hr) ||
                             (HRESULT_FROM_WIN32(RPC_S_CALL_FAILED) == hr) )
                        {
                            IUnknown* pUnkSink = NULL;
                            HRESULT hrT = pSink->QueryInterface(IID_IUnknown, reinterpret_cast<LPVOID*>(&pUnkSink));
                            if (SUCCEEDED(hrT))
                            {
                                ITERUSERNOTIFYMAP iter = pConMan->m_mapNotify.find(pUnkSink);
                                if (iter != pConMan->m_mapNotify.end())
                                {
                                    TraceTag(ttidError, "Dead client detected. Removing notify advise for: %S", iter->second->szUserName.c_str());

                                    hrT = pConMan->Unadvise(iter->second->dwCookie);
                                }
                                ReleaseObj(pUnkSink);
                            }
                            TraceHr (ttidError, FAL, hrT, S_FALSE == hrT, "Error removing notify advise.");
                        }
                    }
                    else
                    {
                        TraceHr (ttidError, FAL, hr, FALSE,
                                 "CConnectionManager::NotifyClientsOfEvent: "
                                 "CoSetProxyBlanket failed for event %d.",
                                 pEvent->Type);
                    }

                    ReleaseObj(pSink);
                }
            }
            MemFree (apUnk);
        }
    }


    // Now that we are finished using the object, indicate so.  FinalRelease
    // may be waiting for this condition in which case the object will soon
    // be destroyed.
    //

    g_fInUse = FALSE;

}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionManager::HrEnsureClassManagersLoaded
//
//  Purpose:    Loads the class managers if they have not been loaded yet.
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   10 Dec 1997
//
//  Notes:
//
HRESULT
CConnectionManager::HrEnsureClassManagersLoaded ()
{
    TraceFileFunc(ttidConman);

    HRESULT hr = S_OK;

    // Need to protect m_mapClassManagers for the case that two clients
    // get our object simultaneously and call a method which invokes
    // this method.  Need to transition m_mapClassManagers from being
    // empty to being full in one atomic operation.
    //
    CExceptionSafeComObjectLock EsLock (this);

    // If our vector of class managers is emtpy, try to load them.
    // This will certainly be the case if we haven't tried to load them yet.
    // If will also be the case when no class managers are registered.
    // This isn't likely because we register them in hivesys.inf, but it
    // shouldn't hurt to keep trying if they're really are none registered.
    //
    if (m_mapClassManagers.empty())
    {
        TraceTag (ttidConman, "Loading class managers...");

        // Load the registered class managers.
        //
        // Open the registry key where the class managers are registered.
        //
        HKEY hkey;
        hr = HrRegOpenKeyEx (HKEY_LOCAL_MACHINE,
                        c_szRegKeyClassManagers, KEY_READ, &hkey);
        if (SUCCEEDED(hr))
        {
            // Read the multi-sz of class manager CLSIDs.
            //
            PWSTR pmsz;
            hr = HrRegQueryMultiSzWithAlloc (hkey, c_szRegValClassManagers,
                    &pmsz);
            if (S_OK == hr)
            {
                (VOID) HrNmWaitForClassObjectsToBeRegistered ();

                // For each CLSID, create the object and request its
                // INetConnectionManager interface.
                //
                for (PCWSTR pszClsid = pmsz;
                     *pszClsid;
                     pszClsid += wcslen (pszClsid) + 1)
                {
                    // Convert the string to a CLSID.  If it fails, skip it.
                    //
                    CLSID clsid;
                    if (FAILED(CLSIDFromString ((LPOLESTR)pszClsid, &clsid)))
                    {
                        TraceTag (ttidConman, "Skipping bogus CLSID (%S)",
                            pszClsid);
                        continue;
                    }

                    // Create the class manager and add it to our list.
                    //
                    INetConnectionManager* pConMan;

                    hr = CoCreateInstance (
                            clsid, NULL,
                            CLSCTX_ALL | CLSCTX_NO_CODE_DOWNLOAD,
                            IID_INetConnectionManager,
                            reinterpret_cast<VOID**>(&pConMan));

                    TraceHr (ttidError, FAL, hr, FALSE,
                        "CConnectionManager::HrEnsureClassManagersLoaded: "
                        "CoCreateInstance failed for class manager %S.",
                        pszClsid);

                    if (SUCCEEDED(hr))
                    {
                        TraceTag (ttidConman, "Loaded class manager %S",
                            pszClsid);

                        Assert (pConMan);
                        
                        if (m_mapClassManagers.find(clsid) != m_mapClassManagers.end())
                        {
                            AssertSz(FALSE, "Attempting to insert the same class manager twice!");
                        }
                        else
                        {
                            m_mapClassManagers[clsid] = pConMan;
                        }
                    }

/*
// If CoCreateInstance starts failing again on retail builds, this can
// be helpful.
                    else
                    {
                        CHAR psznBuf [512];
                        wsprintfA (psznBuf, "NETCFG: CoCreateInstance failed "
                            "(0x%08x) on class manager %i.\n",
                            hr, m_mapClassManagers.size ());
                        OutputDebugStringA (psznBuf);
                    }
*/
                }

                MemFree (pmsz);
            }

            RegCloseKey (hkey);
        }

        TraceTag (ttidConman, "Loaded %i class managers",
            m_mapClassManagers.size ());
    }

    TraceErrorOptional ("CConnectionManager::HrEnsureClassManagersLoaded", hr, (S_FALSE == hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionManager::RegChangeNotifyHandler
//
//  Purpose:    Notification of a change inside the Registry where the
//              class managers clsid's are being stored. This updates the
//              class manager context with the new clsid's and send out a refresh
//              to all the clients.
//
//  Arguments:
//              pContext [in,out] CConnectionManager context to update
//              fTimerFired [in]  TRUE if this was as a result of a timeout
//
//  Returns:    VOID
//
//  Author:     deonb   Feb 2002
//
//  Notes:      The pContext connection manager will be updated by the new
//              class manager in the registry, or the one just removed.
//
VOID NTAPI CConnectionManager::RegChangeNotifyHandler(IN OUT LPVOID pContext, IN BOOLEAN fTimerFired) throw()
{
    TraceFileFunc(ttidConman);

    TraceTag(ttidConman, "CConnectionManager::RegChangeNotifyHandler (%d)", fTimerFired);

    CConnectionManager *pThis = reinterpret_cast<CConnectionManager *>(pContext);
    CExceptionSafeComObjectLock EsLock (pThis);
 
    list<GUID> lstRegisteredGuids;

    HKEY hkey;
    HRESULT hr = HrRegOpenKeyEx (HKEY_LOCAL_MACHINE, c_szRegKeyClassManagers, KEY_READ, &hkey);
    if (SUCCEEDED(hr))
    {
        // Read the multi-sz of class manager CLSIDs.
        //
        PWSTR pmsz;
        hr = HrRegQueryMultiSzWithAlloc (hkey, c_szRegValClassManagers,
                &pmsz);
        if (S_OK == hr)
        {
            for (PCWSTR pszClsid = pmsz;
                 *pszClsid;
                 pszClsid += wcslen (pszClsid) + 1)
            {
                CLSID clsid;
                if (FAILED(CLSIDFromString ((LPOLESTR)pszClsid, &clsid)))
                {
                    TraceTag (ttidConman, "Skipping bogus CLSID (%S)", pszClsid);
                    continue;
                }
                lstRegisteredGuids.push_back(clsid);
            }
        }
        RegCloseKey(hkey);

        
        BOOL bFound;
        do 
        {
            bFound = FALSE;

            CLASSMANAGERMAP::iterator iterClassMgr;

            for (iterClassMgr = pThis->m_mapClassManagers.begin();  iterClassMgr != pThis->m_mapClassManagers.end(); iterClassMgr++)
            {
                if (find(lstRegisteredGuids.begin(), lstRegisteredGuids.end(), iterClassMgr->first) == lstRegisteredGuids.end())
                {
                    // Class manager key has been removed
                    TraceTag(ttidConman, "Removing class manager");
                    bFound = TRUE;
                    break;
                }
            }

            if (bFound)
            {
                ULONG uRefCount = iterClassMgr->second->Release();
                TraceTag(ttidConman, "Releasing class manager - Refcount = %d", uRefCount);
                pThis->m_mapClassManagers.erase(iterClassMgr);
            }
        } while (bFound);

        for (list<GUID>::iterator iter = lstRegisteredGuids.begin(); iter != lstRegisteredGuids.end(); iter++)
        {
            if (pThis->m_mapClassManagers.find(*iter) == pThis->m_mapClassManagers.end())
            {
                // Class manager key has been added
                TraceTag(ttidConman, "Adding class manager");
                
                INetConnectionManager* pConMan;
                hr = CoCreateInstance (
                        *iter, 
                        NULL,
                        CLSCTX_ALL | CLSCTX_NO_CODE_DOWNLOAD,
                        IID_INetConnectionManager,
                        reinterpret_cast<VOID**>(&pConMan));

                TraceHr (ttidError, FAL, hr, FALSE,
                    "CConnectionManager::RegChangeNotifyHandler: CoCreateInstance failed for class manager.");

                if (SUCCEEDED(hr))
                {
                    TraceTag (ttidConman, "Loaded class manager");
                    Assert (pConMan);
                     
                    if (pThis->m_mapClassManagers.find(*iter) != pThis->m_mapClassManagers.end())
                    {
                        AssertSz(FALSE, "Attempting to insert the same class manager twice!");
                    }
                    else
                    {
                        pThis->m_mapClassManagers[*iter] = pConMan;
                    }
                }
            }
        }
    }
    else
    {
        TraceError("Could not open registry key", HrFromLastWin32Error());
    }

    TraceError("RegChangeNotifyHandler", hr);

    // Update all the connection folder instances.
    LanEventNotify (REFRESH_ALL, NULL, NULL, NULL);
    
    // Reset the change notification
    RegNotifyChangeKeyValue(pThis->m_hRegClassManagerKey, FALSE, REG_NOTIFY_CHANGE_LAST_SET, pThis->m_hRegNotify, TRUE);
}

//+---------------------------------------------------------------------------
// INetConnectionManager
//

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionManager::EnumConnections
//
//  Purpose:    Return an INetConnection enumerator.
//
//  Arguments:
//      Flags        [in]   Unused currently
//      ppEnum       [out]  The enumerator.
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   21 Sep 1997
//
//  Notes:
//
STDMETHODIMP
CConnectionManager::EnumConnections (
        IN  NETCONMGR_ENUM_FLAGS    Flags,
        OUT IEnumNetConnection**    ppEnum)
{
    TraceFileFunc(ttidConman);
    TraceTag(ttidConman, "CConnectionManager::EnumConnections (%d)", Flags);

    HRESULT hr = S_OK;
    {
        CExceptionSafeComObjectLock EsLock (this);

        Assert(FImplies(m_hRegNotify, m_hRegClassManagerKey));
        if (!m_hRegNotify)
        {
            m_hRegNotify = CreateEvent(NULL, FALSE, FALSE, NULL);
            if (m_hRegNotify)
            {
                NTSTATUS Status = RtlRegisterWait(&m_hRegNotifyWait, m_hRegNotify, &CConnectionManager::RegChangeNotifyHandler, this, INFINITE, WT_EXECUTEDEFAULT);
                if (!NT_SUCCESS(Status))
                {
                    hr = HRESULT_FROM_NT(Status);
                }
                else
                {
                    hr = HrRegOpenKeyEx (HKEY_LOCAL_MACHINE, c_szRegKeyClassManagers, KEY_READ, &m_hRegClassManagerKey);
                    if (SUCCEEDED(hr))
                    {
                        hr = RegNotifyChangeKeyValue(m_hRegClassManagerKey, FALSE, REG_NOTIFY_CHANGE_LAST_SET, m_hRegNotify, TRUE);
                        if (FAILED(hr))
                        {
                            RegCloseKey(m_hRegClassManagerKey);
                            m_hRegClassManagerKey = NULL;
                        }
                    }

                    if (FAILED(hr))
                    {
                        // Use INVALID_HANDLE_VALUE to block call until all outstanding event notifications have returned
                        Status = RtlDeregisterWaitEx(m_hRegNotifyWait, INVALID_HANDLE_VALUE);
                        if (!NT_SUCCESS(Status))
                        {
                            hr = HRESULT_FROM_NT(Status);
                        }
                        m_hRegNotifyWait = NULL;
                    }
                }

                if (FAILED(hr))
                {
                    CloseHandle(m_hRegNotify);
                    m_hRegNotify = NULL;
                }
            }
            else
            {
                hr = HrFromLastWin32Error();
            }
        }

        if (SUCCEEDED(hr))
        {
            // Create and return the enumerator.
            //
            hr = HrEnsureClassManagersLoaded ();
        }

        if (SUCCEEDED(hr))
        {
            hr = CConnectionManagerEnumConnection::CreateInstance (
                        Flags,
                        m_mapClassManagers,
                        IID_IEnumNetConnection,
                        reinterpret_cast<VOID**>(ppEnum));
        }
    }

    TraceErrorOptional ("CConnectionManager::EnumConnections", hr, (S_FALSE == hr));
    return hr;
}

//+---------------------------------------------------------------------------
// INetConnectionRefresh
//
STDMETHODIMP
CConnectionManager::RefreshAll()
{
    TraceFileFunc(ttidConman);

    LanEventNotify (REFRESH_ALL, NULL, NULL, NULL);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   CConnectionManager::ConnectionAdded
//
//  Purpose:    Notifies event sinks that a new connection has been added.
//
//  Arguments:
//      pConnection [in]  INetConnection* for new connection.
//
//  Returns:    Standard HRESULT
//
//  Author:     deonb   22 Mar 2001
//
//  Notes:
//
STDMETHODIMP 
CConnectionManager::ConnectionAdded(
    IN INetConnection* pConnection)
{
    TraceFileFunc(ttidConman);

    HRESULT hr = S_OK;
    CONMAN_EVENT* pEvent = new CONMAN_EVENT;
    
    if (pEvent)
    {
        ZeroMemory(pEvent, sizeof(CONMAN_EVENT));
        pEvent->Type = CONNECTION_ADDED;
        
        hr = HrGetPropertiesExFromINetConnection(pConnection, &pEvent->pPropsEx);
        if (SUCCEEDED(hr))
        {
            if (QueueUserWorkItemInThread(ConmanEventWorkItem, pEvent, EVENTMGR_CONMAN))
            {
                return hr;
            }
            hr = E_FAIL;
        }
        FreeConmanEvent(pEvent);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CConnectionManager::ConnectionDeleted
//
//  Purpose:    Sends an event to notify of a connection being deleted.
//
//  Arguments:
//      pguidId   [in] GUID of the  connectoid
//
//  Returns:    Standard HRESULT
//
//  Author:     ckotze   18 Apr 2001
//
//  Notes:
//
STDMETHODIMP 
CConnectionManager::ConnectionDeleted(
    IN const GUID* pguidId)
{
    TraceFileFunc(ttidConman);

    HRESULT hr = S_OK;
    
    CONMAN_EVENT* pEvent = new CONMAN_EVENT;
    
    if (pEvent)
    {
        ZeroMemory(pEvent, sizeof(CONMAN_EVENT));
        pEvent->Type = CONNECTION_DELETED;
        pEvent->guidId = *pguidId;
        
        if (!QueueUserWorkItemInThread(ConmanEventWorkItem, pEvent, EVENTMGR_CONMAN))
        {
            hr = E_FAIL;
            FreeConmanEvent(pEvent);
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   CConnectionManager::ConnectionRenamed
//
//  Purpose:    Notifies the event sinks of a connection being renamed.
//
//  Arguments:
//      pConnection [in]  INetConnection* for new connection.
//
//  Returns:    Standard HRESULT
//
//  Author:     ckotze   19 Apr 2001
//
//  Notes:
//
STDMETHODIMP 
CConnectionManager::ConnectionRenamed(
    IN INetConnection* pConnection)
{
    TraceFileFunc(ttidConman);

    HRESULT hr = S_OK;
    CONMAN_EVENT* pEvent = new CONMAN_EVENT;
    
    if (pEvent)
    {
        ZeroMemory(pEvent, sizeof(CONMAN_EVENT));
        pEvent->Type = CONNECTION_RENAMED;
        
        hr = HrGetPropertiesExFromINetConnection(pConnection, &pEvent->pPropsEx);
        if (SUCCEEDED(hr))
        {
            lstrcpynW (pEvent->szNewName, pEvent->pPropsEx->bstrName, celems(pEvent->szNewName) );
            pEvent->guidId = pEvent->pPropsEx->guidId;

            if (QueueUserWorkItemInThread(ConmanEventWorkItem, pEvent, EVENTMGR_CONMAN))
            {
                return hr;
            }
            hr = E_FAIL;
        }
        FreeConmanEvent(pEvent);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CConnectionManager::ConnectionModified
//
//  Purpose:    Sends an event to notify clients that the connection has been
//              Modified.
//  Arguments:
//      pConnection [in]  INetConnection* for new connection.
//
//  Returns:    Standard HRESULT
//
//  Author:     ckotze   22 Mar 2001
//
//  Notes:
//
STDMETHODIMP
CConnectionManager::ConnectionModified(INetConnection* pConnection)
{
    TraceFileFunc(ttidConman);

    HRESULT hr = S_OK;
    CONMAN_EVENT* pEvent = new CONMAN_EVENT;
    
    if (pEvent)
    {
        ZeroMemory(pEvent, sizeof(CONMAN_EVENT));
        pEvent->Type = CONNECTION_MODIFIED;
        
        hr = HrGetPropertiesExFromINetConnection(pConnection, &pEvent->pPropsEx);
        if (SUCCEEDED(hr))
        {
            if (QueueUserWorkItemInThread(ConmanEventWorkItem, pEvent, EVENTMGR_CONMAN))
            {
                return hr;
            }
            hr = E_FAIL;
        }
        FreeConmanEvent(pEvent);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CConnectionManager::ConnectionStatusChanged
//
//  Purpose:    Sends the ShowBalloon event to each applicable netshell
//
//  Arguments:
//      pguidId   [in] GUID of the  connectoid
//      ncs       [in] New status of the connectoid
//
//  Returns:    Standard HRESULT
//
//  Author:     deonb   22 Mar 2001
//
//  Notes:
//
STDMETHODIMP 
CConnectionManager::ConnectionStatusChanged(
                     IN const GUID* pguidId, 
                     IN const NETCON_STATUS  ncs)
{
    TraceFileFunc(ttidConman);

    HRESULT hr = S_OK;

    CONMAN_EVENT* pEvent = new CONMAN_EVENT;
    
    if (pEvent)
    {
        ZeroMemory(pEvent, sizeof(CONMAN_EVENT));
        pEvent->Type = CONNECTION_STATUS_CHANGE;
        pEvent->guidId = *pguidId;
        pEvent->Status = ncs;
    
        if (!QueueUserWorkItemInThread(ConmanEventWorkItem, pEvent, EVENTMGR_CONMAN))
        {
            FreeConmanEvent(pEvent);
            hr = E_FAIL;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
            
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CConnectionManager::ShowBalloon
//
//  Purpose:    Sends the ShowBalloon event to each applicable netshell
//
//  Arguments:
//      pguidId       [in] GUID of the  connectoid
//      szCookie      [in] A specified cookie that will end up at netshell
//      szBalloonText [in] The balloon text
//
//  Returns:    Standard HRESULT
//
//  Author:     deonb   22 Mar 2001
//
//  Notes:
//
STDMETHODIMP 
CConnectionManager::ShowBalloon(
                     IN const GUID *pguidId, 
                     IN const BSTR szCookie, 
                     IN const BSTR szBalloonText)
{
    TraceFileFunc(ttidConman);

    HRESULT hr = S_OK;
    
    CONMAN_EVENT* pEvent = new CONMAN_EVENT;
    
    if (pEvent)
    {
        ZeroMemory(pEvent, sizeof(CONMAN_EVENT));
        pEvent->Type = CONNECTION_BALLOON_POPUP;
        pEvent->guidId        = *pguidId;
        pEvent->szCookie      = SysAllocStringByteLen(reinterpret_cast<LPCSTR>(szCookie), SysStringByteLen(szCookie));
        pEvent->szBalloonText = SysAllocString(szBalloonText);
        
        if (!QueueUserWorkItemInThread(ConmanEventWorkItem, pEvent, EVENTMGR_CONMAN))
        {
            hr = E_FAIL;
            FreeConmanEvent(pEvent);
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CConnectionManager::DisableEvents
//
//  Purpose:    Disable netshell processing of events for x milliseconds
//
//  Arguments:
//      fDisable         [in] TRUE to disable EVENT processing, FALSE to renable
//      ulDisableTimeout [in] Number of milliseconds to disable event processing for
//
//  Returns:    Standard HRESULT
//
//  Author:     deonb   10 April 2001
//
//  Notes:
//
STDMETHODIMP CConnectionManager::DisableEvents(IN const BOOL fDisable, IN const ULONG ulDisableTimeout)
{
    TraceFileFunc(ttidConman);

    HRESULT hr = S_OK;
    
    if (ulDisableTimeout > MAX_DISABLE_EVENT_TIMEOUT)
    {
        return E_INVALIDARG;
    }

    CONMAN_EVENT* pEvent = new CONMAN_EVENT;
    
    if (pEvent)
    {
        ZeroMemory(pEvent, sizeof(CONMAN_EVENT));
        pEvent->Type = DISABLE_EVENTS;
        pEvent->fDisable         = fDisable;
        // We set the high bit to let netshell know that this is coming from our private interface.
        pEvent->ulDisableTimeout = 0x80000000 | ulDisableTimeout;
       
        if (!QueueUserWorkItemInThread(ConmanEventWorkItem, pEvent, EVENTMGR_CONMAN))
        {
            hr = E_FAIL;
            FreeConmanEvent(pEvent);
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CConnectionManager::RefreshConnections
//
//  Purpose:    Refreshes the connections in the connections folder
//
//  Arguments:
//      None.
//      
//
//  Returns:    Standard HRESULT
//
//  Author:     ckotze   19 April 2001
//
//  Notes:      This is a public interface that we are providing in order to 
//              allow other components/companies to have some control over
//              the Connections Folder.
STDMETHODIMP CConnectionManager::RefreshConnections()
{
    TraceFileFunc(ttidConman);

    HRESULT hr = S_OK;
    CONMAN_EVENT* pEvent = new CONMAN_EVENT;
    
    if (pEvent)
    {
        ZeroMemory(pEvent, sizeof(CONMAN_EVENT));
        pEvent->Type = REFRESH_ALL;
        
        if (!QueueUserWorkItemInThread(ConmanEventWorkItem, pEvent, EVENTMGR_CONMAN))
        {
            hr = E_FAIL;
            FreeConmanEvent(pEvent);
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CConnectionManager::Enable
//
//  Purpose:    Enables events to be fired once more in the connections folder
//
//  Arguments:
//      None.
//
//  Returns:    Standard HRESULT
//
//  Author:     ckotze   19 April 2001
//
//  Notes:      This is a public interface that we are providing in order to 
//              allow other components/companies to have some control over
//              the Connections Folder.
//              Since this is a public interface, we are only allowing the
//              INVALID_ADDRESS notification to be disabled
//              (this will take place in netshell.dll).
//
STDMETHODIMP CConnectionManager::Enable()
{
    TraceFileFunc(ttidConman);

    HRESULT hr = S_OK;
    CONMAN_EVENT* pEvent = new CONMAN_EVENT;
    
    if (pEvent)
    {
        ZeroMemory(pEvent, sizeof(CONMAN_EVENT));
        pEvent->Type = DISABLE_EVENTS;
        pEvent->fDisable = FALSE;
        
        if (!QueueUserWorkItemInThread(ConmanEventWorkItem, pEvent, EVENTMGR_CONMAN))
        {
            hr = E_FAIL;
            FreeConmanEvent(pEvent);
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CConnectionManager::Disable
//
//  Purpose:    Disable netshell processing of events for x milliseconds
//
//  Arguments:
//      ulDisableTimeout [in] Number of milliseconds to disable event 
//                            processing for.  Max is 60000 (1 minute)
//
//  Returns:    Standard HRESULT
//
//  Author:     ckotze   19 April 2001
//
//  Notes:      This is a public interface that we are providing in order to 
//              allow other components/companies to have some control over
//              the Connections Folder.
//              Since this is a public interface, we are only allowing the
//              INVALID_ADDRESS notification to be disabled
//              (this will take place in netshell.dll).
//
STDMETHODIMP CConnectionManager::Disable(IN const ULONG ulDisableTimeout)
{
    TraceFileFunc(ttidConman);

    HRESULT hr = S_OK;
    
    if (ulDisableTimeout > MAX_DISABLE_EVENT_TIMEOUT)
    {
        return E_INVALIDARG;
    }
    
    CONMAN_EVENT* pEvent = new CONMAN_EVENT;
    
    if (pEvent)
    {
        ZeroMemory(pEvent, sizeof(CONMAN_EVENT));
        pEvent->Type             = DISABLE_EVENTS;
        pEvent->fDisable         = TRUE;
        pEvent->ulDisableTimeout = ulDisableTimeout;
        
        if (!QueueUserWorkItemInThread(ConmanEventWorkItem, pEvent, EVENTMGR_CONMAN))
        {
            hr = E_FAIL;
            FreeConmanEvent(pEvent);
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    
    return hr;
}

//+---------------------------------------------------------------------------
// INetConnectionCMUtil
//
//+---------------------------------------------------------------------------
//
//  Function:   MapCMHiddenConnectionToOwner
//
//  Purpose:    Maps a child connection to its parent connection.
//
//              Connection Manager has two stages: Dialup and VPN.
//              For the Dialup it creates a hidden connectoid that the 
//              folder (netshell) does not see. However netman caches
//              the name, guid and status of this connectedoid. Both 
//              the parent and child connectoid have the same name. When 
//              the status of the hidden connectiod is updated the folder 
//              recives the guid of the hidden connectoid and maps the 
//              connectiod to it parent (Connection Manager) by searching 
//              netmans cache for the name of the hidden connectoid. Then it
//              searches the connections in the folder for that name and thus
//              gets the guid of the parent connectoid.     
//
//              When the folder gets a notify message from netman for the hidden 
//              connection it uses this function to find the parent and update the 
//              parent's status. The hidden connection is not displayed.
//
//  Arguments:
//      guidHidden   [in]   GUID of the hidden connectiod
//      pguidOwner   [out]  GUID of the parent connectiod
//
//  Returns:    S_OK -- Found hidden connection
//              else not found 
//
//  Author:     omiller   1 Jun 2000
//
//  Notes:
//
STDMETHODIMP 
CConnectionManager::MapCMHiddenConnectionToOwner (
    /*[in]*/  REFGUID guidHidden,
    /*[out]*/ GUID * pguidOwner)
{
    TraceFileFunc(ttidConman);

    HRESULT hr = S_OK;
    bool bFound = false;

    hr = HrEnsureClassManagersLoaded ();
    if (SUCCEEDED(hr))
    {
        // Impersonate the user so that we see all of the connections displayed in the folder
        //
        hr = CoImpersonateClient();
        if (SUCCEEDED(hr))
        {
    
            // Find the hidden connection with this guid
            //
            CMEntry cm;

            hr = CCMUtil::Instance().HrGetEntry(guidHidden, cm);
            // Did we find the hidden connection?
            if( S_OK == hr )
            {
                // Enumerate through all of the connections and find connection with the same name as the
                // hidden connection
                //
                IEnumNetConnection * pEnum = NULL;
                hr = CMDIRECT(DIALUP, CreateWanConnectionManagerEnumConnectionInstance)(NCME_DEFAULT, IID_IEnumNetConnection, reinterpret_cast<LPVOID *>(&pEnum));

                if (SUCCEEDED(hr))
                {
                    INetConnection * pNetCon;
                    NETCON_PROPERTIES * pProps;
                    while(!bFound)
                    {
                        // Get the nect connection
                        //
                        hr = pEnum->Next(1, &pNetCon, NULL);
                        if(S_OK != hr)
                        {
                            // Ooops encountered some error, stop searching
                            //
                            break;
                        }

                        // Get the properties of the connection
                        //
                        hr = pNetCon->GetProperties(&pProps);
                        if(SUCCEEDED(hr))
                        {
                            if(lstrcmp(cm.m_szEntryName, pProps->pszwName) == 0)
                            {
                                // Found the connection that has the same name a the hidden connection
                                // Stop searching!!
                                *pguidOwner = pProps->guidId;
                                bFound = true;
                            }
                            FreeNetconProperties(pProps);
                        }
                        ReleaseObj(pNetCon);
                    }
                    ReleaseObj(pEnum);
                }
            }
            // Stop Impersonating the user 
            //
            CoRevertToSelf();
        }
    }

    return bFound ? S_OK : S_FALSE;
}

//+---------------------------------------------------------------------------
// IConnectionPoint overrides  netman!CConnectionManager__Advise
//
STDMETHODIMP
CConnectionManager::Advise (
    IUnknown* pUnkSink,
    DWORD* pdwCookie)
{
    HRESULT hr = S_OK;

    TraceTag(ttidConman, "Advise");

    Assert(!FBadInPtr(pUnkSink));
    
    // Set our cloaked identity to be used when we call back on this
    // advise interface.  It's important to do this for security.  Since
    // we run as LocalSystem, if we were to call back without identify 
    // impersonation only, the client could impersonate us and get a free 
    // LocalSystem context which could be used for malicious purposes.
    //
    //
    CoSetProxyBlanket (
            pUnkSink,
            RPC_C_AUTHN_WINNT,      // use NT default security
            RPC_C_AUTHZ_NONE,       // use NT default authentication
            NULL,                   // must be null if default
            RPC_C_AUTHN_LEVEL_CALL, // call
            RPC_C_IMP_LEVEL_IDENTIFY,
            NULL,                   // use process token
            EOAC_DEFAULT);
    TraceHr(ttidError, FAL, hr, FALSE, "CoSetProxyBlanket");

    if (S_OK == hr)
    {
        // Initialize our event handler if it has not already been done.
        hr = HrEnsureEventHandlerInitialized();
        if (SUCCEEDED(hr))
        {
            CComPtr<INetConnectionNotifySink> pNotifySink;

            hr = pUnkSink->QueryInterface(IID_INetConnectionNotifySink, reinterpret_cast<void**>(&pNotifySink));
            if (SUCCEEDED(hr))
            {
                GUID guidId = GUID_NULL;

                // If either ConnectionStatusChange or ConnectionAddressChange is implemented, then we need to 
                // register with NLA for events.
                if ((pNotifySink->ConnectionStatusChange(&guidId, NCS_CONNECTED) != E_NOTIMPL) 
                    || (pNotifySink->ConnectionAddressChange(&guidId) != E_NOTIMPL))
                {
                    // We still work for other events if this fails.
                    hr = HrEnsureRegisteredWithNla();
                    TraceErrorOptional("Could not register with Nla", hr, (S_FALSE == hr));
                }
            }

            // Call the underlying ATL implementation of Advise.
            //
            hr = IConnectionPointImpl<
                    CConnectionManager,
                    &IID_INetConnectionNotifySink>::Advise(pUnkSink, pdwCookie);

            TraceTag (ttidConman,
                "CConnectionManager::Advise called... pUnkSink=0x%p, cookie=%d",
                pUnkSink,
                *pdwCookie);

            TraceHr (ttidError, FAL, hr, FALSE, "IConnectionPointImpl::Advise");

            if (SUCCEEDED(hr))
            {
                WCHAR szUserAppData[MAX_PATH];
                HRESULT hrT = S_OK;
                HRESULT hrImpersonate = S_OK;

                if (SUCCEEDED(hrT))
                {
                    // We ignore this HRESULT because we can be called inproc and that would definitely fail.
                    // Instead we just make sure that it succeeded when befor call CoRevertToSelf.  This is 
                    // fine because we'll still get a valid User App data path, it will just be something like
                    // LocalService or LocalSystem and we can still determine which sinks to send events to.

                    BOOLEAN     fNotifyWZC = FALSE;
                    WCHAR       szUserName[MAX_PATH];

                    CNotifySourceInfo* pNotifySourceInfo = new CNotifySourceInfo();
                    if (!pNotifySourceInfo)
                    {
                        hr = E_OUTOFMEMORY;
                    }
                    else
                    {
                        pNotifySourceInfo->dwCookie = *pdwCookie;
                        
                        hrImpersonate = CoImpersonateClient();
                        if (SUCCEEDED(hrImpersonate) || (RPC_E_CALL_COMPLETE == hrImpersonate))
                        {
                            hrT = SHGetFolderPath(NULL, CSIDL_APPDATA, NULL, 0, szUserAppData);
                            if (SUCCEEDED(hrT))
                            {
                                pNotifySourceInfo->szUserProfilesPath = szUserAppData;
                                TraceTag(ttidEvents, "Adding IUnknown for Sink to Map: 0x%08x.  Path: %S", reinterpret_cast<DWORD_PTR>(pUnkSink), szUserAppData);
                                TraceTag(ttidEvents, "Number of Items in Map: %d", m_mapNotify.size());
                            }
                            else
                            {
                                TraceError("Unable to get Folder Path", hrT);
                            }

                            ZeroMemory(szUserName, celems(szUserName));
                            
                            ULONG nSize = celems(szUserName);
                            if (GetUserNameEx(NameSamCompatible, szUserName, &nSize) && *szUserName)
                            {
                                pNotifySourceInfo->szUserName = szUserName;
                                fNotifyWZC = TRUE;
                            }
                            else
                            {
                                pNotifySourceInfo->szUserName = L"System";
                                TraceError("Unable to get the user name", HrFromLastWin32Error());
                            }
                        }
            
                        Lock();
                        m_mapNotify[pUnkSink] = pNotifySourceInfo;
                        Unlock();

#ifdef DBG
                        LPWSTR* ppszAdviseUsers;
                        DWORD   dwCount;
                        HRESULT hrT = GetClientAdvises(&ppszAdviseUsers, &dwCount);
                        if (SUCCEEDED(hrT))
                        {
                            Assert(dwCount);
    
                            TraceTag(ttidConman, "Advise client list after ::Advise:");
                            for (DWORD x = 0; x < dwCount; x++)
                            {
                                LPWSTR szUserName = ppszAdviseUsers[x];
                                TraceTag(ttidConman, "%x: %S", x, szUserName);
                            }

                            CoTaskMemFree(ppszAdviseUsers);
                        }
#endif     
                    }

                    if (SUCCEEDED(hrImpersonate))
                    {
                        CoRevertToSelf();
                    }

                    if (fNotifyWZC)
                    {
                        WZCTrayIconReady(szUserName);
                    }
                }
            
                if (!m_lRegisteredOneTime)
                {
                    // Do an explicit interlocked exchange to only let one thread 
                    // through to do the registration.
                    //
                    if (0 == InterlockedExchange (&m_lRegisteredOneTime, 1))
                    {
                        // Register for device notifications.  Specifically, we're 
                        // interested in network adapters coming and going.  If this 
                        // fails, we proceed anyway.
                        //
                        TraceTag (ttidConman, "Calling RegisterDeviceNotification...");

                        DEV_BROADCAST_DEVICEINTERFACE PnpFilter;
                        ZeroMemory (&PnpFilter, sizeof(PnpFilter));
                        PnpFilter.dbcc_size         = sizeof(PnpFilter);
                        PnpFilter.dbcc_devicetype   = DBT_DEVTYP_DEVICEINTERFACE;
                        PnpFilter.dbcc_classguid    = GUID_NDIS_LAN_CLASS;

                        m_hDevNotify = RegisterDeviceNotification (
                                            (HANDLE)_Module.m_hStatus,
                                            &PnpFilter,
                                            DEVICE_NOTIFY_SERVICE_HANDLE);
                        if (!m_hDevNotify)
                        {
                            TraceHr (ttidError, FAL, HrFromLastWin32Error(), FALSE,
                                "RegisterDeviceNotification");
                        }

                        (VOID) HrEnsureRegisteredOrDeregisteredWithWmi (TRUE);
                    }
                }
            }
        }
    }

    TraceErrorOptional ("CConnectionManager::Advise", hr, (S_FALSE == hr));
    return hr;
}

STDMETHODIMP 
CConnectionManager::Unadvise(DWORD dwCookie)
{
    HRESULT hr = S_OK;
    TraceTag(ttidConman, "Unadvise %d", dwCookie);

    hr = IConnectionPointImpl<CConnectionManager, &IID_INetConnectionNotifySink>::Unadvise(dwCookie);

    Lock();
    BOOL fFound = FALSE;
    
    for (ITERUSERNOTIFYMAP iter = m_mapNotify.begin(); iter != m_mapNotify.end(); iter++)
    {
        if (iter->second->dwCookie == dwCookie)
        {
            fFound = TRUE;
            delete iter->second;
            m_mapNotify.erase(iter);
            break;
        }
    }
    Unlock();
    if (!fFound)
    {
        TraceTag(ttidError, "Unadvise cannot find advise for cookie 0x%08x in notify map", dwCookie);
    }

#ifdef DBG
    LPWSTR* ppszAdviseUsers;
    DWORD   dwCount;
    HRESULT hrT = GetClientAdvises(&ppszAdviseUsers, &dwCount);
    if (SUCCEEDED(hrT))
    {
        if (!dwCount)
        {
            TraceTag(ttidConman, "Unadvise removed the last advise client");
        }
        else
        {
            TraceTag(ttidConman, "Advise client list after ::Unadvise:");
        }

        for (DWORD x = 0; x < dwCount; x++)
        {
            LPWSTR szUserName = ppszAdviseUsers[x];
            TraceTag(ttidConman, "%x: %S", x, szUserName);
        }

        CoTaskMemFree(ppszAdviseUsers);
    }
#endif     
    return hr;
}

#if DBG

//+---------------------------------------------------------------------------
// INetConnectionManagerDebug
//

DWORD
WINAPI
ConmanNotifyTest (
    PVOID   pvContext
    )
{
    TraceFileFunc(ttidConman);

    HRESULT hr;

    RASENUMENTRYDETAILS*    pDetails;
    DWORD                   cDetails;
    hr = HrRasEnumAllEntriesWithDetails (NULL,
            &pDetails, &cDetails);
    if (SUCCEEDED(hr))
    {
        RASEVENT Event;

        for (DWORD i = 0; i < cDetails; i++)
        {
            Event.Type = ENTRY_ADDED;
            Event.Details = pDetails[i];
            RasEventNotify (&Event);

            Event.Type = ENTRY_MODIFIED;
            RasEventNotify (&Event);

            Event.Type = ENTRY_CONNECTED;
            Event.guidId = pDetails[i].guidId;
            RasEventNotify (&Event);

            Event.Type = ENTRY_DISCONNECTED;
            Event.guidId = pDetails[i].guidId;
            RasEventNotify (&Event);

            Event.Type = ENTRY_RENAMED;
            lstrcpyW (Event.pszwNewName, L"foobar");
            RasEventNotify (&Event);

            Event.Type = ENTRY_DELETED;
            Event.guidId = pDetails[i].guidId;
            RasEventNotify (&Event);
        }

        MemFree (pDetails);
    }

    LanEventNotify (REFRESH_ALL, NULL, NULL, NULL);

    TraceErrorOptional ("ConmanNotifyTest", hr, (S_FALSE == hr));
    return hr;
}

STDMETHODIMP
CConnectionManager::NotifyTestStart ()
{
    TraceFileFunc(ttidConman);

    HRESULT hr = S_OK;

    if (!QueueUserWorkItem (ConmanNotifyTest, NULL, WT_EXECUTEDEFAULT))
    {
        hr = HrFromLastWin32Error ();
    }

    TraceErrorOptional ("CConnectionManager::NotifyTestStart", hr, (S_FALSE == hr));
    return hr;
}

STDMETHODIMP
CConnectionManager::NotifyTestStop ()
{
    TraceFileFunc(ttidConman);

    return S_OK;
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netman\conman\enum.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       E N U M . C P P
//
//  Contents:   Enumerator for connection objects.
//
//  Notes:
//
//  Author:     shaunco   21 Sep 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "enum.h"
#include "nccom.h"

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionManagerEnumConnection::CreateInstance
//
//  Purpose:    Creates the connection manager's implementation of
//              a connection enumerator.
//
//  Arguments:
//      Flags            [in]
//      vecClassManagers [in]
//      riid             [in]
//      ppv              [out]
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   22 Sep 1997
//
//  Notes:
//
HRESULT
CConnectionManagerEnumConnection::CreateInstance (
    NETCONMGR_ENUM_FLAGS                Flags,
    CLASSMANAGERMAP&                    mapClassManagers,
    REFIID                              riid,
    void**                              ppv)
{
    TraceFileFunc(ttidConman);
    
    HRESULT hr = E_OUTOFMEMORY;

    CConnectionManagerEnumConnection* pObj;
    pObj = new CComObject <CConnectionManagerEnumConnection>;
    if (pObj)
    {
        // Initialize our members.
        //
        pObj->m_EnumFlags   = Flags;

        // Copy the array of class managers and AddRef them since
        // we will be holding on to them.
        //

        pObj->m_mapClassManagers = mapClassManagers;
        for (CLASSMANAGERMAP::iterator iter = pObj->m_mapClassManagers.begin(); iter != pObj->m_mapClassManagers.end(); iter++)
        {
            AddRefObj (iter->second);
        }
        pObj->m_iterCurClassMgr   = pObj->m_mapClassManagers.begin();

        // Do the standard CComCreator::CreateInstance stuff.
        //
        pObj->SetVoid (NULL);
        pObj->InternalFinalConstructAddRef ();
        hr = pObj->FinalConstruct ();
        pObj->InternalFinalConstructRelease ();

        if (SUCCEEDED(hr))
        {
            hr = pObj->QueryInterface (riid, ppv);
        }

        if (FAILED(hr))
        {
            delete pObj;
        }
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionManagerEnumConnection::FinalRelease
//
//  Purpose:    COM Destructor.
//
//  Arguments:
//      (none)
//
//  Returns:    nothing
//
//  Author:     shaunco   22 Sep 1997
//
//  Notes:
//
void
CConnectionManagerEnumConnection::FinalRelease ()
{
    TraceFileFunc(ttidConman);

    // Release the current enumerator if we have one.
    //
    ReleaseObj (m_penumCurClassMgr);

    // Release our class managers.
    //
    for (CLASSMANAGERMAP::iterator iter = m_mapClassManagers.begin(); iter != m_mapClassManagers.end(); iter++)
    {
        ReleaseObj (iter->second);
    }
}

//+---------------------------------------------------------------------------
// IEnumNetConnection
//
// See documentation in MSDN for any IEnumXXX interface.
//

STDMETHODIMP
CConnectionManagerEnumConnection::Next (
    ULONG               celt,
    INetConnection**    rgelt,
    ULONG*              pceltFetched)
{
    TraceFileFunc(ttidConman);

    HRESULT hr;
    ULONG   celtFetched;

    // Validate parameters.
    //
    if (!rgelt || (!pceltFetched && (1 != celt)))
    {
        hr = E_POINTER;
        goto finished;
    }

    // Important to initialize rgelt so that in case we fail, we can
    // release only what we put in rgelt.
    //
    ZeroMemory (rgelt, sizeof (*rgelt) * celt);

    // Ask the current class manager to fulfill the request.  If he only
    // partially does, move to the next class manager.  Do this until
    // the request is fulfilled, or we run out of class managers.
    //
    celtFetched = 0;
    hr = S_FALSE;

    { // begin lock scope
    CExceptionSafeComObjectLock EsLock (this);

        while ((S_FALSE == hr) && (celtFetched < celt) &&
               (m_iterCurClassMgr != m_mapClassManagers.end()))
        {
            // Get the connection enumerator from the current class manager
            // if neccesary.
            //
            if (!m_penumCurClassMgr)
            {
                INetConnectionManager* pConMan = m_iterCurClassMgr->second;

                Assert (pConMan);

                hr = pConMan->EnumConnections (m_EnumFlags,
                            &m_penumCurClassMgr);
            }
            if (SUCCEEDED(hr))
            {
                Assert (m_penumCurClassMgr);

                // Each class manager should request only what was reqeuested
                // less what has already been fetched.
                //
                ULONG celtT;
                hr = m_penumCurClassMgr->Next (celt - celtFetched,
                        rgelt + celtFetched, &celtT);

                if (SUCCEEDED(hr))
                {
                    celtFetched += celtT;

                    // If the current class manager couldn't fill the entire
                    // request, go to the next one.
                    //
                    if (S_FALSE == hr)
                    {
                        ReleaseCurrentClassEnumerator ();
                        Assert (!m_penumCurClassMgr);
                        m_iterCurClassMgr++;
                    }
                }
            }
        }
        Assert (FImplies (S_OK == hr, (celtFetched == celt)));
    } // end lock scope

    if (SUCCEEDED(hr))
    {
        TraceTag (ttidConman, "Enumerated %d total connections", celtFetched);

        if (pceltFetched)
        {
            *pceltFetched = celtFetched;
        }
        hr = (celtFetched == celt) ? S_OK : S_FALSE;
    }
    else
    {
        // For any failures, we need to release what we were about to return.
        // Set any output parameters to NULL.
        //
        for (ULONG ulIndex = 0; ulIndex < celt; ulIndex++)
        {
            ReleaseObj (rgelt[ulIndex]);
            rgelt[ulIndex] = NULL;
        }
        if (pceltFetched)
        {
            *pceltFetched = 0;
        }
    }

finished:
    TraceErrorOptional ("CConnectionManagerEnumConnection::Next", hr, (S_FALSE == hr));
    return hr;
}

STDMETHODIMP
CConnectionManagerEnumConnection::Skip (
    ULONG   celt)
{
    TraceFileFunc(ttidConman);

    // Unfortunately, this method doesn't return the number of objects
    // actually skipped.  To implement this correctly across the multiple
    // class managers, we'd need to know how many they skipped similiar
    // to the way we implement Next.
    //
    // So, we'll cheese out and implement this by actually calling
    // Next for the reqested number of elements and just releasing what
    // we get back.
    //
    HRESULT hr = S_OK;
    if (celt)
    {
        INetConnection** rgelt;

        CExceptionSafeComObjectLock EsLock (this);

        hr = E_OUTOFMEMORY;
        rgelt = (INetConnection**)MemAlloc(celt * sizeof(INetConnection*));
        if (rgelt)
        {
            ULONG celtFetched;

            hr = Next (celt, rgelt, &celtFetched);

            if (SUCCEEDED(hr))
            {
                ReleaseIUnknownArray (celtFetched, (IUnknown**)rgelt);
            }

            MemFree (rgelt);
        }
    }
    TraceErrorOptional ("CConnectionManagerEnumConnection::Skip", hr, (S_FALSE == hr));
    return hr;
}

STDMETHODIMP
CConnectionManagerEnumConnection::Reset ()
{
    TraceFileFunc(ttidConman);

    CExceptionSafeComObjectLock EsLock (this);

    ReleaseCurrentClassEnumerator ();
    m_iterCurClassMgr = m_mapClassManagers.begin();
    return S_OK;
}

STDMETHODIMP
CConnectionManagerEnumConnection::Clone (
    IEnumNetConnection**    ppenum)
{
    TraceFileFunc(ttidConman);

    HRESULT hr = E_OUTOFMEMORY;

    // Validate parameters.
    //
    if (!ppenum)
    {
        hr = E_POINTER;
    }
    else
    {
        // Initialize output parameter.
        //
        *ppenum = NULL;

        CConnectionManagerEnumConnection* pObj;
        pObj = new CComObject <CConnectionManagerEnumConnection>;
        if (pObj)
        {
            hr = S_OK;

            CExceptionSafeComObjectLock EsLock (this);

            // Initialize our members.
            //
            pObj->m_EnumFlags   = m_EnumFlags;

            // Copy the array of class managers and AddRef them since
            // we will be holding on to them.
            //
            pObj->m_mapClassManagers = m_mapClassManagers;
            for (CLASSMANAGERMAP::iterator iter = m_mapClassManagers.begin(); iter != m_mapClassManagers.end(); iter++)
            {
                AddRefObj (iter->second);
            }

            // The current class manager index need to be copied.
            //
            pObj->m_iterCurClassMgr = pObj->m_mapClassManagers.find(m_iterCurClassMgr->first);

            // Important to clone (not copy) the current class enumerator
            // if we have one.
            //
            if (m_penumCurClassMgr)
            {
                hr = m_penumCurClassMgr->Clone (&pObj->m_penumCurClassMgr);
            }

            if (SUCCEEDED(hr))
            {
                // Return the object with a ref count of 1 on this
                // interface.
                pObj->m_dwRef = 1;
                *ppenum = pObj;
            }

            if (FAILED(hr))
            {
                delete pObj;
            }
        }
    }
    TraceErrorOptional ("CConnectionManagerEnumConnection::Clone", hr, (S_FALSE == hr));
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netman\conman\conman.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       C O N M A N . H
//
//  Contents:   Connection manager.
//
//  Notes:
//
//  Author:     shaunco   21 Sep 1997
//
//----------------------------------------------------------------------------

#pragma once
#include "nmbase.h"
#include "nmres.h"
#include <rasapip.h>
#include "cmevent.h"
#include "ncstl.h"
#include "map"

// typedef map<IUnknown*, tstring> USERNOTIFYMAP;

class CNotifySourceInfo
{
public:
    tstring szUserName;
    tstring szUserProfilesPath;
    DWORD   dwCookie;
};

typedef map<IUnknown*, CNotifySourceInfo *> USERNOTIFYMAP;
typedef USERNOTIFYMAP::iterator ITERUSERNOTIFYMAP;

class ATL_NO_VTABLE CConnectionManager :
    public CComObjectRootEx <CComMultiThreadModel>,
    public CComCoClass <CConnectionManager, &CLSID_ConnectionManager>,
    public IConnectionPointContainerImpl <CConnectionManager>,
    public IConnectionPointImpl<CConnectionManager, &IID_INetConnectionNotifySink>,
#if DBG
    public INetConnectionManagerDebug,
#endif
    public INetConnectionManager,
    public INetConnectionRefresh,
    public INetConnectionCMUtil,
    public INetConnectionManagerEvents
{
private:
    // These static members are used by NotifyClientsOfEvent and
    // FinalRelease.  Since NotifyClientsOfEvent occurs asynchrounously
    // on a different thread, we need to ensure that the instance of this
    // object remains around for the lifetime of that call.  Therefore,
    // FinalRelease will wait until g_fInUse is FALSE.  NotifyClientsOfEvent
    // sets g_fInUse to TRUE before using g_pConMan.  FinalRelease sets
    // g_pConMan to NULL before waiting for g_fInUse to become FALSE.
    //
    // Note: using this method as opposed to AddRefing g_pConMan avoids the
    // circular refcount that would keep the service always running because
    // it AddRef'd its own object.
    //
    volatile static CConnectionManager* g_pConMan;
    volatile static BOOL                g_fInUse;

    // m_ClassManagers is an array (STL vector) of pointers to the
    // INetConnectionManager interfaces implemented by our registered
    // class managers.
    //
    CLASSMANAGERMAP                     m_mapClassManagers;

    USERNOTIFYMAP                       m_mapNotify;

    LONG                                m_lRegisteredOneTime;
    HDEVNOTIFY                          m_hDevNotify;
    BOOL                                m_fRegisteredWithWmi;

    HANDLE                              m_hRegNotify;
    HANDLE                              m_hRegNotifyWait;
    HKEY                                m_hRegClassManagerKey;

    HRESULT HrEnsureRegisteredOrDeregisteredWithWmi (IN  BOOL fRegister);
    HRESULT HrEnsureClassManagersLoaded ();

public:
    CConnectionManager() throw()
    {
        TraceTag (ttidConman, "New connection manager being created");
        AssertH (!g_pConMan);
        g_pConMan = this;
        m_lRegisteredOneTime = FALSE;
        m_hDevNotify = NULL;
        m_hRegNotify = NULL;
        m_hRegNotifyWait = NULL;
        m_hRegClassManagerKey = NULL;
        m_fRegisteredWithWmi = FALSE;
    }
    VOID FinalRelease () throw();

    DECLARE_CLASSFACTORY_DEFERRED_SINGLETON(CConnectionManager)
    DECLARE_REGISTRY_RESOURCEID(IDR_CONMAN)

    BEGIN_COM_MAP(CConnectionManager)
        COM_INTERFACE_ENTRY(INetConnectionManager)
        COM_INTERFACE_ENTRY(INetConnectionRefresh)
        COM_INTERFACE_ENTRY(INetConnectionCMUtil)
        COM_INTERFACE_ENTRY(INetConnectionManagerEvents)
#if DBG
        COM_INTERFACE_ENTRY(INetConnectionManagerDebug)
#endif
        COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
    END_COM_MAP()

    BEGIN_CONNECTION_POINT_MAP(CConnectionManager)
        CONNECTION_POINT_ENTRY(IID_INetConnectionNotifySink)
    END_CONNECTION_POINT_MAP()

    // INetConnectionManager
    STDMETHOD (EnumConnections) (
        IN  NETCONMGR_ENUM_FLAGS    Flags,
        OUT IEnumNetConnection**    ppEnum);

    // INetConnectionRefresh
    STDMETHOD (RefreshAll) ();
    STDMETHOD (ConnectionAdded) (IN INetConnection* pConnection);
    STDMETHOD (ConnectionDeleted) (IN  const GUID* pguidId);
    STDMETHOD (ConnectionModified) (IN  INetConnection* pConnection);
    STDMETHOD (ConnectionRenamed) (IN  INetConnection* pConnection);
    STDMETHOD (ConnectionStatusChanged) (IN const GUID* pguidId, IN const NETCON_STATUS  ncs );
    STDMETHOD (ShowBalloon) (IN const GUID *pguidId, IN const BSTR szCookie, IN const BSTR szBalloonText);
    STDMETHOD (DisableEvents) (IN const BOOL fDisable, IN const ULONG ulDisableTimeout);
    
    // INetConnectionManagerEvents
    STDMETHOD (RefreshConnections) ();
    STDMETHOD (Enable) ();
    STDMETHOD (Disable) (IN ULONG ulDisableTimeout);
    
    // INetConnectionCMUtil
    STDMETHOD (MapCMHiddenConnectionToOwner) (
        /*[in]*/  REFGUID guidHidden,
        /*[out]*/ GUID * pguidOwner);

#if DBG
    // INetConnectionManagerDebug
    STDMETHOD (NotifyTestStart) ();
    STDMETHOD (NotifyTestStop) ();
#endif

    // Override Advise so we know when to register for LAN device
    // notifications.
    //
    STDMETHOD (Advise) (
        IUnknown* pUnkSink,
        DWORD* pdwCookie);

    STDMETHOD (Unadvise) (
        DWORD dwCookie);

public:
    static
    BOOL FHasActiveConnectionPoints () throw();

    static
    VOID NotifyClientsOfEvent (
        IN  const CONMAN_EVENT* pEvent) throw();

private:
    friend HRESULT GetClientAdvises(OUT LPWSTR** pppszAdviseUsers, OUT LPDWORD pdwCount);
    static VOID NTAPI RegChangeNotifyHandler(IN OUT LPVOID pContext, IN BOOLEAN fTimerFired) throw();
};

VOID FreeConmanEvent (IN TAKEOWNERSHIP CONMAN_EVENT* pEvent) throw();

HRESULT HrGetRasConnectionProperties(
    IN  const RASENUMENTRYDETAILS*      pDetails,
    OUT NETCON_PROPERTIES_EX**          ppPropsEx);

HRESULT HrGetIncomingConnectionPropertiesEx(
    IN  const HANDLE                    hRasConn,
    IN  const GUID*                     pguidId,
    IN  const DWORD                     dwType,
    OUT NETCON_PROPERTIES_EX**          ppPropsEx);

HRESULT 
GetClientAdvises(OUT LPWSTR** pppszAdviseUsers, OUT LPDWORD pdwCount);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netman\conman\enum.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       E N U M . H
//
//  Contents:   Enumerator for connection objects.
//
//  Notes:
//
//  Author:     shaunco   21 Sep 1997
//
//----------------------------------------------------------------------------

#pragma once
#include "nmbase.h"
#include "nmres.h"


class ATL_NO_VTABLE CConnectionManagerEnumConnection :
    public CComObjectRootEx <CComMultiThreadModel>,
    public CComCoClass <CConnectionManagerEnumConnection,
                        &CLSID_ConnectionManagerEnumConnection>,
    public IEnumNetConnection
{
private:
    NETCONMGR_ENUM_FLAGS    m_EnumFlags;

    // m_ClassManagers is a binary tree (STL map) of pointers to the
    // INetConnectionManager interfaces implemented by our registered
    // class managers, indexed by the GUIDs of the class manager.
    //
    CLASSMANAGERMAP                     m_mapClassManagers;

    // m_iCurClassMgr is the iterator into the above map for the current
    // class manager involved in the enumeration.
    //
    CLASSMANAGERMAP::iterator           m_iterCurClassMgr;

    // m_penumCurClassMgr is the enumerator corresponding to the current
    // class manager.
    IEnumNetConnection*                 m_penumCurClassMgr;

private:
    VOID ReleaseCurrentClassEnumerator () throw()
    {
        ReleaseObj (m_penumCurClassMgr);
        m_penumCurClassMgr = NULL;
    }

public:
    CConnectionManagerEnumConnection () throw()
    {
        m_EnumFlags         = NCME_DEFAULT;
        m_penumCurClassMgr  = NULL;
        m_iterCurClassMgr   = m_mapClassManagers.begin();
    }
    VOID FinalRelease () throw();

    DECLARE_REGISTRY_RESOURCEID(IDR_CONMAN_ENUM)

    BEGIN_COM_MAP(CConnectionManagerEnumConnection)
        COM_INTERFACE_ENTRY(IEnumNetConnection)
    END_COM_MAP()

    // IEnumNetConnection
    STDMETHOD (Next) (
        ULONG               celt,
        INetConnection**    rgelt,
        ULONG*              pceltFetched);

    STDMETHOD (Skip) (
        ULONG   celt);

    STDMETHOD (Reset) ();

    STDMETHOD (Clone) (
        IEnumNetConnection**    ppenum);

public:
    static HRESULT CreateInstance (
        NETCONMGR_ENUM_FLAGS                Flags,
        CLASSMANAGERMAP&                    mapClassManagers,
        REFIID                              riid,
        VOID**                              ppv);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netman\conman\conman2.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       C O N M A N 2 . C P P
//
//  Contents:   Connection manager 2.
//
//  Notes:
//
//  Author:     ckotze   16 Mar 2001
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include <atlbase.h>
#include "cobase.h"
#include "conman.h"
#include "conman2.h"
#include "ncnetcon.h"

HRESULT CConnectionManager2::EnumConnectionProperties(OUT SAFEARRAY** ppsaConnectionProperties)
{
    TraceFileFunc(ttidConman);

    CComPtr<INetConnectionManager> pConMan;
    NETCON_PROPERTIES_EX* pPropsEx;
    HRESULT hr = S_OK;

    hr = CoCreateInstance(CLSID_ConnectionManager, NULL, CLSCTX_INPROC, IID_INetConnectionManager, reinterpret_cast<void**>(&pConMan));

    if (SUCCEEDED(hr))
    {
        CComPtr<IEnumNetConnection> pNetConnection;
        hr = pConMan->EnumConnections(NCME_DEFAULT, &pNetConnection);
        if (SUCCEEDED(hr))
        {   
            INetConnection* pConn;
            ULONG ulFetched;
            LISTNETCONPROPEX listNCProperties;
            ITERNETCONPROPEX iterProps;
        
            HRESULT hrFetched = S_OK;
            do
            {
                hrFetched = pNetConnection->Next(1, &pConn, &ulFetched);
                if ( (S_OK == hr) && (ulFetched) )
                {
                    CComPtr<INetConnection2> pConn2;
                    
                    // Does the class manager support INetConnection2?
                    // if so use it directly
                    hr = pConn->QueryInterface(IID_INetConnection2, reinterpret_cast<void**>(&pConn2));
                    if (SUCCEEDED(hr))
                    {
                        hr = pConn2->GetPropertiesEx(&pPropsEx);
                    }
                    else
                    {
                        // This class manager does not support INetConnection2. Convert the connection
                        NETCON_PROPERTIES* pProps;
                        hr = pConn->GetProperties(&pProps);
                        if (SUCCEEDED(hr))
                        {
                            pPropsEx = reinterpret_cast<NETCON_PROPERTIES_EX*>(CoTaskMemAlloc(sizeof(NETCON_PROPERTIES_EX)));
                            
                            if (pPropsEx)
                            {
                                CComPtr<IPersistNetConnection> pPersistNetConnection;
                                hr = pConn->QueryInterface(IID_IPersistNetConnection, reinterpret_cast<LPVOID *>(&pPersistNetConnection));
                                if (SUCCEEDED(hr))
                                {
                                    ZeroMemory(pPropsEx, sizeof(NETCON_PROPERTIES_EX));
                                    hr = HrBuildPropertiesExFromProperties(pProps, pPropsEx, pPersistNetConnection);
                                }
                            }
                            else
                            {
                                hr = E_OUTOFMEMORY;
                            }
                            FreeNetconProperties(pProps);
                        }
                    }

                    if (S_OK == hr)
                    {
                        listNCProperties.insert(listNCProperties.end(), pPropsEx);
                    }
                    else
                    {
                        TraceTag(ttidError, "Failed to retrieve connection information for connection. Connection will be ommitted from Connections Folder.");
                    }

                    ReleaseObj(pConn);
                }
            } while ( (S_OK == hrFetched) && (ulFetched) );

            if (listNCProperties.size())
            {
                hr = S_OK;
                
                if (listNCProperties.size() != 0)
                {
                    SAFEARRAYBOUND rgsaBound[1];
                    LONG lIndex;
                    rgsaBound[0].cElements = listNCProperties.size();
                    rgsaBound[0].lLbound = 0;
                    lIndex = rgsaBound[0].lLbound;
                    *ppsaConnectionProperties = SafeArrayCreate(VT_VARIANT, 1, rgsaBound);
                    for (ITERNETCONPROPEX iter = listNCProperties.begin(); iter != listNCProperties.end(); iter++)
                    {
                        HRESULT hrT = S_OK;
                        VARIANT varElement;
                        SAFEARRAY* psaPropertiesEx = NULL;

                        pPropsEx = *iter;

                        hrT = HrSafeArrayFromNetConPropertiesEx(pPropsEx, &psaPropertiesEx);

                        if (SUCCEEDED(hrT))
                        {
                            VariantInit(&varElement);
                            varElement.vt = VT_VARIANT | VT_ARRAY;
                            varElement.parray = psaPropertiesEx;

                            hrT = SafeArrayPutElement(*ppsaConnectionProperties, &lIndex, &varElement);
                            VariantClear(&varElement);
                        }

                        if (FAILED(hrT))
                        {
                            hr = hrT;
                            break;
                        }

                        lIndex++;
                    }
                }
            }

            for (ITERNETCONPROPEX iter = listNCProperties.begin(); iter != listNCProperties.end(); iter++)
            {   
                HrFreeNetConProperties2(*iter);
            }
        }
    }

    if (SUCCEEDED(hr) && !(*ppsaConnectionProperties) )
    {
        hr = S_FALSE;
    }

    TraceHr (ttidError, FAL, hr, FALSE, "CConnectionManager2::EnumConnectionProperties");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netman\dll\implinc.cpp ===
#include "pch.h"
#pragma hdrstop
#include "nmbase.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

// Include ATL's implementation.  Substitute _ASSERTE with our Assert.
//
#ifdef _ASSERTE
#undef _ASSERTE
#define _ASSERTE Assert
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netman\conman\nmhnet.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000.
//
//  File:       N M H N E T . C P P
//
//  Contents:   Home networking support routines
//
//  Notes:
//
//  Author:     jonburs     15 August 2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "nmbase.h"
#include "nmhnet.h"

//
// Exported globals
//

IHNetCfgMgr *g_pHNetCfgMgr;
LONG g_lHNetModifiedEra;

//
// Private globals
//

CRITICAL_SECTION g_csHNetCfgMgr;
BOOLEAN g_fCreatingHNetCfgMgr;

VOID
InitializeHNetSupport(
    VOID
    )

{
    g_pHNetCfgMgr = NULL;
    g_lHNetModifiedEra = 0;
    g_fCreatingHNetCfgMgr = FALSE;

    __try
    {
        InitializeCriticalSection(&g_csHNetCfgMgr);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        AssertSz(FALSE, "InitializeHNetSupport: exception during InitializeCriticalSection");
    }
}

VOID
CleanupHNetSupport(
    VOID
    )

{
    ReleaseObj(g_pHNetCfgMgr);
    DeleteCriticalSection(&g_csHNetCfgMgr);
}

HRESULT
HrGetHNetCfgMgr(
    IHNetCfgMgr **ppHNetCfgMgr
    )

{
    HRESULT hr = S_OK;

    Assert(ppHNetCfgMgr);

    *ppHNetCfgMgr = NULL;

    //
    // Make sure that the service is in the correct state.
    //

    if (SERVICE_RUNNING != _Module.DwServiceStatus ())
    {
        hr = E_UNEXPECTED;
    }
    else
    {
        if (NULL == g_pHNetCfgMgr)
        {
            EnterCriticalSection(&g_csHNetCfgMgr);

            if (!g_fCreatingHNetCfgMgr && NULL == g_pHNetCfgMgr)
            {
                IHNetCfgMgr *pHNetCfgMgr;
                
                g_fCreatingHNetCfgMgr = TRUE;
                
                LeaveCriticalSection(&g_csHNetCfgMgr);
                hr = HrCreateInstance(
                        CLSID_HNetCfgMgr,
                        CLSCTX_INPROC_SERVER,
                        &pHNetCfgMgr
                        );
                EnterCriticalSection(&g_csHNetCfgMgr);
                
                Assert(NULL == g_pHNetCfgMgr);
                g_fCreatingHNetCfgMgr = FALSE;
                g_pHNetCfgMgr = pHNetCfgMgr;
            }
            else if (NULL == g_pHNetCfgMgr)
            {
                //
                // Another thread is already trying to create the
                // object. (Spin for a small amount of time to see
                // if that thread succeeds?)
                //

                hr = HRESULT_FROM_WIN32(ERROR_BUSY);

            }

            LeaveCriticalSection(&g_csHNetCfgMgr);
        }

        Assert(g_pHNetCfgMgr || FAILED(hr));

        if (SUCCEEDED(hr))
        {
            *ppHNetCfgMgr = g_pHNetCfgMgr;
            AddRefObj(*ppHNetCfgMgr);
        }
    }

    return hr;
}

//
// CNetConnectionHNetUtil implementation -- INetConnectionHNetUtil routines
//

STDMETHODIMP
CNetConnectionHNetUtil::NotifyUpdate(
    VOID
    )

{
    InterlockedIncrement(&g_lHNetModifiedEra);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netman\conman\nmpolicy.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       E V E N T Q  . C P P
//
//  Contents:   Event Queue for managing synchonization of external events.
//
//  Notes:      
//
//  Author:     ckotze   29 Nov 2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "nmpolicy.h"
#include "ncperms.h"

extern CGroupPolicyNetworkLocationAwareness* g_pGPNLA;

CNetMachinePolicies::CNetMachinePolicies() throw() : m_pGroupPolicyNLA(0)
{
    HRESULT hr;
    hr = HrEnsureRegisteredWithNla();
    if (SUCCEEDED(hr))
    {
        m_pGroupPolicyNLA = g_pGPNLA;
    }
    TraceHr(ttidGPNLA, FAL, hr, (S_FALSE==hr), "CNetMachinePolicies::CNetMachinePolicies()");
}

CNetMachinePolicies::~CNetMachinePolicies() throw()
{
}

HRESULT CNetMachinePolicies::VerifyPermission(IN DWORD ulPerm, OUT BOOL* pfPermission)
{
    Assert(ulPerm == NCPERM_ShowSharedAccessUi || ulPerm == NCPERM_PersonalFirewallConfig || 
           ulPerm == NCPERM_ICSClientApp || ulPerm == NCPERM_AllowNetBridge_NLA);

    if (ulPerm != NCPERM_ShowSharedAccessUi && ulPerm != NCPERM_PersonalFirewallConfig  &&
        ulPerm != NCPERM_ICSClientApp && ulPerm != NCPERM_AllowNetBridge_NLA)
    {
        return E_INVALIDARG;
    }
    if (!pfPermission)
    {
        return E_POINTER;
    }

    // If for some reason m_pGroupPolicyNLA is NULL, then FHasPermission will return TRUE,
    // We assume that we're on a different network from which the policy came, rather than
    // enforce the policies and cause the firewall not to start when connected to a public
    // network.

    *pfPermission = FHasPermission(ulPerm, dynamic_cast<CGroupPolicyBase*>(m_pGroupPolicyNLA));

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netman\conman\gpnla.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       G P N L A . C P P
//
//  Contents:   Class for Handling NLA Changes that affect Group Policies
//
//  Notes:
//
//  Author:     sjkhan   20 Feb 2001
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "trace.h"
#include "gpnla.h"
#include <winsock2.h>
#include <mswsock.h>
#include "nmbase.h"
#include <userenv.h>
#include <userenvp.h>
#include <ncstl.h>
#include <algorithm>
#include <lancmn.h>
#include <lm.h>
#include "ipnathlp.h"
#include "ncmisc.h"
#include "ipifcons.h"
#include "conman.h"
#include "eventq.h"

GUID g_WsMobilityServiceClassGuid = NLA_SERVICE_CLASS_GUID;

static const WCHAR c_szHomenetService[] = L"SharedAccess";

extern CGroupPolicyNetworkLocationAwareness* g_pGPNLA;

bool operator == (const GPNLAPAIR& rpair1, const GPNLAPAIR& rpair2)
{
    return IsEqualGUID(rpair1.first, rpair2.first) == TRUE;
}

LONG CGroupPolicyNetworkLocationAwareness::m_lBusyWithReconfigure = 0;


//+---------------------------------------------------------------------------
//
//  Member:     CGroupPolicyNetworkLocationAwareness::CGroupPolicyNetworkLocationAwareness
//
//  Purpose:    CGroupPolicyNetworkLocationAwareness constructor
//
//  Arguments:
//      (none)
//
//  Returns:    none
//
//  Author:     ckotze   20 Feb 2001
//
//  Notes:
//
CGroupPolicyNetworkLocationAwareness::CGroupPolicyNetworkLocationAwareness() throw()
{
    TraceFileFunc(ttidGPNLA);

    m_fSameNetwork = FALSE;
    m_fShutdown = FALSE;
    m_lRefCount = 0;
    m_fErrorShutdown = FALSE;
    m_hGPWait = INVALID_HANDLE_VALUE;
    m_hNLAWait = INVALID_HANDLE_VALUE;
    m_lBusyWithReconfigure = 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CGroupPolicyNetworkLocationAwareness::~CGroupPolicyNetworkLocationAwareness
//
//  Purpose:    CGroupPolicyNetworkLocationAwareness destructor
//
//  Arguments:
//      (none)
//
//  Returns:    none
//
//  Author:     ckotze   20 Feb 2001
//
//  Notes:
//
CGroupPolicyNetworkLocationAwareness::~CGroupPolicyNetworkLocationAwareness() throw()
{
    TraceFileFunc(ttidGPNLA);
}

//+---------------------------------------------------------------------------
//
//  Member:     CGroupPolicyNetworkLocationAwareness::Initialize
//
//  Purpose:    To initialize the different components required for detecting
//              changes to the network and creating the different 
//              synchronization objects required.
//  Arguments:
//      (none)
//
//  Returns:    HRESULT indicating SUCCESS or FAILURE
//
//  Author:     sjkhan   20 Feb 2001
//
//  Notes:
//
HRESULT CGroupPolicyNetworkLocationAwareness::Initialize()
{
    HRESULT hr;

    TraceTag(ttidGPNLA, "Initializing Group Policy Handler");

    InitializeCriticalSection(&m_csList);
    
    // Init Winsock
    if (ERROR_SUCCESS == WSAStartup(MAKEWORD(2, 2), &m_wsaData)) 
    {
        m_hEventNLA = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (m_hEventNLA)
        {
            m_hEventExit = CreateEvent(NULL, FALSE, FALSE, NULL);
            if (m_hEventExit)
            {
                m_hEventGP = CreateEvent(NULL, FALSE, FALSE, NULL);
                if (m_hEventGP)
                {
                    hr = RegisterWait();
                    if (SUCCEEDED(hr))
                    {
                        if (RegisterGPNotification(m_hEventGP, TRUE))
                        {
                            ZeroMemory(&m_wsaCompletion,sizeof(m_wsaCompletion));
                            ZeroMemory(&m_wsaOverlapped,sizeof(m_wsaOverlapped));
        
                            m_wsaOverlapped.hEvent = m_hEventNLA;
        
                            m_wsaCompletion.Type = NSP_NOTIFY_EVENT;
                            m_wsaCompletion.Parameters.Event.lpOverlapped = &m_wsaOverlapped;
        
                            ZeroMemory(&m_wqsRestrictions, sizeof(m_wqsRestrictions));
                            m_wqsRestrictions.dwSize = sizeof(m_wqsRestrictions);
                            m_wqsRestrictions.lpServiceClassId = &g_WsMobilityServiceClassGuid;
                            m_wqsRestrictions.dwNameSpace = NS_NLA;
        
                            hr = LookupServiceBegin(LUP_NOCONTAINERS);
                            
                            if (SUCCEEDED(hr))
                            {
                                // Loop through once and get all the data to begin with.
                                hr = EnumChanges();

                                if (SUCCEEDED(hr))
                                {
                                    return hr;
                                }
                            }

                            UnregisterGPNotification(m_hEventGP);
                        }
                        else
                        {
                            hr = HrFromLastWin32Error();
                        }
                        DeregisterWait();
                    }
                    CloseHandle(m_hEventGP);
                }
                else
                {
                    hr = HrFromLastWin32Error();
                }
            }
            else
            {
                hr = HrFromLastWin32Error();
            }
            CloseHandle(m_hEventExit);
        }
        else
        {
            hr = HrFromLastWin32Error();
        }
        CloseHandle(m_hEventNLA);
    }
    else
    {
        int nError;

        nError  = WSAGetLastError();

        hr = HRESULT_FROM_WIN32(nError);
    }

    TraceError("CGroupPolicyNetworkLocationAwareness::Initialize failed", hr);
    
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CGroupPolicyNetworkLocationAwareness::Uninitialize
//
//  Purpose:    This is used to ensure that no threads are currently running
//              when they should be stopped.  If the refcount is >0 then it 
//              waits for the last busy thread to terminate and set the event
//              marking its termination so that shutdown can proceed.
//  Arguments:
//      (none)
//
//  Returns:    HRESULT indicating success/failure.
//
//  Author:     sjkhan   20 Feb 2001
//
//  Notes:
//
HRESULT CGroupPolicyNetworkLocationAwareness::Uninitialize()
{
    HRESULT hr = S_OK;
    DWORD dwRet = WAIT_OBJECT_0;
    int nCount = 0;

    TraceTag(ttidGPNLA, "Unitializing Group Policy Handler");
    
    m_fShutdown = TRUE;

    Unreference();

    // LookupServiceEnd should cause an event to fire which will make us exit (unless NLA was already stopped).
    hr = LookupServiceEnd();

    if ((0 != m_lRefCount) && SUCCEEDED(hr) && !m_fErrorShutdown)
    {   
        dwRet = WaitForSingleObject(m_hEventExit, 30000L);
    }

    do
    {
        hr = DeregisterWait();
        if (SUCCEEDED(hr))
        {
            break;
        }
    } while ((nCount++ < 3) && FAILED(hr));

    TraceError("DeregisterWait returned", hr);

    if (SUCCEEDED(hr))
    {
        CloseHandle(m_hEventExit);
        CloseHandle(m_hEventNLA);

        DeleteCriticalSection(&m_csList);

        WSACleanup();
    }

    TraceTag(ttidGPNLA, "NLA was uninitialized");

     return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CGroupPolicyNetworkLocationAwareness::RegisterWait
//
//  Purpose:    Registers the Wait Object so that we don't require any threads
//              of our own.
//  Arguments:
//      (none)
//
//  Returns:    HRESULT indicating success/failure.
//
//  Author:     sjkhan   20 Feb 2001
//
//  Notes:
//
HRESULT CGroupPolicyNetworkLocationAwareness::RegisterWait()
{
    TraceFileFunc(ttidGPNLA);

    HRESULT hr = S_OK;
    NTSTATUS Status;

    Reference();  // Make sure that we're referenced so that we don't accidentally kill the service while it's still busy.

    Status = RtlRegisterWait(&m_hNLAWait, m_hEventNLA, &CGroupPolicyNetworkLocationAwareness::EventHandler, this, INFINITE, WT_EXECUTEINLONGTHREAD);

    if (!NT_SUCCESS(Status))
    {
        m_hNLAWait = INVALID_HANDLE_VALUE;
        hr = HRESULT_FROM_NT(Status);
    }
    else
    {
        Status = RtlRegisterWait(&m_hGPWait, m_hEventGP, &CGroupPolicyNetworkLocationAwareness::GroupPolicyChange, this, INFINITE, WT_EXECUTEINLONGTHREAD);
        if (!NT_SUCCESS(Status))
        {
            hr = HRESULT_FROM_NT(Status);
            RtlDeregisterWaitEx(m_hNLAWait, INVALID_HANDLE_VALUE);
            m_hGPWait = INVALID_HANDLE_VALUE;
            m_hNLAWait = INVALID_HANDLE_VALUE;
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CGroupPolicyNetworkLocationAwareness::DeregisterWait
//
//  Purpose:    Deregisters the wait so that we can shutdown and not have
//              any new threads spawned.
//  Arguments:
//      (none)
//
//  Returns:    HRESULT indicating success/failure.
//
//  Author:     sjkhan   20 Feb 2001
//
//  Notes:
//
HRESULT CGroupPolicyNetworkLocationAwareness::DeregisterWait()
{
    TraceFileFunc(ttidGPNLA);

    HRESULT hr,hr1,hr2 = S_OK;
    NTSTATUS Status1, Status2;

    if (INVALID_HANDLE_VALUE != m_hNLAWait)
    {
        Status1 = RtlDeregisterWaitEx(m_hNLAWait, INVALID_HANDLE_VALUE);
        
        if (!NT_SUCCESS(Status1))
        {
            hr1 = HRESULT_FROM_NT(Status1);
        }
        
        if (INVALID_HANDLE_VALUE != m_hGPWait)
        {
            Status2 = RtlDeregisterWaitEx(m_hGPWait, INVALID_HANDLE_VALUE);
            if (!NT_SUCCESS(Status2))
            {
                hr2 = HRESULT_FROM_NT(Status2);
            }
        }
    
        if (FAILED(hr1))
        {
            hr = hr1;
        }
        else if (FAILED(hr2))
        {
            hr = hr2;
        }
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CGroupPolicyNetworkLocationAwareness::IsJoinedToDomain
//
//  Purpose:    Checks to see if this machine belongs to an NT Domain
//              
//  Arguments:
//      (none)
//
//  Returns:    BOOL.  TRUE = Joined to a Domain, FALSE = not...
//
//  Author:     sjkhan   29 Jan 2002
//
//  Notes:
//
BOOL CGroupPolicyNetworkLocationAwareness::IsJoinedToDomain()
{
    static DWORD dwDomainMember = 0xffffffff; // Unconfigured
    
    TraceTag(ttidGPNLA, "Entering IsJoinedToDomain");

    if (0xffffffff == dwDomainMember)
    {
        dwDomainMember = FALSE;
        
        LPWSTR pszDomain;
        NETSETUP_JOIN_STATUS njs = NetSetupUnknownStatus;
        if (NERR_Success == NetGetJoinInformation(NULL, &pszDomain, &njs))
        {
            NetApiBufferFree(pszDomain);
            if (NetSetupDomainName == njs)
            {
                dwDomainMember = TRUE;
                TraceTag(ttidGPNLA, "We're  on a domain (NLA policies apply)");
            }
            else
            {
                TraceTag(ttidGPNLA, "We're not on a domain (No NLA policies will apply)");
            }
        }
        else
        {
            TraceTag(ttidGPNLA, "We're not on a domain (No NLA policies will apply)");
        }
    }
    else
    {
        TraceTag(ttidGPNLA, "IsJoinedToDomain: Previously configured to: %s", dwDomainMember ? "TRUE" : "FALSE");
    }
    
    TraceTag(ttidGPNLA, "Leaving IsJoinedToDomain");

    return static_cast<BOOL>(dwDomainMember);
}



//+---------------------------------------------------------------------------
//
//  Member:     CGroupPolicyNetworkLocationAwareness::IsSameNetworkAsGroupPolicies
//
//  Purpose:    Used to determine our current network location with respect to
//              the network from which the Group Policies came from.
//
//  Arguments:
//      (none)
//
//  Returns:    BOOL.
//
//  Author:     sjkhan   20 Feb 2001
//
//  Notes:
//
BOOL CGroupPolicyNetworkLocationAwareness::IsSameNetworkAsGroupPolicies() throw()
{
    BOOL fNetworkMatch = FALSE;  // Assume we are on a different network.
    WCHAR pszName[256] = {0};
    DWORD dwSize = 256;
    DWORD dwErr;
    
    TraceTag(ttidGPNLA, "Entering IsSameNetworkAsGroupPolicies");

    // Get the network Name.
    dwErr = GetGroupPolicyNetworkName(pszName, &dwSize);
    
    TraceTag(ttidGPNLA, "NetworkName: %S", pszName);

    if (ERROR_SUCCESS == dwErr)
    {
        if (IsJoinedToDomain())
        {
            CExceptionSafeLock esLock(&m_csList);  // Protecting list
            GPNLAPAIR nlapair;
            
            // We need to look at all of the adapters to check that at least 1 
            // is on the same network from which the Group Policies came, and is currently
            // connected or trying to connect to a network.
            for (GPNLAITER iter = m_listAdapters.begin(); iter != m_listAdapters.end(); iter++)
            {
                LPCSTR pStr = NULL;
                nlapair = *iter;

                TraceTag(ttidGPNLA,  "Network Name: %S", nlapair.second.strNetworkName.c_str());
                TraceTag(ttidGPNLA,  "Network Status: %s", DbgNcs(nlapair.second.ncsStatus));

                if (
                        (nlapair.second.strNetworkName == pszName) 
                        && 
                        (
                            (NCS_CONNECTED == nlapair.second.ncsStatus) || 
                            (NCS_AUTHENTICATING == nlapair.second.ncsStatus) || 
                            (NCS_AUTHENTICATION_SUCCEEDED == nlapair.second.ncsStatus) ||
                            (NCS_AUTHENTICATION_FAILED == nlapair.second.ncsStatus) ||
                            (NCS_CREDENTIALS_REQUIRED == nlapair.second.ncsStatus)
                        )
                    )
                {
                    // Yes, we're still on the network so we need to enforce group policies.
                    fNetworkMatch = TRUE;
                }
            }
        }
        else
        {
            TraceTag(ttidGPNLA, "We're not on a domain, exiting...");
        }
        
        if (fNetworkMatch != m_fSameNetwork)
        {
            LanEventNotify (REFRESH_ALL, NULL, NULL, NULL);
            m_fSameNetwork = fNetworkMatch;
            ReconfigureHomeNet();
        }
    }
    
    TraceTag(ttidGPNLA, "IsSameNetworkAsGroupPolicies. Matches: %s", fNetworkMatch ? "TRUE" : "FALSE");

    return fNetworkMatch;
}

//+---------------------------------------------------------------------------
//
//  Member:     CGroupPolicyNetworkLocationAwareness::Reference
//
//  Purpose:    Increments our reference count.
//
//  Arguments:
//      (none)
//
//  Returns:    The current Refcount (note this may not be 100% accurate, 
//              but will never be 0 unless we're really shutting down).
//
//  Author:     sjkhan   20 Feb 2001
//
//  Notes:
//
LONG CGroupPolicyNetworkLocationAwareness::Reference() throw()
{
    InterlockedIncrement(&m_lRefCount);

    TraceTag(ttidGPNLA, "Reference() - Count: %d", m_lRefCount);

    return m_lRefCount;
}

//+---------------------------------------------------------------------------
//
//  Member:     CGroupPolicyNetworkLocationAwareness::Unreference
//
//  Purpose:    Decrements our reference countand sets and event if it reaches
//              zero and we're shutting down.
//
//  Arguments:
//      (none)
//
//  Returns:    The current Refcount (note this may not be 100% accurate, 
//              but will never be 0 unless we're really shutting down).
//
//  Author:     sjkhan   20 Feb 2001
//
//  Notes:
//
LONG CGroupPolicyNetworkLocationAwareness::Unreference() throw()
{
    if ((0 == InterlockedDecrement(&m_lRefCount)) && m_fShutdown)
    {
        SetEvent(m_hEventExit);
    }

    TraceTag(ttidGPNLA, "Unreference() - Count: %d", m_lRefCount);

    return m_lRefCount;
}

//+---------------------------------------------------------------------------
//
//  Member:     CGroupPolicyNetworkLocationAwareness::LookupServiceBegin
//
//  Purpose:    Wraps the WSA function using our class members.
//
//  Arguments:
//      DWORD dwControlFlags [in] WSA Control Flags
//
//  Returns:    HRESULT indicating success/failure.
//
//  Author:     sjkhan   20 Feb 2001
//
//  Notes:
//
HRESULT CGroupPolicyNetworkLocationAwareness::LookupServiceBegin(IN DWORD dwControlFlags)
{
    TraceFileFunc(ttidGPNLA);

    HRESULT hr = S_OK;

    if (SOCKET_ERROR == WSALookupServiceBegin(&m_wqsRestrictions, dwControlFlags, &m_hQuery))
    {
        int nError;

        nError = WSAGetLastError();

        hr = HRESULT_FROM_WIN32(nError);

        TraceError("WSALookupServiceBegin() failed", hr);

        m_hQuery = NULL;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CGroupPolicyNetworkLocationAwareness::LookupServiceNext
//
//  Purpose:    Wraps the WSA function using our class members.
//
//  Arguments:
//      DWORD dwControlFlags [in]           - WSA Control Flags
//      LPDWORD lpdwBufferLength [in/out]   - Buffer Length sent/required.
//      LPWSAQUERYSET lpqsResults [out]     - Actual Query Results.
//
//  Returns:    HRESULT indicating success/failure.
//
//  Author:     sjkhan   20 Feb 2001
//
//  Notes:
//
HRESULT CGroupPolicyNetworkLocationAwareness::LookupServiceNext(IN     DWORD dwControlFlags, 
                                                                IN OUT LPDWORD lpdwBufferLength, 
                                                                OUT    LPWSAQUERYSET lpqsResults)
{
    TraceFileFunc(ttidGPNLA);

    HRESULT hr = S_OK;
    int nError;

    INT nRet = WSALookupServiceNext(m_hQuery, dwControlFlags, lpdwBufferLength, lpqsResults);
    if (SOCKET_ERROR == nRet)
    {
        BOOL fTraceError;

        nError = WSAGetLastError();
        hr = HRESULT_FROM_WIN32(nError);

        fTraceError = (!lpqsResults || (hr == HRESULT_FROM_WIN32(WSA_E_NO_MORE))) ? TRUE : FALSE;

        TraceErrorOptional("LookupServiceNext", hr, fTraceError);
    }

    TraceTag(ttidGPNLA, "LookupServiceNext terminated with %x", nRet);

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CGroupPolicyNetworkLocationAwareness::LookupServiceEnd
//
//  Purpose:    Wraps the WSA function using our class members.
//
//  Arguments:
//      (none)
//
//  Returns:    HRESULT indicating success/failure.
//
//  Author:     sjkhan   20 Feb 2001
//
//  Notes:
//
HRESULT CGroupPolicyNetworkLocationAwareness::LookupServiceEnd()
{
    TraceFileFunc(ttidGPNLA);

    HRESULT hr = S_OK;
    int nError;

    if (SOCKET_ERROR == WSALookupServiceEnd(m_hQuery))
    {
        nError = WSAGetLastError();
        hr = HRESULT_FROM_WIN32(nError);
    }
    
    m_hQuery = NULL;

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CGroupPolicyNetworkLocationAwareness::QueueEvent
//
//  Purpose:    Queue's an event to notify netshell of a change.
//
//  Arguments:
//      CONMAN_EVENTTYPE cmEventType [in]   - Type of Event.
//      LPGUID pguidAdapter [in]            - Guid for the adapter.
//      NETCON_STATUS ncsStatus [in]        - Status for Connection.
//
//  Returns:    HRESULT.
//
//  Author:     sjkhan   20 Feb 2001
//
//  Notes:
//
HRESULT CGroupPolicyNetworkLocationAwareness::QueueEvent(IN CONMAN_EVENTTYPE cmEventType, 
                                                         IN LPCGUID          pguidAdapter, 
                                                         IN NETCON_STATUS    ncsStatus)
{
    TraceFileFunc(ttidGPNLA);

    HRESULT hr = S_OK;

    if ( (CONNECTION_STATUS_CHANGE == cmEventType) ||
         (CONNECTION_ADDRESS_CHANGE == cmEventType) )
    {
        CONMAN_EVENT* pEvent = new CONMAN_EVENT;

        if (pEvent)
        {
            ZeroMemory(pEvent, sizeof(CONMAN_EVENT));
            pEvent->Type = cmEventType;
            pEvent->guidId = *pguidAdapter;
            pEvent->Status = ncsStatus;
            pEvent->ConnectionManager = CONMAN_LAN;
            
            if (NCS_HARDWARE_NOT_PRESENT == ncsStatus) // Not too useful for LAN connections. We can delete the device instead.
            {                                          
                // This will happen during PnP undock.
                TraceTag(ttidGPNLA, "Sending delete for NCS_HARDWARE_NOT_PRESENT instead");
                pEvent->Type = CONNECTION_DELETED;
            }

            if (!QueueUserWorkItemInThread(LanEventWorkItem, pEvent, EVENTMGR_CONMAN))
            {
                FreeConmanEvent(pEvent);
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CGroupPolicyNetworkLocationAwareness::QueueEvent");

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CGroupPolicyNetworkLocationAwareness::EnumChanges
//
//  Purpose:    Enumerates all the changes that have occurred to the network.
//
//  Arguments:
//      (none)
//
//  Returns:    HRESULT indicating success or failure.
//
//  Author:     sjkhan   20 Feb 2001
//
//  Notes:      This will re-increment the reference count if m_fShutdown is not set.
//              Doesn't allow it to go to Zero though.
//
HRESULT CGroupPolicyNetworkLocationAwareness::EnumChanges()
{
    TraceFileFunc(ttidGPNLA);

    HRESULT hr = S_OK;
    BOOL fRet = FALSE;
    BOOL fNoNetwork = TRUE;
    BOOL fNetworkMatch = FALSE;
    PWSAQUERYSET wqsResult = NULL;
    DWORD dwLen;
    WCHAR pszName[256] = {0};
    DWORD dwSize = 256;

    TraceTag(ttidGPNLA, "Entering EnumChanges");

    BOOL bDomainMember = IsJoinedToDomain();

    if (!m_hQuery)
    {
        // For some reason we didn't get this ealier.
        // Possibly TCP/IP wasn't installed.  We can add this now and
        // it will have the desired effect.
        LookupServiceBegin(LUP_NOCONTAINERS);
    }

    if (!m_hQuery)
    {
        return E_UNEXPECTED;
    }

    while (fRet == FALSE) 
    {
        dwLen = 0;
        // Do call twice, first to get dwSize of buffer for second call
        hr = LookupServiceNext(0, &dwLen, NULL);
        if (FAILED(hr) && hr != HRESULT_FROM_WIN32(WSA_E_NO_MORE) && hr != HRESULT_FROM_WIN32(WSAEFAULT)) 
        {
            TraceError("LookupServiceNext", hr);
            fRet = FALSE;
            break;
        }

        wqsResult = reinterpret_cast<PWSAQUERYSET>(new BYTE[dwLen]);

        if (!wqsResult) 
        {
            hr = HrFromLastWin32Error();
            TraceError("Error: malloc() failed", hr);
            fRet = TRUE;
            break;
        }
                                   
        if (S_OK == (hr = LookupServiceNext(0, &dwLen, wqsResult)))
        {
            fNoNetwork = FALSE;
            if (wqsResult->lpBlob != NULL) 
            {
                NLA_BLOB *blob = reinterpret_cast<NLA_BLOB *>(wqsResult->lpBlob->pBlobData);
                int next;
                do 
                {
                    // We are looking for the blob containing the network GUID
                    if (blob->header.type == NLA_INTERFACE)
                    {
                        WCHAR strAdapter[MAX_PATH];
                        DWORD dwErr;

                        ZeroMemory(strAdapter, MAX_PATH * sizeof(WCHAR));

                        lstrcpynW(strAdapter, wqsResult->lpszServiceInstanceName, celems(strAdapter));

                        // Get the network Name. We ignore failure since we still need to know other details.
                        dwErr = GetGroupPolicyNetworkName(pszName, &dwSize);

                        // matching pszName and interface type is ATM/LAN etc, but not RAS
                        if(blob->data.interfaceData.dwType != IF_TYPE_PPP && blob->data.interfaceData.dwType != IF_TYPE_SLIP)
                        {
                            CExceptionSafeLock esLock(&m_csList);   // Protecting list
                            
                            GUID guidAdapter;
                            WCHAR strAdapterGuid[39];
                            GPNLAPAIR nlapair;
                            GPNLAITER iter;
                            NETCON_STATUS ncsStatus;
                            
                            ZeroMemory(strAdapterGuid, 39 * sizeof(WCHAR));
                            
                            TraceTag(ttidGPNLA, "AdapterName: %s", blob->data.interfaceData.adapterName);

                            mbstowcs(strAdapterGuid, blob->data.interfaceData.adapterName, 39);

                            CLSIDFromString(strAdapterGuid, &guidAdapter);

                            nlapair.first = guidAdapter;

                            iter = find(m_listAdapters.begin(), m_listAdapters.end(), nlapair);

                            if (iter == m_listAdapters.end())
                            {
                                // We didn't find the adapter in the list that we currently have.
                                // So we need to add it to the list.
                                hr = HrGetPnpDeviceStatus(&guidAdapter, &ncsStatus);
    
                                nlapair.second.strNetworkName = strAdapter;
                                nlapair.second.ncsStatus = ncsStatus;

                                if (SUCCEEDED(hr))
                                {
                                    // If we got a valid status, we go ahead and add the adapter to
                                    // the list.
                                    m_listAdapters.insert(m_listAdapters.begin(), nlapair);
                                }

                                // Send the initial address status info:
                                QueueEvent(CONNECTION_STATUS_CHANGE,  &guidAdapter, ncsStatus);
                                QueueEvent(CONNECTION_ADDRESS_CHANGE, &guidAdapter, ncsStatus);
                            }
                            else
                            {
                                // We found the adapter, so update its status.
                                GPNLAPAIR& rnlapair = *iter;

                                if (rnlapair.second.strNetworkName != strAdapter)
                                {
                                    rnlapair.second.strNetworkName = strAdapter;
                                }

                                hr = HrGetPnpDeviceStatus(&guidAdapter, &ncsStatus);

                                if (SUCCEEDED(hr))
                                {
                                    if (ncsStatus != rnlapair.second.ncsStatus)
                                    {
                                        // The status is different so we need to send an event to the connections folder.
                                        rnlapair.second.ncsStatus = ncsStatus;
                                    }
        
                                    // [Deon] We need to always send this as we don't really know what the current
                                    // status of the adapter is. We only know the NLA part.
                                    // 
                                    // If we make the above check it could happen somebody else moves the address over
                                    // to NCS_INVALID_ADDRESS and then we don't send the NCS_CONNECTED once it changes.
                                    QueueEvent(CONNECTION_STATUS_CHANGE,  &guidAdapter, ncsStatus);
                                    QueueEvent(CONNECTION_ADDRESS_CHANGE, &guidAdapter, ncsStatus);
                                }
                            }

                            if (strAdapter != pszName)
                            {
                                // If this adapter is not on the same network, then we need to look at all others and
                                // ensure that at least 1 is on the same network from which the Group Policies came.
                                for (GPNLAITER iter = m_listAdapters.begin(); iter != m_listAdapters.end(); iter++)
                                {
                                    LPCSTR pStr = NULL;
                                    nlapair = *iter;

                                    TraceTag(ttidGPNLA,  "Network Name: %S", nlapair.second.strNetworkName.c_str());
                                    TraceTag(ttidGPNLA,  "Network Status: %s", DbgNcs(nlapair.second.ncsStatus));

                                    if (nlapair.second.strNetworkName == pszName)
                                    {
                                        // Yes, we're still on the network so we need to enforce group policies.
                                        fNetworkMatch = TRUE;
                                    }
                                }
                            }

                            if (fNetworkMatch)
                            {
                                break;
                            }
                        }
                    }
                    // There may be multiple blobs for each interface so make sure we find them all
                    next = blob->header.nextOffset;
                    blob = (NLA_BLOB *)(((char *)blob) + next);
                } while(next != 0);
            }
            else
            {
                TraceTag(ttidGPNLA, "Blob is NULL");
                fRet = TRUE;
            }

            free(wqsResult);
            wqsResult = NULL;
        } 
        else 
        {
            if (hr != HRESULT_FROM_WIN32(WSA_E_NO_MORE))
            {
                TraceError("LookupServiceNext failed\n", hr);
                fRet = FALSE;
            }
            free(wqsResult);
            break;
        }
    }

    BOOL fFireRefreshAll = FALSE;

    if (bDomainMember)
    {
        if (!fNoNetwork)
        {    // We have a Network
            if (fNetworkMatch) 
            {
                // Enforce Policies.
                if (!m_fSameNetwork)
                {   
                    // We are changing the network - we need to refresh all the connectoids in the folder to 
                    // update their icons to reflect policy.
                    fFireRefreshAll = TRUE; 
                    m_fSameNetwork  = TRUE;
                }

                TraceTag(ttidGPNLA, "Network Match");
            }
            else 
            {
                // Removed Policy Enforcement.
                if (m_fSameNetwork)
                {   
                    // We are changing the network - we need to refresh all the connectoids in the folder to 
                    // update their icons to reflect policy.
                    fFireRefreshAll = TRUE; 
                    m_fSameNetwork  = FALSE;
                }

                TraceTag(ttidGPNLA, "Network does not Match");
            }
            ReconfigureHomeNet();
        }
        else 
        {
            // No Networks so don't do anything.
        }
    } 
    else // Member of a workgroup
    {
        m_fSameNetwork = FALSE;
        ReconfigureHomeNet();
    }

    if (HRESULT_FROM_WIN32(WSA_E_NO_MORE) == hr)
    {
        hr = S_OK;
    }

    DWORD cbOutBuffer;

    if (!m_fShutdown)
    {
        Reference();

        // Wait for Network Change
        WSANSPIoctl(m_hQuery, SIO_NSP_NOTIFY_CHANGE,
                    NULL, 0, NULL, 0, &cbOutBuffer,
                    &m_wsaCompletion);

        if (fFireRefreshAll)
        {
            LanEventNotify (REFRESH_ALL, NULL, NULL, NULL);
        }
    }

    TraceTag(ttidGPNLA, "Exiting EnumChanges");

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CGroupPolicyNetworkLocationAwareness::EventHandler
//
//  Purpose:    Called when NLA changes occur.
//
//  Arguments:
//      LPVOID  pContext    - generally the "this" pointer.
//      BOOLEAN fTimerFired - if this happened because of a timer or the event
//                            getting set.  Since we specify INFINITE, this is
//                            not going to get fired by the timer.
//  Returns:    nothing
//
//  Author:     sjkhan   20 Feb 2001
//
//  Notes:  static
//
VOID NTAPI CGroupPolicyNetworkLocationAwareness::EventHandler(IN LPVOID pContext, IN BOOLEAN fTimerFired) throw()
{
    TraceFileFunc(ttidGPNLA);

    CGroupPolicyNetworkLocationAwareness* pGPNLA = reinterpret_cast<CGroupPolicyNetworkLocationAwareness*>(pContext);

    DWORD dwBytes;
    
    BOOL bSucceeded = GetOverlappedResult(pGPNLA->m_hQuery, &pGPNLA->m_wsaOverlapped, &dwBytes, FALSE);
    
    if (!bSucceeded)
    {
        TraceError("GetOverlappedResult failed", HrFromLastWin32Error());
    }

    if (FALSE == fTimerFired && !pGPNLA->m_fShutdown && bSucceeded)
    {
        pGPNLA->EnumChanges();
    }
    
    pGPNLA->Unreference();

    if (!bSucceeded)
    {
        pGPNLA->m_fErrorShutdown = TRUE;

        QueueUserWorkItem(ShutdownNlaHandler, pContext, WT_EXECUTEINLONGTHREAD);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CGroupPolicyNetworkLocationAwareness::GroupPolicyChange
//
//  Purpose:    Called when Machine Group Policy changes occur.
//
//  Arguments:
//      LPVOID  pContext    - generally the "this" pointer.
//      BOOLEAN fTimerFired - if this happened because of a timer or the event
//                            getting set.  Since we specify INFINITE, this is
//                            not going to get fired by the timer.
//  Returns:    nothing
//
//  Author:     sjkhan   05 Feb 2002
//
//  Notes:
//
VOID NTAPI CGroupPolicyNetworkLocationAwareness::GroupPolicyChange(IN LPVOID pContext, IN BOOLEAN fTimerFired)
{
    TraceFileFunc(ttidGPNLA);

    TraceTag(ttidGPNLA, "GroupPolicyChange called");
    ReconfigureHomeNet(TRUE);
    LanEventNotify(REFRESH_ALL, NULL, NULL, NULL);
}

//+---------------------------------------------------------------------------
//
//  Member:     CGroupPolicyNetworkLocationAwareness::ShutdownNlaHandler
//
//  Purpose:    Shutdown Nla handler, because Nla service is toast.
//
//  Arguments:
//              pVoid [in]  The CGroupPolicyNetworkLocationAwareness context
//
//  Returns:    nothing
//
//  Author:     sjkhan   05 Feb 2002
//
//  Notes:  static
//
DWORD WINAPI CGroupPolicyNetworkLocationAwareness::ShutdownNlaHandler(IN PVOID pThis)
{
    TraceFileFunc(ttidGPNLA);

    CGroupPolicyNetworkLocationAwareness* pGPNLA = 
        reinterpret_cast<CGroupPolicyNetworkLocationAwareness*>(InterlockedExchangePointer( (PVOID volatile *) &g_pGPNLA, NULL));
    
    if (pGPNLA)
    {
        Assert(pGPNLA == pThis); // Making the assumption that the context is always g_pGPNLA, since I'm clearing g_pGPNLA.

        pGPNLA->Uninitialize();
        delete pGPNLA;
    }

    return 0;

}

//+---------------------------------------------------------------------------
//
//  Function:   CGroupPolicyNetworkLocationAwareness::ReconfigureHomeNet
//
//  Purpose:    Change Homenet Configuration
//
//  Arguments:
//      (none)
//
//  Returns:    HRESULT indicating success of failure
//
//  Author:     sjkhan   09 Dec 2000
//
//  Notes:      
//              
//              
//              
//
HRESULT CGroupPolicyNetworkLocationAwareness::ReconfigureHomeNet(BOOL fWaitUntilRunningOrStopped)
{
    TraceFileFunc(ttidGPNLA);

    SC_HANDLE hscManager;
    SC_HANDLE hService;
    SERVICE_STATUS ServiceStatus;

    if (0 != InterlockedExchange(&m_lBusyWithReconfigure, 1L))
    {
        return S_FALSE;
    }

    TraceTag(ttidGPNLA, "Entering ReconfigureHomeNet");
    hscManager = OpenSCManager(NULL, SERVICES_ACTIVE_DATABASE, SC_MANAGER_CONNECT | SC_MANAGER_ENUMERATE_SERVICE);

    if (hscManager)
    {
        TraceTag(ttidGPNLA, "Attempting to open service");
        hService = OpenService(hscManager, c_szHomenetService, SERVICE_QUERY_STATUS | SERVICE_USER_DEFINED_CONTROL);
        if (hService)
        {
            DWORD dwCount = 0; 
            SERVICE_STATUS SvcStatus = {0};
            BOOL fRet;

            if (fWaitUntilRunningOrStopped)
            {
                do
                {
                    if (!QueryServiceStatus(hService, &SvcStatus))
                    {
                        break;
                    }
                    if (SERVICE_START_PENDING == SvcStatus.dwCurrentState)
                    {
                        TraceTag(ttidGPNLA, "Service is still starting.  Waiting 5 seconds.");
                        Sleep(5000);  // Sleep 5 seconds;
                    }
                } while ((SERVICE_START_PENDING == SvcStatus.dwCurrentState) && ++dwCount <= 6);
            }
            if (!fWaitUntilRunningOrStopped || (SERVICE_RUNNING == SvcStatus.dwCurrentState))
            {
                fRet = ControlService(hService, IPNATHLP_CONTROL_UPDATE_POLICY, &ServiceStatus);
                if (!fRet)
                {
                    DWORD dwErr = GetLastError();
                    TraceError("Error sending IPNATHLP_CONTROL_UPDATE_POLICY to SharedAccess service", HRESULT_FROM_WIN32(dwErr));
                }
                else
                {
                    TraceTag(ttidGPNLA, "Requested Reconfiguration check from ICF/ICS");
                }
            }
            CloseServiceHandle(hService);
        }
        else
        {
            TraceTag(ttidGPNLA, "Could not open service");
        }

        CloseServiceHandle(hscManager);
    }
    
    TraceTag(ttidGPNLA, "Leaving ReconfigureHomeNet");

    InterlockedExchange(&m_lBusyWithReconfigure, 0L);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netman\conman\eventq.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       E V E N T Q  . C P P
//
//  Contents:   Event Queue for managing synchonization of external events.
//
//  Notes:      
//
//  Author:     ckotze   29 Nov 2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "cmevent.h"
#include "eventq.h"
#include "ncmisc.h"
#include "conman.h"
#include "nceh.h"

//+---------------------------------------------------------------------------
//
//  Function:   Constructor for CEventQueue
//
//  Purpose:    Creates the various synchronization objects required for the
//              Queue
//  Arguments:
//      HANDLE hServiceShutdown [in] 
//                 Event to set when shutting down queue.
//
//
//  Returns:    nothing.
//
//  Author:     ckotze   30 Nov 2000
//
//  Notes:      
//
//
//
CEventQueue::CEventQueue(HANDLE hServiceShutdown) throw(HRESULT) :
    m_hServiceShutdown(0), m_pFireEvents(NULL), m_hWait(0), m_fRefreshAllInQueue(FALSE)
{
    TraceFileFunc(ttidEvents);
    NTSTATUS Status;

    try
    {
        Status = DuplicateHandle(GetCurrentProcess(), hServiceShutdown, GetCurrentProcess(), &m_hServiceShutdown, NULL, FALSE, DUPLICATE_SAME_ACCESS);
        if (!Status)
        {
            TraceTag(ttidEvents, "Couldn't Duplicate handle!");
            throw HRESULT_FROM_WIN32(Status);
        }
    
        HANDLE hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        m_pFireEvents = new CEvent(hEvent);
        if (!m_pFireEvents)
        {
            throw E_OUTOFMEMORY;
        }

        Status = RtlRegisterWait(&m_hWait, hEvent, (WAITORTIMERCALLBACKFUNC) DispatchEvents, NULL, INFINITE, WT_EXECUTEDEFAULT);
        if (!NT_SUCCESS(Status))
        {
            throw HRESULT_FROM_WIN32(Status);
        }

        TraceTag(ttidEvents, "RtlRegisterWait Succeeded");
        InitializeCriticalSection(&m_csQueue);
    }
    catch (HRESULT &hr)
    {
        TraceError("Out of memory", hr);
        if (m_hWait && NT_SUCCESS(Status))
        {
            RtlDeregisterWaitEx(m_hWait, INVALID_HANDLE_VALUE);
        }
        // ISSUE: If CreateEvent succeeds and new CEvent fails, we're not freeing the hEvent.
        if (m_pFireEvents)
        {
            delete m_pFireEvents;
        }
        if (m_hServiceShutdown)
        {
            CloseHandle(m_hServiceShutdown);
        }
        throw;
    }
    catch (SE_Exception &e)
    {
        TraceError("An exception occurred", HRESULT_FROM_WIN32(e.getSeNumber()) );

        if (m_hWait && NT_SUCCESS(Status))
        {
            RtlDeregisterWaitEx(m_hWait, INVALID_HANDLE_VALUE);
        }
        // ISSUE: If CreateEvent succeeds and new CEvent fails, we're not freeing the hEvent.
        if (m_pFireEvents)
        {
            delete m_pFireEvents;
        }
        if (m_hServiceShutdown)
        {
            CloseHandle(m_hServiceShutdown);
        }
        throw E_UNEXPECTED;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   Destructor for CEventQueue
//
//  Purpose:    Empties the queue and frees all existing items in the queue.
//
//  Arguments:
//      
//      
//
//
//  Returns:    nothing.
//
//  Author:     ckotze   30 Nov 2000
//
//  Notes:      
//
//
//
CEventQueue::~CEventQueue() throw()
{
    TraceFileFunc(ttidEvents);

    NTSTATUS Status;

    // Blocks until all outstanding threads return.
    Status = RtlDeregisterWaitEx(m_hWait, INVALID_HANDLE_VALUE);
    TraceError("RtlDeregisterWaitEx", HRESULT_FROM_WIN32(Status));

    if (TryEnterCriticalSection(&m_csQueue))
    {
        // This is okay.
        LeaveCriticalSection(&m_csQueue);
    }
    else
    {
        AssertSz(FALSE, "Another thread is still holding onto this critical section. This is unexpected at this point.");
    }

    DeleteCriticalSection(&m_csQueue);

    while (!m_eqWorkItems.empty())
    {
        USERWORKITEM UserWorkItem;

        UserWorkItem = m_eqWorkItems.front();
        m_eqWorkItems.pop_front();

        if (UserWorkItem.EventMgr == EVENTMGR_CONMAN)
        {
            FreeConmanEvent(UserWorkItem.Event);
        }
    }

    delete m_pFireEvents;
    CloseHandle(m_hServiceShutdown);
}

//+---------------------------------------------------------------------------
//
//  Function:   EnqueueEvent
//
//  Purpose:    Stores the new event in the Event Queue
//
//  Arguments:
//      Function - The pointer to the function to be called when firing the 
//                 event
//      pEvent   - The Event information
//      EventMgr - Which event manager the event should go to.
//
//  Returns:    HRESULT
//              S_OK            -   Event has been added and Event code is
//                                  already dispatching events
//              S_FALSE         -   Event has been added to Queue, but a 
//                                  thread needs to be scheduled to fire 
//                                  the events
//              E_OUTOFMEMORY   -   Unable to add the event to the Queue.
//
//  Author:     ckotze   30 Nov 2000
//
//  Notes:      Locks and Unlocks the critical section only while working 
//              with the queue
//              
//
HRESULT CEventQueue::EnqueueEvent(IN               PCONMAN_EVENTTHREAD  Function, 
                                  IN TAKEOWNERSHIP CONMAN_EVENT*        pEvent, 
                                  IN               const EVENT_MANAGER  EventMgr)
{
    TraceFileFunc(ttidEvents);

    CExceptionSafeLock esLock(&m_csQueue);
    USERWORKITEM UserWorkItem;
    HRESULT hr = S_OK;

    if (!Function)
    {
        return E_POINTER;
    }

    if (!pEvent)
    {
        return E_POINTER;
    }

    UserWorkItem.Function = Function;
    UserWorkItem.Event    = pEvent;
    UserWorkItem.EventMgr = EventMgr;

    if (EVENTMGR_CONMAN == EventMgr)
    {
        if (REFRESH_ALL == pEvent->Type)
        {
            if (!m_fRefreshAllInQueue)
            {
                m_fRefreshAllInQueue = TRUE;
            }
            else
            {
                FreeConmanEvent(pEvent);
                return S_OK;
            }
        }
    } 

#ifdef DBG
    char pchErrorText[MAX_PATH];

    Assert(UserWorkItem.EventMgr);

    if (EVENTMGR_CONMAN == UserWorkItem.EventMgr)
    {
        TraceTag(ttidEvents, "EnqueueEvent received Event: %s (currently %d in queue). Event Manager: CONMAN", DbgEvents(pEvent->Type), m_eqWorkItems.size());

        sprintf(pchErrorText, "Invalid Type %d specified in Event structure\r\n", pEvent->Type);

        AssertSz(IsValidEventType(UserWorkItem.EventMgr, pEvent->Type), pchErrorText);
    }
    else
    {
        sprintf(pchErrorText, "Invalid Event Manager %d specified in Event structure\r\n", EventMgr);
        AssertSz(FALSE, pchErrorText);
    }

#endif

    try
    {
        m_eqWorkItems.push_back(UserWorkItem);
        m_pFireEvents->SetEvent();
    }
    catch (bad_alloc)
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   DequeueEvent
//
//  Purpose:    Retrieves the next event in the Event Queue
//
//  Arguments:
//      Function - The pointer to the function to be called when firing the 
//                 event
//      Event    - The Event information. Free with delete
//      EventMgr - Which event manager the event should go to.
//
//  Returns:    HRESULT
//
//  Author:     ckotze   30 Nov 2000
//
//  Notes:      Locks and Unlocks the critical section only while working 
//              with the queue
//
//
HRESULT CEventQueue::DequeueEvent(OUT               PCONMAN_EVENTTHREAD& Function, 
                                  OUT TAKEOWNERSHIP CONMAN_EVENT*&       pEvent, 
                                  OUT               EVENT_MANAGER&       EventMgr)
{
    TraceFileFunc(ttidEvents);
    
    CExceptionSafeLock esLock(&m_csQueue);
    USERWORKITEM UserWorkItem;
    DWORD dwSize = m_eqWorkItems.size();

    if (!dwSize)
    {
        AssertSz(FALSE, "Calling DequeueEvent with 0 items in Queue!!!");
        return E_UNEXPECTED;
    }

    UserWorkItem = m_eqWorkItems.front();
    m_eqWorkItems.pop_front();

    Function = UserWorkItem.Function;
    pEvent   = UserWorkItem.Event;
    EventMgr = UserWorkItem.EventMgr;

    if (EVENTMGR_CONMAN == EventMgr)
    {
        if (REFRESH_ALL == pEvent->Type)
        {
            m_fRefreshAllInQueue = FALSE;
        }
    } 


#ifdef DBG
    char pchErrorText[MAX_PATH];

    Assert(EventMgr);

    if (EVENTMGR_CONMAN == EventMgr)
    {
        TraceTag(ttidEvents, "DequeueEvent retrieved Event: %s (%d left in queue). Event Manager: CONMAN", DbgEvents(pEvent->Type), m_eqWorkItems.size());

        sprintf(pchErrorText, "Invalid Type %d specified in Event structure\r\nItems in Queue: %d\r\n", pEvent->Type, dwSize);

        AssertSz(IsValidEventType(EventMgr, pEvent->Type), pchErrorText);
    }
    else
    {
        sprintf(pchErrorText, "Invalid Event Manager %d specified in Event structure\r\n", EventMgr);
        AssertSz(FALSE, pchErrorText);
    }
#endif


    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   WaitForExit
//
//  Purpose:    Waits for the queue to exit.
//
//  Arguments:
//      (none)
//
//  Returns:    WAIT_OBJECT_0 or failure code.
//
//  Author:     ckotze   28 Apr 2001
//
//  Notes:      
//              
//
DWORD CEventQueue::WaitForExit() throw()
{
    TraceFileFunc(ttidEvents);
    return WaitForSingleObject(m_hServiceShutdown, INFINITE);
}

//+---------------------------------------------------------------------------
//
//  Function:   size
//
//  Purpose:    Returns the Number of items in the queue
//
//  Arguments:
//      (none)
//
//  Returns:    Number of items in the queue
//
//  Author:     ckotze   30 Nov 2000
//
//  Notes:      
//              
//
size_t CEventQueue::size() throw()
{
    CExceptionSafeLock esLock(&m_csQueue);
    TraceFileFunc(ttidEvents);
    size_t tempsize;

    tempsize = m_eqWorkItems.size();

    return tempsize;
}

//+---------------------------------------------------------------------------
//
//  Function:   AtomCheckSizeAndResetEvent
//
//  Purpose:    Make sure we know when we're supposed to exit, lock during the
//              operation.
//  Arguments:
//              fDispatchEvents [in] Should be dispatching more events.
//
//  Returns:    TRUE if should exit thread.  FALSE if more events in queue, or
//              service is not shutting down.
//  Author:     ckotze   04 March 2001
//
//  Notes:      
//              
//
BOOL CEventQueue::AtomCheckSizeAndResetEvent(IN const BOOL fDispatchEvents) throw()
{
    TraceFileFunc(ttidEvents);

    CExceptionSafeLock esLock(&m_csQueue);
    BOOL fRet = TRUE;

    TraceTag(ttidEvents, "Checking for Exit Conditions, Events in queue: %d, Service Shutting Down: %s", size(), (fDispatchEvents) ? "FALSE" : "TRUE");

    if (m_eqWorkItems.empty() || !fDispatchEvents)
    {
        fRet = FALSE;
        if (fDispatchEvents)
        {
            m_pFireEvents->ResetEvent();
        }
        else
        {
            SetEvent(m_hServiceShutdown);
        }
    }
    return fRet;
}

//  CEvent is a Hybrid between Automatic and Manual reset events.
//  It is automatically reset, but we control when it is set so it
//  doesn't spawn threads while set, except for the first one.

CEvent::CEvent(IN HANDLE hEvent) throw()
{
    m_hEvent = hEvent;
    m_bSignaled = FALSE;
}

CEvent::~CEvent() throw()
{
    CloseHandle(m_hEvent);
}

HRESULT CEvent::SetEvent()
{
    HRESULT hr = S_OK;

    if (!m_bSignaled)
    {
        if (!::SetEvent(m_hEvent))
        {
            hr = HrFromLastWin32Error();
        }
        else
        {
            m_bSignaled = TRUE;
        }
    }
    return hr;
}

HRESULT CEvent::ResetEvent()
{
    HRESULT hr = S_OK;

    Assert(m_bSignaled);

    m_bSignaled = FALSE;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netman\dll\dllmain.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       D L L M A I N . C P P
//
//  Contents:   DLL entry points for netman.dll
//
//  Notes:
//
//  Author:     shaunco   3 Apr 1998
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "nmbase.h"
#include "nmres.h"
#include "ncreg.h"
#include "nceh.h"

#define INITGUID
#include "nmclsid.h"
#include "..\conman\conman.h"

//+---------------------------------------------------------------------------
// DLL Entry Point
//
EXTERN_C
BOOL
WINAPI
DllMain (
    IN          HINSTANCE   hinst,
    IN          DWORD       dwReason,
    IN WACKYAPI LPVOID      pvReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
#ifndef DBG
        DisableThreadLibraryCalls (hinst);
#endif
        EnableCPPExceptionHandling();

        InitializeDebugging();
        _Module.DllProcessAttach (hinst);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        DbgCheckPrematureDllUnload ("netman.dll", _Module.GetLockCount());
        _Module.DllProcessDetach ();
        UnInitializeDebugging();

        DisableCPPExceptionHandling(); // Disable translation of SEH exceptions into CPP exceptions.
    }
#ifdef DBG
    else if (dwReason == DLL_THREAD_DETACH)
    {
        CTracingIndent::FreeThreadInfo();        
    }
#endif
    return TRUE;
}

//+---------------------------------------------------------------------------
// ServiceMain - Called by the generic service process when starting
//                this service.
//
// type of LPSERVICE_MAIN_FUNCTIONW
//
EXTERN_C
VOID
WINAPI
ServiceMain (
    DWORD     argc,
    LPCWSTR   argv[])
{
    _Module.ServiceMain (argc, argv);
}

//SD for netman
const BYTE sdNetmanLaunchPermission[] = {
  01,0x00,0x04,0x80,0x70,0x00,0x00,0x00,0x8c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x14,0x00,
  00,0x00,0x02,0x00,0x5c,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x18,0x00,0x01,0x00,0x00,0x00,0x01,0x02,0x00,0x00,0x00,0x00,0x00,
  05,0x20,0x00,0x00,0x00,0x20,0x02,0x00,0x00,0x00,0x00,0x14,0x00,0x01,0x00,0x00,0x00,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x05,
  04,0x00,0x00,0x00,0x00,0x00,0x14,0x00,0x01,0x00,0x00,0x00,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x05,0x14,0x00,0x00,0x00,0x00,
  00,0x14,0x00,0x01,0x00,0x00,0x00,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x05,0x12,0x00,0x00,0x00,0x01,0x05,0x00,0x00,0x00,0x00,
  00,0x05,0x15,0x00,0x00,0x00,0xa0,0x5f,0x84,0x1f,0x5e,0x2e,0x6b,0x49,0xce,0x12,0x03,0x03,0xf4,0x01,0x00,0x00,0x01,0x05,0x00,
  00,0x00,0x00,0x00,0x05,0x15,0x00,0x00,0x00,0xa0,0x5f,0x84,0x1f,0x5e,0x2e,0x6b,0x49,0xce,0x12,0x03,0x03,0xf4,0x01,0x00,0x00
};

const static WCHAR c_szNetmanAppId[] = L"AppId\\{27AF75ED-20D9-11D1-B1CE-00805FC1270E}";
const static WCHAR c_szLaunchPermission[] = L"LaunchPermission";

//+---------------------------------------------------------------------------
// DllRegisterServer - Adds entries to the system registry
//
STDAPI
DllRegisterServer ()
{
    BOOL    fCoUninitialize = TRUE;

    HRESULT hr = CoInitializeEx (NULL,
                    COINIT_DISABLE_OLE1DDE | COINIT_APARTMENTTHREADED);
    if (FAILED(hr))
    {
        fCoUninitialize = FALSE;
        if (RPC_E_CHANGED_MODE == hr)
        {
            hr = S_OK;
        }
    }

    if (SUCCEEDED(hr))
    {
        hr = _Module.UpdateRegistryFromResource (IDR_NETMAN, TRUE);
        if (SUCCEEDED(hr))
        {
            HKEY hkNetmanAppId = NULL;
            hr = HrRegOpenKeyEx(HKEY_CLASSES_ROOT, c_szNetmanAppId, KEY_WRITE, &hkNetmanAppId);

            if (SUCCEEDED(hr))
            {
                HrRegSetBinary(hkNetmanAppId, c_szLaunchPermission, sdNetmanLaunchPermission, sizeof(sdNetmanLaunchPermission));
                if (SUCCEEDED(hr))
                {
                    hr = NcAtlModuleRegisterServer (&_Module);

                    if (fCoUninitialize)
                    {
                        CoUninitialize ();
                    }
                }
                RegCloseKey(hkNetmanAppId);
            }
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE, "netman!DllRegisterServer");
    return hr;
}

//+---------------------------------------------------------------------------
// DllUnregisterServer - Removes entries from the system registry
//
STDAPI
DllUnregisterServer ()
{
    _Module.UpdateRegistryFromResource (IDR_NETMAN, FALSE);

    _Module.UnregisterServer ();

    return S_OK;
}

HRESULT
GetClientAdvises(OUT LPWSTR** pppszAdviseUsers, OUT LPDWORD pdwCount)
{
    HRESULT hr = S_OK;

    if ( (!pppszAdviseUsers) || (!pdwCount) )
    {
        return E_POINTER;
    }

    CConnectionManager *pConMan = const_cast<CConnectionManager*>(CConnectionManager::g_pConMan);
    if (!pConMan)
    {
        return E_UNEXPECTED;
    }

    DWORD dwTotalLength = 0;
    DWORD dwNumItems    = 0;

    list<tstring> NameList;
    pConMan->g_fInUse = TRUE;
    pConMan->Lock();
    for (ITERUSERNOTIFYMAP iter = pConMan->m_mapNotify.begin(); iter != pConMan->m_mapNotify.end(); iter++)
    {
        tstring szName = iter->second->szUserName;

        NameList.push_back(szName);
        dwTotalLength += sizeof(WCHAR) * (szName.length() + 1);
        dwNumItems++;
    }
    pConMan->Unlock();
    pConMan->g_fInUse = FALSE;

    if (!dwNumItems)
    {
        *pppszAdviseUsers = NULL;
        *pdwCount = 0;
        return S_FALSE;
    }

    DWORD dwAllocSize = dwNumItems * sizeof(LPCWSTR) + dwTotalLength;
    *pppszAdviseUsers = reinterpret_cast<LPWSTR *>(CoTaskMemAlloc(dwAllocSize));
    if (!*pppszAdviseUsers)
    {
        return E_OUTOFMEMORY;
    }

    LPWSTR  pszEndString     = reinterpret_cast<LPWSTR>(reinterpret_cast<LPBYTE>(*pppszAdviseUsers) + dwAllocSize);

    // First string in the structure
    LPWSTR  pszCurrentString = reinterpret_cast<LPWSTR>(reinterpret_cast<LPBYTE>(*pppszAdviseUsers) + (sizeof(LPWSTR) * dwNumItems));
    // First pointer in the structure
    LPWSTR* lppArray         = *pppszAdviseUsers;

    for (list<tstring>::const_iterator iterName = NameList.begin(); iterName != NameList.end(); iterName++)
    {
        *lppArray = pszCurrentString;
        wcscpy(pszCurrentString, iterName->c_str());

        lppArray++;
        pszCurrentString += (iterName->size() + 1);
        Assert(pszCurrentString <= pszEndString);
    }

    *pdwCount = dwNumItems;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netman\conman\event.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       E V E N T . C P P
//
//  Contents:   Interface between external events that effect connections.
//
//  Notes:
//
//  Author:     shaunco   21 Aug 1998
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include <winsock2.h>
#include <mswsock.h>
#include <iphlpapi.h>
#include "nmbase.h"
#include "ncnetcon.h"
#include "conman.h"
#include <cmdefs.h>
#include "cmutil.h"
#include "eventq.h"
#include <userenv.h>
#include <userenvp.h>
#include "ncperms.h"
#include <ras.h>
#include <raserror.h>
#include <ncstl.h>
#include <algorithm>
#include <lancmn.h>
#include <ncreg.h>
#include "gpnla.h"
#include "cobase.h"
#include <mprapi.h>
#include <rasapip.h>
#include "ncras.h"
#include "wzcsvc.h"

#include "cmdirect.h"

// This LONG is incremented every time we get a notification that
// a RAS phonebook entry has been modified.  It is reset to zero
// when the service is started.  Wrap-around does not matter.  It's
// purpose is to let a RAS connection object know if it's cache should
// be re-populated with current information.
//
LONG g_lRasEntryModifiedVersionEra;

LONG g_cInRefreshAll;
const LONG MAX_IN_REFRESH_ALL = 5;

CEventQueue*    g_pEventQueue = NULL;
BOOL            g_fDispatchEvents = FALSE;
HANDLE          g_hEventWait = NULL;
HANDLE          g_hEventThread = NULL;
HANDLE          g_hQuery = NULL;
BOOL            g_fHandleIncomingEvents = FALSE;

CGroupPolicyNetworkLocationAwareness* g_pGPNLA = NULL;

//+---------------------------------------------------------------------------
//
//  Function:   FreeConmanEvent
//
//  Purpose:    Free the memory associated with a CONMAN_EVENT structure.
//
//  Arguments:
//      pEvent [in] The structure to free.
//
//  Returns:    nothing
//
//  Author:     shaunco   21 Aug 1998
//
//  Notes:
//
inline
VOID
FreeConmanEvent (
    IN TAKEOWNERSHIP CONMAN_EVENT* pEvent) throw()
{
    TraceFileFunc(ttidEvents);

    if (pEvent)
    {
        if (((CONNECTION_ADDED == pEvent->Type) ||
             (CONNECTION_MODIFIED == pEvent->Type)))
        {
            HRESULT hr = HrFreeNetConProperties2(pEvent->pPropsEx);
            TraceError("HrFreeNetConProperties2", hr);
        }

        if (CONNECTION_BALLOON_POPUP == pEvent->Type)
        {
            SysFreeString(pEvent->szCookie);
            SysFreeString(pEvent->szBalloonText);
        }

        MemFree(pEvent);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   RasEventWorkItem
//
//  Purpose:    The LPTHREAD_START_ROUTINE passed to QueueUserWorkItem to
//              handle the work of notifying connection manager clients
//              of the event.
//
//  Arguments:
//      pvContext [in] A pointer to a CONMAN_EVENT structure.
//
//  Returns:    NOERROR
//
//  Author:     sjkhan   21 Mar 2001
//
//  Notes:      This function calls Ras on a different thread than where the 
//              event came from so as not to cause a deadlock in Ras.
//              This call owns pvContext and frees it.
//
DWORD
WINAPI
RasEventWorkItem (
                IN TAKEOWNERSHIP CONMAN_EVENT* pEvent
                )
{
    TraceFileFunc(ttidEvents);

    BOOL fNotify;
    Assert (pEvent);
    
    if (SERVICE_RUNNING == _Module.DwServiceStatus ())
    {
        fNotify = TRUE;
        
        if (fNotify)
        {
            HRESULT hr = S_OK;
            RASENUMENTRYDETAILS Details;

            if (CONNECTION_ADDED == pEvent->Type || CONNECTION_MODIFIED == pEvent->Type)
            {
                // Clear out the details passed in from RAS and query RAS for the latest info.
                Details = pEvent->Details;
                ZeroMemory(&pEvent->Details, sizeof(RASENUMENTRYDETAILS));

                if (CONNECTION_ADDED == pEvent->Type)
                {
                    hr = HrGetRasConnectionProperties(&Details, &(pEvent->pPropsEx));
                }
                else if (CONNECTION_MODIFIED == pEvent->Type)
                {
                    hr = HrGetRasConnectionProperties(&Details, &(pEvent->pPropsEx));
                    TraceTag(ttidEvents, "Is Default Connection: %s", (NCCF_DEFAULT == (pEvent->pPropsEx->dwCharacter & NCCF_DEFAULT)) ? "Yes" : "No");
                    TraceTag(ttidEvents, "Should be Default Connection: %s", (Details.dwFlagsPriv & REED_F_Default) ? "Yes" : "No");
                }
            }
            if (SUCCEEDED(hr))
            {
                CConnectionManager::NotifyClientsOfEvent (pEvent);
            }
        }
    }

    FreeConmanEvent(pEvent);
    
    return NOERROR;
}


//+---------------------------------------------------------------------------
//
//  Function:   LanEventWorkItem
//
//  Purpose:    The LPTHREAD_START_ROUTINE passed to QueueUserWorkItem to
//              handle the work of notifying connection manager clients
//              of the event.
//
//  Arguments:
//      pvContext [in] A pointer to a CONMAN_EVENT structure.
//
//  Returns:    NOERROR
//
//  Author:     deonb   15 May 2001
//
//  Notes:      This function retreives a more up to do status from the NIC
//              and sends it to netshell
//
DWORD
WINAPI
LanEventWorkItem (
                IN TAKEOWNERSHIP CONMAN_EVENT* pEvent
                )
{
    TraceFileFunc(ttidEvents);

    BOOL fNotify;
    Assert (pEvent);
    Assert(CONMAN_LAN== pEvent->ConnectionManager);
    
    HRESULT hr = S_OK;
    RASENUMENTRYDETAILS Details;

    TraceTag(ttidEvents, "Refreshing connection status");

    GUID gdLanGuid = GUID_NULL;

    if ((CONNECTION_ADDED == pEvent->Type) || (CONNECTION_MODIFIED == pEvent->Type))
    {
        gdLanGuid = pEvent->pPropsEx->guidId;
    }

    if ((CONNECTION_STATUS_CHANGE == pEvent->Type) || (CONNECTION_ADDRESS_CHANGE == pEvent->Type) || (CONNECTION_DELETED == pEvent->Type))
    {
        gdLanGuid = pEvent->guidId;
    }


    Assert(GUID_NULL != gdLanGuid);
    if (GUID_NULL == gdLanGuid)
    {
        return E_INVALIDARG;
    }

#ifdef DBG
    NETCON_STATUS ncsPrior;
#endif
    NETCON_STATUS ncs;
    hr = HrGetPnpDeviceStatus(&gdLanGuid, &ncs);
    if (SUCCEEDED(hr))
    {
        // Get additional Status information from 802.1X
        //
        if ((NCS_CONNECTED == ncs) 
            || (NCS_INVALID_ADDRESS == ncs) 
            || (NCS_MEDIA_DISCONNECTED == ncs))
        {
            NETCON_STATUS ncsWZC = ncs;
            HRESULT hrT = WZCQueryGUIDNCSState(&gdLanGuid, &ncsWZC);
            if (S_OK == hrT)
            {
                ncs = ncsWZC;
            }

            TraceHr(ttidError, FAL, hrT, (S_FALSE == hrT), "LanEventWorkItem error in WZCQueryGUIDNCSState");
        }

        if ( (CONNECTION_ADDED == pEvent->Type) || (CONNECTION_MODIFIED == pEvent->Type))
        {
#ifdef DBG
            ncsPrior = pEvent->pPropsEx->ncStatus;
#endif
            pEvent->pPropsEx->ncStatus = ncs;
        }

        if (CONNECTION_STATUS_CHANGE == pEvent->Type)
        {
#ifdef DBG
            ncsPrior = pEvent->Status;
#endif
            if ( (NCS_HARDWARE_NOT_PRESENT == ncs) || 
                 (NCS_HARDWARE_MALFUNCTION == ncs) )
            {
                pEvent->Type = CONNECTION_DELETED;
                TraceTag(ttidEvents, "LanEventWorkItem changed EventType to CONNECTION_DELETED");
            }
            else
            {
                pEvent->Status = ncs;
            }
        }
    }

#ifdef DBG
    if (ncsPrior != ncs)
    {
        TraceTag(ttidEvents, "LanEventWorkItem overruled status: %s to %s", DbgNcs(ncsPrior), DbgNcs(ncs));
    }
#endif

    CConnectionManager::NotifyClientsOfEvent (pEvent);
    FreeConmanEvent(pEvent);
    
    TraceHr(ttidError, FAL, hr, FALSE, "LanEventWorkItem");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   IncomingEventWorkItem
//
//  Purpose:    The LPTHREAD_START_ROUTINE passed to QueueUserWorkItem to
//              handle the work of notifying connection manager clients
//              of the event.
//
//  Arguments:
//      pvContext [in] A pointer to a CONMAN_EVENT structure.
//
//  Returns:    NOERROR
//
//  Author:     sjkhan   21 Mar 2001
//
//  Notes:      This function calls Ras on a different thread than where the 
//              event came from so as not to cause a deadlock in Ras.
//              This call owns pvContext and frees it.
//
DWORD
WINAPI
IncomingEventWorkItem (
                  IN TAKEOWNERSHIP CONMAN_EVENT* pEvent
                  )
{
    TraceFileFunc(ttidEvents);

    BOOL fNotify;
    Assert (pEvent);
    
    if (SERVICE_RUNNING == _Module.DwServiceStatus ())
    {
        fNotify = TRUE;
        
        if (fNotify)
        {
            HRESULT hr = S_OK;
            
            if (CONNECTION_ADDED == pEvent->Type)
            {
                GUID guidId;
                guidId = pEvent->guidId;     // We need to store this because CONMAN_EVENT is a union and pProps occupies the same space as guidId.
                pEvent->guidId = GUID_NULL;  // We don't need this anymore so it's a good idea to clean it up, as pEvent is a union.
                hr = HrGetIncomingConnectionPropertiesEx(pEvent->hConnection, &guidId, pEvent->dwConnectionType, &pEvent->pPropsEx);
            }
            if (SUCCEEDED(hr))
            {
                CConnectionManager::NotifyClientsOfEvent (pEvent);
            }
        }
    }
    
    FreeConmanEvent(pEvent);
    
    return NOERROR;
}


//+---------------------------------------------------------------------------
//
//  Function:   ConmanEventWorkItem
//
//  Purpose:    The LPTHREAD_START_ROUTINE passed to QueueUserWorkItem to
//              handle the work of notifying connection manager clients
//              of the event.
//
//  Arguments:
//      pvContext [in] A pointer to a CONMAN_EVENT structure.
//
//  Returns:    NOERROR
//
//  Author:     shaunco   21 Aug 1998
//
//  Notes:      Ownership of the CONMAN_EVENT structure is given to this
//              function.  i.e. the structure is freed here.
//
DWORD
WINAPI
ConmanEventWorkItem (
    IN TAKEOWNERSHIP CONMAN_EVENT* pEvent
    )
{
    TraceFileFunc(ttidEvents);

    BOOL fIsRefreshAll;
    BOOL fNotify;
    Assert (pEvent);

    if (SERVICE_RUNNING == _Module.DwServiceStatus ())
    {
        fIsRefreshAll = (REFRESH_ALL == pEvent->Type);
        fNotify = TRUE;

        if (fIsRefreshAll)
        {
            // We'll deliver this refresh-all notification only if another
            // thread is not already delivering one.
            //
            fNotify = (InterlockedIncrement (&g_cInRefreshAll) < MAX_IN_REFRESH_ALL);
        }

        if (fNotify)
        {
            CConnectionManager::NotifyClientsOfEvent (pEvent);
        }

        // Reset our global flag if we were the single thread allowed to
        // deliver a refresh-all notification.
        //
        if (fIsRefreshAll)
        {
            if (InterlockedDecrement (&g_cInRefreshAll) < 0)
            {
                AssertSz (FALSE, "Mismatched Interlocked Increment/Decrement?");
                g_cInRefreshAll = 0;
            }
        }
    }

    FreeConmanEvent (pEvent);

    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Function:   LanEventNotify
//
//  Purpose:    To be called when a LAN adapter is added or removed.
//
//  Arguments:
//      EventType    [in] Type of the event
//      pConn        [in] The INetConnection (only for CONNECTION_ADDED, CONNECTION_MODIFIED)
//      pszNewName   [in] The name (for CONNECTION_RENAMED)
//      pguidConn    [in] The GUID of the connection (for CONNECTION_RENAMED)
//
//  Returns:    nothing
//
//  Author:     shaunco   2 Sep 1998
//
//  Notes:      The easy thing is done a full refresh is queued for the
//              connection manager to notify its clients of.
//
VOID
LanEventNotify (
    IN  CONMAN_EVENTTYPE    EventType,
    IN  INetConnection*     pConn,
    IN  PCWSTR              pszNewName,
    IN  const GUID *        pguidConn) throw()
{
    TraceFileFunc(ttidEvents);

    // Let's be sure we only do work if the service state is still running.
    // If we have a stop pending for example, we don't need to do anything.
    //
    if (SERVICE_RUNNING != _Module.DwServiceStatus ())
    {
        return;
    }

    // If the connection manager has no active connection points registered,
    // we don't need to do anything.
    //
    if (!CConnectionManager::FHasActiveConnectionPoints ())
    {
        return;
    }

    if ((REFRESH_ALL == EventType) && (g_cInRefreshAll >= MAX_IN_REFRESH_ALL))
    {
        return;
    }

    // Allocate a CONMAN_EVENT structure and initialize it from the
    // RASEVENT information.
    //
    CONMAN_EVENT* pEvent = (CONMAN_EVENT*)MemAlloc (sizeof(CONMAN_EVENT));
    if (!pEvent)
    {
        TraceTag (ttidEvents,
            "Failed to allocate a new work item in LanEventNotify.");
        return;
    }
    ZeroMemory (pEvent, sizeof(CONMAN_EVENT));
    pEvent->ConnectionManager = CONMAN_LAN;
    pEvent->Type = EventType;

    BOOL    fFreeEvent = TRUE;
    HRESULT hr = S_OK;

    if (pConn)
    {
        // pEvent->pProps is only valid for added and modified events.
        // So, we don't want to be getting properties for any other event.
        //
        AssertSz (
            (CONNECTION_ADDED == EventType) ||
            (CONNECTION_MODIFIED == EventType),
            "Why is pConn being passed for this event type?");

        hr = HrGetPropertiesExFromINetConnection(pConn, &pEvent->pPropsEx);
    }

    AssertSz(FImplies(EventType == CONNECTION_RENAMED, FIff(pszNewName,
                                                            !pConn)),
                      "szwNewName && pConn cannot be NULL or non-NULL at "
                      "the same time!");
    AssertSz(FIff(pszNewName, pguidConn), "szwNewName & pguidConn must both "
             "be NULL or non-NULL");

    if (EventType == CONNECTION_RENAMED)
    {
        AssertSz(pszNewName, "Rename event requires szwNewName to be "
                 "non-NULL");
        AssertSz(pguidConn, "Rename event requires pguidConn to be "
                 "non-NULL");

        // Copy in the right info into the event struct
        //
        pEvent->guidId = *pguidConn;
        lstrcpynW(pEvent->szNewName, pszNewName, celems(pEvent->szNewName));
    }

    if (S_OK == hr)
    {
        TraceTag (ttidEvents,
            "LanEventNotify: Queuing ConmanEventWorkItem (Type=%s)...",
            DbgEvents(pEvent->Type));

        // Queue a worker to deliver the event to the clients of the
        // connection manager with registered connection points.
        // We pass ownership of the structure to the worker thread which
        // will free it.  (Therefore, we don't want to free it.)
        //
        if (QueueUserWorkItemInThread (ConmanEventWorkItem,
                pEvent, EVENTMGR_CONMAN))
        {
            fFreeEvent = FALSE;
        }
        else
        {
            TraceTag (ttidEvents,
                "QueueUserWorkItem failed with error %d in LanEventNotify.",
                GetLastError ());
        }
    }

    if (fFreeEvent)
    {
        FreeConmanEvent (pEvent);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   FIsIgnorableCMEvent
//
//  Purpose:    Determine whether an event is an ignorable CM event, such
//              as those that are adds/removes from a temporary CM connection
//              (used by CM VPN connections to double-dial). We don't want
//              clients to react to these events.
//
//  Arguments:
//      pRasEvent [in] pointer to a RASEVENT structure describing the event.
//
//  Returns:
//
//  Author:     jeffspr   15 Jan 1999
//
//  Notes:
//
BOOL FIsIgnorableCMEvent(IN const RASEVENT* pRasEvent) throw()
{
    TraceFileFunc(ttidEvents);

    BOOL    fReturn = FALSE;
    WCHAR   szFileName[MAX_PATH];

    Assert(pRasEvent);

    // Split the filename out of the path
    //
    _wsplitpath(pRasEvent->Details.szPhonebookPath, NULL, NULL,
                szFileName, NULL);

    // Compare that file name with the filter prefix to see if we
    // should throw this event away
    //
    if (_wcsnicmp(CM_PBK_FILTER_PREFIX, szFileName,
                   wcslen(CM_PBK_FILTER_PREFIX)) == 0)
    {
        fReturn = TRUE;
    }

    return fReturn;
}

HRESULT HrGetRasConnectionProperties(
        IN  const RASENUMENTRYDETAILS*  pDetails,
        OUT NETCON_PROPERTIES_EX**      ppPropsEx)
{
    TraceFileFunc(ttidEvents);

    HRESULT hr = S_OK;
    INetConnection* pConn;

    Assert(ppPropsEx);

    hr = CMDIRECT(DIALUP, CreateInstanceFromDetails)(
            pDetails,
            IID_INetConnection,
            reinterpret_cast<VOID**>(&pConn));

    if (SUCCEEDED(hr))
    {
        hr = HrGetPropertiesExFromINetConnection(pConn, ppPropsEx);

        ReleaseObj (pConn);
    }

    return hr;
}

HRESULT HrGetIncomingConnectionPropertiesEx(
    IN  const HANDLE             hRasConn,
    IN  const GUID*              pguidId,
    IN  const DWORD              dwType,
    OUT NETCON_PROPERTIES_EX**   ppPropsEx)
{
    TraceFileFunc(ttidEvents);

    HRESULT hr = S_OK;
    DWORD dwResult = 0;
    RAS_SERVER_HANDLE hRasServer = NULL;
    RAS_CONNECTION_2* pRasConnection = NULL;

    if (NULL == hRasConn)
    {
        return E_INVALIDARG;
    }
    if (!ppPropsEx)
    {
        return E_POINTER;
    }

    *ppPropsEx = NULL;

    dwResult = MprAdminServerConnect(NULL, &hRasServer);

    if (NO_ERROR == dwResult)
    {
        dwResult = MprAdminConnectionGetInfo(hRasServer, 2, hRasConn, reinterpret_cast<LPBYTE*>(&pRasConnection));

        if (NO_ERROR == dwResult)
        {
            DWORD dwRead = 0;
            DWORD dwTot = 0;
            RAS_PORT_0* pPort = NULL;
           
            dwResult = MprAdminPortEnum(hRasServer,
                                        0,
                                        hRasConn,
                                        (LPBYTE*)&pPort,
                                        sizeof(RAS_PORT_0) * 2,
                                        &dwRead,
                                        &dwTot,
                                        NULL);
            
            if (NO_ERROR == dwResult)
            {
                CComPtr<INetConnection> pConn;
                
                hr = CMDIRECT(INBOUND, CreateInstance)(FALSE,
                                                        hRasConn,
                                                        pRasConnection->wszUserName,
                                                        pPort->wszDeviceName,
                                                        dwType,
                                                        pguidId,
                                                        IID_INetConnection,
                                                        reinterpret_cast<LPVOID*>(&pConn));
                if (SUCCEEDED(hr))
                {
                    hr = HrGetPropertiesExFromINetConnection(pConn, ppPropsEx);
                    (*ppPropsEx)->ncStatus = NCS_CONNECTED;
                }
                MprAdminBufferFree(reinterpret_cast<LPVOID>(pPort));
            }
            MprAdminBufferFree(pRasConnection);
        }
        MprAdminServerDisconnect(hRasServer);
    }

    if (NO_ERROR != dwResult)
    {
        hr = HRESULT_FROM_WIN32(dwResult);
    }
    
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   RasEventNotify
//
//  Purpose:    Private export used by Rasman service to notify the
//              Netman service of RAS events which may effect connections.
//
//  Arguments:
//      pRasEvent [in] pointer to a RASEVENT structure describing the event.
//
//  Returns:    nothing
//
//  Author:     shaunco   21 Aug 1998
//
//  Notes:
//
VOID
APIENTRY
RasEventNotify (
    const RASEVENT* pRasEvent) /* throw() */
{
    TraceFileFunc(ttidEvents);

    NETCON_STATUS ncs;
    BOOL fMatchedStatus = TRUE;

    Assert (pRasEvent);

    TraceTag (ttidEvents,
        "RasEventNotify: Recieved RAS event (Type=%d)...",
        pRasEvent->Type);

    // Let's be sure we only do work if the service state is still running.
    // If we have a stop pending for example, we don't need to do anything.
    //
    if (SERVICE_RUNNING != _Module.DwServiceStatus ())
    {
        return;
    }
    
    // Map the ras type to the conman type
    // 
    switch(pRasEvent->Type)
    {
    case ENTRY_CONNECTED:
        ncs = NCS_CONNECTED;
        break;

    case ENTRY_CONNECTING:
        ncs = NCS_CONNECTING;
        break;

    case ENTRY_DISCONNECTING:
        ncs = NCS_DISCONNECTING;
        break;

    case ENTRY_DISCONNECTED:
        ncs = NCS_DISCONNECTED;
        break;
    
    default:
        fMatchedStatus = FALSE;
    }

    // Remember any Connection Manager connectoids and ras events
    // For Ras Connecting is Disconnected so we have to memorize the 
    // real state of the connectoid. /*&& FIsIgnorableCMEvent(pRasEvent)*/
    //
    if( fMatchedStatus )
    {
        // Save the connection in a list
        //
        CCMUtil::Instance().SetEntry(pRasEvent->Details.guidId, pRasEvent->Details.szEntryName,ncs);
    }

    // If the connection manager has no active connection points registered,
    // we don't need to do anything.
    //
    if (!CConnectionManager::FHasActiveConnectionPoints ())
    {
        return;
    }

    //  Windows XP Bug 336787.
    //  sjkhan
    //  We're checking to see if we should be firing events when the RemoteAccess Service
    //  starts.  We call the same API that we do when checking whether or not to show the 
    //  config connection, and we're then able to determine whether or not we should fire
    //  the incoming events.  Since we get notified of the service stopping and starting,
    //  we'll always know when we should or should not fire IncomingEvents.  This reduces
    //  the call overhead to O(1), and since  we exit here if  we're not supposed to fire
    //  events, we don't even have to allocate and then free the pEvent memory.
    //
    if (((INCOMING_CONNECTED == pRasEvent->Type) ||
        (INCOMING_DISCONNECTED == pRasEvent->Type)) &&
        !g_fHandleIncomingEvents)
    {
        return;
    }

    if ((ENTRY_ADDED == pRasEvent->Type) ||
        (ENTRY_DELETED == pRasEvent->Type))
    {
        // Filter out CM temporary phonebook events
        //
        if (FIsIgnorableCMEvent(pRasEvent))
        {
            TraceTag(ttidEvents, "Filtering ignorable CM event in RasEventNotify");
            return;
        }
    }

    // Allocate a CONMAN_EVENT structure and initialize it from the
    // RASEVENT information.
    //
    CONMAN_EVENT* pEvent = (CONMAN_EVENT*)MemAlloc (sizeof(CONMAN_EVENT));
    if (!pEvent)
    {
        TraceTag (ttidEvents,
            "Failed to allocate a new work item in RasEventNotify.");
        return;
    }
    ZeroMemory (pEvent, sizeof(CONMAN_EVENT));
    pEvent->ConnectionManager = CONMAN_RAS;

    BOOL    fFreeEvent = TRUE;
    HRESULT hr = S_OK;

    switch (pRasEvent->Type)
    {
        case ENTRY_ADDED:
            pEvent->Type = CONNECTION_ADDED;
            pEvent->Details = pRasEvent->Details;
            TraceTag(ttidEvents, "Path: %S", pRasEvent->Details.szPhonebookPath);
            break;

        case ENTRY_DELETED:
            pEvent->Type = CONNECTION_DELETED;
            pEvent->guidId = pRasEvent->guidId;
            break;

        case ENTRY_MODIFIED:
            pEvent->Type = CONNECTION_MODIFIED;
            pEvent->Details = pRasEvent->Details;
            InterlockedIncrement(&g_lRasEntryModifiedVersionEra);
            break;

        case ENTRY_RENAMED:
            pEvent->Type = CONNECTION_RENAMED;
            pEvent->guidId = pRasEvent->guidId;
            lstrcpynW (
                pEvent->szNewName,
                pRasEvent->pszwNewName,
                celems(pEvent->szNewName) );
            InterlockedIncrement(&g_lRasEntryModifiedVersionEra);
            break;

        case ENTRY_AUTODIAL:
            pEvent->Type = CONNECTION_MODIFIED;
            pEvent->Details = pRasEvent->Details;
            InterlockedIncrement(&g_lRasEntryModifiedVersionEra);
            break;

        case ENTRY_CONNECTED:
            pEvent->Type = CONNECTION_STATUS_CHANGE;
            pEvent->guidId = pRasEvent->Details.guidId;
            pEvent->Status = NCS_CONNECTED;
            break;

        case ENTRY_CONNECTING:
            pEvent->Type = CONNECTION_STATUS_CHANGE;
            pEvent->guidId = pRasEvent->Details.guidId;
            pEvent->Status = NCS_CONNECTING;
            break;

        case ENTRY_DISCONNECTING:
            pEvent->Type = CONNECTION_STATUS_CHANGE;
            pEvent->guidId = pRasEvent->Details.guidId;
            pEvent->Status = NCS_DISCONNECTING;
            break;

        case ENTRY_DISCONNECTED:
            pEvent->Type = CONNECTION_STATUS_CHANGE;
            pEvent->guidId = pRasEvent->Details.guidId;
            pEvent->Status = NCS_DISCONNECTED;
            break;

        case INCOMING_CONNECTED:
            pEvent->ConnectionManager = CONMAN_INCOMING;
            pEvent->hConnection = pRasEvent->hConnection;
            pEvent->guidId = pRasEvent->guidId;
            pEvent->dwConnectionType = RasSrvTypeFromRasDeviceType(pRasEvent->rDeviceType);
            pEvent->Type = CONNECTION_ADDED;
            break;

        case INCOMING_DISCONNECTED:
            pEvent->ConnectionManager = CONMAN_INCOMING;
            pEvent->guidId = pRasEvent->guidId;
            pEvent->Type = CONNECTION_DELETED;
            break;

        case SERVICE_EVENT:
            if (REMOTEACCESS == pRasEvent->Service)
            {
                DWORD dwErr;
                pEvent->ConnectionManager = CONMAN_INCOMING;
                pEvent->Type = REFRESH_ALL;
                //  Check to see if we should handle incoming events.
                dwErr = RasSrvAllowConnectionsConfig(&g_fHandleIncomingEvents);
                TraceError ("RasSrvIsConnectionConnected", HRESULT_FROM_WIN32(dwErr));
            }
            else if (RAS_SERVICE_STARTED == pRasEvent->Event)
            {
                _Module.ReferenceRasman(REF_REFERENCE);
                hr = S_FALSE;
            }
            else
            {
                // skip queueing the workitem
                hr = S_FALSE;
            }
            break;

        case ENTRY_BANDWIDTH_ADDED:
        case ENTRY_BANDWIDTH_REMOVED:
            pEvent->Type = CONNECTION_BANDWIDTH_CHANGE;
            pEvent->guidId = pRasEvent->guidId;
            break;

        case DEVICE_ADDED:
        case DEVICE_REMOVED:
            pEvent->Type = REFRESH_ALL;
            break;

        default:
            // skip queueing the workitem
            AssertSz (FALSE, "Invalid Type specified in pRasEvent");
            hr = S_FALSE;
            break;
    }

    if (S_OK == hr)
    {
        if (CONMAN_RAS == pEvent->ConnectionManager)
        {
           TraceTag (ttidEvents,
                "RasEventNotify: Queueing RasEventWorkItem (Type=%s)...",
                DbgEvents(pEvent->Type));

            // Queue the event to be delivered the event to the clients of the
            // connection manager with registered connection points.
            // We pass ownership of the structure to the worker thread which
            // will free it.  (Therefore, we don't want to free it.)
            //
            if (QueueUserWorkItemInThread (RasEventWorkItem,
                    pEvent, EVENTMGR_CONMAN))
            {
                fFreeEvent = FALSE;
            }
            else
            {
                TraceTag (ttidEvents,
                    "QueueUserWorkItem failed with error %d in RasEventNotify.",
                    GetLastError ());
            }
        }
        else if (CONMAN_INCOMING == pEvent->ConnectionManager)
        {
            TraceTag (ttidEvents,
                "RasEventNotify: Queueing IncomingEventWorkItem (Type=%s)...",
                DbgEvents(pEvent->Type));
            
            // Queue the event to be delivered the event to the clients of the
            // connection manager with registered connection points.
            // We pass ownership of the structure to the worker thread which
            // will free it.  (Therefore, we don't want to free it.)
            //
            if (QueueUserWorkItemInThread (IncomingEventWorkItem,
                pEvent, EVENTMGR_CONMAN))
            {
                fFreeEvent = FALSE;
            }
            else
            {
                TraceTag (ttidEvents,
                    "QueueUserWorkItem failed with error %d in RasEventNotify.",
                    GetLastError ());
            }
            
        }
    }

    if (fFreeEvent)
    {
        FreeConmanEvent (pEvent);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   IncomingEventNotify
//
//  Purpose:    To be called when something changes on an Incoming Connection
//
//  Arguments:
//      EventType    [in] Type of the event
//      pConn        [in] The INetConnection (only for CONNECTION_MODIFIED)
//      pszNewName   [in] The name (for CONNECTION_RENAMED)
//      pguidConn    [in] The GUID of the connection (for CONNECTION_RENAMED)
//
//  Returns:    nothing
//
//  Author:     sjkhan   17 Oct 2000
//
//  Notes:      The easy thing is done a full refresh is queued for the
//              connection manager to notify its clients of.
//
VOID
IncomingEventNotify (
    CONMAN_EVENTTYPE    EventType,
    INetConnection*     pConn,
    PCWSTR              pszNewName,
    const GUID *        pguidConn) throw()
{
    TraceFileFunc(ttidEvents);

    // Let's be sure we only do work if the service state is still running.
    // If we have a stop pending for example, we don't need to do anything.
    //
    if (SERVICE_RUNNING != _Module.DwServiceStatus ())
    {
        return;
    }

    // If the connection manager has no active connection points registered,
    // we don't need to do anything.
    //
    if (!CConnectionManager::FHasActiveConnectionPoints ())
    {
        return;
    }

    if ((REFRESH_ALL == EventType) && (g_cInRefreshAll >= MAX_IN_REFRESH_ALL))
    {
        return;
    }

    // Allocate a CONMAN_EVENT structure and initialize it from the
    // INCOMING information.
    //
    CONMAN_EVENT* pEvent = (CONMAN_EVENT*)MemAlloc (sizeof(CONMAN_EVENT));
    if (!pEvent)
    {
        TraceTag (ttidEvents,
            "Failed to allocate a new work item in IncomingEventNotify.");
        return;
    }
    ZeroMemory (pEvent, sizeof(CONMAN_EVENT));
    pEvent->ConnectionManager = CONMAN_INCOMING;
    pEvent->Type = EventType;

    BOOL    fFreeEvent = TRUE;
    HRESULT hr = S_OK;

    if (pConn)
    {
        // pEvent->pProps is valid for modified events and added events, but we only support modified for incoming.
        // So, we don't want to be getting properties for any other event.
        // 
        AssertSz (
            (CONNECTION_MODIFIED == EventType),
            "Why is pConn being passed for this event type?");

        hr = HrGetPropertiesExFromINetConnection(pConn, &pEvent->pPropsEx);
    }

    if (EventType == CONNECTION_RENAMED)
    {
        AssertSz(pszNewName, "Rename event requires szwNewName to be "
                 "non-NULL");
        AssertSz(pguidConn, "Rename event requires pguidConn to be "
                 "non-NULL");

        // Copy in the right info into the event struct
        //
        pEvent->guidId = *pguidConn;
        lstrcpynW(pEvent->szNewName, pszNewName, celems(pEvent->szNewName));
    }

    if (S_OK == hr)
    {
        TraceTag (ttidEvents,
            "IncomingEventNotify: Queuing ConmanEventWorkItem (Type=%s)...",
            DbgEvents(pEvent->Type));

        // Queue a worker to deliver the event to the clients of the
        // connection manager with registered connection points.
        // We pass ownership of the structure to the worker thread which
        // will free it.  (Therefore, we don't want to free it.)
        //
        if (QueueUserWorkItemInThread (ConmanEventWorkItem,
                pEvent, EVENTMGR_CONMAN))
        {
            fFreeEvent = FALSE;
        }
        else
        {
            TraceTag (ttidEvents,
                "QueueUserWorkItem failed with error %d in IncomingEventNotify.",
                GetLastError ());
        }
    }

    if (fFreeEvent)
    {
        FreeConmanEvent (pEvent);
    }
}



//+---------------------------------------------------------------------------
//
//  Function:   DispatchEvents
//
//  Purpose:    Thread function for Dispatching events
//
//  Arguments:
//      pUnused      [in,out] Unused
//      fTimerFired  [in]  We are being signalled
//
//  Returns:    nothing
//
//  Author:     sjkhan   30 Nov 2000
//
//  Notes:      Is called when something is added to the queue and and an event
//              is set, then dispatches all events until the queue is empty
//              and then exits.
//              
//
VOID NTAPI DispatchEvents(IN OUT LPVOID pUnused, IN BOOLEAN fTimerFired) throw()
{
    TraceFileFunc(ttidEvents);

    HRESULT hr = S_OK;
    TraceTag(ttidEvents, "Event Dispatching Thread Started.");
    
    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    if (SUCCEEDED(hr))
    {
        if (fTimerFired == FALSE /* We were signaled */)
        {
            while (g_pEventQueue->AtomCheckSizeAndResetEvent(g_fDispatchEvents))
            {
                PCONMAN_EVENTTHREAD pfnEvent = NULL;
                CONMAN_EVENT   *pEvent = NULL;
                EVENT_MANAGER  EventMgr;
                HRESULT hr;

                TraceTag(ttidEvents, "Number of events in Queue: %d", g_pEventQueue->size());

                hr = g_pEventQueue->DequeueEvent(pfnEvent, pEvent, EventMgr);
                if (SUCCEEDED(hr) && pfnEvent)
                {
                    pfnEvent(pEvent);
                }
            }
        }

        CoUninitialize();
    }
    else
    {
        TraceError("Error calling CoInitialize.", hr);
    }

    TraceTag(ttidEvents, "Event Dispatching Thread Stopping.");
}

//+---------------------------------------------------------------------------
//
//  Function:   HrEnsureEventHandlerInitialized
//
//  Purpose:    Thread function for Dispatching events
//
//  Arguments:
//      (none)
//
//  Returns:    HRESULT
//
//  Author:     sjkhan   30 Nov 2000
//
//  Notes:      
//
//
HRESULT HrEnsureEventHandlerInitialized()
{
    TraceFileFunc(ttidEvents);

    DWORD dwThreadId;
    NTSTATUS Status;
    HANDLE hEventExit;
    HRESULT hr = S_FALSE;  // Events are already initialized.
    
    TraceTag(ttidEvents, "Entering HrEnsureEventHandlerInitialized");
    
    if (!g_pEventQueue)
    {
        hEventExit = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (hEventExit)
        {
            try
            {
                g_pEventQueue = new CEventQueue(hEventExit); // This throws only HRESULT's
                if (!g_pEventQueue)
                {
                    throw E_OUTOFMEMORY;
                }

                //  Check to see if we should handle incoming events.
                DWORD dwErr = RasSrvAllowConnectionsConfig(&g_fHandleIncomingEvents);
                TraceError ("RasSrvIsConnectionConnected", HRESULT_FROM_WIN32(dwErr));

                g_fDispatchEvents = TRUE;
            }
            catch (HRESULT hrThrown)
            {
                hr = hrThrown;
            }
            CloseHandle(hEventExit);
        }
        else
        {
            hr = HrFromLastWin32Error();
        }
    }

    TraceError("Error in HrEnsureEventHandlerInitialized", hr);

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   UninitializeEventHandler
//
//  Purpose:    
//
//  Arguments:
//      (none)
//
//  Returns:    HRESULT
//
//  Author:     sjkhan   30 Nov 2000
//
//  Notes:      
//              
//
HRESULT UninitializeEventHandler()
{
    TraceFileFunc(ttidEvents);

    HRESULT hr = S_OK;
    DWORD dwStatus;
    NTSTATUS Status;

    TraceTag(ttidEvents, "Entering UninitializeEventHandler");

    if (g_fDispatchEvents)
    {
        g_fDispatchEvents = FALSE;

        if (g_pEventQueue && (0 != g_pEventQueue->size()))
        {
            dwStatus = g_pEventQueue->WaitForExit();
        }

        TraceTag(ttidEvents, "Deregistering Event Wait");

        if (g_hEventWait)
        {
            Status = RtlDeregisterWaitEx(g_hEventWait, INVALID_HANDLE_VALUE);
            g_hEventWait = NULL;
        }
    
        if (g_pEventQueue)
        {
            delete g_pEventQueue;
            g_pEventQueue = NULL;
        }
    }

    CGroupPolicyNetworkLocationAwareness* pGPNLA = 
        reinterpret_cast<CGroupPolicyNetworkLocationAwareness*>(InterlockedExchangePointer( (PVOID volatile *) &g_pGPNLA, NULL));
    
    if (pGPNLA)
    {
        TraceTag(ttidEvents, "Calling Group Policy Uninitialize");
        hr = pGPNLA->Uninitialize();
    
        delete pGPNLA;
    }

    TraceError("UninitializeEventHandler", hr);

    TraceTag(ttidEvents, "Exiting UninitializeEventHandler");

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   QueueUserWorkItemInThread
//
//  Purpose:    Places events and their workitems into the event queue for 
//              scheduling.
//  Arguments:
//      LPTHREAD_START_ROUTINE [in] -  worker function to call
//      Context                [in] -  event data, allocate & pass a CONMAN_EVENT using operator new()
//      EventMgr               [in] -  CONMAN or EAPOLMAN
//
//
//  Returns:    BOOL
//
//  Author:     sjkhan   30 Nov 2000
//
//  Notes:      
//              
//
BOOL QueueUserWorkItemInThread(IN               PCONMAN_EVENTTHREAD    Function, 
                               IN TAKEOWNERSHIP CONMAN_EVENT*          Context, 
                               IN               EVENT_MANAGER          EventMgr) throw()
{
    TraceFileFunc(ttidEvents);

    HRESULT hr = S_OK;

    TraceTag(ttidEvents, "Entering QueueUserWorkItemInThread");

    if (g_fDispatchEvents)  // if we're shutting down then this will be FALSE and we won't be scheduling events.
    {

        hr = g_pEventQueue->EnqueueEvent(Function, Context, EventMgr);
        // The queue should contain only one item at this point unless someone else has added something
        // but either way, only one thread will be handling events (as the other call would have received S_OK
        // as a return value), as we synchronize this in EnqueueEvent.
    
        TraceTag(ttidEvents, "Number of Items in Queue: %d", g_pEventQueue->size());

    }

    TraceTag(ttidEvents, "Exiting QueueUserWorkItemInThread");

    if (FAILED(hr))
    {
        TraceError("Error in QueueUserWorkItemInThread", hr);
    }

    return SUCCEEDED(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   IsValidEventType
//
//  Purpose:    Validate Event parameters.  
//
//  Arguments:
//      EventMgr    - type of event manager
//      EventType   - type of event
//
//  Returns:    HRESULT indicating success of failure
//
//  Author:     sjkhan   09 Dec 2000
//
//  Notes:      
//              
//              
//              
//
BOOL IsValidEventType(IN EVENT_MANAGER EventMgr, IN int EventType) throw()
{
    TraceFileFunc(ttidEvents);

    BOOL fIsValid = FALSE;

    Assert(EventMgr);
    TraceTag(ttidEvents, "IsValidEventType received: %d", EventType);

    if (EventMgr == EVENTMGR_CONMAN)
    {
        if (EventType == INVALID_TYPE)
        {
            fIsValid = FALSE;
        }
        else if (EventType <= DISABLE_EVENTS)
        {
            fIsValid = TRUE;
        }
    }
    else
    {
        AssertSz(FALSE, "Invalid Event Manager");
    }

    return fIsValid;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrEnsureRegisteredWithNla
//
//  Purpose:    Initialize our Nla Event class, if not already done.
//
//  Arguments:
//      (none)
//
//  Returns:    HRESULT indicating success of failure
//
//  Author:     sjkhan   21 Apr 2001
//
//  Notes:      
//
//
//
HRESULT HrEnsureRegisteredWithNla()
{
    TraceFileFunc(ttidEvents);

    HRESULT hr = S_FALSE;  // We're already registered, no need to do so again.

    if (!g_pGPNLA)
    {
        try
        {
            g_pGPNLA = new CGroupPolicyNetworkLocationAwareness();
            if (g_pGPNLA)
            {
                hr = g_pGPNLA->Initialize();
                if (FAILED(hr))
                {
                    TraceError("Error in HrEnsureRegisteredWithNla", hr);
            
                    delete g_pGPNLA;
                    g_pGPNLA = NULL;
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        catch (HRESULT hrThrown)
        {
            hr = hrThrown;
        }
        // CGroupPolicyNetworkLocationAwareness constructor can throw 
        // a bad_alloc because it contains a STL list member.
        catch (bad_alloc)        
        {
            hr = E_OUTOFMEMORY;
        }
    }
    
    TraceTag(ttidEvents, "Exiting HrEnsureRegisteredWithNla");
    
    return hr;   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netman\dll\nminit.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N M I N I T . C P P
//
//  Contents:   Initialization routines for netman.
//
//  Notes:
//
//  Author:     shaunco   27 Jan 1998
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "nmbase.h"
#include "nminit.h"

static const WCHAR c_szClassObjectRegistrationEvent [] =
    L"NetmanClassObjectRegistrationEvent";

//+---------------------------------------------------------------------------
//
//  Function:   HrNmCreateClassObjectRegistrationEvent
//
//  Purpose:    Create the named event that will be signaled after
//              our class objects have been registered.
//
//  Arguments:
//      phEvent [out] Returned event handle
//
//  Returns:    S_OK or a Win32 error code.
//
//  Author:     shaunco   27 Jan 1998
//
//  Notes:
//
HRESULT
HrNmCreateClassObjectRegistrationEvent (
    OUT HANDLE* phEvent)
{
    Assert (phEvent);

    HRESULT hr = S_OK;

    // Create the name event and return it.
    //
    *phEvent = CreateEvent (NULL, FALSE, FALSE,
                    c_szClassObjectRegistrationEvent);
    if (!*phEvent)
    {
        hr = HrFromLastWin32Error ();
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "HrNmCreateClassObjectRegistrationEvent");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrNmWaitForClassObjectsToBeRegistered
//
//  Purpose:    For the event to be signaled if it can be opened.
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK or a Win32 error code.
//
//  Author:     shaunco   27 Jan 1998
//
//  Notes:
//
HRESULT
HrNmWaitForClassObjectsToBeRegistered ()
{
    HRESULT hr = S_OK;

    // Try to open the named event.  If it does not exist,
    // that's okay because we've probably already created and destroyed
    // it before this function was called.
    //
    HANDLE hEvent = OpenEvent (SYNCHRONIZE, FALSE,
                        c_szClassObjectRegistrationEvent);
    if (hEvent)
    {
        // Now wait for the event to be signaled while pumping messages
        // as needed.  We'll wait for up to 10 seconds.  That should be
        // plenty of time for the class objects to be registered.
        //
        while (1)
        {
            const DWORD cMaxWaitMilliseconds = 10000;   // 10 seconds

            DWORD dwWait = MsgWaitForMultipleObjects (1, &hEvent, FALSE,
                                cMaxWaitMilliseconds, QS_ALLINPUT);
            if ((WAIT_OBJECT_0 + 1) == dwWait)
            {
                // We have messages to pump.
                //
                MSG msg;
                while (PeekMessage(&msg,NULL,NULL,NULL,PM_REMOVE))
                {
                    DispatchMessage (&msg);
                }
            }
            else
            {
                // Wait is satisfied, or we had a timeout, or an error.
                //
                if (WAIT_TIMEOUT == dwWait)
                {
                    hr = HRESULT_FROM_WIN32 (ERROR_TIMEOUT);
                }
                else if (0xFFFFFFFF == dwWait)
                {
                    hr = HrFromLastWin32Error ();
                }

                break;
            }
        }

        CloseHandle (hEvent);
    }
    TraceHr (ttidError, FAL, hr, FALSE,
        "HrNmWaitForClassObjectsToBeRegistered");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netman\dll\version.h ===
#pragma once

#include <ntverp.h>
#include <winver.h>

#define VER_FILETYPE                    VFT_APP
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "Network Connections Manager"
#define VER_INTERNALNAME_STR            "netman.dll"

#include <common.ver>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netman\dll\wsdpsvc.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       W S D P S V C . H
//
//  Contents:   Start/stop Winsock Direct Path Service.
//
//  Notes:      The service is actually implemented in MS TCP Winsock provider
//
//  Author:     VadimE   24 Jan 2000
//
//----------------------------------------------------------------------------
#pragma once

VOID
StartWsdpService (
    VOID
    ) throw();

VOID
StopWsdpService (
    VOID
    ) throw();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netman\inc\cmevent.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       C M E V E N T  . H
//
//  Contents:   Connection manager Event type declarations
//
//  Notes:
//
//  Author:     ckotze   1 Mar 2001
//
//----------------------------------------------------------------------------
#pragma once
#include "nmbase.h"
#include "nmres.h"
#include <rasapip.h>

enum CONMAN_MANAGER
{
    INVALID_MANAGER = 0,
    CONMAN_INCOMING,
    CONMAN_LAN,
    CONMAN_RAS,
};

struct CONMAN_EVENT
{
    CONMAN_EVENTTYPE    Type;
    CONMAN_MANAGER      ConnectionManager;

    union
    {
    // CONNECTION_ADDED
    // CONNECTION_MODIFIED
        RASENUMENTRYDETAILS Details;
        struct
        {
            NETCON_PROPERTIES*   pProps;         // ConnectionManager = CONMAN_RAS and CONMAN_LAN
            BYTE*                pbPersistData;  // ConnectionManager = CONMAN_RAS and EVENTTYPE = CONNECTION_ADDED
            ULONG                cbPersistData;  // ConnectionManager = CONMAN_RAS and EVENTTYPE = CONNECTION_ADDED
        };

        NETCON_PROPERTIES_EX*   pPropsEx;
    
    // CONNECTION_DELETED
        GUID                guidId;
        
    // INCOMING_CONNECTED
    // INCOMING_DISCONNECTED
        struct
        {
            GUID                guidId;         // ConnectionManager = CONMAN_INCOMING and type = INCOMING_CONNECTED/DISCONNECTED
            HANDLE              hConnection;    // ConnectionManager = CONMAN_INCOMING and EVENTYPE = CONNECTION_ADDED
            DWORD               dwConnectionType;
        };

    // CONNECTION_RENAMED
        struct
        {
            GUID            guidId;
            WCHAR           szNewName [NETCON_MAX_NAME_LEN + 1];
        };

    // CONNECTION_STATUS_CHANGE
        struct
        {
            GUID            guidId;
            NETCON_STATUS   Status;
        };

    // CONNECTION_BALLOON_POPUP
        struct
        {
            GUID            guidId;
            BSTR            szCookie;
            BSTR            szBalloonText;
        };

	// DISABLE_EVENTS
        struct
        {
            BOOL            fDisable;
            ULONG           ulDisableTimeout;
        };
    };
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netman\dll\svcmain.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       S V C M A I N . C P P
//
//  Contents:   Service main for netman.dll
//
//  Notes:
//
//  Author:     shaunco   3 Apr 1998
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include <dbt.h>
#include "nmbase.h"
#include "nminit.h"
#include "nmres.h"
#include "cmevent.h"
#include "eventq.h"
#include "wsdpsvc.h"

// Includes for COM objects needed in the following object map.
//

// Connection Manager
//
#include "..\conman\conman.h"
#include "..\conman\conman2.h"
#include "..\conman\enum.h"

// As the object map needs to map directly to the original class manager, we'll have to define
// NO_CM_SEPERATE_NAMESPACES so that the code doesn't put the class managers in a seperate namespace.
// Take this out from time to time and compile without it. All the code has to compile fine. 
// However, it won't link.
#define NO_CM_SEPERATE_NAMESPACES
#include "cmdirect.h"

// Install queue
//
#include "ncqueue.h"

// Home networking support
//
#include "nmhnet.h"

// NetGroupPolicies
#include "nmpolicy.h"

#define INITGUID
DEFINE_GUID(CLSID_InternetConnectionBeaconService,0x04df613a,0x5610,0x11d4,0x9e,0xc8,0x00,0xb0,0xd0,0x22,0xdd,0x1f);
// TODO Remove this when we have proper idl

CServiceModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)

// Connection Manager
//
    OBJECT_ENTRY(CLSID_ConnectionManager,                       CConnectionManager)
    OBJECT_ENTRY(CLSID_ConnectionManagerEnumConnection,         CConnectionManagerEnumConnection)


// Connection Manager2
    OBJECT_ENTRY(CLSID_ConnectionManager2,                       CConnectionManager2)

// Connection Class Managers
//
    OBJECT_ENTRY(CLSID_InboundConnectionManager,                CMDIRECT(INBOUND, CInboundConnectionManager))
    OBJECT_ENTRY(CLSID_InboundConnectionManagerEnumConnection,  CMDIRECT(INBOUND, CInboundConnectionManagerEnumConnection))
    OBJECT_ENTRY(CLSID_LanConnectionManager,                    CMDIRECT(LANCON, CLanConnectionManager))
    OBJECT_ENTRY(CLSID_LanConnectionManagerEnumConnection,      CMDIRECT(LANCON, CLanConnectionManagerEnumConnection))
    OBJECT_ENTRY(CLSID_WanConnectionManager,                    CMDIRECT(DIALUP, CWanConnectionManager))
    OBJECT_ENTRY(CLSID_WanConnectionManagerEnumConnection,      CMDIRECT(DIALUP, CWanConnectionManagerEnumConnection))
    OBJECT_ENTRY(CLSID_SharedAccessConnectionManager,           CMDIRECT(SHAREDACCESS, CSharedAccessConnectionManager))
    OBJECT_ENTRY(CLSID_SharedAccessConnectionManagerEnumConnection, CMDIRECT(SHAREDACCESS, CSharedAccessConnectionManagerEnumConnection))

// Connection Objects
//
    OBJECT_ENTRY(CLSID_DialupConnection,                        CMDIRECT(DIALUP, CDialupConnection))
    OBJECT_ENTRY(CLSID_InboundConnection,                       CMDIRECT(INBOUND, CInboundConnection))
    OBJECT_ENTRY(CLSID_LanConnection,                           CMDIRECT(LANCON, CLanConnection))
    OBJECT_ENTRY(CLSID_SharedAccessConnection,                  CMDIRECT(SHAREDACCESS, CSharedAccessConnection))

// Install queue
//
    OBJECT_ENTRY(CLSID_InstallQueue,                            CInstallQueue)

// Home networking support
//
    OBJECT_ENTRY(CLSID_NetConnectionHNetUtil,                   CNetConnectionHNetUtil)

// NetGroupPolicies
    OBJECT_ENTRY(CLSID_NetGroupPolicies,                        CNetMachinePolicies)

END_OBJECT_MAP()


VOID
CServiceModule::DllProcessAttach (
    IN  HINSTANCE hinst) throw() 
{
    CComModule::Init (ObjectMap, hinst);
}

VOID
CServiceModule::DllProcessDetach (
    IN  VOID) throw() 
{
    CComModule::Term ();
}

DWORD
CServiceModule::DwHandler (
    IN DWORD dwControl,
    IN DWORD dwEventType,
    IN LPCVOID pEventData,
    IN LPCVOID pContext)
{
    if (SERVICE_CONTROL_STOP == dwControl)
    {
        HRESULT hr;

        TraceTag (ttidConman, "Received SERVICE_CONTROL_STOP request");

        SetServiceStatus (SERVICE_STOP_PENDING);

        hr = ServiceShutdown();
    }

    else if (SERVICE_CONTROL_INTERROGATE == dwControl)
    {
        TraceTag (ttidConman, "Received SERVICE_CONTROL_INTERROGATE request");
        UpdateServiceStatus (FALSE);
    }
    else if (SERVICE_CONTROL_SESSIONCHANGE == dwControl)
    {
        TraceTag (ttidConman, "Received SERVICE_CONTROL_SESSIONCHANGE request");
        CONMAN_EVENT* pEvent = new CONMAN_EVENT;

        // Send out a CONNECTION_DELETED event for a non-existing connection (GUID_NULL).
        // This will cause us to send an event to every logged in user on the system.
        // The event won't do anything, however, it will allow us to verify
        // each of the connection points to see if they are still alive.
        // Otherwise we could queue the connection points up every time a
        // user logs in & out again if no other networks events are being fired,
        // causing us to overflow RPC.
        //
        // See: NTRAID9:490981. rpcrt4!FindOrCreateLrpcAssociation has ~40,000 client LRPC associations for various COM endpoints
        if (pEvent)
        {
            ZeroMemory(pEvent, sizeof(CONMAN_EVENT));
            pEvent->guidId = GUID_NULL;
            pEvent->Type   = CONNECTION_DELETED;
        
            if (!QueueUserWorkItemInThread(ConmanEventWorkItem, pEvent, EVENTMGR_CONMAN))
            {
                FreeConmanEvent(pEvent);
            }
        }
    }
    else if ((SERVICE_CONTROL_DEVICEEVENT == dwControl) && pEventData)
    {
        DEV_BROADCAST_DEVICEINTERFACE* pInfo =
                (DEV_BROADCAST_DEVICEINTERFACE*)pEventData;

        if (DBT_DEVTYP_DEVICEINTERFACE == pInfo->dbcc_devicetype)
        {
            if (DBT_DEVICEARRIVAL == dwEventType)
            {
                TraceTag (ttidConman, "Device arrival: [%S]",
                    pInfo->dbcc_name);

                LanEventNotify (REFRESH_ALL, NULL, NULL, NULL);
            }
            else if (DBT_DEVICEREMOVECOMPLETE == dwEventType)
            {
                GUID guidAdapter = GUID_NULL;
                WCHAR szGuid[MAX_PATH];
                WCHAR szTempName[MAX_PATH];
                WCHAR* szFindGuid;

                TraceTag (ttidConman, "Device removed: [%S]",
                    pInfo->dbcc_name);

                szFindGuid = wcsrchr(pInfo->dbcc_name, L'{');
                if (szFindGuid)
                {
                    wcscpy(szGuid, szFindGuid);
                    IIDFromString(szGuid, &guidAdapter);
                }

                if (!IsEqualGUID(guidAdapter, GUID_NULL))
                {
                    CONMAN_EVENT* pEvent;

                    pEvent = new CONMAN_EVENT;

                    if (pEvent)
                    {
                        pEvent->ConnectionManager = CONMAN_LAN;
                        pEvent->guidId = guidAdapter;
                        pEvent->Type = CONNECTION_STATUS_CHANGE;
                        pEvent->Status = NCS_DISCONNECTED;

                        if (!QueueUserWorkItemInThread(LanEventWorkItem, pEvent, EVENTMGR_CONMAN))
                        {
                            FreeConmanEvent(pEvent);
                        }
                    }
                }
                else
                {
                    LanEventNotify (REFRESH_ALL, NULL, NULL, NULL);
                }
            }
        }
    }

    return 1;
}

VOID
CServiceModule::SetServiceStatus(DWORD dwState) throw()
{
    m_status.dwCurrentState = dwState;
    m_status.dwCheckPoint   = 0;
    if (!::SetServiceStatus (m_hStatus, &m_status))
    {
        TraceHr (ttidError, FAL, HrFromLastWin32Error(), FALSE,
            "CServiceModule::SetServiceStatus");
    }
}

VOID CServiceModule::UpdateServiceStatus (
    BOOL fUpdateCheckpoint /* = TRUE */) throw()
{
    if (fUpdateCheckpoint)
    {
        m_status.dwCheckPoint++;
    }

    if (!::SetServiceStatus (m_hStatus, &m_status))
    {
        TraceHr (ttidError, FAL, HrFromLastWin32Error(), FALSE,
            "CServiceModule::UpdateServiceStatus");
    }
}

VOID
CServiceModule::Run() throw()
{
    HRESULT hr = CoInitializeEx (NULL,
                    COINIT_MULTITHREADED | COINIT_DISABLE_OLE1DDE);
    TraceHr (ttidError, FAL, hr, FALSE, "CServiceModule::Run: "
        "CoInitializeEx failed");

    if (SUCCEEDED(hr))
    {
        TraceTag (ttidConman, "Calling RegisterClassObjects...");

        // Create the event to sychronize registering our class objects
        // with the connection manager which attempts to CoCreate
        // objects which are also registered here.  I've seen cases
        // where the connection manager will be off and running before
        // this completes causing CoCreateInstance to fail.
        // The connection manager will wait on this event before
        // executing CoCreateInstance.
        //
        HANDLE hEvent;
        hr = HrNmCreateClassObjectRegistrationEvent (&hEvent);
        if (SUCCEEDED(hr))
        {
            hr = _Module.RegisterClassObjects (
                    CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER,
                    REGCLS_MULTIPLEUSE);
            TraceHr (ttidError, FAL, hr, FALSE, "CServiceModule::Run: "
                "_Module.RegisterClassObjects failed");

            // Signal the event and close it.  If this delete's the
            // event, so be it. It's purpose is served as all
            // class objects have been registered.
            //
            SetEvent (hEvent);
            CloseHandle (hEvent);
        }

        if (SUCCEEDED(hr))
        {
            hr = ServiceStartup();
        }

        CoUninitialize();
    }

}

VOID
CServiceModule::ServiceMain (
    IN  DWORD     argc,
    IN  LPCWSTR   argv[]) throw()
{
    // Reset the version era for RAS phonebook entry modifications.
    //
    g_lRasEntryModifiedVersionEra = 0;

    m_fRasmanReferenced = FALSE;

    m_dwThreadID = GetCurrentThreadId ();

    ZeroMemory (&m_status, sizeof(m_status));
    m_status.dwServiceType      = SERVICE_WIN32_SHARE_PROCESS;
    m_status.dwControlsAccepted = SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_SESSIONCHANGE;

    // Register the service control handler.
    //
    m_hStatus = RegisterServiceCtrlHandlerEx (
                    L"netman",
                    _DwHandler, 
                    NULL);

    if (m_hStatus)
    {
        SetServiceStatus (SERVICE_START_PENDING);

        // When the Run function returns, the service is running.
        // We now handle shutdown from ServiceShutdown when our DwHandler
        // is called and is passed SERVICE_CONTROL_STOP as the dwControl
        // parameter.  This allows us to terminate our message pump thread
        // which effectively reduces us to 0 threads that we own.
        Run ();
    }
    else
    {
        TraceHr (ttidError, FAL, HrFromLastWin32Error(), FALSE,
            "CServiceModule::ServiceMain - RegisterServiceCtrlHandler failed");
    }
}

// static
DWORD
WINAPI
CServiceModule::_DwHandler (
    IN DWORD  dwControl,
    IN DWORD  dwEventType,
    IN WACKYAPI LPVOID pEventData,
    IN WACKYAPI LPVOID pContext)
{
    return _Module.DwHandler (dwControl, dwEventType, const_cast<LPCVOID>(pEventData), const_cast<LPCVOID>(pContext));
}

VOID
CServiceModule::ReferenceRasman (
    IN  RASREFTYPE RefType) throw()
{
    BOOL fRef = (REF_REFERENCE == RefType);

    if (REF_INITIALIZE == RefType)
    {
        Assert (!fRef);

        // RasInitialize implicitly references rasman.
        //
        RasInitialize ();
    }
    // If we need to reference and we're not already,
    // or we need unreference and we're referenced, do the appropriate thing.
    // (This is logical xor.  Quite different than bitwise xor when
    // the two arguments don't neccesarily have the same value for TRUE.)
    //
    else if ((fRef && !m_fRasmanReferenced) ||
            (!fRef && m_fRasmanReferenced))
    {
        RasReferenceRasman (fRef);

        m_fRasmanReferenced = fRef;
    }
}

HRESULT CServiceModule::ServiceStartup()
{
    HRESULT hr = S_OK;

    StartWsdpService (); // Starts WSDP service on DTC/AdvServer build/
                         // no-op otherwise

    InitializeHNetSupport();

    SetServiceStatus (SERVICE_RUNNING);
    TraceTag (ttidConman, "Netman is now running...");

    return hr;
}

HRESULT CServiceModule::ServiceShutdown()
{
    HRESULT hr = S_OK;

    TraceFileFunc(ttidConman);

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    if (SUCCEEDED(hr))
    {
        TraceTag(ttidConman, "ServiceShutdown: UninitializeEventHandler");

        hr = UninitializeEventHandler();

        if (SUCCEEDED(hr))
        {
            TraceTag(ttidConman, "ServiceShutdown: CleanupHNetSupport");
            CleanupHNetSupport();

            TraceTag(ttidConman, "ServiceShutdown: StopWsdpService");
            StopWsdpService (); // Stops WSDP service if necessary

            // We must synchronize with the install queue's thread otherwise
            // RevokeClassObjects will kill the InstallQueue object and
            // CoUninitialize will free the NetCfg module before the thread
            // is finished.
            //
            TraceTag(ttidConman, "ServiceShutdown: WaitForInstallQueueToExit");
            WaitForInstallQueueToExit();

            TraceTag(ttidConman, "ServiceShutdown: RevokeClassObjects");
            _Module.RevokeClassObjects ();

            // Unreference rasman now that our service is about to stop.
            //
            TraceTag(ttidConman, "ServiceShutdown: ReferenceRasman");
            _Module.ReferenceRasman (REF_UNREFERENCE);

            AssertIfAnyAllocatedObjects();

            SetServiceStatus(SERVICE_STOPPED);
        }
        CoUninitialize();

        TraceTag(ttidConman, "ServiceShutdown: Completed");
    }

    if (FAILED(hr))
    {
        SetServiceStatus(SERVICE_RUNNING);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netman\dll\wsdpsvc.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       W S D P S V C . C P P
//
//  Contents:   Start/stop Winsock Direct Path Service.
//
//  Notes:      The service is actually implemented in MS TCP Winsock provider
//
//  Author:     VadimE   24 Jan 2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "wsdpsvc.h"

#define MSTCP_PROVIDER_DLL          TEXT("mswsock.dll")
#define START_WSDP_FUNCTION_NAME    "StartWsdpService"
#define STOP_WSDP_FUNCTION_NAME     "StopWsdpService"

// MS TCP Winsock provider module handle
HINSTANCE   ghMsTcpDll;

// Service start function pointer
typedef INT (WINAPI *PFN_START_WSDP_SVC) (VOID);
PFN_START_WSDP_SVC gpfnStartWsdpSvc;

// Service stop function pointer
typedef VOID (WINAPI *PFN_STOP_WSDP_SVC) (VOID);
PFN_STOP_WSDP_SVC gpfnStopWsdpSvc;


//+---------------------------------------------------------------------------
// StartWsdpService - start WSDP service if running on DTC
//
//
VOID
StartWsdpService (
    VOID
    ) throw()
{
    NTSTATUS                status;
    NT_PRODUCT_TYPE         product;

    //
    // First check if we are running Server build
    //
    status = RtlGetNtProductType (&product);
    if (!NT_SUCCESS (status) ||
			 (product == NtProductWinNt)) {
        return;
    }

    //
    // Load MS TCP provider and get WSDP service entry points
    //
    ghMsTcpDll = LoadLibrary (MSTCP_PROVIDER_DLL);
    if (ghMsTcpDll!=NULL) {
        gpfnStartWsdpSvc = (PFN_START_WSDP_SVC) GetProcAddress (
                                ghMsTcpDll,
                                START_WSDP_FUNCTION_NAME);
        gpfnStopWsdpSvc = (PFN_STOP_WSDP_SVC) GetProcAddress (
                                ghMsTcpDll,
                                STOP_WSDP_FUNCTION_NAME);
        if (gpfnStartWsdpSvc != NULL && gpfnStopWsdpSvc != NULL) {
            //
            // Launch the service and return if succeded
            //
            INT err = (*gpfnStartWsdpSvc)();
            if (err==0) {
                return;
            }
        }
        //
        // Cleanup if anything fails
        //
        FreeLibrary (ghMsTcpDll);
        ghMsTcpDll = NULL;
    }
    
}

//+---------------------------------------------------------------------------
// StopWsdpService - stop WSDP service if it was started
//
//
VOID
StopWsdpService (
    VOID
    ) throw()
{
    if (ghMsTcpDll!=NULL) {
        //
        // Tell the service to stop and unload the provider
        //
        (*gpfnStopWsdpSvc)();
        FreeLibrary (ghMsTcpDll);
        ghMsTcpDll = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netman\inc\cobase.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       C O B A S E . H
//
//  Contents:   Connection Objects Shared code
//
//  Notes:
//
//  Author:     ckotze   16 Mar 2001
//
//----------------------------------------------------------------------------

#pragma once
#include "nmbase.h"
#include "nmres.h"

HRESULT 
HrBuildPropertiesExFromProperties(
    IN  const NETCON_PROPERTIES* pProps, 
    OUT NETCON_PROPERTIES_EX*  pPropsEx, 
    IN  IPersistNetConnection* pPersistNetConnection);

HRESULT 
HrGetPropertiesExFromINetConnection(
    IN                INetConnection* pConn, 
    OUT TAKEOWNERSHIP NETCON_PROPERTIES_EX** ppPropsEx);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netman\inc\cmutil.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       C M U T I L . H
//
//  Contents:   Connection manager.
//
//  Notes:
//
//  Author:     omiller   1 Jun 2000
//
//----------------------------------------------------------------------------

#pragma once
#include "nmbase.h"
#include <rasapip.h>
#include <map>
#include "nceh.h"

struct CMEntry
{

    CMEntry() throw() {}
    CMEntry(const CMEntry & ref) throw()
    {
        Set(ref.m_guid,ref.m_szEntryName,ref.m_ncs);
    }

    CMEntry(const GUID & guid,const WCHAR * szEntryName, const NETCON_STATUS ncs) throw()
    {
        Set(guid,szEntryName,ncs);
    }

    CMEntry & operator=(const CMEntry & ref) throw()
    {
        if(&ref != this)
        {
            Set(ref.m_guid, ref.m_szEntryName, ref.m_ncs);
        }
        return *this;
    }

    CMEntry & operator=(const CMEntry * ref) throw()
    {
        if(ref != this)
        {
            Set(ref->m_guid, ref->m_szEntryName, ref->m_ncs);
        }
        return *this;
    }

    void Set(const GUID & guid, const WCHAR * sz, const NETCON_STATUS ncs) throw()
    {
        ZeroMemory(m_szEntryName, sizeof(m_szEntryName)); 
        lstrcpyn(m_szEntryName, sz, NETCON_MAX_NAME_LEN);
        m_guid = guid;
        m_ncs = ncs;
    }

    WCHAR         m_szEntryName[NETCON_MAX_NAME_LEN + 1];
    GUID          m_guid;
    NETCON_STATUS m_ncs;
};

class CCMUtil
{
public:
    ~CCMUtil() throw();

    static CCMUtil & Instance() throw() { return s_instance; }
    HRESULT HrGetEntry(const GUID & guid, CMEntry & cm);
    HRESULT HrGetEntry(const WCHAR * szEntryName, CMEntry & cm);
    void SetEntry(const GUID & guid, const WCHAR * szEntryName, const NETCON_STATUS ncs) throw (std::bad_alloc);
    void RemoveEntry(const GUID & guid) throw();

private:
    static CCMUtil s_instance;
    
    CRITICAL_SECTION m_CriticalSection;
    
    typedef vector<CMEntry> CMEntryTable;

    CMEntryTable m_Table;

    CMEntryTable::iterator GetIteratorFromGuid(const GUID & guid);

    
    CCMUtil() throw(SE_Exception);
    CCMUtil(const CCMUtil &) throw(); // Make this private to be sure we don't call the copy constructor
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netman\inc\cmdirect.h ===
// This contains all the functions that are currently directly called inside the class managers from netman
// In order to move the class managers out later, these functions should stop being used.

#pragma once

#define CMNAME(classmanname, classOrig) classmanname::classOrig
#define CMDIRECT(classmanname, classOrig) CMDIRECT::CMNAME(classmanname, classOrig)

#ifdef NO_CM_SEPERATE_NAMESPACES
#define BEGIN_CLASSMGRHEADERS(classmanname)
#define END_CLASSMGRHEADERS
#define CLASS_MAPPING(classmanname, classOrig) typedef ::classOrig classOrig;
#else
#define BEGIN_CLASSMGRHEADERS(classmanname) namespace classmanname {
#define END_CLASSMGRHEADERS }
#define CLASSMGR(classmanname)
#define CLASS_MAPPING(classmanname, classOrig) typedef ::classmanname::classOrig classOrig;
#endif

BEGIN_CLASSMGRHEADERS(DIALUP)
    #include "..\classman\dialup\dialup.h"
    #include "..\classman\dialup\enumw.h"
    #include "..\classman\dialup\conmanw.h"
END_CLASSMGRHEADERS

BEGIN_CLASSMGRHEADERS(LANCON)
    #include "..\classman\lan\lan.h"
    #include "..\classman\lan\enuml.h"
    #include "..\classman\lan\conmanl.h"
END_CLASSMGRHEADERS

BEGIN_CLASSMGRHEADERS(SHAREDACCESS)
    #include "..\classman\sharedaccess\saconob.h"
    #include "..\classman\sharedaccess\enumsa.h"
    #include "..\classman\sharedaccess\conmansa.h"
END_CLASSMGRHEADERS

BEGIN_CLASSMGRHEADERS(INBOUND)
    #include "..\classman\inbound\inbound.h"
    #include "..\classman\inbound\enumi.h"
    #include "..\classman\inbound\conmani.h"
END_CLASSMGRHEADERS

#include "diag.h"

namespace CMDIRECT
{
    namespace DIALUP
    {
        CLASS_MAPPING(DIALUP, CWanConnectionManager)
        CLASS_MAPPING(DIALUP, CDialupConnection)
        CLASS_MAPPING(DIALUP, CWanConnectionManagerEnumConnection)

        HRESULT CreateWanConnectionManagerEnumConnectionInstance(NETCONMGR_ENUM_FLAGS Flags, REFIID riid, VOID** ppv);
        HRESULT CreateInstanceFromDetails (const RASENUMENTRYDETAILS*  pEntryDetails, REFIID riid, VOID** ppv);
    }

    namespace LANCON
    {
        CLASS_MAPPING(LANCON, CLanConnectionManager)
        CLASS_MAPPING(LANCON, CLanConnection)
        CLASS_MAPPING(LANCON, CLanConnectionManagerEnumConnection)

        HRESULT HrInitializeConMan(OUT INetConnectionManager **ppConMan);
        VOID CmdShowAllDevices(IN const DIAG_OPTIONS *pOptions, IN INetConnectionManager *pConMan) throw(std::bad_alloc);
        VOID CmdShowLanConnections(IN  const DIAG_OPTIONS  *pOptions, OUT INetConnectionManager *pConMan) throw();
        VOID CmdShowLanDetails(IN  const DIAG_OPTIONS *pOptions, OUT INetConnectionManager *pConMan) throw(std::bad_alloc);
        VOID CmdLanChangeState(IN const DIAG_OPTIONS *pOptions, IN INetConnectionManager *pConMan) throw ();
        HRESULT HrUninitializeConMan(IN  INetConnectionManager *pConMan);
    }

    namespace SHAREDACCESS
    {
        CLASS_MAPPING(SHAREDACCESS, CSharedAccessConnectionManager)
        CLASS_MAPPING(SHAREDACCESS, CSharedAccessConnection)
        CLASS_MAPPING(SHAREDACCESS, CSharedAccessConnectionManagerEnumConnection)
    }

    namespace INBOUND
    {
        CLASS_MAPPING(INBOUND, CInboundConnectionManager)
        CLASS_MAPPING(INBOUND, CInboundConnection)
        CLASS_MAPPING(INBOUND, CInboundConnectionManagerEnumConnection)

        HRESULT CreateInstance (
                    IN  BOOL        fIsConfigConnection,
                    IN  HRASSRVCONN hRasSrvConn,
                    IN  PCWSTR     pszwName,
                    IN  PCWSTR     pszwDeviceName,
                    IN  DWORD       dwType,
                    IN  const GUID* pguidId,
                    IN  REFIID      riid,
                    OUT VOID**      ppv);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netman\inc\gpnla.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       G P N L A . H
//
//  Contents:   Class for Handling NLA Changes that affect Group Policies
//
//  Notes:
//
//  Author:     sjkhan   20 Feb 2001
//
//----------------------------------------------------------------------------
#pragma once
#include "nmbase.h"
#include <winsock2.h>
#include "ncstl.h"
#include "netcon.h"
#include "gpbase.h"
#include "cmevent.h"

typedef struct tagGPNLAINFORMATION
{
    tstring         strNetworkName;
    NETCON_STATUS   ncsStatus;
} GPNLAINFORMATION;

typedef pair<GUID, GPNLAINFORMATION> GPNLAPAIR;

typedef list<GPNLAPAIR> GPNLALIST;
typedef GPNLALIST::iterator GPNLAITER;

class CGroupPolicyNetworkLocationAwareness : public CGroupPolicyBase
{
public:
    CGroupPolicyNetworkLocationAwareness() throw();
    ~CGroupPolicyNetworkLocationAwareness() throw();

    HRESULT Initialize();
    HRESULT Uninitialize();
    virtual BOOL IsSameNetworkAsGroupPolicies() throw();

    static VOID NTAPI EventHandler(IN LPVOID pContext, IN BOOLEAN TimerOrWaitFired) throw();
    static VOID NTAPI GroupPolicyChange(IN LPVOID pContext, IN BOOLEAN TimerOrWaitFired);
    static DWORD WINAPI ShutdownNlaHandler(IN PVOID pThis);
    
protected:
    HRESULT LookupServiceBegin(IN DWORD dwControlFlags);
    HRESULT LookupServiceNext(IN     DWORD dwControlFlags, 
                              IN OUT LPDWORD lpdwBufferLength, 
                              OUT    LPWSAQUERYSET lpqsResults);
    HRESULT LookupServiceEnd();
    HRESULT QueueEvent(IN CONMAN_EVENTTYPE cmEventType, 
                       IN LPCGUID          pguidAdapter, 
                       IN NETCON_STATUS    ncsStatus);
    HRESULT RegisterWait();
    HRESULT DeregisterWait();
    HRESULT EnumChanges();

    LONG Reference() throw();
    LONG Unreference() throw();
    
    BOOL IsJoinedToDomain();

    static HRESULT ReconfigureHomeNet(IN BOOL fWaitUntilRunningOrStopped = FALSE);

protected:
    WSADATA             m_wsaData;
    WSACOMPLETION       m_wsaCompletion;
    WSAOVERLAPPED       m_wsaOverlapped;
    HANDLE              m_hQuery;
    WSAQUERYSET         m_wqsRestrictions;
    BOOL                m_fSameNetwork;
    HANDLE              m_hEventNLA;
    HANDLE              m_hNLAWait;
    HANDLE              m_hEventGP;
    HANDLE              m_hGPWait;
    GPNLALIST           m_listAdapters;
    CRITICAL_SECTION    m_csList;
    LONG                m_lRefCount;
    HANDLE              m_hEventExit;
    BOOL                m_fShutdown;
    BOOL                m_fErrorShutdown;
    static LONG         m_lBusyWithReconfigure;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netman\inc\eventq.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       E V E N T Q  . H
//
//  Contents:   Event Queue for managing synchonization of external events.
//
//  Notes:      
//
//  Author:     ckotze   29 Nov 2000
//
//----------------------------------------------------------------------------

#pragma once
#include "nmbase.h"
#include <ncstl.h>
#include <queue>

using namespace std;

class CEvent 
{
public:
    CEvent(IN HANDLE hEvent) throw();
    ~CEvent() throw();

    HRESULT SetEvent();
    HRESULT ResetEvent();

private:
    HANDLE  m_hEvent;
    BOOL    m_bSignaled;
};

enum EVENT_MANAGER;

typedef DWORD (WINAPI CONMAN_EVENTTHREAD)(
    IN TAKEOWNERSHIP CONMAN_EVENT* lpEvent
    );

typedef CONMAN_EVENTTHREAD *PCONMAN_EVENTTHREAD;

typedef struct tagUSERWORKITEM
{
    PCONMAN_EVENTTHREAD Function;
    CONMAN_EVENT* Event;
    EVENT_MANAGER EventMgr;
} USERWORKITEM;

typedef list<USERWORKITEM> EVENTQUEUE;
typedef EVENTQUEUE::iterator EVENTQUEUEITER;

class CEventQueue
{
public:
    CEventQueue(HANDLE hServiceShutdown) throw (HRESULT);
    ~CEventQueue() throw();

    HRESULT EnqueueEvent(IN                PCONMAN_EVENTTHREAD  Function, 
                         IN TAKEOWNERSHIP  CONMAN_EVENT* pEvent, 
                         IN                const EVENT_MANAGER EventMgr);
    
    HRESULT DequeueEvent(OUT               PCONMAN_EVENTTHREAD& Function, 
                         OUT TAKEOWNERSHIP CONMAN_EVENT*& pEvent, 
                         OUT               EVENT_MANAGER& EventMgr);

    BOOL    AtomCheckSizeAndResetEvent(IN const BOOL fDispatchEvents) throw();
    DWORD   WaitForExit() throw();
    size_t size() throw();

private:
    EVENTQUEUE          m_eqWorkItems;
    CRITICAL_SECTION    m_csQueue;
    CEvent*             m_pFireEvents;
    HANDLE              m_hServiceShutdown;
    HANDLE              m_hWait;
    BOOL                m_fRefreshAllInQueue;
};

BOOL
QueueUserWorkItemInThread(
    IN               PCONMAN_EVENTTHREAD    Function, 
    IN TAKEOWNERSHIP CONMAN_EVENT*          Context, 
    IN               EVENT_MANAGER          EventMgr) throw();

CONMAN_EVENTTHREAD ConmanEventWorkItem;
CONMAN_EVENTTHREAD RasEventWorkItem;
CONMAN_EVENTTHREAD LanEventWorkItem;
CONMAN_EVENTTHREAD IncomingEventWorkItem;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netman\inc\ncqueue.h ===
#pragma once
#include "nmbase.h"
#include "nmres.h"
#include "nceh.h"
//
//  The queue item structure.  The device instance id of the queue item
//  will follow the actual structure (i.e. string start =
//  beginning of structure + size of structure.)
//
struct NCQUEUE_ITEM
{
    DWORD           cbSize;
    NC_INSTALL_TYPE eType;
    GUID            ClassGuid;
    GUID            InstanceGuid;
    DWORD           dwCharacter;
    DWORD           dwDeipFlags;
    union
    {
        DWORD  cchPnpId;
        PWSTR  pszPnpId;
    };
    union
    {
        DWORD  cchInfId;
        PWSTR  pszInfId;
    };

};

class ATL_NO_VTABLE CInstallQueue :
    public CComObjectRootEx <CComMultiThreadModel>,
    public CComCoClass <CInstallQueue, &CLSID_InstallQueue>,
    public INetInstallQueue
{
public:
    CInstallQueue() throw (SE_Exception);
    VOID FinalRelease ();

    DECLARE_CLASSFACTORY_DEFERRED_SINGLETON(CInstallQueue)
    DECLARE_REGISTRY_RESOURCEID(IDR_INSTALLQUEUE)

    BEGIN_COM_MAP(CInstallQueue)
        COM_INTERFACE_ENTRY(INetInstallQueue)
    END_COM_MAP()

    // INetInstallQueue
    STDMETHOD (AddItem) (
        IN const NIQ_INFO* pInfo);

    STDMETHOD (ProcessItems) ()
    {
        return HrQueueWorkItem();
    };

    VOID            Close();
    HRESULT         HrOpen();
    HRESULT         HrGetNextItem(NCQUEUE_ITEM** ppncqi);
    HRESULT         HrRefresh();
    VOID            MarkCurrentItemForDeletion();

protected:
    CRITICAL_SECTION    m_csReadLock;
    CRITICAL_SECTION    m_csWriteLock;
    DWORD               m_dwNextAvailableIndex;
    HKEY                m_hkey;
    INT                 m_nCurrentIndex;
    DWORD               m_cItems;
    PWSTR*             m_aszItems;
    DWORD               m_cItemsToDelete;
    PWSTR*             m_aszItemsToDelete;
    BOOL                m_fQueueIsOpen;

    DWORD           DwSizeOfItem(NCQUEUE_ITEM* pncqi);
    VOID            DeleteMarkedItems();
    BOOL            FIsQueueIndexInRange();
    VOID            FreeAszItems();
    HRESULT         HrAddItem(
                        const NIQ_INFO* pInfo);

    NCQUEUE_ITEM*   PncqiCreateItem(
                        const NIQ_INFO* pInfo);

    VOID            SetNextAvailableIndex();
    VOID            SetItemStringPtrs(NCQUEUE_ITEM* pncqi);
    HRESULT         HrQueueWorkItem();
};

//+---------------------------------------------------------------------------
//
//  Function:   DwSizeOfItem
//
//  Purpose:    Determines the size (in bytes) of the entire NCQUEUE_ITEM
//              structure.  This includes the string (and the NULL terminator)
//              appended to the end of the structure.
//
//  Arguments:
//      ncqi [in] The queue item.
//
//  Returns:    DWORD. The size in bytes.
//
//  Author:     billbe   25 Aug 1998
//
//  Notes:
//
inline DWORD
CInstallQueue::DwSizeOfItem (NCQUEUE_ITEM* pncqi)
{
    AssertH(pncqi);
    PWSTR pszDeviceInstanceId = (PWSTR)((BYTE*)pncqi + pncqi->cbSize);

    DWORD cbDeviceInstanceId = CbOfSzAndTerm (pszDeviceInstanceId);

    PWSTR pszInfId = (PWSTR)((BYTE*)pszDeviceInstanceId + cbDeviceInstanceId);

    return pncqi->cbSize + cbDeviceInstanceId + CbOfSzAndTerm (pszInfId);
};

//+---------------------------------------------------------------------------
//
//  Function:   SetItemStringPtrs
//
//  Purpose:    Sets the pszwDeviceInstanceId member of the NCQUEUE_ITEM
//              structure to the correct location of the device id string.
//
//  Arguments:
//      pncqi [inout] The queue item.
//
//  Returns:    nothing
//
//  Author:     billbe   25 Aug 1998
//
//  Notes:
//
inline VOID
CInstallQueue::SetItemStringPtrs (
    NCQUEUE_ITEM* pncqi)
{
    AssertH(pncqi);

    pncqi->pszPnpId = (PWSTR)((BYTE*)pncqi + pncqi->cbSize);

    DWORD cbPnpId = CbOfSzAndTerm (pncqi->pszPnpId);
    pncqi->pszInfId = (PWSTR)((BYTE*)pncqi->pszPnpId + cbPnpId);
};

inline BOOL
CInstallQueue::FIsQueueIndexInRange()
{
    return (m_nCurrentIndex >= 0) && (m_nCurrentIndex < (INT)m_cItems);
}

inline void
CInstallQueue::FreeAszItems()
{
    for (DWORD dw = 0; dw < m_cItems; ++dw)
    {
        MemFree(m_aszItems[dw]);
    }
    MemFree(m_aszItems);
    m_aszItems = NULL;
    m_cItems = 0;
}


VOID
WaitForInstallQueueToExit();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netman\inc\nmclsid.h ===
#include <guiddef.h>

// Reserved GUIDS for our use
//
// BA126AD1-2166-11D1-B1D0-00805FC1270E     CLSID_ConnectionManager
// BA126AD2-2166-11D1-B1D0-00805FC1270E     CLSID_ConnectionManagerEnumConnection
// BA126AD3-2166-11D1-B1D0-00805FC1270E     CLSID_LanConnectionManager
// BA126AD4-2166-11D1-B1D0-00805FC1270E     CLSID_LanConnectionManagerEnumConnection
// BA126AD5-2166-11D1-B1D0-00805FC1270E     CLSID_WanConnectionManager
// BA126AD6-2166-11D1-B1D0-00805FC1270E     CLSID_WanConnectionManagerEnumConnection
// BA126AD7-2166-11D1-B1D0-00805FC1270E     CLSID_DialUpConnection
// BA126AD8-2166-11D1-B1D0-00805FC1270E     CLSID_NetGroupPolicies
// BA126AD9-2166-11D1-B1D0-00805FC1270E     CLSID_InboundConnection
// BA126ADA-2166-11D1-B1D0-00805FC1270E     (free) CLSID_InternetConnection
// BA126ADB-2166-11D1-B1D0-00805FC1270E     CLSID_LanConnection
// BA126ADC-2166-11D1-B1D0-00805FC1270E     (free) CLSID_VpnConnection
// BA126ADD-2166-11D1-B1D0-00805FC1270E     CLSID_InboundConnectionManager
// BA126ADE-2166-11D1-B1D0-00805FC1270E     CLSID_InboundConnectionManagerEnumConnection
// BA126ADF-2166-11D1-B1D0-00805FC1270E     CLSID_InstallQueue
// BA126AE0-2166-11D1-B1D0-00805FC1270E     CLSID_SharedAccessConnectionManager
// BA126AE1-2166-11D1-B1D0-00805FC1270E     CLSID_SharedAccessConnectionManagerEnumConnection
// BA126AE2-2166-11D1-B1D0-00805FC1270E     CLSID_SharedAccessConnection
// BA126AE3-2166-11D1-B1D0-00805FC1270E     CLSID_NetConnectionHNetUtil
// BA126AE4-2166-11D1-B1D0-00805FC1270E     CLSID_EAPOLManager
// BA126AE5-2166-11D1-B1D0-00805FC1270E     CLSID_ConnectionManager2
// ...
// BA126B1D-2166-11D1-B1D0-00805FC1270E
// BA126B1E-2166-11D1-B1D0-00805FC1270E
// BA126B1F-2166-11D1-B1D0-00805FC1270E

// The following CLSIDs are defined in uuid.lib because the public uses them.
//
EXTERN_C const CLSID CLSID_ConnectionManager;
EXTERN_C const CLSID CLSID_LanConnectionManager;
EXTERN_C const CLSID CLSID_NetConnectionHNetUtil;
EXTERN_C const CLSID CLSID_EAPOLManager;

DEFINE_GUID(CLSID_ConnectionManagerEnumConnection,          0xBA126AD2,0x2166,0x11D1,0xB1,0xD0,0x00,0x80,0x5F,0xC1,0x27,0x0E);
DEFINE_GUID(CLSID_LanConnectionManagerEnumConnection,       0xBA126AD4,0x2166,0x11D1,0xB1,0xD0,0x00,0x80,0x5F,0xC1,0x27,0x0E);
DEFINE_GUID(CLSID_WanConnectionManager,                     0xBA126AD5,0x2166,0x11D1,0xB1,0xD0,0x00,0x80,0x5F,0xC1,0x27,0x0E);
DEFINE_GUID(CLSID_WanConnectionManagerEnumConnection,       0xBA126AD6,0x2166,0x11D1,0xB1,0xD0,0x00,0x80,0x5F,0xC1,0x27,0x0E);
DEFINE_GUID(CLSID_DialupConnection,                         0xBA126AD7,0x2166,0x11D1,0xB1,0xD0,0x00,0x80,0x5F,0xC1,0x27,0x0E);
DEFINE_GUID(CLSID_NetGroupPolicies,                         0xBA126AD8,0x2166,0x11D1,0xB1,0xD0,0x00,0x80,0x5F,0xC1,0x27,0x0E);
DEFINE_GUID(CLSID_InboundConnection,                        0xBA126AD9,0x2166,0x11D1,0xB1,0xD0,0x00,0x80,0x5F,0xC1,0x27,0x0E);
DEFINE_GUID(CLSID_LanConnection,                            0xBA126ADB,0x2166,0x11D1,0xB1,0xD0,0x00,0x80,0x5F,0xC1,0x27,0x0E);
DEFINE_GUID(CLSID_InboundConnectionManager,                 0xBA126ADD,0x2166,0x11D1,0xB1,0xD0,0x00,0x80,0x5F,0xC1,0x27,0x0E);
DEFINE_GUID(CLSID_InboundConnectionManagerEnumConnection,   0xBA126ADE,0x2166,0x11D1,0xB1,0xD0,0x00,0x80,0x5F,0xC1,0x27,0x0E);
DEFINE_GUID(CLSID_SharedAccessConnectionManager,            0xBA126AE0,0x2166,0x11D1,0xB1,0xD0,0x00,0x80,0x5F,0xC1,0x27,0x0E);
DEFINE_GUID(CLSID_SharedAccessConnectionManagerEnumConnection, 0xBA126AE1,0x2166,0x11D1,0xB1,0xD0,0x00,0x80,0x5F,0xC1,0x27,0x0E);
DEFINE_GUID(CLSID_SharedAccessConnection,                   0xBA126AE2,0x2166,0x11D1,0xB1,0xD0,0x00,0x80,0x5F,0xC1,0x27,0x0E);

DEFINE_GUID(CLSID_InstallQueue,                             0xBA126ADF,0x2166,0x11D1,0xB1,0xD0,0x00,0x80,0x5F,0xC1,0x27,0x0E);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netman\inc\nmbase.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N M B A S E . H
//
//  Contents:   Base include file for netman.exe.  Defines globals.
//
//  Notes:
//
//  Author:     shaunco   15 Sep 1997
//
//----------------------------------------------------------------------------

#pragma once
#include "netcon.h"
#include "netconp.h"
#include <atlbase.h>
#include "ncstl.h"
#include <map>

enum EVENT_MANAGER
{
    INVALID_EVENTMGR = 0,
    EVENTMGR_CONMAN
};

#define PersistDataLead 0x14
#define PersistDataTrail 0x05

typedef struct tagRegEntry
{
    LPWSTR      strKeyName;
    LPWSTR      strValueName;
    DWORD       dwType;
    DWORD       dwValue;
    LPWSTR      strValue;
    BYTE*       pbValue;
    DWORD       dwBinLen;
    BOOL        fMoreOnKey;
} REGENTRY;

typedef map<GUID, INetConnectionManager*> CLASSMANAGERMAP;
bool operator < (const GUID& rguid1, const GUID& rguid2);

enum RASREFTYPE
{
    REF_INITIALIZE,
    REF_REFERENCE,
    REF_UNREFERENCE,
};

class CServiceModule : public CComModule
{
public:
    VOID    DllProcessAttach (IN  HINSTANCE hinst) throw();
    VOID    DllProcessDetach (IN  VOID) throw();

    VOID    ServiceMain (IN  DWORD argc, IN  LPCWSTR argv[]) throw();
    DWORD   DwHandler (IN DWORD  dwControl, 
                       IN DWORD  dwEventType,
                       IN LPCVOID pEventData, 
                       IN LPCVOID pContext);
    VOID    Run () throw();
    VOID    SetServiceStatus (IN  DWORD dwState) throw();
    VOID    UpdateServiceStatus (IN  BOOL fUpdateCheckpoint = TRUE) throw();
    DWORD   DwServiceStatus () throw() { return m_status.dwCurrentState; }

    VOID    ReferenceRasman (IN  RASREFTYPE RefType) throw();

private:
    static
    DWORD
    WINAPI TAKEOWNERSHIP
    _DwHandler (
        IN DWORD dwControl,
        IN DWORD dwEventType,
        IN WACKYAPI LPVOID pEventData,
        IN WACKYAPI LPVOID pContext);

public:
    HRESULT ServiceShutdown();
    HRESULT ServiceStartup();
    DWORD                   m_dwThreadID;
    SERVICE_STATUS_HANDLE   m_hStatus;
    SERVICE_STATUS          m_status;
    BOOL                    m_fRasmanReferenced;
};


extern CServiceModule _Module;
#include <atlcom.h>

#include "ncatl.h"
#include "ncstring.h"
#include "nmclsid.h"

typedef LPCVOID PCSID;

enum CONMAN_EVENTTYPE
{
    INVALID_TYPE = 0,
    CONNECTION_ADDED,
    CONNECTION_BANDWIDTH_CHANGE,
    CONNECTION_DELETED,
    CONNECTION_MODIFIED,
    CONNECTION_RENAMED,
    CONNECTION_STATUS_CHANGE,
    REFRESH_ALL,
    CONNECTION_ADDRESS_CHANGE,
    CONNECTION_BALLOON_POPUP,
    DISABLE_EVENTS
};

BOOL IsValidEventType(IN EVENT_MANAGER EventMgr, IN int EventType) throw();

// This LONG is incremented every time we get a notification that
// a RAS phonebook entry has been modified.  It is reset to zero
// when the service is started.  Wrap-around does not matter.  It's
// purpose is to let a RAS connection object know if it's cache should
// be re-populated with current information.
//
extern LONG g_lRasEntryModifiedVersionEra;

VOID
LanEventNotify (
    IN  CONMAN_EVENTTYPE    EventType,
    IN  INetConnection*     pConn,
    IN  PCWSTR              szwNewName,
    IN  const GUID *        pguidConn) throw();

VOID
IncomingEventNotify (
    IN  CONMAN_EVENTTYPE    EventType,
    IN  INetConnection*     pConn,
    IN  PCWSTR              szwNewName,
    IN  const GUID *        pguidConn) throw();

STDAPI
RegisterSvrHelper();

STDAPI
CreateEAPOLKeys();

STDAPI
SetKeySecurity(
    IN  DWORD dwKeyIndex,
    IN  PCSID psidUserOrGroup,
    IN  ACCESS_MASK dwAccessMask);

VOID
NTAPI
DispatchEvents(
    IN OUT LPVOID  pUnused,
    IN     BOOLEAN TimerOrWaitFired) throw();

HRESULT 
HrEnsureEventHandlerInitialized();

HRESULT
UninitializeEventHandler();

HRESULT
WINAPI
HrEnsureRegisteredWithNla();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netman\inc\nmhnet.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       N M H N E T. H
//
//  Contents:   Globals and routines used of hnetworking support
//
//  Notes:
//
//  Author:     jonburs     15 August 2000
//
//----------------------------------------------------------------------------

#pragma once

#include "nmres.h"
#include "netconp.h"
#include "hnetcfg.h"

//
// Cached IHNetCfgMgr pointer. This pointer is obtained the
// first time someone calls HrGetHNetCfgMgr, and is released
// when CleanupHNetSupport is called.
//

extern IHNetCfgMgr *g_pHNetCfgMgr;

//
// This value is incremented every time INetConnectionHNetUtil::NotifyUpdate()
// is called, and is used by connection objects to make sure that their
// cached homenet properties (sharing, bridging, firewall, etc.) are
// up to date. Rollover does not matter. This value is set to 0 when
// InitializeHNetSupport is called.
//

extern LONG g_lHNetModifiedEra;

VOID
InitializeHNetSupport(
    VOID
    );

VOID
CleanupHNetSupport(
    VOID
    );

HRESULT
HrGetHNetCfgMgr(
    IHNetCfgMgr **ppHNetCfgMgr
    );

class ATL_NO_VTABLE CNetConnectionHNetUtil :
    public CComObjectRootEx <CComMultiThreadModelNoCS>,
    public CComCoClass <CNetConnectionHNetUtil, &CLSID_NetConnectionHNetUtil>,
    public INetConnectionHNetUtil
{

public:

    BEGIN_COM_MAP(CNetConnectionHNetUtil)
        COM_INTERFACE_ENTRY(INetConnectionHNetUtil)
    END_COM_MAP()

    DECLARE_PROTECT_FINAL_CONSTRUCT()
    DECLARE_REGISTRY_RESOURCEID(IDR_HN_CONNECTION_UTIL)

    CNetConnectionHNetUtil()
    {
    }
    
    ~CNetConnectionHNetUtil()
    {
    }

    //
    // INetConnectionHNetUtil
    //

    STDMETHODIMP
    NotifyUpdate(
        VOID
        );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netman\inc\nmpolicy.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       N M P O L I C Y  . H
//
//  Contents:   Interface for verifying NLA policy settings.
//
//  Notes:      
//
//  Author:     ckotze   12 Dec 2000
//
//----------------------------------------------------------------------------

#pragma once
#include "nmbase.h"
#include "nmres.h"
#include "gpnla.h"

class ATL_NO_VTABLE CNetMachinePolicies : 
    public CComObjectRootEx <CComMultiThreadModel>,
    public CComCoClass <CNetMachinePolicies,
                        &CLSID_NetGroupPolicies>,
    public INetMachinePolicies

{
public:
    CNetMachinePolicies() throw();
    ~CNetMachinePolicies() throw();
    
    DECLARE_REGISTRY_RESOURCEID(IDR_NET_GROUP_POLICIES)

    BEGIN_COM_MAP(CNetMachinePolicies)
        COM_INTERFACE_ENTRY(INetMachinePolicies)
    END_COM_MAP()

    HRESULT STDMETHODCALLTYPE VerifyPermission(IN const DWORD ulPerm, OUT BOOL* pfPermission);

protected:
    CGroupPolicyNetworkLocationAwareness* m_pGroupPolicyNLA;
private:
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netman\inc\nminit.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N M I N I T . H
//
//  Contents:   Initialization routines for netman.
//
//  Notes:
//
//  Author:     shaunco   27 Jan 1998
//
//----------------------------------------------------------------------------

#pragma once

HRESULT
HrNmCreateClassObjectRegistrationEvent (
    OUT HANDLE* phEvent);

HRESULT
HrNmWaitForClassObjectsToBeRegistered ();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netman\inc\pch.h ===
#pragma once

#define COM_NO_WINDOWS_H
#define RPC_NO_WINDOWS_H
#define NOCOMM
#define NOCRYPT
#define NOGDI
#define NOHELP
#define NOICONS
#define NOIME
#define NOMCX
#define NOMDI
#define NOMENUS
#define NOMETAFILE
#define NOSOUND
#define NOSYSPARAMSINFO
#define NOWH
#define NOWINABLE
#define NOWINRES

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <objbase.h>

#include <cfgmgr32.h>
#include <devguid.h>
#include <setupapi.h>

#include <stdio.h>
#include <wchar.h>

#include "ncmem.h"
#include "ncbase.h"
#include "ncdebug.h"
#include "ncdefine.h"
#include "ncexcept.h"

#ifdef ENABLELEAKDETECTION
#include "nmbase.h"
template <class T>
class CComObjectRootExDbg : public CComObjectRootEx<T>, 
                            public CNetCfgDebug<T>
{
public:
    void FinalRelease()
    {
        CComObjectRootEx<T>::FinalRelease();
//      ISSUE_knownleak(this);
    }
};
#define CComObjectRootEx CComObjectRootExDbg
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netman\test\main.cpp ===
#include "pch.h"
#pragma hdrstop
#include <netcon.h>
#include <netconp.h>
#include <tchar.h>

EXTERN_C
VOID
__cdecl
wmain ()
/*
VOID
wmainCRTStartup (
    VOID
    )
*/
{
    HRESULT                 hr;
    INetConnectionManager * pconMan;

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED | COINIT_DISABLE_OLE1DDE);
    if (SUCCEEDED(hr))
    {
        hr = CoCreateInstance(CLSID_ConnectionManager, NULL,
                              CLSCTX_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
                              IID_INetConnectionManager,
                              (LPVOID *)&pconMan);
        if (SUCCEEDED(hr))
        {
            IEnumNetConnection* pEnum;
            hr = pconMan->EnumConnections(NCME_DEFAULT, &pEnum);

            if (SUCCEEDED(hr))
            {
                INetConnection* aNetCon [512];
                ULONG           cNetCon;

                hr = pEnum->Next (celems(aNetCon), aNetCon, &cNetCon);

                _tprintf(L"Number of connections: %d\r\n", cNetCon);

                if (SUCCEEDED(hr))
                {
                    for (ULONG i = 0; i < cNetCon; i++)
                    {
                        INetConnection* pNetCon = aNetCon[i];

                        NETCON_PROPERTIES* pProps;
                        hr = pNetCon->GetProperties (&pProps);
                        if (SUCCEEDED(hr))
                        {
                            _tprintf(L"Connection name: %s Type: %d\r\n", pProps->pszwName, pProps->MediaType);
                            
                            if (pProps->MediaType == NCT_LAN && pProps->Status == NCS_MEDIA_DISCONNECTED)
                            {
                                _tprintf(L"Connection %s (%s) is currently Disconnected", pProps->pszwName, pProps->pszwDeviceName);
                            }
                            if (pProps->dwCharacter & NCCF_INCOMING_ONLY)
                            {
                                _tprintf(L"Inbound Connection\r\n");
                                INetConnectionSysTray* pTray;
                                hr = pNetCon->QueryInterface(IID_INetConnectionSysTray, reinterpret_cast<void **>(&pTray));
                                _tprintf(L"QI returned: %x", hr);
                                if (SUCCEEDED(hr))
                                {
                                    pTray->IconStateChanged();
                                }
                            }

                            CoTaskMemFree(pProps);
                        }

                        ReleaseObj (pNetCon);
                    }
                }
                pEnum->Release();
            }

            pconMan->Release();
        }
        CoUninitialize();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netman\test\version.h ===
#pragma once

#include <ntverp.h>
#include <winver.h>

#define VER_FILETYPE                    VFT_DLL
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "Network Connections Manager Test App"
#define VER_INTERNALNAME_STR            "tnetman.exe"

#include <common.ver>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netman\ncqueue\ncqueue.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       N C Q U E U E . C P P
//
//  Contents:   NetCfg queued installer actions
//
//  Notes:
//
//  Author:     billbe   19 Aug 1998
//
//----------------------------------------------------------------------------


#include "pch.h"
#pragma hdrstop

#include "nceh.h"
#include "ncmisc.h"
#include "ncnetcfg.h"
#include "ncqueue.h"
#include "ncreg.h"
#include "ncsetup.h"
#include "ncui.h"
#include "nceh.h"
#include "wizentry.h"


const WCHAR c_szRegKeyNcQueue[] = L"SYSTEM\\CurrentControlSet\\Control\\Network\\NcQueue";
const DWORD c_cchQueueValueNameLen = 9;
const DWORD c_cbQueueValueNameLen = c_cchQueueValueNameLen * sizeof(WCHAR);

enum RO_ACTION
{
    RO_ADD,
    RO_CLEAR,
};

extern const WCHAR c_szRegValueNetCfgInstanceId[];

CRITICAL_SECTION    g_csRefCount;
DWORD               g_dwRefCount = 0;
HANDLE              g_hLastThreadExitEvent;

DWORD WINAPI
InstallQueueWorkItem(PVOID pvContext);


inline VOID
IncrementRefCount()
{
    EnterCriticalSection(&g_csRefCount);

    // If 0 is the current count and we have an event to reset...
    if (!g_dwRefCount && g_hLastThreadExitEvent)
    {
        ResetEvent(g_hLastThreadExitEvent);
    }
    ++g_dwRefCount;

    LeaveCriticalSection(&g_csRefCount);
}

inline VOID
DecrementRefCount()
{
    EnterCriticalSection(&g_csRefCount);

    --g_dwRefCount;

    // If the count is 0 and we have an event to signal...
    if (!g_dwRefCount && g_hLastThreadExitEvent)
    {
        SetEvent(g_hLastThreadExitEvent);
    }

    LeaveCriticalSection(&g_csRefCount);
}

//+---------------------------------------------------------------------------
//
//  Function:   WaitForInstallQueueToExit
//
//  Purpose:    This function waits until the last thread Called to continue processing the queue after processing was
//              stopped due to a shutdown (of teh Netman service or system)
//
//  Arguments:
//      none
//
//  Returns:    nothing
//
//  Author:     billbe   8 Sep 1998
//
//  Notes:
//
VOID
WaitForInstallQueueToExit()
{
    // Wait on the event if it was successfully created.
    if (g_hLastThreadExitEvent)
    {
        TraceTag(ttidInstallQueue, "Waiting on LastThreadExitEvent");
        (VOID) WaitForSingleObject(g_hLastThreadExitEvent, INFINITE);
        TraceTag(ttidInstallQueue, "Event signaled");
    }
    else
    {
        // If the event was not created, fall back to simply looping
        // on the ref count
        while (g_dwRefCount);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   ProcessQueue
//
//  Purpose:    Called to continue processing the queue after processing was
//              stopped due to a shutdown (of the Netman service or system)
//
//  Arguments:
//      none
//
//  Returns:    nothing
//
//  Author:     billbe   8 Sep 1998
//
//  Notes:
//
EXTERN_C VOID WINAPI
ProcessQueue()
{
    HRESULT                 hr;
    INetInstallQueue*       pniq;
    BOOL                    fInitCom = TRUE;

    TraceTag(ttidInstallQueue, "ProcessQueue called");
    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED | COINIT_DISABLE_OLE1DDE);
    if (RPC_E_CHANGED_MODE == hr)
    {
        hr = S_OK;
        fInitCom = FALSE;
    }

    if (SUCCEEDED(hr))
    {
        // Create the install queue object and get the install queue interface
        hr = CoCreateInstance(CLSID_InstallQueue, NULL,
                              CLSCTX_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
                              IID_INetInstallQueue,
                              reinterpret_cast<LPVOID *>(&pniq));
        if (S_OK == hr)
        {
            // Process whatever was left in the queue
            //
            pniq->ProcessItems();
            pniq->Release();
        }

        if (fInitCom)
        {
            CoUninitialize();
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   RunOnceAddOrClearItem
//
//  Purpose:    Adds or clears an entry to/from the RunOnce registry key.
//
//  Arguments:
//      pszValueName [in] The value name of the run once item
//      pszItemToRun [in] The actual command to "Run Once"
//      eAction      [in] RO_ADD to add the item, RO_CLEAR to clear the item.
//
//  Returns:    nothing
//
//  Author:     billbe   8 Sep 1998
//
//  Notes:
//
VOID
RunOnceAddOrClearItem (
    IN PCWSTR pszValueName,
    IN PCWSTR pszItemToRun,
    IN RO_ACTION eAction)
{
    static const WCHAR c_szRegKeyRunOnce[] = L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnce";
    HRESULT hr;
    HKEY    hkey;

    // Open the RunOnce key
    hr = HrRegOpenKeyEx (HKEY_LOCAL_MACHINE, c_szRegKeyRunOnce,
            KEY_WRITE, &hkey);

    if (S_OK == hr)
    {
        if (RO_ADD == eAction)
        {
            // Set the command line to run when the user logs in next.
            (VOID) HrRegSetSz (hkey, pszValueName, pszItemToRun);
            TraceTag(ttidInstallQueue, "Added %S RunOnce entry", pszValueName);
        }
        else if (RO_CLEAR == eAction)
        {
            // Remove the command line.
            (VOID) HrRegDeleteValue (hkey, pszValueName);
            TraceTag(ttidInstallQueue, "Cleared %S RunOnce entry", pszValueName);
        }

        RegCloseKey(hkey);
    }

}



//+---------------------------------------------------------------------------
//
//  Member:     CInstallQueue::CInstallQueue
//
//  Purpose:    CInstall queue constructor
//
//  Arguments:
//      (none)
//
//  Returns:    nothing
//
//  Author:     BillBe   10 Sep 1998
//
//  Notes:
//
CInstallQueue::CInstallQueue() throw (SE_Exception):
    m_dwNextAvailableIndex(0),
    m_hkey(NULL),
    m_nCurrentIndex(-1),
    m_cItems(0),
    m_aszItems(NULL),
    m_cItemsToDelete(0),
    m_aszItemsToDelete(NULL),
    m_fQueueIsOpen(FALSE)
{
    TraceTag(ttidInstallQueue, "Installer queue processor being created");

    InitializeCriticalSection (&m_csReadLock);
    InitializeCriticalSection (&m_csWriteLock);
    InitializeCriticalSection (&g_csRefCount);

    // Create an event that we will use to signal to interested parties
    // that we are done.  This is used by netman to wait for our threads
    // to exit before destroying this object
    g_hLastThreadExitEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

    // If the event could not be created, we can still go on, we just won't
    // use the event to signal our exit.
    if (!g_hLastThreadExitEvent)
    {
        TraceTag(ttidInstallQueue, "Error creating last thread exit "
                "event %d", GetLastError());
    }

    // Set the next available queue index so insertions won't overlap
    SetNextAvailableIndex();
}

//+---------------------------------------------------------------------------
//
//  Member:     CInstallQueue::FinalRelease
//
//  Purpose:    COM destructor
//
//  Arguments:
//      (none)
//
//  Returns:    nothing
//
//  Author:     BillBe   10 Sep 1998
//
//  Notes:
//
VOID
CInstallQueue::FinalRelease ()
{
    DeleteCriticalSection (&m_csWriteLock);
    DeleteCriticalSection (&m_csReadLock);
    DeleteCriticalSection (&g_csRefCount);
}

// INetInstallQueue

//+---------------------------------------------------------------------------
//
//  Function:   CInstallQueue::AddItem
//
//  Purpose:    Add item to the queue
//
//  Arguments:
//      pGuid                [in] The class guid of the device that was
//                                modified (installed. updated, or removed)
//      pszDeviceInstanceId  [in] The instance id of the device
//      pszInfId             [in] The inf id of the device
//      dwCharacter          [in] The device's characteristics
//      eType                [in] The install type (event) - indicates
//                                whether the device was installed, updated,
//                                or removed
//
//  Returns:    HRESULT. S_OK if successful, an error code otherwise.
//
//  Author:     billbe   25 Aug 1998
//
//  Notes:  If the device was removed, the device instance id will be the
//          instance guid of the device.  If the device was installed
//          or updated then the id will be the PnP instance id
//
STDMETHODIMP
CInstallQueue::AddItem (
    const NIQ_INFO* pInfo)
{
    Assert(pInfo);
    Assert(pInfo->pszPnpId);
    Assert(pInfo->pszInfId);

    if (!pInfo)
    {
        return E_POINTER;
    }

    if (!pInfo->pszPnpId)
    {
        return E_POINTER;
    }

    if (!pInfo->pszInfId)
    {
        return E_POINTER;
    }

    // Increment our refcount since we will be queueing a thread
    IncrementRefCount();

    // Add the item to the queue
    HRESULT hr = HrAddItem (pInfo);

    if (S_OK == hr)
    {
        // Start processing the queue on another thread
        hr = HrQueueWorkItem();
    }

    TraceHr (ttidError, FAL, hr, FALSE, "CInstallQueue::AddItem");
    return hr;
}


// CInstallQueue
//

//+---------------------------------------------------------------------------
//
//  Function:   CInstallQueue::HrQueueWorkItem
//
//  Purpose:    Start processing the queue on another thread
//
//  Arguments:
//      (none)
//
//  Returns:    HRESULT. S_OK if successful, an error code otherwise.
//
//  Author:     billbe   25 Aug 1998
//
//  Notes:
//
HRESULT
CInstallQueue::HrQueueWorkItem()
{
    HRESULT hr = S_OK;

    // Add ref our object since we will need it independent of whoever
    // called us
    AddRef();

    // Queue a work item thread
    if (!QueueUserWorkItem(InstallQueueWorkItem, this, WT_EXECUTEDEFAULT))
    {
        hr = HrFromLastWin32Error();
        Release();

        // The thread wasn't queued so reduce the ref count
        DecrementRefCount();
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CInstallQueue::SetNextAvailableIndex
//
//  Purpose:    Sets the member variable m_dwNextAvailableIndex to the next
//              available queue position (registry valuename)
//
//  Arguments:
//      none
//
//  Returns:    nothing
//
//  Author:     billbe   25 Aug 1998
//
//  Notes:
//
VOID
CInstallQueue::SetNextAvailableIndex()
{
    TraceTag(ttidInstallQueue, "Setting Next Available index");

    EnterCriticalSection(&m_csWriteLock);

    DWORD dwTempCount;

    HKEY hkey;
    // Open the NcQueue registry key
    HRESULT hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegKeyNcQueue,
            KEY_QUERY_VALUE, &hkey);

    if (S_OK == hr)
    {
        WCHAR  szValueName[c_cchQueueValueNameLen];
        DWORD  cbValueName;
        PWSTR pszStopString;
        DWORD  dwIndex = 0;
        DWORD  dwType;

        do
        {
            cbValueName = c_cchQueueValueNameLen;

            // Enumerate each value name
            hr = HrRegEnumValue(hkey, dwIndex, szValueName, &cbValueName,
                    &dwType, NULL, NULL);

            if (S_OK == hr)
            {
                // Convert the value name to a number
                dwTempCount = wcstoul(szValueName, &pszStopString, c_nBase16);

                // If the number is greater than our current count
                // adjust the current count
                if (dwTempCount >= m_dwNextAvailableIndex)
                {
                    m_dwNextAvailableIndex = dwTempCount + 1;
                }
            }
            ++dwIndex;
        } while (S_OK == hr);

        if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr)
        {
            hr = S_OK;
        }

        RegCloseKey(hkey);
    }
    else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
    {
        hr = S_OK;
    }

    TraceTag(ttidInstallQueue, "Next Available index set %d", m_dwNextAvailableIndex);
    LeaveCriticalSection(&m_csWriteLock);
}


// Compare strings given pointers to PCWSTRs
inline int __cdecl
iCompare(const void* ppszArg1, const void* ppszArg2)
{

    return lstrcmpW(*((PCWSTR*)(void*)ppszArg1), *((PCWSTR*)(void*)ppszArg2));
}


//+---------------------------------------------------------------------------
//
//  Function:   CInstallQueue::PncqiCreateItem
//
//  Purpose:    Creates a queue item
//
//  Arguments:
//      pguidClass           [in] The class guid of a device.
//      pszDeviceInstanceId  [in] The device id of the device.
//                                a pnp instance id if the device is being
//                                added or updated, a netcfg instance guid
//                                if it is being removed.
//      pszInfId             [in] The device's inf id.
//      dwCharacter          [in] The device's characteristics.
//      eType                [in] The notification for the item. Whether
//                                the device was installed, removed,
//                                or reinstalled.
//
//  Returns:    NCQUEUE_ITEM.  The newly created item.
//
//  Author:     billbe   25 Aug 1998
//
//  Notes:
//
NCQUEUE_ITEM*
CInstallQueue::PncqiCreateItem(
    const NIQ_INFO* pInfo)
{
    Assert(pInfo);
    Assert(pInfo->pszPnpId);
    Assert(pInfo->pszInfId);

    // The size of the item is the size of the structure plus the size of
    // the device id we are appending to the structure
    DWORD cbPnpId = CbOfSzAndTerm (pInfo->pszPnpId);
    DWORD cbInfId = CbOfSzAndTerm (pInfo->pszInfId);
    DWORD cbSize = sizeof(NCQUEUE_ITEM) + cbPnpId + cbInfId;

    NCQUEUE_ITEM* pncqi = (NCQUEUE_ITEM*)MemAlloc(cbSize);

    if (pncqi)
    {
        pncqi->cbSize = sizeof(NCQUEUE_ITEM);
        pncqi->eType = pInfo->eType;
        pncqi->dwCharacter = pInfo->dwCharacter;
        pncqi->dwDeipFlags = pInfo->dwDeipFlags;
        pncqi->cchPnpId = wcslen(pInfo->pszPnpId);
        pncqi->cchInfId = wcslen(pInfo->pszInfId);
        pncqi->ClassGuid = pInfo->ClassGuid;
        pncqi->InstanceGuid = pInfo->InstanceGuid;
        CopyMemory((BYTE*)pncqi + pncqi->cbSize, pInfo->pszPnpId, cbPnpId);
        CopyMemory((BYTE*)pncqi + pncqi->cbSize + cbPnpId,
                   pInfo->pszInfId, cbInfId);
    }

    return pncqi;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrAddItem
//
//  Purpose:    Worker function that adds an item to the queue
//
//  Arguments:
//      pguidClass [in] The class guid of a device
//      pszwDeviceInstanceId [in] The device id of the device
//                                a pnp instance id if the device is being
//                                added or updated, a netcfg instance guid
//                                if it is being removed
//      eType [in] The notification for the item. Whether the device
//                   was installed, removed, or reinstalled.
//
//  Returns:    HRESULT. S_OK if successful, an error code otherwise.
//
//  Author:     billbe   25 Aug 1998
//
//  Notes:
//
HRESULT
CInstallQueue::HrAddItem(
    const NIQ_INFO* pInfo)
{
    HRESULT hr = S_OK;
    Assert(pInfo->pszPnpId);
    Assert(pInfo->pszInfId);

    EnterCriticalSection(&m_csWriteLock);

    // Create the structure to be stored in the registry
    NCQUEUE_ITEM* pncqi = PncqiCreateItem(pInfo);

    if (pncqi)
    {
        // Open the NcQueue registry key
        //
        HKEY hkey;
        hr = HrRegCreateKeyEx(HKEY_LOCAL_MACHINE, c_szRegKeyNcQueue,
                                      0, KEY_READ_WRITE, NULL, &hkey, NULL);
                                      
        if (S_OK == hr)
        {
            // Store the queue item under the next available valuename
            //
            WCHAR szValue[c_cchQueueValueNameLen];
            wsprintfW(szValue, L"%.8X", m_dwNextAvailableIndex);
            
            hr = HrRegSetValueEx(hkey, szValue, REG_BINARY, (BYTE*)pncqi,
                                 DwSizeOfItem(pncqi));
                                 
            if (S_OK == hr)         
            {
                // Update the global count string
                ++m_dwNextAvailableIndex;
            }
            RegCloseKey(hkey);
        }
        
        MemFree(pncqi);
    }
    LeaveCriticalSection(&m_csWriteLock);

    TraceError("CInstallQueue::HrAddItem", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CInstallQueue::DeleteMarkedItems
//
//  Purpose:    Deletes, from the registry, any values that have been
//              marked for delete.
//
//  Arguments:
//      none
//
//  Returns:    nothing
//
//  Author:     billbe   25 Aug 1998
//
//  Notes:
//
VOID
CInstallQueue::DeleteMarkedItems()
{
    Assert(m_hkey);

    // If we have items to delete...
    if (m_cItemsToDelete)
    {
        Assert(m_aszItemsToDelete);

        // Remove each one from the registry
        //
        for (DWORD dw = 0; dw < m_cItemsToDelete; ++dw)
        {
            RegDeleteValue(m_hkey, m_aszItemsToDelete[dw]);
        }
    }

    // Free the array and reset the pointer and counter
    //
    MemFree(m_aszItemsToDelete);
    m_aszItemsToDelete = NULL;
    m_cItemsToDelete = 0;
}


//+---------------------------------------------------------------------------
//
//  Function:   CInstallQueue::HrRefresh
//
//  Purpose:    Refreshs our snapshot of the queue.
//
//  Arguments:
//      none
//
//  Returns:    HRESULT. S_OK if successful and the queue has items,
//                       S_FALSE if the queue is empty,
//                       an error code otherwise.
///
//  Author:     billbe   25 Aug 1998
//
//  Notes:
//
HRESULT
CInstallQueue::HrRefresh()
{
    Assert(m_hkey);

    // We don't want items being added to the queue while we are
    // refreshing our snapshot, so we use a critical section to keep
    // things
    //
    EnterCriticalSection(&m_csWriteLock);

    // Do some housecleaning before the refresh
    //
    DeleteMarkedItems();
    FreeAszItems();

    // Retrieve the number of items in the queue
    HRESULT hr = HrRegQueryInfoKey(m_hkey, NULL, NULL, NULL, NULL,
            NULL, &m_cItems, NULL, NULL, NULL, NULL);

    if (S_OK == hr)
    {
        Assert(0 <= (INT) m_cItems);

        // If the queue is not empty...
        if (0 < m_cItems)
        {
            DWORD cbValueLen;

            // Allocate the array of pointers to strings for the items.
            // Also, allocate the same quantity of pointers to hold
            // items we will delete from the queue
            DWORD cbArraySize = m_cItems * sizeof(PWSTR*);
            m_aszItems =
                    reinterpret_cast<PWSTR*>(MemAlloc(cbArraySize));

            if (m_aszItems)
            {
                m_aszItemsToDelete =
                        reinterpret_cast<PWSTR*>(MemAlloc(cbArraySize));

                if (m_aszItemsToDelete)
                {

                    // Store all the value names
                    // We will need to sort them so we can process each device in the
                    // correct order
                    //
                    DWORD dwType;
                    for (DWORD dw = 0; dw < m_cItems; ++dw)
                    {
                        m_aszItems[dw] =
                                reinterpret_cast<PWSTR>(MemAlloc(c_cbQueueValueNameLen));
                        if (m_aszItems[dw])
                        {
                            cbValueLen = c_cchQueueValueNameLen;
                            (void) HrRegEnumValue(m_hkey, dw,
                                    m_aszItems[dw], &cbValueLen,
                                    &dwType, NULL, NULL);
                        }
                        else
                        {
                            hr = E_OUTOFMEMORY;
                        }
                    }

                    // Sort the value names in ascending order.  The value names
                    // are string versions of numbers padded to the left with zeroes
                    // e.g. 00000001
                    qsort(m_aszItems, m_cItems, sizeof(PWSTR), iCompare);
                }
                else
                {
                    MemFree(m_aszItems);
                    hr = E_OUTOFMEMORY;
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            // no items in the queue
            hr = S_FALSE;

            // The next items entered should start with valuename 00000000
            m_dwNextAvailableIndex = 0;
        }
    }
    else
    {
        // Refresh not possible so invalidate the key
        RegCloseKey(m_hkey);
        m_hkey = NULL;
    }

    // Reset Queue Index to just before the first element since
    // retrieval is always done on the next element
    m_nCurrentIndex = -1;

    // Items can now be added to the queue
    LeaveCriticalSection(&m_csWriteLock);

    TraceError("CInstallQueue::HrRefresh",
            (S_FALSE == hr) ? S_OK : hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CInstallQueue::HrOpen
//
//  Purpose:    Opens the netcfg installer queue
//
//  Arguments:
//      None
//
//  Returns:    HRESULT. S_OK if successful and the queue has items,
//                       S_FALSE if the queue is empty,
//                       an error code otherwise.
//
//  Author:     billbe   25 Aug 1998
//
//  Notes:  When the queue is opened, it is a snapshot of the current queue
//          state.  i.e. items could be added after the fact.  To refresh the
//          snapshot, use RefreshQueue.
//
HRESULT
CInstallQueue::HrOpen()
{
    HRESULT hr = S_OK;

    // We don't want any other thread to process the queue since we will
    // continue to retrieve new items that are added while we are
    // processing the initial set
    EnterCriticalSection(&m_csReadLock);

    AssertSz(!m_hkey, "Reopening NcQueue without closing first!");

    // We might have been waiting for a bit.  Make sure the system
    // is not shutting down before continuing
    //
    if (SERVICE_RUNNING == _Module.DwServiceStatus ())
    {
        hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegKeyNcQueue,
                KEY_ALL_ACCESS, &m_hkey);

        if (S_OK == hr)
        {
            // Get a current snapshot of what's in the queue
            // by refreshing
            hr = HrRefresh();

            if (SUCCEEDED(hr))
            {
                // The queue is officially open
                m_fQueueIsOpen = TRUE;
            }
        }
    }
    else
    {
        TraceTag(ttidInstallQueue, "HrOpen::System is shutting down");
        hr = HRESULT_FROM_WIN32(ERROR_SHUTDOWN_IN_PROGRESS);
    }

    TraceError("CInstallQueue::HrOpen",
               ((S_FALSE == hr) ||
                (HRESULT_FROM_WIN32(ERROR_SHUTDOWN_IN_PROGRESS)) == hr) ?
               S_OK : hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   CInstallQueue::Close
//
//  Purpose:    Closes the netcfg installer queue
//
//  Arguments:
//      None
//
//  Returns:    nothing
//
//  Author:     billbe   25 Aug 1998
//
//  Notes:
//
VOID
CInstallQueue::Close()
{
    if (m_fQueueIsOpen)
    {
        // Housecleaning
        //

        // Delete anything so marked
        DeleteMarkedItems();

        // Free up the list of value names (aka queue items)
        FreeAszItems();

        RegSafeCloseKey(m_hkey);
        m_hkey = NULL;

        // Queue is now closed
        m_fQueueIsOpen = FALSE;
    }

    // Other threads may have a chance at the queue now
    LeaveCriticalSection(&m_csReadLock);
}

//+---------------------------------------------------------------------------
//
//  Function:   CInstallQueue::MarkCurrentItemForDeletion
//
//  Purpose:    Marks the current item for deletion from the registry
//              when the queue is refreshed or closed
//
//  Arguments:
//      None
//
//  Returns:    nothing
//
//  Author:     billbe   25 Aug 1998
//
//  Notes:
//
VOID
CInstallQueue::MarkCurrentItemForDeletion()
{
    AssertSz(FIsQueueIndexInRange(), "Queue index out of range");

    if (FIsQueueIndexInRange())
    {
        // The number of items to delete should never exceed the number
        // of queue items in our snapshot
        if (m_cItemsToDelete < m_cItems)
        {
            // Just store a pointer, in m_aszItemsToDelete, to the value name
            // pointed to by m_aszItems
            //
            m_aszItemsToDelete[m_cItemsToDelete] = m_aszItems[m_nCurrentIndex];
            ++m_cItemsToDelete;
        }
        else
        {
            TraceTag(ttidError, "Too many items marked for deletion");
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   CInstallQueue::HrGetNextItem
//
//  Purpose:    Get's the next item in the queue
//
//  Arguments:
//      None
//
//  Returns:    HRESULT. S_OK is successful,
//              ERROR_NO_MORE_ITEMS (hresult version), if there are no
//              more items in the queue.  An error code otherwise.
//
//  Author:     billbe   25 Aug 1998
//
//  Notes:
//
HRESULT
CInstallQueue::HrGetNextItem(NCQUEUE_ITEM** ppncqi)
{
    Assert(ppncqi);

    HRESULT hr;

    // Increment index to the next value
    ++m_nCurrentIndex;

    // If we haven't gone past the end of the queue...
    if (FIsQueueIndexInRange())
    {
        // assign convenience pointer
        PCWSTR pszItem = m_aszItems[m_nCurrentIndex];

        DWORD cbData;

        // Get the next queue item from the registry
        //
        hr = HrRegQueryValueEx(m_hkey, pszItem, NULL, NULL, &cbData);

        if (S_OK == hr)
        {
            *ppncqi = (NCQUEUE_ITEM*)MemAlloc(cbData);
            
            if( *ppncqi )
            {
                DWORD dwType;
                hr = HrRegQueryValueEx(m_hkey, pszItem, &dwType,
                    (BYTE*)(*ppncqi), &cbData);

                if (S_OK == hr)
                {
                    Assert(REG_BINARY == dwType);
                    Assert((*ppncqi)->cchPnpId == (DWORD)
                           (wcslen((PWSTR)((BYTE*)(*ppncqi) +
                           (*ppncqi)->cbSize))));
                    Assert((*ppncqi)->cchInfId == (DWORD)
                           (wcslen((PWSTR)((BYTE*)(*ppncqi) +
                           (*ppncqi)->cbSize +
                          ((*ppncqi)->cchPnpId + 1) * sizeof(WCHAR)))));

                    // change union variable from the count of characters
                    // to the actual string pointer
                    SetItemStringPtrs(*ppncqi);
                }
                else
                {
                    MemFree(*ppncqi);
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
    }

    TraceError("CInstallQueue::HrGetNextItem",
            (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr) ? S_OK : hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   EnumerateQueueItemsAndDoNotifications
//
//  Purpose:    Enumerates each item in the queue and notifies INetCfg
//              of the modification (event)
//
//  Arguments:
//      pINetCfg                 [in]  INetCfg interface
//      pinq                     [in]  The INetInstallQueue interface
//      hdi                      [in]  See Device Installer Api for more info
//      pfReboot                 [out] TRUE if INetCfg requested a reboot,
//                                     FALSE otherwise
//
//  Returns:    HRESULT. S_OK is successful, an error code otherwise
//
//  Author:     billbe   8 Sep 1998
//
//  Notes:
//
BOOL
EnumerateQueueItemsAndDoNotifications(
    INetCfg* pINetCfg,
    INetCfgInternalSetup* pInternalSetup,
    CInstallQueue* pniq,
    HDEVINFO hdi,
    BOOL* pfReboot)
{
    Assert(pINetCfg);
    Assert(pniq);
    Assert(IsValidHandle(hdi));
    Assert(pfReboot);

    NCQUEUE_ITEM*   pncqi;
    SP_DEVINFO_DATA deid;
    HRESULT         hr;
    BOOL            fStatusOk = TRUE;

    // Go through each item in the queue and add to INetCfg
    //
    while (S_OK == (hr = pniq->HrGetNextItem(&pncqi)))
    {
        // If we are not shutting down...
        if (SERVICE_RUNNING == _Module.DwServiceStatus ())
        {
            if (NCI_INSTALL == pncqi->eType)
            {
                NIQ_INFO Info;
                ZeroMemory(&Info, sizeof(Info));
                Info.ClassGuid = pncqi->ClassGuid;
                Info.InstanceGuid = pncqi->InstanceGuid;
                Info.dwCharacter = pncqi->dwCharacter;
                Info.dwDeipFlags = pncqi->dwDeipFlags;
                Info.pszPnpId = pncqi->pszPnpId;
                Info.pszInfId = pncqi->pszInfId;

                // Notify INetCfg
                hr = HrDiAddComponentToINetCfg(
                        pINetCfg, pInternalSetup, &Info);
            }
            else if (NCI_UPDATE == pncqi->eType)
            {
                pInternalSetup->EnumeratedComponentUpdated(pncqi->pszPnpId);
            }
            else if (NCI_REMOVE == pncqi->eType)
            {
                hr = pInternalSetup->EnumeratedComponentRemoved (
                        pncqi->pszPnpId);
            }

            if (SUCCEEDED(hr))
            {
                // Store the reboot result
                if (NETCFG_S_REBOOT == hr)
                {
                    *pfReboot = TRUE;
                }
                TraceTag(ttidInstallQueue, "Deleting item");
                pniq->MarkCurrentItemForDeletion();
            }
            else
            {
                if (NETCFG_E_NEED_REBOOT == hr)
                {
                    // Stop processing the queue since INetCfg will
                    // refuse updates.
                    hr = HRESULT_FROM_WIN32(ERROR_SHUTDOWN_IN_PROGRESS);
                    fStatusOk = FALSE;
                }
                else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
                {
                    // INetCfg couldn't find the adapter.  Maybe someone
                    // removed it before we could notify INetCfg.
                    //
                    if (NCI_REMOVE != pncqi->eType)
                    {
                        HDEVINFO hdi;
                        SP_DEVINFO_DATA deid;

                        // Double check if the device is there.
                        // If it is, we need to remove it since INetCfg
                        // refuses to acknowledge its presence.
                        //
                        hr = HrSetupDiCreateDeviceInfoList (&pncqi->ClassGuid,
                                NULL, &hdi);

                        if (S_OK == hr)
                        {
                            hr = HrSetupDiOpenDeviceInfo (hdi,
                                    pncqi->pszPnpId, NULL, 0, &deid);

                            if (S_OK == hr)
                            {
                                (VOID) HrSetupDiRemoveDevice (hdi, &deid);
                            }

                            SetupDiDestroyDeviceInfoList (hdi);
                        }

                        // Stop trying to notify INetCfg.
                        //
                        pniq->MarkCurrentItemForDeletion();
                    }
                }
                else
                {
                    // Display message on error??
                    TraceHr (ttidError, FAL, hr, FALSE,
                            "EnumerateQueueItemsAndDoNotifications");
                }
            }
        }
        else
        {
            TraceTag(ttidInstallQueue, "System is shutting down during processing");
            hr = HRESULT_FROM_WIN32(ERROR_SHUTDOWN_IN_PROGRESS);
        }
        MemFree(pncqi);

        if (HRESULT_FROM_WIN32(ERROR_SHUTDOWN_IN_PROGRESS) == hr)
        {
            break;
        }
    }

    // This error is expected when enumeration is complete
    if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr)
    {
        hr = S_OK;
    }

    TraceError("EnumerateQueueItemsAndDoNotifications", hr);
    return fStatusOk;
}

//+---------------------------------------------------------------------------
//
//  Function:   InstallerQueueWorkItem
//
//  Purpose:    The LPTHREAD_START_ROUTINE passed to QueueUserWorkItem to
//              handle the work of notifying INetCfg and the Connections
//              wizard of an installation event.
//
//  Arguments:
//      pvContext [in] A pointer to a CInstallQueue class.
//
//  Returns:    NOERROR
//
//  Author:     billbe   25 Aug 1998
//
//  Notes:      The CInstallQueue was AddRef'd to insure its existence
//              while we use it.  This function must release it before
//              exiting.
//
DWORD WINAPI
InstallQueueWorkItem(PVOID pvContext)
{
    const WCHAR c_szInstallQueue[] = L"Install Queue";
    const WCHAR c_szProcessQueue[] = L"rundll32 netman.dll,ProcessQueue";
    const WCHAR c_szRegValueNcInstallQueue[] = L"NCInstallQueue";

    CInstallQueue* pniq = reinterpret_cast<CInstallQueue*>(pvContext);
    Assert(pniq);

    BOOL fReboot = FALSE;
    BOOL fInitCom = TRUE;

    // We need to continue processing when the system is rebooted.
    RunOnceAddOrClearItem (c_szRegValueNcInstallQueue,
            c_szProcessQueue, RO_ADD);

    HRESULT hr = CoInitializeEx (NULL,
                    COINIT_MULTITHREADED | COINIT_DISABLE_OLE1DDE);

    if (RPC_E_CHANGED_MODE == hr)
    {
        hr = S_OK;
        fInitCom = FALSE;
    }

    TraceHr (ttidError, FAL, hr, FALSE, "InstallQueueWorkItem: "
            "CoInitializeEx failed");

    if (SUCCEEDED(hr))
    {
        // Open the queue, this will give us a snapshot of what is in the queue
        // at this time
        hr = pniq->HrOpen();

        if (S_OK == hr)
        {
            // Create an HDEVINFO
            HDEVINFO hdi;
            hr = HrSetupDiCreateDeviceInfoList(NULL, NULL, &hdi);

            if (S_OK == hr)
            {
                INetCfg* pINetCfg;
                INetCfgInternalSetup* pInternalSetup;
                DWORD cmsTimeout = 500;

                // As long as we are not shutting down. keep trying to get a
                // writable INetCfg.
                do
                {
                    // Increase the time we wait each iteration.
                    cmsTimeout = cmsTimeout >= 512000 ? 512000 : cmsTimeout * 2;

                    // If we are not in the process of shutting down...
                    if (SERVICE_RUNNING == _Module.DwServiceStatus())
                    {
                        // Try to get a writable INetCfg
                        hr = HrCreateAndInitializeINetCfg(NULL, &pINetCfg,
                                TRUE, cmsTimeout, c_szInstallQueue, NULL);
                        if (NETCFG_E_NEED_REBOOT == hr)
                        {
                            hr = HRESULT_FROM_WIN32(ERROR_SHUTDOWN_IN_PROGRESS);
                            break;
                        }
                    }
                    else
                    {
                        // Times up! Pencils down!  Netman is shutting down
                        // we need to stop processing
                        hr = HRESULT_FROM_WIN32(ERROR_SHUTDOWN_IN_PROGRESS);
                        break;
                    }

                } while (FAILED(hr));

                if (S_OK == hr)
                {
                    hr = pINetCfg->QueryInterface (IID_INetCfgInternalSetup,
                            (void**)&pInternalSetup);
                    if (S_OK == hr)
                    {
                        // Go through the queue notifying interested modules
                        do
                        {
                            if (!EnumerateQueueItemsAndDoNotifications(pINetCfg,
                                    pInternalSetup, pniq, hdi, &fReboot))
                            {
                                hr = HRESULT_FROM_WIN32(ERROR_SHUTDOWN_IN_PROGRESS);
                                continue;
                            }

                            if (SERVICE_RUNNING == _Module.DwServiceStatus ())
                            {
                                TraceTag(ttidInstallQueue, "Refreshing queue");
                                // Check to see if any items were added to the queue
                                // after we started processing it
                                hr = pniq->HrRefresh();

                                if (S_FALSE == hr)
                                {
                                    // We are finished so we can remove
                                    // the entry in runonce that would
                                    // start the queue processing on login.
                                    RunOnceAddOrClearItem (
                                            c_szRegValueNcInstallQueue,
                                            c_szProcessQueue, RO_CLEAR);
                                }
                            }
                            else
                            {
                                hr = HRESULT_FROM_WIN32(ERROR_SHUTDOWN_IN_PROGRESS);
                            }
                        } while (S_OK == hr);

                        ReleaseObj (pInternalSetup);
                    }

                    (VOID) HrUninitializeAndReleaseINetCfg(FALSE, pINetCfg,
                            TRUE);

                }
                SetupDiDestroyDeviceInfoList(hdi);
            }
        }

        // Close the queue
        pniq->Close();

        DecrementRefCount();

        if (fInitCom)
        {
            CoUninitialize();
        }
    }

    if (FAILED(hr))
    {
        // Display error.
    }

    // If a reboot is required and we are not in setup or already shutting
    // down prompt the user.
    //
    if (fReboot && (SERVICE_RUNNING == _Module.DwServiceStatus()) &&
            !FInSystemSetup())
    {
        // Handle reboot prompt
        DWORD dwFlags = QUFR_REBOOT | QUFR_PROMPT;

        (VOID) HrNcQueryUserForReboot(_Module.GetResourceInstance(),
                                      NULL, IDS_INSTALLQUEUE_CAPTION,
                                      IDS_INSTALLQUEUE_REBOOT_REQUIRED,
                                      dwFlags);
    }

    TraceTag(ttidInstallQueue, "User Work Item Completed");

    TraceError("InstallQueueWorkItem", (S_FALSE == hr) ? S_OK : hr);
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netman\inc\nmres.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N M R E S . H
//
//  Contents:   Master resource header for netman.exe
//
//  Notes:
//
//  Author:     shaunco   15 Sep 1997
//
//----------------------------------------------------------------------------

#pragma once

//+---------------------------------------------------------------------------
// Strings resources
//
#define IDS_INBOUND_CONFIG_CONNECTION_NAME  100
#define IDS_LAN_DEFAULT_CONN_NAME           101
#define IDS_INSTALLQUEUE_CAPTION            102
#define IDS_INSTALLQUEUE_REBOOT_REQUIRED    103
#define IDS_ELAN_DEFAULT_CONN_NAME          104
#define IDS_ATM_DEFAULT_CONN_NAME           105
#define IDS_SHAREDACCESS_DEFAULT_CONN_NAME  106
#define IDS_SHAREDACCESS_CONN_NAME          107
#define IDS_BRIDGE_DEFAULT_CONN_NAME        108

//+---------------------------------------------------------------------------
// Reigstry resources
//

// Netman application
//
#define IDR_NETMAN                  100

// Connection Manager
//
#define IDR_CONMAN                  101
#define IDR_CONMAN_ENUM             102

// Connection Class Managers
//
#define IDR_INBOUND_CONMAN          103
#define IDR_INBOUND_CONMAN_ENUM     104
#define IDR_LAN_CONMAN              105
#define IDR_LAN_CONMAN_ENUM         106
#define IDR_WAN_CONMAN              107
#define IDR_WAN_CONMAN_ENUM         108

// Connection Objects
//
#define IDR_DIALUP_CONNECTION       109
#define IDR_DIRECT_CONNECTION       110
#define IDR_INBOUND_CONNECTION      111
#define IDR_INTERNET_CONNECTION     112
#define IDR_LAN_CONNECTION          113
#define IDR_VPN_CONNECTION          114

// Install queue
//
#define IDR_INSTALLQUEUE            115

// Connection Manager 2
//
#define IDR_CONMAN2                 122


// Shared Access Connection Class Manager

#define IDR_SA_CONMAN                120
#define IDR_SA_CONMAN_ENUM           117
#define IDR_SA_CONNECTION            118

// Home networking util

#define IDR_HN_CONNECTION_UTIL       119

// NetGroupPolicies

#define IDR_NET_GROUP_POLICIES      121
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netoc\nccm.cpp ===
//+---------------------------------------------------------------------------
//
// File:     NCCM.CPP
//
// Module:   NetOC.DLL
//
// Synopsis: Implements the dll entry points required to integrate into
//           NetOC.DLL the installation of the following components.
//
//              CMAK, PBS, PBA
//
// Copyright (C)  Microsoft Corporation.  All rights reserved.
//
// Author:  quintinb   15 Dec 1998
//
//+---------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "nccm.h"


//+---------------------------------------------------------------------------
//
//  Function:   HrOcExtCMAK
//
//  Purpose:    NetOC external message handler
//
//  Arguments:
//      pnocd  []
//      uMsg   []
//      wParam []
//      lParam []
//
//  Returns:
//
//  Author:     danielwe   17 Sep 1998
//
//  Notes:
//
HRESULT HrOcExtCMAK(PNETOCDATA pnocd, UINT uMsg,
                    WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = S_OK;

    Assert(pnocd);

    switch (uMsg)
    {
    case NETOCM_QUEUE_FILES:

        hr = HrOcCmakPreQueueFiles(pnocd);
        TraceError("HrOcExtCMAK -- HrOcCmakPreQueueFiles Failed", hr);

        break;

    case NETOCM_POST_INSTALL:

        hr = HrOcCmakPostInstall(pnocd);
        TraceError("HrOcExtCMAK -- HrOcCmakPostInstall Failed", hr);

        break;
    }

    TraceError("HrOcExtCMAK", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOcExtCPS
//
//  Purpose:    NetOC external message handler
//
//  Arguments:
//      pnocd  []
//      uMsg   []
//      wParam []
//      lParam []
//
//  Returns:
//
//  Author:     quintinb   26 Jan 2002
//
//  Notes:
//
HRESULT HrOcExtCPS(PNETOCDATA pnocd, UINT uMsg,
                   WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = S_OK;

    Assert(pnocd);

    switch (uMsg)
    {
    case NETOCM_QUEUE_FILES:

        //
        //  PBA is in value add, but add back the start menu link if an upgrade
        //
        hr = HrOcCpaPreQueueFiles(pnocd);
        TraceError("HrOcExtCPS -- HrOcCpaPreQueueFiles Failed", hr);

        hr = HrOcCpsPreQueueFiles(pnocd);
        TraceError("HrOcExtCPS -- HrOcCpsPreQueueFiles Failed", hr);

        break;

    case NETOCM_POST_INSTALL:

        hr = HrOcCpsOnInstall(pnocd);
        TraceError("HrOcExtCPS -- HrOcCpsOnInstall Failed", hr);

        break;
    }

    TraceError("HrOcExtCPS", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netoc\implinc.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-1999.
//
//  File:       I M P L I N C . C P P
//
//  Contents:
//
//  Notes:
//
//  Author:     shaunco   25 Nov 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "ncxbase.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

// Include ATL's implementation.  Substitute _ASSERTE with our Assert.
//
#ifdef _ASSERTE
#undef _ASSERTE
#define _ASSERTE Assert
#endif

#include <atlimpl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netoc\dllmain.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       D L L M A I N . C P P
//
//  Contents:   Networking Optional component DLL
//
//  Notes:
//
//  Author:     danielwe   18 Dec 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include <ncxbase.h>
#include <ncreg.h>
#include "nceh.h"

// Optional component setup
#include "netoc.h"
#include "netocp.h"


BEGIN_OBJECT_MAP(ObjectMap)
END_OBJECT_MAP()

// Global
CComModule _Module;


EXTERN_C
BOOL
WINAPI
DllMain (
    HINSTANCE hInstance,
    DWORD dwReason,
    LPVOID /*lpReserved*/)
{
    if (DLL_PROCESS_ATTACH == dwReason)
    {
#ifndef DBG
        DisableThreadLibraryCalls (hInstance);
#endif

        BOOL fRetVal = FALSE;

        EnableCPPExceptionHandling(); // Translate any SEH exceptions into CPP exceptions.

        // Initialize fusion
        fRetVal = SHFusionInitializeFromModuleID(hInstance, 50);
        Assert(fRetVal);

        InitializeDebugging();

        _Module.Init (ObjectMap, hInstance);
    }
    else if (DLL_PROCESS_DETACH == dwReason)
    {
        _Module.Term ();
        UnInitializeDebugging();

        SHFusionUninitialize();

        DisableCPPExceptionHandling(); // Disable translation of SEH exceptions into CPP exceptions.
    }
#ifdef DBG
    else if (dwReason == DLL_THREAD_DETACH)
    {
        CTracingIndent::FreeThreadInfo();        
    }
#endif
        return TRUE;    // ok
}

//+---------------------------------------------------------------------------
//
//  Function:   NetOcSetupProc
//
//  Purpose:
//
//  Arguments:
//      pvComponentId    []
//      pvSubcomponentId []
//      uFunction        []
//      uParam1          []
//      pvParam2         []
//
//  Returns:
//
//  Author:     danielwe   12 Dec 1997
//
//  Notes:
//
EXTERN_C
DWORD
WINAPI
NetOcSetupProc (
    LPCVOID pvComponentId,
    LPCVOID pvSubcomponentId,
    UINT uFunction,
    UINT uParam1,
    LPVOID pvParam2)
{
    return NetOcSetupProcHelper(pvComponentId, pvSubcomponentId, uFunction,
                                uParam1, pvParam2);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netoc\nccm.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       NCCM.H
//
//  Contents:   Installation support for Connection Manager Administration kit
//  Contents:   Installation support for Connection Point Services -- Phonebook Admin
//  Contents:   Installation support for Connection Point Services -- Phonebook Server
//
//  Notes:
//
//  Author:     quintinb 26 Jan 1999
//
//----------------------------------------------------------------------------

#ifndef _NCCM_H_
#define _NCCM_H_

#pragma once

#include <aclapi.h>

#include "netoc.h"
#include "netocp.h"
#include "ncreg.h"

//  Types
//
enum e_rootType {www, ftp};

//  Function Headers
//

// Extension Procs
HRESULT HrOcExtCMAK(PNETOCDATA pnocd, UINT uMsg, WPARAM wParam, LPARAM lParam);
HRESULT HrOcExtCPS(PNETOCDATA pnocd, UINT uMsg, WPARAM wParam, LPARAM lParam);

//CMAK
HRESULT HrOcCmakPreQueueFiles(PNETOCDATA pnocd);
HRESULT HrOcCmakPostInstall(PNETOCDATA pnocd);
BOOL migrateProfiles(PCTSTR pszSource, PCWSTR pszDestination);
BOOL RenameProfiles32(PCTSTR pszCMAKpath, PCWSTR pszProfilesDir);
void DeleteOldCmakSubDirs(PCWSTR pszCmakPath);
void DeleteIeakCmakLinks();
void DeleteProgramGroupWithLinks(PCWSTR pszGroupPath);
void DeleteOldNtopLinks();

//PBA
HRESULT HrOcCpaPreQueueFiles(PNETOCDATA pnocd);
//HRESULT HrOcCpaOnInstall(PNETOCDATA pnocd);
//HRESULT RefCountPbaSharedDlls(BOOL bIncrement);
//HRESULT UnregisterAndDeleteDll(PCWSTR pszFile);
//HRESULT HrGetDaoInstallPath(PWSTR pszDaoPath, DWORD dwNumChars);
//HRESULT HrGetPbaInstallPath(PWSTR pszCpaPath, DWORD dwNumChars);
//HRESULT RegisterDll(PCWSTR pszFile);

//PBS
HRESULT HrOcCpsOnInstall(PNETOCDATA pnocd);
HRESULT HrOcCpsPreQueueFiles(PNETOCDATA pnocd);
BOOL RegisterPBServerDataSource();
BOOL CreateCPSVRoots();
BOOL RemoveCPSVRoots();
BOOL LoadPerfmonCounters();
HRESULT SetVirtualRootAccessPermissions(PWSTR pszVirtDir, DWORD dwAccessPermissions);
HRESULT SetVirtualRootNoAnonymous(PWSTR pszVirtDir);
HRESULT AddNewVirtualRoot(e_rootType rootType, PWSTR pszDir, PWSTR pszPath);
HRESULT DeleteVirtualRoot(e_rootType rootType, PWSTR pszPath);
HRESULT SetDirectoryAccessPermissions(PCWSTR pszFile, ACCESS_RIGHTS AccessRightsToModify, ULONG fAccessFlags, PSID pSid);
void SetCpsDirPermissions();
HRESULT CreateNewAppPoolAndAddPBS();
HRESULT DeleteAppPool();
HRESULT EnableISAPIRequests(PCTSTR szComponentName);
HRESULT UseProcessToEnableDisablePBS(BOOL fEnable);
HRESULT HrMoveOldCpsInstall(PCWSTR pszProgramFiles);
HRESULT HrGetWwwRootDir(PWSTR pszWwwRoot, UINT uWwwRootCount);

#endif // _NCCM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netoc\nccmak.cpp ===
//+---------------------------------------------------------------------------
//
// File:     NCCMAK.CPP
//
// Module:   NetOC.DLL
//
// Synopsis: Implements the dll entry points required to integrate into
//           NetOC.DLL the installation of the following components.
//
//              NETCMAK
//
// Copyright (C)  Microsoft Corporation.  All rights reserved.
//
// Author:   a-anasj 9 Mar 1998
//           quintinb   18 Sep 1998 --  rewrote
//
//+---------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>
#include "ncatl.h"

#include "resource.h"

#include "nccm.h"

//
//  Define Globals
//
WCHAR g_szCmakPath[MAX_PATH+1];

//
//  Define Strings Chars
//
static const WCHAR c_szCmakRegPath[] = L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\CMAK.EXE";
static const WCHAR c_szPathValue[] = L"Path";
static const WCHAR c_szProfiles32Fmt[] = L"%s\\Profiles-32";
static const WCHAR c_szCm32Fmt[] = L"%s\\cm32";
static const WCHAR c_szProfilesFmt[] = L"%s\\Profiles";
static const WCHAR c_szSupportFmt[] = L"%s\\Support";
static const WCHAR c_szCmHelpFmt[] = L"%s\\Support\\CmHelp";
static const WCHAR c_szCmakGroup[] = L"Connection Manager Administration Kit";

const DWORD c_dwCmakDirID = 123174; // just must be larger than DIRID_USER = 0x8000;


//+---------------------------------------------------------------------------
//
//  Function:   HrOcCmakPreQueueFiles
//
//  Purpose:    Called by optional components installer code before any files
//              are copied to handle any additional installation processing
//              for the Connection Manager Administration Kit.
//
//  Arguments:
//      pnocd           [in]   Pointer to NETOC data.
//
//  Returns:    S_OK if successfull, Win32 error otherwise.
//
//  Author:     quintinb 18 Sep 1998
//
//  Notes:
//
HRESULT HrOcCmakPreQueueFiles(PNETOCDATA pnocd)
{
    HRESULT hr = S_OK;

    if ((IT_INSTALL == pnocd->eit) || (IT_UPGRADE == pnocd->eit) || (IT_REMOVE == pnocd->eit))
    {
        //  Figure out if CMAK is already installed
        //      if so, save where it is located

        HKEY hKey;
        ZeroMemory(g_szCmakPath, sizeof(g_szCmakPath));

        hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szCmakRegPath, KEY_READ, &hKey);

        if (SUCCEEDED(hr))
        {
            DWORD dwSize = sizeof(g_szCmakPath);

            if (ERROR_SUCCESS != RegQueryValueExW(hKey, c_szPathValue, NULL, NULL,
                (LPBYTE)g_szCmakPath, &dwSize))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
            }

            RegCloseKey(hKey);
        }
        else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
        {
            //  This is  a fresh install of CMAK, don't return an error
            //
            hr = SHGetSpecialFolderPath(NULL, g_szCmakPath, CSIDL_PROGRAM_FILES, FALSE);
            if (SUCCEEDED(hr))
            {
                lstrcatW(g_szCmakPath, L"\\Cmak");
            }
        }

        if (SUCCEEDED(hr))
        {
            //  Next Create the CMAK Dir ID
            //
            hr = HrEnsureInfFileIsOpen(pnocd->pszComponentId, *pnocd);
            if (SUCCEEDED(hr))
            {
                if(!SetupSetDirectoryId(pnocd->hinfFile, c_dwCmakDirID, g_szCmakPath))
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                }
            }
        }
    }

    TraceError("HrOcCmakPreQueueFiles", hr);
    return hr;

}

//+---------------------------------------------------------------------------
//
//  Function:   HrOcCmakPostInstall
//
//  Purpose:    Called by optional components installer code to handle
//              additional installation requirements for Connection Manager Administration Kit.
//
//  Arguments:
//      pnocd           [in]   Pointer to NETOC data.
//
//  Returns:    S_OK if successfull, Win32 error otherwise.
//
//  Author:     a-anasj 9 Mar 1998
//
//  Notes:
//
HRESULT HrOcCmakPostInstall(PNETOCDATA pnocd)
{
    HRESULT hr = S_OK;
    WCHAR szTempDest[MAX_PATH+1];

    if ((IT_INSTALL == pnocd->eit) || (IT_UPGRADE == pnocd->eit))
    {
        //
        //  Then we need to migrate profiles and potentially delete old directories
        //

        if (L'\0' != g_szCmakPath[0])
        {
            wsprintfW(szTempDest, c_szProfilesFmt, g_szCmakPath);

            //
            //  Rename Profiles-32 to Profiles
            //

            BOOL bFail = !RenameProfiles32(g_szCmakPath, szTempDest);
            hr = bFail ? E_UNEXPECTED: S_OK;

            //
            //  Migrate 1.0 Profiles
            //
            bFail = !migrateProfiles(g_szCmakPath, szTempDest);
            hr = bFail ? E_UNEXPECTED: S_OK;

            //
            //  Delete the old directories (cm32 and its sub-dirs)
            //

            DeleteOldCmakSubDirs(g_szCmakPath);
        DeleteOldNtopLinks();
            DeleteIeakCmakLinks();
        }
    }
    else if (IT_REMOVE == pnocd->eit)
    {
        //
        //  We use the g_szCmakPath string to hold where CMAK was installed.
        //  To Properly delete the CMAK directory, we must delete the following
        //  directories CMAK\Support\CMHelp, CMAK\Support, CMAK\Profiles, and CMAK.
        //  We should only delete these directories if they are empty of both files
        //  and sub-dirs.
        //
        wsprintfW(szTempDest, c_szCmHelpFmt, g_szCmakPath);
        if (!RemoveDirectory(szTempDest))
        {
            TraceError("HrOcCmakPostInstall -- Removing CMHelp Dir",
                HRESULT_FROM_WIN32(GetLastError()));
        }

        wsprintfW(szTempDest, c_szSupportFmt, g_szCmakPath);
        if (!RemoveDirectory(szTempDest))
        {
            TraceError("HrOcCmakPostInstall -- Removing Support Dir",
                HRESULT_FROM_WIN32(GetLastError()));
        }

        wsprintfW(szTempDest, c_szProfilesFmt, g_szCmakPath);
        if (!RemoveDirectory(szTempDest))
        {
            TraceError("HrOcCmakPostInstall -- Removing Profiles Dir",
                HRESULT_FROM_WIN32(GetLastError()));
        }

        if (!RemoveDirectory(g_szCmakPath))
        {
            TraceError("HrOcCmakPostInstall -- Removing CMAK Dir",
                HRESULT_FROM_WIN32(GetLastError()));
        }
    }

    TraceError("HrOcCmakPostInstall", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   migrateProfiles
//
//  Purpose:    This is the function that migrates the profiles.  It takes the current
//              CMAK dir as its first input and the new CMAK dir as its second input..
//
//  Arguments:  PCWSTR pszSource - root of source CMAK dir
//              PCWSTR pszDestination - root of destination CMAK dir
//
//  Returns:    BOOL - Returns TRUE if it was able to migrate the profiles.
//
//  Author:     a-anasj   9 Mar 1998
//
//  Notes:
// History:   quintinb Created    12/9/97
//
BOOL migrateProfiles(PCWSTR pszSource, PCWSTR pszDestination)
{
    WCHAR szSourceProfileSearchString[MAX_PATH+1];
    WCHAR szFile[MAX_PATH+1];
    HANDLE hFileSearch;
    WIN32_FIND_DATA wfdFindData;
    BOOL bReturn = TRUE;
    SHFILEOPSTRUCT fOpStruct;

    //
    //  Initialize the searchstring and the destination dir
    //

    wsprintfW(szSourceProfileSearchString, L"%s\\*.*", pszSource);

    //
    //  Create the destination directory
    //

    CreateDirectory(pszDestination, NULL); //lint !e534 this might fail if it already exists

    hFileSearch = FindFirstFile(szSourceProfileSearchString, &wfdFindData);

    while (INVALID_HANDLE_VALUE != hFileSearch)
    {

        if((wfdFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
            (0 != _wcsicmp(wfdFindData.cFileName, L"cm32")) && // 1.1/1.2 Legacy
            (0 != _wcsicmp(wfdFindData.cFileName, L"cm16")) && // 1.1/1.2 Legacy
            (0 != _wcsicmp(wfdFindData.cFileName, L"Docs")) &&
            (0 != _wcsicmp(wfdFindData.cFileName, L"Profiles-32")) && // 1.1/1.2 Legacy
            (0 != _wcsicmp(wfdFindData.cFileName, L"Profiles-16")) && // 1.1/1.2 Legacy
            (0 != _wcsicmp(wfdFindData.cFileName, L"Support")) &&
            (0 != _wcsicmp(wfdFindData.cFileName, L"Profiles")) &&
            (0 != _wcsicmp(wfdFindData.cFileName, L".")) &&
            (0 != _wcsicmp(wfdFindData.cFileName, L"..")))
        {
            //
            //  Then I have a profile directory
            //

            ZeroMemory(&fOpStruct, sizeof(fOpStruct));
            ZeroMemory(szFile, sizeof(szFile));
            wsprintfW(szFile, L"%s\\%s", pszSource, wfdFindData.cFileName);

            fOpStruct.hwnd = NULL;
            fOpStruct.wFunc = FO_MOVE;
            fOpStruct.pTo = pszDestination;
            fOpStruct.pFrom = szFile;
            fOpStruct.fFlags = FOF_SILENT | FOF_NOCONFIRMATION | FOF_NOCONFIRMMKDIR;

            bReturn &= (0== SHFileOperation(&fOpStruct));   //lint !e514, intended use of boolean, quintinb
        }

        //
        //  Check to see if we have any more Files
        //
        if (!FindNextFile(hFileSearch, &wfdFindData))
        {
            if (ERROR_NO_MORE_FILES != GetLastError())
            {
                //
                //  We had some unexpected error, report unsuccessful completion
                //
                bReturn = FALSE;
            }

            //
            //  Exit the loop
            //
            break;
        }
    }

    if (INVALID_HANDLE_VALUE != hFileSearch)
    {
        FindClose(hFileSearch);
    }

    return bReturn;
}

//+---------------------------------------------------------------------------
//
//  Function:   RenameProfiles32
//
//  Purpose:    Takes the inputted CMAK path, appends Profiles-32 to it, and then
//              renames the resulting dir to the path inputted as pszProfilesDir.
//              Note this dir must exist for it to be renamed.
//
//  Arguments:  PCWSTR pszCMAKpath - current cmak path
//              PCWSTR pszProfilesDir - new profiles directory path
//
//  Returns:    BOOL - Returns TRUE if succeeded
//
//  Author:     quintinb   13 Aug 1998
//
//  Notes:
BOOL RenameProfiles32(PCWSTR pszCMAKpath, PCWSTR pszProfilesDir)
{
    SHFILEOPSTRUCT fOpStruct;
    WCHAR szTemp[MAX_PATH+1];

    ZeroMemory(&fOpStruct, sizeof(fOpStruct));
    ZeroMemory(szTemp, sizeof(szTemp));

    wsprintfW(szTemp, c_szProfiles32Fmt, pszCMAKpath);

    if (SetFileAttributes(szTemp, FILE_ATTRIBUTE_NORMAL))
    {
        fOpStruct.hwnd = NULL;
        fOpStruct.wFunc = FO_MOVE;
        fOpStruct.pTo = pszProfilesDir;
        fOpStruct.pFrom = szTemp;
        fOpStruct.fFlags = FOF_SILENT | FOF_NOCONFIRMATION | FOF_NOCONFIRMMKDIR;

        return (0== SHFileOperation(&fOpStruct));   //lint !e514, intended use of boolean, quintinb
    }
    else
    {
        return TRUE;
    }

}

//+---------------------------------------------------------------------------
//
//  Function:   DeleteOldCmakSubDirs
//
//  Purpose:    Deletes the old Cmak sub directories.  Uses FindFirstFile becuase
//              we don't want to delete any customized doc files that the user may
//              have customized.  Thus anything in the CMHelp directory except the
//              original help files is deleted.
//
//  Arguments:  PCWSTR pszCMAKpath - current cmak path
//
//  Returns:    Nothing
//
//  Author:     quintinb   6 Nov 1998
//
//  Notes:
void DeleteOldCmakSubDirs(PCWSTR pszCmakPath)
{
    WCHAR szCm32path[MAX_PATH+1];
    WCHAR szCm32SearchString[MAX_PATH+1];
    WCHAR szTemp[MAX_PATH+1];
    HANDLE hCm32FileSearch;
    WIN32_FIND_DATA wfdCm32;

    //
    // Delete the old IEAK Docs Dir
    //
    wsprintfW(szTemp, L"%s\\%s", pszCmakPath, SzLoadIds(IDS_OC_OLD_IEAK_DOCDIR));
    RemoveDirectory(szTemp);

    wsprintfW(szCm32path, c_szCm32Fmt, pszCmakPath);

    //
    //  First look in the Cm32 directory itself.  Delete all files found, continue down
    //  into subdirs.
    //

    wsprintfW(szCm32SearchString, L"%s\\*.*", szCm32path);

    hCm32FileSearch = FindFirstFile(szCm32SearchString, &wfdCm32);

    while (INVALID_HANDLE_VALUE != hCm32FileSearch)
    {

        if (wfdCm32.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
        {
            if ((0 != lstrcmpiW(wfdCm32.cFileName, L".")) &&
               (0 != lstrcmpiW(wfdCm32.cFileName, L"..")))
            {
                //
                //  Then we want to delete all the files in this lang sub dir and we
                //  we want to delete the four help files from the CM help dir.  If all the
                //  files are deleted from a dir then we should remove the directory.
                //
                WCHAR szLangDirSearchString[MAX_PATH+1];
                HANDLE hLangDirFileSearch;
                WIN32_FIND_DATA wfdLangDir;

                wsprintfW(szLangDirSearchString, L"%s\\%s\\*.*", szCm32path,
                    wfdCm32.cFileName);

                hLangDirFileSearch = FindFirstFile(szLangDirSearchString, &wfdLangDir);

                while (INVALID_HANDLE_VALUE != hLangDirFileSearch)
                {
                    if (wfdLangDir.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                    {
                        if ((0 != lstrcmpiW(wfdLangDir.cFileName, L".")) &&
                           (0 != lstrcmpiW(wfdLangDir.cFileName, L"..")))
                        {
                            //
                            //  We only want to delete help files from our help source dirs
                            //
                            if (0 == _wcsnicmp(wfdLangDir.cFileName, L"CM", 2))
                            {
                                //
                                //  Delete the four help files only.
                                //
                                wsprintfW(szTemp, L"%s\\%s\\%s\\cmctx32.rtf", szCm32path,
                                    wfdCm32.cFileName, wfdLangDir.cFileName);
                                DeleteFile(szTemp);

                                wsprintfW(szTemp, L"%s\\%s\\%s\\cmmgr32.h", szCm32path,
                                    wfdCm32.cFileName, wfdLangDir.cFileName);
                                DeleteFile(szTemp);

                                wsprintfW(szTemp, L"%s\\%s\\%s\\cmmgr32.hpj", szCm32path,
                                    wfdCm32.cFileName, wfdLangDir.cFileName);
                                DeleteFile(szTemp);

                                wsprintfW(szTemp, L"%s\\%s\\%s\\cmtrb32.rtf", szCm32path,
                                    wfdCm32.cFileName, wfdLangDir.cFileName);
                                DeleteFile(szTemp);

                                //
                                //  Now try to remove the directory
                                //
                                wsprintfW(szTemp, L"%s\\%s\\%s", szCm32path,
                                    wfdCm32.cFileName, wfdLangDir.cFileName);
                                RemoveDirectory(szTemp);
                            }
                        }
                    }
                    else
                    {
                        wsprintfW(szTemp, L"%s\\%s\\%s", szCm32path, wfdCm32.cFileName,
                            wfdLangDir.cFileName);

                        DeleteFile(szTemp);
                    }

                    //
                    //  Check to see if we have any more Files
                    //
                    if (!FindNextFile(hLangDirFileSearch, &wfdLangDir))
                    {
                        //
                        //  Exit the loop
                        //
                        break;
                    }
                }

                if (INVALID_HANDLE_VALUE != hLangDirFileSearch)
                {
                    FindClose(hLangDirFileSearch);

                    //
                    //  Now try to remove the lang dir directory
                    //
                    wsprintfW(szTemp, L"%s\\%s", szCm32path, wfdCm32.cFileName);
                    RemoveDirectory(szTemp);
                }
            }
        }
        else
        {
            wsprintfW(szTemp, L"%s\\%s", szCm32path, wfdCm32.cFileName);

            DeleteFile(szTemp);
        }

        //
        //  Check to see if we have any more Files
        //
        if (!FindNextFile(hCm32FileSearch, &wfdCm32))
        {
            if (INVALID_HANDLE_VALUE != hCm32FileSearch)
            {
                FindClose(hCm32FileSearch);
            }

            //
            //  Now try to remove the cm32 directory
            //
            RemoveDirectory(szCm32path);

            //
            //  Exit the loop
            //
            break;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   DeleteProgramGroupWithLinks
//
//  Purpose:    Utility function to delete a given program group and its links.
//              Thus if you pass in the full path to a program group to delete,
//              the function does a findfirstfile to find and delete any links.
//              The function ignores sub-dirs.
//
//
//  Arguments:  PCWSTR pszGroupPath - Full path to the program group to delete.
//
//  Returns:    Nothing
//
//  Author:     quintinb   6 Nov 1998
//
//  Notes:
void DeleteProgramGroupWithLinks(PCWSTR pszGroupPath)
{
    HANDLE hLinkSearch;
    WIN32_FIND_DATA wfdLinks;
    WCHAR szLinkSearchString[MAX_PATH+1];
    WCHAR szTemp[MAX_PATH+1];

    wsprintfW(szLinkSearchString, L"%s\\*.*", pszGroupPath);

    hLinkSearch = FindFirstFile(szLinkSearchString, &wfdLinks);

    while (INVALID_HANDLE_VALUE != hLinkSearch)
    {
        if (!(wfdLinks.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
        {
            wsprintfW(szTemp, L"%s\\%s", pszGroupPath, wfdLinks.cFileName);

            DeleteFile(szTemp);
        }

        //
        //  Check to see if we have any more Files
        //
        if (!FindNextFile(hLinkSearch, &wfdLinks))
        {
            FindClose(hLinkSearch);

            //
            //  Now try to remove the directory
            //
            RemoveDirectory(pszGroupPath);

            //
            //  Exit the loop
            //
            break;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   DeleteOldNtopLinks
//
//  Purpose:    Deletes the old links from the NT 4.0 Option Pack
//
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//  Author:     quintinb   6 Nov 1998
//
//  Notes:
void DeleteOldNtopLinks()
{
    HRESULT hr;

    //
    //  First Delete the old NTOP4 Path
    //
    WCHAR szGroup[MAX_PATH+1];
    WCHAR szTemp[MAX_PATH+1];

    //
    //  Get the CSIDL_COMMON_PROGRAMS value
    //
    hr = SHGetSpecialFolderPath(NULL, szTemp, CSIDL_COMMON_PROGRAMS, FALSE);
    if (SUCCEEDED(hr))
    {
        wsprintfW(szGroup, L"%s\\%s\\%s", szTemp,
            (PWSTR)SzLoadIds(IDS_OC_NTOP4_GROUPNAME),
            (PWSTR)SzLoadIds(IDS_OC_ICS_GROUPNAME));

        DeleteProgramGroupWithLinks(szGroup);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   DeleteIeakCmakLinks
//
//  Purpose:    Deletes the old links from the IEAK4 CMAK
//
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//  Author:     quintinb   6 Nov 1998
//
//  Notes:
void DeleteIeakCmakLinks()
{
    WCHAR szUserDirRoot[MAX_PATH+1];
    WCHAR szGroup[MAX_PATH+1];
    WCHAR szTemp[MAX_PATH+1];
    WCHAR szEnd[MAX_PATH+1];


    //
    //  Next Delete the old IEAK CMAK links
    //
    //
    //  Get the Desktop directory and then remove the desktop part.  This will give us the
    //  root of the user directories.
    //
    HRESULT hr = SHGetSpecialFolderPath(NULL, szUserDirRoot, CSIDL_DESKTOPDIRECTORY, FALSE);
    if (SUCCEEDED(hr))
    {

        //
        //  Remove \\Desktop
        //
        WCHAR* pszTemp = wcsrchr(szUserDirRoot, L'\\');
        if (NULL == pszTemp)
        {
            return;
        }
        else
        {
            *pszTemp = L'\0';
        }

        HRESULT hr = SHGetSpecialFolderPath(NULL, szTemp, CSIDL_PROGRAMS, FALSE);

        if (SUCCEEDED(hr))
        {
            if (0 == _wcsnicmp(szUserDirRoot, szTemp, wcslen(szUserDirRoot)))
            {
                lstrcpyW(szEnd, &(szTemp[wcslen(szUserDirRoot)]));
            }
        }

        //
        //  Remove \\<User Name>>
        //
        pszTemp = wcsrchr(szUserDirRoot, L'\\');
        if (NULL == pszTemp)
        {
            return;
        }
        else
        {
            *pszTemp = L'\0';
        }

        //
        //  Now start searching for user dirs to delete the CMAK group from
        //
        WCHAR szUserDirSearchString[MAX_PATH+1];
        HANDLE hUserDirSearch;
        WIN32_FIND_DATA wfdUserDirs;

        wsprintfW(szUserDirSearchString, L"%s\\*.*", szUserDirRoot);
        hUserDirSearch = FindFirstFile(szUserDirSearchString, &wfdUserDirs);

        while (INVALID_HANDLE_VALUE != hUserDirSearch)
        {
            if ((wfdUserDirs.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
                (0 != _wcsicmp(wfdUserDirs.cFileName, L".")) &&
                (0 != _wcsicmp(wfdUserDirs.cFileName, L"..")))
            {
                wsprintfW(szGroup, L"%s\\%s%s\\%s", szUserDirRoot, wfdUserDirs.cFileName,
                    szEnd, c_szCmakGroup);
                DeleteProgramGroupWithLinks(szGroup);

            }

            if (!FindNextFile(hUserDirSearch, &wfdUserDirs))
            {
                FindClose(hUserDirSearch);

                //
                //  Exit the loop
                //
                break;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netoc\nccpa.cpp ===
//+---------------------------------------------------------------------------
//
// File:     NCNetCPA.CPP
//
// Module:   NetOC.DLL
//
// Synopsis: Implements the dll entry points required to integrate into
//           NetOC.DLL the installation of the following components.
//
//              NETCPS
//
// Copyright (C)  Microsoft Corporation.  All rights reserved.
//
// Author:   Anas Jarrah (a-anasj) Created    3/9/98
//
//+---------------------------------------------------------------------------


#include "pch.h"
#pragma hdrstop

#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>
#include "ncatl.h"

#include "resource.h"

#include "nccm.h"

//
//  Define Globals
//
WCHAR g_szCpaPath[MAX_PATH+1];
WCHAR g_szDaoPath[MAX_PATH+1];

//
//  Define Constants
//
const DWORD c_dwCpaDirID = 123176;  // just must be larger than DIRID_USER = 0x8000;
const DWORD c_dwDaoDirID = 123177;  // just must be larger than DIRID_USER = 0x8000;

const WCHAR* const c_szDaoClientsPath = L"SOFTWARE\\Microsoft\\Shared Tools\\DAO\\Clients";
const WCHAR* const c_szCommonFilesPath = L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion";
const WCHAR* const c_szCommonFilesDirValue = L"CommonFilesDir";

HRESULT HrGetPBAPathIfInstalled(PWSTR pszCpaPath, DWORD dwNumChars)
{
    HRESULT hr;
    HKEY hKey;
    BOOL bFound = FALSE;

    //  We need to see if PBA is installed or not.  If it is then we want to 
    //  add back the PBA start menu link.  If it isn't, then we want to do nothing
    //  with PBA.
    //

    ZeroMemory(pszCpaPath, sizeof(WCHAR)*dwNumChars);
    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szDaoClientsPath, KEY_READ, &hKey);

    if (SUCCEEDED(hr))
    {
        WCHAR szCurrentValue[MAX_PATH+1];
        WCHAR szCurrentData[MAX_PATH+1];
        DWORD dwValueSize = MAX_PATH;
        DWORD dwDataSize = MAX_PATH;
        DWORD dwType;
        DWORD dwIndex = 0;

        while (ERROR_SUCCESS == RegEnumValue(hKey, dwIndex, szCurrentValue, &dwValueSize, NULL, &dwType,
               (LPBYTE)szCurrentData, &dwDataSize))
        {
            _wcslwr(szCurrentValue);
            if (NULL != wcsstr(szCurrentValue, L"pbadmin.exe"))
            {
                //
                //  Then we have found the PBA path
                //

                WCHAR* pszTemp = wcsrchr(szCurrentValue, L'\\');
                if (NULL != pszTemp)
                {
                    *pszTemp = L'\0';
                    lstrcpyW(pszCpaPath, szCurrentValue);
                    bFound = TRUE;
                    break;
                }
            }
            dwValueSize = MAX_PATH;
            dwDataSize = MAX_PATH;
            dwIndex++;
        }

        RegCloseKey(hKey);
    }

    if (!bFound)
    {
        //  We didn't find PBA, so lets return S_FALSE
        //
        hr = S_FALSE;
    }
    else
    {
        hr = S_OK;
    }

    return hr;
}

BOOL GetAdminToolsFolder(PWSTR pszAdminTools)
{
    BOOL bReturn = FALSE;

    if (pszAdminTools)
    {
        bReturn = SHGetSpecialFolderPath(NULL, pszAdminTools, CSIDL_COMMON_PROGRAMS, TRUE);

        if (bReturn)
        {
            //  Now Append Administrative Tools
            //
            lstrcat(pszAdminTools, SzLoadIds(IDS_OC_ADMIN_TOOLS));            
        }
    }

    return bReturn;
}

HRESULT HrCreatePbaShortcut(PWSTR pszCpaPath)
{
    HRESULT hr = CoInitialize(NULL);

    if (SUCCEEDED(hr))
    {
        IShellLink *psl = NULL;

        hr = CoCreateInstance(CLSID_ShellLink, NULL,
                CLSCTX_INPROC_SERVER, //CLSCTX_LOCAL_SERVER,
                IID_IShellLink,
                (LPVOID*)&psl);
        
        if (SUCCEEDED(hr))
        {
            IPersistFile *ppf = NULL;

            // Set up the properties of the Shortcut
            //
            static const WCHAR c_szPbAdmin[] = L"\\pbadmin.exe";

            WCHAR szPathToPbadmin[MAX_PATH+1] = {0};
            DWORD dwLen = lstrlen(c_szPbAdmin) + lstrlen(pszCpaPath) + 1;

            if (MAX_PATH >= dwLen)
            {
                //  Set the Path to pbadmin.exe
                //
                lstrcpy(szPathToPbadmin, pszCpaPath);
                lstrcat(szPathToPbadmin, c_szPbAdmin);
            
                hr = psl->SetPath(szPathToPbadmin);
            
                if (SUCCEEDED(hr))
                {
                    //  Set the Description to Phone Book Administrator
                    //
                    hr = psl->SetDescription(SzLoadIds(IDS_OC_PBA_DESC));

                    if (SUCCEEDED(hr))
                    {
                        hr = psl->QueryInterface(IID_IPersistFile,
                                                 (LPVOID *)&ppf);
                        if (SUCCEEDED(hr))
                        {
                            WCHAR szAdminTools[MAX_PATH+1] = {0};                            
                            if (GetAdminToolsFolder(szAdminTools))
                            {
                                // Create the link file.
                                //
                                hr = ppf->Save(szAdminTools, TRUE);
                            }

                            ReleaseObj(ppf);
                        }                    
                    }
                }
            }

            ReleaseObj(psl);
        }

        CoUninitialize();
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOcCpaPreQueueFiles
//
//  Purpose:    Called by optional components installer code to handle
//              additional installation requirements for PhoneBook Server.
//
//  Arguments:
//      pnocd           [in]   Pointer to NETOC data.
//
//  Returns:    S_OK if successfull, Win32 error otherwise.
//
//  Author:     quintinb 18 Sep 1998
//
//  Notes:
//
HRESULT HrOcCpaPreQueueFiles(PNETOCDATA pnocd)
{
    HRESULT hr = S_OK;

    switch ( pnocd->eit )
    {
    case IT_UPGRADE:

        WCHAR szPbaInstallPath[MAX_PATH+1];

        hr = HrGetPBAPathIfInstalled(szPbaInstallPath, MAX_PATH);

        if (S_OK == hr)
        {
            HrCreatePbaShortcut(szPbaInstallPath);
        }

	break;

    case IT_INSTALL:
    case IT_REMOVE:

        break;
    }

    TraceError("HrOcCpaPreQueueFiles", hr);
    return hr;
}


/*
//+---------------------------------------------------------------------------
//
//  Function:   HrOcCpaPreQueueFiles
//
//  Purpose:    Called by optional components installer code to handle
//              additional installation requirements for PhoneBook Server.
//
//  Arguments:
//      pnocd           [in]   Pointer to NETOC data.
//
//  Returns:    S_OK if successfull, Win32 error otherwise.
//
//  Author:     quintinb 18 Sep 1998
//
//  Notes:
//
HRESULT HrOcCpaPreQueueFiles(PNETOCDATA pnocd)
{
    HRESULT hr = S_OK;

    switch ( pnocd->eit )
    {
    case IT_UPGRADE:
    case IT_INSTALL:
    case IT_REMOVE:

        //
        //  Get the PBA install Dir.
        //
        hr = HrGetPbaInstallPath(g_szCpaPath, celems(g_szCpaPath));

        if (SUCCEEDED(hr))
        {
            //  Next Create the CPA Dir ID
            //
            hr = HrEnsureInfFileIsOpen(pnocd->pszComponentId, *pnocd);
            if (SUCCEEDED(hr))
            {
                if(!SetupSetDirectoryId(pnocd->hinfFile, c_dwCpaDirID, g_szCpaPath))
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                }
            }
        }

        //
        //  Now query the system for the DAO350 install path
        //

        if (SUCCEEDED (hr))
        {
            hr = HrGetDaoInstallPath(g_szDaoPath, celems(g_szDaoPath));
            if (SUCCEEDED(hr))
            {
                //  Next Create the DAO Dir ID
                //
                hr = HrEnsureInfFileIsOpen(pnocd->pszComponentId, *pnocd);
                if (SUCCEEDED(hr))
                {
                    if(!SetupSetDirectoryId(pnocd->hinfFile, c_dwDaoDirID, g_szDaoPath))
                    {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                    }
                }
            }
        }

        break;
    }

    TraceError("HrOcCpaPreQueueFiles", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOcCpaOnInstall
//
//  Purpose:    Called by optional components installer code to handle
//              additional installation requirements for PhoneBook Server.
//
//  Arguments:
//      pnocd           [in]   Pointer to NETOC data.
//
//  Returns:    S_OK if successfull, Win32 error otherwise.
//
//  Author:     quintinb 18 Sep 1998
//
//  Notes:
//
HRESULT HrOcCpaOnInstall(PNETOCDATA pnocd)
{
    HRESULT     hr      = S_OK;
    switch ( pnocd->eit )
    {
    case IT_INSTALL:
        hr = RefCountPbaSharedDlls(TRUE); // bIncrement = TRUE
        break;

    case IT_REMOVE:
        hr = RefCountPbaSharedDlls(FALSE); // bIncrement = FALSE
        break;

    case IT_UPGRADE:
        DeleteOldNtopLinks();
        break;

    case IT_UNKNOWN:
    case IT_NO_CHANGE:
        break;
    }

    TraceError("HrOcCpaOnInstall", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   RefCountPbaSharedDlls
//
//  Purpose:    Reference count and register/unregister all of the PBAdmin
//              shared components.
//
//  Arguments:  BOOL bIncrement -- if TRUE, then increment the ref count,
//                                 else decrement it
//
//
//  Returns:    S_OK if successfull, Win32 error otherwise.
//
//  Author:     quintinb 9 OCT 1998
//
//  Notes:
//
HRESULT RefCountPbaSharedDlls(BOOL bIncrement)
{
    HRESULT hr = S_OK;
    HKEY hKey;
    WCHAR szSystemDir[MAX_PATH+1];
    DWORD dwSize;
    DWORD dwCount;
    LONG lResult;
    const UINT uNumDlls = 6;
    const UINT uStringLen = 12 + 1;
    const WCHAR* const c_szSsFmt = L"%s\\%s";
    const WCHAR* const c_szSharedDllsPath = L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\SharedDlls";
    WCHAR mszDlls[uNumDlls][uStringLen] = {  L"comctl32.ocx",
                                                 L"comdlg32.ocx",
                                                 L"msinet.ocx",
                                                 L"tabctl32.ocx",
                                                 L"dbgrid32.ocx",
                                                 L"dao350.dll"
    };

    WCHAR mszDllPaths[uNumDlls][MAX_PATH];


    //
    //  All of the Dlls that we ref count are in the system directory, except for Dao350.dll.
    //  Thus we want to append the system directory path to our filenames and handle dao last.
    //

    if (0 == GetSystemDirectory(szSystemDir, MAX_PATH))
    {
        return E_UNEXPECTED;
    }

    for (int i = 0; i < (uNumDlls - 1); i++)
    {
        wsprintfW(mszDllPaths[i], c_szSsFmt, szSystemDir, mszDlls[i]);
    }

    //
    //  Now write out the dao350.dll path.
    //
    wsprintfW(mszDllPaths[i], c_szSsFmt, g_szDaoPath, mszDlls[i]);

    //
    //  Open the shared DLL key and start enumerating our multi-sz with all of our dll's
    //  to add.
    //
    if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_LOCAL_MACHINE, c_szSharedDllsPath,
        0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, &dwSize)) // using dwSize as a temp to hold the disposition value
    {
        for (int i=0; i < uNumDlls; i++)
        {
            dwSize = sizeof(DWORD);

            lResult = RegQueryValueExW(hKey, mszDllPaths[i], NULL, NULL, (LPBYTE)&dwCount, &dwSize);

            if (ERROR_SUCCESS == lResult)
            {
                //
                //  Increment or decrement as appropriate.  Make sure not to decrement 0
                //

                if (0 != dwCount || bIncrement)
                {
                    dwCount = dwCount + (bIncrement ? 1 : -1);
                }
            }
            else if (ERROR_FILE_NOT_FOUND == lResult)
            {
                if (bIncrement)
                {
                    //
                    //  The the value doesn't yet exist.  Set the count to 1.
                    //
                    dwCount = 1;
                }
                else
                {
                    //
                    //  We are decrementing and we couldn't find the DLL, nothing to
                    //  change for the count but we should still delete the dll.
                    //
                    dwCount = 0;
                }
            }
            else
            {
                hr = S_FALSE;
                continue;
            }

            //
            //  Not that we have determined the ref count, do something about it.
            //
            if (dwCount == 0)
            {
                //
                //  We don't want to delete dao350.dll, but otherwise we need to delete
                //  the file if it has a zero refcount.
                //
                if (0 != lstrcmpiW(mszDlls[i], L"dao350.dll"))
                {
                    hr = UnregisterAndDeleteDll(mszDllPaths[i]);
                    if (FAILED(hr))
                    {
                        //
                        //  Don't fail the setup over a file that we couldn't unregister or
                        //  couldn't delete
                        //
                        hr = S_FALSE;
                    }
                }
                RegDeleteValue(hKey, mszDllPaths[i]);
            }
            else
            {
                //
                //  Set the value to its new count.
                //
                if (ERROR_SUCCESS != RegSetValueEx(hKey, mszDllPaths[i], 0, REG_DWORD,
                    (LPBYTE)&dwCount, sizeof(DWORD)))
                {
                    hr = S_FALSE;
                }

                //
                //  If we are incrementing the count then we should register the dll.
                //
                if (bIncrement)
                {
                    hr = RegisterDll(mszDllPaths[i]);
                }
            }
        }

        RegCloseKey(hKey);
    }

    TraceError("RefCountPbaSharedDlls", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   UnregisterAndDeleteDll
//
//  Purpose:    Unregister and delete the given COM component
//
//  Arguments:  pszFile -- The full path to the file to unregister and delete
//
//
//  Returns:    S_OK if successfull, Win32 error otherwise.
//
//  Author:     quintinb 9 OCT 1998
//
//  Notes:
//

HRESULT UnregisterAndDeleteDll(PCWSTR pszFile)
{
    HINSTANCE hLib = NULL;
    FARPROC pfncUnRegister;
    HRESULT hr = S_OK;

    if ((NULL == pszFile) || (L'\0' == pszFile[0]))
    {
        return E_INVALIDARG;
    }

    hLib = LoadLibrary(pszFile);
    if (NULL != hLib)
    {
        pfncUnRegister = GetProcAddress(hLib, "DllUnregisterServer");
        if (NULL != pfncUnRegister)
        {
            hr = (pfncUnRegister)();
            if (SUCCEEDED(hr))
            {
                FreeLibrary(hLib);
                hLib = NULL;
//  This was removed because PBA setup is moving to Value Add and because of bug 323231
//                if (!DeleteFile(pszFile))
//                {
//                    hr = S_FALSE;
//                }
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    }

    if (NULL != hLib)
    {
        FreeLibrary(hLib);
    }


    TraceError("UnregisterAndDeleteDll", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   RegisterDll
//
//  Purpose:    Register the given COM component
//
//  Arguments:  pszFile -- The full path to the file to register
//
//
//  Returns:    S_OK if successfull, Win32 error otherwise.
//
//  Author:     quintinb 9 OCT 1998
//
//  Notes:
//

HRESULT RegisterDll(PCWSTR pszFile)
{
    HINSTANCE hLib = NULL;
    FARPROC pfncRegister;
    HRESULT hr = S_OK;

    if ((NULL == pszFile) || (L'\0' == pszFile[0]))
    {
        return E_INVALIDARG;
    }

    hLib = LoadLibrary(pszFile);
    if (NULL != hLib)
    {
        pfncRegister = GetProcAddress(hLib, "DllRegisterServer");
        if (NULL != pfncRegister)
        {
            hr = (pfncRegister)();
        }
        else
        {
            hr = HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    }

    if (NULL != hLib)
    {
        FreeLibrary(hLib);
    }


    TraceError("RegisterDll", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrGetPbaInstallPath
//
//  Purpose:    Get the install path for pbadmin.exe.
//
//  Arguments:  pszCpaPath -- buffer to hold the install path of PBA.
//              dwNumChars -- the number of characters that the buffer can hold.
//
//
//  Returns:    S_OK if successfull, Win32 error otherwise.
//
//  Author:     quintinb 19 OCT 1998
//
//  Notes:
//

HRESULT HrGetPbaInstallPath(PWSTR pszCpaPath, DWORD dwNumChars)
{
    HRESULT hr;
    HKEY hKey;
    BOOL bFound = FALSE;

    //  We need to setup the custom DIRID so that CPA will install
    //  to the correct location.  First get the path from the system.
    //

    ZeroMemory(pszCpaPath, sizeof(WCHAR)*dwNumChars);
    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szDaoClientsPath, KEY_READ, &hKey);

    if (SUCCEEDED(hr))
    {
        WCHAR szCurrentValue[MAX_PATH+1];
        WCHAR szCurrentData[MAX_PATH+1];
        DWORD dwValueSize = MAX_PATH;
        DWORD dwDataSize = MAX_PATH;
        DWORD dwType;
        DWORD dwIndex = 0;

        while (ERROR_SUCCESS == RegEnumValue(hKey, dwIndex, szCurrentValue, &dwValueSize, NULL, &dwType,
               (LPBYTE)szCurrentData, &dwDataSize))
        {
            _wcslwr(szCurrentValue);
            if (NULL != wcsstr(szCurrentValue, L"pbadmin.exe"))
            {
                //
                //  Then we have found the PBA path
                //

                WCHAR* pszTemp = wcsrchr(szCurrentValue, L'\\');
                if (NULL != pszTemp)
                {
                    *pszTemp = L'\0';
                    lstrcpyW(pszCpaPath, szCurrentValue);
                    bFound = TRUE;
                    break;
                }
            }
            dwValueSize = MAX_PATH;
            dwDataSize = MAX_PATH;
            dwIndex++;
        }

        RegCloseKey(hKey);
    }

    if (!bFound)
    {
        //  This is  a fresh install of CPA, don't return an error
        //
        hr = SHGetSpecialFolderPath(NULL, pszCpaPath, CSIDL_PROGRAM_FILES, FALSE);

        if (SUCCEEDED(hr))
        {
            lstrcatW(pszCpaPath, L"\\PBA");
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrGetDaoInstallPath
//
//  Purpose:    Get the install path for pbadmin.exe.
//
//  Arguments:  pszCpaPath -- buffer to hold the install path of PBA.
//              dwNumChars -- the number of characters that the buffer can hold.
//
//
//  Returns:    S_OK if successfull, Win32 error otherwise.
//
//  Author:     quintinb 19 OCT 1998
//
//  Notes:
//

HRESULT HrGetDaoInstallPath(PWSTR pszDaoPath, DWORD dwNumChars)
{
    HRESULT hr;
    HKEY hKey;

    //  We need to setup the custom DIRID so that CPA will install
    //  to the correct location.  First get the path from the system.
    //

    ZeroMemory(pszDaoPath, sizeof(WCHAR)*dwNumChars);
    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szCommonFilesPath, KEY_ALL_ACCESS, &hKey);

    if (SUCCEEDED(hr))
    {
        DWORD dwSize = sizeof(WCHAR)*dwNumChars;

        //
        //  Try to get the CommonFilesDir value from the registry, but if it doesn't exist
        //  then create it.
        //
        if (ERROR_SUCCESS != RegQueryValueExW(hKey, c_szCommonFilesDirValue, NULL, NULL,
            (LPBYTE)pszDaoPath, &dwSize))
        {
            hr = SHGetSpecialFolderPath(NULL, pszDaoPath, CSIDL_PROGRAM_FILES, FALSE);

            if (SUCCEEDED(hr))
            {
                //
                //  QBBUG -- Common files is localizable.  Make a string resource.
                //
                lstrcatW(pszDaoPath, (PWSTR)SzLoadIds(IDS_OC_COMMON_FILES));

                //
                //  Now set the regvalue
                //
                hr = HrRegSetValueEx(hKey, c_szCommonFilesDirValue, REG_SZ,
                     (const BYTE*)pszDaoPath, sizeof(WCHAR)*dwNumChars);
            }

        }
        RegCloseKey(hKey);
    }

    if (SUCCEEDED(hr))
    {
        //
        //  QBBUG -- should Microsoft shared be a string resource?
        //
        lstrcatW(g_szDaoPath, (PWSTR)SzLoadIds(IDS_OC_MS_SHARED_DAO));
    }

    return hr;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netoc\nccps.cpp ===
//+---------------------------------------------------------------------------
//
// File:     NcCPS.CPP
//
// Module:   NetOC.DLL
//
// Synopsis: Implements the dll entry points required to integrate into
//           NetOC.DLL the installation of the following components.
//
//              NETCPS
//
// Copyright (C)  Microsoft Corporation.  All rights reserved.
//
// Author:   a-anasj 9 Mar 1998
//
//+---------------------------------------------------------------------------


#include "pch.h"
#pragma hdrstop

#include <iadmw.h>      // Interface header
#include <iiscnfg.h>    // MD_ & IIS_MD_ defines
#include <LOADPERF.H>

#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>
#include "ncatl.h"
#include "resource.h"

#include "nccm.h"

//
//  Define Globals
//
WCHAR g_szProgramFiles[MAX_PATH+1];

//
//  Define Constants
//
static const WCHAR c_szInetRegPath[] = L"Software\\Microsoft\\InetStp";
static const WCHAR c_szWWWRootValue[] = L"PathWWWRoot";
static const WCHAR c_szSSFmt[] = L"%s%s";
static const WCHAR c_szMsAccess[] = L"Microsoft Access";
static const WCHAR c_szOdbcDataSourcesPath[] = L"SOFTWARE\\ODBC\\ODBC.INI\\ODBC Data Sources";
static const WCHAR c_szPbServer[] = L"PBServer";
static const WCHAR c_szOdbcInstKey[] = L"SOFTWARE\\ODBC\\ODBCINST.INI";
static const WCHAR c_szWwwRootPath[] = L"\\Inetpub\\wwwroot";
static const WCHAR c_szWwwRoot[] = L"\\wwwroot";
static const WCHAR c_szPbsRootPath[] = L"\\Phone Book Service";
static const WCHAR c_szPbsBinPath[] = L"\\Phone Book Service\\Bin";
static const WCHAR c_szPbsDataPath[] = L"\\Phone Book Service\\Data";
static const WCHAR c_szOdbcPbserver[] = L"Software\\ODBC\\odbc.ini\\pbserver";
const DWORD c_dwCpsDirID = 123175;  // just must be larger than DIRID_USER = 0x8000;
static const WCHAR c_szPBSAppPoolID[] = L"PBSAppPool";
static const WCHAR c_szPBSGroupID[] = L"PBS";
static const WCHAR c_szPBSGroupDescription[] = L"Phone Book Service";
static const WCHAR c_szAppPoolKey[] = L"IIsApplicationPool";
static const WCHAR c_szPerfMonAppName[] = L"%SystemRoot%\\System32\\lodctr.exe";
static const WCHAR c_szPerfMonIniFile[] = L"CPSSym.ini";


//+---------------------------------------------------------------------------
//
//  Function:   SetPrivilege
//
//  Notes:      lifted unchanged from MSDN (used by TakeOwnershipOfRegKey)
//
BOOL SetPrivilege(
    HANDLE hToken,          // access token handle
    LPCTSTR lpszPrivilege,  // name of privilege to enable/disable
    BOOL bEnablePrivilege   // to enable or disable privilege
    ) 
{
    TOKEN_PRIVILEGES tp;
    LUID luid;

    if ( !LookupPrivilegeValue( 
            NULL,            // lookup privilege on local system
            lpszPrivilege,   // privilege to lookup 
            &luid ) )        // receives LUID of privilege
    {
        printf("LookupPrivilegeValue error: %u\n", GetLastError() ); 
        return FALSE; 
    }

    tp.PrivilegeCount = 1;
    tp.Privileges[0].Luid = luid;
    if (bEnablePrivilege)
        tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
    else
        tp.Privileges[0].Attributes = 0;

    // Enable the privilege or disable all privileges.

    if ( !AdjustTokenPrivileges(
           hToken, 
           FALSE, 
           &tp, 
           sizeof(TOKEN_PRIVILEGES), 
           (PTOKEN_PRIVILEGES) NULL, 
           (PDWORD) NULL) )
    { 
          printf("AdjustTokenPrivileges error: %u\n", GetLastError() ); 
          return FALSE; 
    } 

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   TakeOwnershipOfRegKey
//
//  Purpose:    There is an old registry key that we can't delete because it doesn't
//              inherit permissions.  Take ownership of it so it can be deleted.
//
//  Arguments:
//      pszKey  [in]   string representing reg key
//
//  Returns:    S_OK if successful, Win32 error otherwise.
//
//  Author:     SumitC  4-Dec-2002
//
//  Notes:
//
HRESULT TakeOwnershipOfRegKey(LPWSTR pszRegKey)
{
    HRESULT         hr = S_OK;
    DWORD           dwRes = ERROR_SUCCESS;
    PSID            psidAdmin = NULL;
    PACL            pACL = NULL;
    HANDLE          hToken = NULL; 
    EXPLICIT_ACCESS ea = {0} ;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;

    //
    // from MSDN, the following is "the way" to take ownership of an object
    //

    BOOL bRet = AllocateAndInitializeSid (&NtAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID, 
                              DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0, &psidAdmin);

    if (!bRet || !psidAdmin)
    {
        dwRes = GetLastError();
        TraceError("TakeOwnershipOfRegKey - AllocateAndInitializeSid failed, GLE=%u", dwRes);
        goto Cleanup;            
    }

    // Open a handle to the access token for the calling process.
    if (!OpenProcessToken(GetCurrentProcess(), 
                          TOKEN_ADJUST_PRIVILEGES, 
                          &hToken))
    {
        dwRes = GetLastError();
        TraceError("TakeOwnershipOfRegKey - OpenProcessToken failed with, GLE=%u", dwRes);
        goto Cleanup;            
    }

    // Enable the SE_TAKE_OWNERSHIP_NAME privilege.
    if (!SetPrivilege(hToken, SE_TAKE_OWNERSHIP_NAME, TRUE))
    {
        dwRes = GetLastError();
        TraceError("TakeOwnershipOfRegKey - SetPrivilege to takeownership failed, GLE=%u", dwRes);
        goto Cleanup;            
    }

    // Set the owner in the object's security descriptor.
    dwRes = SetNamedSecurityInfo(pszRegKey,                   // name of the object
                                 SE_REGISTRY_KEY,             // type of object
                                 OWNER_SECURITY_INFORMATION,  // change only the object's owner
                                 psidAdmin,                   // SID of Administrators
                                 NULL,
                                 NULL,
                                 NULL);

    // Disable the SE_TAKE_OWNERSHIP_NAME privilege.
    if (!SetPrivilege(hToken, SE_TAKE_OWNERSHIP_NAME, FALSE)) 
    {
        dwRes = GetLastError();
        TraceError("TakeOwnershipOfRegKey - SetPrivilege to revoke takeownership failed, GLE=%u", dwRes);
        goto Cleanup;            
    }

    // NOTE: I'm doing it in this order to make sure the SetPrivilege gets reverted
    //       even if SetNamedSecurityInfo fails.
    if (ERROR_SUCCESS != dwRes)
    {
        TraceError("TakeOwnershipOfRegKey - SetNamedSecurityInfo failed, GLE=%u", dwRes);
        if (ERROR_FILE_NOT_FOUND == dwRes)
        {
            // probably upgrading from a post-Win2k build.  Anyway, if the reg
            // key doesn't exist, there's nothing to do, so exit without an error
            dwRes = 0;
        }
        goto Cleanup;            
    }

    // create an ACL to give ownership to admins
    // Set full control for Administrators.
    ea.grfAccessPermissions = GENERIC_ALL;
    ea.grfAccessMode        = SET_ACCESS;
    ea.grfInheritance       = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
    ea.Trustee.TrusteeForm  = TRUSTEE_IS_SID;
    ea.Trustee.TrusteeType  = TRUSTEE_IS_GROUP;
    ea.Trustee.ptstrName    = (LPTSTR) psidAdmin;

    dwRes = SetEntriesInAcl(1, &ea,  NULL, &pACL);
    if (ERROR_SUCCESS != dwRes)
    {
        TraceError("TakeOwnershipOfRegKey - couldn't create needed ACL, GLE=%u", dwRes);
        goto Cleanup;
    }

    //
    //  Now change the DACL to allow deletion
    //
    dwRes = SetNamedSecurityInfo(pszRegKey,                   // name of the object
                                 SE_REGISTRY_KEY,             // type of object
                                 DACL_SECURITY_INFORMATION,   // type of information to set
                                 NULL,                        // pointer to the new owner SID
                                 NULL,                        // pointer to the new primary group SID
                                 pACL,                        // pointer to new DACL
                                 NULL);                       // pointer to new SACL
    if (ERROR_SUCCESS != dwRes)
    {
        TraceError("TakeOwnershipOfRegKey - tried to change DACL for PBS reg key under ODBC, GLE=%u", dwRes);
        goto Cleanup;            
    }

    // successfully changed DACL    

Cleanup:

    if (psidAdmin)
    {
        FreeSid(psidAdmin);
    }
    if (pACL)
    {
       LocalFree(pACL);
    }
    if (hToken)
    {
       CloseHandle(hToken);
    }

    if (dwRes != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(dwRes);
    }

    TraceError("TakeOwnershipOfRegKey", hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrOcCpsPreQueueFiles
//
//  Purpose:    Called by optional components installer code to handle
//              additional installation requirements for PhoneBook Server.
//
//  Arguments:
//      pnocd           [in]   Pointer to NETOC data.
//
//  Returns:    S_OK if successful, Win32 error otherwise.
//
//  Author:     quintinb 18 Sep 1998
//
//  Notes:
//
HRESULT HrOcCpsPreQueueFiles(PNETOCDATA pnocd)
{
    HRESULT hr = S_OK;

    switch ( pnocd->eit )
    {
    case IT_UPGRADE:
    case IT_INSTALL:
    case IT_REMOVE:

        //  We need to setup the custom DIRID so that CPS will install
        //  to the correct location.  First get the path from the system.
        //
        ZeroMemory(g_szProgramFiles, sizeof(g_szProgramFiles));
        hr = SHGetSpecialFolderPath(NULL, g_szProgramFiles, CSIDL_PROGRAM_FILES, FALSE);

        if (SUCCEEDED(hr))
        {
            //  Next Create the CPS Dir ID
            //
            if (SUCCEEDED(hr))
            {
                hr = HrEnsureInfFileIsOpen(pnocd->pszComponentId, *pnocd);
                if (SUCCEEDED(hr))
                {
                    if(!SetupSetDirectoryId(pnocd->hinfFile, c_dwCpsDirID, g_szProgramFiles))
                    {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                    }
                }
            }

            // Before proceeding, make sure that setting the DIRID worked. CPS's
            // INF file is hosed if the DIRID isn't set.
            //
            if (SUCCEEDED(hr))
            {
                if (IT_UPGRADE == pnocd->eit)
                {
                    hr = HrMoveOldCpsInstall(g_szProgramFiles);
                    TraceError("HrOcCpsPreQueueFiles - HrMoveOldCpsInstall failed, hr=%u", hr);
                    // we'll say that failing to move the old install is not fatal

                    // On Win2k, some registry keys end up with permissions so that
                    // they can't be removed, and this causes upgrade failures,
                    // so we have to take ownership of said registry key(s)
                    //
                    WCHAR szPBSKey[MAX_PATH+1];
                    lstrcpy(szPBSKey, L"MACHINE\\");
                    lstrcat(szPBSKey, c_szOdbcPbserver);

                    hr = TakeOwnershipOfRegKey(szPBSKey);
                }
            }
        }
        break;
    }

    TraceError("HrOcCpsPreQueueFiles", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrMoveOldCpsInstall
//
//  Purpose:    This function moves the old cps directory to the new cps directory
//              location.  Because of the problems with Front Page Extensions and
//              directory permissions we moved our install directory out from under
//              wwwroot to Program Files instead.
//
//  Arguments:
//      pszprogramFiles        [in]
//
//  Returns:    S_OK if successful,  Win32 error otherwise.
//
//  Author:     quintinb 26 Jan 1999
//
//  Notes:
//
HRESULT HrMoveOldCpsInstall(PCWSTR pszProgramFiles)
{
    WCHAR szOldCpsLocation[MAX_PATH+1];
    WCHAR szNewCpsLocation[MAX_PATH+1];
    WCHAR szTemp[MAX_PATH+1];
    SHFILEOPSTRUCT fOpStruct;
    HRESULT hr = S_OK;

    if ((NULL == pszProgramFiles) || (L'\0' == pszProgramFiles[0]))
    {
        return E_INVALIDARG;
    }

    //
    //  First, lets build the old CPS location
    //
    hr = HrGetWwwRootDir(szTemp, celems(szTemp));

    if (SUCCEEDED(hr))
    {
        //
        //  Zero the string buffers
        //
        ZeroMemory(szOldCpsLocation, celems(szOldCpsLocation));
        ZeroMemory(szNewCpsLocation, celems(szNewCpsLocation));

        wsprintfW(szOldCpsLocation, c_szSSFmt, szTemp, c_szPbsRootPath);

        //
        //  Now check to see if the old cps location exists
        //
        DWORD dwDirectoryAttributes = GetFileAttributes(szOldCpsLocation);

        //
        //  If we didn't get back -1 (error return code for GetFileAttributes), check to
        //  see if we have a directory.  If so, go ahead and copy the data over.
        //
        if ((-1 != dwDirectoryAttributes) && (dwDirectoryAttributes & FILE_ATTRIBUTE_DIRECTORY))
        {
            //
            //  Now build the new cps location
            //
            wsprintfW(szNewCpsLocation, c_szSSFmt, pszProgramFiles, c_szPbsRootPath);

            //
            //  Now copy the old files to the new location
            //
            ZeroMemory(&fOpStruct, sizeof(fOpStruct));

            fOpStruct.hwnd = NULL;
            fOpStruct.wFunc = FO_COPY;
            fOpStruct.pTo = szNewCpsLocation;
            fOpStruct.pFrom = szOldCpsLocation;
            fOpStruct.fFlags = FOF_SILENT | FOF_NOCONFIRMATION | FOF_NOCONFIRMMKDIR;

            if (0== SHFileOperation(&fOpStruct))
            {
                //
                //  Now delete the original directory
                //
                fOpStruct.pTo = NULL;
                fOpStruct.wFunc = FO_DELETE;
                if (0 != SHFileOperation(&fOpStruct))
                {
                    hr = S_FALSE;
                }
            }
            else
            {
                //
                //  Note, SHFileOperation isn't guaranteed to return anything sensible here.  We might
                //  get back ERROR_NO_TOKEN or ERROR_INVALID_HANDLE, etc when the directory is just missing.
                //  The following check probably isn't useful anymore because of this but I will leave it just
                //  in case.  Hopefully the file check above will make sure we don't hit this but ...
                //
                DWORD dwError = GetLastError();

                if ((ERROR_FILE_NOT_FOUND == dwError) || (ERROR_PATH_NOT_FOUND == dwError))
                {
                    //
                    //  Then we couldn't find the old dir to move it.  Not fatal.
                    //
                    hr = S_FALSE;
                }
                else
                {
                    hr = HRESULT_FROM_WIN32(dwError);
                }
            }
        }
        else
        {
            //
            //  Then we couldn't find the old dir to move it.  Not fatal.
            //
            hr = S_FALSE;        
        }
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrGetWwwRootDir
//
//  Purpose:    This function retrieves the location of the InetPub\wwwroot dir from the
//              WwwRootDir registry key.
//
//  Arguments:
//      szInetPub               [out]   String Buffer to hold the InetPub dir path
//      uInetPubCount           [in]    number of chars in the output buffer
//
//  Returns:    S_OK if successful, Win32 error otherwise.
//
//  Author:     quintinb 26 Jan 1999
//
//  Notes:
//
HRESULT HrGetWwwRootDir(PWSTR szWwwRoot, UINT uWwwRootCount)
{
    HKEY hKey;
    HRESULT hr = S_OK;

    //
    //  Check input params
    //
    if ((NULL == szWwwRoot) || (0 == uWwwRootCount))
    {
        return E_INVALIDARG;
    }

    //
    //  Set the strings to empty
    //
    szWwwRoot[0] = L'\0';

    //
    //  First try to open the InetStp key and get the wwwroot value.
    //
    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szInetRegPath, KEY_READ, &hKey);

    if (SUCCEEDED(hr))
    {
        DWORD dwSize = uWwwRootCount * sizeof(WCHAR);

        RegQueryValueExW(hKey, c_szWWWRootValue, NULL, NULL, (LPBYTE)szWwwRoot, &dwSize);
        RegCloseKey(hKey);
        hr = S_OK;
    }


    if (L'\0' == szWwwRoot[0])
    {
        //  Well, we didn't get anything from the registry, lets try building the default.
        //
        WCHAR szTemp[MAX_PATH+1];
        if (GetWindowsDirectory(szTemp, MAX_PATH))
        {
            //  Get the drive that the windows dir is on using _tsplitpath
            //
            WCHAR szDrive[_MAX_DRIVE+1];
            _wsplitpath(szTemp, szDrive, NULL, NULL, NULL);

            if (uWwwRootCount > (UINT)(lstrlenW(szDrive) + lstrlenW (c_szWwwRootPath) + 1))
            {
                wsprintfW(szWwwRoot, c_szSSFmt, szDrive, c_szWwwRootPath);
                hr = S_OK;
            }
            else
            {
                hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOcCpsOnInstall
//
//  Purpose:    Called by optional components installer code to handle
//              additional installation requirements for PhoneBook Server.
//
//  Arguments:
//      pnocd           [in]   Pointer to NETOC data.
//
//  Returns:    S_OK if successful, Win32 error otherwise.
//
//  Author:     a-anasj 9 Mar 1998
//
//  Notes:
//
HRESULT HrOcCpsOnInstall(PNETOCDATA pnocd)
{
    HRESULT     hr      = S_OK;
    DWORD       dwRet   = 0;
    BOOL        bRet    = FALSE;

    switch (pnocd->eit)
    {
    case IT_INSTALL:
    case IT_UPGRADE:
        {

        // Register MS_Access data source
        //
        dwRet = RegisterPBServerDataSource();
        if ( NULL == dwRet)
        {
            hr = S_FALSE;
        }

        // Load Perfomance Monitor Counters
        //
        bRet = LoadPerfmonCounters();
        if (FALSE == bRet)
        {
            hr = S_FALSE;
        }

        // Create Virtual WWW and FTP roots
        //
        if (IT_UPGRADE == pnocd->eit)
        {
            //
            //  If this is an upgrade, we must first delete the old Virtual Roots
            //  before we can create new ones.
            //
            RemoveCPSVRoots();
        }

        dwRet = CreateCPSVRoots();
        if (FALSE == dwRet)
        {
            hr = S_FALSE;
        }

        SetCpsDirPermissions();

        //
        //  Place PBS in its own Application Pool
        //
        if (S_OK != CreateNewAppPoolAndAddPBS())
        {
            hr = S_FALSE;
        }

        //
        //  Work with IIS's Security Lockdown wizard to enable ISAPI requests to ourselves
        //
        if (S_OK != EnableISAPIRequests(pnocd->strDesc.c_str()))
        {
            hr = S_FALSE;
        }
        }

        break;

    case IT_REMOVE:

        //  Remove the Virtual Directories, so access to the service is stopped.
        //
        RemoveCPSVRoots();

        //
        //  Delete PBS's Application pool
        //
        (void) DeleteAppPool();

        //
        //  Fire up our worker process to tell IIS not to accept PBS requests anymore
        //
        hr = UseProcessToEnableDisablePBS(FALSE);       // FALSE => disable

        if (S_OK != hr)
        {
            // Bah Humbug
            TraceError("HrOcCpsOnInstall - disabling PBS failed, probably already removed", hr);
            hr = S_FALSE;
        }

        break;
    }

    TraceError("HrOcCpsOnInstall", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   LoadPerfmonCounters
//
//  Purpose:    Do whatever is neccessary to make the performance monitor Display the PBServerMonitor counters
//
//  Arguments:
//
//  Returns:    BOOL TRUE if successful, Not TRUE otherwise.
//
//  Author:     a-anasj Mar 9/1998
//
//  Notes: One of the installation requirements for PhoneBook Server.
//          is to load the perfomance monitor counters that allow PBServerMonitor
//          to report to the user on PhoneBook Server performance.
//          In this function we add the services registry entry first then we
//          call into LoadPerf.Dll to load the counters for us. The order is imperative.
//          I then add other registry entries related to PBServerMonitor.
//

BOOL LoadPerfmonCounters()
{

    SHELLEXECUTEINFO sei = { 0 };

    sei.cbSize          = sizeof(SHELLEXECUTEINFO);
    sei.fMask           = SEE_MASK_DOENVSUBST;
    sei.lpFile          = c_szPerfMonAppName;
    sei.lpParameters    = c_szPerfMonIniFile;
    sei.nShow           = SW_HIDE;

    return ShellExecuteEx(&sei);

}

 
//+---------------------------------------------------------------------------
//
//  Function:   RegisterPBServerDataSource
//
//  Purpose:    Registers PBServer.
//
//  Arguments:  None
//
//  Returns:    Win32 error code
//
//  Author:     a-anasj   9 Mar 1998
//
//  Notes:
//  History:    7-9-97 a-frankh Created
//              10/4/97 mmaguire RAID #19906 - Totally restructured to include error handling
//              5-14-98 quintinb removed unnecessary comments and cleaned up the function.
//
BOOL RegisterPBServerDataSource()
{
    DWORD dwRet = 0;

    HKEY hkODBCInst = NULL;
    HKEY hkODBCDataSources = NULL;

    DWORD dwIndex;
    WCHAR szName[MAX_PATH+1];

    __try
    {
        // Open the hkODBCInst RegKey
        //
        dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, c_szOdbcInstKey, &hkODBCInst);
        if((ERROR_SUCCESS != dwRet) || (NULL == hkODBCInst))
        {
            __leave;
        }

        // Look to see the the "Microsoft Access" RegKey is defined
        //  If it is, then set the value of the ODBC Data Sources RegKey below
        //
        dwIndex = 0;
        do
        {
            dwRet = RegEnumKey(hkODBCInst,dwIndex,szName,celems(szName));
            dwIndex++;
        } while ((ERROR_SUCCESS == dwRet) && (NULL == wcsstr(szName, c_szMsAccess)));

        if ( ERROR_SUCCESS != dwRet )
        {
            // We need the Microsoft Access *.mdb driver to work
            // and we could not find it
            //
            __leave;
        }

        // Open the hkODBCDataSources RegKey
        //
        dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, c_szOdbcDataSourcesPath,
            &hkODBCDataSources);

        if( ERROR_SUCCESS != dwRet )
        {
            __leave;
        }

        //
        //  Use the name from the resource for registration purposes.
        //
        //  NOTE: this string is from HKLM\Software\ODBC\ODBCINST.INI\*
        //
        lstrcpy(szName, SzLoadIds(IDS_OC_PB_DSN_NAME));

        // Set values in the hkODBCDataSources key
        //
        dwRet = RegSetValueEx(hkODBCDataSources, c_szPbServer, 0, REG_SZ,
            (LPBYTE)szName, (lstrlenW(szName)+1)*sizeof(WCHAR));

        if( ERROR_SUCCESS != dwRet )
        {
            __leave;
        }

    } // end __try



    __finally
    {
        if (hkODBCInst)
        {
            RegCloseKey (hkODBCInst);
        }

        if (hkODBCDataSources)
        {
            RegCloseKey (hkODBCDataSources);
        }
    }

    return (ERROR_SUCCESS == dwRet);
}

//+---------------------------------------------------------------------------
//
//  Function:   CreateCPSVRoots
//
//  Purpose:    Creates the Virtual Directories required for Phone Book Service.
//
//  Arguments:  None
//
//  Returns:    TRUE if successful, FALSE otherwise.
//
//  Author:     a-anasj Mar 9/1998
//
//  Notes:
//
BOOL CreateCPSVRoots()
{
    //  QBBUG - Should we make sure the physical paths exist before pointing a virtual root to them?

    WCHAR   szPath[MAX_PATH+1];
    HRESULT hr;

    if (L'\0' == g_szProgramFiles[0])
    {
        return FALSE;
    }

    //  Create the Bindir virtual root
    //
    wsprintfW(szPath, c_szSSFmt, g_szProgramFiles, c_szPbsBinPath);

    hr = AddNewVirtualRoot(www, L"PBServer", szPath);
    if (S_OK != hr)
    {
        return FALSE;
    }

    //  Now we set the Execute access permissions on the PBServer Virtual Root
    //
    PWSTR szVirtDir;
    szVirtDir = L"/LM/W3svc/1/ROOT/PBServer";
    SetVirtualRootAccessPermissions( szVirtDir, MD_ACCESS_EXECUTE | MD_ACCESS_READ);

    //  Create the Data dir virtual roots
    //
    wsprintfW(szPath, c_szSSFmt, g_szProgramFiles, c_szPbsDataPath);
    hr = AddNewVirtualRoot(www, L"PBSData", szPath);
    if (S_OK != hr)
    {
        return FALSE;
    }

    hr = AddNewVirtualRoot(ftp, L"PBSData", szPath);
    if (S_OK != hr)
    {
        return FALSE;
    }

    //  Now we set the Execute access permissions on the PBServer Virtual Root
    //
    szVirtDir = L"/LM/MSFTPSVC/1/ROOT/PBSData";
    hr = SetVirtualRootAccessPermissions(szVirtDir, MD_ACCESS_READ);
    if (S_OK != hr)
    {
        TraceTag(ttidNetOc, "CreateCPSVRoots - SetVirtualRootAccessPermissions failed with 0x%x", hr);
    }

    //  And disable anonymous FTP 
    //
    szVirtDir = L"/LM/MSFTPSVC/1";
    hr = SetVirtualRootNoAnonymous(szVirtDir);
    if (S_OK != hr)
    {
        TraceTag(ttidNetOc, "CreateCPSVRoots - SetVirtualRootNoAnonymous failed with 0x%x", hr);
    }

    return 1;
}


//+---------------------------------------------------------------------------
//
//  The following are neccessary defines, define guids and typedefs enums
//  they are created for the benefit of AddNewVirtualRoot()
//+---------------------------------------------------------------------------

#define error_leave(x)  goto leave_routine;

#define MY_DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
        EXTERN_C const GUID name \
                = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }


MY_DEFINE_GUID(CLSID_MSAdminBase, 0xa9e69610, 0xb80d, 0x11d0, 0xb9, 0xb9, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x50);
MY_DEFINE_GUID(IID_IMSAdminBase, 0x70b51430, 0xb6ca, 0x11d0, 0xb9, 0xb9, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x50);


//+---------------------------------------------------------------------------
//
//  Function:   AddNewVirtualRoot
//
//  Purpose:    Helps create Virtual Roots in the WWW and FTP services.
//
//  Arguments:
//      PWSTR szDirW : Alias of new Virtual Root
//      PWSTR szPathW: Physical Path to wich the new Virtual Root will point
//
//  Returns:    S_OK if successful, Win32 error otherwise.
//
//  Author:     a-anasj Mar 9/1998
//
//  Notes:
//
HRESULT AddNewVirtualRoot(e_rootType rootType, PWSTR szDirW, PWSTR szPathW)
{

    HRESULT hr = S_OK;
    IMSAdminBase *pIMeta = NULL;
    METADATA_HANDLE hMeta = NULL;       // handle to metabase
    PWSTR szMBPathW;

    if (www == rootType)
    {
        szMBPathW = L"/LM/W3svc/1/ROOT";
    }
    else if (ftp == rootType)
    {
        szMBPathW = L"/LM/MSFTPSVC/1/ROOT";
    }
    else
    {
        //  Unknown root type
        //
        ASSERT(FALSE);
        return S_FALSE;
    }

    if (FAILED(CoInitialize(NULL)))
    {
        return S_FALSE;
    }

    // Create an instance of the metabase object
    hr=::CoCreateInstance(CLSID_MSAdminBase,//CLSID_MSAdminBase,
                          NULL,
                          CLSCTX_ALL,
                          IID_IMSAdminBase,
                          (void **)&pIMeta);
    if (FAILED(hr))
    {
        error_leave("CoCreateInstance");
    }

    // open key to ROOT on website #1 (where all the VDirs live)
    hr = pIMeta->OpenKey(METADATA_MASTER_ROOT_HANDLE,
                         szMBPathW,
                         METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
                         1000,
                         &hMeta);
    if (FAILED(hr))
    {
        error_leave("OpenKey");
    }

    // Add new VDir called szDirW

    hr=pIMeta->AddKey(hMeta, szDirW);

    if (FAILED(hr))
    {
        error_leave("Addkey");
    }

    // Set the physical path for this VDir
    METADATA_RECORD mr;
    mr.dwMDIdentifier = MD_VR_PATH;
    mr.dwMDAttributes = METADATA_INHERIT ;
    mr.dwMDUserType   = IIS_MD_UT_FILE;
    mr.dwMDDataType   = STRING_METADATA;

    mr.dwMDDataLen    = (wcslen(szPathW) + 1) * sizeof(WCHAR);
    mr.pbMDData       = (unsigned char*)(szPathW);

    hr=pIMeta->SetData(hMeta,szDirW,&mr);

    if (FAILED(hr))
    {
        error_leave("SetData");
    }

    //
    // we also need to set the keytype
    //
    ZeroMemory((PVOID)&mr, sizeof(METADATA_RECORD));
    mr.dwMDIdentifier = MD_KEY_TYPE;
    mr.dwMDAttributes = METADATA_INHERIT ;
    mr.dwMDUserType   = IIS_MD_UT_FILE;
    mr.dwMDDataType   = STRING_METADATA;
    mr.pbMDData       = (unsigned char*)(www == rootType? L"IIsWebVirtualDir" : L"IIsFtpVirtualDir");
    mr.dwMDDataLen    = (lstrlenW((PWSTR)mr.pbMDData) + 1) * sizeof(WCHAR);

    hr=pIMeta->SetData(hMeta,szDirW,&mr);
    if (FAILED(hr))
    {
        error_leave("SetData");
    }


    // Call CloseKey() prior to calling SaveData
    pIMeta->CloseKey(hMeta);
    hMeta = NULL;
    // Flush out the changes and close
    hr=pIMeta->SaveData();
    if (FAILED(hr))
    {
        error_leave("SaveData");
    }

leave_routine:
    if (pIMeta)
    {
        if(hMeta)
            pIMeta->CloseKey(hMeta);
        pIMeta->Release();
    }
    CoUninitialize();
    return hr;
}



//+---------------------------------------------------------------------------
//
//  Function:   SetVirtualRootAccessPermissions
//
//  Purpose :   Sets Access Permissions to a Virtual Roots in the WWW service.
//
//  Arguments:
//      PWSTR szVirtDir : Alias of new Virtual Root
//      DWORD   dwAccessPermisions can be any combination of the following
//                   or others defined in iiscnfg.h
//                  MD_ACCESS_EXECUTE | MD_ACCESS_WRITE | MD_ACCESS_READ;
//
//  Returns:    S_OK if successful, Win32 error otherwise.
//
//  Author:     a-anasj Mar 18/1998
//
//  Notes:
//
HRESULT SetVirtualRootAccessPermissions(PWSTR szVirtDir, DWORD dwAccessPermissions)
{
    HRESULT hr = S_OK;                  // com error status
    IMSAdminBase *pIMeta = NULL;
    METADATA_HANDLE hMeta = NULL;       // handle to metabase

    if (FAILED(CoInitialize(NULL)))
    {
        TraceTag(ttidNetOc, "SetVirtualRootAccessPermissions - CoInitialize failed with 0x%x", hr);
        return S_FALSE;
    }

    // Create an instance of the metabase object
    hr=::CoCreateInstance(CLSID_MSAdminBase,
                          NULL,
                          CLSCTX_ALL,
                          IID_IMSAdminBase,
                          (void **)&pIMeta);
    if (FAILED(hr))
    {
        TraceTag(ttidNetOc, "SetVirtualRootAccessPermissions - CoCreateInstance failed with 0x%x", hr);
        error_leave("CoCreateInstance");
    }

    // open key to ROOT on website #1 (where all the VDirs live)
    hr = pIMeta->OpenKey(METADATA_MASTER_ROOT_HANDLE,
                         szVirtDir,
                         METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
                         1000,
                         &hMeta);
    if (FAILED(hr))
    {
        TraceTag(ttidNetOc, "SetVirtualRootAccessPermissions - OpenKey failed with 0x%x", hr);
        error_leave("OpenKey");
    }


    // Set the physical path for this VDir
    METADATA_RECORD mr;
    mr.dwMDIdentifier = MD_ACCESS_PERM;
    mr.dwMDAttributes = METADATA_INHERIT;
    mr.dwMDUserType   = IIS_MD_UT_FILE;
    mr.dwMDDataType   = DWORD_METADATA; // this used to be STRING_METADATA, but that was
                                        // the incorrect type and was causing vdir access
                                        // problems.

    // Now, create the access perm
    mr.pbMDData = (PBYTE) &dwAccessPermissions;
    mr.dwMDDataLen = sizeof (DWORD);
    mr.dwMDDataTag = 0;  // datatag is a reserved field.

    hr=pIMeta->SetData(hMeta,
        TEXT ("/"),             // The root of the Virtual Dir we opened above
        &mr);

    if (FAILED(hr))
    {
        TraceTag(ttidNetOc, "SetVirtualRootAccessPermissions - SetData failed with 0x%x", hr);
        error_leave("SetData");
    }

    // Call CloseKey() prior to calling SaveData
    pIMeta->CloseKey(hMeta);
    hMeta = NULL;
    // Flush out the changes and close
    hr=pIMeta->SaveData();
    if (FAILED(hr))
    {
        TraceTag(ttidNetOc, "SetVirtualRootAccessPermissions - SaveData failed with 0x%x", hr);
        error_leave("SaveData");
    }

leave_routine:
    if (pIMeta)
    {
        if(hMeta)
            pIMeta->CloseKey(hMeta);
        pIMeta->Release();
    }
    CoUninitialize();
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   SetVirtualRootNoAnonymous
//
//  Purpose :   Unchecks the "Allow Anonymous Access" checkbox in FTP UI
//
//  Arguments:
//      PWSTR szVirtDir : Alias of  Virtual Root
//
//  Returns:    S_OK if successful, Win32 error otherwise.
//
//  Author:     sumitc  23-Nov-2002     Created
//
//  Notes:
//
HRESULT SetVirtualRootNoAnonymous(PWSTR szVirtDir)
{

    HRESULT hr = S_OK;                  // com error status
    IMSAdminBase *pIMeta = NULL;
    METADATA_HANDLE hMeta = NULL;       // handle to metabase

    if (FAILED(CoInitialize(NULL)))
    {
        TraceTag(ttidNetOc, "SetVirtualRootNoAnonymous - CoInitialize failed with 0x%x", hr);
        return S_FALSE;
    }

    // Create an instance of the metabase object
    hr=::CoCreateInstance(CLSID_MSAdminBase,
                          NULL,
                          CLSCTX_ALL,
                          IID_IMSAdminBase,
                          (void **)&pIMeta);
    if (FAILED(hr))
    {
        TraceTag(ttidNetOc, "SetVirtualRootNoAnonymous - CoCreateInstance failed with 0x%x", hr);
        error_leave("CoCreateInstance");
    }

    // open key to ROOT on website #1 (where all the VDirs live)
    hr = pIMeta->OpenKey(METADATA_MASTER_ROOT_HANDLE,
                         szVirtDir,
                         METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
                         1000,
                         &hMeta);
    if (FAILED(hr))
    {
        TraceTag(ttidNetOc, "SetVirtualRootNoAnonymous - OpenKey failed with 0x%x", hr);
        error_leave("OpenKey");
    }


    METADATA_RECORD mr;
    DWORD dwAllowAnonymous = 0;

    mr.dwMDIdentifier = MD_ALLOW_ANONYMOUS;
    mr.dwMDAttributes = METADATA_INHERIT;
    mr.dwMDUserType   = IIS_MD_UT_SERVER;
    mr.dwMDDataType   = DWORD_METADATA;
    mr.pbMDData       = (PBYTE) &dwAllowAnonymous;
    mr.dwMDDataLen    = sizeof (DWORD);
    mr.dwMDDataTag    = 0;  // datatag is a reserved field.

    hr=pIMeta->SetData(hMeta,
        TEXT ("/"),             // The root of the Virtual Dir we opened above
        &mr);
    
    if (FAILED(hr))
    {
        TraceTag(ttidNetOc, "SetVirtualRootNoAnonymous - SetData failed with 0x%x", hr);
        error_leave("SetData");
    }

    // Call CloseKey() prior to calling SaveData
    pIMeta->CloseKey(hMeta);
    hMeta = NULL;
    // Flush out the changes and close
    hr=pIMeta->SaveData();
    if (FAILED(hr))
    {
        TraceTag(ttidNetOc, "SetVirtualRootNoAnonymous - SaveData failed with 0x%x", hr);
        error_leave("SaveData");
    }

leave_routine:
    if (pIMeta)
    {
        if(hMeta)
            pIMeta->CloseKey(hMeta);
        pIMeta->Release();
    }
    CoUninitialize();
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   RemoveCPSVRoots
//
//  Purpose:    Deletes the Virtual Directories required for Phone Book Service.
//
//  Arguments:  None
//
//  Returns:    TRUE if successful, FALSE otherwise.
//
//  Author:     a-anasj Mar 9/1998
//              quintinb Jan 10/1999  added error checking and replaced asserts with traces
//
//  Notes:
//
BOOL RemoveCPSVRoots()
{
    HRESULT hr;
    HKEY hKey;

    hr = DeleteVirtualRoot(www, L"PBServer");
    if (SUCCEEDED(hr))
    {
        //
        //  Now delete the associated reg key
        //
        hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE,
            L"SYSTEM\\CurrentControlSet\\Services\\W3SVC\\Parameters\\Virtual Roots",
            KEY_ALL_ACCESS, &hKey);

        if (SUCCEEDED(hr))
        {
            if (ERROR_SUCCESS == RegDeleteValue(hKey, L"/PBServer"))
            {
                hr = S_OK;
            }
            else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
            {
                hr = S_FALSE;
            }

            RegCloseKey(hKey);
        }
        else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
        {
            hr = S_FALSE;
        }
    }
    TraceError("RemoveCPSVRoots -- Deleting PBServer Www Vroot", hr);

    hr = DeleteVirtualRoot(www, L"PBSData");
    if (SUCCEEDED(hr))
    {
        //
        //  Now delete the associated reg key
        //
        hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE,
            L"SYSTEM\\CurrentControlSet\\Services\\W3SVC\\Parameters\\Virtual Roots",
            KEY_ALL_ACCESS, &hKey);

        if (SUCCEEDED(hr))
        {
            if (ERROR_SUCCESS == RegDeleteValue(hKey, L"/PBSData"))
            {
                hr = S_OK;
            }
            else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
            {
                hr = S_FALSE;
            }

            RegCloseKey(hKey);
        }
        else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
        {
            hr = S_FALSE;
        }
    }
    TraceError("RemoveCPSVRoots -- Deleting PBSData WWW Vroot", hr);

    hr = DeleteVirtualRoot(ftp, L"PBSData");
    if (SUCCEEDED(hr))
    {
        //
        //  Now delete the associated reg key
        //
        hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE,
            L"SYSTEM\\CurrentControlSet\\Services\\MSFTPSVC\\Parameters\\Virtual Roots",
            KEY_ALL_ACCESS, &hKey);

        if (SUCCEEDED(hr))
        {
            if (ERROR_SUCCESS == RegDeleteValue(hKey, L"/PBSData"))
            {
                hr = S_OK;
            }
            else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
            {
                hr = S_FALSE;
            }

            RegCloseKey(hKey);
        }
        else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
        {
            hr = S_FALSE;
        }
    }
    TraceError("RemoveCPSVRoots -- Deleting PBSData FTP Vroot", hr);

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   DeleteVirtualRoot
//
//  Purpose:    Deletes a Virtual Root in the WWW or FTP services.
//
//  Arguments:
//
//  Returns:    S_OK if successful, Win32 error otherwise.
//
//  Author:     a-anasj Mar 9/1998
//
//  Notes:
//
HRESULT DeleteVirtualRoot(e_rootType rootType, PWSTR szPathW)
{

    HRESULT hr = S_OK;                  // com error status
    IMSAdminBase *pIMeta = NULL;
    METADATA_HANDLE hMeta = NULL;       // handle to metabase
    PWSTR szMBPathW;

    if (www == rootType)
    {
        szMBPathW = L"/LM/W3svc/1/ROOT";
    }
    else if (ftp == rootType)
    {
        szMBPathW = L"/LM/MSFTPSVC/1/ROOT";
    }
    else
    {
        //  Unknown root type
        //
        ASSERT(FALSE);
        return S_FALSE;
    }


    if (FAILED(CoInitialize(NULL)))
    {
        return S_FALSE;
        //error_leave("CoInitialize");
    }

    // Create an instance of the metabase object
    hr=::CoCreateInstance(CLSID_MSAdminBase,//CLSID_MSAdminBase,
                          NULL,
                          CLSCTX_ALL,
                          IID_IMSAdminBase,
                          (void **)&pIMeta);
    if (FAILED(hr))
    {
        error_leave("CoCreateInstance");
    }

    // open key to ROOT on website #1 (where all the VDirs live)
    hr = pIMeta->OpenKey(METADATA_MASTER_ROOT_HANDLE,
                         szMBPathW,
                         METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
                         1000,
                         &hMeta);
    if (FAILED(hr))
    {
        error_leave("OpenKey");
    }

    // Add new VDir called szDirW

    hr=pIMeta->DeleteKey(hMeta, szPathW);

    if (FAILED(hr))
    {
        error_leave("DeleteKey");
    }

    // Call CloseKey() prior to calling SaveData
    pIMeta->CloseKey(hMeta);
    hMeta = NULL;
    // Flush out the changes and close
    hr=pIMeta->SaveData();
    if (FAILED(hr))
    {
        error_leave("SaveData");
    }

leave_routine:
    if (pIMeta)
    {
        if(hMeta)
            pIMeta->CloseKey(hMeta);
        pIMeta->Release();
    }
    CoUninitialize();
    return hr;
}

HRESULT SetDirectoryAccessPermissions(PWSTR pszFile, ACCESS_MASK AccessRightsToModify,
                                      ACCESS_MODE fAccessFlags, PSID pSid)
{
    if (!pszFile && !pSid)
    {
        return E_INVALIDARG;
    }

    EXPLICIT_ACCESS         AccessEntry = {0};
    PSECURITY_DESCRIPTOR    pSecurityDescriptor = NULL;
    PACL                    pOldAccessList = NULL;
    PACL                    pNewAccessList = NULL;
    DWORD                   dwRes;

    // Get the current DACL information from the object.

    dwRes = GetNamedSecurityInfo(pszFile,                        // name of the object
                                 SE_FILE_OBJECT,                 // type of object
                                 DACL_SECURITY_INFORMATION,      // type of information to set
                                 NULL,                           // provider is Windows NT
                                 NULL,                           // name or GUID of property or property set
                                 &pOldAccessList,                // receives existing DACL information
                                 NULL,                           // receives existing SACL information
                                 &pSecurityDescriptor);          // receives a pointer to the security descriptor

    if (ERROR_SUCCESS == dwRes)
    {
        //
        // Initialize the access list entry.
        //
        BuildTrusteeWithSid(&(AccessEntry.Trustee), pSid);
        
        AccessEntry.grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
        AccessEntry.grfAccessMode = fAccessFlags;   

        //
        // Set provider-independent standard rights.
        //
        AccessEntry.grfAccessPermissions = AccessRightsToModify;

        //
        // Build an access list from the access list entry.
        //

        dwRes = SetEntriesInAcl(1, &AccessEntry, pOldAccessList, &pNewAccessList);

        if (ERROR_SUCCESS == dwRes)
        {
            //
            // Set the access-control information in the object's DACL.
            //
            dwRes = SetNamedSecurityInfo(pszFile,                     // name of the object
                                         SE_FILE_OBJECT,              // type of object
                                         DACL_SECURITY_INFORMATION,   // type of information to set
                                         NULL,                        // pointer to the new owner SID
                                         NULL,                        // pointer to the new primary group SID
                                         pNewAccessList,              // pointer to new DACL
                                         NULL);                       // pointer to new SACL
        }
    }

    //
    // Free the returned buffers.
    //
    if (pNewAccessList)
    {
        LocalFree(pNewAccessList);
    }

    if (pSecurityDescriptor)
    {
        LocalFree(pSecurityDescriptor);
    }

    //
    //  If the system is using FAT instead of NTFS, then we will get the Invalid Acl error.
    //
    if (ERROR_INVALID_ACL == dwRes)
    {
        return S_FALSE;
    }
    else
    {
        return HRESULT_FROM_WIN32(dwRes);
    }
}

void SetCpsDirPermissions()
{
    WCHAR szPath[MAX_PATH+1];
    HRESULT hr;

    //
    //  Previous versions of CPS gave "Everyone" permissions for the CPS directories.
    //  For .Netserver2003 onwards, we ACL differently, but need to undo the previous ACL'ing.
    //  Thus the first block below removes all access for "Everyone".  The 2nd block
    //  grants the appropriate access to "Authenticated Users". See bug 729903 for details.
    //

    //
    //  Create the SID for the Everyone Account (World account)
    //
    
    PSID pWorldSid;
    SID_IDENTIFIER_AUTHORITY WorldSidAuthority = SECURITY_WORLD_SID_AUTHORITY;
    
    BOOL bRet = AllocateAndInitializeSid (&WorldSidAuthority, 1, SECURITY_WORLD_RID, 
                              0, 0, 0, 0, 0, 0, 0, &pWorldSid);
    
    if (bRet && pWorldSid)
    {
        ACCESS_MODE fAccessFlags = REVOKE_ACCESS;
    
        //
        //  Set the Data Dir access permissions
        //
        wsprintf(szPath, c_szSSFmt, g_szProgramFiles, c_szPbsDataPath);
        hr = SetDirectoryAccessPermissions(szPath, 0, fAccessFlags, pWorldSid);
        TraceError("SetCpsDirPermissions -- removed Everyone perms from Data dir", hr);
    
        //
        //  Set the Bin Dir access permissions
        //
        wsprintf(szPath, c_szSSFmt, g_szProgramFiles, c_szPbsBinPath);
        hr = SetDirectoryAccessPermissions(szPath, 0, fAccessFlags, pWorldSid);
        TraceError("SetCpsDirPermissions -- removed Everyone perms from Bin dir", hr);
    
        //
        //  Set the Root Dir access permissions
        //
        wsprintf(szPath, c_szSSFmt, g_szProgramFiles, c_szPbsRootPath);
        hr = SetDirectoryAccessPermissions(szPath, 0, fAccessFlags, pWorldSid);
        TraceError("SetCpsDirPermissions -- removed Everyone perms from Root dir", hr);
    
        FreeSid(pWorldSid);
    }

    //
    //  Create the SID for "Authenticated Users"
    //

    PSID pAuthUsersSid;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;

    bRet = AllocateAndInitializeSid (&NtAuthority, 1, SECURITY_AUTHENTICATED_USER_RID, 
                              0, 0, 0, 0, 0, 0, 0, &pAuthUsersSid);

    if (bRet && pAuthUsersSid)
    {
        const ACCESS_MASK c_Write = FILE_WRITE_ATTRIBUTES | FILE_WRITE_DATA | FILE_WRITE_EA | 
                                     FILE_ADD_SUBDIRECTORY | FILE_ADD_FILE | 
                                     FILE_DELETE_CHILD | FILE_APPEND_DATA;

        const ACCESS_MASK c_Read = FILE_READ_ATTRIBUTES | FILE_READ_DATA | FILE_READ_EA |
                                    FILE_LIST_DIRECTORY | SYNCHRONIZE | READ_CONTROL;

        const ACCESS_MASK c_Execute = FILE_EXECUTE | FILE_TRAVERSE;

        ACCESS_MASK arCpsRoot= c_Read;

        ACCESS_MASK arCpsBin=  c_Read | c_Execute;

        ACCESS_MASK arCpsData= c_Read | c_Write;

        ACCESS_MODE fAccessFlags = GRANT_ACCESS;

        //
        //  Set the Data Dir access permissions
        //
        wsprintf(szPath, c_szSSFmt, g_szProgramFiles, c_szPbsDataPath);
        hr = SetDirectoryAccessPermissions(szPath, arCpsData, fAccessFlags, pAuthUsersSid);
        TraceError("SetCpsDirPermissions -- Data dir", hr);

        //
        //  Set the Bin Dir access permissions
        //
        wsprintf(szPath, c_szSSFmt, g_szProgramFiles, c_szPbsBinPath);
        hr = SetDirectoryAccessPermissions(szPath, arCpsBin, fAccessFlags, pAuthUsersSid);
        TraceError("SetCpsDirPermissions -- Bin dir", hr);

        //
        //  Set the Root Dir access permissions
        //
        wsprintf(szPath, c_szSSFmt, g_szProgramFiles, c_szPbsRootPath);
        hr = SetDirectoryAccessPermissions(szPath, arCpsRoot, fAccessFlags, pAuthUsersSid);
        TraceError("SetCpsDirPermissions -- Root dir", hr);

        FreeSid(pAuthUsersSid);
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   CreateNewAppPoolAndAddPBS
//
//  Purpose:    Creates new app pool for PBS, and sets non-default params we need
//
//  Arguments:  none
//
//  Returns:    S_OK if successful, Win32 error otherwise.
//
//  Author:     SumitC      24-Sep-2001
//
//  Notes:
//
HRESULT CreateNewAppPoolAndAddPBS()
{
    HRESULT hr = S_OK;
    IMSAdminBase *pIMeta = NULL;
    METADATA_HANDLE hMeta = NULL;
    METADATA_RECORD mr;

    if (FAILED(CoInitialize(NULL)))
    {
        return S_FALSE;
    }

    // Create an instance of the metabase object
    hr=::CoCreateInstance(CLSID_MSAdminBase,
                          NULL,
                          CLSCTX_ALL,
                          IID_IMSAdminBase,
                          (void **)&pIMeta);
    if (FAILED(hr))
    {
        error_leave("CoCreateInstance");
    }

    // open key to App Pools root
    hr = pIMeta->OpenKey(METADATA_MASTER_ROOT_HANDLE,
                         L"/LM/W3svc/AppPools",
                         METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
                         1000,
                         &hMeta);
    if (FAILED(hr))
    {
        error_leave("OpenKey");
    }

    // Add new app pool
    hr=pIMeta->AddKey(hMeta, c_szPBSAppPoolID);

    if (FAILED(hr))
    {
        error_leave("Addkey");
    }

    // Set the key type
    ZeroMemory((PVOID)&mr, sizeof(METADATA_RECORD));
    mr.dwMDIdentifier = MD_KEY_TYPE;
    mr.dwMDAttributes = METADATA_NO_ATTRIBUTES;
    mr.dwMDUserType   = IIS_MD_UT_SERVER;
    mr.dwMDDataType   = STRING_METADATA;
    mr.dwMDDataLen    = (wcslen(c_szAppPoolKey) + 1) * sizeof(WCHAR);
    mr.pbMDData       = (unsigned char*)(c_szAppPoolKey);
    mr.dwMDDataTag    = 0;          // reserved

    hr=pIMeta->SetData(hMeta, c_szPBSAppPoolID, &mr);

    if (FAILED(hr))
    {
        error_leave("SetData");
    }

    // Disable overlapped rotation
    ZeroMemory((PVOID)&mr, sizeof(METADATA_RECORD));

    DWORD dwDisableOverlappingRotation = TRUE;
    mr.dwMDIdentifier = MD_APPPOOL_DISALLOW_OVERLAPPING_ROTATION;
    mr.dwMDAttributes = METADATA_INHERIT;
    mr.dwMDUserType   = IIS_MD_UT_SERVER;
    mr.dwMDDataType   = DWORD_METADATA;
    mr.pbMDData       = (PBYTE) &dwDisableOverlappingRotation;
    mr.dwMDDataLen    = sizeof (DWORD);
    mr.dwMDDataTag    = 0;          // reserved

    hr=pIMeta->SetData(hMeta, c_szPBSAppPoolID, &mr);

    if (FAILED(hr))
    {
        error_leave("SetData");
    }

    // Call CloseKey() prior to calling SaveData
    pIMeta->CloseKey(hMeta);
    hMeta = NULL;

    // Flush out the changes and close
    hr=pIMeta->SaveData();
    if (FAILED(hr))
    {
        error_leave("SaveData");
    }

    //
    //  Now add PBS to this app pool
    //
    hr = pIMeta->OpenKey(METADATA_MASTER_ROOT_HANDLE,
                         L"/LM/w3svc/1/Root/PBServer",
                         METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
                         1000,
                         &hMeta);
    if (FAILED(hr))
    {
        error_leave("OpenKey");
    }

    ZeroMemory((PVOID)&mr, sizeof(METADATA_RECORD));
    mr.dwMDIdentifier = MD_APP_APPPOOL_ID;
    mr.dwMDAttributes = METADATA_INHERIT;
    mr.dwMDUserType   = IIS_MD_UT_SERVER;
    mr.dwMDDataType   = STRING_METADATA;
    mr.dwMDDataLen    = (wcslen(c_szPBSAppPoolID) + 1) * sizeof(WCHAR);
    mr.pbMDData       = (unsigned char*)(c_szPBSAppPoolID);

    hr=pIMeta->SetData(hMeta, TEXT(""), &mr);

    if (FAILED(hr))
    {
        error_leave("SetData");
    }

    // Call CloseKey() prior to calling SaveData
    pIMeta->CloseKey(hMeta);
    hMeta = NULL;

    // Flush out the changes and close
    hr=pIMeta->SaveData();
    if (FAILED(hr))
    {
        error_leave("SaveData");
    }

leave_routine:
    if (pIMeta)
    {
        if(hMeta)
            pIMeta->CloseKey(hMeta);
        pIMeta->Release();
    }
    CoUninitialize();
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   DeleteAppPool
//
//  Purpose:    Deletes new app pool created for PBS
//
//  Arguments:  none
//
//  Returns:    S_OK if successful, Win32 error otherwise.
//
//  Author:     SumitC      24-Sep-2001
//
//  Notes:
//
HRESULT DeleteAppPool()
{
    HRESULT hr = S_OK;
    IMSAdminBase *pIMeta = NULL;
    METADATA_HANDLE hMeta = NULL;

    if (FAILED(CoInitialize(NULL)))
    {
        return S_FALSE;
    }

    // Create an instance of the metabase object
    hr=::CoCreateInstance(CLSID_MSAdminBase,
                          NULL,
                          CLSCTX_ALL,
                          IID_IMSAdminBase,
                          (void **)&pIMeta);
    if (FAILED(hr))
    {
        error_leave("CoCreateInstance");
    }

    // open key to App Pools root
    hr = pIMeta->OpenKey(METADATA_MASTER_ROOT_HANDLE,
                         L"/LM/W3svc/AppPools",
                         METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
                         1000,
                         &hMeta);
    if (FAILED(hr))
    {
        error_leave("OpenKey");
    }

    // Delete previously-created app pool

    hr=pIMeta->DeleteKey(hMeta, c_szPBSAppPoolID);
    if (FAILED(hr))
    {
        error_leave("DeleteKey");
    }

    // Call CloseKey() prior to calling SaveData
    pIMeta->CloseKey(hMeta);
    hMeta = NULL;

    // Flush out the changes and close
    hr=pIMeta->SaveData();
    if (FAILED(hr))
    {
        error_leave("SaveData");
    }

leave_routine:
    if (pIMeta)
    {
        if(hMeta)
            pIMeta->CloseKey(hMeta);
        pIMeta->Release();
    }
    CoUninitialize();
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   EnableISAPIRequests
//
//  Purpose:    Enables ISAPI requests if appropriate
//
//  Arguments:  szComponentName - mostly for reporting errors
//
//  Returns:    S_OK if successful, Win32 error otherwise.
//
//  Author:     SumitC      18-Sep-2001
//
//  Notes:
//
HRESULT EnableISAPIRequests(PCTSTR szComponentName)
{
    HRESULT hr = S_OK; 
    BOOL    fEnablePBSRequests = FALSE;
    BOOL    fDontShowUI = FALSE;

    // NOTE: if the following becomes available as a global var or a member of pnocd, use that.
    fDontShowUI = (g_ocmData.sic.SetupData.OperationFlags & SETUPOP_BATCH) && 
                  (!g_ocmData.fShowUnattendedMessages);

    if (fDontShowUI)
    {
        // "Unattended" mode

        //
        //  Per the IIS spec, the NetCMAK or NetCPS unattended file entry is a good enough
        //  indication that the admin intends to install *and enable* PBS, so
        //  we can enable PBS requests, as long as we log that we did this.
        //
        fEnablePBSRequests = TRUE;
    }
    else
    {
        // "Attended mode", so interact with user
        int     nRet;

        //
        // warn admin about security concerns and ask about enabling PBS requests
        //
        nRet = NcMsgBoxMc(g_ocmData.hwnd, IDS_OC_CAPTION, IDS_OC_PBS_ENABLE_ISAPI_REQUESTS,
                          MB_YESNO | MB_ICONWARNING);

        fEnablePBSRequests = (IDYES == nRet) ? TRUE : FALSE;
    }

    //
    //  Enable if appropriate, or say they have to do this themselves
    //
    if (FALSE == fEnablePBSRequests)
    {
        //
        //  Don't show UI because the previous dialog has already explained the situation.
        //
        (void) ReportEventHrString(TEXT("You must enable Phone Book Service ISAPI requests using the IIS Security Wizard"),
                                   IDS_OC_PBS_ENABLE_ISAPI_YOURSELF, szComponentName);
    }
    else
    {
        //
        //  Fire up a process to enable PBS in the IIS metabase
        //
        hr = UseProcessToEnableDisablePBS(TRUE);        // TRUE => enable

        if (S_OK != hr)
        {
            //
            //  we use a function that puts up UI if appropriate, otherwise logs.
            //  
            (void) ReportErrorHr(hr, 
                                 IDS_OC_PBS_ENABLE_ISAPI_YOURSELF,
                                 g_ocmData.hwnd, szComponentName);
        }
        else
        {
            //
            //  Write Success event to the event log
            //
            HANDLE  hEventLog = RegisterEventSource(NULL, NETOC_SERVICE_NAME);

            if (NULL == hEventLog)
            {
                TraceTag(ttidNetOc, "EnableISAPIRequests - RegisterEventSource failed (GLE=%d), couldn't log success event", GetLastError());
            }
            else
            {
                PCWSTR  plpszArgs[2];

                plpszArgs[0] = NETOC_SERVICE_NAME;
                plpszArgs[1] = L"Phone Book Service";

                if (!ReportEvent(hEventLog,                 // event log handle 
                                 EVENTLOG_INFORMATION_TYPE, // event type 
                                 0,                         // category zero 
                                 IDS_OC_ISAPI_REENABLED,    // event identifier 
                                 NULL,                      // no user security identifier 
                                 2,                         // two substitution strings 
                                 0,                         // no data 
                                 plpszArgs,                 // pointer to string array 
                                 NULL))                     // pointer to data 
                {
                    TraceTag(ttidNetOc, "EnableISAPIRequests - ReportEvent failed with %x, couldn't log success event", GetLastError());
                }

                DeregisterEventSource(hEventLog);
            }

            //  I suppose I could now ReportErrorHr saying that logging the success event failed.
            //  But I won't.
        }
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   UseProcessToEnableDisablePBS
//
//  Purpose:    Starts a process (pbsnetoc.exe) to enable or disable PBS within
//              the IIS metabase
//
//  Arguments:  fEnable - true => enable PBS, false => disable PBS
//
//  Returns:    S_OK if successful, HRESULT otherwise.
//
//  Author:     SumitC      05-Jun-2002
//
//  Notes:      We need to use this method (instead of a call from within netoc.dll)
//              because IIS wants us to use ADSI to get to their metabase.  However,
//              ADSI has problems when used by several clients within a large process.
//              Specifically, whoever uses ADSI first causes the list of ADSI providers
//              to be initialized - and frozen.  If any providers register themselves
//              after this, they will be ignored by this ADSI instance.  Thus, if our
//              code is running within a process like setup.exe (gui-mode setup) or
//              sysocmgr.exe, and some other ADSI client initializes ADSI early on,
//              and then IIS registers itself, and then we try to do our setup via
//              ADSI calls - those would fail.  Using a separate EXE bypasses this problem.
//
HRESULT UseProcessToEnableDisablePBS(BOOL fEnable)
{
    HRESULT             hr = S_OK;
    STARTUPINFO         StartupInfo = {0};
    PROCESS_INFORMATION ProcessInfo = {0};
    WCHAR               szFullPath[MAX_PATH + 1];
    WCHAR               szCmdLine[MAX_PATH + 1];
    DWORD               dwReturnValue = S_OK;

    GetSystemDirectory(szFullPath, MAX_PATH + 1);
    if ((lstrlen(szFullPath) + lstrlen(L"\\setup\\pbsnetoc.exe")) <= MAX_PATH)
    {
        lstrcat(szFullPath, L"\\setup\\pbsnetoc.exe");
    }

    wsprintf(szCmdLine, L"%s %s", szFullPath, (fEnable ? L"/i" : L"/u"));

    if (NULL == CreateProcess(szFullPath, szCmdLine,
                              NULL, NULL, FALSE, 0,
                              NULL, NULL,
                              &StartupInfo, &ProcessInfo))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        TraceError("RunAsExeFromSystem() CreateProcess() for pbsnetoc.exe failed, GLE=%u.", GetLastError());
        ProcessInfo.hProcess = NULL;
    }
    else
    {
        WaitForSingleObject(ProcessInfo.hProcess, 10 * 1000);   // wait 10 seconds

        (void) GetExitCodeProcess(ProcessInfo.hProcess, &dwReturnValue);

        if (dwReturnValue != S_OK)
        {
            hr = (HRESULT) dwReturnValue;
        }

        CloseHandle(ProcessInfo.hProcess);
        CloseHandle(ProcessInfo.hThread);
    }
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netoc\ncdhcps.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C D H C P S . H
//
//  Contents:   Installation support for DHCP Server
//
//  Notes:      B sharp
//
//  Author:     jeffspr   13 May 1997
//
//----------------------------------------------------------------------------

#ifndef _NCDHCPS_H_
#define _NCDHCPS_H_

#pragma once
#include "netoc.h"

HRESULT HrOcDhcpOnInstall(PNETOCDATA pnocd);
HRESULT HrOcExtDHCPServer(PNETOCDATA pnocd, UINT uMsg,
                          WPARAM wParam, LPARAM lParam);
HRESULT HrSetServiceRecoveryOption(PNETOCDATA pnocd);

#endif // _NCDHCPS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netoc\ncias.cpp ===
//+---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corp. All rights reserved.
//
//  File:       ncias.cpp
//
//  Contents:   Installation support for IAS service
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "netoc.h"
#include "ncreg.h"

#include "ncias.h"
#include "ncstring.h"

#include "userenv.h"

static const char   c_szIASRegisterFunctionName[]   = "IASDirectoryRegisterService";
static const char   c_szIASUnRegisterFunctionName[] = "IASDirectoryUnregisterService";
static const WCHAR  c_szIASDllName[]                = L"ias.dll";


//
//  Function:   HrOcIASUnRegisterActiveDirectory
//
//  Purpose:   Try to remove IAS from the Active Directory 
//             if the computer is part of a Win2k domain... 
//
HRESULT HrOcIASUnRegisterActiveDirectory()
{
    typedef INT_PTR (WINAPI *UNREGISTER_IAS_ACTIVE_DIRECTORY)();

    UNREGISTER_IAS_ACTIVE_DIRECTORY   pfnUnRegisterIASActiveDirectory;
    
    ///////////////////
    // Load ias.dll
    ///////////////////
    HMODULE         hmod;
    HRESULT         hr = HrLoadLibAndGetProc (      
                                c_szIASDllName,
                                c_szIASUnRegisterFunctionName,
                                &hmod,
                                &pfnUnRegisterIASActiveDirectory
                             );
    if (S_OK == hr)
    {
        // fix bug 444354
        // pfnUnRegisterIASActiveDirectory not NULL here
        if (!FAILED (CoInitialize(NULL)))
        {
            INT_PTR lresult = pfnUnRegisterIASActiveDirectory();

            if (ERROR_SUCCESS != lresult)
            {
                hr = S_OK; //not a fatal error, should be ignored
            }
            CoUninitialize();
        }

        FreeLibrary(hmod);
    }

    // Errors ignored
    hr = S_OK;
    return hr;
}


//
//  Function:   HrOcIASRegisterActiveDirectory
//
//  Purpose:   Try to register IAS in the Active Directory 
//             if the computer is part of a Win2k domain... 
//
HRESULT HrOcIASRegisterActiveDirectory()
{
    typedef INT_PTR (WINAPI *REGISTER_IAS_ACTIVE_DIRECTORY)();

    REGISTER_IAS_ACTIVE_DIRECTORY   pfnRegisterIASActiveDirectory;
    
    ///////////////////
    // Load ias.dll
    ///////////////////
    HMODULE         hmod;
    HRESULT         hr = HrLoadLibAndGetProc (      
                                c_szIASDllName,
                                c_szIASRegisterFunctionName,
                                &hmod,
                                &pfnRegisterIASActiveDirectory
                             );
    if (S_OK == hr)
    {
        // Fix bug 444353
        // pfnRegisterIASActiveDirectory not NULL here
        if (!FAILED (CoInitialize(NULL)))
        {

            INT_PTR lresult = pfnRegisterIASActiveDirectory();

            if (ERROR_SUCCESS != lresult)
            {
                hr = S_OK; //not a fatal error, should be ignored
            }  
            CoUninitialize();
        }

        FreeLibrary(hmod);
    }

    // Errors ignored
    hr = S_OK;
    return hr;
}


HRESULT HrOcIASRegisterPerfDll()
{
    const WCHAR  c_szIASPerfDllName[]            = L"iasperf.dll";
    const char   c_szIASPerfFunctionName[]       = "DllRegisterServer";
    typedef INT_PTR (*DLLREGISTERSERVER)();

    DLLREGISTERSERVER   pfnDllRegisterServer;
    
    ///////////////////
    // Load iasperf.dll
    ///////////////////
    HMODULE hmod;
    HRESULT hr = HrLoadLibAndGetProc (      
                     c_szIASPerfDllName,
                     c_szIASPerfFunctionName,
                     &hmod,
                     &pfnDllRegisterServer
                     );
    if (S_OK == hr)
    {
        // pfnDllRegisterServer not NULL here
         HRESULT result = (HRESULT)pfnDllRegisterServer();

         if (FAILED(result))
         {
             TraceErrorOptional("Registration of iasperf.dll failed", result, true);
         }

        FreeLibrary(hmod);
    }

    // Errors ignored
    return S_OK;
}


//
//  Function:   HrOcIASPostInstall
//
//  Purpose:    Called when IAS service is being installed/upgraded/removed.
//              Called after the processing of the INF file
//
//  Arguments:
//      pnocd           [in]   Pointer to NETOC data.
//
//  Returns:    S_OK if successful, Win32 error otherwise.
//
HRESULT HrOcIASPostInstall(const PNETOCDATA pnocd)
{ 
    HRESULT             hr;
    
    switch(pnocd->eit)
    {
    case IT_INSTALL:
        {
            // call the Active Directory registration code here
            hr = HrOcIASRegisterActiveDirectory();
            break;
        }
    case IT_REMOVE:
        {
            // call the Active Directory clean code here
            hr = HrOcIASUnRegisterActiveDirectory();
            break;
        }
    case IT_UPGRADE:
        {

            hr = HrOcIASRegisterPerfDll();
            break;
        }
    default:
        {
            hr = S_OK; //  some new messages should not be seen as errors 
        }
    }

    TraceError("HrOcIASPostInstall", hr); 
    return      hr;
}


//
//  Function:   HrOcExtIAS
//
//  Purpose:    NetOC external message handler
//
HRESULT HrOcExtIAS(PNETOCDATA pnocd, UINT uMsg,
                   WPARAM wParam, LPARAM lParam)
{
    HRESULT         hr;
    Assert(pnocd);

    switch (uMsg)
    {
    case NETOCM_POST_INSTALL:
        {
            hr = HrOcIASPostInstall(pnocd);
            break;
        }
    default:
        {
            hr = S_OK; //  some new messages should not be seen as errors 
        }
    }

    TraceError("HrOcExtIAS", hr);
    return      hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netoc\ncdhcps.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C D H C P S . C P P
//
//  Contents:   Installation support for DHCP Server
//
//  Notes:
//
//  Author:     jeffspr     13 May 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "ncdhcps.h"
#include "ncreg.h"
#include "ncsvc.h"
#include "netoc.h"
#include "ncnetcfg.h"
#include "netcfgp.h"
#include "ncmisc.h"
#include "netcfgn.h"

extern const WCHAR c_szInfId_MS_DHCPServer[];

static const WCHAR c_szDHCPServerParamPath[]    = L"System\\CurrentControlSet\\Services\\DHCPServer\\Parameters";

//$ REVIEW (jeffspr) 13 May 1997: These obviously need to be localized.
static const WCHAR      c_szDisplayName[]   = L"DHCP Server";
static const WCHAR      c_szManufacturer[]  = L"Microsoft";
static const WCHAR      c_szProduct[]       = L"DHCPServer";

//+---------------------------------------------------------------------------
//
//  Function:   HrInstallDHCPServerNotifyObject
//
//  Purpose:    Handles the installation of DHCP Server on behalf of the DHCP
//              Server optional component. Calls into the INetCfg interface
//              to do the install.
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK if successful, Win32 error otherwise.
//
//  Author:     jeffspr   13 May 1997
//
//  Notes:
//
HRESULT HrInstallDHCPServerNotifyObject(PNETOCDATA pnocd)
{
    HRESULT                 hr          = S_OK;
    INetCfg *               pnc         = NULL;
    INetCfgComponent*       pncc        = NULL;
    INetCfgComponentSetup*  pnccSetup   = NULL;

    hr = HrOcGetINetCfg(pnocd, TRUE, &pnc);
    if (SUCCEEDED(hr))
    {
        NETWORK_INSTALL_PARAMS  nip = {0};

        nip.dwSetupFlags = FInSystemSetup() ? NSF_PRIMARYINSTALL :
                                              NSF_POSTSYSINSTALL;
        Assert(pnocd);

        TraceTag(ttidNetOc, "Installing DHCP Server notify object");
        hr = HrInstallComponentOboUser(
            pnc,
            &nip,
            GUID_DEVCLASS_NETSERVICE,
            c_szInfId_MS_DHCPServer,
            &pncc);
        if (SUCCEEDED(hr))
        {
            TraceTag(ttidNetOc, "QI'ing INetCfgComponentPrivate from DHCP pncc");

            // Need to query for the private component interface which
            // gives us access to the notify object.
            //
            INetCfgComponentPrivate* pnccPrivate = NULL;
            hr = pncc->QueryInterface(
                    IID_INetCfgComponentPrivate,
                    reinterpret_cast<void**>(&pnccPrivate));
            if (S_OK == hr)
            {
                TraceTag(ttidNetOc, "Getting notify object INetCfgComponentSetup from pnccSetup");

                // Query the notify object for its setup interface.
                // If it doesn't support it, that's okay, we can continue.
                //
                hr = pnccPrivate->QueryNotifyObject(
                        IID_INetCfgComponentSetup,
                        (void**) &pnccSetup);
                if (S_OK == hr)
                {
                    TraceTag(ttidNetOc, "Calling pnccSetup->ReadAnswerFile()");

                    (VOID) pnccSetup->ReadAnswerFile(g_ocmData.sic.SetupData.UnattendFile, pnocd->pszSection);

                    hr = pnc->Apply();

                    ReleaseObj(pnccSetup);
                }

                ReleaseObj(pnccPrivate);
            }

            ReleaseObj(pncc);
        }

        (VOID) HrUninitializeAndReleaseINetCfg(TRUE, pnc, TRUE);
    }

    TraceError("HrInstallDHCPServerNotifyObject", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRemoveDHCPServerNotifyObject
//
//  Purpose:    Handles the removal of the DHCP Server on behalf of the DHCP
//              Server optional component. Calls into the INetCfg interface
//              to do the actual removal.
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK if successful, Win32 error otherwise.
//
//  Author:     jeffspr   13 Jun 1997
//
//  Notes:
//
HRESULT HrRemoveDHCPServerNotifyObject(PNETOCDATA pnocd)
{
    HRESULT     hr  = S_OK;
    INetCfg *   pnc = NULL;

    hr = HrOcGetINetCfg(pnocd, TRUE, &pnc);
    if (SUCCEEDED(hr))
    {
        // Ignore the return from this. This is purely to remove the
        // spurious user refcount from NT4 to NT5 upgrade. This will
        // likely fail when removing a fresh install of DHCP Server.
        //
        hr = HrRemoveComponentOboUser(
            pnc,
            GUID_DEVCLASS_NETSERVICE,
            c_szInfId_MS_DHCPServer);

        if (SUCCEEDED(hr))
        {
            hr = pnc->Apply();
        }

        (VOID) HrUninitializeAndReleaseINetCfg(TRUE, pnc, TRUE);
    }

    TraceError("HrRemoveDHCPServerNotifyObject", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrSetDhcpServiceRecoveryOption
//
//  Purpose:    Sets the recovery options for the DHCPServer service
//
//  Arguments:
//      pnocd [in]  Pointer to NETOC data.
//
//  Returns:    S_OK if successful, Win32 error otherwise.
//
//  Author:     danielwe   26 May 1999
//
//  Notes:
//
HRESULT HrSetDhcpServiceRecoveryOption(PNETOCDATA pnocd)
{
    CServiceManager     sm;
    CService            service;
    HRESULT             hr = S_OK;

    SC_ACTION   sra [4] =
    {
        { SC_ACTION_RESTART, 15*1000 }, // restart after 15 seconds
        { SC_ACTION_RESTART, 15*1000 }, // restart after 15 seconds
        { SC_ACTION_RESTART, 15*1000 }, // restart after 15 seconds
        { SC_ACTION_NONE,    30*1000 },
    };

    SERVICE_FAILURE_ACTIONS sfa =
    {
        60 * 60,        // dwResetPeriod is 1 hr
        L"",            // no reboot message
        L"",            // no command to execute
        4,              // 3 attempts to restart the server and stop after that
        sra
    };

    hr = sm.HrOpenService(&service, L"DHCPServer");
    if (S_OK == hr)
    {
        hr = service.HrSetServiceRestartRecoveryOption(&sfa);
    }

    TraceError("HrSetDhcpServiceRecoveryOption", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrInstallDHCPServer
//
//  Purpose:    Called when DHCP Server is being installed. Handles all of the
//              additional installation for DHCPS beyond that of the INF file.
//
//  Arguments:
//      pnocd           [in]   Pointer to NETOC data.
//
//  Returns:    S_OK if successful, Win32 error otherwise.
//
//  Author:     jeffspr     13 May 1997
//
//  Notes:
//
HRESULT HrInstallDHCPServer(PNETOCDATA pnocd)
{
    HRESULT         hr = S_OK;
    CServiceManager sm;
    CService        srv;

    Assert(pnocd);

    hr = HrHandleStaticIpDependency(pnocd);
    if (SUCCEEDED(hr))
    {
        hr = HrInstallDHCPServerNotifyObject(pnocd);
        if (SUCCEEDED(hr))
        {
            hr = HrSetDhcpServiceRecoveryOption(pnocd);
        }
    }

    TraceError("HrInstallDHCPServer", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRemoveDHCPServer
//
//  Purpose:    Handles additional removal requirements for DHCP Server
//              component.
//
//      hwnd [in]   Parent window for displaying UI.
//      poc  [in]   Pointer to optional component being installed.
//
//  Returns:    S_OK if successful, Win32 error otherwise.
//
//  Author:     jeffspr     13 May 1997
//
//  Notes:
//
HRESULT HrRemoveDHCPServer(PNETOCDATA pnocd)
{
    Assert(pnocd);

    // Get the path to the database files from the regsitry.
    // Important to do this before removing the component because
    // the registry locations get removed when removing the component.
    //
    tstring strDatabasePath;
    tstring strBackupDatabasePath;

    HKEY hkeyParams;
    HRESULT hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE,
                        c_szDHCPServerParamPath,
                        KEY_READ,
                        &hkeyParams);
    if (SUCCEEDED(hr))
    {
        (VOID) HrRegQueryExpandString (
                    hkeyParams,
                    L"DatabasePath",
                    &strDatabasePath);

        (VOID) HrRegQueryExpandString (
                    hkeyParams,
                    L"BackupDatabasePath",
                    &strBackupDatabasePath);

        RegCloseKey (hkeyParams);
    }

    // Remove DHCP server.
    //
    hr = HrRemoveDHCPServerNotifyObject(pnocd);

    if (SUCCEEDED(hr) &&
        !(strDatabasePath.empty() && strBackupDatabasePath.empty()))
    {
        (VOID) HrDeleteFileSpecification (
                    L"*.mdb",
                    strDatabasePath.c_str());

        (VOID) HrDeleteFileSpecification (
                    L"*.log",
                    strDatabasePath.c_str());

        (VOID) HrDeleteFileSpecification (
                    L"*.mdb",
                    strBackupDatabasePath.c_str());

        (VOID) HrDeleteFileSpecification (
                    L"*.log",
                    strBackupDatabasePath.c_str());
    }

    TraceError("HrRemoveDHCPServer", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOcExtDHCPServer
//
//  Purpose:    NetOC external message handler
//
//  Arguments:
//      pnocd  []
//      uMsg   []
//      wParam []
//      lParam []
//
//  Returns:
//
//  Author:     danielwe   17 Sep 1998
//
//  Notes:
//
HRESULT HrOcExtDHCPServer(PNETOCDATA pnocd, UINT uMsg,
                          WPARAM wParam, LPARAM lParam)
{
    HRESULT     hr = S_OK;

    Assert(pnocd);

    switch (uMsg)
    {
    case NETOCM_POST_INSTALL:
        hr = HrOcDhcpOnInstall(pnocd);
        break;
    }

    TraceError("HrOcExtDHCPServer", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOcDhcpOnInstall
//
//  Purpose:    Called by optional components installer code to handle
//              additional installation requirements for DHCP Server
//
//  Arguments:
//      pnocd           [in]   Pointer to NETOC data
//
//  Returns:    S_OK if successful, Win32 error otherwise.
//
//  Author:     jeffspr     13 May 1997
//
//  Notes:
//
HRESULT HrOcDhcpOnInstall(PNETOCDATA pnocd)
{
    HRESULT     hr = S_OK;

    switch(pnocd->eit)
    {
        // Install DHCP
        case IT_INSTALL:
            hr = HrInstallDHCPServer(pnocd);
            break;

        // Remove DHCP
        case IT_REMOVE:
            hr = HrRemoveDHCPServer(pnocd);
            break;

        case IT_UPGRADE:
            hr = HrSetDhcpServiceRecoveryOption(pnocd);
            break;
    }

    TraceError("HrOcDhcpOnInstall", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netoc\ncsfm.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C S F M . H
//
//  Contents:   Installation support for Services for Macintosh.
//
//  Notes:
//
//  Author:     danielwe   5 May 1997
//
//----------------------------------------------------------------------------

#pragma once

#include "netoc.h"

BOOL FContainsUAMVolume(WCHAR chDrive);
HRESULT HrGetFirstPossibleUAMDrive(WCHAR *pchDriveLetter);
HRESULT HrInstallSFM(PNETOCDATA pnocd);
HRESULT HrCreateDirectory(PCWSTR pszDir);
HRESULT HrSetupUAM(PWSTR pszPath);
HRESULT HrRemoveSFM(PNETOCDATA pnocd);
HRESULT HrOcSfmOnQueryChangeSelState(PNETOCDATA pnocd, BOOL fShowUi);
HRESULT HrOcSfmOnInstall(PNETOCDATA pnocd);
HRESULT HrOcExtSFM(PNETOCDATA pnocd, UINT uMsg, WPARAM wParam, LPARAM lParam);
HRESULT HrDeleteOldFolders(PCWSTR pszUamPath);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netoc\ncsfm.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C S F M . C P P
//
//  Contents:   Installation support for Services for Macintosh.
//
//  Notes:
//
//  Author:     danielwe   5 May 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include <ncxbase.h>
#include "ncatlui.h"
#include "ncmisc.h"
#include "ncreg.h"
#include "ncsfm.h"
#include "ncui.h"
#include "netoc.h"
#include "netocp.h"
#include "resource.h"
#include "sfmsec.h"
#include "macfile.h"

extern const WCHAR      c_szBackslash[];

static const WCHAR      c_szNTFS[]          = L"NTFS";
static const WCHAR      c_szColonBackslash[]= L":\\";

// These will have %windir%\system32\ prepended to them
static const WCHAR      c_szSrcRSCFile[]    = L"SFMUAM.RSC";
static const WCHAR      c_szSrcRSCFile5[]   = L"SFMUAM5.RSC";
static const WCHAR      c_szSrcIFOFile[]    = L"SFMUAM.IFO";
static const WCHAR      c_szSrcIFOFile5[]   = L"SFMUAM5.IFO";
static const WCHAR      c_szSrcTXTFile[]    = L"SFMUAM.TXT";
static const WCHAR      c_szSrcRSCUamInst[] = L"UAMINST.RSC";
static const WCHAR      c_szSrcIFOUamInst[] = L"UAMINST.IFO";

// These will have UAM path prepended to them
static const WCHAR      c_szDstRSCFile[]    = L"\\%s\\MS UAM:Afp_Resource";
static const WCHAR      c_szDstRSCFile5[]   = L"\\%s\\MS UAM 5.0:Afp_Resource";
static const WCHAR      c_szDstIFOFile[]    = L"\\%s\\MS UAM:Afp_AfpInfo";
static const WCHAR      c_szDstIFOFile5[]   = L"\\%s\\MS UAM 5.0:Afp_AfpInfo";
static const WCHAR      c_szDstTXTFile[]    = L"\\ReadMe.UAM";
static const WCHAR      c_szDstRSCUamInst[] = L"\\%s:Afp_Resource";
static const WCHAR      c_szDstIFOUamInst[] = L"\\%s:Afp_AfpInfo";

// registry constants
static const WCHAR      c_szRegKeyVols[]    = L"System\\CurrentControlSet\\Services\\MacFile\\Parameters\\Volumes";
static const WCHAR      c_szRegKeyParams[]  = L"System\\CurrentControlSet\\Services\\MacFile\\Parameters";
static const WCHAR      c_szPath[]          = L"PATH=";
static const WCHAR      c_szRegValServerOptions[] = L"ServerOptions";


inline BOOL
IsValidHandle(HANDLE h)
{
    return (h && INVALID_HANDLE_VALUE != h);
}


//+---------------------------------------------------------------------------
//
//  Function:   FContainsUAMVolume
//
//  Purpose:    Determines whether the given drive letter contains a UAM
//              volume.
//
//  Arguments:
//      chDrive [in]    Drive letter to search.
//
//  Returns:    TRUE if drive contains a UAM volume, FALSE if not.
//
//  Author:     danielwe   22 May 1997
//
//  Notes:
//
BOOL FContainsUAMVolume(WCHAR chDrive)
{
    tstring         strUAMPath;
    WIN32_FIND_DATA w32Data;
    BOOL            frt = FALSE;
    HANDLE          hfind;

    try
    {
        strUAMPath = chDrive;
        strUAMPath += c_szColonBackslash;
        strUAMPath += SzLoadIds(IDS_OC_SFM_VOLNAME);
    }
    catch (bad_alloc)
    {
        return frt;
    }

    hfind = FindFirstFile(strUAMPath.c_str(), &w32Data);
    if (hfind != INVALID_HANDLE_VALUE)
    {
        // Found a volume!
        frt = TRUE;
        FindClose(hfind);
    }

    return frt;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrGetFirstPossibleUAMDrive
//
//  Purpose:    Obtains the first fixed or removable drive's drive letter
//              that has the NTFS file system installed on it and/or already
//              has a UAM volume on it.
//
//  Arguments:
//      pchDriveLetter [out]    Drive letter returned. If no drive is found,
//                              this is the NUL character.
//
//  Returns:    S_OK if successfull, Win32 error otherwise.
//
//  Author:     danielwe   5 May 1997
//
//  Notes:
//
HRESULT HrGetFirstPossibleUAMDrive(WCHAR *pchDriveLetter)
{
    HRESULT     hr = S_OK;
    WCHAR       mszDrives[1024];

    Assert(pchDriveLetter);

    *pchDriveLetter = 0;
    ZeroMemory ((PVOID)mszDrives, 1024*sizeof(WCHAR));

    if (GetLogicalDriveStrings(celems(mszDrives), mszDrives))
    {
        PCWSTR      pchDrive = NULL;
        WCHAR       szFileSystem[64];
        DWORD       dwType;

        pchDrive = mszDrives;
        while (*pchDrive)
        {
            // pchDrive is something like "C:\" at this point
            dwType = GetDriveType(pchDrive);

            if ((dwType == DRIVE_REMOVABLE) || (dwType == DRIVE_FIXED))
            {
                // Only look at removable or fixed drives.
                if (GetVolumeInformation(pchDrive, NULL, 0, NULL, NULL, NULL,
                                         szFileSystem, celems(szFileSystem)))
                {
                    if (!lstrcmpiW(szFileSystem, c_szNTFS))
                    {
                        // Drive letter gets first char of drive root path
                        if (!*pchDriveLetter)
                        {
                            // If no drive was found yet, this becomes the
                            // first
                            *pchDriveLetter = *pchDrive;
                        }

                        // Found NTFS drive. Continue looking, though
                        // in case there exists an NTFS drive that already has
                        // a UAM volume on it.
                        if (FContainsUAMVolume(*pchDrive))
                        {
                            // Override first drive letter and use this one
                            // and break because it already has a UAM volume
                            // on it.
                            *pchDriveLetter = *pchDrive;
                            break;
                        }
                    }
                }
            }
            pchDrive += lstrlenW(pchDrive) + 1;
        }
    }
    else
    {
        hr = HrFromLastWin32Error();
    }

    TraceError("HrGetFirstPossibleUAMDrive", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrDeleteOldFolders
//
//  Purpose:    Removes the old AppleShare Folder directory from an NT4 to
//              NT5 upgrade.
//
//  Arguments:
//      pszUamPath [in]  Path to UAM volume.
//
//  Returns:    S_OK if success, WIN32 error otherwise
//
//  Author:     danielwe   15 Dec 1998
//
//  Notes:
//
HRESULT HrDeleteOldFolders(PCWSTR pszUamPath)
{
    HRESULT     hr = S_OK;

    WCHAR   szOldFolder[MAX_PATH];

    if (wcslen(pszUamPath) > (MAX_PATH - wcslen(c_szBackslash) - wcslen(SzLoadIds(IDS_OC_SFM_APPLESHARE_FOLDER)) - 1))
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        return hr;
    }
    lstrcpyW(szOldFolder, pszUamPath);
    lstrcatW(szOldFolder, c_szBackslash);
    lstrcatW(szOldFolder, SzLoadIds(IDS_OC_SFM_APPLESHARE_FOLDER));

    hr = HrDeleteDirectory(szOldFolder, TRUE);
    if ((HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr) ||
        (HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND) == hr))
    {
        // ok if old directory was not there
        hr = S_OK;
    }

    TraceError("HrDeleteOldFolders", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrInstallSFM
//
//  Purpose:    Called when SFM is being installed. Handles all of the
//              additional installation for SFM beyond that of the INF file.
//
//  Arguments:
//      pnocd   [in]   Pointer to NETOC data.
//
//  Returns:    S_OK if successfull, Win32 error otherwise.
//
//  Author:     danielwe   5 May 1997
//
//  Notes:
//
HRESULT HrInstallSFM(PNETOCDATA pnocd)
{
    HRESULT     hr = S_OK;
    WCHAR       chNTFSDrive;

    hr = HrGetFirstPossibleUAMDrive(&chNTFSDrive);
    if (SUCCEEDED(hr))
    {
        if (chNTFSDrive != 0)
        {
            WCHAR   szUAMPath[MAX_PATH];

            szUAMPath[0] = chNTFSDrive;
            szUAMPath[1] = 0;
            lstrcatW(szUAMPath, c_szColonBackslash);
            lstrcatW(szUAMPath, SzLoadIds(IDS_OC_SFM_VOLNAME));

            // UAM Path is now something like "D:\Microsoft UAM Volume".

            hr = HrDeleteOldFolders(szUAMPath);
            if (SUCCEEDED(hr))
            {
                hr = HrSetupUAM(szUAMPath);
                if (SUCCEEDED(hr))
                {
                    WCHAR       szValue[MAX_PATH];

                    lstrcpyW(szValue, c_szPath);
                    lstrcatW(szValue, szUAMPath);

                    // Add the final multi_sz value to the registry
                    hr = HrRegAddStringToMultiSz(szValue,
                                                 HKEY_LOCAL_MACHINE,
                                                 c_szRegKeyVols,
                                                 SzLoadIds(IDS_OC_SFM_VOLNAME),
                                                 STRING_FLAG_ENSURE_AT_END,
                                                 0);
                }
            }
        }
        else
        {
            // No NTFS drives present.
            //$ REVIEW (danielwe) 6 May 1997: For now we will fail,
            // but how can we do this in the future?
            // Not the best error code, but hopefully it's close to
            // what we want.
            hr = HRESULT_FROM_WIN32(ERROR_UNRECOGNIZED_MEDIA);
        }
    }

    TraceError("HrInstallSFM", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRemoveSFM
//
//  Purpose:    Handles additional removal requirements for SFM component.
//
//      pnocd   [in]   Pointer to NETOC data.
//
//  Returns:    S_OK if successfull, Win32 error otherwise.
//
//  Author:     danielwe   5 May 1997
//
//  Notes:
//
HRESULT HrRemoveSFM(PNETOCDATA pnocd)
{
    HRESULT     hr = S_OK;

    static const WCHAR c_szRegKeyLsa[] = L"System\\CurrentControlSet\\Control\\Lsa";
    static const WCHAR c_szRegValueNotif[] = L"Notification Packages";
    static const WCHAR c_szRasSfm[] = L"RASSFM";

    hr = HrRegRemoveStringFromMultiSz(c_szRasSfm, HKEY_LOCAL_MACHINE,
                                      c_szRegKeyLsa, c_szRegValueNotif,
                                      STRING_FLAG_REMOVE_ALL);
    if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
    {
        // benign error
        hr = S_OK;
    }

    TraceError("HrRemoveSFM", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOcExtSFM
//
//  Purpose:    NetOC external message handler
//
//  Arguments:
//      pnocd  []
//      uMsg   []
//      wParam []
//      lParam []
//
//  Returns:
//
//  Author:     danielwe   17 Sep 1998
//
//  Notes:
//
HRESULT HrOcExtSFM(PNETOCDATA pnocd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT     hr = S_OK;

    Assert(pnocd);

    switch (uMsg)
    {
    case NETOCM_POST_INSTALL:
        hr = HrOcSfmOnInstall(pnocd);
        break;

    case NETOCM_QUERY_CHANGE_SEL_STATE:
        hr = HrOcSfmOnQueryChangeSelState(pnocd, static_cast<BOOL>(wParam));
        break;
    }

    TraceError("HrOcExtSFM", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOcSfmOnInstall
//
//  Purpose:    Called by optional components installer code to handle
//              additional installation requirements for SFM.
//
//  Arguments:
//      pnocd           [in]   Pointer to NETOC data.
//
//  Returns:    S_OK if successfull, Win32 error otherwise.
//
//  Author:     danielwe   5 May 1997
//
//  Notes:
//
HRESULT HrOcSfmOnInstall(PNETOCDATA pnocd)
{
    HRESULT     hr = S_OK;

    Assert(pnocd);

    if (pnocd->eit == IT_INSTALL || pnocd->eit == IT_UPGRADE)
    {
        hr = HrInstallSFM(pnocd);
        if (HRESULT_FROM_WIN32(ERROR_UNRECOGNIZED_MEDIA) == hr)
        {
            // This error code means no NTFS drives were present
            ReportErrorHr(hr, 
                          IDS_OC_SFM_NO_NTFS, 
                          g_ocmData.hwnd, 
                          SzLoadIds(IDS_OC_GENERIC_COMP));
            g_ocmData.fErrorReported = TRUE;
        }
        else
        {
            if (SUCCEEDED(hr) && pnocd->eit == IT_UPGRADE)
            {
                HKEY    hkeyParams;

                TraceTag(ttidNetOc, "Upgrading MacFile server options...");

                hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegKeyParams,
                                    KEY_ALL_ACCESS, &hkeyParams);
                if (S_OK == hr)
                {
                    DWORD       dwOptions;

                    hr = HrRegQueryDword(hkeyParams, c_szRegValServerOptions,
                                         &dwOptions);
                    if (S_OK == hr)
                    {
                        // 'or' in the UAM option
                        //
                        hr = HrRegSetDword(hkeyParams, c_szRegValServerOptions,
                                           dwOptions | AFP_SRVROPT_MICROSOFT_UAM);
                    }

                    RegCloseKey (hkeyParams);
                }
            }
        }
    }
    else
    {
        // Do not call HrRemoveSFM anymore.
        // It removes an entry in the notification packages list for LSA.
        // RASSFM entry should never be removed if LSA/SAM is to notify
        // SFM/IAS about changes in password/guest account changes etc.
        //hr = HrRemoveSFM(pnocd);
    }

    TraceError("HrOcSfmOnInstall", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOcSfmOnQueryChangeSelState
//
//  Purpose:    Handles the request of the OC framework of whether or not
//              the user should be allowed to install this component.
//
//  Arguments:
//      pnocd   [in]  NetOC Data
//      fShowUi [in]  TRUE if UI should be shown, FALSE if not
//
//  Returns:    S_OK if install is allowed, S_FALSE if not, Win32 error
//              otherwise
//
//  Author:     danielwe   6 Feb 1998
//
//  Notes:
//
HRESULT HrOcSfmOnQueryChangeSelState(PNETOCDATA pnocd, BOOL fShowUi)
{
    HRESULT     hr = S_OK;
    WCHAR       chNTFSDrive;

    Assert(pnocd);
    Assert(g_ocmData.hwnd);

    // See if an NTFS volume exists
    hr = HrGetFirstPossibleUAMDrive(&chNTFSDrive);
    if (SUCCEEDED(hr))
    {
        if (chNTFSDrive == 0)
        {
            if (fShowUi)
            {
                ReportErrorHr(hr, 
                              IDS_OC_SFM_NO_NTFS, 
                              g_ocmData.hwnd, 
                              SzLoadIds(IDS_OC_GENERIC_COMP));
            }

            hr = S_FALSE;
        }
    }

    TraceError("HrOcSfmOnQueryChangeSelState", (S_FALSE == hr) ? S_OK : hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrCreateDirectory
//
//  Purpose:    Creates the given directory. If the directory already exists,
//              no error is returned.
//
//  Arguments:
//      pszDir [in]  Path to directory to create.
//
//  Returns:    S_OK if success, Win32 error otherwise.
//
//  Author:     danielwe   5 May 1997
//
//  Notes:
//
HRESULT HrCreateDirectory(PCWSTR pszDir)
{
    HRESULT     hr = S_OK;

    if (!CreateDirectory(pszDir, NULL))
    {
        // Don't complain if directory already exists.
        if (GetLastError() != ERROR_ALREADY_EXISTS)
        {
            hr = HrFromLastWin32Error();
        }
    }

    TraceError("HrCreateDirectory" ,hr);
    return hr;
}

struct FOLDER
{
    UINT                idsFoldName;
    PCWSTR              aszSrcFiles[2];
    PCWSTR              aszDstFiles[2];
};

static const FOLDER     c_afold[] =
{
    {
        IDS_OC_SFM_FOLDNAMENT4,
        {
            c_szSrcRSCFile,
            c_szSrcIFOFile
        },
        {
            c_szDstRSCFile,
            c_szDstIFOFile,
        }
    },
    {
        IDS_OC_SFM_FOLDNAMENT5,
        {
            c_szSrcRSCFile5,
            c_szSrcIFOFile5
        },
        {
            c_szDstRSCFile5,
            c_szDstIFOFile5
        }
    }
};

static const INT c_cfold = celems(c_afold);

static const PCWSTR c_aszRootFilesSrc[] =
{
    c_szSrcTXTFile,
    c_szSrcIFOUamInst,
    c_szSrcRSCUamInst,
};

static const PCWSTR c_aszRootFilesDst[] =
{
    c_szDstTXTFile,
    c_szDstIFOUamInst,
    c_szDstRSCUamInst,
};

static const INT c_cszFilesRoot = celems(c_aszRootFilesDst);


//+---------------------------------------------------------------------------
//
//  Function:   HrCopyFileAsStream
//
//  Purpose:    Copies a default data stream file as a named stream file
//
//  Arguments:  Same as CopyFile
//
//  Returns:    Same as CopyFile
//
//  Author:     roelfc   30 January 2002
//
//  Notes:      This function replaces the normal CopyFile API by manually 
//              reading the default data stream and writing it as a named 
//              stream to the new file name.
//              This is because applications like eTrust can cause the normal 
//              CopyFile API to fail, since eTrust injects an additional stream 
//              into the file when the incremental scan option is used.
//              (See RAID# 493890: 
//               SFM: File Services for Mac doesn't install with etrust installed.)
//
BOOL HrCopyFileAsStream(PWSTR pszSourceFileName,
                        PWSTR pszDestFileName,
                        BOOL bFailIfExists)
{
    DWORD   dwSize;
    DWORD   dwResult = NO_ERROR;
    BOOL    fResult = FALSE;
    PBYTE   pBuffer = NULL;
    HANDLE  hSourceFile = NULL;
    HANDLE  hDestFile = NULL;
    

    TraceTag(ttidNetOc, "HrCopyFileAsStream: Copying \"%s\" to \"%s\"...",
             pszSourceFileName, pszDestFileName);

    // Open the unnamed stream source file first
    hSourceFile = CreateFile(pszSourceFileName, 
                             GENERIC_READ, 
                             FILE_SHARE_READ, 
                             NULL, 
                             OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL, 
                             NULL);
    
    if (INVALID_HANDLE_VALUE != hSourceFile)
    {

        dwSize = GetFileSize(hSourceFile, NULL);
        if (0xFFFFFFFF != dwSize) 
        {
            // Since we know we are working with small files, 
            // we can allocate the total file size.
            pBuffer = (PBYTE)LocalAlloc(LPTR,dwSize);
            if (NULL != pBuffer)
            {

                DWORD dwBytesRead;
                if (ReadFile(hSourceFile, pBuffer, dwSize, &dwBytesRead, NULL))
                {
                    // Sanity check
                    Assert(dwSize == dwBytesRead);

                    // Now try to open the named stream destination file
                    hDestFile = CreateFile(pszDestFileName, 
                                           GENERIC_WRITE, 
                                           0, 
                                           NULL, 
                                           bFailIfExists ? CREATE_NEW : CREATE_ALWAYS,
                                           FILE_ATTRIBUTE_NORMAL, 
                                           NULL);

                    if (INVALID_HANDLE_VALUE != hDestFile)
                    {
                        DWORD dwBytesWritten;
                        if (WriteFile(hDestFile, pBuffer, dwSize, &dwBytesWritten, NULL))
                        {
                            // Another sanity check
                            Assert(dwSize == dwBytesWritten);
                            fResult = TRUE;
                        }
                    }

                }

            }
        }
    }

    // Save the last error result code
    if (!fResult)
    {
        dwResult = GetLastError();
    }

    if (IsValidHandle(hSourceFile))
    {
        CloseHandle(hSourceFile);
    }

    if (IsValidHandle(hDestFile))
    {
        CloseHandle(hDestFile);
    }

    if (NULL != pBuffer)
    {
        LocalFree(pBuffer);
    }

    // Set the last result code again
    SetLastError(dwResult);

    TraceError("HrCopyFileAsStream", fResult ? S_OK : HrFromLastWin32Error());

    return fResult;

}


//+---------------------------------------------------------------------------
//
//  Function:   HrSetupUAM
//
//  Purpose:    Copies the UAM files to the proper UAM path.
//
//  Arguments:
//      pszPath [in]     Path to UAM volume.
//
//  Returns:    S_OK if successfull, Win32 error otherwise.
//
//  Author:     danielwe   5 May 1997
//
//  Notes:
//
HRESULT HrSetupUAM(PWSTR pszPath)
{
    HRESULT     hr = S_OK;
    WCHAR       szWinDir[MAX_PATH];
    INT         isz;

    // Create dir: "X:\Microsoft UAM Volume"
    hr = HrCreateDirectory(pszPath);
    if (SUCCEEDED(hr))
    {
        hr = HrSecureSfmDirectory(pszPath);
        if (SUCCEEDED(hr))
        {
            INT     ifold;

            for (ifold = 0; ifold < c_cfold; ifold++)
            {
                WCHAR   szNewDir[MAX_PATH];

                lstrcpyW(szNewDir, pszPath);
                lstrcatW(szNewDir, c_szBackslash);
                lstrcatW(szNewDir, SzLoadIds(c_afold[ifold].idsFoldName));
                lstrcatW(szNewDir, c_szBackslash);
                lstrcatW(szNewDir, SzLoadIds(IDS_OC_SFM_APPLESHARE_FOLDER));
                lstrcatW(szNewDir, c_szBackslash);

                // Create dir: "X:\Microsoft UAM Volume\<folder>\AppleShare Folder"
                hr = HrCreateDirectoryTree(szNewDir, NULL);
                if (SUCCEEDED(hr))
                {
                    if (GetSystemDirectory(szWinDir, celems(szWinDir)))
                    {
                        WCHAR   szSrcFile[MAX_PATH];
                        WCHAR   szDstFile[MAX_PATH];
                        WCHAR   szDstFilePath[MAX_PATH];
                        INT     isz;

                        for (isz = 0; isz < celems(c_afold[ifold].aszSrcFiles);
                             isz++)
                        {
                            lstrcpyW(szSrcFile, szWinDir);
                            lstrcatW(szSrcFile, c_szBackslash);
                            lstrcatW(szSrcFile, c_afold[ifold].aszSrcFiles[isz]);

                            lstrcpyW(szDstFile, pszPath);
                            lstrcatW(szDstFile, c_szBackslash);
                            lstrcatW(szDstFile, SzLoadIds(c_afold[ifold].idsFoldName));

                            wsprintf(szDstFilePath,
                                     c_afold[ifold].aszDstFiles[isz],
                                     SzLoadIds(IDS_OC_SFM_APPLESHARE_FOLDER));

                            lstrcatW(szDstFile, szDstFilePath);

                            TraceTag(ttidNetOc, "MacFile: Copying %S to %S...",
                                     szSrcFile, szDstFile);

                            if (!HrCopyFileAsStream(szSrcFile, szDstFile, FALSE))
                            {
                                hr = HrFromLastWin32Error();
                                goto err;
                            }
                        }
                    }
                    else
                    {
                        hr = HrFromLastWin32Error();
                    }
                }
            }
        }
    }

    // Copy files to the root
    //
    if (SUCCEEDED(hr))
    {
        for (isz = 0; isz < c_cszFilesRoot; isz++)
        {
            WCHAR   szSrcFile[MAX_PATH];
            WCHAR   szDstFile[MAX_PATH];

            lstrcpyW(szSrcFile, szWinDir);
            lstrcatW(szSrcFile, c_szBackslash);
            lstrcatW(szSrcFile, c_aszRootFilesSrc[isz]);

            if ((c_aszRootFilesDst[isz] == c_szDstIFOUamInst) ||
                (c_aszRootFilesDst[isz] == c_szDstRSCUamInst))
            {
                WCHAR   szTemp[MAX_PATH];

                lstrcpyW(szTemp, pszPath);
                lstrcatW(szTemp, c_aszRootFilesDst[isz]);
                wsprintfW(szDstFile, szTemp,
                         SzLoadIds(IDS_OC_SFM_UAM_INSTALLER));
            }
            else
            {
                lstrcpyW(szDstFile, pszPath);
                lstrcatW(szDstFile, c_aszRootFilesDst[isz]);
            }

            TraceTag(ttidNetOc, "MacFile: Copying %S to %S", szSrcFile,
                     szDstFile);

            if (!HrCopyFileAsStream(szSrcFile, szDstFile, FALSE))
            {
                hr = HrFromLastWin32Error();
                goto err;
            }
        }
    }

err:
    TraceError("HrSetupUAM", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netoc\ncias.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       N C I A S . H
//
//  Contents:   Installation support for IAS service
//
//  Notes:
//
//  Author:     tperraut    02/22/1999
//
//----------------------------------------------------------------------------

#ifndef _NCIAS_H_
#define _NCIAS_H_

#pragma once
#include "netoc.h"

HRESULT HrOcExtIAS(
                   PNETOCDATA pnocd, 
                   UINT uMsg,
                   WPARAM wParam, 
                   LPARAM lParam
                  );

HRESULT HrOcIASUpgrade(const PNETOCDATA pnocd);

HRESULT HrOcIASDelete(const PNETOCDATA pnocd);

HRESULT HrOcIASInstallCleanRegistry(const PNETOCDATA pnocd);

HRESULT HrOcIASBackupMdb(const PNETOCDATA pnocd);

HRESULT HrOcIASPreInf(const PNETOCDATA pnocd);

HRESULT HrOcIASPostInstall(const PNETOCDATA pnocd);

HRESULT HrOcIASRetrieveMDBNames(
                                    tstring* pstrOriginalName, 
                                    tstring* pstrBackupName
                               );

#endif // _NCIAS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netoc\netoc.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N E T O C . C P P
//
//  Contents:   Functions for handling installation and removal of optional
//              networking components.
//
//  Notes:
//
//  Author:     danielwe   28 Apr 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "lancmn.h"
#include "ncatlui.h"
#include "nccm.h"
#include "ncdhcps.h"
#include "ncias.h"
#include "ncmisc.h"
#include "ncmsz.h"
#include "ncnetcfg.h"
#include "ncnetcon.h"
#include "ncoc.h"
#include "ncperms.h"
#include "ncreg.h"
#include "ncsetup.h"
#include "ncsfm.h"
#include "ncstring.h"
#include "ncsvc.h"
#include "ncxbase.h"
#include "netcfgn.h"
#include "netcon.h"
#include "netoc.h"
#include "netocp.h"
#include "netocx.h"
#include "resource.h"
#include "netocmsg.h"


//
// External component install functions.
// Add an entry in this table for each component that requires additional,
// non-common installation support.
//
// NOTE: The component name should match the section name in the INF.
//
#pragma BEGIN_CONST_SECTION
static const OCEXTPROCS c_aocepMap[] =
{
    { L"MacSrv",       HrOcExtSFM          },
    { L"DHCPServer",   HrOcExtDHCPServer   },
    { L"NetCMAK",      HrOcExtCMAK         },
    { L"NetCPS",       HrOcExtCPS          },
    { L"WINS",         HrOcExtWINS         },
    { L"DNS",          HrOcExtDNS          },
    { L"SNMP",         HrOcExtSNMP         },
    { L"IAS",          HrOcExtIAS          },
};
#pragma END_CONST_SECTION

static const INT c_cocepMap = celems(c_aocepMap);

// generic strings
static const WCHAR  c_szUninstall[]         = L"Uninstall";
static const WCHAR  c_szServices[]          = L"StartServices";
static const WCHAR  c_szDependOnComp[]      = L"DependOnComponents";
static const WCHAR  c_szVersionSection[]    = L"Version";
static const WCHAR  c_szProvider[]          = L"Provider";
static const WCHAR  c_szDefManu[]           = L"Unknown";
static const WCHAR  c_szInfRef[]            = L"SubCompInf";
static const WCHAR  c_szDesc[]              = L"OptionDesc";
static const WCHAR  c_szNoDepends[]         = L"NoDepends";

// static-IP verification
static const WCHAR  c_szTcpipInterfacesPath[]   = 

L"System\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Interfaces";
static const WCHAR  c_szEnableDHCP[]            = L"EnableDHCP";

extern const WCHAR  c_szOcMainSection[];

static const DWORD  c_dwUpgradeMask         = SETUPOP_WIN31UPGRADE |
                                              SETUPOP_WIN95UPGRADE |
                                              SETUPOP_NTUPGRADE;

OCM_DATA g_ocmData;

typedef list<NETOCDATA*> ListOcData;
ListOcData g_listOcData;

//+---------------------------------------------------------------------------
//
//  Function:   PnocdFindComponent
//
//  Purpose:    Looks for the given component name in the list of known
//              components.
//
//  Arguments:
//      pszComponent [in]   Name of component to lookup.
//
//  Returns:    Pointer to component's data.
//
//  Author:     danielwe   23 Feb 1998
//
//  Notes:
//
NETOCDATA *PnocdFindComponent(PCWSTR pszComponent)
{
    ListOcData::iterator    iterList;

    for (iterList = g_listOcData.begin();
         iterList != g_listOcData.end();
         iterList++)
    {
        NETOCDATA * pnocd;

        pnocd = *iterList;
        if (!lstrcmpiW(pnocd->pszComponentId, pszComponent))
        {
            return pnocd;
        }
    }

    return NULL;
}

//+---------------------------------------------------------------------------
//
//  Function:   DeleteAllComponents
//
//  Purpose:    Removes all components from our list and frees all associated
//              data.
//
//  Arguments:
//      (none)
//
//  Returns:    Nothing.
//
//  Author:     danielwe   23 Feb 1998
//
//  Notes:
//
VOID DeleteAllComponents()
{
    ListOcData::iterator    iterList;

    for (iterList = g_listOcData.begin();
         iterList != g_listOcData.end();
         iterList++)
    {
        NETOCDATA * pnocd;

        pnocd = (*iterList);

        if (pnocd->hinfFile)
        {
            SetupCloseInfFile(pnocd->hinfFile);
        }

        delete pnocd;
    }

    g_listOcData.erase(g_listOcData.begin(), g_listOcData.end());
}

//+---------------------------------------------------------------------------
//
//  Function:   AddComponent
//
//  Purpose:    Adds a component to our list.
//
//  Arguments:
//      pszComponent [in]   Name of component to add.
//      pnocd        [in]   Data to associate with component.
//
//  Returns:    S_OK if success, failure HRESULT otherwise
//
//  Author:     danielwe   23 Feb 1998
//
//  Notes:
//
HRESULT AddComponent(PCWSTR pszComponent, NETOCDATA *pnocd)
{
    HRESULT     hr = S_OK;

    Assert(pszComponent);
    Assert(pnocd);

    pnocd->pszComponentId = SzDupSz(pszComponent);
    if (pnocd->pszComponentId)
    {
        try
        {
            g_listOcData.push_back(pnocd);
        }
        catch (bad_alloc)
        {
            MemFree(pnocd->pszComponentId);
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    TraceError("AddComponent", hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   ParseAdditionalArguments
//
//  Purpose:    Parse additional commands following the /z option
//              of sysocmgr.
//
//  Arguments:  Nothing.
//
//  Returns:    Nothing.
//
//  Author:     roelfc   19 Jul 2001
//
//  Notes:
//
VOID ParseAdditionalArguments()
{

    LPTSTR lpCmdLine = GetCommandLine();
    TCHAR szTokens[] = TEXT("-/");
    LPCTSTR lpszToken = NULL;


    if (lpCmdLine)
    {
        // Search for additional parameters
        lpszToken = wcspbrk(lpCmdLine, szTokens);
        while (lpszToken != NULL) 
        {   
            // Check the correct option
            switch (lpszToken[1])
            {
                case TEXT('z'):
                case TEXT('Z'):
                    if ((lpszToken[2] == TEXT(':')) &&
                        (_wcsnicmp(&lpszToken[3], 
                                   SHOW_UNATTENDED_MESSAGES, 
                                   wcslen(SHOW_UNATTENDED_MESSAGES)) == 0) &&
                        (!iswgraph(lpszToken[3 + wcslen(SHOW_UNATTENDED_MESSAGES)])))
                    {
                        // Set the show unattended messages flag
                        g_ocmData.fShowUnattendedMessages = TRUE;
                        TraceTag(ttidNetOc, "Flag set to show messages in unattended mode");
                    }
                    break;

                default:
                    break;
            }

            // Skip the last token found to find the next one
            lpszToken = wcspbrk(&lpszToken[1], szTokens);
        }
    }

} 


//+---------------------------------------------------------------------------
//
//  Function:   RegisterNetEventSource
//
//  Purpose:    Add netoc source name to the registry for
//              event reporting.
//
//  Arguments:  Nothing.
//
//  Returns:    TRUE if success, FALSE otherwise
//
//  Author:     roelfc   21 May 2001
//
//  Notes:
//
BOOL RegisterNetEventSource()
{
    HKEY hk; 
    BOOL fSuccess = TRUE;
 
    
    // Check if the key already exists
    if (ERROR_SUCCESS != RegOpenKey(HKEY_LOCAL_MACHINE, 
                                    NETOC_REGISTRY_NAME NETOC_SERVICE_NAME,
                                    &hk)) 
    {
        DWORD dwData; 
        WCHAR szBuf[80];

        // Create the key as a subkey under the Application 
        // key in the EventLog registry key. 
        if (RegCreateKey(HKEY_LOCAL_MACHINE, 
                         NETOC_REGISTRY_NAME NETOC_SERVICE_NAME,
                         &hk)) 
        {
            TraceTag(ttidNetOc, "RegisterEventSource: Could not create the registry key.");
            return FALSE;
        }
 
        // Set the name of the message file. 
        lstrcpyW(szBuf, NETOC_DLL_NAME); 
 
        // Add the name to the EventMessageFile subkey. 
        if (RegSetValueEx(hk,                       // subkey handle 
                          L"EventMessageFile",      // value name 
                          0,                        // must be zero 
                          REG_EXPAND_SZ,            // value type 
                          (LPBYTE) szBuf,           // pointer to value data 
                          (2 * lstrlenW(szBuf)) + 1))   // length of value data 
        {
            TraceTag(ttidNetOc, "RegisterEventSource: Could not set the event message file.");
            fSuccess = FALSE;
            goto RegisterExit;
        }
 
        // Set the supported event types in the TypesSupported subkey. 
        dwData = EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE | 
                 EVENTLOG_INFORMATION_TYPE; 
 
        if (RegSetValueEx(hk,                // subkey handle 
                          L"TypesSupported", // value name 
                          0,                 // must be zero 
                          REG_DWORD,         // value type 
                          (LPBYTE) &dwData,  // pointer to value data 
                          sizeof(DWORD)))    // length of value data 
        {
            TraceTag(ttidNetOc, "RegisterEventSource: Could not set the supported types.");
            fSuccess = FALSE;
        }

    }

RegisterExit:
    RegCloseKey(hk); 

    // Return result
    return fSuccess;

} 


//+---------------------------------------------------------------------------
//
//  Function:   NetOcSetupProcHelper
//
//  Purpose:    Main entry point for optional component installs
//
//  Arguments:
//      pvComponentId    [in]       Component Id (string)
//      pvSubcomponentId [in]       Sub component Id (string)
//      uFunction        [in]       Function being performed
//      uParam1          [in]       First param to function
//      pvParam2         [in, out]  Second param to function
//
//  Returns:    Win32 error if failure
//
//  Author:     danielwe   17 Dec 1997
//
//  Notes:
//
DWORD NetOcSetupProcHelper(LPCVOID pvComponentId, LPCVOID pvSubcomponentId,
                           UINT uFunction, UINT uParam1, LPVOID pvParam2)
{
    TraceFileFunc(ttidNetOc);
    HRESULT     hr = S_OK;
    UINT        uiFlags;

    switch (uFunction)
    {
    case OC_PREINITIALIZE:
        return HrOnPreInitializeComponent(uParam1);

    case OC_QUERY_CHANGE_SEL_STATE:

        TraceTag(ttidNetOc, "OC_QUERY_CHANGE_SEL_STATE: %S, %ld, 0x%08X.",
                 pvSubcomponentId ? pvSubcomponentId : L"null", uParam1,
                 pvParam2);

        if (FHasPermission(NCPERM_AddRemoveComponents))
        {
            uiFlags = PtrToUlong(pvParam2);
            hr = HrOnQueryChangeSelState(reinterpret_cast<PCWSTR>(pvSubcomponentId),
                                         uParam1, uiFlags);

            if (S_OK == hr)
            {
                return TRUE;
            }

        }
        else
        {
            ReportErrorHr(hr, 
                          IDS_OC_NO_PERMS, 
                          g_ocmData.hwnd, 
                          SzLoadIds(IDS_OC_GENERIC_COMP));
        }
        return FALSE;

    case OC_QUERY_SKIP_PAGE:
        TraceTag(ttidNetOc, "OC_QUERY_SKIP_PAGE: %ld", uParam1);
        return FOnQuerySkipPage(static_cast<OcManagerPage>(uParam1));

    case OC_WIZARD_CREATED:
        TraceTag(ttidNetOc, "OC_WIZARD_CREATED: 0x%08X", pvParam2);
        OnWizardCreated(reinterpret_cast<HWND>(pvParam2));
        break;

    case OC_INIT_COMPONENT:
        TraceTag(ttidNetOc, "OC_INIT_COMPONENT: %S", pvSubcomponentId ?
                 pvSubcomponentId : L"null");
        hr = HrOnInitComponent(reinterpret_cast<PSETUP_INIT_COMPONENT>(pvParam2));
        break;

    case OC_ABOUT_TO_COMMIT_QUEUE:
        TraceTag(ttidNetOc, "OC_ABOUT_TO_COMMIT_QUEUE: %S", pvSubcomponentId ?
                 pvSubcomponentId : L"null");
        hr = HrOnPreCommitFileQueue(reinterpret_cast<PCWSTR>(pvSubcomponentId));
        break;

    case OC_CALC_DISK_SPACE:
        // Ignore return value for now. This is not fatal anyway.
        (VOID) HrOnCalcDiskSpace(reinterpret_cast<PCWSTR>(pvSubcomponentId),
                               uParam1, reinterpret_cast<HDSKSPC>(pvParam2));
        break;

    case OC_QUERY_STATE:
        return DwOnQueryState(reinterpret_cast<PCWSTR>(pvSubcomponentId),
                              uParam1 == OCSELSTATETYPE_FINAL);

    case OC_QUEUE_FILE_OPS:
        TraceTag(ttidNetOc, "OC_QUEUE_FILE_OPS: %S, 0x%08X", pvSubcomponentId ?
                 pvSubcomponentId : L"null",
                 pvParam2);
        hr = HrOnQueueFileOps(reinterpret_cast<PCWSTR>(pvSubcomponentId),
                              reinterpret_cast<HSPFILEQ>(pvParam2));
        break;

    case OC_COMPLETE_INSTALLATION:
        TraceTag(ttidNetOc, "OC_COMPLETE_INSTALLATION: %S, %S", pvComponentId ?
                 pvComponentId : L"null",
                 pvSubcomponentId ? pvSubcomponentId : L"null");
        hr = HrOnCompleteInstallation(reinterpret_cast<PCWSTR>(pvComponentId),
                                      reinterpret_cast<PCWSTR>(pvSubcomponentId));
        break;

    case OC_QUERY_STEP_COUNT:
        return DwOnQueryStepCount(reinterpret_cast<PCWSTR>(pvSubcomponentId));

    case OC_CLEANUP:
        OnCleanup();
        break;

    default:
        break;
    }

    if (g_ocmData.sic.HelperRoutines.SetReboot && (NETCFG_S_REBOOT == hr))
    {
        // Request a reboot. Note we don't return the warning as the OCM call
        // below handles it. Fall through and return NO_ERROR.
        //
        g_ocmData.sic.HelperRoutines.SetReboot(
                    g_ocmData.sic.HelperRoutines.OcManagerContext,
                    FALSE);
    }
    else if (FAILED(hr))
    {
        if (!g_ocmData.fErrorReported)
        {
            PCWSTR pszSubComponentId = reinterpret_cast<PCWSTR>(pvSubcomponentId);

            TraceError("NetOcSetupProcHelper", hr);

            if (pszSubComponentId)
            {
                NETOCDATA * pnocd;

                pnocd = PnocdFindComponent(pszSubComponentId);

                if (HRESULT_FROM_WIN32(ERROR_CANCELLED) != hr)
                {
                    ReportErrorHr(hr, 
                                  UiOcErrorFromHr(hr), 
                                  g_ocmData.hwnd, 
                                  (pnocd)?(pnocd->strDesc.c_str()):
                                           (SzLoadIds(IDS_OC_GENERIC_COMP)));
                }
            }
        }

        TraceError("NetOcSetupProcHelper", hr);
        return DwWin32ErrorFromHr(hr);
    }

    return NO_ERROR;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrOnPreInitializeComponent
//
//  Purpose:    Handles the OC_PREINITIALIZE function message.
//
//  Arguments:
//      uModesSupported   [in]  Modes supported by OCM (see OCManager spec)
//
//  Returns:    Flag indicating mode supported by netoc
//
//  Author:     roelfc   19 Jul 2001
//
//  Notes:
//
DWORD HrOnPreInitializeComponent (UINT uModesSupported)
{

    RegisterNetEventSource();

    // Parse the additional command line arguments specific for netoc
    ParseAdditionalArguments();

    return OCFLAG_UNICODE;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrOnInitComponent
//
//  Purpose:    Handles the OC_INIT_COMPONENT function message.
//
//  Arguments:
//      psic              [in]  Setup data. (see OCManager spec)
//
//  Returns:    S_OK if success, Win32 error otherwise
//
//  Author:     danielwe   23 Feb 1998
//
//  Notes:
//
HRESULT HrOnInitComponent (PSETUP_INIT_COMPONENT psic)
{
    HRESULT     hr = S_OK;

    if (OCMANAGER_VERSION <= psic->OCManagerVersion)
    {
        psic->ComponentVersion = OCMANAGER_VERSION;
        CopyMemory(&g_ocmData.sic, (LPVOID)psic, sizeof(SETUP_INIT_COMPONENT));
    }
    else
    {
        hr = HRESULT_FROM_WIN32(ERROR_CALL_NOT_IMPLEMENTED);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   OnWizardCreated
//
//  Purpose:    Handles the OC_WIZARD_CREATED function message.
//
//  Arguments:
//      hwnd [in]   HWND of wizard (may not be NULL)
//
//  Returns:    Nothing.
//
//  Author:     danielwe   23 Feb 1998
//
//  Notes:
//
VOID OnWizardCreated(HWND hwnd)
{
    g_ocmData.hwnd = hwnd;
    AssertSz(g_ocmData.hwnd, "Parent HWND is NULL!");
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOnCalcDiskSpace
//
//  Purpose:    Handles the OC_CALC_DISK_SPACE function message.
//
//  Arguments:
//      pszSubComponentId [in]  Name of component.
//      fAdd              [in]  TRUE if disk space should be added to total
//                              FALSE if removed from total.
//      hdskspc           [in]  Handle to diskspace struct.
//
//  Returns:    S_OK if success, Win32 error otherwise
//
//  Author:     danielwe   23 Feb 1998
//
//  Notes:
//
HRESULT HrOnCalcDiskSpace(PCWSTR pszSubComponentId, BOOL fAdd,
                          HDSKSPC hdskspc)
{
    HRESULT     hr = S_OK;
    DWORD       dwErr;
    NETOCDATA * pnocd;

    pnocd = PnocdFindComponent(pszSubComponentId);
    if (!pnocd)
    {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    }

    if (SUCCEEDED(hr))
    {
        TraceTag(ttidNetOc, "Calculating disk space for %S...",
                 pszSubComponentId);

        hr = HrEnsureInfFileIsOpen(pszSubComponentId, *pnocd);
        if (SUCCEEDED(hr))
        {
            if (fAdd)
            {
                dwErr = SetupAddInstallSectionToDiskSpaceList(hdskspc,
                                                              pnocd->hinfFile,
                                                              NULL,
                                                              pszSubComponentId,
                                                              0, 0);
            }
            else
            {
                dwErr = SetupRemoveInstallSectionFromDiskSpaceList(hdskspc,
                                                                   pnocd->hinfFile,
                                                                   NULL,
                                                                   pszSubComponentId,
                                                                   0, 0);
            }

            if (!dwErr)
            {
                hr = HrFromLastWin32Error();
            }
        }
    }

    TraceError("HrOnCalcDiskSpace", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   DwOnQueryState
//
//  Purpose:    Handles the OC_QUERY_STATE function message.
//
//  Arguments:
//      pszSubComponentId [in]  Name of component.
//      fFinal            [in]  TRUE if this is the final state query, FALSE
//                              if not
//
//  Returns:    SubcompOn - component should be checked "on"
//              SubcompUseOcManagerDefault - use whatever OCManage thinks is
//              the default
//
//  Author:     danielwe   23 Feb 1998
//
//  Notes:
//
DWORD DwOnQueryState(PCWSTR pszSubComponentId, BOOL fFinal)
{
    HRESULT     hr = S_OK;

    if (pszSubComponentId)
    {
        NETOCDATA *     pnocd;
        EINSTALL_TYPE   eit;

        pnocd = PnocdFindComponent(pszSubComponentId);
        if (!pnocd)
        {
            pnocd = new NETOCDATA;
            if(pnocd) 
            {
                hr = AddComponent(pszSubComponentId, pnocd);
                if (FAILED(hr))
                {
                    TraceTag(ttidNetOc, "OC_QUERY_STATE: Failed to add component %s.",
                             pszSubComponentId);
                    delete pnocd;
                    pnocd = NULL;
                }
            }
        }

        if(pnocd) 
        {
            if (fFinal)
            {
                if (pnocd->fFailedToInstall)
                {
                    TraceTag(ttidNetOc, "OC_QUERY_STATE: %S failed to install so "
                             "we are turning it off", pszSubComponentId);
                    return SubcompOff;
                }
            }
            else
            {
                hr = HrGetInstallType(pszSubComponentId, *pnocd, &eit);
                if (SUCCEEDED(hr))
                {
                    pnocd->eit = eit;

                    if ((eit == IT_INSTALL) || (eit == IT_UPGRADE))
                    {
                        TraceTag(ttidNetOc, "OC_QUERY_STATE: %S is ON",
                                 pszSubComponentId);
                        return SubcompOn;
                    }
                    else if (eit == IT_REMOVE)
                    {
                        TraceTag(ttidNetOc, "OC_QUERY_STATE: %S is OFF",
                                 pszSubComponentId);
                        return SubcompOff;
                    }
                }
            }
        }
    }

    TraceTag(ttidNetOc, "OC_QUERY_STATE: %S is using default",
             pszSubComponentId);

    return SubcompUseOcManagerDefault;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrEnsureInfFileIsOpen
//
//  Purpose:    Ensures that the INF file for the given component is open.
//
//  Arguments:
//      pszSubComponentId [in]      Name of component.
//      nocd              [in, ref] Data associated with component.
//
//  Returns:    S_OK if success, Win32 error otherwise
//
//  Author:     danielwe   23 Feb 1998
//
//  Notes:
//
HRESULT HrEnsureInfFileIsOpen(PCWSTR pszSubComponentId, NETOCDATA &nocd)
{
    HRESULT     hr = S_OK;
    tstring     strInf;

    if (!nocd.hinfFile)
    {
        // Get component INF file name
        hr = HrSetupGetFirstString(g_ocmData.sic.ComponentInfHandle,
                                   pszSubComponentId, c_szInfRef,
                                   &strInf);
        if (SUCCEEDED(hr))
        {
            TraceTag(ttidNetOc, "Opening INF file %S...", strInf.c_str());

            hr = HrSetupOpenInfFile(strInf.c_str(), NULL,
                                    INF_STYLE_WIN4, NULL, &nocd.hinfFile);
            if (SUCCEEDED(hr))
            {
                // Append in the layout.inf file
                (VOID) SetupOpenAppendInfFile(NULL, nocd.hinfFile, NULL);
            }
        }

        // This is a good time to cache away the component description as
        // well.
        (VOID) HrSetupGetFirstString(g_ocmData.sic.ComponentInfHandle,
                                     pszSubComponentId, c_szDesc,
                                     &nocd.strDesc);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOnPreCommitFileQueue
//
//  Purpose:    Handles the OC_ABOUT_TO_COMMIT_QUEUE function message.
//
//  Arguments:
//      pszSubComponentId [in]  Name of component.
//
//  Returns:    S_OK if success, Win32 error otherwise
//
//  Author:     danielwe   9 Dec 1998
//
//  Notes:
//
HRESULT HrOnPreCommitFileQueue(PCWSTR pszSubComponentId)
{
    HRESULT     hr = S_OK;
    NETOCDATA * pnocd;

    if (pszSubComponentId)
    {
        EINSTALL_TYPE   eit;

        pnocd = PnocdFindComponent(pszSubComponentId);
        if (!pnocd)
        {
            hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        }

        if (SUCCEEDED(hr))
        {
            hr = HrGetInstallType(pszSubComponentId, *pnocd, &eit);
            if (SUCCEEDED(hr))
            {
                pnocd->eit = eit;

                if (pnocd->eit == IT_REMOVE)
                {
                    // Always use main install section
                    hr = HrStartOrStopAnyServices(pnocd->hinfFile,
                                                  pszSubComponentId, FALSE);
                    if (FAILED(hr))
                    {
                      // Don't report errors for non-existent services
                        if (HRESULT_FROM_WIN32(ERROR_SERVICE_DOES_NOT_EXIST) != hr)
                        {
                          // Don't bail removal if services couldn't be stopped.
                            if (!g_ocmData.fErrorReported)
                            {
                              // Report an error and continue the removal.
                              ReportErrorHr(hr,
                                            IDS_OC_STOP_SERVICE_FAILURE,
                                            g_ocmData.hwnd,
                                            pnocd->strDesc.c_str());
                            }
                        }

                      hr = S_OK;
                    }

                    // We need to unregister DLLs before they get commited to the
                    // queue, otherwise we try to unregister a non-existent DLL.
                    if (SUCCEEDED(hr))
                    {
                        tstring     strUninstall;

                        // Get the name of the uninstall section first
                        hr = HrSetupGetFirstString(pnocd->hinfFile,
                                                   pszSubComponentId,
                                                   c_szUninstall, &strUninstall);
                        if (SUCCEEDED(hr))
                        {
                            PCWSTR   pszInstallSection;

                            pszInstallSection = strUninstall.c_str();

                            // Run the INF but only call the unregister function
                            //
                            hr = HrSetupInstallFromInfSection(g_ocmData.hwnd,
                                                              pnocd->hinfFile,
                                                              pszInstallSection,
                                                              SPINST_UNREGSVR,
                                                              NULL, NULL, 0, NULL,
                                                              NULL, NULL, NULL);
                        }
                        else
                        {
                            // Uninstall may not be present
                            hr = S_OK;
                        }
                    }
                }
            }
        }
    }

    TraceError("HrOnPreCommitFileQueue", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOnQueueFileOps
//
//  Purpose:    Handles the OC_QUEUE_FILE_OPS function message.
//
//  Arguments:
//      pszSubComponentId [in]  Name of component.
//      hfq               [in]  Handle to file queue struct.
//
//  Returns:    S_OK if success, Win32 error otherwise
//
//  Author:     danielwe   23 Feb 1998
//
//  Notes:
//
HRESULT HrOnQueueFileOps(PCWSTR pszSubComponentId, HSPFILEQ hfq)
{
    HRESULT     hr = S_OK;
    NETOCDATA * pnocd;

    if (pszSubComponentId)
    {
        EINSTALL_TYPE   eit;

        pnocd = PnocdFindComponent(pszSubComponentId);
        if (!pnocd)
        {
            hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        }

        if (SUCCEEDED(hr))
        {
            hr = HrGetInstallType(pszSubComponentId, *pnocd, &eit);
            if (SUCCEEDED(hr))
            {
                pnocd->eit = eit;

                if ((pnocd->eit == IT_INSTALL) || (pnocd->eit == IT_UPGRADE) ||
                    (pnocd->eit == IT_REMOVE))
                {
                    BOOL    fSuccess = TRUE;
                    PCWSTR pszInstallSection;
                    tstring strUninstall;

                    AssertSz(hfq, "No file queue?");

                    hr = HrEnsureInfFileIsOpen(pszSubComponentId, *pnocd);
                    if (SUCCEEDED(hr))
                    {
                        if (pnocd->eit == IT_REMOVE)
                        {
                            // Get the name of the uninstall section first
                            hr = HrSetupGetFirstString(pnocd->hinfFile,
                                                       pszSubComponentId,
                                                       c_szUninstall,
                                                       &strUninstall);
                            if (SUCCEEDED(hr))
                            {
                                pszInstallSection = strUninstall.c_str();
                            }
                            else
                            {
                                if (hr == HRESULT_FROM_SETUPAPI(ERROR_LINE_NOT_FOUND))
                                {
                                    // Uninstall section is not required.
                                    hr = S_OK;
                                    fSuccess = FALSE;
                                }
                            }
                        }
                        else
                        {
                            pszInstallSection = pszSubComponentId;
                        }
                    }

                    if (SUCCEEDED(hr) && fSuccess)
                    {
                        hr = HrCallExternalProc(pnocd, NETOCM_QUEUE_FILES,
                                                (WPARAM)hfq, 0);
                    }

                    if (SUCCEEDED(hr))
                    {
                        TraceTag(ttidNetOc, "Queueing files for %S...",
                                 pszSubComponentId);

                        hr = HrSetupInstallFilesFromInfSection(pnocd->hinfFile,
                                                               NULL, hfq,
                                                               pszInstallSection,
                                                               NULL, 0);
                    }
                }
            }
        }
    }

    TraceError("HrOnQueueFileOps", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOnCompleteInstallation
//
//  Purpose:    Handles the OC_COMPLETE_INSTALLATION function message.
//
//  Arguments:
//      pszComponentId    [in]  Top-level component name (will always be
//                              "NetOC" or NULL.
//      pszSubComponentId [in]  Name of component.
//
//  Returns:    S_OK if success, Win32 error otherwise
//
//  Author:     danielwe   23 Feb 1998
//              omiller    28 March 2000 Added code to move the progress
//                                       bar one tick for every component 
//                                       installed or removed.
//
//  Notes:
//
HRESULT HrOnCompleteInstallation(PCWSTR pszComponentId,
                                 PCWSTR pszSubComponentId)
{
    HRESULT     hr = S_OK;

    // Make sure they're different. If not, it's the top level item and
    // we don't want to do anything
    if (pszSubComponentId && lstrcmpiW(pszSubComponentId, pszComponentId))
    {
        NETOCDATA * pnocd;

        pnocd = PnocdFindComponent(pszSubComponentId);
        if (!pnocd)
        {
            hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        }

        if (SUCCEEDED(hr))
        {

            pnocd->fCleanup = FALSE;

            if (pnocd->eit == IT_INSTALL || pnocd->eit == IT_REMOVE ||
                pnocd->eit == IT_UPGRADE)
            {
                pnocd->pszSection = pszSubComponentId;

                // Get component description

    #if DBG
                if (pnocd->eit == IT_INSTALL)
                {
                    TraceTag(ttidNetOc, "Installing network OC %S...",
                             pszSubComponentId);
                }
                else if (pnocd->eit == IT_UPGRADE)
                {
                    TraceTag(ttidNetOc, "Upgrading network OC %S...",
                             pszSubComponentId);
                }
                else if (pnocd->eit == IT_REMOVE)
                {
                    TraceTag(ttidNetOc, "Removing network OC %S...",
                             pszSubComponentId);
                }
    #endif

                hr = HrDoOCInstallOrUninstall(pnocd);
                if (FAILED(hr) && pnocd->eit == IT_INSTALL)
                {
                    // A failure during install means we have to clean up by doing
                    // an uninstall now. Report the appropriate error and do the
                    // remove. Note - Don't report the error if it's ERROR_CANCELLED,
                    // because they KNOW that they cancelled, and it's not really
                    // an error.
                    //
                    if (HRESULT_FROM_WIN32(ERROR_CANCELLED) != hr)
                    {
                        // Don't report the error a second time if the component
                        // has already put up error UI (and set this flag)
                        //
                        if (!g_ocmData.fErrorReported)
                        {
                            ReportErrorHr(hr, 
                                          UiOcErrorFromHr(hr),
                                          g_ocmData.hwnd,
                                          pnocd->strDesc.c_str());
                        }
                    }
                    g_ocmData.fErrorReported = TRUE;


                    // Now we're removing
                    pnocd->eit = IT_REMOVE;
                    pnocd->fCleanup = TRUE;
                    pnocd->fFailedToInstall = TRUE;

                    // eat the error. Haven't we troubled them enough? :(
                    (VOID) HrDoOCInstallOrUninstall(pnocd);
                }
                else
                {
                    // Every time a component is installed,upgraded or removed, the progress
                    // bar is advanced by one tick. For every component that is being 
                    // installed/removed/upgraded the OC manager asked netoc for how many ticks
                    // that component counts (OC_QUERY_STEP_COUNT). From this information
                    // the OC manger knows the relationship between tick and progress bar 
                    // advancement.
                    g_ocmData.sic.HelperRoutines.TickGauge(g_ocmData.sic.HelperRoutines.OcManagerContext);
                }
            }
        }
    }


    TraceError("HrOnCompleteInstallation", hr);
    return hr;
}



//+---------------------------------------------------------------------------
//
//  Function:   DwOnQueryStepCount
//
//  Purpose:    Handles the OC_QUERY_STEP_COUNT message. 
//              The OC manager is asking us how many ticks a component is worth. 
//              The number of ticks determines the distance the progress bar gets 
//              moved. For netoc all components installed/removed are one tick and
//              all components that are unchanged are 0 ticks.
//
//  Arguments:  
//      pszSubComponentId [in]  Name of component.
//
//  Returns:    Number of ticks for progress bar to move
//
//  Author:     omiller    28 March 2000
//
//
DWORD DwOnQueryStepCount(PCWSTR pvSubcomponentId)
{
    NETOCDATA * pnocd;
    
    // Get the component
    pnocd = PnocdFindComponent(reinterpret_cast<PCWSTR>(pvSubcomponentId));
    if( pnocd )
    {
        // Check if the status of the component has changed.
        if (pnocd->eit == IT_INSTALL || pnocd->eit == IT_REMOVE ||
            pnocd->eit == IT_UPGRADE)
        {
            // Status of component has changed. For this component the OC manager
            // will move the status bar by one tick.
            return 1;
        }
    }

    // The component has not changed. The progress bar will not move for this component.
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOnQueryChangeSelState
//
//  Purpose:    Handles the OC_QUERY_CHANGE_SEL_STATE function message.
//              Enables and disables the next button. If no changes has 
//              been made to the selections the next button is disabled.
//
//  Arguments:
//      pszSubComponentId [in]  Name of component.
//      fSelected         [in]  TRUE if component was checked "on", FALSE if
//                              checked "off"
//      uiFlags           [in]  Flags defined in ocmgr.doc
//
//  Returns:    S_OK if success, Win32 error otherwise
//
//  Author:     danielwe   23 Feb   1998
//
//  Notes:
//
HRESULT HrOnQueryChangeSelState(PCWSTR pszSubComponentId, BOOL fSelected,
                                UINT uiFlags)
{
    HRESULT       hr = S_OK;
    static int    nItemsChanged=0;
    NETOCDATA *   pnocd;

    if (fSelected && pszSubComponentId)
    {
        pnocd = PnocdFindComponent(pszSubComponentId);
        if (pnocd)
        {
            // "NetOc" may be a subcomponent and we don't want to call this
            // for it.
            hr = HrCallExternalProc(pnocd, NETOCM_QUERY_CHANGE_SEL_STATE,
                                    (WPARAM)(!!(uiFlags & OCQ_ACTUAL_SELECTION)),
                                    0);
        }
    }

    TraceError("HrOnQueryChangeSelState", hr);
    return hr;
}



//+---------------------------------------------------------------------------
//
//  Function:   FOnQuerySkipPage
//
//  Purpose:    Handles the OC_QUERY_SKIP_PAGE function message.
//
//  Arguments:
//      ocmPage [in]    Which page we are asked to possibly skip.
//
//  Returns:    TRUE if component list page should be skipped, FALSE if not.
//
//  Author:     danielwe   23 Feb   1998
//
//  Notes:
//
BOOL FOnQuerySkipPage(OcManagerPage ocmPage)
{
    BOOL    fUnattended;
    BOOL    fGuiSetup;
    BOOL    fWorkstation;

    fUnattended = !!(g_ocmData.sic.SetupData.OperationFlags & SETUPOP_BATCH);
    fGuiSetup = !(g_ocmData.sic.SetupData.OperationFlags & SETUPOP_STANDALONE);
    fWorkstation = g_ocmData.sic.SetupData.ProductType == PRODUCT_WORKSTATION;

    if ((fUnattended || fWorkstation) && fGuiSetup)
    {
        // We're in GUI mode setup and... we're unattended -OR- this is
        // a workstation install
        if (ocmPage == OcPageComponentHierarchy)
        {
            TraceTag(ttidNetOc, "NETOC: Skipping component list page "
                     "during GUI mode setup...");
            TraceTag(ttidNetOc, "fUnattended = %s, fGuiSetup = %s, "
                     "fWorkstation = %s",
                     fUnattended ? "yes" : "no",
                     fGuiSetup ? "yes" : "no",
                     fWorkstation ? "yes" : "no");

            // Make sure we never show the component list page during setup
            return TRUE;
        }
    }

    TraceTag(ttidNetOc, "Using component list page.");
    TraceTag(ttidNetOc, "fUnattended = %s, fGuiSetup = %s, "
             "fWorkstation = %s",
             fUnattended ? "yes" : "no",
             fGuiSetup ? "yes" : "no",
             fWorkstation ? "yes" : "no");

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   OnCleanup
//
//  Purpose:    Handles the OC_CLEANUP function message.
//
//  Arguments:
//      (none)
//
//  Returns:    Nothing
//
//  Author:     danielwe   23 Feb 1998
//
//  Notes:
//
VOID OnCleanup()
{
    TraceTag(ttidNetOc, "Cleaning up");

    if (g_ocmData.hinfAnswerFile)
    {
        SetupCloseInfFile(g_ocmData.hinfAnswerFile);
        TraceTag(ttidNetOc, "Closed answer file");
    }

    DeleteAllComponents();
}

//+---------------------------------------------------------------------------
//
//  Function:   HrGetSelectionState
//
//  Purpose:
//
//  Arguments:
//      pszSubComponentId [in]  Name of subcomponent
//      uStateType        [in]  In OCManager doc.
//
//  Returns:    S_OK if component is selected, S_FALSE if not, or Win32 error
//              otheriwse
//
//  Author:     danielwe   17 Dec 1997
//
//  Notes:
//
HRESULT HrGetSelectionState(PCWSTR pszSubComponentId, UINT uStateType)
{
    HRESULT     hr = S_OK;
    BOOL        fInstall;

    fInstall = g_ocmData.sic.HelperRoutines.
        QuerySelectionState(g_ocmData.sic.HelperRoutines.OcManagerContext,
                            pszSubComponentId, uStateType);
    if (!fInstall)
    {
        // Still not sure of the state
        hr = HrFromLastWin32Error();
        if (SUCCEEDED(hr))
        {
            // Ok now we know
            hr = S_FALSE;
        }
    }
    else
    {
        hr = S_OK;
    }

    TraceError("HrGetSelectionState", (S_FALSE == hr) ? S_OK : hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrGetInstallType
//
//  Purpose:    Determines whether the given component is being installed or
//              removed and stores the result in the given structure.
//
//  Arguments:
//      pszSubComponentId [in]  Component being queried
//      nocd              [in, ref] Net OC Data.
//      peit              [out] Returns the install type
//
//  Returns:    S_OK if success, Win32 error otherwise
//
//  Author:     danielwe   16 Dec 1997
//
//  Notes:      If the function fails, the eit member is unreliable
//
HRESULT HrGetInstallType(PCWSTR pszSubComponentId, NETOCDATA &nocd,
                         EINSTALL_TYPE *peit)
{
    HRESULT     hr = S_OK;

    Assert(peit);
    Assert(pszSubComponentId);

    *peit = IT_UNKNOWN;

    if (g_ocmData.sic.SetupData.OperationFlags & SETUPOP_BATCH)
    {
        // In batch mode (upgrade or unattended install), install flag is
        // determined from answer file not from selection state.

        // assume no change
        *peit = IT_NO_CHANGE;

        if (!g_ocmData.hinfAnswerFile)
        {
            // Open the answer file
            hr = HrSetupOpenInfFile(g_ocmData.sic.SetupData.UnattendFile, NULL,
                                    INF_STYLE_OLDNT | INF_STYLE_WIN4, NULL,
                                    &g_ocmData.hinfAnswerFile);
        }

        if (SUCCEEDED(hr))
        {
            DWORD   dwValue = 0;

            // First query for a special value called "NoDepends" which, if
            // present, means that the DependOnComponents line will be IGNORED
            // for ALL network optional components for this install. This is
            // because NetCfg may invoke the OC Manager to install an optional
            // component and if that component has DependOnComponents, it will
            // turn around and try to instantiate another INetCfg and that
            // will fail because one instance is already running. This case
            // is rare, though.
            //
            hr = HrSetupGetFirstDword(g_ocmData.hinfAnswerFile,
                                        c_szOcMainSection, c_szNoDepends,
                                        &dwValue);
            if (SUCCEEDED(hr) && dwValue)
            {
                TraceTag(ttidNetOc, "Found the special 'NoDepends'"
                         " keyword in the answer file. DependOnComponents "
                         "will be ignored from now on");
                g_ocmData.fNoDepends = TRUE;
            }
            else
            {
                TraceTag(ttidNetOc, "Didn't find the special 'NoDepends'"
                         " keyword in the answer file");
                hr = S_OK;
            }

            hr = HrSetupGetFirstDword(g_ocmData.hinfAnswerFile,
                                      c_szOcMainSection, pszSubComponentId,
                                      &dwValue);
            if (SUCCEEDED(hr))
            {
                // This component was installed before, so we should
                // return that this component should be checked on

                if (dwValue)
                {
                    TraceTag(ttidNetOc, "Optional component %S was "
                             "previously installed or is being added thru"
                             " unattended install.", pszSubComponentId);

                    if (g_ocmData.sic.SetupData.OperationFlags & SETUPOP_NTUPGRADE)
                    {
                        // If we're upgrading NT, then this optional component
                        // does exist but it needs to be upgraded
                        *peit = IT_UPGRADE;
                    }
                    else
                    {
                        // Otherwise (even if Win3.1 or Win95 upgrade) it's like
                        // we're fresh installing the optional component
                        *peit = IT_INSTALL;
                    }
                }
                else
                {
                    // Answer file contains something like WINS=0
                    hr = HrGetSelectionState(pszSubComponentId,
                                             OCSELSTATETYPE_ORIGINAL);
                    if (S_OK == hr)
                    {
                        // Only set state to remove if the component was
                        // previously installed.
                        //
                        *peit = IT_REMOVE;
                    }
                }
            }
        }

        hr = S_OK;

        // If the answer file was opened successfully and if the
        // a section was found for the pszSubComponentId, *peit
        // will be either IT_INSTALL, IT_UPGRADE or IT_REMOVE.
        // Nothing needs to be done for any of these *peit values.
        // However, if the answerfile could not be opened or if
        // no section existed in the answer file for the pszSubComponentId
        // *peit will have the value IT_NO_CHANGE. For this scenario,
        // if the corresponding subComponent is currently installed, 
        // we should upgrade it. The following if addresses this scenario. 

        if (*peit == IT_NO_CHANGE)
        {
            // Still not going to install, because this is an upgrade
            hr = HrGetSelectionState(pszSubComponentId,
                                     OCSELSTATETYPE_ORIGINAL);
            if (S_OK == hr)
            {
                // If originally selected and not in answer file, this is an
                // upgrade of this component
                *peit = IT_UPGRADE;
            }
        }
    }
    else    // This is standalone (post-setup) mode
    {
        hr = HrGetSelectionState(pszSubComponentId, OCSELSTATETYPE_ORIGINAL);
        if (SUCCEEDED(hr))
        {
            HRESULT     hrT;

            hrT = HrGetSelectionState(pszSubComponentId,
                                      OCSELSTATETYPE_CURRENT);
            if (SUCCEEDED(hrT))
            {
                if (hrT != hr)
                {
                    // wasn't originally installed so...
                    *peit = (hrT == S_OK) ? IT_INSTALL : IT_REMOVE;
                }
                else
                {
                    // was originally checked
                    *peit = IT_NO_CHANGE;
                }
            }
            else
            {
                hr = hrT;
            }
        }
    }

    AssertSz(FImplies(SUCCEEDED(hr), *peit != IT_UNKNOWN), "Succeeded "
             "but we never found out the install type!");

    if (SUCCEEDED(hr))
    {
        hr = S_OK;

#if DBG
        const CHAR *szInstallType;

        switch (*peit)
        {
        case IT_NO_CHANGE:
            szInstallType = "no change";
            break;
        case IT_INSTALL:
            szInstallType = "install";
            break;
        case IT_UPGRADE:
            szInstallType = "upgrade";
            break;
        case IT_REMOVE:
            szInstallType = "remove";
            break;
        default:
            AssertSz(FALSE, "Unknown install type!");
            break;
        }

        TraceTag(ttidNetOc, "Install type of %S is %s.", pszSubComponentId,
                 szInstallType);
#endif

    }

    TraceError("HrGetInstallType", hr);
    return hr;
}

#if DBG
PCWSTR SzFromOcUmsg(UINT uMsg)
{
    switch (uMsg)
    {
    case NETOCM_PRE_INF:
        return L"NETOCM_PRE_INF";

    case NETOCM_POST_INSTALL:
        return L"NETOCM_POST_INSTALL";

    case NETOCM_QUERY_CHANGE_SEL_STATE:
        return L"NETOCM_QUERY_CHANGE_SEL_STATE";

    case NETOCM_QUEUE_FILES:
        return L"NETOCM_QUEUE_FILES";

    default:
        return L"**unknown**";
    }
}
#else
#define SzFromOcUmsg(x)     (VOID)0
#endif

//+---------------------------------------------------------------------------
//
//  Function:   HrCallExternalProc
//
//  Purpose:    Calls a component's external function as defined by
//              the table at the top of this file. This enables a component
//              to perform additional installation tasks that are not common
//              to other components.
//
//  Arguments:
//      pnocd   [in]   Pointer to Net OC Data
//
//  Returns:    S_OK if successful, Win32 error code otherwise.
//
//  Author:     danielwe   5 May 1997
//
//  Notes:
//
HRESULT HrCallExternalProc(PNETOCDATA pnocd, UINT uMsg, WPARAM wParam,
                           LPARAM lParam)
{
    HRESULT     hr = S_OK;
    INT         iaocep;
    BOOL        fFound = FALSE;

    AssertSz(pnocd, "Bad pnocd in HrCallExternalProc");

    for (iaocep = 0; iaocep < c_cocepMap; iaocep++)
    {
        if (!lstrcmpiW(c_aocepMap[iaocep].pszComponentName,
                      pnocd->pszComponentId))
        {
            TraceTag(ttidNetOc, "Calling external procedure for %S. uMsg = %S"
                     " wParam = %08X,"
                     " lParam = %08X", c_aocepMap[iaocep].pszComponentName,
                     SzFromOcUmsg(uMsg), wParam, lParam);

            // This component has an external proc. Call it now.
            hr = c_aocepMap[iaocep].pfnHrOcExtProc(pnocd, uMsg,
                                                   wParam, lParam);

            fFound = TRUE;
            // Don't try to call any other functions
            break;
        }
    }

    if (FALSE == fFound)
    {
        TraceTag(ttidNetOc, "HrCallExternalProc - did not find a matching Proc for %S",
                 pnocd->pszComponentId);
    }

    TraceError("HrCallExternalProc", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrInstallOrRemoveNetCfgComponent
//
//  Purpose:    Utility function for use by optional components that wish to
//              install a NetCfg component from within their own install.
//
//  Arguments:
//      pnocd          [in]     Pointer to NETOC data
//      pszComponentId  [in]     Component ID of NetCfg component to install.
//                              This can be found in the netinfid.cpp file.
//      pszManufacturer [in]     Manufacturer name of component doing the
//                              installing (*this* component). Should always
//                              be "Microsoft".
//      pszProduct      [in]     Short name of product for this component.
//                              Should be something like "MacSrv".
//      pszDisplayName  [in]     Display name of this product. Should be
//                              something like "Services For Macintosh".
//      rguid          [in]     class GUID of the component being installed
//
//  Returns:    S_OK if successful, Win32 error code otherwise.
//
//  Author:     danielwe   6 May 1997
//
//  Notes:
//
HRESULT HrInstallOrRemoveNetCfgComponent(PNETOCDATA pnocd,
                                         PCWSTR pszComponentId,
                                         PCWSTR pszManufacturer,
                                         PCWSTR pszProduct,
                                         PCWSTR pszDisplayName,
                                         const GUID& rguid)
{
    HRESULT                 hr = S_OK;
    INetCfg *               pnc;
    NETWORK_INSTALL_PARAMS  nip = {0};
    BOOL                    fReboot = FALSE;

    nip.dwSetupFlags = FInSystemSetup() ? NSF_PRIMARYINSTALL :
                                          NSF_POSTSYSINSTALL;

    hr = HrOcGetINetCfg(pnocd, TRUE, &pnc);
    if (SUCCEEDED(hr))
    {
        if (pnocd->eit == IT_INSTALL || pnocd->eit == IT_UPGRADE)
        {
            if (*pszComponentId == L'*')
            {
                // Advance past the *
                pszComponentId++;

                // Install OBO user instead
                TraceTag(ttidNetOc, "Installing %S on behalf of the user",
                         pszComponentId);

                hr = HrInstallComponentOboUser(pnc, &nip, rguid,
                                               pszComponentId, NULL);
            }
            else
            {
                TraceTag(ttidNetOc, "Installing %S on behalf of %S",
                         pszComponentId, pnocd->pszSection);

                hr = HrInstallComponentOboSoftware(pnc, &nip,
                                                   rguid,
                                                   pszComponentId,
                                                   pszManufacturer,
                                                   pszProduct,
                                                   pszDisplayName,
                                                   NULL);
            }
        }
        else
        {
            AssertSz(pnocd->eit == IT_REMOVE, "Invalid install action!");

            TraceTag(ttidNetOc, "Removing %S on behalf of %S",
                     pszComponentId, pnocd->pszSection);

            hr = HrRemoveComponentOboSoftware(pnc,
                                              rguid,
                                              pszComponentId,
                                              pszManufacturer,
                                              pszProduct,
                                              pszDisplayName);
            if (NETCFG_S_REBOOT == hr)
            {
                // Save off the fact that we need to reboot
                fReboot = TRUE;
            }
            // Don't care about the return value here. If we can't remove a
            // dependent component, we can't do anything about it so we should
            // still continue the removal of the OC.
            //
            else if (FAILED(hr))
            {
                TraceTag(ttidError, "Failed to remove %S on behalf of %S!! "
                         "Error is 0x%08X",
                         pszComponentId, pnocd->pszSection, hr);
                hr = S_OK;
            }
        }
        if (SUCCEEDED(hr))
        {
            hr = pnc->Apply();
        }

        (VOID) HrUninitializeAndReleaseINetCfg(TRUE, pnc, TRUE);
    }

    if (SUCCEEDED(hr) && fReboot)
    {
        // If all went well and we needed to reboot, set hr back.
        hr = NETCFG_S_REBOOT;
    }

    TraceError("HrInstallOrRemoveNetCfgComponent", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrInstallOrRemoveServices
//
//  Purpose:    Given an install section, installs (or removes) NT services
//              from the section.
//
//  Arguments:
//      hinf          [in]  Handle to INF file.
//      pszSectionName [in]  Name of section to use.
//
//  Returns:    S_OK if successful, WIN32 HRESULT if not.
//
//  Author:     danielwe   23 Apr 1997
//
//  Notes:
//
HRESULT HrInstallOrRemoveServices(HINF hinf, PCWSTR pszSectionName)
{
    static const WCHAR c_szDotServices[] = L"."INFSTR_SUBKEY_SERVICES;

    HRESULT     hr = S_OK;
    PWSTR       pszServicesSection;
    const DWORD c_cchServices = celems(c_szDotServices);
    DWORD       cchName;

    // Look for <szSectionName>.Services to install any NT
    // services if they exist.

    cchName = c_cchServices + lstrlenW(pszSectionName);

    pszServicesSection = new WCHAR [cchName];

    if(pszServicesSection)
    {
        lstrcpyW(pszServicesSection, pszSectionName);
        lstrcatW(pszServicesSection, c_szDotServices);

        if (!SetupInstallServicesFromInfSection(hinf, pszServicesSection, 0))
        {
            hr = HrFromLastWin32Error();
            if (hr == HRESULT_FROM_SETUPAPI(ERROR_SECTION_NOT_FOUND))
            {
                // No problem if section was not found
                hr = S_OK;
            }
        }

        delete [] pszServicesSection;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    TraceError("HrInstallOrRemoveServices", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrHandleOCExtensions
//
//  Purpose:    Handles support for all optional component extensions to the
//              INF file format.
//
//  Arguments:
//      hinfFile         [in]   handle to INF to process
//      pszInstallSection [in]   Install section to process
//
//  Returns:    S_OK if success, setup API HRESULT otherwise
//
//  Author:     danielwe   28 Apr 1997
//
//  Notes:
//
HRESULT HrHandleOCExtensions(HINF hinfFile, PCWSTR pszInstallSection)
{
    HRESULT     hr  = S_OK;

    // There's now common code to do this, so simply make a call to that code.
    //
    hr = HrProcessAllINFExtensions(hinfFile, pszInstallSection);

    TraceError("HrHandleOCExtensions", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrInstallOrRemoveDependOnComponents
//
//  Purpose:    Handles installation or removal of any NetCfg components that
//              the optional component being installed is dependent upon.
//
//  Arguments:
//      pnocd            [in]   Pointer to NETOC data
//      hinf             [in]   Handle to INF file to process.
//      pszInstallSection [in]   Section name to install from.
//      pszDisplayName    [in]   Display name of component being installed.
//
//  Returns:    S_OK if success, setup API HRESULT otherwise
//
//  Author:     danielwe   17 Jun 1997
//
//  Notes:
//
HRESULT HrInstallOrRemoveDependOnComponents(PNETOCDATA pnocd,
                                            HINF hinf,
                                            PCWSTR pszInstallSection,
                                            PCWSTR pszDisplayName)
{
    HRESULT     hr = S_OK;
    PWSTR       mszDepends;
    tstring     strManufacturer;
    PCWSTR      pszManufacturer;

    Assert(pnocd);

    hr = HrSetupGetFirstString(hinf, c_szVersionSection, c_szProvider,
                               &strManufacturer);
    if (S_OK == hr)
    {
        pszManufacturer = strManufacturer.c_str();
    }
    else
    {
        // No provider found, use default
        hr = S_OK;
        pszManufacturer = c_szDefManu;
    }

    hr = HrSetupGetFirstMultiSzFieldWithAlloc(hinf, pszInstallSection,
                                              c_szDependOnComp,
                                              &mszDepends);
    if (S_OK == hr)
    {
        PCWSTR     pszComponent;

        pszComponent = mszDepends;
        while (SUCCEEDED(hr) && *pszComponent)
        {
            const GUID *    pguidClass;
            PCWSTR         pszComponentActual = pszComponent;

            if (*pszComponent == L'*')
            {
                pszComponentActual = pszComponent + 1;
            }

            if (FClassGuidFromComponentId(pszComponentActual, &pguidClass))
            {
                hr = HrInstallOrRemoveNetCfgComponent(pnocd,
                                                      pszComponent,
                                                      pszManufacturer,
                                                      pszInstallSection,
                                                      pszDisplayName,
                                                      *pguidClass);
            }
#ifdef DBG
            else
            {
                TraceTag(ttidNetOc, "Error in INF, Component %S not found!",
                         pszComponent);
            }
#endif
            pszComponent += lstrlenW(pszComponent) + 1;
        }
        delete mszDepends;
    }
    else if (hr == HRESULT_FROM_SETUPAPI(ERROR_LINE_NOT_FOUND))
    {
        // Section is not required.
        hr = S_OK;
    }

    TraceError("HrInstallOrRemoveDependOnComponents", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRunInfSection
//
//  Purpose:    Runs the given INF section, but doesn't copy files
//
//  Arguments:
//      hinf              [in]   Handle to INF to run
//      pnocd             [in]   NetOC Data
//      pszInstallSection [in]   Install section to run
//      dwFlags           [in]   Install flags (SPINST_*)
//
//  Returns:    S_OK if success, SetupAPI or Win32 error otherwise
//
//  Author:     danielwe   16 Dec 1997
//
//  Notes:
//
HRESULT HrRunInfSection(HINF hinf, PNETOCDATA pnocd,
                        PCWSTR pszInstallSection, DWORD dwFlags)
{
    HRESULT     hr;

    // Now we run all sections but CopyFiles and UnregisterDlls because we
    // did that earlier
    //
    hr = HrSetupInstallFromInfSection(g_ocmData.hwnd, hinf,
                                      pszInstallSection,
                                      dwFlags & ~SPINST_FILES & ~SPINST_UNREGSVR,
                                      NULL, NULL, 0, NULL,
                                      NULL, NULL, NULL);

    TraceError("HrRunInfSection", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrStartOrStopAnyServices
//
//  Purpose:    Starts or stops any services the INF has requested via the
//              Services value in the main install section.
//
//  Arguments:
//      hinf      [in] handle to INF to process
//      pszSection [in] Install section to process
//      fStart    [in] TRUE to start, FALSE to stop.
//
//  Returns:    S_OK or Win32 error code.
//
//  Author:     danielwe   17 Jun 1997
//
//  Notes:      Services are stopped in the same order they are started.
//
HRESULT HrStartOrStopAnyServices(HINF hinf, PCWSTR pszSection, BOOL fStart)
{
    HRESULT     hr;
    PWSTR      mszServices;

    hr = HrSetupGetFirstMultiSzFieldWithAlloc(hinf, pszSection,
                                              c_szServices, &mszServices);
    if (SUCCEEDED(hr))
    {
        // Build an array of pointers to strings that point at the
        // strings of the multi-sz.  This is needed because the API to
        // stop and start services takes an array of pointers to strings.
        //
        UINT     cServices;
        PCWSTR* apszServices;

        hr = HrCreateArrayOfStringPointersIntoMultiSz(
                mszServices,
                &cServices,
                &apszServices);

        if (SUCCEEDED(hr))
        {
            CServiceManager scm;

            if (fStart)
            {
                hr = scm.HrStartServicesAndWait(cServices, apszServices);
            }
            else
            {
                hr = scm.HrStopServicesAndWait(cServices, apszServices);
            }

            MemFree (apszServices);
        }

        delete mszServices;
    }
    else if (hr == HRESULT_FROM_SETUPAPI(ERROR_LINE_NOT_FOUND))
    {
        // this is a totally optional thing
        hr = S_OK;
    }

    TraceError("HrStartOrStopAnyServices", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrDoActualInstallOrUninstall
//
//  Purpose:    Handles main portion of install or uninstall for an optional
//              network component.
//
//  Arguments:
//      hinf             [in]   handle to INF to process
//      pnocd            [in]   Pointer to NETOC data (hwnd, poc)
//      pszInstallSection [in]   Install section to process
//
//  Returns:    S_OK if success, setup API HRESULT otherwise
//
//  Author:     danielwe   17 Jun 1997
//
//  Notes:
//
HRESULT HrDoActualInstallOrUninstall(HINF hinf,
                                     PNETOCDATA pnocd,
                                     PCWSTR pszInstallSection)
{
    HRESULT     hr = S_OK;
    BOOL        fReboot = FALSE;

    AssertSz(pszInstallSection, "Install section is NULL!");
    AssertSz(pnocd, "Bad pnocd in HrDoActualInstallOrUninstall");
    //AssertSz(g_ocmData.hwnd, "Bad g_ocmData.hwnd in HrDoActualInstallOrUninstall");

    if (pnocd->eit == IT_REMOVE)
    {
        hr = HrCallExternalProc(pnocd, NETOCM_PRE_INF, 0, 0);
        if (SUCCEEDED(hr))
        {
            // Now process the component's INF file
            //

            TraceTag(ttidNetOc, "Running INF section %S", pszInstallSection);

            hr = HrRunInfSection(hinf, pnocd, pszInstallSection, SPINST_ALL);
        }
    }
    else
    {
        hr = HrCallExternalProc(pnocd, NETOCM_PRE_INF, 0, 0);
        if (SUCCEEDED(hr))
        {
            // Process the component's INF file
            //

            TraceTag(ttidNetOc, "Running INF section %S", pszInstallSection);

            hr = HrRunInfSection(hinf, pnocd, pszInstallSection,
                                 SPINST_ALL & ~SPINST_REGSVR);
        }
    }

    if (SUCCEEDED(hr))
    {
        // Must install or remove services first
        TraceTag(ttidNetOc, "Running HrInstallOrRemoveServices for %S",
                 pszInstallSection);
        hr = HrInstallOrRemoveServices(hinf, pszInstallSection);
        if (SUCCEEDED(hr))
        {
            // Bug #383239: Wait till services are installed before
            // running the RegisterDlls section
            //
            hr = HrRunInfSection(hinf, pnocd, pszInstallSection,
                                 SPINST_REGSVR);
        }

        if (SUCCEEDED(hr))
        {
            TraceTag(ttidNetOc, "Running HrHandleOCExtensions for %S",
                     pszInstallSection);
            hr = HrHandleOCExtensions(hinf, pszInstallSection);
            if (SUCCEEDED(hr))
            {
                if (!g_ocmData.fNoDepends)
                {
                    // Now install or remove any NetCfg components that this
                    // component requires
                    TraceTag(ttidNetOc, "Running "
                             "HrInstallOrRemoveDependOnComponents for %S",
                             pnocd->pszSection);
                    hr = HrInstallOrRemoveDependOnComponents(pnocd,
                                                             hinf,
                                                             pnocd->pszSection,
                                                             pnocd->strDesc.c_str());
                    if (NETCFG_S_REBOOT == hr)
                    {
                        fReboot = TRUE;
                    }
                }
                else
                {
                    AssertSz(g_ocmData.sic.SetupData.OperationFlags &
                             SETUPOP_BATCH, "How can NoDepends be set??");

                    TraceTag(ttidNetOc, "NOT Running "
                             "HrInstallOrRemoveDependOnComponents for %S "
                             "because NoDepends was set in the answer file.",
                             pnocd->pszSection);
                }

                if (SUCCEEDED(hr))
                {
                    // Now call any external installation support...
                    hr = HrCallExternalProc(pnocd, NETOCM_POST_INSTALL,
                                            0, 0);
                    if (SUCCEEDED(hr))
                    {
                        if (pnocd->eit == IT_INSTALL && !FInSystemSetup())
                        {
                            // ... and finally, start any services they've
                            // requested
                            hr = HrStartOrStopAnyServices(hinf,
                                    pszInstallSection, TRUE);
                            {
                                if (FAILED(hr))
                                {
                                    UINT    ids = IDS_OC_START_SERVICE_FAILURE;

                                    if (HRESULT_FROM_WIN32(ERROR_TIMEOUT) == hr)
                                    {
                                        ids = IDS_OC_START_TOOK_TOO_LONG;
                                    }

                                    // Don't bail installation if service
                                    // couldn't be started. Report an error
                                    // and continue the install.
                                    ReportErrorHr(hr, ids, g_ocmData.hwnd,
                                                  pnocd->strDesc.c_str());
                                    hr = S_OK;
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    if ((S_OK == hr) && (fReboot))
    {
        hr = NETCFG_S_REBOOT;
    }

    TraceError("HrDoActualInstallOrUninstall", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOCInstallOrUninstallFromINF
//
//  Purpose:    Handles installation of an Optional Component from its INF
//              file.
//
//  Arguments:
//      pnocd          [in]     Pointer to NETOC data.
//
//  Returns:    S_OK if success, setup API HRESULT otherwise
//
//  Author:     danielwe   6 May 1997
//
//  Notes:
//
HRESULT HrOCInstallOrUninstallFromINF(PNETOCDATA pnocd)
{
    HRESULT     hr = S_OK;
    tstring     strUninstall;
    PCWSTR      pszInstallSection = NULL;
    BOOL        fSuccess = TRUE;

    Assert(pnocd);

    if (pnocd->eit == IT_REMOVE)
    {
        // Get the name of the uninstall section first
        hr = HrSetupGetFirstString(pnocd->hinfFile, pnocd->pszSection,
                                    c_szUninstall, &strUninstall);
        if (SUCCEEDED(hr))
        {
            pszInstallSection = strUninstall.c_str();
        }
        else
        {
            if (hr == HRESULT_FROM_SETUPAPI(ERROR_LINE_NOT_FOUND))
            {
                // Uninstall section is not required.
                hr = S_OK;
            }
            fSuccess = FALSE;
        }
    }
    else
    {
        pszInstallSection = pnocd->pszSection;
    }

    if (fSuccess)
    {
        hr = HrDoActualInstallOrUninstall(pnocd->hinfFile,
                                          pnocd,
                                          pszInstallSection);
    }

    TraceError("HrOCInstallOrUninstallFromINF", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrDoOCInstallOrUninstall
//
//  Purpose:    Installs or removes an optional networking component.
//
//  Arguments:
//      pnocd          [in]   Pointer to NETOC data
//
//  Returns:    S_OK for success, SetupAPI HRESULT error code otherwise.
//
//  Author:     danielwe   6 May 1997
//
//  Notes:
//
HRESULT HrDoOCInstallOrUninstall(PNETOCDATA pnocd)
{
    HRESULT     hr = S_OK;

    hr = HrOCInstallOrUninstallFromINF(pnocd);

    TraceError("HrDoOCInstallOrUninstall", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   UiOcErrorFromHr
//
//  Purpose:    Maps a Win32 error code into an understandable error string.
//
//  Arguments:
//      hr [in]     HRESULT to convert
//
//  Returns:    The resource ID of the string.
//
//  Author:     danielwe   9 Feb 1998
//
//  Notes:
//
UINT UiOcErrorFromHr(HRESULT hr)
{
    UINT    uid;

    AssertSz(FAILED(hr), "Don't call UiOcErrorFromHr if Hr didn't fail!");

    switch (hr)
    {
    case HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND):
    case HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND):
        uid = IDS_OC_REGISTER_PROBLEM;
        break;
    case HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND):
        uid = IDS_OC_FILE_PROBLEM;
        break;
    case NETCFG_E_NEED_REBOOT:
    case HRESULT_FROM_WIN32(ERROR_SERVICE_MARKED_FOR_DELETE):
        uid = IDS_OC_NEEDS_REBOOT;
        break;
    case HRESULT_FROM_WIN32(ERROR_CANCELLED):
        uid = IDS_OC_USER_CANCELLED;
        break;
    case HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED):
        uid = IDS_OC_NO_PERMISSION;
        break;
    default:
        uid = IDS_OC_ERROR;
        break;
    }

    return uid;
}

//+---------------------------------------------------------------------------
//
//  Function:   SzErrorToString
//
//  Purpose:    Converts an HRESULT into a displayable string.
//
//  Arguments:
//      hr      [in]    HRESULT value to convert.
//
//  Returns:    LPWSTR a dynamically allocated string to be freed with LocalFree
//
//  Author:     mbend    3 Apr 2000
//
//  Notes:      Attempts to use FormatMessage to convert the HRESULT to a string.
//              If that fails, just convert the HRESULT to a hex string.
//
LPWSTR SzErrorToString(HRESULT hr)
{
    LPWSTR pszErrorText = NULL;
    FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                   FORMAT_MESSAGE_FROM_SYSTEM,
                   NULL, hr,
                   MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
                   (WCHAR*)&pszErrorText, 0, NULL);

    if (pszErrorText)
    {
        // Strip off newline characters.
        //
        LPWSTR pchText = pszErrorText;
        while (*pchText && (*pchText != L'\r') && (*pchText != L'\n'))
        {
            pchText++;
        }
        *pchText = 0;

        return pszErrorText;
    }
    // We did't find anything so format the hex value
    WCHAR szBuf[128];
    wsprintfW(szBuf, L"0x%08x", hr);
    WCHAR * szRet = reinterpret_cast<WCHAR*>(LocalAlloc(LMEM_FIXED, (lstrlenW(szBuf) + 1) * sizeof(WCHAR)));
    if(szRet)
    {
        lstrcpyW(szRet, szBuf);
    }
    return szRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   NcMsgBoxMc
//
//  Purpose:    Displays a message box using resource strings from
//              the message resource file and using replaceable
//              parameters.
//
//  Arguments:
//      hwnd        [in] parent window handle
//      unIdCaption [in] resource id of caption string
//                       (from .RC file)
//      unIdFormat  [in] resource id of text string (with %1, %2, etc.)
//                       (from .MC file)
//      unStyle     [in] standard message box styles
//      ...         [in] replaceable parameters (optional)
//                          (these must be PCWSTRs as that is all
//                          FormatMessage handles.)
//
//  Returns:    The return value of MessageBox()
//
//  Author:     roelfc     7 June 2001
//
//  Notes:      FormatMessage is used to do the parameter substitution.
//              The unIdFormat resource id MUST be specified in the
//              .MC resource file with a severity of either informational,
//              warning or error.
//
NOTHROW
int
WINAPIV
NcMsgBoxMc(HWND    hwnd,
           UINT    unIdCaption,
           UINT    unIdFormat,
           UINT    unStyle,
           ...)
{
    PCWSTR pszCaption = SzLoadIds(unIdCaption);

    // We report only valid message resources to prevent event log failures
    AssertSz(STATUS_SEVERITY_VALUE(unIdFormat) != STATUS_SEVERITY_SUCCESS,
             "Either the severity code is not set (information, warning or error),"
             " or you passed a .RC resource id instead of a .MC resource id.");

    PWSTR  pszText = NULL;
    va_list val;
    va_start (val, unStyle);
    FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE,
                   _Module.GetResourceInstance(), unIdFormat, 0, (PWSTR)&pszText, 0, &val);
    va_end (val);
    if(!pszText)
    {
        // This is what MessageBox returns if it fails.
        return 0;
    }

    INT nRet = MessageBox (hwnd, pszText, pszCaption, unStyle);
    LocalFree (pszText);

    return nRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   ReportEventHrString
//
//  Purpose:    Reports an error, warning or informative message
//              to the event log from an error description string.
//
//  Arguments:
//      pszErr  [in]    Error description string.
//      ids     [in]    Resource ID of string to display.
//      pszDesc [in]    Description of component involved.
//
//  Returns:    S_OK, or valid Win32 error code.
//
//  Author:     roelfc   18 May 2001
//
//  Notes: This function works slow since it calls the open and close
//         eventlog source everytime. This should not have an effect
//         since it only happens during errors.
//         The string resource in ids must contain a %1 and %2 where %1
//         is the name of the component, and %2 is the error code.
//         The resource ID of the string to display MUST be defined
//         in the .MC file, with a severity of either informational,
//         warning or error. The Assert below prevents the incorrect 
//         use of .RC strings which will fail during event logging.
//
HRESULT ReportEventHrString(PCWSTR pszErr, INT ids, PCWSTR pszDesc)
{

    HANDLE 	hEventLog;
    WORD    elt;
    HRESULT hr = S_OK;
    PCWSTR  plpszSubStrings[2];


    plpszSubStrings[0] = pszDesc;
    plpszSubStrings[1] = pszErr;

    // We report only valid message resources to prevent event log failures
    AssertSz(STATUS_SEVERITY_VALUE(ids) != STATUS_SEVERITY_SUCCESS,
             "Either the severity code is not set (information, warning or error),"
             " or you passed a .RC resource id instead of a .MC resource id.");

    // Determine the event log type
    switch (STATUS_SEVERITY_VALUE(ids))
    {
        case STATUS_SEVERITY_WARNING:
            elt = EVENTLOG_WARNING_TYPE;
            break;

        case STATUS_SEVERITY_ERROR:
            elt = EVENTLOG_ERROR_TYPE;
            break;

        default:
            // Default to informational
            elt = EVENTLOG_INFORMATION_TYPE;
            break;
    }

    hEventLog = RegisterEventSource(NULL, NETOC_SERVICE_NAME);
    Assert(hEventLog);

    if (hEventLog)
    {
	    if (!ReportEvent(hEventLog,
                         elt,
                         0,           		// Event category
                         ids,               // Message file full id
                         NULL,
                         sizeof(plpszSubStrings) / sizeof(plpszSubStrings[0]),
                         0,
                         plpszSubStrings,
                         NULL))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }

        DeregisterEventSource(hEventLog);
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   ReportEventHrResult
//
//  Purpose:    Reports an error, warning or informative message
//              to the event log from a result value.
//
//  Arguments:
//      hrv     [in]    HRESULT value to report.
//      ids     [in]    Resource ID of string to display.
//      pszDesc [in]    Description of component involved.
//
//  Returns:    S_OK, or valid Win32 error code.
//
//  Author:     roelfc   18 May 2001
//
//  Notes: 
//
HRESULT ReportEventHrResult(HRESULT hrv, INT ids, PCWSTR pszDesc)
{

    HRESULT hr = S_OK;
    BOOL    bCleanup = TRUE;
    WCHAR * szText = SzErrorToString(hrv);

    if(!szText)
    {
        szText = L"Out of memory!";
        bCleanup = FALSE;
    }

    hr = ReportEventHrString(szText, ids, pszDesc);
 
    if(bCleanup)
    {
        LocalFree(szText);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   ReportErrorHr
//
//  Purpose:    Reports an error, warning or informative message
//              to the user or event log.
//
//  Arguments:
//      hrv     [in]    HRESULT value to report.
//      ids     [in]    Resource ID of string to display.
//      hwnd    [in]    HWND of parent window.
//      pszDesc [in]    Description of component involved.
//
//  Returns:    S_OK, or valid Win32 error code.
//
//  Author:     danielwe   28 Apr 1997
//
//  Notes:      The string resource in ids must contain a %1 and %2 where %1
//              is the name of the component, and %2 is the error code.
//              The resource ID of the string to display MUST be defined
//              in the .MC file, with a severity of either informational,
//              warning or error. The Assert below prevents the incorrect 
//              use of .RC strings which will fail during event logging.
//
HRESULT ReportErrorHr(HRESULT hrv, INT ids, HWND hwnd, PCWSTR pszDesc)
{

    DWORD dwRt;
    HRESULT hr = S_OK;


    // We report only valid message resources to prevent event log failures
    AssertSz(STATUS_SEVERITY_VALUE(ids) != STATUS_SEVERITY_SUCCESS,
             "Either the severity code is not set (information, warning or error),"
             " or you passed a .RC resource id instead of a .MC resource id.");

    // We can only display a message box in "attended" setup mode
    // or when the caller overide with the /z:netoc_show_unattended_messages option,
    // else we log the problem to the event log.
    if ((g_ocmData.sic.SetupData.OperationFlags & SETUPOP_BATCH) &&
        (!g_ocmData.fShowUnattendedMessages))
    {
        // In batch mode ("unattended") we need to report the error in the event log
        hr = ReportEventHrResult(hrv, ids, pszDesc);
    }
    else
    {
        BOOL bCleanup = TRUE;
        WCHAR * szText = SzErrorToString(hrv);

        if(!szText)
        {
            szText = L"Out of memory!";
            bCleanup = FALSE;
        }

        // Get the right icon from the type of message
        switch (STATUS_SEVERITY_VALUE(ids))
        {
            case STATUS_SEVERITY_WARNING:
                dwRt = MB_ICONWARNING;
                break;

            case STATUS_SEVERITY_ERROR:
                dwRt = MB_ICONERROR;
                break;

            default:
                // Default to informational
                dwRt = MB_ICONINFORMATION;
                break;
        }
        
        // We can display the error to the user
        NcMsgBoxMc(hwnd, IDS_OC_CAPTION, ids, dwRt | MB_OK, pszDesc, szText);

        if(bCleanup)
        {
            LocalFree(szText);
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrVerifyStaticIPPresent
//
//  Purpose:    Verify that at least one adapter has a static IP address.
//              Both DHCP Server and WINS need to know this, as they need
//              to bring up UI if this isn't the case. This function is, of
//              course, a complete hack until we can get a properties
//              interface hanging off of the components.
//
//  Arguments:
//      pnc     [in] INetCfg interface to use
//
//  Returns:    S_OK, or valid Win32 error code.
//
//  Author:     jeffspr   19 Jun 1997
//
//  Notes:
//
HRESULT HrVerifyStaticIPPresent(INetCfg *pnc)
{
    HRESULT             hr                  = S_OK;
    HKEY                hkeyInterfaces      = NULL;
    HKEY                hkeyEnum            = NULL;
    INetCfgComponent*   pncc                = NULL;
    HKEY                hkeyTcpipAdapter    = NULL;
    PWSTR               pszBindName        = NULL;

    Assert(pnc);

    // Iterate the adapters in the system looking for non-virtual adapters
    //
    CIterNetCfgComponent nccIter(pnc, &GUID_DEVCLASS_NET);
    while (S_OK == (hr = nccIter.HrNext(&pncc)))
    {
        DWORD   dwFlags = 0;

        // Get the adapter characteristics
        //
        hr = pncc->GetCharacteristics(&dwFlags);
        if (SUCCEEDED(hr))
        {
            DWORD       dwEnableValue   = 0;

            // If we're NOT a virtual adapter, THEN test for
            // tcp/ip static IP
            if (!(dwFlags & NCF_VIRTUAL))
            {
                WCHAR   szRegPath[MAX_PATH+1];

                // Get the component bind name
                //
                hr = pncc->GetBindName(&pszBindName);
                if (FAILED(hr))
                {
                    TraceTag(ttidError,
                            "Error getting bind name from component "
                            "in HrVerifyStaticIPPresent()");
                    goto Exit;
                }

                // Build the path to the TCP/IP instance key for his adapter
                //
                wsprintfW(szRegPath, L"%s\\%s",
                        c_szTcpipInterfacesPath, pszBindName);

                // Open the key for this adapter.
                //
                hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE,
                        szRegPath,
                        KEY_READ, &hkeyTcpipAdapter);
                if (SUCCEEDED(hr))
                {
                    // Read the EnableDHCP value.
                    //
                    hr = HrRegQueryDword(hkeyTcpipAdapter, c_szEnableDHCP,
                            &dwEnableValue);
                    if (FAILED(hr))
                    {
                        TraceTag(ttidError,
                                "Error reading the EnableDHCP value from "
                                "the enumerated key in "
                                "HrVerifyStaticIPPresent()");
                        goto Exit;
                    }

                    // If we've found a non-DHCP-enabled adapter.
                    //
                    if (0 == dwEnableValue)
                    {
                        // We have our man. Take a hike, and return S_OK,
                        // meaning that we had at least one good adapter.
                        // The enumerated key will get cleaned up at exit.
                        hr = S_OK;
                        goto Exit;
                    }

                    RegSafeCloseKey(hkeyTcpipAdapter);
                    hkeyTcpipAdapter = NULL;
                }
                else
                {
                    // If the key wasn't found, we just don't have a
                    // binding to TCP/IP. This is fine, but we don't need
                    // to continue plodding down this path.
                    //
                    if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
                    {
                        hr = S_OK;
                    }
                    else
                    {
                        TraceTag(ttidError,
                                "Error opening adapter key in "
                                "HrVerifyStaticIPPresent()");
                        goto Exit;
                    }
                }
            }
        }

        if (pszBindName)
        {
            CoTaskMemFree(pszBindName);
            pszBindName = NULL;
        }

        ReleaseObj (pncc);
        pncc = NULL;
    }

    // If we haven't found an adapter, we'll have an S_FALSE returned from
    // the HrNext. This is fine, because if we haven't found an adapter
    // with a static IP address, this is exactly what we want to return.
    // If we'd found one, we'd have set hr = S_OK, and dropped out of the
    // loop.

Exit:
    RegSafeCloseKey(hkeyTcpipAdapter);

    if (pszBindName)
    {
        CoTaskMemFree(pszBindName);
        pszBindName = NULL;
    }

    ReleaseObj(pncc);

    TraceError("HrVerifyStaticIPPresent()", (hr == S_FALSE) ? S_OK : hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrCountConnections
//
//  Purpose:    Determines the number of LAN connections present and returns
//              a pointer to an INetConnection object if only one connection
//              is present.
//
//  Arguments:
//      ppconn [out]    If only one connection is present, this returns it
//
//  Returns:    S_OK if no errors were found and at least one connection
//              exists, S_FALSE if no connections exist, or a Win32 or OLE
//              error code otherwise
//
//  Author:     danielwe   28 Jul 1998
//
//  Notes:
//
HRESULT HrCountConnections(INetConnection **ppconn)
{
    HRESULT                 hr = S_OK;
    INetConnectionManager * pconMan;

    Assert(ppconn);

    *ppconn = NULL;

    // Iterate all LAN connections
    //
    hr = HrCreateInstance(
        CLSID_LanConnectionManager,
        CLSCTX_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
        &pconMan);

    TraceHr(ttidError, FAL, hr, FALSE, "HrCreateInstance");

    if (SUCCEEDED(hr))
    {
        CIterNetCon         ncIter(pconMan, NCME_DEFAULT);
        INetConnection *    pconn = NULL;
        INetConnection *    pconnCur = NULL;
        INT                 cconn = 0;

        while (SUCCEEDED(hr) && (S_OK == (ncIter.HrNext(&pconn))))
        {
            ReleaseObj(pconnCur);
            cconn++;
            AddRefObj(pconnCur = pconn);
            ReleaseObj(pconn);
        }

        if (cconn > 1)
        {
            // if more than one connection found, release last one we had
            ReleaseObj(pconnCur);
            hr = S_OK;
        }
        else if (cconn == 0)
        {
            ReleaseObj(pconnCur);
            hr = S_FALSE;
        }
        else    // conn == 1
        {
            *ppconn = pconnCur;
            hr = S_OK;
        }

        ReleaseObj(pconMan);
    }

    TraceError("HrCountConnections", (hr == S_FALSE) ? S_OK : hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrHandleStaticIpDependency
//
//  Purpose:    Handles the need that some components have that requires
//              at least one adapter using a static IP address before they
//              can be installed properly.
//
//  Arguments:
//      pnocd   [in]    Pointer to NETOC data
//
//  Returns:    S_OK if success, Win32 HRESULT error code otherwise.
//
//  Author:     danielwe   19 Jun 1997
//
//  Notes:
//

HRESULT HrHandleStaticIpDependency(PNETOCDATA pnocd)
{
    HRESULT     hr = S_OK;
    static BOOL fFirstInvocation = TRUE;

    // bug 25841. This function is called during installation of DNS, DHCP, 
    // and WINS. If all three are being installed togetther then this ends
    // up showing the same error message thrice when one would suffice.

    if( fFirstInvocation )
    {
        fFirstInvocation = FALSE;
    }
    else
    {
        return hr;
    }

    // We handle "attended" and "unattended" setup mode through ReportErrorHr
    {
        BOOL        fChangesApplied = FALSE;
        INetCfg *   pnc = NULL;

        Assert(pnocd);
        //Assert(g_ocmData.hwnd);

        hr = HrOcGetINetCfg(pnocd, FALSE, &pnc);
        if (SUCCEEDED(hr))
        {
            hr = HrVerifyStaticIPPresent(pnc);
            if (hr == S_FALSE)
            {
                INetConnectionCommonUi *    pcommUi;
                INetConnection *            pconn = NULL;

                hr = HrCountConnections(&pconn);
                if (S_OK == hr)
                {
                    // One or more connections found

                    // Report message to user indicating that she has to
                    // configure at least one adapter with a static IP address
                    // before we can continue.
                    ReportErrorHr(hr, 
                                  IDS_OC_NEED_STATIC_IP, 
                                  g_ocmData.hwnd, 
                                  pnocd->strDesc.c_str());

                    // Try to fix it if we are in "attended" mode or
                    // we have the /z:netoc_show_unattended_messages options flag set.
                    if ((!(g_ocmData.sic.SetupData.OperationFlags & SETUPOP_BATCH)) ||
                        (g_ocmData.fShowUnattendedMessages))
                    {
                        hr = CoCreateInstance(CLSID_ConnectionCommonUi, NULL,
                                              CLSCTX_INPROC | CLSCTX_NO_CODE_DOWNLOAD,
                                              IID_INetConnectionCommonUi,
                                              reinterpret_cast<LPVOID *>(&pcommUi));

                        TraceHr(ttidError, FAL, hr, FALSE, "CoCreateInstance");

                        if (SUCCEEDED(hr))
                        {
                            if (pconn)
                            {
                                // Exactly one connection found
                                hr = pcommUi->ShowConnectionProperties(g_ocmData.hwnd,
                                                                       pconn);
                                if (S_OK == hr)
                                {
                                    fChangesApplied = TRUE;
                                }
                                else if (FAILED(hr))
                                {
                                    // Eat the error since we can't do anything about it
                                    // anyway.
                                    TraceError("HrHandleStaticIpDependency - "
                                               "ShowConnectionProperties", hr);
                                    hr = S_OK;
                                }
                            }
                            else
                            {
                                // More than one connection found
                                if (SUCCEEDED(hr))
                                {
                                    NETCON_CHOOSECONN   chooseCon = {0};

                                    chooseCon.lStructSize = sizeof(NETCON_CHOOSECONN);
                                    chooseCon.hwndParent = g_ocmData.hwnd;
                                    chooseCon.dwTypeMask = NCCHT_LAN;
                                    chooseCon.dwFlags    = NCCHF_DISABLENEW;

                                    hr = pcommUi->ChooseConnection(&chooseCon, NULL);
                                    if (SUCCEEDED(hr))
                                    {
                                        fChangesApplied = TRUE;
                                    }
                                    else
                                    {
                                        // Eat the error since we can't do anything about it
                                        // anyway.
                                        TraceError("HrHandleStaticIpDependency - "
                                                   "ChooseConnection", hr);
                                        hr = S_OK;
                                    }
                                }
                            }

                            ReleaseObj(pcommUi);
                        }

                        ReleaseObj(pconn);

                        if (SUCCEEDED(hr))
                        {
                            // Don't bother checking again if they never
                            // made any changes

                            if (!fChangesApplied ||
                                (S_FALSE == (hr = HrVerifyStaticIPPresent(pnc))))
                            {
                                // Geez, still no static IP address available.
                                // Report another message scolding the user for
                                // not following directions.
                                ReportErrorHr(hr, 
                                              IDS_OC_STILL_NO_STATIC_IP, 
                                              g_ocmData.hwnd, 
                                              pnocd->strDesc.c_str());
                                hr = S_OK;
                            }
                        }
                    }
                    else
                    {
                        // Just report the error as would have happened when the
                        // user did not correct it.
                        ReportErrorHr(hr, 
                                      IDS_OC_STILL_NO_STATIC_IP, 
                                      g_ocmData.hwnd, 
                                      pnocd->strDesc.c_str());
                        TraceTag(ttidNetOc, "Not handling static IP dependency for %S "
                                 "because we're in unattended mode", pnocd->strDesc.c_str());
                    }
                }
            }

            hr = HrUninitializeAndReleaseINetCfg(TRUE, pnc, FALSE);
        }
    }

    TraceError("HrHandleStaticIpDependency", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOcGetINetCfg
//
//  Purpose:    Obtains an INetCfg to work with
//
//  Arguments:
//      pnocd      [in]     OC Data
//      fWriteLock [in]     TRUE if write lock should be acquired, FALSE if
//                          not.
//      ppnc       [out]    Returns INetCfg pointer
//
//  Returns:    S_OK if success, OLE or Win32 error if failed. ERROR_CANCELLED
//              is returned if INetCfg is locked and the users cancels.
//
//  Author:     danielwe   18 Dec 1997
//
//  Notes:
//
HRESULT HrOcGetINetCfg(PNETOCDATA pnocd, BOOL fWriteLock, INetCfg **ppnc)
{
    HRESULT     hr = S_OK;
    PWSTR      pszDesc;
    BOOL        fInitCom = TRUE;

    Assert(ppnc);
    *ppnc = NULL;

top:

    AssertSz(!*ppnc, "Can't have valid INetCfg here!");

    hr = HrCreateAndInitializeINetCfg(&fInitCom, ppnc, fWriteLock, 0,
                                      SzLoadIds(IDS_OC_CAPTION), &pszDesc);
    if ((hr == NETCFG_E_NO_WRITE_LOCK) && !pnocd->fCleanup)
    {
        // See if we are in "attended" mode or
        // we have the /z:netoc_show_unattended_messages options flag set.
        if ((g_ocmData.sic.SetupData.OperationFlags & SETUPOP_BATCH) &&
            (!g_ocmData.fShowUnattendedMessages))
        {
            // "Unattended" mode, just report error
            ReportEventHrString(pnocd->strDesc.c_str(),
                                IDS_OC_CANT_GET_LOCK,
                                pszDesc ? pszDesc : SzLoadIds(IDS_OC_GENERIC_COMP)); 

            CoTaskMemFree(pszDesc);

            hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
        }
        else
        {
            // "Attended mode", so interact with user
            int     nRet;

            nRet = NcMsgBoxMc(g_ocmData.hwnd, IDS_OC_CAPTION, IDS_OC_CANT_GET_LOCK,
                              MB_RETRYCANCEL | MB_DEFBUTTON1 | MB_ICONWARNING,
                              pnocd->strDesc.c_str(),
                              pszDesc ? pszDesc : SzLoadIds(IDS_OC_GENERIC_COMP));

            CoTaskMemFree(pszDesc);

            if (IDRETRY == nRet)
            {
                goto top;
            }
            else
            {
                hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
            }
        }

    }

    TraceError("HrOcGetINetCfg", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netoc\netoc.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N E T O C . H
//
//  Contents:   Functions for handling installation and removal of optional
//              networking components.
//
//  Notes:
//
//  Author:     danielwe   28 Apr 1997
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _NETOC_H
#define _NETOC_H

#ifndef _OCMANAGE_H
#define _OCMANAGE_H
#include <ocmanage.h>   // OC Manager header
#endif //!_OCMANAGE_H

#include "netcon.h"
#include "ncstring.h"
#include "netcfgx.h"
#include "netocmsg.h"   


//
// Names of the Optional Networking Service event log
#define NETOC_REGISTRY_NAME      TEXT("SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\")
#define NETOC_SERVICE_NAME       TEXT("Network Optional Components")
#define NETOC_DLL_NAME           TEXT("%SystemRoot%\\System32\\Setup\\netoc.dll")


// Severity code masks
#define STATUS_SEVERITY_SHIFT       0x1e
#define STATUS_SEVERITY_MASK        0xc0000000
#define STATUS_SEVERITY_VALUE(x)    (((x) & STATUS_SEVERITY_MASK) >> STATUS_SEVERITY_SHIFT)


// Special flag to indicate that we can display messages in unattended mode
#define SHOW_UNATTENDED_MESSAGES    TEXT("netoc_show_unattended_messages")


enum EINSTALL_TYPE
{
    IT_UNKNOWN          =   0x0,
    IT_INSTALL          =   0x1,
    IT_UPGRADE          =   0x2,
    IT_REMOVE           =   0x3,
    IT_NO_CHANGE        =   0x4,
};

struct OCM_DATA
{
    INetCfg *               pnc;    // Uh, I assume we all know what this is.
    HWND                    hwnd;   // hwnd of parent window for any UI
    SETUP_INIT_COMPONENT    sic;    // initialization data
    HINF                    hinfAnswerFile;
    BOOL                    fErrorReported;
    BOOL                    fNoDepends;
    BOOL                    fShowUnattendedMessages;

    OCM_DATA()
    {
        hwnd = NULL;
        hinfAnswerFile = NULL;
        pnc = NULL;
        fErrorReported = FALSE;
        fNoDepends = FALSE;
        fShowUnattendedMessages = FALSE;
    }
};

//+---------------------------------------------------------------------------
//
//  NetOCData - Combines all of the standard parameters that we were
//              previously passing all over the place. This will keep
//              us from having to continually change all of our prototypes
//              when we need other info in ALL functions, and will prevent
//              us from instantiating objects such as INetCfg in multiple
//              places
//
//  Notes:      Some members of this structure will not be initialized right away,
//              but will be filled in when first needed.
//
//  Author:     jeffspr   24 Jul 1997
//
struct NetOCData
{
    PCWSTR                  pszSection;
    PWSTR                   pszComponentId;
    tstring                 strDesc;
    EINSTALL_TYPE           eit;
    BOOL                    fCleanup;
    BOOL                    fFailedToInstall;
    HINF                    hinfFile;

    NetOCData()
    {
        eit = IT_UNKNOWN;
        pszSection = NULL;
        fCleanup = FALSE;
        fFailedToInstall = FALSE;
        hinfFile = NULL;
        pszComponentId = NULL;
    }

    ~NetOCData()
    {
        delete [] pszComponentId;
    }
};

typedef struct NetOCData    NETOCDATA;
typedef struct NetOCData *  PNETOCDATA;

// Extension proc prototype
//
typedef HRESULT (*PFNOCEXTPROC) (PNETOCDATA pnocd, UINT uMsg, WPARAM wParam,
                                 LPARAM lParam);

struct OCEXTPROCS
{
    PCWSTR          pszComponentName;
    PFNOCEXTPROC    pfnHrOcExtProc;
};

// Message handler constants
//
const UINT NETOCM_QUERY_CHANGE_SEL_STATE    = 1000;
const UINT NETOCM_POST_INSTALL              = 1001;
const UINT NETOCM_PRE_INF                   = 1002;
const UINT NETOCM_QUEUE_FILES               = 1003;

extern OCM_DATA g_ocmData;

//
// Public functions
//

HRESULT HrHandleStaticIpDependency(PNETOCDATA pnocd);
HRESULT HrOcGetINetCfg(PNETOCDATA pnocd, BOOL fWriteLock, INetCfg **ppnc);

#endif //!_NETOC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netoc\netocx.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N E T O C X . H
//
//  Contents:   Custom installation functions for the various optional
//              components.
//
//  Notes:
//
//  Author:     danielwe   19 Jun 1997
//
//----------------------------------------------------------------------------

#ifndef _NETOCX_H
#define _NETOCX_H
#pragma once

HRESULT HrOcWinsOnInstall(PNETOCDATA pnocd);
HRESULT HrOcExtWINS(PNETOCDATA pnocd, UINT uMsg,
                    WPARAM wParam, LPARAM lParam);
HRESULT HrOcDnsOnInstall(PNETOCDATA pnocd);
HRESULT HrOcExtDNS(PNETOCDATA pnocd, UINT uMsg,
                    WPARAM wParam, LPARAM lParam);
HRESULT HrOcSnmpOnInstall(PNETOCDATA pnocd);
HRESULT HrOcExtSNMP(PNETOCDATA pnocd, UINT uMsg,
                    WPARAM wParam, LPARAM lParam);
HRESULT HrSetWinsServiceRecoveryOption(PNETOCDATA pnocd);

#endif //!_NETOCX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netoc\pch.h ===
#pragma once

#define COM_NO_WINDOWS_H
#define RPC_NO_WINDOWS_H
#define NOCOMM
#define NOCRYPT
#define NOHELP
#define NOICONS
#define NOIME
#define NOMCX
#define NOMDI
#define NOMENUS
#define NOMETAFILE
#define NOSOUND
#define NOWH
#define NOWINABLE
#define NOWINRES

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <objbase.h>
#include <oleauto.h>

#include <cfgmgr32.h>
#include <devguid.h>
#include <infstr.h>
#include <setupapi.h>
#include <shellapi.h>
#include <shlobj.h>
#include <stdio.h>

// Fusion support
#include "shfusion.h"

#include "ncmem.h"
#include "ncbase.h"
#include "ncdebug.h"
#include "ncdefine.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netoc\netocx.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N E T O C X . C P P
//
//  Contents:   Custom installation functions for various optional
//              components.
//
//  Notes:
//
//  Author:     danielwe   19 Jun 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "netoc.h"
#include "netocx.h"
#include "ncmisc.h"
#include "ncreg.h"
#include "ncsetup.h"
#include "ncsvc.h"
#include "snmpocx.h"

static const WCHAR c_szFileSpec[] = L"*.*";
static const WCHAR c_szWinsPath[] = L"\\wins";
static const WCHAR c_szRegKeyWinsParams[] = L"System\\CurrentControlSet\\Services\\WINS\\Parameters";
static const WCHAR c_szRegValWinsBackupDir[] = L"BackupDirPath";

// data specific to the removal of obsoleted subagents during upgrades
// Removal of ACS Subagent on upgrade
const WCHAR c_wszAcsRegKey[] = L"SOFTWARE\\Microsoft\\ACS";
const WCHAR c_wszAcsRegValData[] = L"SOFTWARE\\Microsoft\\ACS\\CurrentVersion";
// Removal of IAS Subagent on upgrade
const WCHAR c_wszIasRegKey[] = L"SOFTWARE\\Microsoft\\IASAgent";
const WCHAR c_wszIasRegValData[] = L"SOFTWARE\\Microsoft\\IASAgent\\CurrentVersion";
// Removal of IPX Subagent on upgrade
const WCHAR c_wszIPXMibAgentKey[] = L"SOFTWARE\\Microsoft\\IPXMibAgent";
const WCHAR c_wszIPXMibAgentValData[] = L"SOFTWARE\\Microsoft\\IPXMibAgent\\CurrentVersion";

BOOL FRunningOnWorkstationOrLess()
{
    OSVERSIONINFOEXW verInfo = {0};
    ULONGLONG ConditionMask = 0;
    
    verInfo.dwOSVersionInfoSize = sizeof(verInfo);
    verInfo.wProductType = VER_NT_WORKSTATION;
    VER_SET_CONDITION(ConditionMask, VER_PRODUCT_TYPE, VER_LESS_EQUAL);       
    return VerifyVersionInfo(&verInfo, VER_PRODUCT_TYPE, ConditionMask);
}
// add your entry here if you want to remove your subagent during upgrade
SUBAGENT_REMOVAL_INFO c_sri[] =
{
    // removal of ACS Subagent on all SKU
    {c_wszAcsRegKey, c_wszAcsRegValData, NULL},  
    // removal of IAS Subagent if we're running on SKU which is <= Workstation
    {c_wszIasRegKey, c_wszIasRegValData, FRunningOnWorkstationOrLess},
    // removal of IPX Subagent on all SKU
    {c_wszIPXMibAgentKey, c_wszIPXMibAgentValData, NULL}   
};

//+---------------------------------------------------------------------------
//
//  Function:   HrOcExtWINS
//
//  Purpose:    NetOC external message handler
//
//  Arguments:
//      pnocd  []
//      uMsg   []
//      wParam []
//      lParam []
//
//  Returns:
//
//  Author:     danielwe   17 Sep 1998
//
//  Notes:
//
HRESULT HrOcExtWINS(PNETOCDATA pnocd, UINT uMsg,
                    WPARAM wParam, LPARAM lParam)
{
    HRESULT     hr = S_OK;

    Assert(pnocd);

    switch (uMsg)
    {
    case NETOCM_POST_INSTALL:
        hr = HrOcWinsOnInstall(pnocd);
        break;
    }

    TraceError("HrOcExtWINS", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOcExtDNS
//
//  Purpose:    NetOC external message handler
//
//  Arguments:
//      pnocd  []
//      uMsg   []
//      wParam []
//      lParam []
//
//  Returns:
//
//  Author:     danielwe   17 Sep 1998
//
//  Notes:
//
HRESULT HrOcExtDNS(PNETOCDATA pnocd, UINT uMsg,
                   WPARAM wParam, LPARAM lParam)
{
    HRESULT     hr = S_OK;

    Assert(pnocd);

    switch (uMsg)
    {
    case NETOCM_POST_INSTALL:
        hr = HrOcDnsOnInstall(pnocd);
        break;
    }

    TraceError("HrOcExtDNS", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOcExtSNMP
//
//  Purpose:    NetOC external message handler
//
//  Arguments:
//      pnocd  []
//      uMsg   []
//      wParam []
//      lParam []
//
//  Returns:
//
//  Author:     danielwe   17 Sep 1998
//
//  Notes:
//
HRESULT HrOcExtSNMP(PNETOCDATA pnocd, UINT uMsg,
                    WPARAM wParam, LPARAM lParam)
{
    HRESULT     hr = S_OK;

    Assert(pnocd);

    switch (uMsg)
    {
    case NETOCM_POST_INSTALL:
        hr = HrOcSnmpOnInstall(pnocd);
        break;
    }

    TraceError("HrOcExtSNMP", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrSetWinsServiceRecoveryOption
//
//  Purpose:    Sets the recovery options for the WINS service
//
//  Arguments:
//      pnocd [in]  Pointer to NETOC data.
//
//  Returns:    S_OK if successful, Win32 error otherwise.
//
//  Author:     danielwe   26 May 1999
//
//  Notes:
//
HRESULT HrSetWinsServiceRecoveryOption(PNETOCDATA pnocd)
{
    CServiceManager     sm;
    CService            service;
    HRESULT             hr = S_OK;

    SC_ACTION   sra [4] =
    {
        { SC_ACTION_RESTART, 15*1000 }, // restart after 15 seconds
        { SC_ACTION_RESTART, 15*1000 }, // restart after 15 seconds
        { SC_ACTION_RESTART, 15*1000 }, // restart after 15 seconds
        { SC_ACTION_NONE,    30*1000 },
    };

    SERVICE_FAILURE_ACTIONS sfa =
    {
        60 * 60,        // dwResetPeriod is 1 hr
        L"",            // no reboot message
        L"",            // no command to execute
        4,              // 3 attempts to restart the server and stop after that
        sra
    };

    hr = sm.HrOpenService(&service, L"WINS");
    if (S_OK == hr)
    {
        hr = service.HrSetServiceRestartRecoveryOption(&sfa);
    }

    TraceError("HrSetWinsServiceRecoveryOption", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOcWinsOnInstall
//
//  Purpose:    Called by optional components installer code to handle
//              additional installation requirements for WINS Server.
//
//  Arguments:
//      pnocd           [in]   Pointer to NETOC data.
//
//  Returns:    S_OK if successful, Win32 error otherwise.
//
//  Author:     danielwe   19 Jun 1997
//
//  Notes:
//
HRESULT HrOcWinsOnInstall(PNETOCDATA pnocd)
{
    HRESULT     hr = S_OK;

    if (pnocd->eit == IT_INSTALL)
    {
        hr = HrHandleStaticIpDependency(pnocd);
        if (SUCCEEDED(hr))
        {
            hr = HrSetWinsServiceRecoveryOption(pnocd);
        }
    }
    else if (pnocd->eit == IT_UPGRADE)
    {
        HKEY    hkey;

        // Upgrade the BackupDirPath value from whatever it was to
        // REG_EXPAND_SZ
        hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegKeyWinsParams,
                            KEY_ALL_ACCESS, &hkey);
        if (SUCCEEDED(hr))
        {
            DWORD   dwType;
            LPBYTE  pbData = NULL;
            DWORD   cbData;

            hr = HrRegQueryValueWithAlloc(hkey, c_szRegValWinsBackupDir,
                                          &dwType, &pbData, &cbData);
            if (SUCCEEDED(hr))
            {
                switch (dwType)
                {
                case REG_MULTI_SZ:
                case REG_SZ:
                    PWSTR  pszNew;

                    // This cast will give us the first string of the MULTI_SZ
                    pszNew = reinterpret_cast<PWSTR>(pbData);

                    TraceTag(ttidNetOc, "Resetting %S to %S",
                             c_szRegValWinsBackupDir, pszNew);

                    hr = HrRegSetSz(hkey, c_szRegValWinsBackupDir, pszNew);
                    break;
                }

                MemFree(pbData);
            }

            RegCloseKey(hkey);
        }

        // This process is non-fatal

        TraceError("HrOcWinsOnInstall - Failed to upgrade BackupDirPath - "
                   "non-fatal", hr);

        // overwrite hr on purpose
        hr = HrSetWinsServiceRecoveryOption(pnocd);
    }
    else if (pnocd->eit == IT_REMOVE)
    {
        WCHAR   szWinDir[MAX_PATH + celems(c_szWinsPath)];

        if (GetSystemDirectory(szWinDir, MAX_PATH + 1))
        {
            lstrcatW(szWinDir, c_szWinsPath);

            // szWinDir should now be something like c:\winnt\system32\wins
            hr = HrDeleteFileSpecification(c_szFileSpec, szWinDir);
        }
        else
        {
            hr = HrFromLastWin32Error();
        }

        if (FAILED(hr))
        {
            TraceError("HrOcWinsOnInstall: failed to delete files, continuing...",
                       hr);
            hr = S_OK;
        }
    }

    TraceError("HrOcWinsOnInstall", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOcDnsOnInstall
//
//  Purpose:    Called by optional components installer code to handle
//              additional installation requirements for DNS Server.
//
//  Arguments:
//      pnocd           [in]   Pointer to NETOC data.
//
//  Returns:    S_OK if successful, Win32 error otherwise.
//
//  Author:     danielwe   19 Jun 1997
//
//  Notes:
//
HRESULT HrOcDnsOnInstall(PNETOCDATA pnocd)
{
    HRESULT     hr = S_OK;

    if (pnocd->eit == IT_INSTALL)
    {
        hr = HrHandleStaticIpDependency(pnocd);
    }

    TraceError("HrOcDnsOnInstall", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOcSnmpAgent
//
//  Purpose:    Installs the SNMP agent parameters
//
//  Arguments:
//      pnocd           [in]   Pointer to NETOC data.
//
//  Returns:    S_OK if successful, Win32 error otherwise.
//
//  Author:     FlorinT 10/05/1998
//
//  Notes:
//
HRESULT HrOcSnmpAgent(PNETOCDATA pnocd)
{
    tstring tstrVariable;
    PWSTR  pTstrArray = NULL;
    HRESULT hr;

    // Read SNMP answer file params and save them to the registry

    //-------- read the 'Contact Name' parameter
    hr = HrSetupGetFirstString(g_ocmData.hinfAnswerFile,
                               AF_SECTION,
                               AF_SYSNAME,
                               &tstrVariable);
    if (hr == S_OK)
    {
        hr = SnmpRegWriteTstring(REG_KEY_AGENT,
                                 SNMP_CONTACT,
                                 tstrVariable);
    }

    if (hr == S_OK || hr == HRESULT_FROM_SETUPAPI(ERROR_LINE_NOT_FOUND))
    {
        //-------- read the 'Location' parameter
        hr = HrSetupGetFirstString(g_ocmData.hinfAnswerFile,
                                   AF_SECTION,
                                   AF_SYSLOCATION,
                                   &tstrVariable);
    }

    if (hr == S_OK)
    {
        hr = SnmpRegWriteTstring(REG_KEY_AGENT,
                                 SNMP_LOCATION,
                                 tstrVariable);
    }

    if (hr == S_OK || hr == HRESULT_FROM_SETUPAPI(ERROR_LINE_NOT_FOUND))
    {
        //-------- read the 'Service' parameter
        hr = HrSetupGetFirstMultiSzFieldWithAlloc(g_ocmData.hinfAnswerFile,
                                                  AF_SECTION,
                                                  AF_SYSSERVICES,
                                                  &pTstrArray);
    }

    if (hr == S_OK)
    {
        DWORD dwServices = SnmpStrArrayToServices(pTstrArray);
        delete pTstrArray;
        hr = SnmpRegWriteDword(REG_KEY_AGENT,
                               SNMP_SERVICES,
                               dwServices);
    }

    return  (hr == HRESULT_FROM_SETUPAPI(ERROR_LINE_NOT_FOUND)) ? S_OK : hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOcSnmpTraps
//
//  Purpose:    Installs the traps SNMP parameters defined in the answer file
//
//  Arguments:
//      pnocd           [in]   Pointer to NETOC data.
//
//  Returns:    S_OK if successful, Win32 error otherwise.
//
//  Author:     FlorinT 10/05/1998
//
//  Notes:
//
HRESULT HrOcSnmpTraps(PNETOCDATA pnocd)
{
    tstring tstrVariable;
    PWSTR  pTstrArray = NULL;
    HRESULT hr;

    // Read SNMP answer file params and save them to the registry

    //-------- read the 'Trap community' parameter
    hr = HrSetupGetFirstString(g_ocmData.hinfAnswerFile,
                               AF_SECTION,
                               AF_TRAPCOMMUNITY,
                               &tstrVariable);

    if (hr == S_OK)
    {
        //-------- read the 'Trap destinations' parameter
        HrSetupGetFirstMultiSzFieldWithAlloc(g_ocmData.hinfAnswerFile,
                                             AF_SECTION,
                                             AF_TRAPDEST,
                                             &pTstrArray);

        hr = SnmpRegWriteTraps(tstrVariable, pTstrArray);
        delete pTstrArray;
    }

    return  (hr == HRESULT_FROM_SETUPAPI(ERROR_LINE_NOT_FOUND)) ? S_OK : hr;
}

// bitmask values for 'pFlag' parameter for HrOcSnmpSecurity()
// they indicate which of the SNMP SECuritySETtings were defined through
// the answerfile.
#define SNMP_SECSET_COMMUNITIES     0x00000001
#define SNMP_SECSET_AUTHFLAG        0x00000002
#define SNMP_SECSET_PERMMGR         0x00000004

//+---------------------------------------------------------------------------
//
//  Function:   HrOcSnmpSecurituy
//
//  Purpose:    Installs the security SNMP parameters defined in the answer file
//
//  Arguments:
//      pnocd           [in]   Pointer to NETOC data.
//
//  Returns:    S_OK if successful, Win32 error otherwise.
//
//  Author:     FlorinT 10/05/1998
//
//  Notes:
//
HRESULT HrOcSnmpSecurity(PNETOCDATA pnocd, DWORD *pFlags)
{
    BOOL    bVariable = FALSE;
    PWSTR  pTstrArray = NULL;
    HRESULT hr;

    // Read SNMP answer file params and save them to the registry

    //-------- read the 'Accepted communities' parameter
    hr = HrSetupGetFirstMultiSzFieldWithAlloc(g_ocmData.hinfAnswerFile,
                                 AF_SECTION,
                                 AF_ACCEPTCOMMNAME,
                                 &pTstrArray);

    if (hr == S_OK)
    {
        if (pFlags)
            (*pFlags) |= SNMP_SECSET_COMMUNITIES;
        hr = SnmpRegWriteCommunities(pTstrArray);
        delete pTstrArray;
    }

    if (hr == S_OK || hr == HRESULT_FROM_SETUPAPI(ERROR_LINE_NOT_FOUND))
    {
        //-------- read the 'EnableAuthenticationTraps' parameter
        hr = HrSetupGetFirstStringAsBool(g_ocmData.hinfAnswerFile,
                                         AF_SECTION,
                                         AF_SENDAUTH,
                                         &bVariable);
        if (hr == S_OK)
        {
            if (pFlags)
                (*pFlags) |= SNMP_SECSET_AUTHFLAG;

            hr = SnmpRegWriteDword(REG_KEY_SNMP_PARAMETERS,
                                   REG_VALUE_AUTHENTICATION_TRAPS,
                                   bVariable);
        }
    }

    if (hr == S_OK || hr == HRESULT_FROM_SETUPAPI(ERROR_LINE_NOT_FOUND))
    {
        //-------- read the 'Permitted Managers' parameter
        hr = HrSetupGetFirstStringAsBool(g_ocmData.hinfAnswerFile,
                                         AF_SECTION,
                                         AF_ANYHOST,
                                         &bVariable);
    }

    if (hr == S_OK)
    {
        pTstrArray = NULL;

        // if not 'any host', get the list of hosts from the inf file
        if (bVariable == FALSE)
        {
            hr = HrSetupGetFirstMultiSzFieldWithAlloc(g_ocmData.hinfAnswerFile,
                                                      AF_SECTION,
                                                      AF_LIMITHOST,
                                                      &pTstrArray);
        }

        // at least clear up the 'permitted managers' list (bVariable = TRUE)
        // at most, write the allowed managers to the registry
        if (hr == S_OK)
        {
            if (pFlags)
                (*pFlags) |= SNMP_SECSET_PERMMGR;

            hr = SnmpRegWritePermittedMgrs(bVariable, pTstrArray);
        }

        if (pTstrArray != NULL)
            delete pTstrArray;
    }

    return  (hr == HRESULT_FROM_SETUPAPI(ERROR_LINE_NOT_FOUND)) ? S_OK : hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOcSnmpDefPermittedManagers
//
//  Purpose:    Installs the default SNMP PermittedManagers.
//
//  Arguments:
//      
//
//  Returns:    S_OK if successful, Win32 error otherwise.
//
//  Author:     FrankLi 4/22/2002
//
//  Notes:
//
HRESULT HrOcSnmpDefPermittedManagers()
{
    HRESULT hr = S_OK;

    hr = SnmpRegWritePermittedMgrs(FALSE, SEC_DEF_PERMITTED_MANAGERS);

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOcSnmpUpgParams
//
//  Purpose:    makes all the registry changes needed when upgrading to Win2K
//
//  Arguments:
//      pnocd           [in]   Pointer to NETOC data.
//
//  Returns:    S_OK if successful, Win32 error otherwise.
//
//  Author:     FlorinT 10/05/1998
//
//  Notes:
//
HRESULT HrOcSnmpUpgParams(PNETOCDATA pnocd)
{
    HRESULT hr = S_OK;

    hr = SnmpRegUpgEnableAuthTraps();

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOcSnmpOnInstall
//
//  Purpose:    Called by optional components installer code to handle
//              additional installation requirements for SNMP.
//
//  Arguments:
//      pnocd           [in]   Pointer to NETOC data.
//
//  Returns:    S_OK if successful, Win32 error otherwise.
//
//  Author:     danielwe   15 Sep 1998
//
//  Notes:
//
HRESULT HrOcSnmpOnInstall(PNETOCDATA pnocd)
{
    HRESULT     hr = S_OK;
    DWORD       secFlags = 0;

    if ((pnocd->eit == IT_INSTALL) | (pnocd->eit == IT_UPGRADE))
    {
        // --ft:10/14/98-- bug #237203 - success if there is no answer file!
        if (g_ocmData.hinfAnswerFile != NULL)
        {
            hr = HrOcSnmpSecurity(pnocd, &secFlags);
            if (hr == S_OK)
                hr = HrOcSnmpTraps(pnocd);
            if (hr == S_OK)
                hr = HrOcSnmpAgent(pnocd);
        }
    }

    // configure '1:REG_SZ:localhost' under PermittedManagers subkey only if:
    // 1. fresh installion without answer file 
    // OR
    // 2. fresh installion with answer file but the answer file has the
    //    following characteristics on configuring PermittedManagers: 
    //    a. No "Any_Host" AND "Limit_Host" keys in answer file 
    //    OR
    //    b. "Any_Host = NO" AND there is no Limit_Host key in answer file
    if (hr == S_OK && pnocd->eit == IT_INSTALL && !(secFlags & SNMP_SECSET_PERMMGR))
    {
       hr = HrOcSnmpDefPermittedManagers();
    }


    // on upgrade only 
    // - look at the old EnableAuthTraps value and copy it to the new location
    // - see if we have to remove some subagent configuration
    if (hr == S_OK && pnocd->eit == IT_UPGRADE)
    {
        // don't care here about the return code. The upgrade from W2K to W2K fail here and we
        // don't need to fail in this case. Any failure in upgrading the setting from NT4 to W2K
        // will result in having the default parameter.
        HrOcSnmpUpgParams(pnocd);
        SnmpRemoveSubAgents(c_sri, celems(c_sri));
    }

    if (hr == S_OK && (pnocd->eit == IT_INSTALL || pnocd->eit == IT_UPGRADE) )
    {
        // set admin dacl to ValidCommunities subkey
        hr = SnmpAddAdminAclToKey(REG_KEY_VALID_COMMUNITIES);
        if (hr == S_OK)
        {
            // set admin dacl to PermittedManagers subkey
            hr = SnmpAddAdminAclToKey(REG_KEY_PERMITTED_MANAGERS);
        }   
    }

    TraceError("HrOcSnmpOnInstall", hr);
    return (hr == HRESULT_FROM_SETUPAPI(ERROR_SECTION_NOT_FOUND)) ? S_OK : hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netoc\resource.h ===
#define IDS_OC_STRINGBASE                       500

#define IDS_OC_CAPTION                          IDS_OC_STRINGBASE +  18
#define UNUSED_XX1                              IDS_OC_STRINGBASE +  26
#define UNUSED_XX2                              IDS_OC_STRINGBASE +  27

#define IDS_OC_GENERIC_COMP                     IDS_OC_STRINGBASE +  29

#define IDS_OC_CMAK_STPTITLE                    IDS_OC_STRINGBASE +  35
#define IDS_OC_CMAKPROGGROUP                    IDS_OC_STRINGBASE +  36
#define IDS_OC_CMAKLINK                         IDS_OC_STRINGBASE +  37
#define IDS_OC_PBS                              IDS_OC_STRINGBASE +  40

#define IDS_OC_SFM_FOLDNAMENT4                  IDS_OC_STRINGBASE +  41
#define IDS_OC_SFM_FOLDNAMENT5                  IDS_OC_STRINGBASE +  42
#define IDS_OC_SFM_VOLNAME                      IDS_OC_STRINGBASE +  43
#define IDS_OC_SFM_UAM_INSTALLER                IDS_OC_STRINGBASE +  44
#define IDS_OC_COMMON_FILES                     IDS_OC_STRINGBASE +  46
#define IDS_OC_MS_SHARED_DAO                    IDS_OC_STRINGBASE +  47
#define IDS_OC_NTOP4_GROUPNAME                  IDS_OC_STRINGBASE +  48
#define IDS_OC_ICS_GROUPNAME                    IDS_OC_STRINGBASE +  49
#define IDS_OC_OLD_IEAK_DOCDIR                  IDS_OC_STRINGBASE +  50

#define IDS_OC_SFM_APPLESHARE_FOLDER            IDS_OC_STRINGBASE +  52

#define IDS_OC_ADMIN_TOOLS                      IDS_OC_STRINGBASE +  54
#define IDS_OC_PBA_DESC                         IDS_OC_STRINGBASE +  55
// ISSUE-2003/01/21-SumitC IDS_OC_PB_DSN_NAME is no longer needed, but it's too close to ship to touch resources
#define IDS_OC_PB_DSN_NAME                      IDS_OC_STRINGBASE +  57

#define IDI_PNPU_CMAK    99
#define IDI_PNPU_PBA    98
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netoc\sfmsec.h ===
#ifndef _SFMSEC_H
#define _SFMSEC_H

#pragma once

HRESULT HrSecureSfmDirectory(PCWSTR wszPath);

#endif //!_SFMSEC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netoc\sfmsec.cpp ===
#include "pch.h"
#pragma hdrstop

#include "sfmsec.h"

#define AFP_MIN_ACCESS          (FILE_READ_ATTRIBUTES | READ_CONTROL)

#define AFP_READ_ACCESS         (READ_CONTROL           |      \
                                                        FILE_READ_ATTRIBUTES |  \
                                                        FILE_TRAVERSE            |      \
                                                        FILE_LIST_DIRECTORY      |      \
                                                        FILE_READ_EA)

#define AFP_WRITE_ACCESS        (FILE_ADD_FILE           |      \
                                                        FILE_ADD_SUBDIRECTORY|  \
                                                        FILE_WRITE_ATTRIBUTES|  \
                                                        FILE_WRITE_EA            |      \
                                                        DELETE)

#define AFP_OWNER_ACCESS        (WRITE_DAC                        | \
                                                         WRITE_OWNER)



SID     AfpSidWorld     = { 1, 1, SECURITY_WORLD_SID_AUTHORITY, SECURITY_WORLD_RID };
SID     AfpSidNull      = { 1, 1, SECURITY_NULL_SID_AUTHORITY, SECURITY_NULL_RID };
SID     AfpSidSystem    = { 1, 1, SECURITY_NT_AUTHORITY, SECURITY_LOCAL_SYSTEM_RID };
SID     AfpSidCrtrOwner = { 1, 1, SECURITY_CREATOR_SID_AUTHORITY, SECURITY_CREATOR_OWNER_RID };
SID     AfpSidCrtrGroup = { 1, 1, SECURITY_CREATOR_SID_AUTHORITY, SECURITY_CREATOR_GROUP_RID };

/***    afpAddAceToAcl
 *
 *      Build an Ace corres. to the Sid(s) and mask and add these to the Acl. It is
 *      assumed that the Acl has space for the Aces. If the Mask is 0 (i.e. no access)
 *      the Ace added is a DENY Ace, else a ALLOWED ACE is added.
 */
PACCESS_ALLOWED_ACE
afpAddAceToAcl(
        IN  PACL                                pAcl,
        IN  PACCESS_ALLOWED_ACE pAce,
        IN  ACCESS_MASK                 Mask,
        IN  PSID                                pSid,
        IN  PSID                                pSidInherit OPTIONAL
)
{
        NTSTATUS Status = STATUS_SUCCESS;

        // Add a vanilla ace
        pAcl->AceCount ++;
        pAce->Mask = Mask | SYNCHRONIZE | AFP_MIN_ACCESS;
        pAce->Header.AceFlags = 0;
        pAce->Header.AceType = ACCESS_ALLOWED_ACE_TYPE;
        pAce->Header.AceSize = (USHORT)(sizeof(ACE_HEADER) + sizeof(ACCESS_MASK) +
                                                        RtlLengthSid(pSid));
        Status = RtlCopySid(RtlLengthSid(pSid), (PSID)(&pAce->SidStart), pSid);
        if (!NT_SUCCESS(Status))
        {
            ASSERT(0);
        }

        // Now add an inherit ace
        //

        pAce = (PACCESS_ALLOWED_ACE)((PBYTE)pAce + pAce->Header.AceSize);
        pAcl->AceCount ++;
        pAce->Mask = Mask | SYNCHRONIZE | AFP_MIN_ACCESS;
        pAce->Header.AceFlags = CONTAINER_INHERIT_ACE |
                                                        OBJECT_INHERIT_ACE |
                                                        INHERIT_ONLY_ACE;
        pAce->Header.AceType = ACCESS_ALLOWED_ACE_TYPE;
        pAce->Header.AceSize = (USHORT)(sizeof(ACE_HEADER) + sizeof(ACCESS_MASK) +
                                                        RtlLengthSid(pSid));
        Status = RtlCopySid(RtlLengthSid(pSid), (PSID)(&pAce->SidStart), pSid);
        if (!NT_SUCCESS(Status))
        {
            ASSERT(0);
        }

        // Now add an inherit ace for the CreatorOwner/CreatorGroup
        if (ARGUMENT_PRESENT(pSidInherit))
        {
                pAce = (PACCESS_ALLOWED_ACE)((PBYTE)pAce + pAce->Header.AceSize);
                pAcl->AceCount ++;
                pAce->Mask = Mask | SYNCHRONIZE | AFP_MIN_ACCESS;
                pAce->Header.AceFlags = CONTAINER_INHERIT_ACE |
                                                                OBJECT_INHERIT_ACE |
                                                                INHERIT_ONLY_ACE;
                pAce->Header.AceType = ACCESS_ALLOWED_ACE_TYPE;
                pAce->Header.AceSize = (USHORT)(sizeof(ACE_HEADER) + sizeof(ACCESS_MASK) +
                                                                RtlLengthSid(pSidInherit));
                Status = RtlCopySid(RtlLengthSid(pSidInherit), (PSID)(&pAce->SidStart), pSidInherit);
                if (!NT_SUCCESS(Status))
                {
                    ASSERT(0);
                }
        }

        return ((PACCESS_ALLOWED_ACE)((PBYTE)pAce + pAce->Header.AceSize));
}

/***    afpMoveAces
 *
 *      Move a bunch of aces from the old security descriptor to the new security
 *      descriptor.
 */
PACCESS_ALLOWED_ACE
afpMoveAces(
	IN	PACL				pOldDacl,
	IN	PACCESS_ALLOWED_ACE	pAceStart,
	IN	PSID				pSidOldOwner,
	IN	PSID				pSidNewOwner,
	IN	PSID				pSidOldGroup,
	IN	PSID				pSidNewGroup,
	IN	BOOLEAN				DenyAces,
	IN	BOOLEAN				InheritedAces,
	IN	OUT PACL			pNewDacl
)
{
	USHORT				i;
	PACCESS_ALLOWED_ACE	pAceOld;
	PSID				pSidAce;

	for (i = 0, pAceOld = (PACCESS_ALLOWED_ACE)((PBYTE)pOldDacl + sizeof(ACL));
		 i < pOldDacl->AceCount;
		 i++, pAceOld = (PACCESS_ALLOWED_ACE)((PBYTE)pAceOld + pAceOld->Header.AceSize))
	{
		if (InheritedAces && ((pAceOld->Header.AceFlags & INHERITED_ACE) != INHERITED_ACE))
			continue;

		if ((!InheritedAces) && ((pAceOld->Header.AceFlags & INHERITED_ACE) == INHERITED_ACE))
			continue;

		// Note: All deny aces are ahead of the grant aces.
		if (DenyAces && (pAceOld->Header.AceType != ACCESS_DENIED_ACE_TYPE))
			break;

		if (!DenyAces && (pAceOld->Header.AceType == ACCESS_DENIED_ACE_TYPE))
			continue;

		pSidAce = (PSID)(&pAceOld->SidStart);
		if (!RtlEqualSid(pSidAce, &AfpSidWorld)		&&
                        !RtlEqualSid(pSidAce, &AfpSidCrtrOwner)	&&
                        !RtlEqualSid(pSidAce, &AfpSidCrtrGroup)	&&
                        !RtlEqualSid(pSidAce, pSidOldOwner)     &&
                        !RtlEqualSid(pSidAce, pSidNewOwner)     &&
                        !RtlEqualSid(pSidAce, pSidOldGroup)     &&
                        !RtlEqualSid(pSidAce, pSidNewGroup))
		{
			RtlCopyMemory(pAceStart, pAceOld, pAceOld->Header.AceSize);
                        pNewDacl->AclSize += pAceOld->Header.AceSize;
			pNewDacl->AceCount ++;
			pAceStart = (PACCESS_ALLOWED_ACE)((PBYTE)pAceStart +
													pAceStart->Header.AceSize);
		}
	}
	return pAceStart;
}


/***    FSfmSetUamSecurity
 *
 *      Set the permissions on this directory. Also optionally set the owner and
 *      group ids. For setting the owner and group ids verify if the user has the
 *      needed access. This access is however not good enough. We check for this
 *      access but do the actual setting of the permissions in the special server
 *      context (RESTORE privilege is needed).
 */
HRESULT HrSecureSfmDirectory(PCWSTR wszPath)
{
    HRESULT                 hr = S_OK;
    NTSTATUS                Status;
    DWORD                   SizeNeeded;
    PBYTE                   pBuffer = NULL;
    PBYTE                   pAbsSecDesc = NULL;
    PISECURITY_DESCRIPTOR   pSecDesc;
    SECURITY_INFORMATION    SecInfo = DACL_SECURITY_INFORMATION;
    PACL                    pDaclNew = NULL;
    PACCESS_ALLOWED_ACE     pAce;
    LONG                    SizeNewDacl;
    HANDLE                  DirHandle;
    PWSTR                   pDirPath = NULL;
    UNICODE_STRING          DirectoryName;
    IO_STATUS_BLOCK         IoStatusBlock;
    DWORD                   cbDirPath;
    OBJECT_ATTRIBUTES       ObjectAttributes;
    UINT                    Size;

    //
    // Convert the DIR Path to UNICODE
    //

   pDirPath =  (PWSTR)LocalAlloc(LPTR, (wcslen(wszPath) +
                                  wcslen(L"\\DOSDEVICES\\")+1) *
                                  sizeof(WCHAR));

    if (pDirPath == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto err;
    }

   wcscpy(pDirPath, L"\\DOSDEVICES\\");
   wcscat(pDirPath, wszPath);

   RtlInitUnicodeString(&DirectoryName, pDirPath);

   InitializeObjectAttributes(&ObjectAttributes,
                              &DirectoryName,
                              OBJ_CASE_INSENSITIVE,
                              NULL,
                              NULL);

   Status = NtOpenFile(&DirHandle,
                       WRITE_DAC | READ_CONTROL | SYNCHRONIZE,
                       &ObjectAttributes,
                       &IoStatusBlock,
                       FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE ,
                       FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT);

   LocalFree(pDirPath);

    if (!NT_SUCCESS(Status))
    {
        goto err;
    }

    do
    {
        //
        // Read the security descriptor for this directory
        //

        SizeNeeded = 256;

        do
        {
            if (pBuffer != NULL)
                LocalFree(pBuffer);

            if ((pBuffer = (PBYTE)LocalAlloc(LPTR,SizeNewDacl = SizeNeeded)) == NULL)
            {

                Status = STATUS_NO_MEMORY;
                break;
            }

            Status = NtQuerySecurityObject(DirHandle,
                                           OWNER_SECURITY_INFORMATION |
                                           GROUP_SECURITY_INFORMATION |
                                           DACL_SECURITY_INFORMATION,
                                           (PSECURITY_DESCRIPTOR)pBuffer,
                                           SizeNeeded, &SizeNeeded);

        } while ((Status != STATUS_SUCCESS) &&
                 ((Status == STATUS_BUFFER_TOO_SMALL)   ||
                  (Status == STATUS_BUFFER_OVERFLOW)    ||
                  (Status == STATUS_MORE_ENTRIES)));

        if (!NT_SUCCESS(Status))
        {
            hr = E_FAIL;
            break;
        }

        pSecDesc = (PISECURITY_DESCRIPTOR)pBuffer;

        // If the security descriptor is in self-relative form, convert to absolute
        if (pSecDesc->Control & SE_SELF_RELATIVE)
        {
            DWORD AbsoluteSizeNeeded;

            //
            // An absolute SD is not necessarily the same size as a relative
            // SD, so an in-place conversion may not be possible.
            //

            AbsoluteSizeNeeded = SizeNeeded;
            Status = RtlSelfRelativeToAbsoluteSD2(pSecDesc, &AbsoluteSizeNeeded);
            if (Status == STATUS_BUFFER_TOO_SMALL) {

                //
                // Allocate a new buffer in which to store the absolute
                // security descriptor, copy the contents of the relative
                // descriptor in, and try again.
                // 

                pAbsSecDesc = (PBYTE)LocalAlloc(LPTR,AbsoluteSizeNeeded);
                if (pAbsSecDesc == NULL) {
                    Status = STATUS_NO_MEMORY;
                    break;
                }

                RtlCopyMemory(pAbsSecDesc,pSecDesc,SizeNeeded);
                Status = RtlSelfRelativeToAbsoluteSD2(pAbsSecDesc,
                                                      &AbsoluteSizeNeeded );
                if (NT_SUCCESS(Status)) {
                    pSecDesc = (PISECURITY_DESCRIPTOR)pAbsSecDesc;
                }
            }
        }

        if (!NT_SUCCESS(Status))
        {
            break;
        }

        // Construct the new Dacl. This consists of Aces for World, Owner and Group
        // followed by Old Aces for everybody else, but with Aces for World, OldOwner
        // and OldGroup stripped out. First determine space for the new Dacl and
        // allocated space for the new Dacl. Lets be exteremely conservative. We
        // have two aces each for owner/group/world.

        SizeNewDacl +=
        (RtlLengthSid(pSecDesc->Owner) + sizeof(ACCESS_ALLOWED_ACE) +
         RtlLengthSid(pSecDesc->Group) + sizeof(ACCESS_ALLOWED_ACE) +
         RtlLengthSid(&AfpSidSystem) + sizeof(ACCESS_ALLOWED_ACE) +
         RtlLengthSid(&AfpSidWorld) + sizeof(ACCESS_ALLOWED_ACE)) * 3;

        if ((pDaclNew = (PACL)LocalAlloc(LPTR,SizeNewDacl)) == NULL)
        {

            Status = STATUS_NO_MEMORY;
            hr = E_OUTOFMEMORY;
            break;
        }

        Status = RtlCreateAcl(pDaclNew, SizeNewDacl, ACL_REVISION);
        if (!NT_SUCCESS(Status))
        {
            hr = E_FAIL;
            break;
        }

        pAce = (PACCESS_ALLOWED_ACE)((PBYTE)pDaclNew + sizeof(ACL));

        // At this time the Acl list is empty, i.e. no access for anybody
        // Start off by copying the the Explicit/Non-inherited Deny Aces 
        // from the original Dacl list weeding out the Aces 
        // for World, old and new owner, new and old
        // group, creator owner and creator group
        if (pSecDesc->Dacl != NULL)
        {
            pAce = afpMoveAces(pSecDesc->Dacl, pAce, pSecDesc->Owner,
                               pSecDesc->Owner, pSecDesc->Group, pSecDesc->Group,
                               TRUE, FALSE, pDaclNew);

        }

        // Now add Aces for System, World, Group & Owner - in that order
        pAce = afpAddAceToAcl(pDaclNew,
                              pAce,
                              AFP_READ_ACCESS,
                              &AfpSidSystem,
                              &AfpSidSystem);

        pAce = afpAddAceToAcl(pDaclNew,
                              pAce,
                              AFP_READ_ACCESS,
                              &AfpSidWorld,
                              NULL);

        pAce = afpAddAceToAcl(pDaclNew,
                              pAce,
                              AFP_READ_ACCESS ,
                              pSecDesc->Group,
                              &AfpSidCrtrGroup);

        pAce = afpAddAceToAcl(pDaclNew,
                              pAce,
                              AFP_READ_ACCESS |  AFP_WRITE_ACCESS,
                              pSecDesc->Owner,
                              &AfpSidCrtrOwner);


        // Now add in the Explicit/Non-inherited Grant Aces from the 
        // original Dacl list weeding out
        // the Aces for World, old and new owner, new and old group, creator
        // owner and creator group
        if (pSecDesc->Dacl != NULL)
        {
            pAce = afpMoveAces(pSecDesc->Dacl, pAce, pSecDesc->Owner,
                               pSecDesc->Owner, pSecDesc->Group, pSecDesc->Group,
                               FALSE, FALSE, pDaclNew);

        }

        // Now add in the Non-explicit/Inherited Deny Aces from 
        // the original Dacl list
        // weeding out the Aces for World, old and new owner, new and old
        // group, creator owner and creator group
        if (pSecDesc->Dacl != NULL)
        {
            pAce = afpMoveAces(pSecDesc->Dacl, pAce, pSecDesc->Owner,
                               pSecDesc->Owner, pSecDesc->Group, pSecDesc->Group,
                               TRUE, TRUE, pDaclNew);

        }

        // Now add in the Non-explicit/Inherited Deny Aces from 
        // the original Dacl list
        // weeding out the Aces for World, old and new owner, new and old
        // group, creator owner and creator group
        if (pSecDesc->Dacl != NULL)
        {
            pAce = afpMoveAces(pSecDesc->Dacl, pAce, pSecDesc->Owner,
                               pSecDesc->Owner, pSecDesc->Group, pSecDesc->Group,
                               FALSE, TRUE, pDaclNew);

        }

        // Now set the new security descriptor
        pSecDesc->Dacl = pDaclNew;

        Status = NtSetSecurityObject(DirHandle, SecInfo, pSecDesc);


    } while (FALSE);

    // Free the allocated buffers before we return
    if (pBuffer != NULL)
        LocalFree(pBuffer);
    if (pDaclNew != NULL)
        LocalFree(pDaclNew);
    if (pAbsSecDesc != NULL)
        LocalFree(pAbsSecDesc);

    if (!NT_SUCCESS(Status))
    {
        hr = E_FAIL;
    }

err:
    TraceError("HrSfmSetUamSecurity", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netoc\netocp.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N E T O C P . H
//
//  Contents:   Private definitions for NETOC
//
//  Notes:
//
//  Author:     danielwe   17 Sep 1998
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _NETOCP_H
#define _NETOCP_H

#ifndef _OCMANAGE_H
#define _OCMANAGE_H
#include <ocmanage.h>   // OC Manager header
#endif //!_OCMANAGE_H

#include "netoc.h"
#include "netcon.h"
#include "ncstring.h"
#include "netcfgx.h"

//---[ Prototypes ]-----------------------------------------------------------

DWORD NetOcSetupProcHelper(LPCVOID pvComponentId, LPCVOID pvSubcomponentId,
                           UINT uFunction, UINT uParam1, LPVOID pvParam2);
DWORD HrOnPreInitializeComponent (UINT uModesSupported);
HRESULT HrOnInitComponent(PSETUP_INIT_COMPONENT psic);
VOID OnWizardCreated(HWND hwnd);
HRESULT HrOnCalcDiskSpace(PCWSTR szwSubComponentId, BOOL fAdd,
                          HDSKSPC hdskspc);
DWORD DwOnQueryState(PCWSTR szwSubComponentId, BOOL fFinal);
HRESULT HrEnsureInfFileIsOpen(PCWSTR szwSubComponentId, NETOCDATA &nocd);
HRESULT HrOnPreCommitFileQueue(PCWSTR szwSubComponentId);
HRESULT HrOnQueueFileOps(PCWSTR szwSubComponentId, HSPFILEQ hfq);
HRESULT HrOnCompleteInstallation(PCWSTR szwComponentId,
                                 PCWSTR szwSubComponentId);
HRESULT HrOnQueryChangeSelState(PCWSTR szwSubComponentId, BOOL fSelected,
                                UINT uiFlags);
BOOL FOnQuerySkipPage(OcManagerPage ocmPage);
VOID OnCleanup(VOID);
HRESULT HrGetSelectionState(PCWSTR szwSubComponentId, UINT uStateType);
HRESULT HrGetInstallType(PCWSTR szwSubComponentId, NETOCDATA &nocd,
                         EINSTALL_TYPE *peit);
HRESULT HrInstallNetCfgComponent(PCWSTR szComponentId,
                                 PCWSTR szManufacturer,
                                 PCWSTR szProduct,
                                 PCWSTR szDisplayName,
                                 const GUID& rguid);
HRESULT HrRemoveNetCfgComponent(PCWSTR szComponentId,
                                 PCWSTR szManufacturer,
                                 PCWSTR szProduct,
                                 PCWSTR szDisplayName,
                                 const GUID& rguid);
HRESULT HrCallExternalProc(PNETOCDATA pnocd, UINT uMsg, WPARAM wParam,
                           LPARAM lParam);
HRESULT HrRunInfSection(HINF hinf, PNETOCDATA pnocd,
                        PCWSTR szInstallSection, DWORD dwFlags);
HRESULT HrInstallOrRemoveServices(HINF hinf, PCWSTR szSectionName);
HRESULT HrHandleOCExtensions(HINF hinfFile, PCWSTR szInstallSection);
HRESULT HrOCInstallOrUninstallFromINF(PNETOCDATA pnocd);
HRESULT HrDoOCInstallOrUninstall(PNETOCDATA pnocd);
UINT UiOcErrorFromHr(HRESULT hr);
HRESULT ReportEventHrString(PCWSTR pszErr, INT ids, PCWSTR pszDesc);
HRESULT ReportEventHrResult(HRESULT hrv, INT ids, PCWSTR pszDesc);
HRESULT ReportErrorHr(HRESULT hrv, INT ids, HWND hwnd, PCWSTR pszDesc);

NOTHROW int WINAPIV NcMsgBoxMc(HWND hwnd, UINT unIdCaption, UINT unIdFormat, UINT unStyle, ...);

HRESULT HrInstallOrRemoveNetCfgComponent(PNETOCDATA pnocd,
                                         PCWSTR szComponentId,
                                         PCWSTR szManufacturer,
                                         PCWSTR szProduct,
                                         PCWSTR szDisplayName,
                                         const GUID& rguid);
HRESULT HrDoActualInstallOrUninstall(HINF hinf, PNETOCDATA pnocd,
                                     PCWSTR szInstallSection);
HRESULT HrVerifyStaticIPPresent(INetCfg *pnc);

NETOCDATA *PnocdFindComponent(PCWSTR szwComponent);
VOID DeleteAllComponents(VOID);
HRESULT AddComponent(PCWSTR szwComponent, NETOCDATA *pnocd);
HRESULT HrCountConnections(INetConnection **ppconn);
HRESULT HrStartOrStopAnyServices(HINF hinf, PCWSTR szSection, BOOL fStart);
DWORD DwOnQueryStepCount(PCWSTR pvSubcomponentId);
HRESULT HrSetNextButton(PCWSTR pszSubComponentId);
#endif //!_NETOCP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netoc\version.h ===
#pragma once

#include <ntverp.h>
#include <winver.h>

#define VER_FILETYPE                    VFT_DLL
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "Network Optional Component Installer"
#define VER_INTERNALNAME_STR            "netoc.dll"

#include <common.ver>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netoc\snmpocx.h ===
#ifndef _SNMPOCX_H
#define _SNMPOCX_H

//---------------- general defines ---------------------
#define MAX_AF_STRING_LEN           1024
#define MAX_REG_STRING_LEN          256

// the section name expected to be found in the answer file
#define AF_SECTION                      L"SNMP"
// registry key
#define REG_KEY_SNMP_PARAMETERS         L"SYSTEM\\CurrentControlSet\\Services\\SNMP\\Parameters"

//---------------- the "Security" Panel ----------------
// answer file keys
#define AF_ACCEPTCOMMNAME               L"Accept_CommunityName"
#define AF_SENDAUTH                     L"Send_Authentication"
#define AF_ANYHOST                      L"Any_Host"
#define AF_LIMITHOST                    L"Limit_Host"
// registry keys
#define REG_KEY_VALID_COMMUNITIES       REG_KEY_SNMP_PARAMETERS L"\\ValidCommunities"
#define REG_KEY_AUTHENTICATION_TRAPS    REG_KEY_SNMP_PARAMETERS L"\\EnableAuthenticationTraps"
#define REG_VALUE_SWITCH                L"switch"
#define REG_VALUE_AUTHENTICATION_TRAPS  L"EnableAuthenticationTraps"
#define REG_NAME_RESOLUTION_RETRIES     L"NameResolutionRetries"
#define REG_KEY_PERMITTED_MANAGERS      REG_KEY_SNMP_PARAMETERS L"\\PermittedManagers"
// security defines
#define SEC_NONE_NAME                   L"NONE"
#define SEC_NONE_VALUE                  0x00000001
#define SEC_NOTIFY_NAME                 L"NOTIFY"
#define SEC_NOTIFY_VALUE                0x00000002
#define SEC_READ_ONLY_NAME              L"READ_ONLY"
#define SEC_READ_ONLY_VALUE             0x00000004
#define SEC_READ_WRITE_NAME             L"READ_WRITE"
#define SEC_READ_WRITE_VALUE            0x00000008
#define SEC_READ_CREATE_NAME            L"READ_CREATE"
#define SEC_READ_CREATE_VALUE           0x00000010
// default PermittedManagers
#define SEC_DEF_PERMITTED_MANAGERS      L"localhost\0" // multi_Sz value to SnmpRegWritePermittedMgrs

//----------------- the "Traps" Panel ------------------
// answer file keys
#define AF_TRAPCOMMUNITY                L"Community_Name"
#define AF_TRAPDEST                     L"Traps"
// registry keys
#define REG_KEY_TRAP_DESTINATIONS       REG_KEY_SNMP_PARAMETERS L"\\TrapConfiguration"

//----------------- the "Agent" Panel ------------------
// answer file keys
#define AF_SYSNAME                      L"Contact_Name"
#define AF_SYSLOCATION                  L"Location"
#define AF_SYSSERVICES                  L"Service"
// registry keys
#define REG_KEY_AGENT                   REG_KEY_SNMP_PARAMETERS L"\\RFC1156Agent"
#define SNMP_CONTACT                    L"sysContact"
#define SNMP_LOCATION                   L"sysLocation"
#define SNMP_SERVICES                   L"sysServices"
#define SRV_AGNT_PHYSICAL_NAME          L"Physical"
#define SRV_AGNT_PHYSICAL_VALUE         0x00000001
#define SRV_AGNT_DATALINK_NAME          L"Datalink"
#define SRV_AGNT_DATALINK_VALUE         0x00000002
#define SRV_AGNT_INTERNET_NAME          L"Internet"
#define SRV_AGNT_INTERNET_VALUE         0x00000004
#define SRV_AGNT_ENDTOEND_NAME          L"End-to-End"
#define SRV_AGNT_ENDTOEND_VALUE         0x00000008
#define SRV_AGNT_APPLICATIONS_NAME      L"Applications"
#define SRV_AGNT_APPLICATIONS_VALUE     0x00000040

#define REG_KEY_EXTENSION_AGENTS   REG_KEY_SNMP_PARAMETERS L"\\ExtensionAgents"

typedef BOOL (* LPFNFREMOVESUBAGENT)(void);
typedef struct tagSubagentRemovalInfo
{
    LPCWSTR pwszRegKey;     // Subagent Registry Key to be removed
    LPCWSTR pwszRegValData; // Subagent value data under 
                            // REG_KEY_EXTENSION_AGENTS key
    LPFNFREMOVESUBAGENT pfnFRemoveSubagent;// function to tell if this subagent
                                           // needs to be removed
} SUBAGENT_REMOVAL_INFO, * LPSUBAGENT_REMOVAL_INFO;

//~~~~~~~~~~~~~~~~~ registry setting functions ~~~~~~~~~
HRESULT
SnmpRegWriteDword(PWSTR pRegKey,
                  PWSTR pValueName,
                  DWORD dwValueData);

HRESULT
SnmpRegUpgEnableAuthTraps();

HRESULT
SnmpRegWriteCommunities(PWSTR pCommArray);

HRESULT
SnmpRegWritePermittedMgrs(BOOL bAnyHost,
                          PWSTR pMgrsList);

HRESULT
SnmpRegWriteTraps(tstring tstrVariable,
                  PWSTR  pTstrArray);

HRESULT
SnmpRegWriteTstring(PWSTR pRegKey,
                    PWSTR pValueName,
                    tstring tstrValueData);

DWORD
SnmpStrArrayToServices(PWSTR pSrvArray);

//~~~~~~~~~~~~~~~adding admin ACL to registry subkey~~~~~
HRESULT SnmpAddAdminAclToKey(PWSTR pwszKey);

//~~~~~~~~~~~~~~~Removal of obsoleted subagents during upgrade~~~~~
HRESULT SnmpRemoveSubAgents(
                const SUBAGENT_REMOVAL_INFO * prgSRI,
                UINT  cParams);
#endif // _SNMPOCX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netoc\snmpocx.cpp ===
#include "pch.h"
#pragma hdrstop
#include <aclapi.h>
#include "netoc.h"
#include "ncreg.h"
#include "snmpocx.h"


// Under opened registry subkey hKey,
// removes the registry value name who has a value data of pwszRegValData
// if it exists.
HRESULT HrSnmpRegDeleteValueData(
                                IN HKEY hKey,
                                IN LPCWSTR pwszRegValData)
{
    HRESULT hr   = S_OK;
    DWORD   dwIndex = 0;
    DWORD   dwNameSize;
    DWORD   dwValueSize;
    DWORD   dwValueType;
    WCHAR   wszName[MAX_PATH];
    WCHAR   wszValue[MAX_PATH];

    Assert (hKey);
    Assert (pwszRegValData);

    // initialize buffer sizes
    dwNameSize  = sizeof(wszName) / sizeof(wszName[0]); // size in number of TCHARs
    dwValueSize = sizeof(wszValue); // size in number of bytes

    // loop until error, end of list, or found subagent to be removed
    while (S_OK == hr)
    {
        // read next value
        hr = HrRegEnumValue(
                    hKey, 
                    dwIndex, 
                    wszName, 
                    &dwNameSize,
                    &dwValueType, 
                    (LPBYTE)wszValue, 
                    &dwValueSize
                    );
            
        // validate return code
        if (S_OK == hr)
        {
            // see if the subagent value data matched the one to be removed
            if (!wcscmp(pwszRegValData, wszValue))
            {
                hr = HrRegDeleteValue(hKey, wszName);
                if (S_OK != hr)
                {
                    TraceTag(ttidError, 
                        "SnmpNetOc: HrRegDeleteValue: failed to delete %S. hr = %x.",
                        wszName, hr);
                }
                break;
            }
                    
            // re-initialize buffer sizes
            dwNameSize  = sizeof(wszName) / sizeof(wszName[0]); // size in number of TCHARs
            dwValueSize = sizeof(wszValue); // size in number of bytes
                
            // next
            dwIndex++;
        } 
        else if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr) 
        {
            // success
            break; 
        }
    }
    
    return hr;
}

// Removes Subagent Configuration from registry according to the given
// array of SUBAGENT_REMOVAL_INFO
HRESULT SnmpRemoveSubAgents
(
    IN const SUBAGENT_REMOVAL_INFO * prgSRI, // array of SUBAGENT_REMOVAL_INFO
    IN UINT  cParams                         // number of elements in the arrary
)
{
    if ((NULL == prgSRI) || (0 == cParams))
    {
        TraceError( "No Subagents need to be removed.", S_FALSE);
        return S_FALSE;
    }
    HRESULT hr      = S_OK;
    HRESULT hrTmp   = S_OK;
    UINT    i       = 0;
    HKEY    hKey    = NULL;

    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, REG_KEY_EXTENSION_AGENTS, 
                        KEY_READ | KEY_WRITE, &hKey);
    if (S_OK != hr)
    {
        TraceTag(ttidError, 
            "SnmpNetOc: HrRegOpenKeyEx: failed to open %S. hr = %x.",
            REG_KEY_EXTENSION_AGENTS, hr);
        return hr;
    }

    for (i = 0; i < cParams; i++)
    {
        hrTmp = S_OK;
        if (
            // removal from all SKU AND has valid registry info
            (!prgSRI[i].pfnFRemoveSubagent && prgSRI[i].pwszRegKey 
                                           && prgSRI[i].pwszRegValData) 
            ||
            // removal depending on given function and has valid registry info 
            (prgSRI[i].pfnFRemoveSubagent && 
             (*(prgSRI[i].pfnFRemoveSubagent))() &&
             prgSRI[i].pwszRegKey && prgSRI[i].pwszRegValData)
           )
        {
            // removes everything under subagent registry key if it exits
            hrTmp = HrRegDeleteKeyTree(HKEY_LOCAL_MACHINE, prgSRI[i].pwszRegKey);
            if (S_OK != hrTmp)
            {
                TraceTag(ttidError, 
                    "SnmpNetOc: HrRegDeleteKeyTree: failed to delete %S. hr = %x.",
                    prgSRI[i].pwszRegKey, hrTmp);
            }

            // Under registry subkey of REG_KEY_EXTENSION_AGENTS,
            // removes the registry value name who has value data identical to
            // pwszRegKey.
            hrTmp = HrSnmpRegDeleteValueData(hKey, prgSRI[i].pwszRegValData);
            if (S_OK != hrTmp)
            {
                TraceTag(ttidError, 
                    "SnmpNetOc: HrSnmpRegDeleteValueData: failed to delete %S value data. hr = %x.",
                    prgSRI[i].pwszRegValData, hrTmp);
            }

        }
    }
    RegSafeCloseKey(hKey);
    //we dont pass the error of hrTmp out of this function because
    //there is not much we can do with this error
    return hr;
}

// Allocates an admin ACL to be used with security descriptor
PACL AllocACL()
{
    PACL                        pAcl = NULL;
    PSID                        pSidAdmins = NULL;
    SID_IDENTIFIER_AUTHORITY    Authority = SECURITY_NT_AUTHORITY;

    EXPLICIT_ACCESS ea[1];

    // Create a SID for the BUILTIN\Administrators group.
    if ( !AllocateAndInitializeSid( &Authority,
                                    2,
                                    SECURITY_BUILTIN_DOMAIN_RID,
                                    DOMAIN_ALIAS_RID_ADMINS,
                                    0, 0, 0, 0, 0, 0,
                                    &pSidAdmins ))
    {
        return NULL;
    }


    // Initialize an EXPLICIT_ACCESS structure for an ACE.
    ZeroMemory(&ea, 1 * sizeof(EXPLICIT_ACCESS));
    
    // The ACE will allow the Administrators group full access to the key.
    ea[0].grfAccessPermissions = KEY_ALL_ACCESS;
    ea[0].grfAccessMode = SET_ACCESS;
    ea[0].grfInheritance= NO_INHERITANCE;
    ea[0].Trustee.TrusteeForm = TRUSTEE_IS_SID;
    ea[0].Trustee.TrusteeType = TRUSTEE_IS_GROUP;
    ea[0].Trustee.ptstrName  = (LPTSTR) pSidAdmins;

    // Create a new ACL that contains the new ACEs.
    if (SetEntriesInAcl(1, ea, NULL, &pAcl) != ERROR_SUCCESS) 
    {
        TraceError( "SetEntriesInAcl Error", GetLastError() );
        FreeSid(pSidAdmins);
        return NULL;
    }

    FreeSid(pSidAdmins);

    return pAcl;
}
// frees a ACL
void FreeACL( PACL pAcl)
{
    if (pAcl != NULL)
        LocalFree(pAcl);
}

HRESULT SnmpAddAdminAclToKey(PWSTR pwszKey)
{
    HKEY    hKey = NULL;
    HRESULT hr;
    PACL    pAcl = NULL;
    SECURITY_DESCRIPTOR S_Desc;

    if (pwszKey == NULL)
        return S_FALSE;
    
    // open registy key
    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                        pwszKey,         // subkey name
                        KEY_ALL_ACCESS,  // want WRITE_DAC,
                        &hKey            // handle to open key
                          );
    if (hr != S_OK)
    {
        TraceError("SnmpAddAdminDaclToKey::HrRegOpenKeyEx", hr);
        return hr;
    }
    
    // Initialize a security descriptor.  
    if (InitializeSecurityDescriptor (&S_Desc, SECURITY_DESCRIPTOR_REVISION) == 0)
    {
        RegSafeCloseKey(hKey);
        TraceError("SnmpAddAdminDaclToKey::InitializeSecurityDescriptor", GetLastError());
        return S_FALSE;
    }

    // get the ACL and put it into the security descriptor
    if ( (pAcl = AllocACL()) != NULL )
    {
        if (!SetSecurityDescriptorDacl (&S_Desc, TRUE, pAcl, FALSE))
        {
            FreeACL(pAcl);
            RegSafeCloseKey(hKey);
            TraceError("SnmpAddAdminDaclToKey::SetSecurityDescriptorDacl Failed.", GetLastError());
            return S_FALSE;
        }
    }
    else
    {
        RegSafeCloseKey(hKey);
        TraceError("SnmpAddAdminAclToKey::AllocACL Failed.", GetLastError());
        return S_FALSE;
    }


    if (RegSetKeySecurity (hKey, DACL_SECURITY_INFORMATION, &S_Desc)  != ERROR_SUCCESS)
    {
        FreeACL(pAcl);
        RegSafeCloseKey(hKey);
        TraceError("SnmpAddAdminDaclToKey::RegSetKeySecurity", GetLastError());
        return S_FALSE;
    }

    FreeACL(pAcl);
    RegSafeCloseKey(hKey);
    
    return S_OK;
}

HRESULT
SnmpRegWriteDword(PWSTR pszRegKey,
                  PWSTR pszValueName,
                  DWORD dwValueData)
{
    HRESULT hr;
    HKEY    hKey;

    hr = HrRegCreateKeyEx(HKEY_LOCAL_MACHINE,
                          pszRegKey,
                          0,
                          KEY_QUERY_VALUE | KEY_SET_VALUE,
                          NULL,
                          &hKey,
                          NULL);
    if (hr != S_OK)
    {
        return hr;
    }

    hr = HrRegSetDword(hKey, pszValueName, dwValueData);

    RegSafeCloseKey(hKey);

    return hr;
}

HRESULT
SnmpRegUpgEnableAuthTraps()
{
    HRESULT hr = S_OK;
    HKEY    hKey;

    // open the ..SNMP\Parameters registry key
    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE,
                        REG_KEY_AUTHENTICATION_TRAPS,
                        KEY_QUERY_VALUE,
                        &hKey);

    // if successful, look for EnableAuthenticationTrap switch
    // in the old registry location
    if (hr == S_OK)
    {
        DWORD dwAuthTrap;

        // get the value of the old 'switch' parameter
        hr = HrRegQueryDword(hKey,
                             REG_VALUE_SWITCH,
                             &dwAuthTrap);

        // if successful transfer the value to the new location
        // if this fails, it means the SNMP service worked with the default value
        // which is already installed through the inf file.
        if (hr == S_OK)
        {
            hr = SnmpRegWriteDword(REG_KEY_SNMP_PARAMETERS,
                                   REG_VALUE_AUTHENTICATION_TRAPS,
                                   dwAuthTrap);
        }

        // close and delete the old registry key as it is obsolete
        RegSafeCloseKey(hKey);
        HrRegDeleteKey (HKEY_LOCAL_MACHINE,
                        REG_KEY_AUTHENTICATION_TRAPS);
    }

    return hr;

}

HRESULT
SnmpRegWriteCommunities(PWSTR pszCommArray)
{
    HRESULT hr;
    HKEY    hKey;
    PWSTR  pszComm, pszAccess;
    DWORD   dwAccess;

    hr = HrRegDeleteKey(HKEY_LOCAL_MACHINE,
                        REG_KEY_VALID_COMMUNITIES);

    if (hr != S_OK)
    {
        return hr;
    }


    hr = HrRegCreateKeyEx(HKEY_LOCAL_MACHINE,
                          REG_KEY_VALID_COMMUNITIES,
                          0,
                          KEY_QUERY_VALUE | KEY_SET_VALUE,
                          NULL,
                          &hKey,
                          NULL);

    if (hr != S_OK)
    {
        return hr;
    }
    

    pszComm = pszCommArray;
    while (*pszComm != L'\0')
    {
        dwAccess = SEC_READ_ONLY_VALUE;
        pszAccess = wcschr(pszComm, L':');
        if (pszAccess != NULL)
        {
            *pszAccess = L'\0';
            pszAccess++;

            if (_wcsicmp(pszAccess, SEC_NONE_NAME)==0)
            {
                dwAccess = SEC_NONE_VALUE;
            }
            if (_wcsicmp(pszAccess, SEC_NOTIFY_NAME)==0)
            {
                dwAccess = SEC_NOTIFY_VALUE;
            }
            if (_wcsicmp(pszAccess, SEC_READ_ONLY_NAME)==0)
            {
                dwAccess = SEC_READ_ONLY_VALUE;
            }
            if (_wcsicmp(pszAccess, SEC_READ_WRITE_NAME)==0)
            {
                dwAccess = SEC_READ_WRITE_VALUE;
            }
            if (_wcsicmp(pszAccess, SEC_READ_CREATE_NAME)==0)
            {
                dwAccess = SEC_READ_CREATE_VALUE;
            }
        }

        hr = HrRegSetDword(hKey, pszComm, dwAccess);
        if (hr != S_OK)
        {
            break;
        }
        if (pszAccess != NULL)
        {
            pszComm = pszAccess;
        }
        pszComm += (wcslen(pszComm) + 1);
    }

    RegSafeCloseKey(hKey);
    
    return hr;
}

HRESULT SnmpRegWritePermittedMgrs(BOOL bAnyHost,
                                  PWSTR pMgrsList)
{
    HRESULT hr;
    HKEY    hKey;
    UINT    nMgr = 1;
    WCHAR   szMgr[16];

    hr = HrRegDeleteKey(HKEY_LOCAL_MACHINE,
                        REG_KEY_PERMITTED_MANAGERS);

    if (hr != S_OK)
    {
        return hr;
    }

    hr = HrRegCreateKeyEx(HKEY_LOCAL_MACHINE,
                          REG_KEY_PERMITTED_MANAGERS,
                          0,
                          KEY_QUERY_VALUE | KEY_SET_VALUE,
                          NULL,
                          &hKey,
                          NULL);

    if (hr != S_OK)
    {
        return hr;
    }

    if (bAnyHost)
    {
        RegSafeCloseKey(hKey);
        return hr;
    }

    AssertSz(pMgrsList, "pMgrsList is NULL and bAnyHost is FALSE in SnmpRegWritePermittedMgrs");
    while(*pMgrsList != L'\0')
    {
        swprintf(szMgr, L"%d", nMgr++);
        hr = HrRegSetSz(hKey, szMgr, pMgrsList);
        if (hr != S_OK)
            break;
        pMgrsList += wcslen(pMgrsList) + 1;
    }

    RegSafeCloseKey(hKey);

    return hr;
}

HRESULT
SnmpRegWriteTraps(tstring tstrVariable,
                  PWSTR  pTstrArray)
{
    HKEY hKey, hKeyTrap;
    HRESULT hr = S_OK;
    UINT    nTrap = 1;
    WCHAR   szTrap[16];

    hr = HrRegDeleteKeyTree(HKEY_LOCAL_MACHINE,
                            REG_KEY_TRAP_DESTINATIONS);

    if (hr != S_OK)
        return hr;

    hr = HrRegCreateKeyEx(HKEY_LOCAL_MACHINE,
                      REG_KEY_TRAP_DESTINATIONS,
                      0,
                      KEY_QUERY_VALUE | KEY_SET_VALUE,
                      NULL,
                      &hKey,
                      NULL);

    if (hr != S_OK)
        return hr;

    hr = HrRegCreateKeyEx(hKey,
                       tstrVariable.c_str(),
                       0,
                       KEY_QUERY_VALUE | KEY_SET_VALUE,
                       NULL,
                       &hKeyTrap,
                       NULL);
    if (hr == S_OK)
    {
        // it might just happen that you want to create a
        // community but you don't have the trap destination
        // addresses yet. We should let this happen.
        if (pTstrArray != NULL)
        {
            while(*pTstrArray != L'\0')
            {
                swprintf(szTrap, L"%d", nTrap++);
                hr = HrRegSetSz(hKeyTrap, szTrap, pTstrArray);
                if (hr != S_OK)
                    break;
                pTstrArray += wcslen(pTstrArray) + 1;
            }
        }

        RegSafeCloseKey(hKeyTrap);
    }

    RegSafeCloseKey(hKey);

    return hr;
}

HRESULT
SnmpRegWriteTstring(PWSTR pRegKey,
                    PWSTR pValueName,
                    tstring tstrValueData)
{
    HRESULT hr = S_OK;
    HKEY    hKey;

    hr = HrRegCreateKeyEx(HKEY_LOCAL_MACHINE,
                          pRegKey,
                          0,
                          KEY_QUERY_VALUE | KEY_SET_VALUE,
                          NULL,
                          &hKey,
                          NULL);
    if (hr != S_OK)
        return hr;

    hr = HrRegSetString(hKey, pValueName, tstrValueData);

    RegSafeCloseKey(hKey);

    return hr;
}

DWORD
SnmpStrArrayToServices(PWSTR pSrvArray)
{
    DWORD dwServices = 0;

    while(*pSrvArray)
    {
        if(_wcsicmp(pSrvArray, SRV_AGNT_PHYSICAL_NAME)==0)
            dwServices |= SRV_AGNT_PHYSICAL_VALUE;
        if(_wcsicmp(pSrvArray, SRV_AGNT_DATALINK_NAME)==0)
            dwServices |= SRV_AGNT_DATALINK_VALUE;
        if(_wcsicmp(pSrvArray, SRV_AGNT_ENDTOEND_NAME)==0)
            dwServices |= SRV_AGNT_ENDTOEND_VALUE;
        if(_wcsicmp(pSrvArray, SRV_AGNT_INTERNET_NAME)==0)
            dwServices |= SRV_AGNT_INTERNET_VALUE;
        if(_wcsicmp(pSrvArray, SRV_AGNT_APPLICATIONS_NAME)==0)
            dwServices |= SRV_AGNT_APPLICATIONS_VALUE;

        pSrvArray += wcslen(pSrvArray) + 1;
    }
    return dwServices;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\samples\bindview\component.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       C O M P O N E N T . C P P
//
//  Contents:   Functions to illustrate
//              o How to enumerate network components.
//              o How to install protocols, clients and services.
//              o How to uninstall protocols, clients and services.
//              o How to bind/unbind network components.
//
//  Notes:      
//
//  Author:     Alok Sinha    15-May-01
//
//----------------------------------------------------------------------------

#include "bindview.h"

//
// Function:  HandleComponentOperation
//
// Purpose:   Do component specific functions.
//
// Arguments:
//    hwndOwner    [in]  Owner window.
//    ulSelection  [in]  Option selected.
//    hItem        [in]  Item selected.
//    lParam       [in]  lParam of the item.
//
// Returns:   None.
//
// Notes:
//

VOID HandleComponentOperation (HWND hwndOwner,
                               ULONG ulSelection,
                               HTREEITEM hItem,
                               LPARAM lParam)
{
    switch( ulSelection ) {

        case IDI_BIND_TO:
        case IDI_UNBIND_FROM:

            //
            // Bind/unbind components.
            //

            BindUnbindComponents( hwndOwner,
                                  hItem,
                                  (LPWSTR)lParam,
                                  ulSelection == IDI_BIND_TO );
    }

    return;
}

//
// Function:  BindUnbindComponents
//
// Purpose:   Bind/unbind a network component.
//
// Arguments:
//    hwndOwner  [in]  Owner window.
//    hItem      [in]  Item handle of the network component.
//    lpszInfId  [in]  PnpID of the network component.
//    fBindTo    [in]  if TRUE, bind, otherwise unbind.
//
// Returns:   None.
//
// Notes:
//

VOID BindUnbindComponents( HWND hwndOwner,
                           HTREEITEM hItem,
                           LPWSTR lpszInfId,
                           BOOL fBindTo)
{
    BIND_UNBIND_INFO  BindUnbind;

    BindUnbind.lpszInfId = lpszInfId;
    BindUnbind.fBindTo = fBindTo;

    DialogBoxParam( hInstance,
                    MAKEINTRESOURCE(IDD_BIND_UNBIND),
                    hwndOwner,
                    BindComponentDlg,
                    (LPARAM)&BindUnbind ); 

    return;
}

//
// Function:  InstallComponent
//
// Purpose:   Install a network component.
//
// Arguments:
//    hwndDlg     [in]  Owner window.
//    pguidClass  [in]  Class GUID of type of network component to install.
//
// Returns:   S_OK on success, otherwise and error code.
//
// Notes:
//

HRESULT InstallComponent (HWND hwndDlg,
                          const GUID *pguidClass)
{
    INetCfg              *pnc;
    INetCfgClass         *pncClass;
    INetCfgClassSetup    *pncClassSetup;
    LPWSTR               lpszApp;
    OBO_TOKEN            obo;
    HRESULT              hr;

    //
    // Get INetCfg reference.
    //

    hr = HrGetINetCfg( TRUE,
                       APP_NAME,
                       &pnc,
                       &lpszApp );

    if ( hr == S_OK ) {

        //
        // Get network component's class reference.
        //

        hr = pnc->QueryNetCfgClass( pguidClass,
                                    IID_INetCfgClass,
                                    (PVOID *)&pncClass );

        if ( hr == S_OK ) {

            //
            // Get Setup class reference.
            //

            hr = pncClass->QueryInterface( IID_INetCfgClassSetup,
                                           (LPVOID *)&pncClassSetup );

            if ( hr == S_OK ) {

                ZeroMemory( &obo,
                            sizeof(OBO_TOKEN) );

                obo.Type = OBO_USER;

                //
                // Let the network class installer prompt the user to select
                // a network component to install.
                //

                hr = pncClassSetup->SelectAndInstall( hwndDlg,
                                                      &obo,
                                                      NULL );

                if ( (hr == S_OK) || (hr == NETCFG_S_REBOOT) ) {

                    hr = pnc->Apply();

                    if ( (hr != S_OK) && (hr != NETCFG_S_REBOOT) ) {

                        ErrMsg( hr,
                                L"Couldn't apply the changes after"
                                L" installing the network component." );
                    }

                }
                else {
                    if ( hr != HRESULT_FROM_WIN32(ERROR_CANCELLED) ) {
                        ErrMsg( hr,
                                L"Couldn't install the network component." );
                    }
                }

                ReleaseRef( pncClassSetup );
            }
            else {
                ErrMsg( hr,
                        L"Couldn't get an interface to setup class." );
            }

            ReleaseRef( pncClass );
        }
        else {
            ErrMsg( hr,
                    L"Couldn't get a pointer to class interface." );
        }

        HrReleaseINetCfg( pnc,
                          TRUE );
    }
    else {
        if ( (hr == NETCFG_E_NO_WRITE_LOCK) && lpszApp ) {
            ErrMsg( hr,
                    L"%s currently holds the lock, try later.",
                    lpszApp );

            CoTaskMemFree( lpszApp );
        }
        else {
            ErrMsg( hr,
                    L"Couldn't the get notify object interface." );
        }
    }
 
    return hr;
}

//
// Function:  InstallSpecifiedComponent
//
// Purpose:   Install a network component from an INF file.
//
// Arguments:
//    lpszInfFile [in]  INF file.
//    lpszPnpID   [in]  PnpID of the network component to install.
//    pguidClass  [in]  Class GUID of the network component.
//
// Returns:   None.
//
// Notes:
//

HRESULT InstallSpecifiedComponent (LPWSTR lpszInfFile,
                                   LPWSTR lpszPnpID,
                                   const GUID *pguidClass)
{
    INetCfg    *pnc;
    LPWSTR     lpszApp;
    HRESULT    hr;

    hr = HrGetINetCfg( TRUE,
                       APP_NAME,
                       &pnc,
                       &lpszApp );

    if ( hr == S_OK ) {

        //
        // Install the network component.
        //

        hr = HrInstallNetComponent( pnc,
                                    lpszPnpID,
                                    pguidClass,
                                    lpszInfFile );
        if ( (hr == S_OK) || (hr == NETCFG_S_REBOOT) ) {

            hr = pnc->Apply();
        }
        else {
            if ( hr != HRESULT_FROM_WIN32(ERROR_CANCELLED) ) {
                ErrMsg( hr,
                        L"Couldn't install the network component." );
            }
        }

        HrReleaseINetCfg( pnc,
                          TRUE );
    }
    else {
        if ( (hr == NETCFG_E_NO_WRITE_LOCK) && lpszApp ) {
            ErrMsg( hr,
                    L"%s currently holds the lock, try later.",
                    lpszApp );

            CoTaskMemFree( lpszApp );
        }
        else {
            ErrMsg( hr,
                    L"Couldn't the get notify object interface." );
        }
    }

    return hr;
}

//
// Function:  ListCompToBindUnbind
//
// Purpose:   List all the components that are bound or bindable.
//
// Arguments:
//    lpszInfId [in]  PnpID of the network component.
//    uiType    [in]  Type of network component.
//    hwndTree  [in]  Tree handle in which to list.
//    fBound    [in]  if TRUE, list components that are bound.
//
// Returns:   Number of components listed.
//
// Notes:
//

DWORD ListCompToBindUnbind (LPWSTR lpszInfId,
                            UINT uiType,
                            HWND hwndTree,
                            BOOL fBound)
{
    INetCfg                   *pnc;
    INetCfgComponent          *pncc;
    IEnumNetCfgComponent      *pencc;
    INetCfgComponentBindings  *pnccb;
    INetCfgComponent          *pnccToBindUnbind;
    LPWSTR                    lpszApp;
    DWORD                     dwCount;
    HRESULT                   hr;


    dwCount = 0;
    hr = HrGetINetCfg( TRUE,
                       APP_NAME,
                       &pnc,
                       &lpszApp );

    if ( hr == S_OK ) {

        //
        // Get a reference to the network component selected.
        //

        hr = pnc->FindComponent( lpszInfId,
                                 &pncc );

        if ( hr == S_OK ) {

            //
            // Get Component Enumerator Interface.
            //

            hr = HrGetComponentEnum( pnc,
                                     pguidNetClass[uiType],
                                     &pencc );
            if ( hr == S_OK ) {

                hr = pncc->QueryInterface( IID_INetCfgComponentBindings,
                                          (PVOID *)&pnccb );
                if ( hr == S_OK ) {

                    hr = HrGetFirstComponent( pencc, &pnccToBindUnbind );

                    while( hr == S_OK ) {

                        hr = pnccb->IsBoundTo( pnccToBindUnbind );

                        //
                        // fBound = TRUE ==> Want to list components that are
                        // bound.
                        //

                        if ( fBound ) {
                  
                            if ( hr == S_OK ) {
                                AddToTree( hwndTree,
                                           TVI_ROOT,
                                           pnccToBindUnbind );
                                dwCount++;
                            }
                        }
                        else {

                            //
                            // fBound = FALSE ==> Want to list components that 
                            // are not bound but are bindable.
                            //

                            if ( hr == S_FALSE ) {

                                hr = pnccb->IsBindableTo( pnccToBindUnbind );

                                if ( hr == S_OK ) {
                                    AddToTree( hwndTree,
                                               TVI_ROOT,
                                               pnccToBindUnbind );
                                    dwCount++;
                                }
                            }
                        }

                        ReleaseRef( pnccToBindUnbind );

                        hr = HrGetNextComponent( pencc, &pnccToBindUnbind );
                    }

                    ReleaseRef( pnccb );
                }
                else {
                    ErrMsg( hr,
                            L"Couldn't get the component binding interface "
                            L"of %s.",
                            lpszInfId );
                }

                ReleaseRef( pencc );
            }
            else {
                ErrMsg( hr,
                        L"Couldn't get the network component enumerator "
                        L"interface." );
            }
  
            ReleaseRef( pncc );

        }
        else {
            ErrMsg( hr,
                    L"Couldn't get an interface pointer to %s.",
                    lpszInfId );
        }

        HrReleaseINetCfg( pnc,
                          TRUE );
    }
    else {
        if ( (hr == NETCFG_E_NO_WRITE_LOCK) && lpszApp ) {
            ErrMsg( hr,
                    L"%s currently holds the lock, try later.",
                    lpszApp );

            CoTaskMemFree( lpszApp );
        }
        else {
            ErrMsg( hr,
                    L"Couldn't get the notify object interface." );
        }
    }

    return dwCount;
}

//
// Function:  BindUnbind
//
// Purpose:   Bind/unbind a network component.
//
// Arguments:
//    lpszInfId  [in]  PnpID of the network component to bind/unbind.
//    hwndTree   [in]  Tree handle.
//    fBind      [in]  if TRUE, bind, otherwise unbind.
//
// Returns:   TRUE on success.
//                       
// Notes:
//

BOOL BindUnbind (LPWSTR lpszInfId,
                 HWND hwndTree,
                 BOOL fBind)
{
    INetCfg                   *pnc;
    INetCfgComponent          *pncc;
    INetCfgComponentBindings  *pnccb;
    INetCfgComponent          *pnccToBindUnbind;
    LPWSTR                    lpszApp;
    HTREEITEM                 hTreeItem;
    TVITEMW                   tvItem;
    HRESULT                   hr;
    BOOL                      fChange;


    hr = HrGetINetCfg( TRUE,
                       APP_NAME,
                       &pnc,
                       &lpszApp );

    fChange = FALSE;

    if ( hr == S_OK ) {

        //
        // Get a reference to the network component.
        //

        hr = pnc->FindComponent( lpszInfId,
                                 &pncc );
        if ( hr == S_OK ) {

            //
            // Get a reference to the component's binding.
            //

            hr = pncc->QueryInterface( IID_INetCfgComponentBindings,
                                         (PVOID *)&pnccb );
            if ( hr == S_OK ) {

                //
                // Start with the root item.
                //

                hTreeItem = TreeView_GetRoot( hwndTree );

                //
                // Bind/unbind the network component with every component
                // that is checked.
                //

                while ( hTreeItem ) {

                    ZeroMemory( &tvItem,
                                sizeof(TVITEMW) );

                    tvItem.hItem = hTreeItem;
                    tvItem.mask = TVIF_PARAM | TVIF_STATE;
                    tvItem.stateMask = TVIS_STATEIMAGEMASK;

                    if ( TreeView_GetItem(hwndTree,
                                          &tvItem) ) {

                        //
                        // Is the network component selected?
                        //

                        if ( (tvItem.state >> 12) == 2 ) {

                            //
                            // Get a reference to the selected component.
                            //

                            hr = pnc->FindComponent( (LPWSTR)tvItem.lParam,
                                                     &pnccToBindUnbind );
                            if ( hr == S_OK ) {

                                if ( fBind ) {

                                    //
                                    // Bind the component to the selected component.
                                    //

                                    hr = pnccb->BindTo( pnccToBindUnbind );

                                    if ( !fChange ) {
                                        fChange = hr == S_OK;
                                    }

                                    if ( hr != S_OK ) {
                                        ErrMsg( hr,
                                                L"%s couldn't be bound to %s.",
                                                     lpszInfId, (LPWSTR)tvItem.lParam );
                                    }
                                }
                                else {
                                    //
                                    // Unbind the component from the selected component.
                                    //

                                    hr = pnccb->UnbindFrom( pnccToBindUnbind );

                                    if ( !fChange ) {
                                        fChange = hr == S_OK;
                                    }

                                    if ( hr != S_OK ) {
                                        ErrMsg( hr,
                                                L"%s couldn't be unbound from %s.",
                                                     lpszInfId, (LPWSTR)tvItem.lParam );
                                    }
                                }

                                ReleaseRef( pnccToBindUnbind );
                            }
                            else {
                                ErrMsg( hr,
                                        L"Couldn't get an interface pointer to %s. "
                                        L"%s will not be bound to it.",
                                        (LPWSTR)tvItem.lParam,
                                        lpszInfId );
                            }
                        }
                    }

                    //
                    // Get the next item.
                    //

                    hTreeItem = TreeView_GetNextSibling( hwndTree,
                                                         hTreeItem );
                }

                ReleaseRef( pnccb );
            }
            else {
                ErrMsg( hr,
                        L"Couldn't get a binding interface of %s.",
                        lpszInfId );
            }

            ReleaseRef( pncc );
        }
        else {
            ErrMsg( hr,
                    L"Couldn't get an interface pointer to %s.",
                    lpszInfId );
        }

        //
        // If one or more network components have been bound/unbound,
        // apply the changes.
        //

        if ( fChange ) {
            hr = pnc->Apply();

            fChange = hr == S_OK;
        }

        HrReleaseINetCfg( pnc,
                          TRUE );
    }
    else {
        if ( (hr == NETCFG_E_NO_WRITE_LOCK) && lpszApp ) {
            ErrMsg( hr,
                    L"%s currently holds the lock, try later.",
                    lpszApp );

            CoTaskMemFree( lpszApp );
        }
        else {
            ErrMsg( hr,
                    L"Couldn't get the notify object interface." );
        }
    }

    return fChange;
}

//
// Function:  ListInstalledComponents
//
// Purpose:   List installed network components of specific class.
//
// Arguments:
//    hwndTree      [in]  Tree handle in which to list.
//    pguidClass    [in]  Class GUID of the network compoent class.
//
// Returns:   None.
//
// Notes:
//

VOID ListInstalledComponents (HWND hwndTree,
                              const GUID *pguidClass)
{
    INetCfg              *pnc;
    IEnumNetCfgComponent *pencc;
    INetCfgComponent     *pncc;
    LPWSTR               lpszApp;
    HTREEITEM            hTreeItem;
    HRESULT              hr;


    hr = HrGetINetCfg( FALSE,
                       APP_NAME,
                       &pnc,
                       &lpszApp );

    if ( hr == S_OK ) {

        //
        // Get Component Enumerator Interface.
        //

        hr = HrGetComponentEnum( pnc,
                                 pguidClass,
                                 &pencc );
        if ( hr == S_OK ) {

            hr = HrGetFirstComponent( pencc, &pncc );

            while( hr == S_OK ) {

                //
                // Add an item to the tree for the network component.
                //

                hTreeItem = AddToTree( hwndTree,
                                       TVI_ROOT,
                                       pncc );

                ReleaseRef( pncc );

                hr = HrGetNextComponent( pencc, &pncc );
            }

            ReleaseRef( pencc );
        }
        else {
            ErrMsg( hr,
                    L"Failed to get the network component enumerator." );
        }

        HrReleaseINetCfg( pnc, FALSE );
    }
    else {
        if ( (hr == NETCFG_E_NO_WRITE_LOCK) && lpszApp ) {
            ErrMsg( hr,
                    L"%s currently holds the lock, try later.",
                    lpszApp );

            CoTaskMemFree( lpszApp );
        }
        else {
            ErrMsg( hr,
                    L"Couldn't get the notify object interface." );
        }
    }

    return;
}

//
// Function:  UninstallComponent
//
// Purpose:   Uninstall a network component.
//
// Arguments:
//    lpszInfId  [in]  PnpID of the network component to uninstall.
//
// Returns:   S_OK on success, otherwise an error code.
//
// Notes:
//

HRESULT UninstallComponent (LPWSTR lpszInfId)
{
    INetCfg              *pnc;
    INetCfgComponent     *pncc;
    INetCfgClass         *pncClass;
    INetCfgClassSetup    *pncClassSetup;
    LPWSTR               lpszApp;
    GUID                 guidClass;
    OBO_TOKEN            obo;
    HRESULT              hr;

    hr = HrGetINetCfg( TRUE,
                       APP_NAME,
                       &pnc,
                       &lpszApp );

    if ( hr == S_OK ) {

        //
        // Get a reference to the network component to uninstall.
        //

        hr = pnc->FindComponent( lpszInfId,
                                 &pncc );

        if ( hr == S_OK ) {

            //
            // Get the class GUID.
            //

            hr = pncc->GetClassGuid( &guidClass );

            if ( hr == S_OK ) {

                //
                // Get a reference to component's class.
                //

                hr = pnc->QueryNetCfgClass( &guidClass,
                                            IID_INetCfgClass,
                                            (PVOID *)&pncClass );
                if ( hr == S_OK ) {

                    //
                    // Get the setup interface.
                    //

                    hr = pncClass->QueryInterface( IID_INetCfgClassSetup,
                                                   (LPVOID *)&pncClassSetup );

                    if ( hr == S_OK ) {

                        //
                        // Uninstall the component.
                        //

                        ZeroMemory( &obo,
                                    sizeof(OBO_TOKEN) );

                        obo.Type = OBO_USER;

                        hr = pncClassSetup->DeInstall( pncc,
                                                       &obo,
                                                       NULL );
                        if ( (hr == S_OK) || (hr == NETCFG_S_REBOOT) ) {

                            hr = pnc->Apply();

                            if ( (hr != S_OK) && (hr != NETCFG_S_REBOOT) ) {
                                ErrMsg( hr,
                                        L"Couldn't apply the changes after"
                                        L" uninstalling %s.",
                                        lpszInfId );
                            }
                        }
                        else {
                            ErrMsg( hr,
                                    L"Failed to uninstall %s.",
                                    lpszInfId );
                        }

                        ReleaseRef( pncClassSetup );
                    }
                    else {
                        ErrMsg( hr,
                                L"Couldn't get an interface to setup class." );
                    }

                    ReleaseRef( pncClass );
                }
                else {
                    ErrMsg( hr,
                            L"Couldn't get a pointer to class interface "
                            L"of %s.",
                            lpszInfId );
                }
            }
            else {
                ErrMsg( hr,
                        L"Couldn't get the class guid of %s.",
                        lpszInfId );
            }

            ReleaseRef( pncc );
        }
        else {
            ErrMsg( hr,
                    L"Couldn't get an interface pointer to %s.",
                    lpszInfId );
        }

        HrReleaseINetCfg( pnc,
                          TRUE );
    }
    else {
        if ( (hr == NETCFG_E_NO_WRITE_LOCK) && lpszApp ) {
            ErrMsg( hr,
                    L"%s currently holds the lock, try later.",
                    lpszApp );

            CoTaskMemFree( lpszApp );
        }
        else {
            ErrMsg( hr,
                    L"Couldn't get the notify object interface." );
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\samples\bindview\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by BindView.rc
//
#define IDD_MAIN                        101
#define IDM_OPTIONS                     101
#define IDI_BINDVIEW                    105
#define IDD_BIND_UNBIND                 106
#define IDD_INSTALL                     107
#define IDD_UNINSTALL                   108
#define IDT_BINDINGS                    1000
#define IDB_INSTALL                     1001
#define IDB_UNINSTALL                   1002
#define IDS_COMPONENT                   1003
#define IDL_COMPONENT_TYPES             1004
#define IDB_EXPAND_ALL                  1005
#define IDB_COLLAPSE_ALL                1006
#define IDB_BROWSE                      1007
#define IDS_ENABLE                      1012
#define IDE_OWNER                       1013
#define IDE_DEPTH                       1014
#define IDB_BIND_UNBIND                 1016
#define IDG_COMPONENT_LIST              1018
#define IDB_CLOSE                       1021
#define IDB_REMOVE                      1022
#define IDT_COMPONENT_LIST              1024
#define IDB_SAVE                        1025
#define IDI_ENABLE                      40001
#define IDI_UNBIND_FROM                 40004
#define IDI_BIND_TO                     40005
#define IDI_CANCEL                      40006
#define IDI_DISABLE                     40007

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        109
#define _APS_NEXT_COMMAND_VALUE         40008
#define _APS_NEXT_CONTROL_VALUE         1028
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\samples\bindview\netcfgapi.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       N E T C F G A P I . H
//
//  Contents:   Functions Prototypes
//
//  Notes:      
//
//  Author:     Alok Sinha    15-May-01
//
//----------------------------------------------------------------------------

#ifndef _NETCFGAPI_H_INCLUDED

#define _NETCFGAPI_H_INCLUDED


#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <wchar.h>
#include <netcfgx.h>
#include <netcfgn.h>
#include <setupapi.h>
#include <devguid.h>
#include <objbase.h>

#define LOCK_TIME_OUT     5000

HRESULT HrGetINetCfg (IN BOOL fGetWriteLock,
                      IN LPCWSTR lpszAppName,
                      OUT INetCfg** ppnc,
                      OUT LPWSTR *lpszLockedBy);

HRESULT HrReleaseINetCfg (INetCfg* pnc,
                          BOOL fHasWriteLock);

HRESULT HrInstallNetComponent (IN INetCfg *pnc,
                               IN LPCWSTR szComponentId,
                               IN const GUID    *pguildClass,
                               IN LPCWSTR lpszInfFullPath);

HRESULT HrInstallComponent(IN INetCfg* pnc,
                           IN LPCWSTR szComponentId,
                           IN const GUID* pguidClass);

HRESULT HrUninstallNetComponent(IN INetCfg* pnc,
                                IN LPCWSTR szComponentId);

HRESULT HrGetComponentEnum (INetCfg* pnc,
                            IN const GUID* pguidClass,
                            IEnumNetCfgComponent **ppencc);

HRESULT HrGetFirstComponent (IEnumNetCfgComponent* pencc,
                             INetCfgComponent **ppncc);

HRESULT HrGetNextComponent (IEnumNetCfgComponent* pencc,
                            INetCfgComponent **ppncc);

HRESULT HrGetBindingPathEnum (INetCfgComponent *pncc,
                              DWORD dwBindingType,
                              IEnumNetCfgBindingPath **ppencbp);

HRESULT HrGetFirstBindingPath (IEnumNetCfgBindingPath *pencbp,
                               INetCfgBindingPath **ppncbp);

HRESULT HrGetNextBindingPath (IEnumNetCfgBindingPath *pencbp,
                               INetCfgBindingPath **ppncbp);

HRESULT HrGetBindingInterfaceEnum (INetCfgBindingPath *pncbp,
                                   IEnumNetCfgBindingInterface **ppencbi);

HRESULT HrGetFirstBindingInterface (IEnumNetCfgBindingInterface *pencbi,
                                    INetCfgBindingInterface **ppncbi);

HRESULT HrGetNextBindingInterface (IEnumNetCfgBindingInterface *pencbi,
                                   INetCfgBindingInterface **ppncbi);

VOID ReleaseRef (IUnknown* punk);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\samples\bindview\binding.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       B I N D I N G . C P P
//
//  Contents:   Functions to illustrate
//              o How to enumerate binding paths.
//              o How to enumerate binding interfaces.
//              o How to enable/disable bindings.
//
//  Notes:      
//
//  Author:     Alok Sinha    15-May-01
//
//----------------------------------------------------------------------------

#include "bindview.h"

//
// Function:  WriteBindings
//
// Purpose:   Write bindings to specified file.
//
// Arguments:
//    fp  [in]  File handle.
//
// Returns:   None.
//
// Notes:
//

VOID WriteBindings (FILE *fp)
{
    INetCfg              *pnc;
    IEnumNetCfgComponent *pencc;
    INetCfgComponent     *pncc;
    LPWSTR               lpszApp;
    HRESULT              hr;
    UINT                 i;


    hr = HrGetINetCfg( FALSE,
                       APP_NAME,
                       &pnc,
                       &lpszApp );

    if ( hr == S_OK ) {

        for (i=CLIENTS_SELECTED; i <= PROTOCOLS_SELECTED; ++i) {

            fwprintf( fp, L"--- Bindings of %s ---\n", lpszNetClass[i] );

            //
            // Get Component Enumerator Interface.
            //

            hr = HrGetComponentEnum( pnc,
                                     pguidNetClass[i],
                                     &pencc );
            if ( hr == S_OK ) {

                hr = HrGetFirstComponent( pencc, &pncc );

                while( hr == S_OK ) {

                    //
                    // Write bindings of the component.
                    //

                    WriteBindingPath( fp,
                                      pncc );
                    ReleaseRef( pncc );

                    fwprintf( fp, L"\n" );

                    hr = HrGetNextComponent( pencc, &pncc );
                }

                fwprintf( fp, L"\n" );

                //
                // S_FALSE merely indicates that there are no more components.
                //

                if ( hr == S_FALSE ) {
                    hr = S_OK;
                }

                ReleaseRef( pencc );
            }
            else {
                ErrMsg( hr,
                        L"Couldn't get the component enumerator interface." );
            }
        }

        HrReleaseINetCfg( pnc, FALSE );
    }
    else {
        if ( (hr == NETCFG_E_NO_WRITE_LOCK) && lpszApp ) {
            ErrMsg( hr,
                    L"%s currently holds the lock, try later.",
                    lpszApp );

            CoTaskMemFree( lpszApp );
        }
        else {
            ErrMsg( hr,
                    L"Couldn't get the notify object interface." );
        }
    }

    return;
}

//
// Function:  WriteBindingPath
//
// Purpose:   Write binding paths of a component.
//
// Arguments:
//    fp    [in]  File handle.
//    pncc  [in]  Network component.
//
// Returns:   None.
//
// Notes:
//

VOID WriteBindingPath (FILE *fp,
                       INetCfgComponent *pncc)
{
    IEnumNetCfgBindingPath  *pencbp;
    INetCfgBindingPath      *pncbp;
    LPWSTR                  lpszName;
    HRESULT                 hr;

    //
    // Write the first component's name.
    //

    hr = pncc->GetDisplayName( &lpszName );

    if ( hr == S_OK ) {
        fwprintf( fp, L"\n%s", lpszName );
    }
    else {
        ErrMsg( hr,
                L"Unable to get the display name of a component, "
                L" some binding paths will not be written." );

       return;
    }

    //
    // Get binding path enumerator.
    //

    hr = HrGetBindingPathEnum( pncc,
                               EBP_BELOW,
                               &pencbp );
    if ( hr == S_OK ) {

        hr = HrGetFirstBindingPath( pencbp,
                                    &pncbp );

        while( hr == S_OK ) {

            //
            // Write interfaces of the binding path.
            //

            WriteInterfaces( fp,
                             pncbp );

            ReleaseRef( pncbp );

            hr = HrGetNextBindingPath( pencbp,
                                       &pncbp );
            if ( hr == S_OK ) {
                fwprintf( fp, L"\n%s", lpszName );
            }
        }
  
        ReleaseRef( pencbp );
    }
    else {
        ErrMsg( hr,
                L"Couldn't get the binding path enumerator of %s. "
                L"Its binding paths will not be written.",
                lpszName );
    }

    CoTaskMemFree( lpszName );
    return;
}

//
// Function:  WriteInterfaces
//
// Purpose:   Write bindings to specified file.
//
// Arguments:
//    fp     [in]  File handle.
//    pncbp  [in]  Binding path.
//
// Returns:   None.
//
// Notes:
//

VOID WriteInterfaces (FILE *fp,
                      INetCfgBindingPath *pncbp)
{
    IEnumNetCfgBindingInterface *pencbi;
    INetCfgBindingInterface     *pncbi;
    INetCfgComponent            *pnccLower;
    LPWSTR                      lpszName;
    HRESULT                     hr;

    hr = HrGetBindingInterfaceEnum( pncbp,
                                    &pencbi );

    if ( hr == S_OK ) {

        hr = HrGetFirstBindingInterface( pencbi,
                                         &pncbi );

        //
        // Write lower component of each interface.
        //

        while( hr == S_OK ) {

            hr = pncbi->GetLowerComponent ( &pnccLower );

            if ( hr == S_OK ) {

                hr = pnccLower->GetDisplayName( &lpszName );
                if ( hr == S_OK ) {
                    fwprintf( fp, L"-->%s", lpszName );
                    CoTaskMemFree( lpszName );
                }
            }

            ReleaseRef( pnccLower );
            ReleaseRef( pncbi );

            hr = HrGetNextBindingInterface( pencbi,
                                            &pncbi );
        }

        ReleaseRef( pencbi );
    }
    else {
        ErrMsg( hr,
                L"Couldn't get the binding interface enumerator."
                L"The binding interfaces will not be shown." );
    }

    return;
}

//
// Function:  EnumNetBindings
//
// Purpose:   Enumerate components and their bindings.
//
// Arguments:
//    hwndTree        [in]  Tree handle.
//    uiTypeSelected  [in]  Type of network component selected.
//
// Returns:   TRUE on success.
//
// Notes:
//

BOOL EnumNetBindings (HWND hwndTree,
                      UINT uiTypeSelected)
{
    INetCfg              *pnc;
    IEnumNetCfgComponent *pencc;
    INetCfgComponent     *pncc;
    LPWSTR               lpszApp;
    HTREEITEM            hTreeItem;
    HRESULT              hr;


    hr = HrGetINetCfg( FALSE,
                       APP_NAME,
                       &pnc,
                       &lpszApp );

    if ( hr == S_OK ) {

        //
        // Get Component Enumerator Interface.
        //

        hr = HrGetComponentEnum( pnc,
                                 pguidNetClass[uiTypeSelected],
                                 &pencc );
        if ( hr == S_OK ) {

            hr = HrGetFirstComponent( pencc, &pncc );

            while( hr == S_OK ) {

                //
                // Add the component's name to the tree.
                //

                hTreeItem = AddToTree( hwndTree,
                                       TVI_ROOT,
                                       pncc );
                if ( hTreeItem ) {

                    //
                    // Enumerate bindings.
                    //

                    ListBindings( pncc,
                                  hwndTree,
                                  hTreeItem );
                }

                ReleaseRef( pncc );

                hr = HrGetNextComponent( pencc, &pncc );
            }

            //
            // S_FALSE merely indicates that there are no more components.
            //

            if ( hr == S_FALSE ) {
                hr = S_OK;
            }

            ReleaseRef( pencc );
        }
        else {
            ErrMsg( hr,
                    L"Couldn't get the component enumerator interface." );
        }

        HrReleaseINetCfg( pnc, FALSE );
    }
    else {
        if ( (hr == NETCFG_E_NO_WRITE_LOCK) && lpszApp ) {
            ErrMsg( hr,
                    L"%s currently holds the lock, try later.",
                    lpszApp );

            CoTaskMemFree( lpszApp );
        }
        else {
            ErrMsg( hr,
                    L"Couldn't get the notify object interface." );
        }
    }

    return hr == S_OK;
}

//
// Function:  ListBindings
//
// Purpose:   Enumerate bindings of network components.
//
// Arguments:
//    pncc          [in]  Network component.
//    hwndTree      [in]  Tree handle.
//    hTreeItemRoot [in]   Parent item.
//
// Returns:   None.
//
// Notes:
//

VOID ListBindings (INetCfgComponent *pncc,
                   HWND hwndTree,
                   HTREEITEM hTreeItemRoot)
{
    IEnumNetCfgBindingPath      *pencbp;
    INetCfgBindingPath          *pncbp;
    HTREEITEM                   hTreeItem;
    ULONG                       ulIndex;
    HRESULT                     hr;
  
    hr = HrGetBindingPathEnum( pncc,
                               EBP_BELOW,
                               &pencbp );
    if ( hr == S_OK ) {

        hr = HrGetFirstBindingPath( pencbp,
                                    &pncbp );

        ulIndex = 1;

        while( hr == S_OK ) {

            //
            // Add an item for the binding path.
            //

            hTreeItem = AddBindNameToTree( pncbp,
                                           hwndTree,
                                           hTreeItemRoot,
                                           ulIndex );

            if ( hTreeItem ) {

                //
                // Enumerate interfaces.
                //

                ListInterfaces( pncbp,
                                hwndTree,
                                hTreeItem );
            }

            ReleaseRef( pncbp );

            hr = HrGetNextBindingPath( pencbp,
                                       &pncbp );

            ulIndex++;
        }
  
        ReleaseRef( pencbp );
    }
    else {
       LPWSTR  lpszName;

       if ( pncc->GetDisplayName(&lpszName) == S_OK ) {

          ErrMsg( hr,
                  L"Couldn't get the binding path enumerator of %s. "
                  L"Its binding paths will not be shown.",
                  lpszName );

          CoTaskMemFree( lpszName );
       }
       else {
          ErrMsg( hr,
                  L"Couldn't get the binding path enumerator of a "
                  L"network component. The binding paths will not "
                  L"be shown." );
       }
    }

    return;
}

//
// Function:  ListInterfaces
//
// Purpose:   Enumerate interfaces of a binding path.
//
// Arguments:
//    pncbp         [in]  Binding path.
//    hwndTree      [in]  Tree handle.
//    hTreeItemRoot [in]  Parent item.
//
// Returns:   None.
//
// Notes:
//

VOID ListInterfaces (INetCfgBindingPath *pncbp,
                     HWND hwndTree,
                     HTREEITEM hTreeItemRoot)
{
    IEnumNetCfgBindingInterface *pencbi;
    INetCfgBindingInterface     *pncbi;
    INetCfgComponent            *pnccBound;
    HTREEITEM                   hTreeItem;
    HRESULT                     hr;

    hr = HrGetBindingInterfaceEnum( pncbp,
                                    &pencbi );

    if ( hr == S_OK ) {

        hr = HrGetFirstBindingInterface( pencbi,
                                         &pncbi );
        hTreeItem = hTreeItemRoot;

        while( (hr == S_OK) && hTreeItem ) {

            //
            // Add lower component of every interface to the tree.
            //

            hr = pncbi->GetLowerComponent( &pnccBound );

            hTreeItem = AddToTree( hwndTree,
                                   hTreeItem,
                                   pnccBound );

            ReleaseRef( pnccBound );
            ReleaseRef( pncbi );

            hr = HrGetNextBindingInterface( pencbi,
                                            &pncbi );
        }

        //
        // If hr is S_OK then, the loop terminated due to error in adding
        // the binding path to the tree and pncbi has a reference to an
        // interface.
        //

        if ( hr == S_OK ) {

            ReleaseRef( pncbi );
        }

        ReleaseRef( pencbi );
    }
    else {
        ErrMsg( hr,
                L"Couldn't get the binding interface enumerator."
                L"The binding interfaces will not be shown." );
    }

    return;
}

//
// Function:  HandleBindingPathOperation
//
// Purpose:   
//
// Arguments:
//    hwndOwner    [in]  Owner window.
//    ulSelection  [in]  Option selected.
//    hItem        [in]  Item selected.
//    lParam       [in]  lParam of the item.
//
// Returns:   None.
//
// Notes:
//

VOID HandleBindingPathOperation (HWND hwndOwner,
                                 ULONG ulSelection,
                                 HTREEITEM hItem,
                                 LPARAM lParam)
{
    switch( ulSelection ) {

        case IDI_ENABLE:
        case IDI_DISABLE:

            //
            // Enable/disable binding path.
            //

            EnableBindingPath( hwndOwner,
                               hItem,
                               (LPWSTR)lParam,
                               ulSelection == IDI_ENABLE );
    }

    return;
}

//
// Function:  EnableBindingPath
//
// Purpose:   Enable/disable binding path.
//
// Arguments:
//    hwndOwner      [in]  Owner window.
//    hItem          [in]  Item handle of the binding path.
//    lpszPathToken  [in]  Path token of the binding path.
//    fEnable        [in]  if TRUE, enable, otherwise disable.
//
// Returns:   None.
//
// Notes:
//

VOID EnableBindingPath (HWND hwndOwner,
                        HTREEITEM hItem,
                        LPWSTR lpszPathToken,
                        BOOL fEnable)
{
    INetCfg              *pnc;
    INetCfgBindingPath   *pncbp;
    LPWSTR               lpszInfId;
    LPWSTR               lpszApp;
    HRESULT              hr;

    //
    // Get PnpID of the owner component.
    //

    lpszInfId = GetComponentId( hwndOwner,
                                hItem );

    if ( lpszInfId ) {

        hr = HrGetINetCfg( TRUE,
                           APP_NAME,
                           &pnc,
                           &lpszApp );

        if ( hr == S_OK ) {

            //
            // Find the binding path reference.
            //

            pncbp = FindBindingPath( pnc,
                                     lpszInfId,
                                     lpszPathToken );

            if ( pncbp ) {

                //
                // Enable/disable.
                //

                hr = pncbp->Enable( fEnable );

                if ( hr == S_OK ) {
                    hr = pnc->Apply();

                    if ( hr == S_OK ) {

                        //
                        // Refreshe the state of the item representing the
                        // binding path.
                        //

                        RefreshItemState( hwndOwner,
                                          hItem,
                                          fEnable );
                    }
                    else {
                        ErrMsg( hr,
                                L"Failed to apply changes to the binding path." );
                    }
                }
                else {
                    if ( fEnable ) {
                        ErrMsg( hr,
                                L"Failed to enable the binding path." );
                    }
                    else {
                        ErrMsg( hr,
                                L"Failed to disable the binding path." );
                    }
                }

                ReleaseRef( pncbp );
            }

            HrReleaseINetCfg( pnc,
                             TRUE );
        }
        else {
            if ( (hr == NETCFG_E_NO_WRITE_LOCK) && lpszApp ) {
               ErrMsg( hr,
                       L"%s currently holds the lock, try later.",
                       lpszApp );

               CoTaskMemFree( lpszApp );
            }
            else {
               ErrMsg( hr,
                       L"Couldn't get the notify object interface." );
            }
        }
    }
    else {
          ErrMsg( HRESULT_FROM_WIN32(GetLastError()),
                  L"Couldn't determine the owner of the binding path." );
    }

    return;
}

//
// Function:  GetComponentId
//
// Purpose:   Find the PnpID of a network component.
//
// Arguments:
//    hwndTree  [in]  Tree handle.
//    hItem     [in]  Item handle of the binding path.
//
// Returns:   PnpID of the network component.
//
// Notes:
//

LPWSTR GetComponentId (HWND hwndTree,
                       HTREEITEM hItem)
{
    LPWSTR       lpszInfId;
    HTREEITEM    hTreeItemParent;
    TVITEMW      tvItem;

    lpszInfId = NULL;

    //
    // Get the item handle of the owner component.
    //

    hTreeItemParent = TreeView_GetParent( hwndTree,
                                          hItem );
    if ( hTreeItemParent ) {

        //
        // Get lParam of the owner component. lParam is the PnpID.
        //

        ZeroMemory( &tvItem,
                    sizeof(TVITEMW) );

        tvItem.hItem = hTreeItemParent;
        tvItem.mask = TVIF_PARAM;

        if ( TreeView_GetItem(hwndTree,
                              &tvItem) ) {

            lpszInfId = (LPWSTR)tvItem.lParam;
        }
    }

    return lpszInfId;
}

//
// Function:  WriteBindings
//
// Purpose:   Find the binding path with a give path token.
//
// Arguments:
//    pnc                    [in]  INetCfg reference.
//    lpszInfId              [in]  PnpID of the network component.
//    lpszPathTokenSelected  [in]  Path token of the binding path to search.
//
// Returns:   Reference to the binding path on success, otherwise NULL.
//
// Notes:
//

INetCfgBindingPath *FindBindingPath (INetCfg *pnc,
                                     LPWSTR lpszInfId,
                                     LPWSTR lpszPathTokenSelected)
{
    INetCfgComponent       *pncc;
    IEnumNetCfgBindingPath *pencbp;
    INetCfgBindingPath     *pncbp;
    LPWSTR                 lpszPathToken;
    HRESULT                hr;
    BOOL                   fFound;


    fFound = FALSE;

    //
    // Get the component reference.
    //

    hr = pnc->FindComponent( lpszInfId,
                             &pncc );

    if ( hr == S_OK ) {
     
        hr = HrGetBindingPathEnum( pncc,
                                   EBP_BELOW,
                                   &pencbp );
        if ( hr == S_OK ) {

            hr = HrGetFirstBindingPath( pencbp,
                                        &pncbp );

            // Enumerate each binding path and find the one
            // whose path token matches the specified one.
            //

            while ( !fFound && (hr == S_OK) ) {

                hr = pncbp->GetPathToken( &lpszPathToken );

                if ( hr == S_OK ) {
                    fFound = !wcscmp( lpszPathToken,
                                       lpszPathTokenSelected );

                    CoTaskMemFree( lpszPathToken );
                }

                if ( !fFound ) {
                    ReleaseRef( pncbp );

                    hr = HrGetNextBindingPath( pencbp,
                                               &pncbp );
                }
            }

            ReleaseRef( pencbp );
        }
        else {
            ErrMsg( hr,
                    L"Couldn't get the binding path enumerator interface." );
        }
    }
    else {
        ErrMsg( hr,
                L"Couldn't get an interface pointer to %s.",
                lpszInfId );
    }

    return (fFound) ? pncbp : NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\samples\bindview\bindview.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       B I N D V I E W . C P P
//
//  Contents:  
//
//  Notes:      
//
//  Author:     Alok Sinha    15-Amy-01
//
//----------------------------------------------------------------------------


#include "BindView.h"

//----------------------------------------------------------------------------
// Globals
//

//
// Image list for devices of various setup class.
//

SP_CLASSIMAGELIST_DATA ClassImageListData;

HINSTANCE              hInstance;
HMENU                  hMainMenu;
HMENU                  hComponentSubMenu;
HMENU                  hBindingPathSubMenu;

//
// Network components whose bindings are enumerated.
//

LPWSTR   lpszNetClass[] = {
                    L"All Clients",
                    L"All Services",
                    L"All Protocols"
         };

//
// GUIDs of network components.
//

const GUID     *pguidNetClass [] = {
                     &GUID_DEVCLASS_NETCLIENT,
                     &GUID_DEVCLASS_NETSERVICE,
                     &GUID_DEVCLASS_NETTRANS,
                     &GUID_DEVCLASS_NET
         };

//
// Program entry point.
//

int APIENTRY WinMain (HINSTANCE hInst,
                      HINSTANCE hPrevInstance, 
                      LPSTR lpCmdLine,         
                      int nCmdShow )           
{
    //
    // Make sure common control DLL is loaded.
    //

    hInstance = hInst;

    InitCommonControls();

    if ( DialogBoxW(hInst,
                    MAKEINTRESOURCEW(IDD_MAIN), 
                    NULL,
                    MainDlgProc) == -1 ) {

        ErrMsg( HRESULT_FROM_WIN32(GetLastError()),
                L"Failed to create the main dialog box, exiting..." );
    }

    return 0;
}

//
// WndProc for the main dialog box.
//

INT_PTR CALLBACK MainDlgProc (HWND hwndDlg,
                              UINT uMsg,
                              WPARAM wParam,
                              LPARAM lParam)
{
    HWND   hwndBindingTree;
    HICON  hIcon;

    switch (uMsg) {

        case WM_INITDIALOG:

            hIcon = LoadIcon( hInstance,
                              MAKEINTRESOURCE(IDI_BINDVIEW) );

            if ( !hIcon ) {
                ErrMsg( HRESULT_FROM_WIN32(GetLastError()),
                        L"Couldn't load the program icon, exiting..." );

                return FALSE;
            }

            SetClassLongPtr( hwndDlg,
                              GCLP_HICON,
                              (LONG_PTR)hIcon );

            hMainMenu = LoadMenu( hInstance,
                                  MAKEINTRESOURCE(IDM_OPTIONS) );

            if ( !hMainMenu ) {

                ErrMsg( HRESULT_FROM_WIN32(GetLastError()),
                        L"Couldn't load the program menu, exiting..." );

                return FALSE;
            }

            hComponentSubMenu = GetSubMenu( hMainMenu,
                                            0 );

            hBindingPathSubMenu = GetSubMenu( hMainMenu,
                                              1 );

            if ( !hComponentSubMenu || !hBindingPathSubMenu ) {

                ErrMsg( HRESULT_FROM_WIN32(GetLastError()),
                        L"Couldn't load the program menu, exiting..." );

                DestroyMenu( hMainMenu );
                return FALSE;
            }

            //
            // Add the network components types whose bindings are shown.
            //

            UpdateComponentTypeList( GetDlgItem(hwndDlg,
                                                IDL_COMPONENT_TYPES) );

            //
            // Load and associate the image list of all device classes with
            // tree.
            //

            hwndBindingTree = GetDlgItem( hwndDlg,
                                          IDT_BINDINGS );

            ZeroMemory( &ClassImageListData, sizeof(SP_CLASSIMAGELIST_DATA) );
            ClassImageListData.cbSize = sizeof(SP_CLASSIMAGELIST_DATA);

            if ( SetupDiGetClassImageList(&ClassImageListData) == TRUE ) {

                TreeView_SetImageList( hwndBindingTree,
                                       ClassImageListData.ImageList,
                                       LVSIL_NORMAL );
            }
            else {

                //
                // In case, we failed to load the image list, abort.
                //

                ErrMsg( HRESULT_FROM_WIN32(GetLastError()),
                        L"Couldn't load the image list of "
                        L"device classes, exiting..." );

                DestroyMenu( hMainMenu );
                return FALSE;
            }

            //
            // Enumerate  the bindings of the network component selected by default.
            //

            EnumNetBindings( hwndBindingTree,
                             DEFAULT_COMPONENT_SELECTED );

            return TRUE; // Tell Windows to continue creating the dialog box.

        case WM_COMMAND:

            switch( LOWORD(wParam) ) {

                case IDL_COMPONENT_TYPES:

                    if ( HIWORD(wParam) == CBN_SELCHANGE ) {

                        //
                        // User has selected a new network component type.
                        //

                        RefreshAll( hwndDlg );
                    }

                    break;

                case IDB_EXPAND_ALL:
                case IDB_COLLAPSE_ALL:

                    if ( HIWORD(wParam) == BN_CLICKED ) {

                        HTREEITEM hItem;
                        //
                        // Expand/Collapse the entire tree.
                        //

                        hwndBindingTree = GetDlgItem( hwndDlg,
                                                      IDT_BINDINGS );

                        hItem = TreeView_GetSelection( hwndBindingTree );

                        ExpandCollapseAll( hwndBindingTree,
                                           TVI_ROOT,
                                           (LOWORD(wParam) == IDB_EXPAND_ALL) ?
                                           TVE_EXPAND : TVE_COLLAPSE );

                        TreeView_SelectSetFirstVisible( hwndBindingTree,
                                                        hItem );
                    }
                    
                    break;

                case IDB_SAVE:

                    if ( HIWORD(wParam) == BN_CLICKED ) {

                        //
                        // Save the binding information to a file.
                        //

                        WCHAR lpszFile[MAX_PATH+1];

                        if ( GetFileName(hwndDlg,
                                         L"Text files (*.txt)\0*.txt\0",
                                         L"Select a file name",
                                         OFN_DONTADDTORECENT | OFN_PATHMUSTEXIST | OFN_OVERWRITEPROMPT,
                                         lpszFile,
                                         L"txt",
                                         TRUE) ) {

                            DumpBindings( lpszFile );
                        }
                    }

                    break;

                case IDB_INSTALL:

                    if ( HIWORD(wParam) == BN_CLICKED ) {

                        // 
                        // Install a network component.
                        //

                        if ( (BOOL)DialogBoxW(hInstance,
                                    MAKEINTRESOURCEW(IDD_INSTALL),
                                    hwndDlg,
                                    InstallDlg) == TRUE ) {

                            RefreshAll( hwndDlg );
                        }
                    }

                    break;

                case IDB_UNINSTALL:

                    if ( HIWORD(wParam) == BN_CLICKED ) {

                        // 
                        // Uninstall a network component.
                        //

                        if ( (BOOL)DialogBoxW(hInstance,
                                    MAKEINTRESOURCEW(IDD_UNINSTALL),
                                    hwndDlg,
                                    UninstallDlg) == TRUE ) {

                            RefreshAll( hwndDlg );
                        }
                    }
            }

            break;

        case WM_NOTIFY:
            {
                LPNMHDR       lpnm;

                lpnm = (LPNMHDR)lParam;

                if ( (lpnm->idFrom == IDT_BINDINGS) &&
                      (lpnm->code == NM_RCLICK) ) {
      
                    //
                    // A network component or a binding path is selected
                    // with a righ-click.
                    //

                    ProcessRightClick( lpnm );

                    //
                    // Tell Windows that the righ-click has been handled
                    // us.
                    //

                    return TRUE;
                }
            }
            break;

        case WM_SYSCOMMAND:

            if ( (0xFFF0 & wParam) == SC_CLOSE ) {

                //
                // Before exiting, make sure to delete the image list
                // and the buffers associated with each item in the tree.
                //

                SetupDiDestroyClassImageList( &ClassImageListData );

                ReleaseMemory( GetDlgItem(hwndDlg, IDT_BINDINGS),
                               TVI_ROOT );

                DestroyMenu( hMainMenu );
                EndDialog( hwndDlg, 0 );
            }
    }

    return FALSE;
}

//
// WndProc of the dialog box for binding/unbinding compoents.
//

INT_PTR CALLBACK BindComponentDlg (HWND hwndDlg,
                                   UINT uMsg,
                                   WPARAM wParam,
                                   LPARAM lParam)
{
    LPBIND_UNBIND_INFO lpBindUnbind;

    switch (uMsg) {

        case WM_INITDIALOG:
            {
                DWORD dwCount;

                //
                // Save the lParam which is an index to the selected network
                // component.
                //

                SetWindowLongPtr( hwndDlg,
                                  DWLP_USER,
                                  (LONG_PTR)lParam );

                lpBindUnbind = (LPBIND_UNBIND_INFO)lParam;

                //
                // fBindTo is TRUE when the user wants to bind the selected
                // component to other components. So, we list the components
                // that are not bound and can bind.
                //
                //
                // fBindTo is FALSE when the user wants to unbind the selected
                // component from other components. So, we list the components
                // that are bound to it.
                //
                //
                // ListCompToBindUnbind returns number of components added to
                // the list. Keep track of it. If it zero then, we don't want to
                // show this dialog box.
                //

                dwCount = ListCompToBindUnbind(
                                      lpBindUnbind->lpszInfId,
                                      ADAPTERS_SELECTED,
                                      GetDlgItem(hwndDlg, IDT_COMPONENT_LIST),
                                      lpBindUnbind->fBindTo == FALSE );

                dwCount += ListCompToBindUnbind(
                                      lpBindUnbind->lpszInfId,
                                      CLIENTS_SELECTED,
                                      GetDlgItem(hwndDlg, IDT_COMPONENT_LIST),
                                      lpBindUnbind->fBindTo == FALSE );

                dwCount += ListCompToBindUnbind(
                                      lpBindUnbind->lpszInfId,
                                      SERVICES_SELECTED,
                                      GetDlgItem(hwndDlg, IDT_COMPONENT_LIST),
                                      lpBindUnbind->fBindTo == FALSE );

                dwCount += ListCompToBindUnbind(
                                      lpBindUnbind->lpszInfId,
                                      PROTOCOLS_SELECTED,
                                      GetDlgItem(hwndDlg, IDT_COMPONENT_LIST),
                                      lpBindUnbind->fBindTo == FALSE );

                if ( dwCount > 0 ) {

                    //
                    // Since the same dialog box is used for unbind opration,
                    // we need to update the text on the button to reflect that
                    // it is a bind operation.
                    //

                    if ( lpBindUnbind->fBindTo == FALSE ) {

                        SetWindowTextW( hwndDlg,
                                       L"Unbind From Network Components" );

                        SetWindowTextW( GetDlgItem(hwndDlg, IDB_BIND_UNBIND),
                                        L"Unbind" );

                        SetWindowTextW( GetDlgItem(hwndDlg, IDG_COMPONENT_LIST),
                                        L"Select components to unbind from" );
                    }
                }
                else {
                    if ( lpBindUnbind->fBindTo == TRUE ) {
                      ErrMsg( 0,
                                L"There no network components that can "
                                L"bind to the selected component." );
                    }
                    else {
                      ErrMsg( 0,
                                L"There no network components that are "
                                L"bound to the selected component." );
                    }

                    PostMessage( hwndDlg, WM_NO_COMPONENTS, 0, 0 );
                }

                return TRUE;
            }

        case WM_NO_COMPONENTS:
            EndDialog( hwndDlg, 0 );
            break;

        case WM_COMMAND:

            if ( (LOWORD(wParam) == IDB_CLOSE) &&
                 (HIWORD(wParam) == BN_CLICKED) ) {

                //
                // Before deleting the list in the tree, free the buffer
                // associated with each item. The buffer holds the
                // INF Id of network components.
                //
   
                ReleaseMemory( GetDlgItem(hwndDlg, IDT_COMPONENT_LIST),
                               TVI_ROOT );

                EndDialog( hwndDlg, 0 );
            }
            else {

                //
                // User wants to bind/unbind.
                //

                if ( (LOWORD(wParam) == IDB_BIND_UNBIND) &&
                     (HIWORD(wParam) == BN_CLICKED) ) {

           

                    lpBindUnbind = (LPBIND_UNBIND_INFO)GetWindowLongPtr( hwndDlg,
                                                                         DWLP_USER );

                    if ( BindUnbind(lpBindUnbind->lpszInfId,
                                    GetDlgItem(hwndDlg, IDT_COMPONENT_LIST),
                                    lpBindUnbind->fBindTo) ) {

                        RefreshBindings( hwndDlg,
                                         lpBindUnbind->lpszInfId );
                    }

                    ReleaseMemory( GetDlgItem(hwndDlg, IDT_COMPONENT_LIST),
                                   TVI_ROOT );
                    EndDialog( hwndDlg, 0 );
                }
            }
            break;
             
        case WM_SYSCOMMAND:

            if ( (0xFFF0 & wParam) == SC_CLOSE ) {

                //
                // Before deleting the list in the tree, free the buffer
                // associated with each item. The buffer holds the
                // INF Id of network components.
                //
  
                ReleaseMemory( GetDlgItem(hwndDlg, IDT_COMPONENT_LIST),
                               TVI_ROOT );

                EndDialog( hwndDlg, 0 );
            }
    }

    return FALSE;
}

//
//WndProc of the dialog box for installing network components.
//

INT_PTR CALLBACK InstallDlg (HWND hwndDlg,
                             UINT uMsg,
                             WPARAM wParam,
                             LPARAM lParam)
{
    switch (uMsg) {

        case WM_INITDIALOG:
            {
                HWND     hwndTree;

                //
                // List types of network components e.g. client,
                // protocol and service.
                //

                hwndTree = GetDlgItem( hwndDlg,
                                       IDT_COMPONENT_LIST );

                TreeView_SetImageList( hwndTree,
                                       ClassImageListData.ImageList,
                                       LVSIL_NORMAL );

                //
                // Insert and select client by default.
                //

                TreeView_Select( hwndTree,
                                 InsertItem(hwndTree,
                                            CLIENTS_SELECTED),
                                 TVGN_CARET );

                InsertItem( hwndTree,
                            SERVICES_SELECTED );

                InsertItem( hwndTree,
                            PROTOCOLS_SELECTED );

                //
                // Initialize it to FALSE. It will be set to TRUE when
                // at least one component is installed.
                //

                SetWindowLongPtr( hwndDlg,
                                  DWLP_USER,
                                  (LONG_PTR)FALSE );
                return TRUE;
            }

        case WM_COMMAND:

            switch( LOWORD(wParam) ) {

                case IDB_INSTALL:

                    //
                    // Install from Windows system directory.
                    //

                    if ( HIWORD(wParam) == BN_CLICKED ) {

                        InstallSelectedComponentType( hwndDlg, NULL );
                    }
                    break;

                case IDB_BROWSE:

                    //
                    // User wants to specify an INF file for the network
                    // to install.
                    //
                    if ( HIWORD(wParam) == BN_CLICKED ) {

                        WCHAR lpszInfFile[MAX_PATH+1];

                        if ( GetFileName(hwndDlg,
                                         L"INF files (*.inf)\0*.inf\0",
                                         L"Select the INF file of the network component to install",
                                         OFN_DONTADDTORECENT | OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST,
                                         lpszInfFile,
                                         NULL,
                                         FALSE) ) {

                            InstallSelectedComponentType( hwndDlg,
                                                          lpszInfFile );
                        }
                    }
                    break;

                case IDB_CLOSE:

                    if ( HIWORD(wParam) == BN_CLICKED ) {

                        //
                        // Return the value of DWLP_USER to indicate whether one or
                        // more components have been installed. Accordingly, the 
                        // the list will be refreshed.
                        //

                        EndDialog( hwndDlg,
                                   GetWindowLongPtr(hwndDlg, DWLP_USER) );
                    }
            } 
            break;

        case WM_NOTIFY:
            {
                LPNMHDR       lpnm;

                lpnm = (LPNMHDR)lParam;

                if ( (lpnm->idFrom == IDT_COMPONENT_LIST) &&
                    (lpnm->code == NM_DBLCLK) ) {

                    //
                    // On double-click, install from Windows system directory.
                    //

                    InstallSelectedComponentType( hwndDlg, NULL );
                    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, TRUE);
                    return TRUE;
                }
             }
             break;

        case WM_SYSCOMMAND:

            if ( (0xFFF0 & wParam) == SC_CLOSE ) {
 
                //
                // Return the value of DWLP_USER to indicate whether one or
                // more components have been installed. Accordingly, the 
                // the list will be refreshed.
                //

                EndDialog( hwndDlg,
                           GetWindowLongPtr(hwndDlg, DWLP_USER) );
            }
    }

    return FALSE;
}

//
// WndProc of the dialog box for uninstalling a network component.
//

INT_PTR CALLBACK UninstallDlg (HWND hwndDlg,
                               UINT uMsg,
                               WPARAM wParam,
                               LPARAM lParam)
{
    HWND     hwndTree;

    switch (uMsg) {

        case WM_INITDIALOG:

            hwndTree = GetDlgItem( hwndDlg,
                                   IDT_COMPONENT_LIST );
            TreeView_SetImageList( hwndTree,
                                   ClassImageListData.ImageList,
                                   LVSIL_NORMAL );

            //
            // List all the compoents currently installed.
            //

            ListInstalledComponents( hwndTree,
                                     &GUID_DEVCLASS_NETCLIENT);
            ListInstalledComponents( hwndTree,
                                     &GUID_DEVCLASS_NETSERVICE );
            ListInstalledComponents( hwndTree,
                                     &GUID_DEVCLASS_NETTRANS );

            //
            // Initialize it to FALSE. It will be set to TRUE when
            // at least one component is installed.
            //

            SetWindowLongPtr( hwndDlg,
                              DWLP_USER,
                              (LONG_PTR)FALSE );
            return TRUE;

        case WM_COMMAND:

            switch( LOWORD(wParam) ) {

                case IDB_REMOVE:

                    if ( HIWORD(wParam) == BN_CLICKED ) {

                        //
                        // Uninstall the selected component.
                        //

                        UninstallSelectedComponent( hwndDlg );

                    }
                    break;

                case IDB_CLOSE:

                    if ( HIWORD(wParam) == BN_CLICKED ) {
  
                        hwndTree = GetDlgItem( hwndDlg,
                                               IDT_COMPONENT_LIST );
                        ReleaseMemory( hwndTree,
                                       TVI_ROOT );

                        //
                        // Return the value of DWLP_USER to indicate whether one or
                        // more components have been installed. Accordingly, the 
                        // the list will be refreshed.
                        //

                        EndDialog( hwndDlg,
                                   GetWindowLongPtr(hwndDlg, DWLP_USER) );
                    }
            } 

            break;

        case WM_NOTIFY:
            {
                LPNMHDR       lpnm;

                lpnm = (LPNMHDR)lParam;

                if ( (lpnm->idFrom == IDT_COMPONENT_LIST) &&
                    (lpnm->code == NM_DBLCLK) ) {

                    UninstallSelectedComponent( hwndDlg );
                    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, TRUE);
                    return TRUE;
                }
             }
             break;

        case WM_SYSCOMMAND:

            if ( (0xFFF0 & wParam) == SC_CLOSE ) {

                hwndTree = GetDlgItem( hwndDlg,
                                       IDT_COMPONENT_LIST );
                ReleaseMemory( hwndTree,
                               TVI_ROOT );

                //
                // Return the value of DWLP_USER to indicate whether one or
                // more components have been installed. Accordingly, the 
                // the list will be refreshed.
                //

                EndDialog( hwndDlg,
                           GetWindowLongPtr(hwndDlg, DWLP_USER) );
            }
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
// Function:  DumpBindings
//
// Purpose:   Write the binding information.
//
// Arguments:
//    lpszFile [in]  Name of the file in which to write.
//
// Returns:   None
//
// Notes:
//

VOID DumpBindings (LPWSTR lpszFile)
{
    FILE *fp;

    fp = _wfopen( lpszFile,
                  L"w" );

    if ( fp == NULL ) {

        ErrMsg( 0,
                L"Unable to open %s.",
                lpszFile );
    }
    else {
        WriteBindings( fp );

        fclose( fp );
    }

    return;
}

//
// Function:  InstallSelectedComponentType
//
// Purpose:   Install a network component.
//
// Arguments:
//    hwndDlg     [in]  Handle to Install dialog box.
//    lpszInfFile [in]  Inf file of the network component.
//
// Returns:   None
//
// Notes:
//       If lpszInfFile is NULL, network components are installed from the
//       system directory.
//       

VOID InstallSelectedComponentType (HWND hwndDlg,
                                   LPWSTR lpszInfFile)
{
    HWND      hwndTree;
    HTREEITEM hItem;
    LPARAM    lParam;
    HCURSOR   hPrevCursor;
    HCURSOR   hWaitCursor;
    HWND      hwndFocus;
    DWORD     dwType;
    BOOL      fEnable;
    HRESULT   hr;

    hwndTree = GetDlgItem( hwndDlg,
                           IDT_COMPONENT_LIST );

    //
    // Find out the type of component selected.
    //

    hItem = TreeView_GetSelection( hwndTree );

    if ( hItem ) {
        if ( GetItemInfo( hwndTree,
                          hItem,
                          &lParam,
                          &dwType,
                          &fEnable) ) {

            //
            // Disable the install dialog controls.
            //

            hwndFocus = GetFocus();

            hWaitCursor = LoadCursor( NULL,
                                      IDC_WAIT );
            if ( hWaitCursor ) {
                hPrevCursor = SetCursor( hWaitCursor );
            }

            EnableWindow( hwndTree, FALSE );
            EnableWindow( GetDlgItem(hwndDlg,IDB_INSTALL),
                          FALSE );
            EnableWindow( GetDlgItem(hwndDlg,IDB_BROWSE),
                          FALSE );
            EnableWindow( GetDlgItem(hwndDlg,IDB_CLOSE),
                          FALSE );

            if ( lpszInfFile ) {

                LPWSTR  lpszPnpID;

                //
                // Inf file name specified, install the network component
                // from this file.
                //

                hr = GetPnpID( lpszInfFile, &lpszPnpID );

                if ( hr == S_OK ) {

                    hr = InstallSpecifiedComponent( lpszInfFile,
                                                    lpszPnpID,
                                                    pguidNetClass[(UINT)lParam] );

                    CoTaskMemFree( lpszPnpID );
                }
                else {
                    ErrMsg( hr,
                            L"Error reading the INF file %s.",
                            lpszInfFile );
                }
            }
            else {

                //
                // Install from system directory.
                //

                hr = InstallComponent( hwndTree,
                                       pguidNetClass[(UINT)lParam] );
            }

            if ( hWaitCursor ) {
                SetCursor( hPrevCursor );
            }

            switch( hr ) {

                case S_OK:
                    MessageBoxW(
                           hwndDlg,
                           L"Component installed successfully.",
                           L"Network Component Installation",
                           MB_OK | MB_ICONINFORMATION );
                           SetWindowLongPtr( hwndDlg,
                                             DWLP_USER,
                                             (LONG_PTR)TRUE );
                           break;

                case NETCFG_S_REBOOT:
                    MessageBoxW(
                          hwndDlg,
                          L"Component installed successfully: "
                          L"Reboot required.",
                          L"Network Component Installation",
                          MB_OK | MB_ICONINFORMATION );
                          SetWindowLongPtr( hwndDlg,
                                            DWLP_USER,
                                            (LONG_PTR)TRUE );

            }

            //
            // Enable the install dialog controls.
            //

            EnableWindow( hwndTree, TRUE );
            EnableWindow( GetDlgItem(hwndDlg,IDB_INSTALL),
                          TRUE );
            EnableWindow( GetDlgItem(hwndDlg,IDB_BROWSE),
                          TRUE );
            EnableWindow( GetDlgItem(hwndDlg,IDB_CLOSE),
                          TRUE );

            SetFocus( hwndFocus );
        }
    }

    return;
}

//
// Function:  GetPnpID
//
// Purpose:   Retrieve PnpID from an inf file.
//
// Arguments:
//    lpszInfFile [in]  Inf file to search.
//    lppszPnpID  [out] PnpID found.
//
// Returns:   TRUE on success.
//
// Notes:
//       

HRESULT GetPnpID (LPWSTR lpszInfFile,
                  LPWSTR *lppszPnpID)
{
    HINF    hInf;
    LPWSTR  lpszModelSection;
    HRESULT hr;

    *lppszPnpID = NULL;

    hInf = SetupOpenInfFileW( lpszInfFile,
                              NULL,
                              INF_STYLE_WIN4,
                              NULL );

    if ( hInf == INVALID_HANDLE_VALUE )
    {

        return HRESULT_FROM_WIN32(GetLastError());
    }

    //
    // Read the Model section name from Manufacturer section.
    //

    hr = GetKeyValue( hInf,
                      L"Manufacturer",
                      NULL,
                      1,
                      &lpszModelSection );

    if ( hr == S_OK )
    {

        //
        // Read PnpID from the Model section.
        //

        hr = GetKeyValue( hInf,
                          lpszModelSection,
                          NULL,
                          2,
                          lppszPnpID );

        CoTaskMemFree( lpszModelSection );
    }

    SetupCloseInfFile( hInf );

    return hr;
}

//
// Function:  GetKeyValue
//
// Purpose:   Retrieve the value of a key from the inf file.
//
// Arguments:
//    hInf        [in]  Inf file handle.
//    lpszSection [in]  Section name.
//    lpszKey     [in]  Key name.
//    dwIndex     [in]  Key index.
//    lppszValue  [out] Key value.
//
// Returns:   S_OK on success, otherwise and error code.
//
// Notes:
//       

HRESULT GetKeyValue (HINF hInf,
                     LPCWSTR lpszSection,
                     LPCWSTR lpszKey,
                     DWORD  dwIndex,
                     LPWSTR *lppszValue)
{
    INFCONTEXT  infCtx;
    DWORD       dwSizeNeeded;
    HRESULT     hr;

    *lppszValue = NULL;

    if ( SetupFindFirstLineW(hInf,
                             lpszSection,
                             lpszKey,
                             &infCtx) == FALSE )
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    SetupGetStringFieldW( &infCtx,
                          dwIndex,
                          NULL,
                          0,
                          &dwSizeNeeded );

    *lppszValue = (LPWSTR)CoTaskMemAlloc( sizeof(WCHAR) * dwSizeNeeded );

    if ( !*lppszValue  )
    {
       return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    }

    if ( SetupGetStringFieldW(&infCtx,
                              dwIndex,
                              *lppszValue,
                              dwSizeNeeded,
                              NULL) == FALSE )
    {

        hr = HRESULT_FROM_WIN32(GetLastError());

        CoTaskMemFree( *lppszValue );
        *lppszValue = NULL;
    }
    else
    {
        hr = S_OK;
    }

    return hr;
}

//
// Function:  UninstallSelectedComponent
//
// Purpose:   Uninstall the selected network component.
//
// Arguments:
//    hwndDlg     [in]  Window handle of the uninstall dialog box.
//
// Returns:   TRUE on success.
//
// Notes:
//       

VOID UninstallSelectedComponent (HWND hwndDlg)
{
    HWND      hwndTree;
    HTREEITEM hItem;
    LPARAM    lParam;
    HCURSOR   hPrevCursor;
    HCURSOR   hWaitCursor;
    DWORD     dwType;
    BOOL      fEnable;
    HRESULT   hr;

    hwndTree = GetDlgItem( hwndDlg,
                           IDT_COMPONENT_LIST );

    //
    // Get the selected item to get its lParam which is the
    // PnpID of the network component.
    //

    hItem = TreeView_GetSelection( hwndTree );

    if ( hItem ) {
        if ( GetItemInfo( hwndTree,
                          hItem,
                          &lParam,
                          &dwType,
                          &fEnable) ) {

            hWaitCursor = LoadCursor( NULL,
                                      IDC_WAIT );
            if ( hWaitCursor ) {
                hPrevCursor = SetCursor( hWaitCursor );
            }

            EnableWindow( hwndTree, FALSE );
            EnableWindow( GetDlgItem(hwndDlg,IDB_REMOVE),
                          FALSE );
            EnableWindow( GetDlgItem(hwndDlg,IDB_CLOSE),
                          FALSE );

            //
            // Uninstall the selected component.
            //

            hr = UninstallComponent( (LPWSTR)lParam );


            if ( hWaitCursor ) {
                SetCursor( hPrevCursor );
            }

            switch( hr ) {

                case S_OK:
                    MessageBoxW(
                           hwndDlg,
                           L"Uninstallation successful.",
                           L"Network Component Uninstallation",
                           MB_OK | MB_ICONINFORMATION );

                    CoTaskMemFree( (LPVOID)lParam );
                    TreeView_DeleteItem( hwndTree,
                                         hItem );

                    SetWindowLongPtr( hwndDlg,
                                      DWLP_USER,
                                      (LONG_PTR)TRUE );
                    break;

                case NETCFG_S_REBOOT:
                    MessageBoxW(
                          hwndDlg,
                          L"Uninstallation successful: "
                          L"Reboot required.",
                          L"Network Component Uninstallation",
                          MB_OK | MB_ICONINFORMATION );

                    CoTaskMemFree( (LPVOID)lParam );
                    TreeView_DeleteItem( hwndTree,
                                         hItem );

                    SetWindowLongPtr( hwndDlg,
                                      DWLP_USER,
                                      (LONG_PTR)TRUE );
            }

            EnableWindow( hwndTree, TRUE );
            EnableWindow( GetDlgItem(hwndDlg,IDB_REMOVE),
                          TRUE );
            EnableWindow( GetDlgItem(hwndDlg,IDB_CLOSE),
                          TRUE );
        }
    }

    return;
}

//
// Function:  ExpandCollapseAll
//
// Purpose:   Expand or collapse a tree.
//
// Arguments:
//    hwndTree   [in]  Window handle of the tree.
//    hTreeItem  [in]  Handle of root item.
//    uiFlag     [in]  Flag indicating whether to expand or collapse.
//
// Returns:   None.
//
// Notes:
//       

VOID ExpandCollapseAll (HWND hwndTree,
                        HTREEITEM hTreeItem,
                        UINT uiFlag)
{
    HTREEITEM  hItemChild;

    hItemChild = TreeView_GetChild( hwndTree,
                                    hTreeItem );

    if ( hItemChild ) {

        //
        // If the root has one or more children, expand/collapse the root.
        //

        TreeView_Expand( hwndTree,
                         hTreeItem,
                         uiFlag );
    }

    while ( hItemChild ) {

        //
        // Expand/collapse all the children.
        //

        ExpandCollapseAll( hwndTree,
                           hItemChild,
                           uiFlag );

        //
        // Expand/collapse all the siblings.
        //

        hItemChild = TreeView_GetNextSibling( hwndTree,
                                              hItemChild );
    }

    return;
}

//
// Function:  GetFileName
//
// Purpose:   Prompt for a filename.
//
// Arguments:
//    hwndDlg    [in]  Window handle of the parent.
//    lpszFilter [in]  See documentation for GetOpenFileName.
//    lpszTitle  [in]  See documentation for GetOpenFileName.
//    dwFlags    [in]  See documentation for GetOpenFileName.
//    lpszFile   [in]  See documentation for GetOpenFileName.
//
// Returns:   See documentation for GetOpenFileName.
//
// Notes:
//       

BOOL GetFileName (HWND hwndDlg,
                  LPWSTR lpszFilter,
                  LPWSTR lpszTitle,
                  DWORD dwFlags,
                  LPWSTR lpszFile,
                  LPWSTR lpszDefExt,
                  BOOL   fSave)
{
    OPENFILENAMEW ofn;
               
    lpszFile[0] = NULL;

    ZeroMemory( &ofn, sizeof(OPENFILENAMEW) );
    ofn.lStructSize = sizeof(OPENFILENAMEW);
    ofn.hwndOwner = hwndDlg;
    ofn.lpstrFilter = lpszFilter;
    ofn.lpstrFile = lpszFile;
    ofn.lpstrDefExt  = lpszDefExt;
    ofn.nMaxFile = MAX_PATH+1;
    ofn.lpstrTitle = lpszTitle;
    ofn.Flags = dwFlags;

    if ( fSave )
    {
        return GetSaveFileName( &ofn );
    }
    else
    {
        return GetOpenFileName( &ofn );
    }
}

//
// Function:  ProcessRightClick
//
// Purpose:   Handle righ mouse button click.
//
// Arguments:
//    lpnm    [in]  LPNMHDR info
//
// Returns:   None.
//
// Notes:
//       

VOID ProcessRightClick (LPNMHDR lpnm)
{
    HTREEITEM hItemSelected;
    LPARAM    lParam;
    DWORD     dwItemType;
    BOOL      fEnabled;

    //
    // Determine the item on which user clicked the right mouse button.
    //

    hItemSelected = TreeView_GetDropHilight( lpnm->hwndFrom );

    if ( !hItemSelected ) {
        hItemSelected = TreeView_GetSelection( lpnm->hwndFrom );
    }
    else {

        //
        // User has right-clicked an unselected item, make that a selected
        // item.
        //

        TreeView_Select( lpnm->hwndFrom,
                         hItemSelected,
                         TVGN_CARET );
    }

    if ( hItemSelected ) {

        //
        // Get the lParam of the selected node in the tree which points to inf id or
        // pathtoken name depending on if the node represents a network component or
        // a binding path.
        //

        if ( GetItemInfo(lpnm->hwndFrom,
                         hItemSelected,
                         &lParam,
                         &dwItemType,
                         &fEnabled) ) {

            if ( dwItemType & ITEM_NET_COMPONENTS ) {

                //
                // Show the shortcut menu of operations for a network component.
                //

                ShowComponentMenu( lpnm->hwndFrom,
                                   hItemSelected,
                                   lParam);
            }
            else {
                if ( dwItemType & ITEM_NET_BINDINGS ) {

                    //
                    // Show the shortcut menu of operations for a binding path.
                    //

                    ShowBindingPathMenu( lpnm->hwndFrom,
                                         hItemSelected,
                                         lParam,
                                         fEnabled );
                }
            }
        }
    }

    return;
}

//
// Function:  ShowComponentMenu
//
// Purpose:   Show shortcut menu of options for a network component.
//
// Arguments:
//    hwndOwner  [in]  Owner window.
//    hItem      [in]  Selected item representing a network component.
//    lParam     [in]  PnpID of the network component.
//
// Returns:   None.
//
// Notes:
//       

VOID ShowComponentMenu (HWND hwndOwner,
                        HTREEITEM hItem,
                        LPARAM lParam)
{
    ULONG   ulSelection;
    POINT   pt;

    GetCursorPos( &pt );
    ulSelection = (ULONG)TrackPopupMenu( hComponentSubMenu,
                                         TPM_RIGHTALIGN | TPM_BOTTOMALIGN |
                                         TPM_NONOTIFY | TPM_RETURNCMD |
                                         TPM_RIGHTBUTTON,
                                         pt.x,
                                         pt.y,
                                         0,
                                         hwndOwner,
                                         NULL );

    if ( ulSelection ) {

        //
        // Do the selected action.
        //

        HandleComponentOperation( hwndOwner,
                                  ulSelection,
                                  hItem,
                                  lParam );
    }

    return;
}

//
// Function:  ShowBindingPathMenu
//
// Purpose:   Show shortcut menu of options for a network component.
//
// Arguments:
//    hwndOwner  [in]  Owner window.
//    hItem      [in]  Selected item representing a binding path.
//    lParam     [in]  PnpID of the network component.
//    fEnabled   [in]  TRUE when the path is enabled.
//
// Returns:   None.
//
// Notes:
//       


VOID ShowBindingPathMenu (HWND hwndOwner,
                          HTREEITEM hItem,
                          LPARAM lParam,
                          BOOL fEnabled)
{
    MENUITEMINFOW  menuItemInfo;
    ULONG   ulSelection;
    POINT   pt;

    //
    // Build the shortcut menu depending on whether path is
    // disabled or enabled.
    //

    ZeroMemory( &menuItemInfo,
                sizeof(MENUITEMINFOW) );

    menuItemInfo.cbSize = sizeof( MENUITEMINFOW );
    menuItemInfo.fMask = MIIM_TYPE | MIIM_ID;
    menuItemInfo.fType = MFT_STRING;
    menuItemInfo.fState = MFS_ENABLED;

    if ( fEnabled ) {
        menuItemInfo.dwTypeData = MENUITEM_DISABLE;
        menuItemInfo.wID = IDI_DISABLE;
    }
    else {
        menuItemInfo.dwTypeData = MENUITEM_ENABLE;
        menuItemInfo.wID = IDI_ENABLE;
    }

    SetMenuItemInfoW( hBindingPathSubMenu,
                     0,
                     TRUE,
                     &menuItemInfo );  

    GetCursorPos( &pt );
    ulSelection = (ULONG)TrackPopupMenu( hBindingPathSubMenu,
                                         TPM_RIGHTALIGN | TPM_BOTTOMALIGN |
                                         TPM_NONOTIFY | TPM_RETURNCMD |
                                         TPM_RIGHTBUTTON,
                                         pt.x,
                                         pt.y,
                                         0,
                                         hwndOwner,
                                         NULL );

    if ( ulSelection ) {

        //
        // Do the selected action.
        //

        HandleBindingPathOperation( hwndOwner,
                                    ulSelection,
                                    hItem,
                                    lParam );
    }

    return;
}

//
// Function:  GetItemInfo
//
// Purpose:   Returns information about an item.
//
// Arguments:
//    hwndTree     [in]  Window handle of the tree.
//    hItem        [in]  Item handle.
//    lParam       [out] lParam
//    lpdwItemType [out] Type, binding path or network component.
//    fEnabled     [out] TRUE if the binding path or component is enabled.
//
// Returns:   TRUE on sucess.
//
// Notes:
//       

BOOL GetItemInfo (HWND hwndTree,
                  HTREEITEM hItem,
                  LPARAM *lParam,
                  LPDWORD lpdwItemType,
                  BOOL *fEnabled)
{
    TVITEMW   tvItem;
    int       iImage;
    BOOL      fSuccess;


    fSuccess = FALSE;

    //
    // Get item's information.
    //

    ZeroMemory( &tvItem,
                sizeof(TVITEMW) );
    tvItem.hItem = hItem;
    tvItem.mask = TVIF_PARAM | TVIF_IMAGE | TVIF_STATE;
    tvItem.stateMask = TVIS_OVERLAYMASK ;

    if ( TreeView_GetItem(hwndTree,
                          &tvItem) ) {

        *lParam = tvItem.lParam;

        if ( SetupDiGetClassImageIndex(&ClassImageListData,
                                       &GUID_DEVCLASS_SYSTEM,
                                       &iImage) ) {
  
            //
            // Is it a binding path?
            //

            if ( tvItem.iImage == iImage ) {
                *lpdwItemType = ITEM_NET_BINDINGS;

                *fEnabled = !(TVIS_OVERLAYMASK & tvItem.state); 

                fSuccess = TRUE;
            }
            else {

                //
                // Item is a network component.
                //

                if ( SetupDiGetClassImageIndex(&ClassImageListData,
                                               &GUID_DEVCLASS_NET,
                                               &iImage) ) {

                    if ( tvItem.iImage == iImage ) {
                        *lpdwItemType = ITEM_NET_ADAPTERS;
                    }
                    else {
                        *lpdwItemType = ITEM_NET_COMPONENTS;
                    }

                    *fEnabled = !(TVIS_OVERLAYMASK & tvItem.state); 

                    fSuccess = TRUE;
                }
                else {
                    ErrMsg( HRESULT_FROM_WIN32(GetLastError()),
                            L"Couldn't load the images of network adapters." );
                }
            }
        }
        else {
            ErrMsg( HRESULT_FROM_WIN32(GetLastError()),
                    L"Couldn't load the images of system devices." );
        }
    }

    return fSuccess;
}

//
// Function:  AddBindNameToTree
//
// Purpose:   Adds an item representing the binding path.
//
// Arguments:
//    pncbp     [in]  Binding path to add.
//    hwndTree  [in]  Tree handle.
//    hParent   [in]  Parent item.
//    ulIndex   [in]  Index of the binding path.
//
// Returns:   Handle of the item added on success, otherwise NULL.
//
// Notes:
//       

HTREEITEM AddBindNameToTree (INetCfgBindingPath *pncbp,
                             HWND hwndTree,
                             HTREEITEM hParent,
                             ULONG  ulIndex)
{
    WCHAR            lpszBindName[40];
    LPWSTR           lpszPathToken;
    HTREEITEM        hTreeItem;
    TV_INSERTSTRUCTW tvInsertStruc;
    HRESULT          hr;

    hTreeItem = NULL;

    //
    // Store the path token as lParam.
    //

    hr = pncbp->GetPathToken( &lpszPathToken );

    if ( hr == S_OK ) {

        swprintf( lpszBindName, L"Binding Path %d", ulIndex );

        ZeroMemory(
              &tvInsertStruc,
              sizeof(TV_INSERTSTRUCTW) );

        tvInsertStruc.hParent = hParent;

        tvInsertStruc.hInsertAfter = TVI_LAST;

        tvInsertStruc.item.mask = TVIF_TEXT | TVIF_PARAM | TVIF_IMAGE |
                                  TVIF_SELECTEDIMAGE | TVIF_STATE;

        tvInsertStruc.item.pszText = lpszBindName;

        SetupDiGetClassImageIndex( &ClassImageListData,
                                   &GUID_DEVCLASS_SYSTEM,
                                   &tvInsertStruc.item.iImage );

        tvInsertStruc.item.iSelectedImage = tvInsertStruc.item.iImage;

        tvInsertStruc.item.stateMask = TVIS_OVERLAYMASK;

        if (  pncbp->IsEnabled() == S_FALSE ) {
            tvInsertStruc.item.state = INDEXTOOVERLAYMASK(
                                   IDI_DISABLED_OVL - IDI_CLASSICON_OVERLAYFIRST + 1);
        }

        tvInsertStruc.item.lParam = (LPARAM)lpszPathToken;

        hTreeItem = TreeView_InsertItem( hwndTree,
                                         &tvInsertStruc );

        if ( !hTreeItem ) {
            ErrMsg( hr,
                    L"Couldn't add the binding path %d to the list."
                    L" The binding path will not be shown.", ulIndex );

            CoTaskMemFree( lpszPathToken );
        }
    }
    else {
        ErrMsg( hr,
                L"Couldn't get the PathToken of the binding path %d."
                L" The binding path will not be shown.", ulIndex );
    }

    return hTreeItem;
}

//
// Function:  AddToTree
//
// Purpose:   Adds an item representing the network component.
//
// Arguments:
//    hwndTree  [in]  Tree handle.
//    hParent   [in]  Parent item.
//    pncc      [in]  Network component.
//
// Returns:   Handle of the item added on success, otherwise NULL.
//
// Notes:
//       

HTREEITEM AddToTree (HWND hwndTree,
                     HTREEITEM hParent,
                     INetCfgComponent *pncc)
{
    LPWSTR           lpszItemName;
    LPWSTR           lpszId;
    GUID             guidClass;
    BOOL             fEnabled;
    ULONG            ulStatus;
    HTREEITEM        hTreeItem;
    TV_INSERTSTRUCTW tvInsertStruc;
    HRESULT          hr;

    hTreeItem = NULL;

    hr = pncc->GetDisplayName( &lpszItemName );

    if ( hr == S_OK ) {

        //
        // Get the inf id of the network component. We store it at lParam
        // and use it later to retrieve its interface pointer.
        //

        hr = pncc->GetId( &lpszId );

        if ( hr == S_OK ) {

            //
            // If it is a network adapter then, find out if it enabled/disabled.
            //

            hr = pncc->GetClassGuid( &guidClass );

            if ( hr == S_OK ) {
                if ( IsEqualGUID(guidClass, GUID_DEVCLASS_NET) ) {
                    hr = pncc->GetDeviceStatus( &ulStatus );
                    fEnabled = ulStatus == 0;
                }
                else {
                    fEnabled = TRUE;
                }
            }
            else {

                //
                // We can't get the status, so assume that it is disabled.
                //

                fEnabled = FALSE;
            }

            ZeroMemory(
                  &tvInsertStruc,
                  sizeof(TV_INSERTSTRUCTW) );

            tvInsertStruc.hParent = hParent;

            tvInsertStruc.hInsertAfter = TVI_LAST;

            tvInsertStruc.item.mask = TVIF_TEXT | TVIF_PARAM | TVIF_IMAGE |
                                      TVIF_SELECTEDIMAGE | TVIF_STATE;

            tvInsertStruc.item.pszText = lpszItemName;

            SetupDiGetClassImageIndex( &ClassImageListData,
                                       &guidClass,
                                       &tvInsertStruc.item.iImage );

            tvInsertStruc.item.iSelectedImage = tvInsertStruc.item.iImage;

            tvInsertStruc.item.stateMask = TVIS_OVERLAYMASK;

            if ( fEnabled == FALSE ) {
                tvInsertStruc.item.state = INDEXTOOVERLAYMASK(
                                       IDI_DISABLED_OVL - IDI_CLASSICON_OVERLAYFIRST + 1);
            }

            tvInsertStruc.item.lParam = (LPARAM)lpszId;

            hTreeItem = TreeView_InsertItem( hwndTree,
                                             &tvInsertStruc );
            if ( !hTreeItem ) {
                ErrMsg( hr,
                        L"Failed to add %s to the list.",
                        lpszItemName );

                CoTaskMemFree( lpszId );
            }
        }
        else {
            ErrMsg( hr,
                    L"Couldn't get the inf id of %s."
                    L" It will not be added to the list.",
                    lpszItemName );
        }

        CoTaskMemFree( lpszItemName );
    }
    else {
        ErrMsg( hr,
                L"Couldn't get the display name of a network component."
                L" It will not be added to the list." );
    }

    return hTreeItem;
}

//
// Function:  RefreshAll
//
// Purpose:   Refreshes the main dialog box.
//
// Arguments:
//    hwndDlg  [in]  Dialog box handle.
//
// Returns:   None.
//
// Notes:
//       

VOID RefreshAll (HWND hwndDlg)
{
    HWND hwndTypeList;
    INT  iSelected;

    //
    // Find the selected network component type.
    //

    hwndTypeList = GetDlgItem( hwndDlg,
                              IDL_COMPONENT_TYPES );

    iSelected = (int)SendMessage( hwndTypeList,
                                  CB_GETCURSEL,
                                  0,
                                  0 );

    if ( iSelected != CB_ERR ) {

        //
        // Before deleting the list in the tree, free the buffer
        // associated with each item. The buffer holds either the
        // INF Id or the pathtoken depending on whether it is a
        // network component or a binding path.
        //

        ReleaseMemory( GetDlgItem(hwndDlg, IDT_BINDINGS),
                       TVI_ROOT );

        TreeView_DeleteItem (
                    GetDlgItem(hwndDlg, IDT_BINDINGS),
                    TVI_ROOT );

        //
        // Repopulate the tree with the selected network compnent
        // type.
        //

        EnumNetBindings( GetDlgItem(hwndDlg, IDT_BINDINGS),
                         (UINT)iSelected );

    }

    return;
}

//
// Function:  RefreshItemState
//
// Purpose:   Refreshes the specified item.
//
// Arguments:
//    hwndTree  [in]  Dialog box handle.
//    hItem     [in]  Item to refresh.
//    fEnable   [in]  TRUE if component is enabled.
//
// Returns:   None.
//
// Notes:
//       

VOID RefreshItemState (HWND hwndTree,
                       HTREEITEM hItem,
                       BOOL fEnable)
{
    TVITEMW       tvItem;

    ZeroMemory( &tvItem,
                sizeof(TVITEMW) );

    tvItem.hItem = hItem;
    tvItem.mask = TVIF_STATE;
    tvItem.stateMask = TVIS_OVERLAYMASK;

    if ( fEnable )
        tvItem.state = INDEXTOOVERLAYMASK( 0 );
    else
        tvItem.state = INDEXTOOVERLAYMASK(
                             IDI_DISABLED_OVL - IDI_CLASSICON_OVERLAYFIRST + 1);
    TreeView_SetItem( hwndTree,
                      &tvItem );
    return;
}

//
// Function:  RefreshBindings
//
// Purpose:   Refreshes bindings of a specific component.
//
// Arguments:
//    hwndBindUnBindDlg  [in]  Dialog box handle.
//    lpszInfId          [in]  PnpID of the component whose bindings changed.
//
// Returns:   None.
//
// Notes:
//       

VOID RefreshBindings (HWND hwndBindUnBindDlg,
                      LPWSTR lpszInfId)
{
    INetCfg              *pnc;
    INetCfgComponent     *pncc;
    HWND                 hwndParent;
    HWND                 hwndTree;
    HTREEITEM            hItem;
    HRESULT              hr;


    hwndParent = GetParent( hwndBindUnBindDlg );
    hwndTree = GetDlgItem( hwndParent,
                           IDT_BINDINGS );

    hItem = TreeView_GetSelection( hwndTree );

    hr = HrGetINetCfg( FALSE,
                       APP_NAME,
                       &pnc,
                       NULL );

    if ( hr == S_OK ) {

        hr = pnc->FindComponent( lpszInfId,
                                 &pncc );

        if ( hr == S_OK ) {

            //
            // Delete all the children.
            //

            ReleaseMemory( hwndTree,
                           hItem );

            DeleteChildren( hwndTree,
                            hItem );

            ListBindings( pncc,
                          hwndTree,
                          hItem );

            ReleaseRef( pncc );
        }

        HrReleaseINetCfg( pnc,
                          FALSE );
    }

    return;
}

//
// Function:  ReleaseMemory
//
// Purpose:   Free memory associated with each item in the tree.
//
// Arguments:
//    hwndTree  [in]  Tree handle.
//    hTreeItem [in]  Root item.
//
// Returns:   None.
//
// Notes:
//
// Each node of the tree represents a network component or a binding path.
// At each node, lParam points to an allocated buffer wherein we store the
// inf id if it is a network component or pathtoken name if it is a binding
// path.
// 
//

VOID ReleaseMemory (HWND hwndTree,
                    HTREEITEM hTreeItem)
{
    HTREEITEM  hItemChild;
    TVITEMW    tvItem;

    hItemChild = TreeView_GetChild( hwndTree,
                                    hTreeItem );

    while ( hItemChild ) {

        ZeroMemory(
              &tvItem,
              sizeof(TVITEMW) );

        tvItem.hItem = hItemChild;
        tvItem.mask = TVIF_PARAM;

        TreeView_GetItem( hwndTree,
                          &tvItem );

        //
        // It should never be NULL but just in case...
        //

        if ( tvItem.lParam ) {
            CoTaskMemFree( (LPVOID)tvItem.lParam );

        }

        ReleaseMemory( hwndTree, hItemChild );

        hItemChild = TreeView_GetNextSibling( hwndTree,
                                              hItemChild );
    }

    return;
}

//
// Function:  DeleteChildren
//
// Purpose:   Delete childen of a specific item.
//
// Arguments:
//    hwndTree  [in]  Tree handle.
//    hTreeItem [in]  Parent item.
//
// Returns:   None.
//
// Notes:
//

VOID DeleteChildren (HWND hwndTree,
                     HTREEITEM hTreeItem)
{
    HTREEITEM  hItemChild;
    HTREEITEM  hItemSibling;

    hItemChild = TreeView_GetChild( hwndTree,
                                    hTreeItem );

    while ( hItemChild ) {

        DeleteChildren( hwndTree,
                        hItemChild );

        hItemSibling = TreeView_GetNextSibling( hwndTree,
                                                hItemChild );
        TreeView_DeleteItem( hwndTree,
                             hItemChild );

        hItemChild = hItemSibling;
    }

    return;
}

//
// Function:  InsertItem
//
// Purpose:   Insert text for each network component type.
//
// Arguments:
//    hwndTree  [in]  Tree handle.
//    uiType    [in]  Item type, protocol, client, service.
//
// Returns:   Item handle on success, otherwise NULL.
//
// Notes:
//

HTREEITEM InsertItem (HWND hwndTree,
                      UINT uiType)
{
    TV_INSERTSTRUCTW tvInsertStruc;

    ZeroMemory(
          &tvInsertStruc,
          sizeof(TV_INSERTSTRUCTW) );

    tvInsertStruc.hParent = TVI_ROOT;

    tvInsertStruc.hInsertAfter = TVI_LAST;

    tvInsertStruc.item.mask = TVIF_TEXT | TVIF_PARAM | TVIF_IMAGE |
                              TVIF_SELECTEDIMAGE;


    switch( uiType ) {

        case CLIENTS_SELECTED:
            tvInsertStruc.item.pszText = L"Client";
            break;

        case SERVICES_SELECTED:
            tvInsertStruc.item.pszText = L"Service";
            break;

        default:
            tvInsertStruc.item.pszText = L"Protocol";
            break;
    }

    SetupDiGetClassImageIndex( &ClassImageListData,
                               pguidNetClass[uiType],
                               &tvInsertStruc.item.iImage );

    tvInsertStruc.item.iSelectedImage = tvInsertStruc.item.iImage;

    tvInsertStruc.item.lParam = (LPARAM)uiType;

    return TreeView_InsertItem( hwndTree,
                                &tvInsertStruc );

}

//
// Function:  UpdateComponentTypeList
//
// Purpose:   Insert text for each network component type.
//
// Arguments:
//    hwndTypeList  [in]  ListView handle.
//
// Returns:   TRUE on success.
//
// Notes:
//

BOOL UpdateComponentTypeList (HWND hwndTypeList)
{
    UINT i;

    for (i=0; i < 3; ++i) {
        SendMessage( hwndTypeList,
                     CB_ADDSTRING,
                     (WPARAM)0,
                     (LPARAM)lpszNetClass[i] );
    }

    SendMessage( hwndTypeList,
                 CB_SETCURSEL,
                 (WPARAM)DEFAULT_COMPONENT_SELECTED,
                 (LPARAM)0 );
    return TRUE;
}

//
// Function:  ErrMsg
//
// Purpose:   Insert text for each network component type.
//
// Arguments:
//    hr  [in]  Error code.
//
// Returns:   None.
//
// Notes:
//

VOID ErrMsg (HRESULT hr,
             LPCWSTR  lpFmt,
             ...)
{

    LPWSTR   lpSysMsg;
    WCHAR    buf[400];
    ULONG    offset;
    va_list  vArgList; 


    if ( hr != 0 ) {
        swprintf( buf,
                  L"Error %#lx: ",
                  hr );
    }
    else {
        buf[0] = 0;
    }

    offset = wcslen( buf );
  
    va_start( vArgList,
              lpFmt );
    vswprintf( buf+offset,
                lpFmt,
                vArgList );

    va_end( vArgList );

    if ( hr != 0 ) {
        FormatMessageW( FORMAT_MESSAGE_ALLOCATE_BUFFER |
                       FORMAT_MESSAGE_FROM_SYSTEM |
                       FORMAT_MESSAGE_IGNORE_INSERTS,
                       NULL,
                       hr,
                       MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                       (LPWSTR)&lpSysMsg,
                       0,
                       NULL );
        if ( lpSysMsg ) {

            offset = wcslen( buf );

            swprintf( buf+offset,
                      L"\n\nPossible cause:\n\n" );

            offset = wcslen( buf );

            wcscat( buf+offset,
                     lpSysMsg );

            LocalFree( (HLOCAL)lpSysMsg );
        }

        MessageBoxW( NULL,
                    buf,
                    L"Error",
                    MB_ICONERROR | MB_OK );
    }
    else {
        MessageBoxW( NULL,
                    buf,
                    L"BindView",
                    MB_ICONINFORMATION | MB_OK );
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\samples\bindview\bindview.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       B I N D V I E W . H
//
//  Contents:   Function Prototypes
//
//  Notes:      
//
//  Author:     Alok Sinha    15-May-01
//
//----------------------------------------------------------------------------

#ifndef _BINDVIEW_H_INCLUDED

#define _BINDVIEW_H_INCLUDED

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <windowsx.h>
#include <wchar.h>
#include <commctrl.h>        // For common controls, e.g. Tree
#include <commdlg.h>
#include <setupapi.h>
#include <devguid.h>

#include "NetCfgAPI.h"
#include "resource.h"

#define ID_STATUS           100
#define APP_NAME            L"BindView"

#define CLIENTS_SELECTED    0
#define SERVICES_SELECTED   1
#define PROTOCOLS_SELECTED  2
#define ADAPTERS_SELECTED   3

#define ITEM_NET_COMPONENTS 1
#define ITEM_NET_BINDINGS   2
#define ITEM_NET_ADAPTERS   4

#define DEFAULT_COMPONENT_SELECTED  CLIENTS_SELECTED

#define WM_NO_COMPONENTS    WM_USER+1

#define MENUITEM_ENABLE     L"Enable"
#define MENUITEM_DISABLE    L"Disable"

extern HINSTANCE    hInstance;
extern const GUID   *pguidNetClass [];
extern LPWSTR       lpszNetClass [];

typedef struct _BIND_UNBIND_INFO {
  LPWSTR lpszInfId;
  BOOL   fBindTo;
} BIND_UNBIND_INFO, *LPBIND_UNBIND_INFO;

//
// Functions defined in bindview.cpp
//

INT_PTR CALLBACK MainDlgProc (HWND hwndDlg,
                              UINT uMsg,
                              WPARAM wParam,
                              LPARAM lParam);

INT_PTR CALLBACK BindComponentDlg (HWND hwndDlg,
                                   UINT uMsg,
                                   WPARAM wParam,
                                   LPARAM lParam);

INT_PTR CALLBACK InstallDlg (HWND hwndDlg,
                                      UINT uMsg,
                                      WPARAM wParam,
                                      LPARAM lParam);

INT_PTR CALLBACK UninstallDlg (HWND hwndDlg,
                               UINT uMsg,
                               WPARAM wParam,
                               LPARAM lParam);

VOID DumpBindings (LPWSTR lpszFile);

VOID InstallSelectedComponentType (HWND   hwndDlg,
                                   LPWSTR lpszInfFile);

HRESULT GetPnpID (LPWSTR lpszInfFile,
                  LPWSTR *lppszPnpID);

HRESULT GetKeyValue (HINF hInf,
                     LPCWSTR lpszSection,
                     LPCWSTR lpszKey,
                     DWORD  dwIndex,
                     LPWSTR *lppszValue);

VOID UninstallSelectedComponent (HWND hwndDlg);

VOID ExpandCollapseAll (HWND hwndTree,
                        HTREEITEM hTreeItem,
                        UINT uiFlag);

BOOL GetFileName (HWND hwndDlg,
                  LPWSTR lpszFilter,
                  LPWSTR lpszTitle,
                  DWORD dwFlags,
                  LPWSTR  lpszFile,
                  LPWSTR  lpszDefExt,
                  BOOL    fSave);

VOID ProcessRightClick (LPNMHDR lpnm);

VOID ShowComponentMenu (HWND hwndOwner,
                        HTREEITEM hItem,
                        LPARAM lParam);

VOID ShowBindingPathMenu (HWND hwndOwner,
                          HTREEITEM hItem,
                          LPARAM lParam,
                          BOOL fEnabled);

BOOL GetItemInfo (HWND hwndTree,
                  HTREEITEM hItem,
                  LPARAM *lParam,
                  LPDWORD  lpdwItemType,
                  BOOL *fEnabled);

HTREEITEM AddBindNameToTree (INetCfgBindingPath *pncbp,
                             HWND hwndTree,
                             HTREEITEM hParent,
                             ULONG  ulIndex);

HTREEITEM AddToTree (HWND hwndTree,
                     HTREEITEM hParent,
                     INetCfgComponent *pncc);

VOID RefreshAll (HWND hwndDlg);

VOID RefreshItemState (HWND hwndTree,
                       HTREEITEM hItem,
                       BOOL fEnable);

VOID RefreshBindings (HWND hwndTree,
                      LPWSTR lpszInfId);

VOID ReleaseMemory (HWND hwndTree,
                    HTREEITEM hTreeItem);


VOID DeleteChildren (HWND hwndTree,
                     HTREEITEM hTreeItem);

HTREEITEM InsertItem (HWND hwndTree,
                      UINT uiType);

BOOL UpdateComponentTypeList (HWND hwndTypeList);


VOID ErrMsg (HRESULT hr,
             LPCWSTR  lpFmt,
             ...);

//
// Functions defined in component.cpp
//

VOID HandleComponentOperation (HWND hwndOwner,
                               ULONG ulSelection,
                               HTREEITEM hItem,
                               LPARAM lParam);

VOID BindUnbindComponents( HWND hwndOwner,
                           HTREEITEM hItem,
                           LPWSTR lpszInfId,
                           BOOL fBindTo);

HRESULT InstallComponent (HWND hwndDlg,
                          const GUID *pguidClass);

HRESULT InstallSpecifiedComponent (LPWSTR lpszInfFile,
                                   LPWSTR lpszPnpID,
                                   const GUID *pguidClass);

DWORD ListCompToBindUnbind (LPWSTR lpszInfId,
                            UINT uiType,
                            HWND hwndTree,
                            BOOL fBound);

BOOL BindUnbind (LPWSTR lpszInfId,
                 HWND hwndTree,
                 BOOL fBind);

VOID ListInstalledComponents (HWND hwndTree,
                              const GUID *pguidClass);

HRESULT UninstallComponent (LPWSTR lpszInfId);

//
// Functions defined in binding.cpp
//

VOID WriteBindings (FILE *fp);

VOID WriteBindingPath (FILE *fp,
                       INetCfgComponent *pncc);

VOID WriteInterfaces (FILE *fp,
                      INetCfgBindingPath *pncbp);

BOOL EnumNetBindings (HWND hwndTree,
                      UINT uiTypeSelected);

VOID ListBindings (INetCfgComponent *pncc,
                   HWND hwndTree,
                   HTREEITEM hTreeItemRoot);

VOID ListInterfaces (INetCfgBindingPath *pncbp,
                     HWND hwndTree,
                     HTREEITEM hTreeItemRoot);

VOID HandleBindingPathOperation (HWND hwndOwner,
                                 ULONG ulSelection,
                                 HTREEITEM hItem,
                                 LPARAM lParam);

VOID EnableBindingPath (HWND hwndOwner,
                        HTREEITEM hItem,
                        LPWSTR lpszTokenPath,
                        BOOL fEnable);

LPWSTR GetComponentId (HWND hwndTree,
                       HTREEITEM hItem);

INetCfgBindingPath *FindBindingPath (INetCfg *pnc,
                                     LPWSTR lpszInfId,
                                     LPWSTR lpszPathTokenSelected);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\samples\muxim\adapter.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992-2001.
//
//  File:       A D A P T E R . C P P
//
//  Contents:   Physical adapter class definition.
//
//  Notes:
//
//  Author:     Alok Sinha
//
//----------------------------------------------------------------------------

#include "adapter.h"
#include "common.h"

#ifdef  CUSTOM_EVENTS
#include "public.h"
#endif

//+---------------------------------------------------------------------------
//
// Function:  CMuxPhysicalAdapter::CMuxPhysicalAdapter
//
// Purpose:   Constructor for class CMuxPhysicalAdapter
//
// Arguments: None
//
// Returns:
//
// Notes:
//

CMuxPhysicalAdapter::CMuxPhysicalAdapter (INetCfg *pnc,
                                          GUID *pguidAdapter)
{

    TraceMsg( L"-->CMuxPhysicalAdapter::CMuxPhysicalAdapter(Constructor).\n" );

    m_pnc = pnc;
    m_pnc->AddRef();

    CopyMemory( &m_guidAdapter,
                pguidAdapter,
                sizeof(GUID) );

    TraceMsg( L"<--CMuxPhysicalAdapter::CMuxPhysicalAdapter(Constructor).\n" );
}

//+---------------------------------------------------------------------------
//
// Function:  CMuxPhysicalAdapter::~CMuxPhysicalAdapter
//
// Purpose:   Destructor for class CMuxPhysicalAdapter
//
// Arguments: None
//
// Returns:
//
// Notes:
//

CMuxPhysicalAdapter::~CMuxPhysicalAdapter (VOID)
{
    CMuxVirtualMiniport  *pMiniport;
    DWORD                dwMiniportCount;
    DWORD                i;


    TraceMsg( L"-->CMuxPhysicalAdapter::~CMuxPhysicalAdapter(Destructor).\n" );

    //
    // Delete all the instances representing the virtual miniports.
    // We are only deleting the class instances, not uninstalling the
    // the virtual miniports.
    //

    dwMiniportCount = m_MiniportList.ListCount();

    for (i=0; i < dwMiniportCount; ++i) {

        m_MiniportList.Remove( &pMiniport );
        delete pMiniport;
    }

    dwMiniportCount = m_MiniportsToAdd.ListCount();

    for (i=0; i < dwMiniportCount; ++i) {

        m_MiniportsToAdd.Remove( &pMiniport );
        delete pMiniport;
    }

    dwMiniportCount = m_MiniportsToRemove.ListCount();

    for (i=0; i < dwMiniportCount; ++i) {

        m_MiniportsToRemove.Remove( &pMiniport );
        delete pMiniport;
    }

    ReleaseObj( m_pnc );

    TraceMsg( L"<--CMuxPhysicalAdapter::~CMuxPhysicalAdapter(Destructor).\n" );

}

//+---------------------------------------------------------------------------
//
// Function:  CMuxPhysicalAdapter::LoadConfiguration
//
// Purpose:   Read the registry to get the device IDs of the 
//            virtual miniports installed on the adapter and
//            crate an instance to represent each virtual miniport.
//
// Arguments: None
//
// Returns: S_OK on success, otherwise an error code.
//
// Notes:
//

HRESULT CMuxPhysicalAdapter::LoadConfiguration (VOID)
{
    HKEY                    hkeyAdapterGuid;
    WCHAR                   szAdapterGuidKey[MAX_PATH+1];
    WCHAR                   szAdapterGuid[MAX_PATH+1];
    LPWSTR                  lpMiniportList;
    LPWSTR                  lpMiniport;
    LPWSTR                  lpMiniportGuid;
    DWORD                   dwDisp;
    CMuxVirtualMiniport     *pMiniport;
    GUID                    guidMiniport;
    DWORD                   dwBytes;
    LONG                    lResult;

    TraceMsg( L"-->CMuxPhysicalAdapter::LoadConfiguration.\n" );

    //
    // Build the registry key using the adapter guid under which 
    // device IDs of the virtual miniports are stored.
    //

    StringFromGUID2( m_guidAdapter,
                    szAdapterGuid,
                    MAX_PATH+1 );

    swprintf( szAdapterGuidKey,
              L"%s\\%s",
              c_szAdapterList,
              szAdapterGuid );

    lResult = RegCreateKeyExW( HKEY_LOCAL_MACHINE,
                                szAdapterGuidKey,
                                0,
                                NULL,
                                REG_OPTION_NON_VOLATILE,
                                KEY_ALL_ACCESS,
                                NULL,
                                &hkeyAdapterGuid,
                                &dwDisp);

    if ( lResult == ERROR_SUCCESS ) {

        //
        // If dwDisp indicates that a new key is created then, we know there
        // is no virtual miniport currently listed underneath and we simply
        // return.
        //

        if ( dwDisp != REG_CREATED_NEW_KEY ) {

            dwBytes = 0;
            lResult =  RegQueryValueExW(
                                        hkeyAdapterGuid,
                                        c_szUpperBindings,
                                        NULL,
                                        NULL,
                                        NULL,
                                        &dwBytes );

            lpMiniportList = (LPWSTR)calloc( dwBytes, 1 );

            if ( lpMiniportList ) {

                lResult =  RegQueryValueExW(
                                    hkeyAdapterGuid,
                                    c_szUpperBindings,
                                    NULL,
                                    NULL,
                                    (LPBYTE)lpMiniportList,
                                    &dwBytes );

                if ( lResult == ERROR_SUCCESS ) {

                    lpMiniport = lpMiniportList;

#ifndef PASSTHRU_NOTIFY

                    //
                    // In case of mux, c_szUpperBindings is a multi_sz string.
                    //

                    while ( wcslen(lpMiniport) ) {

                        lpMiniportGuid = RemoveDevicePrefix( lpMiniport );

                        TraceMsg( L"   Loading configuration for miniport %s...\n",
                        lpMiniportGuid );

                        if ( lpMiniportGuid ) {

                            CLSIDFromString( lpMiniportGuid,
                                             &guidMiniport );
         
                            //
                            // Create an instance representing the virtual miniport.
                            //

                            pMiniport = new CMuxVirtualMiniport( m_pnc,
                                                                 &guidMiniport,
                                                                 &m_guidAdapter );

                            if ( pMiniport ) {

                                //
                                // Load any miniport specific configuration.
                                //

                                pMiniport->LoadConfiguration();

                                //
                                // Save the miniport instance in a list.
                                //

                                m_MiniportList.Insert( pMiniport,
                                                       guidMiniport );

                            }

                            free( lpMiniportGuid );
                        }

                        //
                        // Get next miniport guid.
                        //

                        lpMiniport += wcslen(lpMiniport) + 1;
                    }

#else

                    //
                    // In case of the passthru driver, c_szUpperBindings is
                    // a reg_sz string.
                    //

                    lpMiniportGuid = RemoveDevicePrefix( lpMiniport );

                    TraceMsg( L"   Loading configuration for miniport %s...\n",
                              lpMiniportGuid );

                    if ( lpMiniportGuid ) {

                        CLSIDFromString( lpMiniportGuid,
                                         &guidMiniport );

                        //
                        // Create an instance representing the virtual miniport.
                        //

                        pMiniport = new CMuxVirtualMiniport( m_pnc,
                                                             &guidMiniport,
                                                             &m_guidAdapter );

                        if ( pMiniport ) {

                            //
                            // Load any miniport specific configuration.
                            //

                            pMiniport->LoadConfiguration();

                            //
                            // Save the miniport instance in a list.
                            //

                            m_MiniportList.Insert( pMiniport,
                                                   guidMiniport );
                        }

                        free( lpMiniportGuid );
                    }
#endif
                }
                else {
                    TraceMsg( L"   Failed to read the registry value: %s.\n",
                              c_szUpperBindings );
                }

                free( lpMiniportList );
            }
            else {
                lResult = ERROR_NOT_ENOUGH_MEMORY;
            }
        }

        RegCloseKey( hkeyAdapterGuid );
    }
    else {

        TraceMsg( L"   Failed to open the registry key: %s.\n",
                  szAdapterGuidKey );
    }

    TraceMsg( L"<--CMuxPhysicalAdapter::LoadConfiguration(HRESULT = %x).\n",
              HRESULT_FROM_WIN32(lResult) );

    return HRESULT_FROM_WIN32(lResult);
}

//+---------------------------------------------------------------------------
//
// Function:  CMuxPhysicalAdapter::GetAdapterGUID
//
// Purpose:   Returns the adapter GUID.
//
// Arguments:
//          OUT pguidAdapter:  GUID of the adapter returned.
//
// Returns: None.
//
// Notes:
//

VOID CMuxPhysicalAdapter::GetAdapterGUID (GUID *pguidAdapter)
{
    TraceMsg( L"-->CMuxPhysicalAdapter::GetAdapterGUID.\n" );

    CopyMemory( pguidAdapter,
                &m_guidAdapter,
                sizeof(GUID) );

    TraceMsg( L"<--CMuxPhysicalAdapter::GetAdapterGUID.\n" );
}

//+---------------------------------------------------------------------------
//
// Function:  CMuxPhysicalAdapter::AddMiniport
//
// Purpose:   Puts the miniport instance into the list of newly added miniports.
//
// Arguments:
//          IN pMiniport:  A newly create miniport instance.
//
// Returns: S_OK on success, otherwize and error code.
//
// Notes:
//

HRESULT CMuxPhysicalAdapter::AddMiniport (CMuxVirtualMiniport *pMiniport)
{
    GUID    guidMiniport;
    HRESULT hr;

    TraceMsg( L"-->CMuxPhysicalAdapter::AddMiniport.\n" );

    pMiniport->GetMiniportGUID( &guidMiniport );

    hr = m_MiniportsToAdd.Insert( pMiniport,
                                  guidMiniport );

    TraceMsg( L"<--CMuxPhysicalAdapter::AddMiniport(HRESULT = %x).\n",
              hr );

    return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  CMuxPhysicalAdapter::RemoveMiniport
//
// Purpose:   Remove a specified miniport instance from the list and
//            uninstalls the corresponding virtual miniport.
//
// Arguments:
//          IN pguidMiniportToRemove: GUID of the miniport to be removed
//                                    and uninstalled. If it is NULL then,
//                                    the first miniport instance is removed.
//
// Returns: S_OK on success, otherwize and error code.
//
// Notes:
//

HRESULT CMuxPhysicalAdapter::RemoveMiniport (GUID *pguidMiniportToRemove)
{
    CMuxVirtualMiniport  *pMiniport;
    GUID                 guidMiniport;
    HRESULT              hr;

    TraceMsg( L"-->CMuxPhysicalAdapter::RemoveMiniport.\n" );

    //
    // If miniport GUID specified then, delete that one.
    //

    if ( pguidMiniportToRemove ) {

        hr = m_MiniportList.RemoveByKey( *pguidMiniportToRemove,
                                      &pMiniport );
    }
    else {

        //
        // No GUID specified, so we just delete the first one.
        //

        hr = m_MiniportList.Remove( &pMiniport );
    }

    if ( hr == S_OK ) {

        pMiniport->GetMiniportGUID( &guidMiniport );

        m_MiniportsToRemove.Insert( pMiniport,
                                    guidMiniport );
        pMiniport->DeInstall();
    }

    TraceMsg( L"<--CMuxPhysicalAdapter::RemoveMiniport(HRESULT = %x).\n",
              hr );

    return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  CMuxPhysicalAdapter::Remove
//
// Purpose:   Uninstall all the instances of virtual miniports.
//
// Arguments: None
//
// Returns: S_OK.
//
// Notes:
//

HRESULT CMuxPhysicalAdapter::Remove (VOID)
{
    CMuxVirtualMiniport  *pMiniport;
    GUID                    guidMiniport;
    DWORD                   dwMiniportCount;
    DWORD                   i;

    TraceMsg( L"-->CMuxPhysicalAdapter::Remove.\n" );

    dwMiniportCount = m_MiniportList.ListCount();

    TraceMsg ( L"   Removing %d miniports.\n",
               dwMiniportCount );

    for (i=0; i < dwMiniportCount; ++i) {

        m_MiniportList.Remove( &pMiniport );
        pMiniport->GetMiniportGUID( &guidMiniport );
        m_MiniportsToRemove.Insert( pMiniport,
                                    guidMiniport );
        pMiniport->DeInstall();
    }

    TraceMsg( L"<--CMuxPhysicalAdapter::Remove(HRESULT = %x).\n",
              S_OK );

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Function:  CMuxPhysicalAdapter::ApplyRegistryChanges
//
// Purpose:   Update the registry depending on the actions performed.
//
// Arguments:
//          IN eApplyAction:  Action that was last performed.
//                            
//
// Returns: S_OK.
//
// Notes:
//        More than one action could have been performed by the user
//        but this function is called only once at the end. So, the argument
//        only denotes the very last action performed. For example, if the 
//        user deletes one miniport and adds two miniports then, the argument
//        will denote an add action.
//

HRESULT CMuxPhysicalAdapter::ApplyRegistryChanges (ConfigAction eApplyAction)
{
    HKEY                    hkeyAdapterList;
    HKEY                    hkeyAdapterGuid;
    WCHAR                   szAdapterGuid[MAX_PATH+1];
    CMuxVirtualMiniport     *pMiniport = NULL;
    DWORD                   dwMiniportCount;
    DWORD                   dwDisp;
    DWORD                   i;
    LONG                    lResult;
    HRESULT                 hr;


    TraceMsg( L"-->CMuxPhysicalAdapter::ApplyRegistryChanges.\n" );

    //
    // Open/create and then close the registry key to ensure that it does exist.
    //

    StringFromGUID2( m_guidAdapter,
                     szAdapterGuid,
                     MAX_PATH+1 );

    lResult = RegCreateKeyExW( HKEY_LOCAL_MACHINE,
                               c_szAdapterList,
                               0,
                               NULL,
                               REG_OPTION_NON_VOLATILE,
                               KEY_ALL_ACCESS,
                               NULL,
                               &hkeyAdapterList,
                               &dwDisp);


    if ( lResult == ERROR_SUCCESS ) {

        lResult = RegCreateKeyExW( hkeyAdapterList,
                                   szAdapterGuid,
                                   0,
                                   NULL,
                                   REG_OPTION_NON_VOLATILE,
                                   KEY_ALL_ACCESS,
                                   NULL,
                                   &hkeyAdapterGuid,
                                   &dwDisp);

        if ( lResult == ERROR_SUCCESS ) {

            RegCloseKey( hkeyAdapterGuid );
        }
        else {
            TraceMsg( L"   Failed to create/open the registry key: %s\\%s.\n",
                      c_szAdapterList, szAdapterGuid );
        }

        RegCloseKey( hkeyAdapterList );
    }
    else {

        TraceMsg( L"   Failed to open the registry key: %s.\n",
                  c_szAdapterList );
    }

    //
    // Update the registry in case there were new miniports installed.
    //

    hr = HRESULT_FROM_WIN32( lResult );

    dwMiniportCount = m_MiniportsToAdd.ListCount();

    TraceMsg( L"   Applying registry changes when %d miniports added.\n",
              dwMiniportCount );

    for (i=0; i < dwMiniportCount; ++i) {

        m_MiniportsToAdd.Find( i,
                               &pMiniport );

        //
        // Do virtual miniport specific registry changes.
        //
        // We need to tell the miniport instance explicitly what the action
        // is.
        //

        hr = pMiniport->ApplyRegistryChanges( eActAdd );

        if ( hr != S_OK ) {

            TraceMsg( L"   Failed to apply registry changes to miniport(%d).\n",
                      i );

        }
    }



    //
    // Update the registry in case one or more miniports were uninstalled.
    //

    dwMiniportCount = m_MiniportsToRemove.ListCount();

    TraceMsg( L"   Applying registry changes when %d miniports removed.\n",
              dwMiniportCount );

    for (i=0; i < dwMiniportCount; ++i) {

        m_MiniportsToRemove.Find( i,
                                  &pMiniport );

        //
        // Do virtual miniport specific registry changes.
        //
        // We need to tell the miniport instance explicitly what the action
        // is.
        //

        hr = pMiniport->ApplyRegistryChanges( eActRemove );

        if ( hr != S_OK ) {

            TraceMsg( L"   Failed to apply registry changes to miniport(%d).\n",
                      i );

        }
    }

    //
    // If the adapter is being removed or the protocol is being uninstalled,
    // delete the adatper registry key.
    //

    if ( eApplyAction == eActRemove ) {

        //
        // Delete the adapter key.
        //

        lResult = RegCreateKeyExW( HKEY_LOCAL_MACHINE,
                                   c_szAdapterList,
                                   0,
                                   NULL,
                                   REG_OPTION_NON_VOLATILE,
                                   KEY_ALL_ACCESS,
                                   NULL,
                                   &hkeyAdapterList,
                                   &dwDisp);

        if ( lResult == ERROR_SUCCESS ) {

            TraceMsg( L"   Deleting the registry key: %s.\n", szAdapterGuid );

            RegDeleteKeyW( hkeyAdapterList,
                           szAdapterGuid );
        }
    }

    TraceMsg( L"<--CMuxPhysicalAdapter::ApplyRegistryChanges(HRESULT = %x).\n",
            S_OK );

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Function:  CMuxPhysicalAdapter::ApplyPnpChanges
//
// Purpose:   Apply the PnP changes depending on the actions performed.
//
// Arguments:
//          IN pfCallback  :  SendPnpConfig Callback interface.
//          IN eApplyAction:  Action that was last performed.
//                            
//
// Returns: S_OK.
//
// Notes:
//        More than one action could have been performed by the user
//        but this function is called only once at the end. So, the argument
//        only denotes the very last action performed. For example, if the 
//        user deletes one miniport and adds two miniports then, the argument
//        will denote an add action.
//

HRESULT CMuxPhysicalAdapter::ApplyPnpChanges(
                    INetCfgPnpReconfigCallback *pfCallback,
                    ConfigAction eApplyAction)
{
    CMuxVirtualMiniport     *pMiniport;
    GUID                    guidMiniport;
    WCHAR                   szMiniportGuid[MAX_PATH+1];
    LPWSTR                  lpDevice;
    DWORD                   dwMiniportCount;
    DWORD                   i;
    DWORD                   dwBytes;
    INetCfgComponent        *pncc;
    HRESULT                 hr;

#ifdef CUSTOM_EVENTS    
    LPWSTR                  lpszBindName;
    PNOTIFY_CUSTOM_EVENT       lppnpEvent;
#endif

    TraceMsg( L"-->CMuxPhysicalAdapter::ApplyPnpChanges.\n" );

#ifdef CUSTOM_EVENTS    

    //
    // Find the instance of the adapter to get its bindname.
    //

    hr = HrFindInstance( m_pnc,
                         m_guidAdapter,
                         &pncc );

    if ( hr == S_OK ) {

        hr = pncc->GetBindName( &lpszBindName );

        if ( hr != S_OK ) {
            TraceMsg( L"  GetBindName failed.(HRESULT = %x). PnP changes will not "
                      L"be applied and the driver will not be notified.\n",
                      hr );
        }

        ReleaseObj( pncc );
    }
    else {
        TraceMsg( L"  PnP changes will not "
               L"be applied and the driver will not be notified.\n",
               hr );
    }

#endif    

    dwMiniportCount = m_MiniportsToAdd.ListCount();

    TraceMsg( L"   Applying PnP changes to %d new miniports.\n",
            dwMiniportCount );

    for (i=0; i < dwMiniportCount; ++i) {

        m_MiniportsToAdd.Remove( &pMiniport );

        pMiniport->GetMiniportGUID( &guidMiniport );

        m_MiniportList.Insert( pMiniport,
                               guidMiniport );

        //
        // Do miniport specific Pnp Changes when they are added.
        //

        hr = pMiniport->ApplyPnpChanges( pfCallback,
                                         eActAdd );

#ifdef CUSTOM_EVENTS


        //
        // Notify the driver that one or more virtual miniports have been added.
        //

        StringFromGUID2( guidMiniport,
                         szMiniportGuid,
                         MAX_PATH+1 );
        lpDevice = AddDevicePrefix( szMiniportGuid );

        if ( lpDevice ) {

            dwBytes = sizeof(NOTIFY_CUSTOM_EVENT) +
                      ((wcslen(lpDevice) + 1) * sizeof(WCHAR));

            lppnpEvent = (PNOTIFY_CUSTOM_EVENT)malloc( dwBytes );

            if ( lppnpEvent ) {

                lppnpEvent->uSignature = NOTIFY_SIGNATURE;
                lppnpEvent->uEvent = MUX_CUSTOM_EVENT;
                wcscpy( lppnpEvent->szMiniport,
                       lpDevice );

                hr = pfCallback->SendPnpReconfig( NCRL_NDIS,
                                                 c_szMuxService,
                                                 lpszBindName,
                                                 (PVOID)lppnpEvent,
                                                 dwBytes );

                TraceMsg( L"   INetCfgPnpReconfigCallback->SendPnpReconfig returned "
                         L"%#x.\n",
                         hr );

                if ( hr != S_OK ) {

                  TraceMsg( L"   Failed to apply Pnp changes, miniport(%d).\n",
                            i );

                }

                free( lppnpEvent );
            }
            free( lpDevice );
        }
#endif        
    }

    dwMiniportCount = m_MiniportsToRemove.ListCount();

    TraceMsg( L"   Applying PnP changes to %d removed miniports.\n",
            dwMiniportCount );

    for (i=0; i < dwMiniportCount; ++i) {

        m_MiniportsToRemove.Remove( &pMiniport );

        pMiniport->GetMiniportGUID( &guidMiniport );

        //
        // Do miniport specific Pnp Changes when they are uninstalled.
        //

        hr = pMiniport->ApplyPnpChanges( pfCallback,
                                         eActRemove );

        delete pMiniport;

#ifdef CUSTOM_EVENTS

        //
        // Notify the driver that one or more virtual miniports have been
        // uninstalled.
        //
        // We can't notify the driver in case the adapter or the protocol is
        // being uninstalled because the binding handle doesn't exist.
        //

        if ( eApplyAction != eActRemove ) {

            StringFromGUID2( guidMiniport,
                             szMiniportGuid,
                             MAX_PATH+1 );
            lpDevice = AddDevicePrefix( szMiniportGuid );

            if ( lpDevice ) {

                dwBytes = sizeof(NOTIFY_CUSTOM_EVENT) +
                         ((wcslen(lpDevice) + 1) * sizeof(WCHAR));

                lppnpEvent = (PNOTIFY_CUSTOM_EVENT)malloc( dwBytes );

                if ( lppnpEvent ) {

                    lppnpEvent->uSignature = NOTIFY_SIGNATURE;
                    lppnpEvent->uEvent = MUX_CUSTOM_EVENT;
                    wcscpy( lppnpEvent->szMiniport,
                          lpDevice );

                    hr = pfCallback->SendPnpReconfig( NCRL_NDIS,
                                                    c_szMuxService,
                                                    lpszBindName,
                                                    (PVOID)lppnpEvent,
                                                    dwBytes );
                    TraceMsg( L"   INetCfgPnpReconfigCallback->SendPnpReconfig returned "
                            L"%#x.\n",
                            hr );

                    if ( hr != S_OK ) {

                        TraceMsg( L"   Failed to apply Pnp changes, miniport(%d).\n",
                               i );

                    }

                    free( lppnpEvent );
                }

                free( lpDevice );
            }
        }
#endif         

    }

#ifdef CUSTOM_EVENTS    
    CoTaskMemFree( lpszBindName );
#endif

    TraceMsg( L"<--CMuxPhysicalAdapter::ApplyPnpChanges(HRESULT = %x).\n",
            S_OK );

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Function:  CMuxPhysicalAdapter::CancelChanges
//
// Purpose:   Cancel any changes made.
//
// Arguments: None
//                            
//
// Returns: S_OK.
//
// Notes:
//

HRESULT CMuxPhysicalAdapter::CancelChanges (VOID)
{
    TraceMsg( L"-->CMuxPhysicalAdapter::CancelChanges.\n" );

    TraceMsg( L"<--CMuxPhysicalAdapter::CancelChanges(HRESULT = %x).\n",
            S_OK );

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Function:  CMuxPhysicalAdapter::AllMiniportsRemoved
//
// Purpose:   Find out if there is no miniport installed on the adapter.
//
// Arguments: None
//                            
//
// Returns: TRUE if all the miniports associated with this adapter have been
//          uninstalled and there is none pending to be added, otherwise FALSE.
//
// Notes:
//

BOOL  CMuxPhysicalAdapter::AllMiniportsRemoved (VOID)
{
  return (m_MiniportList.ListCount() + m_MiniportsToAdd.ListCount()) == 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\samples\bindview\netcfgapi.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       N E T C F G A P I . C P P
//
//  Contents:   Functions to illustrate INetCfg API
//
//  Notes:      
//
//  Author:     Alok Sinha    15-May-01
//
//----------------------------------------------------------------------------

#include "NetCfgAPI.h"

//
// Function:  HrGetINetCfg
//
// Purpose:   Get a reference to INetCfg.
//
// Arguments:
//    fGetWriteLock  [in]  If TRUE, Write lock.requested.
//    lpszAppName    [in]  Application name requesting the reference.
//    ppnc           [out] Reference to INetCfg.
//    lpszLockedBy   [in]  Optional. Application who holds the write lock.
//
// Returns:   S_OK on sucess, otherwise an error code.
//
// Notes:
//

HRESULT HrGetINetCfg (IN BOOL fGetWriteLock,
                      IN LPCWSTR lpszAppName,
                      OUT INetCfg** ppnc,
                      OUT LPWSTR *lpszLockedBy)
{
    INetCfg      *pnc = NULL;
    INetCfgLock  *pncLock = NULL;
    HRESULT      hr = S_OK;

    //
    // Initialize the output parameters.
    //

    *ppnc = NULL;

    if ( lpszLockedBy )
    {
        *lpszLockedBy = NULL;
    }
    //
    // Initialize COM
    //

    hr = CoInitialize( NULL );

    if ( hr == S_OK ) {

        //
        // Create the object implementing INetCfg.
        //

        hr = CoCreateInstance( CLSID_CNetCfg,
                               NULL, CLSCTX_INPROC_SERVER,
                               IID_INetCfg,
                               (void**)&pnc );
        if ( hr == S_OK ) {

            if ( fGetWriteLock ) {

                //
                // Get the locking reference
                //

                hr = pnc->QueryInterface( IID_INetCfgLock,
                                          (LPVOID *)&pncLock );
                if ( hr == S_OK ) {

                    //
                    // Attempt to lock the INetCfg for read/write
                    //

                    hr = pncLock->AcquireWriteLock( LOCK_TIME_OUT,
                                                    lpszAppName,
                                                    lpszLockedBy);
                    if (hr == S_FALSE ) {
                        hr = NETCFG_E_NO_WRITE_LOCK;
                    }
                }
            }

            if ( hr == S_OK ) {

                //
                // Initialize the INetCfg object.
                //

                hr = pnc->Initialize( NULL );

                if ( hr == S_OK ) {
                    *ppnc = pnc;
                    pnc->AddRef();
                }
                else {

                    //
                    // Initialize failed, if obtained lock, release it
                    //

                    if ( pncLock ) {
                        pncLock->ReleaseWriteLock();
                    }
                }
            }

            ReleaseRef( pncLock );
            ReleaseRef( pnc );
        }

        //
        // In case of error, uninitialize COM.
        //

        if ( hr != S_OK ) {
            CoUninitialize();
        }
    }

    return hr;
}

//
// Function:  HrReleaseINetCfg
//
// Purpose:   Get a reference to INetCfg.
//
// Arguments:
//    pnc           [in] Reference to INetCfg to release.
//    fHasWriteLock [in] If TRUE, reference was held with write lock.
//
// Returns:   S_OK on sucess, otherwise an error code.
//
// Notes:
//

HRESULT HrReleaseINetCfg (IN INetCfg* pnc,
                          IN BOOL fHasWriteLock)
{
    INetCfgLock    *pncLock = NULL;
    HRESULT        hr = S_OK;

    //
    // Uninitialize INetCfg
    //

    hr = pnc->Uninitialize();

    //
    // If write lock is present, unlock it
    //

    if ( hr == S_OK && fHasWriteLock ) {

        //
        // Get the locking reference
        //

        hr = pnc->QueryInterface( IID_INetCfgLock,
                                  (LPVOID *)&pncLock);
        if ( hr == S_OK ) {
           hr = pncLock->ReleaseWriteLock();
           ReleaseRef( pncLock );
        }
    }

    ReleaseRef( pnc );

    //
    // Uninitialize COM.
    //

    CoUninitialize();

    return hr;
}

//
// Function:  HrInstallNetComponent
//
// Purpose:   Install a network component(protocols, clients and services)
//            given its INF file.
//
// Arguments:
//    pnc              [in] Reference to INetCfg.
//    lpszComponentId  [in] PnpID of the network component.
//    pguidClass       [in] Class GUID of the network component.
//    lpszInfFullPath  [in] INF file to install from.
//
// Returns:   S_OK on sucess, otherwise an error code.
//
// Notes:
//

HRESULT HrInstallNetComponent (IN INetCfg *pnc,
                               IN LPCWSTR lpszComponentId,
                               IN const GUID    *pguidClass,
                               IN LPCWSTR lpszInfFullPath)
{
    DWORD     dwError;
    HRESULT   hr = S_OK;
    WCHAR     Drive[_MAX_DRIVE];
    WCHAR     Dir[_MAX_DIR];
    WCHAR     DirWithDrive[_MAX_DRIVE+_MAX_DIR];

    //
    // If full path to INF has been specified, the INF
    // needs to be copied using Setup API to ensure that any other files
    // that the primary INF copies will be correctly found by Setup API
    //

    if ( lpszInfFullPath ) {

        //
        // Get the path where the INF file is.
        //

        _wsplitpath( lpszInfFullPath, Drive, Dir, NULL, NULL );

        wcscpy( DirWithDrive, Drive );
        wcscat( DirWithDrive, Dir );

        //
        // Copy the INF file and other files referenced in the INF file.
        //

        if ( !SetupCopyOEMInfW(lpszInfFullPath,
                               DirWithDrive,  // Other files are in the
                                              // same dir. as primary INF
                               SPOST_PATH,    // First param is path to INF
                               0,             // Default copy style
                               NULL,          // Name of the INF after
                                              // it's copied to %windir%\inf
                               0,             // Max buf. size for the above
                               NULL,          // Required size if non-null
                               NULL) ) {      // Optionally get the filename
                                              // part of Inf name after it is copied.
            dwError = GetLastError();

            hr = HRESULT_FROM_WIN32( dwError );
        }
    }

    if ( S_OK == hr ) {

        //
        // Install the network component.
        //

        hr = HrInstallComponent( pnc,
                                 lpszComponentId,
                                 pguidClass );
        if ( hr == S_OK ) {

            //
            // On success, apply the changes
            //

            hr = pnc->Apply();
        }
    }

    return hr;
}

//
// Function:  HrInstallComponent
//
// Purpose:   Install a network component(protocols, clients and services)
//            given its INF file.
// Arguments:
//    pnc              [in] Reference to INetCfg.
//    lpszComponentId  [in] PnpID of the network component.
//    pguidClass       [in] Class GUID of the network component.
//
// Returns:   S_OK on sucess, otherwise an error code.
//
// Notes:
//

HRESULT HrInstallComponent(IN INetCfg* pnc,
                           IN LPCWSTR szComponentId,
                           IN const GUID* pguidClass)
{
    INetCfgClassSetup   *pncClassSetup = NULL;
    INetCfgComponent    *pncc = NULL;
    OBO_TOKEN           OboToken;
    HRESULT             hr = S_OK;

    //
    // OBO_TOKEN specifies on whose behalf this
    // component is being installed.
    // Set it to OBO_USER so that szComponentId will be installed
    // on behalf of the user.
    //

    ZeroMemory( &OboToken,
                sizeof(OboToken) );
    OboToken.Type = OBO_USER;

    //
    // Get component's setup class reference.
    //

    hr = pnc->QueryNetCfgClass ( pguidClass,
                                 IID_INetCfgClassSetup,
                                 (void**)&pncClassSetup );
    if ( hr == S_OK ) {

        hr = pncClassSetup->Install( szComponentId,
                                     &OboToken,
                                     0,
                                     0,       // Upgrade from build number.
                                     NULL,    // Answerfile name
                                     NULL,    // Answerfile section name
                                     &pncc ); // Reference after the component
        if ( S_OK == hr ) {                   // is installed.

            //
            // we don't need to use pncc (INetCfgComponent), release it
            //

            ReleaseRef( pncc );
        }

        ReleaseRef( pncClassSetup );
    }

    return hr;
}

//
// Function:  HrUninstallNetComponent
//
// Purpose:   Uninstall a network component(protocols, clients and services).
//
// Arguments:
//    pnc           [in] Reference to INetCfg.
//    szComponentId [in] PnpID of the network component to uninstall.
//
// Returns:   S_OK on sucess, otherwise an error code.
//
// Notes:
//

HRESULT HrUninstallNetComponent(IN INetCfg* pnc,
                                IN LPCWSTR szComponentId)
{
    INetCfgComponent    *pncc = NULL;
    INetCfgClass        *pncClass = NULL;
    INetCfgClassSetup   *pncClassSetup = NULL;
    OBO_TOKEN           OboToken;
    GUID                guidClass;
    HRESULT             hr = S_OK;

    //
    // OBO_TOKEN specifies on whose behalf this
    // component is being installed.
    // Set it to OBO_USER so that szComponentId will be installed
    // on behalf of the user.
    //

    ZeroMemory( &OboToken,
                sizeof(OboToken) );
    OboToken.Type = OBO_USER;

    //
    // Get the component's reference.
    //

    hr = pnc->FindComponent( szComponentId,
                             &pncc );

    if (S_OK == hr) {

        //
        // Get the component's class GUID.
        //

        hr = pncc->GetClassGuid( &guidClass );

        if ( hr == S_OK ) {

            //
            // Get component's class reference.
            //

            hr = pnc->QueryNetCfgClass( &guidClass,
                                        IID_INetCfgClass,
                                        (void**)&pncClass );
            if ( hr == S_OK ) {

                //
                // Get Setup reference.
                //

                hr = pncClass->QueryInterface( IID_INetCfgClassSetup,
                                               (void**)&pncClassSetup );
                    if ( hr == S_OK ) {

                         hr = pncClassSetup->DeInstall( pncc,
                                                        &OboToken,
                                                        NULL);
                         if ( hr == S_OK ) {

                             //
                             // Apply the changes
                             //

                             hr = pnc->Apply();
                         }

                         ReleaseRef( pncClassSetup );
                    }

                ReleaseRef( pncClass );
            }
        }

        ReleaseRef( pncc );
    }

    return hr;
}

//
// Function:  HrGetComponentEnum
//
// Purpose:   Get network component enumerator reference.
//
// Arguments:
//    pnc         [in]  Reference to INetCfg.
//    pguidClass  [in]  Class GUID of the network component.
//    ppencc      [out] Enumerator reference.
//
// Returns:   S_OK on sucess, otherwise an error code.
//
// Notes:
//

HRESULT HrGetComponentEnum (INetCfg* pnc,
                            IN const GUID* pguidClass,
                            OUT IEnumNetCfgComponent **ppencc)
{
    INetCfgClass  *pncclass;
    HRESULT       hr;

    *ppencc = NULL;

    //
    // Get the class reference.
    //

    hr = pnc->QueryNetCfgClass( pguidClass,
                                IID_INetCfgClass,
                                (PVOID *)&pncclass );

    if ( hr == S_OK ) {

        //
        // Get the enumerator reference.
        //

        hr = pncclass->EnumComponents( ppencc );

        //
        // We don't need the class reference any more.
        //

        ReleaseRef( pncclass );
    }

    return hr;
}

//
// Function:  HrGetFirstComponent
//
// Purpose:   Enumerates the first network component.
//
// Arguments:
//    pencc      [in]  Component enumerator reference.
//    ppncc      [out] Network component reference.
//
// Returns:   S_OK on sucess, otherwise an error code.
//
// Notes:
//

HRESULT HrGetFirstComponent (IN IEnumNetCfgComponent* pencc,
                             OUT INetCfgComponent **ppncc)
{
    HRESULT  hr;
    ULONG    ulCount;

    *ppncc = NULL;

    pencc->Reset();

    hr = pencc->Next( 1,
                      ppncc,
                      &ulCount );
    return hr;
}

//
// Function:  HrGetNextComponent
//
// Purpose:   Enumerate the next network component.
//
// Arguments:
//    pencc      [in]  Component enumerator reference.
//    ppncc      [out] Network component reference.
//
// Returns:   S_OK on sucess, otherwise an error code.
//
// Notes:     The function behaves just like HrGetFirstComponent if
//            it is called right after HrGetComponentEnum.
//
//

HRESULT HrGetNextComponent (IN IEnumNetCfgComponent* pencc,
                            OUT INetCfgComponent **ppncc)
{
    HRESULT  hr;
    ULONG    ulCount;

    *ppncc = NULL;

    hr = pencc->Next( 1,
                      ppncc,
                      &ulCount );
    return hr;
}

//
// Function:  HrGetBindingPathEnum
//
// Purpose:   Get network component's binding path enumerator reference.
//
// Arguments:
//    pncc           [in]  Network component reference.
//    dwBindingType  [in]  EBP_ABOVE or EBP_BELOW.
//    ppencbp        [out] Enumerator reference.
//
// Returns:   S_OK on sucess, otherwise an error code.
//
// Notes:
//

HRESULT HrGetBindingPathEnum (IN INetCfgComponent *pncc,
                              IN DWORD dwBindingType,
                              OUT IEnumNetCfgBindingPath **ppencbp)
{
    INetCfgComponentBindings *pnccb = NULL;
    HRESULT                  hr;

    *ppencbp = NULL;

    //
    // Get component's binding.
    //

    hr = pncc->QueryInterface( IID_INetCfgComponentBindings,
                               (PVOID *)&pnccb );

    if ( hr == S_OK ) {

        //
        // Get binding path enumerator reference.
        //

        hr = pnccb->EnumBindingPaths( dwBindingType,
                                      ppencbp );

        ReleaseRef( pnccb );
    }

    return hr;
}

//
// Function:  HrGetFirstBindingPath
//
// Purpose:   Enumerates the first binding path.
//
// Arguments:
//    pencc      [in]  Binding path enumerator reference.
//    ppncc      [out] Binding path reference.
//
// Returns:   S_OK on sucess, otherwise an error code.
//
// Notes:
//

HRESULT HrGetFirstBindingPath (IN IEnumNetCfgBindingPath *pencbp,
                               OUT INetCfgBindingPath **ppncbp)
{
    ULONG   ulCount;
    HRESULT hr;

    *ppncbp = NULL;

    pencbp->Reset();

    hr = pencbp->Next( 1,
                       ppncbp,
                       &ulCount );

    return hr;
}

//
// Function:  HrGetNextBindingPath
//
// Purpose:   Enumerate the next binding path.
//
// Arguments:
//    pencbp      [in]  Binding path enumerator reference.
//    ppncbp      [out] Binding path reference.
//
// Returns:   S_OK on sucess, otherwise an error code.
//
// Notes:     The function behaves just like HrGetFirstBindingPath if
//            it is called right after HrGetBindingPathEnum.
//
//

HRESULT HrGetNextBindingPath (IN IEnumNetCfgBindingPath *pencbp,
                              OUT INetCfgBindingPath **ppncbp)
{
    ULONG   ulCount;
    HRESULT hr;

    *ppncbp = NULL;

    hr = pencbp->Next( 1,
                       ppncbp,
                       &ulCount );

    return hr;
}

//
// Function:  HrGetBindingInterfaceEnum
//
// Purpose:   Get binding interface enumerator reference.
//
// Arguments:
//    pncbp          [in]  Binding path reference.
//    ppencbp        [out] Enumerator reference.
//
// Returns:   S_OK on sucess, otherwise an error code.
//
// Notes:
//

HRESULT HrGetBindingInterfaceEnum (IN INetCfgBindingPath *pncbp,
                                   OUT IEnumNetCfgBindingInterface **ppencbi)
{
    HRESULT hr;

    *ppencbi = NULL;

    hr = pncbp->EnumBindingInterfaces( ppencbi );

    return hr;
}

//
// Function:  HrGetFirstBindingInterface
//
// Purpose:   Enumerates the first binding interface.
//
// Arguments:
//    pencbi      [in]  Binding interface enumerator reference.
//    ppncbi      [out] Binding interface reference.
//
// Returns:   S_OK on sucess, otherwise an error code.
//
// Notes:
//

HRESULT HrGetFirstBindingInterface (IN IEnumNetCfgBindingInterface *pencbi,
                                    OUT INetCfgBindingInterface **ppncbi)
{
    ULONG   ulCount;
    HRESULT hr;

    *ppncbi = NULL;

    pencbi->Reset();

    hr = pencbi->Next( 1,
                       ppncbi,
                       &ulCount );

    return hr;
}

//
// Function:  HrGetNextBindingInterface
//
// Purpose:   Enumerate the next binding interface.
//
// Arguments:
//    pencbi      [in]  Binding interface enumerator reference.
//    ppncbi      [out] Binding interface reference.
//
// Returns:   S_OK on sucess, otherwise an error code.
//
// Notes:     The function behaves just like HrGetFirstBindingInterface if
//            it is called right after HrGetBindingInterfaceEnum.
//
//

HRESULT HrGetNextBindingInterface (IN IEnumNetCfgBindingInterface *pencbi,
                                   OUT INetCfgBindingInterface **ppncbi)
{
    ULONG   ulCount;
    HRESULT hr;

    *ppncbi = NULL;

    hr = pencbi->Next( 1,
                       ppncbi,
                       &ulCount );

    return hr;
}

//
// Function:  ReleaseRef
//
// Purpose:   Release reference.
//
// Arguments:
//    punk     [in]  IUnknown reference to release.
//
// Returns:   Reference count.
//
// Notes:
//

VOID ReleaseRef (IN IUnknown* punk)
{
    if ( punk ) {
        punk->Release();
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\samples\muxim\implinc.cpp ===
#include <windows.h>
#include <shellapi.h>
#include <shlobj.h>

#include <atlbase.h>
extern CComModule _Module;  // required by atlcom.h
#include <atlcom.h>
#include <initguid.h>
#include <devguid.h>

#ifdef SubclassWindow

#undef SubclassWindow

#endif

#include <atlwin.h>

#ifdef _ATL_STATIC_REGISTRY

#include <statreg.h>
#include <statreg.cpp>

#endif

#include <atlimpl.cpp>
#include <atlwin.cpp>


//EXTERN_C const IID IID_INetLanConnectionUiInfo = {0xC08956A6,0x1CD3,0x11D1,{0xB1,0xC5,0x00,0x80,0x5F,0xC1,0x27,0x0E}};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\samples\muxim\adapter.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992-2001.
//
//  File:       A D A P T E R . H
//
//  Contents:   Header file for physical adapter class.
//
//  Notes:
//
//  Author:     Alok Sinha 31-Oct-2000
//
//----------------------------------------------------------------------------

#ifndef ADAPTER_H_INCLUDED

#define ADAPTER_H_INCLUDED

#include <windows.h>
#include <netcfgn.h>

#include "common.h"
#include "virtual.h"
#include "list.h"

//
// Class to represent a physical adapter.
//

class CMuxPhysicalAdapter
{
    //
    // Private member variables.
    //

    GUID    m_guidAdapter;

    INetCfg *m_pnc;

    //
    // List of virtual miniports associated with the adapter.
    //

    List<CMuxVirtualMiniport *, GUID> m_MiniportList;

    //
    // List of virtual miniports to be added.
    //

    List<CMuxVirtualMiniport *, GUID> m_MiniportsToAdd;

    //
    // List of virtual miniports to be removed.
    //

    List<CMuxVirtualMiniport *, GUID> m_MiniportsToRemove;

    //
    // Private member functions.
    //

  public:

    //
    // Public member functions
    //

    CMuxPhysicalAdapter (INetCfg *pnc,
                         GUID *guidAdapter);

    virtual ~CMuxPhysicalAdapter (VOID);

    HRESULT LoadConfiguration (VOID);

    VOID    GetAdapterGUID (GUID *guidAdapter);

    HRESULT AddMiniport (CMuxVirtualMiniport *pNewMiniport);

    HRESULT RemoveMiniport (GUID *pguidMiniport);

    HRESULT Remove (VOID);

    HRESULT ApplyRegistryChanges (ConfigAction eApplyAction);

    HRESULT ApplyPnpChanges (INetCfgPnpReconfigCallback *pfCallback,
                             ConfigAction eApplyAction);

    HRESULT CancelChanges (VOID);

    DWORD MiniportCount (VOID) { return m_MiniportList.ListCount(); }

    BOOL  AllMiniportsRemoved (VOID);
};


#endif // ADAPTER_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\samples\muxim\common.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992-2001.
//
//  File:       C O M M O N. H
//
//  Contents:   Common macros and declarations for the sample notify object.
//
//  Notes:
//
//  Author:     Alok Sinha
//
//----------------------------------------------------------------------------


#ifndef COMMON_H_INCLUDED

#define COMMON_H_INCLUDED

#include <devguid.h>

enum ConfigAction {

    eActUnknown, 
    eActInstall, 
    eActAdd, 
    eActRemove,
    eActUpdate,
    eActPropertyUIAdd,
    eActPropertyUIRemove
};       

//
// PnP ID, also referred to as Hardware ID, of the protocol interface.
//

const WCHAR c_szMuxProtocol[] = L"ms_muxp";

//
// PnP ID, also referred to as Hardware ID, of the Miniport interface.
//

const WCHAR c_szMuxMiniport[] = L"ms_muxmp";

//
// Name of the service as specified in the inf file in AddService directive.
//

const WCHAR c_szMuxService[] = L"muxp";

//
// Path to the config string where the virtual miniport instance names
// are stored.
//

const WCHAR c_szAdapterList[] =
                  L"System\\CurrentControlSet\\Services\\muxp\\Parameters\\Adapters";

//
// Value name in the registry where miniport device id is stored.
//

const WCHAR c_szUpperBindings[] = L"UpperBindings";


const WCHAR c_szDevicePrefix[] = L"\\Device\\";

#define ReleaseObj( x )  if ( x ) \
                            ((IUnknown*)(x))->Release();


#if DBG
void TraceMsg (LPWSTR szFormat, ...);
void DumpChangeFlag (DWORD dwChangeFlag);
void DumpBindingPath (INetCfgBindingPath* pncbp);
void DumpComponent (INetCfgComponent *pncc);
#else
#define TraceMsg
#define DumpChangeFlag( x )
#define DumpBindingPath( x )
#define DumpComponent( x )
#endif

HRESULT HrFindInstance (INetCfg *pnc,
                        GUID &guidInstance,
                        INetCfgComponent **ppnccMiniport);

LONG AddToMultiSzValue( HKEY hkeyAdapterGuid,
                        LPWSTR szMiniportGuid);

LONG DeleteFromMultiSzValue( HKEY hkeyAdapterGuid,
                             LPWSTR szMiniportGuid);

LPWSTR AddDevicePrefix (LPWSTR lpStr);
LPWSTR RemoveDevicePrefix (LPWSTR lpStr);

#endif // COMMON_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\samples\muxim\common.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992-2001.
//
//  File:       COMMON.CPP
//
//  Contents:   Debug & Utility functions
//
//  Notes:
//
//  Author:     Alok Sinha
//
//----------------------------------------------------------------------------

#include <windows.h>
#include <stdio.h>
#include <netcfgn.h>
#include "common.h"

#ifdef DBG

void TraceMsg (LPWSTR szFormat, ...)
{
    static WCHAR szTempBuf[4096];

    va_list arglist;

    va_start(arglist, szFormat);

    vswprintf( szTempBuf, szFormat, arglist );

    OutputDebugStringW( szTempBuf );

    va_end(arglist);
}

void DumpChangeFlag (DWORD dwChangeFlag)
{
    TraceMsg( L"   ChangeFlag:" );

    if ( dwChangeFlag & NCN_ADD ) {
        TraceMsg( L" NCN_ADD" );
    }

    if ( dwChangeFlag & NCN_REMOVE ) {
        TraceMsg( L" NCN_REMOVE" );
    }

    if ( dwChangeFlag & NCN_UPDATE ) {
        TraceMsg( L" NCN_UPDATE" );
    }

    if ( dwChangeFlag & NCN_ENABLE ) {
        TraceMsg( L" NCN_ENABLE" );
    }

    if ( dwChangeFlag & NCN_DISABLE ) {
        TraceMsg( L" NCN_DISABLE" );
    }

    if ( dwChangeFlag & NCN_BINDING_PATH ) {
        TraceMsg( L" NCN_BINDING_PATH" );
    }

    if ( dwChangeFlag & NCN_PROPERTYCHANGE ) {
        TraceMsg( L" NCN_PROPERTYCHANGE" );
    }

    if ( dwChangeFlag & NCN_NET ) {
        TraceMsg( L" NCN_NET" );
    }

    if ( dwChangeFlag & NCN_NETTRANS ) {
        TraceMsg( L" NCN_NETTRANS" );
    }

    if ( dwChangeFlag & NCN_NETCLIENT ) {
        TraceMsg( L" NCN_NETCLIENT" );
    }

    if ( dwChangeFlag & NCN_NETSERVICE ) {
        TraceMsg( L" NCN_NETSERVICE" );
    }

    TraceMsg( L"\n" );
    return;
}

void DumpBindingPath (INetCfgBindingPath *pncbp)
{
    INetCfgComponent             *pncc;
    IEnumNetCfgBindingInterface  *pencbi;
    INetCfgBindingInterface      *pncbi;
    LPWSTR                       lpsz;
    DWORD                        dwIndex;
    ULONG                        ulCount;
    HRESULT                      hr;

    hr = pncbp->GetPathToken( &lpsz );

    if ( hr == S_OK ) {

        TraceMsg( L"   BindingPath: %s\n",
               lpsz );

        CoTaskMemFree( lpsz );
    }
    else {

    TraceMsg( L"   BindingPath: GetPathToken failed(HRESULT %x).\n",
           hr );
    }

#ifdef VERBOSE_TRACE

    hr = pncbp->EnumBindingInterfaces( &pencbi );

    if ( hr == S_OK ) {

        hr = pencbi ->Next( 1, &pncbi, &ulCount );

        for (dwIndex=0; hr == S_OK; dwIndex++ ) {

            hr = pncbi->GetName( &lpsz );

            if ( hr == S_OK ) {

               TraceMsg( L"   BindingInterface(%d): %s\n",
                         dwIndex, lpsz );

               CoTaskMemFree( lpsz );
            }
            else {

               TraceMsg( L"   BindingInterface(%d): GetName failed(HRESULT %x).\n",
                         dwIndex, hr );
            }

            hr = pncbi->GetUpperComponent( &pncc );

            if ( hr == S_OK ) {

                TraceMsg( L"   \tUpperComponent of the interface(%d)...\n",
                         dwIndex );

                DumpComponent( pncc );

                ReleaseObj( pncc );
            }
            else {

                TraceMsg( L"   UpperComponent: GetUpperComponent failed(HRESULT = %x).\n",
                         hr );
            }
            hr = pncbi->GetLowerComponent( &pncc );

            if ( hr == S_OK ) {

                TraceMsg( L"   \tLowerComponent of the interface(%d)...\n",
                         dwIndex );
                DumpComponent( pncc );

                ReleaseObj( pncc );
            }
            else {

                TraceMsg( L"   LowerComponent: GetLowerComponent failed(HRESULT = %x).\n",
                         hr );
            }

            ReleaseObj( pncbi );

            hr = pencbi ->Next( 1,
                                     &pncbi,
                                     &ulCount );
        }

        ReleaseObj( pencbi );
    }
    else {

        TraceMsg( L"   EnumBindingInterfaces failed, (HRESULT = %x)\n",
                  hr ); 
    }
#endif 
    return;
}

void DumpComponent (INetCfgComponent *pncc)
{
    LPWSTR  lpsz;
    DWORD   dwChars;
    ULONG   ulStatus;
    HRESULT hr;

    hr = pncc->GetDisplayName( &lpsz );

    if ( hr == S_OK ) {

        TraceMsg( L"   \t\tComponent: %s\n",
               lpsz );

        CoTaskMemFree( lpsz );
    }
    else {

        TraceMsg( L"   GetDisplay failed(HRESULT %x).\n",
               hr );
    }

    hr = pncc->GetCharacteristics( &dwChars );

    if ( hr == S_OK ) {

        TraceMsg( L"   \t\tCharacteristics:" );

        if ( dwChars & NCF_HIDDEN ) {
           TraceMsg( L" NCF_HIDDEN" );
        }

        if ( dwChars & NCF_NO_SERVICE ) {
           TraceMsg( L" NCF_NO_SERVICE" );
        }

        if ( dwChars & NCF_VIRTUAL ) {
           TraceMsg( L" NCF_VIRTUAL" );
        }

        if ( dwChars & NCF_PHYSICAL ) {
           TraceMsg( L" NCF_PHYSICAL" );
        }

        if ( dwChars & NCF_FILTER ) {
           TraceMsg( L" NCF_FILTER" );
        }

        if ( dwChars & NCF_NOT_USER_REMOVABLE ) {
           TraceMsg( L" NCF_NOT_USER_REMOVABLE" );
        }

        if ( dwChars & NCF_HAS_UI ) {
           TraceMsg( L" NCF_HAS_UI" );
        }

        if ( dwChars & NCF_SOFTWARE_ENUMERATED ) {
           TraceMsg( L" NCF_SOFTWARE_ENUMERATED" );
        }

        if ( dwChars & NCF_MULTIPORT_INSTANCED_ADAPTER ) {
           TraceMsg( L" NCF_MULTIPORT_INSTANCED_ADAPTER" );
        }

        TraceMsg( L"\n" );
    }
    else {

        TraceMsg( L"   GetCharacteristics failed(HRESULT %x).\n",
               hr );
    }

    hr = pncc->GetId( &lpsz );

    if ( hr == S_OK ) {

        TraceMsg( L"   \t\tHardware Id: %s\n",
               lpsz );

        CoTaskMemFree( lpsz );
    }
    else {

        TraceMsg( L"   GetId failed(HRESULT %x).\n",
               hr );
    }

    hr = pncc->GetBindName( &lpsz );

    if ( hr == S_OK ) {

        TraceMsg( L"   \t\tBindName: %s\n",
               lpsz );

        CoTaskMemFree( lpsz );
    }
    else {

        TraceMsg( L"   GetBindName failed(HRESULT %x).\n",
               hr );
    }

    if ( dwChars & NCF_PHYSICAL ) {
        hr = pncc->GetDeviceStatus( &ulStatus );

        if ( hr == S_OK ) {

            TraceMsg( L"   \t\tDeviceStatus: %#x\n",
                      ulStatus );
        }
        else {

            TraceMsg( L"   GetDeviceStatus failed(HRESULT %x).\n",
                      hr );
        }
    }

  return;
}

#endif

HRESULT HrFindInstance (INetCfg *pnc,
                        GUID &guidInstance,
                        INetCfgComponent **ppnccMiniport)
{
    IEnumNetCfgComponent  *pencc;
    INetCfgComponent      *pncc;
    GUID                  guid;
    WCHAR                 szGuid[MAX_PATH+1];
    ULONG                 ulCount;
    BOOL                  found;
    HRESULT               hr;

    TraceMsg( L"-->HrFindInstance.\n" );

    hr = pnc->EnumComponents( &GUID_DEVCLASS_NET,
                            &pencc );

    if ( hr == S_OK ) {

        StringFromGUID2( guidInstance,
                      szGuid,
                      MAX_PATH+1 );

        TraceMsg( L"  Looking for component with InstanceGuid %s\n",
               szGuid );

        hr = pencc->Next( 1,
                          &pncc,
                          &ulCount );

        for ( found=FALSE; (hr == S_OK) && (found == FALSE); ) {

            hr = pncc->GetInstanceGuid( &guid );

            if ( hr == S_OK ) {

                StringFromGUID2( guid,
                                szGuid,
                                MAX_PATH+1 );

                TraceMsg( L"  Found component with InstanceGuid %s\n",
                         szGuid );

                found = IsEqualGUID( guid,
                                    guidInstance );

                if ( found == FALSE ) {

                    ReleaseObj( pncc );

                    hr = pencc->Next( 1,
                                    &pncc,
                                    &ulCount );
                }
                else {
                    *ppnccMiniport = pncc;
                }
            }
        }   

        ReleaseObj( pencc );
    }
    else {

     TraceMsg( L"   EnumComponents failed(HRESULT = %x).\n",
               hr );
    }

    TraceMsg( L"<--HrFindInstance(HRESULT = %x).\n",
            hr );

    return hr;
}

LONG AddToMultiSzValue( HKEY hkeyAdapterGuid,
                        LPWSTR szMiniportGuid)
{
    LPWSTR lpCurrentValue=NULL;
    LPWSTR lpNewValue=NULL;
    DWORD  dwLen;
    DWORD  dwNewLen;
    LONG   lResult;

    dwLen = 0;
    lResult =  RegQueryValueExW(
                        hkeyAdapterGuid,
                        c_szUpperBindings,
                        NULL,
                        NULL,
                        NULL,
                        &dwLen );

    if ( dwLen != 0 ) {
        lpCurrentValue = (LPWSTR)calloc( dwLen, 1 );

        if ( lpCurrentValue ) {

        lResult =  RegQueryValueExW( hkeyAdapterGuid,
                                     c_szUpperBindings,
                                     NULL,
                                     NULL,
                                     (LPBYTE)lpCurrentValue,
                                     &dwLen );

        }
        else {

            lResult = ERROR_NOT_ENOUGH_MEMORY;
        }
    }
    else {
        dwLen = sizeof(WCHAR);
        lpCurrentValue = (LPWSTR)calloc( dwLen, 1 );

        if ( !lpCurrentValue ) {
            lResult = ERROR_NOT_ENOUGH_MEMORY;
        }
        else {
            lResult = ERROR_SUCCESS;
        }
    }

    if ( lResult == ERROR_SUCCESS ) {

        dwNewLen = dwLen + ((wcslen(szMiniportGuid) + 1) * sizeof(WCHAR));

        lpNewValue = (LPWSTR)malloc( dwNewLen );

        if ( lpNewValue ) {

            wcscpy( lpNewValue, szMiniportGuid );

            CopyMemory( lpNewValue+wcslen(szMiniportGuid)+1,
                        lpCurrentValue,
                        dwLen );

            lResult = RegSetValueExW( hkeyAdapterGuid,
                                    c_szUpperBindings,
                                    0,
                                    REG_MULTI_SZ,
                                    (LPBYTE)lpNewValue,
                                    dwNewLen );
        }
        else {
            lResult = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    if ( lpCurrentValue ) {
        free( lpCurrentValue );
    }

    if ( lpNewValue ) {
        free( lpNewValue );
    }

    return lResult;
}

LONG DeleteFromMultiSzValue( HKEY hkeyAdapterGuid,
                             LPWSTR szMiniportGuid)
{
    LPWSTR lpCurrentValue=NULL;
    LPWSTR lpNewValue=NULL;
    LPWSTR lpCurrentValueTemp;
    LPWSTR lpNewValueTemp;
    DWORD  dwLen;
    DWORD  dwNewLen;
    LONG   lResult;

    dwLen = 0;
    lResult =  RegQueryValueExW(
                        hkeyAdapterGuid,
                        c_szUpperBindings,
                        NULL,
                        NULL,
                        NULL,
                        &dwLen );

    if ( lResult == ERROR_SUCCESS ) {
        lpCurrentValue = (LPWSTR)calloc( dwLen, 1 );
        lpNewValue = (LPWSTR)calloc( dwLen, 1 );

        if ( lpCurrentValue && lpNewValue ) {

            lResult =  RegQueryValueExW(
                              hkeyAdapterGuid,
                              c_szUpperBindings,
                              NULL,
                              NULL,
                              (LPBYTE)lpCurrentValue,
                              &dwLen );

            if ( lResult == ERROR_SUCCESS ) {

                lpCurrentValueTemp = lpCurrentValue;
                lpNewValueTemp = lpNewValue;

                while( wcslen(lpCurrentValueTemp) ) {

                    if ( _wcsicmp(lpCurrentValueTemp, szMiniportGuid) ) {
                        wcscpy( lpNewValueTemp, lpCurrentValueTemp );
                        lpNewValueTemp += wcslen(lpNewValueTemp) + 1;
                    }

                    lpCurrentValueTemp += wcslen(lpCurrentValueTemp) + 1;
                } //end of while

                dwNewLen = dwLen - ((wcslen(szMiniportGuid) + 1) * sizeof(WCHAR));

                if ( dwNewLen > 2 ) {
                    lResult = RegSetValueExW( hkeyAdapterGuid,
                                          c_szUpperBindings,
                                          0,
                                          REG_MULTI_SZ,
                                          (LPBYTE)lpNewValue,
                                          dwNewLen );
                }
                else {
                    lResult = RegDeleteValueW( hkeyAdapterGuid,
                                               c_szUpperBindings );
                }
            }
        }
        else {
            lResult = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    if ( lpCurrentValue ) {
        free( lpCurrentValue );
    }

    if ( lpNewValue ) {
        free( lpNewValue );
    }

    return lResult;
}

LPWSTR AddDevicePrefix (LPWSTR lpStr)
{
    LPWSTR lpNewStr;

    lpNewStr = (LPWSTR)malloc( (wcslen(lpStr) +
                              wcslen(c_szDevicePrefix) + 1) *
                                           sizeof(WCHAR) );
    if ( lpNewStr ) {

        wcscpy( lpNewStr, c_szDevicePrefix );
        wcscat( lpNewStr, lpStr );
    }

    return lpNewStr;
}

LPWSTR RemoveDevicePrefix (LPWSTR lpStr)
{
    int i;
    LPWSTR lpNewStr;
    LPWSTR lpTemp;

    lpTemp = wcsrchr( lpStr, '\\' );

    if ( lpTemp ) {

        lpNewStr = _wcsdup( lpTemp+1 );
    }
    else {
        lpNewStr = NULL;
    }

    return lpNewStr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\samples\muxim\list.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992-2001.
//
//  File:       LIST . H
//
//  Contents:   
//
//  Notes: List manipulation functions.
//
//----------------------------------------------------------------------------

#ifndef LIST_H_INCLUDED

#define LIST_H_INCLUDED

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>


template<class X, class Y> class List { 
     struct Node {
        X    item;
        Y    key;
        Node *next;
     };

     Node  *m_head;
     DWORD m_dwNodeCount;

  public:

              List ();

      virtual ~List();

     HRESULT  Insert (X item,
                      Y key);

     HRESULT  Remove (X *item);

     HRESULT  RemoveThis (X item);

     HRESULT  RemoveByKey (Y key,
                           X *item);

     VOID     RemoveAll(VOID);

     HRESULT  Find (DWORD dwIndex,
                    X *item);

     HRESULT  FindByKey (Y key,
                         X *item);

     DWORD    ListCount (VOID);
};

template<class X, class Y> List<X, Y>::List ()
{
  m_head = NULL;
  m_dwNodeCount = 0;
}

template<class X, class Y> List<X, Y>::~List ()
{
  RemoveAll();
}

template<class X, class Y> HRESULT List<X, Y>::Insert (X item,
                                                       Y key)
{
  Node *pNewNode;

  pNewNode = new Node;

  if ( pNewNode ) {
     pNewNode->item = item;
     pNewNode->key = key;
     pNewNode->next = NULL;

     if ( m_dwNodeCount ) {
        pNewNode->next = m_head;
     }

     m_head = pNewNode;
     m_dwNodeCount++;
  }

  return ( pNewNode ) ? S_OK : HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
}

template<class X, class Y> HRESULT List<X, Y>::Remove (X *item)
{
  Node *temp;

  if ( m_dwNodeCount == 0 ) {
     return HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
  }

  *item = m_head->item;
  temp = m_head;
  m_head = m_head->next;
  delete temp;
  m_dwNodeCount--;

  return S_OK;
}
  
template<class X, class Y> HRESULT List<X, Y>::RemoveThis (X item)
{
  Node *temp;
  Node *nodeToFind;

  if ( m_dwNodeCount == 0 ) {
     return HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
  }

  if ( m_head->item == item ) {

     nodeToFind = m_head;
     m_head = m_head->next;
  }
  else {
     for (temp = m_head; temp->next && (temp->next->item != item); ) {
        temp = temp->next;
     }

     if ( temp->next ) {
        nodeToFind = temp->next;
        temp->next = temp->next->next;
     }
     else
        nodeToFind = NULL;
  }

  if ( nodeToFind ) {
     delete nodeToFind;
     m_dwNodeCount--;
     return S_OK;
  }
  else
     return HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
}

template<class X, class Y> HRESULT List<X, Y>::RemoveByKey (Y key,
                                                            X *item)
{
  Node *temp;
  Node *nodeToFind;

  if ( m_dwNodeCount == 0 ) {
     return HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
  }

  if ( m_head->key == key ) {

     nodeToFind = m_head;
     m_head = m_head->next;
  }
  else {
     for (temp = m_head; temp->next && (temp->next->key != key); ) {
        temp = temp->next;
     }

     if ( temp->next ) {
        nodeToFind = temp->next;
        temp->next = temp->next->next;
     }
     else
        nodeToFind = NULL;
  }

  if ( nodeToFind ) {
     *item = nodeToFind->item;

     delete nodeToFind;
     m_dwNodeCount--;

     return S_OK;
  }
  else
     return HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
}

template<class X, class Y> VOID List<X, Y>::RemoveAll (VOID)
{
  Node *temp;

  for (; m_dwNodeCount; --m_dwNodeCount) {
     temp = m_head;
     m_head = m_head->next;
     delete temp;
  }

  return;
}

template<class X, class Y> HRESULT List<X, Y>::Find (DWORD dwIndex,
                                                     X *item)
{
  Node  *temp;
  DWORD i;

  if ( (m_dwNodeCount == 0) || (dwIndex > m_dwNodeCount) ) {

     return HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
  }

  for (i=0, temp = m_head; i < dwIndex; ++i) {
     temp = temp->next;
  }

  *item = temp->item;
  return S_OK;
}

template<class X, class Y> HRESULT List<X, Y>::FindByKey (Y key,
                                                          X *item)
{
  Node *temp;

  for (temp = m_head; temp && (temp->key != key); )
     temp = temp->next;

  if ( temp ) {
     *item = temp->item;
     return S_OK;
  }
  else {
     return HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
  }
}

template<class X, class Y> DWORD List<X, Y>::ListCount (VOID)
{
  return m_dwNodeCount;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\samples\muxim\notify.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992-2001.
//
//  File:       N O T I F Y . C P P
//
//  Contents:   Sample notify object code
//  
//  Notes:
//
//  Author:     Alok Sinha

//----------------------------------------------------------------------------

#include "notify.h"

//----------------------------------------------------------------------------
//
// Function:  CMuxNotify::CMuxNotify
//
// Purpose:   Constructor for CMuxNotify
//
// Arguments: None
//
// Returns:   None
//
// Notes:
//

CMuxNotify::CMuxNotify (VOID) : m_pncc (NULL),
                                m_pnc(NULL),
                                m_eApplyAction(eActUnknown),
                                m_pUnkContext(NULL)
{
    TraceMsg( L"-->CMuxNotify::CMuxNotify(Constructor).\n" );

    TraceMsg( L"<--CMuxNotify::CMuxNotify(Constructor).\n" );
}


// ----------------------------------------------------------------------
//
// Function:  CMuxNotify::~CMuxNotify
//
// Purpose:   Destructor for class CMuxNotify
//
// Arguments: None
//
// Returns:   None
//
// Notes:
//
CMuxNotify::~CMuxNotify (VOID)
{
    CMuxPhysicalAdapter *pAdapter;
    DWORD dwAdapterCount;
    DWORD i;

    TraceMsg( L"-->CMuxNotify::~CMuxNotify(Destructor).\n" );

    // release interfaces if acquired

    ReleaseObj( m_pncc );
    ReleaseObj( m_pnc );
    ReleaseObj( m_pUnkContext );

    dwAdapterCount = m_AdaptersList.ListCount();

    for (i=0; i < dwAdapterCount; ++i) {

        m_AdaptersList.Remove( &pAdapter );

        delete pAdapter;
    }

    dwAdapterCount = m_AdaptersToRemove.ListCount();

    for (i=0; i < dwAdapterCount; ++i) {

        m_AdaptersToRemove.Remove( &pAdapter );

        delete pAdapter;
    }

    dwAdapterCount = m_AdaptersToAdd.ListCount();

    for (i=0; i < dwAdapterCount; ++i) {

        m_AdaptersToAdd.Remove( &pAdapter );

        delete pAdapter;
    }

    TraceMsg( L"<--CMuxNotify::~CMuxNotify(Destructor).\n" );
}

//
//---------------------- NOTIFY OBJECT FUNCTIONS -----------------------------
//

//----------------------------------------------------------------------------
// INetCfgComponentControl                                           
//                                                                       
// The following functions provide the INetCfgComponentControl interface.
//                                                                       
//----------------------------------------------------------------------------

//
// Function:  CMuxNotify::Initialize
//
// Purpose:   Initialize the notify object
//
// Arguments:
//           IN pnccItem   :  Pointer to INetCfgComponent object
//           IN pnc        :  Pointer to INetCfg object
//           IN fInstalling:  TRUE if we are being installed
//
// Returns:
//
// Notes:
//

STDMETHODIMP CMuxNotify::Initialize (INetCfgComponent* pncc,
                                     INetCfg* pnc, 
                                     BOOL fInstalling)
{
    HRESULT hr = S_OK;

    TraceMsg( L"-->CMuxNotify INetCfgControl::Initialize.\n" );


    // Save INetCfg & INetCfgComponent and add a refcount

    m_pncc = pncc;
    m_pnc = pnc;

    if (m_pncc) {

        m_pncc->AddRef();
    }

    if (m_pnc) {

        m_pnc->AddRef();
    }


    //
    // If this not an installation, then we need to 
    // initialize all of our data and classes
    //

    if ( !fInstalling ) {

        hr = HrLoadAdapterConfiguration();
    }

    TraceMsg( L"<--CMuxNotify INetCfgControl::Initialize(HRESULT = %x).\n",
           hr );

    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  CMuxNotify::CancelChanges
//
// Purpose:   Cancel any changes made to internal data
//
// Arguments: None
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//

STDMETHODIMP CMuxNotify::CancelChanges (VOID)
{
    TraceMsg( L"-->CMuxNotify INetCfgControl::CancelChanges.\n" );


    TraceMsg( L"<--CMuxNotify INetCfgControl::CancelChanges(HRESULT = %x).\n",
              S_OK );

    return S_OK;
}

// ----------------------------------------------------------------------
//
// Function:  CMuxNotify::ApplyRegistryChanges
//
// Purpose:   Apply changes.
//
// Arguments: None
//
// Returns:   S_OK.
//
// Notes:     We can make changes to registry etc. here.

STDMETHODIMP CMuxNotify::ApplyRegistryChanges(VOID)
{
    CMuxPhysicalAdapter *pAdapter = NULL;
    GUID                   guidAdapter;
    DWORD                  dwAdapterCount;
    DWORD                  i;

    TraceMsg( L"-->CMuxNotify INetCfgControl::ApplyRegistryChanges.\n" );

    //
    // Make registry changes for the adapters added.
    //

    dwAdapterCount = m_AdaptersToAdd.ListCount();

    TraceMsg( L"   Adding %d new adapters.\n",
              dwAdapterCount );

    for (i=0; i < dwAdapterCount; ++i) {

        m_AdaptersToAdd.Find( i,
                              &pAdapter );
   
        pAdapter->ApplyRegistryChanges( eActAdd );

    }

    //
    // Make registry changes for the adapters uninstalled.
    //

    dwAdapterCount = m_AdaptersToRemove.ListCount();

    TraceMsg( L"   Removing %d adapters.\n",
              dwAdapterCount );

    for (i=0; i < dwAdapterCount; ++i) {

        m_AdaptersToRemove.Find( i,
                                 &pAdapter );
           
        pAdapter->ApplyRegistryChanges( eActRemove );
    }

    //
    // Make registry changes for the miniports added/removed
    // through the property pages.
    //

    dwAdapterCount = m_AdaptersList.ListCount();

    for (i=0; i < dwAdapterCount; ++i) {

        m_AdaptersList.Find( i,
                             &pAdapter );

        pAdapter->ApplyRegistryChanges( eActUpdate );
    }

    TraceMsg( L"<--CMuxNotify INetCfgControl::ApplyRegistryChanges(HRESULT = %x).\n",
              S_OK );

    return S_OK;
}

// ----------------------------------------------------------------------
//
// Function:  CMuxNotify::ApplyPnpChanges
//
// Purpose:   Apply changes.
//
// Arguments:
//            IN pfCallback: PnPConfigCallback interface.
//
// Returns:   S_OK.
//
// Notes:     

STDMETHODIMP CMuxNotify::ApplyPnpChanges (
                                       INetCfgPnpReconfigCallback* pfCallback)
{
    CMuxPhysicalAdapter *pAdapter = NULL;
    GUID                   guidAdapter;
    DWORD                  dwAdapterCount;
    DWORD                  i;

    TraceMsg( L"-->CMuxNotify INetCfgControl::ApplyPnpChanges.\n" );

    //
    // Apply PnP changes for the adapters added.
    //

    dwAdapterCount = m_AdaptersToAdd.ListCount();

    TraceMsg( L"   Applying PnP changes when %d adapters added.\n",
            dwAdapterCount );

    for (i=0; i < dwAdapterCount; ++i) {

        m_AdaptersToAdd.Remove( &pAdapter );

        pAdapter->ApplyPnpChanges( pfCallback,
                                eActAdd );

        pAdapter->GetAdapterGUID( &guidAdapter );

        m_AdaptersList.Insert( pAdapter,
                            guidAdapter );
    }

    //
    // Apply PnP changes for the adapters uninstalled.
    //

    dwAdapterCount = m_AdaptersToRemove.ListCount();

    TraceMsg( L"   Applying PnP changes when %d adapters removed.\n",
            dwAdapterCount );

    for (i=0; i < dwAdapterCount; ++i) {

        m_AdaptersToRemove.Remove( &pAdapter );

        pAdapter->ApplyPnpChanges( pfCallback,
                            eActRemove );

        delete pAdapter;
    }

    //
    // Apply PnP changes for the miniports added/removed through
    // the property pages.
    //

    dwAdapterCount = m_AdaptersList.ListCount();

    for (i=0; i < dwAdapterCount; ++i) {

        m_AdaptersList.Find( i,
                          &pAdapter );

        pAdapter->ApplyPnpChanges( pfCallback,
                                eActUpdate );
    }

    TraceMsg( L"<--CMuxNotify INetCfgControl::ApplyPnpChanges(HRESULT = %x).\n",
            S_OK );

    return S_OK;
}


//----------------------------------------------------------------------------
// INetCfgComponentSetup                                           
//                                                                       
// The following functions provide the INetCfgComponentSetup interface.
//                                                                       
//----------------------------------------------------------------------------

// ----------------------------------------------------------------------
//
// Function:  CMuxNotify::Install
//
// Purpose:   Do operations necessary during the installation.
//
// Arguments:
//            IN dwSetupFlags:  Setup flags
//
// Returns:   S_OK
//
// Notes:     Don't do anything irreversible (like modifying registry) yet
//            since the config. actually completes only when Apply is called!
//

STDMETHODIMP CMuxNotify::Install (DWORD dwSetupFlags)
{

    TraceMsg( L"-->CMuxNotify INetCfgSetup::Install.\n" );

    // Start up the install process

    m_eApplyAction = eActInstall;

    TraceMsg( L"<--CMuxNotify INetCfgSetup::Install(HRESULT = %x).\n",
            S_OK );

    return S_OK;
}

// ----------------------------------------------------------------------
//
// Function:  CMuxNotify::Upgrade
//
// Purpose:   Do operations necessary during the upgrade.
//
// Arguments:
//            IN dwSetupFlags: Setup flags
//
// Returns:   S_OK
//
// Notes:     Don't do anything irreversible (like modifying registry) yet
//            since the config. actually completes only when Apply is called!
//

STDMETHODIMP CMuxNotify::Upgrade (IN DWORD dwSetupFlags,
                                  IN DWORD dwUpgradeFromBuildNo)
{

    TraceMsg( L"-->CMuxNotify INetCfgSetup::Upgrade.\n" );

    TraceMsg( L"   DwSetupFlags = %x, dwUpgradeFromBuildNo = %x\n",
              dwSetupFlags,
              dwUpgradeFromBuildNo );

    TraceMsg( L"<--CMuxNotify INetCfgSetup::Upgrade(HRESULT = %x).\n",
              S_OK );

    return S_OK;
}


// ----------------------------------------------------------------------
//
// Function:  CMuxNotify::ReadAnswerFile
//
// Purpose:   Read settings from answerfile and configure CMuxNotify
//
// Arguments:
//            IN pszAnswerFile   : Name of AnswerFile
//            IN pszAnswerSection: Name of parameters section
//
// Returns:
//
// Notes:     Don't do anything irreversible (like modifying registry) yet
//            since the config. actually completes only when Apply is called!
//

STDMETHODIMP CMuxNotify::ReadAnswerFile (PCWSTR pszAnswerFile,
                                         PCWSTR pszAnswerSection)
{
    PCWSTR pszParamReadFromAnswerFile = L"ParamFromAnswerFile";

    TraceMsg( L"-->CMuxNotify INetCfgSetup::ReadAnswerFile.\n" );

    // We will pretend here that szParamReadFromAnswerFile was actually
    // read from the AnswerFile using the following steps
    //
    //   - Open file pszAnswerFile using SetupAPI
    //   - locate section pszAnswerSection
    //   - locate the required key and get its value
    //   - store its value in pszParamReadFromAnswerFile
    //   - close HINF for pszAnswerFile

    // Now that we have read pszParamReadFromAnswerFile from the
    // AnswerFile, store it in our memory structure.
    // Remember we should not be writing it to the registry till
    // our Apply is called!!
    //

    TraceMsg( L"<--CMuxNotify INetCfgSetup::ReadAnswerFile(HRESULT = %x).\n",
              S_OK );

    return S_OK;
}


// ----------------------------------------------------------------------
//
// Function:  CMuxNotify::Removing
//
// Purpose:   Do necessary cleanup when being removed
//
// Arguments: None
//
// Returns:   S_OK
//
// Notes:     Don't do anything irreversible (like modifying registry) yet
//            since the removal is actually complete only when Apply is called!
//

STDMETHODIMP CMuxNotify::Removing (VOID)
{

    TraceMsg( L"-->CMuxNotify INetCfgSetup::Removing.\n" );

    TraceMsg( L"<--CMuxNotify INetCfgSetup::Removing(HRESULT = %x).\n",
            S_OK );

    return S_OK;
}



//----------------------------------------------------------------------------
// INetCfgComponentNotifyBinding                                          
//                                                                       
// The following functions provide the INetCfgComponentNotifyBinding interface.
//                                                                       
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//
// Function:  CMuxNotify::QueryBindingPath
//
// Purpose:  This is specific to the component being installed. This will 
//           ask us if we want to bind to the Item being passed into
//           this routine. We can disable the binding by returning
//           NETCFG_S_DISABLE_QUERY 
//
//
// Arguments:
//           IN dwChangeFlag: Type of binding change
//           IN pncbpItem   : Pointer to INetCfgBindingPath object
//
// Returns:   S_OK on success, otherwise an error code.
//
// Notes:
//
STDMETHODIMP CMuxNotify::QueryBindingPath (IN DWORD dwChangeFlag,  
                                           IN INetCfgBindingPath *pncbp)
{
    TraceMsg( L"-->CMuxNotify INetCfgNotifyBinding::QueryBindingPath.\n" );

    DumpChangeFlag( dwChangeFlag );
    DumpBindingPath( pncbp );

    TraceMsg( L"<--CMuxNotify INetCfgNotifyBinding::QueryBindingPath(HRESULT = %x).\n",
            S_OK );

    return S_OK;
}

// ----------------------------------------------------------------------
//
// Function:  CMuxNotify::NotifyBindingPath
//
// Purpose:  We are now being told to bind to the component passed to us. 
//
//
// Arguments:
//           IN dwChangeFlag: Type of system change
//           IN pncc        : Pointer to INetCfgComponent object
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//



STDMETHODIMP CMuxNotify::NotifyBindingPath (IN DWORD dwChangeFlag,  
                                            IN INetCfgBindingPath *pncbp)
{
    INetCfgComponent     *pnccLower;
    INetCfgComponent     *pnccUpper;
    LPWSTR               pszwInfIdLower;
    LPWSTR               pszwInfIdUpper;
    DWORD                dwCharcteristics;
    HRESULT              hr = S_OK;

    TraceMsg( L"-->CMuxNotify INetCfgNotifyBinding::NotifyBindingPath.\n" );

    DumpChangeFlag( dwChangeFlag );
    DumpBindingPath( pncbp );

     //
     // We are only interested to know 1) when a component is installed
     // and we are binding to it i.e. dwChangeFlag = NCN_ADD | NCN_ENABLE
     // and 2) when a component is removed to which we are bound i.e.
     // dwChangeFlag = NCN_REMOVE | NCN_ENABLE. dwChangeFlag is never
     // set to NCN_ADD or NCN_REMOVE only. So, checking for NCN_ENABLE
     // covers the case of NCN_ADD | NCN_ENABLE and checking for NCN_REMOVE
     // covers the case of NCN_REMOVE | NCN_ENABLE. We don't care about
     // NCN_ADD | NCN_DISABLE (case 1) and NCN_REMOVE | NCN_DISABLE (case 2).
     //

     if ( dwChangeFlag & (NCN_ENABLE | NCN_REMOVE) ) {

        //
        // Get the upper and lower components.
        //

        hr = HrGetUpperAndLower( pncbp,
                                 &pnccUpper,
                                 &pnccLower );

        if ( hr == S_OK ) {

            hr = pnccLower->GetCharacteristics( &dwCharcteristics );

            if ( hr == S_OK ) {

                hr = pnccLower->GetId( &pszwInfIdLower );

                if ( hr == S_OK ) {

                    hr = pnccUpper->GetId( &pszwInfIdUpper );

                    if ( hr == S_OK ) {

                        //
                        // We are interested only in binding to a
                        // physical ethernet adapters.
                        // 

                        if ( dwCharcteristics & NCF_PHYSICAL ) {

                            if ( !_wcsicmp( pszwInfIdUpper, c_szMuxProtocol ) ) {

                                if ( dwChangeFlag & NCN_ADD ) {

                                    hr = HrAddAdapter( pnccLower );
                                    m_eApplyAction = eActAdd;

                                } else if ( dwChangeFlag & NCN_REMOVE ) {

                                    hr = HrRemoveAdapter( pnccLower );
                                    m_eApplyAction = eActRemove;
                                }
                            }
                        } // Physical Adapters. 
                        else if (dwCharcteristics & NCF_VIRTUAL) {

                        }

                        CoTaskMemFree( pszwInfIdUpper );

                    } // Got the upper component id.

                    CoTaskMemFree( pszwInfIdLower );

                } // Got the lower component id.

            } // Got NIC's characteristics

            ReleaseObj(pnccLower);
            ReleaseObj(pnccUpper);

        } // Got the upper and lower components.

    } 

    TraceMsg( L"<--CMuxNotify INetCfgNotifyBinding::NotifyBindingPath(HRESULT = %x).\n",
            S_OK );

    return S_OK;
}




//----------------------------------------------------------------------------
// INetCfgComponentNotifyGlobal
//                                                                       
// The following functions provide the INetCfgComponentNotifyGlobal interface.
//                                                                       
//----------------------------------------------------------------------------

// ----------------------------------------------------------------------
//
// Function:  CMuxNotify::GetSupportedNotifications
//
// Purpose:   Tell the system which notifications we are interested in
//
// Arguments:
//            OUT pdwNotificationFlag: Pointer to NotificationFlag
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
STDMETHODIMP CMuxNotify::GetSupportedNotifications (
                                             OUT DWORD* pdwNotificationFlag)
{
    TraceMsg( L"-->CMuxNotify INetCfgNotifyGlobal::GetSupportedNotifications.\n" );

    *pdwNotificationFlag = NCN_NET | NCN_NETTRANS | NCN_ADD | NCN_REMOVE |
                           NCN_BINDING_PATH | NCN_ENABLE | NCN_DISABLE;

    TraceMsg( L"<--CMuxNotify INetCfgNotifyGlobal::GetSupportedNotifications(HRESULT = %x).\n",
            S_OK );

    return S_OK;
}

// ----------------------------------------------------------------------
//
// Function:  CMuxNotify::SysQueryBindingPath
//
// Purpose:   Enable or Disable a binding path.
//
// Arguments:
//            IN dwChangeFlag: Type of binding change
//            IN pncbp       : Pointer to INetCfgBindingPath object
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//

STDMETHODIMP CMuxNotify::SysQueryBindingPath (DWORD dwChangeFlag,
                                              INetCfgBindingPath* pncbp)
{
    INetCfgComponent     *pnccLower;
    INetCfgComponent     *pnccUpper;
    LPWSTR               pszwInfIdLower;
    LPWSTR               pszwInfIdUpper;
    DWORD                dwCharcteristics;
    HRESULT              hr = S_OK;


    TraceMsg( L"-->CMuxNotify INetCfgNotifyGlobal::SysQueryBindingPath.\n" );

    DumpChangeFlag( dwChangeFlag );
    DumpBindingPath( pncbp );

    if ( dwChangeFlag & NCN_ENABLE ) {

        //
        // Get the upper and lower components.
        //

        hr = HrGetUpperAndLower( pncbp,
                                 &pnccUpper,
                                 &pnccLower );

        if ( hr == S_OK ) {
            hr = pnccLower->GetCharacteristics( &dwCharcteristics );

            if ( hr == S_OK ) {

                hr = pnccLower->GetId( &pszwInfIdLower );

                if ( hr == S_OK ) {

                    hr = pnccUpper->GetId( &pszwInfIdUpper );

                    if ( hr == S_OK ) {

                        //
                        // We are interested only in bindings to physical 
                        // ethernet adapters.
                        // 

                        if ( dwCharcteristics & NCF_PHYSICAL ) {

#ifdef DISABLE_PROTOCOLS_TO_PHYSICAL

                            //
                            // If it not our protocol binding to the
                            // physical adapter then, disable the
                            // binding.
                            //

                            if (_wcsicmp( pszwInfIdUpper, c_szMuxProtocol ) ) {

                                TraceMsg( L"   Disabling the binding between %s "
                                          L"and %s.\n",
                                          pszwInfIdUpper,
                                          pszwInfIdLower );

                                hr = NETCFG_S_DISABLE_QUERY;
                            }
#endif

                        } // Physical Adapters. 
                        else {
                            if (dwCharcteristics & NCF_VIRTUAL) {

                                // If the lower component is our miniport
                                // and the upper component is our protocol
                                // then also, disable the binding.

                                if ( !_wcsicmp(pszwInfIdLower, c_szMuxMiniport) &&
                                     !_wcsicmp(pszwInfIdUpper, c_szMuxProtocol) ) {
                                  
                                    TraceMsg( L"   Disabling the binding between %s "
                                              L"and %s.\n",
                                              pszwInfIdUpper,
                                              pszwInfIdLower );

                                    hr = NETCFG_S_DISABLE_QUERY;
                                }

                            } // Virtual Adapters

                        }

                        CoTaskMemFree( pszwInfIdUpper );

                    } // Got the upper component id.

                    CoTaskMemFree( pszwInfIdLower );

                } // Got the lower component id.

            } // Got NIC's characteristics

            ReleaseObj(pnccLower);
            ReleaseObj(pnccUpper);

        }

    }

    TraceMsg( L"<--CMuxNotify INetCfgNotifyGlobal::SysQueryBindingPath(HRESULT = %x).\n",
            hr );

    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  CMuxNotify::SysNotifyBindingPath
//
// Purpose:   System tells us by calling this function which
//            binding path has just been formed.
//
// Arguments:
//            IN dwChangeFlag: Type of binding change
//            IN pncbpItem   : Pointer to INetCfgBindingPath object
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
STDMETHODIMP CMuxNotify::SysNotifyBindingPath (DWORD dwChangeFlag,
                                               INetCfgBindingPath* pncbp)
{
    TraceMsg( L"-->CMuxNotify INetCfgNotifyGlobal::SysNotifyBindingPath.\n" );

    DumpChangeFlag( dwChangeFlag );
    DumpBindingPath( pncbp );

    TraceMsg( L"<--CMuxNotify INetCfgNotifyGlobal::SysNotifyBindingPath(HRESULT = %x).\n",
            S_OK );

    return S_OK;
}

// ----------------------------------------------------------------------
//
// Function:  CMuxNotify::SysNotifyComponent
//
// Purpose:   System tells us by calling this function which
//            component has undergone a change (installed/removed)
//
// Arguments:
//            IN dwChangeFlag: Type of system change
//            IN pncc        : Pointer to INetCfgComponent object
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
STDMETHODIMP CMuxNotify::SysNotifyComponent (DWORD dwChangeFlag,
                                                INetCfgComponent* pncc)
{
    TraceMsg( L"-->CMuxNotify INetCfgNotifyGlobal::SysNotifyComponent.\n" );

    DumpChangeFlag( dwChangeFlag );
    DumpComponent( pncc );

    TraceMsg( L"<--CMuxNotify INetCfgNotifyGlobal::SysNotifyComponent(HRESULT = %x).\n",
            S_OK );

    return S_OK;
}


//----------------------------------------------------------------------------
// INetCfgComponentPropertyUi                                          
//                                                                       
// The following functions provide the INetCfgComponentPropertyUi interface.
//                                                                       
//----------------------------------------------------------------------------

// ----------------------------------------------------------------------
//
// Function:  CMuxNotify::MergePropPages
//
// Purpose:   Supply our property page to system.
//
// Arguments:
//            OUT pdwDefPages  : Pointer to num default pages
//            OUT pahpspPrivate: Pointer to array of pages
//            OUT pcPages      : Pointer to num pages
//            IN  hwndParent   : Handle of parent window
//            IN  szStartPage  : Pointer to
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
STDMETHODIMP CMuxNotify::MergePropPages (IN OUT DWORD* pdwDefPages,
                                         OUT LPBYTE* pahpspPrivate,
                                         OUT UINT* pcPages,
                                         IN HWND hwndParent,
                                         OUT PCWSTR* szStartPage)
{
    HRESULT                 hr = S_OK;
    HPROPSHEETPAGE          *ahpsp;;
    INetLanConnectionUiInfo *pLanConnUiInfo;

    TraceMsg(L"-->CMuxNotify INetCfgPropertyUi::MergePropPages\n");

    //
    // We don't want any default pages to be shown
    //

    *pdwDefPages = 0;
    *pcPages = 0;
    *pahpspPrivate = NULL;

    if ( !m_pUnkContext ) {
        return E_UNEXPECTED;
    }

    hr = m_pUnkContext->QueryInterface(
          IID_INetLanConnectionUiInfo,
          reinterpret_cast<PVOID *>(&pLanConnUiInfo));

    if ( hr == S_OK ) {

        ReleaseObj( pLanConnUiInfo );

        ahpsp = (HPROPSHEETPAGE*)CoTaskMemAlloc( sizeof(HPROPSHEETPAGE) );

        if (ahpsp) {

            PROPSHEETPAGE   psp = {0};

            psp.dwSize            = sizeof(PROPSHEETPAGE);
            psp.dwFlags           = PSP_DEFAULT;
            psp.hInstance         = _Module.GetModuleInstance();
            psp.pszTemplate       = MAKEINTRESOURCE(IDD_NOTIFY_GENERAL);
            psp.pfnDlgProc        = NotifyDialogProc;
            psp.pfnCallback       = NULL; (LPFNPSPCALLBACK)NotifyPropSheetPageProc;
            psp.lParam            = (LPARAM) this;
            psp.pszHeaderTitle    = NULL;
            psp.pszHeaderSubTitle = NULL;

            ahpsp[0] = ::CreatePropertySheetPage(&psp);
            *pcPages = 1;
            *pahpspPrivate = (LPBYTE)ahpsp;
        }
        else {
            hr = E_OUTOFMEMORY;
        }
    }
    TraceMsg(L"<--CMuxNotify INetCfgPropertyUi::MergePropPages(HRESULT = %x).\n",
           hr );

    return hr;
}


// ----------------------------------------------------------------------
//
// Function:  CMuxNotify::ValidateProperties
//
// Purpose:   Validate changes to property page.
//
// Arguments:
//            IN hwndSheet: Window handle of property sheet
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//

STDMETHODIMP CMuxNotify::ValidateProperties (HWND hwndSheet)
{

    TraceMsg( L"-->CMuxNotify INetCfgPropertyUi::ValidateProperties\n" );

    TraceMsg(L"<--CMuxNotify INetCfgPropertyUi::ValidateProperties(HRESULT = %x).\n",
           S_OK );
    return S_OK;
}

// ----------------------------------------------------------------------
//
// Function:  CMuxNotify::CancelProperties
//
// Purpose:   Cancel changes to property page
//
// Arguments: None
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
STDMETHODIMP CMuxNotify::CancelProperties (VOID)
{
    TraceMsg(L"-->CMuxNotify INetCfgPropertyUi::CancelProperties\n");

    TraceMsg(L"<--CMuxNotify INetCfgPropertyUi::CancelProperties(HRESULT = %x).\n",
           S_OK );

    return S_OK;
}

// ----------------------------------------------------------------------
//
// Function:  CMuxNotify::ApplyProperties
//
// Purpose:   Apply value of controls on property page
//            to internal memory structure
//
// Arguments: None
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:     
//
STDMETHODIMP CMuxNotify::ApplyProperties (VOID)
{
    INetLanConnectionUiInfo *pLanConnUiInfo;
    CMuxPhysicalAdapter     *pAdapter;
    GUID                    guidAdapter;
    INetCfgComponent        *pncc;
    HRESULT                 hr = S_OK;

    TraceMsg(L"-->CMuxNotify INetCfgPropertyUi::ApplyProperties\n");

    if ( m_pUnkContext ) {

        hr = m_pUnkContext->QueryInterface(
                                  IID_INetLanConnectionUiInfo,
                                  reinterpret_cast<PVOID *>(&pLanConnUiInfo));

        if ( hr == S_OK ) {

            hr = pLanConnUiInfo->GetDeviceGuid( &guidAdapter );

            if ( hr == S_OK ) {

                hr = m_AdaptersList.FindByKey( guidAdapter,
                                               &pAdapter );
                if ( hr == S_OK ) {

                    switch( m_eApplyAction ) {

                        case eActPropertyUIAdd:

                              hr = HrAddMiniport( pAdapter,
                                                  &guidAdapter );
                        break;

                        case eActPropertyUIRemove:

                              hr = HrRemoveMiniport( pAdapter,
                                                     &guidAdapter );
                        break;
                    }
                }
            }

            ReleaseObj( pLanConnUiInfo );
        }
    }

    TraceMsg(L"<--CMuxNotify INetCfgPropertyUi::ApplyProperties(HRESULT = %x).\n",
           hr );
    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  CMuxNotify::QueryPropertyUi
//
// Purpose:   System is asking if we support property pages.
//
// Arguments:
//            IN pUnk: Pointer to IUnknown.
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:     We display property pages only in the context of
//            a LAN connection.
//

STDMETHODIMP CMuxNotify::QueryPropertyUi (IUnknown * pUnk)
{
    INetLanConnectionUiInfo *pLanConnUiInfo;
    HRESULT                 hr=S_FALSE;

    TraceMsg(L"-->CMuxNotify INetCfgPropertyUi::QueryPropertyUi\n");

#ifndef PASSTHRU_NOTIFY

    if ( pUnk ) {

        hr = pUnk->QueryInterface(
                              IID_INetLanConnectionUiInfo,
                              reinterpret_cast<PVOID *>(&pLanConnUiInfo));

        ReleaseObj( pLanConnUiInfo );
    } 
#endif

    TraceMsg(L"<--CMuxNotify INetCfgPropertyUi::QueryPropertyUi(HRESULT = %x).\n",
           hr );

    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  CMuxNotify::SetContext
//
// Purpose:   Save the LAN connection context.
//
// Arguments: 
//            IN pUnk: Pointer to IUnknown.
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:     It is also called to release the current LAN connection context.
//

STDMETHODIMP CMuxNotify::SetContext (IUnknown * pUnk)
{
    TraceMsg(L"-->CMuxNotify INetCfgPropertyUi::SetContext\n");

    //
    // Release previous context, if any
    //

    ReleaseObj( m_pUnkContext );

    m_pUnkContext = NULL;

    if ( pUnk ) {

        m_pUnkContext = pUnk;
        m_pUnkContext->AddRef();
    }

    TraceMsg(L"<--CMuxNotify INetCfgPropertyUi::SetContext(HRESULT = %x).\n",
           S_OK );

    return S_OK;
}

//----------------------------------------------------------------------------
//
//  Function:   CMuxNotify::HrLoadAdapterConfiguration
//
//  Purpose:    This loads the Miniport and adapters that have already been 
//              installed into our own data structures
//
//  Arguments:  None.
//
//  Returns:    S_OK, or an error.
//
//
//  Notes:
//


HRESULT CMuxNotify::HrLoadAdapterConfiguration (VOID)
{
    HKEY                 hkeyAdapterList;
    WCHAR                szAdapterGuid[MAX_PATH+1];
    DWORD                dwDisp;
    CMuxPhysicalAdapter  *pAdapter;
    GUID                 guidAdapter;
    DWORD                dwIndex;
    LONG                 lResult;

    TraceMsg( L"-->CMuxNotify::HrLoadAdapterConfiguration.\n" );

    lResult = RegCreateKeyExW( HKEY_LOCAL_MACHINE,
                               c_szAdapterList,
                               0,
                               NULL,
                               REG_OPTION_NON_VOLATILE,
                               KEY_ALL_ACCESS,
                               NULL,
                               &hkeyAdapterList,
                               &dwDisp);


    if ( lResult == ERROR_SUCCESS ) {

        //
        // If dwDisp indicates that a new key is created then, we know there
        // is no adapter currently listed underneath and we simply
        // return, otherwise, we enumerate the subkeys, each one representing an 
        // adapter.
        //

        if ( dwDisp != REG_CREATED_NEW_KEY ) {

            lResult = RegEnumKeyW( hkeyAdapterList,
                                   0,
                                   szAdapterGuid,
                                   MAX_PATH+1 );

            for (dwIndex=1; lResult == ERROR_SUCCESS; ++dwIndex) {

                TraceMsg( L"   Loading configuration for adapter %s...\n",
                         szAdapterGuid );

                //
                // Subkeys are actually a guid/bindname of the adapters.
                //

                CLSIDFromString( szAdapterGuid,
                                 &guidAdapter );

                //
                // Create an instance representing the adapter.
                //

                pAdapter = new CMuxPhysicalAdapter( m_pnc,
                                                    &guidAdapter );

                if ( pAdapter ) {

                  //
                  // Load any adapter specific configuration.
                  //

                  pAdapter->LoadConfiguration();

                  //
                  // Save the adapter instance in a list.
                  //

                  m_AdaptersList.Insert( pAdapter,
                                         guidAdapter );

                  //
                  // Get next subkey.
                  //

                  lResult = RegEnumKeyW( hkeyAdapterList,
                                         dwIndex,
                                         szAdapterGuid,
                                         MAX_PATH+1 );
                }
                else {

                 lResult = ERROR_NOT_ENOUGH_MEMORY;
                }
            }

            //
            // RegEnumKeyW may have returned error when there are no more
            // subkeys to read.
            //

            lResult = ERROR_SUCCESS;
        }

        RegCloseKey( hkeyAdapterList );
    }

    TraceMsg( L"<--CMuxNotify::HrLoadAdapterConfiguration(HRESULT = %x).\n",
              HRESULT_FROM_WIN32(lResult) );

    return HRESULT_FROM_WIN32(lResult);
}

//----------------------------------------------------------------------------
//
//  Function:   CMuxNotify::HrGetUpperAndLower
//
//  Purpose:    Get the upper and lower component of the first interface
//              of a binding path.
//
//  Arguments:  
//              IN  pncbp     : Binding path.
//              OUT ppnccUpper: Upper component.
//              OUT ppnccLower: Lower component.
//
//  Returns:    S_OK, or an error.
//
//
//  Notes:
//

HRESULT CMuxNotify::HrGetUpperAndLower (INetCfgBindingPath* pncbp,
                                        INetCfgComponent **ppnccUpper,
                                        INetCfgComponent **ppnccLower)
{
    IEnumNetCfgBindingInterface*    pencbi;
    INetCfgBindingInterface*        pncbi;
    ULONG                           ulCount;
    HRESULT                         hr;

    TraceMsg( L"-->CMuxNotify::HrGetUpperAndLowerComponent.\n" );

    *ppnccUpper = NULL;
    *ppnccLower = NULL;

    hr = pncbp->EnumBindingInterfaces(&pencbi);

    if (S_OK == hr) {
     
        //
        // get the first binding interface
        //

        hr = pencbi->Next(1, &pncbi, &ulCount);

        if ( hr == S_OK ) {

            hr = pncbi->GetUpperComponent( ppnccUpper );

            if ( hr == S_OK ) {

                hr = pncbi->GetLowerComponent ( ppnccLower );
            }
            else {
                ReleaseObj( *ppnccUpper );
            }

            ReleaseObj( pncbi );
        }

        ReleaseObj( pencbi );
    }

    TraceMsg( L"<--CMuxNotify::HrGetUpperAndLowerComponent(HRESULT = %x).\n",
            hr );

    return hr;
}

//----------------------------------------------------------------------------
//
//  Function:   CMuxNotify::HrAddAdapter
//
//  Purpose:    Create an instance representing the physical adapter and install
//              a virtual miniport.
//
//  Arguments:  
//              IN pnccAdapter: Pointer to the physical adapter.
//
//  Returns:    S_OK, or an error.
//
//
//  Notes:
//

HRESULT CMuxNotify::HrAddAdapter (INetCfgComponent *pnccAdapter)
{
    GUID                     guidAdapter;
    CMuxPhysicalAdapter      *pAdapter;
    HRESULT                  hr;

    TraceMsg( L"-->CMuxNotify::HrAddAdapter.\n" );

    hr = pnccAdapter->GetInstanceGuid( &guidAdapter );

    if ( hr == S_OK ) {

        pAdapter = new CMuxPhysicalAdapter( m_pnc,
                                            &guidAdapter );

        if ( pAdapter ) {

            hr = HrAddMiniport( pAdapter,
                                &guidAdapter );

            if ( hr == S_OK ) {

               m_AdaptersToAdd.Insert( pAdapter,
                                       guidAdapter );
            }
            else {

               delete pAdapter;
            }
        }
        else {
            hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        }
    } 

    TraceMsg( L"<--CMuxNotify::HrAddAdapter(HRESULT = %x).\n",
            hr );

    return hr;
}

//----------------------------------------------------------------------------
//
//  Function:   CMuxNotify::HrRemoveAdapter
//
//  Purpose:    Deletes the instance representing the physical adapter
//              and uninstalls all the virtual miniports.
//
//  Arguments:  
//              IN pnccAdapter: Pointer to the physical adapter.
//
//  Returns:    S_OK, or an error.
//
//
//  Notes:      This function is called when the adapter or the protocol
//              is being uninstalled.
//

HRESULT CMuxNotify::HrRemoveAdapter (INetCfgComponent *pnccAdapter)
{
    GUID                  guidAdapter;
    CMuxPhysicalAdapter   *pAdapter;
    HRESULT               hr;

    TraceMsg( L"-->CMuxNotify::HrRemoveAdapter.\n" );

    hr = pnccAdapter->GetInstanceGuid( &guidAdapter );

    if ( hr == S_OK ) {

        hr = m_AdaptersList.RemoveByKey( guidAdapter,
                                      &pAdapter );

         if ( hr == S_OK ) {

            m_AdaptersToRemove.Insert( pAdapter,  
                                       guidAdapter );
            hr = pAdapter->Remove();

#ifdef DISABLE_PROTOCOLS_TO_PHYSICAL

            //
            // Restore the bindings of other protocols to the physical
            // adapter.
            //
 
            EnableBindings( pnccAdapter,
                            TRUE );
#endif
         }
    }

    TraceMsg( L"<--CMuxNotify::HrRemoveAdapter(HRESULT = %x).\n",
            hr );

    return hr;
}

//----------------------------------------------------------------------------
//
//  Function:   CMuxNotify::HrAddMiniport
//
//  Purpose:    Installs a virtual miniport.
//
//  Arguments:  
//              IN pAdapter    : Pointer to the physical adapter class instance.
//              IN pguidAdapter: Pointer to the GUID of the adapter.
//
//  Returns:    S_OK, or an error.
//
//
//  Notes:      
//

HRESULT CMuxNotify::HrAddMiniport (CMuxPhysicalAdapter *pAdapter,
                                   GUID *pguidAdapter)
{
    CMuxVirtualMiniport   *pMiniport;
    INetCfgComponent      *pnccAdapter;
    HRESULT               hr;

    TraceMsg( L"-->CMuxNotify::HrAddMiniport.\n" );

    pMiniport = new CMuxVirtualMiniport( m_pnc,
                                         NULL,
                                         pguidAdapter );
    if ( pMiniport ) {

        hr = pMiniport->Install();

        if ( hr == S_OK ) {

            hr = pAdapter->AddMiniport( pMiniport );

            if ( hr != S_OK ) {

                pMiniport->DeInstall();

                delete pMiniport;
            }
        }
    }
    else {

        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
    }

#ifdef DISABLE_PROTOCOLS_TO_PHYSICAL

    if ( hr == S_OK ) {

        //
        // If this is the first virtual miniport then, disable the bindings
        // of other protocols to the physical adapter.
        //

        if ( pAdapter->MiniportCount() == 0 ) {

            hr = HrFindInstance( m_pnc,
                                 *pguidAdapter,
                                 &pnccAdapter );

            if ( hr == S_OK ) {
                EnableBindings( pnccAdapter,
                                FALSE );

                ReleaseObj( pnccAdapter );
            }
        }
    }
#endif

    TraceMsg( L"<--CMuxNotify::HrAddMiniport(HRESULT = %x).\n",
            hr );
    return hr;
}

//----------------------------------------------------------------------------
//
//  Function:   CMuxNotify::HrRemoveMiniport
//
//  Purpose:    Uninstalls a virtual miniport.
//
//  Arguments:  
//              IN pAdapter    : Pointer to the physical adapter class instance.
//              IN pguidAdapter: Pointer to the GUID of the adapter.
//
//  Returns:    S_OK, or an error.
//
//
//  Notes:      
//

HRESULT CMuxNotify::HrRemoveMiniport (CMuxPhysicalAdapter *pAdapter,
                                      GUID *pguidAdapter)
{
    INetCfgComponent      *pnccAdapter;
    HRESULT                hr;

    TraceMsg( L"-->CMuxNotify::HrRemoveMiniport.\n" );

    hr = pAdapter->RemoveMiniport( NULL );

#ifdef DISABLE_PROTOCOLS_TO_PHYSICAL

    if ( hr == S_OK ) {

        //
        // If this was the last miniport that was removed then, restore the
        // bindings of other protocols to the physical adapter.
        //

        if ( pAdapter->AllMiniportsRemoved() ) {

            hr = HrFindInstance( m_pnc,
                                 *pguidAdapter,
                                 &pnccAdapter );

            if ( hr == S_OK ) {
                EnableBindings( pnccAdapter,
                                TRUE );

                ReleaseObj( pnccAdapter );
            }
        }
    }
#endif

    TraceMsg( L"<--CMuxNotify::HrRemoveMiniport(HRESULT = %x).\n",
            hr );

    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  CMuxNotify::OnInitDialog
//
// Purpose:   Initialize controls
//
// Arguments:
//            IN hWnd: Window handle to the property page.
//
// Returns: TRUE.
//
// Notes:
//

LRESULT CMuxNotify::OnInitDialog (IN HWND hWndPage)
{
    m_eApplyAction = eActUnknown;

    ::SendMessage(GetDlgItem(hWndPage, IDC_ADD), BM_SETCHECK, BST_CHECKED, 0);
    ::SendMessage(GetDlgItem(hWndPage, IDC_REMOVE), BM_SETCHECK, BST_UNCHECKED, 0);

    return TRUE;
}

// ----------------------------------------------------------------------
//
// Function:  CMuxNotify::OnOk
//
// Purpose:   Do actions when OK is pressed
//
// Arguments:
//            IN hWnd: Window handle to the property page.
//
// Returns:   PSNRET_NOERROR
//
// Notes:
//

LRESULT CMuxNotify::OnOk (IN HWND hWndPage)
{
    TraceMsg(L"-->CMuxNotify::OnOk\n");

    if ( ::SendMessage(GetDlgItem(hWndPage, IDC_ADD),
                       BM_GETCHECK, 0, 0) == BST_CHECKED ) {
     
        m_eApplyAction = eActPropertyUIAdd;
    }
    else {
        m_eApplyAction = eActPropertyUIRemove;
    }

    //
    // Set the property sheet changed flag if any of our controls
    // get changed.  This is important so that we get called to
    // apply our property changes.
    //

    PropSheet_Changed( GetParent(hWndPage), hWndPage);

    TraceMsg(L"<--CMuxNotify::OnOk(Action = %s).\n",
           (m_eApplyAction == eActPropertyUIAdd) ? L"Add" : L"Remove" );

    return PSNRET_NOERROR;
}

// ----------------------------------------------------------------------
//
// Function:  CMuxNotify::OnCancel
//
// Purpose:   Do actions when CANCEL is pressed
//
// Arguments:
//            IN hWnd: Window handle to the property page.
//
// Returns:   FALSE
//
// Notes:
//
LRESULT CMuxNotify::OnCancel (IN HWND hWndPage)
{
    TraceMsg(L"-->CMuxNotify::OnCancel\n");

    m_eApplyAction = eActUnknown;

    TraceMsg(L"<--CMuxNotify::OnCancel\n");

    return FALSE;
}

// ----------------------------------------------------------------------
//
// Function:  CMuxNotifyDialogProc
//
// Purpose:   Dialog proc
//
// Arguments:
//            IN hWnd  : See win32 documentation.
//            IN uMsg  : See win32 documentation.
//            IN wParam: See win32 documentation.
//            IN lParam: See win32 documentation.
//
// Returns:   See win32 documentation.
//
// Notes:
//
INT_PTR CALLBACK NotifyDialogProc (HWND hWnd,
                                   UINT uMsg,
                                   WPARAM wParam,
                                   LPARAM lParam)
{
    CMuxNotify     *psf;
    LRESULT        lRes=FALSE;

    if ( uMsg != WM_INITDIALOG ) {

        psf = (CMuxNotify *)::GetWindowLongPtr( hWnd,
                                                DWLP_USER );

        // Until we get WM_INITDIALOG, just return FALSE

        if ( !psf ) {

            return lRes;
        }
    }

    switch( uMsg ) {

        case WM_INITDIALOG:
        {
            PROPSHEETPAGE* ppsp;
            ppsp = (PROPSHEETPAGE *)lParam;

            psf = (CMuxNotify *)ppsp->lParam;

            SetWindowLongPtr( hWnd,
                          DWLP_USER,
                          (LONG_PTR)psf);

            lRes = psf->OnInitDialog( hWnd );
        }
        break;

        case WM_COMMAND:

        break;

        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;

            switch (pnmh->code) {
        
            case PSN_KILLACTIVE:

                //
                // ok to loose focus.
                //

                SetWindowLongPtr( hWnd, DWLP_MSGRESULT, FALSE);

                lRes = TRUE;
                break;

            case PSN_APPLY:

                psf = (CMuxNotify *)::GetWindowLongPtr( hWnd, DWLP_USER);
                lRes = psf->OnOk( hWnd );

                SetWindowLongPtr( hWnd, DWLP_MSGRESULT, lRes);
                lRes = TRUE;
                break;

            case PSN_RESET:

                psf = (CMuxNotify *)::GetWindowLongPtr( hWnd, DWLP_USER);
                psf->OnCancel( hWnd );
        }
     }
  }

  return lRes;
}

// ----------------------------------------------------------------------
//
// Function:  CMuxNotifyPropSheetPageProc
//
// Purpose:   Prop sheet proc
//
// Arguments:
//            IN hWnd: See win32 documentation
//            IN uMsg: See win32 documentation
//            IN ppsp: See win32 documentation
//
// Returns:   See win32 documentation
//
// Notes:
//

UINT CALLBACK NotifyPropSheetPageProc(HWND hWnd,
                                      UINT uMsg,
                                      LPPROPSHEETPAGE ppsp)
{
    return TRUE;
}


#ifdef DISABLE_PROTOCOLS_TO_PHYSICAL

// ----------------------------------------------------------------------
//
// Function:  CMuxNotify::EnableBindings
//
// Purpose:   Enable/Disable the bindings of other protocols to 
//            the physical adapter.
//
// Arguments:
//            IN pnccAdapter: Pointer to the physical adapter.
//            IN bEnable: TRUE/FALSE to enable/disable respectively.
//
// Returns:   None.
//
// Notes:
//

VOID CMuxNotify::EnableBindings (INetCfgComponent *pnccAdapter,
                                 BOOL bEnable)
{
    IEnumNetCfgBindingPath      *pencbp;
    INetCfgBindingPath          *pncbp;
    HRESULT                     hr;
  
    TraceMsg( L"-->CMuxNotify::EnableBindings.\n" );


    //
    // Get the binding path enumerator.
    //

    hr = HrGetBindingPathEnum( pnccAdapter,
                               EBP_ABOVE,
                               &pencbp );
    if ( hr == S_OK ) {

        hr = HrGetBindingPath( pencbp,
                               &pncbp );

        //
        // Traverse each binding path.
        //

        while( hr == S_OK ) {

            //
            // If our protocol does exist in the binding path then,
            // disable it.
            //

            if ( !IfExistMux(pncbp) ) {

                pncbp->Enable( bEnable );
            }

            ReleaseObj( pncbp );

            hr = HrGetBindingPath( pencbp,
                                   &pncbp );
        }

        ReleaseObj( pencbp );
    }
    else {
        TraceMsg( L"   Couldn't get the binding path enumerator, "
                  L"bindings will not be %s.\n",
                  bEnable ? L"enabled" : L"disabled" );
    }

    TraceMsg( L"<--CMuxNotify::EnableBindings.\n" );

    return;
}

// ----------------------------------------------------------------------
//
// Function:  CMuxNotify::IfExistMux
//
// Purpose:   Determine if a given binding path contains our protocol.
//
// Arguments:
//            IN pncbp: Pointer to the binding path.
//
// Returns:   TRUE if our protocol exists, otherwise FALSE.
//
// Notes:
//

BOOL CMuxNotify::IfExistMux (INetCfgBindingPath *pncbp)
{
    IEnumNetCfgBindingInterface *pencbi;
    INetCfgBindingInterface     *pncbi;
    INetCfgComponent            *pnccUpper;
    LPWSTR                      lpszIdUpper;
    HRESULT                     hr;
    BOOL                        bExist = FALSE;

    TraceMsg( L"-->CMuxNotify::IfExistMux.\n" );

    //
    // Get the binding interface enumerator.
    //

    hr = HrGetBindingInterfaceEnum( pncbp,
                                  &pencbi );

    if ( hr == S_OK ) {

        //
        // Traverse each binding interface.
        //

        hr = HrGetBindingInterface( pencbi,
                                    &pncbi );

        while( !bExist && (hr == S_OK) ) {

            //
            // Is the upper component our protocol?
            //

            hr = pncbi->GetUpperComponent( &pnccUpper );

            if ( hr == S_OK ) {

                hr = pnccUpper->GetId( &lpszIdUpper );

                if ( hr == S_OK ) {

                    bExist = !_wcsicmp( lpszIdUpper, c_szMuxProtocol );

                    CoTaskMemFree( lpszIdUpper );
                }
                else {
                    TraceMsg( L"   Failed to get the upper component of the interface.\n" );
                }

                ReleaseObj( pnccUpper );
            }
            else {
                TraceMsg( L"   Failed to get the upper component of the interface.\n" );
            }

            ReleaseObj( pncbi );

            if ( !bExist ) {
                hr = HrGetBindingInterface( pencbi,
                                            &pncbi );
            }
        }

        ReleaseObj( pencbi );
    }
    else {
        TraceMsg( L"   Couldn't get the binding interface enumerator.\n" );
    }

    TraceMsg( L"<--CMuxNotify::IfExistMux(BOOL = %x).\n",
            bExist );

    return bExist;
}

// ----------------------------------------------------------------------
//
// Function:  CMuxNotify::HrGetBindingPathEnum
//
// Purpose:   Returns the binding path enumerator.
//
// Arguments:
//            IN  pnccAdapter  : Pointer to the physical adapter.
//            IN  dwBindingType: Type of binding path enumerator.
//            OUT ppencbp      : Pointer to the binding path enumerator.
//
// Returns:   S_OK on success, otherwise an error code.
//
// Notes:
//

HRESULT CMuxNotify::HrGetBindingPathEnum (
                                     INetCfgComponent *pnccAdapter,
                                     DWORD dwBindingType,
                                     IEnumNetCfgBindingPath **ppencbp)
{
    INetCfgComponentBindings *pnccb = NULL;
    HRESULT                  hr;

    *ppencbp = NULL;

    hr = pnccAdapter->QueryInterface( IID_INetCfgComponentBindings,
                               (PVOID *)&pnccb );

    if ( hr == S_OK ) {
        hr = pnccb->EnumBindingPaths( dwBindingType,
                                      ppencbp );

        ReleaseObj( pnccb );
    }

    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  CMuxNotify::HrGetBindingPath
//
// Purpose:   Returns a binding path.
//
// Arguments:
//            IN  pencbp  : Pointer to the binding path enumerator.
//            OUT ppncbp  : Pointer to the binding path.
//
// Returns:   S_OK on success, otherwise an error code.
//
// Notes:
//

HRESULT CMuxNotify::HrGetBindingPath (IEnumNetCfgBindingPath *pencbp,
                                      INetCfgBindingPath **ppncbp)
{
    ULONG   ulCount;
    HRESULT hr;

    *ppncbp = NULL;

    hr = pencbp->Next( 1,
                       ppncbp,
                       &ulCount );

    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  CMuxNotify::HrGetBindingInterfaceEnum
//
// Purpose:   Returns the binding interface enumerator.
//
// Arguments:
//            IN  pncbp  : Pointer to the binding path.
//            OUT ppencbi: Pointer to the binding path enumerator.
//
// Returns:   S_OK on success, otherwise an error code.
//
// Notes:
//

HRESULT CMuxNotify::HrGetBindingInterfaceEnum (
                                     INetCfgBindingPath *pncbp,
                                     IEnumNetCfgBindingInterface **ppencbi)
{
    HRESULT hr;

    *ppencbi = NULL;

    hr = pncbp->EnumBindingInterfaces( ppencbi );

    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  CMuxNotify::HrGetBindingInterface
//
// Purpose:   Returns a binding interface.
//
// Arguments:
//            IN  pencbi  : Pointer to the binding interface enumerator.
//            OUT ppncbi  : Pointer to the binding interface.
//
// Returns:   S_OK on success, otherwise an error code.
//
// Notes:
//

HRESULT CMuxNotify::HrGetBindingInterface (
                                     IEnumNetCfgBindingInterface *pencbi,
                                     INetCfgBindingInterface **ppncbi)
{
    ULONG   ulCount;
    HRESULT hr;

    *ppncbi = NULL;

    hr = pencbi->Next( 1,
                       ppncbi,
                       &ulCount );

    return hr;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\samples\muxim\notify.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992-2001.
//
//  File:       N O T I F Y . H
//
//  Contents:   Header file for sample notify object.
//
//  Notes:
//
//  Author:     Alok Sinha
//
//----------------------------------------------------------------------------

#ifndef NOTIFY_H_INCLUDE

#define NOTIFY_H_INCLUDE

#include <windows.h>

#include <atlbase.h>
extern CComModule _Module;  // required by atlcom.h
#include <atlcom.h>
#include <devguid.h>
#include <setupapi.h>

#include <notifyn.h>
#include "list.h"
#include "adapter.h"
#include "resource.h"
#include "common.h"


//
// CMuxNotify Object - Base class for the entire notify object
//


class CMuxNotify :

               //
               // Must inherit from CComObjectRoot(Ex) for reference count
               // management and default threading model.
               //
 
               public CComObjectRoot,

               //
               // Define the default class factory and aggregation model.
               //

               public CComCoClass<CMuxNotify, &CLSID_CMuxNotify>,

               //
               // Notify Object's interfaces.
               //

               public INetCfgComponentControl,
               public INetCfgComponentSetup,
               public INetCfgComponentPropertyUi,
               public INetCfgComponentNotifyBinding,
               public INetCfgComponentNotifyGlobal
{

   //
   // Public members.
   //

   public:

      //
      // Constructor
      //

      CMuxNotify(VOID);

      //
      // Destructors.
      //

      ~CMuxNotify(VOID);

      //
      // Notify Object's interfaces.
      //

      BEGIN_COM_MAP(CMuxNotify)
         COM_INTERFACE_ENTRY(INetCfgComponentControl)
         COM_INTERFACE_ENTRY(INetCfgComponentSetup)
         COM_INTERFACE_ENTRY(INetCfgComponentPropertyUi)
         COM_INTERFACE_ENTRY(INetCfgComponentNotifyBinding)
         COM_INTERFACE_ENTRY(INetCfgComponentNotifyGlobal)
      END_COM_MAP()

      //
      // Uncomment the the line below if you don't want your object to
      // support aggregation. The default is to support it
      //
      // DECLARE_NOT_AGGREGATABLE(CMuxNotify)
      //

      DECLARE_REGISTRY_RESOURCEID(IDR_REG_SAMPLE_NOTIFY)

      //
      // INetCfgComponentControl
      //

      STDMETHOD (Initialize) (
                   IN INetCfgComponent  *pIComp,
                   IN INetCfg           *pINetCfg,
                   IN BOOL              fInstalling);

      STDMETHOD (CancelChanges) ();

      STDMETHOD (ApplyRegistryChanges) ();

      STDMETHOD (ApplyPnpChanges) (
                   IN INetCfgPnpReconfigCallback* pICallback);

      //
      // INetCfgComponentSetup
      //

      STDMETHOD (Install) (
                   IN DWORD dwSetupFlags);

      STDMETHOD (Upgrade) (
                   IN DWORD dwSetupFlags,
                   IN DWORD dwUpgradeFromBuildNo);

      STDMETHOD (ReadAnswerFile) (
                   IN PCWSTR szAnswerFile,
                   IN PCWSTR szAnswerSections);

      STDMETHOD (Removing) ();

      //
      // INetCfgComponentPropertyUi
      //

        STDMETHOD (QueryPropertyUi) (
                   IN IUnknown* pUnk);

        STDMETHOD (SetContext) (
                   IN IUnknown* pUnk);

        STDMETHOD (MergePropPages) (
                   IN OUT DWORD* pdwDefPages,
                   OUT LPBYTE* pahpspPrivate,
                   OUT UINT* pcPrivate,
                   IN HWND hwndParent,
                   OUT PCWSTR* pszStartPage);

        STDMETHOD (ValidateProperties) (
                   HWND hwndSheet);

        STDMETHOD (CancelProperties) ();

        STDMETHOD (ApplyProperties) ();

      //
      // INetCfgNotifyBinding
      //

      STDMETHOD (QueryBindingPath) (
                   IN DWORD dwChangeFlag,
                   IN INetCfgBindingPath* pncbp);

      STDMETHOD (NotifyBindingPath) (
                   IN DWORD dwChangeFlag,
                   IN INetCfgBindingPath* pncbp);

      //
      // INetCfgNotifyGlobal
      //

      STDMETHOD (GetSupportedNotifications) (
                   OUT DWORD* pdwNotificationFlag );

      STDMETHOD (SysQueryBindingPath) (
                   IN DWORD dwChangeFlag,
                   IN INetCfgBindingPath* pncbp);

      STDMETHOD (SysNotifyBindingPath) (
                   IN DWORD dwChangeFlag,
                   IN INetCfgBindingPath* pncbp);
            
      STDMETHOD (SysNotifyComponent) (
                   IN DWORD dwChangeFlag,
                   IN INetCfgComponent* pncc);

  //
  // Private members.
  //

  private:

     //
     // Private member variables.
     //

     INetCfgComponent  *m_pncc;  // Protocol's Net Config component
     INetCfg           *m_pnc;
     ConfigAction      m_eApplyAction;
     IUnknown*         m_pUnkContext;

     //
     // List of physical adapters currently installed.
     //

     List<CMuxPhysicalAdapter *, GUID> m_AdaptersList;

     //
     // List of physical adapters to be removed.
     //

     List<CMuxPhysicalAdapter *, GUID> m_AdaptersToRemove;

     //
     // List of physical adapters to be added.
     //

     List<CMuxPhysicalAdapter *, GUID> m_AdaptersToAdd;

     //
     // Private member functions.
     //

     HRESULT HrLoadAdapterConfiguration (VOID);

     HRESULT HrGetUpperAndLower (INetCfgBindingPath* pncbp,
                                 INetCfgComponent **ppnccUpper,
                                 INetCfgComponent **ppnccLower);

     HRESULT HrAddAdapter (INetCfgComponent *pnccAdapter);

     HRESULT HrRemoveAdapter (INetCfgComponent *pnccAdapter);

     HRESULT HrAddMiniport (CMuxPhysicalAdapter *pAdapter,
                            GUID *guidAdapter);

     HRESULT HrRemoveMiniport (CMuxPhysicalAdapter *pAdapter,
                            GUID *guidAdapter);

#ifdef DISABLE_PROTOCOLS_TO_PHYSICAL

    VOID EnableBindings (INetCfgComponent *pnccAdapter,
                         BOOL bEnable);

    BOOL IfExistMux (INetCfgBindingPath *pncbp);

    HRESULT HrGetBindingPathEnum (INetCfgComponent *pnccAdapter,
                                  DWORD dwBindingType,
                                  IEnumNetCfgBindingPath **ppencbp);

    HRESULT HrGetBindingPath (IEnumNetCfgBindingPath *pencbp,
                              INetCfgBindingPath **ppncbp);

    HRESULT HrGetBindingInterfaceEnum (INetCfgBindingPath *pncbp,
                                       IEnumNetCfgBindingInterface **ppencbi);

    HRESULT HrGetBindingInterface (IEnumNetCfgBindingInterface *pencbi,
                                   INetCfgBindingInterface **ppncbi);
#endif

  public:

     LRESULT OnInitDialog (IN HWND hWnd);
     LRESULT OnOk (IN HWND hWnd);
     LRESULT OnCancel (IN HWND hWnd);
};


INT_PTR CALLBACK NotifyDialogProc (HWND hWnd,
                                   UINT uMsg,
                                   WPARAM wParam,
                                   LPARAM lParam);
UINT CALLBACK NotifyPropSheetPageProc (HWND hWnd,
                                       UINT uMsg,
                                       LPPROPSHEETPAGE ppsp);
#endif // NOTIFY_H_INCLUDE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\samples\muxim\dllmain.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992-2001.
//
//  File:       DLLMAIN . C P P
//
//  Contents:   Main entry points into the DLL
//
//  Notes:
//
//----------------------------------------------------------------------------


#include <windows.h>
#include <shellapi.h>
#include <shlobj.h>

#include <atlbase.h>
extern CComModule _Module;  // required by atlcom.h
#include <atlcom.h>
#include <devguid.h>

#include "notify.h"
#include "notifyn_i.c"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_CMuxNotify, CMuxNotify)
END_OBJECT_MAP()





/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain (HINSTANCE hInstance,
                     DWORD dwReason,
                     LPVOID /*lpReserved*/)
{
	TraceMsg( L"-->DllMain.\n");

	if (dwReason == DLL_PROCESS_ATTACH) {

		TraceMsg( L"   Reason: Attach.\n");

		_Module.Init(ObjectMap, hInstance);

		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH) {

		TraceMsg( L"   Reason: Detach.\n");

		   _Module.Term();
	}

	TraceMsg( L"<--DllMain.\n");

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	HRESULT hr;

	TraceMsg( L"-->DllCanUnloadNow.\n");

	hr = (_Module.GetLockCount() == 0) ? S_OK : S_FALSE;

	TraceMsg( L"-->DllCanUnloadNow(HRESULT = %x).\n",
	        hr );

	return hr;  
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	TraceMsg( L"-->DllGetClassObject.\n");

	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// Registers object, typelib and all interfaces in typelib

	TraceMsg( L"-->DllRegisterServer.\n");

	return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	TraceMsg( L"-->DllUnregisterServer.\n");

	_Module.UnregisterServer();

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\samples\muxim\resource.h ===
#ifndef RESOURCE_H_INCLUDE

#define RESOURCE_H_INCLUDE

#define IDR_REG_SAMPLE_NOTIFY     40001

#define IDD_NOTIFY_GENERAL        1850
#define IDC_STATIC                -1
#define IDC_ADD                   100
#define IDC_REMOVE                200

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\shell\advcfg\acbind.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       A C B I N D . C P P
//
//  Contents:   Advanced configuration bindings dialog implementation
//
//  Notes:
//
//  Author:     danielwe   18 Nov 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "acbind.h"
#include "achelp.h"
#include "acsheet.h"
#include "connutil.h"
#include "lancmn.h"
#include "ncnetcfg.h"
#include "ncsetup.h"
#include "ncui.h"
#include "netconp.h"
#include "order.h"


const DWORD g_aHelpIDs_IDD_ADVCFG_Bindings[]=
{
    LVW_Adapters, IDH_Adapters,
    PSB_Adapter_Up, IDH_Adapter_Up,
    PSB_Adapter_Down, IDH_Adapter_Down,
    TVW_Bindings, IDH_Bindings,
    PSB_Binding_Up, IDH_Binding_Up,
    IDH_Binding_Down, PSB_Binding_Down,
    0,0
};

extern const WCHAR c_szNetCfgHelpFile[];

//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::~CBindingsDlg
//
//  Purpose:    Destructor for the Advanced configuration dialog
//
//  Arguments:
//      (none)
//
//  Returns:    Nothing
//
//  Author:     danielwe   26 Nov 1997
//
//  Notes:
//
CBindingsDlg::~CBindingsDlg()
{
    if (m_hiconUpArrow)
    {
        DeleteObject(m_hiconUpArrow);
    }
    if (m_hiconDownArrow)
    {
        DeleteObject(m_hiconDownArrow);
    }

    if (m_hilItemIcons)
    {
        ImageList_Destroy(m_hilItemIcons);
    }

    if (m_hilCheckIcons)
    {
        ImageList_Destroy(m_hilCheckIcons);
    }

    ReleaseObj(m_pnc);
}

//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::OnInitDialog
//
//  Purpose:    Called when the WM_INITDIALOG is received
//
//  Arguments:
//      uMsg     []
//      wParam   []
//      lParam   []
//      bHandled []
//
//  Returns:
//
//  Author:     danielwe   19 Nov 1997
//
//  Notes:
//
LRESULT CBindingsDlg::OnInitDialog(UINT uMsg, WPARAM wParam,
                                   LPARAM lParam, BOOL& bHandled)
{
    HRESULT                 hr = S_OK;
    INT                     iaci;
    RECT                    rc;
    LV_COLUMN               lvc = {0};
    SP_CLASSIMAGELIST_DATA  cid;

    m_hwndLV = GetDlgItem(LVW_Adapters);
    m_hwndTV = GetDlgItem(TVW_Bindings);

    // Make this initially invisible in case we don't have any adapters
    ::ShowWindow(GetDlgItem(IDH_TXT_ADVGFG_BINDINGS), SW_HIDE);

    hr = HrSetupDiGetClassImageList(&cid);
    if (SUCCEEDED(hr))
    {
        // Create small image lists
        m_hilItemIcons = ImageList_Duplicate(cid.ImageList);

        // Add the LAN connection icon to the image list
        HICON hIcon = LoadIcon(_Module.GetResourceInstance(),
                               MAKEINTRESOURCE(IDI_LB_GEN_S_16));
        Assert(hIcon);

        // Add the icon
        m_nIndexLan = ImageList_AddIcon(m_hilItemIcons, hIcon);

        ListView_SetImageList(m_hwndLV, m_hilItemIcons, LVSIL_SMALL);
        TreeView_SetImageList(m_hwndTV, m_hilItemIcons, TVSIL_NORMAL);

        (void) HrSetupDiDestroyClassImageList(&cid);
    }

    ::GetClientRect(m_hwndLV, &rc);
    lvc.mask = LVCF_FMT | LVCF_WIDTH;
    lvc.fmt = LVCFMT_LEFT;
    lvc.cx = rc.right - GetSystemMetrics(SM_CXVSCROLL);
    ListView_InsertColumn(m_hwndLV, 0, &lvc);

    if (!m_hiconUpArrow && !m_hiconDownArrow)
    {
        m_hiconUpArrow = (HICON)LoadImage(_Module.GetResourceInstance(),
                                          MAKEINTRESOURCE(IDI_UP_ARROW),
                                          IMAGE_ICON, 16, 16, 0);
        m_hiconDownArrow = (HICON)LoadImage(_Module.GetResourceInstance(),
                                            MAKEINTRESOURCE(IDI_DOWN_ARROW),
                                            IMAGE_ICON, 16, 16, 0);
    }

    SendDlgItemMessage(PSB_Adapter_Up, BM_SETIMAGE, IMAGE_ICON,
                       reinterpret_cast<LPARAM>(m_hiconUpArrow));
    SendDlgItemMessage(PSB_Adapter_Down, BM_SETIMAGE, IMAGE_ICON,
                       reinterpret_cast<LPARAM>(m_hiconDownArrow));
    SendDlgItemMessage(PSB_Binding_Up, BM_SETIMAGE, IMAGE_ICON,
                       reinterpret_cast<LPARAM>(m_hiconUpArrow));
    SendDlgItemMessage(PSB_Binding_Down, BM_SETIMAGE, IMAGE_ICON,
                       reinterpret_cast<LPARAM>(m_hiconDownArrow));

    if (SUCCEEDED(hr))
    {
        hr = HrBuildAdapterList();
    }

    // Create state image lists
    m_hilCheckIcons = ImageList_LoadBitmapAndMirror(
                                    _Module.GetResourceInstance(),
                                    MAKEINTRESOURCE(IDB_CHECKSTATE),
                                    16,
                                    0,
                                    PALETTEINDEX(6));
    TreeView_SetImageList(m_hwndTV, m_hilCheckIcons, TVSIL_STATE);

    if (FAILED(hr))
    {
        SetWindowLong(DWLP_MSGRESULT, PSNRET_INVALID);
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::OnContextMenu
//
//  Purpose:    Called in response to the WM_CONTEXTMENU message
//
//  Arguments:
//      uMsg     []
//      wParam   []
//      lParam   []
//      bHandled []
//
//  Returns:    0 always
//
//  Author:     danielwe   22 Jan 1998
//
//  Notes:
//
LRESULT CBindingsDlg::OnContextMenu(UINT uMsg, WPARAM wParam,
                                 LPARAM lParam, BOOL& bHandled)
{
    ::WinHelp(m_hWnd,
            c_szNetCfgHelpFile,
            HELP_CONTEXTMENU,
            reinterpret_cast<ULONG_PTR>(g_aHelpIDs_IDD_ADVCFG_Bindings));
    
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::OnHelp
//
//  Purpose:    Called in response to the WM_HELP message
//
//  Arguments:
//      uMsg     []
//      wParam   []
//      lParam   []
//      bHandled []
//
//  Returns:    TRUE
//
//  Author:     danielwe   19 Mar 1998
//
//  Notes:
//
LRESULT CBindingsDlg::OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam,
                           BOOL& bHandled)
{
    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);

    if (HELPINFO_WINDOW == lphi->iContextType)
    {
        ::WinHelp(static_cast<HWND>(lphi->hItemHandle),
                  c_szNetCfgHelpFile,
                  HELP_WM_HELP,
                  reinterpret_cast<ULONG_PTR>(g_aHelpIDs_IDD_ADVCFG_Bindings));
    }

    return TRUE;  
}

//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::OnOk
//
//  Purpose:    Called when the OK button is pressed
//
//  Arguments:
//
//  Returns:
//
//  Author:     danielwe   19 Nov 1997
//
//  Notes:
//
LRESULT CBindingsDlg::OnOk(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    CWaitCursor wc;

    HRESULT hr = m_pnc->Apply();

    if (NETCFG_S_REBOOT == hr)
    {
        // On a reboot, uninitialize NetCfg since we won't be leaving
        // this function.
        //
        (VOID) m_pnc->Uninitialize();

        (VOID) HrNcQueryUserForReboot(_Module.GetResourceInstance(),
                                      m_hWnd,
                                      IDS_ADVCFG_CAPTION,
                                      IDS_REBOOT_REQUIRED,
                                      QUFR_PROMPT | QUFR_REBOOT);
    }

    // Normalize result
    if (S_FALSE == hr)
    {
        hr = S_OK;
    }

    TraceError("CBindingsDlg::OnOk", hr);
    return LresFromHr(hr);
}

//
// Binding list implementation
//

//+---------------------------------------------------------------------------
//
//  Member:     CSortableBindPath::operator <
//
//  Purpose:    Provides comparison operator for binding path depth
//
//  Arguments:
//      refsbp [in] Reference to bind path to compare with
//
//  Returns:    TRUE if given bind path depth is greater than this one
//
//  Author:     danielwe   26 Nov 1997
//
//  Notes:      The comparison is backwards on purpose so that sorting is
//              done is descending order.
//
bool CSortableBindPath::operator<(const CSortableBindPath &refsbp) const
{
    DWORD   dwLen1;
    DWORD   dwLen2;

    GetDepth(&dwLen1);
    refsbp.GetDepth(&dwLen2);

    // yes this is greater than because we want to sort in descending order
    return dwLen1 > dwLen2;
}

//+---------------------------------------------------------------------------
//
//  Function:   FIsHidden
//
//  Purpose:    Returns TRUE if the given component has the NCF_HIDDEN
//              characterstic.
//
//  Arguments:
//      pncc [in]   Component to be checked
//
//  Returns:    TRUE if component is hidden, FALSE if not
//
//  Author:     danielwe   26 Nov 1997
//
//  Notes:
//
BOOL FIsHidden(INetCfgComponent *pncc)
{
    DWORD   dwFlags;

    return (SUCCEEDED(pncc->GetCharacteristics(&dwFlags)) &&
            ((dwFlags & NCF_HIDE_BINDING) || (dwFlags & NCF_HIDDEN)));
}

//+---------------------------------------------------------------------------
//
//  Function:   FDontExposeLower
//
//  Purpose:    Returns TRUE if the given component has the NCF_DONTEXPOSELOWER
//              characterstic.
//
//  Arguments:
//      pncc [in]   Component to be checked
//
//  Returns:    TRUE if component has DONTEXPOSELOWER, FALSE if not
//
//  Author:     danielwe   26 Nov 1997
//
//  Notes:
//
BOOL FDontExposeLower(INetCfgComponent *pncc)
{
    DWORD   dwFlags;

    return (SUCCEEDED(pncc->GetCharacteristics(&dwFlags)) &&
            (dwFlags & NCF_DONTEXPOSELOWER));
}

//+---------------------------------------------------------------------------
//
//  Function:   HrCountDontExposeLower
//
//  Purpose:    Counts the number of components in the given binding path
//              that have the NCF_DONTEXPOSELOWER characterstic.
//
//  Arguments:
//      pncbp  [in]  Binding path to count
//      pcItems[out] Number of components in the binding path that have the
//                   NCF_DONTEXPOSELOWER characterstic.
//
//  Returns:    S_OK if success, OLE or Win32 error otherwise
//
//  Author:     danielwe   1 Dec 1997
//
//  Notes:
//
HRESULT HrCountDontExposeLower(INetCfgBindingPath *pncbp, DWORD *pcItems)
{
    HRESULT                     hr = S_OK;
    CIterNetCfgBindingInterface ncbiIter(pncbp);
    INetCfgBindingInterface *   pncbi;
    DWORD                       cItems = 0;
    DWORD                       cIter = 0;

    Assert(pcItems);

    *pcItems = 0;

    while (SUCCEEDED(hr) && S_OK == (hr = ncbiIter.HrNext(&pncbi)))
    {
        INetCfgComponent *  pncc;

        if (!cIter)
        {
            // First iteration. Get upper component first.
            hr = pncbi->GetUpperComponent(&pncc);
            if (SUCCEEDED(hr))
            {
                if (FDontExposeLower(pncc))
                {
                    cItems++;
                }

                ReleaseObj(pncc);
            }
        }

        hr = pncbi->GetLowerComponent(&pncc);
        if (SUCCEEDED(hr))
        {
            if (FDontExposeLower(pncc))
            {
                cItems++;
            }

            ReleaseObj(pncc);
        }

        ReleaseObj(pncbi);
    }

    if (SUCCEEDED(hr))
    {
        *pcItems = cItems;
        hr = S_OK;
    }

    TraceError("HrCountDontExposeLower", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   FEqualComponents
//
//  Purpose:    Compares the given 2 components to see if they are the same
//
//  Arguments:
//      pnccA [in]  First component to compare
//      pnccB [in]  Second component to compare
//
//  Returns:    TRUE if components are the same, FALSE if not
//
//  Author:     danielwe   1 Dec 1997
//
//  Notes:
//
BOOL FEqualComponents(INetCfgComponent *pnccA, INetCfgComponent *pnccB)
{
    GUID    guidA;
    GUID    guidB;

    if (SUCCEEDED(pnccA->GetInstanceGuid(&guidA)) &&
        SUCCEEDED(pnccB->GetInstanceGuid(&guidB)))
    {
        return (guidA == guidB);
    }

    return FALSE;
}

//
// Debug functions
//

#ifdef ENABLETRACE
//+---------------------------------------------------------------------------
//
//  Function:   DbgDumpBindPath
//
//  Purpose:    Dumps the given binding path in an easy to read format
//
//  Arguments:
//      pncbp [in]  Bind path to dump
//
//  Returns:    Nothing
//
//  Author:     danielwe   26 Nov 1997
//
//  Notes:
//
VOID DbgDumpBindPath(INetCfgBindingPath *pncbp)
{
    HRESULT                     hr = S_OK;
    tstring                     strPath;
    INetCfgBindingInterface *   pncbi;
    INetCfgComponent *          pncc = NULL;
    PWSTR pszwCompId;

    if ((!pncbp) || IsBadReadPtr((CONST VOID *)pncbp,
                                 sizeof(INetCfgBindingPath *)))
    {
        TraceTag(ttidAdvCfg, "Bind path is invalid!");
        return;
    }

    CIterNetCfgBindingInterface ncbiIter(pncbp);

    while (SUCCEEDED(hr) && S_OK == (hr = ncbiIter.HrNext(&pncbi)))
    {
        if (strPath.empty())
        {
            hr = pncbi->GetUpperComponent(&pncc);
            if (SUCCEEDED(hr))
            {
                hr = pncc->GetId(&pszwCompId);
                if (SUCCEEDED(hr))
                {
                    strPath = pszwCompId;
                    CoTaskMemFree(pszwCompId);
                }
                ReleaseObj(pncc);
                pncc = NULL;
            }
        }
        hr = pncbi->GetLowerComponent(&pncc);
        if (SUCCEEDED(hr))
        {
            hr = pncc->GetId(&pszwCompId);
            if (SUCCEEDED(hr))
            {
                strPath += L" -> ";
                strPath += pszwCompId;

                CoTaskMemFree(pszwCompId);
            }
            ReleaseObj(pncc);
        }
        ReleaseObj(pncbi);
    }

    if (SUCCEEDED(hr))
    {
        TraceTag(ttidAdvCfg, "Address = 0x%08lx, Path is '%S'",
                 pncbp, strPath.c_str());
    }
    else
    {
        TraceTag(ttidAdvCfg, "Error dumping binding path.");
    }

}

VOID DbgDumpTreeViewItem(HWND hwndTV, HTREEITEM hti)
{
    WCHAR       szText[256];
    TV_ITEM     tvi;

    if (hti)
    {
        tvi.hItem = hti;
        tvi.pszText = szText;
        tvi.cchTextMax = celems(szText);
        tvi.mask = TVIF_TEXT;
        TreeView_GetItem(hwndTV, &tvi);

        TraceTag(ttidAdvCfg, "TreeView item is %S.", szText);
    }
    else
    {
        TraceTag(ttidAdvCfg, "TreeView item is NULL");
    }
}

#endif //ENABLETRACE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\shell\advcfg\achelp.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Generated by Dan Weisman
// Used by advcfg.rc
//

#define IDH_Edit_NetBios                214
#define IDH_Lana                        218
#define IDH_Adapters                    25000
#define IDH_Adapter_Up                  25001
#define IDH_Adapter_Down                25002
#define IDH_Bindings                    25003
#define IDH_Binding_Up                  25004
#define IDH_Binding_Down                25005
#define IDH_Provider_Order              25006
#define IDH_TREEVIEW                    25011
#define IDH_MOVEUP                      25012
#define IDH_MOVEDOWN                    25013
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\samples\muxim\public.h ===
/*++
Copyright (c) 1990-2000    Microsoft Corporation All Rights Reserved

Module Name:

    public.h

Abstract:

    This module contains the common declarations shared by driver
    and user applications.

Author:

     
Environment:

    user and kernel
Notes:


Revision History:


--*/
#ifndef __PUBLIC_H
#define __PUBLIC_H

//
// To support ioctls from user-mode:
//

#define LINKNAME_STRING     L"\\DosDevices\\Mux"
#define NTDEVICE_STRING     L"\\Device\\Mux"

#define  MUX_CUSTOM_EVENT      1

#define NOTIFY_SIGNATURE       0xAFCDABAB

typedef struct _NOTIFY_CUSTOM_EVENT {
  ULONG           uSignature;
  ULONG           uEvent;
  WCHAR           szMiniport[1];
} NOTIFY_CUSTOM_EVENT, *PNOTIFY_CUSTOM_EVENT;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\shell\advcfg\acbind.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       A D V C F G P . H
//
//  Contents:   Private header for Advanced Configuration dialog
//
//  Notes:
//
//  Author:     danielwe   20 Nov 1997
//
//----------------------------------------------------------------------------

#pragma once
#include "nsbase.h"

#include "ncatlps.h"
#include "netcfgx.h"
#include "resource.h"

//
// image state entries
//

enum SELS_MASKS
{
    SELS_CHECKED         = 0x1,
    SELS_UNCHECKED       = 0x2,
    SELS_FIXEDBINDING_DISABLED = 0x3,
    SELS_FIXEDBINDING_ENABLED  = 0x4,
};

enum MAB_DIRECTION
{
    MAB_UP      =   1,
    MAB_DOWN    =   2,
};

class CSortableBindPath;

typedef list<CSortableBindPath>     SBP_LIST;

enum ASSOCIATE_FLAGS
{
    ASSCF_ON_ENABLE     = 0x1,
    ASSCF_ON_DISABLE    = 0x2,
    ASSCF_ANCESTORS     = 0x8,
};

struct BIND_PATH_INFO
{
    INetCfgBindingPath *    pncbp;
    DWORD                   dwLength;
};

typedef list<BIND_PATH_INFO *>      BPIP_LIST;
typedef list<INetCfgComponent *>    NCC_LIST;
typedef list<INetCfgBindingPath *>  NCBP_LIST;

struct TREE_ITEM_DATA
{
    INetCfgComponent *  pncc;
    BPIP_LIST           listbpipOnEnable;
    BPIP_LIST           listbpipOnDisable;
    BOOL                fOrdered;
};

struct HTREEITEMP
{
    HTREEITEM   hti;
};

typedef list<HTREEITEMP>     HTI_LIST;

//
// CBindingsDlg
//

class CBindingsDlg: public CPropSheetPage
{
    BEGIN_MSG_MAP(CBindingsDlg)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu)
        MESSAGE_HANDLER(WM_HELP, OnHelp)
        NOTIFY_CODE_HANDLER(PSN_APPLY, OnOk)
        COMMAND_ID_HANDLER(PSB_Adapter_Up, OnAdapterUp)
        COMMAND_ID_HANDLER(PSB_Adapter_Down, OnAdapterDown)
        COMMAND_ID_HANDLER(PSB_Binding_Up, OnBindingUp)
        COMMAND_ID_HANDLER(PSB_Binding_Down, OnBindingDown)
        NOTIFY_CODE_HANDLER(TVN_DELETEITEM, OnTreeDeleteItem)
        NOTIFY_CODE_HANDLER(TVN_KEYDOWN, OnTreeKeyDown)
        NOTIFY_CODE_HANDLER(TVN_ITEMEXPANDING, OnTreeItemExpanding)
        NOTIFY_CODE_HANDLER(TVN_SELCHANGED, OnTreeItemChanged)
        NOTIFY_CODE_HANDLER(LVN_DELETEITEM, OnListDeleteItem)
        NOTIFY_CODE_HANDLER(LVN_ITEMCHANGED, OnListItemChanged)
        NOTIFY_CODE_HANDLER(NM_DBLCLK, OnDoubleClick)
        NOTIFY_CODE_HANDLER(NM_CLICK, OnClick)
    END_MSG_MAP()

    enum {IDD = IDD_Advanced_Config};

    CBindingsDlg(INetCfg *pnc)
    {
        AddRefObj(m_pnc = pnc);

        m_hiconUpArrow = NULL;
        m_hiconDownArrow = NULL;
        m_iItemSel = -1;
        m_hilItemIcons = NULL;
        m_hilCheckIcons = NULL;
        m_fWanBindingsFirst = FALSE;
    }

    ~CBindingsDlg();

    BOOL FShowPage()
    {
        return TRUE;
    }

private:
    INetCfg *       m_pnc;
    HWND            m_hwndLV;
    HWND            m_hwndTV;
    HICON           m_hiconUpArrow;
    HICON           m_hiconDownArrow;
    HIMAGELIST      m_hilItemIcons;
    HIMAGELIST      m_hilCheckIcons;
    INT             m_iItemSel;
    BOOL            m_fWanBindingsFirst;
    INT             m_nIndexLan;

    //
    // Message handlers
    //
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam,
                         LPARAM lParam, BOOL& bHandled);

    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam,
                         LPARAM lParam, BOOL& bHandled);

    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnOk(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnAdapterUp(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                        BOOL& bHandled);
    LRESULT OnAdapterDown(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                          BOOL& bHandled);
    LRESULT OnBindingUp(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                        BOOL& bHandled);
    LRESULT OnBindingDown(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                          BOOL& bHandled);
    VOID OnAdapterUpDown(BOOL fUp);
    LRESULT OnListItemChanged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnTreeItemChanged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnTreeDeleteItem(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnListDeleteItem(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnTreeItemExpanding(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnTreeKeyDown(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnClick(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnDoubleClick(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);

    //
    // Adapter list functions
    //
    VOID OnAdapterChange(INT iItem);
    HRESULT HrBuildAdapterList(VOID);
    HRESULT HrGetAdapters(INetCfgComponent *pncc, NCC_LIST *plistNcc);
    VOID SetAdapterButtons();
    VOID AddListViewItem(INetCfgComponent *pncc, INT ipos, INT nIndex,
                         PCWSTR pszConnName);
    BOOL FIsWanBinding(INT iItem);
    VOID GetWanOrdering(VOID);
    VOID SetWanOrdering(VOID);

    //
    // Bindings tree functions
    //

    VOID SetCheckboxStates(VOID);
    VOID ToggleCheckbox(HTREEITEM hti);
    VOID OnBindingUpDown(BOOL fUp);
    HRESULT HrOrderSubItems(VOID);
    HRESULT HrOrderDisableLists(VOID);
    HRESULT HrOrderDisableList(TREE_ITEM_DATA *ptid);
    HTREEITEM HtiMoveTreeItemAfter(HTREEITEM htiParent, HTREEITEM htiDest,
                                   HTREEITEM htiSrc);
    VOID BuildBindingsList(INetCfgComponent *pncc);

    HRESULT HrHandleSubpath(SBP_LIST &listsbp, INetCfgBindingPath *pncbpSub);
    HRESULT HrHandleSubItem(INetCfgBindingPath *pncbpThis,
                            INetCfgBindingPath *pncbpMatch,
                            TREE_ITEM_DATA *ptid,
                            HTREEITEM htiMatchItem);
    HRESULT HrHandleValidSubItem(INetCfgBindingPath *pncbpThis,
                                 INetCfgBindingPath *pncbpMatch,
                                 INetCfgComponent *pnccThisOwner,
                                 HTREEITEM htiMatchItem,
                                 TREE_ITEM_DATA *ptid);
    HRESULT HrHandleTopLevel(INetCfgBindingPath *pncbpSub);
    HRESULT HrComponentIsHidden(INetCfgBindingPath *pncbp, DWORD iComp);
    HTREEITEM HtiAddTreeViewItem(INetCfgComponent * pnccOwner,
                                 HTREEITEM htiParent);
    VOID AssociateBinding(INetCfgBindingPath *pncbpThis, HTREEITEM hti,
                          DWORD dwFlags);
    HTREEITEM HtiIsSubItem(INetCfgComponent *pncc, HTREEITEM hti);
    VOID MoveAdapterBindings(INetCfgComponent *pnccSrc,
                             INetCfgComponent *pnccDst,
                             MAB_DIRECTION mabDir);
    LRESULT OnClickOrDoubleClick(int idCtrl, LPNMHDR pnmh, BOOL fDoubleClick);
};

DWORD
GetDepthSpecialCase (
    INetCfgBindingPath* pPath);

class CSortableBindPath
{
public:
    CSortableBindPath()
    {
        AssertSzH(FALSE,"Don't use this constructor!");
    }

    CSortableBindPath(INetCfgBindingPath *pncbp)
    {
        m_pncbp = pncbp;
    }

    bool operator<(const CSortableBindPath &refsbp) const;

    VOID GetDepth(DWORD *pdwDepth) const
    {
        *pdwDepth = GetDepthSpecialCase (m_pncbp);
    }

    INetCfgBindingPath *GetPath() const
    {
        return m_pncbp;
    }

private:
    INetCfgBindingPath *    m_pncbp;
};

class CIterTreeView
{
public:
    CIterTreeView(HWND hwndTV)
    {
        m_hwndTV = hwndTV;
        Reset();
    }

    HTREEITEM HtiNext();
    VOID Reset()
    {
        HTREEITEM   hti;

        EraseAndDeleteAll();
        hti = TreeView_GetRoot(m_hwndTV);
        if (hti)
        {
            HTREEITEMP  htip = {hti};
            m_stackHti.push_front(htip);
        }
    }

    HTREEITEM Front()
    {
        HTREEITEMP htip;

        if (m_stackHti.empty())
        {
            return NULL;
        }

        htip = m_stackHti.front();
        return htip.hti;
    }

    VOID PopAndDelete()
    {
        m_stackHti.pop_front();
    }

    VOID PushAndAlloc(HTREEITEM hti)
    {
        AssertSzH(hti, "Pushing NULL? Shame on you!");

        HTREEITEMP htip = {hti};
        m_stackHti.push_front(htip);
    }

    VOID EraseAndDeleteAll()
    {
        while (!m_stackHti.empty())
        {
            PopAndDelete();
        }
    }

private:
    HWND        m_hwndTV;
    HTI_LIST    m_stackHti;
};

BOOL FIsHidden(INetCfgComponent *pncc);
BOOL FDontExposeLower(INetCfgComponent *pncc);
VOID AddToListIfNotAlreadyAdded(BPIP_LIST &bpipList, BIND_PATH_INFO *pbpi);
VOID FreeBindPathInfoList(BPIP_LIST &listbpip);
HRESULT HrCountDontExposeLower(INetCfgBindingPath *pncbp, DWORD *pcItems);
BOOL FEqualComponents(INetCfgComponent *pnccA, INetCfgComponent *pnccB);
VOID ChangeTreeItemParam(HWND hwndTV,  HTREEITEM hitem, LPARAM lparam);
BIND_PATH_INFO *BpiFindBindPathInList(INetCfgBindingPath *pncbp,
                                      BPIP_LIST &listBpip);
VOID ChangeListItemParam(HWND hwndLV, INT iItem, LPARAM lParam);

#ifdef ENABLETRACE
VOID DbgDumpBindPath(INetCfgBindingPath *pncbp);
VOID DbgDumpTreeViewItem(HWND hwndTV, HTREEITEM hti);
#else
#define DbgDumpBindPath(x)
#define DbgDumpTreeViewItem(x,y)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\samples\muxim\virtual.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992-2001.
//
//  File:       V I R T U A L . H
//
//  Contents:   Header file for virtual miniport class.
//
//  Notes:
//
//  Author:     Alok Sinha
//
//----------------------------------------------------------------------------

#ifndef VIRTUAL_H_INCLUDED

#define VIRTUAL_H_INCLUDE

#include <windows.h>
#include <stdio.h>
#include "netcfgn.h"

#include "common.h"

//
// Class to represent a virtual miniport created by IM driver.
//

class CMuxVirtualMiniport
{
    //
    // Private member variables.
    //

    INetCfg   *m_pnc;
    GUID      m_guidAdapter;
    GUID      m_guidMiniport;

    //
    // Public members.
    //

    public:

    CMuxVirtualMiniport(INetCfg *m_pnc,
                        GUID    *pguidMiniport,
                        GUID    *guidAdapter);

    virtual ~CMuxVirtualMiniport(VOID);
                                 
    HRESULT LoadConfiguration(VOID);

    VOID    GetAdapterGUID (GUID *);

    VOID    GetMiniportGUID (GUID *);

    HRESULT Install (VOID);

    HRESULT DeInstall (VOID);

    HRESULT ApplyRegistryChanges (ConfigAction eApplyAction);

    HRESULT ApplyPnpChanges (INetCfgPnpReconfigCallback *pfCallback,
                             ConfigAction eApplyAction);
};

#endif // VIRTUAL_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\shell\advcfg\aclist.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       A C L I S T . C P P
//
//  Contents:   Functions related to listview control in adavnced
//              configuration dialog.
//
//  Notes:
//
//  Author:     danielwe   3 Dec 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "acbind.h"
#include "acsheet.h"
#include "lancmn.h"
#include "ncnetcfg.h"
#include "ncnetcon.h"
#include "ncsetup.h"
#include "foldinc.h"

extern const WCHAR c_szInfId_MS_TCPIP[];


HRESULT CBindingsDlg::HrGetAdapters(INetCfgComponent *pncc,
                                    NCC_LIST *plistNcc)
{
    Assert(pncc);

    HRESULT                 hr = S_OK;

    CIterNetCfgBindingPath  ncbpIter(pncc);
    INetCfgBindingPath *    pncbp;
    NCC_LIST                listncc;
    INetCfgComponent *      pnccLast;

    while (SUCCEEDED(hr) && S_OK == (hr = ncbpIter.HrNext(&pncbp)))
    {
        hr = HrGetLastComponentAndInterface(pncbp, &pnccLast, NULL);
        if (SUCCEEDED(hr))
        {
            hr = HrIsConnection(pnccLast);
            if (S_OK == hr)
            {
                plistNcc->push_back(pnccLast);
            }
            else
            {
                // Don't need it anymore so release it
                ReleaseObj(pnccLast);
            }
        }

        ReleaseObj(pncbp);
    }

    if (SUCCEEDED(hr))
    {
        if (plistNcc->empty())
        {
            hr = S_FALSE;
        }
        else
        {
            plistNcc->unique();
            hr = S_OK;
        }
    }

    TraceError("CBindingsDlg::HrGetAdapters", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::HrBuildAdapterList
//
//  Purpose:    Builds the list of adapters displayed in the listview control
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK if succeeded, OLE or Win32 error otherwise
//
//  Author:     danielwe   19 Nov 1997
//
//  Notes:
//
HRESULT CBindingsDlg::HrBuildAdapterList()
{
    HRESULT                 hr = S_OK;
    INetCfgComponent *      pncc = NULL;
    SP_CLASSIMAGELIST_DATA  cid;
    INT                     nIndexWan;
    INT                     ipos = 0;
    NCC_LIST                listncc;

    Assert(m_pnc);

    // Get the class image list structure
    hr = HrSetupDiGetClassImageList(&cid);
    if (SUCCEEDED(hr))
    {
        // Get the modem class image list index
        hr = HrSetupDiGetClassImageIndex(&cid,
                                         const_cast<LPGUID>(&GUID_DEVCLASS_MODEM),
                                         &nIndexWan);
    }

    if (SUCCEEDED(hr))
    {
        hr = m_pnc->FindComponent(c_szInfId_MS_TCPIP, &pncc);
        if (S_FALSE == hr)
        {
            // Hmm, TCP/IP is not installed. Better look for a protocol that
            // has bindings to an adapter.
            //
            CIterNetCfgComponent    nccIter(m_pnc, &GUID_DEVCLASS_NETTRANS);

            while (SUCCEEDED(hr) && S_OK == (hr = nccIter.HrNext(&pncc)))
            {
                hr = HrGetAdapters(pncc, &listncc);
                ReleaseObj(pncc);
                if (S_OK == hr)
                {
                    // We found one! Yay.
                    break;
                }
            }
        }
        else if (S_OK == hr)
        {
            hr = HrGetAdapters(pncc, &listncc);
            ReleaseObj(pncc);
        }
    }

    if (S_OK == hr)
    {
        // Iterate all LAN connections
        //
        INetConnectionManager * pconMan;

        HRESULT hr = HrCreateInstance(
            CLSID_LanConnectionManager,
            CLSCTX_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
            &pconMan);

        TraceHr(ttidError, FAL, hr, FALSE, "HrCreateInstance");

        if (SUCCEEDED(hr))
        {
            NCC_LIST::iterator      iterlist;
            INetCfgComponent *      pnccToAdd;

            for (iterlist = listncc.begin();
                 iterlist != listncc.end();
                 iterlist++)
            {
                CIterNetCon         ncIter(pconMan, NCME_DEFAULT);
                INetConnection *    pconn;
                GUID                guidAdd;
                BOOL                fAdded = FALSE;

                pnccToAdd = *iterlist;
                (VOID) pnccToAdd->GetInstanceGuid(&guidAdd);

                while (SUCCEEDED(hr) && !fAdded &&
                       (S_OK == (ncIter.HrNext(&pconn))))
                {
                    // Compare guid of connection's adapter to this
                    // one. If we have a match, add it to the listview
                    if (FPconnEqualGuid(pconn, guidAdd))
                    {
                        NETCON_PROPERTIES* pProps;
                        hr = pconn->GetProperties(&pProps);
                        if (SUCCEEDED(hr))
                        {
                            AddListViewItem(pnccToAdd, ipos, m_nIndexLan,
                                            pProps->pszwName);
                            fAdded = TRUE;
                            ipos++;

                            FreeNetconProperties(pProps);
                        }
                    }

                    ReleaseObj(pconn);
                }

#if DBG
                if (!fAdded)
                {
                    WCHAR   szwGuid[64];

                    StringFromGUID2(guidAdd, szwGuid, sizeof(szwGuid));
                    TraceTag(ttidAdvCfg, "Never added item %S for this "
                             "connection!", szwGuid);
                }
#endif

                // Balance AddRef from HrGetLastComponentAndInterface()
                ReleaseObj(pnccToAdd);
            }

            ReleaseObj(pconMan);
        }

        listncc.erase(listncc.begin(), listncc.end());
    }

    // Display WAN Adapter Bindings
    if (SUCCEEDED(hr))
    {
        GetWanOrdering();
        AddListViewItem(NULL, m_fWanBindingsFirst ? 0 : ipos, nIndexWan,
                        SzLoadIds(IDS_ADVCFG_WAN_ADAPTERS));
    }

    (void) HrSetupDiDestroyClassImageList(&cid);

    if (SUCCEEDED(hr))
    {
        SetAdapterButtons();
        ListView_SetColumnWidth(m_hwndLV, 0, LVSCW_AUTOSIZE);
        hr = S_OK;
    }

    // Select first item
    ListView_SetItemState(m_hwndLV, 0, LVIS_FOCUSED | LVIS_SELECTED,
                          LVIS_FOCUSED | LVIS_SELECTED);

    TraceError("CBindingsDlg::HrBuildAdapterList", hr);
    return hr;
}

VOID CBindingsDlg::GetWanOrdering()
{
    INetCfgSpecialCase * pncsc = NULL;

    if (SUCCEEDED(m_pnc->QueryInterface(IID_INetCfgSpecialCase,
                                        reinterpret_cast<LPVOID*>(&pncsc))))
    {
        (VOID) pncsc->GetWanAdaptersFirst(&m_fWanBindingsFirst);
        ReleaseObj(pncsc);
    }
}

VOID CBindingsDlg::SetWanOrdering()
{
    INetCfgSpecialCase * pncsc = NULL;

    if (SUCCEEDED(m_pnc->QueryInterface(IID_INetCfgSpecialCase,
                                        reinterpret_cast<LPVOID*>(&pncsc))))
    {
        (VOID) pncsc->SetWanAdaptersFirst(m_fWanBindingsFirst);
        ReleaseObj(pncsc);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::AddListViewItem
//
//  Purpose:    Adds the given component to the listview
//
//  Arguments:
//      pncc        [in] Component to be added. If NULL, then this is the
//                       special WAN adapter component.
//      ipos        [in] Position at which to add
//      nIndex      [in] Index of icon into system image list
//      pszConnName [in] Connection name
//
//  Returns:    Nothing
//
//  Author:     danielwe   3 Dec 1997
//
//  Notes:
//
VOID CBindingsDlg::AddListViewItem(INetCfgComponent *pncc, INT ipos,
                                   INT nIndex, PCWSTR pszConnName)
{
    LV_ITEM     lvi = {0};

    lvi.mask = LVIF_TEXT | LVIF_IMAGE |
               LVIF_STATE | LVIF_PARAM;

    lvi.iImage = nIndex;

    lvi.iItem = ipos;
    AddRefObj(pncc);
    lvi.lParam = reinterpret_cast<LPARAM>(pncc);
    lvi.pszText = const_cast<PWSTR>(pszConnName);

    ListView_InsertItem(m_hwndLV, &lvi);
}

//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::OnListItemChanged
//
//  Purpose:    Called when the LVN_ITEMCHANGED message is received
//
//  Arguments:
//      idCtrl   []
//      pnmh     []
//      bHandled []
//
//  Returns:
//
//  Author:     danielwe   19 Nov 1997
//
//  Notes:
//
LRESULT CBindingsDlg::OnListItemChanged(int idCtrl, LPNMHDR pnmh,
                                      BOOL& bHandled)
{
    NM_LISTVIEW *   pnmlv = reinterpret_cast<NM_LISTVIEW *>(pnmh);

    Assert(pnmlv);

    // Check if selection changed
    if ((pnmlv->uNewState & LVIS_SELECTED) &&
        (!(pnmlv->uOldState & LVIS_SELECTED)))
    {
        if (pnmlv->iItem != m_iItemSel)
        {
            // Selection changed to different item
            OnAdapterChange(pnmlv->iItem);
            m_iItemSel = pnmlv->iItem;
        }
    }

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::OnListDeleteItem
//
//  Purpose:    Called when the LVN_DELETEITEM message is received.
//
//  Arguments:
//      idCtrl   []
//      pnmh     []
//      bHandled []
//
//  Returns:
//
//  Author:     danielwe   4 Dec 1997
//
//  Notes:
//
LRESULT CBindingsDlg::OnListDeleteItem(int idCtrl, LPNMHDR pnmh,
                                     BOOL& bHandled)
{
    LV_ITEM             lvi = {0};
    INetCfgComponent *  pncc;
    NM_LISTVIEW *       pnmlv = reinterpret_cast<NM_LISTVIEW *>(pnmh);

    Assert(pnmlv);

    lvi.mask = LVIF_PARAM;
    lvi.iItem = pnmlv->iItem;

    ListView_GetItem(m_hwndLV, &lvi);
    pncc = reinterpret_cast<INetCfgComponent *>(lvi.lParam);
    ReleaseObj(pncc);

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::OnAdapterChange
//
//  Purpose:    Handles the selection of a different adapter from the listview
//
//  Arguments:
//      iItem [in]  Item in list that was selected
//
//  Returns:    S_OK if success, OLE or Win32 error otherwise
//
//  Author:     danielwe   19 Nov 1997
//
//  Notes:
//
VOID CBindingsDlg::OnAdapterChange(INT iItem)
{
    LV_ITEM             lvi = {0};
    INetCfgComponent *  pncc;
    PWSTR              szwText;
    WCHAR               szBuffer[256];

    lvi.mask = LVIF_TEXT | LVIF_PARAM;
    lvi.pszText = szBuffer;
    lvi.cchTextMax = celems(szBuffer);
    lvi.iItem = iItem;

    ListView_GetItem(m_hwndLV, &lvi);
    TreeView_DeleteAllItems(m_hwndTV);

    pncc = reinterpret_cast<INetCfgComponent *>(lvi.lParam);
    if (pncc)
    {
        BuildBindingsList(pncc);
        SetCheckboxStates();
    }

    SetAdapterButtons();

    DwFormatStringWithLocalAlloc(SzLoadIds(IDS_BINDINGS_FOR), &szwText,
                                 lvi.pszText);

    BOOL bShouldEnable = TRUE;

    if (!pncc) 
    {
        // If the WAN bindings item is selected, hide and disable the treeview
        bShouldEnable = FALSE;
    }
    else
    {
        // if a LAN item is selected, make sure the treeview is enabled
        GUID guid;
        HRESULT hr = pncc->GetInstanceGuid(&guid);
        if (SUCCEEDED(hr))
        {
            ConnListEntry cle;
            hr = g_ccl.HrFindConnectionByGuid(&guid, cle);
            if (S_FALSE == hr)
            {
                hr = g_ccl.HrRefreshConManEntries();
                if (SUCCEEDED(hr))
                {
                    hr = g_ccl.HrFindConnectionByGuid(&guid, cle);
                }
            }
            
            if (S_OK == hr)
            {
                if ( (NCM_LAN == cle.ccfe.GetNetConMediaType()) &&
                     (cle.ccfe.GetCharacteristics() & NCCF_BRIDGED) )
                {
                    bShouldEnable = FALSE;
                }
            }
        }
    }

    if (bShouldEnable)
    {
        ::ShowWindow(GetDlgItem(IDH_TXT_ADVGFG_BINDINGS), SW_SHOW);
        ::EnableWindow(GetDlgItem(IDH_TXT_ADVGFG_BINDINGS), TRUE);
        ::EnableWindow(GetDlgItem(TVW_Bindings), TRUE);
    }
    else
    {
        
        ::ShowWindow(GetDlgItem(IDH_TXT_ADVGFG_BINDINGS), SW_HIDE);
        ::EnableWindow(GetDlgItem(IDH_TXT_ADVGFG_BINDINGS), FALSE);
        ::EnableWindow(GetDlgItem(TVW_Bindings), FALSE);
    }

    SetDlgItemText(IDH_TXT_ADVGFG_BINDINGS, szwText);
    LocalFree(szwText);
}

//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::OnAdapterUpDown
//
//  Purpose:    Helper function that performs most of the work to move
//              adapter bindings
//
//  Arguments:
//      fUp [in]    TRUE if moving up, FALSE if down
//
//  Returns:    Nothing
//
//  Author:     danielwe   2 Dec 1997
//
//  Notes:
//
VOID CBindingsDlg::OnAdapterUpDown(BOOL fUp)
{
    INetCfgComponent *  pnccSrc;
    INetCfgComponent *  pnccDst;
    INT                 iSel;
    INT                 iDst;
    LV_ITEM             lvi = {0};
    WCHAR               szBuffer[256];

    iSel = ListView_GetNextItem(m_hwndLV, -1, LVNI_SELECTED);

    AssertSz(iSel != -1, "No Selection?!?!?");

    lvi.mask = LVIF_PARAM | LVIF_TEXT | LVIF_IMAGE | LVIF_STATE;
    lvi.pszText = szBuffer;
    lvi.cchTextMax = celems(szBuffer);
    lvi.iItem = iSel;

    ListView_GetItem(m_hwndLV, &lvi);
    pnccSrc = reinterpret_cast<INetCfgComponent *>(lvi.lParam);

    if (pnccSrc)
    {
        // Normal LAN adapter
        iDst = ListView_GetNextItem(m_hwndLV, iSel,
                                    fUp ? LVNI_ABOVE : LVNI_BELOW);

        AssertSz(iDst != -1, "No item above or below!");
    }
    else
    {
        m_fWanBindingsFirst = fUp;

        // WAN binding item
        iDst = fUp ? 0 : ListView_GetItemCount(m_hwndLV) - 1;
    }

    lvi.iItem = iDst;

    ListView_GetItem(m_hwndLV, &lvi);
    pnccDst = reinterpret_cast<INetCfgComponent *>(lvi.lParam);
    AssertSz(pnccDst, "Dest Component is NULL!?!?");

    if (pnccSrc)
    {
        MoveAdapterBindings(pnccSrc, pnccDst, fUp ? MAB_UP : MAB_DOWN);
    }
    else
    {
        SetWanOrdering();
    }

    // Delete source item and move to where dest item is

    // Note: (danielwe) 2 Dec 1997: For LVN_DELETEITEM handler, make sure
    // refcount remains the same

    // Get item we are moving
    lvi.iItem = iSel;
    ListView_GetItem(m_hwndLV, &lvi);

    // Make the lParam of the item NULL so we don't release it
    ChangeListItemParam(m_hwndLV, iSel, NULL);
    ListView_DeleteItem(m_hwndLV, iSel);

    // Change its index
    lvi.iItem = iDst;
    lvi.state = lvi.stateMask = 0;

    // And insert in new location
    int iItem = ListView_InsertItem(m_hwndLV, &lvi);

    if (-1 != iItem)
    {
        ListView_SetItemState(m_hwndLV, iItem, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
    }
    
    // Reset cached selection
    m_iItemSel = iDst;

    SetAdapterButtons();
    ::SetFocus(m_hwndLV);
}

//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::OnAdapterUp
//
//  Purpose:    Called when the adapter UP arrow button is pressed
//
//  Arguments:
//      wNotifyCode []
//      wID         []
//      hWndCtl     []
//      bHandled    []
//
//  Returns:
//
//  Author:     danielwe   2 Dec 1997
//
//  Notes:
//
LRESULT CBindingsDlg::OnAdapterUp(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                                BOOL& bHandled)
{
    OnAdapterUpDown(TRUE);

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::OnAdapterDown
//
//  Purpose:    Called when the adapter DOWN button is pressed
//
//  Arguments:
//      wNotifyCode []
//      wID         []
//      hWndCtl     []
//      bHandled    []
//
//  Returns:
//
//  Author:     danielwe   2 Dec 1997
//
//  Notes:
//
LRESULT CBindingsDlg::OnAdapterDown(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                                  BOOL& bHandled)
{
    OnAdapterUpDown(FALSE);

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::FIsWanBinding
//
//  Purpose:    Determines if the given list view item is the special WAN
//              adapter ordering item.
//
//  Arguments:
//      iItem [in]  List view item to test
//
//  Returns:    TRUE if this is the WAN adapter ordering item or FALSE if not
//
//  Author:     danielwe   21 Jul 1998
//
//  Notes:
//
BOOL CBindingsDlg::FIsWanBinding(INT iItem)
{
    if (iItem != -1)
    {
        LV_ITEM     lvi = {0};

        lvi.mask = LVIF_PARAM;
        lvi.iItem = iItem;

        ListView_GetItem(m_hwndLV, &lvi);

        return !lvi.lParam;
    }
    else
    {
        // Invalid item can't be the WAN binding
        return FALSE;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::SetAdapterButtons
//
//  Purpose:    Sets the state of the up and down arrow buttons for the
//              adapters listview
//
//  Arguments:
//      (none)
//
//  Returns:    Nothing
//
//  Author:     danielwe   19 Nov 1997
//
//  Notes:
//
VOID CBindingsDlg::SetAdapterButtons()
{
    INT iItemAbove = -1;
    INT iItemBelow = -1;
    INT iItem;

    iItem = ListView_GetNextItem(m_hwndLV, -1, LVNI_SELECTED);

    if (ListView_GetItemCount(m_hwndLV) > 1)
    {
        iItemAbove = ListView_GetNextItem(m_hwndLV, iItem, LVNI_ABOVE);
        iItemBelow = ListView_GetNextItem(m_hwndLV, iItem, LVNI_BELOW);
        if (FIsWanBinding(iItemAbove))
        {
            iItemAbove = -1;
            AssertSz(ListView_GetNextItem(m_hwndLV, iItemAbove, LVNI_ABOVE) == -1,
                     "Item above the WAN binding??");
        }
        else if (FIsWanBinding(iItemBelow))
        {
            iItemBelow = -1;
            AssertSz(ListView_GetNextItem(m_hwndLV, iItemBelow, LVNI_BELOW) == -1,
                     "Item below the WAN binding??");
        }
    }

    ::EnableWindow(GetDlgItem(PSB_Adapter_Up), (iItemAbove != -1));
    ::EnableWindow(GetDlgItem(PSB_Adapter_Down), (iItemBelow != -1));
}

static const GUID * c_aguidClass[] =
{
    &GUID_DEVCLASS_NETTRANS,
    &GUID_DEVCLASS_NETSERVICE,
    &GUID_DEVCLASS_NETCLIENT,
};
static const DWORD c_cguidClass = celems(c_aguidClass);

//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::MoveAdapterBindings
//
//  Purpose:    Moves all bindings for the given source and destination
//              adapters in the given direction
//
//  Arguments:
//      pnccSrc [in]    Adapter for which bindings are being moved
//      pnccDst [in]    Adapter to which bindings are being moved before or
//                      after
//      mabDir  [in]    Direction to move. Either MAB_UP or MAB_DOWN
//
//  Returns:    Nothing
//
//  Author:     danielwe   2 Dec 1997
//
//  Notes:
//
VOID CBindingsDlg::MoveAdapterBindings(INetCfgComponent *pnccSrc,
                                     INetCfgComponent *pnccDst,
                                     MAB_DIRECTION mabDir)
{
    HRESULT     hr = S_OK;
    DWORD       iguid;

    AssertSz(pnccDst, "Destination component cannot be NULL!");

    for (iguid = 0; iguid < c_cguidClass; iguid++)
    {
        CIterNetCfgComponent    nccIter(m_pnc, c_aguidClass[iguid]);
        INetCfgComponent *      pncc;

        while (SUCCEEDED(hr) && S_OK == (hr = nccIter.HrNext(&pncc)))
        {
            CIterNetCfgBindingPath  ncbpIter(pncc);
            INetCfgBindingPath *    pncbp;
            INetCfgBindingPath *    pncbpTarget = NULL;
            BOOL                    fAssign = TRUE;
            NCBP_LIST               listbp;
            INetCfgComponent *      pnccLast;

            while (SUCCEEDED(hr) && S_OK == (hr = ncbpIter.HrNext(&pncbp)))
            {
                hr = HrGetLastComponentAndInterface(pncbp, &pnccLast, NULL);
                if (SUCCEEDED(hr))
                {
                    if (pnccLast == pnccDst)
                    {
                        if ((mabDir == MAB_UP) && fAssign)
                        {
                            AddRefObj(pncbpTarget = pncbp);
                            fAssign = FALSE;
                        }
                        else if (mabDir == MAB_DOWN)
                        {
                            ReleaseObj(pncbpTarget);
                            AddRefObj(pncbpTarget = pncbp);
                        }
                    }
                    else if (pnccLast == pnccSrc)
                    {
                        AddRefObj(pncbp);
                        listbp.push_back(pncbp);
                    }

                    ReleaseObj(pnccLast);
                }

                ReleaseObj(pncbp);
            }

            if (SUCCEEDED(hr))
            {
                NCBP_LIST::iterator         iterbp;
                INetCfgComponentBindings *  pnccb;

                hr = pncc->QueryInterface(IID_INetCfgComponentBindings,
                                          reinterpret_cast<LPVOID *>(&pnccb));
                if (SUCCEEDED(hr))
                {
                    for (iterbp = listbp.begin();
                         (iterbp != listbp.end()) && SUCCEEDED(hr);
                         iterbp++)
                    {
                        if (mabDir == MAB_UP)
                        {
                            TraceTag(ttidAdvCfg, "Moving...");
                            DbgDumpBindPath(*iterbp);
                            // Move this binding path before the tagret
                            hr = pnccb->MoveBefore(*iterbp, pncbpTarget);
                            TraceTag(ttidAdvCfg, "before...");
                            DbgDumpBindPath(pncbpTarget);
                        }
                        else
                        {
                            TraceTag(ttidAdvCfg, "Moving...");
                            DbgDumpBindPath(*iterbp);
                            // Move this binding path after the tagret
                            hr = pnccb->MoveAfter(*iterbp, pncbpTarget);
                            TraceTag(ttidAdvCfg, "after...");
                            DbgDumpBindPath(pncbpTarget);
                        }

                        if (mabDir == MAB_DOWN)
                        {
                            // In the down direction ONLY, from now on, the
                            // target becomes the last binding we moved. This
                            // keeps the binding order intact because moving
                            // several bindings after the same target
                            // effectively reverses their order.
                            //

                            // Release old target
                            ReleaseObj(pncbpTarget);

                            // AddRef new target
                            AddRefObj(pncbpTarget = *iterbp);
                        }

                        ReleaseObj(*iterbp);
                    }

                    ReleaseObj(pnccb);
                }

                listbp.erase(listbp.begin(), listbp.end());
            }

            ReleaseObj(pncbpTarget);
            ReleaseObj(pncc);
        }
    }

    if (SUCCEEDED(hr))
    {
        hr = S_OK;
    }

    TraceError("CBindingsDlg::MoveAdapterBindings", hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   ChangeListItemParam
//
//  Purpose:    Changes the lParam member of the given item to the given
//              value.
//
//  Arguments:
//      hwndLV [in]     HWND of list view
//      iItem  [in]     Item to modify
//      lParam [in]     New lParam for item
//
//  Returns:    Nothing
//
//  Author:     danielwe   4 Dec 1997
//
//  Notes:
//
VOID ChangeListItemParam(HWND hwndLV, INT iItem, LPARAM lParam)
{
    LV_ITEM     lvi = {0};

    lvi.mask = LVIF_PARAM;
    lvi.iItem = iItem;
    lvi.lParam = lParam;

    ListView_SetItem(hwndLV, &lvi);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\samples\muxim\virtual.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992-2001.
//
//  File:       V I R T U A L . C P P
//
//  Contents:   Virtual miniport class definition.
//
//  Notes:
//
//  Author:     Alok Sinha
//----------------------------------------------------------------------------

#include "virtual.h"
#include "common.h"

//+---------------------------------------------------------------------------
//
// Function:  CMuxVirtualMiniport::CMuxVirtualMiniport
//
// Purpose:   Constructor for class CMuxVirtualMiniport
//
// Arguments: None
//
// Returns:
//
// Notes:
//

CMuxVirtualMiniport::CMuxVirtualMiniport(INetCfg *pnc,
                                         GUID    *pguidMiniport,
                                         GUID    *pguidAdapter)
{
    TraceMsg( L"-->CMuxVirtualMiniport::CMuxVirtualMiniport(Constructor).\n" );

    m_pnc = pnc;
    m_pnc->AddRef();

    CopyMemory( &m_guidAdapter,
                pguidAdapter,
                sizeof(GUID) );

    if ( pguidMiniport ) {

        CopyMemory( &m_guidMiniport,
                    pguidMiniport,
                    sizeof(GUID) );

    }
    else {

        ZeroMemory( &m_guidMiniport,
                    sizeof(GUID) );
    }

    TraceMsg( L"<--CMuxVirtualMiniport::CMuxVirtualMiniport(Constructor).\n" );
}

//+---------------------------------------------------------------------------
//
// Function:  CMuxVirtualMiniport::~CMuxVirtualMiniport
//
// Purpose:   Destructor for class CMuxVirtualMiniport
//
// Arguments: None
//
// Returns:
//
// Notes:
//

CMuxVirtualMiniport::~CMuxVirtualMiniport(VOID)
{
    TraceMsg( L"-->CMuxVirtualMiniport::~CMuxVirtualMiniport(Destructor).\n" );

    ReleaseObj( m_pnc );

    TraceMsg( L"<--CMuxVirtualMiniport::~CMuxVirtualMiniport(Destructor).\n" );

}

//+---------------------------------------------------------------------------
//
// Function:  CMuxVirtualMiniport::LoadConfiguration
//
// Purpose:   Load miniport configuration from the registry.
//
// Arguments: None
//
// Returns: S_OK on success, otherwise an error code.
//
// Notes:
//

HRESULT CMuxVirtualMiniport::LoadConfiguration(VOID)
{
    TraceMsg( L"-->CMuxVirtualMiniport::LoadConfiguration.\n" );

    TraceMsg( L"<--CMuxVirtualMiniport::LoadConfiguration(HRESULT = %x).\n",
            S_OK );

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Function:  CMuxVirtualMiniport::GetAdapterGUID
//
// Purpose:   Returns the adapter GUID.
//
// Arguments:
//          OUT pguidAdapter: GUID of the adapter returned.
//
// Returns: None.
//
// Notes:
//

VOID CMuxVirtualMiniport::GetAdapterGUID (GUID *pguidAdapter)
{
    TraceMsg( L"-->CMuxVirtualMiniport::GetAdapterGUID.\n" );

    CopyMemory( pguidAdapter,
                &m_guidAdapter,
                sizeof(GUID) );

    TraceMsg( L"<--CMuxVirtualMiniport::GetAdapterGUID.\n" );
}

//+---------------------------------------------------------------------------
//
// Function:  CMuxVirtualMiniport::GetMiniportGUID
//
// Purpose:   Returns the miniport GUID.
//
// Arguments:
//          OUT pguidMiniport: GUID of the miniport returned.
//
// Returns: None.
//
// Notes:
//

VOID CMuxVirtualMiniport::GetMiniportGUID (GUID *pguidMiniport)
{
    TraceMsg( L"-->CMuxVirtualMiniport::GetMiniportGUID.\n" );

    CopyMemory( pguidMiniport,
              &m_guidMiniport,
              sizeof(GUID) );

    TraceMsg( L"<--CMuxVirtualMiniport::GetMiniportGUID.\n" );
}

//+---------------------------------------------------------------------------
//
// Function:  CMuxVirtualMiniport::Install
//
// Purpose:   Installs a virtual miniport.
//
// Arguments: None
//
// Returns: S_OK on success, otherwise an error code.
//
// Notes:
//

HRESULT CMuxVirtualMiniport::Install (VOID)
{
    INetCfgClass       *pncClass;
    INetCfgClassSetup  *pncClassSetup;
    INetCfgComponent   *pnccMiniport;
    HRESULT            hr;

    TraceMsg( L"-->CMuxVirtualMiniport::Install.\n" );

    hr = m_pnc->QueryNetCfgClass( &GUID_DEVCLASS_NET,
                                  IID_INetCfgClass,
                                  (void **)&pncClass );
    if ( hr == S_OK ) {

        hr = pncClass->QueryInterface( IID_INetCfgClassSetup,
                                       (void **)&pncClassSetup );
        if ( hr == S_OK ) {

            hr = pncClassSetup->Install( c_szMuxMiniport,
                                         NULL,
                                         0,
                                         0,
                                         NULL,
                                         NULL,
                                         &pnccMiniport );
            if ( hr == S_OK ) {

                hr = pnccMiniport->GetInstanceGuid( &m_guidMiniport );

                if ( hr != S_OK ) {

                    TraceMsg( L"   Failed to get the instance guid, uninstalling "
                              L" the miniport.\n" );

                    pncClassSetup->DeInstall( pnccMiniport,
                                              NULL,
                                              NULL );
                }

                ReleaseObj( pnccMiniport );
            }
            else {

                TraceMsg( L"   Failed to install the miniport.\n" );
            }

            ReleaseObj( pncClassSetup );
        }
        else {

            TraceMsg( L"   QueryInterface failed.\n" );
        }

        ReleaseObj( pncClass );
    }
    else {

     TraceMsg( L"   QueryNetCfgClass failed.\n" );
    }

    TraceMsg( L"<--CMuxVirtualMiniport::Install(HRESULT = %x).\n",
            hr );

    return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  CMuxVirtualMiniport::DeInstall
//
// Purpose:   Uninstalls the virtual miniport.
//
// Arguments: None
//
// Returns: S_OK on success, otherwise an error code.
//
// Notes:
//

HRESULT CMuxVirtualMiniport::DeInstall (VOID)
{
    INetCfgClass       *pncClass;
    INetCfgClassSetup  *pncClassSetup;
    INetCfgComponent   *pnccMiniport;
    HRESULT            hr;

    TraceMsg( L"-->CMuxVirtualMiniport::DeInstall.\n" );

    hr = m_pnc->QueryNetCfgClass( &GUID_DEVCLASS_NET,
                                  IID_INetCfgClass,
                                  (void **)&pncClass );
    if ( hr == S_OK ) {

        hr = pncClass->QueryInterface( IID_INetCfgClassSetup,
                                       (void **)&pncClassSetup );
        if ( hr == S_OK ) {

            hr = HrFindInstance( m_pnc,
                                 m_guidMiniport,
                                 &pnccMiniport );

            if ( hr == S_OK ) {

                TraceMsg( L"   Found the miniport instance to uninstall.\n" );

                hr = pncClassSetup->DeInstall( pnccMiniport,
                                               NULL,
                                               NULL );
                ReleaseObj( pnccMiniport );
            }
            else {
                TraceMsg( L"   Didn't find the miniport instance to uninstall.\n" );
            }

            ReleaseObj( pncClassSetup );
        }
        else {

            TraceMsg( L"   QueryInterface failed.\n" );
        }

        ReleaseObj( pncClass );
    }
    else {

        TraceMsg( L"   QueryNetCfgClass failed.\n" );
    }

    TraceMsg( L"<--CMuxVirtualMiniport::DeInstall(HRESULT = %x).\n",
              hr );

    return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  CMuxVirtualMiniport::ApplyRegistryChanges
//
// Purpose:   Store the changes in the registry.
//
// Arguments:
//            IN eApplyAction: Action performed.
//
// Returns: S_OK on success, otherwise an error code.
//
// Notes:
//

HRESULT CMuxVirtualMiniport::ApplyRegistryChanges(ConfigAction eApplyAction)
{
    HKEY                    hkeyAdapterGuid;
    WCHAR                   szAdapterGuid[MAX_PATH+1];
    WCHAR                   szAdapterGuidKey[MAX_PATH+1];
    WCHAR                   szMiniportGuid[MAX_PATH+1];
    LPWSTR                  lpDevice;
    LONG                    lResult = 0;

    TraceMsg( L"-->CMuxVirtualMiniport::ApplyRegistryChanges.\n" );

    switch( eApplyAction ) {

        case eActAdd:         // Virtual miniport added.

            StringFromGUID2( m_guidAdapter,
                             szAdapterGuid,
                             MAX_PATH+1 );

            swprintf( szAdapterGuidKey,
                      L"%s\\%s",
                      c_szAdapterList,
                      szAdapterGuid );

            lResult = RegCreateKeyExW( HKEY_LOCAL_MACHINE,
                                       szAdapterGuidKey,
                                       0,
                                       NULL,
                                       REG_OPTION_NON_VOLATILE,
                                       KEY_ALL_ACCESS,
                                       NULL,
                                       &hkeyAdapterGuid,
                                       NULL);


            if ( lResult == ERROR_SUCCESS ) {

                StringFromGUID2( m_guidMiniport,
                                 szMiniportGuid,
                                 MAX_PATH+1 );

                lpDevice = AddDevicePrefix( szMiniportGuid );

                if ( lpDevice ) {

#ifndef PASSTHRU_NOTIFY

                    lResult = AddToMultiSzValue( hkeyAdapterGuid,
                                                 lpDevice );
#else

                    lResult = RegSetValueExW( hkeyAdapterGuid,
                                              c_szUpperBindings,
                                              0,
                                              REG_SZ,
                                              (LPBYTE)lpDevice,
                                              (wcslen(lpDevice) + 1) *
                                              sizeof(WCHAR) );


#endif

                    if ( lResult != ERROR_SUCCESS ) {

                        TraceMsg( L"   Failed to save %s at %s\\%s.\n",
                                  lpDevice,
                                  szAdapterGuidKey,
                                  c_szUpperBindings );

                    }

                    free( lpDevice );
                }
                else {
                    lResult = ERROR_NOT_ENOUGH_MEMORY;
                }

                RegCloseKey( hkeyAdapterGuid );
            }
            else {
                TraceMsg( L"   Failed to open the registry key: %s.\n",
                          szAdapterGuidKey );
            }
            break;

        case eActRemove:                  // Virtual miniport removed.

            StringFromGUID2( m_guidAdapter,
                             szAdapterGuid,
                             MAX_PATH+1 );

            swprintf( szAdapterGuidKey,
                      L"%s\\%s",
                      c_szAdapterList,
                      szAdapterGuid );

            lResult = RegCreateKeyExW( HKEY_LOCAL_MACHINE,
                                        szAdapterGuidKey,
                                        0,
                                        NULL,
                                        REG_OPTION_NON_VOLATILE,
                                        KEY_ALL_ACCESS,
                                        NULL,
                                        &hkeyAdapterGuid,
                                        NULL);


            if ( lResult == ERROR_SUCCESS ) {

                StringFromGUID2( m_guidMiniport,
                                 szMiniportGuid,
                                 MAX_PATH+1 );

                lpDevice = AddDevicePrefix( szMiniportGuid );
                TraceMsg( L"   Deleting %s at %s.\n",
                          lpDevice,
                          szAdapterGuidKey );

                if ( lpDevice ) {

#ifndef PASSTHRU_NOTIFY

                    lResult = DeleteFromMultiSzValue( hkeyAdapterGuid,
                                                      lpDevice );
#else

                    lResult = RegDeleteValueW( hkeyAdapterGuid,
                                               c_szUpperBindings );
#endif

                    if ( lResult != ERROR_SUCCESS ) {

                        TraceMsg( L"   Failed to delete %s at %s\\%s.\n",
                                  lpDevice,
                                  szAdapterGuidKey,
                                  c_szUpperBindings );

                    }

                    free( lpDevice );
                }

                RegCloseKey( hkeyAdapterGuid );
            }
            else {
                TraceMsg( L"   Failed to open the registry key: %s.\n",
                          szAdapterGuidKey );
            }
    }

    TraceMsg( L"<--CMuxVirtualMiniport::ApplyRegistryChanges(HRESULT = %x).\n",
              HRESULT_FROM_WIN32(lResult) );

    return HRESULT_FROM_WIN32(lResult);
}

//+---------------------------------------------------------------------------
//
// Function:  CMuxVirtualMiniport::ApplyPnpChanges
//
// Purpose:   
//
// Arguments:
//            IN eApplyAction: Action performed.
//
// Returns: S_OK on success, otherwise an error code.
//
// Notes:
//

HRESULT CMuxVirtualMiniport::ApplyPnpChanges
                                 (INetCfgPnpReconfigCallback *pfCallback,
                                  ConfigAction eApplyAction)
{
    TraceMsg( L"-->CMuxVirtualMiniport::ApplyPnpChanges.\n" );

    TraceMsg( L"<--CMuxVirtualMiniport::ApplyPnpChanges(HRESULT = %x).\n",
            S_OK );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\shell\advcfg\acsheet.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:
//
//  Contents:   A C S H E E T . C P P
//
//  Notes:      Advanced Configuration property sheet code
//
//  Author:     danielwe   14 Jul 1998
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "acsheet.h"
#include "acbind.h"
#include "netcfgx.h"
#include "order.h"


const INT c_cmaxPages = 3;

//+---------------------------------------------------------------------------
//
//  Member:     HrGetINetCfg
//
//  Purpose:    Obtains the INetCfg with lock
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK if success, OLE or Win32 error otherwise
//
//  Author:     danielwe   3 Dec 1997
//
//  Notes:
//
HRESULT HrGetINetCfg(HWND hwndParent, INetCfg **ppnc, INetCfgLock **ppnclock)
{
    HRESULT         hr = S_OK;
    INetCfg *       pnc = NULL;
    INetCfgLock *   pnclock = NULL;

    Assert(ppnc);
    Assert(ppnclock);

    *ppnc = NULL;
    *ppnclock = NULL;

    hr = CoCreateInstance(CLSID_CNetCfg, NULL,
            CLSCTX_INPROC_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
            IID_INetCfg, reinterpret_cast<void**>(&pnc));

    if (SUCCEEDED(hr))
    {
        hr = pnc->QueryInterface(IID_INetCfgLock,
                                 reinterpret_cast<LPVOID *>(&pnclock));
        if (SUCCEEDED(hr))
        {
            PWSTR pszwLockHolder;

            hr = pnclock->AcquireWriteLock(0,
                    SzLoadIds(IDS_ADVCFG_LOCK_DESC), &pszwLockHolder);
            if (S_OK == hr)
            {
                Assert(!pszwLockHolder);
                hr = pnc->Initialize(NULL);
            }
            else if (S_FALSE == hr)
            {
                // Couldn't lock INetCfg
                NcMsgBox(hwndParent,
                    IDS_ADVCFG_CAPTION, IDS_ADVCFG_CANT_LOCK,
                    MB_ICONSTOP | MB_OK,
                    (pszwLockHolder)
                        ? pszwLockHolder
                        : SzLoadIds(IDS_ADVCFG_GENERIC_COMP));

                CoTaskMemFree(pszwLockHolder);

                // Don't need this anymore
                ReleaseObj(pnclock);
                pnclock = NULL;

                hr = E_FAIL;
            }
            else if (NETCFG_E_NEED_REBOOT == hr)
            {
                // Can't make any changes because we are pending a reboot.
                NcMsgBox(hwndParent,
                    IDS_ADVCFG_CAPTION, IDS_ADVCFG_NEED_REBOOT,
                    MB_ICONSTOP | MB_OK);

                // Don't need this anymore
                ReleaseObj(pnclock);
                pnclock = NULL;
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        *ppnc = pnc;
        *ppnclock = pnclock;
    }

    TraceError("HrGetINetCfg", hr);
    return hr;
}

HRESULT HrDoAdvCfgDlg(HWND hwndParent)
{
    PROPSHEETHEADER     psh = {0};
    HPROPSHEETPAGE      ahpsp[c_cmaxPages];
    INetCfg *           pnc = NULL;
    INetCfgLock *       pnclock = NULL;
    HRESULT             hr;

    hr = HrGetINetCfg(hwndParent, &pnc, &pnclock);
    if (SUCCEEDED(hr))
    {
        CBindingsDlg        dlgBindings(pnc);
        CProviderOrderDlg   dlgProviderOrder;
        DWORD               cPages = 0;

        if (dlgBindings.FShowPage())
        {
            ahpsp[cPages++] = dlgBindings.CreatePage(IDD_ADVCFG_Bindings, 0);
        }

        if (dlgProviderOrder.FShowPage())
        {
            ahpsp[cPages++] = dlgProviderOrder.CreatePage(IDD_ADVCFG_Provider, 0);
        }

        psh.dwSize      = sizeof(PROPSHEETHEADER);
        psh.dwFlags     = PSH_NOAPPLYNOW;
        psh.hwndParent  = hwndParent;
        psh.hInstance   = _Module.GetResourceInstance();
        psh.pszCaption  = SzLoadIds(IDS_ADVCFG_PROPSHEET_TITLE);
        psh.nPages      = cPages;
        psh.phpage      = ahpsp;

        int nRet = (int)PropertySheet(&psh);

        hr = pnc->Uninitialize();
        if (SUCCEEDED(hr))
        {
            if (pnclock)
            {
                // Don't unlock unless we previously successfully acquired the
                // write lock
                hr = pnclock->ReleaseWriteLock();
                ReleaseObj(pnclock);
            }
        }

        if (SUCCEEDED(hr))
        {
            ReleaseObj(pnc);
        }
    }

    TraceError("HrDoAdvCfgDlg", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\shell\advcfg\acsheet.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       A C S H E E T . H
//
//  Contents:   Definitions for the Advanced Configuration property sheet
//
//  Notes:
//
//  Author:     danielwe   14 Jul 1997
//
//----------------------------------------------------------------------------

#ifndef _ACSHEET_H
#define _ACSHEET_H

#pragma once
#include "nsbase.h"
#include "ncatlps.h"
#include "ncatlui.h"
#include "resource.h"

#endif //!_ACSHEET_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\shell\advcfg\actree.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       A C T R E E . C P P
//
//  Contents:   Functions related to the Advanced Configuration dialog
//              tree view control
//
//  Notes:
//
//  Author:     danielwe   3 Dec 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "netcon.h"
#include "netconp.h"
#include "acsheet.h"
#include "acbind.h"
#include "ncnetcfg.h"
#include "lancmn.h"
#include "ncui.h"
#include "ncsetup.h"
#include "ncperms.h"

DWORD
GetDepthSpecialCase (
    INetCfgBindingPath* pPath)
{
    HRESULT hr;
    DWORD dwDepth;

    hr = pPath->GetDepth (&dwDepth);

    if (SUCCEEDED(hr))
    {
        INetCfgComponent* pLast;

        hr = HrGetLastComponentAndInterface (
                pPath, &pLast, NULL);

        if (SUCCEEDED(hr))
        {
            DWORD dwCharacteristics;

            // If the last component in the bindpath is one which
            // doesn't expose its lower bindings, then compsensate by
            // returning a depth that thinks it does.  This special case
            // is only for this code which was written for the origianl
            // binding engine but needed to be quickly adapted to the new
            // binding engine which doesn't return 'fake' bindpaths.
            //

            hr = pLast->GetCharacteristics (&dwCharacteristics);
            if (SUCCEEDED(hr) && (dwCharacteristics & NCF_DONTEXPOSELOWER))
            {
                PWSTR pszInfId;

                hr = pLast->GetId (&pszInfId);
                if (S_OK == hr)
                {
                    if (0 == lstrcmpW (pszInfId, L"ms_nwnb"))
                    {
                        dwDepth += 2;
                    }
                    else if (0 == lstrcmpW (pszInfId, L"ms_nwipx"))
                    {
                        dwDepth += 1;
                    }

                    CoTaskMemFree (pszInfId);
                }
            }

            ReleaseObj (pLast);
        }
    }

    return dwDepth;
}

//+---------------------------------------------------------------------------
//
//  Function:   FreeBindPathInfoList
//
//  Purpose:    Frees the given list of BIND_PATH_INFO structures
//
//  Arguments:
//      listbpip [in, ref]  Reference to list to be freed
//
//  Returns:    Nothing
//
//  Author:     danielwe   26 Nov 1997
//
//  Notes:
//
VOID FreeBindPathInfoList(BPIP_LIST &listbpip)
{
    BPIP_LIST::iterator     iterBpip;

    for (iterBpip = listbpip.begin();
         iterBpip != listbpip.end();
         iterBpip++)
    {
        BIND_PATH_INFO *    pbpi = *iterBpip;

        ReleaseObj(pbpi->pncbp);
        delete pbpi;
    }

    listbpip.erase(listbpip.begin(), listbpip.end());
}

//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::OnTreeItemChanged
//
//  Purpose:    Called in response to the TVN_SELCHANGED message
//
//  Arguments:
//      idCtrl   []
//      pnmh     []
//      bHandled []
//
//  Returns:
//
//  Author:     danielwe   26 Nov 1997
//
//  Notes:
//
LRESULT CBindingsDlg::OnTreeItemChanged(int idCtrl, LPNMHDR pnmh,
                                      BOOL& bHandled)
{
    NM_TREEVIEW *   pnmtv = reinterpret_cast<NM_TREEVIEW *>(pnmh);

    Assert(pnmtv);

#ifdef ENABLETRACE
    WCHAR   szBuffer[265];

    pnmtv->itemNew.mask = TVIF_HANDLE | TVIF_PARAM | TVIF_TEXT;
    pnmtv->itemNew.pszText = szBuffer;
    pnmtv->itemNew.cchTextMax = celems(szBuffer);

    TreeView_GetItem(m_hwndTV, &pnmtv->itemNew);

    TREE_ITEM_DATA *    ptid;

    ptid = reinterpret_cast<TREE_ITEM_DATA *>(pnmtv->itemNew.lParam);

    Assert(ptid);

    TraceTag(ttidAdvCfg, "*-------------------------------------------------"
             "------------------------------*");
    TraceTag(ttidAdvCfg, "Tree item %S selected", szBuffer);
    TraceTag(ttidAdvCfg, "-----------------------------------------");
    TraceTag(ttidAdvCfg, "OnEnable list:");
    TraceTag(ttidAdvCfg, "--------------");

    BPIP_LIST::iterator     iterBpip;

    for (iterBpip = ptid->listbpipOnEnable.begin();
         iterBpip != ptid->listbpipOnEnable.end();
         iterBpip++)
    {
        BIND_PATH_INFO *    pbpi = *iterBpip;

        DbgDumpBindPath(pbpi->pncbp);
    }

    TraceTag(ttidAdvCfg, "-----------------------------------");
    TraceTag(ttidAdvCfg, "OnDisable list:");
    TraceTag(ttidAdvCfg, "--------------");

    for (iterBpip = ptid->listbpipOnDisable.begin();
         iterBpip != ptid->listbpipOnDisable.end();
         iterBpip++)
    {
        BIND_PATH_INFO *    pbpi = *iterBpip;

        DbgDumpBindPath(pbpi->pncbp);
    }

    TraceTag(ttidAdvCfg, "*-------------------------------------------------"
             "------------------------------*");

#endif

    // Assume both buttons are greyed initially
    ::EnableWindow(GetDlgItem(PSB_Binding_Up), FALSE);
    ::EnableWindow(GetDlgItem(PSB_Binding_Down), FALSE);

    if (TreeView_GetParent(m_hwndTV, pnmtv->itemNew.hItem))
    {
        if (TreeView_GetNextSibling(m_hwndTV, pnmtv->itemNew.hItem))
        {
            ::EnableWindow(GetDlgItem(PSB_Binding_Down), TRUE);
        }

        if (TreeView_GetPrevSibling(m_hwndTV, pnmtv->itemNew.hItem))
        {
            ::EnableWindow(GetDlgItem(PSB_Binding_Up), TRUE);
        }
    }

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::OnTreeDeleteItem
//
//  Purpose:    Called in response to the TVN_DELETEITEM message
//
//  Arguments:
//      idCtrl   []
//      pnmh     []
//      bHandled []
//
//  Returns:    Nothing useful
//
//  Author:     danielwe   26 Nov 1997
//
//  Notes:
//
LRESULT CBindingsDlg::OnTreeDeleteItem(int idCtrl, LPNMHDR pnmh,
                                     BOOL& bHandled)
{
    NM_TREEVIEW *       pnmtv = reinterpret_cast<NM_TREEVIEW *>(pnmh);
    TREE_ITEM_DATA *    ptid;

    Assert(pnmtv);

    ptid = reinterpret_cast<TREE_ITEM_DATA *>(pnmtv->itemOld.lParam);

    // May be NULL if moving items around
    if (ptid)
    {
        ReleaseObj(ptid->pncc);
        FreeBindPathInfoList(ptid->listbpipOnEnable);
        FreeBindPathInfoList(ptid->listbpipOnDisable);

        delete ptid;
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::OnTreeItemExpanding
//
//  Purpose:    Called when the TVN_ITEMEXPANDING message is received
//
//  Arguments:
//      idCtrl   []
//      pnmh     []
//      bHandled []
//
//  Returns:
//
//  Author:     danielwe   26 Nov 1997
//
//  Notes:
//
LRESULT CBindingsDlg::OnTreeItemExpanding(int idCtrl, LPNMHDR pnmh,
                                          BOOL& bHandled)
{
    // This prevents all tree items from collapsing
    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::OnTreeKeyDown
//
//  Purpose:    Called when the TVN_KEYDOWN message is received
//
//  Arguments:
//      idCtrl   []
//      pnmh     []
//      fHandled []
//
//  Returns:
//
//  Author:     danielwe   22 Dec 1997
//
//  Notes:
//
LRESULT CBindingsDlg::OnTreeKeyDown(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    TV_KEYDOWN *    ptvkd = (TV_KEYDOWN*)pnmh;
    HTREEITEM       hti = NULL;

    if (VK_SPACE == ptvkd->wVKey)
    {
        hti = TreeView_GetSelection(m_hwndTV);
        // if there is a selection
        if (hti)
        {
            ToggleCheckbox(hti);
        }
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::ToggleCheckbox
//
//  Purpose:    Called when the user toggles a checbox in the treeview
//              control.
//
//  Arguments:
//      hti [in]    HTREEITEM of item that was toggled
//
//  Returns:    Nothing
//
//  Author:     danielwe   26 Nov 1997
//
//  Notes:
//
VOID CBindingsDlg::ToggleCheckbox(HTREEITEM hti)
{
    if (!FHasPermission(NCPERM_ChangeBindState))
    {
        // do nothing
        return;
    }

    TV_ITEM             tvi = {0};
    TREE_ITEM_DATA *    ptid;
    BOOL                fEnable;

    tvi.mask = TVIF_PARAM | TVIF_HANDLE | TVIF_STATE;
    tvi.stateMask = TVIS_STATEIMAGEMASK;
    tvi.hItem = hti;
    TreeView_GetItem(m_hwndTV, &tvi);

    ptid = reinterpret_cast<TREE_ITEM_DATA *>(tvi.lParam);
    AssertSz(ptid, "No tree item data??");

    BPIP_LIST::iterator     iterBpip;
    BPIP_LIST *             plist;

    if (tvi.state & INDEXTOSTATEIMAGEMASK(SELS_CHECKED))
    {
        // unchecking the box
        plist = &ptid->listbpipOnDisable;
        fEnable = FALSE;
    }
    else
    {
        // checking the box
        plist = &ptid->listbpipOnEnable;
        fEnable = TRUE;
    }

    TraceTag(ttidAdvCfg, "ToggleChecbox: %s the following binding path(s)",
             fEnable ? "Enabling" : "Disabling");

    // Enable or disable each binding path in the appropriate list
    for (iterBpip = plist->begin();
         iterBpip != plist->end();
         iterBpip++)
    {
        BIND_PATH_INFO *    pbpi = *iterBpip;

        (VOID)pbpi->pncbp->Enable(fEnable);
        DbgDumpBindPath(pbpi->pncbp);
    }

    SetCheckboxStates();

    TraceTag(ttidAdvCfg, "Done!");
}

//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::OnClick
//
//  Purpose:    Called in response to the NM_CLICK message.
//
//  Arguments:
//      idCtrl   []
//      pnmh     []
//      fHandled []
//
//  Returns:
//
//  Author:     danielwe   26 Nov 1997
//
//  Notes:
//
LRESULT CBindingsDlg::OnClick(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    return OnClickOrDoubleClick(idCtrl, pnmh, FALSE);
}

//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::OnDoubleClick
//
//  Purpose:    Called in response to the NM_DBLCLK message.
//
//  Arguments:
//      idCtrl   []
//      pnmh     []
//      fHandled []
//
//  Returns:
//
//  Author:     danielwe   16 Dec 1997
//
//  Notes:
//
LRESULT CBindingsDlg::OnDoubleClick(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    return OnClickOrDoubleClick(idCtrl, pnmh, TRUE);
}

//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::OnClickOrDoubleClick
//
//  Purpose:    Handles clicks or double clicks in the treeview control
//
//  Arguments:
//      idCtrl       [in]   ID of control
//      pnmh         [in]   Notification header
//      fDoubleClick [in]   TRUE if double click, FALSE if single click
//
//  Returns:
//
//  Author:     danielwe   16 Dec 1997
//
//  Notes:
//
LRESULT CBindingsDlg::OnClickOrDoubleClick(int idCtrl, LPNMHDR pnmh,
                                         BOOL fDoubleClick)
{
    if (idCtrl == TVW_Bindings)
    {
        DWORD           dwpts;
        RECT            rc;
        TV_HITTESTINFO  tvhti = {0};
        HTREEITEM       hti;

        // we have the location
        dwpts = GetMessagePos();

        // translate it relative to the tree view
        ::GetWindowRect(m_hwndTV, &rc);

        tvhti.pt.x = LOWORD(dwpts) - rc.left;
        tvhti.pt.y = HIWORD(dwpts) - rc.top;

        // get currently selected item
        hti = TreeView_HitTest(m_hwndTV, &tvhti);
        if (hti)
        {
            if (tvhti.flags & TVHT_ONITEMSTATEICON)
            {
                ToggleCheckbox(hti);
            }
            else if ((tvhti.flags & TVHT_ONITEM) && fDoubleClick)
            {
                ToggleCheckbox(hti);
            }
        }
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::OnBindingUpDown
//
//  Purpose:    Handles the user moving a binding in the treeview up or down
//
//  Arguments:
//      fUp [in]    TRUE if moving up, FALSE if down
//
//  Returns:    Nothing
//
//  Author:     danielwe   3 Dec 1997
//
//  Notes:
//
VOID CBindingsDlg::OnBindingUpDown(BOOL fUp)
{
    HRESULT                     hr = S_OK;
    TV_ITEM                     tvi = {0};
    HTREEITEM                   htiSel;
    HTREEITEM                   htiDst;
    TREE_ITEM_DATA *            ptidSel;
    TREE_ITEM_DATA *            ptidDst;
    INetCfgComponentBindings *  pnccb;

    htiSel = TreeView_GetSelection(m_hwndTV);

    AssertSz(htiSel, "No selection?");

    if (fUp)
    {
        htiDst = TreeView_GetPrevSibling(m_hwndTV, htiSel);
    }
    else
    {
        htiDst = TreeView_GetNextSibling(m_hwndTV, htiSel);
    }

    AssertSz(htiDst, "No next item?!");

    tvi.mask = TVIF_PARAM;
    tvi.hItem = htiSel;

    TreeView_GetItem(m_hwndTV, &tvi);

    ptidSel = reinterpret_cast<TREE_ITEM_DATA *>(tvi.lParam);

    tvi.hItem = htiDst;

    TreeView_GetItem(m_hwndTV, &tvi);

    ptidDst = reinterpret_cast<TREE_ITEM_DATA *>(tvi.lParam);

    BPIP_LIST::iterator         iterlist;
    INetCfgBindingPath *        pncbpDst;
    BIND_PATH_INFO *            pbpiDst = NULL;
    BPIP_LIST::iterator         posDst;
    BPIP_LIST::reverse_iterator posDstRev;
    INetCfgComponent *          pnccDstOwner;

    if (fUp)
    {
        posDst = ptidDst->listbpipOnDisable.begin();
        pbpiDst = *posDst;
    }
    else
    {
        posDstRev = ptidDst->listbpipOnDisable.rbegin();
        pbpiDst = *posDstRev;
    }

    AssertSz(pbpiDst, "We never found a path to move before or after!");

    pncbpDst = pbpiDst->pncbp;

    Assert(pncbpDst);

    hr = pncbpDst->GetOwner(&pnccDstOwner);
    if (SUCCEEDED(hr))
    {
        hr = pnccDstOwner->QueryInterface(IID_INetCfgComponentBindings,
                                          reinterpret_cast<LPVOID *>(&pnccb));
        if (SUCCEEDED(hr))
        {
            for (iterlist = ptidSel->listbpipOnDisable.begin();
                 iterlist != ptidSel->listbpipOnDisable.end() &&
                 SUCCEEDED(hr);
                 iterlist++)
            {
                // loop thru each item in the OnDisable list
                INetCfgBindingPath *    pncbp;
                BIND_PATH_INFO *        pbpi;

                pbpi = *iterlist;
                pncbp = pbpi->pncbp;

#if DBG
                INetCfgComponent *  pnccSrcOwner;

                if (SUCCEEDED(pncbp->GetOwner(&pnccSrcOwner)))
                {
                    AssertSz(pnccSrcOwner == pnccDstOwner, "Source and "
                             "dst path owners are not the same!?!");
                    ReleaseObj(pnccSrcOwner);
                }
#endif
                if (fUp)
                {
                    TraceTag(ttidAdvCfg, "Treeview: Moving...");
                    DbgDumpBindPath(pncbp);
                    // Move this binding path before the tagret
                    hr = pnccb->MoveBefore(pncbp, pncbpDst);
                    TraceTag(ttidAdvCfg, "Treeview: before...");
                    DbgDumpBindPath(pncbpDst);
                }
                else
                {
                    TraceTag(ttidAdvCfg, "Treeview: Moving...");
                    DbgDumpBindPath(pncbp);
                    // Move this binding path after the tagret
                    hr = pnccb->MoveAfter(pncbp, pncbpDst);
                    TraceTag(ttidAdvCfg, "Treeview: after...");
                    DbgDumpBindPath(pncbpDst);
                }
            }

            ReleaseObj(pnccb);
        }

        ReleaseObj(pnccDstOwner);
    }

    if (SUCCEEDED(hr))
    {
        HTREEITEM   htiParent;

        htiParent = TreeView_GetParent(m_hwndTV, htiSel);

        // Now that the binding has been moved, move the tree view item to the
        // proper place. If moving

        if (fUp)
        {
            // If moving up, the "move after" item should be the previous
            // sibling's previous sibling. If that doesn't exist, use the
            // previous sibling's parent. That had better exist!
            htiDst = TreeView_GetPrevSibling(m_hwndTV, htiDst);
            if (!htiDst)
            {
                htiDst = htiParent;
            }
        }

        AssertSz(htiDst, "No destination to move after!");

        SendDlgItemMessage(TVW_Bindings, WM_SETREDRAW, FALSE, 0);
        htiSel = HtiMoveTreeItemAfter(htiParent, htiDst, htiSel);
        TreeView_SelectItem(m_hwndTV, htiSel);
        SendDlgItemMessage(TVW_Bindings, WM_SETREDRAW, TRUE, 0);

        ::SetFocus(m_hwndTV);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::OnBindingUp
//
//  Purpose:    Called when the PSB_Binding_Up button is pressed
//
//  Arguments:
//      wNotifyCode []
//      wID         []
//      hWndCtl     []
//      bHandled    []
//
//  Returns:
//
//  Author:     danielwe   3 Dec 1997
//
//  Notes:
//
LRESULT CBindingsDlg::OnBindingUp(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                                BOOL& bHandled)
{
    OnBindingUpDown(TRUE);

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::OnBindingDown
//
//  Purpose:    Called when the PSB_Binding_Down button is pressed
//
//  Arguments:
//      wNotifyCode []
//      wID         []
//      hWndCtl     []
//      bHandled    []
//
//  Returns:
//
//  Author:     danielwe   3 Dec 1997
//
//  Notes:
//
LRESULT CBindingsDlg::OnBindingDown(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                                  BOOL& bHandled)
{
    OnBindingUpDown(FALSE);

    return 0;
}


//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::SetCheckboxStates
//
//  Purpose:    Sets the state of all checkboxes in the treeview.
//
//  Arguments:
//      (none)
//
//  Returns:    Nothing
//
//  Author:     danielwe   26 Nov 1997
//
//  Notes:
//
VOID CBindingsDlg::SetCheckboxStates()
{
    HRESULT         hr = S_OK;
    CIterTreeView   iterTV(m_hwndTV);
    HTREEITEM       hti;
    TV_ITEM         tvi = {0};
#ifdef ENABLETRACE
    WCHAR           szBuffer[256];
#endif

    BOOL fHasPermission = FHasPermission(NCPERM_ChangeBindState);

    while ((hti = iterTV.HtiNext()) && SUCCEEDED(hr))
    {
        TREE_ITEM_DATA *    ptid;

#ifdef ENABLETRACE
        tvi.mask = TVIF_HANDLE | TVIF_PARAM | TVIF_TEXT;
        tvi.pszText = szBuffer;
        tvi.cchTextMax = celems(szBuffer);
#else
        tvi.mask = TVIF_HANDLE | TVIF_PARAM;
#endif
        tvi.hItem = hti;
        TreeView_GetItem(m_hwndTV, &tvi);

        ptid = reinterpret_cast<TREE_ITEM_DATA *>(tvi.lParam);
        AssertSz(ptid, "No tree item data??");

#ifdef ENABLETRACE
        TraceTag(ttidAdvCfg, "Setting checkbox state for item %S.", szBuffer);
#endif

        BPIP_LIST::iterator     iterBpip;
        DWORD                   cEnabled = 0;

        for (iterBpip = ptid->listbpipOnDisable.begin();
             iterBpip != ptid->listbpipOnDisable.end();
             iterBpip++)
        {
            BIND_PATH_INFO *    pbpi = *iterBpip;

            if (S_OK == pbpi->pncbp->IsEnabled())
            {
                cEnabled++;
            }
        }

        tvi.mask = TVIF_STATE;
        tvi.stateMask = TVIS_STATEIMAGEMASK;

        UINT iState;

        if (!fHasPermission)
        {
            iState = cEnabled ? SELS_FIXEDBINDING_ENABLED : SELS_FIXEDBINDING_DISABLED;
        }
        else
        {
            iState = cEnabled ? SELS_CHECKED : SELS_UNCHECKED;
        }
        tvi.state =  INDEXTOSTATEIMAGEMASK(iState);

        TreeView_SetItem(m_hwndTV, &tvi);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::BuildBindingsList
//
//  Purpose:    Builds the contents of the Bindings treeview control
//
//  Arguments:
//      pncc [in]   INetCfgComponent of adapter upon which this list is based
//
//  Returns:    Nothing
//
//  Author:     danielwe   26 Nov 1997
//
//  Notes:
//
VOID CBindingsDlg::BuildBindingsList(INetCfgComponent *pncc)
{
    HRESULT     hr = S_OK;

    Assert(pncc);

    SBP_LIST                    listsbp;
    CIterNetCfgUpperBindingPath ncupbIter(pncc);
    INetCfgBindingPath *        pncbp;

    CWaitCursor wc;

    SendDlgItemMessage(TVW_Bindings, WM_SETREDRAW, FALSE, 0);

    while (SUCCEEDED(hr) && S_OK == (hr = ncupbIter.HrNext(&pncbp)))
    {
        listsbp.push_back(CSortableBindPath(pncbp));
    }

    if (SUCCEEDED(hr))
    {
        SBP_LIST::iterator  iterlist;

        // This sorts the list descending by depth
        listsbp.sort();

        for (iterlist = listsbp.begin();
             iterlist != listsbp.end() && SUCCEEDED(hr);
             iterlist++)
        {
            INetCfgBindingPath *    pncbp;

            pncbp = (*iterlist).GetPath();
            Assert(pncbp);

            hr = HrHandleSubpath(listsbp, pncbp);
            if (S_FALSE == hr)
            {
                hr = HrHandleTopLevel(pncbp);
            }
        }
    }

#ifdef ENABLETRACE
    if (FALSE)
    {
        SBP_LIST::iterator  iterlist;
        for (iterlist = listsbp.begin(); iterlist != listsbp.end(); iterlist++)
        {
            INetCfgBindingPath *    pncbp;

            pncbp = (*iterlist).GetPath();

            DWORD dwLen = GetDepthSpecialCase(pncbp);

            TraceTag(ttidAdvCfg, "Length is %ld.", dwLen);
        }
    }
#endif

    if (SUCCEEDED(hr))
    {
        hr = HrOrderDisableLists();
        if (SUCCEEDED(hr))
        {
            hr = HrOrderSubItems();
        }
    }

    SendDlgItemMessage(TVW_Bindings, WM_SETREDRAW, TRUE, 0);

    // Select first item in the tree
    TreeView_SelectItem(m_hwndTV, TreeView_GetRoot(m_hwndTV));

    {
        SBP_LIST::iterator  iterlist;

        for (iterlist = listsbp.begin();
             iterlist != listsbp.end() && SUCCEEDED(hr);
             iterlist++)
        {
            INetCfgBindingPath *    pncbp;

            pncbp = (*iterlist).GetPath();
            ReleaseObj(pncbp);
        }
    }

    TraceError("CBindingsDlg::BuildBindingsList", hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   BpiFindBindPathInList
//
//  Purpose:    Given a bind path and a list, finds the BIND_PATH_INFO item
//              that contains the given bind path.
//
//  Arguments:
//      pncbp    [in]       Bind path to look for
//      listBpip [in, ref]  List to search
//
//  Returns:    BIND_PATH_INFO of corresponding binding path, NULL if not
//              found
//
//  Author:     danielwe   4 Dec 1997
//
//  Notes:
//
BIND_PATH_INFO *BpiFindBindPathInList(INetCfgBindingPath *pncbp,
                                      BPIP_LIST &listBpip)
{
    BPIP_LIST::iterator     iterlist;

    for (iterlist = listBpip.begin(); iterlist != listBpip.end(); iterlist++)
    {
        BIND_PATH_INFO *    pbpi;

        pbpi = *iterlist;

        if (S_OK == pncbp->IsSamePathAs(pbpi->pncbp))
        {
            // Found the target path
            return pbpi;
        }
    }

    return NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::HrOrderDisableList
//
//  Purpose:    Given a component's item data, orders the OnDisable list
//              based on the true binding order for the owning component
//
//  Arguments:
//      ptid [in]   Item data containing list
//
//  Returns:    S_OK if success, Win32 or OLE error code otherwise
//
//  Author:     danielwe   4 Dec 1997
//
//  Notes:
//
HRESULT CBindingsDlg::HrOrderDisableList(TREE_ITEM_DATA *ptid)
{
    HRESULT             hr = S_OK;
    INetCfgComponent *  pnccOwner;
    BIND_PATH_INFO *    pbpi;

#if DBG
    size_t              cItems = ptid->listbpipOnDisable.size();
#endif

    // Get the owning component of the first binding path in the list
    pbpi = *(ptid->listbpipOnDisable.begin());
    hr = pbpi->pncbp->GetOwner(&pnccOwner);
    if (SUCCEEDED(hr))
    {
        CIterNetCfgBindingPath  ncbpIter(pnccOwner);
        INetCfgBindingPath *    pncbp;
        BPIP_LIST::iterator     posPncbp;
        BPIP_LIST::iterator     posInsertAfter;

        // Start this at beginning
        posInsertAfter = ptid->listbpipOnDisable.begin();

        while (SUCCEEDED(hr) && S_OK == (hr = ncbpIter.HrNext(&pncbp)))
        {
            pbpi = BpiFindBindPathInList(pncbp, ptid->listbpipOnDisable);
            if (pbpi)
            {
                BPIP_LIST::iterator     posErase;

                posErase = find(ptid->listbpipOnDisable.begin(),
                                ptid->listbpipOnDisable.end(), pbpi);

                AssertSz(posErase != ptid->listbpipOnDisable.end(), "It HAS"
                         " to be in the list!");

                // Found bind path in list
                // Remove it from present location and insert after next item
                ptid->listbpipOnDisable.splice(posInsertAfter,
                                               ptid->listbpipOnDisable,
                                               posErase);
                posInsertAfter++;
            }

            ReleaseObj(pncbp);
        }

        ReleaseObj(pnccOwner);
    }

    if (SUCCEEDED(hr))
    {
        AssertSz(ptid->listbpipOnDisable.size() == cItems, "How come we don't"
                 " have the same number of items in the list anymore??");
        hr = S_OK;
    }

    TraceError("CBindingsDlg::HrOrderDisableList", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::HrOrderDisableLists
//
//  Purpose:    Orders the OnDisable lists of all tree view items according
//              to the true binding order
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK if success, Win32 or OLE error code otherwise
//
//  Author:     danielwe   4 Dec 1997
//
//  Notes:
//
HRESULT CBindingsDlg::HrOrderDisableLists()
{
    HRESULT         hr = S_OK;
    CIterTreeView   iterHti(m_hwndTV);
    HTREEITEM       hti;
    TV_ITEM         tvi = {0};

    // Loop thru each tree item, ordering the OnDisable lists to match the
    // owning component's true binding order

    while ((hti = iterHti.HtiNext()) && SUCCEEDED(hr))
    {
        TREE_ITEM_DATA *    ptid;

        tvi.mask = TVIF_PARAM;
        tvi.hItem = hti;
        TreeView_GetItem(m_hwndTV, &tvi);

        ptid = reinterpret_cast<TREE_ITEM_DATA *>(tvi.lParam);
        AssertSz(ptid, "No item data?!");

        hr = HrOrderDisableList(ptid);
    }

    if (SUCCEEDED(hr))
    {
        hr = S_OK;
    }

    TraceError("CBindingsDlg::HrOrderDisableLists", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::HrOrderSubItems
//
//  Purpose:    Orders the sub items of the tree view to reflect the bind
//              order of the system
//
//  Arguments:
//      (none)
//
//  Returns:    Nothing
//
//  Author:     danielwe   3 Dec 1997
//
//  Notes:
//
HRESULT CBindingsDlg::HrOrderSubItems()
{
    HRESULT     hr = S_OK;
    HTREEITEM   htiTopLevel;

    htiTopLevel = TreeView_GetRoot(m_hwndTV);
    while (htiTopLevel)
    {
        HTREEITEM           htiChild;
        TREE_ITEM_DATA *    ptid;
        TV_ITEM             tvi = {0};

        tvi.mask = TVIF_PARAM;
        tvi.hItem = htiTopLevel;
        TreeView_GetItem(m_hwndTV, &tvi);

        ptid = reinterpret_cast<TREE_ITEM_DATA *>(tvi.lParam);
        AssertSz(ptid, "No tree item data??");

        CIterNetCfgBindingPath      ncbpIter(ptid->pncc);
        INetCfgBindingPath *        pncbp;
        HTREEITEM                   htiInsertAfter = NULL;

        while (SUCCEEDED(hr) && S_OK == (hr = ncbpIter.HrNext(&pncbp)))
        {
            BOOL    fFound = FALSE;

            htiChild = TreeView_GetChild(m_hwndTV, htiTopLevel);

            while (htiChild && !fFound)
            {
                TREE_ITEM_DATA *    ptidChild;

                tvi.mask = TVIF_PARAM;
                tvi.hItem = htiChild;
                TreeView_GetItem(m_hwndTV, &tvi);

                ptidChild = reinterpret_cast<TREE_ITEM_DATA *>(tvi.lParam);
                AssertSz(ptidChild, "No tree item data??");

                if (!ptidChild->fOrdered)
                {
                    BIND_PATH_INFO *        pbpi;

                    pbpi = BpiFindBindPathInList(pncbp,
                                                 ptidChild->listbpipOnDisable);
                    if (pbpi)
                    {
                        htiInsertAfter = HtiMoveTreeItemAfter(htiTopLevel,
                                                              htiInsertAfter,
                                                              htiChild);
                        ptidChild->fOrdered = TRUE;

                        fFound = TRUE;
                        // Go to next bind path
                        break;
                    }
                }

                htiChild = TreeView_GetNextSibling(m_hwndTV, htiChild);
            }

            ReleaseObj(pncbp);
        }

        htiTopLevel = TreeView_GetNextSibling(m_hwndTV, htiTopLevel);
    }

    if (SUCCEEDED(hr))
    {
        hr = S_OK;
    }

    TraceError("CBindingsDlg::HrOrderSubItems", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::HtiAddTreeViewItem
//
//  Purpose:    Addes a new tree item according to provided information
//
//  Arguments:
//      pnccOwner [in]  INetCfgComponent owner of component being added
//      htiParent [in]  HTREEITEM of parent (NULL if top-level item)
//
//  Returns:    HTREEITEM of newly added item
//
//  Author:     danielwe   26 Nov 1997
//
//  Notes:
//
HTREEITEM CBindingsDlg::HtiAddTreeViewItem(INetCfgComponent * pnccOwner,
                                         HTREEITEM htiParent)
{
    HRESULT                 hr = S_OK;
    HTREEITEM               hti = NULL;
    SP_CLASSIMAGELIST_DATA  cid;

    Assert(pnccOwner);

    // Get the class image list structure
    hr = HrSetupDiGetClassImageList(&cid);
    if (SUCCEEDED(hr))
    {
        BSTR    pszwName;

        hr = pnccOwner->GetDisplayName(&pszwName);
        if (SUCCEEDED(hr))
        {
            GUID    guidClass;

            hr = pnccOwner->GetClassGuid(&guidClass);
            if (SUCCEEDED(hr))
            {
                INT     nIndex;

                // Get the component's class image list index
                hr = HrSetupDiGetClassImageIndex(&cid, &guidClass,
                                                 &nIndex);
                if (SUCCEEDED(hr))
                {
                    TV_INSERTSTRUCT     tvis = {0};
                    TREE_ITEM_DATA *    ptid;

                    ptid = new TREE_ITEM_DATA;
                    if (ptid)
                    {
                        AddRefObj(ptid->pncc = pnccOwner);
                        ptid->fOrdered = FALSE;

                        tvis.item.mask = TVIF_PARAM | TVIF_TEXT |
                                         TVIF_STATE | TVIF_IMAGE |
                                         TVIF_SELECTEDIMAGE;
                        tvis.item.iImage = nIndex;
                        tvis.item.iSelectedImage = nIndex;
                        tvis.item.stateMask = TVIS_STATEIMAGEMASK | TVIS_EXPANDED;
                        tvis.item.state = TVIS_EXPANDED |
                                          INDEXTOSTATEIMAGEMASK(SELS_CHECKED);
                        tvis.item.pszText = pszwName;
                        tvis.item.lParam = reinterpret_cast<LPARAM>(ptid);
                        tvis.hParent = htiParent;
                        tvis.hInsertAfter = TVI_LAST;

                        hti = TreeView_InsertItem(m_hwndTV, &tvis);

                        TraceTag(ttidAdvCfg, "Adding%s treeview item: %S",
                                 htiParent ? " child" : "", tvis.item.pszText);

                        CoTaskMemFree(pszwName);
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }
            }
        }

        (void) HrSetupDiDestroyClassImageList(&cid);
    }

    return hti;
}

//+---------------------------------------------------------------------------
//
//  Function:   AddToListIfNotAlreadyAdded
//
//  Purpose:    Addes the given bind path info structure to the given list
//
//  Arguments:
//      bpipList [in, ref]  List to be added to
//      pbpi     [in]       BIND_PATH_INFO structure to add
//
//  Returns:    Nothing
//
//  Author:     danielwe   26 Nov 1997
//
//  Notes:      If the item is not added to the list, it is deleted
//
VOID AddToListIfNotAlreadyAdded(BPIP_LIST &bpipList, BIND_PATH_INFO *pbpi)
{
    BPIP_LIST::iterator     iterBpip;
    BOOL                    fAlreadyInList = FALSE;

    for (iterBpip = bpipList.begin();
         iterBpip != bpipList.end();
         iterBpip++)
    {
        BIND_PATH_INFO *    pbpiList = *iterBpip;

        if (S_OK == pbpiList->pncbp->IsSamePathAs(pbpi->pncbp))
        {
            fAlreadyInList = TRUE;
            break;
        }
    }

    if (!fAlreadyInList)
    {
        bpipList.push_back(pbpi);
    }
    else
    {
        ReleaseObj(pbpi->pncbp);
        delete pbpi;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::AssociateBinding
//
//  Purpose:    Associates the given binding path with the given tree item
//
//  Arguments:
//      pncbpThis [in]  Bind path to associate
//      hti       [in]  HTREEITEM of item to associate the binding with
//      dwFlags   [in]  One or combination of:
//                          ASSCF_ON_ENABLE - associate with OnEnable list
//                          ASSCF_ON_DISABLE - associate with OnDisable list
//                          ASSCF_ANCESTORS - associate this binding with all
//                                            ancestors of the given item as
//                                            well
//
//  Returns:    Nothing
//
//  Author:     danielwe   26 Nov 1997
//
//  Notes:      If binding is already present in the given list, it is not
//              added again.
//
VOID CBindingsDlg::AssociateBinding(INetCfgBindingPath *pncbpThis,
                                  HTREEITEM hti, DWORD dwFlags)
{
    TV_ITEM             tvi = {0};
    TREE_ITEM_DATA *    ptid;

#ifdef ENABLETRACE
    WCHAR               szBuffer[256];
#endif

    //$ TODO (danielwe) 26 Nov 1997: Include ALL ancestors as well!

    AssertSz(dwFlags, "NO flags!");

#ifdef ENABLETRACE
    tvi.mask = TVIF_HANDLE | TVIF_PARAM | TVIF_TEXT;
    tvi.pszText = szBuffer;
    tvi.cchTextMax = celems(szBuffer);
#else
    tvi.mask = TVIF_HANDLE | TVIF_PARAM;
#endif

    tvi.hItem = hti;

    SideAssert(TreeView_GetItem(m_hwndTV, &tvi));

    ptid = reinterpret_cast<TREE_ITEM_DATA *>(tvi.lParam);
    AssertSz(ptid, "No tree item data??");

#ifdef ENABLETRACE
    TraceTag(ttidAdvCfg, "Associating the following binding path with tree "
             "item %S", szBuffer);
#endif
    DbgDumpBindPath(pncbpThis);

    if (dwFlags & ASSCF_ON_ENABLE)
    {
        BIND_PATH_INFO *    pbpi;

        pbpi = new BIND_PATH_INFO;
        if (pbpi)
        {
            AddRefObj(pbpi->pncbp = pncbpThis);

            // Note: (danielwe) 25 Nov 1997: Let's see if we need this. Until
            // then, set to 0

            pbpi->dwLength = 0;

            AddToListIfNotAlreadyAdded(ptid->listbpipOnEnable, pbpi);
        }
    }

    if (dwFlags & ASSCF_ON_DISABLE)
    {
        BIND_PATH_INFO *    pbpi;

        pbpi = new BIND_PATH_INFO;
        if (pbpi)
        {
            AddRefObj(pbpi->pncbp = pncbpThis);

            // Note: (danielwe) 25 Nov 1997: Let's see if we need this. Until
            // then, set to 0

            pbpi->dwLength = 0;

            AddToListIfNotAlreadyAdded(ptid->listbpipOnDisable, pbpi);
        }
    }

    if (dwFlags & ASSCF_ANCESTORS)
    {
        // Now associate the same binding with my parent (this will recurse to
        // cover all ancestors)
        HTREEITEM htiParent = TreeView_GetParent(m_hwndTV, hti);
        if (htiParent)
        {
            AssociateBinding(pncbpThis, htiParent, dwFlags);
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::HrHandleSubpath
//
//  Purpose:    Handles the case of the given binding path being a subpath
//              of an already associated binding path
//
//  Arguments:
//      listsbp  [in, ref]  Sorted list of binding paths to use in checking
//      pncbpSub [in]       Binding path to compare
//
//  Returns:    S_OK if success, Win32 or OLE error code otherwise
//
//  Author:     danielwe   26 Nov 1997
//
//  Notes:
//
HRESULT CBindingsDlg::HrHandleSubpath(SBP_LIST &listsbp,
                                    INetCfgBindingPath *pncbpSub)
{
    HRESULT     hr = S_OK;
    BOOL        fProcessed = FALSE;

    SBP_LIST::iterator  iterlist;

    TraceTag(ttidAdvCfg, "---------------------------------------------------"
             "-------------------------");
    DbgDumpBindPath(pncbpSub);
    TraceTag(ttidAdvCfg, "...is being compared to the following...");

    for (iterlist = listsbp.begin();
         iterlist != listsbp.end() && SUCCEEDED(hr);
         iterlist++)
    {
        INetCfgBindingPath *    pncbp;
        INetCfgComponent *      pnccOwner;

        pncbp = (*iterlist).GetPath();
        Assert(pncbp);

        if (S_OK == pncbp->IsSamePathAs(pncbpSub))
        {
            // Don't compare path to itself
            continue;
        }

        hr = pncbp->GetOwner(&pnccOwner);
        if (SUCCEEDED(hr))
        {
            if (FIsHidden(pnccOwner))
            {
                ReleaseObj(pnccOwner);
                continue;
            }
            else
            {
                ReleaseObj(pnccOwner);
            }

            DbgDumpBindPath(pncbp);
            hr = pncbpSub->IsSubPathOf(pncbp);
            if (S_OK == hr)
            {
                CIterTreeView   iterTV(m_hwndTV);
                HTREEITEM       hti;
                TV_ITEM         tvi = {0};
#ifdef ENABLETRACE
                WCHAR           szBuf[256] = {0};
#endif

                while ((hti = iterTV.HtiNext()) && SUCCEEDED(hr))
                {
                    TREE_ITEM_DATA *    ptid;

#ifdef ENABLETRACE
                    tvi.mask = TVIF_TEXT | TVIF_PARAM | TVIF_HANDLE;
                    tvi.pszText = szBuf;
                    tvi.cchTextMax = celems(szBuf);
#else
                    tvi.mask = TVIF_PARAM | TVIF_HANDLE;
#endif
                    tvi.hItem = hti;
                    TreeView_GetItem(m_hwndTV, &tvi);

#ifdef ENABLETRACE
                    TraceTag(ttidAdvCfg, "TreeView item: %S.", szBuf);
#endif
                    ptid = reinterpret_cast<TREE_ITEM_DATA *>(tvi.lParam);
                    AssertSz(ptid, "No tree item data??");

                    // Look for pncbp in OnEnable of this item
                    BPIP_LIST::iterator     iterBpip;

                    for (iterBpip = ptid->listbpipOnEnable.begin();
                         iterBpip != ptid->listbpipOnEnable.end();
                         iterBpip++)
                    {
                        INetCfgBindingPath *    pncbpIter;
                        BIND_PATH_INFO *        pbpi = *iterBpip;

                        pncbpIter = pbpi->pncbp;
                        AssertSz(pncbpIter, "No binding path?");

#ifdef ENABLETRACE
                        TraceTag(ttidAdvCfg, "OnEnable bindpath is");
                        DbgDumpBindPath (pncbpIter);
#endif

                        if (S_OK == pncbpIter->IsSamePathAs(pncbp))
                        {
                            hr = HrHandleSubItem(pncbpSub, pncbp, ptid, hti);
                            fProcessed = TRUE;
                        }
                    }
                }
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        hr = fProcessed ? S_OK : S_FALSE;
    }

    TraceError("CBindingsDlg::HrHandleSubpath", (hr == S_FALSE) ? S_OK : hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::HtiIsSubItem
//
//  Purpose:    Determines if the given component is already a sub item of
//              the given tree item
//
//  Arguments:
//      pncc [in]   Component to check
//      hti  [in]   HTREEITEM of item to check
//
//  Returns:    HTREEITEM of sub item, NULL if it is not a subitem
//
//  Author:     danielwe   26 Nov 1997
//
//  Notes:
//
HTREEITEM CBindingsDlg::HtiIsSubItem(INetCfgComponent *pncc, HTREEITEM hti)
{
    HTREEITEM   htiCur;

    htiCur = TreeView_GetChild(m_hwndTV, hti);
    while (htiCur)
    {
        TREE_ITEM_DATA *    ptid;
        TV_ITEM             tvi = {0};

        tvi.hItem = htiCur;
        tvi.mask = TVIF_HANDLE | TVIF_PARAM;
        TreeView_GetItem(m_hwndTV, &tvi);
        ptid = reinterpret_cast<TREE_ITEM_DATA *>(tvi.lParam);

        AssertSz(ptid, "No item data??");

        // Note: (danielwe) 26 Nov 1997: Make sure pointer comparison is
        // ok.
        if (pncc == ptid->pncc)
        {
            return htiCur;
        }

        htiCur = TreeView_GetNextSibling(m_hwndTV, htiCur);
    }

    return NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::HrHandleSubItem
//
//  Purpose:    Handles the case of a single sub-item existing in the tree
//              that matches the given binding path.
//
//  Arguments:
//      pncbpThis    [in]   Binding path being evaluated
//      pncbpMatch   [in]   Binding path it is a subpath of
//      ptid         [in]   Tree item data for tree view item that pncbpMatch
//                          is associated with
//      htiMatchItem [in]   HTREEITEM of above
//
//  Returns:    S_OK if success, Win32 or OLE error code otherwise
//
//  Author:     danielwe   26 Nov 1997
//
//  Notes:
//
HRESULT CBindingsDlg::HrHandleSubItem(INetCfgBindingPath *pncbpThis,
                                    INetCfgBindingPath *pncbpMatch,
                                    TREE_ITEM_DATA *ptid,
                                    HTREEITEM htiMatchItem)
{
    HRESULT             hr = S_OK;
    DWORD               dwThisLen;
    DWORD               dwMatchLen;
    DWORD               dLen;
    INetCfgComponent *  pnccMatchItem;

    pnccMatchItem = ptid->pncc;

    Assert(pnccMatchItem);

    dwThisLen = GetDepthSpecialCase(pncbpThis);
    dwMatchLen = GetDepthSpecialCase(pncbpMatch);

    dLen = dwMatchLen - dwThisLen;

    if ((dwMatchLen - dwThisLen) == 1 ||
        (S_OK == (hr = HrComponentIsHidden(pncbpMatch, dLen))))
    {
        INetCfgComponent *  pnccThisOwner;
        INetCfgComponent *  pnccMatchOwner;

        hr = pncbpThis->GetOwner(&pnccThisOwner);
        if (SUCCEEDED(hr))
        {
            hr = pncbpMatch->GetOwner(&pnccMatchOwner);
            if (SUCCEEDED(hr))
            {
                if (!FIsHidden(pnccThisOwner) &&
                    !FDontExposeLower(pnccMatchOwner))
                {
                    hr = HrHandleValidSubItem(pncbpThis, pncbpMatch,
                                              pnccThisOwner,
                                              htiMatchItem, ptid);
                }

                ReleaseObj(pnccMatchOwner);
            }

            ReleaseObj(pnccThisOwner);
        }
    }

    AssociateBinding(pncbpThis, htiMatchItem,
                     ASSCF_ON_ENABLE | ASSCF_ANCESTORS);

    TraceError("CBindingsDlg::HrHandleSubItem", (hr == S_FALSE) ? S_OK : hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::HrHandleValidSubItem
//
//  Purpose:    Handles the case of the given binding path being a sub item
//              of at least on item in the tree.
//
//  Arguments:
//      pncbpThis     [in]  THIS binding path
//      pncbpMatch    [in]  MATCH binding path
//      pnccThisOwner [in]  Owner of THIS binding path
//      htiMatchItem  [in]  HTREEITEM of match item
//      ptid          [in]  TREE item data for match item
//
//  Returns:    S_OK if success, Win32 or OLE error code otherwise
//
//  Author:     danielwe   1 Dec 1997
//
//  Notes:
//
HRESULT CBindingsDlg::HrHandleValidSubItem(INetCfgBindingPath *pncbpThis,
                                         INetCfgBindingPath *pncbpMatch,
                                         INetCfgComponent *pnccThisOwner,
                                         HTREEITEM htiMatchItem,
                                         TREE_ITEM_DATA *ptid)
{
    HRESULT     hr = S_OK;
    HTREEITEM   htiNew = NULL;

    if (pnccThisOwner != ptid->pncc)
    {
        // Check if it is already present as a subitem
        htiNew = HtiIsSubItem(pnccThisOwner, htiMatchItem);
        if (!htiNew)
        {
            htiNew = HtiAddTreeViewItem(pnccThisOwner, htiMatchItem);
        }

        AssertSz(htiNew, "No new or existing tree item!?!");

        AssociateBinding(pncbpMatch, htiNew,
                         ASSCF_ON_ENABLE | ASSCF_ON_DISABLE);
        AssociateBinding(pncbpThis, htiNew, ASSCF_ON_ENABLE);
    }

    TraceError("CBindingsDlg::HrHandleComponent", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::HrComponentIsHidden
//
//  Purpose:    Determines if the Nth component of the given binding path is
//              hidden.
//
//  Arguments:
//      pncbp [in]  Binding path to check
//      iComp [in]  Index of component to check for hidden characterstic
//
//  Returns:    S_OK if success, Win32 or OLE error code otherwise
//
//  Author:     danielwe   26 Nov 1997
//
//  Notes:
//
HRESULT CBindingsDlg::HrComponentIsHidden(INetCfgBindingPath *pncbp,
                                        DWORD iComp)
{
    Assert(pncbp);

    HRESULT                     hr = S_OK;
    CIterNetCfgBindingInterface ncbiIter(pncbp);
    INetCfgBindingInterface *   pncbi;

    // Convert from component count to interface count
    iComp--;

    AssertSz(iComp > 0, "We should never be looking for the first component!");

    while (SUCCEEDED(hr) && iComp && S_OK == (hr = ncbiIter.HrNext(&pncbi)))
    {
        iComp--;
        if (!iComp)
        {
            INetCfgComponent *  pnccLower;

            hr = pncbi->GetLowerComponent(&pnccLower);
            if (SUCCEEDED(hr))
            {
                if (!FIsHidden(pnccLower))
                {
                    hr = S_FALSE;
                }

                ReleaseObj(pnccLower);
            }
        }
        ReleaseObj(pncbi);
    }

    TraceError("CBindingsDlg::HrComponentIsHidden", (hr == S_FALSE) ? S_OK : hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::HrHandleTopLevel
//
//  Purpose:    Handles the case of the given binding path not being associated
//              with any existing tree view item
//
//  Arguments:
//      pncbpThis [in]  Binding path being evaluated
//
//  Returns:    S_OK if success, Win32 or OLE error code otherwise
//
//  Author:     danielwe   26 Nov 1997
//
//  Notes:
//
HRESULT CBindingsDlg::HrHandleTopLevel(INetCfgBindingPath *pncbpThis)
{
    HRESULT             hr = S_OK;
    INetCfgComponent *  pnccOwner;
    BOOL                fFound = FALSE;

    // Check if the owner of this path is already present in the tree
    hr = pncbpThis->GetOwner(&pnccOwner);
    if (SUCCEEDED(hr))
    {
        CIterTreeView   iterTV(m_hwndTV);
        HTREEITEM       hti;
        TV_ITEM         tvi = {0};

        while ((hti = iterTV.HtiNext()) && SUCCEEDED(hr))
        {
            TREE_ITEM_DATA *    ptid;

            tvi.mask = TVIF_PARAM | TVIF_HANDLE;
            tvi.hItem = hti;
            TreeView_GetItem(m_hwndTV, &tvi);

            ptid = reinterpret_cast<TREE_ITEM_DATA *>(tvi.lParam);
            AssertSz(ptid, "No tree item data??");

            // Note: (danielwe) 25 Nov 1997: Pointer comparison may not
            // work. Use GUIDs if necessary.
            if (ptid->pncc == pnccOwner)
            {
                // Found match with THIS binding owner and an existing tree
                // item
                AssociateBinding(pncbpThis, hti, ASSCF_ON_ENABLE |
                                 ASSCF_ON_DISABLE);

                fFound = TRUE;
                break;
            }
        }

        if (SUCCEEDED(hr) && !fFound)
        {
            // Not found in the tree
            if (!FIsHidden(pnccOwner))
            {
                DWORD   dwLen;

                dwLen = GetDepthSpecialCase(pncbpThis);

                if (dwLen > 2)
                {
                    HTREEITEM   hti;

                    hti = HtiAddTreeViewItem(pnccOwner, NULL);
                    if (hti)
                    {
                        AssociateBinding(pncbpThis, hti,
                                         ASSCF_ON_ENABLE |
                                         ASSCF_ON_DISABLE);
                    }
                }
            }
        }

        ReleaseObj(pnccOwner);
    }

    TraceError("CBindingsDlg::HrHandleTopLevel", (S_FALSE == hr) ? S_OK : hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   ChangeTreeItemParam
//
//  Purpose:    Helper function to change the lParam of a tree view item
//
//  Arguments:
//      hwndTV [in]     Tree view window
//      hitem  [in]     Handle to item to change
//      lparam [in]     New value of lParam
//
//  Returns:    Nothing
//
//  Author:     danielwe   3 Dec 1997
//
//  Notes:
//
VOID ChangeTreeItemParam(HWND hwndTV,  HTREEITEM hitem, LPARAM lparam)
{
    TV_ITEM tvi;

    tvi.hItem = hitem;
    tvi.mask = TVIF_PARAM;
    tvi.lParam = lparam;

    TreeView_SetItem(hwndTV, &tvi);
}

//+---------------------------------------------------------------------------
//
//  Member:     CBindingsDlg::HtiMoveTreeItemAfter
//
//  Purpose:    Moves the given tree view item and all its children after the
//              given treeview item
//
//  Arguments:
//      htiParent [in]  Parent treeview item
//      htiDest   [in]  Item to move after
//      htiSrc    [in]  Item to move
//
//  Returns:    Newly added treeview item
//
//  Author:     danielwe   3 Dec 1997
//
//  Notes:
//
HTREEITEM CBindingsDlg::HtiMoveTreeItemAfter(HTREEITEM htiParent,
                                           HTREEITEM htiDest,
                                           HTREEITEM htiSrc)
{
    HTREEITEM       htiNew;
    HTREEITEM       htiChild;
    HTREEITEM       htiNextChild;
    TV_INSERTSTRUCT tvis;
    WCHAR           szText[256];

    TraceTag(ttidAdvCfg, "Moving ...");
    DbgDumpTreeViewItem(m_hwndTV, htiSrc);
    TraceTag(ttidAdvCfg, "... after ...");
    DbgDumpTreeViewItem(m_hwndTV, htiDest);

    // retieve the items data
    tvis.item.hItem = htiSrc;
    tvis.item.mask = TVIF_IMAGE | TVIF_PARAM | TVIF_SELECTEDIMAGE |
                     TVIF_TEXT | TVIF_STATE;
    tvis.item.stateMask = TVIS_STATEIMAGEMASK;
    tvis.item.pszText = szText;
    tvis.item.cchTextMax = celems(szText);
    TreeView_GetItem(m_hwndTV, &tvis.item);

    if (NULL == htiDest)
    {
        tvis.hInsertAfter = TVI_LAST;
    }
    else
    {
        if (htiParent == htiDest)
        {
            tvis.hInsertAfter = TVI_FIRST;
        }
        else
        {
            tvis.hInsertAfter = htiDest;
        }
    }

    tvis.hParent = htiParent;

    // add our new one
    htiNew = TreeView_InsertItem(m_hwndTV, &tvis);

    // copy all children
    htiChild = TreeView_GetChild(m_hwndTV, htiSrc);
    while (htiChild)
    {
        htiNextChild = TreeView_GetNextSibling(m_hwndTV, htiChild);

        HtiMoveTreeItemAfter(htiNew, NULL, htiChild);
        htiChild = htiNextChild;
    }

    // set old location param to null, so when it is removed,
    // our lparam is not deleted by our remove routine
    ChangeTreeItemParam(m_hwndTV, htiSrc, NULL);

    // remove from old location
    TreeView_DeleteItem(m_hwndTV, htiSrc);

    return htiNew;
}

//
// Treeview flat iterator
//

//+---------------------------------------------------------------------------
//
//  Member:     CIterTreeView::HtiNext
//
//  Purpose:    Advances the iterator to the next treeview item
//
//  Arguments:
//      (none)
//
//  Returns:    Next HTREEITEM in tree view
//
//  Author:     danielwe   26 Nov 1997
//
//  Notes:      Uses a systematic iteration. First all children of first item
//              are returned, then all siblings, then next sibling and so on
//
HTREEITEM CIterTreeView::HtiNext()
{
    HTREEITEM   htiRet;
    HTREEITEM   hti;

    if (m_stackHti.empty())
    {
        return NULL;
    }

    htiRet = Front();
    hti = TreeView_GetChild(m_hwndTV, htiRet);
    if (!hti)
    {
        PopAndDelete();
        hti = TreeView_GetNextSibling(m_hwndTV, htiRet);
        if (hti)
        {
            PushAndAlloc(hti);
        }
        else
        {
            if (!m_stackHti.empty())
            {
                hti = TreeView_GetNextSibling(m_hwndTV, Front());
                PopAndDelete();
                if (hti)
                {
                    PushAndAlloc(hti);
                }
            }
        }
    }
    else
    {
        PushAndAlloc(hti);
    }

    return htiRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\shell\advcfg\order.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       O R D E R . H
//
//  Contents:   Header file for Advanced Options->Provider Order
//
//  Notes:
//
//  Author:     sumitc   1 Dec 1997
//
//----------------------------------------------------------------------------

#pragma once
#include "nsbase.h"     // must be first to include atl

#include "nsres.h"
#include "resource.h"


typedef list<tstring *>::iterator   ListIter;


static HTREEITEM AppendItem(HWND hwndTV, HTREEITEM hroot, PCWSTR szText, void * lParam, INT iImage);
static void AppendItemList(HWND hwndTV, HTREEITEM hroot, ListStrings lstr, ListStrings lstr2, INT iImage);


bool AreThereMultipleProviders(void);

static HRESULT ReadNetworkProviders(ListStrings& m_lstr, ListStrings& m_lstrDisp);
static HRESULT ReadPrintProviders(ListStrings& m_lstr, ListStrings& m_lstrDisp);

//
// CProviderOrderDlg
//

class CProviderOrderDlg :
    public CPropSheetPage
{
    BEGIN_MSG_MAP(CProviderOrderDlg)

        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu);
        MESSAGE_HANDLER(WM_HELP, OnHelp);
        COMMAND_ID_HANDLER(IDC_MOVEUP, OnMoveUp)
        COMMAND_ID_HANDLER(IDC_MOVEDOWN, OnMoveDown)
        NOTIFY_CODE_HANDLER(TVN_SELCHANGED, OnTreeItemChanged)
        NOTIFY_CODE_HANDLER(PSN_APPLY, OnOk)
    END_MSG_MAP()

    enum { IDD = IDD_PROVIDER};

    CProviderOrderDlg();
    ~CProviderOrderDlg();

    BOOL FShowPage()
    {
        return AreThereMultipleProviders();
    }

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam,
                        LPARAM lParam, BOOL& bHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& Handled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnOk(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnMoveUp(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                         BOOL& bHandled);
    LRESULT OnMoveDown(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                         BOOL& bHandled);
    LRESULT OnTreeItemChanged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
#if 0
    LRESULT OnProperties(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                         BOOL& bHandled);
    LRESULT OnApply(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnCancel(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnDeleteItem(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnItemChanged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
#endif

private:
    HCURSOR     m_hcurAfter;        // cursor after drag has started
    HCURSOR     m_hcurNoDrop;       // cursor indicating can't drop here
    HICON       m_hiconUpArrow;     // icon for up arrow
    HICON       m_hiconDownArrow;   // icon for down arrow
    HTREEITEM   m_htiNetwork;       // treeitem root for Network (one below actual root)
    HTREEITEM   m_htiPrint;         // treeitem root for Print (one below actual root)

    ListStrings m_lstrNetwork;      // list of strings with (ordered) Network providers
    ListStrings m_lstrNetworkDisp;  // list of display names for Network providers (same order)

    ListStrings m_lstrPrint;        // list of strings with (ordered) Print providers
    ListStrings m_lstrPrintDisp;    // list of display names for Print providers (same order)

    bool        m_fNoNetworkProv:1; // flag to indicate that we failed to get any network providers
    bool        m_fNoPrintProv:1;   // flag to indicate that we failed to get any print providers

    // the following functions fill up lstrDisplayNames with the list of net/print providers
    HRESULT     WriteProviders(HWND hwndTV, bool fPrint);
    HRESULT     MoveItem(bool fMoveUp);
    HRESULT     UpdateUpDownButtons(HWND hwndTV);
};


#if DBG
static void DumpItemList(ListStrings& lstr, PSTR szInfoAboutList);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\shell\advcfg\order.cpp ===
//+-------------------------------------------------------------------
//
//  File:       order.cpp
//
//  Synopsis:   code for Advanced Options->Provider Order
//
//  History:    1-Dec-97    SumitC      Created
//
//  Copyright 1985-1997 Microsoft Corporation, All Rights Reserved
//
//--------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "achelp.h"
#include "acsheet.h"
#include "order.h"
#include "ncui.h"
#include "ncreg.h"
#include "ncsetup.h"
#include "winspool.h"

extern const WCHAR c_szNetCfgHelpFile[];

const int   c_nMaxProviderTitle = 128;

const WCHAR c_chComma = WCHAR(',');

const WCHAR c_szNetwkProviderKey[] =   L"System\\CurrentControlSet\\Control\\NetworkProvider\\Order";
const WCHAR c_szNetwkProviderValue[] = L"ProviderOrder";
const WCHAR c_szNetwkService0[] =      L"System\\CurrentControlSet\\Services\\%s\\NetworkProvider";
const WCHAR c_szNetwkDisplayName[] =   L"Name";
const WCHAR c_szNetwkClass[] =         L"Class";

const WCHAR c_szPrintProviderKey[] =   L"System\\CurrentControlSet\\Control\\Print\\Providers";
const WCHAR c_szPrintProviderValue[] = L"Order";
const WCHAR c_szPrintService0[] =      L"System\\CurrentControlSet\\Control\\Print\\Providers\\%s";
const WCHAR c_szPrintDisplayName[] =   L"DisplayName";

const WCHAR c_szNetwkGetFailed[] =     L"failed to get network providers";
const WCHAR c_szPrintGetFailed[] =     L"failed to get print providers";


const DWORD g_aHelpIDs_IDD_ADVCFG_Provider[]=
{
    IDC_TREEVIEW,IDH_TREEVIEW,
    IDC_MOVEUP,IDH_MOVEUP,
    IDC_MOVEDOWN,IDH_MOVEDOWN,
    0,0
};

CProviderOrderDlg::CProviderOrderDlg()
{
    m_hcurAfter = m_hcurNoDrop = NULL;
    m_hiconUpArrow = m_hiconDownArrow = NULL;
}


CProviderOrderDlg::~CProviderOrderDlg()
{
    DeleteColString(&m_lstrNetwork);
    DeleteColString(&m_lstrNetworkDisp);
    DeleteColString(&m_lstrPrint);
    DeleteColString(&m_lstrPrintDisp);
    if (m_hiconUpArrow)
    {
        DeleteObject(m_hiconUpArrow);
    }
    if (m_hiconDownArrow)
    {
        DeleteObject(m_hiconDownArrow);
    }

}


LRESULT
CProviderOrderDlg::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    HWND        hwndTV;
    HTREEITEM   htiRoot;
    HRESULT     hr;
    PCWSTR      pszNetwork, pszPrint;
    HIMAGELIST  hil = NULL;
    INT         iNetClient, iPrinter;

//    CascadeDialogToWindow(hwndDlg, porder->GetParent(), FALSE);

    // setup drag and drop cursors

    m_hcurAfter = LoadCursor(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDCUR_AFTER));
    m_hcurNoDrop = LoadCursor(NULL, IDC_NO);
    m_hiconUpArrow = (HICON)LoadImage(_Module.GetResourceInstance(),
                                      MAKEINTRESOURCE(IDI_UP_ARROW),
                                      IMAGE_ICON, 16, 16, 0);
    m_hiconDownArrow = (HICON)LoadImage(_Module.GetResourceInstance(),
                                        MAKEINTRESOURCE(IDI_DOWN_ARROW),
                                        IMAGE_ICON, 16, 16, 0);

    m_htiNetwork = NULL;
    m_htiPrint = NULL;

    m_fNoNetworkProv = m_fNoPrintProv = FALSE;

    pszNetwork = SzLoadIds(IDS_NCPA_NETWORK);
    pszPrint = SzLoadIds(IDS_NCPA_PRINT);

    //$ REVIEW (sumitc, 11-dec-97): why exactly do we have this separator line?  (NT4 has it too)
    // Changes the style of the static control so it displays
    HWND hLine = GetDlgItem(IDC_STATIC_LINE);
    ::SetWindowLong(hLine, GWL_EXSTYLE, WS_EX_STATICEDGE | ::GetWindowLong(hLine, GWL_EXSTYLE));
    ::SetWindowPos(hLine, 0, 0,0,0,0, SWP_FRAMECHANGED|SWP_NOMOVE|
                            SWP_NOZORDER|SWP_NOSIZE|SWP_NOACTIVATE);

    // treeview stuff

    hwndTV = GetDlgItem(IDC_TREEVIEW);

    // prepare treeview
    {
        // use system imagelist functions

        SP_CLASSIMAGELIST_DATA cild;

        hr = HrSetupDiGetClassImageList(&cild);

        hil = ImageList_Duplicate(cild.ImageList);
        //$ REVIEW (sumitc, 11-dec-97) note down these indices and hardcode them?
        hr = ::HrSetupDiGetClassImageIndex(
                        &cild,
                        const_cast<LPGUID>(&GUID_DEVCLASS_NETCLIENT),
                        &iNetClient);
        hr = ::HrSetupDiGetClassImageIndex(
                        &cild,
                        const_cast<LPGUID>(&GUID_DEVCLASS_PRINTER),
                        &iPrinter);
        hr = HrSetupDiDestroyClassImageList(&cild);
    }

    TreeView_SetImageList(hwndTV, hil, TVSIL_NORMAL);

    // fill treeview
    //

    // Network Providers
    hr = ReadNetworkProviders(m_lstrNetwork, m_lstrNetworkDisp);

#if DBG
    DumpItemList(m_lstrNetworkDisp, "Network Provider Order");
#endif

    if (hr == S_OK)
    {
        htiRoot = AppendItem(hwndTV, (HTREEITEM)NULL, pszNetwork, NULL, iNetClient);
        AppendItemList(hwndTV, htiRoot, m_lstrNetworkDisp, m_lstrNetwork, iNetClient);
        TreeView_Expand(hwndTV, htiRoot, TVE_EXPAND);
        m_htiNetwork = htiRoot;
    }
    else
    {
        AppendItem(hwndTV, NULL, c_szNetwkGetFailed, NULL, iNetClient);
        m_fNoNetworkProv = TRUE;
    }

    // Print Providers
    hr = ReadPrintProviders(m_lstrPrint, m_lstrPrintDisp);

#if DBG
    DumpItemList(m_lstrPrintDisp, "Print Provider Order");
#endif
    if (hr == S_OK)
    {
        htiRoot = AppendItem(hwndTV, (HTREEITEM)NULL, pszPrint, NULL, iPrinter);
        AppendItemList(hwndTV, htiRoot, m_lstrPrintDisp, m_lstrPrint, iPrinter);
        TreeView_Expand(hwndTV, htiRoot, TVE_EXPAND);
        m_htiPrint = htiRoot;
    }
    else
    {
        AppendItem(hwndTV, NULL, c_szPrintGetFailed, NULL, iPrinter);
        m_fNoPrintProv = TRUE;
    }

    SendDlgItemMessage(IDC_MOVEUP, BM_SETIMAGE, IMAGE_ICON,
                       reinterpret_cast<LPARAM>(m_hiconUpArrow));
    SendDlgItemMessage(IDC_MOVEDOWN, BM_SETIMAGE, IMAGE_ICON,
                       reinterpret_cast<LPARAM>(m_hiconDownArrow));

    UpdateUpDownButtons(hwndTV);

    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Method: CProviderOrderDlg::OnContextMenu
//
//  Desc:   Bring up context-sensitive help
//
//  Args:   Standard command parameters
//
//  Return: LRESULT
//
LRESULT
CProviderOrderDlg::OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled)
{
    ::WinHelp(m_hWnd,
              c_szNetCfgHelpFile,
              HELP_CONTEXTMENU,
              reinterpret_cast<ULONG_PTR>(g_aHelpIDs_IDD_ADVCFG_Provider));
    
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Method: CProviderOrderDlg::OnHelp
//
//  Desc:   Bring up context-sensitive help when dragging ? icon over a control
//
//  Args:   Standard command parameters
//
//  Return: LRESULT
//
//
LRESULT
CProviderOrderDlg::OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled)
{
    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);
    Assert(lphi);

    if ((g_aHelpIDs_IDD_ADVCFG_Provider != NULL) && (HELPINFO_WINDOW == lphi->iContextType))
    {
        ::WinHelp(static_cast<HWND>(lphi->hItemHandle),
                  c_szNetCfgHelpFile,
                  HELP_WM_HELP,
                  (ULONG_PTR)g_aHelpIDs_IDD_ADVCFG_Provider);
    }
    return 0;
}

//+--------------------------------------------------------------------------
//
//  Method: CProviderOrderDlg::OnOk
//
//  Desc:   if we found network or print providers, write out the new values
//
//  Args:   [usual dialog stuff]
//
//  Return: LRESULT
//
//  Notes:
//
// History: 1-Dec-97    SumitC      Created
//
//---------------------------------------------------------------------------
LRESULT
CProviderOrderDlg::OnOk(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    HRESULT     hr;
    HWND        hwndTV;

    CWaitCursor wc;

    hwndTV = GetDlgItem(IDC_TREEVIEW);
    hr = m_fNoNetworkProv ? S_OK : WriteProviders(hwndTV, FALSE);
    if (hr == S_OK)
    {
        hr = m_fNoPrintProv ? S_OK : WriteProviders(hwndTV, TRUE);
        if (FAILED(hr))
        {
            NcMsgBox(_Module.GetResourceInstance(), m_hWnd, 
                IDS_ADVANCEDLG_WRITE_PROVIDERS_CAPTION, 
                IDS_ADVANCEDLG_WRITE_PRINT_PROVIDERS_ERROR, 
                MB_OK | MB_ICONEXCLAMATION);
        }
    }
    else
    {
        NcMsgBox(_Module.GetResourceInstance(), m_hWnd, 
            IDS_ADVANCEDLG_WRITE_PROVIDERS_CAPTION, 
            IDS_ADVANCEDLG_WRITE_NET_PROVIDERS_ERROR, 
            MB_OK | MB_ICONEXCLAMATION);
    }

    

    TraceError("CProviderOrderDlg::OnOk", hr);
    return LresFromHr(hr);
}


LRESULT
CProviderOrderDlg::OnMoveUp(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    MoveItem(TRUE);

    return 0;
}


LRESULT
CProviderOrderDlg::OnMoveDown(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    MoveItem(FALSE);

    return 0;
}


LRESULT
CProviderOrderDlg::OnTreeItemChanged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    LPNMTREEVIEW pnmtv = (LPNMTREEVIEW)pnmh;

    HWND hwndTV = GetDlgItem(IDC_TREEVIEW);

    if (pnmtv && pnmtv->itemOld.hItem)
        UpdateUpDownButtons(hwndTV);

    return 0;
}



//+--------------------------------------------------------------------------
//
//      Utility member functions
//
//---------------------------------------------------------------------------


//+--------------------------------------------------------------------------
//
//  Method: CProviderOrderDlg::MoveItem
//
//  Desc:   does the list mangling required in order to move an item
//
//  Args:   [fMoveUp] -- true -> move up, false -> move down
//
//  Return: HRESULT
//
//  Notes:
//
// History: 1-Dec-97    SumitC      Created
//
//---------------------------------------------------------------------------
HRESULT
CProviderOrderDlg::MoveItem(bool fMoveUp)
{
    HWND        hwndTV = GetDlgItem(IDC_TREEVIEW);
    HTREEITEM   htiSel = TreeView_GetSelection(hwndTV);
    HTREEITEM   htiOther;
    HTREEITEM   flag;
    WCHAR       achText[c_nMaxProviderTitle+1];
    TV_ITEM     tvi;
    TV_INSERTSTRUCT tvii;

    // find tree element, find which element (iElement)

    tvi.hItem       = htiSel;
    tvi.mask        = TVIF_IMAGE | TVIF_PARAM | TVIF_SELECTEDIMAGE | TVIF_TEXT;
    tvi.pszText     = achText;
    tvi.cchTextMax  = c_nMaxProviderTitle;
    TreeView_GetItem(hwndTV, &tvi);

    // find the item to insert the item after
    if (fMoveUp)
    {
        htiOther = TreeView_GetPrevSibling(hwndTV, htiSel);
        if (NULL != htiOther)
        {
            htiOther = TreeView_GetPrevSibling(hwndTV, htiOther);
        }
        flag = TVI_FIRST;
    }
    else
    {
        htiOther = TreeView_GetNextSibling(hwndTV, htiSel);
        flag = TVI_LAST;
    }

    // insert into new location
    if (NULL == htiOther)
    {
        tvii.hInsertAfter = flag;
    }
    else
    {
        tvii.hInsertAfter = htiOther;
    }
    tvii.hParent = TreeView_GetParent(hwndTV, htiSel);
    tvii.item = tvi;

    htiOther = TreeView_InsertItem(hwndTV, &tvii);

    // remove from old location
    TreeView_DeleteItem(hwndTV, htiSel);

    // set selection focus to new location
    TreeView_SelectItem(hwndTV, htiOther);

    return S_OK;
}


//+--------------------------------------------------------------------------
//
//  Method: CProviderOrderDlg::UpdateUpDownButtons
//
//  Desc:   enables/disables the up and down arrows as appropriate
//
//  Args:   [hwndTV] -- handle to the treeview root
//
//  Return: HRESULT
//
//  Notes:
//
// History: 1-Dec-97    SumitC      Created
//
//---------------------------------------------------------------------------
HRESULT
CProviderOrderDlg::UpdateUpDownButtons(HWND hwndTV)
{
    HTREEITEM   htiSel;
    bool        fEnableUp, fEnableDown;
    HWND        hwndUp = GetDlgItem(IDC_MOVEUP);
    HWND        hwndDn = GetDlgItem(IDC_MOVEDOWN);
    HWND        hwndFocus = GetFocus();
    HWND        hwndNewFocus = hwndTV;
    UINT        nIdNewDef = 0;

    // Initialize to disabled
    fEnableUp = fEnableDown = FALSE;

    if (htiSel = TreeView_GetSelection(hwndTV))
    {
        // if this item has no children it can be moved.
        //
        if (TreeView_GetChild(hwndTV, htiSel) == NULL)
        {
            if (TreeView_GetPrevSibling(hwndTV, htiSel) != NULL)
            {
                // Enable Move Up button
                fEnableUp = TRUE;
            }

            if (TreeView_GetNextSibling(hwndTV, htiSel) != NULL)
            {
                // Enable Move Down button
                fEnableDown = TRUE;
            }
        }
    }

    if ((hwndFocus == hwndUp) && (FALSE == fEnableUp))
    {
        if (fEnableDown)
        {
            hwndNewFocus = hwndDn;
            nIdNewDef = IDC_MOVEDOWN;
        }

        SetDefaultButton(m_hWnd, nIdNewDef);
        ::SetFocus(hwndNewFocus);
    }
    else if ((hwndFocus == hwndDn) && (FALSE == fEnableDown))
    {
        if (fEnableUp)
        {
            hwndNewFocus = hwndUp;
            nIdNewDef = IDC_MOVEUP;
        }

        SetDefaultButton(m_hWnd, nIdNewDef);
        ::SetFocus(hwndNewFocus);
    }
    else
    {
        // Neither Up or Down is button with focus, remove any default button
        //
        SetDefaultButton(m_hWnd, 0);
    }

    ::EnableWindow(hwndUp, fEnableUp);
    ::EnableWindow(hwndDn, fEnableDown);

    return S_OK;
}


//+--------------------------------------------------------------------------
//
//  Method: CProviderOrderDlg::WriteProviders
//
//  Desc:   writes out, to the registry, the providers for network/print,
//
//  Args:   [hwndTV] -- handle to treeview
//          [fPrint] -- true -> print, false -> network
//
//  Return: HRESULT
//
//  Notes:
//
// History: 1-Dec-97    SumitC      Created
//
//---------------------------------------------------------------------------
HRESULT
CProviderOrderDlg::WriteProviders(HWND hwndTV, bool fPrint)
{
    HRESULT     hr = S_OK;
    ListStrings lstrNewOrder;
    HTREEITEM   htvi;
    TV_ITEM     tvi;
    WCHAR       achBuf[c_nMaxProviderTitle+1];
    HKEY        hkey = NULL;

    tvi.mask = TVIF_TEXT;
    tvi.pszText = achBuf;
    tvi.cchTextMax = c_nMaxProviderTitle;

    // retrieve items in order

    ListStrings * plstrProvider = fPrint ? &m_lstrPrint : &m_lstrNetwork;

#if DBG
    DumpItemList(*plstrProvider, "WriteProviders list (just before clearing)");
#endif
    plstrProvider->clear();
    //  we clear out the provider list, but NOTE! we don't delete the tstrings,
    //  since they're still being referenced by the lParams of the treeview items.
    //  the following block of code gets them back into (a new) m_lstrX.

    htvi = TreeView_GetChild(hwndTV, fPrint ? m_htiPrint : m_htiNetwork);
    while (NULL != htvi)
    {
        tvi.hItem = htvi;
        TreeView_GetItem(hwndTV, &tvi);
        TraceTag(ttidAdvCfg, "recovered item: %S and %S", tvi.pszText, ((tstring *)(tvi.lParam))->c_str());
        plstrProvider->push_back((tstring *)(tvi.lParam));
        htvi = TreeView_GetNextSibling(hwndTV, htvi);
    }

    if (fPrint)
    {
#if DBG
        DumpItemList(m_lstrPrint, "PrintProviders");
#endif
        PROVIDOR_INFO_2  p2info;

        ColStringToMultiSz(m_lstrPrint, &p2info.pOrder);
        if (!AddPrintProvidor(NULL, 2, reinterpret_cast<LPBYTE>(&p2info)))
        {
            hr = HrFromLastWin32Error();
        }
        delete [] p2info.pOrder;
    }
    else
    {
        hr = ::HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szNetwkProviderKey, KEY_WRITE, &hkey);
        if (hr == S_OK)
        {
            tstring str;

            ::ConvertColStringToString(m_lstrNetwork, c_chComma, str);
#if DBG
            TraceTag(ttidAdvCfg, "net providers = %S", str.c_str());
#endif
            hr = ::HrRegSetSz(hkey, c_szNetwkProviderValue, str.c_str());
        }
    }

    RegSafeCloseKey(hkey);
    return hr;
}



//+--------------------------------------------------------------------------
//
//      Utility functions (non-member)
//
//---------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//
//  Func:   AppendItem
//
//  Desc:   adds one item into a treeview control
//
//  Args:
//
//  Return:
//
//  Notes:
//
// History: 1-Dec-97    SumitC      Created
//
//--------------------------------------------------------------------------

HTREEITEM
AppendItem(HWND hwndTV, HTREEITEM htiRoot, PCWSTR pszText, void * lParam, INT iImage)
{
    TV_INSERTSTRUCT tvis;

    tvis.hParent                = htiRoot;
    tvis.hInsertAfter           = TVI_LAST;
    tvis.item.mask              = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM;
    tvis.item.pszText           = (PWSTR) pszText;
    tvis.item.iImage            = iImage;
    tvis.item.iSelectedImage    = iImage;
    tvis.item.lParam            = (LPARAM) lParam;
    TraceTag(ttidAdvCfg, "append item: item = %S, data = %S", pszText, lParam ? ((tstring *)(lParam))->c_str() : L"null");

    return( TreeView_InsertItem( hwndTV, &tvis ) );
}


//+--------------------------------------------------------------------------
//
//  Func:   AppendItemList
//
//  Desc:   adds a list of providers as subitems to a given tree node.
//
//  Args:
//
//  Return: (void)
//
//  Notes:
//
// History: 1-Dec-97    SumitC      Created
//
//---------------------------------------------------------------------------
void
AppendItemList(HWND hwndTV, HTREEITEM htiRoot, ListStrings lstr, ListStrings lstr2, INT iImage)
{
    ListIter    iter;
    ListIter    iter2;

    AssertSz(lstr.size() == lstr2.size(), "data corruption - these lists should the same size");
    for (iter = lstr.begin(), iter2 = lstr2.begin();
         iter != lstr.end();
         iter++, iter2++)
    {
        AppendItem(hwndTV, (HTREEITEM)htiRoot, (*iter)->c_str(), (void *)(*iter2), iImage);
    }
}


//+--------------------------------------------------------------------------
//
//  Meth:   ReadNetworkProviders
//
//  Desc:   fills up lstr with network provider names, and lstrDisp with the
//          corresponding 'friendly' names.
//
//  Args:   [lstr]     -- string list for providers (short names)
//          [lstrDisp] -- string list for provider display-names (friendly names)
//
//  Return: HRESULT
//
//  Notes:  m_lstrNetwork and m_lstrNetworkDisp must be empty on entry.
//
// History: 1-Dec-97    SumitC      Created
//
//---------------------------------------------------------------------------
HRESULT
ReadNetworkProviders(ListStrings& lstr, ListStrings& lstrDisp)
{
    HKEY        hkey;
    HRESULT     hr;
    ListIter    iter;

    AssertSz(lstr.empty(), "incorrect call order (this should be empty)");

    WCHAR szBuf[c_nMaxProviderTitle + 1];
    DWORD cBuf = sizeof(szBuf);

    hr = ::HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szNetwkProviderKey, KEY_READ, &hkey);
    if (hr == S_OK)
    {
        hr = ::HrRegQuerySzBuffer(hkey, c_szNetwkProviderValue, szBuf, &cBuf);
        if (hr == S_OK)
        {
            ConvertStringToColString(szBuf, c_chComma, lstr);
        }
        RegSafeCloseKey(hkey);
    }

    if (hr)
        goto Error;

    AssertSz(lstrDisp.empty(), "incorrect call order (this should be empty)");
    for (iter = lstr.begin(); iter != lstr.end(); iter++)
    {
        WCHAR   szBuf[c_nMaxProviderTitle + sizeof(c_szNetwkService0)];
        tstring str;
        HKEY    hkeyProv;

        wsprintfW(szBuf, c_szNetwkService0, (*iter)->c_str());
        hr = ::HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, szBuf, KEY_READ, &hkeyProv);
        if (hr == S_OK)
        {
#if 0
            DWORD dwClass = 0;

            // now get displayname and class
            hr = ::HrRegQueryDword(hkeyProv, c_szNetwkClass, &dwClass);
            if (dwClass & WN_NETWORK_CLASS)
            {
#endif
                hr = ::HrRegQueryString(hkeyProv, c_szNetwkDisplayName, &str);
                if (hr == S_OK)
                {
                    lstrDisp.push_back(new tstring(str));
                }
                else
                {
                    TraceTag(ttidAdvCfg, "failed to get DisplayName for network provider %S", (*iter)->c_str());
                }
#if 0
            }
            else
            {
                hr = S_OK;
                // actually, if we start taking the netclass into account we'll
                // have to delete the corresponding item (*iter) from m_lstrNetwork,
                // otherwise the two lists will be out of sync.
            }
#endif
            RegSafeCloseKey(hkeyProv);
        }
        else
        {
            TraceTag(ttidAdvCfg, "a member of the networkprovider string is missing NetworkProvider key under Services!");
        }
    }

    AssertSz(lstr.size() == lstrDisp.size(), "lists must be the same size");

Error:
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Method: ReadPrintProviders
//
//  Desc:   fills up lstr with print provider names, and lstrDisp with the
//          corresponding 'friendly' names.
//
//  Args:   [lstr]     -- string list for providers (short names)
//          [lstrDisp] -- string list for provider display-names (friendly names)
//
//  Return: HRESULT
//
//  Notes:  m_lstrPrint and m_lstrPrintDisp must be empty on entry.
//
// History: 1-Dec-97    SumitC      Created
//
//---------------------------------------------------------------------------
HRESULT
ReadPrintProviders(ListStrings& lstr, ListStrings& lstrDisp)
{
    HKEY        hkey;
    HRESULT     hr;
    ListIter    iter;

    AssertSz(lstr.empty(), "incorrect call order (this should be empty)");
    hr = ::HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szPrintProviderKey, KEY_READ, &hkey);
    if (hr == S_OK)
    {
        hr = ::HrRegQueryColString(hkey, c_szPrintProviderValue, &lstr);
        RegSafeCloseKey(hkey);
    }

    AssertSz(lstrDisp.empty(), "incorrect call order (this should be empty)");
    for (iter = lstr.begin(); iter != lstr.end(); iter++)
    {
        WCHAR   szBuf[c_nMaxProviderTitle + sizeof(c_szPrintService0)];
        tstring str;
        HKEY    hkeyProv;

        wsprintfW(szBuf, c_szPrintService0, (*iter)->c_str());
        hr = ::HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, szBuf, KEY_READ, &hkeyProv);
        if (hr == S_OK)
        {
            hr = ::HrRegQueryString(hkeyProv, c_szPrintDisplayName, &str);
            if (hr == S_OK)
            {
                lstrDisp.push_back(new tstring(str));
            }
            else
            {
                TraceTag(ttidAdvCfg, "failed to get DisplayName for printer %S", (*iter)->c_str());
            }
            RegSafeCloseKey(hkeyProv);
        }
        else
        {
            TraceTag(ttidAdvCfg, "a member of the print/providers/order string doesn't have key under control/print/providers!");
        }
    }

    AssertSz(lstr.size() == lstrDisp.size(), "lists must be the same size");

    return hr;
}


bool
AreThereMultipleProviders(void)
{
    HRESULT             hr;
    ListStrings         lstrN, lstrND, lstrP, lstrPD;   // netwk, netwk display, etc..
    bool                fRetval = FALSE;

    hr = ReadNetworkProviders(lstrN, lstrND);
    if (hr == S_OK)
    {
        hr = ReadPrintProviders(lstrP, lstrPD);
        if (hr == S_OK)
        {
            fRetval = ((lstrN.size() > 1) || (lstrP.size() > 1));
        }
    }

    DeleteColString(&lstrN);
    DeleteColString(&lstrND);
    DeleteColString(&lstrP);
    DeleteColString(&lstrPD);

    return fRetval;
}


#if DBG

//+--------------------------------------------------------------------------
//
//  Funct:  DumpItemList
//
//  Desc:   debug utility function to dump out the given list
//
//  Args:
//
//  Return: (void)
//
//  Notes:
//
// History: 1-Dec-97    SumitC      Created
//
//---------------------------------------------------------------------------
static void
DumpItemList(ListStrings& lstr, PSTR szInfoAboutList = NULL)
{
    ListIter iter;

    if (szInfoAboutList)
    {
        TraceTag(ttidAdvCfg, "Dumping contents of: %s", szInfoAboutList);
    }

    for (iter = lstr.begin(); iter != lstr.end(); ++iter)
    {
        PWSTR psz = (PWSTR)((*iter)->c_str());
        TraceTag(ttidAdvCfg, "%S", psz);
    }
    TraceTag(ttidAdvCfg, "... end list");
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\shell\advcfg\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by advcfg.rc
//
#define IDCUR_AFTER                     3101
#define IDS_NCPA_NETWORK                5251
#define IDS_NCPA_PRINT                  5252
#define IDC_STATIC_LINE                 7000
#define LVW_Adapters                    25000
#define PSB_Adapter_Up                  25001
#define PSB_Adapter_Down                25002
#define TVW_Bindings                    25003
#define PSB_Binding_Up                  25004
#define PSB_Binding_Down                25005
#define PSB_Provider_Order              25006
#define IDD_Advanced_Config             25009
#define IDD_ADVCFG_Bindings             25009
#define IDD_PROVIDER                    25010
#define IDD_ADVCFG_Provider             25010
#define IDC_TREEVIEW                    25011
#define IDC_MOVEUP                      25012
#define IDC_MOVEDOWN                    25013
#define IDS_ADVCFG_LOCK_DESC            25100
#define IDS_BINDINGS_FOR                25101
#define IDS_ADVCFG_CAPTION              25102
#define IDS_ADVCFG_CANT_LOCK            25103
#define IDS_ADVCFG_GENERIC_COMP         25104
#define IDS_ADVCFG_PROPSHEET_TITLE      25108
#define IDS_ADVCFG_WAN_ADAPTERS         25109
#define IDS_ADVCFG_NEED_REBOOT          25110
#define TXT_Bindings_For                25111
#define IDH_TXT_AdvCfg_Network          25112
#define IDH_TXT_Advcfg_Connections      25113
#define IDH_TXT_ADVGFG_BINDINGS         25114
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1010
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\shell\commconn\commconn.cpp ===
#include "pch.h"
#pragma hdrstop
#include "commconn.h"    // Standard shell\commconn includes
#include "commconp.h"    // Private shell\commconn includes
#include "conprops.h"
#include "nceh.h"
#include "resource.h"
#include "wizentry.h"


CConnectionCommonUi::CConnectionCommonUi() :
        m_pconMan(NULL),
        m_hIL(NULL)
{
}

CConnectionCommonUi::~CConnectionCommonUi()
{
    ReleaseObj(m_pconMan);
    if (NULL != m_hIL)
        ImageList_Destroy(m_hIL);
}

HRESULT CConnectionCommonUi::HrInitialize()
{
    HRESULT hr = NOERROR;

    // Get the connection manager if we haven't already
    if (NULL == m_pconMan)
    {
        INITCOMMONCONTROLSEX iccex = {0};
        iccex.dwSize = sizeof(INITCOMMONCONTROLSEX);
        iccex.dwICC = ICC_USEREX_CLASSES;

        hr = HrCreateInstance(
            CLSID_ConnectionManager,
            CLSCTX_LOCAL_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
            &m_pconMan);

        TraceHr(ttidError, FAL, hr, FALSE, "HrCreateInstance");

        if (FAILED(hr))
            goto Error;

        // Init the new common controls
        if (FALSE == InitCommonControlsEx(&iccex))
        {
            hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
            goto Error;
        }

        hr = CChooseConnectionDlg::HrLoadImageList(&m_hIL);
    }

Error:
    TraceError("CConnectionCommonUi::HrInitialize",hr);
    return hr;
}

HRESULT CConnectionCommonUi::ChooseConnection(
        NETCON_CHOOSECONN * pChooseConn,
        INetConnection** ppConn)
{
    HRESULT hr     = E_POINTER;

    COM_PROTECT_TRY
    {
        INT_PTR                nRet;
        CChooseConnectionDlg * pdlg = NULL;

        // Parameter Validation
        if ((NULL == pChooseConn) ||
            IsBadReadPtr(pChooseConn, sizeof(NETCON_CHOOSECONN)) ||
            ((NULL != ppConn) && IsBadWritePtr(ppConn, sizeof(INetConnection*))))
        {
            goto Error;
        }

        if ((sizeof(NETCON_CHOOSECONN) != pChooseConn->lStructSize) ||
            ((~NCCHT_ALL) & pChooseConn->dwTypeMask) ||
            ((NULL != pChooseConn->hwndParent) && !IsWindow(pChooseConn->hwndParent)) ||
            (~(NCCHF_CONNECT | NCCHF_CAPTION | NCCHF_AUTOSELECT |
               NCCHF_OKBTTNTEXT | NCCHF_DISABLENEW) & pChooseConn->dwFlags))
        {
            hr = E_INVALIDARG;
            goto Error;
        }

        if ((pChooseConn->dwFlags & NCCHF_CAPTION) &&
            ((NULL == pChooseConn->lpstrCaption) ||
             IsBadStringPtr(pChooseConn->lpstrCaption, 1024)))
        {
            goto Error;
        }

        if ((pChooseConn->dwFlags & NCCHF_OKBTTNTEXT) &&
            ((NULL == pChooseConn->lpstrOkBttnText) ||
             IsBadStringPtr(pChooseConn->lpstrOkBttnText, 1024)))
        {
            goto Error;
        }

        // Initialize
        hr = HrInitialize();
        if (FAILED(hr))
        {
            goto Error;
        }

        // Render the dialog
        Assert(PConMan());
        pdlg = new CChooseConnectionDlg(pChooseConn, this, ppConn);
        if (NULL == pdlg)
        {
            hr = E_OUTOFMEMORY;
            goto Error;
        }

        hr = S_OK;
        nRet = DialogBoxParam(_Module.GetResourceInstance(),
                              MAKEINTRESOURCE(IDD_ConnChooser),
                              pChooseConn->hwndParent,
                              CChooseConnectionDlg::dlgprocConnChooser,
                              (LPARAM)pdlg);
        if (IDOK != nRet)
        {
            hr = S_FALSE;
        }

        delete pdlg;

Error:
    ;
    }
    COM_PROTECT_CATCH

    TraceErrorOptional("CConnectionCommonUi::ChooseConnection", hr, (S_FALSE==hr));
    return hr;
}


HRESULT CConnectionCommonUi::ShowConnectionProperties (
        HWND hwndParent,
        INetConnection* pCon)
{
    HRESULT          hr       = E_INVALIDARG;
    INetConnection * pConnTmp = NULL;

    COM_PROTECT_TRY
    {
        // Parameter Validation
        if (((NULL != hwndParent) && !IsWindow(hwndParent)))
        {
            goto Error;
        }

        if ((NULL == pCon) || IsBadReadPtr(pCon, sizeof(INetConnection*)))
        {
            hr = E_POINTER;
            goto Error;
        }

        if (FAILED(HrQIAndSetProxyBlanket(pCon, &pConnTmp)))
        {
            hr = E_NOINTERFACE;
            goto Error;
        }
        Assert(NULL != pConnTmp);
        pConnTmp->Release();

        // Initialize
        hr = HrInitialize();
        if (FAILED(hr))
        {
            goto Error;
        }

        hr = HrRaiseConnectionProperties(hwndParent, pCon);

Error:
    ;
    }
    COM_PROTECT_CATCH

    TraceErrorOptional("CConnectionCommonUi::ShowConnectionProperties", hr, (S_FALSE==hr));
    return hr;
}

HRESULT CConnectionCommonUi::StartNewConnectionWizard (
        HWND hwndParent,
        INetConnection** ppCon)
{
    HRESULT hr = E_INVALIDARG;

    COM_PROTECT_TRY
    {
        // Parameter Validation
        if ((NULL != hwndParent) && !IsWindow(hwndParent))
        {
            goto Error;
        }

        if ((NULL == ppCon) || IsBadWritePtr(ppCon, sizeof(INetConnection*)))
        {
            hr = E_POINTER;
            goto Error;
        }

        // Initialize
        hr = HrInitialize();
        if (FAILED(hr))
        {
            goto Error;
        }

        *ppCon = NULL;
        hr = NetSetupAddRasConnection(hwndParent, ppCon);

Error:
    ;
    }
    COM_PROTECT_CATCH

    TraceErrorOptional("CConnectionCommonUi::StartNewConnectionWizard", hr, (S_FALSE==hr));
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\shell\commconn\commconp.cpp ===
#include "pch.h"
#pragma hdrstop

#include "ncnetcon.h"
#include "conprops.h"
#include "commconn.h"    // Standard shell\commconn includes
#include "commconp.h"    // Private shell\commconn includes
#include "resource.h"
#include "ncperms.h"



typedef struct
{
    NETCON_MEDIATYPE  nct;
    NETCON_CHOOSETYPE ncct;
    UINT              nIDI;
    INT               nIDI_Idx;
} ConnTypeChooserMap;
static ConnTypeChooserMap ConnTypeMap[] = {
        {NCM_DIRECT,         NCCHT_DIRECT_CONNECT, IDI_DB_GEN_S_16, 0},
        {NCM_LAN,            NCCHT_LAN,            IDI_LB_GEN_S_16, 0},
        {NCM_PHONE,          NCCHT_PHONE,          IDI_PB_GEN_S_16, 0},
        {NCM_ISDN,           NCCHT_ISDN,           IDI_PB_GEN_S_16, 0},
        {NCM_TUNNEL,         NCCHT_TUNNEL,         IDI_TB_GEN_S_16, 0}};

CChooseConnectionData::CChooseConnectionData(INetConnection * pConn)
{
    Assert(pConn);
    m_pConn = pConn;
    AddRefObj(m_pConn);

    m_Nct    = NCM_LAN;
    m_Ncs    = NCS_DISCONNECTED;
    m_dwChar = 0;
}

HRESULT CChooseConnectionData::HrCreate(INetConnection * pNetCon,
                                        CChooseConnectionData **ppData)
{
    HRESULT                 hr = E_OUTOFMEMORY;
    CChooseConnectionData * pData = NULL;
    NETCON_PROPERTIES *     pProps = NULL;

    pData = new CChooseConnectionData(pNetCon);
    if (NULL == pData)
        goto Error;

    hr = pNetCon->GetProperties(&pProps);
    if (FAILED(hr))
        goto Error;

    Assert(NULL != pProps->pszwName);
    pData->SetName(pProps->pszwName);
    pData->SetCharacteristics(pProps->dwCharacter);
    pData->SetType(pProps->MediaType);
    pData->SetStatus(pProps->Status);

Error:
    if (FAILED(hr))
    {
        delete pData;
    }
    else
    {
        Assert(NULL != pData);
        *ppData = pData;
    }

    FreeNetconProperties(pProps);

    TraceError("CChooseConnectionData::HrCreate",hr);
    return hr;
}

CChooseConnectionData::~CChooseConnectionData()
{
    ReleaseObj(m_pConn);
}


CChooseConnectionDlg::CChooseConnectionDlg(NETCON_CHOOSECONN * pChooseConn,
                                           CConnectionCommonUi * pConnUi,
                                           INetConnection** ppConn)
{
    Assert(pChooseConn);
    Assert(pConnUi);

    m_pChooseConn = pChooseConn;
    m_pConnUi = pConnUi;
    m_ppConn = ppConn;          // The optional out parameter
    if (NULL != m_ppConn)
    {
        *m_ppConn = NULL;
    }

    m_hWnd = NULL;
}

CChooseConnectionDlg::~CChooseConnectionDlg()
{
    m_pChooseConn = NULL;
    m_pConnUi = NULL;
}

HRESULT CChooseConnectionDlg::HrLoadImageList(HIMAGELIST  * pIL)
{
    UINT        nIdx;
    HRESULT     hr  = E_OUTOFMEMORY;
    HIMAGELIST  hIL = ImageList_Create(16, 16, TRUE, 6, 1);
    if (NULL == hIL)
        goto Error;

    for (nIdx=0; nIdx<celems(ConnTypeMap); nIdx++)
    {
        HICON hIcon = LoadIcon(_Module.GetResourceInstance(),
                               MAKEINTRESOURCE(ConnTypeMap[nIdx].nIDI));
        Assert(NULL != hIcon);
        ConnTypeMap[nIdx].nIDI_Idx = ImageList_AddIcon(hIL, hIcon);
        if (-1 == ConnTypeMap[nIdx].nIDI_Idx)
            goto Error;
    }

    *pIL = hIL;
    hr = S_OK;

Error:
    TraceError("CChooseConnectionDlg::HrLoadImageList",hr);
    return hr;
}

VOID CChooseConnectionDlg::ReleaseData()
{
    if (NULL != m_hWnd)
    {
        HWND hwndCMB = GetDlgItem(m_hWnd, CMB_CHOOSER_LIST);
        LONG lCnt = (LONG)SendMessage(hwndCMB, CB_GETCOUNT, 0, 0);
        for (;lCnt>0;)
        {
            CChooseConnectionData * pData = GetData(--lCnt);
            delete pData;
        }

        SendMessage(hwndCMB, CB_RESETCONTENT, 0, 0);
    }
}

BOOL CChooseConnectionDlg::IsConnTypeInMask(NETCON_MEDIATYPE nct)
{
    BOOL fFound = FALSE;

    for (UINT nIdx=0; nIdx<celems(ConnTypeMap); nIdx++)
    {
        if ((ConnTypeMap[nIdx].nct == nct) &&
            (ConnTypeMap[nIdx].ncct & m_pChooseConn->dwTypeMask))
        {
            fFound = TRUE;
            break;
        }
    }

    return fFound;
}

INT CChooseConnectionDlg::ConnTypeToImageIdx(NETCON_MEDIATYPE nct)
{
    UINT nIdx;
    for (nIdx=0; nIdx<celems(ConnTypeMap); nIdx++)
        if (ConnTypeMap[nIdx].nct == nct)
            break;

    Assert(nIdx < celems(ConnTypeMap));;
    return ConnTypeMap[nIdx].nIDI_Idx;
}

LONG CChooseConnectionDlg::FillChooserCombo()
{
    HRESULT         hr;
    LONG            lCnt = 0;
    COMBOBOXEXITEM  CBItem = {0};
    HWND            hwndCMB = GetDlgItem(m_hWnd, CMB_CHOOSER_LIST);

    // Free anything currently in the combo box
    ReleaseData();

    // Query new data for the combo box
    Assert(NULL != m_pConnUi->PConMan());

    INetConnection * pNetCon;
    CIterNetCon ncIter(m_pConnUi->PConMan(), NCME_DEFAULT);
    hr = S_OK;
    while (SUCCEEDED(hr) &&
           S_OK == (hr = ncIter.HrNext(&pNetCon)))
    {
        NETCON_PROPERTIES* pProps;
        hr = pNetCon->GetProperties(&pProps);

        if (SUCCEEDED(hr))
        {
            if (IsConnTypeInMask(pProps->MediaType))
            {
                CChooseConnectionData * pData = NULL;
                hr = CChooseConnectionData::HrCreate(pNetCon, &pData);
                if (SUCCEEDED(hr))
                {
                    pData->SetCharacteristics(pProps->dwCharacter);
                    pData->SetType(pProps->MediaType);
                    pData->SetStatus(pProps->Status);

                    CBItem.mask = CBEIF_IMAGE | CBEIF_SELECTEDIMAGE | CBEIF_LPARAM | CBEIF_TEXT;
                    CBItem.iItem = -1;
                    CBItem.pszText = const_cast<PWSTR>(pData->SzName());
                    CBItem.cchTextMax = lstrlenW(pData->SzName());
                    CBItem.iImage = ConnTypeToImageIdx(pProps->MediaType);
                    CBItem.iSelectedImage = CBItem.iImage;
                    CBItem.lParam = reinterpret_cast<LPARAM>(pData);

                    if (-1 != SendMessage(hwndCMB, CBEM_INSERTITEM, 0, (LPARAM)&CBItem))
                        lCnt++;
                }
            }

            FreeNetconProperties(pProps);
        }

        ReleaseObj(pNetCon);
    }

    if (0 == lCnt)
    {
        // Add a "No connection found" line
        CBItem.mask = CBEIF_IMAGE | CBEIF_SELECTEDIMAGE | CBEIF_TEXT;
        CBItem.iItem = -1;
        CBItem.pszText = const_cast<PWSTR>(SzLoadIds(IDS_NO_CONNECTIONS));
        CBItem.cchTextMax = lstrlenW(SzLoadIds(IDS_NO_CONNECTIONS));
        CBItem.iImage = ConnTypeToImageIdx(NCM_LAN);
        CBItem.iSelectedImage = CBItem.iImage;
        CBItem.lParam = NULL;

        if (-1 != SendMessage(hwndCMB, CBEM_INSERTITEM, 0, (LPARAM)&CBItem))
        {
            SendMessage(hwndCMB, CB_SETCURSEL, 0, 0);
        }
    }

    EnableWindow(hwndCMB, !!lCnt);

    TraceError("CChooseConnectionDlg::FillChooserCombo",hr==S_FALSE ? S_OK: hr);
    return lCnt;
}

CChooseConnectionData * CChooseConnectionDlg::GetData(LPARAM lIdx)
{
    CChooseConnectionData * pData = NULL;
    HWND hwndCMB = GetDlgItem(m_hWnd, CMB_CHOOSER_LIST);
    COMBOBOXEXITEM CBItem = {0};

    CBItem.iItem = lIdx;
    CBItem.mask = CBEIF_LPARAM;
    if (0 != SendMessage(hwndCMB, CBEM_GETITEM, 0, (LPARAM)(PCOMBOBOXEXITEM) &CBItem))
    {
        pData = reinterpret_cast<CChooseConnectionData *>(CBItem.lParam);
    }

    return pData;
}

CChooseConnectionData * CChooseConnectionDlg::GetCurrentData()
{
    HWND hwndCMB = GetDlgItem(m_hWnd, CMB_CHOOSER_LIST);
    LPARAM lParam = SendMessage(hwndCMB, CB_GETCURSEL, 0, 0);

    if (CB_ERR == lParam)
        return NULL;

    return GetData(lParam);
}

BOOL CChooseConnectionDlg::OnInitDialog(HWND hwndDlg)
{
    HWND hwndOk = GetDlgItem(hwndDlg, BTN_CHOOSER_OK);
    HWND hwndCMB = GetDlgItem(hwndDlg, CMB_CHOOSER_LIST);

    m_hWnd = hwndDlg;

    // Set the caption text if necessary
    if (NCCHF_CAPTION & m_pChooseConn->dwFlags)
    {
        SetWindowText(m_hWnd, m_pChooseConn->lpstrCaption);
    }
    else if (NCCHF_CONNECT & m_pChooseConn->dwFlags)
    {
        SetWindowText(m_hWnd, SzLoadIds(IDS_CONNECT_CAPTION));
    }

    // Set the Ok text if necessary
    if (NCCHF_OKBTTNTEXT & m_pChooseConn->dwFlags)
    {
        SetWindowText(hwndOk, m_pChooseConn->lpstrOkBttnText);
    }
    else if (NCCHF_CONNECT & m_pChooseConn->dwFlags)
    {
        SetWindowText(hwndOk, SzLoadIds(IDS_OKBTTNTEXT));
    }

    // Disable the New button if requested or if the user doesn't
    // have rights for it.
    //
    if ((NCCHF_DISABLENEW & m_pChooseConn->dwFlags) ||
        !FHasPermission(NCPERM_NewConnectionWizard))
    {
        EnableWindow(GetDlgItem(m_hWnd, BTN_CHOOSER_NEW), FALSE);
    }

    // Populate the UI
    LONG lCnt = FillChooserCombo();

    Assert(NULL != m_pConnUi->HImageList());
    SendMessage(hwndCMB, CBEM_SETIMAGELIST, 0, (LPARAM)m_pConnUi->HImageList());
    ::SendMessage(hwndCMB, CB_SETCURSEL, 0, 0L);

    // Enable the buttons based on what was found
    UpdateOkState();

    // Special case, if they don't want to be able to create new connections
    // and we're in chooser mode and only one connection exists and the
    // autoselect option is selected, select it and return
    //
    if ((1 == lCnt) && (NCCHF_AUTOSELECT & m_pChooseConn->dwFlags) &&
        IsWindowEnabled(hwndOk))
    {
        PostMessage(hwndDlg, WM_COMMAND, MAKEWPARAM(BTN_CHOOSER_OK, 0),
                    (LPARAM)hwndOk);
    }

    return FALSE;
}

VOID CChooseConnectionDlg::UpdateOkState()
{
    BOOL fEnabledOk = TRUE;
    BOOL fEnabledProps = TRUE;

    CChooseConnectionData * pData = GetCurrentData();
    if (NULL == pData)
    {
        fEnabledOk = FALSE;
        fEnabledProps = FALSE;
    }
    else
    {
        if (NCCHF_CONNECT & m_pChooseConn->dwFlags)
        {
            // If the current connection is not disconnected or if it's
            // a LAN/RAS connection and they don't have connect rights
            // then disable the OK button
            //
            if ((pData->ConnStatus() != NCS_DISCONNECTED) ||
                ((pData->ConnType() == NCM_LAN) && !FHasPermission(NCPERM_LanConnect)) ||
                ((pData->ConnType() != NCM_LAN) && !FHasPermission(NCPERM_RasConnect)))
            {
                fEnabledOk = FALSE;
            }
        }

        // If this is a LAN connection and the user doesn't have rights
        // then disallow properties
        //
        if ((NCM_LAN == pData->ConnType()) &&
              !FHasPermission(NCPERM_LanProperties))
        {
            fEnabledProps = FALSE;
        }

        // If this is a RAS connection and the user doesn't have rights
        // then disallow properties
        //
        if (NCM_LAN != pData->ConnType())
        {
            if (((pData->Characteristics() & NCCF_ALL_USERS) &&
                 !FHasPermission(NCPERM_RasAllUserProperties)) ||
                !FHasPermission(NCPERM_RasMyProperties))
            {
                fEnabledProps = FALSE;
            }
        }
    }

    EnableWindow(GetDlgItem(m_hWnd, BTN_CHOOSER_OK), fEnabledOk);
    EnableWindow(GetDlgItem(m_hWnd, BTN_CHOOSER_PROPS), fEnabledProps);
}

BOOL CChooseConnectionDlg::OnNew()
{
    INetConnection * pConn = NULL;
    HRESULT hr = m_pConnUi->StartNewConnectionWizard (m_hWnd, &pConn);
    if ((S_OK == hr) && (NULL != pConn))
    {
        NETCON_PROPERTIES * pProps = NULL;
        LONG lCnt = FillChooserCombo();
        int  nIdx = CB_ERR;
        HWND hwndCMB = GetDlgItem(m_hWnd, CMB_CHOOSER_LIST);

        Assert(pConn);
        hr = pConn->GetProperties(&pProps);
        ReleaseObj(pConn);
        if (SUCCEEDED(hr) && lCnt && pProps->pszwName)
        {
            nIdx = (int)::SendMessage(hwndCMB, CB_FINDSTRINGEXACT,
                        -1, (LPARAM)pProps->pszwName);
        }

        // Select whatever was found
        ::SendMessage(hwndCMB, CB_SETCURSEL, ((CB_ERR == nIdx) ? 0 : nIdx), 0L);

        UpdateOkState();
        FreeNetconProperties(pProps);
    }
    TraceErrorOptional("CChooseConnectionDlg::OnProps", hr, (S_FALSE==hr));
    return TRUE;
}

BOOL CChooseConnectionDlg::OnProps()
{
    CChooseConnectionData * pData = GetCurrentData();
    if (NULL != pData)
    {
        HRESULT hr = m_pConnUi->ShowConnectionProperties(m_hWnd,
                                        pData->PConnection());
        TraceErrorOptional("CChooseConnectionDlg::OnProps", hr, (S_FALSE==hr));
    }
    return TRUE;
}

BOOL CChooseConnectionDlg::OnOk()
{
    CChooseConnectionData * pData = GetCurrentData();
    if ((NULL != pData) && pData->PConnection())
    {
        if (m_ppConn)
        {
            *m_ppConn = pData->PConnection();
            (*m_ppConn)->AddRef();
        }

        // Launch the connection if we're in NCCHF_CONNECT mode
        if (NCCHF_CONNECT & m_pChooseConn->dwFlags)
        {
            Assert(*m_ppConn);
            HRESULT hr = HrConnectOrDisconnectNetConObject(
                            m_hWnd, pData->PConnection(), CD_CONNECT);
        }

        EndDialog(m_hWnd, IDOK);
    }
    return TRUE;
}

INT_PTR CALLBACK
CChooseConnectionDlg::dlgprocConnChooser(HWND hwndDlg, UINT uMsg,
                                         WPARAM wParam, LPARAM lParam)
{
    BOOL                   frt = FALSE;
    LONG_PTR                lTmp = ::GetWindowLongPtr(hwndDlg, DWLP_USER);
    CChooseConnectionDlg * pdlg = reinterpret_cast<CChooseConnectionDlg *>(lTmp);

    switch (uMsg)
    {
    case WM_INITDIALOG:
        {
            Assert(lParam);
            ::SetWindowLongPtr(hwndDlg, DWLP_USER, lParam);
            pdlg = reinterpret_cast<CChooseConnectionDlg *>(lParam);
            frt = pdlg->OnInitDialog(hwndDlg);
        }
        break;

    case WM_DESTROY:
        if (NULL != pdlg)
        {
            pdlg->ReleaseData();
        }
        break;

    case WM_COMMAND:
        switch (HIWORD(wParam))
        {
        case CBN_SELENDOK:
            if (LOWORD(wParam) == CMB_CHOOSER_LIST)
            {
                Assert(pdlg);
                pdlg->UpdateOkState();
            }
            break;

        case BN_CLICKED:
            switch (LOWORD(wParam))
            {
            case BTN_CHOOSER_NEW:
                Assert(pdlg);
                frt = pdlg->OnNew();
                break;
            case BTN_CHOOSER_PROPS:
                Assert(pdlg);
                frt = pdlg->OnProps();
                break;
            case BTN_CHOOSER_OK:
                Assert(pdlg);
                frt = pdlg->OnOk();
                break;
            case IDCANCEL:
                frt = TRUE;
                EndDialog(hwndDlg, IDCANCEL);
                break;
            }
            break;
        }
        break;

    default:
        frt = FALSE;
        break;
    }

    return frt;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\shell\commconn\commconn.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       C O M M C O N N . H
//
//  Contents:   defines the INetConnectionCommonUi interface.
//
//  Notes:
//
//  Author:     scottbri   14 Jan 1998
//
//----------------------------------------------------------------------------

#pragma once

#ifndef _COMMCONN_H_
#define _COMMCONN_H_

#include <netshell.h>
#include "nsbase.h"
#include "nsres.h"

//    typedef enum tagNETCON_CHOOSEFLAGS
//    {
//        NCCHF_CONNECT    = 0x0001,      // Selected Connection is activated
//                                        // and returned. If not set then
//                                        // the selected connection interface
//                                        // is returned without being activated
//        NCCHF_CAPTION    = 0x0002,
//        NCCHF_OKBTTNTEXT = 0x0004,
//    } NETCON_CHOOSEFLAGS;
//
//    typedef enum tagNETCON_CHOOSETYPE
//    {
//        NCCHT_DIRECT_CONNECT = 0x0001,
//        NCCHT_INBOUND        = 0x0002,
//        NCCHT_CONNECTIONMGR  = 0x0004,
//        NCCHT_LAN            = 0x0008,
//        NCCHT_PHONE          = 0x0010,
//        NCCHT_TUNNEL         = 0x0020,
//        NCCHT_ALL            = 0x003F
//    } NETCON_CHOOSETYPE;
//
//    typedef struct tagNETCON_CHOOSECONN
//    {
//        DWORD       lStructSize;
//        HWND        hwndParent;
//        DWORD       dwFlags;            // Combine NCCHF_* flags
//        DWORD       dwTypeMask;         // Combine NCCHT_* flags
//        PCWSTR     lpstrCaption;
//        PCWSTR     lpstrOkBttnText;
//    } NETCON_CHOOSECONN;

class ATL_NO_VTABLE CConnectionCommonUi :
    public CComObjectRootEx <CComObjectThreadModel>,
    public CComCoClass <CConnectionCommonUi, &CLSID_ConnectionCommonUi>,
    public INetConnectionCommonUi
{
public:
    DECLARE_REGISTRY_RESOURCEID(IDR_COMMCONN)

    BEGIN_COM_MAP(CConnectionCommonUi)
        COM_INTERFACE_ENTRY(INetConnectionCommonUi)
    END_COM_MAP()

    CConnectionCommonUi();
    ~CConnectionCommonUi();

    STDMETHODIMP ChooseConnection(
        NETCON_CHOOSECONN * pChooseConn,
        INetConnection** ppCon);

    STDMETHODIMP ShowConnectionProperties (
        HWND hwndParent,
        INetConnection* pCon);

    STDMETHODIMP StartNewConnectionWizard (
        HWND hwndParent,
        INetConnection** ppCon);

    INetConnectionManager * PConMan()    {return m_pconMan;}
    HIMAGELIST              HImageList() {return m_hIL;}

private:
    HRESULT                 HrInitialize();

private:
    INetConnectionManager * m_pconMan;
    HIMAGELIST              m_hIL;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\shell\commconn\resource.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       R E S O U R C E . H
//
//  Contents:   defines constants for the connections common ui
//
//  Notes:
//
//  Author:     scottbri   14 Jan 1998
//
//----------------------------------------------------------------------------

#pragma once

#ifndef _RESOURCE_H_
#define _RESOURCE_H_


// Dialog IDD's 
#define IDD_ConnChooser         22000

// String ID's   
#define IDS_CONNECT_CAPTION     22010
#define IDS_OKBTTNTEXT          22011
#define IDS_NO_CONNECTIONS      22012

// Control ID's
#define BTN_CHOOSER_OK          22040
#define BTN_CHOOSER_NEW         22041
#define BTN_CHOOSER_PROPS       22042
#define CMB_CHOOSER_LIST        22043
#define TXT_CHOOSER_CMB         22044

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\shell\commconn\commconp.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       C O M M C O N P . H
//
//  Contents:   Private includes for the common connection ui
//
//  Notes:
//
//  Author:     scottbri   15 Jan 1998
//
//----------------------------------------------------------------------------

#pragma once

#ifndef _COMMCONP_H_
#define _COMMCONP_H_

class CChooseConnectionData
{
public:
    static HRESULT HrCreate(INetConnection *, CChooseConnectionData **);
    ~CChooseConnectionData();

    INetConnection * PConnection() {return m_pConn;}
    PCWSTR          SzName() {return m_strName.c_str();}
    VOID             SetCharacteristics(DWORD dw) {m_dwChar = dw;};
    VOID             SetName(PCWSTR sz) {m_strName = sz;}
    VOID             SetStatus(NETCON_STATUS ncs) {m_Ncs = ncs;}
    VOID             SetType(NETCON_MEDIATYPE nct) {m_Nct = nct;}
    NETCON_STATUS    ConnStatus() {return m_Ncs;}
    NETCON_MEDIATYPE ConnType() {return m_Nct;}
    DWORD            Characteristics() {return m_dwChar;}

private:
    CChooseConnectionData(INetConnection *);

private:
    INetConnection * m_pConn;
    NETCON_MEDIATYPE m_Nct;
    NETCON_STATUS    m_Ncs;
    DWORD            m_dwChar;
    tstring          m_strName;
};

class CChooseConnectionDlg
{
public:
    CChooseConnectionDlg(NETCON_CHOOSECONN * pChooseConn,
                         CConnectionCommonUi * pConnUi,
                         INetConnection** ppConn);
    ~CChooseConnectionDlg();

    static INT_PTR CALLBACK dlgprocConnChooser(HWND, UINT, WPARAM, LPARAM);
    static HRESULT HrLoadImageList(HIMAGELIST *);

private:
    CChooseConnectionData * GetData(LPARAM lIdx);
    CChooseConnectionData * GetCurrentData();

    BOOL OnInitDialog(HWND);
    VOID ReleaseData();
    BOOL OnOk();
    BOOL OnNew();
    BOOL OnProps();
    VOID UpdateOkState();
    LONG FillChooserCombo();
    BOOL IsConnTypeInMask(NETCON_MEDIATYPE nct);
    INT  ConnTypeToImageIdx(NETCON_MEDIATYPE nct);

private:
    NETCON_CHOOSECONN   *   m_pChooseConn;
    CConnectionCommonUi *   m_pConnUi;
    INetConnection **       m_ppConn;         // Output parameter

    HWND                    m_hWnd;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\shell\common\openfold.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       O P E N F O L D . C P P
//
//  Contents:   Folder launching code for the connections folder
//
//  Notes:
//
//  Author:     jeffspr   12 Jan 1998
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

// Undocument shell32 stuff.  Sigh.
#define DONT_WANT_SHELLDEBUG 1
#define NO_SHIDLIST 1
#define USE_SHLWAPI_IDLIST

#include "pidlutil.h"

#include <ncdebug.h>

#define AVOID_NET_CONFIG_DUPLICATES

#include "nsbase.h"
#include "nsres.h"
#include <ncdebug.h>
#include <ncreg.h>
#include <netshell.h>
#include <netconp.h>
#include <ncui.h>

#include "cfpidl.h"
#include "openfold.h"

// Note -- Don't convert this to a constant. We need copies of it within the
// functions because ParseDisplayName actually mangles the string.
//
// CLSID_MyComputer
// CLSID_ControlPanel
// CLSID_NetworkConnections
#define NETCON_FOLDER_PATH   L"::{20D04FE0-3AEA-1069-A2D8-08002B30309D}\\" \
                             L"::{21EC2020-3AEA-1069-A2DD-08002B30309D}\\" \
                             L"::{7007ACC7-3202-11D1-AAD2-00805FC1270E}";


//+---------------------------------------------------------------------------
//
//  Function:   HrGetConnectionsFolderPidl
//
//  Purpose:    Get the connections folder pidl. Used in places where we're
//              not folder specific, but we still need to update folder
//              entries.
//
//  Arguments:
//      ppidlFolder [out]   Return parameter for the folder pidl
//
//  Returns:
//
//  Author:     jeffspr   13 Jun 1998
//
//  Notes:
//
HRESULT HrGetConnectionsFolderPidl(OUT PCONFOLDPIDLFOLDER& ppidlFolder)
{
    HRESULT         hr          = S_OK;
    LPSHELLFOLDER   pshf        = NULL;
    LPITEMIDLIST    pidlFolder  = NULL;

    // "::CLSID_MyComputer\\::CLSID_ControlPanel\\::CLSID_ConnectionsFolder"
    WCHAR szNetConFoldPath[] = NETCON_FOLDER_PATH;

    // Get the desktop folder, so we can parse the display name and get
    // the UI object of the connections folder
    //
    hr = SHGetDesktopFolder(&pshf);
    if (SUCCEEDED(hr))
    {
        ULONG           chEaten;

        pidlFolder = NULL;
        hr = pshf->ParseDisplayName(NULL, 0, (WCHAR *) szNetConFoldPath,
            &chEaten, &pidlFolder, NULL);

        ReleaseObj(pshf);
    }

    // If succeeded, fill in the return param.
    //
    if (SUCCEEDED(hr))
    {
        hr = ppidlFolder.InitializeFromItemIDList(pidlFolder);

        SHFree(pidlFolder); // ISSUE: Why can't we free regardless?
    }

    TraceHr(ttidShellFolder, FAL, hr, FALSE, "HrGetConnectionsFolderPidl");
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrOpenConnectionsFolder
//
//  Purpose:    Open the connections folder in explorer.
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     jeffspr   16 Apr 1998
//
//  Notes:
//
HRESULT HrOpenConnectionsFolder()
{
    HRESULT         hr          = S_OK;
    HCURSOR         hcWait      = SetCursor(LoadCursor(NULL, IDC_WAIT));
    PCONFOLDPIDLFOLDER    pidlFolder;

    hr = HrGetConnectionsFolderPidl(pidlFolder);
    if (SUCCEEDED(hr))
    {
        Assert(!pidlFolder.empty());

        SHELLEXECUTEINFO shei = { 0 };
        shei.cbSize     = sizeof(shei);
        shei.fMask      = SEE_MASK_IDLIST | SEE_MASK_INVOKEIDLIST | SEE_MASK_FLAG_DDEWAIT;
        shei.nShow      = SW_SHOW;    // used to be SW_SHOWNORMAL
        shei.lpIDList   = const_cast<LPITEMIDLIST>(pidlFolder.GetItemIdList());

        ShellExecuteEx(&shei);
    }

    if (hcWait)
    {
        SetCursor(hcWait);
    }

    TraceHr(ttidError, FAL, hr, FALSE, "HrOpenConnectionsFolder");
    return hr;
}

HRESULT HrGetConnectionsIShellFolder(
    const PCONFOLDPIDLFOLDER& pidlFolder,
    LPSHELLFOLDER * ppsf)
{
    HRESULT         hr          = S_OK;
    LPSHELLFOLDER   psfDesktop  = NULL;

    Assert(ppsf);
    *ppsf = NULL;

    // Get the desktop folder so we can use it to retrieve the
    // connections folder
    //
    hr = SHGetDesktopFolder(&psfDesktop);
    if (SUCCEEDED(hr))
    {
        Assert(psfDesktop);

        hr = psfDesktop->BindToObject(pidlFolder.GetItemIdList(), NULL, IID_IShellFolder,
            (LPVOID*) ppsf);
    }

    TraceHr(ttidShellFolder, FAL, hr, FALSE, "HrGetConnectionsIShellFolder");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\shell\cpl\cpl.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       C P L . C P P
//
//  Contents:   Entrypoints and other code for the new NCPA
//
//  Notes:
//
//  Author:     jeffspr   12 Jan 1998
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "cplres.h"
#include "nceh.h"

#include <openfold.h>   // For launching connections folder
#include <cpl.h>


//---[ Globals ]--------------------------------------------------------------

HINSTANCE   g_hInst = NULL;

//+---------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Purpose:    Standard DLL entrypoint
//
//  Arguments:
//      hInstance  []   Our instance handle
//      dwReason   []   reason for invocation (attach/detach/etc)
//      lpReserved []   Unused
//
//  Returns:
//
//  Author:     jeffspr   12 Jan 1998
//
//  Notes:
//
BOOL APIENTRY DllMain( HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved )
{
    g_hInst = hInstance;

    if (dwReason == DLL_PROCESS_ATTACH)
    {
#ifndef DBG
        EnableCPPExceptionHandling(); // Translate any SEH exceptions into CPP exceptions.

        InitializeDebugging();
#endif
        if (FIsDebugFlagSet (dfidNetShellBreakOnInit))
        {
            DebugBreak();
        }

        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        UnInitializeDebugging();

        DisableCPPExceptionHandling(); // Disable translation of SEH exceptions into CPP exceptions.
    }
#ifdef DBG
    else if (dwReason == DLL_THREAD_DETACH)
    {
        CTracingIndent::FreeThreadInfo();        
    }
#endif
    
    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   CPlApplet
//
//  Purpose:
//
//  Arguments:
//      hwndCPL [in]    Handle of control panel window
//      uMsg    [in]    message
//      lParam1 [in]
//      lParam2 [in]
//
//  Returns:
//
//  Author:     jeffspr   12 Jan 1998
//
//  Notes:
//
LONG CALLBACK CPlApplet( HWND hwndCPL, UINT uMsg, LPARAM lParam1, LPARAM lParam2 )
{
    TraceFileFunc(ttidShellFolder);
    
    LPNEWCPLINFO    pNewCPlInfo     = NULL;
    LPCPLINFO       pCPlInfo        = NULL;
    INT             iApp            = NULL;
    LONG            lReturn         = 0;

    iApp = ( int ) lParam1;

    switch ( uMsg )
    {
        // First message, sent once.
        //
        case CPL_INIT:
            TraceTag(ttidShellFolder, "NCPA message: CPL_INIT");
            lReturn = 1;    // Successfully initialized
            break;

        // Second message, sent once.
        //
        case CPL_GETCOUNT:
            TraceTag(ttidShellFolder, "NCPA message: CPL_GETCOUNT");
            lReturn = 1;        // We only have one app to support
            break;

        // Third message (alternate, old). Sent once per app
        //
        case CPL_INQUIRE:
            TraceTag(ttidShellFolder, "NCPA message: CPL_INQUIRE");
            pCPlInfo = ( LPCPLINFO ) lParam2;
            pCPlInfo->idIcon = IDI_NCPA;
            pCPlInfo->idName = IDS_NCPTITLE;
            pCPlInfo->idInfo = IDS_NCPDESC;
            pCPlInfo->lData = NULL;
            lReturn = 0;    // Processed successfully
            break;

        // Alternate third message, sent once per app
        //
        case CPL_NEWINQUIRE:
            TraceTag(ttidShellFolder, "NCPA message: CPL_NEWINQUIRE");
            lReturn = 1;    // Ignore this message
            break;

        // Application icon selected. We should never get this message
        //
        case CPL_SELECT:
            TraceTag(ttidShellFolder, "NCPA message: CPL_SELECT");
            lReturn = 1;    // Who cares? We never get this.
            break;

        // Application icon double-clicked.
        // Or application invoked via STARTWPARAMS (through rundll)
        //
        case CPL_DBLCLK:
        case CPL_STARTWPARMSW:
        case CPL_STARTWPARMSA:
            switch(uMsg)
            {
                case CPL_STARTWPARMSW:
                    TraceTag(ttidShellFolder, "NCPA message: CPL_STARTWPARMSW, app: %d, parms: %S",
                        lParam1, lParam2 ? (PWSTR) lParam2 : L"");
                    break;
                case CPL_STARTWPARMSA:
                    TraceTag(ttidShellFolder, "NCPA message: CPL_STARTWPARMSA, app: %d, parms: %s",
                        lParam1, lParam2 ? (PSTR) lParam2 : "");
                    break;
                case CPL_DBLCLK:
                    TraceTag(ttidShellFolder, "NCPA message: CPL_DBLCLK");
                    break;
            }

            // No matter what, we're doing the same thing here
            //
            (VOID) HrOpenConnectionsFolder();

            // Return the correct code. DBLCLK wants 0 == success, the others want (TRUE)
            //
            if (uMsg == CPL_DBLCLK)
                lReturn = 0;    // Processed successfully
            else
                lReturn = 1;    // TRUE, which for the START versions means success
            break;

        // Controlling application closing.
        //
        case CPL_STOP:
            TraceTag(ttidShellFolder, "NCPA message: CPL_STOP");
            lReturn = 0;    // Processed succesfully
            break;

        // We're about to be released. Sent after last CPL_STOP
        //
        case CPL_EXIT:
            TraceTag(ttidShellFolder, "NCPA message: CPL_EXIT");
            lReturn = 0;    // Processed successfully
            break;

        default:
            TraceTag(ttidShellFolder, "NCPA message: CPL_? (%d)", uMsg);
            lReturn = 1;
            break;
    }

    return lReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\shell\cpl\cplres.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       R E S O U R C E . H 
//
//  Contents:   Resource identifiers for the connections folder CPL
//
//  Notes:      
//
//  Author:     jeffspr   12 Jan 1998
//
//----------------------------------------------------------------------------

#ifndef _CPLRES_H_
#define _CPLRES_H_

// Our CPL icon
#define IDI_NCPA                        1001

// Our CPL strings              
#define IDS_NCPTITLE                    2001
#define IDS_NCPDESC                     2002

#endif // _CPLRES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\shell\common\windutil.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       W I N D U T I L . C P P
//
//  Contents:   Window utilities -- For now, just CenterWindow
//
//  Notes:
//
//  Author:     jeffspr   22 May 1998
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop



//+---------------------------------------------------------------------------
//
//  Function:   FCenterWindow
//
//  Purpose:    Center a child window on the parent
//
//  Arguments:
//      hwndChild  [in]     Child window handle
//      hwndParent [in]     Parent window handle (or NULL for desktop)
//
//  Returns:
//
//  Author:     jeffspr   22 May 1998
//
//  Notes:
//
BOOL FCenterWindow (HWND hwndChild, HWND hwndParent)
{
    RECT    rChild, rParent;
    int     wChild, hChild, wParent, hParent;
    int     wScreen, hScreen, xNew, yNew;
    HDC     hdc = NULL;
    BOOL    fReturn = TRUE;

    AssertSz(hwndChild, "Bad Child Window param to CenterWindow");

    // Get the Height and Width of the child window
    //
    GetWindowRect (hwndChild, &rChild);
    wChild = rChild.right - rChild.left;
    hChild = rChild.bottom - rChild.top;

    // Get the Height and Width of the parent window
    //
    if (NULL == hwndParent)
    {
        GetWindowRect (GetDesktopWindow(), &rParent);
    }
    else
    {
        GetWindowRect (hwndParent, &rParent);
    }

    wParent = rParent.right - rParent.left;
    hParent = rParent.bottom - rParent.top;

    // Get the display limits
    //
    hdc = GetDC (hwndChild);
    if (hdc)
    {
        wScreen = GetDeviceCaps (hdc, HORZRES);
        hScreen = GetDeviceCaps (hdc, VERTRES);
        ReleaseDC (hwndChild, hdc);

        // Calculate new X position, then adjust for screen
        //
        xNew = rParent.left + ((wParent - wChild) / 2);
        if (xNew < 0)
        {
            xNew = 0;
        }
        else if ((xNew + wChild) > wScreen)
        {
            xNew = wScreen - wChild;
        }

        // Calculate new Y position, then adjust for screen
        //
        yNew = rParent.top + ((hParent - hChild) / 2);
        if (yNew < 0)
        {
            yNew = 0;
        }
        else if ((yNew + hChild) > hScreen)
        {
            yNew = hScreen - hChild;
        }

        // Set it, and return
        //
        fReturn = SetWindowPos (hwndChild, NULL,
                             xNew, yNew, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
    }
    else
    {
        fReturn = FALSE;
    }

    return fReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\shell\cpl\openfold.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       O P E N F O L D . H 
//
//  Contents:   Utility function for opening the connections folder
//
//  Notes:      
//
//  Author:     jeffspr   12 Jan 1998
//
//----------------------------------------------------------------------------

#ifndef _OPENFOLD_H_
#define _OPENFOLD_H_

// Get our folder pidl
//
HRESULT HrGetConnectionsFolderPidl(LPITEMIDLIST *ppidlFolder);

// Bring up the connections folder UI
//
HRESULT HrOpenConnectionsFolder();

// Get an IShellFolder * given the folder pidl
//
HRESULT HrGetConnectionsIShellFolder(
    LPITEMIDLIST    pidlFolder, 
    LPSHELLFOLDER * ppsf);

// Note -- This code is actually in folder\oncommand.cpp, but can be
// referenced from any place that needs it.
//
VOID    RefreshFolderItem(LPITEMIDLIST pidlFolder, 
                          LPITEMIDLIST pidlItemOld,
                          LPITEMIDLIST pidlItemNew,
                          BOOL fRestart = FALSE);

#endif // _OPENFOLD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\shell\cpl\version.h ===
#pragma once

#include <ntverp.h>
#include <winver.h>

#define VER_FILETYPE                    VFT_DLL
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "Network Connections Control-Panel Stub"
#define VER_INTERNALNAME_STR            "ncpa.cpl"

#include <common.ver>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\shell\dll\dlldatax.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#define USE_STUBLESS_PROXY  //defined only with MIDL switch /Oicf

//#pragma comment(lib, "rpcndr.lib")
//#pragma comment(lib, "rpcns4.lib")
//#pragma comment(lib, "rpcrt4.lib")

#define DllMain             PrxDllMain
#define DllRegisterServer   PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "netshell_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL
WINAPI
PrxDllMain (
    HINSTANCE   hInstance,
    DWORD       dwReason,
    LPVOID      lpReserved)
{
    return TRUE;
}

STDAPI
PrxDllCanUnloadNow ()
{
    return S_OK;
}

STDAPI
PrxDllGetClassObject (
    REFCLSID    rclsid,
    REFIID      riid,
    LPVOID*     ppv)
{
    return CLASS_E_CLASSNOTAVAILABLE;
}

STDAPI
PrxDllRegisterServer ()
{
    return S_OK;
}

STDAPI
PrxDllUnregisterServer ()
{
    return S_OK;
}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\shell\dll\dlldatax.h ===
#pragma once

#ifdef _MERGE_PROXYSTUB

extern "C"
{

BOOL
WINAPI
PrxDllMain (
    HINSTANCE   hInstance,
    DWORD       dwReason,
    LPVOID      lpReserved);

STDAPI
PrxDllCanUnloadNow ();

STDAPI
PrxDllGetClassObject (
    REFCLSID    rclsid,
    REFIID      riid,
    LPVOID*     ppv);

STDAPI
PrxDllRegisterServer ();

STDAPI
PrxDllUnregisterServer ();

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\shell\dll\implinc.cpp ===
#include "pch.h"
#pragma hdrstop
#include "nsbase.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

// Include ATL's implementation.  Substitute _ASSERTE with our Assert.
//
#ifdef _ASSERTE
#undef _ASSERTE
#define _ASSERTE Assert
#endif

#include <atlimpl.cpp>
#ifdef SubclassWindow
#undef SubclassWindow
#endif
#include <atlwin.h>
#include <atlwin.cpp>


#define INITGUID
#include <nmclsid.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\shell\cpl\openfold.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       O P E N F O L D . C P P
//
//  Contents:   Folder launching code for the connections folder
//
//  Notes:
//
//  Author:     jeffspr   12 Jan 1998
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

// Undocument shell32 stuff.  Sigh.
#define DONT_WANT_SHELLDEBUG 1
#define NO_SHIDLIST 1
#define USE_SHLWAPI_IDLIST

#include <commctrl.h>
#include <ncdebug.h>
#include <openfold.h>   // For launching connections folder



// Note -- Don't convert this to a constant. We need copies of it within the
// functions because ParseDisplayName actually mangles the string.
//
// CLSID_MyComputer
// CLSID_ControlPanel
// CLSID_NetworkConnections
#define NETCON_FOLDER_PATH   L"::{20D04FE0-3AEA-1069-A2D8-08002B30309D}\\" \
                             L"::{21EC2020-3AEA-1069-A2DD-08002B30309D}\\" \
                             L"::{7007ACC7-3202-11D1-AAD2-00805FC1270E}";


//+---------------------------------------------------------------------------
//
//  Function:   HrGetConnectionsFolderPidl
//
//  Purpose:    Get the connections folder pidl. Used in places where we're
//              not folder specific, but we still need to update folder
//              entries.
//
//  Arguments:
//      ppidlFolder [out]   Return parameter for the folder pidl
//
//  Returns:
//
//  Author:     jeffspr   13 Jun 1998
//
//  Notes:
//
HRESULT HrGetConnectionsFolderPidl(LPITEMIDLIST *ppidlFolder)
{
    HRESULT         hr          = S_OK;
    LPSHELLFOLDER   pshf        = NULL;
    LPITEMIDLIST    pidlFolder  = NULL;

    Assert(ppidlFolder);

    // "::CLSID_MyComputer\\::CLSID_ControlPanel\\::CLSID_ConnectionsFolder"
    WCHAR szNetConFoldPath[] = NETCON_FOLDER_PATH;

    // Get the desktop folder, so we can parse the display name and get
    // the UI object of the connections folder
    //
    hr = SHGetDesktopFolder(&pshf);
    if (SUCCEEDED(hr))
    {
        ULONG           chEaten;

        hr = pshf->ParseDisplayName(NULL, 0, (WCHAR *) szNetConFoldPath,
            &chEaten, &pidlFolder, NULL);

        ReleaseObj(pshf);
    }

    // If succeeded, fill in the return param.
    //
    if (SUCCEEDED(hr))
    {
        *ppidlFolder = pidlFolder;
    }
    else
    {
        // If we failed, then delete the pidl if we already got it.
        //
        if (pidlFolder)
            SHFree(pidlFolder);
    }

    TraceHr(ttidShellFolder, FAL, hr, FALSE, "HrGetConnectionsFolderPidl");
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrOpenConnectionsFolder
//
//  Purpose:    Open the connections folder in explorer.
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     jeffspr   16 Apr 1998
//
//  Notes:
//
HRESULT HrOpenConnectionsFolder()
{
    HRESULT         hr          = S_OK;
    HCURSOR         hcWait      = SetCursor(LoadCursor(NULL, IDC_WAIT));
    LPITEMIDLIST    pidlFolder  = NULL;;

    hr = HrGetConnectionsFolderPidl(&pidlFolder);
    if (SUCCEEDED(hr))
    {
        Assert(pidlFolder);

        SHELLEXECUTEINFO shei = { 0 };
        shei.cbSize     = sizeof(shei);
        shei.fMask      = SEE_MASK_IDLIST | SEE_MASK_INVOKEIDLIST | SEE_MASK_FLAG_DDEWAIT;
        shei.nShow      = SW_SHOW;    // used to be SW_SHOWNORMAL
        shei.lpIDList   = pidlFolder;

        ShellExecuteEx(&shei);
        SHFree(pidlFolder);
    }

    if (hcWait)
    {
        SetCursor(hcWait);
    }

    TraceHr(ttidError, FAL, hr, FALSE, "HrOpenConnectionsFolder");
    return hr;
}

HRESULT HrGetConnectionsIShellFolder(
    LPITEMIDLIST    pidlFolder,
    LPSHELLFOLDER * ppsf)
{
    HRESULT         hr          = S_OK;
    LPSHELLFOLDER   psfDesktop  = NULL;

    Assert(ppsf);
    *ppsf = NULL;

    // Get the desktop folder so we can use it to retrieve the
    // connections folder
    //
    hr = SHGetDesktopFolder(&psfDesktop);
    if (SUCCEEDED(hr))
    {
        Assert(psfDesktop);

        hr = psfDesktop->BindToObject(pidlFolder, NULL, IID_IShellFolder,
            (LPVOID*) ppsf);
    }

    TraceHr(ttidShellFolder, FAL, hr, FALSE, "HrGetConnectionsIShellFolder");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\shell\dll\dllmain.cpp ===
#include "pch.h"
#pragma hdrstop

// This avoids duplicate definitions with Shell PIDL functions
// and MUST BE DEFINED!
#define AVOID_NET_CONFIG_DUPLICATES

#include "nsbase.h"
#include "nsres.h"
#include "netshell.h"
#include "ncnetcon.h"
#include "ncui.h"
#include "nceh.h"

// Connection Folder Objects
//
// Undocument shell32 stuff.  Sigh.
#define DONT_WANT_SHELLDEBUG 1
#define NO_SHIDLIST 1
#define USE_SHLWAPI_IDLIST

#include <commctrl.h>

#include <netcfgp.h>
#include <netconp.h>
#include <ncui.h>

// Connection UI Objects
//
#include "..\lanui\lanuiobj.h"
#include "..\lanui\lanui.h"
#include "dialupui.h"
#include "intnetui.h"
#include "directui.h"
#include "inbui.h"
#include "vpnui.h"
#include "pppoeui.h"
#include "..\lanui\saui.h"
#include "..\lanui\sauiobj.h"

#include "foldinc.h"
#include "openfold.h"
#include "..\folder\confold.h"
#include "..\folder\foldglob.h"
#include "..\folder\oncommand.h"
#include "..\folder\shutil.h"
#include "..\dun\dunimport.h"

// Connection Tray Objects
//
#include "..\folder\contray.h"

// Common Connection Ui Objects
#include "..\commconn\commconn.h"

#include "netshell_i.c"

// Icon support
#include "..\folder\iconhandler.h"
#include "..\folder\cmdtable.h"

#include "repair.h"

#define INITGUID
#include "nsclsid.h"

//+---------------------------------------------------------------------------
// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file
//      dlldatax.c to the project.  Make sure precompiled headers
//      are turned off for this file, and add _MERGE_PROXYSTUB to the
//      defines for the project.
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for foo.idl by adding the following
//      files to the Outputs.
//          foo_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL,
//      run nmake -f foops.mk in the project directory.

// Proxy/Stub registration entry points
//
#include "dlldatax.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;

CNetConfigIcons *g_pNetConfigIcons = NULL;
CRITICAL_SECTION g_csPidl;

BEGIN_OBJECT_MAP(ObjectMap)

    // Connection UI Objects
    //
    OBJECT_ENTRY(CLSID_DialupConnectionUi,      CDialupConnectionUi)
    OBJECT_ENTRY(CLSID_DirectConnectionUi,      CDirectConnectionUi)
    OBJECT_ENTRY(CLSID_InboundConnectionUi,     CInboundConnectionUi)
    OBJECT_ENTRY(CLSID_LanConnectionUi,         CLanConnectionUi)
    OBJECT_ENTRY(CLSID_VpnConnectionUi,         CVpnConnectionUi)
    OBJECT_ENTRY(CLSID_PPPoEUi,                 CPPPoEUi)
    OBJECT_ENTRY(CLSID_SharedAccessConnectionUi, CSharedAccessConnectionUi)
    OBJECT_ENTRY(CLSID_InternetConnectionUi,      CInternetConnectionUi)

    // Connection Folder and enumerator
    //
    OBJECT_ENTRY(CLSID_ConnectionFolder,        CConnectionFolder)
    OBJECT_ENTRY(CLSID_ConnectionFolderWin98,   CConnectionFolder)
    OBJECT_ENTRY(CLSID_ConnectionFolderEnum,    CConnectionFolderEnum)
    OBJECT_ENTRY(CLSID_ConnectionTray,          CConnectionTray)

    // Connection Common Ui
    OBJECT_ENTRY(CLSID_ConnectionCommonUi,      CConnectionCommonUi)

    OBJECT_ENTRY(CLSID_NetConnectionUiUtilities, CNetConnectionUiUtilities)

END_OBJECT_MAP()

//+---------------------------------------------------------------------------
// DLL Entry Point
//
EXTERN_C
BOOL
WINAPI
DllMain (
    HINSTANCE   hInstance,
    DWORD       dwReason,
    LPVOID      lpReserved)
{
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
    {
        return FALSE;
    }
#endif

    if (dwReason == DLL_PROCESS_ATTACH)
    {
        BOOL fRetVal = FALSE;
#ifndef DBG
        DisableThreadLibraryCalls(hInstance);
#endif
        EnableCPPExceptionHandling(); // Translate any SEH exceptions into CPP exceptions.

        InitializeDebugging();

        if (FIsDebugFlagSet (dfidNetShellBreakOnInit))
        {
            DebugBreak();
        }
        
        // Initialize fusion
        fRetVal = SHFusionInitializeFromModuleID(hInstance, 50);

        Assert(fRetVal);

        _Module.Init(ObjectMap, hInstance);

        InitializeCriticalSection(&g_csPidl);

        // Initialize the list and tie it to the tray (param == TRUE)
        //
        g_ccl.Initialize(TRUE, TRUE);

        g_pNetConfigIcons = new CNetConfigIcons(_Module.GetResourceInstance());
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        DbgCheckPrematureDllUnload ("netshell.dll", _Module.GetLockCount());

        delete g_pNetConfigIcons;

        EnterCriticalSection(&g_csPidl);
        LeaveCriticalSection(&g_csPidl);

        DeleteCriticalSection(&g_csPidl);

        g_ccl.Uninitialize(TRUE);

        _Module.Term();

        SHFusionUninitialize();

        UnInitializeDebugging();

        DisableCPPExceptionHandling(); // Disable translation of SEH exceptions into CPP exceptions.
    }
#ifdef DBG
    else if (dwReason == DLL_THREAD_DETACH)
    {
        CTracingIndent::FreeThreadInfo();        
    }
#endif
    return TRUE;
}

//+---------------------------------------------------------------------------
// Used to determine whether the DLL can be unloaded by OLE
//
STDAPI
DllCanUnloadNow ()
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
    {
        return S_FALSE;
    }
#endif

    return (_Module.GetLockCount() == 0) ? S_OK : S_FALSE;
}

//+---------------------------------------------------------------------------
// Returns a class factory to create an object of the requested type
//
STDAPI
DllGetClassObject (
    REFCLSID    rclsid,
    REFIID      riid,
    LPVOID*     ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
    {
        return S_OK;
    }
#endif

    // The check is to works around an ATL problem where AtlModuleGetClassObject will AV
    // if _Module.m_pObjMap == NULL
    if (_Module.m_pObjMap)
    {
        return _Module.GetClassObject(rclsid, riid, ppv);
    }
    else
    {
        return E_FAIL;
    }
}

//+---------------------------------------------------------------------------
// DllRegisterServer - Adds entries to the system registry
//
STDAPI
DllRegisterServer ()
{
    BOOL fCoUninitialize = TRUE;

    HRESULT hr = CoInitializeEx (NULL,
                    COINIT_DISABLE_OLE1DDE | COINIT_APARTMENTTHREADED);
    if (FAILED(hr))
    {
        fCoUninitialize = FALSE;
        if (RPC_E_CHANGED_MODE == hr)
        {
            hr = S_OK;
        }
    }

    if (SUCCEEDED(hr))
    {
#ifdef _MERGE_PROXYSTUB
        hr = PrxDllRegisterServer ();
        if (FAILED(hr))
        {
            goto Exit;
        }
#endif

        HKEY hkey;
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_SHELLSERVICEOBJECTDELAYED, 0, KEY_WRITE, &hkey))
        {
            RegDeleteValue(hkey, TEXT("Network.ConnectionTray"));
            RegCloseKey(hkey);
        }

        hr = NcAtlModuleRegisterServer (&_Module);
        if (SUCCEEDED(hr))
        {
            hr = HrRegisterFolderClass();
            if (SUCCEEDED(hr))
            {
                hr = HrRegisterDUNFileAssociation();
            }
        }

Exit:
        if (fCoUninitialize)
        {
            CoUninitialize ();
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE, "netshell!DllRegisterServer");
    return hr;
}

//+---------------------------------------------------------------------------
// DllUnregisterServer - Removes entries from the system registry
//
STDAPI
DllUnregisterServer ()
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer ();
#endif

    _Module.UnregisterServer ();

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Function:   NcFreeNetconProperties
//
//  Purpose:    Free the memory assicated with the return value from
//              INetConnection->GetProperties.  This is a helper function
//              used by clients of INetConnection.
//
//  Arguments:
//      pProps  [in] The properties to free.
//
//  Returns:    nothing.
//
//  Author:     shaunco   1 Feb 1998
//
//  Notes:
//
STDAPI_(VOID)
NcFreeNetconProperties (
    NETCON_PROPERTIES* pProps)
{
    // Defer to the common function in nccon.h.
    // We do this so that netman.exe doesn't have to link to netshell.dll
    // just for this function.
    //
    FreeNetconProperties (pProps);
}

STDAPI_(BOOL)
NcIsValidConnectionName (
    PCWSTR pszwName)
{
    return FIsValidConnectionName (pszwName);
}

//+---------------------------------------------------------------------------
//
//  Function:   HrLaunchNetworkOptionalComponents
//
//  Purpose:    External Entry point for launching the Network Optional Components
//
//  Arguments:
//
//  Returns:
//
//  Author:     scottbri   29 Oct 1998
//
//  Notes:      The CreateFile in this function will fail if the user does
//              this very quickly twice in a row. In that case, the second
//              instance will fall out unharmed before the first one even
//              comes up, which is no big deal. The only negative impact
//              would be if the second client in rewrote the file while the
//              oc manager was attempting to read it, but oc manager would
//              have to allow FILE_SHARE_WRITE, which is doubtful.
//
//              I've opened this window due to RAID 336302, which requires
//              that only a single instance of NETOC is running.
//
//
const WCHAR c_szTmpMasterOC[]   = L"[Version]\r\nSignature = \"$Windows NT$\"\r\n[Components]\r\nNetOC=netoc.dll,NetOcSetupProc,netoc.inf\r\nappsrv=iis.dll,OcEntry,iis.inf,hide,7\r\n[Global]\r\nWindowTitle=\"";
const WCHAR c_szQuote[]         = L"\"";
const WCHAR c_szTmpFileName[]   = L"NDCNETOC.INF";
const WCHAR c_szSysOCMgr[]      = L"%SystemRoot%\\System32\\sysocmgr.exe";

EXTERN_C
HRESULT
APIENTRY
HrLaunchNetworkOptionalComponents()
{
    DWORD   BytesWritten = 0;
    HANDLE  hFile = NULL;
    HRESULT hr = S_OK;
    PCWSTR pszName = NULL;
    WCHAR   szName[MAX_PATH + 1];

    // Jump to the existing netoc dialog, if present
    //
    HWND hwnd = FindWindow(NULL, SzLoadIds(IDS_CONFOLD_OC_TITLE));
    if (IsWindow(hwnd))
    {
        SetForegroundWindow(hwnd);
    }
    else
    {
        // Generate a temporary filename
        //
        if (0 == GetTempPath(celems(szName), szName))
        {
            hr = ::HrFromLastWin32Error();
            TraceTag(ttidShellFolder, "Unable to get temporary path for Optional Component Launch\n");
            goto Error;
        }

        lstrcatW(szName, c_szTmpFileName);

        // Create the file
        //
        hFile = CreateFile(szName, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ,
                           NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_TEMPORARY, NULL);
        if (INVALID_HANDLE_VALUE == hFile)
        {
            hr = ::HrFromLastWin32Error();
            goto Error;
        }

        // Generate the file contents
        //
        if (WriteFile(hFile, c_szTmpMasterOC, lstrlenW(c_szTmpMasterOC) * sizeof(WCHAR),
                      &BytesWritten, NULL))
        {
            // Write the OC Dialog Title
            //
            WCHAR szBufW[256];
            if (LoadStringW(_Module.GetResourceInstance(), IDS_CONFOLD_OC_TITLE,
                            szBufW, celems(szBufW)-1))
            {
                szBufW[255] = 0;
                if (WriteFile(hFile, szBufW, lstrlenW(szBufW) * sizeof(WCHAR), &BytesWritten, NULL) == FALSE)
                {
                    CloseHandle(hFile);
                    return(::HrFromLastWin32Error());
                }
            }

            if (WriteFile(hFile, c_szQuote, lstrlenW(c_szQuote) * sizeof(WCHAR), &BytesWritten, NULL) == FALSE)
            {
                CloseHandle(hFile);
                return(::HrFromLastWin32Error());
            }

            CloseHandle(hFile);

            SHELLEXECUTEINFO seiTemp    = { 0 };
            tstring strParams = L"/x /i:";
            strParams += szName;

            //  Fill in the data structure
            //
            seiTemp.cbSize          = sizeof(SHELLEXECUTEINFO);
            seiTemp.fMask           = SEE_MASK_DOENVSUBST;
            seiTemp.hwnd            = NULL;
            seiTemp.lpVerb          = NULL;
            seiTemp.lpFile          = c_szSysOCMgr;
            seiTemp.lpParameters    = strParams.c_str();
            seiTemp.lpDirectory     = NULL;
            seiTemp.nShow           = SW_SHOW;
            seiTemp.hInstApp        = NULL;
            seiTemp.hProcess        = NULL;

            // Execute the OC Manager Script
            //
            if (!::ShellExecuteEx(&seiTemp))
            {
                hr = ::HrFromLastWin32Error();
            }
        }
        else
        {
            CloseHandle(hFile);
            hr = HrFromLastWin32Error();
        }
    }

Error:
    TraceError("HrOnCommandOptionalComponents", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrCreateDeskTopIcon
//
//  Purpose:    External Entry point for creating a desktop shortcut to
//              an existing connection
//
//  Arguments:  guidId: GUID of the connection
//
//  Returns:    S_OK if succeeded
//              S_FALSE if the GUID does not match any existing connection
//              standard error code otherwise
//
//  Author:     tongl   19 Feb 1999
//
//  Notes:
//
EXTERN_C
HRESULT APIENTRY HrCreateDesktopIcon(const GUID& guidId, PCWSTR pszDir)
{
    HRESULT                 hr              = S_OK;
    PCONFOLDPIDL            pidlCon;
    PCONFOLDPIDLFOLDER      pidlFolder;
    BOOL                    fValidConnection= FALSE;

    #ifdef DBG
        WCHAR   szwGuid[c_cchGuidWithTerm];
        StringFromGUID2(guidId, szwGuid, c_cchGuidWithTerm);
        TraceTag(ttidShellFolder, "HrCreateDeskTopIcon called with GUID: %S", szwGuid);
        TraceTag(ttidShellFolder, "Dir path is: %S", pszDir);
    #endif

    // Initialize COM on this thread
    //
    BOOL fUninitCom = FALSE;

    hr = CoInitializeEx(NULL, COINIT_DISABLE_OLE1DDE | COINIT_APARTMENTTHREADED);
    if (RPC_E_CHANGED_MODE == hr)
        {
        hr = S_OK;
    }

    if (SUCCEEDED(hr))
    {
        fUninitCom = TRUE;

        hr = HrGetConnectionPidlWithRefresh(guidId, pidlCon);
        if (S_OK == hr)
        {
            AssertSz(!pidlCon.empty(), "We should have a valid PIDL for the connection !");

            // Get the pidl for the Connections Folder
            //
            hr = HrGetConnectionsFolderPidl(pidlFolder);
            if (SUCCEEDED(hr))
            {
                // Get the Connections Folder object
                //
                LPSHELLFOLDER psfConnections;

                hr = HrGetConnectionsIShellFolder(pidlFolder, &psfConnections);
                if (SUCCEEDED(hr))
                {
                    PCONFOLDPIDLVEC pidlVec;
                    pidlVec.push_back(pidlCon);
                    hr = HrCreateShortcutWithPath(pidlVec,
                                                  NULL,
                                                  psfConnections,
                                                  pszDir);
                    ReleaseObj(psfConnections);
                }
            }
        }
    }

    if (fUninitCom)
    {
        CoUninitialize();
    }

    TraceError("HrCreateDeskTopIcon", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrLaunchConnection
//
//  Purpose:    External Entry point for "connecting" an existing connection
//
//  Arguments:  guidId: GUID of the connection
//
//  Returns:    S_OK if succeeded
//              S_FALSE if the GUID does not match any existing connection
//              standard error code otherwise
//
//  Author:     tongl   19 Feb 1999
//
//  Notes:
//
EXTERN_C
HRESULT APIENTRY HrLaunchConnection(const GUID& guidId)
{
    HRESULT                 hr              = S_OK;
    PCONFOLDPIDL            pidlCon;
    PCONFOLDPIDLFOLDER      pidlFolder;

    #ifdef DBG
        WCHAR   szwGuid[c_cchGuidWithTerm];
        StringFromGUID2(guidId, szwGuid, c_cchGuidWithTerm);
        TraceTag(ttidShellFolder, "HrLaunchConnection called with GUID: %S", szwGuid);
    #endif

    // Initialize COM on this thread
    //
    BOOL fUninitCom = FALSE;

    hr = CoInitializeEx(NULL, COINIT_DISABLE_OLE1DDE | COINIT_APARTMENTTHREADED);
    if (RPC_E_CHANGED_MODE == hr)
    {
        hr = S_OK;
    }
    if (SUCCEEDED(hr))
    {
        fUninitCom = TRUE;

        hr = HrGetConnectionPidlWithRefresh(guidId, pidlCon);
        if (S_OK == hr)
        {
            AssertSz(!pidlCon.empty(), "We should have a valid PIDL for the connection !");

            // Get the pidl for the Connections Folder
            //
            hr = HrGetConnectionsFolderPidl(pidlFolder);
            if (SUCCEEDED(hr))
            {
                // Get the Connections Folder object
                //
                LPSHELLFOLDER psfConnections;

                hr = HrGetConnectionsIShellFolder(pidlFolder, &psfConnections);
                if (SUCCEEDED(hr))
                {
                    PCONFOLDPIDLVEC pidlVec;
                    pidlVec.push_back(pidlCon);

                    hr = HrOnCommandConnect(pidlVec, NULL, psfConnections);
                    ReleaseObj(psfConnections);
                }
            }
        }
    }

    if (fUninitCom)
    {
        CoUninitialize();
    }

    TraceError("HrLaunchConnection", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrLaunchConnectionEx
//
//  Purpose:    External Entry point for "connecting" an existing connection
//
//  Arguments:  dwFlags: Flags.
//                       0x00000001 - Opens the folder before launching the connection
//
//              guidId: GUID of the connection
//
//  Returns:    S_OK if succeeded
//              S_FALSE if the GUID does not match any existing connection
//              standard error code otherwise
//
//  Author:     deonb    8 May 2001
//
//  Notes:
//
EXTERN_C
HRESULT APIENTRY HrLaunchConnectionEx(DWORD dwFlags, const GUID& guidId)
{
    HRESULT                 hr              = S_OK;
    PCONFOLDPIDL            pidlCon;
    PCONFOLDPIDLFOLDER      pidlFolder;
    HWND hwndConnFolder     = NULL;

    #ifdef DBG
        WCHAR   szwGuid[c_cchGuidWithTerm];
        StringFromGUID2(guidId, szwGuid, c_cchGuidWithTerm);
        TraceTag(ttidShellFolder, "HrLaunchConnection called with GUID: %S", szwGuid);
    #endif

    if (dwFlags & 0x00000001)
    {
        hwndConnFolder = FindWindow(NULL, SzLoadIds(IDS_CONFOLD_NAME));
        if (!hwndConnFolder)
        {
            HrOpenConnectionsFolder();

            DWORD dwRetries = 120; // 1 Minute
            while (!hwndConnFolder && dwRetries--)
            {
                hwndConnFolder = FindWindow(NULL, SzLoadIds(IDS_CONFOLD_NAME));
                Sleep(500);
            }
        }

        if (hwndConnFolder)
        {
            SetForegroundWindow(hwndConnFolder);
        }
        else
        {
            TraceError("Could not open the Network Connections Folder in time", E_FAIL);
        }
    }

    // Initialize COM on this thread
    //
    BOOL fUninitCom = FALSE;

    hr = CoInitializeEx(NULL, COINIT_DISABLE_OLE1DDE | COINIT_APARTMENTTHREADED);
    if (RPC_E_CHANGED_MODE == hr)
    {
        hr = S_OK;
    }
    if (SUCCEEDED(hr))
    {
        fUninitCom = TRUE;

        hr = HrGetConnectionPidlWithRefresh(guidId, pidlCon);
        if (S_OK == hr)
        {
            AssertSz(!pidlCon.empty(), "We should have a valid PIDL for the connection !");

            // Get the pidl for the Connections Folder
            //
            hr = HrGetConnectionsFolderPidl(pidlFolder);
            if (SUCCEEDED(hr))
            {
                // Get the Connections Folder object
                //
                LPSHELLFOLDER psfConnections;

                hr = HrGetConnectionsIShellFolder(pidlFolder, &psfConnections);
                if (SUCCEEDED(hr))
                {
                    PCONFOLDPIDLVEC pidlVec;
                    pidlVec.push_back(pidlCon);

                    hr = HrOnCommandConnect(pidlVec, hwndConnFolder, psfConnections);
                    ReleaseObj(psfConnections);
                }
            }
        }
    }

    if (fUninitCom)
    {
        CoUninitialize();
    }

    TraceError("HrLaunchConnection", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRenameConnection
//
//  Purpose:    External Entry point for renaming an existing connection
//
//  Arguments:  guidId: GUID of the connection
//
//
//  Returns:    S_OK if succeeded
//              S_FALSE if the GUID does not match any existing connection
//              standard error code otherwise
//
//  Author:     tongl   26 May 1999
//
//  Notes:
//

EXTERN_C
HRESULT APIENTRY HrRenameConnection(const GUID& guidId, PCWSTR pszNewName)
{
    HRESULT                 hr              = S_OK;
    PCONFOLDPIDL            pidlCon;
    PCONFOLDPIDLFOLDER      pidlFolder;

    #ifdef DBG
        WCHAR   szwGuid[c_cchGuidWithTerm];
        StringFromGUID2(guidId, szwGuid, c_cchGuidWithTerm);
        TraceTag(ttidShellFolder, "HrRenameConnection called with GUID: %S, NewName: %S",
                 szwGuid, pszNewName);
    #endif

    if (!pszNewName)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        // check lpszName for validity
        if (!FIsValidConnectionName(pszNewName))
        {
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_NAME);
        }
    }

    if (SUCCEEDED(hr))
    {
        // Initialize COM on this thread
        //
        BOOL fUninitCom = FALSE;

        hr = CoInitializeEx(NULL, COINIT_DISABLE_OLE1DDE | COINIT_APARTMENTTHREADED);
        if (RPC_E_CHANGED_MODE == hr)
        {
            hr = S_OK;
        }
        if (SUCCEEDED(hr))
        {
            fUninitCom = TRUE;

            hr = HrGetConnectionPidlWithRefresh(guidId, pidlCon);
            if (S_OK == hr)
            {
                AssertSz(!pidlCon.empty(), "We should have a valid PIDL for the connection !");

                // Get the pidl for the Connections Folder
                //
                hr = HrGetConnectionsFolderPidl(pidlFolder);
                if (SUCCEEDED(hr))
                {
                    PCONFOLDPIDL pcfpEmpty;
                    hr = HrRenameConnectionInternal(pidlCon, pidlFolder, pszNewName,
                                                    FALSE, NULL, pcfpEmpty);
                }
            }
        }

        if (fUninitCom)
        {
            CoUninitialize();
        }

    }

    TraceError("HrRenameConnection", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   InvokeDunFile
//  Purpose:    External Entry point for launching .dun files
//
//  Arguments:
//
//  Returns:
//
//  Author:     tongl  4 Feb 1999
//
//  Notes:
//

EXTERN_C
VOID APIENTRY InvokeDunFile(HWND hwnd, HINSTANCE hinst, LPCSTR lpszCmdLine, int nCmdShow)
{
    if (lpszCmdLine)
    {
        INT     cch         = 0;
        WCHAR * pszFileW    = NULL;

        cch = lstrlenA(lpszCmdLine) + 1;
        pszFileW = new WCHAR[cch];

        if (pszFileW)
        {
            int iRet = MultiByteToWideChar( CP_ACP,
                                            MB_PRECOMPOSED,
                                            lpszCmdLine,
                                            -1,
                                            pszFileW,
                                            cch);
            if (iRet)
            {
                HRESULT hr = HrInvokeDunFile_Internal(pszFileW);
                TraceError("Failed to invoke the DUN file", hr);
            }
            else
            {
                HRESULT hr = HrFromLastWin32Error();
                TraceError("Failed converting commandline to UniCode string", hr);
            }

            delete pszFileW;
        }
    }
}

EXTERN_C
HRESULT APIENTRY RepairConnection(GUID guidConnection, LPWSTR * ppszMessage)
{
    return RepairConnectionInternal(guidConnection, ppszMessage);
}

//+---------------------------------------------------------------------------
//
//  Function:   HrGetIconFromIconId
//
//  Purpose:    Exported version of CNetConfigIcons::HrGetIconFromMediaType
//
//  Arguments:
//      dwIconSize        [in] Size of the icon required
//      ncm               [in] The NETCON_MEDIATYPE
//      ncsm              [in] The NETCON_SUBMEDIATYPE
//      dwConnectionIcon  [in] ENUM_CONNECTION_ICON (Not shifted (IOW: 0 or 4,5,6,7)
//      dwCharacteristics [in] The NCCF_CHARACTERISTICS flag (0 allowed)
//      phIcon            [in] The resulting icon. Destroy using DestroyIcon
//
//  Returns:
//
//  Author:     deonb    23 Apr 2001
//
//  Notes:
//
EXTERN_C
HRESULT APIENTRY HrGetIconFromMediaType(DWORD dwIconSize, IN NETCON_MEDIATYPE ncm, IN NETCON_SUBMEDIATYPE ncsm, IN DWORD dwConnectionIcon, IN DWORD dwCharacteristics, OUT HICON *phIcon)
{
    Assert(g_pNetConfigIcons);
    if (g_pNetConfigIcons)
    {
        return g_pNetConfigIcons->HrGetIconFromMediaType(dwIconSize, ncm, ncsm, dwConnectionIcon, dwCharacteristics, phIcon);
    }
    else
    {
        return E_UNEXPECTED;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\shell\dll\version.h ===
#pragma once

#include <ntverp.h>
#include <winver.h>

#define VER_FILETYPE                    VFT_DLL
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "Network Connections Shell"
#define VER_INTERNALNAME_STR            "netshell.dll"

#include <common.ver>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\shell\dun\dunimport.h ===
#pragma once
#include "ncstring.h"
#include "ras.h"

HRESULT HrInvokeDunFile_Internal(IN LPWSTR szDunFile);

HRESULT HrGetPhoneBookFile(tstring& strPhoneBook);

HRESULT HrGetEntryName(IN LPWSTR szDunFile, 
                       IN LPWSTR szEntryName, 
                       tstring & strPhoneBook);

HRESULT HrImportPhoneBookInfo(  IN LPWSTR szDunFile, 
                                IN LPWSTR szEntryName, 
                                tstring & strPhoneBook);

HRESULT HrImportPhoneInfo(RASENTRY * pRasEntry, 
                          IN LPWSTR  szDunFile);

VOID ImportDeviceInfo(RASENTRY * pRasEntry, 
                      IN LPWSTR  szDunFile);

VOID ImportServerInfo(RASENTRY * pRasEntry, 
                      IN LPWSTR  szDunFile);


VOID ImportIPInfo(RASENTRY * pRasEntry, 
                  IN LPWSTR  szDunFile);

VOID ImportScriptFileName(RASENTRY * pRasEntry, 
                          IN LPWSTR  szDunFile);

VOID SzToRasIpAddr(IN LPWSTR szIPAddr, 
                   OUT RASIPADDR * pIpAddr);

HRESULT HrImportMLInfo( IN LPWSTR szDunFile, 
                        IN LPWSTR szEntryName, 
                        tstring & pRasIpAddr);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\shell\folder\ac_ctrayui.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       ac_CTrayUi.h
//
//  Contents:   Home Networking Auto Config Tray Icon UI code
//
//  Author:     jeffsp    9/27/2000
//
//----------------------------------------------------------------------------

#pragma once

extern HWND g_hwndHnAcTray;


LRESULT
CALLBACK
CHnAcTrayUI_WndProc (
                 IN  HWND    hwnd,       // window handle
                 IN  UINT    uiMessage,  // type of message
                 IN  WPARAM  wParam,     // additional information
                 IN  LPARAM  lParam);    // additional information


LRESULT 
OnHnAcTrayWmNotify(
	IN  HWND hwnd,
	IN  WPARAM wParam,
	IN  LPARAM lParam 
);	

LRESULT 
OnHnAcTrayWmTimer(
	IN  HWND hwnd,
	IN  WPARAM wParam,
	IN  LPARAM lParam 
);	

HRESULT HrRunHomeNetworkWizard(
	IN  HWND                    hwndOwner
);


LRESULT OnHnAcTrayWmCreate(
    IN  HWND hwnd
);

LRESULT OnHnAcMyWMNotifyIcon(
    IN  HWND hwnd,
    IN  UINT uiMessage,
    IN  WPARAM wParam,
    IN  LPARAM lParam
);


HRESULT ac_CreateHnAcTrayUIWindow();
LRESULT ac_DestroyHnAcTrayUIWindow();
LRESULT ac_DeviceChange(IN  HWND hWnd, IN  UINT uMessage, IN  WPARAM wParam, IN  LPARAM lParam);
HRESULT ac_Register(IN  HWND hWindow);
HRESULT ac_Unregister(IN  HWND hWindow);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\shell\folder\cfpidl_templates.cpp ===
// ****************************************************************************
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       C F P I D L _ T E M P L A T E S . C P P
//
//  Contents:   Connections Folder template structures.
//
//  Author:     deonb     12 Jan 2001
//
// ****************************************************************************

#include "pch.h"
#pragma hdrstop


#include "ncperms.h"
#include "ncras.h"
#include "foldinc.h"    // Standard shell\folder includes
#include "ncnetcon.h"

template <class T>
HRESULT CPConFoldPidl<T>::FreePIDLIfRequired()
{
    if ( m_pConFoldPidl )
    {
        FreeIDL(reinterpret_cast<LPITEMIDLIST>(m_pConFoldPidl));
        m_pConFoldPidl = NULL;
        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}

template <class T>
HRESULT CPConFoldPidl<T>::Clear()
{
    FreePIDLIfRequired();

    return S_OK;
}

template <class T>
T& CPConFoldPidl<T>::operator *()
{
    return (*m_pConFoldPidl);
}

template <class T>
UNALIGNED T* CPConFoldPidl<T>::operator->()
{
    return m_pConFoldPidl;
}

template <class T>
const UNALIGNED T* CPConFoldPidl<T>::operator->() const
{
    return m_pConFoldPidl;
}

template <class T>
HRESULT CPConFoldPidl<T>::ILCreate(IN const DWORD dwSize)
{
    Assert(dwSize >= sizeof(T));
    FreePIDLIfRequired();
    
    // Just call the constructor on T (placement form of new doesn't allocate any more memory).
    LPVOID pPlacement = ::ILCreate(dwSize);
    if (!pPlacement)
    {
        return E_OUTOFMEMORY;
    }
#if DBG
    ZeroMemory(pPlacement, dwSize);
#endif

    // Basically call the constructor
    // Semantic equivalent to m_pConFoldPidl = pPlacement;
    // m_pConFoldPidl::T();
    m_pConFoldPidl = new( pPlacement ) T; // Placement new can't fail with OUTOFMEMORY.

    Assert(pPlacement == m_pConFoldPidl);

    return S_OK;
}

template <class T>
HRESULT CPConFoldPidl<T>::SHAlloc(IN const SIZE_T cb)
{
    FreePIDLIfRequired();

    LPVOID pPlacement = reinterpret_cast<UNALIGNED T*>(::SHAlloc(cb));
    if (!pPlacement)
    {
        return E_OUTOFMEMORY;
    }

    // Basically call the constructor
    // Semantic equivalent to m_pConFoldPidl = pPlacement;
    // m_pConFoldPidl::T();
    m_pConFoldPidl = new( pPlacement ) T;  // Placement new can't fail with OUTOFMEMORY.
    Assert(pPlacement == m_pConFoldPidl);

    if (m_pConFoldPidl)
    {
        return S_OK;
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}

template <class T>
HRESULT CPConFoldPidl<T>::ILClone(IN const CPConFoldPidl<T>& PConFoldPidl)
{
    C_ASSERT(PIDL_VERSION == T::CONNECTIONS_FOLDER_IDL_VERSION);
    FreePIDLIfRequired();

    LPVOID pPlacement = reinterpret_cast<UNALIGNED T*>(::ILClone(reinterpret_cast<LPITEMIDLIST>(PConFoldPidl.m_pConFoldPidl)));
    if (!pPlacement)
    {
        return E_OUTOFMEMORY;
    }

    // Basically call the constructor
    // Semantic equivalent to m_pConFoldPidl = pPlacement;
    // m_pConFoldPidl::T();
    m_pConFoldPidl = new( pPlacement ) T; // Placement new can't fail with OUTOFMEMORY.
    Assert(pPlacement == m_pConFoldPidl);
    if (m_pConFoldPidl)
    {
        Assert(m_pConFoldPidl->IsPidlOfThisType());
        return S_OK;
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}

template <class T>
LPITEMIDLIST CPConFoldPidl<T>::TearOffItemIdList() const
{
    TraceFileFunc(ttidConFoldEntry);

    Assert(m_pConFoldPidl);
    Assert( m_pConFoldPidl->IsPidlOfThisType() );
    LPITEMIDLIST retList = ::ILClone(reinterpret_cast<LPITEMIDLIST>(m_pConFoldPidl));

#ifdef DBG_VALIDATE_PIDLS
    Assert(IsValidPIDL(retList));
#endif

    return retList;
}

template <class T>
LPITEMIDLIST CPConFoldPidl<T>::Detach()
{
    TraceFileFunc(ttidConFoldEntry);

    Assert(m_pConFoldPidl);
    Assert( m_pConFoldPidl->IsPidlOfThisType() );
    LPITEMIDLIST retList = reinterpret_cast<LPITEMIDLIST>(m_pConFoldPidl);

#ifdef DBG_VALIDATE_PIDLS
    Assert(IsValidPIDL(retList));
#endif

    m_pConFoldPidl = NULL;
    return retList;
}

template <class T>
LPCITEMIDLIST CPConFoldPidl<T>::GetItemIdList() const
{
    TraceFileFunc(ttidConFoldEntry);

    Assert(m_pConFoldPidl);
    Assert( m_pConFoldPidl->IsPidlOfThisType() );
    LPCITEMIDLIST tmpItemIdList = reinterpret_cast<LPCITEMIDLIST>(m_pConFoldPidl);

#ifdef DBG_VALIDATE_PIDLS
    Assert(IsValidPIDL(tmpItemIdList));
#endif

    return tmpItemIdList;
}

#ifdef DBG_VALIDATE_PIDLS
template <class T>
BOOL CPConFoldPidl<T>::IsValidConFoldPIDL() const
{
    return IsValidPIDL(reinterpret_cast<LPCITEMIDLIST>(m_pConFoldPidl));
}
#endif

template <class T>
HRESULT CPConFoldPidl<T>::InitializeFromItemIDList(IN LPCITEMIDLIST pItemIdList)
{
    DWORD dwPidlSize = 0;
    UNALIGNED ConFoldPidl_v1  * cfpv1  = NULL;
    UNALIGNED ConFoldPidl_v2  * cfpv2  = NULL;
    UNALIGNED ConFoldPidl98   * cfpv98 = NULL;
    LPVOID pPlacement = NULL;
    
    HRESULT hr = S_OK;
    Assert(pItemIdList);

#ifdef DBG_VALIDATE_PIDLS
    if (!IsValidPIDL(pItemIdList))
    {
        TraceError("Invalid PIDL passed to InitializeFromItemIDList", E_INVALIDARG);
    }
#endif

    Clear();

    CONFOLDPIDLTYPE pidlType = GetPidlType(pItemIdList);
    if ( (PIDL_TYPE_UNKNOWN == pidlType) && (PIDL_VERSION == PIDL_TYPE_FOLDER) )
    {
        pidlType = PIDL_TYPE_FOLDER; // Give it the benefit of the doubt
    }

    if (pidlType == PIDL_VERSION)
    {
        pPlacement = reinterpret_cast<UNALIGNED T*>(::ILClone(pItemIdList));
        if (!pPlacement)
        {
            return E_OUTOFMEMORY;
        }

        // Basically call the constructor
        // Semantic equivalent to m_pConFoldPidl = pPlacement;
        // m_pConFoldPidl::T();

        m_pConFoldPidl = new( pPlacement ) T;  // Placement new can't fail with OUTOFMEMORY
        Assert(pPlacement == m_pConFoldPidl);

        if (!m_pConFoldPidl->IsPidlOfThisType())
        {
            ::SHFree(pPlacement);
            m_pConFoldPidl = NULL;

            return E_INVALIDARG;
        }

    }
    else // We'll have to convert:
    {
        TraceTag(ttidShellFolderIface, "InitializeFromItemIDList: Converting PIDL from type %d to %d", pidlType, PIDL_VERSION);

        switch (PIDL_VERSION)
        {
            case PIDL_TYPE_UNKNOWN: // This is what we are
                {
                    switch (pidlType)   
                    {
                        // This is what we're getting
                        case PIDL_TYPE_UNKNOWN:
                            AssertSz(FALSE, "PIDL is already of this type.");
                            break;
                        case PIDL_TYPE_V1:
                        case PIDL_TYPE_V2:
                        case PIDL_TYPE_98:
                        case PIDL_TYPE_FOLDER:
                        default:
                            AssertSz(FALSE, "Can't upgrade PIDL to UNKNOWN type");
                            hr = E_INVALIDARG;
                            break;
                    }
                }  
                break;

            case PIDL_TYPE_V1: // This is what we are
                {
                    switch (pidlType)
                    {
                         // This is what we're getting
                        case PIDL_TYPE_V1:
                            AssertSz(FALSE, "PIDL is already of this type.");
                            break;

                        case PIDL_TYPE_UNKNOWN:
                        case PIDL_TYPE_V2:
                        case PIDL_TYPE_98:
                        case PIDL_TYPE_FOLDER:
                        default:
                            AssertSz(FALSE, "Can't upgrade PIDL to PIDL_V1 type");
                            hr = E_INVALIDARG;
                            break;
                    }
                }
                break;
                
            case PIDL_TYPE_FOLDER: // This is what we are
                {
                    switch (pidlType)
                    {
                        // This is what we're getting
                        case PIDL_TYPE_FOLDER:
                            AssertSz(FALSE, "PIDL is already of this type.");
                            break;

                        case PIDL_TYPE_V1:
                        case PIDL_TYPE_98:
                        case PIDL_TYPE_UNKNOWN:
                        case PIDL_TYPE_V2:
                        default:
                            AssertSz(FALSE, "Can't upgrade PIDL to PIDL_TYPE_FOLDER type");
                            hr = E_INVALIDARG;
                            break;
                    }
                }
                break;

            case PIDL_TYPE_98: // This is what we are
                {
                    switch (pidlType)
                    {
                            // This is what we're getting
                        case PIDL_TYPE_98:
                            AssertSz(FALSE, "PIDL is already of this type.");
                            break;
                        case PIDL_TYPE_V1:
                        case PIDL_TYPE_V2:
                        case PIDL_TYPE_UNKNOWN:
                        case PIDL_TYPE_FOLDER:
                        default:
                            AssertSz(FALSE, "Can't upgrade PIDL to PIDL_TYPE_98 type");
                            hr = E_INVALIDARG;
                            break;
                    }
                }
                break;

            case PIDL_TYPE_V2: // This is what we are
                {
                    switch (pidlType)
                    {
                        // This is what we're getting
                        case PIDL_TYPE_V2:
                            AssertSz(FALSE, "PIDL is already of this type.");
                            break;
                            
                        case PIDL_TYPE_V1:
                            {
                                // Do the convert.
                                cfpv1 = const_cast<ConFoldPidl_v1 *>(reinterpret_cast<const ConFoldPidl_v1 *>(pItemIdList));
                                if (!cfpv1->IsPidlOfThisType())
                                {
                                    return E_INVALIDARG;
                                }

                                dwPidlSize = cfpv1->iCB + CBCONFOLDPIDLV2_MIN - CBCONFOLDPIDLV1_MIN;
                                dwPidlSize += sizeof(WCHAR); // Adding NULL for PhoneOrHostAddress in bData

                                pPlacement = reinterpret_cast<UNALIGNED T*>(::ILCreate(dwPidlSize + sizeof(USHORT))); // Terminating 0
                                if (!pPlacement)
                                {
                                    return E_OUTOFMEMORY;
                                }
                                TraceTag(ttidShellFolderIface, "InitializeFromItemIDList: Original: 0x%08x  New:0x%08x", pItemIdList, pPlacement);
                                
                                // Basically call the constructor
                                // Semantic equivalent to m_pConFoldPidl = pPlacement;
                                // m_pConFoldPidl::T();
                                m_pConFoldPidl = new( pPlacement ) T; // Placement new can't fail with OUTOFMEMORY
                                Assert(pPlacement == m_pConFoldPidl);

                                Assert(sizeof(ConFoldPidlBase) <= cfpv1->iCB );

                                // Copy the ConFoldPidlBase data
                                CopyMemory(m_pConFoldPidl, cfpv1, sizeof(ConFoldPidlBase)); 

                                // I know we're already a ConFoldPidl_v2 - but this is a template, so we'll have to cast
                                // to get it to compile. This code path is dead for non-v2 classes though.                                
                                cfpv2 = reinterpret_cast<ConFoldPidl_v2 *>(m_pConFoldPidl);

                                // Copy the bData member (everything but ConFoldPidlBase in this case)
                                CopyMemory(cfpv2->bData, cfpv1->bData, cfpv1->iCB - sizeof(ConFoldPidlBase));

                                // Force update the version number and byte count
                                cfpv2->iCB  = (WORD)dwPidlSize;
                                const_cast<DWORD&>(cfpv2->dwVersion) = PIDL_TYPE_V2;

                                if (NCM_LAN == cfpv2->ncm)
                                {
                                    cfpv2->ncsm = NCSM_LAN;
                                }
                                else
                                {
                                    cfpv2->ncsm = NCSM_NONE;
                                }

                                cfpv2->ulStrPhoneOrHostAddressPos = cfpv2->ulPersistBufPos + cfpv2->ulPersistBufSize;

                                LPWSTR pszPhoneOrHostAddress = cfpv2->PszGetPhoneOrHostAddressPointer();
                                *pszPhoneOrHostAddress = L'\0';
                                cfpv2->ulStrPhoneOrHostAddressSize = sizeof(WCHAR); // Size of NULL

                                // Don't forget to terminate the list!
                                //
                                LPITEMIDLIST pidlTerminate;
                                pidlTerminate = ILNext( reinterpret_cast<LPCITEMIDLIST>( m_pConFoldPidl ) );
                                pidlTerminate->mkid.cb = 0;

#ifdef DBG_VALIDATE_PIDLS
                                Assert(IsValidConFoldPIDL());
#endif
                                Assert(m_pConFoldPidl->IsPidlOfThisType());
                                if (!m_pConFoldPidl->IsPidlOfThisType())
                                {
                                    ::SHFree(m_pConFoldPidl);
                                    m_pConFoldPidl = NULL;
                                    return E_FAIL;
                                }
                            }
                            break;                            

                        case PIDL_TYPE_98:
                            {
                                cfpv98 = const_cast<ConFoldPidl98 *>(reinterpret_cast<const ConFoldPidl98 *>(pItemIdList));
                                if (!cfpv98->IsPidlOfThisType())
                                {
                                    return E_INVALIDARG;
                                }

                                WCHAR szName[MAX_PATH];
                                mbstowcs(szName, cfpv98->szaName, MAX_PATH);

                                ConnListEntry cle;
                                PCONFOLDPIDL pidlv2;

                                HRESULT hrTmp = g_ccl.HrFindConnectionByName(szName, cle);
                                if (hrTmp != S_OK)
                                {
                                    return E_FAIL;
                                }
                                
                                cle.ccfe.ConvertToPidl(pidlv2);
                                LPITEMIDLIST pIdl = pidlv2.TearOffItemIdList();
                                
                                m_pConFoldPidl = reinterpret_cast<T *>(pIdl);

                                LPITEMIDLIST pidlTerminate;
                                pidlTerminate = ILNext( reinterpret_cast<LPCITEMIDLIST>( m_pConFoldPidl ) );
                                pidlTerminate->mkid.cb = 0;

#ifdef DBG_VALIDATE_PIDLS                                
                                Assert(IsValidConFoldPIDL());
#endif
                                Assert(m_pConFoldPidl->IsPidlOfThisType());
                                if (!m_pConFoldPidl->IsPidlOfThisType())
                                {
                                    ::SHFree(m_pConFoldPidl);
                                    m_pConFoldPidl = NULL;
                                    return E_FAIL;
                                }
                            }
                            break;

                        case PIDL_TYPE_FOLDER:
                            AssertSz(FALSE, "Can't upgrade PIDL to PIDL_V2 type");

                        case PIDL_TYPE_UNKNOWN:
                        default:
                            hr = E_INVALIDARG;
                            break;
                    }
                }
                break;

           default:
                AssertSz(FALSE, "Can't upgrade PIDL");
                hr = E_INVALIDARG;
                break;
        }
    }
    
    if ( FAILED(hr) )
    {
        ::SHFree(m_pConFoldPidl);
        m_pConFoldPidl = NULL;
    }
    else
    {
        Assert(m_pConFoldPidl->IsPidlOfThisType());
    }

    return hr;
}

template <class T>
CPConFoldPidl<T>::CPConFoldPidl()
{
    m_pConFoldPidl = NULL;
}

template <class T>
CPConFoldPidl<T>::CPConFoldPidl(IN const CPConFoldPidl& PConFoldPidl) throw (HRESULT)
{
    m_pConFoldPidl = NULL;
    
    HRESULT hr = InitializeFromItemIDList(reinterpret_cast<LPCITEMIDLIST>(PConFoldPidl.m_pConFoldPidl));
    if (FAILED(hr))
    {
        throw hr;
    }
}

template <class T>
CPConFoldPidl<T>::~CPConFoldPidl()
{
    FreePIDLIfRequired();
    m_pConFoldPidl = NULL;
}

template <class T>
CPConFoldPidl<T>& CPConFoldPidl<T>::operator =(IN const CPConFoldPidl<T>& PConFoldPidl) throw (HRESULT)
{
    FreePIDLIfRequired();
    
    if (PConFoldPidl.m_pConFoldPidl)
    {
        HRESULT hr = InitializeFromItemIDList(reinterpret_cast<LPCITEMIDLIST>(PConFoldPidl.m_pConFoldPidl));
        if (FAILED(hr))
        {
            throw hr;
        }
    }
    else
    {
        m_pConFoldPidl = NULL;
    }
    return *this;
}


template <class T>
inline BOOL CPConFoldPidl<T>::empty() const
{
    return (m_pConFoldPidl == NULL);
}

template <class T>
    HRESULT CPConFoldPidl<T>::ConvertToConFoldEntry(OUT CConFoldEntry& cfe) const
{
    Assert(m_pConFoldPidl);
    if (!m_pConFoldPidl)
    {
        return E_UNEXPECTED;
    }

    return m_pConFoldPidl->ConvertToConFoldEntry(cfe);
}

template <class T>
HRESULT CPConFoldPidl<T>::Swop(OUT CPConFoldPidl<T>& cfe)
{
    UNALIGNED T* pTemp = m_pConFoldPidl;
    m_pConFoldPidl = cfe.m_pConFoldPidl;
    cfe.m_pConFoldPidl = pTemp;
    return S_OK;
}

template CPConFoldPidl<ConFoldPidl_v1>;
template CPConFoldPidl<ConFoldPidl_v2 >;
template CPConFoldPidl<ConFoldPidlFolder>;
template CPConFoldPidl<ConFoldPidl98>;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\shell\folder\cfpidl.cpp ===
// ****************************************************************************
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       C F P I D L . C P P
//
//  Contents:   Connections Folder structures and classes.
//
//  Author:     jeffspr   11 Nov 1997
//
// ****************************************************************************

#include "pch.h"
#pragma hdrstop

#include "ncperms.h"
#include "ncras.h"
#include "initguid.h"
#include "foldinc.h"    // Standard shell\folder includes
#include "ncnetcon.h"
#include "ncmisc.h"

extern CRITICAL_SECTION g_csPidl;

BOOL fIsConnectedStatus(IN const NETCON_STATUS ncs)
{
    switch (ncs)
    {
        case NCS_CONNECTED:
        case NCS_AUTHENTICATING:
        case NCS_AUTHENTICATION_FAILED:
        case NCS_AUTHENTICATION_SUCCEEDED:
        case NCS_CREDENTIALS_REQUIRED:
            return TRUE;
        default:
            return FALSE;
    }
}

// ****************************************************************************
//
//  Member:     CConFoldEntry::CConFoldEntry
//
//  Purpose:    Constructor for CConFoldEntry
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     jeffspr   11 Nov 1997
// ****************************************************************************

CConFoldEntry::CConFoldEntry() throw()
{
    m_bDirty = TRUE;
    TraceFileFunc(ttidConFoldEntry);

    // Need to clear out the pointers, otherwise clear() will AV
    m_pszName       = NULL;
    m_pszDeviceName = NULL;
    m_pbPersistData = NULL;
    m_pszPhoneOrHostAddress = NULL;
    
    clear();
}

CConFoldEntry::CConFoldEntry(IN const CConFoldEntry& ConFoldEntry) throw() // NULL on failure
{
    TraceFileFunc(ttidConFoldEntry);
    m_bDirty = TRUE;
    
    if (!ConFoldEntry.empty())
    {
        HRESULT hr = HrDupFolderEntry(ConFoldEntry);
        if (FAILED(hr))
        {
            clear();
        }
    }
    else
    {
        // Need to clear out the pointers, otherwise clear() will AV
        m_pszName       = NULL;
        m_pszDeviceName = NULL;
        m_pbPersistData = NULL;
        m_pszPhoneOrHostAddress = NULL;
        
        clear();
    }
}

CConFoldEntry& CConFoldEntry::operator =(const CConFoldEntry& ConFoldEntry) // NULL on failure
{
    TraceFileFunc(ttidConFoldEntry);
    m_bDirty = TRUE;
    
    if (!ConFoldEntry.empty())
    {
        HRESULT hr = HrDupFolderEntry(ConFoldEntry);
        if (FAILED(hr))
        {
            clear();
        }
    }
    else
    {
        clear();
    }
    return *this;
}

// ****************************************************************************
//
//  Member:     CConFoldEntry::~CConFoldEntry
//
//  Purpose:    Destructor for CConFoldEntry
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     jeffspr   11 Nov 1997
// ****************************************************************************

CConFoldEntry::~CConFoldEntry() throw()
{
    TraceFileFunc(ttidConFoldEntry);
    clear();
}

// ****************************************************************************
//
//  Member:     CConFoldEntry::SetDeviceName
//
//  Purpose:    Set the name of the device used by this connection
//
//  Arguments:
//      pszDeviceName - New device name (NULL is valid)
//
//  Returns:
//
//  Author:     deonb 2000
// ****************************************************************************

HRESULT CConFoldEntry::SetDeviceName(IN LPCWSTR pszDeviceName)
{
    HRESULT hr      = S_OK;
    PWSTR  pszOld  = m_pszDeviceName;
    
    m_bDirty = TRUE;
    
    if (pszDeviceName)
    {
        // Only change the text is the text is actually different
        //
        if ((NULL == GetDeviceName()) ||
            wcscmp(pszDeviceName, GetDeviceName()))
        {
            hr = HrDupeShellString(pszDeviceName, &m_pszDeviceName);
        }
        else
        {
            // NOTE: In this one case, nothing change so there is
            //       nothing to free so short circut the clean-up below
            //
            pszOld = NULL;
            hr = S_OK;
        }
    }
    else
    {
        hr = HrDupeShellString(L"", &m_pszDeviceName);
    }
    
    // Free the old string
    //
    if (SUCCEEDED(hr) && pszOld)
    {
        SHFree(pszOld);
    }
    
    TraceHr(ttidError, FAL, hr, FALSE, "CConFoldEntry::HrSetDeviceName");
    return hr;
}

// ****************************************************************************
//
//  Member:     CConFoldEntry::SetPhoneOrHostAddress
//
//  Purpose:    Set the name of the device used by this connection
//
//  Arguments:
//      pszPhoneOrHostAddress - New phone or host address (NULL is valid)
//
//  Returns:
//
//  Author:     deonb 2000
// ****************************************************************************

HRESULT CConFoldEntry::SetPhoneOrHostAddress(IN LPCWSTR pszPhoneOrHostAddress)
{
    HRESULT hr      = S_OK;
    PWSTR  pszOld  = m_pszPhoneOrHostAddress;
    
    m_bDirty = TRUE;
    
    if (pszPhoneOrHostAddress)
    {
        // Only change the text is the text is actually different
        //
        if ((NULL == GetPhoneOrHostAddress()) ||
            wcscmp(pszPhoneOrHostAddress, GetPhoneOrHostAddress()))
        {
            hr = HrDupeShellString(pszPhoneOrHostAddress, &m_pszPhoneOrHostAddress);
        }
        else
        {
            // NOTE: In this one case, nothing change so there is
            //       nothing to free so short circut the clean-up below
            //
            pszOld = NULL;
            hr = S_OK;
        }
    }
    else
    {
        hr = HrDupeShellString(L"", &m_pszPhoneOrHostAddress);
    }
    
    // Free the old string
    //
    if (SUCCEEDED(hr) && pszOld)
    {
        SHFree(pszOld);
    }
    
    TraceHr(ttidError, FAL, hr, FALSE, "CConFoldEntry::HrSetDeviceName");
    return hr;
}

// ****************************************************************************
//
//  Member:     CConFoldEntry::SetName
//
//  Purpose:    Set the name of the connection
//
//  Arguments:
//      pszName - New connection name (NULL is valid)
//
//  Returns:
//
//  Author:     deonb 2000
// ****************************************************************************

HRESULT CConFoldEntry::SetName(IN LPCWSTR pszName)
{
    HRESULT hr      = S_OK;
    PWSTR  pszOld  = m_pszName;
    
    m_bDirty = TRUE;
    
    if (pszName)
    {
        // Only change the text is the text is actually different
        //
        if ((NULL == GetName()) ||
            wcscmp(pszName, GetName()))
        {
            hr = HrDupeShellString(pszName, &m_pszName);
        }
        else
        {
            pszOld = NULL;
            hr = S_OK;
        }
    }
    else
    {
        PWSTR  pszLoad  = NULL;
        
        if (GetWizard() == WIZARD_MNC)
        {
            pszLoad = (PWSTR) SzLoadIds(IDS_CONFOLD_WIZARD_DISPLAY_NAME);
        }
        else if (GetWizard() == WIZARD_HNW)
        {
            pszLoad = (PWSTR) SzLoadIds(IDS_CONFOLD_HOMENET_WIZARD_DISPLAY_NAME);
        }
        
        // ISSUE: Change this to use c_szEmpty
        //
        hr = HrDupeShellString(pszLoad ? pszLoad : L"", &m_pszName);
        Assert(GetName());
    }
    
    // Free the old string
    //
    if (SUCCEEDED(hr) && pszOld)
    {
        SHFree(pszOld);
    }
    
    TraceHr(ttidError, FAL, hr, FALSE, "CConFoldEntry::HrSetConnectionName");
    return hr;
}

// ****************************************************************************
//
//  Member:     CConFoldEntry::HrInitData
//
//  Purpose:    Initialize the CConFoldEntry data. Not all fields are
//              required at this time, though they will most likely be
//              required at some point during the life of the object.
//
//  Arguments:
//      wizWizard           [in]  Wizard type?
//      ncm                 [in]  Connection type
//      ncs                 [in]  Connection status
//      pclsid              [in]  Pointer to CLSID of the connection
//      pguidId             [in]  Pointer to unique GUID for the connection
//      dwCharacteristics   [in]  Connection characteristics
//      pbPersistData       [in]  Persistant data for this connection
//      ulPersistSize       [in]  Size of the persist data blob
//      pszName             [in]  Name of the connection
//      pszDeviceName       [in]  Name of the connection's device
//
//  Returns:    S_OK or valid OLE return code.
//
//  Author:     deonb  2000
// ****************************************************************************
HRESULT CConFoldEntry::HrInitData(IN  const WIZARD        wizWizard,
                                  IN  const NETCON_MEDIATYPE    ncm,
                                  IN  const NETCON_SUBMEDIATYPE ncsm,
                                  IN  const NETCON_STATUS       ncs,
                                  IN  const CLSID *       pclsid,
                                  IN  LPCGUID             pguidId,
                                  IN  const DWORD         dwCharacteristics,
                                  IN  const BYTE *        pbPersistData,
                                  IN  const ULONG         ulPersistSize,
                                  IN  LPCWSTR             pszName,
                                  IN  LPCWSTR             pszDeviceName,
                                  IN  LPCWSTR             pszPhoneOrHostAddress)
{
    TraceFileFunc(ttidConFoldEntry);
    HRESULT hr  = S_OK;
    
    // Initialize the internal data
    //
    m_bDirty = TRUE;
    m_wizWizard = wizWizard;
    m_ncm = ncm;
    m_ncs = ncs;
    m_dwCharacteristics = dwCharacteristics;;

    BOOL fOldEapolStatus =  (
                                (ncsm == NCSM_CM) 
                                && 
                                (ncm == NCM_LAN)
                            ) // NCSM_CM used to be NCM_AUTHENTICATING
                            || 
                            (ncsm > NCSM_CM); // E.g. NCM_AUTHENTICATION_SUCCEEDED etc.

    if (!fOldEapolStatus)        
    {
        m_ncsm = ncsm;
    }
    else
    {
        // ISSUE: This is for the migration of EAPOL state out off our PIDL
        // This should be taken out after the no-prior-upgrades RC1 build is released.
        if (NCM_LAN == ncm)
        {
            m_ncsm = NCSM_LAN; // If all else file, we'll pretend to be a normal LAN card.

            CIntelliName inName(NULL, NULL);
            NETCON_MEDIATYPE    ncmTmp;
            NETCON_SUBMEDIATYPE ncsmTmp;

            // Try get the status from the OID or Bindings
            HRESULT hrT = inName.HrGetPseudoMediaTypes(*pguidId, &ncmTmp, &ncsmTmp);
            if (SUCCEEDED(hrT))
            {
                m_ncsm = ncsmTmp;
            }
            else
            {
                // Ok. That didn't work. Try the connections list next.
                if (g_ccl.IsInitialized())
                {
                    ConnListEntry cle;
                    hrT = g_ccl.HrFindConnectionByGuid(pguidId, cle);
                    if (S_OK == hrT)
                    {
                        m_ncsm = cle.ccfe.GetNetConSubMediaType();
                    }
                }

            }        
        }
        else
        {
            m_ncsm = NCSM_NONE;
        }
    }

    if (pclsid)
    {
        m_clsid = *pclsid;
    }
    else
    {
        AssertSz(wizWizard != WIZARD_NOT_WIZARD, "If you're not a wizard, you must give me a CLSID for the class!");
    }
    
    if (pguidId)
    {
        m_guidId = *pguidId;
    }

    AssertSz(pguidId, "You must give me a GUID for the object!");
    
    // Copy the persist buffer
    //
    if (pbPersistData)
    {
        LPBYTE bufTemp = (BYTE *) SHAlloc(ulPersistSize);
        if (!bufTemp)
        {
            SetPersistData(NULL, 0);
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
        
        CopyMemory(bufTemp, pbPersistData, ulPersistSize);
        SetPersistData(bufTemp, ulPersistSize);
    }
    else
    {
        AssertSz(wizWizard != WIZARD_NOT_WIZARD, "If you're not a wizard, you must give me a pbPersistData for the object!");
        SetPersistData(NULL, 0);
    }

    // Copy the device name
    //
    hr = SetDeviceName(pszDeviceName);
    
    if (SUCCEEDED(hr))
    {
        // Copy the name
        //
        hr = SetName(pszName);
        
        if (SUCCEEDED(hr))
        {
            hr = SetPhoneOrHostAddress(pszPhoneOrHostAddress);
        }
    }
    

Exit:
    TraceHr(ttidError, FAL, hr, FALSE, "CConFoldEntry::HrInitData");
    return hr;
}

// ****************************************************************************
//
//  Member:     CConFoldEntry::UpdateData
//
//  Purpose:    Modify the values in a CConFoldEntry
//
//  Arguments:
//            DWORD            dwChangeFlags
//            NETCON_MEDIATYPE MediaType
//            NETCON_STATUS    Status
//            DWORD            dwCharacteristics
//            PWSTR            pszName
//            PWSTR            pszDeviceName
//
//  Returns:    HRESULT
//
//  Author:     scottbri   10 Nov 1998
// ****************************************************************************

HRESULT CConFoldEntry::UpdateData( 
                                    IN  const  DWORD dwChangeFlags,
                                    IN  const  NETCON_MEDIATYPE MediaType,
                                    IN  const  NETCON_SUBMEDIATYPE SubMediaType,
                                    IN  const  NETCON_STATUS Status,
                                    IN  const  DWORD dwCharacteristics,
                                    IN  PCWSTR pszName,
                                    IN  PCWSTR pszDeviceName,
                                    IN  PCWSTR pszPhoneOrHostAddress)
{
    TraceFileFunc(ttidConFoldEntry);
    HRESULT hr = S_OK;
    HRESULT hrTmp;
    
    m_bDirty = TRUE;
    
    if (dwChangeFlags & CCFE_CHANGE_MEDIATYPE)
    {
        SetNetConMediaType(MediaType);
    }
            
    if (dwChangeFlags & CCFE_CHANGE_SUBMEDIATYPE)
    {
        SetNetConSubMediaType(SubMediaType);
    }
    
    if (dwChangeFlags & CCFE_CHANGE_STATUS)
    {
        SetNetConStatus(Status);
    }
    
    if (dwChangeFlags & CCFE_CHANGE_CHARACTERISTICS)
    {
        SetCharacteristics(dwCharacteristics);
    }

    if (dwChangeFlags & CCFE_CHANGE_NAME)
    {
        hrTmp = SetName(pszName);
        if (FAILED(hrTmp))
        {
            hr = hrTmp;
        }
    }
    
    if (dwChangeFlags & CCFE_CHANGE_DEVICENAME)
    {
        hrTmp = SetDeviceName(pszDeviceName);
        if (FAILED(hrTmp))
        {
            hr = hrTmp;
        }
    }
    
    if (dwChangeFlags & CCFE_CHANGE_PHONEORHOSTADDRESS)
    {
        hrTmp = SetPhoneOrHostAddress(pszPhoneOrHostAddress);
        if (FAILED(hrTmp))
        {
            hr = hrTmp;
        }
    }
    
    TraceHr(ttidError, FAL, hr, FALSE, "CConFoldEntry::UpdateData");
    return hr;
}

// ****************************************************************************
//
//  Member:     CConFoldEntry::HrDupFolderEntry
//
//  Purpose:    Duplicate a connection folder entry.
//
//  Arguments:
//      pccfe       The source folder entry to dup from
//
//  Returns:
//
//  Author:     tongl   9/3/98
// ****************************************************************************

HRESULT CConFoldEntry::HrDupFolderEntry(const CConFoldEntry& ccfe)
{
    TraceFileFunc(ttidConFoldEntry);
    m_bDirty = TRUE;
    
    Assert(!ccfe.empty());
    
    clear();
    
    return HrInitData( ccfe.GetWizard(),
        ccfe.GetNetConMediaType(),
        ccfe.GetNetConSubMediaType(),
        ccfe.GetNetConStatus(),
        &(ccfe.GetCLSID()),
        &(ccfe.GetGuidID()),
        ccfe.GetCharacteristics(),
        ccfe.GetPersistData(),
        ccfe.GetPersistSize(),
        ccfe.GetName(),
        ccfe.GetDeviceName(),
        ccfe.GetPhoneOrHostAddress());
}

// ****************************************************************************
//
//  Member:     CConFoldEntry::FShouldHaveTrayIconDisplayed
//
//  Purpose:    Return TRUE if this entry should have a tray icon displayed.
//
//  Arguments:
//      (none)
//
//  Returns:    TRUE or FALSE.
//
//  Author:     shaunco   2 Nov 1998
// ****************************************************************************

BOOL CConFoldEntry::FShouldHaveTrayIconDisplayed() const throw()
{
    // If we're in a failed state (!IsConnected) or in any 802.1x state 
    // or we're connected and have the correct bits turned on with the correct permissions
    // then we should display the icon
    //
    return     
        (
            (
                !IsConnected()
            )
            ||
            (
                (NCS_AUTHENTICATING           == GetNetConStatus()) ||
                (NCS_AUTHENTICATION_FAILED    == GetNetConStatus()) ||
                (NCS_AUTHENTICATION_SUCCEEDED == GetNetConStatus()) ||
                (NCS_CREDENTIALS_REQUIRED     == GetNetConStatus())
            )
        ) 
        ||
        (
            (NCS_CONNECTED == GetNetConStatus())
            &&
            (
                (GetCharacteristics() & NCCF_SHOW_ICON)
                &&
                (!GetWizard())
                && 
                FHasPermission(NCPERM_Statistics)
            )
        );
}

// ****************************************************************************
//  Function:   

//
//  Purpose:    Translate from a pidl to a CConFoldEntry class object
//
//  Arguments:
//      pidl   [in]     PIDL from which to create
//      ppccfe [out]    Resultant CConFoldEntry object pointer
//
//  Returns:
//
//  Author:     jeffspr   11 Nov 1997
// ****************************************************************************


// ****************************************************************************
//
//  Function:   HrCreateConFoldPidlInternal
//
//  Purpose:    Utility function for creating new Connections Folder PIDLs.
//              This function is primarily called from HrCreateConFoldPidl,
//              but can also be called directly by those that have already
//              loaded the properties and persist data.
//
//  Arguments:
//      pProps    [in]  From GetProperties
//      pbBuf     [in]  The persist buffer
//      ulBufSize [in]  Size of the persist buffer
//      szPhoneOrHostAddress [in]  Phone or Host Address
//      ppidl     [out] Return pointer for the resultant pidl
//
//  Returns:
//
//  Author:     jeffspr   27 Aug 1998
// ****************************************************************************

HRESULT HrCreateConFoldPidlInternal(IN  const NETCON_PROPERTIES* pProps,
                                    IN  const BYTE *        pbBuf,
                                    IN  ULONG               ulBufSize,
                                    IN  LPCWSTR             szPhoneOrHostAddress,
                                    OUT PCONFOLDPIDL &      pidl)
{
    HRESULT         hr      = S_OK;
    CONFOLDENTRY    ccfe;
    
    // Trace the useful info
    //
    TraceTag(ttidShellFolder, "Enum: %S, Ncm: %d, Ncs: %d, Char: 0x%08x "
        "(Show: %d, Del: %d, All: %d), Dev: %S",
        (pProps->pszwName) ? pProps->pszwName : L"null",
        pProps->MediaType, pProps->Status, pProps->dwCharacter,
        ((pProps->dwCharacter & NCCF_SHOW_ICON) > 0),
        ((pProps->dwCharacter & NCCF_ALLOW_REMOVAL) > 0),
        ((pProps->dwCharacter & NCCF_ALL_USERS) > 0),
        (pProps->pszwDeviceName) ? pProps->pszwDeviceName : L"null");
    
    // Init the CConFoldEntry from the data that we've retrieved.
    //
    hr = ccfe.HrInitData(WIZARD_NOT_WIZARD,
        pProps->MediaType, 
        NCSM_NONE,
        pProps->Status,
        &pProps->clsidThisObject,
        &pProps->guidId,
        pProps->dwCharacter, 
        pbBuf,
        ulBufSize, 
        pProps->pszwName, 
        pProps->pszwDeviceName,
        szPhoneOrHostAddress);
    if (FAILED(hr))
    {
        TraceHr(ttidShellFolder, FAL, hr, FALSE, "ccfe.HrInitData failed for "
            "non-wizard");
        goto Exit;
    }
    
    // Translate into the actual pidl
    //
    hr = ccfe.ConvertToPidl(pidl);
    if (FAILED(hr))
    {
        TraceHr(ttidShellFolder, FAL, hr, FALSE, "ConvertToPidl failed for non-wizard");
    }
    
Exit:
    TraceHr(ttidError, FAL, hr, FALSE, "HrCreateConFoldPidlInternal");
    return hr;
}

// ****************************************************************************
//
//  Function:   HrCreateConFoldPidl
//
//  Purpose:    Utility function for creating new Connections Folder PIDLs.
//
//  Arguments:
//      wizWizard   [in]    Is this PIDL for a wizard?
//      pNetCon     [in]    INetConnection interface from the enumerator
//      ppidl       [out]   Return pointer for the new pidl
//
//  Returns:    S_OK or valid OLE return code.
//
//  Author:     jeffspr   6 Oct 1997
//
//  Notes:  If the connection that you're adding is a real connection object
//          (not the wizard) and you already have loaded the persist data and
//          properties, you should call HrCreateConFoldPidlInternal directly
// ****************************************************************************

HRESULT HrCreateConFoldPidl(IN  const WIZARD      wizWizard,
                            IN  INetConnection *  pNetCon,
                            OUT PCONFOLDPIDL &    ppidl)
{
    HRESULT             hr              = S_OK;
    LPBYTE              pbBuf           = NULL;
    ULONG               ulBufSize       = 0;
    NETCON_PROPERTIES * pProps          = NULL;
    CConFoldEntry       ccfe;
    
    if (wizWizard == WIZARD_NOT_WIZARD)
    {
        Assert(pNetCon);
        
        hr = pNetCon->GetProperties (&pProps);
        if (FAILED(hr))
        {
            TraceHr(ttidShellFolder, FAL, hr, FALSE, "pNetCon->GetProperties failed in "
                "CConnectionFolderEnum::HrCreateConFoldPidl");
            goto Exit;
        }
        Assert (pProps);
        
        // Get the persist data from the connection
        //
        hr = HrGetConnectionPersistData(pNetCon, &pbBuf, &ulBufSize, NULL);
        if (FAILED(hr))
        {
            TraceHr(ttidShellFolder, FAL, hr, FALSE, "HrGetConnectionPersistData failed in "
                "CConnectionFolderEnum::HrCreateConFoldPidl");
            goto Exit;
        }

        WCHAR szPhoneOrHostAddress[MAX_PATH];
        wcscpy(szPhoneOrHostAddress, L" ");
        
        if ( (NCM_TUNNEL == pProps->MediaType) || (NCM_PHONE == pProps->MediaType) )
        {
            HRESULT hrTmp;
            RASCON_INFO RasConInfo;
            if (SUCCEEDED(hr))
            {
                
                hrTmp = HrRciGetRasConnectionInfo(pNetCon, &RasConInfo);
                if (SUCCEEDED(hrTmp))
                {
                    GetPrivateProfileString(RasConInfo.pszwEntryName, L"PhoneNumber",
                        L" ", szPhoneOrHostAddress, MAX_PATH, 
                        RasConInfo.pszwPbkFile);
                    
                    RciFree(&RasConInfo);
                }
            }
        }

        // Call the pre-read-data version of this function to actually pack the
        // ccfe and insert.
        //
        hr = HrCreateConFoldPidlInternal(pProps, pbBuf, ulBufSize, szPhoneOrHostAddress, ppidl);
        if (FAILED(hr))
        {
            goto Exit;
        }
        
    }
    else
    {
        GUID guidWiz;
        if (wizWizard == WIZARD_MNC)
        {
            guidWiz = GUID_MNC_WIZARD;
        }
        else
        {
            guidWiz = GUID_HNW_WIZARD;
            Assert(wizWizard == WIZARD_HNW);
        }

        // Pack the CConFoldEntry data from the retrieved info
        //
        hr = ccfe.HrInitData(wizWizard, NCM_NONE, NCSM_NONE, NCS_DISCONNECTED, 
            NULL, &guidWiz, 0, NULL, 0, NULL, NULL, NULL);
        if (FAILED(hr))
        {
            TraceHr(ttidShellFolder, FAL, hr, FALSE, "ccfe.HrInitData failed for "
                "Wizard");
            goto Exit;
        }
        
        // Translate into an actual pidl
        //
        hr = ccfe.ConvertToPidl(ppidl);
        if (FAILED(hr))
        {
            TraceHr(ttidShellFolder, FAL, hr, FALSE, "ConvertToPidl failed for wizard");
        }
    }
    
Exit:
    MemFree(pbBuf);
    FreeNetconProperties(pProps);
    
    TraceHr(ttidError, FAL, hr, FALSE, "HrCreateConFoldPidl");
    return hr;
}


// ****************************************************************************
//
//  Function:   HrCreateConFoldPidl
//
//  Purpose:    Utility function for creating new Connections Folder PIDLs.
//
//  Arguments:
//      PropsEx     [in]    PropsEx structure
//      ppidl       [out]   Return pointer for the new pidl
//
//  Returns:    S_OK or valid OLE return code.
//
//  Author:     deonb   26 Mar 2001
//
//  Notes:  
// ****************************************************************************

HRESULT HrCreateConFoldPidl(IN  const NETCON_PROPERTIES_EX& PropsEx,
                            OUT PCONFOLDPIDL &    ppidl)
{
    HRESULT             hr              = S_OK;
    NETCON_PROPERTIES * pProps          = NULL;
    CConFoldEntry       ccfe;


    // Trace the useful info
    //
    TraceTag(ttidShellFolder, "Enum: %S, Ncm: %d, Ncs: %d, Char: 0x%08x "
        "(Show: %d, Del: %d, All: %d), Dev: %S",
        (PropsEx.bstrName) ? PropsEx.bstrName : L"null",
        PropsEx.ncMediaType, 
        PropsEx.ncStatus, 
        PropsEx.dwCharacter,
        ((PropsEx.dwCharacter & NCCF_SHOW_ICON) > 0),
        ((PropsEx.dwCharacter & NCCF_ALLOW_REMOVAL) > 0),
        ((PropsEx.dwCharacter & NCCF_ALL_USERS) > 0),
        (PropsEx.bstrDeviceName) ? PropsEx.bstrDeviceName : L"null");

    // Init the CConFoldEntry from the data that we've retrieved.
    //
    hr = ccfe.HrInitData(WIZARD_NOT_WIZARD,
        PropsEx.ncMediaType, 
        PropsEx.ncSubMediaType,
        PropsEx.ncStatus,
        &PropsEx.clsidThisObject,
        &PropsEx.guidId,
        PropsEx.dwCharacter, 
        reinterpret_cast<const BYTE*>(PropsEx.bstrPersistData),
        SysStringByteLen(PropsEx.bstrPersistData),
        PropsEx.bstrName, 
        PropsEx.bstrDeviceName,
        PropsEx.bstrPhoneOrHostAddress);

    if (SUCCEEDED(hr))
    {
        // Translate into the actual pidl
        //
        hr = ccfe.ConvertToPidl(ppidl);
    }

    TraceHr(ttidShellFolder, FAL, hr, FALSE, "HrCreateConFoldPidl");
    return hr;
}

// ****************************************************************************
//
//  Function:   ConvertToPidlInCache
//
//  Purpose:    Determine whether a particular PIDL is in a format we support.
//              If so but it is not in the CONFOLDPIDL format, then find a match
//              in our cache and allocate a new pisl
//
//  Arguments:
//      pidl []     PIDL to test
//      ppcfpRet    PIDL converted to PCONFOLDPIDL, if required and it
//                  matches an existing connection in the cache
//
//  Returns:    NONE
//
//  Author:     tongl, 4 April, 1999
// ****************************************************************************

// ****************************************************************************
//
//  Function:   HrNetConFromPidl
//
//  Purpose:    Translate from a packed PIDL to a INetConnection pointer.
//              Do this by converting to a ConFoldEntry and getting the
//              pointer from there
//
//  Arguments:
//      pidl        [in]    Pidl that contains the connection persist data
//      ppNetCon    [out]   INetConnection * return
                            //
                            //  Returns:
//
//  Author:     jeffspr   11 Nov 1997
// ****************************************************************************

HRESULT HrNetConFromPidl(IN  const PCONFOLDPIDL & pidl,
                         OUT INetConnection **   ppNetCon)
{
    HRESULT       hr      = S_OK;
    CONFOLDENTRY  pccfe;
    
    Assert(ppNetCon);
    
    hr = pidl.ConvertToConFoldEntry(pccfe);
    if (SUCCEEDED(hr))
    {
        Assert(!pccfe.empty());
        
        hr = pccfe.HrGetNetCon(IID_INetConnection, 
            reinterpret_cast<VOID**>(ppNetCon));
    }
    
    // Free the CConFoldEntry class, if successfully created
    //
    
    TraceHr(ttidError, FAL, hr, FALSE, "HrNetConFromPidl");
    return hr;
}

// ****************************************************************************
//
//  Member:     CConFoldEntry::HrGetNetCon
//
//  Purpose:    Get the INetConnection pointer from the persisted data
//
//  Arguments:
//      riid       Interface to query for
//      ppv []     Return pointer for the interface
//
//  Returns:
//
//  Author:     jeffspr   11 Nov 1997
// ****************************************************************************

HRESULT CConFoldEntry::HrGetNetCon(IN REFIID riid,
                                   IN VOID** ppv) const
{
    HRESULT hr = HrGetConnectionFromPersistData( GetCLSID(),
        GetPersistData(),
        GetPersistSize(),
        riid,
        ppv);
    
    TraceHr(ttidError, FAL, hr, FALSE, "CConFoldEntry::HrGetNetCon");
    return hr;
}

// ****************************************************************************

// ****************************************************************************
//
//  Member:     PConfoldPidlVecFromItemIdListArray
//
//  Purpose:    Covert a LPCITEMIDLIST into a PIDL vector
//
//  Arguments:
//      apidl          [in]  LPCITEMIDLIST array of PIDLs
//      dwPidlCount    [in]  Number of items in the array
//      vecConfoldPidl [out] Vector of PIDLs
//
//  Returns:
//
//  Author:     deonb 2000
// ****************************************************************************

HRESULT PConfoldPidlVecFromItemIdListArray(IN  LPCITEMIDLIST * apidl, 
                                           IN  const DWORD dwPidlCount, 
                                           OUT PCONFOLDPIDLVEC& vecConfoldPidl)
{
    HRESULT hr = S_OK;
    if (NULL == apidl)
    {
        return S_FALSE;
    }
    
    LPCITEMIDLIST   *tmpIdList = apidl;
    for (DWORD i = 0; i < dwPidlCount; i++)
    {
        PCONFOLDPIDL newPidl;
        hr = newPidl.InitializeFromItemIDList(*tmpIdList);
        if (SUCCEEDED(hr))
        {
            vecConfoldPidl.push_back(newPidl);
        }
        else
        {
            break;
        }
        
        tmpIdList++;
    }
    
    return hr;
}

#ifdef DBG_VALIDATE_PIDLS
inline BOOL IsValidPIDL(IN  LPCITEMIDLIST pidl) throw()
{
    CExceptionSafeLock esLock(&g_csPidl);
    if (NULL == pidl)
    {
        return TRUE;
    }
    
    if (IsBadReadPtr(pidl, sizeof(USHORT)))
    {
        AssertSz(FALSE, "invalid read pointer");
        return FALSE;
    }
    else
    {
        if (IsBadReadPtr(pidl, pidl->mkid.cb) )
        {
            AssertSz(FALSE, "invalid read buffer");
            return FALSE;
        }
        else
        {
            if (0 == _ILNext(pidl)->mkid.cb || IsValidPIDL(_ILNext(pidl)) )
            {
                return TRUE;
            }
            else
            {
                // Don't need to assert since called IsValidPidl would have asserted already
                return FALSE;
            }
        }
    }
    return FALSE;
}
#endif

BOOL IsNullTerminatedW(LPCWSTR szString, DWORD dwMaxLen)
{
    for (DWORD x = 0; x < dwMaxLen; x++)
    {
        if (szString[x] == L'\0')
        {
            return TRUE;
        }
    }

    return FALSE;
}

BOOL IsNullTerminatedA(LPCSTR szString, DWORD dwMaxLen)
{
    for (DWORD x = 0; x < dwMaxLen; x++)
    {
        if (szString[x] == '\0')
        {
            return TRUE;
        }
    }

    return FALSE;
}

BOOL ConFoldPidl_v1::IsPidlOfThisType() const throw()
{
    BOOL bValidPidl = FALSE;

    if ( GetPidlType(reinterpret_cast<LPCITEMIDLIST>(this)) == PIDL_TYPE_V1 )
    {
#if defined (_X86_)
        DWORD dwDataOffset = bData - reinterpret_cast<const BYTE *>(this); // Get bData offset;

        DWORD dwPidlSize;
        dwPidlSize = dwDataOffset;
        dwPidlSize += ulPersistBufSize;
        dwPidlSize += ulStrNameSize;
        dwPidlSize += ulStrDeviceNameSize;
        dwPidlSize += sizeof(USHORT); // Terminating
    
        if (
                (uLeadId == CONFOLDPIDL_LEADID)
             && (uTrailId == CONFOLDPIDL_TRAILID)
             && (dwPidlSize <= iCB) // Calculated size <= handed PIDL size (Sometimes V1 PIDLs are shorter - hence not == a check.)
             && (ulStrNamePos == 0) // Name starts at 0
             && (ulPersistBufPos < iCB) // Persisted buffer starts before end of PIDL
             && (ulStrDeviceNamePos < iCB) // Devicename starts before end of PIDL
             && (ulPersistBufSize < iCB) // Persisted buffer size smaller than PIDL
             && (ulStrDeviceNameSize < iCB) // Devicename smaller than PIDL
             && (ulStrNameSize < iCB) // Name smaller than PIDL
             && (ulStrDeviceNamePos == ulStrNameSize) // Device name starts where name stops
             && (ulPersistBufPos == ulStrDeviceNamePos + ulStrDeviceNameSize) // Persisted buffer starts where DeviceName stops
             && (dwDataOffset + ulPersistBufPos + ulPersistBufSize <= iCB) // Persisted buffer ends before PIDL 
             && (IsNullTerminatedW(PszGetNamePointer(), ulStrNameSize) ) // Name is zero terminated correctly
             && (IsNullTerminatedW(PszGetDeviceNamePointer(), ulStrDeviceNameSize) ) // Device name is zero terminated correctly
           )
        {
            bValidPidl = TRUE;
        }
#else
        bValidPidl = TRUE;
#endif
    }

    if (!bValidPidl)
    {
        TraceTag(ttidError, "Ignoring bad V1 pidl");
    }

    return bValidPidl;
}

BOOL ConFoldPidl_v2::IsPidlOfThisType() const throw()
{
    BOOL bValidPidl = FALSE;

    if ( GetPidlType(reinterpret_cast<LPCITEMIDLIST>(this)) == PIDL_TYPE_V2 )
    {
#if defined (_X86_)
        DWORD dwDataOffset = bData - reinterpret_cast<const BYTE *>(this); // Get bData offset;
        
        DWORD dwPidlSize;
        dwPidlSize = dwDataOffset;
        dwPidlSize += ulPersistBufSize;
        dwPidlSize += ulStrNameSize;
        dwPidlSize += ulStrDeviceNameSize;
        dwPidlSize += ulStrPhoneOrHostAddressSize;
        dwPidlSize += sizeof(USHORT); // Terminating 0
        

        if (
                (uLeadId == CONFOLDPIDL_LEADID)
             && (uTrailId == CONFOLDPIDL_TRAILID)
             && (dwPidlSize <= iCB) // Calculated size <= handed PIDL size (Sometimes PIDLs imported from V1 are shorter - hence not == a check.)
             && (ulStrNamePos == 0) // Name starts at 0
             && (ulPersistBufPos < iCB) // Persisted buffer starts before end of PIDL
             && (ulStrDeviceNamePos < iCB) // Devicename starts before end of PIDL
             && (ulStrPhoneOrHostAddressPos < iCB) // Phone/Host starts before end of PIDL
             && (ulPersistBufSize < iCB) // Persisted buffer size smaller than PIDL
             && (ulStrDeviceNameSize < iCB) // Devicename smaller than PIDL
             && (ulStrNameSize < iCB) // Name smaller than PIDL
             && (ulStrDeviceNamePos == ulStrNameSize) // Device name starts where name stops
             && (ulPersistBufPos == ulStrDeviceNamePos + ulStrDeviceNameSize) // Persisted buffer starts where DeviceName stops
             && (ulStrPhoneOrHostAddressPos == ulPersistBufPos + ulPersistBufSize) // Phone/Host starts where Persisted buffer stop
             && (dwDataOffset + ulStrPhoneOrHostAddressPos + ulStrPhoneOrHostAddressSize <= iCB) // Phone/Host ends before PIDL 
             && (IsNullTerminatedW(PszGetNamePointer(), ulStrNameSize)) // Name is zero terminated correctly
             && (IsNullTerminatedW(PszGetDeviceNamePointer(), ulStrDeviceNameSize)) // Device name is zero terminated correctly
             && (IsNullTerminatedW(PszGetPhoneOrHostAddressPointer(), ulStrPhoneOrHostAddressSize)) // Phone/host is zero terminated correctly
             )
        {
            bValidPidl = TRUE;
        }
#else
        bValidPidl = TRUE;
#endif
    }

    if (!bValidPidl)
    {
        TraceTag(ttidError, "Ignoring bad V2 pidl");
    }
    
    return bValidPidl;
}

BOOL ConFoldPidlFolder::IsPidlOfThisType() const throw()
{
    // We can't tell if it's a PIDL_TYPE_FOLDER - this is shell internal
    if ( GetPidlType(reinterpret_cast<LPCITEMIDLIST>(this)) == PIDL_TYPE_UNKNOWN ) 
    {
#ifdef DBG
        if ( (dwLength != 0x14) || (dwId != 0x1f) )
        {
            return FALSE;
        }
#endif
        return TRUE;
    }
    else
    {
        return FALSE; 
    }
}

BOOL ConFoldPidl98::IsPidlOfThisType(OUT BOOL* pReserved) const throw()
{
    BOOL bValidPidl = FALSE;

    if ( GetPidlType(reinterpret_cast<LPCITEMIDLIST>(this)) == PIDL_TYPE_98 )
    {
        if (IsNullTerminatedA(szaName, min(cbSize, MAX_PATH))) // Name is zero terminated inside PIDL and smaller than MAX_PATH
        {
            bValidPidl = TRUE;
        }
    }

    if (!bValidPidl)
    {
        TraceTag(ttidError, "Ignoring bad V98 pidl");
    }

    return bValidPidl;
}

const DWORD CConFoldEntry::GetCharacteristics() const throw()
{
    return m_dwCharacteristics;
}

HRESULT CConFoldEntry::SetCharacteristics(IN const DWORD dwCharacteristics)
{
    m_bDirty = TRUE;
    m_dwCharacteristics = dwCharacteristics;
    return S_OK;
}

const GUID CConFoldEntry::GetGuidID() const throw()
{
    return m_guidId;
}

HRESULT CConFoldEntry::SetGuidID(IN const GUID guidId)
{
    m_bDirty = TRUE;
    m_guidId = guidId;
    return S_OK;
}

const CLSID CConFoldEntry::GetCLSID() const throw()
{
    return m_clsid;
}

HRESULT CConFoldEntry::SetCLSID(IN const CLSID clsid)
{
    m_bDirty = TRUE;
    m_clsid = clsid;
    return S_OK;
}

PCWSTR CConFoldEntry::GetName() const throw()
{
    return m_pszName;
}

HRESULT CConFoldEntry::SetPName(IN TAKEOWNERSHIP SHALLOCATED PWSTR pszName)
{
    m_bDirty = TRUE;
    m_pszName = pszName;
    return S_OK;
}

PCWSTR CConFoldEntry::GetDeviceName() const throw()
{
    return m_pszDeviceName;
}

HRESULT CConFoldEntry::SetPDeviceName(IN TAKEOWNERSHIP SHALLOCATED PWSTR pszDeviceName)
{
    m_bDirty = TRUE;
    m_pszDeviceName = pszDeviceName;
    return S_OK;
}

PCWSTR CConFoldEntry::GetPhoneOrHostAddress() const throw()
{
    return m_pszPhoneOrHostAddress;
}

HRESULT CConFoldEntry::SetPPhoneOrHostAddress(IN TAKEOWNERSHIP SHALLOCATED PWSTR pszPhoneOrHostAddress)
{
    m_bDirty = TRUE;
    m_pszPhoneOrHostAddress = pszPhoneOrHostAddress;
    return S_OK;
}

const NETCON_STATUS CConFoldEntry::GetNetConStatus() const throw()
{
    return m_ncs;
}

const BOOL CConFoldEntry::IsConnected() const throw()
{
    return (m_ncs != NCS_MEDIA_DISCONNECTED) && (m_ncs != NCS_INVALID_ADDRESS);
}

HRESULT CConFoldEntry::SetNetConStatus(IN const NETCON_STATUS ncs)
{
    m_bDirty = TRUE;
    m_ncs = ncs;
    return S_OK;
}

const NETCON_MEDIATYPE CConFoldEntry::GetNetConMediaType() const throw()
{
    return m_ncm;
}

HRESULT CConFoldEntry::SetNetConMediaType(IN const NETCON_MEDIATYPE ncm)
{
    m_bDirty = TRUE;
    m_ncm = ncm;
    return S_OK;
}

const NETCON_SUBMEDIATYPE CConFoldEntry::GetNetConSubMediaType() const throw()
{
    return m_ncsm;
}

HRESULT CConFoldEntry::SetNetConSubMediaType(IN const NETCON_SUBMEDIATYPE ncsm)
{
    m_bDirty = TRUE;
    m_ncsm = ncsm;
    return S_OK;
}


const WIZARD CConFoldEntry::GetWizard() const throw()
{
    return m_wizWizard;
}

HRESULT CConFoldEntry::SetWizard(IN const WIZARD  wizWizard)
{
    m_bDirty = TRUE;
    m_wizWizard = wizWizard;
    return S_OK;
}

const BYTE * CConFoldEntry::GetPersistData() const throw()
{
    return m_pbPersistData;
}

const ULONG  CConFoldEntry::GetPersistSize() const throw()
{
    return m_ulPersistSize;
}

HRESULT CConFoldEntry::SetPersistData(IN BYTE* TAKEOWNERSHIP SHALLOCATED pbPersistData, 
                                      IN const ULONG ulPersistSize)
{
    m_bDirty = TRUE;
    m_pbPersistData = pbPersistData;
    m_ulPersistSize = ulPersistSize;
    return S_OK;
}

BOOL CConFoldEntry::empty() const throw()
{
    if (GetWizard())
    {
        return FALSE;
    }
    else
    {
        if (IsEqualGUID(GetCLSID(), GUID_NULL) )
        {
            return TRUE;
        }
        else
        {
            return FALSE;
        }
    }
}

void CConFoldEntry::clear() throw()
{
    TraceFileFunc(ttidConFoldEntry);
    m_bDirty = TRUE;
    
    if (GetName())
    {
        SHFree(m_pszName);
        m_pszName = NULL;
    }
    
    if (GetDeviceName())
    {
        SHFree(m_pszDeviceName);
        m_pszDeviceName = NULL;
    }
    
    if (GetPhoneOrHostAddress())
    {
        SHFree(m_pszPhoneOrHostAddress);
        m_pszPhoneOrHostAddress = NULL;
    }
    
    if (GetPersistData())
    {
        SHFree(m_pbPersistData);
        m_pbPersistData = NULL;
        m_ulPersistSize = 0;
    }
    
    m_wizWizard = WIZARD_NOT_WIZARD;
    m_ncm = NCM_NONE;
    m_ncsm= NCSM_NONE;
    m_ncs = NCS_DISCONNECTED;
    m_dwCharacteristics = 0;
    m_clsid = GUID_NULL;
    m_guidId = GUID_NULL;
}

LPITEMIDLIST CConFoldEntry::TearOffItemIdList() const throw()
{
    PCONFOLDPIDL pidl;
    
    m_bDirty = TRUE;
    
    ConvertToPidl(pidl);
    return pidl.TearOffItemIdList();
}

HRESULT CConFoldEntry::InitializeFromItemIdList(IN LPCITEMIDLIST lpItemIdList)
{
    PCONFOLDPIDL pidl;
    HRESULT hr = S_OK;
    
    m_bDirty = TRUE;
    
    hr = pidl.InitializeFromItemIDList(lpItemIdList);
    if (FAILED(hr))
    {
        return hr;
    }
    
    hr = pidl.ConvertToConFoldEntry(*this);
    return hr;
}

HRESULT CConFoldEntry::ConvertToPidl( OUT CPConFoldPidl<ConFoldPidl_v1>& pidl) const
{
    TraceFileFunc(ttidConFoldEntry);
    
    HRESULT         hr                  = S_OK;
    DWORD           dwNameSize          = 0;
    DWORD           dwDeviceNameSize    = 0;
    DWORD           dwPidlSize          = sizeof(ConFoldPidl_v1); // Initialize the PIDL byte count with the base size
    
    Assert(!empty());
    Assert(GetName());
    Assert(GetDeviceName());

    NETCFG_TRY

        if (m_bDirty)
        {
            // Get the size of the name, and tack on a trailing NULL (since we now
            // have something else in the buffer behind it.
            //
            dwNameSize                  = lstrlenW(GetName()) + 1;
            dwDeviceNameSize            = lstrlenW(GetDeviceName()) + 1;

            // Add the size of the string to the PIDL struct size. We don't need to include
            // an extra byte for the string's terminating NULL because we've already
            // included a WCHAR[1] in the struct.
            //
            dwPidlSize += ((dwNameSize) * sizeof(WCHAR));
            dwPidlSize += ((dwDeviceNameSize) * sizeof(WCHAR));
            
            // Tack of the length of the persist buffer
            //
            dwPidlSize += GetPersistSize();
            
            // Allocate the PIDL.
            //
            hr = pidl.ILCreate(dwPidlSize + sizeof(USHORT));   // Terminating 0 for the PIDL
            if (SUCCEEDED(hr))
            {
                PWSTR          pszName         = NULL;
                PWSTR          pszDeviceName   = NULL;
                PWSTR          pszPhoneOrHostAddress = NULL;
                
                // Fill in the pidl info.
                //
                pidl->wizWizard         = GetWizard();
                pidl->iCB               = (WORD)dwPidlSize;
                //            pidl->dwVersion         = CONNECTIONS_FOLDER_IDL_VERSION_V1;
                pidl->ncm               = GetNetConMediaType();
                pidl->ncs               = GetNetConStatus();
                pidl->uLeadId           = CONFOLDPIDL_LEADID;
                pidl->uTrailId          = CONFOLDPIDL_TRAILID;
                pidl->clsid             = GetCLSID();
                pidl->guidId            = GetGuidID();
                pidl->dwCharacteristics = GetCharacteristics();
                
                // Fill in the name
                //
                pidl->ulStrNamePos = 0;             // offset into the PIDL's pbBuf
                pidl->ulStrNameSize = dwNameSize * sizeof(WCHAR);   // in bytes
                
                pszName = pidl->PszGetNamePointer();
                lstrcpyW(pszName, GetName());
                pszName[dwNameSize] = 0;
                
                // Fill in the device name, and set the offset info
                //
                pidl->ulStrDeviceNamePos = pidl->ulStrNamePos + pidl->ulStrNameSize;
                pidl->ulStrDeviceNameSize = dwDeviceNameSize * sizeof(WCHAR);   // in bytes
                pszDeviceName = pidl->PszGetDeviceNamePointer();
                lstrcpyW(pszDeviceName, GetDeviceName());
                pszDeviceName[dwDeviceNameSize] = 0;
                
                // Set the offset into the PIDL's pbBuf
                //
                pidl->ulPersistBufPos = pidl->ulStrDeviceNamePos + pidl->ulStrDeviceNameSize;
                
                // Fill in the persist buffer, if present (it won't be on a wizard)
                //
                if (GetPersistData())
                {
                    pidl->ulPersistBufSize = GetPersistSize();
                    CopyMemory(pidl->bData + pidl->ulPersistBufPos, GetPersistData(), GetPersistSize());
                }
                else
                {
                    // Since we're the wizard, there shouldn't be a buffer, so the size
                    // should always be passed in as 0.
                    //
                    Assert(GetPersistSize() == 0);
                    pidl->ulPersistBufSize = 0;
                }

                // Don't forget to terminate the list!
                //
                LPITEMIDLIST pidlTerminate;
                pidlTerminate = ILNext( pidl.GetItemIdList() );
                pidlTerminate->mkid.cb = 0;
            }
            else
            {
                AssertSz(FALSE, "CConFoldEntry::ConvertToPidl is hosed");
                hr = E_OUTOFMEMORY;
            }
            
#ifdef DBG_VALIDATE_PIDLS
            Assert(IsValidPIDL( pidl.GetItemIdList() ));
#endif
            Assert( pidl->IsPidlOfThisType() ) ;
            
            if (SUCCEEDED(hr))
            {
                m_bDirty = FALSE;
                m_CachedV1Pidl = pidl;
            }
        }
        else
        {
            TraceTag(ttidShellFolder, "Using internally cached PIDL");
            pidl = m_CachedV1Pidl;
        }

    NETCFG_CATCH(hr)

    TraceHr(ttidError, FAL, hr, FALSE, "CConFoldEntry::ConvertToPidl");
    return hr;
}

HRESULT CConFoldEntry::ConvertToPidl( OUT CPConFoldPidl<ConFoldPidl_v2>& pidl) const
{
    TraceFileFunc(ttidConFoldEntry);
    
    HRESULT         hr                  = S_OK;
    DWORD           dwNameSize          = 0;
    DWORD           dwDeviceNameSize    = 0;
    DWORD           dwPhoneOrHostAddressSize  = 0;
    DWORD           dwPidlSize          = sizeof(ConFoldPidl_v2); // Initialize the PIDL byte count with the base size
    
    Assert(!empty());
    Assert(GetName());
    Assert(GetDeviceName());
    Assert(GetPhoneOrHostAddress());

    NETCFG_TRY
        
        if (m_bDirty)
        {
            // Get the size of the name, and tack on a trailing NULL (since we now
            // have something else in the buffer behind it.
            //
            dwNameSize                  = lstrlenW(GetName()) + 1;
            dwDeviceNameSize            = lstrlenW(GetDeviceName()) + 1;
            dwPhoneOrHostAddressSize    = lstrlenW(GetPhoneOrHostAddress()) + 1;
            
            // Add the size of the string to the PIDL struct size. We don't need to include
            // an extra byte for the string's terminating NULL because we've already
            // included a WCHAR[1] in the struct.
            //
            dwPidlSize += ((dwNameSize) * sizeof(WCHAR));
            dwPidlSize += ((dwDeviceNameSize) * sizeof(WCHAR));
            dwPidlSize += ((dwPhoneOrHostAddressSize) * sizeof(WCHAR));
            
            // Tack of the length of the persist buffer
            //
            dwPidlSize += GetPersistSize();
            
            // Allocate the PIDL.
            //
            hr = pidl.ILCreate(dwPidlSize + sizeof(USHORT));   // Terminating 0 for the PIDL
            if (SUCCEEDED(hr))
            {
                PWSTR          pszName         = NULL;
                PWSTR          pszDeviceName   = NULL;
                PWSTR          pszPhoneOrHostAddress = NULL;
                
                // Fill in the pidl info.
                //
                pidl->wizWizard         = GetWizard();
                pidl->iCB               = (WORD)dwPidlSize;
                //            pidl->dwVersion         = CONNECTIONS_FOLDER_IDL_VERSION_V1;
                pidl->ncm               = GetNetConMediaType();
                pidl->ncs               = GetNetConStatus();
                pidl->ncsm              = GetNetConSubMediaType();
                pidl->uLeadId           = CONFOLDPIDL_LEADID;
                pidl->uTrailId          = CONFOLDPIDL_TRAILID;
                pidl->clsid             = GetCLSID();
                pidl->guidId            = GetGuidID();
                pidl->dwCharacteristics = GetCharacteristics();
                
                // Fill in the name
                //
                pidl->ulStrNamePos = 0;             // offset into the PIDL's pbBuf
                pidl->ulStrNameSize = dwNameSize * sizeof(WCHAR);   // in bytes
                
                pszName = pidl->PszGetNamePointer();
                lstrcpyW(pszName, GetName());
                pszName[dwNameSize] = 0;
                
                // Fill in the device name, and set the offset info
                //
                pidl->ulStrDeviceNamePos = pidl->ulStrNamePos + pidl->ulStrNameSize;
                pidl->ulStrDeviceNameSize = dwDeviceNameSize * sizeof(WCHAR);   // in bytes
                pszDeviceName = pidl->PszGetDeviceNamePointer();
                lstrcpyW(pszDeviceName, GetDeviceName());
                pszDeviceName[dwDeviceNameSize] = 0;

                // Set the offset into the PIDL's pbBuf
                //
                pidl->ulPersistBufPos = pidl->ulStrDeviceNamePos + pidl->ulStrDeviceNameSize;

                // Fill in the persist buffer, if present (it won't be on a wizard)
                //
                if (GetPersistData())
                {
                    pidl->ulPersistBufSize = GetPersistSize();
                    CopyMemory(pidl->bData + pidl->ulPersistBufPos, GetPersistData(), GetPersistSize());
                }
                else
                {
                    // Since we're the wizard, there shouldn't be a buffer, so the size
                    // should always be passed in as 0.
                    //
                    Assert(GetPersistSize() == 0);
                    pidl->ulPersistBufSize = 0;
                }
                
                // Fill in the Phone Number & Host Address name, and set the offset info
                //
                pidl->ulStrPhoneOrHostAddressPos  = pidl->ulPersistBufPos + pidl->ulPersistBufSize; // offset
                pidl->ulStrPhoneOrHostAddressSize = dwPhoneOrHostAddressSize * sizeof(WCHAR);   // in bytes
                pszPhoneOrHostAddress = pidl->PszGetPhoneOrHostAddressPointer();
                lstrcpyW(pszPhoneOrHostAddress, GetPhoneOrHostAddress());
                pszPhoneOrHostAddress[dwPhoneOrHostAddressSize] = 0;

                Assert( !lstrcmpW(pidl->PszGetNamePointer(), GetName()) );
                Assert( !lstrcmpW(pidl->PszGetPhoneOrHostAddressPointer(), GetPhoneOrHostAddress()) );
                Assert( !lstrcmpW(pidl->PszGetDeviceNamePointer(), GetDeviceName()) );
                Assert( !memcmp(pidl->PbGetPersistBufPointer(), GetPersistData(), GetPersistSize()) );
                
                // Don't forget to terminate the list!
                //
                LPITEMIDLIST pidlTerminate;
                pidlTerminate = ILNext( pidl.GetItemIdList() );
                pidlTerminate->mkid.cb = 0;
            }
            else
            {
                AssertSz(FALSE, "CConFoldEntry::ConvertToPidl is hosed");
                hr = E_OUTOFMEMORY;
            }

#ifdef DBG_VALIDATE_PIDLS
            Assert(IsValidPIDL( pidl.GetItemIdList() ));
#endif
            Assert( pidl->IsPidlOfThisType() ) ;
            
            if (SUCCEEDED(hr))
            {
                m_bDirty = FALSE;
                m_CachedV2Pidl = pidl;
            }
        }
        else
        {
            TraceTag(ttidShellFolder, "Using internally cached PIDL");
            pidl = m_CachedV2Pidl;
        }

    NETCFG_CATCH(hr)

    TraceHr(ttidError, FAL, hr, FALSE, "CConFoldEntry::ConvertToPidl");
    return hr;
}

CONFOLDPIDLTYPE GetPidlType(IN  LPCITEMIDLIST pidl) throw()
{
    CONFOLDPIDLTYPE bRet = PIDL_TYPE_UNKNOWN;
    
    if (!pidl)
    {
        return bRet;
    }
    
    // V1 check
    if (pidl->mkid.cb >= CBCONFOLDPIDLV1_MIN)
    {
        const UNALIGNED ConFoldPidl_v1* pcfp = reinterpret_cast<const ConFoldPidl_v1*>(pidl);
        
        if ( (pcfp->iCB >= CBCONFOLDPIDLV1_MIN) && (pcfp->iCB <= CBCONFOLDPIDLV1_MAX))
        {
            if (pcfp->uLeadId == CONFOLDPIDL_LEADID &&
                pcfp->uTrailId == CONFOLDPIDL_TRAILID)
            {
                if (pcfp->dwVersion == ConFoldPidl_v1::CONNECTIONS_FOLDER_IDL_VERSION)
                {
                    bRet = PIDL_TYPE_V1;
                    return bRet;
                }
            }
        }
    }   
    
    // V2 check
    if (pidl->mkid.cb >= CBCONFOLDPIDLV2_MIN)
    {
        const UNALIGNED ConFoldPidl_v2* pcfp = reinterpret_cast<const ConFoldPidl_v2 *>(pidl);
        if ( (pcfp->iCB >= CBCONFOLDPIDLV2_MIN) && (pcfp->iCB <= CBCONFOLDPIDLV2_MAX))
        {
            if (pcfp->uLeadId == CONFOLDPIDL_LEADID &&
                pcfp->uTrailId == CONFOLDPIDL_TRAILID)
            {
                if (pcfp->dwVersion == ConFoldPidl_v2::CONNECTIONS_FOLDER_IDL_VERSION)
                {
                    bRet = PIDL_TYPE_V2;
                    return bRet;
                }
            }
        }
    }
    
    // 98 Check
    if (pidl->mkid.cb >= CBCONFOLDPIDL98_MIN)
    {
        const UNALIGNED ConFoldPidl98*  pcfp = reinterpret_cast<const ConFoldPidl98 *>(pidl);
        if ((pcfp->cbSize >= CBCONFOLDPIDL98_MIN) && (pcfp->cbSize <= CBCONFOLDPIDL98_MAX))
        {
            if ((SOF_REMOTE == pcfp->uFlags) || (SOF_NEWREMOTE == pcfp->uFlags) ||
                (SOF_MEMBER == pcfp->uFlags))
            {
                if (pcfp->nIconIndex >= 0)
                {
                    bRet = PIDL_TYPE_98;
                    return bRet;
                }
            }
        }
    }
    
    return bRet;
}

HRESULT ConFoldPidl_v1::ConvertToConFoldEntry(OUT CConFoldEntry& ccfe) const
{
    HRESULT         hr      = S_OK;
    
    Assert(this);
    if (!this)
    {
        return E_UNEXPECTED;
    }
    
#if ( defined (MMMDBG) && defined ( _X86_ ) )
    if ( (g_ccl.m_csMain.OwningThread == (HANDLE)GetCurrentThreadId()) && (g_ccl.m_csMain.LockCount != -1) )
    {
        AssertSz(NULL, ".ConvertToConFoldEntry is called while the thread is owning g_ccl's Critical section. \r\n"
            "This may deadlock since .ConvertToConFoldEntry needs to marshall COM calls to other threads \r\n\r\n"
            "To Fix: Make a copy of ccfe from the pidl and Release the lock before calling .ConvertToConFoldEntry.");
    }
#endif
    
    // hr = ConvertToPidlInCache(*this, pcfp); // NOT REQUIRED. WE KNOW THIS IS A V1 PIDL!
    
    // Initialize the data from the pidl
    hr = ccfe.HrInitData(wizWizard,
        ncm,
        NCSM_NONE,
        ncs,
        &clsid,
        &guidId,
        dwCharacteristics,
        PbGetPersistBufPointer(),
        ulPersistBufSize,
        PszGetNamePointer(),
        PszGetDeviceNamePointer(),
        NULL /*PszGetPhoneOrHostAddressPointer()*/);
    
    if (FAILED(hr))
    {
        TraceHr(ttidShellFolder, FAL, hr, FALSE, "Failed in call to pcfe->HrInitData in ConvertToConFoldEntry");
    }
    
    TraceHr(ttidError, FAL, hr, FALSE, "ConvertToConFoldEntry");
    return hr;
}

HRESULT ConFoldPidl_v2::ConvertToConFoldEntry(OUT CConFoldEntry& ccfe) const
{
    HRESULT         hr      = S_OK;
    
    Assert(this);
    if (!this)
    {
        return E_UNEXPECTED;
    }
    
#if ( defined (MMMDBG) && defined ( _X86_ ) )
    if ( (g_ccl.m_csMain.OwningThread == (HANDLE)GetCurrentThreadId()) && (g_ccl.m_csMain.LockCount != -1) )
    {
        AssertSz(NULL, ".ConvertToConFoldEntry is called while the thread is owning g_ccl's Critical section. \r\n"
            "This may deadlock since .ConvertToConFoldEntry needs to marshall COM calls to other threads \r\n\r\n"
            "To Fix: Make a copy of ccfe from the pidl and Release the lock before calling .ConvertToConFoldEntry.");
    }
#endif
    
    // hr = ConvertToPidlInCache(*this, pcfp); // NOT REQUIRED. WE KNOW THIS IS A V2 PIDL!
    
    // Initialize the data from the pidl
    hr = ccfe.HrInitData(wizWizard,
        ncm,
        ncsm,
        ncs,
        &clsid,
        &guidId,
        dwCharacteristics,
        PbGetPersistBufPointer(),
        ulPersistBufSize,
        PszGetNamePointer(),
        PszGetDeviceNamePointer(),
        PszGetPhoneOrHostAddressPointer());
    
    if (FAILED(hr))
    {
        TraceHr(ttidShellFolder, FAL, hr, FALSE, "Failed in call to pcfe->HrInitData in ConvertToConFoldEntry");
    }
    
    TraceHr(ttidError, FAL, hr, FALSE, "ConvertToConFoldEntry");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\shell\folder\ac_ctrayui.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       ac_CTrayUiCpp.h
//
//  Contents:   Home Networking Auto Config Tray Icon UI code
//
//  Author:     jeffsp    9/27/2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop



#include "ac_CTrayUi.h"
#include "foldinc.h"    // Standard shell\tray includes
#include <nsres.h>
#include "foldres.h"
#include "traymsgs.h"
#include <dbt.h>
#include <ndisguid.h>
#include "lm.h"



UINT g_uWindowRefCount = 0;
HWND g_hwndHnAcTray = NULL;
UINT_PTR g_HnAcTimerHandle = NULL;
HDEVNOTIFY  g_hDeviceChangeNotify = NULL;


CRITICAL_SECTION g_WindowCriticalSection;
const WCHAR c_szHnAcTrayClass[]             = L"Home Net Auto Config Tray";
const DWORD c_dwAutoConfigBalloonTimeoutSeconds   = 15;
static const WCHAR c_szRunDll32[]             = L"rundll32.exe";
static const WCHAR c_szRunHomeNetworkWizard[] = L"hnetwiz.dll,HomeNetWizardRunDll";

DWORD WINAPI ac_AsyncDeviceChange(IN TAKEOWNERSHIP LPVOID lpParam);

HRESULT IsAdapterPhysical(IN const GUID* pGuid, OUT BOOL* bPhysical);

LRESULT
CALLBACK
CHnAcTrayUI_WndProc (
                 IN  HWND    hwnd,       // window handle
                 IN  UINT    uiMessage,  // type of message
                 IN  WPARAM  wParam,     // additional information
                 IN  LPARAM  lParam)     // additional information
{
    switch (uiMessage)
    {
      case WM_CREATE:
        return OnHnAcTrayWmCreate(hwnd);

      case MYWM_NOTIFYICON:
        return OnHnAcMyWMNotifyIcon(hwnd, uiMessage, wParam, lParam);

      case WM_DESTROY:
        g_hwndHnAcTray = NULL;
        PostQuitMessage(0);
        break;

      default:     // Passes it on if unproccessed
        return (DefWindowProc (hwnd, uiMessage, wParam, lParam));
    }
    return (0);
}

HRESULT ac_CreateHnAcTrayUIWindow()
{

    HRESULT hr = S_OK;

    // create a hidden window
    //
    WNDCLASS wndclass;
    ZeroMemory (&wndclass, sizeof(wndclass));

    wndclass.lpfnWndProc   = CHnAcTrayUI_WndProc;
    wndclass.hInstance     = _Module.GetResourceInstance();
    wndclass.lpszClassName = c_szHnAcTrayClass;

    RegisterClass (&wndclass);

    EnterCriticalSection(&g_WindowCriticalSection); // we have to protect this since we are on a thread pool callback

    if(0 == g_uWindowRefCount++)
    {
        CreateWindow(c_szHnAcTrayClass,
            c_szHnAcTrayClass,
            WS_OVERLAPPEDWINDOW,
            CW_USEDEFAULT,
            CW_USEDEFAULT,
            CW_USEDEFAULT,
            CW_USEDEFAULT,
            NULL,
            NULL,
            _Module.GetResourceInstance(),
            NULL);
    }
    LeaveCriticalSection(&g_WindowCriticalSection);

    BOOL bGetMessage;
    MSG Message;

    while(bGetMessage = GetMessage(&Message, g_hwndHnAcTray, 0, 0) && -1 != bGetMessage)
    {
        DispatchMessage(&Message);
    }

    return hr;
}





LRESULT OnHnAcTrayWmCreate(IN  HWND hwnd)
{
    g_hwndHnAcTray = hwnd;


    HICON hiconTray;
    HRESULT hr = S_OK;

    hiconTray = LoadIcon(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDI_CONFOLD_HOMENET_WIZARD));

    if (hiconTray)
    {
        NOTIFYICONDATA  nid;

        ZeroMemory (&nid, sizeof(nid));
        nid.cbSize              = sizeof(NOTIFYICONDATA);
        nid.hWnd                = g_hwndHnAcTray;
        nid.uID                 = 9998;
        nid.uFlags              = NIF_MESSAGE | NIF_ICON; // | NIF_STATE;
        nid.uCallbackMessage    = MYWM_NOTIFYICON;
        nid.hIcon               = hiconTray;
//      nid.dwState             = NIS_HIDDEN;
//      nid.dwStateMask         = nid.dwState;

        // Configure the balloon tip
        {
            nid.uFlags |= NIF_INFO;
            nid.dwInfoFlags = NIIF_INFO;
            nid.uTimeout = c_dwAutoConfigBalloonTimeoutSeconds * 1000;

            // WARNING these fields are 64 and 256 chars max
            lstrcpyW(nid.szInfoTitle, SzLoadIds(IDS_AUTOCONFIGTRAY_RUN_HOME_NET_WIZARD_BALLOON_TITLE));
            lstrcpyW(nid.szInfo, SzLoadIds(IDS_AUTOCONFIGTRAY_RUN_HOME_NET_WIZARD_BALLOON));
        }

        hr = HrShell_NotifyIcon(NIM_ADD, &nid);

        nid.uVersion = NOTIFYICON_VERSION;
        nid.uFlags   = 0;
        hr = HrShell_NotifyIcon(NIM_SETVERSION, &nid);

    }

    return 0;
}

LRESULT OnHnAcTrayWmNotify(
    IN  HWND hwnd,
    IN  WPARAM wParam,
    IN  LPARAM lParam )
{

    return (DefWindowProc (hwnd, WM_NOTIFY, wParam, lParam));

}


LRESULT OnHnAcMyWMNotifyIcon(IN  HWND hwnd, 
                             IN  UINT uiMessage, 
                             IN  WPARAM wParam, 
                             IN  LPARAM lParam)
{
    UINT    uiIcon;
    UINT    uiMouseMsg;

    uiIcon = (UINT) wParam;
    uiMouseMsg = (UINT) lParam;

    switch (uiMouseMsg)
    {
      case NIN_BALLOONTIMEOUT:
        ac_DestroyHnAcTrayUIWindow();
        break;
      case NIN_BALLOONHIDE:
        break;
      case NIN_BALLOONSHOW:
        break;
      case NIN_BALLOONUSERCLICK:
        HrRunHomeNetworkWizard(hwnd);
        ac_DestroyHnAcTrayUIWindow();
        break;
      case NIN_KEYSELECT:
        break;
      case NIN_SELECT:
        break;

    }

    return 0;
}


HRESULT HrRunHomeNetworkWizard(
    HWND                    hwndOwner)
{
    TraceFileFunc(ttidShellFolder);

    HRESULT   hr          = S_OK;
    WCHAR     szPath[MAX_PATH];
    
    hr = SHGetFolderPath(
                hwndOwner,
                CSIDL_SYSTEM,
                NULL,
                SHGFP_TYPE_CURRENT,
                szPath);

    if (SUCCEEDED(hr))
    {
        HINSTANCE hInst = ::ShellExecute(hwndOwner, NULL, c_szRunDll32, c_szRunHomeNetworkWizard, szPath, SW_SHOW );
        if (hInst <= reinterpret_cast<HINSTANCE>(32))
        {
            hr = HRESULT_FROM_WIN32(static_cast<DWORD>(reinterpret_cast<DWORD_PTR>(hInst)));
        }
    }
    
    TraceHr(ttidShellFolder, FAL, hr, FALSE, "HrRunHomeNetworkWizard");
    return hr;
}



LRESULT ac_DestroyHnAcTrayUIWindow()
{
    HRESULT hr = S_OK;
    NOTIFYICONDATA  nid;

    ZeroMemory (&nid, sizeof(nid));
    nid.cbSize              = sizeof(NOTIFYICONDATA);
    nid.hWnd                = g_hwndHnAcTray;
    nid.uID                 = 9998;
    nid.uFlags              = 0;
    nid.uCallbackMessage    = MYWM_NOTIFYICON;
    nid.hIcon               = 0;

    hr = HrShell_NotifyIcon(NIM_DELETE, &nid);

#if 0
    if (!SUCCEEDED(hr)){
        MessageBox( NULL,
        L"NotifyIcon DELETE failed",
        L"This is a test...",
        MB_OK | MB_ICONERROR);
    }
#endif

    EnterCriticalSection(&g_WindowCriticalSection);
    if (0 == --g_uWindowRefCount)
    {
        DestroyWindow(g_hwndHnAcTray);
    }
    LeaveCriticalSection(&g_WindowCriticalSection);

    return 0;
}

LRESULT ac_DeviceChange(IN  HWND hWnd, 
                        IN  UINT uMessage, 
                        IN  WPARAM wParam, 
                        IN  LPARAM lParam)
{

    // COM is initialized

    if(NULL != g_hDeviceChangeNotify)
    {
        HRESULT hr;
        if(DBT_DEVICEARRIVAL == wParam)
        {
            DEV_BROADCAST_DEVICEINTERFACE* pInfo = (DEV_BROADCAST_DEVICEINTERFACE*)lParam;

            if (DBT_DEVTYP_DEVICEINTERFACE == pInfo->dbcc_devicetype)
            {
                LPWSTR pszNetDeviceGuid = wcsrchr(pInfo->dbcc_name, L'\\'); // need a better way to do this, but shouldn't crash
                if(NULL != pszNetDeviceGuid)
                {
                    GUID* pDeviceGuid = reinterpret_cast<GUID*>(CoTaskMemAlloc(sizeof(GUID)));
                    if(NULL != pDeviceGuid)
                    {
                        hr = CLSIDFromString(pszNetDeviceGuid + 1, pDeviceGuid); // +1 is safe, at worst it will point to L'\0'
                        if(SUCCEEDED(hr))
                        {
                            // we have to move this off-uithread
                            if(0 == QueueUserWorkItem(ac_AsyncDeviceChange, pDeviceGuid, WT_EXECUTELONGFUNCTION))
                            {
                                hr = E_FAIL;
                            }
                        }

                        if(FAILED(hr))
                        {
                            CoTaskMemFree(pDeviceGuid);
                        }
                    }
                }
            }
        }
    }
    return TRUE;
}

HRESULT ac_Register(IN  HWND hWindow)
{

    HRESULT hr = S_OK;

#ifdef _WIN64
    // The autoconfig service is not available on IA64 (since the homenet wizard
    // isn't present)
    hr = E_FAIL;
#else
    //if the machine is a server SKU we don't create the autocfg stuff
    OSVERSIONINFOEXW verInfo = {0};
    ULONGLONG ConditionMask = 0;

    verInfo.dwOSVersionInfoSize = sizeof(verInfo);
    verInfo.wProductType = VER_NT_SERVER;

    VER_SET_CONDITION(ConditionMask, VER_PRODUCT_TYPE, VER_GREATER_EQUAL);

    if (TRUE == (VerifyVersionInfo(&verInfo, VER_PRODUCT_TYPE, ConditionMask)))
    {
        hr = E_FAIL;
    }
#endif

    if(SUCCEEDED(hr))
    {
        // if machine is joined to a domain don't create the autocfg stuff
        LPWSTR pszNameBuffer;
        NETSETUP_JOIN_STATUS BufferType;

        if (NERR_Success == NetGetJoinInformation(NULL, &pszNameBuffer, &BufferType))
        {
            NetApiBufferFree(pszNameBuffer);
            if(NetSetupDomainName == BufferType)
            {
                hr = E_FAIL;
            }
        }
        else
        {
            hr = E_FAIL;
        }
    }

    if(SUCCEEDED(hr))
    {

        DEV_BROADCAST_DEVICEINTERFACE PnpFilter;  // device change notifications for homenet auto config service
        ZeroMemory (&PnpFilter, sizeof(PnpFilter));

        PnpFilter.dbcc_size         = sizeof(PnpFilter);
        PnpFilter.dbcc_devicetype   = DBT_DEVTYP_DEVICEINTERFACE;
        PnpFilter.dbcc_classguid    = GUID_NDIS_LAN_CLASS;
        g_hDeviceChangeNotify = RegisterDeviceNotification( hWindow, &PnpFilter, DEVICE_NOTIFY_WINDOW_HANDLE);
        if(NULL != g_hDeviceChangeNotify)
        {
            InitializeCriticalSection(&g_WindowCriticalSection); // REVIEW: no memory exception
        }
    }
    return hr;
}

HRESULT ac_Unregister(IN  HWND hWindow)
{
    if(NULL != g_hDeviceChangeNotify)
    {
        UnregisterDeviceNotification(g_hDeviceChangeNotify);
        g_hDeviceChangeNotify = NULL;
        DeleteCriticalSection(&g_WindowCriticalSection);
    }

    return S_OK;
}

DWORD WINAPI ac_AsyncDeviceChange(IN TAKEOWNERSHIP LPVOID lpParam)
{
    HRESULT hr;
    GUID* pDeviceGuid = reinterpret_cast<GUID*>(lpParam);
    BOOL fUninitializeCOM = TRUE;

    hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED  | COINIT_DISABLE_OLE1DDE);
    if (RPC_E_CHANGED_MODE == hr)
    {
        fUninitializeCOM = FALSE;
        hr = S_OK;
    }

    if(SUCCEEDED(hr))
    {
        BOOL fPhysical;
        hr = IsAdapterPhysical(pDeviceGuid, &fPhysical);
        if ( (SUCCEEDED(hr)) && (TRUE == fPhysical) )
        {
            IHNetCfgMgr* pHomenetConfigManager;
            hr = HrCreateInstance(CLSID_HNetCfgMgr, CLSCTX_INPROC, &pHomenetConfigManager);
            if (SUCCEEDED(hr))
            {
                IHNetConnection* pHomenetConnection;
                hr = pHomenetConfigManager->GetIHNetConnectionForGuid(pDeviceGuid, TRUE, TRUE, &pHomenetConnection);
                if(SUCCEEDED(hr))
                {
                    BOOLEAN fShowBalloon;
                    hr = pHomenetConnection->ShowAutoconfigBalloon(&fShowBalloon);
                    if(SUCCEEDED(hr) && fShowBalloon)
                    {
                        ac_CreateHnAcTrayUIWindow();
                    }
                    ReleaseObj(pHomenetConnection);
                }
                ReleaseObj(pHomenetConfigManager);
            }
        }

        if(TRUE == fUninitializeCOM)
        {
            CoUninitialize();
        }
    }
    CoTaskMemFree(pDeviceGuid);
    return hr;
}

HRESULT IsAdapterPhysical(IN const GUID* pGuid, OUT BOOL* bPhysical)
{
    // com is initialized
    HRESULT hr;
    *bPhysical = FALSE;

    INetCfg* pNetConfig;
    hr = HrCreateInstance(CLSID_CNetCfg, CLSCTX_SERVER, &pNetConfig);
    if(SUCCEEDED(hr))
    {
        INetCfgLock* pNetConfigLock;
        hr = pNetConfig->QueryInterface(&pNetConfigLock);
        if(SUCCEEDED(hr))
        {
            hr = pNetConfig->Initialize(NULL);
            if(SUCCEEDED(hr))
            {
                GUID NetDevClass = GUID_DEVCLASS_NET;
                IEnumNetCfgComponent* pNetConfigComponentEnum;
                hr = pNetConfig->EnumComponents(&NetDevClass, &pNetConfigComponentEnum);
                if (SUCCEEDED(hr))
                {
                    INetCfgComponent* pNetConfigComponent;
                    BOOL fFound = FALSE;
                    ULONG ulFetched;
                    while (FALSE == fFound && S_OK == pNetConfigComponentEnum->Next(1, &pNetConfigComponent, &ulFetched))
                    {
                        Assert(1 == ulFetched);
                        GUID DeviceGuid;
                        hr = pNetConfigComponent->GetInstanceGuid( &DeviceGuid );
                        if (SUCCEEDED(hr) && (InlineIsEqualGUID(DeviceGuid,*pGuid)))
                        {
                            fFound = TRUE;

                            DWORD dwCharacteristics;
                            hr = pNetConfigComponent->GetCharacteristics(&dwCharacteristics);
                            if(SUCCEEDED(hr))
                            {
                                if(NCF_PHYSICAL & dwCharacteristics)
                                {
                                    *bPhysical = TRUE;
                                }
                            }
                        }
                        ReleaseObj(pNetConfigComponent);
                    }
                    ReleaseObj(pNetConfigComponentEnum);
                }
                pNetConfig->Uninitialize();
            }
            ReleaseObj(pNetConfigLock);
        }
        ReleaseObj(pNetConfig);
    }
    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\shell\dun\dunimport.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       D U N I M P O R T . C P P
//
//  Contents:   Functions that handles .DUN files for RAS connections
//              created in win9x
//
//  Notes:
//
//  Author:     TongL   15 March 1999
//
//----------------------------------------------------------------------------


#include "pch.h"
#pragma hdrstop

#include "dunimport.h"
#include "raserror.h"
#include "ncras.h"
#include "connutil.h"

#define RAS_MaxEntryName    256
#define MAXLONGLEN          11              // Maximum long string length
#define MAXIPADDRLEN        20
#define SIZE_ReadBuf        0x00008000      // 32K buffer size
#define NUM_IP_FIELDS       4
#define MIN_IP_VALUE        0
#define MAX_IP_VALUE        255
#define CH_DOT              L'.'

const WCHAR c_szPhoneBookPath[]     = L"\\Microsoft\\Network\\Connections\\Pbk\\rasphone.pbk";
const WCHAR c_szRASDT[]             = L"RASDT_";

const WCHAR c_szEntrySection[]      = L"Entry";
const WCHAR c_szEntryName[]         = L"Entry_Name";
const WCHAR c_szML[]                = L"Multilink";

const WCHAR c_szPhoneSection[] = L"Phone";
const WCHAR c_szDialAsIs[]     = L"Dial_As_Is";
const WCHAR c_szPhoneNumber[]  = L"Phone_Number";
const WCHAR c_szAreaCode[]     = L"Area_Code";
const WCHAR c_szCountryCode[]  = L"Country_Code";
const WCHAR c_szCountryID[]    = L"Country_ID";

const WCHAR c_szYes[]          = L"yes";
const WCHAR c_szNo[]           = L"no";

const WCHAR c_szDeviceSection[] = L"Device";
const WCHAR c_szDeviceType[]    = L"Type";
const WCHAR c_szModem[]         = L"modem";
const WCHAR c_szVpn[]           = L"vpn";
const WCHAR c_szDeviceName[]    = L"Name";

const WCHAR c_szServerSection[] = L"Server";
const WCHAR c_szServerType[]    = L"Type";
const WCHAR c_szPPP[]           = L"PPP";
const WCHAR c_szSLIP[]          = L"SLIP";
const WCHAR c_szRAS[]           = L"RAS";
const WCHAR c_szSWCompress[]    = L"SW_Compress";
const WCHAR c_szPWEncrypt[]     = L"PW_Encrypt";
const WCHAR c_szNetLogon[]      = L"Network_Logon";
const WCHAR c_szSWEncrypt[]     = L"SW_Encrypt";
const WCHAR c_szNetBEUI[]       = L"Negotiate_NetBEUI";
const WCHAR c_szIPX[]           = L"Negotiate_IPX/SPX";
const WCHAR c_szIP[]            = L"Negotiate_TCP/IP";

const WCHAR c_szIPSection[]     = L"TCP/IP";
const WCHAR c_szIPSpec[]        = L"Specify_IP_Address";
const WCHAR c_szIPAddress[]     = L"IP_address";
const WCHAR c_szServerSpec[]    = L"Specify_Server_Address";
const WCHAR c_szDNSAddress[]    = L"DNS_address";
const WCHAR c_szDNSAltAddress[] = L"DNS_Alt_address";
const WCHAR c_szWINSAddress[]   = L"WINS_address";
const WCHAR c_szWINSAltAddress[]= L"WINS_Alt_address";
const WCHAR c_szIPCompress[]    = L"IP_Header_Compress";
const WCHAR c_szRemoteGateway[] = L"Gateway_On_Remote";

//+---------------------------------------------------------------------------
//
//  Function:   HrInvokeDunFile_Internal
//
//  Purpose:    This is the entry point for DUN file invoking
//
//  Arguments:
//      szFileName [in] The .DUN file name
//
//  Returns:    S_OK if succeeded, failure code otherwise
//

HRESULT HrInvokeDunFile_Internal(IN LPWSTR szDunFile)
{
    HRESULT hr = S_OK;
    WCHAR   szEntryName[RAS_MaxEntryName+1];
    tstring strPhoneBook;

    hr = HrGetPhoneBookFile(strPhoneBook);
    if (SUCCEEDED(hr))
    {
        // Get the size of device configuration
        // This also validates an exported file
        //
        hr = HrGetEntryName(szDunFile, szEntryName, strPhoneBook);

        if ((HRESULT_FROM_WIN32(ERROR_CANNOT_OPEN_PHONEBOOK) == hr) ||
            (HRESULT_FROM_WIN32(ERROR_CANNOT_FIND_PHONEBOOK_ENTRY) == hr))
        {
            // create a new entry in the current user's phonebook
            hr = HrImportPhoneBookInfo(szDunFile, szEntryName, strPhoneBook);
        }

        if (SUCCEEDED(hr))
        {
            // get the GUID of this connection
            RASENTRY*   pRasEntry = NULL;
            hr = HrRasGetEntryProperties( strPhoneBook.c_str(),
                                          szEntryName,
                                          &pRasEntry,
                                          NULL);
            if(SUCCEEDED(hr))
            {
                // dial the connection
                hr = HrLaunchConnection(pRasEntry->guidId);
                MemFree(pRasEntry);
            }
        }
    }

    TraceError("HrInvokeDunFile_Internal", hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrGetPhoneBookFile
//
//  Purpose:    This function will return the proper path to the current user's
//              phonebook.
//
//  Arguments:
//      szFileName [in] The .DUN file name
//
//  Returns:    S_OK if succeeded, failure code otherwise
//
HRESULT HrGetPhoneBookFile(tstring& strPhoneBook)
{
    HRESULT hr = S_OK;
    strPhoneBook = c_szEmpty;

    LPITEMIDLIST    pidl;
    LPMALLOC        pMalloc;
    WCHAR           szDir[MAX_PATH+1];

    hr = SHGetSpecialFolderLocation(NULL,
                                    CSIDL_APPDATA,
                                    &pidl);
    if(SUCCEEDED(hr))
    {
        if (SHGetPathFromIDList(pidl, szDir))
        {
            strPhoneBook = szDir;
            TraceTag(ttidDun, "The path to the application directory is: %S", strPhoneBook.c_str());

            // release the memory by using the the shell's IMalloc ptr
            //
            if (SUCCEEDED(SHGetMalloc(&pMalloc)))
            {
                pMalloc->Free(pidl);
            }
        }
        else
        {
            hr = E_FAIL;
        }
    }

    if (SUCCEEDED(hr))
    {
        TraceTag(ttidDun, "The path to the phonebook is: %S", strPhoneBook.c_str());
        strPhoneBook += c_szPhoneBookPath;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrGetEntryName
//
//  Purpose:    This function validates and returns the entry name
//
//  Arguments:
//      szDunFile   [in] The .dun file created on win9x
//      szEntryName [in] The entry name for this connection
//
//  Returns:    S_OK if valid and is a new entry
//              S_FALSE if valid and but is an existing entry
//              otherwise, specific error
//
HRESULT HrGetEntryName(IN LPWSTR szFileName,
                       IN LPWSTR szEntryName,
                       tstring & strPhoneBook)
{
    HRESULT hr = S_OK;
    DWORD dwRet;

    // Get the entry name
    //
    dwRet = GetPrivateProfileString(c_szEntrySection,
                                    c_szEntryName,
                                    c_szEmpty,
                                    szEntryName,
                                    RAS_MaxEntryName+1,
                                    szFileName);
    // no entry name
    if (dwRet <= 0)
    {
        return HRESULT_FROM_WIN32(ERROR_CORRUPT_PHONEBOOK);
    }

    // Check if entry name already exists in phonebook
    //
    RASENTRY*   pRasEntry = NULL;
    hr = HrRasGetEntryProperties( strPhoneBook.c_str(),
                                  szEntryName,
                                  &pRasEntry,
                                  NULL);
    MemFree(pRasEntry);

    TraceErrorOptional("HrGetEntryName", hr,
                       ((HRESULT_FROM_WIN32(ERROR_CANNOT_OPEN_PHONEBOOK) == hr) ||
                        (HRESULT_FROM_WIN32(ERROR_CANNOT_FIND_PHONEBOOK_ENTRY) == hr)));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrImportPhoneBookInfo
//
//  Purpose:    This function checks if the RAS entry already exists in the
//              current user's phonebook
//
//  Arguments:
//      szEntryName [in] The entry name for this connection
//
//  Returns:    TRUE if already exists, FALSE otherwise
//
HRESULT HrImportPhoneBookInfo(  IN LPWSTR szDunFile,
                                IN LPWSTR szEntryName,
                                tstring & strPhoneBook)
{
    HRESULT hr = S_OK;
    RASENTRY RasEntry = {0};

    // Get the phone number
    //
    hr = HrImportPhoneInfo(&RasEntry, szDunFile);
    if (SUCCEEDED(hr))
    {
        // Get device name, type and config
        //
        ImportDeviceInfo(&RasEntry, szDunFile);

        // Get Server Type settings
        //
        ImportServerInfo(&RasEntry, szDunFile);

        // Get IP address
        //
        ImportIPInfo(&RasEntry, szDunFile);

        // Prompt for user name and password
        RasEntry.dwfOptions |= RASEO_PreviewUserPw;

        // Save it to the phonebook
        //
        DWORD dwRet;
        RasEntry.dwSize = sizeof(RASENTRY);
        RasEntry.dwType = RASET_Phone;
        dwRet = RasSetEntryProperties(strPhoneBook.c_str(),
                                      szEntryName,
                                      &RasEntry,
                                      sizeof(RASENTRY),
                                      NULL,
                                      0);

        hr = HRESULT_FROM_WIN32(dwRet);
        TraceError("RasSetEntryProperties", hr);
    }

    TraceError("HrImportPhoneBookInfo", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrImportPhoneInfo
//
//  Purpose:    This function imports the phone number
//
//  Arguments:
//      szFileName [in] The .DUN file name
//
//  Returns:
//
HRESULT HrImportPhoneInfo(RASENTRY * pRasEntry,
                          IN LPWSTR  szFileName)
{
    HRESULT hr = S_OK;

    // szLocalPhoneNumber
    if (GetPrivateProfileString(c_szPhoneSection,
                                c_szPhoneNumber,
                                c_szEmpty,
                                pRasEntry->szLocalPhoneNumber,
                                celems(pRasEntry->szLocalPhoneNumber),
                                szFileName) == 0)
    {
        hr = HRESULT_FROM_WIN32(ERROR_CORRUPT_PHONEBOOK);
    };

    if (SUCCEEDED(hr))
    {
        WCHAR   szYesNo[MAXLONGLEN+1];

        GetPrivateProfileString(c_szPhoneSection,
                                c_szDialAsIs,
                                c_szYes,
                                szYesNo,
                                celems(szYesNo),
                                szFileName);

        // Do we have to get country code and area code?
        //
        if (!lstrcmpiW(szYesNo, c_szNo))
        {
            // use country and area codes
            pRasEntry->dwfOptions |= RASEO_UseCountryAndAreaCodes;

            // If we cannot get the country ID or it is zero, default to dial as is
            //
            if ((pRasEntry->dwCountryID = GetPrivateProfileInt( c_szPhoneSection,
                                                                c_szCountryID,
                                                                0,
                                                                szFileName)) != 0)
            {
                pRasEntry->dwCountryCode = GetPrivateProfileInt(c_szPhoneSection,
                                                                c_szCountryCode,
                                                                1,
                                                                szFileName);
            }

            GetPrivateProfileString(c_szPhoneSection,
                                    c_szAreaCode,
                                    c_szEmpty,
                                    pRasEntry->szAreaCode,
                                    celems(pRasEntry->szAreaCode),
                                    szFileName);
        };
    }

    TraceError("HrImportPhoneInfo", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   ImportDeviceInfo
//
//  Purpose:    This function imports the device info
//
//  Arguments:
//      szFileName [in] The .DUN file name
//
//  Returns:
//
VOID ImportDeviceInfo(RASENTRY * pRasEntry,
                      IN LPWSTR  szFileName)
{
    WCHAR szDeviceType[RAS_MaxDeviceType+1];

    // Get the device type
    //
    if (GetPrivateProfileString(c_szDeviceSection,
                                c_szDeviceType,
                                c_szEmpty,
                                szDeviceType,
                                celems(szDeviceType),
                                szFileName))
    {
        if (!lstrcmpiW(szDeviceType, c_szModem))
        {
            lstrcpyW(pRasEntry->szDeviceType, RASDT_Modem);
        }
        else if (!lstrcmpiW(szDeviceType, c_szVpn))
        {
            lstrcpyW(pRasEntry->szDeviceType, RASDT_Vpn);
        }
        else
        {
            AssertSz(FALSE, "Unknown device type");
        }

        // Get the device name
        //
        GetPrivateProfileString( c_szDeviceSection,
                                 c_szDeviceName,
                                 c_szEmpty,
                                 pRasEntry->szDeviceName,
                                 celems(pRasEntry->szDeviceName),
                                 szFileName);
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   ImportServerInfo
//
//  Purpose:    This function imports the server type name and settings
//
//  Arguments:
//      szFileName [in] The .DUN file name
//
//  Returns:
//

VOID ImportServerInfo(RASENTRY * pRasEntry,
                      IN LPWSTR  szFileName)
{
    HRESULT hr = S_OK;

    WCHAR szValue[MAXLONGLEN];
    WCHAR szYesNo[MAXLONGLEN];
    DWORD dwRet;

    // Get the server type: PPP, SLIP or RAS
    //
    if (GetPrivateProfileString(c_szServerSection,
                                c_szServerType,
                                c_szEmpty,
                                szValue,
                                celems(szValue),
                                szFileName))
    {
        if (!lstrcmpiW(szValue, c_szPPP))
        {
            pRasEntry->dwFramingProtocol = RASFP_Ppp;
        }
        else if (!lstrcmpiW(szValue, c_szSLIP))
        {
            pRasEntry->dwFramingProtocol = RASFP_Slip;
        }
        else if (!lstrcmpiW(szValue, c_szRAS))
        {
            pRasEntry->dwFramingProtocol = RASFP_Ras;
        }
    }

    // SW_Compress
    //
    if (GetPrivateProfileString(c_szServerSection,
                                c_szSWCompress,
                                c_szEmpty,
                                szYesNo,
                                celems(szYesNo),
                                szFileName))
    {
        if (!lstrcmpiW(szYesNo, c_szYes))
        {
            pRasEntry->dwfOptions |= RASEO_SwCompression;
        };
    };

    // PW_Encrypt
    //
    if (GetPrivateProfileString(c_szServerSection,
                                c_szPWEncrypt,
                                c_szEmpty,
                                szYesNo,
                                celems(szYesNo),
                                szFileName))
    {
        if (!lstrcmpiW(szYesNo, c_szYes))
        {
            pRasEntry->dwfOptions |= RASEO_RequireEncryptedPw;
        };
    };

    // Network_Logon
    //
    if (GetPrivateProfileString(c_szServerSection,
                                c_szNetLogon,
                                c_szEmpty,
                                szYesNo,
                                celems(szYesNo),
                                szFileName))
    {
        if (!lstrcmpiW(szYesNo, c_szYes))
        {
            pRasEntry->dwfOptions |= RASEO_NetworkLogon;
        };
    };


    // SW_Encrypt
    //
    // set both RASEO_RequireMsEncryptedPw and RASEO_RequireDataEncryption
    // if SW_Encrypt is TRUE
    //
    if (GetPrivateProfileString(c_szServerSection,
                                c_szSWEncrypt,
                                c_szEmpty,
                                szYesNo,
                                celems(szYesNo),
                                szFileName))
    {
        if (!lstrcmpiW(szYesNo, c_szYes))
        {
            pRasEntry->dwfOptions |= RASEO_RequireMsEncryptedPw;
            pRasEntry->dwfOptions |= RASEO_RequireDataEncryption;
        };
    };

    // Get the network protocols to negotiate
    //
    if (GetPrivateProfileString(c_szServerSection,
                                c_szNetBEUI,
                                c_szEmpty,
                                szYesNo,
                                celems(szYesNo),
                                szFileName))
    {
        if (!lstrcmpiW(szYesNo, c_szYes))
        {
            pRasEntry->dwfNetProtocols |= RASNP_NetBEUI;
        };
    };

    if (GetPrivateProfileString(c_szServerSection,
                                c_szIPX,
                                c_szEmpty,
                                szYesNo,
                                celems(szYesNo),
                                szFileName))
    {
        if (!lstrcmpiW(szYesNo, c_szYes))
        {
            pRasEntry->dwfNetProtocols |= RASNP_Ipx;
        };
    };

    if (GetPrivateProfileString(c_szServerSection,
                                c_szIP,
                                c_szEmpty,
                                szYesNo,
                                celems(szYesNo),
                                szFileName))
    {
        if (!lstrcmpiW(szYesNo, c_szYes))
        {
            pRasEntry->dwfNetProtocols |= RASNP_Ip;
        };
    };
}


//+---------------------------------------------------------------------------
//
//  Function:   ImportIPInfo
//
//  Purpose:    This function imports the device info
//
//  Arguments:
//      szFileName [in] The .DUN file name
//
//  Returns:
//

VOID ImportIPInfo(RASENTRY * pRasEntry,
                  IN LPWSTR  szFileName)
{
    WCHAR   szIPAddr[MAXIPADDRLEN];
    WCHAR   szYesNo[MAXLONGLEN];

    // Import IP address information
    //
    if (GetPrivateProfileString(c_szIPSection,
                                c_szIPSpec,
                                c_szEmpty,
                                szYesNo,
                                celems(szYesNo),
                                szFileName))
    {
        if (!lstrcmpiW(szYesNo, c_szYes))
        {
            pRasEntry->dwfOptions |= RASEO_SpecificIpAddr;

            // Get the IP address
            //
            if (GetPrivateProfileString(c_szIPSection,
                                        c_szIPAddress,
                                        c_szEmpty,
                                        szIPAddr,
                                        celems(szIPAddr),
                                        szFileName))
            {
                SzToRasIpAddr(szIPAddr, &(pRasEntry->ipaddr));
            };
        }
    };

    // Import Server address information
    //
    if (GetPrivateProfileString(c_szIPSection,
                                c_szServerSpec,
                                c_szEmpty,
                                szYesNo,
                                celems(szYesNo),
                                szFileName))
    {
        if (!lstrcmpiW(szYesNo, c_szYes))
        {
            // The import file has server address specified, get the server address
            //
            pRasEntry->dwfOptions |= RASEO_SpecificNameServers;

            if (GetPrivateProfileString(c_szIPSection,
                                        c_szDNSAddress,
                                        c_szEmpty,
                                        szIPAddr,
                                        celems(szIPAddr),
                                        szFileName))
            {
                SzToRasIpAddr(szIPAddr, &(pRasEntry->ipaddrDns));
            };

            if (GetPrivateProfileString(c_szIPSection,
                                        c_szDNSAltAddress,
                                        c_szEmpty,
                                        szIPAddr,
                                        celems(szIPAddr),
                                        szFileName))
            {
                SzToRasIpAddr(szIPAddr, &(pRasEntry->ipaddrDnsAlt));
            };

            if (GetPrivateProfileString(c_szIPSection,
                                        c_szWINSAddress,
                                        c_szEmpty,
                                        szIPAddr,
                                        celems(szIPAddr),
                                        szFileName))
            {
                SzToRasIpAddr(szIPAddr, &(pRasEntry->ipaddrWins));
            };

            if (GetPrivateProfileString(c_szIPSection,
                                        c_szWINSAltAddress,
                                        c_szEmpty,
                                        szIPAddr,
                                        celems(szIPAddr),
                                        szFileName))
            {
                SzToRasIpAddr(szIPAddr, &(pRasEntry->ipaddrWinsAlt));
            };
        }
    };

    // Header compression and the gateway settings
    //
    if (GetPrivateProfileString(c_szIPSection,
                                c_szIPCompress,
                                c_szEmpty,
                                szYesNo,
                                celems(szYesNo),
                                szFileName))
    {
        if (!lstrcmpiW(szYesNo, c_szYes))
        {
            pRasEntry->dwfOptions |= RASEO_IpHeaderCompression;
        }
    };

    if (GetPrivateProfileString(c_szIPSection,
                                c_szRemoteGateway,
                                c_szEmpty,
                                szYesNo,
                                celems(szYesNo),
                                szFileName))
    {
        if (!lstrcmpiW(szYesNo, c_szYes))
        {
            pRasEntry->dwfOptions |= RASEO_RemoteDefaultGateway;
        }
    };
}

VOID SzToRasIpAddr(IN LPWSTR szIPAddress,
                   OUT RASIPADDR * pIpAddr)
{
    list<tstring *> listFields;
    ConvertStringToColString(szIPAddress,
                             CH_DOT,
                             listFields);

    list<tstring *>::const_iterator iter = listFields.begin();

    if (listFields.size() == NUM_IP_FIELDS)
    {
        // Go through each field and get the number value
        BYTE a = (BYTE)_wtol((*iter++)->c_str());
        BYTE b = (BYTE)_wtol((*iter++)->c_str());
        BYTE c = (BYTE)_wtol((*iter++)->c_str());
        BYTE d = (BYTE)_wtol((*iter++)->c_str());

        // validate the address
        if ((a >= MIN_IP_VALUE) && (a <= MAX_IP_VALUE) &&
            (b >= MIN_IP_VALUE) && (b <= MAX_IP_VALUE) &&
            (c >= MIN_IP_VALUE) && (c <= MAX_IP_VALUE) &&
            (d >= MIN_IP_VALUE) && (d <= MAX_IP_VALUE))
        {
            pIpAddr->a = a;
            pIpAddr->b = b;
            pIpAddr->c = c;
            pIpAddr->d = d;
        }
    }
    FreeCollectionAndItem(listFields);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\shell\folder\cfutils.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       C F U T I L S . H
//
//  Contents:   Various utility functions for the connections folder
//
//  Notes:
//
//  Author:     jeffspr   20 Jan 1998
//
//----------------------------------------------------------------------------

#pragma once

#ifndef _CFUTILS_H_
#define _CFUTILS_H_

VOID MapNCMToResourceId(
        IN  NETCON_MEDIATYPE    ncm,
        IN  DWORD               dwCharacteristics,
        OUT INT *               piStringRes) throw();

#define CONFOLD_MAX_STATUS_LENGTH 255

VOID MapNCSToComplexStatus(
        IN  NETCON_STATUS       ncs,
        IN  NETCON_MEDIATYPE    ncm,
        IN  NETCON_SUBMEDIATYPE ncsm,
        IN  DWORD dwCharacteristics,
        OUT LPWSTR              pszString,
        IN  DWORD               cString,
        IN  GUID                gdDevice) throw();

VOID MapNCSToStatusResourceId(
        IN  NETCON_STATUS       ncs,
        IN  NETCON_MEDIATYPE    ncm,
        IN  NETCON_SUBMEDIATYPE ncsm,
        IN  DWORD               dwCharacteristics,
        OUT INT *               piStringRes,
        IN  GUID                gdDevice) throw();

DWORD  MapRSSIToWirelessSignalStrength(IN  int iRSSI) throw();

PCWSTR PszGetRSSIString(IN  int iRSSI) throw();

PCWSTR PszGetOwnerStringFromCharacteristics(
        IN  PCWSTR        pszUserName,
        IN  DWORD         dwCharacteristics) throw();

BOOL IsMediaLocalType(
        IN  NETCON_MEDIATYPE    ncm) throw();

BOOL IsMediaRASType(
        IN  NETCON_MEDIATYPE    ncm) throw();

BOOL IsMediaSharedAccessHostType(
        IN  NETCON_MEDIATYPE    ncm) throw();

#endif // _CFUTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\shell\folder\cfutils.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       C F U T I L S . C P P
//
//  Contents:   Various utility functions for the connections folder
//
//  Notes:
//
//  Author:     jeffspr   20 Jan 1998
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "foldinc.h"    // Standard shell\folder includes
#include "nsres.h"      // Netshell strings
#include "cfutils.h"    // Connection folder utility functions
#include "wzcdlg.h"

VOID MapNCMToResourceId(
        IN  NETCON_MEDIATYPE    nct,
        IN  DWORD               dwCharacteristics,
        OUT INT *               piStringRes)
{
    Assert(piStringRes);

    if (dwCharacteristics & NCCF_BRANDED)
    {
        *piStringRes = IDS_CONFOLD_OBJECT_TYPE_CONMAN;
    }
    else
    if (dwCharacteristics & NCCF_INCOMING_ONLY)
    {
        *piStringRes = IDS_CONFOLD_OBJECT_TYPE_INBOUND;
    }
    else
    {
        switch(nct)
        {
            case NCM_NONE:
                Assert(dwCharacteristics & NCCF_INCOMING_ONLY);
                *piStringRes = IDS_CONFOLD_OBJECT_TYPE_INBOUND;
                break;

            case NCM_DIRECT:
                *piStringRes = IDS_CONFOLD_OBJECT_TYPE_DIRECT;
                break;

            case NCM_ISDN:
                *piStringRes = IDS_CONFOLD_OBJECT_TYPE_PHONE;
                break;

            case NCM_LAN:
                if(dwCharacteristics & NCCF_BRIDGED)
                {
                    *piStringRes = IDS_CONFOLD_OBJECT_TYPE_BRIDGE;
                }
                else
                {
                    *piStringRes = IDS_CONFOLD_OBJECT_TYPE_LAN;
                }
                break;

            case NCM_PHONE:
                *piStringRes = IDS_CONFOLD_OBJECT_TYPE_PHONE;
                break;

            case NCM_TUNNEL:
                *piStringRes = IDS_CONFOLD_OBJECT_TYPE_TUNNEL;
                break;

            case NCM_BRIDGE:
                *piStringRes = IDS_CONFOLD_OBJECT_TYPE_BRIDGE;
                break;

            case NCM_SHAREDACCESSHOST_LAN:
            case NCM_SHAREDACCESSHOST_RAS:
                *piStringRes = IDS_CONFOLD_OBJECT_TYPE_SHAREDACCESSHOST;
                break;
            
            case NCM_PPPOE:
                *piStringRes = IDS_CONFOLD_OBJECT_TYPE_PPPOE;
                break;

            default:
                AssertSz(FALSE, "Marfa -- I can't find my teef!  (You may ignore.)");
                *piStringRes = IDS_CONFOLD_OBJECT_TYPE_UNKNOWN;
                break;
        }
    }
}

VOID MapNCSToComplexStatus(
        IN  NETCON_STATUS       ncs,
        IN  NETCON_MEDIATYPE    ncm,
        IN  NETCON_SUBMEDIATYPE ncsm,
        IN  DWORD dwCharacteristics,
        OUT LPWSTR              pszString,
        IN  DWORD               cString,
        IN  GUID                gdDevice)
{
    Assert(cString >= CONFOLD_MAX_STATUS_LENGTH); 
    *pszString = L'\0';

    PCWSTR szArgs[4] = {L"", L"", L"", L""};
    DWORD dwArg = 0;

    WCHAR  szTmpString[MAX_PATH];
    
    INT iStringRes = 0;

    if ((NCM_NONE == ncm) && (dwCharacteristics & NCCF_INCOMING_ONLY) )
    {
        DWORD dwIncomingCount;
        HRESULT hr = g_ccl.HasActiveIncomingConnections(&dwIncomingCount);
        if (SUCCEEDED(hr) && dwIncomingCount)
        {
            if (1 == dwIncomingCount)
            {
                szArgs[dwArg++] = SzLoadIds(IDS_CONFOLD_STATUS_INCOMING_ONE);
            }
            else
            {
                if (DwFormatString(SzLoadIds(IDS_CONFOLD_STATUS_INCOMING_MULTI), szTmpString, MAX_PATH, dwIncomingCount))
                {
                    szArgs[dwArg++] = szTmpString;
                }
            }
        }
        else
        {
            szArgs[dwArg++] = SzLoadIds(IDS_CONFOLD_STATUS_INCOMING_NONE);
        }
    }
    else
    {
        MapNCSToStatusResourceId(ncs, ncm, ncsm, dwCharacteristics, &iStringRes, gdDevice);
    }

    if (iStringRes)
    {
        szArgs[dwArg++] = SzLoadIds(iStringRes);
    }
    
    if (ncs == NCS_DISCONNECTED || fIsConnectedStatus(ncs))
    {
        if(NCCF_BRIDGED & dwCharacteristics)
        {
            szArgs[dwArg++] = SzLoadIds(IDS_CONFOLD_STATUS_BRIDGED);
        }
        
        if(NCCF_SHARED & dwCharacteristics)
        {
            szArgs[dwArg++] = SzLoadIds(IDS_CONFOLD_STATUS_SHARED);
        }
        
        if(NCCF_FIREWALLED & dwCharacteristics)
        {
            szArgs[dwArg++] = SzLoadIds(IDS_CONFOLD_STATUS_FIREWALLED);
        }
    }

    if(0 == FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY, L"%1%2%3%4", 0, 0, pszString, cString, (va_list*) &szArgs))
    {
        *pszString = L'\0'; // on error return empty
    }

    if ( (NCS_CREDENTIALS_REQUIRED == ncs) || (NCS_AUTHENTICATING == ncs) )
    {
        BSTR szStatusText = NULL;
        HRESULT hrT = WZCQueryConnectionStatusText(&gdDevice, ncs, &szStatusText);
        if (S_OK == hrT)
        {
            wcsncpy(pszString, szStatusText, cString);
            SysFreeString(szStatusText);
        }
    }
}


VOID MapNCSToStatusResourceId(
        IN  NETCON_STATUS       ncs,
        IN  NETCON_MEDIATYPE    ncm,
        IN  NETCON_SUBMEDIATYPE ncsm,
        IN  DWORD dwCharacteristics,
        OUT INT *               piStringRes,
        IN  GUID                gdDevice)
{
    Assert(piStringRes);

    switch(ncs)
    {
        case NCS_DISCONNECTED:
            if (IsMediaLocalType(ncm) || NCM_SHAREDACCESSHOST_LAN == ncm)
            {
                *piStringRes = IDS_CONFOLD_STATUS_DISABLED;
            }
            else
            {
                *piStringRes = IDS_CONFOLD_STATUS_DISCONNECTED;
            }
            break;

        case NCS_CONNECTING:
            if (IsMediaLocalType(ncm) || NCM_SHAREDACCESSHOST_LAN == ncm)
                *piStringRes = IDS_CONFOLD_STATUS_ENABLING;
            else
                *piStringRes = IDS_CONFOLD_STATUS_CONNECTING;
            break;

        case NCS_CONNECTED:
            if (IsMediaLocalType(ncm) || NCM_SHAREDACCESSHOST_LAN == ncm)
            {
                *piStringRes = IDS_CONFOLD_STATUS_ENABLED;
            }
            else
            {
                *piStringRes = IDS_CONFOLD_STATUS_CONNECTED;
            }
            break;

        case NCS_DISCONNECTING:
            if (IsMediaLocalType(ncm) || NCM_SHAREDACCESSHOST_LAN == ncm)
                *piStringRes = IDS_CONFOLD_STATUS_DISABLING;
            else
                *piStringRes = IDS_CONFOLD_STATUS_DISCONNECTING;
            break;

        case NCS_HARDWARE_NOT_PRESENT:
            *piStringRes = IDS_CONFOLD_STATUS_HARDWARE_NOT_PRESENT;
            break;

        case NCS_HARDWARE_DISABLED:
            *piStringRes = IDS_CONFOLD_STATUS_HARDWARE_DISABLED;
            break;

        case NCS_HARDWARE_MALFUNCTION:
            *piStringRes = IDS_CONFOLD_STATUS_HARDWARE_MALFUNCTION;
            break;

        case NCS_MEDIA_DISCONNECTED:
            if ( (ncm == NCM_LAN) && (ncsm == NCSM_WIRELESS) )
            {
                *piStringRes = IDS_CONFOLD_STATUS_WIRELESS_DISCONNECTED;
            }
            else
            {
                *piStringRes = IDS_CONFOLD_STATUS_MEDIA_DISCONNECTED;
            }
            break;

        case NCS_INVALID_ADDRESS:
            *piStringRes = IDS_CONFOLD_STATUS_INVALID_ADDRESS;
            break;

        case NCS_AUTHENTICATION_FAILED:
            *piStringRes = IDS_CONFOLD_STATUS_AUTHENTICATION_FAILED;
            break;

        case NCS_AUTHENTICATING:
            *piStringRes = IDS_CONFOLD_STATUS_AUTHENTICATING;
            break;

        case NCS_AUTHENTICATION_SUCCEEDED:
            *piStringRes = IDS_CONFOLD_STATUS_AUTHENTICATION_SUCCEEDED;
            break;

        case NCS_CREDENTIALS_REQUIRED:
            *piStringRes = IDS_CONFOLD_STATUS_CREDENTIALS_REQUIRED;
            break;

        default:
            AssertSz(FALSE, "Unknown status in MapNCSToStatusResourceId");
            *piStringRes = IDS_CONFOLD_STATUS_DISCONNECTED;
            break;
    }
}

DWORD MapRSSIToWirelessSignalStrength(IN  int iRSSI) throw()
{
    if (iRSSI < -90)
    {
        return 0;
    }
    
    if (iRSSI < -81)
    {
        return 1;
    }
    
    if (iRSSI < -71)
    {
        return 2;
    }
    
    if (iRSSI < -67)
    {
        return 3;
    }

    if (iRSSI < -57)
    {
        return 4;
    }

    return 5;
}

PCWSTR PszGetRSSIString(IN  INT iRSSI) throw()
{
    DWORD wss = MapRSSIToWirelessSignalStrength(iRSSI);

    Assert(wss <= (IDS_802_11_LEVEL5 - IDS_802_11_LEVEL0) );

    return SzLoadIds(IDS_802_11_LEVEL0 + wss);
}

//+---------------------------------------------------------------------------
//
//  Function:   PszGetOwnerStringFromCharacteristics
//
//  Purpose:    Get the owner string from the CONFOLDENTRY. This will
//              return the string for "System" if the connection is for
//              all users, and will return the particular user if
//              appropriate
//
//  Arguments:
//      pszUserName       [in] The name for the currently logged in user
//      dwCharacteristics [in] The current characteristics of the connection
//
//  Returns:    The string for the user name
//
//  Author:     jeffspr   20 Jan 1998
//
//  Notes:
//
PCWSTR PszGetOwnerStringFromCharacteristics(IN  PCWSTR pszUserName, IN  DWORD dwCharacteristics) throw()

{
    PCWSTR  pszOwner    = NULL;
    BOOL    fAllUsers   = (dwCharacteristics & NCCF_ALL_USERS) > 0;

    // If they both have the same user type, then they're equal
    //
    if (fAllUsers)
    {
        pszOwner = SzLoadIds(IDS_CONFOLD_DETAILS_OWNER_SYSTEM);
    }
    else
    {
        pszOwner = pszUserName;
    }

    return pszOwner;
}

BOOL IsMediaLocalType(IN NETCON_MEDIATYPE ncm) throw()
{
    return (ncm == NCM_LAN || ncm == NCM_BRIDGE);
}

BOOL IsMediaRASType(IN NETCON_MEDIATYPE ncm) throw()
{
    return (ncm == NCM_DIRECT || ncm == NCM_ISDN || ncm == NCM_PHONE || ncm == NCM_TUNNEL || ncm == NCM_PPPOE);// REVIEW DIRECT correct?
}

BOOL IsMediaSharedAccessHostType(IN NETCON_MEDIATYPE ncm) throw()
{
    return (ncm == NCM_SHAREDACCESSHOST_LAN || ncm == NCM_SHAREDACCESSHOST_RAS);
}


//+---------------------------------------------------------------------------
//
//  Function Name:  ImageList_LoadImageAndMirror
//
//  Purpose:    This function creates an image list from the specified bitmap or icon resource.
//
//  Arguments:
//      hi          [in] Handle to the instance of an application or DLL that contains an image. 
//      lpbmp       [in] Long pointer to the image to load. 
//                       If the uFlags parameter includes LR_LOADFROMFILE, lpbmp is the address 
//                       of a null-terminated string that names the file containing the image to load. 
//
//                       If the hi parameter is non-NULL and LR_LOADFROMFILE is not specified, lpbmp is the 
//                          address of a null-terminated string that contains the name of the image resource in the hi module. 
//
//                       If hi is NULL and LR_LOADFROMFILE is not specified, the low-order word of this 
//                          parameter must be the identifier of an OEM image to load. To create this value, use the 
//                          MAKEINTRESOURCE macro with one of the OEM image identifiers defined in Winuser.h. 
//                       These identifiers have the following prefixes: 
//                          OBM_ for OEM bitmaps 
//                          OIC_ for OEM icons 
//
//      cx          [in] Width of each image. The height of each image and the initial number of images are inferred 
//                          by the dimensions of the specified resource. 
//      cGrow       [in] Number of images by which the image list can grow when the system needs to make room for new 
//                          images. This parameter represents the number of new images that the resized image list can contain. 
//      crMask      [in] Color used to generate a mask. Each pixel of this color in the specified bitmap or icon is changed to 
//                          black, and the corresponding bit in the mask is set to 1. If this parameter is the CLR_NONE value, 
//                          no mask is generated. If this parameter is the CLR_DEFAULT value, the color of the pixel at the 
//                          upper-left corner of the image is treated as the mask color. 
//      uType       [in] Flag that specifies the type of image to load. This parameter can be one of the following values: 
//                          IMAGE_BITMAP Loads a bitmap. 
//                          IMAGE_ICON Loads an icon. 
//      uFlags      [in] Unsupported; set to 0. 
//
//  Returns:    
//      The handle to the image list indicates success. NULL indicates failure. 
//
//  Author:     deonb   8 Feb 2001
//
//  Notes:
//      This is an exact duplication of the implementation of shell's ImageList_LoadImage function EXCEPT for the 
//      fact that we set ILC_MIRROR in order to create the second, mirrored image list which will be used
//      by RTL languages
//      
HIMAGELIST WINAPI ImageList_LoadImageAndMirror(
                            IN  HINSTANCE hi, 
                            IN  LPCTSTR lpbmp, 
                            IN  int cx, 
                            IN  int cGrow, 
                            IN  COLORREF crMask, 
                            IN  UINT uType, 
                            IN  UINT uFlags) throw()
{
    HBITMAP hbmImage;
    HIMAGELIST piml = NULL;
    BITMAP bm;
    int cy, cInitial;
    UINT flags;
	
    hbmImage = (HBITMAP)LoadImage(hi, lpbmp, uType, 0, 0, uFlags);
    if (hbmImage && (sizeof(bm) == GetObject(hbmImage, sizeof(bm), &bm)))
    {
        // If cx is not stated assume it is the same as cy.
        // ASSERT(cx);
        cy = bm.bmHeight;
		
        if (cx == 0)
            cx = cy;
		
        cInitial = bm.bmWidth / cx;
		
        flags = 0;
        if (crMask != CLR_NONE)
            flags |= ILC_MASK;
        if (bm.bmBits)
            flags |= (bm.bmBitsPixel & ILC_COLORMASK);

        flags |= ILC_MIRROR;

        piml = ImageList_Create(cx, cy, flags, cInitial, cGrow);
        if (piml)
        {
            int added;
			
            if (crMask == CLR_NONE)
                added = ImageList_Add(piml, hbmImage, NULL);
            else
                added = ImageList_AddMasked(piml, hbmImage, crMask);
			
            if (added < 0)
            {
                ImageList_Destroy(piml);
                piml = NULL;
            }
        }
    }
	
    if (hbmImage)
        DeleteObject(hbmImage);
	
    return reinterpret_cast<HIMAGELIST>(piml);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\shell\folder\confold.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       C O N F O L D . C P P
//
//  Contents:   CConnectionFolder base functions.
//
//  Notes:
//
//  Author:     jeffspr   18 Mar 1998
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "foldinc.h"    // Standard shell\folder includes
#include "webview.h"


// Map of replaceable items in connfold.rgs file
// this allows us to localize these items
//
struct _ATL_REGMAP_ENTRY g_FolderRegMap[] =
{
    { L"ConnectionsFolderName",    NULL },
    { L"ConnectionsFolderInfoTip", NULL },
    { NULL,                             NULL }
};


//+---------------------------------------------------------------------------
//
// Function:  CConnectionFolder::UpdateRegistry
//
// Purpose:   Apply registry data in connfold.rgs
//
// Arguments:
//    fRegister [in]  whether to register
//
//  Returns:  S_OK if success, otherwise an error code
//
// Author:    kumarp 15-September-98
//
// Notes:
//
HRESULT WINAPI CConnectionFolder::UpdateRegistry(IN BOOL fRegister)
{
    TraceFileFunc(ttidConFoldEntry);

    // fill-in localized strings for the two replaceable parameters
    g_FolderRegMap[0].szData = SzLoadIds(IDS_CONFOLD_NAME);
    g_FolderRegMap[1].szData = SzLoadIds(IDS_CONFOLD_INFOTIP);

    return _Module.UpdateRegistryFromResourceD(IDR_CONFOLD, fRegister,
                                               g_FolderRegMap);
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolder::CConnectionFolder
//
//  Purpose:    Constructor for the primary Folder object
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     jeffspr   18 Mar 1998
//
//  Notes:
//
CConnectionFolder::CConnectionFolder() throw()
{
    TraceFileFunc(ttidConFoldEntry);

    DWORD   dwLength = UNLEN+1;

    // By default, we want to enumerate all connection types
    //
    m_dwEnumerationType = CFCOPT_ENUMALL;
    m_hwndMain          = NULL;
    m_pWebView          = NULL;

    m_pWebView          = new CNCWebView(this);
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolder::~CConnectionFolder
//
//  Purpose:    Destructor for the primary folder object
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     jeffspr   18 Mar 1998
//
//  Notes:
//
CConnectionFolder::~CConnectionFolder() throw()
{
    Assert(m_pWebView);

    delete m_pWebView;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolder::PidlGetFolderRoot
//
//  Purpose:    Return the folder pidl. If NULL at this time, generate
//              the pidl for future usage.
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     jeffspr   10 Jan 1999
//
//  Notes:
//
PCONFOLDPIDLFOLDER& CConnectionFolder::PidlGetFolderRoot() throw()
{
    TraceFileFunc(ttidConFoldEntry);

    HRESULT hr  = S_OK;

    if (m_pidlFolderRoot.empty())
    {
        // Ignore this hr. For debugging only
        //
        hr = HrGetConnectionsFolderPidl(m_pidlFolderRoot);
    }

    return m_pidlFolderRoot;
}


//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolder::pszGetUserName
//
//  Purpose:    Return the user name of the Connectoid.
//              Currently makes the assumption that any active user can only
//              read either System Wide or his own Connectoids.
//              Probably should cache the user name, however this component
//              is MTA and the UserName is per thread.
//              I don't want to use up a TLS just for this.
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     deonb   19 June 1999
//
//  Notes:
//
PCWSTR  CConnectionFolder::pszGetUserName() throw()
{
    TraceFileFunc(ttidConFoldEntry);

    DWORD dwSize = UNLEN+1;

    if (GetUserName(m_szUserName, &dwSize))
    {
        return m_szUserName;
    }
    else
    {
        return NULL;
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\shell\folder\connlist.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       C O N N L I S T . C P P
//
//  Contents:   Connection list class -- subclass of the stl list<> code.
//
//  Notes:
//
//  Author:     jeffspr   19 Feb 1998
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "foldinc.h"    // Standard shell\folder includes
#include "ncnetcon.h"
#include "ctrayui.h"
#include "traymsgs.h"
#include "ncerror.h"
#include "notify.h"
#include "ncperms.h"
#include "cmdtable.h"
#include "foldres.h"
#include "winuserp.h"

extern HWND g_hwndTray;

const DWORD c_dwInvalidCookie = -1;
DWORD  CConnectionList::m_dwNotifyThread = NULL;
HANDLE CConnectionList::m_hNotifyThread = NULL;

// use this for debugging. We don't usually want more than one advise, so for
// now I'm going to assert on this being false on advise creation
//
DWORD   g_dwAdvisesActive   = 0;

CTrayIconData::CTrayIconData(const CTrayIconData& TrayIconData) throw()
{
    m_uiTrayIconId = TrayIconData.m_uiTrayIconId;
    m_ncs          = TrayIconData.m_ncs;
    m_pcpStat      = TrayIconData.m_pcpStat;
    m_pnseStats    = TrayIconData.m_pnseStats;
    m_pccts        = TrayIconData.m_pccts;

    m_dwLastBalloonMessage = TrayIconData.m_dwLastBalloonMessage;
    m_pfnBalloonFunction   = TrayIconData.m_pfnBalloonFunction;
    m_szCookie             = SysAllocStringByteLen(reinterpret_cast<LPCSTR>(TrayIconData.m_szCookie), SysStringByteLen(TrayIconData.m_szCookie));
    
    DWORD dwpcpStatCount = 0;
    DWORD dwpnseStats = 0;
    DWORD dwpccts = 0;

    if (m_pcpStat)
    {
        dwpcpStatCount = m_pcpStat->AddRef();
    }
    
    if (m_pnseStats)
    {
        dwpnseStats = m_pnseStats->AddRef();
    }
    
    if (m_pccts)
    {
        dwpccts = m_pccts->AddRef();
    }

    AssertSz(dwpcpStatCount < 100, "Possible IConnectionPoint reference leak");
    AssertSz(dwpnseStats < 100, "Possible INetStatisticsEngine*  reference leak");
    AssertSz(dwpccts < 100, "Possible CConnectionTrayStats*  reference leak");

    TraceTag(ttidConnectionList, "CTrayIconData::CTrayIconData(CTrayIconData&) [%d %d %d]", dwpcpStatCount, dwpnseStats, dwpccts);
}

CTrayIconData::CTrayIconData(IN  UINT uiTrayIconId, 
                             IN  NETCON_STATUS ncs, 
                             IN  IConnectionPoint * pcpStat, 
                             IN  INetStatisticsEngine * pnseStats, 
                             IN  CConnectionTrayStats * pccts) throw()
{
    m_uiTrayIconId = uiTrayIconId;
    m_ncs = ncs;
    m_pcpStat= pcpStat;
    m_pnseStats = pnseStats;
    m_pccts = pccts;
    m_szCookie = NULL;

    m_dwLastBalloonMessage = BALLOON_NOTHING;
    m_pfnBalloonFunction   = NULL;

    DWORD dwpcpStatCount = 0;
    DWORD dwpnseStats = 0;
    DWORD dwpccts = 0;

    if (m_pcpStat)
    {
        dwpcpStatCount = m_pcpStat->AddRef();
    }

    if (m_pnseStats)
    {
        dwpnseStats = m_pnseStats->AddRef();
    }

    if (m_pccts)
    {
        dwpccts = m_pccts->AddRef();
    }
    
    SetBalloonInfo(0, NULL, NULL);

    AssertSz(dwpcpStatCount < 100, "Possible IConnectionPoint reference leak");
    AssertSz(dwpnseStats < 100, "Possible INetStatisticsEngine*  reference leak");
    AssertSz(dwpccts < 100, "Possible CConnectionTrayStats*  reference leak");

#ifdef DBG
    if (FIsDebugFlagSet(dfidTraceFileFunc))
    {
        TraceTag(ttidConnectionList, "CTrayIconData::CTrayIconData(UINT, BOOL...) [%d %d %d]", dwpcpStatCount, dwpnseStats, dwpccts);
    }
#endif
}

CTrayIconData::~CTrayIconData() throw()
{
    DWORD dwpcpStatCount = 0;
    DWORD dwpnseStats = 0;
    DWORD dwpccts = 0;

    if (m_pccts)
    {
        dwpccts = m_pccts->Release();
    }
    if (m_pcpStat)
    {
        dwpcpStatCount = m_pcpStat->Release();
    }
    if (m_pnseStats)
    {
        dwpnseStats = m_pnseStats->Release();
    }
    if (m_szCookie)
    {
        SysFreeString(m_szCookie);
    }

    AssertSz(dwpcpStatCount < 100, "Possible IConnectionPoint reference leak");
    AssertSz(dwpnseStats < 100, "Possible INetStatisticsEngine*  reference leak");
    AssertSz(dwpccts < 100, "Possible CConnectionTrayStats*  reference leak");

#ifdef DBG
    if (FIsDebugFlagSet(dfidTraceFileFunc))
    {
        TraceTag(ttidConnectionList, "CTrayIconData::~CTrayIconData [%d %d %d]", dwpcpStatCount, dwpnseStats, dwpccts);
    }
#endif
}

HRESULT CTrayIconData::SetBalloonInfo(IN  DWORD dwLastBalloonMessage, 
                                      IN  BSTR szCookie, 
                                      IN  FNBALLOONCLICK* pfnBalloonFunction)
{
    m_dwLastBalloonMessage = dwLastBalloonMessage;
    m_pfnBalloonFunction   = pfnBalloonFunction;
    if (szCookie)
    {
        m_szCookie = SysAllocStringByteLen(reinterpret_cast<LPCSTR>(szCookie), SysStringByteLen(szCookie));;
    }
    else
    {
        m_szCookie = NULL;
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionList::Initialize
//
//  Purpose:    Initialize class members.
//
//  Arguments:
//      fTieToTray [in] Use this list for tray support. This should be passed
//                      in as FALSE when the list is being used for temporary
//                      work.
//
//  Returns:
//
//  Author:     jeffspr   17 Nov 1998
//
//  Notes:
//
VOID CConnectionList::Initialize(IN  BOOL fTieToTray, IN  BOOL fAdviseOnThis) throw()
{
    TraceFileFunc(ttidConnectionList);

    m_pcclc             = NULL;
    m_fPopulated        = false;
    m_dwAdviseCookie    = c_dwInvalidCookie;
    m_fTiedToTray       = fTieToTray;
    m_fAdviseOnThis     = fAdviseOnThis;

#if DBG
    m_dwCritSecRef      = 0;
    m_dwWriteLockRef    = 0;
#endif

    
    InitializeCriticalSection(&m_csMain);
    InitializeCriticalSection(&m_csWriteLock);
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionList::Uninitialize
//
//  Purpose:    Flush the connection list and do all cleanup
//              of tray icons and interfaces and such.
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     jeffspr   24 Sep 1998
//
//  Notes: Don't make COM calls from this function if fFinalUninitialize is true. It's called from DllMain.
//  No need for EnsureConPointNotifyRemoved() as it's removed from 
//  CConnectionTray::HrHandleTrayClose
VOID CConnectionList::Uninitialize(IN BOOL fFinalUninitialize) throw()
{    
    TraceFileFunc(ttidConnectionList);

    if (fFinalUninitialize)
    {
        Assert(FImplies(m_dwNotifyThread, m_hNotifyThread));
        if (m_dwNotifyThread && m_hNotifyThread)
        {
            PostThreadMessage(m_dwNotifyThread, WM_QUIT, NULL, NULL);
            if (WAIT_TIMEOUT == WaitForSingleObject(m_hNotifyThread, 30000))
            {
                TraceTag(ttidError, "Timeout waiting for Notify Thread to quit");
            }
        }
    }

    
    FlushConnectionList();

    delete m_pcclc;
    m_pcclc = NULL;

    Assert(m_dwCritSecRef == 0);
    Assert(m_dwWriteLockRef == 0);
    DeleteCriticalSection(&m_csWriteLock);
    DeleteCriticalSection(&m_csMain);
}

HRESULT ConnListEntry::SetTrayIconData(IN const CTrayIconData& TrayIconData)
{
    TraceFileFunc(ttidConnectionList);

    if (m_pTrayIconData)
    {
        delete m_pTrayIconData;
        m_pTrayIconData = NULL;
    }

    m_pTrayIconData = new CTrayIconData(TrayIconData);
    if (!m_pTrayIconData)
    {
        return E_OUTOFMEMORY;
    }
        
    return S_OK;
}

CONST_IFSTRICT CTrayIconData* ConnListEntry::GetTrayIconData() const 
{
    return m_pTrayIconData;
}

BOOL ConnListEntry::HasTrayIconData() const throw()
{
    return (m_pTrayIconData != NULL);
}


HRESULT ConnListEntry::DeleteTrayIconData()
{
    if (m_pTrayIconData)
    {
        delete m_pTrayIconData;
        m_pTrayIconData = NULL;
    }    
    return S_OK;
}

//
// Is this the main shell process? (eg the one that owns the desktop window)
//
// NOTE: if the desktop window has not been created, we assume that this is NOT the
//       main shell process and return FALSE;
//
STDAPI_(BOOL) IsMainShellProcess() throw()
{
    static int s_fIsMainShellProcess = -1;

    if (s_fIsMainShellProcess == -1)
    {
        s_fIsMainShellProcess = FALSE;

        HWND hwndDesktop = GetShellWindow();
        if (hwndDesktop)
        {
            DWORD dwPid;
            if (GetWindowThreadProcessId(hwndDesktop, &dwPid))
            {
                if (GetCurrentProcessId() == dwPid)
                {
                    s_fIsMainShellProcess  = TRUE;
                }
            }
        }
        else
        {
            TraceTag(ttidError, "IsMainShellProcess: hwndDesktop does not exist, assuming we are NOT the main shell process");
            return FALSE;
        }

        if (s_fIsMainShellProcess)
        {
            TraceTag(ttidNotifySink, "We are running inside the main explorer process.");
        }
        else
        {
            TraceTag(ttidNotifySink, "We are NOT running inside the main explorer process.");
        }
    }

    return s_fIsMainShellProcess ? TRUE : FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionList::NotifyThread
//
//  Purpose:    Create a thread to listen for notifications from netman
//
//  Arguments:
//      pConnectionList [out]     The CConnectionList to be updated by netman events
//
//  Returns:
//
//  Author:     deonb 2001
//
//  Notes: This thread is used in the case where we are running the Connection
//         folder outside of the context of explorer.exe. In that case we don't
//         have the explorer tray icon thread to listen to events from netman.
//
DWORD CConnectionList::NotifyThread(IN OUT LPVOID pConnectionList) throw()
{
    CConnectionList *pThis = reinterpret_cast<CConnectionList *>(pConnectionList);

    HRESULT hr = CoInitializeEx(NULL, COINIT_DISABLE_OLE1DDE | COINIT_APARTMENTTHREADED);
    if (SUCCEEDED(hr))
    {
        pThis->EnsureConPointNotifyAdded();

        MSG msg;
        while (GetMessage (&msg, 0, 0, 0))
        {
            DispatchMessage (&msg);
        }
    
        // Don't call EnsureConPointNotifyRemoved() since this function is called from DllMain.
        // We'll have to rely on Netman to detect by itself that this thread has died.
        CoUninitialize();
    }

    return SUCCEEDED(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionList::HrRetrieveConManEntries
//
//  Purpose:    Get the connection data from the enumerator, and build the
//              connection list and tray
//
//  Arguments:
//      papidlOut [out]     Retrieved entry pidl vector
//
//  Returns:
//
//  Author:     jeffspr   24 Sep 1998
//
//  Notes:
//
HRESULT CConnectionList::HrRetrieveConManEntries(
    OUT PCONFOLDPIDLVEC& apidlOut)
{
    TraceFileFunc(ttidConnectionList);

    HRESULT         hr              = S_OK;
    DWORD           cpidl           = 0;

    NETCFG_TRY

        ConnListEntry   cle;
        BOOL            fLockAcquired   = FALSE;

         // If we haven't yet populated our list, do so.
        //
        if (!m_fPopulated)
        {
            static LONG lSyncAquired = 0;
            if (!InterlockedExchange(&lSyncAquired, 1))
            {
                if (!IsMainShellProcess() && (!g_dwAdvisesActive) && (m_fAdviseOnThis) )
                {
                    m_hNotifyThread = CreateThread(NULL, STACK_SIZE_SMALL, NotifyThread, this, 0, &m_dwNotifyThread);
                    if (!m_hNotifyThread)
                    {
                        TraceTag(ttidError, "Could not create sink thread");
                    }
                }
            }
        
            hr = HrRefreshConManEntries();
            if (FAILED(hr))
            {
                goto Exit;
            }

            m_fPopulated = true;
        }
      
        if (m_pcclc)
        {
            AcquireLock();
            fLockAcquired = TRUE;

            // Get the count of the elements
            //
            cpidl = m_pcclc->size();

            // Allocate an array to store the pidls that we'll retrieve
            //
            ConnListCore::const_iterator  clcIter;
            DWORD                   dwLoop  = 0;

            // Iterate through the list and build the ppidl array
            //
            for (clcIter = m_pcclc->begin();
                 clcIter != m_pcclc->end();
                 clcIter++)
            {
                Assert(!clcIter->second.empty());

                cle = clcIter->second;

                Assert(!cle.ccfe.empty() );
                if (!cle.ccfe.empty())
                {
                    // Convert the confoldentry to a pidl, so we can
                    // retrieve the size
                    //
                    PCONFOLDPIDL pConFoldPidlTmp;
                    hr = cle.ccfe.ConvertToPidl(pConFoldPidlTmp);
                    if (FAILED(hr))
                    {
                        goto Exit;
                    }
                    apidlOut.push_back(pConFoldPidlTmp);
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }

            // Do NOT do FlushTrayPosts here. It doesn't work, and it causes a deadlock.
        }

Exit:
        if (fLockAcquired)
        {
            ReleaseLock();
        }

    NETCFG_CATCH(hr)

    TraceHr(ttidError, FAL, hr, FALSE, "CConnectionList::HrRetrieveConManEntries");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionList::HrRemove
//
//  Purpose:    Remove a connection from the list based on a pccfe
//
//  Arguments:
//      pccfe [in]  Connection data (so we can find)
//      pfFlushPosts [out] Whether we should flush the tray icons
//
//  Returns:
//
//  Author:     jeffspr   24 Sep 1998
//
//  Notes:
//
HRESULT CConnectionList::HrRemove(IN const CONFOLDENTRY& ccfe, OUT BOOL * pfFlushPosts)
{
    TraceFileFunc(ttidConnectionList);

    HRESULT                 hr      = S_OK;

    AcquireLock();
    ConnListCore::iterator  clcIter;

    if (m_pcclc)
    {
        // Iterate through the list looking for the entry with the
        // matching guid.
        //
        for (clcIter = m_pcclc->begin();
             clcIter != m_pcclc->end();
             clcIter++)
        {
            ConnListEntry& cleIter    = clcIter->second;

            if (InlineIsEqualGUID(cleIter.ccfe.GetGuidID(), ccfe.GetGuidID()))
            {
                // Remove the entry, then break 'cause the ++
                // in the for loop would explode if we didn't
                //
                hr = HrRemoveByIter(clcIter, pfFlushPosts);
                break;
            }
        }
    }

    ReleaseLock();

    TraceHr(ttidError, FAL, hr, FALSE, "CConnectionList::HrRemove");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionList::HrRemoveByIter
//
//  Purpose:    Remove a list entry, using the list entry itself as
//              the search element.
//
//  Arguments:
//
//  Returns:
//
//  Author:     jeffspr   10 Apr 1998
//
//  Notes:
//
HRESULT CConnectionList::HrRemoveByIter(IN  ConnListCore::iterator clcIter, 
                                        OUT BOOL *pfFlushTrayPosts)
{
    TraceFileFunc(ttidConnectionList);
    
    HRESULT         hr    = S_OK;
    ConnListEntry& cle    = clcIter->second;
    Assert(!cle.empty());

    AcquireLock();

    // If there's a tray item for this connection
    //
    if (cle.HasTrayIconData() )
    {
        // Since we're deleting the entry, remove the tray
        // icon associated with this entry. Ignore the return
        //
        if (m_fTiedToTray && g_pCTrayUI)
        {
            // Set the flag to inform the caller that they will need to flush this stuff.
            //
            if (pfFlushTrayPosts)
            {
                *pfFlushTrayPosts = TRUE;
            }

            CTrayIconData * pTrayIconData = new CTrayIconData(*cle.GetTrayIconData());
            cle.DeleteTrayIconData();
        
            TraceTag(ttidSystray, "HrRemoveByIter: Removing tray icon for %S", cle.ccfe.GetName());
            PostMessage(g_hwndTray, MYWM_REMOVETRAYICON, reinterpret_cast<WPARAM>(pTrayIconData), (LPARAM) 0);
        }
    }

    // release the branding info
    //
    // icon path
    CON_BRANDING_INFO * pcbi = cle.pcbi;
    if (pcbi)
    {
        CoTaskMemFree(pcbi->szwLargeIconPath);
        CoTaskMemFree(pcbi->szwTrayIconPath);
        CoTaskMemFree(pcbi);
    }

    // menu items
    CON_TRAY_MENU_DATA * pMenuData = cle.pctmd;
    if (pMenuData)
    {
        DWORD dwCount = pMenuData->dwCount;
        CON_TRAY_MENU_ENTRY * pMenuEntry = pMenuData->pctme;

        while (dwCount)
        {
            Assert(pMenuEntry);

            CoTaskMemFree(pMenuEntry->szwMenuText);
            CoTaskMemFree(pMenuEntry->szwMenuCmdLine);
            CoTaskMemFree(pMenuEntry->szwMenuParams);

            dwCount--;
            pMenuEntry++;
        }

        CoTaskMemFree(pMenuData->pctme);
        CoTaskMemFree(pMenuData);
    }

    // Remove the actual element from the list
    //
    Assert(m_pcclc);
    m_pcclc->erase(clcIter);

    ReleaseLock();

    TraceHr(ttidError, FAL, hr, FALSE, "CConnectionList::HrRemoveByIter");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionList::FlushTrayIcons
//
//  Purpose:    Remove all of our icons from the tray, since we're about
//              to either flush the connection list or turn off the tray.
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     jeffspr   24 Sep 1998
//
//  Notes:
//
VOID CConnectionList::FlushTrayIcons() throw()
{
    TraceFileFunc(ttidConnectionList);
    
    AssertSz(m_fTiedToTray, "This connection list not allowed to modify tray");

    if (!g_pCTrayUI || !m_fTiedToTray)
    {
        return;
    }

    AcquireLock();

    ConnListCore::iterator  clcIter;
    ConnListCore::const_iterator  clcNext;
    BOOL                    fFlushPosts = FALSE;

    if (m_pcclc)
    {
        // Iterate through the list and build the ppidl array
        //
        for (clcIter = m_pcclc->begin();
             clcIter != m_pcclc->end();
             clcIter = clcNext)
        {
            Assert(!clcIter->second.empty());

            clcNext = clcIter;
            clcNext++;

            ConnListEntry& cle = clcIter->second; // using non-const reference for renaming only (calling cle.DeleteTrayIconData).

            if ( cle.HasTrayIconData() )
            {
                fFlushPosts = TRUE;

                CTrayIconData *pTrayIconData = new CTrayIconData(*cle.GetTrayIconData());
                cle.DeleteTrayIconData();

                TraceTag(ttidSystray, "FlushTrayIcons: Removing tray icon for %S", cle.ccfe.GetName());
                PostMessage(g_hwndTray, MYWM_REMOVETRAYICON, (WPARAM) pTrayIconData , (LPARAM) 0);
            }
        }
    }

    g_pCTrayUI->ResetIconCount();

    ReleaseLock();

    if (fFlushPosts)
    {
        FlushTrayPosts(g_hwndTray);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionList::EnsureIconsPresent
//
//  Purpose:    Given an existing list, ensure that all of the tray
//              icons that should be shown are being shown. This needs to
//              be called when the tray was turned on AFTER enumeration.
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     jeffspr   24 Sep 1998
//
//  Notes:
//
VOID CConnectionList::EnsureIconsPresent() throw()
{
    TraceFileFunc(ttidConnectionList);
    
    Assert(m_fTiedToTray);

    if (!g_pCTrayUI || !m_fTiedToTray)
    {
        return;
    }

    AcquireLock();

    ConnListCore::iterator  clcIter;
    ConnListCore::const_iterator  clcNext;

    if (m_pcclc)
    {
        // Iterate through the list and build the ppidl array
        //
        for (clcIter = m_pcclc->begin();
             clcIter != m_pcclc->end();
             clcIter = clcNext)
        {
            Assert(!clcIter->second.empty());

            clcNext = clcIter;
            clcNext++;

            const ConnListEntry& cle = clcIter->second;

            if ((!cle.HasTrayIconData() ) &&
                 cle.ccfe.FShouldHaveTrayIconDisplayed())
            {
                CONFOLDENTRY pccfeDup;

                HRESULT hr = pccfeDup.HrDupFolderEntry(cle.ccfe);
                if (SUCCEEDED(hr))
                {
                    TraceTag(ttidSystray, "EnsureIconsPresent: Adding tray icon for %S", cle.ccfe.GetName());
                    PostMessage(g_hwndTray, MYWM_ADDTRAYICON, (WPARAM) pccfeDup.TearOffItemIdList(), (LPARAM) 0);
                }
            }
        }
    }

    ReleaseLock();
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionList::FlushConnectionList
//
//  Purpose:    Remove all entries from the connection list
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     jeffspr   24 Sep 1998
//
//  Notes:
//
VOID CConnectionList::FlushConnectionList() throw()
{
    TraceFileFunc(ttidConnectionList);
    
    AcquireLock();

    ConnListCore::const_iterator  clcIter;
    ConnListCore::const_iterator  clcNext;
    BOOL                    fFlushTrayPosts = FALSE;

    TraceTag(ttidConnectionList, "Flushing the connection list");
    TraceStack(ttidConnectionList);

    if (m_pcclc)
    {
        // Iterate through the list and build the ppidl array
        //
        for (clcIter = m_pcclc->begin();
             clcIter != m_pcclc->end();
             clcIter = clcNext)
        {
            Assert(!clcIter->second.empty());

            clcNext = clcIter;
            clcNext++;

            (VOID) HrRemoveByIter(clcIter, &fFlushTrayPosts);
        }

        if (m_pcclc->size() != 0)
        {
            AssertSz(FALSE, "List not clear after deleting all elements in FlushConnectionList");

            // Flush the list itself
            //
            m_pcclc->clear();
        }
    }

    // Reset the icon's icon ID count, as we've cleared out all icons
    //
    if (g_pCTrayUI && m_fTiedToTray)
    {
        g_pCTrayUI->ResetIconCount();
    }

    m_fPopulated = FALSE;

    ReleaseLock();

    // If we need to do the SendMessage to flush any PostMessages to the tray
    // do so
    //
    if (g_pCTrayUI && g_hwndTray && fFlushTrayPosts)
    {
        FlushTrayPosts(g_hwndTray);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionList::HrRetrieveConManEntries
//
//  Purpose:    Retrieve the connection entries from the connection manager
//
//  Arguments:
//      None
//
//  Returns:
//
//  Author:     jeffspr   20 Feb 1998
//
//  Notes:
//
HRESULT CConnectionList::HrRefreshConManEntries()
{
    TraceFileFunc(ttidConnectionList);
    
    HRESULT                 hr          = S_OK;
    CONFOLDENTRY           ccfe;

    PCONFOLDPIDL           pidlMNCWizard;
    PCONFOLDPIDL           pidlHNWWizard;

    CComPtr<INetConnectionManager2> pconMan2;

    // Create an instance of the connection manager
    //
    hr = HrCreateInstance(
        CLSID_ConnectionManager2,
        CLSCTX_LOCAL_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
        &pconMan2);

    TraceHr(ttidError, FAL, hr, FALSE, "HrCreateInstance");

    if (SUCCEEDED(hr))
    {
        HRESULT hrDebug = S_OK;
        HRESULT hrProp = S_OK;

        // Iterate through the connections
        //
        SAFEARRAY* psaConnectionProperties;
        HRESULT hrEnumConnections = pconMan2->EnumConnectionProperties(&psaConnectionProperties);
        if (SUCCEEDED(hrEnumConnections))
        {
            FlushConnectionList();
            AcquireWriteLock();

            AcquireLock();
            if (m_pcclc)
            {
                m_pcclc->clear(); // Make sure somebody else didn't come in in between the two calls and added stuff to the list
            }
            ReleaseLock();

            // Add the wizards to the beginning of the list
            //
            PCONFOLDPIDLVEC pcfpvEmpty;
            NCCS_STATE nccs = NCCS_ENABLED;
            DWORD dwResourceId;

            // Add the Make New Connection Wizard, regardless if there were any connections or not
            // Check for permissions etc.
            HrGetCommandState(pcfpvEmpty, CMIDM_NEW_CONNECTION, nccs, &dwResourceId, 0xffffffff, NB_FLAG_ON_TOPMENU);
            if (NCCS_ENABLED == nccs)
            {
                hr = HrCreateConFoldPidl(WIZARD_MNC, NULL, pidlMNCWizard);
                if (SUCCEEDED(hr))
                {
                    // Convert the pidl to a ConFoldEntry
                    //
                    hr = pidlMNCWizard.ConvertToConFoldEntry(ccfe);
                    if (SUCCEEDED(hr))
                    {
                        // Insert the wizard item
                        //
                        // $$NOTE: Let this fall through, even if the Insert of the wizard
                        // didn't work. Yeah, we'd be in a bad position, but we'd be even
                        // worse off if we just left an empty list. Whatever the case, it
                        // would be next to impossible for this to fail.
                        //
                        hr = HrInsert(ccfe);
                    }
                }
            }

            // Now check if we had found any connections
            if (S_OK == hrEnumConnections)
            {
                Assert(psaConnectionProperties);

                // Add the Network Setup Wizard
                nccs = NCCS_ENABLED;
                // Check for permissions etc.
                HrGetCommandState(pcfpvEmpty, CMIDM_HOMENET_WIZARD, nccs, &dwResourceId, 0xffffffff, NB_FLAG_ON_TOPMENU);
                if (NCCS_ENABLED == nccs)
                {
                    hr = HrCreateConFoldPidl(WIZARD_HNW, NULL, pidlHNWWizard);
                    if (SUCCEEDED(hr))
                    {
                        // Convert the pidl to a ConFoldEntry
                        //
                        hr = pidlHNWWizard.ConvertToConFoldEntry(ccfe);
                        if (SUCCEEDED(hr))
                        {
                            hr = HrInsert(ccfe);
                        }
                    }
                }

                LONG lLBound;
                LONG lUBound;

                m_fPopulated = TRUE;
            
                hr = SafeArrayGetLBound(psaConnectionProperties, 1, &lLBound);
                if (SUCCEEDED(hr))
                {
                    hr = SafeArrayGetUBound(psaConnectionProperties, 1, &lUBound);
                    if (SUCCEEDED(hr))
                    {
                        for (LONG i = lLBound; i <= lUBound; i++)
                        {
                            CComVariant varRecord;
                    
                            hr = SafeArrayGetElement(psaConnectionProperties, &i, reinterpret_cast<LPVOID>(&varRecord));
                            if (FAILED(hr))
                            {
                                SafeArrayDestroy(psaConnectionProperties);
                                break;
                            }
                        
                            Assert( (VT_ARRAY | VT_VARIANT) == varRecord.vt);
                            if ( (VT_ARRAY | VT_VARIANT) != varRecord.vt)
                            {
                                SafeArrayDestroy(psaConnectionProperties);
                                break;
                            }

                            NETCON_PROPERTIES_EX *pPropsEx;
                            hrDebug = HrNetConPropertiesExFromSafeArray(varRecord.parray, &pPropsEx);
                            if (SUCCEEDED(hr))
                            {
                                // don't insert incoming connection in transit state
                                if (!((pPropsEx->dwCharacter & NCCF_INCOMING_ONLY) &&
                                      (pPropsEx->ncMediaType != NCM_NONE) &&
                                      !(fIsConnectedStatus(pPropsEx->ncStatus)) ))
                                {
                                    // Get this for debugging only.
                                    PCONFOLDPIDL pcfpEmpty;
                                    hrDebug = HrInsertFromNetConPropertiesEx(*pPropsEx, pcfpEmpty);

                                    TraceError("Could not Insert from NetConProperties", hrDebug);
                                }
                                HrFreeNetConProperties2(pPropsEx);
                            }
                            else
                            {
                                TraceError("Could not obtain properties from Safe Array", hrDebug);
                            }
                        }
                    }
                }

            }
            else
            {
                TraceHr(ttidError, FAL, hr, FALSE, "EnumConnectionProperties of the Connection Manager failed");
            } // if S_OK == hr

            ReleaseWriteLock();

        } // if SUCCEEDED(hrEnumConnections)
    }
    else
    {
        TraceHr(ttidError, FAL, hr, FALSE, "CoCreateInstance of the Connection Manager v2 failed. "
                "If you're in the process of shutting down, this is expected, as we can't do "
                "a CoCreate that would force a process to start (netman.exe). If you're not "
                "shutting down, then let us know the error code");
    }
    
#ifdef DBG
    if (SUCCEEDED(hr))
    {
        AcquireLock();

        TraceTag(ttidNotifySink, "CConnectionList::HrRefreshConManEntries:");

        if (m_pcclc)
        {
            for (ConnListCore::const_iterator i = m_pcclc->begin(); i != m_pcclc->end(); i++)
            {
                const CONFOLDENTRY& cfe = i->second.ccfe;
                WCHAR szTrace[MAX_PATH*2];

                OLECHAR szGuidString[MAX_GUID_STRING_LEN];
                StringFromGUID2(cfe.GetGuidID(), szGuidString, MAX_GUID_STRING_LEN);

                TraceTag(ttidNotifySink, "  ==>%S [%s:%s:%s:%s]", 
                cfe.GetName(), DbgNcm(cfe.GetNetConMediaType()), DbgNcsm(cfe.GetNetConSubMediaType()), DbgNcs(cfe.GetNetConStatus()), DbgNccf(cfe.GetCharacteristics()) );
            }
        }

        ReleaseLock();
    }
#endif

    TraceHr(ttidError, FAL, hr, FALSE, "CConnectionList::HrRetrieveConManEntries");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionList::HrGetBrandingInfo
//
//  Purpose:    Get the branding-specific information off of this particular
//              connection. It MUST be an NCCF_BRANDING-type connection, or
//              this information will not be present.
//
//  Arguments:
//      cle   [in, out]  The entry for this connection. cle.ccfe must have been
//                       set before this call.
//
//  Returns:
//
//  Author:     jeffspr   25 Mar 1998
//
//  Notes:
//
HRESULT CConnectionList::HrGetBrandingInfo(
    IN OUT ConnListEntry& cle)
{
    TraceFileFunc(ttidConnectionList);
    
    HRESULT                         hr      = S_OK;
    INetConnectionBrandingInfo *    pncbi   = NULL;

    Assert(!cle.empty());
    Assert(!cle.ccfe.empty());

    if (cle.empty() || cle.ccfe.empty())
    {
        hr = E_POINTER;
    }
    else
    {
        Assert(cle.ccfe.GetCharacteristics() & NCCF_BRANDED);

        hr = cle.ccfe.HrGetNetCon(IID_INetConnectionBrandingInfo,
                                      reinterpret_cast<VOID**>(&pncbi));
        if (SUCCEEDED(hr))
        {
            // Everything is kosher. Grab the paths.
            //
            hr = pncbi->GetBrandingIconPaths(&(cle.pcbi));
            if (SUCCEEDED(hr))
            {
                // Trace the icon paths for debugging
                //
                if (cle.pcbi->szwLargeIconPath)
                {
                    TraceTag(ttidConnectionList, "  Branded icon [large]: %S",
                             cle.pcbi->szwLargeIconPath);
                }
                if (cle.pcbi->szwTrayIconPath)
                {
                    TraceTag(ttidConnectionList, "  Branded icon [tray]: %S",
                             cle.pcbi->szwTrayIconPath);
                }
            }

            // Grab any menu items
            hr = pncbi->GetTrayMenuEntries(&(cle.pctmd));
            if (SUCCEEDED(hr))
            {
                // Trace the menu items for debugging
                CON_TRAY_MENU_DATA * pMenuData = cle.pctmd;
                if (pMenuData)
                {
                    CON_TRAY_MENU_ENTRY * pMenuEntry = pMenuData->pctme;
                    DWORD dwCount = pMenuData->dwCount;
                    while (dwCount)
                    {
                       Assert(pMenuEntry);

                       TraceTag(ttidConnectionList, "***CM menu:*** \nItem: %S \nCommand: %S \nParameters: %S",
                                pMenuEntry->szwMenuText,
                                pMenuEntry->szwMenuCmdLine,
                                pMenuEntry->szwMenuParams);

                       dwCount--;
                       pMenuEntry++;
                    }
                }
            }

            ReleaseObj(pncbi);  // 180240
        }
        else
        {
            // Not a problem -- just doesn't have branding information
            //
            hr = S_OK;
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CConnectionList::HrGetBrandingInfo");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionList::EnsureConPointNotifyAdded
//
//  Purpose:    Ensure that we create the con point notify
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     jeffspr   5 Oct 1998
//
//  Notes:
//
VOID CConnectionList::EnsureConPointNotifyAdded() throw()
{
    TraceFileFunc(ttidConnectionList);
    
    HRESULT                     hr              = S_OK; // Not returned, but used for debugging
    IConnectionPoint *          pConPoint       = NULL;
    INetConnectionNotifySink *  pSink           = NULL;

    AssertSz(m_fAdviseOnThis, "Shouldn't even be calling EnsureConPointNotifyAdded if "
           "we don't want advises");

    if (m_fAdviseOnThis)
    {
        if (!InSendMessage())
        {
            // If we don't already have an advise sink
            //
            if (c_dwInvalidCookie == m_dwAdviseCookie)
            {
                AssertSz(g_dwAdvisesActive == 0, "An advise already exists. We should never "
                         "be creating more than one Advise per Explorer instance");

                // Make sure that we have a connection point.
                //
                hr = HrGetNotifyConPoint(&pConPoint);
                if (SUCCEEDED(hr))
                {
                    // Create the notify sink
                    //
                    hr = CConnectionNotifySink::CreateInstance(
                            IID_INetConnectionNotifySink,
                            (LPVOID*)&pSink);
                    if (SUCCEEDED(hr))
                    {
                        Assert(pSink);

                        hr = pConPoint->Advise(pSink, &m_dwAdviseCookie);
                        if (SUCCEEDED(hr))
                        {
                            TraceTag(ttidNotifySink, "Added advise sink. Cookie = %d", m_dwAdviseCookie);
                            g_dwAdvisesActive++;
                        }

                        TraceHr(ttidError, FAL, hr, FALSE, "pConPoint->Advise");

                        ReleaseObj(pSink);
                    }

                    ReleaseObj(pConPoint);
                }
            }
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "EnsureConPointNotifyAdded");
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionList::EnsureConPointNotifyRemoved
//
//  Purpose:    Ensure that the connection point notify has been unadvised.
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     jeffspr   7 Oct 1998
//
//  Notes:
//
VOID CConnectionList::EnsureConPointNotifyRemoved() throw()
{
    TraceFileFunc(ttidConnectionList);
    
    HRESULT             hr          = S_OK;
    IConnectionPoint *  pConPoint   = NULL;

    AssertSz(m_fAdviseOnThis, "EnsureConPointNotifyRemoved shouldn't be "
            "called when we're not a notify capable connection list");

    // No more objects, so remove the advise if present
    //
    if (m_dwAdviseCookie != c_dwInvalidCookie)
    {
        hr = HrGetNotifyConPoint(&pConPoint);
        if (SUCCEEDED(hr))
        {
            // Unadvise
            //
            hr = pConPoint->Unadvise(m_dwAdviseCookie);
            TraceTag(ttidNotifySink, "Removed advise sink. Cookie = d", m_dwAdviseCookie);

            TraceHr(ttidError, FAL, hr, FALSE, "pConPoint->Unadvise");

            m_dwAdviseCookie = c_dwInvalidCookie;

            ReleaseObj(pConPoint);

            g_dwAdvisesActive--;
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "EnsureConPointNotifyRemoved");
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionList::HrInsert
//
//  Purpose:    Insert a connection into the list, based on a pre-built
//              ConFoldEntry
//
//  Arguments:
//      pccfe [in]  ConFoldEntry describing the connection
//
//  Returns:
//
//  Author:     jeffspr   24 Sep 1998
//
//  Notes:
//
HRESULT CConnectionList::HrInsert(IN const CONFOLDENTRY& pccfe)
{
    TraceFileFunc(ttidConnectionList);
    
    HRESULT         hr          = S_OK;
    HRESULT         hrFind      = S_OK;
    BOOL            fLockHeld   = FALSE;

    Assert(!pccfe.empty());

    // Get the lock, so our find/add can't allow a dupe.
    //

    // Fill the struct data, and push it on.
    //
    ConnListEntry   cle;
    cle.dwState     = CLEF_NONE;
    cle.ccfe        = pccfe;

    // Initialize the branding info
    cle.pcbi = NULL;
    cle.pctmd = NULL;
    if (cle.ccfe.GetCharacteristics() & NCCF_BRANDED)
    {
        HrGetBrandingInfo(cle);
    }
    Assert(!cle.empty());
    
    AcquireLock();
    
    TraceTag(ttidConnectionList, "Adding %S to the connection list", pccfe.GetName());

    ConnListEntry cleFind;
    hrFind =  HrFindConnectionByGuid(&(pccfe.GetGuidID()), cleFind);
    if (hrFind == S_FALSE)
    {
        // Allocate our list if we haven't already.
        //
        if (!m_pcclc)
        {
            m_pcclc = new ConnListCore;
        }

        // Allocate the structure to be pushed onto the STL list.
        //
        if (!m_pcclc)
        {
            hr = E_OUTOFMEMORY;
            ReleaseLock();
        }
        else
        {
            Assert(!cle.empty());

            (*m_pcclc)[cle.ccfe.GetGuidID()] = cle;
            ReleaseLock();

            if (m_fTiedToTray && g_pCTrayUI && cle.ccfe.FShouldHaveTrayIconDisplayed())
            {
                CONFOLDENTRY ccfeDup;
                hr = ccfeDup.HrDupFolderEntry(cle.ccfe);
                if (SUCCEEDED(hr))
                {
                    // Note: this must be a send message otherwise we can
                    // get duplicate icons in the tray. ;-(  We should set the
                    // uiTrayIconId here (while we have the lock) and PostMessage
                    // to actually add the tray icon, but that's a big change.
                    //
                    TraceTag(ttidSystray, "HrInsert: Adding tray icon for %S", cle.ccfe.GetName());
                    PostMessage(g_hwndTray, MYWM_ADDTRAYICON, (WPARAM) ccfeDup.TearOffItemIdList(), (LPARAM) 0);
                }
            }
        }
    }
    else
    {
        ReleaseLock();
        
        if (S_OK == hrFind)
        {
            TraceTag(ttidConnectionList, "Avoiding adding duplicate connection to the connection list");
        }
        else
        {
            // We had a failure finding the connection. We're hosed.
            TraceTag(ttidConnectionList, "Failure doing a findbyguid in the CConnectionList::HrInsert()");
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CConnectionList::HrInsert");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionList::HrInsertFromNetCon
//
//  Purpose:    Given an INetConnection *, build the cle data and insert
//              the new connection into the list. Return a PCONFOLDPIDL if
//              requested.
//
//  Arguments:
//      pNetCon [in]    The active INetConnection interface
//      ppcfp   [out]   Return pointer for PCFP, if requested
//
//  Returns:
//
//  Author:     jeffspr   24 Sep 1998
//
//  Notes:
//
HRESULT CConnectionList::HrInsertFromNetCon(
    IN  INetConnection *    pNetCon,
    OUT PCONFOLDPIDL &      ppcfp)
{
    TraceFileFunc(ttidConnectionList);
    
    HRESULT                hr              = S_OK;
    PCONFOLDPIDL           pidlConnection;
    CONFOLDENTRY           pccfe;

    Assert(pNetCon);

    NETCFG_TRY
    // From the net connection, create the pidl
        //
        hr = HrCreateConFoldPidl(WIZARD_NOT_WIZARD, pNetCon, pidlConnection);
        if (SUCCEEDED(hr))
        {
            // Convert the pidl to a ConFoldEntry.
            //
            hr = pidlConnection.ConvertToConFoldEntry(pccfe);
            if (SUCCEEDED(hr))
            {
                // Insert the item into the connection list. HrInsert should
                // take over this CONFOLDENTRY, so we can't delete it.
                // Note: We should kill this on fail, but we must make
                // sure that HrInsert doesn't keep the pointer anywhere on
                // failure.
                //
                hr = HrInsert(pccfe);
            }
        }

        if (SUCCEEDED(hr))
        {
            // Fill in the out param
            if ( !(pidlConnection.empty()) )
            {
                ppcfp = pidlConnection;
            }
        }

    NETCFG_CATCH(hr)
        
    TraceHr(ttidError, FAL, hr, FALSE, "CConnectionList::HrInsertFromNetCon");
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CConnectionList::HrInsertFromNetConPropertiesEx
//
//  Purpose:    Given an NETCON_PROPERTIES_EX&, build the cle data and insert
//              the new connection into the list. Return a PCONFOLDPIDL
//
//  Arguments:
//      pPropsEx [in]    The active NETCON_PROPERTIES_EX
//      ppcfp    [out]   Return PCONFOLDPIDL
//
//  Returns:
//
//  Author:     deonb   26 Mar 2001
//
//  Notes:
//
HRESULT CConnectionList::HrInsertFromNetConPropertiesEx(
        IN  const NETCON_PROPERTIES_EX& pPropsEx,
        OUT PCONFOLDPIDL &              ppcfp)
{
    TraceFileFunc(ttidConnectionList);
    
    HRESULT                hr              = S_OK;
    PCONFOLDPIDL           pidlConnection;
    CONFOLDENTRY           pccfe;

    //
    hr = HrCreateConFoldPidl(pPropsEx, pidlConnection);
    if (SUCCEEDED(hr))
    {
        // Convert the pidl to a ConFoldEntry.
        //
        hr = pidlConnection.ConvertToConFoldEntry(pccfe);
        if (SUCCEEDED(hr))
        {
            // Insert the item into the connection list. HrInsert should
            // take over this CONFOLDENTRY, so we can't delete it.
            // Note: We should kill this on fail, but we must make
            // sure that HrInsert doesn't keep the pointer anywhere on
            // failure.
            //
            hr = HrInsert(pccfe);
        }
    }

    if (SUCCEEDED(hr))
    {
        // Fill in the out param
        if ( !(pidlConnection.empty()) )
        {
            ppcfp = pidlConnection;
        }
    }

        
    TraceHr(ttidError, FAL, hr, FALSE, "CConnectionList::HrInsertFromNetCon");
    return hr;
}

// Old HrFindCallbackConnName
bool operator==(IN  const ConnListCore::value_type& val, IN  PCWSTR pszName) throw()
{
    bool bRet = false;
    
    Assert(pszName);

    const ConnListEntry &cle = val.second;
    Assert(!cle.empty());
    Assert(!cle.ccfe.empty());
    Assert(cle.ccfe.GetName());
    
    if (lstrcmpiW(pszName, cle.ccfe.GetName()) == 0)
    {
        bRet = true;
    }
    
    return bRet;
}

// Old HrFindCallbackConFoldEntry
bool operator==(IN  const ConnListCore::value_type& val, IN  const CONFOLDENTRY& cfe) throw()
{
    bool bRet = false;

    Assert(!cfe.empty())
    const ConnListEntry &cle = val.second;

    Assert(!cle.empty());
    Assert(!cfe.empty());
    
    Assert(!cle.ccfe.empty());
    Assert(cle.ccfe.GetName());
    
    if (cle.ccfe.GetWizard() && cfe.GetWizard())
    {
        bRet = true;
    }
    else
    {
        if (InlineIsEqualGUID(cfe.GetGuidID(), cle.ccfe.GetGuidID()))
        {
            bRet = true;
        }
    }
    
    return bRet;
}

// Old HrFindCallbackTrayIconId
bool operator==(IN  const ConnListCore::value_type& val, IN  const UINT& uiIcon) throw()
{
    bool bRet = false;

    const ConnListEntry &cle = val.second;
    
    Assert(!cle.empty());
    Assert(!cle.ccfe.empty());

    if (cle.HasTrayIconData() && 
        (cle.GetTrayIconData()->GetTrayIconId() == uiIcon))
    {
        bRet = true;
    }
    
    return bRet;
}

// Old HrFindCallbackGuid
bool operator < (IN  const GUID& rguid1, IN  const GUID& rguid2) throw()
{
    return memcmp(&rguid1, &rguid2, sizeof(GUID)) < 0;
}

BOOL ConnListEntry::empty() const throw()
{
    return (ccfe.empty());
}

void ConnListEntry::clear() throw()
{
    dwState = NULL;
    ccfe.clear();
    pctmd = NULL;
    pcbi = NULL;
    DeleteTrayIconData();
}

VOID CConnectionList::InternalAcquireLock() throw()
{
    TraceFileFunc(ttidConnectionList);
    
    EnterCriticalSection(&m_csMain);
#if DBG
    m_dwCritSecRef++;
//    TraceTag(ttidConnectionList, "CConnectionList::AcquireLock (%d)", m_dwCritSecRef);
#endif
}

VOID CConnectionList::InternalReleaseLock() throw()
{
    TraceFileFunc(ttidConnectionList);
    
#if DBG
    m_dwCritSecRef--;
//    TraceTag(ttidConnectionList, "CConnectionList::ReleaseLock (%d)", m_dwCritSecRef);
#endif
    LeaveCriticalSection(&m_csMain);
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionList::HrFindConnectionByName
//
//  Purpose:    Find a connection in the connection list, using
//              the connection name as the search key
//
//  Arguments:
//      pszName [in]    Name of the connection to find
//      cle     [out]   Return pointer for the connection entry
//
//  Returns:
//
//  Author:     jeffspr   20 Mar 1998
//
//  Notes:
//
inline HRESULT CConnectionList::HrFindConnectionByName(
    IN  PCWSTR   pszName,
    OUT ConnListEntry& cle)
{
    TraceFileFunc(ttidConnectionList);
    
    return HrFindConnectionByType( pszName, cle );
}

inline HRESULT CConnectionList::HrFindConnectionByConFoldEntry(
    IN  const CONFOLDENTRY&  cfe,
    OUT ConnListEntry& cle)
{
    TraceFileFunc(ttidConnectionList);
    
    return HrFindConnectionByType( cfe, cle );
}

inline HRESULT CConnectionList::HrFindConnectionByTrayIconId(
    IN  UINT          uiIcon,
    OUT ConnListEntry& cle)
{
    TraceFileFunc(ttidConnectionList);
    
    return HrFindConnectionByType( uiIcon, cle );
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionList::HrFindRasServerConnection
//
//  Purpose:    Find the RAS Server connection
//
//  Arguments:
//      cle [out] The connection list entry
//
//  Returns:
//
//  Author:     deonb 26 Apr 2001
//
//  Notes:
//
HRESULT CConnectionList::HrFindRasServerConnection(
    OUT ConnListEntry& cle)
{
    HRESULT hr = S_FALSE;
    if (m_pcclc)
    {
        AcquireLock();

        ConnListCore::const_iterator clcIter;
        // Try to find the connection
        //
        for (clcIter = m_pcclc->begin(); clcIter != m_pcclc->end(); clcIter++)
        {
            cle = clcIter->second;
            if (!cle.ccfe.empty())
            {
                if (cle.ccfe.GetCharacteristics() & NCCF_INCOMING_ONLY)
                {
                    if (cle.ccfe.GetNetConMediaType() == NCM_NONE)
                    {
                        hr = S_OK;
                        break;
                    }
                }
            }
        }

        ReleaseLock();
    }
    else
    {
        hr = E_UNEXPECTED;
    }
    
    return hr;
}
//+---------------------------------------------------------------------------
//
//  Member:     CConnectionList::HrFindPidlByGuid
//
//  Purpose:    Using a GUID, find the connection in the connection list
//              and, using the conlist pccfe member, generate a pidl. This
//              will be used in most of the notify sink refresh operations.
//
//  Arguments:
//      pguid [in]  Connection GUID
//      ppidl [out] Out param for the generated pidl
//
//  Returns:
//
//  Author:     jeffspr   28 Aug 1998
//
//  Notes:
//
HRESULT CConnectionList::HrFindPidlByGuid(
    IN  const GUID *   pguid,
    OUT PCONFOLDPIDL& pidl)
{
    TraceFileFunc(ttidConnectionList);
    
    HRESULT         hr      = S_OK;
    ConnListEntry   cle;

    hr = HrFindConnectionByGuid(pguid, cle);
    if (S_OK == hr)
    {
        // convert to pidl and call the deleteccl
        //
        hr = cle.ccfe.ConvertToPidl(pidl);
    }

    TraceHr(ttidError, FAL, hr, (S_FALSE == hr),
        "CConnectionList::HrFindPidlByGuid");
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CConnectionList::HrFindConnectionByGuid
//
//  Purpose:    Find the connection list entry based on the unique GUID
//              of the connection. Return the list entry to the caller.
//
//  Arguments:
//      pguid [in]  Lookup key
//      cle   [out] Return pointer for the list entry (see Notes:)
//
//  Returns:    S_OK, S_FALSE, or an error
//
//  Author:     jeffspr   24 Sep 1998
//
//  Notes:      The list must be locked until the caller stops using
//              the returned entry
//
HRESULT CConnectionList::HrFindConnectionByGuid(
    IN  const GUID UNALIGNED*pguid,
    OUT ConnListEntry & cle)
{
    TraceFileFunc(ttidConnectionList);
    
    HRESULT hr = S_FALSE;
    GUID alignedGuid;

    Assert(pguid);
    alignedGuid = *pguid;

    // Pre-NULL this out in case of failure.
    //
    if (m_pcclc)
    {
        AcquireLock();
        ConnListCore::const_iterator iter = m_pcclc->find(alignedGuid);

        if (iter != m_pcclc->end() )
        {
            cle = iter->second;

            Assert(!cle.ccfe.empty() );
            if (!cle.ccfe.empty())
            {
                cle.UpdateCreationTime();
                hr = S_OK;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            hr = S_FALSE;
        }
        ReleaseLock();
    }
    else
    {
        hr = S_FALSE;
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionList::HrGetCurrentStatsForTrayIconId
//
//  Purpose:    Get the current statistics data from the connection
//              with the specified tray icon id.
//
//  Arguments:
//      uiIcon   [in]  Tray icon id.
//      ppData   [out] Address of where to return pointer to data.
//      pstrName [out] Address of a tstring where the name of the connection
//                     is returned.
//
//  Returns:    S_OK, S_FALSE if not found, or an error.
//
//  Author:     shaunco   7 Nov 1998
//
//  Notes:      Free the *ppData with CoTaskMemFree.
//
HRESULT CConnectionList::HrGetCurrentStatsForTrayIconId(
    IN  UINT                    uiIcon,
    OUT STATMON_ENGINEDATA**    ppData,
    OUT tstring*                pstrName)
{
    TraceFileFunc(ttidConnectionList);
    
    HRESULT                 hr;
    ConnListEntry           cle;
    INetStatisticsEngine*   pnse = NULL;

    // Initialize the output parameter.
    //
    if (ppData)
    {
        *ppData = NULL;
    }

    pstrName->erase();

    // Lock the list only long enough to find the entry and
    // get an AddRef'd copy of its INetStatisticsEngine interface pointer.
    // It's very important not to use this pointer while our lock is
    // held because doing so will cause it to try to get it's own lock.
    // If, on some other thread, that statistics engine is trying to call
    // back into us (and it already has its lock held), we'd have a dead lock.
    // AddRefing it ensures that the interface is valid even after we
    // release our lock.
    //
    AcquireLock();

    hr = HrFindConnectionByTrayIconId(uiIcon, cle);
    if (S_OK == hr)
    {
        Assert(cle.HasTrayIconData() );

        pnse = cle.GetTrayIconData()->GetNetStatisticsEngine();
        AddRefObj(pnse);
        
        // Make a copy of the name for the caller.
        //
        pstrName->assign(cle.ccfe.GetName());
    }

    ReleaseLock();

    // If we found the entry and obtained it's INetStatisticsEngine interface,
    // get the current statistics data from it and release it.
    //
    if (pnse && ppData)
    {
        hr = pnse->GetStatistics(ppData);
    }

    if (pnse)
    {
        ReleaseObj(pnse);
    }

    TraceHr(ttidError, FAL, hr, (S_FALSE == hr),
        "CConnectionList::HrGetCurrentStatsForTrayIconId");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionList::HrUpdateTrayIconIdByName
//
//  Purpose:    Update the connection list entry for a particular connection,
//              as the icon id has changed.
//
//  Arguments:
//      pszName     [in]    Name of the connection to update
//      pccts       [in]    Tray stats interface
//      pcpStat     [in]    Interface used for Advise
//      pnseStats   [in]    More statistics object crap
//      uiIcon      [in]    Icon ID to be stored in that entry
//
//  Returns:    S_OK, S_FALSE if not found, or an error code.
//
//  Author:     jeffspr   20 Mar 1998
//
//  Notes:
//
HRESULT CConnectionList::HrUpdateTrayIconDataByGuid(
        IN  const GUID *            pguid,
        IN  CConnectionTrayStats *  pccts,
        IN  IConnectionPoint *      pcpStat,
        IN  INetStatisticsEngine *  pnseStats,
        IN  UINT                    uiIcon)
{
    TraceFileFunc(ttidConnectionList);
    
    HRESULT         hr              = S_OK;
    ConnListEntry   cle;

    AcquireWriteLock();
    hr = HrFindConnectionByGuid(pguid, cle);
    if (hr == S_OK)
    {
        Assert(!cle.empty());

        CTrayIconData pTrayIconData(uiIcon, cle.ccfe.GetNetConStatus(), pcpStat, pnseStats, pccts);
        cle.SetTrayIconData(pTrayIconData);

        hr = HrUpdateConnectionByGuid(pguid, cle);
    }
    ReleaseWriteLock();

    TraceHr(ttidError, FAL, hr, (S_FALSE == hr),
        "CConnectionList::HrUpdateTrayIconDataByGuid");
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CConnectionList::HrUpdateTrayBalloonInfoByGuid
//
//  Purpose:    Update the balloon entry for a particular connection,
//
//  Arguments:
//      pguid                [in] Guid of the connection to update
//      dwLastBalloonMessage [in] BALLOONS enum 
//      szCookie             [in] Cookie
//      pfnBalloonFunction   [in] Balloon callback function if BALLOONS == BALLOON_CALLBACK
//
//  Returns:    S_OK, S_FALSE if not found, or an error code.
//
//  Author:     deon   22 Mar 2001
//
//  Notes:
//
HRESULT CConnectionList::HrUpdateTrayBalloonInfoByGuid(IN  const GUID *     pguid,
                                                       IN  DWORD            dwLastBalloonMessage, 
                                                       IN  BSTR             szCookie,
                                                       IN  FNBALLOONCLICK*  pfnBalloonFunction)
{
    TraceFileFunc(ttidConnectionList);
    
    HRESULT         hr              = S_OK;
    ConnListEntry   cle;
    
    AcquireWriteLock();
    hr = HrFindConnectionByGuid(pguid, cle);
    if (hr == S_OK)
    {
        Assert(!cle.empty());

        
        CTrayIconData * pTrayIconData = cle.GetTrayIconData();
        if (pTrayIconData != NULL)
        {
            hr = pTrayIconData->SetBalloonInfo(dwLastBalloonMessage, szCookie, pfnBalloonFunction);
            if (SUCCEEDED(hr))
            {
                hr = HrUpdateConnectionByGuid(pguid, cle);
            }
        }
    }
    ReleaseWriteLock();
    
    TraceHr(ttidError, FAL, hr, (S_FALSE == hr),
        "CConnectionList::HrUpdateTrayBalloonInfoByGuid");
    return hr;
}

HRESULT CConnectionList::HrUpdateConnectionByGuid(IN  const GUID *         pguid,
                                                  IN  const ConnListEntry& cle )
{
    TraceFileFunc(ttidConnectionList);
    
    HRESULT hr = S_OK;

    GUID alignedGuid;
    Assert(pguid);
    alignedGuid = *pguid;

    if (m_pcclc)
    {
        ConnListEntry cleCopy(cle);

        AcquireLock();
        ConnListCore::iterator iter = m_pcclc->find(alignedGuid);
        
        if (iter != m_pcclc->end() )
        {
            // If what we have in the list is already more recent, just discard the change
            if ( iter->second.GetCreationTime() <= cleCopy.GetCreationTime() )
            {
                iter->second = cleCopy;
                hr = S_OK;
            }
            else
            {
                TraceError("HrUpdateConnectionByGuid discarded older ConnectionListEntry", E_FAIL);
                hr = S_FALSE;
            }
                
            Assert(!cleCopy.empty());
        }
        else
        {
            hr = E_FAIL;
        }
        ReleaseLock();
    }
    else
    {
        hr = E_FAIL;
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionList::HrUpdateNameByGuid
//
//  Purpose:    Update the list with the new connection name. Search for the
//              connection using the guid. Depending on the value of fForce,
//              either fail a duplicate connection name or force the issue
//              (since this might be as a result of a shell call, which we
//              have no control over)
//
//  Arguments:
//      pguid      [in]     Lookup key
//      pszNewName [in]     New name for the connection
//      ppidlOut   [out]    Output pidl, if requested
//      fForce     [in]     Force the name change, or fail on duplicate?
//
//  Returns:
//
//  Author:     jeffspr   24 Sep 1998
//
//  Notes:
//
HRESULT CConnectionList::HrUpdateNameByGuid(
    IN  const GUID *        pguid,
    IN  PCWSTR              pszNewName,
    OUT PCONFOLDPIDL &      pidlOut,
    IN  BOOL                fForce)
{
    TraceFileFunc(ttidConnectionList);
    
    HRESULT         hr          = S_OK;
    ConnListEntry   cle;

    Assert(pguid);
    Assert(pszNewName);

    AcquireWriteLock();

    hr = HrFindConnectionByGuid(pguid, cle);
    if (S_OK == hr)
    {
        // Check to see if we already have an entry with this name
        //
        ConnListEntry   cleDupe;
        hr = HrFindConnectionByName(pszNewName, cleDupe);
        if (S_OK == hr && !fForce)
        {
            Assert(!cleDupe.empty());

            hr = NETCFG_E_NAME_IN_USE;
        }
        else
        {
            // This is what we want.. Either there's not already a connection
            // with this name or we are allowing ourselves to rename it to
            // a duplicate string (this can occur when RAS is notifying us of
            // a change -- you know, separate phonebooks and all).
            //
            if ((S_FALSE == hr) || (hr == S_OK && fForce))
            {
                PWSTR pszNewNameCopy = NULL;

                if (!(cle.ccfe.GetWizard()))
                {
                    hr = HrDupeShellString(pszNewName, &pszNewNameCopy);
                    if (SUCCEEDED(hr))
                    {
                        Assert(pszNewNameCopy);

                        // If it's not the static wizard string, and it's non-NULL then
                        // free it
                        //
                        cle.ccfe.SetPName(pszNewNameCopy);

                        // If we're to return a new PIDL for this entry
                        //
                        // Convert the class back to the pidl format
                        //
                        hr = cle.ccfe.ConvertToPidl(pidlOut);
                    }
                }
            }
            else
            {
                AssertSz(FALSE, "Error occurred while attempting to find a dupe in HrUpdateNameByGuid");
            }
        }
        
        if (SUCCEEDED(hr))
        {
            hr = HrUpdateConnectionByGuid(pguid, cle);
        }
    }

    ReleaseWriteLock();

    TraceHr(ttidError, FAL, hr, FALSE, "CConnectionList::HrUpdateNameByGuid");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionList::HrUpdateTrayIconByGuid
//
//  Purpose:    Update the icon image based on the connection changes.
//              Do the lookup by GUID.
//
//  Arguments:
//      pguid [in]  GUID of the changed connection
//
//  Returns:
//
//  Author:     jeffspr   24 Sep 1998
//
//  Notes:
//
HRESULT CConnectionList::HrUpdateTrayIconByGuid(
    IN  const GUID *    pguid,
    OUT BOOL            fBrieflyShowBalloon)
{
    TraceFileFunc(ttidConnectionList);
    
    HRESULT         hr          = S_OK;
    ConnListEntry   cle;

    Assert(m_fTiedToTray);

    TraceTag(ttidConnectionList, "HrUpdateTrayIconByGuid");

    if (!g_pCTrayUI || !m_fTiedToTray)
    {
        TraceTag(ttidConnectionList, "!g_pCTrayUI || !m_fTiedToTray, so no updates");
        return S_OK;
    }

    Assert(pguid);

    AcquireWriteLock();

    hr = HrFindConnectionByGuid(pguid, cle);
    if (S_OK == hr)
    {
        GUID * pguidCopy = NULL;

        BOOL fShouldHaveIcon = cle.ccfe.FShouldHaveTrayIconDisplayed();
        BOOL fShouldRemoveOld = FALSE;

        TraceTag(ttidConnectionList, "HrUpdateTrayIconByGuid: Found. fShouldHave: %d",
            fShouldHaveIcon);

        // If there's an existing icon, see if it needs to go away
        if (cle.HasTrayIconData())
        {
            // If we need to remove a media-disconnected icon, do so.
            //
            if (cle.ccfe.GetNetConStatus() != cle.GetTrayIconData()->GetConnected()) // If the status has changed.
            {
                NETCON_STATUS ncsOldStatus = cle.GetTrayIconData()->GetConnected();
                NETCON_STATUS ncsNewStatus = cle.ccfe.GetNetConStatus();

                if ( (NCS_INVALID_ADDRESS    == ncsNewStatus) || // Definitely changes the icon
                     (NCS_MEDIA_DISCONNECTED == ncsNewStatus) || // Definitely changes the icon
                     (NCS_INVALID_ADDRESS    == ncsOldStatus) || // Definitely changes the icon
                     (NCS_MEDIA_DISCONNECTED == ncsOldStatus) || // Definitely changes the icon
                     ( (fIsConnectedStatus(ncsOldStatus) != fIsConnectedStatus(ncsNewStatus)) && // From connect to disconnect or disconnect to connect
                       !((NCS_DISCONNECTING == ncsOldStatus) && (NCS_CONNECTED  == ncsNewStatus)) && // BUT NOT going from Disconnecting to Connect (BAP dialup failure)
                       !((NCS_CONNECTED     == ncsOldStatus) && (NCS_CONNECTING == ncsNewStatus)) // Or from Connect to Connecting (BAP dialup failure)
                     )
                   )
                {
                    // if we are changing to one of these states, we need to remove whatever was there previously
                    TraceTag(ttidConnectionList, "HrUpdateTrayByGuid: Need to remove icon");
                    fShouldRemoveOld = TRUE;
                }
            }
            // Else if we just don't need one anymore...
            //
            else if (!fShouldHaveIcon)
            {
                TraceTag(ttidConnectionList, "HrUpdateTrayIconByGuid: Shouldn't have a tray icon. Need to remove");
                fShouldRemoveOld = TRUE;
            }
        }
        else
        {
            TraceTag(ttidConnectionList, "HrUpdateTrayIconByGuid. No existing icon (for removal)");
            pguidCopy = new GUID;

            // Copy the guid
            if (pguidCopy)
            {
                CopyMemory(pguidCopy, pguid, sizeof(GUID));
            }
        }

        TraceTag(ttidConnectionList, "HrUpdateTrayIconByGuid: Found. fShouldHave: %d, fShouldRemove: %d",
            fShouldHaveIcon, fShouldRemoveOld);

        if (fShouldRemoveOld || pguidCopy)
        {
            TraceTag(ttidConnectionList, "HrUpdateTrayIconByGuid: Posting icon removal");

            if (cle.HasTrayIconData())
            {
                CTrayIconData* pTrayIconData = new CTrayIconData(*cle.GetTrayIconData());
                cle.DeleteTrayIconData();

                TraceTag(ttidSystray, "HrUpdateTrayIconByGuid: Removing tray icon for %S", cle.ccfe.GetName());
                PostMessage(g_hwndTray, MYWM_REMOVETRAYICON, (WPARAM) pTrayIconData, (LPARAM) 0);
            }
            else
            {
                TraceTag(ttidSystray, "HrUpdateTrayIconByGuid: Removing tray icon [FROM GUID] for %S", cle.ccfe.GetName());
                PostMessage(g_hwndTray, MYWM_REMOVETRAYICON, (WPARAM) 0, (LPARAM) pguidCopy);
            }


            TraceTag(ttidConnectionList, "HrUpdateTrayIconByGuid: Back from icon removal");
        }

        TraceTag(ttidConnectionList, "HrUpdateTrayIconByGuid: cle.pTrayIconData: 0x%08x, fShouldHave: %d",
            cle.GetTrayIconData(), fShouldHaveIcon);

        // If there's no tray icon, but the characteristics say that there should be,
        // add one.
        //
        if ((!cle.HasTrayIconData()) && fShouldHaveIcon)
        {
            TraceTag(ttidConnectionList, "HrUpdateTrayIconByGuid: Adding tray icon");

            CONFOLDENTRY ccfeDup;
            hr = ccfeDup.HrDupFolderEntry(cle.ccfe);
            if (SUCCEEDED(hr))
            {
                TraceTag(ttidSystray, "HrUpdateTrayIconByGuid: Adding tray icon for %S", cle.ccfe.GetName());
                PostMessage(g_hwndTray, MYWM_ADDTRAYICON, (WPARAM) ccfeDup.TearOffItemIdList(), (LPARAM) fBrieflyShowBalloon);
            }
        }
        else
        {
            TraceTag(ttidConnectionList, "HrUpdateTrayIconByGuid: Not adding an icon");
        }

        if (SUCCEEDED(hr))
        {
            hr = HrUpdateConnectionByGuid(pguid, cle);
        }
    }

    ReleaseWriteLock();

    TraceHr(ttidError, FAL, hr, FALSE, "CConnectionList::HrUpdateTrayIconByGuid");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionList::HrSuggestNameForDuplicate
//
//  Purpose:    Given an existing connection name, suggest a new name
//              based on name conflict resolution rules
//
//  Arguments:
//      pszOriginal [in]    Name being copied
//      ppszNew     [out]   Suggested duplicate
//
//  Returns:
//
//  Author:     jeffspr   24 Sep 1998
//
//  Notes:
//
HRESULT CConnectionList::HrSuggestNameForDuplicate(
    IN  PCWSTR      pszOriginal,
    OUT PWSTR *    ppszNew)
{
    TraceFileFunc(ttidConnectionList);
    
    HRESULT         hr              = S_OK;
    PWSTR           pszReturn       = NULL;
    DWORD           dwLength        = lstrlenW(pszOriginal);
    BOOL            fUnique         = FALSE;
    ConnListEntry   cle;

    // Maximum # of digits for resolving duplicates = 999999
    static const DWORD  c_cmaxDigits = 6;
    static const DWORD  c_cmaxSuggest = 999999;

    if (dwLength == 0)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        dwLength += lstrlenW(SzLoadIds(IDS_CONFOLD_DUPLICATE_PREFIX2)) +
            c_cmaxDigits;

        pszReturn = new WCHAR[dwLength + 1];
        if (!pszReturn)
        {
            hr = E_FAIL;
        }
        else
        {
            INT     cSuggest = 0;

            while (!fUnique && SUCCEEDED(hr) && (cSuggest <= c_cmaxSuggest))
            {
                if (!cSuggest)
                {
                    // Try "Copy of <foo>" first
                    DwFormatString(SzLoadIds(IDS_CONFOLD_DUPLICATE_PREFIX1),
                                   pszReturn, dwLength, pszOriginal);
                }
                else
                {
                    WCHAR   szDigits[c_cmaxDigits + 1];

                    wsprintfW(szDigits, L"%lu", cSuggest + 1);

                    // Try "Copy (x) of <foo>" now.
                    DwFormatString(SzLoadIds(IDS_CONFOLD_DUPLICATE_PREFIX2),
                                   pszReturn, dwLength, szDigits,
                                   pszOriginal);
                }

                if (lstrlenW(pszReturn) > 255)
                {
                    pszReturn[255] = '\0'; // Truncate if too long
                }

                // See if it already exists
                //
                hr = HrFindConnectionByName(pszReturn, cle);
                if (SUCCEEDED(hr))
                {
                    if (hr == S_FALSE)
                    {
                        // Normalize the hr -- don't want to return S_FALSE;
                        //
                        hr = S_OK;
                        fUnique = TRUE;
                    }
                }

                cSuggest++;
            }

            // If we're still not unique, then we're out of range, and fail out.
            //
            if (!fUnique)
            {
                hr = E_FAIL;
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        *ppszNew = pszReturn;
    }
    else
    {
        if (pszReturn)
        {
            delete [] pszReturn;
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CConnectionList::HrSuggestNameForDuplicate");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionList::HrGetCachedPidlCopyFromPidl
//
//  Purpose:    Given an existing (likely outdated) pidl, retrieve the
//              cached info from the list and build an up-to-date pidl
//
//  Arguments:
//      pidl  [in]      Not-necessarily-new pidl
//      ppcfp [out]     New pidl using cached data
//
//  Returns:
//
//  Author:     jeffspr   24 Sep 1998
//
//  Notes:
//
HRESULT CConnectionList::HrGetCachedPidlCopyFromPidl(
    IN  const PCONFOLDPIDL& pidl,
    OUT PCONFOLDPIDL &      pcfp)
{
    TraceFileFunc(ttidConnectionList);
    
    HRESULT         hr      = S_OK;
    ConnListEntry   cle;

    Assert(!pidl.empty());

    NETCFG_TRY

        pcfp.Clear();

        // Verify that this is a confoldpidl
        //
        if (pidl->IsPidlOfThisType())
        {
            hr = HrFindConnectionByGuid(&(pidl->guidId), cle);
            if (S_OK == hr)
            {
                Assert(!cle.empty());
                Assert(!cle.ccfe.empty());

                const CONFOLDENTRY &pccfe = cle.ccfe;
                hr = pccfe.ConvertToPidl(pcfp);
            }
            else
            {
                pcfp = pidl;
            }
        }
        else
        {
            pcfp = pidl;
            hr = S_OK;
        }

    NETCFG_CATCH(hr)

    TraceHr(ttidError, FAL, hr, (S_FALSE == hr),
        "CConnectionList::HrGetCachedPidlCopyFromPidl");
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrMapCMHiddenConnectionToOwner
//
//  Purpose:    Maps a child connection to its parent connection.
//
//              Connection Manager has two stages: Dialup and VPN.
//              For the Dialup it creates a hidden connectoid that the 
//              folder (netshell) does not see. However netman caches
//              the name, guid and status of this connectedoid. Both 
//              the parent and child connectoid have the same name. When 
//              the status of the hidden connectiod is updated the folder 
//              recives the guid of the hidden connectoid and maps the 
//              connectiod to it parent (Connection Manager) by searching 
//              netmans cache for the name of the hidden connectoid. Then it
//              searches the connections in the folder for that name and thus
//              gets the guid of the parent connectoid.     
//
//              When the folder gets a notify message from netman for the hidden 
//              connection it uses this function to find the parent and update the 
//              parent's status. The hidden connection is not displayed.
//
//  Arguments:
//      guidHidden   [in]   GUID of the hidden connectiod
//      pguidOwner   [out]  GUID of the parent connectiod
//
//  Returns:    S_OK -- mapped the hidden connection to its parent
//
//  Author:     omiller   1 Jun 2000
//
//  Notes:
//
HRESULT CConnectionList::HrMapCMHiddenConnectionToOwner(IN  REFGUID guidHidden, 
                                                        OUT GUID * pguidOwner)
{
    TraceFileFunc(ttidConnectionList);
    
    INetConnectionCMUtil * pCMUtil;
    HRESULT hr = S_OK;

    hr = HrCreateInstance(
                CLSID_ConnectionManager,
                CLSCTX_LOCAL_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
                &pCMUtil);   

    if( SUCCEEDED(hr) )
    {
        // Map the hidden connection to its parent.
        //
        hr = pCMUtil->MapCMHiddenConnectionToOwner(guidHidden, pguidOwner);

        ReleaseObj(pCMUtil);
    }

    
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrUnsetCurrentDefault
//
//  Purpose:    Searches for the current default connection and clear
//				the default flag.
//
//  Arguments:
//      guidHidden   [in]   GUID of the hidden connectiod
//      pguidOwner   [out]  GUID of the parent connectiod
//
//  Returns:    S_OK -- mapped the hidden connection to its parent
//
//  Author:     deonb   4 Apr 2001
//
//  Notes:
//
HRESULT CConnectionList::HrUnsetCurrentDefault(OUT PCONFOLDPIDL& cfpPreviousDefault)
{
    HRESULT hr = S_FALSE;

    AcquireLock();

    ConnListCore::iterator  clcIter;

    // Iterate through the list and search for the old default connection.
    //
    for (clcIter = m_pcclc->begin(); clcIter != m_pcclc->end(); clcIter++)
    {
        ConnListEntry &cle = clcIter->second;
        if (!cle.ccfe.empty())
        {
            if (cle.ccfe.GetCharacteristics() & NCCF_DEFAULT)
            {
                cle.ccfe.SetCharacteristics(cle.ccfe.GetCharacteristics() & ~NCCF_DEFAULT);
                hr = cle.ccfe.ConvertToPidl(cfpPreviousDefault);
                break;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    ReleaseLock();

    return hr;
}



//+---------------------------------------------------------------------------
//
//  Function:   HrHasActiveIncomingConnections
//
//  Purpose:    See if there are active incoming connections active (apart from
//              the RAS server).
//
//  Arguments:  pdwCount   [out]   Number of incoming connections
//
//  Returns:    S_OK    -- Has active incoming connections 
//              S_FALSE -- Does not have active incoming connections 
//              FAILED(HRESULT) if failed
//
//  Author:     deonb   24 Apr 2001
//
//  Notes:
//
HRESULT CConnectionList::HasActiveIncomingConnections(OUT LPDWORD pdwCount)
{
    HRESULT hr = S_FALSE;

    Assert(pdwCount);
    *pdwCount = 0;

    AcquireLock();

    ConnListCore::const_iterator  clcIter;
    BOOL bRasServer = FALSE;

    // Iterate through the list and search for the old default connection.
    //
    for (clcIter = m_pcclc->begin(); clcIter != m_pcclc->end(); clcIter++)
    {
        const ConnListEntry &cle = clcIter->second;
        if (!cle.ccfe.empty())
        {
            if (cle.ccfe.GetCharacteristics() & NCCF_INCOMING_ONLY)
            {
                if (cle.ccfe.GetNetConMediaType() == NCM_NONE)
                {
                    AssertSz(!bRasServer, "How did you get more than one RAS Server?");
                    bRasServer = TRUE;
                }
                else
                {
                    (*pdwCount)++;
                }
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    ReleaseLock();

    if (SUCCEEDED(hr))
    {
        if (*pdwCount)
        {
            AssertSz(bRasServer, "How did you get Incoming Connections without a RAS Server?")
            hr = S_OK;
        }
        else
        {
            hr = S_FALSE;
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrCheckForActivation
//
//  Purpose:    Check to see if this connection is in the process of
//              activating (so we can disallow delete/rename/etc.).
//
//  Arguments:
//      pccfe        [in]   ConFoldEntry to check
//      pfActivating [out]  Return pointer for activating yes/no
//
//  Returns:    S_OK on success, S_FALSE if connection not found, or
//              any upstream error code.
//
//  Author:     jeffspr   4 Jun 1998
//
//  Notes:
//
HRESULT HrCheckForActivation(
    IN  const PCONFOLDPIDL& pcfp,
    IN  const CONFOLDENTRY& pccfe,
    OUT BOOL *          pfActivating)
{
    HRESULT         hr          = S_OK;
    ConnListEntry   cle;
    BOOL            fActivating = FALSE;

    Assert(pfActivating);
    Assert(! (pccfe.empty() && pcfp.empty()) ); // Must specify one of the two

    if (!pccfe.empty())
    {
        hr = g_ccl.HrFindConnectionByConFoldEntry(pccfe, cle);
    }
    else
    {
        hr = g_ccl.HrFindConnectionByGuid(&(pcfp->guidId), cle);
    }

    if (S_OK == hr)
    {
        fActivating = (cle.dwState & CLEF_ACTIVATING);
    }

    if (SUCCEEDED(hr))
    {
        *pfActivating = fActivating;
    }

    TraceHr(ttidError, FAL, hr, (S_FALSE == hr), "HrCheckForActivation");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrSetActivationFlag
//
//  Purpose:    Set the activation flag for a particular connection
//
//  Arguments:
//      pcfp        [in]    Either this pidl or the pconfoldentry below
//      pccfe       [in]    must be valid.
//      fActivating [out]   Current activation status
//
//  Returns:
//
//  Author:     jeffspr   5 Jun 1998
//
//  Notes:
//
HRESULT HrSetActivationFlag(
    IN  const PCONFOLDPIDL& pcfp,
    IN  const CONFOLDENTRY& pccfe,
    IN  BOOL            fActivating)
{
    HRESULT         hr          = S_OK;
    ConnListEntry   cle;

    // If the pccfe is valid, use that. Otherwise, use the guid from the pidl
    //
#ifdef DBG
    if (FIsDebugFlagSet(dfidTraceFileFunc))
    {
        TraceTag(ttidConnectionList, "Acquiring LOCK: %s, %s, %d", __FUNCTION__, __FILE__, __LINE__); 
    }
#endif
    g_ccl.AcquireWriteLock();

    if (!pccfe.empty())
    {
        hr = g_ccl.HrFindConnectionByConFoldEntry(pccfe, cle);
    }
    else
    {
        Assert(!pcfp.empty());
        hr = g_ccl.HrFindConnectionByGuid(&(pcfp->guidId), cle);
    }

    if (S_OK == hr)
    {
        // Assert that the state isn't already set this way.
        //
//        Assert((!!(cle.dwState & CLEF_ACTIVATING)) != fActivating);

        if (fActivating)
        {
            cle.dwState |= CLEF_ACTIVATING;
        }
        else
        {
            cle.dwState &= ~CLEF_ACTIVATING;
        }
        g_ccl.HrUpdateConnectionByGuid(&(cle.ccfe.GetGuidID()), cle);
    }
#ifdef DBG
if (FIsDebugFlagSet(dfidTraceFileFunc))
{
    TraceTag(ttidConnectionList, "Releasing LOCK: %s, %s, %d", __FUNCTION__, __FILE__, __LINE__); 
}
#endif
    g_ccl.ReleaseWriteLock();

    TraceHr(ttidError, FAL, hr, (S_FALSE == hr), "HrSetActivationFlag");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrGetTrayIconLock
//
//  Purpose:    Get a lock for the tray icon -- keeps us from getting
//              duplicate icons in the tray if two enumerations are occurring
//              simultaneously
//
//  Arguments:
//      pguid [in] Item for which to set the lock
//
//  Returns:    S_OK if the lock could be set. S_FALSE otherwise.
//
//  Author:     jeffspr   23 Oct 1998
//
//  Notes:
//
HRESULT HrGetTrayIconLock(
    IN  const GUID *    pguid,
    OUT UINT *          puiIcon,
    OUT LPDWORD pdwLockingThreadId)
{
    HRESULT         hr          = S_OK;
    ConnListEntry   cle;

    Assert(pguid);
    // Otherwise, use the guid from the pidl
    //
    TraceTag(ttidSystray, "Acquiring Tray icon lock"); 

    g_ccl.AcquireWriteLock();
    
    hr = g_ccl.HrFindConnectionByGuid(pguid, cle);
    if (S_OK == hr)
    {
        if (cle.dwState & CLEF_TRAY_ICON_LOCKED)
        {
            hr = S_FALSE;
#ifdef DBG
// if (pdwLockingThreadId)
{
    Assert(cle.dwLockingThreadId);
    *pdwLockingThreadId = cle.dwLockingThreadId;
}
#endif
        }
        else
        {
            cle.dwState |= CLEF_TRAY_ICON_LOCKED;
#ifdef DBG
            cle.dwLockingThreadId = GetCurrentThreadId();
#endif
            if (puiIcon)
            {
                if (cle.HasTrayIconData())
                {
                    *puiIcon = cle.GetTrayIconData()->GetTrayIconId();
                }
                else
                {
                    *puiIcon = BOGUS_TRAY_ICON_ID;
                }
            }
            g_ccl.HrUpdateConnectionByGuid(pguid, cle);
            Assert(cle.dwLockingThreadId);
        }
    }
    else
    {
        hr = E_FILE_NOT_FOUND;
    }

    g_ccl.ReleaseWriteLock();

    TraceHr(ttidError, FAL, hr, (S_FALSE == hr), "HrGetTrayIconLock");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   ReleaseTrayIconLock
//
//  Purpose:    Release a lock (if held) on a particular tray icon
//
//  Arguments:
//      pguid [in]  Item for which to release the lock
//
//  Returns:
//
//  Author:     jeffspr   23 Oct 1998
//
//  Notes:
//
VOID ReleaseTrayIconLock(
    IN const GUID *  pguid) throw()
{
    HRESULT         hr          = S_OK;
    ConnListEntry   cle;

    g_ccl.AcquireWriteLock();
    Assert(pguid);

    hr = g_ccl.HrFindConnectionByGuid(pguid, cle);
    if (S_OK == hr)
    {
        // Ignore whether or not this flag has already been removed.
        //
        cle.dwState &= ~CLEF_TRAY_ICON_LOCKED;
#ifdef DBG
        cle.dwLockingThreadId = 0;
#endif
        g_ccl.HrUpdateConnectionByGuid(pguid, cle);
    }

    g_ccl.ReleaseWriteLock();
    
    TraceTag(ttidSystray, "Releasing Tray icon lock"); 
    
    TraceHr(ttidError, FAL, hr, (S_FALSE == hr), "ReleaseTrayIconLock");
}

ConnListEntry::ConnListEntry() throw() : dwState(0), m_pTrayIconData(NULL), pctmd(NULL), pcbi(NULL)
{
    TraceFileFunc(ttidConnectionList);
    m_CreationTime = GetTickCount();
#ifdef DBG
    dwLockingThreadId = 0;
#endif
}

ConnListEntry::ConnListEntry(const ConnListEntry& ConnectionListEntry) throw()
{
    TraceFileFunc(ttidConnectionList);

#ifdef DBG
    dwLockingThreadId = ConnectionListEntry.dwLockingThreadId;
#endif

    m_CreationTime  = ConnectionListEntry.m_CreationTime;
    
    dwState         = ConnectionListEntry.dwState;
    ccfe            = ConnectionListEntry.ccfe;
    if (ConnectionListEntry.HasTrayIconData())
    {
        m_pTrayIconData = new CTrayIconData(*ConnectionListEntry.GetTrayIconData());
    }
    else
    {
        m_pTrayIconData = NULL;
    }
    pctmd         = ConnectionListEntry.pctmd;
    pcbi          = ConnectionListEntry.pcbi;
}

ConnListEntry& ConnListEntry::operator =(const ConnListEntry& ConnectionListEntry)
{
    TraceFileFunc(ttidConnectionList);

    m_CreationTime  = ConnectionListEntry.m_CreationTime;

#ifdef DBG
    dwLockingThreadId = ConnectionListEntry.dwLockingThreadId;
#endif
    dwState         = ConnectionListEntry.dwState;
    ccfe            = ConnectionListEntry.ccfe;

    if (ConnectionListEntry.HasTrayIconData())
    {
        if (m_pTrayIconData)
        {
            delete m_pTrayIconData;
            m_pTrayIconData = NULL;
        }
        m_pTrayIconData = new CTrayIconData(*ConnectionListEntry.GetTrayIconData());
    }
    else
    {
        if (m_pTrayIconData)
        {
            delete m_pTrayIconData;
            m_pTrayIconData = NULL;
        }
        else
        {
            m_pTrayIconData = NULL;
        }
    }
    pctmd         = ConnectionListEntry.pctmd;
    pcbi          = ConnectionListEntry.pcbi;
    return *this;
}

ConnListEntry::~ConnListEntry()
{
    TraceFileFunc(ttidConnectionList);
    
    delete m_pTrayIconData;
    m_pTrayIconData = NULL;
}

void CConnectionList::AcquireWriteLock() throw()
{

    EnterCriticalSection(&m_csWriteLock);
#ifdef DBG
    m_dwWriteLockRef++;
    TraceTag(ttidConnectionList, "CConnectionList::AcquireWriteLock (%d)", m_dwWriteLockRef);
#endif
}

void CConnectionList::ReleaseWriteLock() throw()
{
#ifdef DBG
    m_dwWriteLockRef--;
    TraceTag(ttidConnectionList, "CConnectionList::ReleaseWriteLock (%d)", m_dwWriteLockRef);
#endif
    LeaveCriticalSection(&m_csWriteLock);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\shell\folder\cmdtable.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       C M D T A B L E . H 
//
//  Contents:   Command-table code -- determines which menu options are 
//              available by the selection count, among other criteria  
//
//  Notes:      
//
//  Author:     jeffspr   28 Jan 1998
//
//----------------------------------------------------------------------------

#pragma once
#include "ncperms.h"

//---[ Constants ]------------------------------------------------------------
#define CMIDM_SEPARATOR 0xffffffff

typedef enum tagNETCON_MEDIATYPE_BM
{
    NBM_ANY     = 0xFFFFFFFF,
    NBM_NOMEDIATYPE = 0,
    NBM_MNC_WIZARD  = 0x80000000,
    NBM_HNW_WIZARD  = 0x40000000,
    NBM_INCOMING= 1 << NCM_NONE,
    NBM_DIRECT  = 1 << NCM_DIRECT,
    NBM_ISDN    = 1 << NCM_ISDN,
    NBM_LAN     = 1 << NCM_LAN,
    NBM_PHONE   = 1 << NCM_PHONE,
    NBM_TUNNEL    = 1 << NCM_TUNNEL,
    NBM_PPPOE    = 1 << NCM_PPPOE,
    NBM_BRIDGE    = 1 << NCM_BRIDGE,
    NBM_SHAREDACCESSHOST_LAN    = 1 << NCM_SHAREDACCESSHOST_LAN,
    NBM_SHAREDACCESSHOST_RAS    = 1 << NCM_SHAREDACCESSHOST_RAS,

    NBM_ISLANTYPE = NBM_LAN | NBM_BRIDGE,
    NBM_ISRASTYPE = NBM_ISDN | NBM_DIRECT | NBM_PHONE | NBM_TUNNEL | NBM_PPPOE,
    NBM_ISCONNECTIONTYPE = NBM_ISLANTYPE | NBM_ISRASTYPE,

    NBM_NOTWIZARD = ~(NBM_MNC_WIZARD | NBM_HNW_WIZARD)
} NETCON_MEDIATYPE_BM;

typedef enum tagNETCON_STATUS_BM
{
    NBS_ANY     = 0xFFFFFFFF,
    NBS_NONE                    = 0,
    NBS_DISCONNECTED            = 1 << NCS_DISCONNECTED,
    NBS_CONNECTING              = 1 << NCS_CONNECTING,
    NBS_CONNECTED               = 1 << NCS_CONNECTED,
    NBS_DISCONNECTING           = 1 << NCS_DISCONNECTING,
    NBS_HARDWARE_NOT_PRESENT    = 1 << NCS_HARDWARE_NOT_PRESENT,
    NBS_HARDWARE_DISABLED       = 1 << NCS_HARDWARE_DISABLED,
    NBS_HARDWARE_MALFUNCTION    = 1 << NCS_HARDWARE_MALFUNCTION,
    NBS_MEDIA_DISCONNECTED      = 1 << NCS_MEDIA_DISCONNECTED,
    NBS_AUTHENTICATING          = 1 << NCS_AUTHENTICATING,
    NBS_AUTHENTICATION_SUCCEEDED= 1 << NCS_AUTHENTICATION_SUCCEEDED,
    NBS_AUTHENTICATION_FAILED   = 1 << NCS_AUTHENTICATION_FAILED,
    NBS_INVALID_ADDRESS         = 1 << NCS_INVALID_ADDRESS,
    NBS_CREDENTIALS_REQUIRED    = 1 << NCS_CREDENTIALS_REQUIRED,

    NBS_NOT_DISCONNECTED        = NBS_ANY & ~NBS_DISCONNECTED,
    NBS_NOT_DISCONNECT          = NBS_CONNECTED | NBS_MEDIA_DISCONNECTED | NBS_INVALID_ADDRESS | NBS_AUTHENTICATING | NBS_AUTHENTICATION_SUCCEEDED | NBS_AUTHENTICATION_FAILED | NBS_CREDENTIALS_REQUIRED,
    NBS_HW_ISSUE                = NBS_HARDWARE_NOT_PRESENT | NBS_HARDWARE_DISABLED | NBS_HARDWARE_MALFUNCTION,
    NBS_IS_CONNECTED            = NBS_CONNECTED | NBS_AUTHENTICATION_SUCCEEDED | NBS_AUTHENTICATION_FAILED | NBS_AUTHENTICATING | NBS_CREDENTIALS_REQUIRED
} NETCON_STATUS_BM;

const DWORD64 NBPERM_NewConnectionWizard           = 1 << NCPERM_NewConnectionWizard;
const DWORD64 NBPERM_Statistics                    = 1 << NCPERM_Statistics;
const DWORD64 NBPERM_AddRemoveComponents           = 1 << NCPERM_AddRemoveComponents;
const DWORD64 NBPERM_RasConnect                    = 1 << NCPERM_RasConnect;
const DWORD64 NBPERM_LanConnect                    = 1 << NCPERM_LanConnect;
const DWORD64 NBPERM_DeleteConnection              = 1 << NCPERM_DeleteConnection;
const DWORD64 NBPERM_DeleteAllUserConnection       = 1 << NCPERM_DeleteAllUserConnection;
const DWORD64 NBPERM_RenameConnection              = 1 << NCPERM_RenameConnection;
const DWORD64 NBPERM_RenameMyRasConnection         = 1 << NCPERM_RenameMyRasConnection;
const DWORD64 NBPERM_ChangeBindState               = 1 << NCPERM_ChangeBindState;
const DWORD64 NBPERM_AdvancedSettings              = 1 << NCPERM_AdvancedSettings;
const DWORD64 NBPERM_DialupPrefs                   = 1 << NCPERM_DialupPrefs;
const DWORD64 NBPERM_LanChangeProperties           = 1 << NCPERM_LanChangeProperties;
const DWORD64 NBPERM_RasChangeProperties           = 1 << NCPERM_RasChangeProperties;
const DWORD64 NBPERM_LanProperties                 = 1 << NCPERM_LanProperties;
const DWORD64 NBPERM_RasMyProperties               = 1 << NCPERM_RasMyProperties;
const DWORD64 NBPERM_RasAllUserProperties          = 1 << NCPERM_RasAllUserProperties;
const DWORD64 NBPERM_ShowSharedAccessUi            = 1 << NCPERM_ShowSharedAccessUi;
const DWORD64 NBPERM_AllowAdvancedTCPIPConfig      = 1 << NCPERM_AllowAdvancedTCPIPConfig;
const DWORD64 NBPERM_OpenConnectionsFolder         = 1 << NCPERM_OpenConnectionsFolder;
const DWORD64 NBPERM_PersonalFirewallConfig        = 1 << NCPERM_PersonalFirewallConfig;
const DWORD64 NBPERM_AllowNetBridge_NLA            = 1 << NCPERM_AllowNetBridge_NLA;
const DWORD64 NBPERM_ICSClientApp                  = 1 << NCPERM_ICSClientApp;
const DWORD64 NBPERM_EnDisComponentsAllUserRas     = 1 << NCPERM_EnDisComponentsAllUserRas;
const DWORD64 NBPERM_EnDisComponentsMyRas          = 1 << NCPERM_EnDisComponentsMyRas;
const DWORD64 NBPERM_ChangeMyRasProperties         = 1 << NCPERM_ChangeMyRasProperties;
const DWORD64 NBPERM_ChangeAllUserRasProperties    = 1 << NCPERM_ChangeAllUserRasProperties;
const DWORD64 NBPERM_RenameLanConnection           = 1 << NCPERM_RenameLanConnection;
const DWORD64 NBPERM_RenameAllUserRasConnection    = 1 << NCPERM_RenameAllUserRasConnection;
const DWORD64 NBPERM_IpcfgOperation                = 1 << NCPERM_IpcfgOperation;
const DWORD64 NBPERM_Repair                        = 1 << NCPERM_Repair;
const DWORD64 NBPERM_Always                        = 0x00000000;

typedef enum tagNB_MENUVALID
{
    NCWHEN_ANYSELECT    = 0xFFFFFFFF,
    NCWHEN_TOPLEVEL     = 1,
    NCWHEN_ONESELECT    = 2,
    NCWHEN_MULTISELECT  = 4,
    NCWHEN_TOPLEVEL_DISREGARD_ITEM  = 8,
    NCWHEN_SOMESELECT   = NCWHEN_ONESELECT | NCWHEN_MULTISELECT
} NB_MENUVALID;

typedef enum tagNCCS_STATE
{
    NCCS_ENABLED  = 1,
    NCCS_DISABLED = 2,
    NCCS_NOTSHOWN = 3
} NCCS_STATE;

typedef enum tagNCCS_CHECKED_STATE
{
    NCCS_UNCHECKED = 0,
    NCCS_CHECKED   = 1
} NCCS_CHECKED_STATE;

typedef enum tagNB_REMOVEDISABLE
{
    NB_NO_FLAGS       = 0x0,

    NB_NEGATE_VIS_NBM_MATCH   = 0x1,
    NB_NEGATE_VIS_NBS_MATCH   = 0x2,
    NB_NEGATE_VIS_CHAR_MATCH  = 0x4,
    NB_NEGATE_VIS_PERMS_MATCH = 0x8,

    NB_NEGATE_ACT_NBM_MATCH   = 0x10,
    NB_NEGATE_ACT_NBS_MATCH   = 0x20,
    NB_NEGATE_ACT_CHAR_MATCH  = 0x40,
    NB_NEGATE_ACT_PERMS_MATCH = 0x80,
    
    NB_VERB                   = 0x100,
    NB_FLAG_ON_TOPMENU        = 0x1000,
    NB_TOPLEVEL_PERM          = 0x2000, // perms only
    NB_REMOVE_IF_NOT_MATCH    = 0x4000, // perms only

    NB_REMOVE_TOPLEVEL_ITEM   = 0x8000, // applies to top-level items only. WARNING: Permanent effect. 
                                        // Use this only for something that cannot change inside the same user session.

    NB_REVERSE_TOPLEVEL_ITEM  = 0x10000, // applies to top-level items only. WARNING: Permanent effect. 
                                        // Use this only for something that cannot change inside the same user session.

    NB_NEGATE_NBM_MATCH   = NB_NEGATE_VIS_NBM_MATCH   | NB_NEGATE_ACT_NBM_MATCH,
    NB_NEGATE_NBS_MATCH   = NB_NEGATE_VIS_NBS_MATCH   | NB_NEGATE_ACT_NBS_MATCH,
    NB_NEGATE_CHAR_MATCH  = NB_NEGATE_VIS_CHAR_MATCH  | NB_NEGATE_ACT_CHAR_MATCH,
    NB_NEGATE_PERMS_MATCH = NB_NEGATE_VIS_PERMS_MATCH | NB_NEGATE_ACT_PERMS_MATCH
} NB_REMOVEDISABLE;

struct CMDCHKENTRY
{
    int  iCommandId;        // Associated command ID
    bool fCurrentlyChecked; // Is this menu item already checked? 
    bool fNewCheckState;    // What's the new check state?        
};

// If this function returns S_FALSE it's an indication it didn't change the state.
typedef HRESULT (HrEnableDisableCB)(
    IN    const CConFoldEntry& cfe,
    IN    BOOL                 fMultiSelect,
    IN    int                  iCommandId,
    OUT   NCCS_STATE&          nccs
    );

// If this function returns S_FALSE it's an indication to use Default string
typedef HRESULT (HrCustomMenuStringCB)(
    IN    const CConFoldEntry& cfe,
    IN    int                  iCommandId,
    OUT   LPDWORD              pdwResourceId
    );

// Implementations of HrEnableDisableCB/HrCustomMenuStringCB
//HrEnableDisableCB    HrDisableForIncomingClients;
HrEnableDisableCB    HrCanRenameConnection;
HrEnableDisableCB    HrCanShowProperties;
HrEnableDisableCB    HrIsBridgeSupported;
HrEnableDisableCB    HrIsHomeNewWizardSupported;
HrEnableDisableCB    HrIsTroubleShootSupported;
HrEnableDisableCB    HrIsMediaWireless;
HrEnableDisableCB    HrIsNCWSupported;

struct COMMANDENTRY
{
    int     iCommandId;
    DWORD   dwDefaultPriority;   // The highest item that's visible+active will be the default. 0 item will never be selected.
    DWORD   dwValidWhen;         // NB_MENUVALID     flags
    DWORD   dwFlags;             // NB_REMOVEDISABLE flags (disabled unless specified in this flags - then removed).

    HrEnableDisableCB    *pfnHrEnableDisableCB;    // Callback function. Return S_FALSE to leave alone
    HrCustomMenuStringCB *pfnHrCustomMenuStringCB; // Callback function. Return S_FALSE/E_ to leave alone, or S_OK with a dwResourceID

    DWORD   dwMediaTypeVisible;   // NETCON_MEDIATYPE_BM flags
    DWORD   dwMediaTypeActive;    // NETCON_MEDIATYPE_BM flags

    DWORD   dwStatusVisible;      // NETCON_STATUS_BM flags  
    DWORD   dwStatusActive;       // NETCON_STATUS_BM flags 

    DWORD   dwCharacteristicsVisible; // NCCF_ flags
    DWORD   dwCharacteristicsActive;  // NCCF_ flags
};

struct COMMANDPERMISSIONSENTRY
{
    int     iCommandId;
    DWORD   dwMediaType;
    DWORD   dwCharacteristicsActive;
    DWORD   dwFlags;             // NB_REMOVEDISABLE flags (disabled unless specified in this flags - then removed).

    DWORD64 dwPermissionsActive;  // e.g. NBPERM_NewConnectionWizard - NBPERM_Always for always enabled
    NCPERM_APPLY_TO ncpAppliesTo;
};

struct SFVCOMMANDMAP
{
    int     iSFVCommandId;
    int     iCommandId;
};

extern COMMANDENTRY g_cteCommandMatrix[];
extern const DWORD g_cteCommandMatrixCount;

//---[ Prototypes ]-----------------------------------------------------------

HRESULT HrBuildMenu(IN OUT HMENU &hMenu, IN BOOL fVerbsOnly, IN PCONFOLDPIDLVEC& cfpl, IN DWORD idCmdFirst);
HRESULT HrUpdateMenu(IN OUT HMENU &hMenu, IN PCONFOLDPIDLVEC& cfpl, IN DWORD idCmdFirst);

HRESULT HrAssertTwoMenusEqual(IN HMENU hMenu1, IN HMENU hMenu2, IN UINT idCmdFirst, IN BOOL bIgnoreFlags, IN BOOL fPopupAsserts);

HRESULT HrAssertMenuStructuresValid(IN HWND hwndOwner);
HRESULT HrGetCommandState(IN const PCONFOLDPIDLVEC& cfpl, IN const DWORD dwCmdID, OUT NCCS_STATE& nccs, OUT LPDWORD dwResourceId, IN DWORD cteHint = 0xffffffff, IN DWORD dwOverrideFlag = 0);
BOOL    HasPermissionToRenameConnection(IN const PCONFOLDPIDL& pcfp);

HRESULT HrSetConnectDisconnectMenuItem(
    IN     const PCONFOLDPIDLVEC& apidlSelected, 
    IN OUT HMENU           hmenu,
    IN     INT             idCmdFirst);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\shell\folder\cmdtable.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       C M D T A B L E . C P P
//
//  Contents:   Command-table code -- determines which menu options are
//              available by the selection count, among other criteria
//
//  Notes:
//
//  Author:     jeffspr   28 Jan 1998
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "foldinc.h"    // Standard shell\folder includes
#include "foldres.h"    // Folder resource IDs
#include "nsres.h"      // Netshell strings
#include "cmdtable.h"   // Header for this file
#include "ncperms.h"    // For checking User's rights on actions/menu items
#include "cfutils.h"
#include "hnetcfg.h"
#include "lm.h"

//---[ Constants ]------------------------------------------------------------

const DWORD NCCF_ALL      = 0xffffffff; // NCCF_ALL      - For all Characteristics
const DWORD S_REMOVE = 2;
#define TRACESTRLEN 65535


// Active must be a subset of Visible (Opening connections folder using a CHK DLL asserts integrity of table).
// DO NOT use NCM_ and NCS_ flags in this table!!! You should use NBM_ and NBS_ flags over here.
COMMANDENTRY g_cteCommandMatrix[] =
{
    //iCommandId    dwDefaultPriority             dwFlags                HrEnableDisableCB HrCustomMenuStringCB
    // |                      |  dwValidWhen         |                           |           |
    // |                      |    |                 | dwMediaTypeVisible        |           |  dwMediaTypeActive
    // |                      |    |                 | dwStatusVisible           |           |  dwStatusActive
    // |                      |    |                 | dwCharacteristicsVisible  |           |  dwCharacteristicsActive
    // |                      |    |                 |  (VISIBLE)                |           |  (ACTIVE... (NOT REMOVED))
    // v                      v    v                 v     |                     v           v    |
    //                                                     v                                      v
    { CMIDM_HOMENET_WIZARD,   5, NCWHEN_ANYSELECT,  NB_REMOVE_TOPLEVEL_ITEM,HrIsHomeNewWizardSupported, NULL,
                                                          NBM_HNW_WIZARD,                    NBM_HNW_WIZARD,            // Media Type
                                                          NBS_ANY,                           NBS_ANY,                   // Status
                                                          NCCF_ALL,                          NCCF_ALL},                 // Characteristics

    { CMIDM_NET_TROUBLESHOOT, 5, NCWHEN_TOPLEVEL,   NB_REMOVE_TOPLEVEL_ITEM,HrIsTroubleShootSupported,  NULL,
                                                          NBM_NOMEDIATYPE,                   NBM_NOMEDIATYPE,           // Media Type
                                                          NBS_NONE,                          NBS_NONE,                  // Status
                                                          NCCF_ALL,                          NCCF_ALL},                 // Characteristics

    { CMIDM_CONMENU_ADVANCED_CONFIG,  
                              5, NCWHEN_TOPLEVEL,   NB_NO_FLAGS,                       NULL,  NULL,
                                                    NBM_NOMEDIATYPE,                   NBM_NOMEDIATYPE,           // Media Type
                                                    NBS_NONE,                          NBS_NONE,                  // Status
                                                    NCCF_ALL,                          NCCF_ALL},                 // Characteristics

    { CMIDM_CONMENU_DIALUP_PREFS,  
                              5, NCWHEN_TOPLEVEL,
                                                    NB_NO_FLAGS,                       NULL,  NULL,
                                                    NBM_NOMEDIATYPE,                   NBM_NOMEDIATYPE,           // Media Type
                                                    NBS_NONE,                          NBS_NONE,                  // Status
                                                    NCCF_ALL,                          NCCF_ALL},                 // Characteristics
    
    { CMIDM_NEW_CONNECTION,   5, NCWHEN_ANYSELECT,  NB_VERB,                    HrIsNCWSupported, NULL,
                                                          NBM_MNC_WIZARD,                    NBM_MNC_WIZARD,                // Media Type
                                                          NBS_ANY,                           NBS_ANY,                   // Status
                                                          NCCF_ALL,                          NCCF_ALL},                 // Characteristics

    { CMIDM_CONNECT,          3, NCWHEN_ONESELECT,  NB_VERB,                    NULL,        NULL,
                                                          NBM_SHAREDACCESSHOST_RAS | NBM_ISRASTYPE, NBM_SHAREDACCESSHOST_RAS | NBM_ISRASTYPE, // Media Type
                                                          NBS_HW_ISSUE | NBS_DISCONNECTED | NBS_CONNECTING, NBS_DISCONNECTED,          // Status
                                                          NCCF_ALL,                          NCCF_ALL},                 // Characteristics

    { CMIDM_DISCONNECT,       0, NCWHEN_ONESELECT,  NB_VERB,                    NULL,        NULL,
                                                          NBM_SHAREDACCESSHOST_RAS|NBM_ISRASTYPE,NBM_SHAREDACCESSHOST_RAS|NBM_ISRASTYPE,             // Media Type
                                                          NBS_IS_CONNECTED | NBS_DISCONNECTING, NBS_IS_CONNECTED,             // Status
                                                          NCCF_ALL,                          NCCF_ALL},                 // Characteristics

    { CMIDM_ENABLE,           3, NCWHEN_ONESELECT,  NB_VERB,                    NULL,        NULL,
                                                          NBM_SHAREDACCESSHOST_LAN|NBM_ISLANTYPE,NBM_SHAREDACCESSHOST_LAN|NBM_ISLANTYPE,             // Media Type
                                                          NBS_HW_ISSUE | NBS_DISCONNECTED | NBS_CONNECTING,    NBS_DISCONNECTED,          // Status
                                                          NCCF_ALL,                          NCCF_ALL},                 // Characteristics

    { CMIDM_DISABLE,          0, NCWHEN_ONESELECT,  NB_VERB,                    NULL,        NULL,
                                                          NBM_SHAREDACCESSHOST_LAN|NBM_ISLANTYPE,NBM_SHAREDACCESSHOST_LAN|NBM_ISLANTYPE,             // Media Type
                                                          NBS_DISCONNECTING | NBS_IS_CONNECTED | NBS_MEDIA_DISCONNECTED | NBS_INVALID_ADDRESS,   NBS_NOT_DISCONNECT,        // Status
                                                          NCCF_ALL,                          NCCF_ALL},                 // Characteristics

    { CMIDM_WZCDLG_SHOW,      4, NCWHEN_ONESELECT,  NB_VERB,                    HrIsMediaWireless, NULL,
                                                          NBM_LAN,                           NBM_LAN,                  // Media Type
                                                          NBS_NOT_DISCONNECT,                NBS_NOT_DISCONNECT, // Status
                                                          NCCF_ALL,                          NCCF_ALL},                 // Characteristics
    
    { CMIDM_STATUS,           5, NCWHEN_ONESELECT,  NB_VERB,                    NULL,        NULL,
                                                          NBM_INCOMING | NBM_SHAREDACCESSHOST_LAN|NBM_SHAREDACCESSHOST_RAS|NBM_ISCONNECTIONTYPE, NBM_INCOMING | NBM_SHAREDACCESSHOST_LAN|NBM_SHAREDACCESSHOST_RAS|NBM_ISCONNECTIONTYPE,
                                                          NBS_ANY,                           NBS_IS_CONNECTED | NBS_INVALID_ADDRESS, // Status
                                                          NCCF_ALL,                          NCCF_ALL},                 // Characteristics

    { CMIDM_FIX,              0, NCWHEN_SOMESELECT, NB_NO_FLAGS,                NULL,        NULL,
                                                          NBM_ISLANTYPE,                     NBM_ISLANTYPE,             // Media Type
                                                          NBS_IS_CONNECTED | NBS_DISCONNECTING| NBS_MEDIA_DISCONNECTED| NBS_INVALID_ADDRESS, NBS_INVALID_ADDRESS | NBS_IS_CONNECTED, // Status
                                                          NCCF_ALL,                          NCCF_ALL},                 // Characteristics

    { CMIDM_SEPARATOR,        0,0,0,0,0,  0,0,  0,0,  0,0 },

    { CMIDM_SET_DEFAULT,      0, NCWHEN_ONESELECT,  NB_NEGATE_CHAR_MATCH,  NULL,  NULL,
                                                          NBM_INCOMING | NBM_ISRASTYPE,      NBM_INCOMING | NBM_ISRASTYPE,             // Media Type
                                                          NBS_ANY,                           NBS_ANY,                   // Status
                                                          NCCF_INCOMING_ONLY | NCCF_DEFAULT, NCCF_INCOMING_ONLY | NCCF_DEFAULT}, // Characteristics

    { CMIDM_UNSET_DEFAULT,    0, NCWHEN_ONESELECT,  NB_NO_FLAGS,           NULL,  NULL,
                                                          NBM_INCOMING | NBM_ISRASTYPE,      NBM_INCOMING | NBM_ISRASTYPE,             // Media Type
                                                          NBS_ANY,                           NBS_ANY,                   // Status
                                                          NCCF_DEFAULT,                      NCCF_DEFAULT},             // Characteristics

    { CMIDM_SEPARATOR,        0,0,0,0,0,  0,0,  0,0,  0,0 },

    { CMIDM_CREATE_BRIDGE,    0, NCWHEN_ANYSELECT,   NB_NO_FLAGS,           HrIsBridgeSupported, NULL,
                                                          NBM_LAN,                           NBM_LAN,                  // Media Type
                                                          NBS_IS_CONNECTED | NBS_DISCONNECTING| NBS_MEDIA_DISCONNECTED| NBS_INVALID_ADDRESS, NBS_DISCONNECTING|NBS_IS_CONNECTED|NBS_MEDIA_DISCONNECTED|NBS_INVALID_ADDRESS, // Status
                                                          NCCF_ALL,                          NCCF_ALL   },             // Characteristics

    { CMIDM_CONMENU_CREATE_BRIDGE,0, NCWHEN_TOPLEVEL,NB_REMOVE_TOPLEVEL_ITEM,HrIsBridgeSupported,  NULL,
                                                          NBM_NOMEDIATYPE,                   NBM_NOMEDIATYPE,           // Media Type
                                                          NBS_NONE,                          NBS_NONE,                  // Status
                                                          NCCF_ALL,                          NCCF_ALL},                 // Characteristics

    { CMIDM_ADD_TO_BRIDGE,    0, NCWHEN_SOMESELECT,  NB_NEGATE_CHAR_MATCH,   HrIsBridgeSupported, NULL,
                                                          NBM_LAN,                           NBM_LAN,                  // Media Type
                                                          NBS_IS_CONNECTED | NBS_DISCONNECTING| NBS_MEDIA_DISCONNECTED| NBS_INVALID_ADDRESS, NBS_DISCONNECTING|NBS_IS_CONNECTED|NBS_MEDIA_DISCONNECTED|NBS_INVALID_ADDRESS, // Status
                                                          NCCF_BRIDGED | NCCF_FIREWALLED | NCCF_SHARED, NCCF_BRIDGED | NCCF_FIREWALLED | NCCF_SHARED   },            // Characteristics

    { CMIDM_REMOVE_FROM_BRIDGE, 0, NCWHEN_SOMESELECT,NB_NO_FLAGS,            HrIsBridgeSupported, NULL,
                                                          NBM_LAN,                           NBM_LAN,                  // Media Type
                                                          NBS_IS_CONNECTED | NBS_DISCONNECTING| NBS_MEDIA_DISCONNECTED| NBS_INVALID_ADDRESS, NBS_DISCONNECTING|NBS_IS_CONNECTED|NBS_MEDIA_DISCONNECTED|NBS_INVALID_ADDRESS, // Status
                                                          NCCF_BRIDGED,                      NCCF_BRIDGED                                              },            // Characteristics

    { CMIDM_SEPARATOR,        0,0,0,0,0,  0,0,  0,0,  0,0 },

    { CMIDM_CREATE_COPY,      0, NCWHEN_ONESELECT,   NB_NEGATE_VIS_CHAR_MATCH,  NULL,        NULL,
                                                          NBM_INCOMING | NBM_SHAREDACCESSHOST_RAS | NBM_ISRASTYPE, NBM_INCOMING | NBM_SHAREDACCESSHOST_RAS | NBM_ISRASTYPE,             // Media Type
                                                          NBS_ANY,                           NBS_ANY,                   // Status
                                                          NCCF_INCOMING_ONLY,                NCCF_ALLOW_DUPLICATION},   // Characteristics

    { CMIDM_SEPARATOR,        0,0,0,0,0,  0,0,  0,0,  0,0 },

    { CMIDM_CREATE_SHORTCUT,  0, NCWHEN_ONESELECT,   NB_NEGATE_CHAR_MATCH,      NULL,        NULL,
                                                          NBM_ANY,                           NBM_ANY,    // Media Type
                                                          NBS_ANY,                           NBS_ANY,                   // Status
                                                          NCCF_INCOMING_ONLY,                NCCF_INCOMING_ONLY},       // Characteristics

    { CMIDM_DELETE,           0, NCWHEN_SOMESELECT,  NB_NO_FLAGS,               NULL,        NULL,
                                                          NBM_NOTWIZARD,                     NBM_NOTWIZARD,           // Media Type
                                                          NBS_ANY,                           NBS_ANY,                   // Status
                                                          NCCF_ALL,                          NCCF_ALLOW_REMOVAL},       // Characteristics


    { CMIDM_RENAME,           0, NCWHEN_ONESELECT,   NB_NO_FLAGS,               HrCanRenameConnection, NULL,
                                                          NBM_NOTWIZARD,                     NBM_NOTWIZARD,            // Media Type
                                                          NBS_ANY,                           NBS_ANY,                   // Status
                                                          NCCF_ALL,                          NCCF_ALLOW_RENAME},        // Characteristics

    { CMIDM_SEPARATOR,        0,0,0,0,0,  0,0,  0,0,  0,0 },

    { CMIDM_PROPERTIES,       2, NCWHEN_ONESELECT,   NB_NO_FLAGS,               HrCanShowProperties,        NULL,
                                                          NBM_INCOMING|NBM_SHAREDACCESSHOST_LAN|NBM_SHAREDACCESSHOST_RAS|NBM_ISCONNECTIONTYPE, NBM_INCOMING|NBM_SHAREDACCESSHOST_LAN|NBM_SHAREDACCESSHOST_RAS|NBM_ISCONNECTIONTYPE,      // Media Type
                                                          NBS_ANY,                           NBS_ANY,                   // Status
                                                          NCCF_ALL,                          NCCF_ALL},                 // Characteristics
};

// What is the difference between NCCF_INCOMING_ONLY, ~NCCF_INCOMING_ONLY and NCCF_INCOMING_ONLY + NB_NEGATE_CHAR_MATCH?
// NCCF_INCOMING_ONLY | NCCF_ALLOW_REMOVAL means: NCCF_INCOMING_ONLY or NCCF_ALLOW_REMOVAL or BOTH should be set.
// ~NCCF_INCOMING_ONLY means: One or flag (irrespective of NCCF_INCOMING_ONLY flag) should be set.
// NB_NEGATE_CHAR_MATCH + NCCF_INCOMING_ONLY means: Check that NCCF_INCOMING_ONLY is not set.

const DWORD g_cteCommandMatrixCount = celems(g_cteCommandMatrix);

COMMANDPERMISSIONSENTRY g_cteCommandPermissionsMatrix[] =
{
    { CMIDM_NEW_CONNECTION, NBM_ANY,                  NCCF_ALL,           NB_TOPLEVEL_PERM | NB_REMOVE_IF_NOT_MATCH,NBPERM_NewConnectionWizard,  APPLY_TO_ALL_USERS    },
    { CMIDM_CONNECT,        NBM_ISRASTYPE,            NCCF_ALL,           NB_NO_FLAGS,         NBPERM_RasConnect,           APPLY_TO_ALL_USERS    },
    { CMIDM_CONNECT,        NBM_SHAREDACCESSHOST_RAS, NCCF_ALL,           NB_NO_FLAGS,         NBPERM_Always,               APPLY_TO_ALL_USERS    },

    { CMIDM_DISCONNECT,     NBM_ISRASTYPE,            NCCF_INCOMING_ONLY, NB_NEGATE_CHAR_MATCH,NBPERM_RasConnect,           APPLY_TO_ALL_USERS    },
    { CMIDM_DISCONNECT,     NBM_ISRASTYPE,            NCCF_INCOMING_ONLY, NB_NO_FLAGS,         NBPERM_RasConnect,           APPLY_TO_ADMIN        },
    { CMIDM_DISCONNECT,     NBM_SHAREDACCESSHOST_RAS, NCCF_ALL,           NB_NO_FLAGS,         NBPERM_Always,               APPLY_TO_ALL_USERS    },
    { CMIDM_ENABLE,         NBM_LAN,                  NCCF_ALL,           NB_NO_FLAGS,         NBPERM_LanConnect,           APPLY_TO_ALL_USERS    },

    { CMIDM_ENABLE,         NBM_SHAREDACCESSHOST_LAN, NCCF_ALL,           NB_NO_FLAGS,         NBPERM_Always,               APPLY_TO_ALL_USERS    },
    { CMIDM_ENABLE,         NBM_BRIDGE,               NCCF_ALL,           NB_NO_FLAGS,         NBPERM_AllowNetBridge_NLA,   APPLY_TO_OPS_OR_ADMIN },
    { CMIDM_DISABLE,        NBM_LAN,                  NCCF_ALL,           NB_NO_FLAGS,         NBPERM_LanConnect,           APPLY_TO_ALL_USERS },
    { CMIDM_DISABLE,        NBM_SHAREDACCESSHOST_LAN, NCCF_ALL,           NB_NO_FLAGS,         NBPERM_Always,               APPLY_TO_ALL_USERS    },
    { CMIDM_DISABLE,        NBM_BRIDGE,               NCCF_ALL,           NB_NO_FLAGS,         NBPERM_AllowNetBridge_NLA,   APPLY_TO_OPS_OR_ADMIN },

    { CMIDM_STATUS,         NBM_ANY,                  NCCF_INCOMING_ONLY, NB_NEGATE_CHAR_MATCH,NBPERM_Statistics,           APPLY_TO_ALL_USERS    },
    { CMIDM_STATUS,         NBM_ANY,                  NCCF_INCOMING_ONLY, NB_NO_FLAGS,         NBPERM_Statistics,           APPLY_TO_ADMIN        },

    { CMIDM_CREATE_BRIDGE,  NBM_ANY,                  NCCF_ALL,           NB_NO_FLAGS,         NBPERM_AllowNetBridge_NLA,   APPLY_TO_OPS_OR_ADMIN },
    { CMIDM_ADD_TO_BRIDGE,  NBM_ANY,                  NCCF_ALL,           NB_NO_FLAGS,         NBPERM_AllowNetBridge_NLA,   APPLY_TO_OPS_OR_ADMIN },
    { CMIDM_REMOVE_FROM_BRIDGE,  NBM_ANY,             NCCF_ALL,           NB_NO_FLAGS,         NBPERM_AllowNetBridge_NLA,   APPLY_TO_OPS_OR_ADMIN },

    { CMIDM_CREATE_COPY,    NBM_ANY,                  NCCF_ALL_USERS,     NB_NO_FLAGS,         NBPERM_NewConnectionWizard | NBPERM_RasAllUserProperties,  APPLY_TO_ALL_USERS    },
    { CMIDM_CREATE_COPY,    NBM_ANY,                  NCCF_ALL_USERS,     NB_NEGATE_CHAR_MATCH,NBPERM_NewConnectionWizard, APPLY_TO_ALL_USERS    },

    { CMIDM_FIX,            NBM_ANY,                  NCCF_ALL,           NB_NO_FLAGS,         NBPERM_Repair,               APPLY_TO_POWERUSERSPLUS },

    { CMIDM_DELETE,         NBM_ANY,                  NCCF_ALL_USERS,     NB_NO_FLAGS,         NBPERM_DeleteConnection | NBPERM_DeleteAllUserConnection, APPLY_TO_ALL_USERS    },
    { CMIDM_DELETE,         NBM_ANY,                  NCCF_ALL_USERS,     NB_NEGATE_CHAR_MATCH,NBPERM_DeleteConnection,     APPLY_TO_ALL_USERS    },

    { CMIDM_SET_DEFAULT,    NBM_INCOMING |
                            NBM_ISRASTYPE,            NCCF_ALL,           NB_NO_FLAGS,         NBPERM_Always,               APPLY_TO_OPS_OR_ADMIN     },
    { CMIDM_UNSET_DEFAULT,  NBM_INCOMING |
                            NBM_ISRASTYPE,            NCCF_ALL,           NB_NO_FLAGS,         NBPERM_Always,               APPLY_TO_OPS_OR_ADMIN     },

    { CMIDM_CONMENU_ADVANCED_CONFIG,
                            NBM_ANY,                  NCCF_ALL_USERS,     NB_TOPLEVEL_PERM,    NBPERM_AdvancedSettings,     APPLY_TO_ADMIN        },

    { CMIDM_CONMENU_DIALUP_PREFS,
                            NBM_ANY,                  NCCF_ALL_USERS,     NB_TOPLEVEL_PERM,    NBPERM_DialupPrefs,          APPLY_TO_ALL_USERS    },
    
    { CMIDM_PROPERTIES,     NBM_INCOMING,             NCCF_ALL,           NB_NO_FLAGS,         NBPERM_Always,               APPLY_TO_ADMIN        },
    { CMIDM_PROPERTIES,     NBM_ISRASTYPE,            NCCF_ALL_USERS,     NB_NEGATE_CHAR_MATCH,NBPERM_RasMyProperties,      APPLY_TO_ALL_USERS    },
    { CMIDM_PROPERTIES,     NBM_ISRASTYPE,            NCCF_ALL_USERS,     NB_NO_FLAGS,         NBPERM_RasAllUserProperties, APPLY_TO_ALL_USERS    },
    { CMIDM_PROPERTIES,     NBM_LAN,                  NCCF_ALL,           NB_NO_FLAGS,         NBPERM_LanProperties,        APPLY_TO_ALL_USERS    }
};

const DWORD g_cteCommandPermissionsMatrixCount = celems(g_cteCommandPermissionsMatrix);

SFVCOMMANDMAP g_cteSFVCommandMap[] =
{
    { SFVIDM_FILE_DELETE,       CMIDM_DELETE},
    { SFVIDM_FILE_LINK,         CMIDM_CREATE_SHORTCUT},
    { SFVIDM_FILE_PROPERTIES,   CMIDM_PROPERTIES},
    { SFVIDM_FILE_RENAME,       CMIDM_RENAME}
};

const DWORD g_cteSFVCommandMapCount = celems(g_cteSFVCommandMap);

CMDCHKENTRY  g_cceFolderChecks[] =
{
    // command id
    //                                  currently checked
    //                                   |      new check state
    //                                   |       |
    //                                   v       v
    { CMIDM_CONMENU_OPERATOR_ASSIST,    false,  false }
};

const DWORD g_nFolderCheckCount = celems(g_cceFolderChecks);

inline DWORD dwNegateIf(IN DWORD dwInput, IN DWORD dwFlags, IN DWORD dwNegateCondition)
{
    if (dwFlags & dwNegateCondition)
    {
        return ~dwInput;
    }
    else
    {
        return dwInput;
    }
}

inline BOOL bContains(IN DWORD dwContainee, 
                      IN DWORD dwContainer, 
                      IN DWORD dwFlags, 
                      IN DWORD dwContaineeNegateCondition, 
                      IN DWORD dwContainerNegateCondition)
{
    dwContainer = dwNegateIf(dwContainer, dwFlags, dwContainerNegateCondition);
    dwContainee = dwNegateIf(dwContainee, dwFlags, dwContaineeNegateCondition);

    if ( (dwContainee & dwContainer) != dwContainee)
    {
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     HrAssertIntegrityAgainstOldMatrix
//
//  Purpose:    Asserts the internal integrity of the Command Matrix
//              Currently checks for:
//                1. No duplicate CMDIDs
//                2. Each NCWHEN flag at least specified NCWHEN_ONESELECT
//
//  Arguments:
//      none
//
//  Returns:
//              S_OK is succeeded
//              E_FAIL if not
//
//  Author:     deonb   8 Feb 2001
//
//  Notes:      Asserts on failure
//
HRESULT HrAssertCommandMatrixIntegrity()
{
    TraceFileFunc(ttidMenus);

    HRESULT hr = S_OK;

    LPSTR szErr = new CHAR[TRACESTRLEN];
    for (DWORD x = 0; x < g_cteCommandMatrixCount; x++)
    {
        // Check that there isn't another entry with the same CommandID and Media Type.
        const COMMANDENTRY& cte = g_cteCommandMatrix[x];
        if (CMIDM_SEPARATOR == cte.iCommandId)
        {
            continue;
        }

        for (DWORD y = x + 1; y < g_cteCommandMatrixCount; y++)
        {
            const COMMANDENTRY& ctecmp = g_cteCommandMatrix[y];
            if (cte.iCommandId == ctecmp.iCommandId)
            {
                sprintf(szErr, "Multiple lines (%d and %d) in the COMMANDENTRY table describe the same CmdID", x+1, y+1);
                AssertSz(FALSE, szErr);
                hr = E_FAIL;
            }
        }

        if ( !bContains(cte.dwCharacteristicsActive, cte.dwCharacteristicsVisible, cte.dwFlags, NB_NEGATE_ACT_CHAR_MATCH, NB_NEGATE_VIS_CHAR_MATCH) )
        {
            sprintf(szErr, "Row %d. ACTIVE flags not a subset of VISIBLE flags for Characteristics? ", x+1);
            AssertSz(FALSE, szErr);
            hr = E_FAIL;
        }

        if ( !bContains(cte.dwStatusActive, cte.dwStatusVisible, cte.dwFlags, NB_NEGATE_ACT_NBS_MATCH, NB_NEGATE_VIS_NBS_MATCH) )
        {
            sprintf(szErr, "Row %d. ACTIVE flags not a subset of VISIBLE flags for Status... did you use NCS_ instead of NBM_? ", x+1);
            AssertSz(FALSE, szErr);
            hr = E_FAIL;
        }

        if ( !bContains(cte.dwMediaTypeActive, cte.dwMediaTypeVisible, cte.dwFlags, NB_NEGATE_ACT_NBM_MATCH, NB_NEGATE_VIS_NBM_MATCH) )
        {
            sprintf(szErr, "Row %d. ACTIVE flags not a subset of VISIBLE flags for MediaType... did you use NCM_ instead of NBM_? ", x+1);
            AssertSz(FALSE, szErr);
            hr = E_FAIL;
        }
    }

    // Assert the permissions table
    for (x = 0; x < g_cteCommandPermissionsMatrixCount; x++)
    {
        const COMMANDPERMISSIONSENTRY cpe = g_cteCommandPermissionsMatrix[x];

        // Check that each CMD entry has a corresponding entry in the Command Table
        BOOL bFound = FALSE;
        for (DWORD y = 0; y < g_cteCommandMatrixCount; y++)
        {
            const COMMANDENTRY& ctecmp = g_cteCommandMatrix[y];

            if (cpe.iCommandId == ctecmp.iCommandId)
            {
                bFound = TRUE;
                if ( (cpe.dwMediaType != NBM_ANY) &&
                     ((cpe.dwMediaType & ctecmp.dwMediaTypeActive) != cpe.dwMediaType) )
                {
                    sprintf(szErr, "A permission has been specified in the Permissions table (row %d) for a MediaType that is not active in the Command Table (row %d)... did you use NCM_ instead of NBM_?", x+1, y+1);
                    AssertSz(FALSE, szErr);
                    hr = E_FAIL;
                }
//                if ( (cpe.dwCharacteristicsActive != NCCF_ALL) &&
//                     ((cpe.dwCharacteristicsActive & ctecmp.dwCharacteristicsActive) != cpe.dwCharacteristicsActive) )
//                {
//                    sprintf(szErr, "A permission has been specified in the Permissions table (row %d) for a Characteristics that is not active in the Command Table (row %d)", x+1, y+1);
//                    AssertSz(FALSE, szErr);
//                    hr = E_FAIL;
//                }
            }
        }

        if (!bFound)
        {
            sprintf(szErr, "An entry has been found in the Permissions table (row %d) without a corresponding CMDID entry in the Command Table", x+1);
            AssertSz(FALSE, szErr);
            hr = E_FAIL;
        }

        // Check that no CmdId/MediaType/Characteristics has been duplicated
        for (y = x + 1; y < g_cteCommandPermissionsMatrixCount; y++)
        {
            const COMMANDPERMISSIONSENTRY& cpecmp = g_cteCommandPermissionsMatrix[y];
            if ( (cpe.iCommandId == cpecmp.iCommandId) &&
                 (dwNegateIf(cpe.dwMediaType, cpe.dwFlags, NB_NEGATE_NBM_MATCH) &
                   dwNegateIf(cpecmp.dwMediaType, cpecmp.dwFlags, NB_NEGATE_NBM_MATCH)) &&
                 (dwNegateIf(cpe.dwCharacteristicsActive, cpe.dwFlags, NB_NEGATE_CHAR_MATCH) &
                   dwNegateIf(cpecmp.dwCharacteristicsActive, cpecmp.dwFlags, NB_NEGATE_CHAR_MATCH)) )
            {
                sprintf(szErr, "Multiple lines (%d and %d) in the COMMANDENTRY table describe the same CmdID/MediaType/Characteristics combo", x+1, y+1);
                AssertSz(FALSE, szErr);
                hr = E_FAIL;
            }
        }

        if (! ((APPLY_TO_NETCONFIGOPS & cpe.ncpAppliesTo) ||
               (APPLY_TO_USER & cpe.ncpAppliesTo) ||
               (APPLY_TO_ADMIN & cpe.ncpAppliesTo) || 
               (APPLY_TO_POWERUSERS & cpe.ncpAppliesTo) ))
        {
            sprintf(szErr, "Lines (%d) in the Permissionstable - permissions must apply to someone", x+1);
            AssertSz(FALSE, szErr);
            hr = E_FAIL;
        }

        // !!(A & B) != !!(A & C) means: If either B or C is set in A, both B and C must be set (or neither). I hope...
        // kill me... kill me now.
        if ((!!(cpe.dwFlags & NB_NEGATE_VIS_NBM_MATCH)   != !!(cpe.dwFlags & NB_NEGATE_ACT_NBM_MATCH)) ||
            (!!(cpe.dwFlags & NB_NEGATE_VIS_NBS_MATCH)   != !!(cpe.dwFlags & NB_NEGATE_ACT_NBS_MATCH)) ||
            (!!(cpe.dwFlags & NB_NEGATE_VIS_CHAR_MATCH)  != !!(cpe.dwFlags & NB_NEGATE_ACT_CHAR_MATCH)) ||
            (!!(cpe.dwFlags & NB_NEGATE_VIS_PERMS_MATCH) != !!(cpe.dwFlags & NB_NEGATE_ACT_PERMS_MATCH)) )
        {
            sprintf(szErr, "Lines (%d) in the Permissionstable should use NB_NEGATE_xxx instead of NB_NEGATE_VIS_xxx or NB_NEGATE_ACT_xxx ", x+1);
            AssertSz(FALSE, szErr);
            hr = E_FAIL;
        }
    }

    delete[] szErr;
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     HrAssertMenuStructuresValid
//
//  Purpose:    Runs various asserts to make sure the menu structures are intact
//              Called on NetShell startup
//
//  Arguments:
//      [in] hwndOwner    Owner window
//
//  Returns:
//              S_OK is succeeded
//              E_FAIL if not
//
//  Author:     deonb   8 Feb 2001
//
//  Notes:      Asserts on failure
//
HRESULT HrAssertMenuStructuresValid(HWND hwndOwner)
{
#ifdef DBG
    static fBeenHereDoneThat = FALSE;

    if (fBeenHereDoneThat)
    {
        return S_OK;
    }
    else
    {
        fBeenHereDoneThat = TRUE;
    }

    TraceFileFunc(ttidMenus);

    HRESULT hr;
    hr = HrAssertCommandMatrixIntegrity();

    return hr;
#else
    return S_OK;
#endif
}

//+---------------------------------------------------------------------------
//
//  Member:     AdjustNCCS
//
//  Purpose:    Up-adjusts an NCCS_STATE flag. Will move ENABLED to DISABLED,
//              and DISABLED to REMOVE but not backwards.
//
//  Arguments:
//     [in out] nccsCurrent    NCCS to be adjusted
//     [in]     nccsNew        New state
//
//  Returns:
//     none
//
//  Author:     deonb   8 Feb 2001
//
//  Notes:
//
inline void AdjustNCCS(IN OUT NCCS_STATE& nccsCurrent, IN NCCS_STATE nccsNew)
{
    if (nccsNew > nccsCurrent)
    {
        nccsCurrent = nccsNew;
    }
}

inline BOOL fMatchFlags(IN DWORD dwFlagsMask, IN DWORD dwFlagsTest, IN DWORD dwNegateFlagMask, IN DWORD dwNegateFlagTest)
{
    bool bMatch = FALSE;

    if ( (0xffffffff == dwFlagsTest) || // Means always succeed.
         (dwFlagsMask & dwFlagsTest) )
    {
        bMatch = TRUE;
    }
    else
    {
        bMatch = FALSE;
    }

    if ( (dwNegateFlagMask & dwNegateFlagTest) == dwNegateFlagTest) // Do a negative compare
    {
        return !bMatch;
    }
    else
    {
        return bMatch;
    }
}
//+---------------------------------------------------------------------------
//
//  Member:     HrGetCommandStateFromCMDTABLEEntry
//
//  Purpose:    Get the command state for a given Connection Folder Entry,
//              given the Command Table Entry entry that should be used.
//
//  Arguments:
//     [in]  cfe            Connection Folder Entry
//     [in]  cte            Command Table Entry
//     [in]  fMultiSelect   Was this part of a multi-selection?
//     [out] nccs           State that the item should be (NCCS_ENABLED/NCCS_DISABLED/NCCS_NOTSHOWN)
//
//  Returns:
//     none
//
//  Author:     deonb   8 Feb 2001
//
//  Notes: This function uses Cached Permissions. YOU MUST CALL RefreshAllPermission before calling this function.
//
HRESULT HrGetCommandStateFromCMDTABLEEntry(IN const CConFoldEntry& cfe, 
                                           IN const COMMANDENTRY& cte, 
                                           IN BOOL fMultiSelect, 
                                           OUT NCCS_STATE& nccs, 
                                           OUT LPDWORD pdwResourceId)
{
    TraceFileFunc(ttidMenus);

    Assert(pdwResourceId);

    HRESULT hr = S_OK;
    nccs       = NCCS_ENABLED;

    DWORD dwNCMbm = (1 << cfe.GetNetConMediaType());        // Convert to bitmask

    // If we're a wizard, add as Wizard media type.
    if (cfe.GetWizard() == WIZARD_MNC)
    {
        dwNCMbm |= NBM_MNC_WIZARD;
        dwNCMbm &= ~NBM_INCOMING;    // clear the INCOMINGCONNECTIONS flag (old NCM_NONE) if we're a wizard.
    }
    else if (cfe.GetWizard() == WIZARD_HNW)
    {
        dwNCMbm |= NBM_HNW_WIZARD;
        dwNCMbm &= ~NBM_INCOMING;    // clear the INCOMINGCONNECTIONS flag (old NCM_NONE) if we're a wizard.
    }

    DWORD dwNCSbm = (1 << cfe.GetNetConStatus());           // Convert to bitmask
    DWORD dwNCCF  = cfe.GetCharacteristics();               // Already a bitmask

    // Check if the command can participate in multi-select
    if ( fMultiSelect &&
        !(cte.dwValidWhen & NCWHEN_MULTISELECT) )
    {
        AdjustNCCS(nccs, NCCS_DISABLED);
    }

    // Check if the command should be visible
    if (!((fMatchFlags(dwNCMbm, cte.dwMediaTypeVisible,      cte.dwFlags, NB_NEGATE_VIS_NBM_MATCH)) &&
          (fMatchFlags(dwNCSbm, cte.dwStatusVisible,         cte.dwFlags, NB_NEGATE_VIS_NBS_MATCH)) &&
          (fMatchFlags(dwNCCF , cte.dwCharacteristicsVisible,cte.dwFlags, NB_NEGATE_VIS_CHAR_MATCH)) ))
    {
        AdjustNCCS(nccs, NCCS_NOTSHOWN);
    }

    // Check if the command should be grayed out
    if (!((fMatchFlags(dwNCMbm, cte.dwMediaTypeActive,       cte.dwFlags, NB_NEGATE_ACT_NBM_MATCH)) &&
          (fMatchFlags(dwNCSbm, cte.dwStatusActive,          cte.dwFlags, NB_NEGATE_ACT_NBS_MATCH)) &&
          (fMatchFlags(dwNCCF , cte.dwCharacteristicsActive, cte.dwFlags, NB_NEGATE_ACT_CHAR_MATCH)) ))
    {
        AdjustNCCS(nccs, NCCS_DISABLED);
    }

    // Check if the command should be grayed out based on permissions
    for (DWORD x = 0; nccs == NCCS_ENABLED, x < g_cteCommandPermissionsMatrixCount; x++)// Permissions won't affect NOT_SHOWN or DISABLED
    {
        const COMMANDPERMISSIONSENTRY cpe = g_cteCommandPermissionsMatrix[x];

        if ( (cpe.iCommandId == cte.iCommandId) &&
             (fMatchFlags(dwNCMbm, cpe.dwMediaType, cpe.dwFlags, NB_NEGATE_NBM_MATCH)) &&
             (fMatchFlags(dwNCCF,  cpe.dwCharacteristicsActive, cpe.dwFlags, NB_NEGATE_CHAR_MATCH)) )
        {
            for (DWORD dwPerm = 0; dwPerm < sizeof(DWORD)*8; dwPerm++)
            {
                if (cpe.dwPermissionsActive & (1 << static_cast<DWORD64>(dwPerm)) )
                {
                    if (!FHasPermissionFromCache(dwPerm))
                    {
                        if (cpe.dwFlags & NB_REMOVE_IF_NOT_MATCH)
                        {
                            AdjustNCCS(nccs, NCCS_NOTSHOWN);
                        }
                        else
                        {
                            AdjustNCCS(nccs, NCCS_DISABLED);
                        }
                        break; // will break anyway.
                    }
                }
            }

            if (APPLY_TO_USER & cpe.ncpAppliesTo)
            {
                break;
            }

            if ( (APPLY_TO_POWERUSERS & cpe.ncpAppliesTo) && FIsUserPowerUser() )
            {
                break;
            }

            if ( (APPLY_TO_NETCONFIGOPS & cpe.ncpAppliesTo) && FIsUserNetworkConfigOps() )
            {
                break;
            }

            if ( (APPLY_TO_ADMIN & cpe.ncpAppliesTo) && FIsUserAdmin())
            {
                break;
            }

            // At this point all group access checks failed, so disable the connection.
            AdjustNCCS(nccs, NCCS_DISABLED);
            break;
        }
    }

    // Check for callback
    if ( (nccs != NCCS_NOTSHOWN) &&
         (cte.pfnHrEnableDisableCB) )
    {
        HRESULT hrTmp;
        NCCS_STATE nccsTemp;
        hrTmp = (*cte.pfnHrEnableDisableCB)(cfe, fMultiSelect, cte.iCommandId, nccsTemp);
        if (S_OK == hrTmp)
        {
            AdjustNCCS(nccs, nccsTemp);
        }
        else
        {
            if (FAILED(hrTmp))
            {
                AdjustNCCS(nccs, NCCS_NOTSHOWN);
            }
        } // If the function returns S_FALSE it's an indication it didn't change the state.
    }

    // Check for Resource String callback:
    if ( (nccs != NCCS_NOTSHOWN) && // What's the point?
         (0 == *pdwResourceId) && // Must not already have a resource Id
         (cte.pfnHrCustomMenuStringCB) )
    {
        HRESULT hrTmp;
        DWORD dwResourceIdTmp = *pdwResourceId;
        hrTmp = (*cte.pfnHrCustomMenuStringCB)(cfe, cte.iCommandId, &dwResourceIdTmp);
        if (S_OK == hr)
        {
            *pdwResourceId = dwResourceIdTmp;
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     HrGetCommandState
//
//  Purpose:    Get the command state for a given Connection Folder Entry,
//              given the Command ID.
//
//  Arguments:
//     [in]  cfpl           List (0 or more) of PIDLs that are selected
//     [in]  dwCmdID        Command ID
//     [out] nccs           State that the item should be (NCCS_ENABLED/NCCS_DISABLED/NCCS_NOTSHOWN)
//
//  Returns:
//     none
//
//  Author:     deonb   8 Feb 2001
//
//  Notes:
//
HRESULT HrGetCommandState(IN const PCONFOLDPIDLVEC& cfpl, 
                          IN const DWORD dwCmdID, 
                          OUT NCCS_STATE& nccs, 
                          OUT LPDWORD pdwResourceId, 
                          IN DWORD cteHint, 
                          IN DWORD dwOverrideFlag)
{
    TraceFileFunc(ttidMenus);

    Assert(pdwResourceId);
    if (!pdwResourceId)
    {
        return E_POINTER;
    }

    RefreshAllPermission();

    HRESULT hr = S_OK;
    BOOL bFound = FALSE;
    DWORD dwNumItems = cfpl.size();
    *pdwResourceId = 0;

    if ( dwOverrideFlag & NB_FLAG_ON_TOPMENU )
    {
        for (DWORD x = 0; x < g_cteCommandMatrixCount; x++)
        {
            if ( (g_cteCommandMatrix[x].iCommandId == dwCmdID) )
            {
                bFound = TRUE;

                const COMMANDENTRY& cte = g_cteCommandMatrix[x];
                if ((cte.dwValidWhen == NCWHEN_TOPLEVEL) ||         // Toplevel-ONLY menu (doesn't matter if items).
                    ((cte.dwValidWhen & NCWHEN_TOPLEVEL) &&
                            (!dwNumItems || (cte.dwValidWhen & NCWHEN_TOPLEVEL_DISREGARD_ITEM)) ) )
                {                                                  // Must be marked to allow incompatible selection,
                    nccs = NCCS_ENABLED;                           // Otherwise, we'll do the item check (below).

                    // Check for permissions
                    for (DWORD x = 0; nccs == NCCS_ENABLED, x < g_cteCommandPermissionsMatrixCount; x++)// Permissions won't affect NOT_SHOWN or DISABLED
                    {
                        const COMMANDPERMISSIONSENTRY cpe = g_cteCommandPermissionsMatrix[x];

                        if ( (cpe.iCommandId == cte.iCommandId) &&
                             (cpe.dwFlags & NB_TOPLEVEL_PERM) )
                        {
                            for (DWORD dwPerm = 0; dwPerm < sizeof(DWORD)*8; dwPerm++)
                            {
                                if (cpe.dwPermissionsActive & (1 << static_cast<DWORD64>(dwPerm)) )
                                {
                                    if (!FHasPermissionFromCache(dwPerm))
                                    {
                                        if (cpe.dwFlags & NB_REMOVE_IF_NOT_MATCH)
                                        {
                                            AdjustNCCS(nccs, NCCS_NOTSHOWN);
                                        }
                                        else
                                        {
                                            AdjustNCCS(nccs, NCCS_DISABLED);
                                        }
                                        break; // will break anyway.
                                    }
                                }
                            }

                            if (APPLY_TO_USER & cpe.ncpAppliesTo)
                            {
                                break;
                            }

                            if ( (APPLY_TO_NETCONFIGOPS & cpe.ncpAppliesTo) && FIsUserNetworkConfigOps() )
                            {
                                break;
                            }

                            if ( (APPLY_TO_ADMIN & cpe.ncpAppliesTo) && FIsUserAdmin())
                            {
                                break;
                            }

                            // At this point all group access checks failed, so disable the connection.
                            AdjustNCCS(nccs, NCCS_DISABLED);
                            break;
                        }
                    }


                    // Check for callback
                    if (cte.pfnHrEnableDisableCB)
                    {
                        HRESULT hrTmp;
                        NCCS_STATE nccsTemp;
                        CONFOLDENTRY cfe;
                        cfe.clear();

                        if (dwNumItems > 0)
                        {
                            hrTmp = cfpl[0].ConvertToConFoldEntry(cfe);
                            if (FAILED(hrTmp))
                            {
                                cfe.clear();
                            }
                        }
                        
                        hrTmp = (*cte.pfnHrEnableDisableCB)(cfe, dwNumItems > 1, cte.iCommandId, nccsTemp);
                        if (S_OK == hrTmp)
                        {
                            AdjustNCCS(nccs, nccsTemp);
                        }
                        else
                        {
                            if (FAILED(hrTmp))
                            {
                                AdjustNCCS(nccs, NCCS_NOTSHOWN);
                            }
                        } // If the function returns S_FALSE it's an indication it didn't change the state.
                    }

                    if (!(NB_REMOVE_TOPLEVEL_ITEM & cte.dwFlags))
                    {
                        if (nccs == NCCS_NOTSHOWN)
                        {
                            nccs = NCCS_DISABLED;
                        }
                    }

                    return S_OK;
                }

                break; // we won't find another CMDID
            }
        }

        if (!dwNumItems)
        {
            nccs = NCCS_DISABLED;
            if (bFound)
            {
                return S_OK;
            }
            else
            {
                return E_FILE_NOT_FOUND;
            }
        }
    }

    AssertSz(dwNumItems, "You don't have any items selected, but you're not a top-level menu... how come?");

    bFound = FALSE;
    nccs   = NCCS_ENABLED;

    // This will effectively loop through all the selected PIDLs and apply the strictest
    // nccs that applies to everything.

    for (PCONFOLDPIDLVEC::const_iterator cfp = cfpl.begin(); cfp != cfpl.end(); cfp++)
    {
        CONFOLDENTRY cfe;
        hr = cfp->ConvertToConFoldEntry(cfe);
        if (FAILED(hr))
        {
            return E_FAIL;
        }

        DWORD dwPos  = 0xffffffff;

        // This is a O(n^(2+)) algorithm when called from HrBuildMenu.
        // We pass a hint to check if we can quickly find the cte.
        if ( (cteHint != 0xffffffff) &&
             (g_cteCommandMatrix[cteHint].iCommandId == dwCmdID) )
        {
            dwPos  = cteHint;
        }

        if (dwPos == 0xffffffff)
        {
            for (DWORD x = 0; x < g_cteCommandMatrixCount && SUCCEEDED(hr); x++)
            {
                if (g_cteCommandMatrix[x].iCommandId == dwCmdID)
                {
                    dwPos = x;
                    break;
                }
            }
        }

        if (dwPos == 0xffffffff)
        {
            return E_FILE_NOT_FOUND;
        }
        else
        {
            bFound = TRUE;

            NCCS_STATE nccsTmp;
            hr = HrGetCommandStateFromCMDTABLEEntry(cfe, g_cteCommandMatrix[dwPos], dwNumItems != 1, nccsTmp, pdwResourceId);
            if (FAILED(hr))
            {
                return hr;
            }

            AdjustNCCS(nccs, nccsTmp);
    
            if ( (dwOverrideFlag & NB_FLAG_ON_TOPMENU) &&
                 (!(NB_REMOVE_TOPLEVEL_ITEM & g_cteCommandMatrix[dwPos].dwFlags)) &&                    
                 (nccs == NCCS_NOTSHOWN) )
            {
                nccs = NCCS_DISABLED;
            }
        }
    }

    if (!bFound)
    {
        return E_FILE_NOT_FOUND;
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     HrGetCheckState
//
//  Purpose:    Get the check state for a given Connection Folder Entry,
//              given the Command ID.
//
//  Arguments:
//     [in]  cfpl           List (0 or more) of PIDLs that are selected
//     [in]  dwCmdID        Command ID
//     [out] nccs           State that the item should be (NCCS_CHECKED/NCCS_UNCHECKED)
//
//  Returns:
//     HRESULT
//
//  Author:     deonb   7 Mar 2001
//
//  Notes:
//
HRESULT HrGetCheckState(IN const PCONFOLDPIDLVEC& cfpl, IN const DWORD dwCmdID, OUT NCCS_CHECKED_STATE& nccs)
{
    HRESULT hr = S_FALSE;
    DWORD   dwLoop  = 0;

    nccs = NCCS_UNCHECKED;

    for (; dwLoop < g_nFolderCheckCount; dwLoop++)
    {
        if (dwCmdID == g_cceFolderChecks[dwLoop].iCommandId)
        {
            switch(g_cceFolderChecks[dwLoop].iCommandId)
            {
                case CMIDM_CONMENU_OPERATOR_ASSIST:
                    hr = S_OK;
                    if (g_fOperatorAssistEnabled)
                    {
                        nccs = NCCS_CHECKED;
                    }
                    break;
                default:
                    break;
            }
        }
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     NCCMDFromSFV
//
//  Purpose:    Return a NetShell CMDID for Shell Internal IDs
//
//  Arguments:
//     [in]     iCmdID     CMDID to map
//
//  Returns:
//     Returns iCmdID if not shell message, or a iCmdID mapping
//
//  Author:     deonb   8 Feb 2001
//
//  Notes:
//
int NCCMDFromSFV(IN int iCmdID, IN DWORD idCmdFirst)
{
    for (int x = 0; x < g_cteSFVCommandMapCount; x++)
    {
        if (g_cteSFVCommandMap[x].iSFVCommandId == iCmdID)
        {
            return g_cteSFVCommandMap[x].iCommandId + idCmdFirst;
        }
    }
    return iCmdID;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrUpdateMenuItemChecks
//
//  Purpose:    Walk through the list of checkmark-able commands and check if
//              applicable.
//
//  Arguments:
//      None
//
//  Returns:
//
//  Author:     deonb   7 Mar 2001
//
//  Notes:
//
HRESULT HrUpdateMenuItemChecks(IN PCONFOLDPIDLVEC& cfpl, IN OUT HMENU hMenu, IN DWORD idCmdFirst)
{
    HRESULT hr = S_FALSE;
    DWORD   dwLoop  = 0;

    Assert(hMenu)
    if (!hMenu)
    {
        return E_INVALIDARG;
    }

    int cMenuItems = GetMenuItemCount(hMenu);

    for (int x = 0; x < cMenuItems; x++)
    {
        UINT nMenuID = GetMenuItemID(hMenu, x);

        NCCS_CHECKED_STATE nccs;
        DWORD dwCustomResourceId = 0;
        DWORD dwCmdId = NCCMDFromSFV(nMenuID, idCmdFirst) - idCmdFirst;

        hr = HrGetCheckState(cfpl, dwCmdId, nccs);
        if (S_OK == hr) // don't need to set if not supported on this item (S_FALSE)
        {
             CheckMenuItem(
                hMenu,
                x,
                nccs == NCCS_CHECKED ?
                MF_CHECKED | MF_BYPOSITION :     // checked
                MF_UNCHECKED | MF_BYPOSITION);   // unchecked
        }
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     HrBuildMenu
//
//  Purpose:    Build the context menu for for a given Connection Folder Entry..
//
//  Arguments:
//     [in out] hMenu       Handle to menu which is to be updated
//     [in]     fVerbsOnly  Should return Verbs only (shortcuts)
//     [in]     cfpl        List (0 or more) of PIDLs that are selected
//     [in]     idCmdFirst  Min value the handler can specify for a menu item
//
//  Returns:
//     none
//
//  Author:     deonb   8 Feb 2001
//
//  Notes:
//
HRESULT HrBuildMenu(IN OUT HMENU &hMenu, 
                    IN     BOOL fVerbsOnly, 
                    IN     PCONFOLDPIDLVEC& cfpl, 
                    IN     DWORD idCmdFirst)
{
    TraceFileFunc(ttidMenus);

    HRESULT hr = S_OK;

    Assert(hMenu)
    if (!hMenu)
    {
        return E_INVALIDARG;
    }

    DWORD dwCurrentDefaultPriority = 0;

    BOOL fShouldAppendSeparator = FALSE;
    DWORD dwInsertPos = 1;
    for (DWORD x = 0; x < g_cteCommandMatrixCount && SUCCEEDED(hr); x++)
    {
        const COMMANDENTRY& cte = g_cteCommandMatrix[x];

        if ( (fVerbsOnly) && !(cte.dwFlags & NB_VERB) )
        {
            continue;
        }

        if (CMIDM_SEPARATOR == cte.iCommandId)
        {
            fShouldAppendSeparator = TRUE;
        }
        else
        {
            NCCS_STATE nccs;
            DWORD dwCustomResourceId = 0;

            hr = HrGetCommandState(cfpl, cte.iCommandId, nccs, &dwCustomResourceId, x);
            if (SUCCEEDED(hr))
            {
                if ( nccs != NCCS_NOTSHOWN )
                {
                    if (fShouldAppendSeparator)
                    {
                        fShouldAppendSeparator = FALSE;
                        if (!InsertMenu(hMenu, dwInsertPos++, MF_BYPOSITION | MF_SEPARATOR, CMIDM_SEPARATOR, NULL))
                        {
                            hr = HRESULT_FROM_WIN32(GetLastError());
                        }
                    }

                    LPCWSTR szMenuString;
                    if (!dwCustomResourceId)
                    {
                        szMenuString = SzLoadIds(IDS_MENU_CMIDM_START + cte.iCommandId - CMIDM_FIRST);
                    }
                    else
                    {
                        szMenuString = SzLoadIds(dwCustomResourceId);
                    }

                    if (!InsertMenu(hMenu, dwInsertPos++, MF_BYPOSITION | MF_STRING | (nccs == NCCS_DISABLED ? MF_GRAYED : MF_ENABLED), idCmdFirst + cte.iCommandId - CMIDM_FIRST, szMenuString))
                    {
                        AssertSz(FALSE, "Couldn't append menu item");
                        hr = HRESULT_FROM_WIN32(GetLastError());
                    }
                    else
                    {
                        if ( (nccs == NCCS_ENABLED) &&
                             (cte.dwDefaultPriority > dwCurrentDefaultPriority) ) // Not 0 is implied.
                        {
                            dwCurrentDefaultPriority = cte.dwDefaultPriority;
                            if (!SetMenuDefaultItem(hMenu, idCmdFirst + cte.iCommandId - CMIDM_FIRST, FALSE))
                            {
                                AssertSz(FALSE, "Couldn't set default menu item");
                                hr = HRESULT_FROM_WIN32(GetLastError());
                            }
                        }
                    }
                }
            }
            else
            {
                if (E_FILE_NOT_FOUND == hr)
                {
                    AssertSz(FALSE, "Didn't find the CMDID inside CMDTABLE");
                }
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        hr = HrUpdateMenuItemChecks(cfpl, hMenu, idCmdFirst);
        if (S_FALSE == hr)
        {
            hr = S_OK;
        }
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     HrUpdateMenu
//
//  Purpose:    Update a menu for for a given Connection Folder Entry..
//
//  Arguments:
//     [in out] hMenu       Handle to menu which is to be updated
//     [in]     cfpl        List (0 or more) of PIDLs that are selected
//     [in]     idCmdFirst  Min value the handler can specify for a menu item
//
//  Returns:
//     none
//
//  Author:     deonb   8 Feb 2001
//
//  Notes:
//
HRESULT HrUpdateMenu(IN OUT HMENU &hMenu, 
                     IN     PCONFOLDPIDLVEC& cfpl, 
                     IN     DWORD idCmdFirst)
{
    TraceFileFunc(ttidMenus);

    HRESULT hr = S_OK;

    Assert(hMenu)
    if (!hMenu)
    {
        return E_INVALIDARG;
    }

    int cMenuItems = GetMenuItemCount(hMenu);

    for (int x = 0; x < cMenuItems; x++)
    {
        UINT nMenuID = GetMenuItemID(hMenu, x);
//        UINT uiState = GetMenuState(hMenu, nMenuID, MF_BYCOMMAND );

        NCCS_STATE nccs;
        DWORD dwCustomResourceId = 0;
        DWORD dwCmdId = NCCMDFromSFV(nMenuID, idCmdFirst) - idCmdFirst;

        hr = HrGetCommandState(cfpl, dwCmdId, nccs, &dwCustomResourceId, 0xffffffff, NB_FLAG_ON_TOPMENU);
        if (SUCCEEDED(hr))
        {
            if (nccs == NCCS_NOTSHOWN)
            {
#ifdef DBG
                WCHAR szTemp[MAX_PATH];
                GetMenuStringW(hMenu, x, szTemp, MAX_PATH, MF_BYPOSITION );
                TraceTag(ttidMenus, "Received request to permanently remove menu item: '%S' for CMDID: %d MenuID: %d", szTemp, dwCmdId, nMenuID);
#endif
                RemoveMenu(hMenu, x, MF_BYPOSITION);
            }
            else
            {
                EnableMenuItem(
                     hMenu,
                     x,
                     nccs == NCCS_ENABLED ?
                     MF_ENABLED | MF_BYPOSITION:     // enable
                     MF_GRAYED | MF_BYPOSITION);   
            }
        }

        NCCS_CHECKED_STATE nccCheckedState;
        hr = HrGetCheckState(cfpl, dwCmdId, nccCheckedState);
        if (S_OK == hr) // don't need to set if not supported on this item (S_FALSE)
        {
             CheckMenuItem(
                hMenu,
                x,
                nccCheckedState == NCCS_CHECKED ?
                MF_CHECKED | MF_BYPOSITION :     // checked
                MF_UNCHECKED | MF_BYPOSITION);   // unchecked
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     HasPermissionToRenameConnection
//
//  Purpose:    Checks if the Thread Local user has access to rename a given
//              connection
//
//  Arguments:
//     [in] pcfp     PIDL that wants to be renamed
//
//  Returns:
//     TRUE    if has permissions
//     FALSE   if no permissions
//
//  Author:     deonb   8 Feb 2001
//
//  Notes:
//  ISSUE: Move out of this file
//
BOOL HasPermissionToRenameConnection(IN  const PCONFOLDPIDL& pcfp)
{
    TraceFileFunc(ttidMenus);

    BOOL fPermission = FALSE;

    // ISSUE: Due to a clarification in the spec this code is unreasonably complex.
    // If possible clean it up in the future.

    if (((!(pcfp->dwCharacteristics & NCCF_ALL_USERS) &&
        FHasPermissionFromCache(NCPERM_RenameMyRasConnection))))
    {
        fPermission = TRUE;
    }
    else if (FIsPolicyConfigured(NCPERM_RenameConnection))
    {
        if (((!(pcfp->dwCharacteristics & NCCF_ALL_USERS) &&
            FHasPermissionFromCache(NCPERM_RenameMyRasConnection))))
        {
            fPermission = TRUE;
        }
        else if ((pcfp->ncm != NCM_LAN) && (pcfp->dwCharacteristics & NCCF_ALL_USERS) &&
                FHasPermissionFromCache(NCPERM_RenameConnection) ||
                (pcfp->ncm == NCM_LAN) && FHasPermissionFromCache(NCPERM_RenameConnection))
        {
            fPermission = TRUE;
        }
    }
    else if (((pcfp->ncm == NCM_LAN) && FHasPermissionFromCache(NCPERM_RenameLanConnection))
        || ((pcfp->ncm != NCM_LAN) && (pcfp->dwCharacteristics & NCCF_ALL_USERS) &&
        FHasPermissionFromCache(NCPERM_RenameAllUserRasConnection)))
    {
        fPermission = TRUE;
    }

    return fPermission;
}

//+---------------------------------------------------------------------------
//
//  Function:   SetConnectMenuItem
//
//  Purpose:    This function goes in and modifies the first menu item so
//              that it shows the correct test based on the connection
//              state (enabled or not) or the connection type (LAN / WAN).
//
//  Arguments:
//      hmenu         [in]  Menu to operate on
//      bLan          [in]  Whether or not this is a LAN connection
//      idCmdFirst    [in]  Are commands are really an offset to this value
//      bEnable       [in]  If the connection is enabled or not
//
//  Returns:
//
//  Author:     mbend   8 Mar 2000
//
//  Notes:
//
VOID SetConnectMenuItem(IN  HMENU   hmenu,
                        IN  BOOL    bLan,
                        IN  INT     idCmdFirst,
                        IN  BOOL    bEnable)
{
    // Different strings for WAN/LAN
    INT             iEnableString   =
        bLan ? IDS_DISABLE_MENUITEM : IDS_DISCONNECT_MENUITEM;
    INT             iDisableString  =
        bLan ? IDS_ENABLE_MENUITEM : IDS_CONNECT_MENUITEM;
    INT             iMenuString     =
        bEnable ? iEnableString : iDisableString;
    PCWSTR          pszMenuString   = SzLoadIds(iMenuString);
    MENUITEMINFO    mii;
    // Different commands for WAN/LAN
    INT             iConnect        = bLan ? CMIDM_ENABLE : CMIDM_CONNECT;
    INT             iDisconnect     = bLan ? CMIDM_DISABLE : CMIDM_DISCONNECT;
    INT             iOffset         = bEnable ? iDisconnect : iConnect;
    INT             iNewCommand     = idCmdFirst + iOffset;

    Assert(pszMenuString);

    // Set the menuitem fields
    //
    mii.cbSize      = sizeof(MENUITEMINFO);
    mii.fMask       = MIIM_TYPE | MIIM_ID;
    mii.fType       = MFT_STRING;
    mii.dwTypeData  = (PWSTR) pszMenuString;
    mii.wID         = iNewCommand;

    // This is assuming that we want to take out the first menu item.
    if (!SetMenuItemInfo(hmenu, 0, TRUE, &mii))
    {
        TraceTag(ttidMenus, "SetMenuItemInfo returned: 0x%08x for CMIDM_DISCONNECT",
            GetLastError());
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   HrSetConnectDisconnectMenuItem
//
//  Purpose:    Modify the menu item (if necessary) for connect/disconnect.
//              We change this back and forth as needed since only one can be
//              supported at a time, and those in charge don't want both
//              appearing at any given time.
//
//  Arguments:
//      apidlSelected [in]  List of selected objects
//      cPidl         [in]  Count of selected objects
//      hmenu         [in]  Our menu handle
//
//  Returns:
//
//  Author:     jeffspr   1 May 1998
//
//  Notes:
//
HRESULT HrSetConnectDisconnectMenuItem(IN  const PCONFOLDPIDLVEC& apidlSelected,
                                       IN  HMENU           hmenu,
                                       IN  INT             idCmdFirst)
{
    HRESULT         hr              = S_OK;

    if (apidlSelected.size() == 1)
    {
        Assert(!apidlSelected[0].empty() );

        const PCONFOLDPIDL& pcfp = apidlSelected[0];

        switch(pcfp->ncs)
        {
        case NCS_CONNECTED:
        case NCS_DISCONNECTING:
        case NCS_MEDIA_DISCONNECTED:
        case NCS_INVALID_ADDRESS:
        case NCS_AUTHENTICATING:
        case NCS_AUTHENTICATION_FAILED:
        case NCS_AUTHENTICATION_SUCCEEDED:
        case NCS_CREDENTIALS_REQUIRED:
            SetConnectMenuItem(hmenu, IsMediaLocalType(pcfp->ncm), idCmdFirst, TRUE);
            break;

        case NCS_DISCONNECTED:
        case NCS_CONNECTING:
        case NCS_HARDWARE_NOT_PRESENT:
        case NCS_HARDWARE_DISABLED:
        case NCS_HARDWARE_MALFUNCTION:
            SetConnectMenuItem(hmenu, IsMediaLocalType(pcfp->ncm), idCmdFirst, FALSE);
            break;

        default:
            AssertSz(FALSE, "HrSetConnectDisconnectMenuItem: What in the heck state is this?");
            break;
        }
    }

    TraceHr(ttidMenus, FAL, hr, FALSE, "HrSetConnectDisconnectMenuItem");
    return hr;
}


HRESULT HrCanRenameConnection(
    IN    const CConFoldEntry& cfe,
    IN    BOOL                 fMultiSelect,
    IN    int                  iCommandId,
    OUT   NCCS_STATE&          nccs
    )
{
    if (cfe.empty())
    {
        return S_FALSE;
    }

    if (cfe.GetCharacteristics() & NCCF_INCOMING_ONLY)
    {
        if (cfe.GetNetConMediaType() == NCM_NONE) // Incoming server - don't care
        {
            return S_FALSE;
        }
        else
        {
            nccs = NCCS_NOTSHOWN;
            return S_OK;
        }
    }
    else
    {
        CPConFoldPidl<ConFoldPidl_v2> pcfp;

        cfe.ConvertToPidl(pcfp);

        if (!HasPermissionToRenameConnection(pcfp))
        {
            nccs = NCCS_DISABLED;
        }
        else
        {
            return S_FALSE;
        }
        return S_OK;
    }
}

HRESULT HrCanShowProperties(
      IN    const CConFoldEntry& cfe,
      IN    BOOL                 fMultiSelect,
      IN    int                  iCommandId,
      OUT   NCCS_STATE&          nccs
      )
{
    if (cfe.empty())
    {
        return S_FALSE;
    }
    
    if (cfe.GetCharacteristics() & NCCF_INCOMING_ONLY)
    {
        if (cfe.GetNetConMediaType() == NCM_NONE) // Incoming server - don't care
        {
            return S_FALSE;
        }
        else
        {
            nccs = NCCS_NOTSHOWN;
            return S_OK;
        }
    }
    return S_FALSE;
}

BOOL IsBridgeInstalled() throw()
{
    BOOL fBridgePresent = FALSE;  // fail to false
    HRESULT hResult;

    IHNetCfgMgr* pHomeNetConfigManager;
    hResult = HrCreateInstance(CLSID_HNetCfgMgr, CLSCTX_INPROC, &pHomeNetConfigManager);
    if(SUCCEEDED(hResult))
    {
        IHNetBridgeSettings* pNetBridgeSettings;
        hResult = pHomeNetConfigManager->QueryInterface(IID_IHNetBridgeSettings, reinterpret_cast<void**>(&pNetBridgeSettings));
        if(SUCCEEDED(hResult))
        {
            IHNetBridge* pNetBridge;
            IEnumHNetBridges* pNetBridgeEnum;
            hResult = pNetBridgeSettings->EnumBridges(&pNetBridgeEnum);
            if(SUCCEEDED(hResult))
            {
                hResult = pNetBridgeEnum->Next(1, &pNetBridge, NULL);
                if(S_OK == hResult)
                {
                    fBridgePresent = TRUE;
                    ReleaseObj(pNetBridge);
                }
                ReleaseObj(pNetBridgeEnum);
            }
            ReleaseObj(pNetBridgeSettings);
        }
        ReleaseObj(pHomeNetConfigManager);
    }
    return fBridgePresent;
}

inline BOOL IsNetConnBridgeable (IN const CConFoldEntry& cfe)
{
    return TRUE; // Should check for cfe.GetNetConSubMediaType() != NCSM_BLUETOOTH;
}

HRESULT HrIsBridgeSupported(
    IN    const CConFoldEntry& cfe,
    IN    BOOL                 fMultiSelect,
    IN    int                  iCommandId,
    OUT   NCCS_STATE&          nccs
    )
{
//    if (cfe.empty())
//    {
//        return S_FALSE;
//    }
//
#ifdef _WIN64
        // Homenet technologies are not available at all on IA64
        nccs = NCCS_NOTSHOWN;
        return S_OK;
#else
        // If the machine is Data Center, Back Office, SBS, or Blade delete the bridge menu item
        OSVERSIONINFOEXW verInfo = {0};
        ULONGLONG ConditionMask = 0;

        verInfo.dwOSVersionInfoSize = sizeof(verInfo);
        verInfo.wSuiteMask = VER_SUITE_DATACENTER | 
                             VER_SUITE_BACKOFFICE | 
                             VER_SUITE_SMALLBUSINESS_RESTRICTED |
                             VER_SUITE_SMALLBUSINESS |
                             VER_SUITE_BLADE;

        VER_SET_CONDITION(ConditionMask, VER_SUITENAME, VER_OR);

        if (VerifyVersionInfo(&verInfo, VER_SUITENAME, ConditionMask))
        {
            nccs = NCCS_NOTSHOWN;
            return S_OK;
        }
        else
        {
            BOOL fUserIsAdmin = FALSE;
            HRESULT hr = S_OK;
            CComPtr<INetConnectionUiUtilities> pConnectionUi;
            
            hr = CoCreateInstance(CLSID_NetConnectionUiUtilities, NULL, CLSCTX_INPROC, 
                                  IID_INetConnectionUiUtilities, reinterpret_cast<void**>(&pConnectionUi));

            if (FAILED(hr))
            {
                return hr;
            }

            fUserIsAdmin = FIsUserAdmin();
            
            if (IsBridgeInstalled())
            {
                if (CMIDM_CREATE_BRIDGE == iCommandId)
                {
                    nccs = NCCS_NOTSHOWN;
                    return S_OK;
                }
                else if (CMIDM_CONMENU_CREATE_BRIDGE == iCommandId)
                {
                    nccs = NCCS_DISABLED;
                    return S_OK;
                }
                else // CMIDM_ADD_TO_BRIDGE or CMID_REMOVE_FROM_BRIDGE
                {
                    if (!fUserIsAdmin ||
                        !pConnectionUi->UserHasPermission(NCPERM_AllowNetBridge_NLA) ||
                        !IsNetConnBridgeable(cfe))
                    {
                        nccs = NCCS_DISABLED;
                        return S_OK;
                    }
                    else
                    {
                        return S_FALSE; // Leave alone
                    }
                }
            }
            else
            {
                if ( (CMIDM_CREATE_BRIDGE == iCommandId) ||
                     (CMIDM_CONMENU_CREATE_BRIDGE == iCommandId) )
                {
                    if (!fUserIsAdmin || 
                        !pConnectionUi->UserHasPermission(NCPERM_AllowNetBridge_NLA) ||
                        !IsNetConnBridgeable(cfe))
                    {
                        nccs = NCCS_DISABLED;
                        return S_OK;
                    }
                    else
                    {
                        return S_FALSE; // Leave alone
                    }
                }
                else // CMIDM_ADD_TO_BRIDGE or CMID_REMOVE_FROM_BRIDGE
                {
                    nccs = NCCS_NOTSHOWN;
                    return S_OK;
                }
            }
        }
#endif
}

HRESULT HrOsIsLikePersonal()
{
    if (IsOS(OS_PERSONAL))
    {
        return S_OK;
    }

    if (IsOS(OS_PROFESSIONAL))
    {
        LPWSTR pszDomain;
        NETSETUP_JOIN_STATUS njs = NetSetupUnknownStatus;
        if (NERR_Success == NetGetJoinInformation(NULL, &pszDomain, &njs))
        {
            NetApiBufferFree(pszDomain);
        }

        if (NetSetupDomainName == njs)
        {
            return S_FALSE; // connected to domain
        }
        else
        {
            return S_OK; // Professional, but not a domain member
        }
    }
    return S_FALSE; // not personal or non-domain professional
}

HRESULT HrShouldHaveHomeNetWizard()
{
#ifdef _WIN64
    return S_FALSE;
#else
    if ( ( HrOsIsLikePersonal() == S_OK ) &&
        FIsUserAdmin())
    {
        return S_OK;
    }
    else
    {
        return S_FALSE;
   }
#endif
}

HRESULT HrIsHomeNewWizardSupported(
    IN    const CConFoldEntry& cfe,
    IN    BOOL                 fMultiSelect,
    IN    int                  iCommandId,
    OUT   NCCS_STATE&          nccs
    )
{
    if (S_OK == HrShouldHaveHomeNetWizard() )
    {
        nccs = NCCS_ENABLED;
        return S_OK;
    }
    else
    {
        nccs = NCCS_NOTSHOWN;
        return S_OK;
   }
}

HRESULT HrIsTroubleShootSupported(
    IN    const CConFoldEntry& cfe,
    IN    BOOL                 fMultiSelect,
    IN    int                  iCommandId,
    OUT   NCCS_STATE&          nccs
    )
{
    if ( cfe.empty() && (!fMultiSelect) )
    {
        if ( ! IsOS(OS_ANYSERVER) )
        {
            nccs = NCCS_ENABLED;
            return S_OK;
        }
        else
        {
            nccs = NCCS_ENABLED;
            return S_OK;
       }
    }
    else
    {
        nccs = NCCS_DISABLED;
        return S_OK;
    }
}

HRESULT HrIsNCWSupported(
    IN    const CConFoldEntry& cfe,
    IN    BOOL                 fMultiSelect,
    IN    int                  iCommandId,
    OUT   NCCS_STATE&          nccs
    )
{
    if ( (HrOsIsLikePersonal() == S_OK) &&
         !FIsUserAdmin() )
    {
        nccs = NCCS_NOTSHOWN;
        return S_OK;
    }
    else
    {
        return S_FALSE;
   }
}


HRESULT HrIsMediaWireless(
    IN    const CConFoldEntry& cfe,
    IN    BOOL                 fMultiSelect,
    IN    int                  iCommandId,
    OUT   NCCS_STATE&          nccs
    )
{
    if (cfe.GetNetConSubMediaType() != NCSM_WIRELESS)
    {
        nccs = NCCS_NOTSHOWN;
        return S_OK;
    }

    return S_FALSE; // Continue with processing
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\shell\folder\connlist.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       C O N N L I S T . H
//
//  Contents:   Connection list class -- subclass of the stl list<> code.
//
//  Notes:
//
//  Author:     jeffspr   19 Feb 1998
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _CONNLIST_H_
#define _CONNLIST_H_

// Icon ID to use for a connection that doesn't have a tray entry
//
#define BOGUS_TRAY_ICON_ID      (UINT) -1


// #define VERYSTRICTCOMPILE

#ifdef VERYSTRICTCOMPILE
#define CONST_IFSTRICT const
#else
#define CONST_IFSTRICT 
#endif

typedef HRESULT FNBALLOONCLICK(IN const GUID * pGUIDConn, 
                               IN const BSTR pszConnectionName,
                               IN const BSTR szCookie);

typedef enum tagConnListEntryStateFlags
{
    CLEF_NONE               = 0x0000,   // No special characteristics
    CLEF_ACTIVATING         = 0x0001,   // In the process of connecting
    CLEF_TRAY_ICON_LOCKED   = 0x0002    // Tray icon state is being updated
} CONNLISTENTRYFLAGS;

// Define our structure that will be stored in the list<>
//
class CTrayIconData
{
private:
    CTrayIconData* operator &() throw();
    CTrayIconData& operator =(IN const CTrayIconData&) throw();
public:
    explicit CTrayIconData(IN const CTrayIconData &) throw();
    CTrayIconData(IN  UINT uiTrayIconId, 
                  IN  NETCON_STATUS ncs, 
                  IN  IConnectionPoint * pcpStat, 
                  IN  INetStatisticsEngine * pnseStats, 
                  IN  CConnectionTrayStats * pccts) throw();
//private:
    ~CTrayIconData() throw();

public:
    inline const UINT GetTrayIconId() const throw(){ return m_uiTrayIconId; }
    inline const NETCON_STATUS GetConnected() const throw() { return m_ncs; }
    inline CONST_IFSTRICT INetStatisticsEngine * GetNetStatisticsEngine() throw() { return m_pnseStats; }
    inline CONST_IFSTRICT CConnectionTrayStats * GetConnectionTrayStats() throw() { return m_pccts; }
    inline CONST_IFSTRICT IConnectionPoint     * GetConnectionPoint() throw() { return m_pcpStat; }
    inline const DWORD GetLastBalloonMessage() throw() { return m_dwLastBalloonMessage; }
    inline FNBALLOONCLICK* GetLastBalloonFunction() throw() { return m_pfnBalloonFunction; }
    inline const BSTR GetLastBalloonCookie() throw() { return m_szCookie; }
    
    HRESULT SetBalloonInfo(DWORD dwLastBalloonMessage, BSTR szCookie, FNBALLOONCLICK* pfnBalloonFunction);

private:
    UINT                    m_uiTrayIconId;
    NETCON_STATUS           m_ncs;
    IConnectionPoint *      m_pcpStat;
    INetStatisticsEngine *  m_pnseStats;
    CONST_IFSTRICT CConnectionTrayStats *  m_pccts;

    DWORD                   m_dwLastBalloonMessage;
    BSTR                    m_szCookie;
    FNBALLOONCLICK *        m_pfnBalloonFunction;
};

// typedef TRAYICONDATA * PTRAYICONDATA;
// typedef const TRAYICONDATA * PCTRAYICONDATA;


class ConnListEntry
{
public:
    ConnListEntry& operator =(IN  const ConnListEntry& ConnectionListEntry) throw();
    explicit ConnListEntry(IN  const ConnListEntry& ConnectionListEntry) throw();
    ConnListEntry() throw();
    ~ConnListEntry() throw();
    
    DWORD             dwState;        // bitmask of CONNLISTENTRYFLAGS
    CONFOLDENTRY      ccfe;
    CONST_IFSTRICT CON_TRAY_MENU_DATA * pctmd;
    CONST_IFSTRICT CON_BRANDING_INFO  * pcbi;

    inline CONST_IFSTRICT CTrayIconData* GetTrayIconData() const throw();
    inline BOOL HasTrayIconData() const throw();
    inline const BOOL GetCreationTime() const throw() { return m_CreationTime; };
    inline void UpdateCreationTime() throw() { m_CreationTime = GetTickCount(); };
    
    HRESULT SetTrayIconData(const CTrayIconData& TrayIconData);
    HRESULT DeleteTrayIconData();
    
#ifdef DBG
    DWORD dwLockingThreadId;
#endif
private:
    CONST_IFSTRICT CTrayIconData * m_pTrayIconData;
    DWORD m_CreationTime;

#ifdef VERYSTRICTCOMPILE
private:
    const ConnListEntry* operator& ();
#endif
public:
    
    BOOL empty() const;
    void clear();

};

// This is the callback definition. Each find routine will be a separate
// callback function
//
// typedef HRESULT (CALLBACK *PFNCONNLISTICONREMOVALCB)(UINT);

// We are creating a list of Connection entries
//
typedef map<GUID, ConnListEntry> ConnListCore;

// Our find callbacks
//
// For ALGO find
bool operator==(IN  const ConnListEntry& val, IN  PCWSTR pszName) throw();          // HrFindCallbackConnName
bool operator==(IN  const ConnListEntry& cle, IN  const CONFOLDENTRY& cfe) throw(); // HrFindCallbackConFoldEntry
bool operator==(IN  const ConnListEntry& cle, IN  const UINT& uiIcon) throw();      // HrFindCallbackTrayIconId

// For map::find
bool operator < (IN  const GUID& rguid1, IN  const GUID& rguid2) throw();           // HrFindCallbackGuid

// Global connection list wrapper
//
#ifdef DBG
    #define AcquireLock() if (FIsDebugFlagSet(dfidTraceFileFunc)) {TraceTag(ttidShellFolder, "Acquiring LOCK: %s, %s, %d", __FUNCTION__, __FILE__, __LINE__);} InternalAcquireLock();
    #define ReleaseLock() if (FIsDebugFlagSet(dfidTraceFileFunc)) {TraceTag(ttidShellFolder, "Releasing LOCK: %s, %s, %d", __FUNCTION__, __FILE__, __LINE__);} InternalReleaseLock();
#else
    #define AcquireLock() InternalAcquireLock();
    #define ReleaseLock() InternalReleaseLock();
#endif

class CConnectionList : CNetCfgDebug<CConnectionList>
{
  public:
    // No constructor/destructor because we have a global instance of this
    // object.  Use manual Initialize/Uninitialize instead.
    //
    VOID Initialize(IN  BOOL fTieToTray, IN  BOOL fAdviseOnThis) throw();
    VOID Uninitialize(IN  BOOL fFinalUninitialize = FALSE) throw();

  private:
    template <class T> 
        HRESULT HrFindConnectionByType (IN  const T& findbyType, IN  ConnListEntry& cle)
        {
            HRESULT hr = S_FALSE;
            if (m_pcclc)
            {
                AcquireLock();
                
                // Try to find the connection
                //
                ConnListCore::const_iterator iter;
                iter = find(m_pcclc->begin(), m_pcclc->end(), findbyType);
                
                if (iter == m_pcclc->end())
                {
                    hr = S_FALSE;
                }
                else
                {
                    cle = iter->second;
                    Assert(!cle.ccfe.empty() );
                    if (!cle.ccfe.empty())
                    {                    
                        cle.UpdateCreationTime();
                        hr = S_OK;
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }
                ReleaseLock();
            }
            else
            {
                return S_FALSE;
            }
            return hr;
        }
    
        ConnListCore*          m_pcclc;
        bool                   m_fPopulated;
        CRITICAL_SECTION       m_csMain;
        DWORD                  m_dwAdviseCookie;
        BOOL                   m_fTiedToTray;
    BOOL                   m_fAdviseOnThis;

    static DWORD  NotifyThread(IN OUT LPVOID pConnectionList) throw();
    static DWORD  m_dwNotifyThread;
    static HANDLE m_hNotifyThread;

    // This is for debugging only -- can check the refcount while in the debugger.
#if DBG
    DWORD               m_dwCritSecRef;
    DWORD               m_dwWriteLockRef;
#endif

public:

    CRITICAL_SECTION m_csWriteLock;
    void AcquireWriteLock() throw();
    void ReleaseWriteLock() throw();
    
private:
    VOID InternalAcquireLock() throw();
    VOID InternalReleaseLock() throw();

public:
    HRESULT HrFindConnectionByGuid(
        IN  const GUID UNALIGNED *pguid,
        OUT ConnListEntry& cle);
    
    inline HRESULT HrFindConnectionByName(
        IN  PCWSTR   pszName,
        OUT ConnListEntry& cle);
    
    inline HRESULT HrFindConnectionByConFoldEntry(
        IN  const CONFOLDENTRY& ccfe,
        OUT ConnListEntry& cle);
    
    inline HRESULT HrFindConnectionByTrayIconId(
        IN  UINT     uiIcon,
        OUT ConnListEntry& cle);

    HRESULT HrFindRasServerConnection(
        OUT ConnListEntry& cle);
    
    inline BOOL IsInitialized() const throw() {  return(m_pcclc != NULL); }

    VOID FlushConnectionList() throw();
    VOID FlushTrayIcons() throw();          // Flush just the tray icons
    VOID EnsureIconsPresent() throw();

    HRESULT HrRetrieveConManEntries(
        OUT PCONFOLDPIDLVEC& apidlOut) throw();

    HRESULT HrRefreshConManEntries();
    
    HRESULT HrSuggestNameForDuplicate(
        IN  PCWSTR      pszOriginal,
        OUT PWSTR *    ppszNew);

    HRESULT HrInsert(
        IN  const CONFOLDENTRY& pccfe);

    HRESULT HrRemoveByIter(
        IN OUT ConnListCore::iterator clcIter,
        OUT    BOOL *          pfFlushPosts);

    HRESULT HrRemove(
        IN OUT const CONFOLDENTRY& ccfe,
        OUT    BOOL *          pfFlushPosts);

    HRESULT HrInsertFromNetCon(
        IN  INetConnection *    pNetCon,
        OUT PCONFOLDPIDL &      ppcfp);
    
    HRESULT HrInsertFromNetConPropertiesEx(
        IN  const NETCON_PROPERTIES_EX& PropsEx,
        OUT PCONFOLDPIDL &              ppcfp);

    HRESULT HrFindPidlByGuid(
        IN  const GUID *        pguid,
        OUT PCONFOLDPIDL& pidl);
    
    HRESULT HrGetCurrentStatsForTrayIconId(
        IN  UINT                  uiIcon,
        OUT STATMON_ENGINEDATA**  ppData,
        OUT tstring*              pstrName);

    HRESULT HrUpdateTrayIconDataByGuid(
        IN  const GUID *            pguid,
        IN  CConnectionTrayStats *  pccts,
        IN  IConnectionPoint *      pcpStat,
        IN  INetStatisticsEngine *  pnseStats,
        IN  UINT                    uiIcon);
    
    HRESULT HrUpdateTrayBalloonInfoByGuid(
        IN  const GUID *            pguid,
        IN  DWORD                   dwLastBalloonMessage, 
        IN  BSTR                    szCookie,
        IN  FNBALLOONCLICK*         pfnBalloonFunction);

    HRESULT HrUpdateNameByGuid(
        IN  const GUID *    pguid,
        IN  PCWSTR          pszNewName,
        OUT PCONFOLDPIDL &  pidlOut,
        IN  BOOL            fForce);

    
    HRESULT HrUpdateConnectionByGuid(
        IN  const GUID *         pguid,
        IN  const ConnListEntry& cle );

    HRESULT HrUpdateTrayIconByGuid(
        IN  const GUID *    pguid,
        IN  BOOL            fBrieflyShowBalloon);

    HRESULT HrGetBrandingInfo(
        IN OUT ConnListEntry& cle);

    HRESULT HrGetCachedPidlCopyFromPidl(
        IN  const PCONFOLDPIDL&   pidl,
        OUT PCONFOLDPIDL &  pcfp);

    HRESULT HrMapCMHiddenConnectionToOwner(
        IN  REFGUID guidHidden, 
        OUT GUID * pguidOwner);

    HRESULT HrUnsetCurrentDefault(OUT PCONFOLDPIDL& cfpPreviousDefault);

    HRESULT HasActiveIncomingConnections(OUT LPDWORD pdwCount);

    // BOOL    FExists(PWSTR pszName);
    VOID    EnsureConPointNotifyAdded() throw();
    VOID    EnsureConPointNotifyRemoved() throw();

#ifdef NCDBGEXT
    IMPORT_NCDBG_FRIENDS
#endif
};

// Helper routines
//
HRESULT HrCheckForActivation(
    IN  const PCONFOLDPIDL& cfp,
    IN  const CONFOLDENTRY& ccfe,
    OUT BOOL *          pfActivating);

HRESULT HrSetActivationFlag(
    IN  const PCONFOLDPIDL& cfp,
    IN  const CONFOLDENTRY& ccfe,
    IN  BOOL            fActivating);

HRESULT HrGetTrayIconLock(
    IN  const GUID *  pguid,
    OUT UINT *  puiIcon,
    OUT LPDWORD pdwLockingThreadId);

VOID ReleaseTrayIconLock(IN  const GUID *  pguid) throw();

#endif // _CONNLIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\shell\folder\confold.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       C O N F O L D . H
//
//  Contents:   CConnectionFolder object definition.
//
//  Notes:
//
//  Author:     jeffspr   30 Sep 1997
//
//----------------------------------------------------------------------------

#pragma once

#ifndef _CONFOLD_H_
#define _CONFOLD_H_

#include <netshell.h>
#include "nsbase.h"
#include "nsres.h"
#include "cfpidl.h"
#include "pidlutil.h"
#include "contray.h"
#include "connlist.h"
#include <lmcons.h>         // For UNLEN definition

//---[ Connection Folder Types ]----------------------------------------------

// The details list view columns.  These are used by the view and
// context menus

enum
{
    ICOL_NAME           = 0,
    ICOL_TYPE,               // 1
    ICOL_STATUS,             // 2
    ICOL_DEVICE_NAME,        // 3
    ICOL_PHONEORHOSTADDRESS, // 4
    ICOL_OWNER,              // 5
    ICOL_ADDRESS,            // 6
    ICOL_PHONENUMBER,        // 7
    ICOL_HOSTADDRESS,        // 8
    ICOL_WIRELESS_MODE,      // 9
   
    ICOL_MAX,                // 10 - End of list.
    ICOL_NETCONMEDIATYPE      = 0x101, // - not enumerated, just accessed through GetDetailsEx (keep this value in sync with shell)
    ICOL_NETCONSUBMEDIATYPE   = 0x102, // - not enumerated, just accessed through GetDetailsEx (keep this value in sync with shell)
    ICOL_NETCONSTATUS         = 0x103, // - not enumerated, just accessed through GetDetailsEx (keep this value in sync with shell)
    ICOL_NETCONCHARACTERISTICS= 0x104  // - not enumerated, just accessed through GetDetailsEx (keep this value in sync with shell)
};

// The details list view columns.  These are used by the view and
// context menus

typedef struct tagCOLS
{
    short int iColumn;
    short int iStringRes;
    short int iColumnSize;
    short int iFormat;
    DWORD csFlags; // SHCOLSTATE flags
} COLS;

DEFINE_GUID(IID_IExplorerToolbar,       0x8455F0C1L, 0x158F, 0x11D0, 0x89, 0xAE, 0x00, 0xA0, 0xC9, 0x0A, 0x90, 0xAC);
#define SID_SExplorerToolbar IID_IExplorerToolbar

class CNCWebView;

//---[ Connection Folder Classes ]--------------------------------------------

class ATL_NO_VTABLE CConnectionFolder :
    public CComObjectRootEx <CComObjectThreadModel>,
    public CComCoClass <CConnectionFolder, &CLSID_ConnectionFolder>,
    public IPersistFolder2,
    public IShellExtInit,
    public IShellFolder2,
    public IOleCommandTarget,
    public IShellFolderViewCB
{
private:
    CPConFoldPidl<ConFoldPidlFolder>    m_pidlFolderRoot;
    DWORD                 m_dwEnumerationType;
    
    WCHAR           m_szUserName[UNLEN+1];
    HWND            m_hwndMain;
    CNCWebView*     m_pWebView;
public:

    CConnectionFolder() throw();
    ~CConnectionFolder() throw();

    static HRESULT WINAPI UpdateRegistry(IN BOOL fRegister);

    BEGIN_COM_MAP(CConnectionFolder)
        COM_INTERFACE_ENTRY(IPersist)
        COM_INTERFACE_ENTRY(IPersistFolder)
        COM_INTERFACE_ENTRY(IPersistFolder2)
        COM_INTERFACE_ENTRY(IShellExtInit)
        COM_INTERFACE_ENTRY(IShellFolder)
        COM_INTERFACE_ENTRY_IID(IID_IShellFolder2, IShellFolder2)
        COM_INTERFACE_ENTRY(IOleCommandTarget)
        COM_INTERFACE_ENTRY(IShellFolderViewCB)
    END_COM_MAP()

    // *** IPersist methods ***
    STDMETHOD(GetClassID) (
        OUT LPCLSID lpClassID);

    // *** IPersistFolder methods ***
    STDMETHOD(Initialize) (
        IN  LPCITEMIDLIST   pidl);

    // *** IPersistFolder2 methods ***
    STDMETHOD(GetCurFolder) (
        OUT LPITEMIDLIST *ppidl);

    // *** IShellFolder2 methods from IShellFolder ***
    STDMETHOD(ParseDisplayName) (
        HWND            hwndOwner,
        LPBC            pbcReserved,
        LPOLESTR        lpszDisplayName,
        ULONG *         pchEaten,
        LPITEMIDLIST *  ppidl,
        ULONG *         pdwAttributes);

    STDMETHOD(EnumObjects) (
        HWND            hwndOwner,
        DWORD           grfFlags,
        LPENUMIDLIST *  ppenumIDList);

    STDMETHOD(BindToObject) (
        LPCITEMIDLIST   pidl,
        LPBC            pbcReserved,
        REFIID          riid,
        LPVOID *        ppvOut);

    STDMETHOD(BindToStorage) (
        LPCITEMIDLIST   pidl,
        LPBC            pbcReserved,
        REFIID          riid,
        LPVOID *        ppvObj);

    STDMETHOD(CompareIDs) (
        LPARAM          lParam,
        LPCITEMIDLIST   pidl1,
        LPCITEMIDLIST   pidl2);

    STDMETHOD(CreateViewObject) (
        HWND        hwndOwner,
        REFIID      riid,
        LPVOID *    ppvOut);

    STDMETHOD(GetAttributesOf) (
        UINT            cidl,
        LPCITEMIDLIST * apidl,
        ULONG *         rgfInOut);

    STDMETHOD(GetUIObjectOf) (
        HWND            hwndOwner,
        UINT            cidl,
        LPCITEMIDLIST * apidl,
        REFIID          riid,
        UINT *          prgfInOut,
        LPVOID *        ppvOut);

    STDMETHOD(GetDisplayNameOf) (
        LPCITEMIDLIST   pidl,
        DWORD           uFlags,
        LPSTRRET        lpName);

    STDMETHOD(SetNameOf) (
        HWND            hwndOwner,
        LPCITEMIDLIST   pidl,
        LPCOLESTR       lpszName,
        DWORD           uFlags,
        LPITEMIDLIST *  ppidlOut);

    // *** IShellFolder2 specific methods ***
    STDMETHOD(EnumSearches) (
           IEnumExtraSearch **ppEnum);
       
    STDMETHOD(GetDefaultColumn) (
            DWORD dwReserved,
            ULONG *pSort,
            ULONG *pDisplay );

    STDMETHOD(GetDefaultColumnState) (
            UINT iColumn,
            DWORD *pcsFlags );

    STDMETHOD(GetDefaultSearchGUID) (
            LPGUID lpGUID );

    STDMETHOD(GetDetailsEx) (
            LPCITEMIDLIST pidl,
            const SHCOLUMNID *pscid,
            VARIANT *pv );

    STDMETHOD(GetDetailsOf) (
            LPCITEMIDLIST pidl, 
            UINT iColumn, 
            LPSHELLDETAILS pDetails );

    STDMETHOD(MapColumnToSCID) (
            UINT iColumn,
            SHCOLUMNID *pscid );

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (
        OUT HWND *  lphwnd);

    STDMETHOD(ContextSensitiveHelp) (
        IN  BOOL    fEnterMode);

    // *** IShellExtInit methods ***
    STDMETHOD(Initialize) (
        IN  LPCITEMIDLIST   pidlFolder,
        OUT LPDATAOBJECT    lpdobj,
        IN  HKEY            hkeyProgID);

    // IOleCommandTarget members
    STDMETHODIMP    QueryStatus(
        IN     const GUID *    pguidCmdGroup,
        IN     ULONG           cCmds,
        IN OUT OLECMD          prgCmds[],
        IN OUT OLECMDTEXT *    pCmdText);

    STDMETHODIMP    Exec(
        IN     const GUID *    pguidCmdGroup,
        IN     DWORD           nCmdID,
        IN     DWORD           nCmdexecopt,
        IN     VARIANTARG *    pvaIn,
        IN OUT VARIANTARG *    pvaOut);

    // IShellFolderViewCB methods

    STDMETHOD(MessageSFVCB)
        (UINT uMsg, 
         WPARAM wParam, 
         LPARAM lParam);

    // Other interfaces
    STDMETHOD(RealMessage)( // This is kind'a a odd name, but used by the shell's MessageSFVCB 
        UINT uMsg,          // implementation, so I'm keeping this consistent for purposes
        WPARAM wParam,      // of search
        LPARAM lParam);

    PCONFOLDPIDLFOLDER& PidlGetFolderRoot() throw();
    PCWSTR  pszGetUserName() throw();
    IShellView *m_pShellView;
};

class ATL_NO_VTABLE CConnectionFolderEnum :
    public CComObjectRootEx <CComObjectThreadModel>,
    public CComCoClass <CConnectionFolderEnum, &CLSID_ConnectionFolderEnum>,
    public IEnumIDList
{
private:
    PCONFOLDPIDLFOLDER m_pidlFolder;
    PCONFOLDPIDLVEC m_apidl;
    PCONFOLDPIDLVEC::iterator m_iterPidlCurrent;
    DWORD           m_dwFlags;
    BOOL            m_fTray;                // Tray owns us.
    DWORD           m_dwEnumerationType;    // inbound/outbound/all

public:

    CConnectionFolderEnum() throw();
    ~CConnectionFolderEnum() throw();

    VOID PidlInitialize(
        IN BOOL            fTray,
        IN const PCONFOLDPIDLFOLDER& pidlFolder,
        IN DWORD           dwEnumerationType);

    DECLARE_REGISTRY_RESOURCEID(IDR_CONFOLDENUM)

    BEGIN_COM_MAP(CConnectionFolderEnum)
        COM_INTERFACE_ENTRY(IEnumIDList)
    END_COM_MAP()

    // *** IEnumIDList methods ***
    STDMETHOD(Next) (
        IN  ULONG           celt,
        OUT LPITEMIDLIST *  rgelt,
        OUT ULONG *         pceltFetched);

    STDMETHOD(Skip) (
        IN  ULONG   celt);

    STDMETHOD(Reset) ();

    STDMETHOD(Clone) (
        OUT IEnumIDList **  ppenum);

public:
    static HRESULT CreateInstance (
        IN  REFIID                              riid,
        OUT void**                              ppv);

public:
    HRESULT HrRetrieveConManEntries();

};

typedef enum CMENU_TYPE
{
    CMT_OBJECT      = 1,
    CMT_BACKGROUND  = 2
};

class ATL_NO_VTABLE CConnectionFolderContextMenu :
    public CComObjectRootEx <CComObjectThreadModel>,
    public CComCoClass <CConnectionFolderContextMenu, &CLSID_ConnectionFolderContextMenu>,
    public IContextMenu
{
private:
    HWND                m_hwndOwner;
    PCONFOLDPIDLVEC     m_apidl;
    ULONG               m_cidl;
    LPSHELLFOLDER       m_psf;
    CMENU_TYPE          m_cmt;

public:
    CConnectionFolderContextMenu() throw();
    ~CConnectionFolderContextMenu() throw();

    DECLARE_REGISTRY_RESOURCEID(IDR_CONFOLDCONTEXTMENU)

    BEGIN_COM_MAP(CConnectionFolderContextMenu)
        COM_INTERFACE_ENTRY(IContextMenu)
    END_COM_MAP()

    // *** IContextMenu methods ***

    STDMETHOD(QueryContextMenu) (
        IN OUT HMENU   hmenu,
        IN     UINT    indexMenu,
        IN     UINT    idCmdFirst,
        IN     UINT    idCmdLast,
        IN     UINT    uFlags);

    STDMETHOD(InvokeCommand) (
        IN     LPCMINVOKECOMMANDINFO lpici);

    STDMETHOD(GetCommandString) (
        IN     UINT_PTR    idCmd,
        IN     UINT        uType,
        OUT    UINT *      pwReserved,
        OUT    PSTR       pszName,
        IN     UINT        cchMax);

public:
    static HRESULT CreateInstance (
        IN  REFIID                              riid,
        OUT void**                              ppv,
        IN  CMENU_TYPE                          cmt,
        IN  HWND                                hwndOwner,
        IN  const PCONFOLDPIDLVEC&              apidl,
        IN  LPSHELLFOLDER                       psf);

private:
    HRESULT HrInitialize(
        IN  CMENU_TYPE      cmt,
        IN  HWND            hwndOwner,
        IN  const PCONFOLDPIDLVEC& apidl,
        IN  LPSHELLFOLDER   psf);

};

class ATL_NO_VTABLE CConnectionFolderExtractIcon :
    public CComObjectRootEx <CComObjectThreadModel>,
    public CComCoClass <CConnectionFolderExtractIcon, &CLSID_ConnectionFolderExtractIcon>,
    public IExtractIconW,
    public IExtractIconA
{
private:
    PCONFOLDPIDL m_pidl;

public:
    CConnectionFolderExtractIcon() throw();
    ~CConnectionFolderExtractIcon() throw();

    HRESULT HrInitialize(IN const PCONFOLDPIDL& pidl);

    DECLARE_REGISTRY_RESOURCEID(IDR_CONFOLDEXTRACTICON)

    BEGIN_COM_MAP(CConnectionFolderExtractIcon)
        COM_INTERFACE_ENTRY(IExtractIconW)
        COM_INTERFACE_ENTRY(IExtractIconA)
    END_COM_MAP()

    // *** IExtractIconW methods ***
    STDMETHOD(GetIconLocation) (
        IN  UINT    uFlags,
        OUT PWSTR  szIconFile,
        IN  UINT    cchMax,
        OUT int *   piIndex,
        OUT UINT *  pwFlags);

    STDMETHOD(Extract) (
        IN  PCWSTR pszFile,
        IN  UINT    nIconIndex,
        OUT HICON * phiconLarge,
        OUT HICON * phiconSmall,
        IN  UINT    nIconSize);

    // *** IExtractIcon methods ***
    STDMETHOD(GetIconLocation) (
        IN  UINT    uFlags,
        OUT PSTR   szIconFile,
        IN  UINT    cchMax,
        OUT int *   piIndex,
        OUT UINT *  pwFlags);

    STDMETHOD(Extract) (
        IN  PCSTR  pszFile,
        IN  UINT    nIconIndex,
        OUT HICON * phiconLarge,
        OUT HICON * phiconSmall,
        IN  UINT    nIconSize);

public:
    static HRESULT CreateInstance (
        IN  LPCITEMIDLIST       apidl,
        IN  REFIID              riid,
        OUT void**              ppv);

};

// Util function for the IExtract code (also used elsewhere)
//
class ATL_NO_VTABLE CConnectionFolderQueryInfo :
    public CComObjectRootEx <CComObjectThreadModel>,
    public CComCoClass <CConnectionFolderQueryInfo, &CLSID_ConnectionFolderQueryInfo>,
    public IQueryInfo
{
private:
    PCONFOLDPIDL    m_pidl;

public:
    CConnectionFolderQueryInfo() throw();
    ~CConnectionFolderQueryInfo() throw();

    VOID PidlInitialize(const PCONFOLDPIDL& pidl)
    {
        m_pidl = pidl;
    }

    DECLARE_REGISTRY_RESOURCEID(IDR_CONFOLDQUERYINFO)

    BEGIN_COM_MAP(CConnectionFolderQueryInfo)
        COM_INTERFACE_ENTRY(IQueryInfo)
    END_COM_MAP()

    // *** IQueryInfo methods ***
    STDMETHOD(GetInfoTip) (
        IN  DWORD dwFlags,
        OUT WCHAR **ppwszTip);

    STDMETHOD(GetInfoFlags) (
        OUT DWORD *pdwFlags);

public:
    static HRESULT CreateInstance (
        IN  REFIID                              riid,
        OUT void**                              ppv);
};

//---[ Helper Functions ]------------------------------------------------------

HRESULT HrRegisterFolderClass(VOID);

HRESULT HrRegisterDUNFileAssociation();

HRESULT CALLBACK HrShellViewCallback(
    IShellView *    psvOuter,
    IShellFolder *  psf,
    HWND            hwnd,
    UINT            uMsg,
    WPARAM          wParam,
    LPARAM          lParam);

HRESULT CALLBACK HrShellContextMenuCallback(
    LPSHELLFOLDER   psf,
    HWND            hwndView,
    LPDATAOBJECT    pdtobj,
    UINT            uMsg,
    WPARAM          wParam,
    LPARAM          lParam);

HRESULT HrDataObjGetHIDA(
    IDataObject *   pdtobj,
    STGMEDIUM *     pmedium,
    LPIDA *         ppida);

VOID HIDAReleaseStgMedium(
    LPIDA       pida,
    STGMEDIUM * pmedium);

HRESULT HrSHReleaseStgMedium(
    LPSTGMEDIUM pmedium);

LPITEMIDLIST ILFromHIDA(
    LPIDA   pida,
    UINT    iPidaIndex);

EXTERN_C
HRESULT APIENTRY HrLaunchNetworkOptionalComponents(VOID);

#endif // _CONFOLD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\shell\folder\conprops.cpp ===
#include "pch.h"
#pragma hdrstop

#include "foldinc.h"    // Standard shell\folder includes
#include "conprops.h"
#include "ncnetcon.h"
#include "foldres.h"

class CConnectionPropPages
{
public:
    CConnectionPropPages() throw();
    ~CConnectionPropPages() throw();
    ULONG CntPages()  throw() {return m_culPages;}
    HPROPSHEETPAGE * PHPages() throw()  {return m_rghPages;}
    static BOOL FAddPropSheet(HPROPSHEETPAGE hPage, LPARAM lParam) throw();

private:
    ULONG               m_culPages;
    ULONG               m_ulPageBufferLen;
    HPROPSHEETPAGE *    m_rghPages;
};

CConnectionPropPages::CConnectionPropPages()  throw()
{
    m_culPages = 0;
    m_ulPageBufferLen = 0;
    m_rghPages = NULL;
}

CConnectionPropPages::~CConnectionPropPages()  throw()
{
    delete [] (BYTE *)(m_rghPages);
}

//
// Function:    CConnectionPropPages::FAddPropSheet
//
// Purpose:     Callback function for the AddPages API used to accept
//              connection property pages handed back from a provider.
//
// Parameters:  hPage  [IN] - The page to add
//              lParam [IN] - 'this' casted to an LPARAM
//
// Returns:     BOOL, TRUE if the page was successfully added.
//
BOOL
CConnectionPropPages::FAddPropSheet(IN  HPROPSHEETPAGE hPage, IN  LPARAM lParam) throw()
{
    CConnectionPropPages * pCPP = NULL;

    // Validate the input parameters
    //
    if ((0L == lParam) || (NULL == hPage))
    {
        Assert(lParam);
        Assert(hPage);

        TraceHr(ttidShellFolder, FAL, E_INVALIDARG, FALSE, "CConnectionPropPages::FAddPropSheet");
        return FALSE;
    }

    pCPP = reinterpret_cast<CConnectionPropPages*>(lParam);

    // Grow the buffer if necessary
    //
    if (pCPP->m_culPages == pCPP->m_ulPageBufferLen)
    {
        HPROPSHEETPAGE* rghPages = NULL;

        rghPages = (HPROPSHEETPAGE*)(new BYTE[sizeof(HPROPSHEETPAGE) *
                                   (pCPP->m_ulPageBufferLen + 10)]);

        if (NULL == rghPages)
        {
            TraceHr(ttidShellFolder, FAL, E_OUTOFMEMORY, FALSE, "CConnectionPropPages::FAddPropSheet");
            return FALSE;
        }

        // Copy the existing pages to the new buffer
        //
        memcpy(rghPages, pCPP->m_rghPages,
               sizeof(HPROPSHEETPAGE) * pCPP->m_ulPageBufferLen);
        delete [] (BYTE *)(pCPP->m_rghPages);

        pCPP->m_rghPages = rghPages;
        pCPP->m_ulPageBufferLen += 10;
    }

    // Retain the new page
    //
    pCPP->m_rghPages[pCPP->m_culPages++] = hPage;

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrUIInterfaceFromNetCon
//
//  Purpose:    Get the INetConnectionPropertyUI interface from an
//              INetConnection pointer.
//
//  Arguments:
//      pconn [in]      Valid INetConnection *
//      riid  [in]      IID of desired interface
//      ppv   [out]     Returned pointer to the interface
//
//  Returns:
//
//  Author:     jeffspr   12 Nov 1997
//
//  Notes:
//
HRESULT HrUIInterfaceFromNetCon(
    IN  INetConnection *            pconn,
    IN  REFIID                      riid,
    OUT LPVOID *                    ppv)
{
    HRESULT hr      = S_OK;
    CLSID   clsid;

    Assert(pconn);
    Assert(ppv);

    // Validate the parameters.
    //
    if ((NULL == pconn) || (NULL == ppv))
    {
        hr = E_INVALIDARG;
        goto Error;
    }

    // Initailize the output parameter.
    //
    *ppv = NULL;

    // Get the CLSID of the object which can provide the particular interface.
    //
    hr = pconn->GetUiObjectClassId(&clsid);
    if (FAILED(hr))
    {
        goto Error;
    }

    // Create this object asking for the specified interface.
    //
    hr = CoCreateInstance(clsid, NULL,
            CLSCTX_INPROC_SERVER | CLSCTX_NO_CODE_DOWNLOAD, riid, ppv);

Error:

    TraceHr(ttidError, FAL, hr, (E_NOINTERFACE == hr),
        "HrUIInterfaceFromNetCon");
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrGetPropertiesCaption
//
//  Purpose:    Generate the caption for a property page
//
//  Arguments:
//      pconn       [in]  Connection pointer passed in from the shell
//      ppszCaption [out] Resultant property page caption if successful
//
//  Returns:
//
//  Notes:
//
HRESULT HrGetPropertiesCaption(IN  INetConnection * pconn, 
                               OUT PWSTR * ppszCaption)
{
    HRESULT hr;

    Assert(pconn);
    Assert(ppszCaption);

    // Try to get the connection name
    //
    NETCON_PROPERTIES* pProps;
    hr = pconn->GetProperties(&pProps);
    if (SUCCEEDED(hr))
    {
        Assert (pProps->pszwName);

        FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                      FORMAT_MESSAGE_FROM_STRING |
                      FORMAT_MESSAGE_ARGUMENT_ARRAY,
                      SzLoadIds(IDS_CONPROP_CAPTION),
                      0, 0, (PWSTR)ppszCaption, 0,
                      (va_list *)&pProps->pszwName);

        FreeNetconProperties(pProps);
    }

    TraceHr(ttidError, FAL, hr, FALSE,"HrGetPropertiesCaption");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   ActivatePropertyDialog
//
//  Purpose:    Try to locate a property dialog associated with pconn
//              then bring it to the foreground.
//
//  Arguments:
//      pconn       [in]  Connection pointer passed in from the shell
//
//  Returns:
//
//  Notes:
//
VOID ActivatePropertyDialog(IN  INetConnection * pconn) throw()
{
    PWSTR pszCaption = NULL;

    if (SUCCEEDED(HrGetPropertiesCaption(pconn, &pszCaption)))
    {
        Assert(pszCaption);

        // Find the dialog with this caption
        //
        HWND hwnd = FindWindow(NULL, pszCaption);
        if (IsWindow(hwnd))
        {
            SetForegroundWindow(hwnd);
        }

        LocalFree (pszCaption);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   HrSetPropertiesTaskbarIcon
//
//  Purpose:    Setup the dialog property sheet's taskbar icon.
//
//  Arguments:
//      hwndDlg  [in]  Dialog handle
//      uMsg     [in]  Message value
//      lparam   [in]  Long parameter
//
//  Returns:    0
//
//  Notes:      A standard Win32 commctrl PropSheetProc always return 0.  
//              See MSDN documentation.
//
int CALLBACK HrSetPropertiesTaskbarIcon(
    IN HWND   hwndDlg,
    IN UINT   uMsg,
    IN LPARAM lparam)

{
    switch (uMsg)
    {
        case PSCB_INITIALIZED:

            // Set the dialog window's icon

            // NTRAID#NTBUG9-366302-2001/04/11-roelfc Alt-tab icon
            // This requires a re-architecture in order to be able to retrieve
            // the appropiate icon for the property page through the 
            // IID_INetConnectionPropertyUi2 interface.

            // In the mean time, we query the small icon through the only link we have,
            // the dialog handle, and assign it as the big icon as well. Stretching the 
            // small icon is better than nothing at all...
            HICON  hIcon;

            hIcon = (HICON)SendMessage(hwndDlg, 
                                       WM_GETICON,
                                       ICON_SMALL,
                                       0);
            Assert(hIcon);

            if (hIcon)
            {
                SendMessage(hwndDlg,
                            WM_SETICON,
                            ICON_BIG,
                            (LPARAM)hIcon);
            }
            break;

        default:
            break;

    }

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRaiseConnectionPropertiesInternal
//
//  Purpose:    Bring up the propsheet page UI for the passed in connection
//
//  Arguments:
//      hwnd  [in]  Owner hwnd
//      pconn [in]  Connection pointer passed in from the shell
//
//  Returns:
//
//  Author:     jeffspr   12 Nov 1997
//
//  Notes:
//
HRESULT HrRaiseConnectionPropertiesInternal(IN  HWND hwnd, 
                                            IN  UINT nStartPage, 
                                            IN  INetConnection * pconn)
{
    HRESULT                     hr          = NOERROR;
    INetConnectionPropertyUi *  pPUI        = NULL;
    PWSTR                       pszCaption  = NULL;

    Assert(pconn);
    hr = HrUIInterfaceFromNetCon(pconn, IID_INetConnectionPropertyUi,
            reinterpret_cast<void**>(&pPUI));

    if (E_NOINTERFACE == hr)
    {
        // What we want to check for here, is an object that when QI'd doesn't support IID_INetConnectionPropertyUi
        // but support IID_INetConnectionPropertyUi2.
        //
        // A reinterpret style-downcast directly from the QI would have been ok since INetConnectionPropertyUi2 inherit from 
        // INetConnectionPropertyUi. Hence an object can't multi-inherit from both, so we'll never have both vtable entries.
        // We could simply get the INetConnectionPropertyUi2 vtable entry and treat it like an INetConnectionPropertyUi.
        //
        // However, I'm doing the dynamic cast anyway since a cast-to-wrong-vtable is one of the most difficult
        // bugs to spot.
        INetConnectionPropertyUi2 *pPUI2 = NULL;
        hr = HrUIInterfaceFromNetCon(pconn, IID_INetConnectionPropertyUi2,
                reinterpret_cast<void**>(&pPUI2));

        if (SUCCEEDED(hr))
        {
            pPUI = dynamic_cast<INetConnectionPropertyUi *>(pPUI2);
        }
    }

    if (SUCCEEDED(hr))
    {
        INetConnectionUiLock * pUiLock = NULL;

        // Try to get the connection name
        //
        (VOID)HrGetPropertiesCaption(pconn, &pszCaption);

        Assert(pPUI);
        hr = pPUI->QueryInterface(IID_INetConnectionUiLock, (LPVOID *)&pUiLock);
        if (SUCCEEDED(hr))
        {
            // If the interface exists, we have work to do.
            PWSTR pszwMsg = NULL;
            hr = pUiLock->QueryLock(&pszwMsg);
            ReleaseObj(pUiLock);

            if (S_FALSE == hr)
            {
                // Format the error text
                //
                PWSTR  pszText = NULL;
                PCWSTR  pcszwTemp = pszwMsg;
                if (NULL == pcszwTemp)
                {
                    // Load <Unknown Application>
                    //
                    pcszwTemp = SzLoadIds(IDS_CONPROP_GENERIC_COMP);
                }

                Assert(pcszwTemp);
                FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                              FORMAT_MESSAGE_FROM_STRING |
                              FORMAT_MESSAGE_ARGUMENT_ARRAY,
                              SzLoadIds(IDS_CONPROP_NO_WRITE_LOCK),
                              0, 0, (PWSTR)&pszText, 0,
                              (va_list *)&pcszwTemp);

                if (pszwMsg)
                {
                    CoTaskMemFree(pszwMsg);
                }

                // No UI, couldn't acquire the lock
                //
                if (pszText)
                {
                    MessageBox(hwnd, pszText,
                               (pszCaption ? pszCaption : c_szEmpty),
                               MB_OK | MB_ICONERROR);

                    LocalFree(pszText);
                }

                goto Error;
            }
            else if (FAILED(hr))
            {
                goto Error;
            }
        }

        BOOL fShouldDestroyIcon = FALSE;

        hr = pPUI->SetConnection(pconn);
        if (SUCCEEDED(hr))
        {
            CComPtr<INetConnectionPropertyUi2> pUI2;

            HICON hIcon         = NULL;
            DWORD dwDisplayIcon = 0;
            hr = pPUI->QueryInterface(IID_INetConnectionPropertyUi2, reinterpret_cast<LPVOID *>(&pUI2) );
            if (SUCCEEDED(hr))
            {
                Assert(GetSystemMetrics(SM_CXSMICON) == GetSystemMetrics(SM_CYSMICON));
                
                hr = pUI2->GetIcon(GetSystemMetrics(SM_CXSMICON), &hIcon);
                if (SUCCEEDED(hr))
                {
                    fShouldDestroyIcon = TRUE;
                    dwDisplayIcon = PSH_USEHICON;
                }
                else
                {
                    hIcon = NULL;
                }
            }
            else
            {
                TraceTag(ttidError, "QI for INetConnectionPropertyUi2 failed using Default Icon");
                hIcon = LoadIcon(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDI_CONNECTIONS_FOLDER_LARGE2));
                if (hIcon)
                {
                    dwDisplayIcon = PSH_USEHICON;
                }
            }
            Assert(hIcon);
                
            CConnectionPropPages    CPP;

            // Get the pages from the provider
            hr = pPUI->AddPages(hwnd,
                                CConnectionPropPages::FAddPropSheet,
                                reinterpret_cast<LPARAM>(&CPP));

            // If any pages were returned, display them
            if (SUCCEEDED(hr) && CPP.CntPages())
            {

                PROPSHEETHEADER     psh;
                ZeroMemory (&psh, sizeof(psh));
                psh.dwSize      = sizeof( PROPSHEETHEADER );
                psh.dwFlags     = PSH_NOAPPLYNOW | PSH_USECALLBACK | dwDisplayIcon;
                psh.hwndParent  = hwnd;
                psh.hInstance   = _Module.GetResourceInstance();
                psh.pszCaption  = pszCaption;
                psh.nPages      = CPP.CntPages();
                psh.phpage      = CPP.PHPages();
                psh.hIcon       = hIcon;
                psh.nStartPage  = nStartPage;
                psh.pfnCallback = HrSetPropertiesTaskbarIcon;

                // nRet used for debugging only
                //
                INT_PTR nRet = PropertySheet(&psh);

                if (fShouldDestroyIcon)
                {
                    DestroyIcon(hIcon);
                }
            }
        }

Error:
        ReleaseObj(pPUI);
    }

    // Cleanup
    //
    if (pszCaption)
    {
        LocalFree (pszCaption);
    }

    TraceHr(ttidShellFolder, FAL, hr, FALSE, "HrRaiseConnectionProperties");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrHandleDisconnectHResult
//
//  Purpose:    Put up the message box assocated with an HRESULT from
//              a diconnect operation if the HRESULT represents a failure.
//              Also translate any success codes back to S_OK as needed.
//
//  Arguments:
//      hr    [in] The HRESULT returned from a connection disconnect method.
//      pconn [in] INetConnection* for checking if this is a LAN or RAS connection.
//
//  Returns:    The translated HRESULT if needed
//
//  Author:     shaunco   3 Jun 1999
//
HRESULT HrHandleDisconnectHResult(IN  HRESULT hr, IN  INetConnection * pconn)
{
    if (FAILED(hr))
    {
       	NETCON_PROPERTIES* pProps = NULL;
        UINT nFailureCaptionID;
        UINT nFailureMessageID;

        TraceHr(ttidShellFolder, FAL, hr, FALSE, "pNetCon->Disconnect() failed");

        // Assume that is is a RAS/DIALUP connection unless we find otherwise
        nFailureCaptionID = IDS_CONFOLD_DISCONNECT_FAILURE_CAPTION;
        nFailureMessageID = IDS_CONFOLD_DISCONNECT_FAILURE;

    	hr = pconn->GetProperties(&pProps);
    	if (SUCCEEDED(hr))
    	{
    	    if (NCM_LAN == pProps->MediaType)
            {
                nFailureCaptionID = IDS_CONFOLD_DISABLE_FAILURE_CAPTION;
                nFailureMessageID = IDS_CONFOLD_DISABLE_FAILURE;
            }

    	    FreeNetconProperties(pProps);
    	}

        // Ignore the return from this, since we only allow OK
        //
        (void) NcMsgBox(
            _Module.GetResourceInstance(),
            NULL,
            nFailureCaptionID,
            nFailureMessageID,
            MB_OK | MB_ICONEXCLAMATION);

    }
    else
    {
        // If we get the object_nlv return, it means that the connection
        // is deleted on disconnect and we shouldn't perform an update of
        // that connection. We can normalize this for now, as we'll let the
        // notifysink take care of the delete update.
        //
        if (S_OBJECT_NO_LONGER_VALID == hr)
        {
            hr = S_OK;
        }
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrConnectOrDisconnectNetConObject
//
//  Purpose:    Bring up the connection UI and make the connection for the
//              passed in connection.
//
//  Arguments:
//      hwnd  [in] Owner hwnd
//      pconn [in] Connection pointer passed in from the shell
//      Flag  [in] CD_CONNECT or CD_DISCONNECT.
//
//  Returns:
//
//  Author:     jeffspr   12 Nov 1997
//
//  Notes:
//
HRESULT HrConnectOrDisconnectNetConObject(IN  HWND hwnd, 
                                          IN  INetConnection * pconn,
                                          IN  CDFLAG Flag)
{
    HRESULT                     hr          = NOERROR;
    INetConnectionConnectUi *   pCUI        = NULL;
	
    Assert(pconn);

    // Get the INetConnectionConnectUi interface from the connection
    //
    hr = HrUIInterfaceFromNetCon(pconn, IID_INetConnectionConnectUi,
            reinterpret_cast<void**>(&pCUI));
    if (SUCCEEDED(hr))
    {
        Assert(pCUI);

        // Set the connection on the UI object
        //
        hr = pCUI->SetConnection(pconn);
        if (SUCCEEDED(hr))
        {
            if (CD_CONNECT == Flag)
            {
                // Connect, dangit!
                //
                hr = pCUI->Connect(hwnd, NCUC_DEFAULT);
                if (SUCCEEDED(hr))
                {
                    // heh heh, uhhhh, heh heh. Cool.
                }
                else if (HRESULT_FROM_WIN32(ERROR_NOT_CONNECTED) == hr)
                {
                    // Ignore the return from this, since we only allow OK
                    //
                    (void) NcMsgBox(
                        _Module.GetResourceInstance(),
                        hwnd,
                        IDS_CONFOLD_CONNECT_FAILURE_CAPTION,
                        IDS_CONFOLD_CONNECT_FAILURE,
                        MB_OK | MB_ICONEXCLAMATION);
                }
            }
            else
            {
                // Disconnect the connection object
                //
                hr = pCUI->Disconnect(hwnd, NCUC_DEFAULT);
                hr = HrHandleDisconnectHResult(hr, pconn);
            }
        }

        ReleaseObj(pCUI);
    }
    else if ((E_NOINTERFACE == hr) && (CD_DISCONNECT == Flag))
    {
        // Incoming connection objects do not have a UI interface
        // so we disconect them on the object itself.
        //
        hr = pconn->Disconnect ();
        hr = HrHandleDisconnectHResult(hr, pconn);
    }

    AssertSz(E_NOINTERFACE != hr,
             "Should not have been able to attempt connection on object that doesn't support this interface");

    TraceHr(ttidShellFolder, FAL, hr, (E_NOINTERFACE == hr),
        "HrConnectOrDisconnectNetConObject");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\shell\folder\contray.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       C O N T R A Y . H
//
//  Contents:   CConnectionTray object definition.
//
//  Notes:
//
//  Author:     jeffspr   30 Sep 1997
//
//----------------------------------------------------------------------------

#pragma once

#ifndef _CONTRAY_H_
#define _CONTRAY_H_

#include <netshell.h>
#include "nsbase.h"
#include "nsres.h"
#include "smutil.h"

//---[ Connection Tray Classes ]----------------------------------------------

class ATL_NO_VTABLE CConnectionTray :
    public CComObjectRootEx <CComObjectThreadModel>,
    public CComCoClass <CConnectionTray, &CLSID_ConnectionTray>,
    public IOleCommandTarget
{
private:
    LPITEMIDLIST    m_pidl;

public:
    CConnectionTray() throw()
    {
        m_pidl = NULL;
    }

    DECLARE_REGISTRY_RESOURCEID(IDR_CONTRAY)

    BEGIN_COM_MAP(CConnectionTray)
        COM_INTERFACE_ENTRY(IOleCommandTarget)
    END_COM_MAP()

    // IOleCommandTarget members
    STDMETHODIMP    QueryStatus(
        IN     const GUID *    pguidCmdGroup,
        IN     ULONG           cCmds,
        IN OUT OLECMD          prgCmds[],
        IN OUT OLECMDTEXT *    pCmdText);

    STDMETHODIMP    Exec(
        IN     const GUID *    pguidCmdGroup,
        IN     DWORD           nCmdID,
        IN     DWORD           nCmdexecopt,
        IN     VARIANTARG *    pvaIn,
        IN OUT VARIANTARG *    pvaOut);

    // Handlers for various Exec Command IDs
    //
    HRESULT HrHandleTrayOpen();
    HRESULT HrHandleTrayClose();

};

class ATL_NO_VTABLE CConnectionTrayStats :
    public CComObjectRootEx <CComObjectThreadModel>,
    public INetConnectionStatisticsNotifySink
{
private:
    DWORD                       m_dwConPointCookie;
    CONFOLDENTRY                m_ccfe;
    UINT                        m_uiIcon;
    BOOL                        m_fStaticIcon;

public:
    CConnectionTrayStats() throw();
    ~CConnectionTrayStats() throw();

    DECLARE_REGISTRY_RESOURCEID(IDR_CONTRAY)

    BEGIN_COM_MAP(CConnectionTrayStats)
        COM_INTERFACE_ENTRY(INetConnectionStatisticsNotifySink)
    END_COM_MAP()

    // INetConnectionStatisticsNotifySink members
    //
    STDMETHOD(OnStatisticsChanged)(
        IN  DWORD   dwChangeFlags);

public:
    static HRESULT CreateInstance (
        IN  const CONFOLDENTRY &pcfe,
        IN  UINT            uiIcon,
        IN  BOOL            fStaticIcon,
        IN  REFIID          riid,
        OUT VOID**          ppv);

    LPDWORD GetConPointCookie() throw() {return &m_dwConPointCookie;}
};


#endif // _CONTRAY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\shell\folder\contrays.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       C O N T R A Y S . C P P
//
//  Contents:   Implementation of the CConnectionTrayStats object.
//
//  Notes:
//
//  Author:     jeffspr   11 Dec 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "foldinc.h"    // Standard shell\tray includes
#include "ctrayui.h"
#include "traymsgs.h"
#include "trayres.h"
#include <confold.h>
#include <smutil.h>



extern HWND g_hwndTray;

CConnectionTrayStats::CConnectionTrayStats() throw()
{
    m_dwConPointCookie  = 0;
    m_uiIcon            = 0;
    m_fStaticIcon       = FALSE;
    m_ccfe.clear();
}

CConnectionTrayStats::~CConnectionTrayStats() throw()
{
    // $REVIEW(tongl 9/4/98): release the duplicate pccfe we created
    // when adding the icon
    m_ccfe.clear();
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolderEnum::CreateInstance
//
//  Purpose:    Create an instance of the CConnectionFolderEnum object, and
//              returns the requested interface
//
//  Arguments:
//      riid [in]   Interface requested
//      ppv  [out]  Pointer to receive the requested interface
//
//  Returns:    Standard OLE HRESULT
//
//  Author:     jeffspr   5 Nov 1997
//
//  Notes:
//
HRESULT CConnectionTrayStats::CreateInstance(
        IN  const CONFOLDENTRY&  ccfe,
        IN  UINT            uiIcon,
        IN  BOOL            fStaticIcon,
        IN  REFIID          riid,
        OUT VOID**          ppv)
{
    Assert(!ccfe.empty());
    Assert(!ccfe.GetWizard());

    HRESULT hr = E_OUTOFMEMORY;

    CConnectionTrayStats * pObj    = NULL;

    pObj = new CComObject <CConnectionTrayStats>;
    if (pObj)
    {
        Assert(!ccfe.GetWizard());
        Assert(uiIcon != BOGUS_TRAY_ICON_ID);

        hr = pObj->m_ccfe.HrDupFolderEntry(ccfe);
        if (SUCCEEDED(hr))
        {
            pObj->m_uiIcon = uiIcon;
            pObj->m_fStaticIcon = fStaticIcon;

            // Do the standard CComCreator::CreateInstance stuff.
            //
            pObj->SetVoid (NULL);
            pObj->InternalFinalConstructAddRef ();
            hr = pObj->FinalConstruct ();
            pObj->InternalFinalConstructRelease ();

            if (SUCCEEDED(hr))
            {
                hr = pObj->QueryInterface (riid, ppv);
            }
        }

        if (FAILED(hr))
        {
            delete pObj;
        }
    }



    TraceHr(ttidError, FAL, hr, FALSE, "CConnectionTrayStats::CreateInstance");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionTrayStats::OnStatisticsChanged
//
//  Purpose:    Callback from the stats engine that tells us when data
//              has actually changed
//
//  Arguments:
//      dwCookie      [in]  Our interface cookie
//      dwChangeFlags [in]  Undefined, as of yet
//
//  Returns:
//
//  Author:     jeffspr   12 Dec 1997
//
//  Notes:
//
HRESULT CConnectionTrayStats::OnStatisticsChanged(
        IN DWORD   dwChangeFlags)
{
    HRESULT     hr          = S_OK;

    // Updage the icon.
    //
    if (g_pCTrayUI)
    {
        if (!m_fStaticIcon)
        {
            INT iIconResourceId;

            iIconResourceId = IGetCurrentConnectionTrayIconId(
                                    m_ccfe.GetNetConMediaType(), m_ccfe.GetNetConStatus(), dwChangeFlags);

            PostMessage(g_hwndTray, MYWM_UPDATETRAYICON,
                        (WPARAM) m_uiIcon, (LPARAM) iIconResourceId);
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CConnectionTrayStats::OnStatisticsChanged", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\shell\folder\ctrayui.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       C T R A Y U I . H
//
//  Contents:   Connections Tray UI class
//
//  Notes:
//
//  Author:     jeffspr   13 Nov 1997
//
//----------------------------------------------------------------------------

#pragma once

#ifndef _CTRAYUI_H_
#define _CTRAYUI_H_

#include "connlist.h"

typedef enum tagBALLOONS
{
    BALLOON_NOTHING = 0,
    BALLOON_CALLBACK,
    BALLOON_USE_NCS
} BALLOONS;

class CTrayBalloon
{
public:
    ~CTrayBalloon() throw()
    {
        SysFreeString(m_szCookie);
        m_szCookie = NULL;
    }
    GUID            m_gdGuid;
    CComBSTR        m_szAdapterName;
    CComBSTR        m_szMessage;
    BSTR            m_szCookie;
    FNBALLOONCLICK* m_pfnFuncCallback;
    DWORD           m_dwTimeOut;        // in milliseconds
};

class CTrayUI
{
private:
    // Used to protect member data which is modified by different threads.
    //
    CRITICAL_SECTION    m_csLock;

    UINT                m_uiNextIconId;
    UINT                m_uiNextHiddenIconId;

    typedef map<INT, HICON, less<INT> >   MapIdToHicon;
    MapIdToHicon        m_mapIdToHicon;

public:
    CTrayUI() throw();
    ~CTrayUI() throw()
    {
        DeleteCriticalSection(&m_csLock);
    }

    HRESULT HrInitTrayUI(VOID);
    HRESULT HrDestroyTrayUI(VOID);

    VOID UpdateTrayIcon(
        IN  UINT    uiTrayIconId,
        IN  INT     iIconResourceId) throw();

    VOID    ResetIconCount()  throw()   {m_uiNextIconId = 0;};

    friend HRESULT HrDoMediaDisconnectedIcon(IN  const CONFOLDENTRY& ccfe, IN  BOOL fShowBalloon);
    friend LRESULT OnMyWMAddTrayIcon(IN  HWND hwndMain, IN  WPARAM wParam, IN  LPARAM lParam);
    friend LRESULT OnMyWMRemoveTrayIcon(IN  HWND hwndMain, IN  WPARAM wParam, IN  LPARAM lParam);
    friend LRESULT OnMyWMShowTrayIconBalloon(IN  HWND hwndMain, IN  WPARAM wParam, IN  LPARAM lParam);

private:
    HICON GetCachedHIcon(
        IN  INT     iIconResourceId);
};

extern CTrayUI *    g_pCTrayUI;

HRESULT HrAddTrayExtension(VOID);
HRESULT HrRemoveTrayExtension(VOID);
VOID FlushTrayPosts(IN  HWND hwndTray);


#endif // _CTRAYUI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\shell\folder\ctrayui.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       T R A Y U I . C P P
//
//  Contents:   Tray window code for the CConnectionTray object.
//
//  Notes:
//
//  Author:     jeffspr   13 Nov 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "foldinc.h"    // Standard shell\tray includes
#include "ctrayui.h"
#include "cfutils.h"
#include "ncmisc.h"
#include "oncommand.h"
#include "traymsgs.h"
#include "trayres.h"
#include "ndispnp.h"
#include "ntddndis.h"
#include <confold.h>
#include <smcent.h>
#include <smutil.h>
#include <ncperms.h>
#include "cfutils.h"
#include "ac_ctrayui.h"

const WCHAR c_szTrayClass[]             = L"Connections Tray";
const WCHAR c_szTipTrailer[]            = L" ...";
const WCHAR c_szDelayLoadKey[]          = L"Software\\Microsoft\\Windows\\CurrentVersion\\ShellServiceObjectDelayLoad";
const WCHAR c_szDelayLoadName[]         = L"Connections Tray";
const WCHAR c_szDelayLoadClassID[]      = L"7007ACCF-3202-11D1-AAD2-00805FC1270E";
const DWORD c_dwBalloonTimeoutSeconds   = 5;
const WCHAR c_szDotDotDot[]             = L"...";   // For balloon tip

// don't change this unless you know better
const UINT_PTR c_unTimerIdDblClick      = 1;
const INT   c_idDefaultCMCommand        = CMIDM_TRAY_STATUS;
const INT   c_idDefaultDisconCMCommand  = CMIDM_OPEN_CONNECTIONS_FOLDER;
const INT   c_idDefaultDisconCMWirelessCommand  = CMIDM_TRAY_WZCDLG_SHOW;


CTrayUI *   g_pCTrayUI;  // TrayUI object (not COM)
HWND        g_hwndTray      = NULL;

//---[ From Statmon ] --------------------------------------------------------
HRESULT HrGetAutoNetSetting(PWSTR pszGuid, DHCP_ADDRESS_TYPE * pAddrType);
HRESULT HrGetAutoNetSetting(REFGUID pGuidId, DHCP_ADDRESS_TYPE * pAddrType);

//---[ Prototypes ]-----------------------------------------------------------

VOID
GetInitialBalloonText(
                      IN  INetStatisticsEngine*   pnse,
                      OUT PWSTR                   pszBuf,
                      OUT DWORD                   dwSize) throw();

LRESULT
CALLBACK
CTrayUI_WndProc (
                 IN  HWND hwnd,        // window handle
                 IN  UINT uiMessage,   // type of message
                 IN  WPARAM wParam,    // additional information
                 IN  LPARAM lParam);   // additional information

BOOL FInitFoldEnumerator(IN  HWND hwnd, OUT DWORD * pdwIconsAdded) throw();
VOID OnTaskBarIconRButtonUp(IN  HWND hwnd, IN  UINT uiIcon) throw();
VOID OnTaskBarIconBalloonClick(IN  HWND hwnd, IN  UINT uiIcon) throw();
VOID OnTaskBarIconLButtonDblClk(IN  HWND hwnd, IN  UINT uiIcon) throw();
HRESULT HrOpenContextMenu(IN  HWND hwnd, const POINT * pPoint, IN  UINT uiIcon);

// Window message handlers
//
LRESULT OnTrayWmCreate(IN  HWND hwnd);
LRESULT OnTrayWmDestroy(IN  HWND hwnd);
LRESULT OnTrayWmCommand(IN  HWND hwnd, IN  UINT uiMessage, IN  WPARAM wParam, IN  LPARAM lParam);
LRESULT OnMyWMNotifyIcon(IN  HWND hwnd, IN  UINT uiMessage, IN  WPARAM wParam, IN  LPARAM lParam);
LRESULT OnMyWMOpenStatus(IN  HWND hwnd, IN  WPARAM wParam, IN  LPARAM lParam);
LRESULT OnMyWMUpdateTrayIcon(IN  HWND hwnd, IN  WPARAM wParam, IN  LPARAM lParam);
LRESULT OnMyWMShowTrayIconBalloon (IN  HWND hwnd, IN  WPARAM wParam, IN  LPARAM lParam);
LRESULT OnMyWMFlushNoop(IN  HWND hwnd, IN  WPARAM wParam, IN  LPARAM lParam);

//+---------------------------------------------------------------------------
//
//  Function:   CopyAndAdvanceIfSpaceAvailable
//
//  Purpose:    Helper routine for FormatToolTip.  This manages the current
//              pointer into the tooltip and the count of characters
//              remaining in the buffer.
//
//  Arguments:
//      pchTip         [in out] Current pointer into the tooltip.
//      cchRemaining   [in out] Count of characters remaining in its buffer.
//      pszLine        [in]     New line to append to the tooltip.
//      cchLine        [in]     Count of characters in the line to append.
//      fInsertNewline [in]     TRUE to insert a newline first.
//
//  Returns:    nothing
//
//  Author:     shaunco   7 Nov 1998
//
//  Notes:
//
VOID
CopyAndAdvanceIfSpaceAvailable (IN OUT WCHAR*&     pchTip,
                                IN OUT INT&        cchRemaining,
                                IN     PCWSTR      pszLine,
                                IN     INT         cchLine,
                                IN     BOOL        fInsertNewline) throw()
{
    TraceFileFunc(ttidSystray);

    if (cchLine < cchRemaining - (fInsertNewline) ? 1 : 0)
    {
        if (fInsertNewline)
        {
            *pchTip = L'\n';
            pchTip++;
            cchRemaining--;
        }

        lstrcpyW(pchTip, pszLine);
        pchTip += cchLine;
        cchRemaining -= cchLine;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   FormatToolTip
//
//  Purpose:    Format a tooltip for the connection with the matching
//              icon id.
//
//  Arguments:
//      hwnd   [in] Window handle of the tray.
//      uiIcon [in] Icon id of the tray icon.
//
//  Returns:    nothing
//
//  Author:     shaunco   7 Nov 1998
//
//  Notes:
//
VOID
FormatToolTip (IN  HWND    hwnd,
               IN  UINT    uiIcon) throw()
{
    TraceFileFunc(ttidSystray);

    HRESULT             hr   = S_OK;
    NETCON_STATUS       ncs  = NCS_CONNECTED;
    NETCON_MEDIATYPE    ncm  = NCM_NONE;
    NETCON_SUBMEDIATYPE ncsm = NCSM_NONE;

    tstring         strName;
    WCHAR           pszValue[64];
    WCHAR           pszLine[256];
    INT             cch;
    GUID            gdPcleGuid;

    NOTIFYICONDATA  nid;
    ZeroMemory(&nid, sizeof(nid));
    nid.cbSize  = sizeof(NOTIFYICONDATA);
    nid.hWnd    = hwnd;
    nid.uID     = uiIcon;
    nid.uFlags  = NIF_TIP;

    // Get the info on the connection so we know how to label the tooltip
    //
    ConnListEntry cle;
    hr = g_ccl.HrFindConnectionByTrayIconId(uiIcon, cle);
    if (hr == S_OK)
    {
        Assert(!cle.ccfe.empty());

        ncs = cle.ccfe.GetNetConStatus();
        gdPcleGuid = cle.ccfe.GetGuidID();
        ncm = cle.ccfe.GetNetConMediaType();
        ncsm = cle.ccfe.GetNetConSubMediaType();
    }
    else // Orphaned item -remove it.
    {
        NOTIFYICONDATA  nid;

        ZeroMemory (&nid, sizeof(nid));
        nid.cbSize  = sizeof(NOTIFYICONDATA);
        nid.hWnd    = g_hwndTray;
        nid.uID = uiIcon;
        hr = HrShell_NotifyIcon(NIM_DELETE, &nid);
        TraceTag(ttidSystray, "WARNING: Removing Orphan Tray Icon: %d", uiIcon);
        return;
    }

    // g_ccl.ReleaseLock();

    // Media status based tool tip
    if (fIsConnectedStatus(ncs))
    {
        WCHAR*  pchTip = nid.szTip;
        INT     cchRemaining = celems(nid.szTip);

        // Get a copy of the current stats and the connection's name.
        //
        STATMON_ENGINEDATA* pData;
        hr = g_ccl.HrGetCurrentStatsForTrayIconId(uiIcon, &pData, &strName);
        if (S_OK == hr && pData)
        {
            UINT64 unTransmitSpeed = pData->SMED_SPEEDTRANSMITTING;
            UINT64 unRecieveSpeed  = pData->SMED_SPEEDRECEIVING;
            UINT64 u64Sent         = pData->SMED_BYTESTRANSMITTING;
            UINT64 u64Rcvd         = pData->SMED_BYTESRECEIVING;
            INT    idsSent         = IDS_TOOLTIP_LINE_BYTES_SENT;
            INT    idsRcvd         = IDS_TOOLTIP_LINE_BYTES_RCVD;
            INFRASTRUCTURE_MODE infraStructureMode = pData->SMED_INFRASTRUCTURE_MODE;
            DWORD  dwEncryption    = pData->SMED_802_11_ENCRYPTION_ENABLED;
            INT    iSignalStrength = pData->SMED_802_11_SIGNAL_STRENGTH;
            WCHAR  szSSID[32];
            wcsncpy(szSSID, pData->SMED_802_11_SSID, celems(szSSID));

            WCHAR szNamePostFix[celems(nid.szTip)];
            ZeroMemory(szNamePostFix, celems(nid.szTip));

            if ((0 == u64Sent) && (0 == u64Rcvd))
            {
                // Use packets instead.
                //
                u64Sent = pData->SMED_PACKETSTRANSMITTING;
                u64Rcvd = pData->SMED_PACKETSRECEIVING;
                idsSent = IDS_TOOLTIP_LINE_PACKETS_SENT;
                idsRcvd = IDS_TOOLTIP_LINE_PACKETS_RCVD;
            }

            CoTaskMemFree(pData);
            pData = NULL;

            BOOL fNewLine = FALSE;

            // Speed
            //
            if ((unTransmitSpeed >0) || ( unRecieveSpeed >0))
            {
                FormatTransmittingReceivingSpeed (
                unTransmitSpeed,
                unRecieveSpeed,
                pszValue);

                cch = DwFormatString(SzLoadIds(IDS_TOOLTIP_LINE_SPEED), pszLine, celems(pszLine), pszValue);
                CopyAndAdvanceIfSpaceAvailable(pchTip, cchRemaining, pszLine, cch, FALSE);
                fNewLine = TRUE;
            }

            if ( (ncm == NCM_LAN) && (ncsm == NCSM_WIRELESS) )
            {
                switch (infraStructureMode)
                {
                    case IM_NDIS802_11IBSS:
                        DwFormatString(SzLoadIds(IDS_NAME_NETWORK), szNamePostFix, celems(szNamePostFix), SzLoadIds(IDS_TOOLTIP_ADHOC));
                        break;

                    case IM_NDIS802_11INFRASTRUCTURE:
                        if (*szSSID)
                        {
                            DwFormatString(SzLoadIds(IDS_NAME_NETWORK), szNamePostFix, celems(szNamePostFix), szSSID);
                        }
                        else
                        {
                            DwFormatString(SzLoadIds(IDS_NAME_NETWORK), szNamePostFix, celems(szNamePostFix), SzLoadIds(IDS_TOOLTIP_INFRASTRUCTURE));
                        }
                        break;
                    case IM_NDIS802_11AUTOUNKNOWN:
                    case IM_NOT_SUPPORTED:
                    default:
                        break;
                }

                cch = DwFormatString(SzLoadIds(IDS_SIGNAL_STRENGTH), pszLine, celems(pszLine), PszGetRSSIString(iSignalStrength));
                CopyAndAdvanceIfSpaceAvailable(pchTip, cchRemaining, pszLine, cch, fNewLine);
                fNewLine = TRUE;
            }

            if ( IsMediaRASType(ncm) )
            {
                // Bytes or packets sent
                //
                Format64bitInteger(
                    u64Sent,
                    FALSE,
                    pszValue,
                    celems(pszValue));

                cch = DwFormatString(SzLoadIds(idsSent), pszLine, celems(pszLine), pszValue);
                CopyAndAdvanceIfSpaceAvailable(pchTip, cchRemaining, pszLine, cch, fNewLine);

                // Bytes or packets received
                //
                Format64bitInteger(
                    u64Rcvd,
                    FALSE,
                    pszValue,
                    celems(pszValue));

                cch = DwFormatString(SzLoadIds(idsRcvd), pszLine, celems(pszLine), pszValue);
                CopyAndAdvanceIfSpaceAvailable(pchTip, cchRemaining, pszLine, cch, TRUE);
            }

            // Name
            //
            if ((INT)(strName.length() + 1) < cchRemaining)
            {
                WCHAR pszTip [celems(nid.szTip)];
                lstrcpyW(pszTip, strName.c_str());
                if (*szNamePostFix)
                {
                    lstrcatW(pszTip, szNamePostFix);
                }
                lstrcatW(pszTip, L"\n");
                lstrcatW(pszTip, nid.szTip);

                lstrcpyW(nid.szTip, pszTip);
            }
        }
    }
    else   // MEDIA_DISCONNECTED
    {
        WCHAR*  pchTip = nid.szTip;
        INT     cchRemaining = celems(nid.szTip);
        BOOL    fNewLine = FALSE;

        if (ncs == NCS_INVALID_ADDRESS)
        {
            UINT idString = IDS_CONTRAY_ADDRESS_INVALID_TOOLTIP;
            STATMON_ENGINEDATA* pData = NULL;
            tstring strName;
            hr = g_ccl.HrGetCurrentStatsForTrayIconId(uiIcon, &pData, &strName);

            if (S_OK == hr && pData)
            {
                DHCP_ADDRESS_TYPE dhcpAddressType;
                HrGetAutoNetSetting(cle.ccfe.GetGuidID(), &dhcpAddressType);
                if (STATIC_ADDR == dhcpAddressType)
                {
                    idString = IDS_CONTRAY_STATIC_ADDR_INVALID_TOOLTIP;
                }

                CoTaskMemFree(pData);
            }

            lstrcpynW(pszLine, SzLoadIds(idString), celems(pszLine));

            cch = wcslen(pszLine);
        }
        else
        {
            if ( (ncm == NCM_LAN) && (ncsm == NCSM_WIRELESS) )
            {
               lstrcpynW(pszLine, SzLoadIds(IDS_CONTRAY_WIRELESS_DISCONN_BALLOON), celems(pszLine));
               cch = wcslen(pszLine);
            }
            else
            {
                lstrcpynW(pszLine, SzLoadIds(IDS_CONTRAY_MEDIA_DISCONN_BALLOON), celems(pszLine));
                cch = wcslen(pszLine);
            }
        }

        CopyAndAdvanceIfSpaceAvailable(pchTip, cchRemaining, pszLine, cch, fNewLine);
        fNewLine = TRUE;

        hr = g_ccl.HrGetCurrentStatsForTrayIconId(uiIcon, NULL, &strName);
        if (SUCCEEDED(hr))
        {
            // Name
            //
            if ((INT)(strName.length() + 1) < cchRemaining)
            {

                WCHAR pszTip [celems(nid.szTip)];
                lstrcpyW(pszTip, strName.c_str());
                lstrcatW(pszTip, L"\n");
                lstrcatW(pszTip, nid.szTip);

                lstrcpyW(nid.szTip, pszTip);
            }
        }
    }

    hr = HrShell_NotifyIcon(NIM_MODIFY, &nid);
}


//+---------------------------------------------------------------------------
//
//  Member:     CTrayUI::CTrayUI
//
//  Purpose:    Constructor for the CTrayUI class. Initialize the base junk
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     jeffspr   13 Nov 1997
//
//  Notes:
//
CTrayUI::CTrayUI() throw()
{
    TraceFileFunc(ttidSystray);

    // There should only be one of these objects
    //
    Assert(!g_pCTrayUI);

    InitializeCriticalSection(&m_csLock);
    m_uiNextIconId = 0;
    m_uiNextHiddenIconId = UINT_MAX;
}

HRESULT CTrayUI::HrInitTrayUI(VOID)
{
    TraceFileFunc(ttidSystray);

    HRESULT hr  = S_OK;
    HWND    hwnd;

    // create a hidden window
    //
    WNDCLASS wndclass;
    ZeroMemory (&wndclass, sizeof(wndclass));

    wndclass.lpfnWndProc   = CTrayUI_WndProc;
    wndclass.hInstance     = _Module.GetResourceInstance();
    wndclass.lpszClassName = c_szTrayClass;

    RegisterClass (&wndclass);

    hwnd = CreateWindow(c_szTrayClass,
        c_szTrayClass,
        WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        NULL,
        NULL,
        _Module.GetResourceInstance(),
        NULL);

    if (hwnd)
    {
        // Assigned during WM_CREATE
        //
        Assert(hwnd == g_hwndTray);

        ShowWindow(hwnd, SW_HIDE);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    TraceHr(ttidSystray, FAL, hr, FALSE, "CTrayUI::HrInitTrayUI");
    return hr;
}

HRESULT CTrayUI::HrDestroyTrayUI(VOID)
{
    TraceFileFunc(ttidSystray);

    HRESULT hr  = S_OK;

    // Remove the tray icons before destroying ourselves
    //
    g_ccl.FlushTrayIcons();

    if (g_hwndTray)
    {
        // Don't bother checking the return code here. Most likely, this window
        // is already gone by the time the tray is calling our shutdown.. We'll
        // still grab the return code for debugging purposes, though.
        //
        BOOL fReturn = DestroyWindow(g_hwndTray);

        g_hwndTray = NULL;
    }

    TraceHr(ttidSystray, FAL, hr, FALSE, "CTrayUI::HrDestroyTrayUI");
    return S_OK;
}

VOID SetIconFocus(HWND hwnd, UINT uiIcon) throw()
{
    TraceFileFunc(ttidSystray);

    HRESULT hr;
    NOTIFYICONDATA nid;

    ZeroMemory (&nid, sizeof(nid));
    nid.cbSize  = sizeof(NOTIFYICONDATA);
    nid.hWnd    = hwnd;
    nid.uID     = uiIcon;

    hr = HrShell_NotifyIcon(NIM_SETFOCUS, &nid);
    TraceHr(ttidSystray, FAL, hr, FALSE, "SetIconFocus");
}

//+---------------------------------------------------------------------------
//
//  Function:   CheckMenuPermissions
//
//  Purpose:    Update the tray items based on system policy
//
//  Arguments:
//      hmenu [in]  The tray context menu
//
//  Returns:
//
//  Author:     jeffspr   8 Apr 1999
//
//  Notes:
//
VOID CheckMenuPermissions(IN  HMENU hmenu, IN  const CONFOLDENTRY& ccfe) throw()
{
    TraceFileFunc(ttidSystray);

    // Check the permissions for bringing up statistics. If no,
    // then disable the context menu item
    //
    if (!FHasPermission(NCPERM_Statistics))
    {
        // Enable or disable the menu item, as appopriate
        //
        EnableMenuItem(
            hmenu,
            CMIDM_TRAY_STATUS,
            MF_GRAYED);
    }

    // Check the permission to disconnect
    BOOL fCanDisconnect = TRUE;

    switch(ccfe.GetNetConMediaType())
    {
        case NCM_LAN:
        case NCM_BRIDGE:
            fCanDisconnect = FHasPermission(NCPERM_LanConnect);
            if (!FHasPermission(NCPERM_Repair))
            {
                EnableMenuItem(
                    hmenu,
                    CMIDM_TRAY_REPAIR,
                    MF_GRAYED);
            }
            break;
        case NCM_PPPOE:
        case NCM_DIRECT:
        case NCM_ISDN:
        case NCM_PHONE:
        case NCM_TUNNEL:
        case NCM_NONE:
            fCanDisconnect = FHasPermission(NCPERM_RasConnect);
            break;
        case NCM_SHAREDACCESSHOST_LAN:
        case NCM_SHAREDACCESSHOST_RAS:
            fCanDisconnect = TRUE; // group policy is enforced by the enumerator, if you can see it you can use it.
            break;
        default:
            AssertSz(FALSE, "Need to add a switch for this connection type in the menuing code");
            break;
    }

    if (!fCanDisconnect)
    {
        EnableMenuItem(
            hmenu,
            CMIDM_TRAY_DISCONNECT,
            MF_GRAYED);

    }
}

//+---------------------------------------------------------------------------
//
//  Function:   FAddMenuBranding
//
//  Purpose:    Process the CM branding tray menu extensions. Add them to the
//              menu if needed
//
//  Arguments:
//      hmenu         [in]  Incoming hmenu
//      cle           [in]  Our cache entry
//      IdMinMenuID   [in]  The smallest allowable menu ID to use
//      piIdCustomMin [out] Our custom range min
//      piIdCustomMax [out] Our custom range max
//
//  Returns:    TRUE if we added anything, FALSE if we didn't
//
//  Author:     jeffspr   8 Apr 1999
//
//  Notes:
//
BOOL FAddMenuBranding(
                      IN  HMENU                   hmenu,
                      IN  const ConnListEntry&    cle,
                      IN  INT                     IdMinMenuID,
                      OUT INT *                   piIdCustomMin,
                      OUT INT *                   piIdCustomMax) throw()
{
    TraceFileFunc(ttidSystray);

    BOOL    fBranded        = FALSE;
    int     iIdCustomMin    = -1;
    int     iIdCustomMax    = -1;
    HMENU   hmenuTrack      = NULL;

    Assert(hmenu);
    Assert(!cle.empty());
    Assert(!cle.ccfe.empty());

    if (cle.ccfe.GetCharacteristics() & NCCF_BRANDED)
    {
        // we may have custom menus for CM connections, merge them in
        //
        const CON_TRAY_MENU_DATA* pMenuData = cle.pctmd;
        if (pMenuData)
        {
            Assert(pMenuData->dwCount);

            int cMenuItems = GetMenuItemCount(hmenu);
            if (-1 == cMenuItems)
            {
                TraceLastWin32Error("GetMenuItemCount failed on tray menu");
            }
            else
            {
                BOOL fRet;
                MENUITEMINFO mii;

                // add a separator bar
                ZeroMemory(&mii, sizeof(mii));
                mii.cbSize = sizeof(mii);
                mii.fMask = MIIM_TYPE;
                mii.fType = MFT_SEPARATOR;

                fRet = InsertMenuItem( hmenu,
                    cMenuItems++,
                    TRUE,    // fByPosition
                    &mii);
                if (fRet)
                {
                    DWORD dwCount = pMenuData->dwCount;
                    CON_TRAY_MENU_ENTRY * pMenuEntry = pMenuData->pctme;

                    // this is the first id for our custom menu items
                    iIdCustomMin = CMIDM_FIRST+cMenuItems+1;
                    iIdCustomMin = iIdCustomMin < IdMinMenuID ? IdMinMenuID : iIdCustomMin;

                    iIdCustomMax = iIdCustomMin+dwCount;

                    int iMenu = 0;

                    while (dwCount)
                    {
                        Assert(pMenuEntry);
                        fRet = AppendMenu(  hmenu,
                            MF_STRING,
                            iIdCustomMin+iMenu,
                            pMenuEntry->szwMenuText);

                        if (!fRet)
                        {
                            DWORD dwError = GetLastError();

                            TraceTag(ttidSystray, "Failed adding custom menu: %S, error: %d",
                                pMenuEntry->szwMenuText,
                                dwError);
                        }

                        // move to the next item
                        iMenu++;
                        dwCount--;
                        pMenuEntry++;
                    }

                    // Mark it as branded to say "hey, we actually added items"
                    //
                    fBranded = TRUE;
                }
            }
        }
    }

    if (fBranded)
    {
        *piIdCustomMin = iIdCustomMin;
        *piIdCustomMax = iIdCustomMax;
    }

    return fBranded;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrProcessBrandedTrayMenuCommand
//
//  Purpose:    Perform the custom action specified in the selected
//              branded menu
                      //
                      //  Arguments:
                      //      iMenuEntry [in]     Our branded command
                      //      pMenuData  [in]     Our branded menu struct
//
//  Returns:
//
//  Author:     jeffspr   8 Apr 1999
//
//  Notes:
//
HRESULT HrProcessBrandedTrayMenuCommand(IN  INT                        iMenuEntry,
                                        IN  const CON_TRAY_MENU_DATA * pMenuData)
{
    TraceFileFunc(ttidSystray);

    HRESULT hr  = S_OK;

    Assert(iMenuEntry != -1);
    Assert(pMenuData);

    DWORD dwCount = pMenuData->dwCount;

    Assert(dwCount > 0);

    const CON_TRAY_MENU_ENTRY * pMenuEntry = pMenuData->pctme + iMenuEntry;
    Assert(pMenuEntry);

    SHELLEXECUTEINFO seiTemp    = { 0 };

    //  Fill in the data structure
    //
    seiTemp.cbSize          = sizeof(SHELLEXECUTEINFO);
    seiTemp.fMask           = SEE_MASK_DOENVSUBST;
    seiTemp.hwnd            = NULL;
    seiTemp.lpVerb          = NULL;
    seiTemp.lpFile          = pMenuEntry->szwMenuCmdLine;
    seiTemp.lpParameters    = pMenuEntry->szwMenuParams;
    seiTemp.lpDirectory     = NULL;
    seiTemp.nShow           = SW_SHOW;
    seiTemp.hInstApp        = NULL;
    seiTemp.hProcess        = NULL;

    // Launch the tool
    //
    if (!::ShellExecuteEx(&seiTemp))
    {
        hr = ::HrFromLastWin32Error();
    }

    TraceHr(ttidSystray, FAL, hr, FALSE, "HrProcessBrandedMenuCommand");
    return hr;
}

HRESULT HrOpenContextMenu(IN  HWND hwnd, IN  const POINT * pPoint, IN  UINT uiIcon)
{
    TraceFileFunc(ttidSystray);

    HRESULT         hr                      = S_OK;
    INT             iCmd                    = 0;
    HMENU           hmenu                   = 0;
    PCONFOLDPIDL    pidlItem;
    BOOL            fSetIconFocus           = TRUE;
    INT             iIdCustomMin            = -1;
    INT             iIdCustomMax            = -1;
    BOOL            fBranded                = FALSE;

    Assert(pPoint);
    Assert(hwnd);

    // Find the connection info based on the tray icon id.
    //
    ConnListEntry cle;
    hr = g_ccl.HrFindConnectionByTrayIconId(uiIcon, cle);
    if (hr == S_OK)
    {
        Assert(!cle.ccfe.empty());

        if (!cle.ccfe.empty())
        {
            // Load the menu resource
            //
            INT iMenuToLoad = POPUP_CONTRAY_GENERIC_MENU_RAS;

            if (cle.ccfe.GetNetConStatus() ==  NCS_MEDIA_DISCONNECTED)
            {
                if (IsMediaLocalType(cle.ccfe.GetNetConMediaType()) &&
                    (NCSM_WIRELESS == cle.ccfe.GetNetConSubMediaType()) )
                {
                    iMenuToLoad = POPUP_CONTRAY_WIRELESS_DISCONNECTED_LAN;
                }
                else
                {
                    iMenuToLoad = POPUP_CONTRAY_MEDIA_DISCONNECTED_MENU;
                }
            }
            else if (IsMediaLocalType(cle.ccfe.GetNetConMediaType()) || NCM_SHAREDACCESSHOST_LAN == cle.ccfe.GetNetConMediaType())
            {
                if (NCSM_WIRELESS == cle.ccfe.GetNetConSubMediaType())
                {
                    iMenuToLoad = POPUP_CONTRAY_GENERIC_MENU_WIRELESS_LAN;
                }
                else
                {
                    iMenuToLoad = POPUP_CONTRAY_GENERIC_MENU_LAN;
                }
            }

            hmenu = LoadMenu(_Module.GetResourceInstance(), MAKEINTRESOURCE(iMenuToLoad));
            if (!hmenu)
            {
                hr = E_FAIL;
            }

            if (SUCCEEDED(hr))
            {
                // Get the first menu from the popup. For some reason, this hack is
                // required instead of tracking on the outside menu
                //
                HMENU   hmenuTrack  = GetSubMenu(hmenu, 0);

                //Repair is only availabe for LAN and Bridge adapters
                if ( ((POPUP_CONTRAY_GENERIC_MENU_LAN == iMenuToLoad) ||
                      (POPUP_CONTRAY_GENERIC_MENU_WIRELESS_LAN == iMenuToLoad)) &&
                     (NCM_BRIDGE != cle.ccfe.GetNetConMediaType()) &&
                     (NCM_LAN != cle.ccfe.GetNetConMediaType()) )
                {
                    DeleteMenu(hmenuTrack,
                               CMIDM_TRAY_REPAIR,
                               MF_BYCOMMAND);
                }

                // Don't drop out of the loop if we can't get this right.
                //
                CheckMenuPermissions(hmenuTrack, cle.ccfe);
                fBranded = FAddMenuBranding(hmenuTrack, cle, CMIDM_TRAY_MAX+1, &iIdCustomMin, &iIdCustomMax);

                // Set the default menu item
                //
                if (cle.ccfe.GetNetConStatus() == NCS_MEDIA_DISCONNECTED)
                {
                    if (IsMediaLocalType(cle.ccfe.GetNetConMediaType()) &&
                        (NCSM_WIRELESS == cle.ccfe.GetNetConSubMediaType()) )
                    {
                        SetMenuDefaultItem(hmenuTrack, c_idDefaultDisconCMWirelessCommand, FALSE);
                    }
                    else
                    {
                        SetMenuDefaultItem(hmenuTrack, c_idDefaultDisconCMCommand, FALSE);
                    }
                }
                else
                {
                    SetMenuDefaultItem(hmenuTrack, c_idDefaultCMCommand, FALSE);
                }

                // Set the owner window to be foreground as a hack so the
                // popup menu disappears when the user clicks elsewhere.
                //
                SetForegroundWindow(hwnd);

                // Part of the above hack. Bring up the menu and figure out the result
                iCmd = TrackPopupMenu(hmenuTrack, TPM_RETURNCMD | TPM_NONOTIFY | TPM_RIGHTBUTTON,
                    pPoint->x, pPoint->y, 0, hwnd, NULL);
                DestroyMenu(hmenu);

                MSG msgTmp;
                while (PeekMessage(&msgTmp, hwnd, WM_LBUTTONDOWN, WM_LBUTTONUP, PM_REMOVE))
                {
                    DispatchMessage(&msgTmp);
                }

                // Process the command
                //
                switch (iCmd)
                {
                case CMIDM_OPEN_CONNECTIONS_FOLDER:
                    hr = HrOpenConnectionsFolder();

                    if (S_OK == hr)
                    {
                        // The folder should have focus
                        fSetIconFocus = FALSE;
                    }
                    break;

                case CMIDM_TRAY_REPAIR:
                    HrOnCommandFixInternal(
                            cle.ccfe,
                            g_hwndTray,
                            NULL);
                    break;

                case CMIDM_TRAY_WZCDLG_SHOW:
                    {
                        PCONFOLDPIDLVEC pcfpVec;
                        PCONFOLDPIDL    pcfp;
                        hr = cle.ccfe.ConvertToPidl(pcfp);
                        if (SUCCEEDED(hr))
                        {
                            pcfpVec.insert(pcfpVec.begin(), pcfp);
                            HrOnCommandWZCDlgShow(pcfpVec,
                            g_hwndTray,
                            NULL);
                        }
                    }
                    break;

                case CMIDM_TRAY_DISCONNECT:
                    // Ignore the return from this. If it's NULL, we'll just
                    // pass it in, and it just won't get refreshed properly
                    //
                    hr = HrOnCommandDisconnectInternal(
                        cle.ccfe,
                        g_hwndTray,
                        NULL);

                    // Normalize the return code on success. We don't care
                    // if the dialog was canceled or not.
                    //
                    switch(hr)
                    {
                        // If succeeded, mark us as disconnected.
                        //
                    case S_OK:
                        // If we disconnected and the icon went away, then don't
                        // bother trying to set the focus back
                        //
                        fSetIconFocus = FALSE;
                        break;

                        // If S_FALSE, we didn't disconnect. Go ahead
                        // and normalize the return code.
                        //
                    case S_FALSE:
                        hr = S_OK;
                        break;
                    }
                    break;

                    case CMIDM_TRAY_STATUS:
                        hr = HrOnCommandStatusInternal(cle.ccfe, FALSE);
                        break;

                    case 0:
                        // Tray menu cancelled without selection
                        break;

                    default:
                        if ((iCmd >= iIdCustomMin) && (iCmd < iIdCustomMax))
                        {
                            AssertSz(fBranded, "Hey, what fool added this command?");
                            hr = HrProcessBrandedTrayMenuCommand(iCmd-iIdCustomMin, cle.pctmd);
                        }
                        else
                        {
                            AssertSz(FALSE, "Not in custom range, not a known command, what the...?");
                        }
                        break;
                }

                if (fSetIconFocus)
                {
                    // Shift the focus back to the shell
                    //
                    SetIconFocus(hwnd, uiIcon);
                }
            }
        }
        else
        {
            // Data returned from the FindByIconId was bogus
            //
            hr = E_FAIL;
        }
    }
    else // Orphaned item -remove it.
    {
        NOTIFYICONDATA  nid;

        ZeroMemory (&nid, sizeof(nid));
        nid.cbSize  = sizeof(NOTIFYICONDATA);
        nid.hWnd    = g_hwndTray;
        nid.uID = uiIcon;
        hr = HrShell_NotifyIcon(NIM_DELETE, &nid);

        TraceTag(ttidSystray, "WARNING: Connection not found opening context menu, hr: 0x%08x, uiIcon: %d", hr, uiIcon);
        // Removed this assert because we can have a valid state in the connections folder
        // where we've updated our cache but the PostMessages to remove the tray icons
        // haven't come through yet.
        //
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   OnTrayWmCreate
//
//  Purpose:    Tray window message handler for WM_CREATE.
//              We will perform the connection enumeration and create the
//              appropriate taskbar icons, including the generic connection
//              icon if no connections were present.
//
//  Arguments:
//      hwnd [in]   Tray window
//
//  Returns:
//
//  Author:     jeffspr   14 Dec 1997
//
//  Notes:
//
LRESULT OnTrayWmCreate(IN  HWND hwnd) throw()
{
    TraceFileFunc(ttidSystray);

    BOOL    fResult = 0;
    DWORD   dwIconsAdded  = 0;

    // Do the connections enumeration and add the icons.
    // fResult it for debugging only. We'll always do everything here
    //
    fResult = FInitFoldEnumerator(hwnd, &dwIconsAdded);

    g_ccl.EnsureIconsPresent();

    ac_Register(hwnd); // homenet auto config service
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   OnTrayWmDestroy
//
//  Purpose:    Tray window message handler for WM_DESTROY.
//              We will perform the connection enumeration and create the
//              appropriate taskbar icons, including the generic connection
//              icon if no connections were present.
//
//  Arguments:
//      hwnd [in]   Tray window
//
//  Returns:
//
//  Author:     jeffspr   14 Dec 1997
//
//  Notes:
//
LRESULT OnTrayWmDestroy(IN  HWND hwnd) throw()
{
    TraceFileFunc(ttidSystray);

    ac_Unregister(hwnd);
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   CTrayUI_WndProc
//
//  Purpose:    Window proc for the tray's hidden window
//
//  Arguments:
//      hwnd      [in]    See windows documentation
//      uiMessage [in]    See windows documentation
//      wParam    [in]    See windows documentation
//      lParam    [in]    See windows documentation
//
//  Returns:    See windows documentation
//
//  Author:     jeffspr   14 Dec 1997
//
//  Notes:
//
LRESULT
CALLBACK
CTrayUI_WndProc (
                 IN  HWND    hwnd,       // window handle
                 IN  UINT    uiMessage,  // type of message
                 IN  WPARAM  wParam,     // additional information
                 IN  LPARAM  lParam)  throw() // additional information
{
    TraceFileFunc(ttidSystray);

    switch (uiMessage)
    {
    case WM_CREATE:
        // Note: Move this to a better place.
        g_hwndTray = hwnd;
        return OnTrayWmCreate(hwnd);

    case WM_DESTROY:
        return OnTrayWmDestroy(hwnd);

    case MYWM_NOTIFYICON:
        return OnMyWMNotifyIcon(hwnd, uiMessage, wParam, lParam);

    case MYWM_OPENSTATUS:
        return OnMyWMOpenStatus(hwnd, wParam, lParam);

    case MYWM_ADDTRAYICON:
        return OnMyWMAddTrayIcon(hwnd, wParam, lParam);

    case MYWM_REMOVETRAYICON:
        return OnMyWMRemoveTrayIcon(hwnd, wParam, lParam);

    case MYWM_UPDATETRAYICON:
        return OnMyWMUpdateTrayIcon(hwnd, wParam, lParam);

    case MYWM_SHOWBALLOON:
        return OnMyWMShowTrayIconBalloon(hwnd, wParam, lParam);

    case MYWM_FLUSHNOOP:
        return OnMyWMFlushNoop(hwnd, wParam, lParam);

    case WM_DEVICECHANGE:
        return ac_DeviceChange(hwnd, uiMessage, wParam, lParam);

    default:                                 // Passes it on if unproccessed
        return (DefWindowProc (hwnd, uiMessage, wParam, lParam));
    }
    return (0);
}

//+---------------------------------------------------------------------------
//
//  Function:   HrDoMediaDisconnectedIcon
//
//  Purpose:    Add a Media-disconnected icon to the tray. We're in the
//              state where our cable is unplugged on a LAN adapter and
//              we want to inform the user of the situation
//
//  Arguments:
//      pccfe           [in]  Our connection
//      fShowBalloon    [in]  Show the balloon tip?
//
//  Returns:
//
//  Author:     jeffspr   14 Jul 1999
//
//  Notes:
//
HRESULT HrDoMediaDisconnectedIcon(IN  const CONFOLDENTRY& pccfe, IN  BOOL fShowBalloon)
{
    TraceFileFunc(ttidSystray);

    HRESULT hr      = S_OK;
    UINT    uiIcon  = 0;

    TraceTag(ttidSystray, "HrDoMediaDisconnectedIcon");

    DWORD dwLockingThreadId = 0;
    hr = HrGetTrayIconLock(&(pccfe.GetGuidID()), &uiIcon, &dwLockingThreadId);
    if (S_OK == hr)
    {
        if (uiIcon == BOGUS_TRAY_ICON_ID)
        {
            TraceTag(ttidSystray, "Adding MediaDisconnected icon for: %S", pccfe.GetName());
            NETCON_MEDIATYPE ncm = pccfe.GetNetConMediaType();
            if (IsMediaLocalType(ncm) || IsMediaSharedAccessHostType(ncm)) // ics beacon will say disconnected if it is in a unknown state.
            {
                HICON hiconTray = LoadIcon(_Module.GetResourceInstance(),
                    MAKEINTRESOURCE(IDI_CFT_DISCONNECTED));

                if (hiconTray)
                {
                    ConnListEntry cleFind;
                    g_ccl.AcquireWriteLock();
                    hr = g_ccl.HrFindConnectionByGuid(&(pccfe.GetGuidID()), cleFind);
                    if (S_OK == hr)
                    {
                        Assert(!cleFind.ccfe.empty());

                        g_ccl.HrUpdateTrayBalloonInfoByGuid(&(pccfe.GetGuidID()), BALLOON_USE_NCS, NULL, NULL);
                        g_ccl.ReleaseWriteLock();

                        NOTIFYICONDATA  nid;

                        ZeroMemory (&nid, sizeof(nid));
                        nid.cbSize              = sizeof(NOTIFYICONDATA);
                        nid.hWnd                = g_hwndTray;
                        nid.uID                 = g_pCTrayUI->m_uiNextIconId++;
                        nid.uFlags              = NIF_MESSAGE | NIF_ICON | NIF_STATE;
                        nid.uCallbackMessage    = MYWM_NOTIFYICON;
                        nid.hIcon               = hiconTray;

                        if (fShowBalloon)
                        {
                            nid.uFlags |= NIF_INFO;
                            nid.dwInfoFlags = NIIF_INFO | NIIF_NOSOUND;
                            nid.uTimeout = c_dwBalloonTimeoutSeconds * 1000;

                            if (lstrlenW(pccfe.GetName()) >= celems(nid.szInfoTitle))
                            {
                                lstrcpynW(nid.szInfoTitle, pccfe.GetName(),
                                    celems(nid.szInfoTitle) -
                                    celems(c_szDotDotDot) - 1);
                                lstrcatW(nid.szInfoTitle, c_szDotDotDot);
                            }
                            else
                            {
                                lstrcpyW(nid.szInfoTitle, pccfe.GetName());
                            }

                            if ( (pccfe.GetNetConMediaType() == NCM_LAN) && (pccfe.GetNetConSubMediaType() == NCSM_WIRELESS) )
                            {
                                lstrcpyW(nid.szInfo, SzLoadIds(IDS_CONTRAY_WIRELESS_DISCONN_BALLOON));
                            }
                            else
                            {
                                lstrcpyW(nid.szInfo, SzLoadIds(IDS_CONTRAY_MEDIA_DISCONN_BALLOON));
                            }
                        }

                        hr = HrShell_NotifyIcon(NIM_ADD, &nid);

                        if (SUCCEEDED(hr))
                        {
                            Assert(!pccfe.empty());

                            // Update the connection list with the new icon identifier
                            //
                            hr = g_ccl.HrUpdateTrayIconDataByGuid(
                                &(pccfe.GetGuidID()),
                                NULL,
                                NULL,
                                NULL,
                                nid.uID);

                            if (SUCCEEDED(hr))
                            {
                                hr = g_ccl.HrUpdateTrayBalloonInfoByGuid(&(pccfe.GetGuidID()), BALLOON_USE_NCS, NULL, NULL);
                            }

                            TraceTag(ttidSystray, "Successfully added mediadisconnected icon for %S, uiIcon: %d",
                                pccfe.GetName(), nid.uID);
                        }
                    }
                    else
                    {
                        g_ccl.ReleaseWriteLock();
                    }
                }
            }
            else
            {
                AssertSz(IsMediaLocalType(pccfe.GetNetConMediaType()) || IsMediaSharedAccessHostType(pccfe.GetNetConMediaType()), "I need a dangling cable, not a phone line");
            }
        }
        else
        {
            TraceTag(ttidSystray, "Preventing the addition of a duplicate media "
                "disconnected icon. uiIcon == %d", uiIcon);
        }

        ReleaseTrayIconLock(&(pccfe.GetGuidID()));
    }
    else
    {
        TraceTag(ttidSystray, "Can't get tray icon lock in HrDoMediaDisconnectedIcon for uiIcon: %d as it has been locked by thread %d", uiIcon, dwLockingThreadId);
        // Someone else is already mucking with this icon
        hr = S_FALSE;
    }

    TraceHr(ttidSystray, FAL, hr, FALSE, "HrDoMediaDisconnectedIcon");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   OnMyWMAddTrayIcon
//
//  Purpose:    Process the status message for the tray window
//
//  Arguments:
//      hwnd    [in]
//      wParam  [in] Pointer to CCONFOLDENTRY.
//      lParam  [in] TRUE if we are to briefly show the balloon.
//
//  Returns:
//
//  Author:
//
//  Notes:
//
//
LRESULT OnMyWMAddTrayIcon(IN  HWND hwnd, IN  WPARAM wParam, IN  LPARAM lParam) throw()
{
    TraceFileFunc(ttidSystray);

    HRESULT                 hr                  = S_OK;
    HICON                   hIcon               = NULL;
    INetStatisticsEngine *  pnseStats           = NULL;
    IConnectionPoint *      pcpStat             = NULL;
    CConnectionTrayStats *  pccts               = NULL;
    CONFOLDENTRY            pccfe;
    BOOL                    fStaticIcon         = FALSE;
    BOOL                    fBrieflyShowBalloon = (BOOL) lParam;
    NOTIFYICONDATA          nid;
    UINT                    uiIcon;

    Assert(wParam);
    pccfe.InitializeFromItemIdList(reinterpret_cast<LPCITEMIDLIST>(wParam));
    ::SHFree(reinterpret_cast<LPITEMIDLIST>(wParam));

    Assert(!pccfe.empty());
    Assert(pccfe.FShouldHaveTrayIconDisplayed());

    TraceTag(ttidSystray, "In OnMyWMAddTrayIcon message handler");

    if (pccfe.GetNetConStatus() == NCS_MEDIA_DISCONNECTED)
    {
        hr = HrDoMediaDisconnectedIcon(pccfe, fBrieflyShowBalloon);
        goto Exit;
    }

    // Raid #379459: If logged in as non-admin and incoming, don't show systray icon
    if (FIsUserAdmin() ||
        !(pccfe.GetCharacteristics() & NCCF_INCOMING_ONLY))
    {
        g_ccl.AcquireWriteLock();

        DWORD dwLockingThreadId = 0;
        hr = HrGetTrayIconLock(&(pccfe.GetGuidID()), &uiIcon, &dwLockingThreadId);
        if (S_OK == hr)
        {
            ConnListEntry cle;
            hr = g_ccl.HrFindConnectionByGuid(&(pccfe.GetGuidID()), cle);
            if (S_OK == hr)
            {
                g_ccl.HrUpdateTrayBalloonInfoByGuid(&(pccfe.GetGuidID()), BALLOON_USE_NCS, NULL, NULL);
                g_ccl.ReleaseWriteLock();

                if (uiIcon == BOGUS_TRAY_ICON_ID)
                {
                    // Try to load the branded tray icon, if present
                    //
                    if (pccfe.GetCharacteristics() & NCCF_BRANDED)
                    {
                        if (cle.pcbi && cle.pcbi->szwTrayIconPath)
                        {
                            hIcon = (HICON) LoadImage(
                                NULL,
                                cle.pcbi->szwTrayIconPath,
                                IMAGE_ICON,
                                0, 0,
                                LR_LOADFROMFILE);

                            if (hIcon)
                            {
                                // When we create the ConTrayStats object, we'll mark it as having
                                // a static icon so we don't update it on stat changes.
                                //
                                fStaticIcon = TRUE;
                            }
                        }
                    }

                    // If either the branded icon wasn't present or didn't load, or there
                    // was no branding to begin with, load the standard icon
                    //
                    if (!hIcon)
                    {
                        INT iConnIcon = IGetCurrentConnectionTrayIconId(pccfe.GetNetConMediaType(), pccfe.GetNetConStatus(), SMDCF_NULL);
                        hIcon = g_pCTrayUI->GetCachedHIcon(iConnIcon);
                    }
                }

                ZeroMemory (&nid, sizeof(nid));
                nid.cbSize              = sizeof(NOTIFYICONDATA);
                nid.hWnd                = g_hwndTray;
                nid.uID                 = g_pCTrayUI->m_uiNextIconId++;
                nid.uFlags              = NIF_MESSAGE | NIF_ICON | NIF_STATE;
                nid.uCallbackMessage    = MYWM_NOTIFYICON;
                nid.hIcon               = hIcon;

                // If we're not static, then tell the tray that we're using the cached icons
                //
                if (!fStaticIcon)
                {
                    nid.dwState  = NIS_SHAREDICON;
                    if (IsMediaRASType(pccfe.GetNetConMediaType()) ||
                        (NCM_SHAREDACCESSHOST_RAS == pccfe.GetNetConMediaType()) ||
                        ( (NCM_LAN == pccfe.GetNetConSubMediaType()) &&
                          (NCSM_WIRELESS == pccfe.GetNetConSubMediaType()) )
                       )
                    {
                         nid.dwState |= NIS_SHOWALWAYS;
                    }
                    nid.dwStateMask     = nid.dwState;
                }

                // Create the statistics objects
                //
                hr = HrGetStatisticsEngineForEntry(pccfe, &pnseStats, TRUE);
                if (SUCCEEDED(hr))
                {
                    // Advise the interface
                    hr = HrGetPcpFromPnse(pnseStats, &pcpStat);
                    if (SUCCEEDED(hr))
                    {
                        INetConnectionStatisticsNotifySink *  pncsThis;
                        hr = CConnectionTrayStats::CreateInstance (
                            pccfe,
                            nid.uID,
                            fStaticIcon,
                            IID_INetConnectionStatisticsNotifySink,
                            reinterpret_cast<VOID**>(&pncsThis));

                        if (SUCCEEDED(hr))
                        {
                            pccts = reinterpret_cast<CConnectionTrayStats*>(pncsThis);

                            hr = pnseStats->StartStatistics();

                            if (SUCCEEDED(hr))
                            {
                                // Don't release this. We need to store it with
                                // the entry so we can UnAdvise later
                                //
                                hr = pcpStat->Advise(pncsThis, pccts->GetConPointCookie());
                            }
                        }

                        if (fBrieflyShowBalloon)
                        {
                            if ( (NCS_CONNECTED                == pccfe.GetNetConStatus()) ||
                                 (NCS_AUTHENTICATION_SUCCEEDED == pccfe.GetNetConStatus()) ||
                                 (NCS_INVALID_ADDRESS          == pccfe.GetNetConStatus()) )
                            {
                                nid.uFlags |= NIF_INFO;
                                nid.dwInfoFlags = NIIF_INFO | NIIF_NOSOUND;
                                nid.uTimeout = c_dwBalloonTimeoutSeconds * 1000;

                                UINT idTitle = (NCS_INVALID_ADDRESS == pccfe.GetNetConStatus()) ?
                                                IDS_BALLOON_UNAVAILABLE : IDS_BALLOON_CONNECTED;

                                // Maximum balloon string length including NULL.
                                //
                                int cchMaxStringLen = celems(nid.szInfoTitle);

                                // Title string is really a status string with
                                // insertion characters for the connection name
                                // (e.g. "%1 is now connected").
                                // So status length is title length minus
                                // insertion (%1) characters.
                                //
                                int cchIdStatus = lstrlenW(SzLoadIds(idTitle)) - 2;

                                // Connection name length.
                                //
                                int cchName = lstrlenW(pccfe.GetName());

                                // Check if connection name + status
                                // will fit in the balloon tip.
                                //
                                if ((cchName + cchIdStatus) >= cchMaxStringLen)
                                {
                                    // Name + status was too long. Check if
                                    // just the Name will fit.
                                    //
                                    if (cchName >= cchMaxStringLen)
                                    {
                                        // Name was too long.  Copy a portion
                                        // of it into the balloon tip and
                                        // append continuation dots.
                                        //

                                        // Note: Continuation dots length - NULL = celems(c_szDotDotDot) - 1
                                        //
                                        lstrcpynW(nid.szInfoTitle, pccfe.GetName(), cchMaxStringLen - (celems(c_szDotDotDot) - 1));

                                        lstrcatW(nid.szInfoTitle, c_szDotDotDot);
                                    }
                                    else
                                    {
                                        // Copy name into balloon tip.
                                        //
                                        lstrcpy(nid.szInfoTitle, pccfe.GetName());
                                    }
                                }
                                else
                                {
                                    // Format connection status string (name + status)
                                    // into balloon tip.
                                    //
                                    DwFormatString(SzLoadIds(idTitle), nid.szInfoTitle, cchMaxStringLen, pccfe.GetName());
                                }

                                AssertSz(lstrlenW(nid.szInfoTitle) < celems(nid.szInfoTitle),
                                    "Balloon tooltip text is too long!");


                                if (pccfe.GetNetConStatus() == NCS_INVALID_ADDRESS)
                                {
                                    STATMON_ENGINEDATA* pData = NULL;
                                    UINT idString = IDS_CONTRAY_ADDRESS_INVALID_BALLOON;
                                    if (S_OK == pnseStats->GetStatistics(&pData) && pData)
                                    {
                                        DHCP_ADDRESS_TYPE dhcpAddressType;
                                        HrGetAutoNetSetting(pccfe.GetGuidID(), &dhcpAddressType);
                                        if (STATIC_ADDR == dhcpAddressType)
                                        {
                                            idString = IDS_CONTRAY_STATIC_ADDR_INVALID_BALLON;
                                        }

                                        CoTaskMemFree(pData);
                                    }

                                    lstrcpynW(nid.szInfo, SzLoadIds(idString), celems(nid.szInfo));
                                }
                                else
                                {
                                    GetInitialBalloonText(
                                        pnseStats,
                                        nid.szInfo,
                                        celems(nid.szInfo));
                                }
                            }
                        }

                        // Add the icon itself.
                        //
                        TraceTag(ttidSystray, "Adding shared shell icon: uID=%u, hIcon=0x%x",
                            nid.uID,
                            nid.hIcon);

                        hr = HrShell_NotifyIcon(NIM_ADD, &nid);
                        if (SUCCEEDED(hr) && pccts)
                        {
                            Assert(!pccfe.empty());

                            // Update the connection list with the new icon identifier
                            //
                            hr = g_ccl.HrUpdateTrayIconDataByGuid(
                                &(pccfe.GetGuidID()),
                                pccts,
                                pcpStat,
                                pnseStats,
                                nid.uID);

                            if (SUCCEEDED(hr))
                            {
                                hr = g_ccl.HrUpdateTrayBalloonInfoByGuid(&(pccfe.GetGuidID()), BALLOON_USE_NCS, NULL, NULL);
                            }

                        }

                        ::ReleaseObj(pccts);
                        ::ReleaseObj(pcpStat);
                    }
                    ::ReleaseObj(pnseStats);
                }
            }
            else
            {
                g_ccl.ReleaseWriteLock();
            }

            // Release the lock on the tray icon
            //
            ReleaseTrayIconLock(&(pccfe.GetGuidID()));
        }
        else
        {
            g_ccl.ReleaseWriteLock();

            // Could not obtain an icon lock
            //
#ifdef DBG
            if (S_FALSE == hr)
            {
                Assert(dwLockingThreadId);
                TraceTag(ttidSystray, "Tray icon locked by thread id %d", dwLockingThreadId);
            }
            else
            {
                TraceTag(ttidError, "Could not obtain tray icon data for connection %S", pccfe.GetName());
            }
#endif
            hr = S_FALSE;
        }
    }
    else
    {
        // Non-admin, or incoming connection
        //
        hr = S_FALSE;
    }

Exit:
    TraceHr(ttidSystray, FAL, hr, SUCCEEDED(hr), "OnMyWMAddTrayIcon");
    return 0;
}



//+---------------------------------------------------------------------------
//
//  Function:   OnMyRemoveTrayIcon
//
//  Purpose:    Process the status message for the tray window
//
//  Arguments:
//      hwnd    []
//      wParam  []
//      lParam  []
//
//  Returns:
//
//  Author:
//
//  Notes:
//
//
LRESULT OnMyWMRemoveTrayIcon(IN  HWND hwnd, IN  WPARAM wParam, IN  LPARAM lParam) throw()
{
    TraceFileFunc(ttidSystray);

    HRESULT         hr = E_FAIL;
    GUID *          pGuid            = reinterpret_cast<GUID *>(lParam);
    NOTIFYICONDATA  nid;

    // This is returned from a cle, hence should be locked
#ifdef VERYSTRICTCOMPILE
    const CTrayIconData * pTrayIconData = reinterpret_cast<const CTrayIconData *>(wParam);
#else
    CTrayIconData * pTrayIconData = reinterpret_cast<CTrayIconData *>(wParam);
#endif


    TraceTag(ttidSystray, "In OnMyWMRemoveTrayIcon message handler");

    ZeroMemory (&nid, sizeof(nid));
    nid.cbSize  = sizeof(NOTIFYICONDATA);
    nid.hWnd    = g_hwndTray;

    // We'll make do if this wasn't passed in. What that means is that we may
    // have a timing window where we are adding and removing these icons
    // at such a rate that the add has occurred before the connection has
    // had a chance to add the previous icon (so we don't know to remove it).
    //
    if (!pTrayIconData)
    {
        TraceTag(ttidSystray, "No tray icon data found, loading from cache");

        Assert(pGuid);

        g_ccl.AcquireWriteLock();
        ConnListEntry cle;
        hr = g_ccl.HrFindConnectionByGuid(pGuid, cle);
        if (S_OK == hr)
        {
            TraceTag(ttidSystray, "Tray icon data found in cache");

            Assert(!cle.empty())
                if (cle.HasTrayIconData())
                {
                    TraceTag(ttidSystray, "pTrayIconData was valid");

                    pTrayIconData = new CTrayIconData(*cle.GetTrayIconData());
                    if (!pTrayIconData)
                    {
                        g_ccl.ReleaseWriteLock();
                        return E_OUTOFMEMORY;
                    }
                    cle.DeleteTrayIconData();

                    g_ccl.HrUpdateConnectionByGuid(pGuid, cle);
                }
        }

        g_ccl.ReleaseWriteLock();

        // This is a copy that we should delete
        //
        delete pGuid;
        pGuid = NULL;
    }

    if (pTrayIconData)
    {
        nid.uID = pTrayIconData->GetTrayIconId();

        TraceTag(ttidSystray, "Removing tray icon with id=%u",
            pTrayIconData->GetTrayIconId() );

        int nCount = 5;
        hr = E_FAIL;   // Make sure we get at least one attempt in

        while ((nCount--) && (S_OK != hr))
        {
            hr = HrShell_NotifyIcon(NIM_DELETE, &nid);

            if (E_FAIL == hr)
            {
                TraceTag(ttidSystray, "Tray icon: %d failed in delete via "
                    "HrShell_NotifyIcon. Will retry shortly", pTrayIconData->GetTrayIconId() );

                // Raid #370358
                Sleep(500);
            }
            else
            {
                TraceTag(ttidSystray, "Tray icon: %d removed succesfully", pTrayIconData->GetTrayIconId());
            }
        }

        // Unadvise the statistics interface
        //
        if (pTrayIconData->GetConnectionPoint() && pTrayIconData->GetConnectionTrayStats() )
        {
            pTrayIconData->GetConnectionPoint()->Unadvise(*pTrayIconData->GetConnectionTrayStats()->GetConPointCookie());
        }

        // Stop the statistics
        //
        if (pTrayIconData->GetNetStatisticsEngine() )
        {
            pTrayIconData->GetNetStatisticsEngine()->StopStatistics();
        }

        // Delete the structure
        //
        delete pTrayIconData;
    }

    TraceHr(ttidSystray, FAL, hr, FALSE, "OnMyWMRemoveTrayIcon");

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   OnMyUpdateTrayIcon
//
//  Purpose:    Process the status message for the tray window
//
//  Arguments:
//      hwnd    []
//      wParam  []
//      lParam  []
//
//  Returns:
//
//  Author:
//
//  Notes:
//
//
LRESULT OnMyWMUpdateTrayIcon(IN  HWND hwnd, IN  WPARAM wParam, IN  LPARAM lParam) throw()
{
    TraceFileFunc(ttidSystray);

    if (g_pCTrayUI)
    {
        g_pCTrayUI->UpdateTrayIcon((UINT)wParam, (int)lParam);
    }

    return 0;
}


//+---------------------------------------------------------------------------
//
//  Function:   OnMyWMShowTrayIconBalloon
//
//  Purpose:    Puts balloon text on the icon for the tray window
//              Change the state of the connection
//
//  Arguments:
//      hwnd    [in]
//      wParam  [in]
//      lParam  [in] Point to CTrayBalloon structure
//
//  Returns:
//
//  Author:
//
//  Notes:
//
//
LRESULT OnMyWMShowTrayIconBalloon(IN  HWND hwnd, IN  WPARAM wParam, IN  LPARAM lParam) throw()
{
    TraceFileFunc(ttidSystray);

    HRESULT        hr           = S_OK;
    HRESULT        hrFind       = S_OK;
    BOOL           fLockHeld    = FALSE;

    Assert(lParam);
    if (!lParam)
    {
        return FALSE;
    }

    CTrayBalloon * pTrayBalloon = reinterpret_cast<CTrayBalloon *>(lParam);
    UINT           uiIcon;

    DWORD dwLockingThreadId = 0;
    hr = HrGetTrayIconLock(&(pTrayBalloon->m_gdGuid), &uiIcon, &dwLockingThreadId);
    if (S_OK == hr)
    {
        if (uiIcon != BOGUS_TRAY_ICON_ID)
        {
            ConnListEntry  cleFind;

            g_ccl.AcquireWriteLock();
            hrFind = g_ccl.HrFindConnectionByGuid(&(pTrayBalloon->m_gdGuid), cleFind);
            if (S_OK == hrFind)
            {
                Assert(!cleFind.ccfe.empty());
                Assert(pTrayBalloon->m_pfnFuncCallback);

                g_ccl.HrUpdateTrayBalloonInfoByGuid(&(pTrayBalloon->m_gdGuid), BALLOON_CALLBACK, pTrayBalloon->m_szCookie, pTrayBalloon->m_pfnFuncCallback);
                g_ccl.ReleaseWriteLock();

                NOTIFYICONDATA  nid;
                INT iIconResourceId;
                iIconResourceId = IGetCurrentConnectionTrayIconId(
                                        cleFind.ccfe.GetNetConMediaType(),
                                        cleFind.ccfe.GetNetConStatus(),
                                        0);

                ZeroMemory (&nid, sizeof(nid));
                nid.cbSize              = sizeof(NOTIFYICONDATA);
                nid.hWnd                = g_hwndTray;
                nid.uID                 = uiIcon;
                nid.uFlags              = NIF_MESSAGE | NIF_ICON | NIF_STATE;
                nid.hIcon               = g_pCTrayUI->GetCachedHIcon(iIconResourceId);
                nid.dwState             = NIS_SHAREDICON;
                nid.dwStateMask         = nid.dwState;
                nid.uCallbackMessage    = MYWM_NOTIFYICON;

                // Prepare the balloon data

                nid.uFlags     |= NIF_INFO;
                nid.dwInfoFlags = NIIF_INFO | NIIF_NOSOUND;
                nid.uTimeout = pTrayBalloon->m_dwTimeOut;

                if (lstrlenW(cleFind.ccfe.GetName()) >= celems(nid.szInfoTitle))
                {
                    lstrcpynW(nid.szInfoTitle, cleFind.ccfe.GetName(),
                             celems(nid.szInfoTitle) -
                             celems(c_szDotDotDot) - 1);
                    lstrcatW(nid.szInfoTitle, c_szDotDotDot);
                }
                else
                {
                    lstrcpyW(nid.szInfoTitle, cleFind.ccfe.GetName());
                }

                lstrcpynW(nid.szInfo, pTrayBalloon->m_szMessage, celems(nid.szInfo));

                HrShell_NotifyIcon(NIM_DELETE, &nid); // erase all previous potential balloons that could be lingering about.

                // Display the balloon
                HrShell_NotifyIcon(NIM_ADD, &nid);
            }
            else
            {
                g_ccl.ReleaseWriteLock();
            }
        }
        else
        {
            TraceTag(ttidSystray, "No existing icon data!!!");
        }

        // Release the lock on the tray icon
        //
        ReleaseTrayIconLock(&(pTrayBalloon->m_gdGuid));
    }
    else
    {
        TraceTag(ttidSystray, "Can't get tray icon lock in OnMyWMShowTrayIconBalloon for uiIcon: %d as it has been locked by thread %d", uiIcon, dwLockingThreadId);
    }

    delete pTrayBalloon;

    TraceHr(ttidSystray, FAL, hr, SUCCEEDED(hr), "OnMyWMShowTrayIconBalloon");
    return 0;
}


//+---------------------------------------------------------------------------
//
//  Function:   OnMyWMOpenStatus
//
//  Purpose:    Process the status message for the tray window
//
//  Arguments:
//      hwnd    []
//      wParam  []
//      lParam  []
//
//  Returns:
//
//  Author:     jeffspr   15 Dec 1997
//
//  Notes:
//
//
LRESULT OnMyWMOpenStatus(IN  HWND hwnd, IN  WPARAM wParam, IN  LPARAM lParam) throw()
{
    TraceFileFunc(ttidSystray);

    Assert(wParam);

    CONFOLDENTRY   pccfe;
    pccfe.InitializeFromItemIdList(reinterpret_cast<LPCITEMIDLIST>(wParam));

    BOOL  fCreateEngine = (BOOL)lParam;
    Assert(!pccfe.empty());

    HRESULT hr;
    ConnListEntry cle;
    hr = g_ccl.HrFindConnectionByGuid(&(pccfe.GetGuidID()), cle);
    if (S_OK == hr)
    {
        if (FHasPermission(NCPERM_Statistics))
        {
            if (!pccfe.empty())
            {
                INetStatisticsEngine* pnseNew;
                hr = HrGetStatisticsEngineForEntry(pccfe, &pnseNew, fCreateEngine);
                if (SUCCEEDED(hr))
                {
                    hr = pnseNew->ShowStatusMonitor();
                    ReleaseObj(pnseNew);
                }
                else
                {
                    TraceTag(ttidSystray,
                        "OnMyWMOpenStatus: Statistics Engine for connection %S has been removed."
                        "It's ok if this connection is being disconnected", pccfe.GetName());
                }
            }
        }
    }

    return 0;
}

LRESULT OnMyWMNotifyIcon(IN  HWND hwnd, IN  UINT uiMessage, IN  WPARAM wParam, IN  LPARAM lParam) throw()
{
    TraceFileFunc(ttidSystray);

    UINT    uiIcon;
    UINT    uiMouseMsg;

    uiIcon = (UINT) wParam;
    uiMouseMsg = (UINT) lParam;

    switch (uiMouseMsg)
    {
    case WM_MOUSEMOVE:
        FormatToolTip(hwnd, uiIcon);
        break;

    case WM_RBUTTONUP:
        OnTaskBarIconRButtonUp(hwnd, uiIcon);
        break;

    case NIN_BALLOONUSERCLICK:
        OnTaskBarIconBalloonClick(hwnd, uiIcon);
        break;

    case WM_LBUTTONUP:
        OnTaskBarIconLButtonDblClk(hwnd, uiIcon);
        break;
    }

    return 0;
}

VOID OnTaskBarIconRButtonUp(IN  HWND hwnd, IN  UINT uiIcon) throw()
{
    TraceFileFunc(ttidSystray);

    POINT   pt;

    GetCursorPos(&pt);
    (VOID) HrOpenContextMenu(hwnd, &pt, uiIcon);
}

//+---------------------------------------------------------------------------
//
//  Function:   OnTaskBarIconLButtonDblClk
//
//  Purpose:    Message handler for the Left-button double click from
//              a tray icon
//
//  Arguments:
//      hwnd   []   Our window handle
//      uiIcon []   Our Icon ID.
//
//  Returns:
//
//  Author:     jeffspr   12 Jan 1998
//
//  Notes:
//
VOID OnTaskBarIconLButtonDblClk(IN  HWND hwnd, IN  UINT uiIcon) throw()
{
    TraceFileFunc(ttidSystray);

    HRESULT         hr      = S_OK;
    if (GetKeyState(VK_SHIFT))
    {
        // Uh, nothing special to do here yet, but just in case...
    }

    // Perform the default context menu action
    // Find the connection info based on the tray icon id.
    //
    ConnListEntry cle;
    hr = g_ccl.HrFindConnectionByTrayIconId(uiIcon, cle);
    if (hr == S_OK)
    {
        Assert(!cle.ccfe.empty());

        if (!cle.ccfe.empty())
        {
            if (cle.ccfe.GetNetConStatus() == NCS_MEDIA_DISCONNECTED)
            {
                if (IsMediaLocalType(cle.ccfe.GetNetConMediaType()) &&
                    (NCSM_WIRELESS == cle.ccfe.GetNetConSubMediaType()) )
                {
                    PCONFOLDPIDLVEC pcfpVec;
                    PCONFOLDPIDL    pcfp;
                    hr = cle.ccfe.ConvertToPidl(pcfp);
                    if (SUCCEEDED(hr))
                    {
                        pcfpVec.insert(pcfpVec.begin(), pcfp);
                        HrOnCommandWZCDlgShow(pcfpVec,
                            g_hwndTray,
                            NULL);
                    }
                }
                else
                {
                    hr = HrOpenConnectionsFolder();
                }
            }
            else
            {
                switch(c_idDefaultCMCommand)
                {
                case CMIDM_TRAY_STATUS:
                    hr = HrOnCommandStatusInternal(cle.ccfe, FALSE);
                    break;

                default:
                    AssertSz(FALSE, "Default tray context menu item unhandled");
                    break;
                }
            }
        }
    }

    return;
}

DWORD WINAPI OnTaskBarIconBalloonClickThread(IN OUT LPVOID lpParam) throw()
{
    HRESULT hr = E_FAIL;

    CTrayBalloon *pTrayBalloon = reinterpret_cast<CTrayBalloon *>(lpParam);
    Assert(pTrayBalloon);

    FNBALLOONCLICK *pFNBalloonClick;
    pFNBalloonClick = pTrayBalloon->m_pfnFuncCallback;
    if (pFNBalloonClick)
    {
        hr = (pFNBalloonClick)(&(pTrayBalloon->m_gdGuid), pTrayBalloon->m_szAdapterName, pTrayBalloon->m_szCookie);
    }

    if (E_PENDING == hr)
    {
        MSG msg;
        while (GetMessage (&msg, 0, 0, 0))
        {
            DispatchMessage (&msg);
        }

        hr = S_OK;
    }

    delete pTrayBalloon;

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   OnTaskBarIconBalloonClick
//
//  Purpose:    Message handler for the balloon click from
//              a tray icon
//
//  Arguments:
//      hwnd   []   Our window handle
//      uiIcon []   Our Icon ID.
//
//  Returns:
//
//  Author:     deon   20 Mar 2001
//
//  Notes:
//
VOID OnTaskBarIconBalloonClick(IN  HWND hwnd, IN  UINT uiIcon) throw()
{
    TraceFileFunc(ttidSystray);

    HRESULT         hr      = S_OK;
    if (GetKeyState(VK_SHIFT))
    {
        // Uh, nothing special to do here yet, but just in case...
    }

    // Perform the default context menu action
    // Find the connection info based on the tray icon id.
    //
    ConnListEntry cle;
    hr = g_ccl.HrFindConnectionByTrayIconId(uiIcon, cle);
    if (hr == S_OK)
    {
        Assert(!cle.ccfe.empty());

        if (!cle.ccfe.empty())
        {
            if (!cle.GetTrayIconData())
            {
                ASSERT (0);
            }

            switch ((cle.GetTrayIconData())->GetLastBalloonMessage())
            {
                case BALLOON_NOTHING:
                    AssertSz(NULL, "You didn't set the balloon");
                    break;

                case BALLOON_CALLBACK:
                    {
                        CTrayBalloon *pTrayBalloon = new CTrayBalloon();
                        if (pTrayBalloon)
                        {
                            pTrayBalloon->m_gdGuid   = cle.ccfe.GetGuidID();
                            pTrayBalloon->m_szCookie = SysAllocStringByteLen(reinterpret_cast<LPCSTR>(cle.GetTrayIconData()->GetLastBalloonCookie()), SysStringByteLen(cle.GetTrayIconData()->GetLastBalloonCookie()));
                            pTrayBalloon->m_pfnFuncCallback = cle.GetTrayIconData()->GetLastBalloonFunction();
                            pTrayBalloon->m_dwTimeOut= 0;
                            pTrayBalloon->m_szAdapterName = cle.ccfe.GetName();

                            CreateThread(NULL, STACK_SIZE_SMALL, OnTaskBarIconBalloonClickThread, pTrayBalloon, 0, NULL);
                        }
                    }
                    break;

                case BALLOON_USE_NCS:
                    if (cle.ccfe.GetNetConStatus() == NCS_MEDIA_DISCONNECTED)
                    {
                        Assert(c_idDefaultDisconCMCommand == CMIDM_OPEN_CONNECTIONS_FOLDER);
                        hr = HrOpenConnectionsFolder();
                    }
                    else
                    {
                        switch(c_idDefaultCMCommand)
                        {
                        case CMIDM_TRAY_STATUS:
                            hr = HrOnCommandStatusInternal(cle.ccfe, FALSE);
                            break;

                        default:
                            AssertSz(FALSE, "Default tray context menu item unhandled");
                            break;
                        }
                    }
                    break;

                default:
                    ASSERT (0);
                    break;

            }
        }
    }

    return;
}

//+---------------------------------------------------------------------------
//
//  Function:   OnMyWMFlushNoop
//
//  Purpose:    Process the MYWM_FLUSHNOOP message for the tray. This is used
//              via SendMessage to clear the tray message queue.
//
//  Arguments:
//      hwnd   [in]     Our hwnd
//      wParam [in]     Unused
//      lParam [in]     Unused
//
//  Returns:
//
//  Author:     jeffspr   30 Aug 1999
//
//  Notes:
//
LRESULT OnMyWMFlushNoop(IN  HWND hwnd, IN  WPARAM wParam, IN  LPARAM lParam) throw()
{
    TraceFileFunc(ttidSystray);

    TraceTag(ttidSystray,
        "Tray received tray FLUSH Noop. This should clear the tray message loop");

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   FlushTrayPosts
//
//  Purpose:    Flush the tray message queue by doing a SendMessage of a NOOP
//
//  Arguments:
//      hwnd [in] Where to post to.
//
//  Returns:
//
//  Author:     jeffspr   8 Sep 1999
//
//  Notes:
//
VOID FlushTrayPosts(IN  HWND hwnd) throw()
{
    TraceFileFunc(ttidSystray);

    // Flush the tray posts
    //
    SendMessage(hwnd, MYWM_FLUSHNOOP, (WPARAM) 0, (LPARAM) 0);
}


BOOL FInitFoldEnumerator(IN  HWND hwnd, OUT DWORD * pdwIconsAdded) throw()
{
    TraceFileFunc(ttidSystray);

    BOOL                    fReturn         = FALSE;
    HRESULT                 hr              = S_OK;
    CConnectionFolderEnum * pCFEnum         = NULL;
    PCONFOLDPIDL            pidlCon;
    DWORD                   dwFetched       = 0;
    DWORD                   dwIconsAdded    = 0;
    PCONFOLDPIDLFOLDER      pidlFolder;

    NETCFG_TRY

        // Create the IEnumIDList object (CConnectionFolderEnum)
        //
        hr = CConnectionFolderEnum::CreateInstance (
            IID_IEnumIDList,
            (VOID **)&pCFEnum);

        if (SUCCEEDED(hr))
        {
            Assert(pCFEnum);

            // Call the PidlInitialize function to allow the enumeration
            // object to copy the list.
            //
            PCONFOLDPIDLFOLDER pcfpEmpty;
            pCFEnum->PidlInitialize(TRUE, pcfpEmpty, CFCOPT_ENUMALL);
        }

        if (SUCCEEDED(hr))
        {
            while (SUCCEEDED(hr) && (S_FALSE != hr))
            {
                // Clear out the previous results, if any.
                //
                pidlCon.Clear();
                dwFetched   = 0;

                // Get the next connection
                //
                LPITEMIDLIST pTempItemIdList;
                hr = pCFEnum->Next(1, &pTempItemIdList, &dwFetched);
                if (S_OK == hr)
                {
                    pidlCon.InitializeFromItemIDList(pTempItemIdList);
                    const PCONFOLDPIDL& pcfp = pidlCon;

                    // If it's not a wizard pidl, then update the
                    // icon data.
                    //
                    if (WIZARD_NOT_WIZARD == pcfp->wizWizard)
                    {
                        // If the folder pidl hasn't already been loaded
                        // then get it
                        //
                        if (pidlFolder.empty())
                        {
                            hr = HrGetConnectionsFolderPidl(pidlFolder);
                        }

                        // Assuming that succeeded (or hr will be S_OK if
                        // the HrGet... wasn't called)
                        //
                        if (SUCCEEDED(hr))
                        {
                            // Refresh this item -- this will make the desktop shortcuts
                            // update to the correct state.
                            //
                            RefreshFolderItem(pidlFolder, pidlCon, pidlCon, TRUE);
                        }
                    }
                }
            }
        }

        if (SUCCEEDED(hr))
        {
            // Normalize the return code.
            //
            hr = S_OK;
            fReturn = TRUE;

            // If the caller wants the fetched count
            //
            if (pdwIconsAdded)
            {
                *pdwIconsAdded = dwIconsAdded;
            }
        }

        ReleaseObj(pCFEnum);

    NETCFG_CATCH(hr)

    TraceHr(ttidError, FAL, hr, FALSE, "FInitFoldEnumerator");
    return fReturn;

}

HICON CTrayUI::GetCachedHIcon(IN INT iIconResourceId) throw()
{
    TraceFileFunc(ttidSystray);

    CExceptionSafeLock esLock(&m_csLock);

    HICON hIcon = m_mapIdToHicon [iIconResourceId];
    if (!hIcon)
    {
        TraceTag(ttidSystray, "Loading HICON for resource id %u and adding it to our map.",
            iIconResourceId);

        hIcon = LoadIcon(_Module.GetResourceInstance(),
            MAKEINTRESOURCE(iIconResourceId));

        //AssertSz (hIcon, "Couldn't load a tray icon.  You may ignore this "
        //    "assert and a default icon will be used.");

        if (!hIcon)
        {
            hIcon = LoadIcon(_Module.GetResourceInstance(),
                MAKEINTRESOURCE(IDI_LB_GEN_S_16));
            AssertSz (hIcon, "Okay, now you're hosed.  Couldn't load the "
                "default icon either.  email jeffspr.");
        }

        m_mapIdToHicon [iIconResourceId] = hIcon;

        // Add a hidden icon to the tray so that the shell will cache it.
        //
        NOTIFYICONDATA  nid;
        ZeroMemory (&nid, sizeof(nid));
        nid.cbSize      = sizeof(NOTIFYICONDATA);
        nid.hWnd        = g_hwndTray;
        nid.uID         = m_uiNextHiddenIconId--;
        nid.uFlags      = NIF_ICON | NIF_STATE;
        nid.hIcon       = hIcon;
        nid.dwState     = NIS_HIDDEN;
        nid.dwStateMask = nid.dwState;

        /*
        nid.uFlags |= NIF_TIP;
        wsprintfW(nid.szTip, L"hidden: uID=%u, hIcon=0x%x", nid.uID, nid.hIcon);
        */

        TraceTag(ttidSystray, "Adding hidden shell icon: uID=%u, hIcon=0x%x",
            nid.uID,
            nid.hIcon);

        HRESULT hr = HrShell_NotifyIcon(NIM_ADD, &nid);
        if (SUCCEEDED(hr))
        {
            // We can now destroy the icon.  This looks weird, but we're only
            // going to use the hIcon for passing to Shell_NotifyIcon again
            // when we add the shared icon with a different uID.
            //
            DestroyIcon(hIcon);
        }
    }

    Assert (hIcon);
    return hIcon;
}

VOID CTrayUI::UpdateTrayIcon(IN  UINT    uiTrayIconId,
                             IN  INT     iIconResourceId) throw()
{
    TraceFileFunc(ttidSystray);

    NOTIFYICONDATA  nid;

    ZeroMemory (&nid, sizeof(nid));
    nid.cbSize      = sizeof(NOTIFYICONDATA);
    nid.hWnd        = g_hwndTray;
    nid.uID         = uiTrayIconId;
    nid.uFlags      = NIF_ICON | NIF_STATE;
    nid.hIcon       = GetCachedHIcon(iIconResourceId);
    nid.dwState     = NIS_SHAREDICON;
    nid.dwStateMask = nid.dwState;

    Shell_NotifyIcon(NIM_MODIFY, &nid);
}

VOID GetInitialBalloonText(IN  INetStatisticsEngine*   pnse,
                           OUT PWSTR                   pszBuf,
                           OUT DWORD                   dwSize) throw()
{
    TraceFileFunc(ttidSystray);

    *pszBuf = 0;

    if (pnse)
    {
        STATMON_ENGINEDATA* pData = NULL;

        HRESULT hr = pnse->GetStatistics(&pData);
        if (SUCCEEDED(hr) && pData)
        {
            if (pData->SMED_802_11_SSID && pData->SMED_802_11_SIGNAL_STRENGTH)
            {
                DwFormatString(SzLoadIds(IDS_TOOLTIP_WIRELESS_CONNECTED), pszBuf, dwSize,
                                pData->SMED_802_11_SSID, PszGetRSSIString(pData->SMED_802_11_SIGNAL_STRENGTH));
            }
            else
            if ((pData->SMED_SPEEDTRANSMITTING>0) || (pData->SMED_SPEEDRECEIVING>0))
            {
                WCHAR pszValue [64];

                // Format the transmitting (and possibly the receiving) speed
                // into the buffer.
                //
                FormatTransmittingReceivingSpeed (
                    pData->SMED_SPEEDTRANSMITTING,
                    pData->SMED_SPEEDRECEIVING,
                    pszValue);

                DwFormatString(SzLoadIds(IDS_TOOLTIP_LINE_SPEED), pszBuf, dwSize, pszValue);
            }

            CoTaskMemFree(pData);
        }
    }

    // Provide a default.
    //
    if (!*pszBuf)
    {
        lstrcpyW(pszBuf, SzLoadIds(IDS_CONTRAY_INITIAL_BALLOON));
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   HrAddTrayExtension
//
//  Purpose:    Add the tray extension to the Shell's delay load key
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     jeffspr   28 Jul 1998
//
//  Notes:
//
HRESULT HrAddTrayExtension()
{
    TraceFileFunc(ttidSystray);

    HRESULT hr              = S_OK;
    HKEY    hkeyDelayLoad   = NULL;

    hr = HrRegCreateKeyEx(HKEY_LOCAL_MACHINE, c_szDelayLoadKey,
        REG_OPTION_NON_VOLATILE, KEY_WRITE,
        NULL, &hkeyDelayLoad, NULL);
    if (SUCCEEDED(hr))
    {
        hr = HrRegSetString(hkeyDelayLoad, c_szDelayLoadName, c_szDelayLoadClassID);

        RegCloseKey(hkeyDelayLoad);
    }

    TraceHr(ttidSystray, FAL, hr, FALSE, "HrAddTrayExtension");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRemoveTrayExtension
//
//  Purpose:    Remove the tray extension from the shell's delay load key
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     jeffspr   28 Jul 1998
//
//  Notes:
//
HRESULT HrRemoveTrayExtension()
{
    TraceFileFunc(ttidSystray);

    HRESULT hr              = S_OK;
    HKEY    hkeyDelayLoad   = NULL;

    hr = HrRegCreateKeyEx(HKEY_LOCAL_MACHINE, c_szDelayLoadKey,
        REG_OPTION_NON_VOLATILE, KEY_WRITE,
        NULL, &hkeyDelayLoad, NULL);
    if (SUCCEEDED(hr))
    {
        (void) HrRegDeleteValue(hkeyDelayLoad, c_szDelayLoadName);

        RegCloseKey(hkeyDelayLoad);
    }

    TraceHr(ttidSystray, FAL, hr, FALSE, "HrRemoveTrayExtension");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\shell\folder\disconnect.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       D I S C O N N E C T . H 
//
//  Contents:   Code for disconnect confirmation and SyncMgr sync calls.
//
//  Notes:      
//
//  Author:     jeffspr   11 Mar 1998
//
//----------------------------------------------------------------------------

#pragma once

#ifndef _DISCONNECT_H_
#define _DISCONNECT_H_

#include <syncrasp.h>   // for SYNCMGRQUERYSHOWSYNCUI

VOID PromptForSyncIfNeeded(
    IN  const CONFOLDENTRY&  ccfe,
    IN  HWND            hwndOwner);
                                                         
#endif // _DISCONNECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\shell\folder\foldglob.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       F O L D G L O B . C P P
//
//  Contents:   Globals for the shell foldering code.
//
//  Notes:
//
//  Author:     jeffspr   23 Oct 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "foldinc.h"    // Standard shell\folder includes
#include "connlist.h"   // CConnectionList class.



// Connection list global
//
CConnectionList g_ccl;  // our global list.

// The state of the operator assist dial flag
//
bool    g_fOperatorAssistEnabled;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\shell\folder\disconnect.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       D I S C O N N E C T . C P P
//
//  Contents:   Code for disconnect confirmation and SyncMgr sync calls.
//
//  Notes:
//
//  Author:     jeffspr   11 Mar 1998
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "foldinc.h"    // Standard shell\folder includes
#include <nsres.h>
#include "shutil.h"
#include "disconnect.h"

//+---------------------------------------------------------------------------
//
//  Function:   PromptForSyncIfNeeded
//
//  Purpose:    Query for SyncMgr processing if appropriate and call SyncMgr
//              if requested.
//
//  Arguments:
//      pccfe     [in]  Our connection
//      hwndOwner [in]  Our parent hwnd
//
//  Author:     jeffspr   31 May 1999
//
//  Notes:
//
VOID PromptForSyncIfNeeded(
    IN  const CONFOLDENTRY&  ccfe,
    IN  HWND            hwndOwner)
{
    LRESULT                 lResult         = 0;
    SYNCMGRQUERYSHOWSYNCUI  smqss;
    SYNCMGRSYNCDISCONNECT   smsd;

    smqss.cbSize            = sizeof(SYNCMGRQUERYSHOWSYNCUI);
    smqss.GuidConnection    = ccfe.GetGuidID();
    smqss.pszConnectionName = ccfe.GetName();
    smqss.fShowCheckBox     = FALSE;
    smqss.nCheckState       = 0;

    // We only want to allow sync on dialup connections, and
    // not on incoming connections.
    //
    if (ccfe.GetNetConMediaType() == NCM_PHONE &&
        !(ccfe.GetCharacteristics() & NCCF_INCOMING_ONLY))
    {
        // Get the lResult, but for debugging only. We want to allow the
        // disconnect dialog to come up even if the sync functions failed.
        //
        lResult = SyncMgrRasProc(
                SYNCMGRRASPROC_QUERYSHOWSYNCUI,
                0,
                (LPARAM) &smqss);

        AssertSz(lResult == 0, "Call to SyncMgrRasProc failed for the QuerySyncUI");
        TraceTag(ttidShellFolder, "Call to SyncMgrRasProc returned: 0x%08x", lResult);
    }

    if (smqss.fShowCheckBox)
    {
        // pop up message box and set smqss.nCheckState
        if(NcMsgBox(_Module.GetResourceInstance(),
                    NULL,
                    IDS_CONFOLD_SYNC_CONFIRM_WINDOW_TITLE,
                    IDS_CONFOLD_SYNC_CONFIRM,
                    smqss.nCheckState ?
                        MB_APPLMODAL|MB_ICONEXCLAMATION|MB_YESNO:
                        MB_APPLMODAL|MB_ICONEXCLAMATION|MB_YESNO|MB_DEFBUTTON2)
           == IDYES)
        {
            smqss.nCheckState = BST_CHECKED;
        }
        else
        {
            smqss.nCheckState = BST_UNCHECKED;
        }
    }

    // If the user wanted the sync to occur...
    //
    if (smqss.fShowCheckBox && smqss.nCheckState == BST_CHECKED)
    {
        CWaitCursor wc;     // Bring up wait cursor now. Remove when we go out of scope.

        // Fill in the disconnect data
        //
        smsd.cbSize             = sizeof(SYNCMGRSYNCDISCONNECT);
        smsd.GuidConnection     = ccfe.GetGuidID();
        smsd.pszConnectionName  = ccfe.GetName();

        // Call the syncmgr's disconnect code
        //
        lResult = SyncMgrRasProc(
            SYNCMGRRASPROC_SYNCDISCONNECT,
            0,
            (LPARAM) &smsd);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\shell\folder\foldglob.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       F O L D G L O B . H
//
//  Contents:   Global definitions for the shell foldering code
//
//  Notes:
//
//  Author:     jeffspr   23 Oct 1997
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _FOLDGLOB_H_
#define _FOLDGLOB_H_

// The connection list
//
extern CConnectionList  g_ccl;

// The state of the operator assist dial flag
//
extern bool             g_fOperatorAssistEnabled;

#endif // _FOLDGLOB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\shell\folder\foldres.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       F O L D R E S . H
//
//  Contents:   Folder resources
//
//  Notes:
//
//  Author:     jeffspr   29 Sep 1997
//
//----------------------------------------------------------------------------

#pragma once

// Foldres owns from 0-1, and 10000 - 15999

// Connections folder icon
//
#define IDI_CONNECTIONS_FOLDER_LARGE    0
#define IDI_CONNECTIONS_FOLDER_LARGE2   5

// NT4 .RNK file icon
//
#define IDI_RNK_FILE                    1   // NT4 .RNK file

// PBK file icon
//
#define IDI_PBK_FILE                    2   // .BPK file

// The item icon for the wizard
//
#define IDI_CONFOLD_WIZARD              3
#define IDI_CONFOLD_HOMENET_WIZARD      4

// Toolbar bitmap
#define IDB_TB_SMALL                    10100

// Dialog
#define IDD_STATUS                      10500
#define IDC_TXT_STATUS                  10501

// Message Strings
#define IDS_STATUS_BRIDGE_CREATION      10600
#define IDS_STATUS_BRIDGE_DELETING      10601
#define IDS_STATUS_BRIDGE_REMOVE_MEMBER 10602
#define IDS_CONFOLD_BRIDGE_NOLOCK       10603
#define IDS_BRIDGE_EDUCATION            10604
#define IDS_CONFOLD_BRIDGE_UNEXPECTED   10605
#define IDS_BRIDGE_EDUCATION_2          10606
#define IDS_BRIDGE_CLUSTERING_CONFLICT_WARNING 10607

//---[ Menus, etc ]------------------------------------------------------------

// $$NOTE - Don't change the ordering of these menus, at least not the
// relation of CONNECTED, DISCONNECTED, and UNAVAILABLE. The code uses
// this ordering to decide which of the three menus to bring up based
// on the state of the connection
//
#define MENU_WIZARD                     11000
#define MENU_WIZARD_V                   11001

#define MENU_LAN_DISCON                 11010
#define MENU_LAN_DISCON_V               11011
#define MENU_LAN_CON                    11012
#define MENU_LAN_CON_V                  11013
#define MENU_LAN_UNAVAIL                11014
#define MENU_LAN_UNAVAIL_V              11015

#define MENU_DIAL_DISCON                11020
#define MENU_DIAL_DISCON_V              11021
#define MENU_DIAL_CON                   11022
#define MENU_DIAL_CON_V                 11023
#define MENU_DIAL_UNAVAIL               11024
#define MENU_DIAL_UNAVAIL_V             11025
#define MENU_DIAL_CON_UNSET             11026
#define MENU_DIAL_DISCON_UNSET          11027
#define MENU_DIAL_UNAVAIL_UNSET         11028

#define MENU_INCOM_DISCON               11030
#define MENU_INCOM_DISCON_V             11031
#define MENU_INCOM_CON                  11032
#define MENU_INCOM_CON_V                11033
#define MENU_INCOM_UNAVAIL              11034
#define MENU_INCOM_UNAVAIL_V            11035

#define MENU_INET_DISCON                11040
#define MENU_INET_DISCON_V              11041
#define MENU_INET_CON                   11042
#define MENU_INET_CON_V                 11043
#define MENU_INET_UNAVAIL               11044
#define MENU_INET_UNAVAIL_V             11045

#define MENU_SALAN_CON                  11050
#define MENU_SALAN_DISCON               11051
#define MENU_SARAS_CON                  11052
#define MENU_SARAS_DISCON               11053

#define MENU_MERGE_INBOUND_DISCON       11100
#define MENU_MERGE_INBOUND_CON          11101
#define MENU_MERGE_INBOUND_UNAVAIL      11102
#define MENU_MERGE_OUTBOUND_DISCON      11103
#define MENU_MERGE_OUTBOUND_CON         11104
#define MENU_MERGE_OUTBOUND_UNAVAIL     11105
#define MENU_MERGE_FOLDER_BACKGROUND    11110
#define POPUP_MERGE_FOLDER_CONNECTIONS  11112

#define MENU_DIAL98_UNAVAIL_V           11113


//---[ Commands (context/menus) ]----------------------------------------------

#define CMIDM_FIRST                         0x0000
#define CMIDM_NEW_CONNECTION                (CMIDM_FIRST + 0x0001)
#define CMIDM_CONNECT                       (CMIDM_FIRST + 0x0002)
#define CMIDM_DISCONNECT                    (CMIDM_FIRST + 0x0003)
#define CMIDM_STATUS                        (CMIDM_FIRST + 0x0004)
#define CMIDM_CREATE_SHORTCUT               (CMIDM_FIRST + 0x0005)
#define CMIDM_DELETE                        (CMIDM_FIRST + 0x0006)
#define CMIDM_RENAME                        (CMIDM_FIRST + 0x0007)
#define CMIDM_PROPERTIES                    (CMIDM_FIRST + 0x0008)
#define CMIDM_CREATE_COPY                   (CMIDM_FIRST + 0x0009)
#define CMIDM_ENABLE                        (CMIDM_FIRST + 0x0010)
#define CMIDM_DISABLE                       (CMIDM_FIRST + 0x0011)
#define CMIDM_CREATE_BRIDGE                 (CMIDM_FIRST + 0x0012)
#define CMIDM_ADD_TO_BRIDGE                 (CMIDM_FIRST + 0x0013)
#define CMIDM_REMOVE_FROM_BRIDGE            (CMIDM_FIRST + 0x0014)
#define CMIDM_SET_DEFAULT                   (CMIDM_FIRST + 0x0015)
#define CMIDM_UNSET_DEFAULT                 (CMIDM_FIRST + 0x0016)
#define CMIDM_FIX                           (CMIDM_FIRST + 0x0017)
#define CMIDM_WZCDLG_SHOW                   (CMIDM_FIRST + 0x0018)
#define CMIDM_WZCPROPERTIES                 (CMIDM_FIRST + 0x0019)

// We use different command IDs for the Connections Menu because they're
// mostly duplicates of what's found in the File menu, and having
// dupes prevents correct enable/disable by ID.
//
#define CMIDM_CONNECTIONS                   (CMIDM_FIRST + 0x0020)
#define CMIDM_CONMENU_DIALUP_PREFS          (CMIDM_FIRST + 0x0021)
#define CMIDM_CONMENU_ADVANCED_CONFIG       (CMIDM_FIRST + 0x0022)
#define CMIDM_CONMENU_NETWORK_ID            (CMIDM_FIRST + 0x0023)
#define CMIDM_CONMENU_OPERATOR_ASSIST       (CMIDM_FIRST + 0x0024)
#define CMIDM_CONMENU_OPTIONALCOMPONENTS    (CMIDM_FIRST + 0x0025)

#define CMIDM_ARRANGE                       (CMIDM_FIRST + 0x0026)
#define CMIDM_ARRANGE_BY_NAME               (CMIDM_FIRST + 0x0027)
#define CMIDM_ARRANGE_BY_TYPE               (CMIDM_FIRST + 0x0028)
#define CMIDM_ARRANGE_BY_STATUS             (CMIDM_FIRST + 0x0029)
#define CMIDM_ARRANGE_BY_OWNER              (CMIDM_FIRST + 0x0030)
#define CMIDM_ARRANGE_BY_PHONEORHOSTADDRESS (CMIDM_FIRST + 0x0031)
#define CMIDM_ARRANGE_BY_DEVICE_NAME        (CMIDM_FIRST + 0x0032)

#define CMIDM_CONMENU_CREATE_BRIDGE         (CMIDM_FIRST + 0x0033)
#define CMIDM_HOMENET_WIZARD                (CMIDM_FIRST + 0x0034)
#define CMIDM_NET_DIAGNOSTICS               (CMIDM_FIRST + 0x0035)
#define CMIDM_NET_TROUBLESHOOT              (CMIDM_FIRST + 0x0036)

// Debug only commands
//
#if DBG
#define CMIDM_DEBUG                         (CMIDM_FIRST + 0x0040)
#define CMIDM_DEBUG_TRAY                    (CMIDM_FIRST + 0x0041)
#define CMIDM_DEBUG_TRACING                 (CMIDM_FIRST + 0x0042)
#define CMIDM_DEBUG_NOTIFYADD               (CMIDM_FIRST + 0x0044)
#define CMIDM_DEBUG_NOTIFYREMOVE            (CMIDM_FIRST + 0x0045)
#define CMIDM_DEBUG_NOTIFYTEST              (CMIDM_FIRST + 0x0046)
#define CMIDM_DEBUG_REFRESH                 (CMIDM_FIRST + 0x0047)
#define CMIDM_DEBUG_REFRESHNOFLUSH          (CMIDM_FIRST + 0x0048)
#define CMIDM_DEBUG_REFRESHSELECTED         (CMIDM_FIRST + 0x0049)
#define CMIDM_DEBUG_REMOVETRAYICONS         (CMIDM_FIRST + 0x004A)
#endif

// Menu options
//
#define IDM_OPEN                            11200

//---[ Strings for command ID's (shows in status line) ]-----------------------
//
#define IDS_CMIDM_START                         12000

#define IDS_CMIDM_NEW_CONNECTION                (IDS_CMIDM_START + CMIDM_NEW_CONNECTION)
#define IDS_CMIDM_CONNECT                       (IDS_CMIDM_START + CMIDM_CONNECT)
#define IDS_CMIDM_ENABLE                        (IDS_CMIDM_START + CMIDM_ENABLE)
#define IDS_CMIDM_DISCONNECT                    (IDS_CMIDM_START + CMIDM_DISCONNECT)
#define IDS_CMIDM_DISABLE                       (IDS_CMIDM_START + CMIDM_DISABLE)
#define IDS_CMIDM_STATUS                        (IDS_CMIDM_START + CMIDM_STATUS)
#define IDS_CMIDM_CREATE_SHORTCUT               (IDS_CMIDM_START + CMIDM_CREATE_SHORTCUT)
#define IDS_CMIDM_DELETE                        (IDS_CMIDM_START + CMIDM_DELETE)
#define IDS_CMIDM_RENAME                        (IDS_CMIDM_START + CMIDM_RENAME)
#define IDS_CMIDM_PROPERTIES                    (IDS_CMIDM_START + CMIDM_PROPERTIES)
#define IDS_CMIDM_CREATE_COPY                   (IDS_CMIDM_START + CMIDM_CREATE_COPY)
#define IDS_CMIDM_CREATE_BRIDGE                 (IDS_CMIDM_START + CMIDM_CREATE_BRIDGE)
#define IDS_CMIDM_ADD_TO_BRIDGE                 (IDS_CMIDM_START + CMIDM_ADD_TO_BRIDGE)
#define IDS_CMIDM_REMOVE_FROM_BRIDGE            (IDS_CMIDM_START + CMIDM_REMOVE_FROM_BRIDGE)
#define IDS_CMIDM_SET_DEFAULT                   (IDS_CMIDM_START + CMIDM_SET_DEFAULT)
#define IDS_CMIDM_UNSET_DEFAULT                 (IDS_CMIDM_START + CMIDM_UNSET_DEFAULT)
#define IDS_CMIDM_FIX                           (IDS_CMIDM_START + CMIDM_FIX)
#define IDS_CMIDM_HOMENET_WIZARD                (IDS_CMIDM_START + CMIDM_HOMENET_WIZARD)
#define IDS_CMIDM_WZCDLG_SHOW                   (IDS_CMIDM_START + CMIDM_WZCDLG_SHOW)
#define IDS_CMIDM_NET_TROUBLESHOOT              (IDS_CMIDM_START + CMIDM_NET_TROUBLESHOOT)

#define IDS_CMIDM_CONNECTIONS                   (IDS_CMIDM_START + CMIDM_CONNECTIONS)
#define IDS_CMIDM_CONMENU_DIALUP_PREFS          (IDS_CMIDM_START + CMIDM_CONMENU_DIALUP_PREFS)
#define IDS_CMIDM_CONMENU_ADVANCED_CONFIG       (IDS_CMIDM_START + CMIDM_CONMENU_ADVANCED_CONFIG)
#define IDS_CMIDM_CONMENU_CREATE_BRIDGE         (IDS_CMIDM_START + CMIDM_CONMENU_CREATE_BRIDGE)
#define IDS_CMIDM_CONMENU_NETWORK_ID            (IDS_CMIDM_START + CMIDM_CONMENU_NETWORK_ID)
#define IDS_CMIDM_CONMENU_OPERATOR_ASSIST       (IDS_CMIDM_START + CMIDM_CONMENU_OPERATOR_ASSIST)
#define IDS_CMIDM_CONMENU_OPTIONALCOMPONENTS    (IDS_CMIDM_START + CMIDM_CONMENU_OPTIONALCOMPONENTS)

#define IDS_CMIDM_ARRANGE                       (IDS_CMIDM_START + CMIDM_ARRANGE)
#define IDS_CMIDM_ARRANGE_BY_NAME               (IDS_CMIDM_START + CMIDM_ARRANGE_BY_NAME)
#define IDS_CMIDM_ARRANGE_BY_TYPE               (IDS_CMIDM_START + CMIDM_ARRANGE_BY_TYPE)
#define IDS_CMIDM_ARRANGE_BY_STATUS             (IDS_CMIDM_START + CMIDM_ARRANGE_BY_STATUS)
#define IDS_CMIDM_ARRANGE_BY_OWNER              (IDS_CMIDM_START + CMIDM_ARRANGE_BY_OWNER)
#define IDS_CMIDM_ARRANGE_BY_PHONEORHOSTADDRESS (IDS_CMIDM_START + CMIDM_ARRANGE_BY_PHONEORHOSTADDRESS)
#define IDS_CMIDM_ARRANGE_BY_DEVICE_NAME        (IDS_CMIDM_START + CMIDM_ARRANGE_BY_DEVICE_NAME)

// Debug only commands
//
#if DBG
#define IDS_CMIDM_DEBUG                         (IDS_CMIDM_START + CMIDM_DEBUG)
#define IDS_CMIDM_DEBUG_TRAY                    (IDS_CMIDM_START + CMIDM_DEBUG_TRAY)
#define IDS_CMIDM_DEBUG_TRACING                 (IDS_CMIDM_START + CMIDM_DEBUG_TRACING)
#define IDS_CMIDM_DEBUG_NOTIFYADD               (IDS_CMIDM_START + CMIDM_DEBUG_NOTIFYADD)
#define IDS_CMIDM_DEBUG_NOTIFYREMOVE            (IDS_CMIDM_START + CMIDM_DEBUG_NOTIFYREMOVE)
#define IDS_CMIDM_DEBUG_NOTIFYTEST              (IDS_CMIDM_START + CMIDM_DEBUG_NOTIFYTEST)
#define IDS_CMIDM_DEBUG_REFRESH                 (IDS_CMIDM_START + CMIDM_DEBUG_REFRESH)
#define IDS_CMIDM_DEBUG_REFRESHNOFLUSH          (IDS_CMIDM_START + CMIDM_DEBUG_REFRESHNOFLUSH)
#define IDS_CMIDM_DEBUG_REFRESHSELECTED         (IDS_CMIDM_START + CMIDM_DEBUG_REFRESHSELECTED)
#define IDS_CMIDM_DEBUG_REMOVETRAYICONS         (IDS_CMIDM_START + CMIDM_DEBUG_REMOVETRAYICONS)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\shell\folder\icomtarg.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       I C O M T A R G . C P P
//
//  Contents:   ICommandTarget implementation for IConnectionTray
//
//  Notes:
//
//  Author:     jeffspr   12 Nov 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "foldinc.h"    // Standard shell\tray includes
#include "ctrayui.h"    // extern for the global tray object

HRESULT CConnectionTray::QueryStatus(
    IN     const GUID *    pguidCmdGroup,
    IN     ULONG           cCmds,
    IN OUT OLECMD          prgCmds[],
    IN OUT OLECMDTEXT *    pCmdText)
{
    TraceFileFunc(ttidShellFolderIface);

    HRESULT hr  = E_NOTIMPL;

    TraceHr(ttidError, FAL, hr, (hr == E_NOTIMPL), "CConnectionTray::QueryStatus");
    return hr;
}

HRESULT CConnectionTray::Exec(
    IN     const GUID *    pguidCmdGroup,
    IN     DWORD           nCmdID,
    IN     DWORD           nCmdexecopt,
    IN     VARIANTARG *    pvaIn,
    IN OUT VARIANTARG *    pvaOut)
{
    TraceFileFunc(ttidShellFolderIface);

    HRESULT hr  = S_OK;

    // Set the DisableTray flag in netcfg.ini to prevent the network connections
    // tray code from executing.
    //
    if (!FIsDebugFlagSet (dfidDisableTray))
    {
        if (IsEqualGUID(*pguidCmdGroup, CGID_ShellServiceObject))
        {
            // Handle Shell Service Object notifications here.
            switch (nCmdID)
            {
                case SSOCMDID_OPEN:
                    TraceTag(ttidShellFolder, "The Net Connections Tray is being initialized");
                    hr = HrHandleTrayOpen();
                    break;

                case SSOCMDID_CLOSE:
                    TraceTag(ttidShellFolder, "The Net Connections Tray is being destroyed");
                    hr = HrHandleTrayClose();
                    break;

                default:
                    hr = S_OK;
                    break;
            }
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CConnectionTray::Exec");
    return hr;
}

DWORD WINAPI TrayInitThreadProc(IN LPVOID lpParam)
{
    HRESULT hr          = S_OK;
    BOOL    fCoInited   = FALSE;

    hr = CoInitializeEx (NULL, COINIT_DISABLE_OLE1DDE | COINIT_APARTMENTTHREADED);
    if (SUCCEEDED(hr))
    {
        // We don't care if this is S_FALSE or not, since we'll soon
        // overwrite the hr. If it's already initialized, great...

        fCoInited = TRUE;

        // Create the TrayUI object and save it in a global.
        //
        Assert(!g_pCTrayUI);

        if (!g_pCTrayUI)
        {
            g_pCTrayUI = new CTrayUI();
            if (!g_pCTrayUI)
            {
                hr = E_OUTOFMEMORY;
            }
        }

        // Initialize the tray UI object
        //
        if (g_pCTrayUI)
        {
            hr = g_pCTrayUI->HrInitTrayUI();
        }
    }

    MSG msg;
    while (GetMessage (&msg, 0, 0, 0))
    {
        DispatchMessage (&msg);
    }

    if (fCoInited)
    {
        CoUninitialize();
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionTray::HrHandleTrayOpen
//
//  Purpose:    Handler for the Net Connections Tray object ::Exec call
//              SSOCMDID_OPEN command
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     jeffspr   7 Jan 1998
//
//  Notes:
//
HRESULT CConnectionTray::HrHandleTrayOpen()
{
    HRESULT hr  = S_OK;

    // Turn off separate thread for Whistler. The proper way to do this is to register at runtime
    // a ShellServiceObject when UI is needed and de-register when not needed, using 
#if 0
    TraceTag(ttidShellFolder, "Starting tray thread proc");
    QueueUserWorkItem(TrayInitThreadProc, NULL, WT_EXECUTELONGFUNCTION);
#else
    if (SUCCEEDED(hr))
    {
        // We don't care if this is S_FALSE or not, since we'll soon
        // overwrite the hr. If it's already initialized, great...

        // Create the TrayUI object and save it in a global.
        //
        Assert(!g_pCTrayUI);

        if (!g_pCTrayUI)
        {
            g_pCTrayUI = new CTrayUI();
            if (!g_pCTrayUI)
            {
                hr = E_OUTOFMEMORY;
            }
        }

        // Initialize the tray UI object
        //
        if (g_pCTrayUI)
        {
            hr = g_pCTrayUI->HrInitTrayUI();
        }

        // Add the Notify Sink
        if (SUCCEEDED(hr))
        {
            g_ccl.EnsureConPointNotifyAdded(); 
        }
    }
#endif

    TraceHr(ttidError, FAL, hr, FALSE, "CConnectionTray::HrHandleTrayOpen()");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionTray::HrHandleTrayClose
//
//  Purpose:    Handler for the Net Connections Tray object ::Exec call
//              SSOCMDID_CLOSE command
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     jeffspr   7 Jan 1998
//
//  Notes:
//
HRESULT CConnectionTray::HrHandleTrayClose()
{
    HRESULT hr  = S_OK;

    g_ccl.EnsureConPointNotifyRemoved();

    if (g_pCTrayUI)
    {
        // Destroy the tray UI object
        //
        hr = g_pCTrayUI->HrDestroyTrayUI();

        // Check the outcome, and trace it if it failed, but ignore a failure,
        // and continue to destroy the object
        //
        TraceHr(ttidError, FAL, hr, FALSE,
            "Failed in call to g_pCTrayUI->HrDestroyTrayUI");

        // Delete the tray object
        //
        delete g_pCTrayUI;
        g_pCTrayUI = NULL;

        TraceTag(ttidShellFolder, "Deleted the connections tray object");
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CConnectionTray::HrHandleTrayClose()");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\shell\folder\foldreg.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       F O L D R E G . C P P
//
//  Contents:   Register the folder class
//
//  Notes:
//
//  Author:     jeffspr   30 Sep 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "foldinc.h"    // Standard shell\folder includes

extern const WCHAR c_szNetShellDll[];

//---[ Constants ]------------------------------------------------------------

static const WCHAR* c_szShellFoldDefaultIconVal     =   c_szNetShellDll;
static const WCHAR  c_szShellFolderAttributeVal[]   =   L"Attributes";
static const WCHAR  c_szShellFolderLocalizedString[] =   L"LocalizedString";
static const WCHAR  c_szShellFolderInfoTip[]         =   L"InfoTip";

static const WCHAR  c_szShellFolderClsID[]  =
        L"CLSID\\{7007ACC7-3202-11D1-AAD2-00805FC1270E}";

static const WCHAR  c_szShellFolder98ClsID[]  =
        L"CLSID\\{992CFFA0-F557-101A-88EC-00DD010CCC48}";

static const WCHAR  c_szShellFoldDefaultIcon[]  =
        L"CLSID\\{7007ACC7-3202-11D1-AAD2-00805FC1270E}\\DefaultIcon";

static const WCHAR  c_szShellFoldDefaultIcon98[]  =
        L"CLSID\\{992CFFA0-F557-101A-88EC-00DD010CCC48}\\DefaultIcon";

static const WCHAR  c_szShellFolderKey[]        =
        L"CLSID\\{7007ACC7-3202-11D1-AAD2-00805FC1270E}\\ShellFolder";

static const WCHAR  c_szShellFolderKey98[]        =
        L"CLSID\\{992CFFA0-F557-101A-88EC-00DD010CCC48}\\ShellFolder"; 

static const WCHAR  c_szDotDun[]                = L".dun";
static const WCHAR  c_szDunFile[]               = L"dunfile";
static const WCHAR  c_szDunFileFriendlyName[]   = L"Dialup Networking File";
static const WCHAR  c_szDefaultIcon[]           = L"DefaultIcon";
static const WCHAR  c_szDunIconPath[]           = L"%SystemRoot%\\system32\\netshell.dll,1";
static const WCHAR  c_szShellOpenCommand[]      = L"shell\\open\\command";

static const WCHAR  c_szNetShellEntry[]     = 
        L"%SystemRoot%\\system32\\RUNDLL32.EXE NETSHELL.DLL,InvokeDunFile %1";

static const WCHAR c_szApplicationsNetShell[] =
        L"Applications\\netshell.dll";
static const WCHAR c_szNoOpenWith[]         = L"NoOpenWith";

//+---------------------------------------------------------------------------
//
//  Function:   HrRegisterFolderClass
//
//  Purpose:    Fix the registry values for the Shell entries under HKCR,
//              CLSID\{CLSID}. The code generated from the RGS script doesn't
//              support our replaceable params by default, so we'll fix
//              it up after the fact.
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     jeffspr   23 Sep 1997
//
//  Notes:
//
HRESULT HrRegisterFolderClass()
{
    HRESULT hr      = S_OK;
    LONG    lResult = 0;

    WCHAR szRegValue[MAX_PATH+1];
    WCHAR szWinDir[MAX_PATH+1];

    // Adjust the AppID for Local Server or Service
    CRegKey keyShellDefaultIcon;
    CRegKey keyShellFolder;

    if (GetSystemWindowsDirectory(szWinDir, MAX_PATH+1))
    {
        lResult = keyShellDefaultIcon.Open(HKEY_CLASSES_ROOT, c_szShellFoldDefaultIcon);
        if (lResult == ERROR_SUCCESS)
        {
            wsprintfW(szRegValue, L"%s\\system32\\%s", szWinDir, c_szShellFoldDefaultIconVal);
            keyShellDefaultIcon.SetValue(szRegValue);
            keyShellDefaultIcon.Close();

            lResult = keyShellFolder.Open(HKEY_CLASSES_ROOT, c_szShellFolderKey);
            if (lResult == ERROR_SUCCESS)
            {
                DWORD dwFlags   = SFGAO_FOLDER;

                hr = HrRegSetValueEx(keyShellFolder,
                        c_szShellFolderAttributeVal,
                        REG_BINARY,
                        (LPBYTE) &dwFlags,
                        sizeof (dwFlags));

                keyShellFolder.Close();
            }

            // Write the MUI versions of LocalizedString & InfoTip out to the registry
            lResult = keyShellFolder.Open(HKEY_CLASSES_ROOT, c_szShellFolderClsID);
            if (lResult == ERROR_SUCCESS)
            {
                TCHAR szLocalizedString[MAX_PATH];
                TCHAR szInfoTip[MAX_PATH];

                wsprintf(szLocalizedString, _T("@%s\\system32\\%s,-%d"), szWinDir, c_szNetShellDll, IDS_CONFOLD_NAME);
                wsprintf(szInfoTip, _T("@%s\\system32\\%s,-%d"), szWinDir, c_szNetShellDll, IDS_CONFOLD_INFOTIP);
                hr = HrRegSetValueEx(keyShellFolder,
                    c_szShellFolderLocalizedString,
                    REG_SZ,
                    (LPBYTE) &szLocalizedString,
                    (lstrlen(szLocalizedString) + 1) * sizeof(TCHAR));

                hr = HrRegSetValueEx(keyShellFolder,
                    c_szShellFolderInfoTip,
                    REG_SZ,
                    (LPBYTE) &szInfoTip,
                    (lstrlen(szInfoTip) + 1) * sizeof(TCHAR));
                
                keyShellFolder.Close();
            }

            lResult = keyShellFolder.Open(HKEY_CLASSES_ROOT, c_szShellFolder98ClsID);
            if (lResult == ERROR_SUCCESS)
            {
                TCHAR szLocalizedString[MAX_PATH];
                TCHAR szInfoTip[MAX_PATH];

                wsprintf(szLocalizedString, _T("@%s\\system32\\%s,-%d"), szWinDir, c_szNetShellDll, IDS_CONFOLD_NAME);
                wsprintf(szInfoTip, _T("@%s\\system32\\%s,-%d"), szWinDir, c_szNetShellDll, IDS_CONFOLD_INFOTIP);
                hr = HrRegSetValueEx(keyShellFolder,
                    c_szShellFolderLocalizedString,
                    REG_SZ,
                    (LPBYTE) &szLocalizedString,
                    (lstrlen(szLocalizedString) + 1) * sizeof(TCHAR));

                hr = HrRegSetValueEx(keyShellFolder,
                    c_szShellFolderInfoTip,
                    REG_SZ,
                    (LPBYTE) &szInfoTip,
                    (lstrlen(szInfoTip) + 1) * sizeof(TCHAR));
                
                keyShellFolder.Close();
            }
            
            // added for #413840
            CRegKey keyShellDefaultIcon98;
            CRegKey keyShellFolder98;

            lResult = keyShellDefaultIcon98.Open(HKEY_CLASSES_ROOT, c_szShellFoldDefaultIcon98);
            if (lResult == ERROR_SUCCESS)
            {
                wsprintfW(szRegValue, L"%s\\system32\\%s", szWinDir, c_szShellFoldDefaultIconVal);
                keyShellDefaultIcon98.SetValue(szRegValue);
                keyShellDefaultIcon98.Close();
            }

            lResult = keyShellFolder98.Open(HKEY_CLASSES_ROOT, c_szShellFolderKey98);
            if (lResult == ERROR_SUCCESS)
            {
                DWORD dwFlags   = SFGAO_FOLDER;

                hr = HrRegSetValueEx(keyShellFolder98,
                        c_szShellFolderAttributeVal,
                        REG_BINARY,
                        (LPBYTE) &dwFlags,
                        sizeof (dwFlags));

                keyShellFolder98.Close();
            }
        }
        else
        {
            // Translate LRESULT to HR
            //
            hr = HRESULT_FROM_WIN32(lResult);
        }
    }
    else    // GetWindowsDirectory failed
    {
        hr = HrFromLastWin32Error();
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegisterDUNFileAssociation
//
//  Purpose:    Add or upgrade the registry associate for .DUN fles
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     tongl 2 Feb, 1999
//
//  Notes:
//

HRESULT HrRegisterDUNFileAssociation()
{
    HRESULT hr = S_OK;
    
    HKEY    hkeyRootDun     = NULL;
    HKEY    hkeyRootDunFile = NULL;
    HKEY    hkeyCommand     = NULL;
    HKEY    hkeyIcon        = NULL;
    DWORD   dwDisposition;
    WCHAR   szFriendlyTypeName[MAX_PATH+1];


    // Create or open HKEY_CLASSES_ROOT\.dun
    hr = HrRegCreateKeyEx(HKEY_CLASSES_ROOT, 
                          c_szDotDun,
                          REG_OPTION_NON_VOLATILE, 
                          KEY_WRITE, 
                          NULL,
                          &hkeyRootDun, 
                          &dwDisposition);
    if (SUCCEEDED(hr))
    {
        if (REG_CREATED_NEW_KEY == dwDisposition)
        {
            hr = HrRegSetSz(hkeyRootDun, 
                            c_szEmpty, 
                            c_szDunFile);

            TraceError("Error creating file association for .dun files", hr);
        }

        RegSafeCloseKey(hkeyRootDun);

        if (SUCCEEDED(hr))
        {
            // create or open HKEY_CLASSES_ROOT\dunfile
            hr = HrRegCreateKeyEx(HKEY_CLASSES_ROOT, 
                                  c_szDunFile,
                                  REG_OPTION_NON_VOLATILE, 
                                  KEY_WRITE, 
                                  NULL,
                                  &hkeyRootDunFile, 
                                  &dwDisposition);
            if (SUCCEEDED(hr))
            {
                // Set friendly type name
                hr = HrRegSetValueEx(hkeyRootDunFile,
                                     c_szEmpty,
                                     REG_SZ,
                                     (LPBYTE) c_szDunFileFriendlyName,
                                     CbOfSzAndTermSafe(c_szDunFileFriendlyName));

                // trace the error 
                TraceError("Error creating friendly name for .DUN files", hr);

                // Now, write MUI compliant friendly type name.
                                     
                wsprintf(szFriendlyTypeName,
                         L"@%%SystemRoot%%\\system32\\%s,-%d",
                         c_szNetShellDll,
                         IDS_DUN_FRIENDLY_NAME);

                hr = HrRegSetValueEx(hkeyRootDunFile,
                                     L"FriendlyTypeName",
                                     REG_EXPAND_SZ,
                                     (LPBYTE)szFriendlyTypeName,
                                     CbOfSzAndTermSafe(szFriendlyTypeName));

                // trace the error 
                TraceError("Error creating MUI friendly name for .DUN files", hr);

                hr = S_OK;


                // Set DefaultIcon
                // HKEY_CLASSES_ROOT\dunfile\DefaultIcon = "%SystemRoot%\System32\netshell.dll,1"
                hr = HrRegCreateKeyEx(hkeyRootDunFile, 
                                      c_szDefaultIcon,
                                      REG_OPTION_NON_VOLATILE, 
                                      KEY_WRITE, 
                                      NULL,
                                      &hkeyIcon, 
                                      &dwDisposition);
                if (SUCCEEDED(hr))
                {
                    hr = HrRegSetValueEx (hkeyIcon,
                                          c_szEmpty,
                                          REG_EXPAND_SZ,
                                          (LPBYTE) c_szDunIconPath,
                                          CbOfSzAndTermSafe(c_szDunIconPath));

                    RegSafeCloseKey(hkeyIcon);
                }

                // trace the error 
                TraceError("Error creating DefaultIcon for .DUN files", hr);
                hr = S_OK;
                
                // Set or update Command to invoke 
                // HKEY_CLASSES_ROOT\dunfile\shell\open\command = 
                // "%%SystemRoot%%\system32\RUNDLL32.EXE NETSHELL.DLL,RunDunImport %1"
                hr = HrRegCreateKeyEx(hkeyRootDunFile, 
                                      c_szShellOpenCommand,
                                      REG_OPTION_NON_VOLATILE, 
                                      KEY_WRITE, 
                                      NULL,
                                      &hkeyCommand, 
                                      &dwDisposition);
                if (SUCCEEDED(hr))
                {
                    hr = HrRegSetValueEx(hkeyCommand,
                                         c_szEmpty,
                                         REG_EXPAND_SZ,
                                         (LPBYTE) c_szNetShellEntry,
                                         CbOfSzAndTermSafe(c_szNetShellEntry));
                    if(SUCCEEDED(hr))
                    {
                        HKEY hkeyNetShell = NULL;
                        HRESULT hr2 = HrRegCreateKeyEx(HKEY_CLASSES_ROOT, 
                                                       c_szApplicationsNetShell,
                                                       REG_OPTION_NON_VOLATILE, 
                                                       KEY_WRITE, 
                                                       NULL,
                                                       &hkeyNetShell, 
                                                       &dwDisposition);

                        if(SUCCEEDED(hr2) && (REG_CREATED_NEW_KEY == dwDisposition))
                        {
                            hr2 = HrRegSetValueEx(hkeyNetShell,
                                                  c_szNoOpenWith,
                                                  REG_SZ,
                                                  (LPBYTE) c_szEmpty,
                                                  CbOfSzAndTermSafe(c_szEmpty));
                        }

                        // trace the error 
                        TraceError("Error creating NoOpenWith value for .DUN files", hr2);
                        RegSafeCloseKey(hkeyNetShell);
                    }
    
                    // trace the error 
                    TraceError("Error creating ShellCommand for .DUN files", hr);
                    hr = S_OK;

                    RegSafeCloseKey(hkeyCommand);
                }

                RegSafeCloseKey(hkeyRootDunFile);
            }
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\shell\folder\iconhandler.cpp ===
#include "pch.h"
#pragma hdrstop

#include "nsbase.h"
#include <nsres.h>
#include "ncmisc.h"
#include "foldres.h"
#include "foldinc.h"    // Standard shell\folder includes
#include "connlist.h"
#include "iconhandler.h"

template <class E> class ENUM_IDI_MAP
{
public:
    E   EnumEntry;
    int iIcon;
};

template <class E> int MapIconEnumToResourceID(IN const ENUM_IDI_MAP<E> IconEnumArray[], IN DWORD dwElems, IN const E EnumMatch)
{
    if (0 == EnumMatch)
    {
        return 0;
    }
    
    for (DWORD x = 0; x < dwElems; x++)
    {
        if (EnumMatch == IconEnumArray[x].EnumEntry)
        {
            return IconEnumArray[x].iIcon;
        }  
    }
    
    AssertSz(FALSE, "Could not map match to Icon enum array");
    return 0;
};

static const ENUM_IDI_MAP<ENUM_STAT_ICON> c_STATUS_ICONS[] = 
{
    ICO_STAT_FAULT,         IDI_CFI_STAT_FAULT,
    ICO_STAT_INVALID_IP,    IDI_CFI_STAT_QUESTION,
    ICO_STAT_EAPOL_FAILED,  IDI_CFI_STAT_QUESTION
};

static const ENUM_IDI_MAP<ENUM_CHARACTERISTICS_ICON> c_CHARACTERISTICS_ICON[] = 
{
    ICO_CHAR_INCOMING,      IDI_OVL_INCOMING,
    ICO_CHAR_DEFAULT,       IDI_OVL_DEFAULT,
    ICO_CHAR_FIREWALLED,    IDI_OVL_FIREWALLED,
    ICO_CHAR_SHARED,        IDI_OVL_SHARED,
};

static const ENUM_IDI_MAP<ENUM_CONNECTION_ICON> c_CONNECTION_ICONS[] = 
{
    ICO_CONN_BOTHOFF,       IDI_CFI_CONN_ALLOFF,
    ICO_CONN_RIGHTON,       IDI_CFI_CONN_RIGHTON,
    ICO_CONN_LEFTON,        IDI_CFI_CONN_LEFTON,
    ICO_CONN_BOTHON,        IDI_CFI_CONN_BOTHON,
};

struct NC_MEDIATYPE_ICON
{
    DWORD               ncm;  // NETCON_MEDIATYPE (Shifted left by SHIFT_NETCON_MEDIATYPE)
    DWORD               ncsm; // NETCON_SUBMEDIATYPE (Shifted left by SHIFT_NETCON_SUBMEDIATYPE)
    DWORD               dwMasksSupported;
    INT                 iIcon;
    INT                 iIconDisabled; // Only for dwMasksSupported == MASK_NO_CONNECTIONOVERLAY
};

static const NC_MEDIATYPE_ICON c_NCM_ICONS[] = 
{
//    NETCON_MEDIATYPE (Shifted left by SHIFT_NETCON_MEDIATYPE)
//      |                                              NETCON_SUBMEDIATYPE (Shifted left by SHIFT_NETCON_SUBMEDIATYPE (0) )
//      |                                                       |            dwMasksSupported
//      |                                                       |                  |                       iIcon                 
//      |                                                       |                  |                          |                    Disabled Icon 
//      |                                                       |                  |                          |                        | (for MASK_NO_CONNECTIONOVERLAY)
//      v                                                       v                  v                          v                        v 
    NCM_NONE                 << SHIFT_NETCON_MEDIATYPE, NCSM_NONE,      MASK_NO_CONNECTIONOVERLAY,    IDI_CFI_RASSERVER,        IDI_CFI_RASSERVER,
    NCM_BRIDGE               << SHIFT_NETCON_MEDIATYPE, NCSM_NONE,      MASK_STATUSOVERLAY,           IDI_CFI_BRIDGE_CONNECTED, IDI_CFI_BRIDGE_DISCONNECTED,
    NCM_SHAREDACCESSHOST_LAN << SHIFT_NETCON_MEDIATYPE, NCSM_NONE,      MASK_NO_CONNECTIONOVERLAY,    IDI_CFI_SAH_LAN,          IDI_CFI_SAH_LAN,   
    NCM_SHAREDACCESSHOST_RAS << SHIFT_NETCON_MEDIATYPE, NCSM_NONE,      MASK_NO_CONNECTIONOVERLAY,    IDI_CFI_SAH_RAS,          IDI_CFI_SAH_RAS,   
    NCM_DIRECT               << SHIFT_NETCON_MEDIATYPE, NCSM_NONE,      MASK_SUPPORT_ALL,             IDI_CFI_DIRECT,           0,
    NCM_DIRECT               << SHIFT_NETCON_MEDIATYPE, NCSM_DIRECT,    MASK_SUPPORT_ALL,             IDI_CFI_DIRECT,           0,
    NCM_DIRECT               << SHIFT_NETCON_MEDIATYPE, NCSM_IRDA,      MASK_SUPPORT_ALL,             IDI_CFI_DIRECT,           0,
    NCM_ISDN                 << SHIFT_NETCON_MEDIATYPE, NCSM_NONE,      MASK_SUPPORT_ALL,             IDI_CFI_ISDN,             0,
    NCM_LAN                  << SHIFT_NETCON_MEDIATYPE, NCSM_1394,      MASK_SUPPORT_ALL,             IDI_CFI_LAN,              0,
    NCM_LAN                  << SHIFT_NETCON_MEDIATYPE, NCSM_ATM,       MASK_SUPPORT_ALL,             IDI_CFI_LAN,              0,
    NCM_LAN                  << SHIFT_NETCON_MEDIATYPE, NCSM_ELAN,      MASK_SUPPORT_ALL,             IDI_CFI_LAN,              0,
    NCM_LAN                  << SHIFT_NETCON_MEDIATYPE, NCSM_LAN,       MASK_SUPPORT_ALL,             IDI_CFI_LAN,              0,
    NCM_LAN                  << SHIFT_NETCON_MEDIATYPE, NCSM_WIRELESS,  MASK_SUPPORT_ALL,             IDI_CFI_WIRELESS,         0,
    NCM_PPPOE                << SHIFT_NETCON_MEDIATYPE, NCSM_NONE,      MASK_SUPPORT_ALL,             IDI_CFI_PPPOE,            0,
    NCM_PHONE                << SHIFT_NETCON_MEDIATYPE, NCSM_NONE,      MASK_SUPPORT_ALL,             IDI_CFI_PHONE,            0,
    NCM_PHONE                << SHIFT_NETCON_MEDIATYPE, NCSM_CM,        MASK_SUPPORT_ALL,             IDI_CFI_CM,               0,
    NCM_TUNNEL               << SHIFT_NETCON_MEDIATYPE, NCSM_NONE,      MASK_SUPPORT_ALL,             IDI_CFI_VPN,              0,
    NCM_TUNNEL               << SHIFT_NETCON_MEDIATYPE, NCSM_CM,        MASK_SUPPORT_ALL,             IDI_CFI_CM,               0,
};

struct NC_STATUS_ICON
{
    NETCON_STATUS        ncs;
    DWORD                dwStatIcon;
    ENUM_CONNECTION_ICON enumConnectionIcon;
};

static const NC_STATUS_ICON c_NCS_ICONS[] = 
{
//   NETCON_STATUS
//        |                         dwStatIcon
//        |                           |                                  enumConnectionIcon
//        |                           |                                      |
//        v                           v                                      v
    NCS_AUTHENTICATING,           ICO_STAT_NONE,                           ICO_CONN_BOTHON,
    NCS_AUTHENTICATION_SUCCEEDED, ICO_STAT_NONE,                           ICO_CONN_BOTHON,
    NCS_AUTHENTICATION_FAILED,    ICO_STAT_EAPOL_FAILED,                   ICO_CONN_BOTHON,
    NCS_CREDENTIALS_REQUIRED,     ICO_STAT_EAPOL_FAILED,                   ICO_CONN_BOTHON,
    NCS_CONNECTED,                ICO_STAT_NONE,                           ICO_CONN_BOTHON,
    NCS_DISCONNECTING,            ICO_STAT_NONE,                           ICO_CONN_BOTHON,
    NCS_CONNECTING,               ICO_STAT_DISABLED | ICO_STAT_NONE,       ICO_CONN_BOTHOFF,
    NCS_DISCONNECTED,             ICO_STAT_DISABLED | ICO_STAT_NONE,       ICO_CONN_BOTHOFF,
    NCS_INVALID_ADDRESS,          ICO_STAT_INVALID_IP,                     ICO_CONN_BOTHON,
    NCS_HARDWARE_DISABLED,        ICO_STAT_FAULT,                          ICO_CONN_BOTHON,
    NCS_HARDWARE_MALFUNCTION,     ICO_STAT_FAULT,                          ICO_CONN_BOTHON,
    NCS_HARDWARE_NOT_PRESENT,     ICO_STAT_FAULT,                          ICO_CONN_BOTHON,
    NCS_MEDIA_DISCONNECTED,       ICO_STAT_FAULT,                          ICO_CONN_BOTHON,
};

//+---------------------------------------------------------------------------
//
//  Function:   CNetConfigIcons::CNetConfigIcons
//
//  Purpose:    CNetConfigIcons constructor
//
//  Arguments:
//      none
//
//  Returns:
//      none
//
//  Author:     deonb    18 Feb 2001
//
//  Notes:  
//
CNetConfigIcons::CNetConfigIcons(IN HINSTANCE hInstance) throw() : m_hInstance(hInstance)
{
    TraceFileFunc(ttidIcons);

    dwLastBrandedId = 0;
    InitializeCriticalSection(&csNetConfigIcons);
}

//+---------------------------------------------------------------------------
//
//  Function:   CNetConfigIcons::~CNetConfigIcons
//
//  Purpose:    CNetConfigIcons destructor
//
//  Arguments:
//      none
//
//  Returns:
//      none
//
//  Author:     deonb    18 Feb 2001
//
//  Notes:  
//
CNetConfigIcons::~CNetConfigIcons() throw()
{
    // Can't trace in this function!

    IMAGELISTMAP::iterator iter;
    
    for (iter = m_ImageLists.begin(); iter != m_ImageLists.end(); iter++)
    {
        HIMAGELIST hImageLst = iter->second;
        ImageList_Destroy(hImageLst);
    }

    m_ImageLists.clear();
    DeleteCriticalSection(&csNetConfigIcons);
}

//+---------------------------------------------------------------------------
//
//  Function:   CNetConfigIcons::HrMergeTwoIcons
//
//  Purpose:    Merge a new icon unto an existing one
//
//  Arguments:
//      dwIconSize     [in]     Size of the icon
//      phMergedIcon   [in out] Icon 1 to merge, and contains the merged
//                              icon on output
//      hIconToMerge   [in]     Icon 2 to merge with
//
//  Returns:
//      HRESULT
//
//  Author:     deonb    4 Apr 2001
//
//  Notes:
//
HRESULT CNetConfigIcons::HrMergeTwoIcons(IN DWORD dwIconSize, IN OUT HICON *phMergedIcon, IN HICON hIconToMergeWith)
{
    HRESULT hr = S_FALSE;
    Assert(phMergedIcon);

    HIMAGELIST hImageLst = NULL;

    IMAGELISTMAP::iterator i = m_ImageLists.find(dwIconSize);
    if (i == m_ImageLists.end())
    {
        hImageLst = ImageList_Create(dwIconSize, dwIconSize, ILC_COLOR32 | ILC_MASK, 2, 0);
        if (hImageLst)
        {
            m_ImageLists[dwIconSize] = hImageLst;
        }
        else
        {
            hr = E_FAIL;
        }             
    }
    else
    {
        hImageLst = i->second;
    }

    if (SUCCEEDED(hr))
    {
        if (*phMergedIcon)
        {
            if (hIconToMergeWith)
            {
                hr = E_FAIL;

                // Merge the 2 icons;
                if (ImageList_RemoveAll(hImageLst))
                {
                    int iIcon1 = ImageList_AddIcon(hImageLst, *phMergedIcon);
                    if (-1 != iIcon1)
                    {
                        int iIcon2 = ImageList_AddIcon(hImageLst, hIconToMergeWith);
                        if (-1 != iIcon2)
                        {
                            if (ImageList_SetOverlayImage(hImageLst, iIcon2, 1))
                            {
                                DestroyIcon(*phMergedIcon); // Delete the current icon

                                *phMergedIcon = ImageList_GetIcon(hImageLst, iIcon1, INDEXTOOVERLAYMASK(1));
                                hr = S_OK;
                            }
                        }
                    }
                }
            }
            // else Nothing. Stays the same.
        }
        else
        {
            // Copy icon 2 to icon 1
            *phMergedIcon = CopyIcon(hIconToMergeWith);
        }
    }

    return hr;
};

//+---------------------------------------------------------------------------
//
//  Function:   CNetConfigIcons::HrGetInternalIconIDForPIDL
//
//  Purpose:    Map the connection state and connection type to the
//              appropriate icon resource IDs.
//
//  Arguments:
//      uFlags     [in]    The GIL_xxx shell flags
//      cfe        [in]    The connection folder entry
//      dwIcon     [out]   The ID of the icon
//
//  Returns:
//      HRESULT
//
//  Author:     deonb    18 Feb 2001
//
//  Notes:
//
HRESULT CNetConfigIcons::HrGetInternalIconIDForPIDL(IN UINT uFlags, IN const CConFoldEntry& cfe, OUT DWORD& dwIcon)
{
    TraceFileFunc(ttidIcons);

    if (cfe.GetCharacteristics() & NCCF_BRANDED)
    {
        AssertSz(FALSE, "Call HrGetBrandedIconIDForPIDL instead for branded icons");
        return E_INVALIDARG;
    }

    Assert(!cfe.empty());

    BOOL fValidIcon = FALSE;
    if (cfe.GetWizard() == WIZARD_MNC)
    {
        dwIcon = ICO_MGR_RESOURCEID | IDI_CONFOLD_WIZARD;
        fValidIcon = TRUE;
    }
    else if (cfe.GetWizard() == WIZARD_HNW)
    {
        dwIcon = ICO_MGR_RESOURCEID | IDI_CONFOLD_HOMENET_WIZARD;
        fValidIcon = TRUE;
    }
    else
    {
        dwIcon = ICO_MGR_INTERNAL;

        Assert(cfe.GetWizard() == WIZARD_NOT_WIZARD);

        const NETCON_SUBMEDIATYPE ncsm = cfe.GetNetConSubMediaType();
        const NETCON_MEDIATYPE    ncm  = cfe.GetNetConMediaType();
        const NETCON_STATUS       ncs  = cfe.GetNetConStatus();
        
        // Find the Status part of the icon
        for (DWORD dwLoop = 0; (dwLoop < celems(c_NCM_ICONS)); dwLoop++)
        {
            const NC_STATUS_ICON& ncsIcon = c_NCS_ICONS[dwLoop];

            if (ncs == ncsIcon.ncs)
            {
                Assert((ncsIcon.dwStatIcon         & (MASK_STATUS | MASK_STATUS_DISABLED) ) == ncsIcon.dwStatIcon);
                Assert((ncsIcon.enumConnectionIcon & (MASK_CONNECTION) ) == ncsIcon.enumConnectionIcon);

                dwIcon |= ncsIcon.dwStatIcon;
                dwIcon |= ncsIcon.enumConnectionIcon;
                dwIcon |= ncm  << SHIFT_NETCON_MEDIATYPE;
                dwIcon |= ncsm << SHIFT_NETCON_SUBMEDIATYPE;
                fValidIcon = TRUE;
                
                break;
            }
        }
    }

    AssertSz(fValidIcon, "Could not obtain an icon for this connection");

    if (fValidIcon)
    {
        return S_OK;
    }
    else
    {
        return E_FAIL;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   CNetConfigIcons::HrMergeCharacteristicsIcons
//
//  Purpose:    Merge the characteristics icons unto an input icon
//
//  Arguments:
//      dwIconSize     [in]     Size of the icon
//      dwIconId       [in]     Icon ID (to read Characteristics info from)
//      phMergedIcon   [in out] The icon to merge with, and contains the merged
//                              icon on output
//
//  Returns:
//      HRESULT
//
//  Author:     deonb    4 Apr 2001
//
//  Notes:
//
HRESULT CNetConfigIcons::HrMergeCharacteristicsIcons(IN DWORD dwIconSize, IN DWORD dwIconId, IN OUT HICON *phMergedIcon)
{
    HRESULT hr = S_OK;

    Assert(phMergedIcon);

    if (!(dwIconId & MASK_CHARACTERISTICS))
    {
        return S_FALSE;
    }

    // Characteristics
    int iFireWalled   = MapIconEnumToResourceID(c_CHARACTERISTICS_ICON, celems(c_CHARACTERISTICS_ICON), static_cast<ENUM_CHARACTERISTICS_ICON>(dwIconId & ICO_CHAR_FIREWALLED));
    int iIncoming     = MapIconEnumToResourceID(c_CHARACTERISTICS_ICON, celems(c_CHARACTERISTICS_ICON), static_cast<ENUM_CHARACTERISTICS_ICON>(dwIconId & ICO_CHAR_INCOMING));
    int iShared       = MapIconEnumToResourceID(c_CHARACTERISTICS_ICON, celems(c_CHARACTERISTICS_ICON), static_cast<ENUM_CHARACTERISTICS_ICON>(dwIconId & ICO_CHAR_SHARED));
    int iDefault      = MapIconEnumToResourceID(c_CHARACTERISTICS_ICON, celems(c_CHARACTERISTICS_ICON), static_cast<ENUM_CHARACTERISTICS_ICON>(dwIconId & ICO_CHAR_DEFAULT));

    HICON hFireWalled = iFireWalled ? LoadIconSize(m_hInstance, MAKEINTRESOURCE(iFireWalled), dwIconSize) : NULL;
    HICON hShared     = iShared     ? LoadIconSize(m_hInstance, MAKEINTRESOURCE(iShared),     dwIconSize) : NULL;
    HICON hDefault    = iDefault    ? LoadIconSize(m_hInstance, MAKEINTRESOURCE(iDefault),    dwIconSize) : NULL;
    HICON hIncoming   = NULL;
    
    if (dwIconSize != GetSystemMetrics(SM_CXSMICON)) // Shouldn't display in 16x16
    {
        hIncoming = iIncoming ? LoadIconSize(m_hInstance, MAKEINTRESOURCE(iIncoming), dwIconSize) : NULL;
        AssertSz(FImplies(iIncoming, hIncoming),     "Could not load the Incoming Icon");
    }

    AssertSz(FImplies(iFireWalled, hFireWalled), "Could not load the FireWalled Icon");
    AssertSz(FImplies(iShared, hShared),         "Could not load the Shared Icon");
    AssertSz(FImplies(iDefault, hDefault),       "Could not load the Default Icon");

    HICON hIconArray[] = {hFireWalled, hIncoming, hShared, hDefault};

    for (int x = 0; x < celems(hIconArray); x++)
    {
        hr = HrMergeTwoIcons(dwIconSize, phMergedIcon, hIconArray[x]);
        if (FAILED(hr))
        {
            break;
        }
    }

    for (int x = 0; x < celems(hIconArray); x++)
    {
        if (hIconArray[x])
        {
            DestroyIcon(hIconArray[x]);
            hIconArray[x] = NULL;
        }
    }

    AssertSz(SUCCEEDED(hr) && *phMergedIcon, "Could not load a characteristics icon");

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CNetConfigIcons::HrGetInternalIconFromIconId
//
//  Purpose:    Loads the netshell internal icon given the icon ID 
//               (from HrGetInternalIconIDForPIDL)
//
//  Arguments:
//      dwIconSize [in]  Size of the icon required
//      dwIconId   [in]  Icon ID - from HrGetInternalIconIDForPIDL
//      hIcon      [out] The icon that was loaded
//
//  Returns:
//      HRESULT
//
//  Author:     deonb    18 Feb 2001
//
//  Notes:
//
HRESULT CNetConfigIcons::HrGetInternalIconFromIconId(IN DWORD dwIconSize, IN DWORD dwIconId, OUT HICON &hIcon)
{
    TraceFileFunc(ttidIcons);

    DWORD dwlrFlags = 0;

    if ( (dwIconId & MASK_ICONMANAGER) != ICO_MGR_INTERNAL)
    {
        AssertSz(FALSE, "This is not an internal icon");
        return E_INVALIDARG;
    }

    HRESULT hr = E_FAIL;

    DWORD ncm  = (dwIconId & MASK_NETCON_MEDIATYPE);
    DWORD ncsm = (dwIconId & MASK_NETCON_SUBMEDIATYPE);

    BOOL fDisabledStatus = (dwIconId & ICO_STAT_DISABLED);

    // Status & Connection
    int iStatus       = MapIconEnumToResourceID(c_STATUS_ICONS,     celems(c_STATUS_ICONS),     static_cast<ENUM_STAT_ICON>(dwIconId & MASK_STATUS));
    int iConnection   = MapIconEnumToResourceID(c_CONNECTION_ICONS, celems(c_CONNECTION_ICONS), static_cast<ENUM_CONNECTION_ICON>(dwIconId & MASK_CONNECTION));

    int iMediaType          = 0;

    // Media Type
    for (int x = 0; x < celems(c_NCM_ICONS); x++)
    {
        const NC_MEDIATYPE_ICON& ncmIcon = c_NCM_ICONS[x];

        // Use NCSM if available, otherwise use NCM
        if ( ((NCSM_NONE == ncsm) && (NCSM_NONE == ncmIcon.ncsm) && (ncm == ncmIcon.ncm)) ||
             ((NCSM_NONE != ncsm) && (ncsm == ncmIcon.ncsm)) )
        {
            if (!(ncmIcon.dwMasksSupported & MASK_CONNECTION))
            {
                iConnection    = 0;
            }

            if (!(ncmIcon.dwMasksSupported & MASK_STATUS))
            {
                iStatus        = 0;
            }
            
            iMediaType = ncmIcon.iIcon;

            if (!(iConnection || iStatus) && 
                 (fDisabledStatus))
            {
                Assert(ncmIcon.iIconDisabled);
                iMediaType = ncmIcon.iIconDisabled;
            }
        }
    }

    Assert(iMediaType);
    if (iMediaType)
    {
        HICON hMediaType  = iMediaType  ? LoadIconSize(m_hInstance, MAKEINTRESOURCE(iMediaType), dwIconSize)  : NULL;
        HICON hStatus     = iStatus     ? LoadIconSize(m_hInstance, MAKEINTRESOURCE(iStatus),    dwIconSize)  : NULL;
        HICON hConnection = NULL;

        if (dwIconSize != GetSystemMetrics(SM_CXSMICON)) // Shouldn't display in 16x16
        {
            hConnection = iConnection ? LoadIconSize(m_hInstance, MAKEINTRESOURCE(iConnection),  dwIconSize)  : NULL;
            AssertSz(FImplies(iConnection, hConnection), "Could not load the Connection Icon");
        }

        AssertSz(FImplies(iMediaType, hMediaType),   "Could not load the Media Type Icon");
        AssertSz(FImplies(iStatus, hStatus),         "Could not load the Status Icon");

        HICON hIconArray[] = {hMediaType, hStatus, hConnection};
        hIcon = NULL;

        for (int x = 0; x < celems(hIconArray); x++)
        {
            hr = HrMergeTwoIcons(dwIconSize, &hIcon, hIconArray[x]);
            if (FAILED(hr))
            {
                break;
            }
        }

        for (int x = 0; x < celems(hIconArray); x++)
        {
            if (hIconArray[x])
            {
                DestroyIcon(hIconArray[x]);
                hIconArray[x] = NULL;
            }
        }

        if (SUCCEEDED(hr))
        {
            hr = HrMergeCharacteristicsIcons(dwIconSize, dwIconId, &hIcon);
            if (SUCCEEDED(hr))
            {
                hr = S_OK;
            }

        }
    }

    AssertSz(SUCCEEDED(hr) && hIcon, "Could not load any icon");

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   CNetConfigIcons::HrGetResourceIconFromIconId
//
//  Purpose:    Loads a resource icon given the icon ID 
//               (from HrGetInternalIconIDForPIDL)
//
//  Arguments:
//      dwIconSize [in]  Size of the icon required
//      dwIconId   [in]  Icon ID - from HrGetInternalIconIDForPIDL
//      hIcon      [out] The icon that was loaded
//
//  Returns:
//      HRESULT
//
//  Author:     deonb    18 Feb 2001
//
//  Notes:
//
HRESULT CNetConfigIcons::HrGetResourceIconFromIconId(IN DWORD dwIconSize, IN DWORD dwIconId, OUT HICON &hIcon)
{
    TraceFileFunc(ttidIcons);

    DWORD dwlrFlags = 0;

    if ( (dwIconId & MASK_ICONMANAGER) != ICO_MGR_RESOURCEID)
    {
        AssertSz(FALSE, "This is not a resource id icon manager icon");
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;

    int iIcon = dwIconId & MASK_BRANDORRESOURCEID; // Clear the rest of the bits;

    hIcon = LoadIconSize(m_hInstance, MAKEINTRESOURCE(iIcon), dwIconSize);
    if (!hIcon)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    else
    {
        hr = HrMergeCharacteristicsIcons(dwIconSize, dwIconId, &hIcon);
        if (SUCCEEDED(hr))
        {
            hr = S_OK;
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "Could not load icon %d (size %d x %d) from resource file", iIcon, dwIconSize, dwIconSize);

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CNetConfigIcons::HrGetBrandedIconIDForPIDL
//
//  Purpose:    Initializes the branded icon info from a file
//
//  Arguments:
//      uFlags     [in]    The GIL_xxx shell flags
//      cfe        [in]    The connection folder entry
//      dwIcon     [out]   The ID of the icon
//
//  Returns:
//      HRESULT
//
//  Author:     deonb    18 Feb 2001
//
//  Notes: We store this internally into a map - hence we can't cache
//         branded icons since we might not end up with the same id in the map
//
HRESULT CNetConfigIcons::HrGetBrandedIconIDForPIDL(IN UINT uFlags, IN const CConFoldEntry& cfe, OUT DWORD& dwIcon)
{
    TraceFileFunc(ttidIcons);

    HRESULT hr = S_OK;

    if (!(cfe.GetCharacteristics() & NCCF_BRANDED))
    {
        AssertSz(FALSE, "Call HrGetInternalIconIDForPIDL instead for non-branded icons");
        return E_INVALIDARG;
    }

    Assert(!cfe.empty());

    if (cfe.GetWizard() != WIZARD_NOT_WIZARD)
    {
        AssertSz(FALSE, "You're not allowed to brand the wizard");
        hr = E_INVALIDARG;
    }
    else
    {
        dwIcon = ICO_MGR_CM;

        if (g_ccl.IsInitialized() == FALSE)
        {
            g_ccl.HrRefreshConManEntries();
        }
        
        ConnListEntry  cle;
        hr = g_ccl.HrFindConnectionByGuid(&(cfe.GetGuidID()), cle);
        if (S_OK == hr)
        {
            tstring szBrandedFileName;
            BOOL bBrandedName = FALSE;
            
            if (cle.pcbi)
            {
                if (cle.pcbi->szwLargeIconPath)
                {
                    szBrandedFileName = cle.pcbi->szwLargeIconPath;
                    bBrandedName = TRUE;
                }
                else if (cle.pcbi->szwSmallIconPath)
                {
                    szBrandedFileName = cle.pcbi->szwSmallIconPath;
                    bBrandedName = TRUE;
                }
            }

            if (bBrandedName)
            {
                BrandedNames::const_iterator i = m_BrandedNames.find(szBrandedFileName);
                if (i == m_BrandedNames.end()) // Doesn't exist yet
                {
                    dwLastBrandedId++;
                    m_BrandedNames[szBrandedFileName] = dwLastBrandedId;
                    dwIcon |= dwLastBrandedId;
                }
                else
                {
                    dwIcon |= i->second;
                }
            }
            else
            {
                CConFoldEntry cfeTmp;
                cfeTmp = cfe;
                cfeTmp.SetCharacteristics(cfe.GetCharacteristics() & ~NCCF_BRANDED);
                cfeTmp.SetNetConSubMediaType(NCSM_CM);
                dwIcon = 0;
                hr = HrGetInternalIconIDForPIDL(uFlags, cfeTmp, dwIcon);
            }
        }
        else
        {
            hr = E_FILE_NOT_FOUND;
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "Could not obtain an icon for this connection");

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CNetConfigIcons::HrGetBrandedIconFromIconId
//
//  Purpose:    Loads the branded icon given the icon ID 
//               (from HrGetBrandedIconIDForPIDL)
//
//  Arguments:
//      dwIconSize [in]  Size of the icon required
//      dwIconId   [in]  Icon ID - from HrGetBrandedIconIDForPIDL
//      hIcon      [out] The icon that was loaded
//
//  Returns:
//      HRESULT
//
//  Author:     deonb    18 Feb 2001
//
//  Notes:
//
HRESULT CNetConfigIcons::HrGetBrandedIconFromIconId(IN DWORD dwIconSize, IN DWORD dwIconId, OUT HICON &hIcon)
{
    TraceFileFunc(ttidIcons);

    if ( (dwIconId & MASK_ICONMANAGER) != ICO_MGR_CM)
    {
        AssertSz(FALSE, "This is not a branded icon");
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;
    
    DWORD dwIconIdTmp;
    dwIconIdTmp = dwIconId & MASK_BRANDORRESOURCEID;

    Assert(dwIconIdTmp);

    if (dwIconIdTmp)
    {
        BOOL bFound = FALSE;
        tstring szBrandedFileName;
        for (BrandedNames::iterator i = m_BrandedNames.begin(); i != m_BrandedNames.end(); i++)
        {
            if (i->second == dwIconIdTmp)
            {
#ifdef DBG
                if (bFound)
                {
                    AssertSz(FALSE, "Multiple icon IDs in branded table found");
                }
#endif
                bFound = TRUE;
                szBrandedFileName = i->first;
                break;
            }
        }

        if (!bFound)
        {
            AssertSz(FALSE, "Branded icon id not found in branded table");
            return E_FAIL;
        }

        hIcon = static_cast<HICON>(LoadImage(
            NULL,
            szBrandedFileName.c_str(),
            IMAGE_ICON,
            dwIconSize, dwIconSize,
            LR_LOADFROMFILE));
    }

    if (!hIcon)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    else
    {
        hr = HrMergeCharacteristicsIcons(dwIconSize, dwIconId, &hIcon);
        if (SUCCEEDED(hr))
        {
            hr = S_OK;
        }

    }
    
    TraceHr(ttidError, FAL, hr, FALSE, "CNetConfigIcons::HrGetBrandedIconFromIconId");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CNetConfigIcons::HrGetIconIDForPIDL
//
//  Purpose:    Get a unique icon number given a Connection Folder Entry
//
//  Arguments:
//      uFlags     [in]   The GIL_xxx shell flags
//      cfe        [in]   The connection folder entry
//      dwIcon     [out]  The ID of the icon
//      pfCanCache [out]  Whether we can cache the icon
//
//  Returns:
//      HRESULT
//
//  Author:     deonb    18 Feb 2001
//
//  Notes:
//
HRESULT CNetConfigIcons::HrGetIconIDForPIDL(IN UINT uFlags, IN const CConFoldEntry& cfe, OUT DWORD& dwIconId, OUT LPBOOL pfCanCache)
{
    TraceFileFunc(ttidIcons);

    CExceptionSafeLock EsLock(&csNetConfigIcons);

    HRESULT hr = S_OK;
    if (cfe.GetCharacteristics() & NCCF_BRANDED)
    {
        *pfCanCache = FALSE;
        hr = HrGetBrandedIconIDForPIDL(uFlags, cfe, dwIconId);
    }
    else
    {
#ifdef DBG
        if (FIsDebugFlagSet(dfidDontCacheShellIcons))
        {
            *pfCanCache = FALSE;
        }
        else
        {
            *pfCanCache = TRUE;
        }
#else
        *pfCanCache = TRUE;
#endif
        hr = HrGetInternalIconIDForPIDL(uFlags, cfe, dwIconId);
    }

    if (FAILED(hr))
    {
        return hr;
    }

    Assert( (dwIconId & ~MASK_CHARACTERISTICS) == dwIconId); // Make sure we did't overflow into the overlay

    if (!(GIL_FORSHORTCUT & uFlags))
    {
        DWORD dwOverlay = 0;
        if ( (cfe.GetCharacteristics() & NCCF_INCOMING_ONLY) &&
             (cfe.GetNetConMediaType() != NCM_NONE) ) // No overlay for "default" incoming connection
        {
            dwIconId |= ICO_CHAR_INCOMING;
        }

        if (cfe.GetCharacteristics() & NCCF_SHARED)
        {
            dwIconId |= ICO_CHAR_SHARED;
        }
    
        if (cfe.GetCharacteristics() & NCCF_FIREWALLED)
        {
            dwIconId |= ICO_CHAR_FIREWALLED;
        }

        if (cfe.GetCharacteristics() & NCCF_DEFAULT)
        {
            dwIconId |= ICO_CHAR_DEFAULT;
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CNetConfigIcons::HrGetIconFromIconId
//
//  Purpose:    Loads an icon given the icon ID (branded or internal)
//
//  Arguments:
//      dwIconSize [in]  Size of the icon required
//      dwIconId   [in]  Icon ID - from HrGetIconIDForPIDL
//      hIcon      [out] The icon that was loaded
//
//  Returns:
//
//  Author:     deonb    18 Feb 2001
//
//  Notes:
//
HRESULT CNetConfigIcons::HrGetIconFromIconId(IN DWORD dwIconSize, IN DWORD dwIconId, OUT HICON &hIcon)
{ 
    TraceFileFunc(ttidIcons);

    CExceptionSafeLock EsLock(&csNetConfigIcons);

    HRESULT hr = S_OK;
    switch (dwIconId & MASK_ICONMANAGER)
    {
        case ICO_MGR_CM:
            hr = HrGetBrandedIconFromIconId(dwIconSize, dwIconId, hIcon);
            break;

        case ICO_MGR_INTERNAL:
            hr = HrGetInternalIconFromIconId(dwIconSize, dwIconId, hIcon);
            break;

        case ICO_MGR_RESOURCEID:
            hr = HrGetResourceIconFromIconId(dwIconSize, dwIconId, hIcon);
            break;

        default:
            hr = E_INVALIDARG;
            AssertSz(FALSE, "Unknown Icon manager");
            break;
    }

    if (SUCCEEDED(hr))
    {
        DWORD dwOverlays = (dwIconId & MASK_CHARACTERISTICS); // get the mask bits
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CNetConfigIcons::HrGetIconFromIconId
//
//  Purpose:    Loads an icon given the icon ID (branded or internal)
//
//  Arguments:
//      dwIconSize        [in]  Size of the icon required
//      ncm               [in]  The NETCON_MEDIATYPE
//      ncsm              [in]  The NETCON_SUBMEDIATYPE
//      dwConnectionIcon  [in]  ENUM_CONNECTION_ICON (Not shifted (IOW: 0 or 4,5,6,7)
//      dwCharacteristics [in]  The NCCF_CHARACTERISTICS flag (0 allowed)
//      phIcon            [out] The resulting icon. Destroy using DestroyIcon
//
//  Returns:
//
//  Author:     deonb    23 Apr 2001
//
//  Notes:
//
HRESULT CNetConfigIcons::HrGetIconFromMediaType(IN DWORD dwIconSize, IN NETCON_MEDIATYPE ncm, IN NETCON_SUBMEDIATYPE ncsm, IN DWORD dwConnectionIcon, IN DWORD dwCharacteristics, OUT HICON *phIcon)
{
    HRESULT hr = S_OK;

    CConFoldEntry cfe;

    // Is this a request for a special folder icon?
    if ( (0xFFFFFFFF == dwCharacteristics)  &&
         (NCM_NONE == ncm) &&
         (NCSM_NONE == ncsm)
        )
    {
        BOOL bFoundIcon = FALSE;
        int iIcon = 0;

        switch (dwConnectionIcon)
        {
            case 0x80000000:
                iIcon = IDI_CONNECTIONS_FOLDER_LARGE2;
                bFoundIcon = TRUE;
                break;

            case 0x80000001:
                iIcon = IDI_CONFOLD_WIZARD;
                bFoundIcon = TRUE;
                break;

            case 0x80000002:
                iIcon = IDI_CONFOLD_HOMENET_WIZARD;
                bFoundIcon = TRUE;
                break;
        }

        if (bFoundIcon)
        {
            *phIcon = LoadIconSize(_Module.GetResourceInstance(), MAKEINTRESOURCE(iIcon), dwIconSize);
            if (*phIcon)
            {
                return S_OK;
            }
            else
            {
                return HrFromLastWin32Error();
            }
        }
    }

    // No? Then load a media type icon
    NETCON_STATUS ncs;
    if (ICO_CONN_BOTHOFF == dwConnectionIcon)
    {
        ncs = NCS_DISCONNECTED;
    }
    else
    {
        ncs = NCS_CONNECTED;
    }

    // Most of these values (except for ncm, ncsm, ncs) are totally fake. 
    // However, we need to initialize this structure with 
    // something or it will assert on us.
    //
    // HrGetIconIDForPidl will only use ncm, ncsm, ncs & dwCharacteristics
    hr = cfe.HrInitData(WIZARD_NOT_WIZARD,
                        ncm,
                        ncsm,
                        ncs,
                        &(CLSID_ConnectionCommonUi), // FAKE
                        &(CLSID_ConnectionCommonUi), // FAKE
                        dwCharacteristics,
                        reinterpret_cast<LPBYTE>("PersistData"), // FAKE
                        celems("PersistData"),      // FAKE
                        L"Name",                    // FAKE
                        L"DeviceName",              // FAKE
                        L"PhoneOrHostAddress");     // FAKE
    if (SUCCEEDED(hr))
    {
        DWORD dwIconId;
        BOOL  fCanCache;
        hr = HrGetIconIDForPIDL(0, cfe, dwIconId, &fCanCache);
        if (SUCCEEDED(hr))
        {
            dwIconId &= ~MASK_CONNECTION; // Clear the current connection mask
            dwIconId |= (dwConnectionIcon << SHIFT_CONNECTION); // Set the new connection mask

            hr = HrGetIconFromIconId(dwIconSize, dwIconId, *phIcon);
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CNetConfigIcons::HrUpdateSystemImageListForPIDL
//
//  Purpose:    Notifies the shell that we've changed an icon
//
//  Arguments:
//      cfe [in] The connection folder entry that changed
//
//  Returns:
//      HRESULT
//
//  Author:     deonb    18 Feb 2001
//
//  Notes:
//
HRESULT CNetConfigIcons::HrUpdateSystemImageListForPIDL(IN const CConFoldEntry& cfe)
{
    TraceFileFunc(ttidIcons);

    HRESULT hr = S_OK;
    DWORD dwIcon;
    BOOL  fCacheThisIcon;
    hr = g_pNetConfigIcons->HrGetIconIDForPIDL(0, cfe, dwIcon, &fCacheThisIcon);
    if (SUCCEEDED(hr))
    {
        ULONG  uFlags = GIL_PERINSTANCE | GIL_NOTFILENAME;
        if (!fCacheThisIcon)
        {
             uFlags |= GIL_DONTCACHE;
        }
        int    iIcon = static_cast<int>(dwIcon);
        int    iCachedImage = Shell_GetCachedImageIndex(c_szNetShellIcon, iIcon, uFlags);

        TraceTag(ttidIcons, "%S->SHUpdateImage [0x%08x] (iCachedImage=%d)", cfe.GetName(), dwIcon, iCachedImage);
        if (-1 != iCachedImage)
        {
            SHUpdateImage(c_szNetShellIcon, iIcon, uFlags, iCachedImage);
        }

        DWORD dwIconForShortcut;
        hr = g_pNetConfigIcons->HrGetIconIDForPIDL(GIL_FORSHORTCUT, cfe, dwIconForShortcut, &fCacheThisIcon);
        {
            if (dwIconForShortcut != dwIcon)
            {
                iIcon = static_cast<int>(dwIconForShortcut);
                iCachedImage = Shell_GetCachedImageIndex(c_szNetShellIcon, iIcon, uFlags);

                TraceTag(ttidIcons, "%S->SHUpdateImage GIL_FORSHORTCUT [0x%08x] (iCachedImage=%d)", cfe.GetName(), dwIcon, iCachedImage);
                if (-1 != iCachedImage)
                {
                    SHUpdateImage(c_szNetShellIcon, iIcon, uFlags, iCachedImage);
                }
            }
        }
    }
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\shell\folder\icomtargf.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       I C O M T A R G F . C P P
//
//  Contents:   ICommandTarget implementation for IConnectionFolder
//
//  Notes:
//
//  Author:     jeffspr   12 Mar 1998
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "foldinc.h"    // Standard shell\tray includes



const IID CGID_ConnectionsFolder =
{0xeaf70ce4,0xb521,0x11d1,{0xb5,0x50,0x00,0xc0,0x4f,0xd9,0x18,0xd0}};


//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolder::QueryStatus
//
//  Purpose:    [IOleCommandTarget] Queries the object for the status of one 
//              or more commands generated by user interface events.
//
//              This interface is required but is currently unimplemented
//
//  Arguments:  
//      pguidCmdGroup [in]      // Pointer to command group
//      cCmds         [in]      // Number of commands in prgCmds array
//      prgCmds       [in,out]  // Array of commands
//      pCmdText      [in,out]  // Pointer to name or status of command
//
//  Returns:    
//
//  Author:     jeffspr   12 Aug 1999
//
//  Notes:      
//
HRESULT CConnectionFolder::QueryStatus(
    IN     const GUID *    pguidCmdGroup,
    IN     ULONG           cCmds,
    IN OUT OLECMD          prgCmds[],
    IN OUT OLECMDTEXT *    pCmdText)
{
    TraceFileFunc(ttidShellFolderIface);

    HRESULT hr  = E_NOTIMPL;

    TraceHr(ttidError, FAL, hr, (hr == E_NOTIMPL), "CConnectionFolder::QueryStatus");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolder::Exec
//
//  Purpose:    [IOleCommandTarget] Executes a specified command or displays 
//              help for a command.
//  
//              This method is not currently referenced, but if the shell
//              wanted to enumerate only incoming our outgoing connections,
//              it would use the CFCID_SETENUMTYPE command to force the 
//              issue (that is unimplemented on our side, however)
//
//  Arguments:  
//      pguidCmdGroup [in]      // Pointer to command group
//      nCmdID        [in]      // Identifier of command to execute
//      nCmdexecopt   [in]      // Options for executing the command
//      pvaIn         [in]      // Pointer to input arguments
//      pvaOut        [in,out]  // Pointer to command output
//
//  Returns:    
//
//  Author:     jeffspr   12 Aug 1999
//
//  Notes:      
//
HRESULT CConnectionFolder::Exec(
    IN     const GUID *    pguidCmdGroup,
    IN     DWORD           nCmdID,
    IN     DWORD           nCmdexecopt,
    IN     VARIANTARG *    pvaIn,
    IN OUT VARIANTARG *    pvaOut)
{
    TraceFileFunc(ttidShellFolderIface);

    HRESULT hr  = NOERROR;

    if (!pguidCmdGroup)
    {
        return hr;
    }
    
    // Handle Shell pre-enumeration commands here.
    //
    if (IsEqualGUID(*pguidCmdGroup, CGID_ConnectionsFolder))
    {
        switch (nCmdID)
        {
            case CFCID_SETENUMTYPE:
                m_dwEnumerationType = nCmdexecopt;
                break;
            default:
                hr = S_OK;
                break;
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CConnectionFolder::Exec");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\shell\folder\ienumidl.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       I E N U M I D L . C P P
//
//  Contents:   IEnumIDList implementation for CConnectionFolderEnum
//
//  Notes:
//
//  Author:     jeffspr   22 Sep 1997
//
//----------------------------------------------------------------------------


#include "pch.h"
#pragma hdrstop

#include "foldinc.h"    // Standard shell\folder includes
#include "ncnetcon.h"
#include "webview.h"

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolderEnum::CConnectionFolderEnum
//
//  Purpose:    Constructor for the enumerator
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     jeffspr   18 Mar 1998
//
//  Notes:
//
CConnectionFolderEnum::CConnectionFolderEnum() throw()
{
    TraceFileFunc(ttidShellFolderIface);

    m_iterPidlCurrent = m_apidl.end();
    
    m_pidlFolder.Clear();
    m_dwFlags               = 0;
    m_fTray                 = FALSE;
    m_dwEnumerationType     = CFCOPT_ENUMALL;   // all connection types
}

//+---------------------------------------------------------------------------
//
//  Function:   CConnectionFolderEnum
//
//  Purpose:    Destructor for the enumerator. Standard cleanup.
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     jeffspr   18 Mar 1998
//
//  Notes:
//
CConnectionFolderEnum::~CConnectionFolderEnum() throw()
{
    TraceFileFunc(ttidShellFolderIface);

    m_pidlFolder.Clear();
}

//+---------------------------------------------------------------------------
//
//  Function:   CConnectionFolderEnum::PidlInitialize
//
//  Purpose:    Initialization for the enumerator object
//
//  Arguments:
//      fTray             [in]  Are we owned by the tray
//      pidlFolder        [in]  Pidl for the folder itself
//      dwEnumerationType [in]  Enumeration type (inbound/outbound/all)
//
//  Returns:
//
//  Author:     jeffspr   18 Mar 1998
//
//  Notes:
//
VOID CConnectionFolderEnum::PidlInitialize(
    IN  BOOL            fTray,
    OUT const PCONFOLDPIDLFOLDER& pidlFolder,
    OUT DWORD           dwEnumerationType)
{
    TraceFileFunc(ttidShellFolderIface);

    NETCFG_TRY

        m_fTray             = fTray;
        m_pidlFolder        = pidlFolder;
        m_dwEnumerationType = dwEnumerationType;
        
    NETCFG_CATCH_AND_RETHROW
}


//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolderEnum::CreateInstance
//
//  Purpose:    Create an instance of the CConnectionFolderEnum object, and
//              returns the requested interface
//
//  Arguments:
//      riid [in]   Interface requested
//      ppv  [out]  Pointer to receive the requested interface
//
//  Returns:    Standard OLE HRESULT
//
//  Author:     jeffspr   5 Nov 1997
//
//  Notes:
//
HRESULT CConnectionFolderEnum::CreateInstance(
    IN  REFIID  riid,
    OUT void**  ppv)
{
    TraceFileFunc(ttidShellFolderIface);

    HRESULT                 hr      = E_OUTOFMEMORY;
    CConnectionFolderEnum * pObj    = NULL;

    pObj = new CComObject <CConnectionFolderEnum>;
    if (pObj)
    {
        // Do the standard CComCreator::CreateInstance stuff.
        //
        pObj->SetVoid (NULL);
        pObj->InternalFinalConstructAddRef ();
        hr = pObj->FinalConstruct ();
        pObj->InternalFinalConstructRelease ();

        if (SUCCEEDED(hr))
        {
            hr = pObj->QueryInterface (riid, ppv);
        }

        if (FAILED(hr))
        {
            delete pObj;
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CConnectionFolderEnum::CreateInstance");
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolderEnum::Next
//
//  Purpose:    Retrieves the specified number of item identifiers in the
//              enumeration sequence and advances the current position
//              by the number of items retrieved.
//
//  Arguments:
//      celt         []     Max number requested
//      rgelt        []     Array to fill
//      pceltFetched []     Return count for # filled.
//
//  Returns:    S_OK if successful, S_FALSE if there are no more items
//              in the enumeration sequence, or an OLE-defined error value
//              otherwise.
//
//  Author:     jeffspr   5 Nov 1997
//
//  Notes:
//
STDMETHODIMP CConnectionFolderEnum::Next(
        IN  ULONG           celt,
        OUT LPITEMIDLIST *  rgelt,
        OUT ULONG *         pceltFetched)
{
    TraceFileFunc(ttidShellFolderIface);

    HRESULT hr  = S_OK;

    Assert(celt >= 1);
    Assert(rgelt);
    Assert(pceltFetched || (celt == 1));

    // If the caller asks for the fetch count, zero it out for now.
    //
    if (pceltFetched)
    {
        *pceltFetched   = 0;
    }

    // Init the output list pointer
    //
    *rgelt          = NULL;

    // If there's not currently a list, build one.
    //
    if (m_apidl.empty())
    {
        hr = Reset();

        // This will have returned either S_FALSE (no wizard? weird!), an
        // error (meaning creating the wizard failed), or S_OK, meaning
        // that (at least) the wizard creation succeeded. Enum of the connections
        // failing will get filtered by Reset().
    }

    if (SUCCEEDED(hr))
    {
        // If there are NOW items in the list
        //
        if (!m_apidl.empty() )
        {
            BOOL    fMatchFound = FALSE;

            // Check that we've set the current pointer to at least the root
            //
            // Normalize the return code
            hr = S_OK;

            while ((S_OK == hr) && !fMatchFound)
            {
                // If there are no remaining entries, return S_FALSE.
                //
                if ( m_iterPidlCurrent == m_apidl.end() )
                {
                    hr = S_FALSE;
                }
                else
                {
                    const PCONFOLDPIDL& pcfp = *m_iterPidlCurrent;

                    // Else, Return the first entry, then increment the current
                    // pointer
                    //
                    Assert(!pcfp.empty());

                    // Check to see if we want to return this type, based on
                    // the enumeration type & connection type. The wizard
                    // should always be included.
                    //
                    if ( WIZARD_NOT_WIZARD != pcfp->wizWizard )
                    {
                        if (HrIsWebViewEnabled() == S_OK)
                        {
                            m_iterPidlCurrent++; // skip over this item
                            continue;
                        }
                        else
                        {
                            fMatchFound = TRUE;
                        }
                    }
                    else
                    {
                        switch(m_dwEnumerationType)
                        {
                            case CFCOPT_ENUMALL:
                                fMatchFound = TRUE;
                                break;
                            case CFCOPT_ENUMINCOMING:
                                fMatchFound = (pcfp->dwCharacteristics & NCCF_INCOMING_ONLY);
                                break;
                            case CFCOPT_ENUMOUTGOING:
                                fMatchFound = !(pcfp->dwCharacteristics & NCCF_INCOMING_ONLY);
                                break;
                        }
                    }

                    // If we've found one that needn't be filtered out,
                    // then fill in the return param, etc.
                    //
                    if (fMatchFound)
                    {
                        // Copy the pidl for return
                        //
                        rgelt[0] = m_iterPidlCurrent->TearOffItemIdList();
                        if (!rgelt[0])
                        {
                            hr = E_OUTOFMEMORY;
                        }
                        else
                        {
                            // If they requested a return count, fill it in.
                            //
                            if (pceltFetched)
                            {
                                *pceltFetched = 1;
                            }

                            // ISSUE:
                            // IsValidPIDL is debug code. However, we're doing this in release mode until we
                            // find the bug from NTRAID#NTBUG9-125787-2000/07/26-deonb.
#ifdef DBG_VALIDATE_PIDLS
                            if (!IsValidPIDL(rgelt[0]))
                            {
                                return E_ABORT;
                            }
#endif
                        }
                    }

                    // Move the pointer to the next pidl in the list.
                    //
                    m_iterPidlCurrent++;
                }
            }
        }
        else
        {
            // There are no items in the list, return S_FALSE
            //
            hr = S_FALSE;
        }
    }
#ifdef DBG
    if (pceltFetched)
    {
        TraceTag(ttidShellFolderIface, "IEnumIDList::Next generated PIDL: 0x%08x", rgelt[0]);
    }
#endif

    TraceHr(ttidError, FAL, hr, (S_FALSE == hr), "CConnectionFolderEnum::Next");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolderEnum::Skip
//
//  Purpose:    Skips over the specified number of elements in the
//              enumeration sequence.
//
//  Arguments:
//      celt [in]   Number of item identifiers to skip.
//
//  Returns:    Returns S_OK if successful, or an OLE-defined error
//              value otherwise.
//
//  Author:     jeffspr   5 Nov 1997
//
//  Notes:
//
STDMETHODIMP CConnectionFolderEnum::Skip(
        IN  ULONG   celt)
{
    TraceFileFunc(ttidShellFolderIface);

    HRESULT hr  = S_OK;

    NYI("CConnectionFolderEnum::Skip");

    // Currently, do nothing
    //

    TraceHr(ttidError, FAL, hr, FALSE, "CConnectionFolderEnum::Skip");
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolderEnum::Reset
//
//  Purpose:    Returns to the beginning of the enumeration sequence. For us,
//              this means do all of the actual enumeration
//
//  Arguments:
//      (none)
//
//  Returns:    Returns S_OK if successful, or an OLE-defined error
//              value otherwise.
//
//  Author:     jeffspr   5 Nov 1997
//
//  Notes:
//
STDMETHODIMP CConnectionFolderEnum::Reset()
{
    TraceFileFunc(ttidShellFolderIface);

    HRESULT hr  = S_OK;

    // If there's already a list, free it and rebuild.
    //
    if (!m_apidl.empty())
    {
        m_apidl.clear();
        m_iterPidlCurrent = m_apidl.end();
    }

    hr = HrRetrieveConManEntries();
    if (SUCCEEDED(hr))
    {
        // Normalize the return code. HrRetrieveConManEntries... may have returned
        // S_FALSE, meaning that there we no connections (fine).
        //
        hr = S_OK;
        m_iterPidlCurrent = m_apidl.begin();
    }
    else
    {
        // Actually, we're still going to return noerror here after tracing the problem,
        // as we don't want to keep the enumerator from returning an error
        // if the wizard is present (no connections, but hey, better than nothing).
        //
        TraceHr(ttidError, FAL, hr, FALSE,
                "CConnectionsFolderEnum failed in call to HrRetrieveConManEntries");

        hr = S_FALSE;
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CConnectionFolderEnum::Reset");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolderEnum::Clone
//
//  Purpose:    Creates a new item enumeration object with the same contents
//              and state as the current one.
//
//  Arguments:
//      ppenum [out]    Return a clone of the current internal PIDL
//
//  Returns:    Returns S_OK if successful, or an OLE-defined error
//              value otherwise.
//
//  Author:     jeffspr   5 Nov 1997
//
//  Notes:
//
STDMETHODIMP CConnectionFolderEnum::Clone(
        OUT IEnumIDList **  ppenum)
{
    TraceFileFunc(ttidShellFolderIface);

    NYI("CConnectionFolderEnum::Clone");

    *ppenum = NULL;

    return E_NOTIMPL;
}


//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolderEnum::HrRetrieveConManEntries
//
//  Purpose:    Enumerate all connections from the ConnectionManagers, and
//              add them to our IDL.
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     jeffspr   8 Oct 1997
//
//  Notes:
//
HRESULT CConnectionFolderEnum::HrRetrieveConManEntries()
{
    TraceFileFunc(ttidShellFolderIface);
    
    HRESULT         hr          = S_OK;

    NETCFG_TRY

        PCONFOLDPIDLVEC apidlNew;

        hr = g_ccl.HrRetrieveConManEntries(apidlNew);
        if (SUCCEEDED(hr))
        {
            m_apidl.clear();
            m_apidl = apidlNew;
        }

        TraceHr(ttidError, FAL, hr, FALSE, "CConnectionFolder::HrRetrieveConManEntries");

    NETCFG_CATCH(hr)
        
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\shell\folder\iconhandler.h ===
// The icons ID passed to the shell contains the following format:
//
// B: Designates value is a bitmask
// M: Designates value is mutually exclusive
// 
// Icon Handler Flag (01 = NetConfig, 10 = Connection Manager, 11 = Static Icon from Resource)
//  |
//  | For Icon Handler == 00 (NetConfig)
//  | ==================================
//  |  Characteristics Overlay (B: Reserved)
//  |    |  Characteristics Overlay          (B: 000001000 - Shared)
//  |    |   | Characteristics Overlay       (B: 000000100 - Firewalled)
//  |    |   |  | Characteristics Overlay    (B: 000000010 - Default)
//  |    |   |  |  | Characteristics Overlay (B: 000000001 - Incoming)
//  |    |   |  |  |  |
//  |    |   |  |  |  |  Status Overlay (M: 0000 - None)
//  |    |   |  |  |  |  Status Overlay (M: 0001 - Hardware Not Present)
//  |    |   |  |  |  |  Status Overlay (M: 0010 - Invalid IP)
//  |    |   |  |  |  |  Status Overlay (M: 0011 - EAPOL Authentication Failed)
//  |    |   |  |  |  |  
//  |    |   |  |  |  |  Status Overlay (M: 1xxx - Disabled status)
//  |    |   |  |  |  |   |
//  |    |   |  |  |  |   |  Connection Icon (Flashy Computer) (M: 000 - No Overlay)
//  |    |   |  |  |  |   |  Connection Icon (Flashy Computer) (M: 100 - Both Lights Off)
//  |    |   |  |  |  |   |  Connection Icon (Flashy Computer) (M: 110 - Left Light On (Sent))
//  |    |   |  |  |  |   |  Connection Icon (Flashy Computer) (M: 101 - Right Light On (Received))
//  |    |   |  |  |  |   |  Connection Icon (Flashy Computer) (M: 111 - Both Lights On (Sent + Received))
//  |    |   |  |  |  |   |    |
//  |    |   |  |  |  |   |    |    Media Type (M: NETCON_MEDIATYPE (0x1111111 is Connection Manager)
//  |    |   |  |  |  |   |    |     |     Media Type (M: NETCON_SUBMEDIATYPE)
//  |    |   |  |  |  |   |    |     |      |
//  v    v   v  v  v  v   v    v     v      v
//  01 00000 0  0  0  0 0000  000 0000000 0000000
//  | 
//  |
//  | For Icon Handler == 01 (Connection Manager)
//  | ===========================================
//  |  Characteristics Overlay (B: Reserved)
//  |    |  Characteristics Overlay          (B: 000001000 - Shared)
//  |    |   | Characteristics Overlay       (B: 000000100 - Firewalled)
//  |    |   |  | Characteristics Overlay    (B: 000000010 - Default)
//  |    |   |  |  | Characteristics Overlay (B: 000000001 - Incoming)
//  |    |   |  |  |  |
//  |    |   |  |  |  |
//  |    |   |  |  |  |  Reserved
//  |    |   |  |  |  |   |
//  |    |   |  |  |  |   |    BrandedNames Lookup Table Entry
//  |    |   |  |  |  |   |         |
//  v    v   v  v  v  v   v         v (16 bits)
//  10 00000 0  0  0  0  00000  0000000000000000 
//  |
//  |
//  | For Icon Handler == 10 (10 = Static Icon from Resource)
//  | =======================================================
//  |  Characteristics Overlay (B: Reserved)
//  |    |  Characteristics Overlay          (B: 000001000 - Shared)
//  |    |   | Characteristics Overlay       (B: 000000100 - Firewalled)
//  |    |   |  | Characteristics Overlay    (B: 000000010 - Default)
//  |    |   |  |  | Characteristics Overlay (B: 000000001 - Incoming)
//  |    |   |  |  |  |
//  |    |   |  |  |  |
//  |    |   |  |  |  |  Reserved
//  |    |   |  |  |  |   |
//  |    |   |  |  |  |   |    Resource ID
//  |    |   |  |  |  |   |         |
//  v    v   v  v  v  v   v         v (16 bits)
//  11 00000 0  0  0  0  00000  0000000000000000 

enum ENUM_MEDIA_ICONMASK
{
    MASK_NETCON_SUBMEDIATYPE = 0x0000007f, // 00000000000000000000000001111111
    MASK_NETCON_MEDIATYPE    = 0x00003F80, // 00000000000000000011111110000000
    MASK_CONNECTION          = 0x0001C000, // 00000000000000011100000000000000
    MASK_STATUS              = 0x000E0000, // 00000000000011100000000000000000
    MASK_STATUS_DISABLED     = 0x00100000, // 00000000000100000000000000000000
    MASK_CHARACTERISTICS     = 0x3FE00000, // 00111111111000000000000000000000
    MASK_ICONMANAGER         = 0xC0000000, // 11000000000000000000000000000000
    
    
    MASK_BRANDORRESOURCEID   = 0x0000FFFF, // 00000000000000001111111111111111

    MASK_SUPPORT_ALL         = 0xFFFFFFFF,
    MASK_NO_CONNECTIONOVERLAY= MASK_NETCON_SUBMEDIATYPE | MASK_NETCON_MEDIATYPE | MASK_CHARACTERISTICS | MASK_ICONMANAGER,
    MASK_STATUSOVERLAY       = MASK_NETCON_SUBMEDIATYPE | MASK_NETCON_MEDIATYPE | MASK_CHARACTERISTICS | MASK_ICONMANAGER | MASK_STATUS | MASK_STATUS_DISABLED,
};

enum ENUM_MEDIA_ICONSHIFT
{
    SHIFT_NETCON_SUBMEDIATYPE = 0,
    SHIFT_NETCON_MEDIATYPE    = 7,
    SHIFT_CONNECTION          = 14,
    SHIFT_STATUS              = 17,
    SHIFT_CHARACTERISTICS     = 21,
    SHIFT_ICONMANAGER         = 30
};

enum ENUM_ICON_MANAGER
{
    ICO_MGR_INTERNAL      = 0x1 << SHIFT_ICONMANAGER,
    ICO_MGR_CM            = 0x2 << SHIFT_ICONMANAGER,
    ICO_MGR_RESOURCEID    = 0x3 << SHIFT_ICONMANAGER
};

enum ENUM_STAT_ICON
{
    ICO_STAT_NONE         = 0x0 << SHIFT_STATUS,
    ICO_STAT_FAULT        = 0x1 << SHIFT_STATUS,
    ICO_STAT_INVALID_IP   = 0x2 << SHIFT_STATUS,
    ICO_STAT_EAPOL_FAILED = 0x3 << SHIFT_STATUS,

    ICO_STAT_DISABLED     = 0x8 << SHIFT_STATUS // Flag
};

enum ENUM_CONNECTION_ICON
{
    ICO_CONN_NONE         = 0x0 << SHIFT_CONNECTION,
    ICO_CONN_BOTHOFF      = 0x4 << SHIFT_CONNECTION,
    ICO_CONN_RIGHTON      = 0x5 << SHIFT_CONNECTION,
    ICO_CONN_LEFTON       = 0x6 << SHIFT_CONNECTION,
    ICO_CONN_BOTHON       = 0x7 << SHIFT_CONNECTION,
};

enum ENUM_CHARACTERISTICS_ICON
{
    ICO_CHAR_INCOMING     = 0x1 << SHIFT_CHARACTERISTICS,
    ICO_CHAR_DEFAULT      = 0x2 << SHIFT_CHARACTERISTICS,
    ICO_CHAR_FIREWALLED   = 0x4 << SHIFT_CHARACTERISTICS,
    ICO_CHAR_SHARED       = 0x8 << SHIFT_CHARACTERISTICS
};

class CNetConfigIcons;

typedef map<tstring, DWORD> BrandedNames;
typedef map<DWORD, HIMAGELIST> IMAGELISTMAP;

// CNetConfigIcons
// The main icon manager for NetShell
class CNetConfigIcons
{
private:
    CRITICAL_SECTION csNetConfigIcons;
    
    BOOL m_bInitialized;

    IMAGELISTMAP m_ImageLists;
    HINSTANCE    m_hInstance;

    BrandedNames m_BrandedNames;
    DWORD        dwLastBrandedId;

    HRESULT HrMergeTwoIcons(IN DWORD dwIconSize, IN OUT HICON *phMergedIcon, IN HICON hIconToMergeWith);

    HRESULT HrMergeCharacteristicsIcons(IN DWORD dwIconSize, IN DWORD dwIconId, IN OUT HICON *phMergedIcon);

    HRESULT HrGetBrandedIconFromIconId(IN DWORD dwIconSize, IN DWORD dwIconId, OUT HICON &hIcon);  // Use destroyicon after
    HRESULT HrGetInternalIconFromIconId(IN DWORD dwIconSize, IN DWORD dwIconId, OUT HICON &hIcon); // Use destroyicon after
    HRESULT HrGetResourceIconFromIconId(IN DWORD dwIconSize, IN DWORD dwIconId, OUT HICON &hIcon); // Use destroyicon after

    HRESULT HrGetInternalIconIDForPIDL(IN UINT uFlags, IN const CConFoldEntry& cfe, OUT DWORD &dwIconId); // Use destroyicon after
    HRESULT HrGetBrandedIconIDForPIDL(IN UINT uFlags, IN const CConFoldEntry& cfe, OUT DWORD &dwIconId);  // Use destroyicon after

public:
	CNetConfigIcons(IN HINSTANCE hInstance) throw();
    virtual ~CNetConfigIcons() throw();

    // All external calls are thread safe.
    HRESULT HrGetIconIDForPIDL(IN UINT uFlags, IN const CConFoldEntry& cfe, OUT DWORD &dwIconId, OUT LPBOOL pfCanCache);
    HRESULT HrGetIconFromIconId(IN DWORD dwIconSize, IN DWORD dwIconId, OUT HICON &hIcon);  // Use destroyicon after

    HRESULT HrUpdateSystemImageListForPIDL(IN const CConFoldEntry& cfe);
    
    HRESULT HrGetIconFromMediaType(IN DWORD dwIconSize, IN NETCON_MEDIATYPE ncm, IN NETCON_SUBMEDIATYPE ncsm, IN DWORD dwConnectionIcon, IN DWORD dwCharacteristics, OUT HICON *phIcon);
};

extern CNetConfigIcons *g_pNetConfigIcons;
extern const WCHAR c_szNetShellIcon[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\shell\folder\ipersist.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       I P E R S I S T . C P P
//
//  Contents:   IPersist implementation fopr CConnectionFolder
//
//  Notes:
//
//  Author:     jeffspr   22 Sep 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "foldinc.h"    // Standard shell\folder includes




//+---------------------------------------------------------------------------
//
//  Member:     CJobFolder::GetClassID
//
//  Purpose:    IPersist::GetClassID implementation for CConnectionFolder
//
//  Arguments:
//      lpClassID []
//
//  Returns:
//
//  Author:     jeffspr   22 Sep 1997
//
//  Notes:
//
STDMETHODIMP
CConnectionFolder::GetClassID(
    OUT LPCLSID lpClassID)
{
    TraceFileFunc(ttidShellFolderIface);

    *lpClassID = CLSID_ConnectionFolder;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\shell\folder\iolewind.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       I O L E W I N D . C P P
//
//  Contents:   IOleWindow implementation for CConnectionFolder
//
//  Notes:
//
//  Author:     jeffspr   22 Sep 1997
//
//----------------------------------------------------------------------------


#include "pch.h"
#pragma hdrstop

#include "foldinc.h"    // Standard shell\folder includes




STDMETHODIMP CConnectionFolder::GetWindow(
        OUT HWND *  lphwnd)
{
    TraceFileFunc(ttidShellFolderIface);

    return E_NOTIMPL;
}

STDMETHODIMP CConnectionFolder::ContextSensitiveHelp(
        IN  BOOL    fEnterMode)
{
    TraceFileFunc(ttidShellFolderIface);

    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\shell\folder\iextract.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       I E X T R A C T . C P P
//
//  Contents:   IExtract implementation for CConnectionFolderExtractIcon
//
//  Notes:
//                             
//  Author:     jeffspr   7 Oct 1997
//
//----------------------------------------------------------------------------


#include "pch.h"
#pragma hdrstop

#include "foldinc.h"    // Standard shell\folder includes
#include <nsres.h>
#include "foldres.h"
#include "iconhandler.h"

static const WCHAR c_szNetShellIcon[] = L"netshellicon";

HRESULT CConnectionFolderExtractIcon::CreateInstance(
    IN  LPCITEMIDLIST apidl,
    IN  REFIID  riid,
    OUT void**  ppv)
{
    TraceFileFunc(ttidShellFolderIface);

    HRESULT hr = E_OUTOFMEMORY;

    CConnectionFolderExtractIcon * pObj    = NULL;

    pObj = new CComObject <CConnectionFolderExtractIcon>;
    if (pObj)
    {
        // Do the standard CComCreator::CreateInstance stuff.
        //
        pObj->SetVoid (NULL);
        pObj->InternalFinalConstructAddRef ();
        hr = pObj->FinalConstruct ();
        pObj->InternalFinalConstructRelease ();

        if (SUCCEEDED(hr))
        {
            PCONFOLDPIDL pcfp;
            hr = pcfp.InitializeFromItemIDList(apidl);
            if (SUCCEEDED(hr))
            {
                hr = pObj->HrInitialize(pcfp);
                if (SUCCEEDED(hr))
                {
                    hr = pObj->GetUnknown()->QueryInterface (riid, ppv);
                }
            }
        }

        if (FAILED(hr))
        {
            delete pObj;
        }
    }
    return hr;
}

CConnectionFolderExtractIcon::CConnectionFolderExtractIcon() throw()
{
    TraceFileFunc(ttidShellFolderIface);
}

CConnectionFolderExtractIcon::~CConnectionFolderExtractIcon() throw()
{
    TraceFileFunc(ttidShellFolderIface);
}

HRESULT CConnectionFolderExtractIcon::HrInitialize(
    IN const PCONFOLDPIDL& pidl)
{
    TraceFileFunc(ttidShellFolderIface);

    HRESULT         hr      = S_FALSE;
    ConnListEntry   cle;

    if (SUCCEEDED(hr))
    {
        hr = g_ccl.HrFindConnectionByGuid(&(pidl->guidId), cle);
    }

    if (hr == S_OK)
    {
        Assert(!cle.empty());
        Assert(!cle.ccfe.empty());

        hr = cle.ccfe.ConvertToPidl(m_pidl);
    }
    else
    {
        // Couldn't find the icon in the cache.. Good chance that it hasn't been loaded
        // yet. That being the case, go ahead and use the persisted pidl data to
        // load the icon
        //
        TraceTag(ttidShellFolderIface, "IExtractIcon - Couldn't find connection in the cache.");
        hr = m_pidl.ILClone(pidl);
    }

    TraceHr(ttidShellFolderIface, FAL, hr, FALSE, "CConnectionFolderExtractIcon::HrInitialize");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolderExtractIcon::GetIconLocation
//
//  Purpose:
//
//  Arguments:
//      uFlags     [in]     Address of a UINT value that receives zero or a
//                          combination of the following values:
//
//          GIL_ASYNC       The calling application supports asynchronous
//                          retrieval of icons.
//          GIL_FORSHELL    The icon is to be displayed in a shell folder.
//
//      wzIconFile [out]    Address of the buffer that receives the icon
//                          location. The icon location is a null-terminated
//                          string that identifies the file that contains
//                          the icon.
//      cchMax     [in]     Size of the buffer that receives the icon location.
//      piIndex    [out]    Address of an INT that receives the icon index,
//                          which further describes the icon location.
//      pwFlags    [out]    Address of a UINT value that receives zero or a
//                          combination of the following values:
//
//          GIL_DONTCACHE   Don't cache the physical bits.
//          GIL_NOTFILENAME This isn't a filename/index pair. Call
//                          IExtractIcon::Extract instead
//          GIL_PERCLASS    (Only internal to the shell)
//          GIL_PERINSTANCE Each object of this class has the same icon.
//          GIL_FORSHORTCUT The icon is to be used for a shortcut.
//
//
//  Returns:    S_OK if the function returned a valid location,
//              or S_FALSE if the shell should use a default icon.
//
//  Author:     jeffspr   25 Nov 1998
//
//  Notes:
//
STDMETHODIMP CConnectionFolderExtractIcon::GetIconLocation(
    IN  UINT    uFlags,
    OUT PWSTR   szIconFile,
    IN  UINT    cchMax,
    OUT int *   piIndex,
    OUT UINT *  pwFlags)
{
    TraceFileFunc(ttidShellFolderIface);

    HRESULT hr  = S_FALSE;

    Assert(pwFlags);
    Assert(szIconFile);
    Assert(piIndex);

#ifdef DBG
    // Easy way to check if certain flags are set
    //
    BOOL    fAsync      = (uFlags & GIL_ASYNC);
    BOOL    fForShell   = (uFlags & GIL_FORSHELL);
    BOOL    fOpenIcon   = (uFlags & GIL_OPENICON);
    DWORD   dwOldpwFlags = *pwFlags;
#endif

    BOOL            fIsWizard       = FALSE;

    const PCONFOLDPIDL& pcfp = m_pidl;

    Assert(!pcfp.empty());
    if (!pcfp.empty())
    {
        BOOL  fCacheThisIcon  = TRUE;

        CConFoldEntry cfe;
        hr = pcfp.ConvertToConFoldEntry(cfe);
        if (SUCCEEDED(hr))
        {
            DWORD dwIcon;
            hr = g_pNetConfigIcons->HrGetIconIDForPIDL(uFlags, cfe, dwIcon, &fCacheThisIcon);
            if (SUCCEEDED(hr))
            {
                *piIndex = static_cast<int>(dwIcon);
                wcsncpy(szIconFile, c_szNetShellIcon, cchMax);
                *pwFlags = GIL_PERINSTANCE  | GIL_NOTFILENAME; 

                if (!fCacheThisIcon)
                {
                    *pwFlags |= GIL_DONTCACHE;
                }
            }
        }
    }

#ifdef DBG
    TraceTag(ttidIcons, "%S->GetIconLocation(0x%04x/0x%04x,%S,0x%08x,0x%08x)", pcfp->PszGetNamePointer(), uFlags, dwOldpwFlags, szIconFile, *piIndex, *pwFlags);
#endif
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolderExtractIcon::GetIconLocation
//
//  Purpose:    ANSI wrapper for the above UNICODE GetIconLocation
//
//  Arguments:
//      uFlags     []   See above
//      szIconFile []   See above
//      cchMax     []   See above
//      piIndex    []   See above
//      pwFlags    []   See above
//
//  Returns:
//
//  Author:     jeffspr   6 Apr 1999
//
//  Notes:
//
STDMETHODIMP CConnectionFolderExtractIcon::GetIconLocation(
    IN  UINT    uFlags,
    OUT PSTR    szIconFile,
    IN  UINT    cchMax,
    OUT int *   piIndex,
    OUT UINT *  pwFlags)
{
    TraceFileFunc(ttidShellFolderIface);

    HRESULT hr  = S_OK;
    
    WCHAR * pszIconFileW = new WCHAR[cchMax];
    if (!pszIconFileW)
    {
        hr = ERROR_OUTOFMEMORY;
    }
    else
    {
        hr = GetIconLocation(uFlags, pszIconFileW, cchMax, piIndex, pwFlags);
        if (SUCCEEDED(hr))
        {
            WideCharToMultiByte(CP_ACP, 0, pszIconFileW, -1, szIconFile, cchMax, NULL, NULL);
        }

        delete [] pszIconFileW;
    }

    TraceHr(ttidShellFolder, FAL, hr, FALSE, "CConnectionFolderExtractIcon::GetIconLocation(A)");
    return hr;

}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolderExtractIcon::Extract
//
//  Purpose:    Grab the actual icon for the caller.
//
//  Arguments:
//      wzFile      []  Filename from where we'll retrieve the icon
//      nIconIndex  []  Index of the icon (though this is bogus)
//      phiconLarge []  Return pointer for the large icon handle
//      phiconSmall []  Return pointer for the small icon handle
//      nIconSize   []  Size of the icon requested.
//
//  Returns:
//
//  Author:     jeffspr   9 Oct 1997
// 
//  Notes:
//
STDMETHODIMP CConnectionFolderExtractIcon::Extract(
    IN  PCWSTR  wzFile,
    IN  UINT    nIconIndex,
    OUT HICON * phiconLarge,
    OUT HICON * phiconSmall,
    IN  UINT    nIconSize)
{
    TraceFileFunc(ttidShellFolderIface);

    HRESULT         hr              = S_OK;
    ConnListEntry   cle;

    Assert(wzFile);

    if (wcscmp(wzFile, c_szNetShellIcon))
    {
        TraceHr(ttidError, FAL, E_INVALIDARG, FALSE, "This is not my icon.");
        return E_INVALIDARG;
    }

    Assert(!m_pidl.empty());

    DWORD dwIconSmallSize = HIWORD(nIconSize);
    if (dwIconSmallSize && phiconSmall)
    {
        hr = g_pNetConfigIcons->HrGetIconFromIconId(dwIconSmallSize, nIconIndex, *phiconSmall);
        if (FAILED(hr))
        {
            if (phiconLarge)
            {
                *phiconLarge = NULL;
            }
            *phiconSmall = NULL;
        }
    }

    DWORD dwIconLargeSize = LOWORD(nIconSize);
    if (dwIconLargeSize && phiconLarge && SUCCEEDED(hr))
    {
        hr = g_pNetConfigIcons->HrGetIconFromIconId(dwIconLargeSize, nIconIndex, *phiconLarge);
        if (FAILED(hr))
        {
            if (phiconSmall && *phiconSmall)
            {
                DestroyIcon(*phiconSmall);
                *phiconSmall = NULL;
            }
            *phiconLarge = NULL;
        }
    }

    TraceTag(ttidIcons, "%S,0x%08x->Extract(%d %d)", wzFile, nIconIndex, dwIconLargeSize, dwIconSmallSize);

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolderExtractIcon::Extract
//
//  Purpose:    ANSI version of the above Extract
//
//  Arguments:
//      pszFile     [] Filename from where we'll retrieve the icon
//      nIconIndex  [] Index of the icon (though this is bogus)
//      phiconLarge [] Return pointer for the large icon handle
//      phiconSmall [] Return pointer for the small icon handle
//      nIconSize   [] Size of the icon requested.
//
//  Returns:
//
//  Author:     jeffspr   6 Apr 1999
//
//  Notes:
//
STDMETHODIMP CConnectionFolderExtractIcon::Extract(
    IN  PCSTR   pszFile,
    IN  UINT    nIconIndex,
    OUT HICON * phiconLarge,
    OUT HICON * phiconSmall,
    IN  UINT    nIconSize)
{
    TraceFileFunc(ttidShellFolderIface);

    HRESULT hr          = S_OK;
    INT     cch         = 0;
    WCHAR * pszFileW    = NULL;

    Assert(pszFile);

    cch = lstrlenA(pszFile) + 1;
    pszFileW = new WCHAR[cch];

    if (!pszFileW)
    {
        hr = ERROR_OUTOFMEMORY;
    }
    else
    {
        MultiByteToWideChar(CP_ACP, 0, pszFile, -1, pszFileW, cch);

        hr = Extract(pszFileW, nIconIndex, phiconLarge, phiconSmall, nIconSize);

        delete [] pszFileW;
    }

    TraceHr(ttidShellFolder, FAL, hr, FALSE, "CConnectionFolderExtractIcon::Extract(A)");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\shell\folder\ipersistf.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       I P E R S I S T F . C P P
//
//  Contents:   IPersistFolder implementation for CConnectionFolder
//
//  Notes:
//
//  Author:     jeffspr   22 Sep 1997
//
//----------------------------------------------------------------------------


#include "pch.h"
#pragma hdrstop

#include "foldinc.h"    // Standard shell\folder includes
#include "ncperms.h"    // Permissions (policies)




//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolder::Initialize
//
//  Purpose:    IPersistFolder::Initialize implementation for
//              CConnectionFolder
//
//  Arguments:
//      pidl []
//
//  Returns:
//
//  Author:     jeffspr   22 Sep 1997
//
//  Notes:
//
STDMETHODIMP CConnectionFolder::Initialize(
    IN  LPCITEMIDLIST   pidl)
{
    HRESULT hr  = S_OK;

    TraceFileFunc(ttidShellFolderIface);

    // Store the pidl for the relative position in the namespace. We'll
    // use this later to generate absolute pidls
    //
    hr = m_pidlFolderRoot.InitializeFromItemIDList(pidl);

    // This should always be valid
    //
    AssertSz(!m_pidlFolderRoot.empty(), "Hey, we should have a valid folder pidl");
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\shell\folder\icontextm.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       I C O N T E X T M . C P P
//
//  Contents:   IContextMenu implementation for CConnectionFolderExtractIcon
//
//  Notes:
//
//  Author:     jeffspr   24 Oct 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "foldinc.h"    // Standard shell\folder includes
#include <nsres.h>
#include "foldres.h"
#include "oncommand.h"
#include "cmdtable.h"
#include "cfutils.h"

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolderContextMenu::CreateInstance
//
//  Purpose:    Create an instance of the CConnectionFolderContextMenu object
//
//  Arguments:
//      riid [in]   Interface requested
//      ppv  [out]  Pointer to receive the requested interface
//
//  Returns:
//
//  Author:     jeffspr   7 Aug 1998
//
//  Notes:
//
HRESULT CConnectionFolderContextMenu::CreateInstance(
    IN  REFIID          riid,
    OUT void**          ppv,
    IN  CMENU_TYPE      cmt,
    IN  HWND            hwndOwner,
    IN  const PCONFOLDPIDLVEC& apidl,
    IN  LPSHELLFOLDER   psf)
{
    TraceFileFunc(ttidShellFolderIface);

    HRESULT hr = E_OUTOFMEMORY;

    CConnectionFolderContextMenu * pObj    = NULL;

    pObj = new CComObject <CConnectionFolderContextMenu>;
    if (pObj)
    {
        // Do the standard CComCreator::CreateInstance stuff.
        //
        pObj->SetVoid (NULL);
        pObj->InternalFinalConstructAddRef ();
        hr = pObj->FinalConstruct ();
        pObj->InternalFinalConstructRelease ();

        if (SUCCEEDED(hr))
        {
            hr = pObj->HrInitialize(cmt, hwndOwner, apidl, psf);
            if (SUCCEEDED(hr))
            {
                hr = pObj->QueryInterface (riid, ppv);
            }
        }

        if (FAILED(hr))
        {
            delete pObj;
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CConnectionFolderContextMenu::CreateInstance");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolderContextMenu::CConnectionFolderContextMenu
//
//  Purpose:    Constructor for CConnectionFolderContextMenu. Initialize
//              data members
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     jeffspr   7 Aug 1998
//
//  Notes:
//
CConnectionFolderContextMenu::CConnectionFolderContextMenu() throw()
{
    TraceFileFunc(ttidShellFolderIface);

    m_psf           = NULL;
    m_cidl          = 0;
    m_hwndOwner     = NULL;
    m_cmt           = CMT_OBJECT;   // arbitrary. Just make sure it's something
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolderContextMenu::HrInitialize
//
//  Purpose:    Initialization for the context menu object. Make copies of
//              the pidl array, etc.
//
//  Arguments:
//      hwndOwner [in]  Our parent hwnd
//      apidl     [in]  Pidl array of selected items
//      psf       [in]  Our shell folder pointer
//
//  Returns:
//
//  Author:     jeffspr   7 Aug 1998
//
//  Notes:
//
HRESULT CConnectionFolderContextMenu::HrInitialize(
    IN  CMENU_TYPE      cmt,
    IN  HWND            hwndOwner,
    IN  const PCONFOLDPIDLVEC& apidl,
    IN  LPSHELLFOLDER   psf)
{
    TraceFileFunc(ttidShellFolderIface);

    HRESULT hr  = NOERROR;

    // Grab and addref the folder object
    //
    Assert(psf);
    psf->AddRef();
    m_psf = static_cast<CConnectionFolder *>(psf);

    // Copy the context menu type (object -vs- background)
    //
    m_cmt = cmt;

    // Note: This will be NULL if the context menu is invoked from the desktop
    //
    m_hwndOwner = hwndOwner;

    if (!apidl.empty())
    {
        Assert(CMT_OBJECT == cmt);

        // Clone the pidl array using the cache
        //
        hr = HrCloneRgIDL(apidl, TRUE, TRUE, m_apidl);
        if (FAILED(hr))
        {
            TraceHr(ttidError, FAL, hr, FALSE, "HrCloneRgIDL failed on apidl in "
                    "CConnectionFolderContextMenu::HrInitialize");
        }
    }
    else
    {
        Assert(CMT_BACKGROUND == cmt);
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CConnectionFolderContextMenu::HrInitialize");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolderContextMenu::~CConnectionFolderContextMenu
//
//  Purpose:    Destructor. Free the pidl array and release the shell folder
//              object
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     jeffspr   7 Aug 1998
//
//  Notes:
//
CConnectionFolderContextMenu::~CConnectionFolderContextMenu() throw()
{
    TraceFileFunc(ttidShellFolderIface);

    if (m_psf)
    {
        ReleaseObj(reinterpret_cast<LPSHELLFOLDER>(m_psf));
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolderContextMenu::QueryContextMenu
//
//  Purpose:    Adds menu items to the specified menu. The menu items should
//              be inserted in the menu at the position specified by
//              indexMenu, and their menu item identifiers must be between
//              the idCmdFirst and idCmdLast parameter values.
//
//  Arguments:
//      hmenu      [in] Handle to the menu. The handler should specify this
//                      handle when adding menu items
//      indexMenu  [in] Zero-based position at which to insert the first
//                      menu item.
//      idCmdFirst [in] Min value the handler can specify for a menu item
//      idCmdLast  [in] Max value the handler can specify for a menu item
//      uFlags     [in] Optional flags specifying how the context menu
//                      can be changed. See MSDN for the full list.
//
//  Returns:
//
//  Author:     jeffspr   7 Aug 1998
//
//  Notes:
//
HRESULT CConnectionFolderContextMenu::QueryContextMenu(
    IN OUT HMENU   hmenu,
    IN     UINT    indexMenu,
    IN     UINT    idCmdFirst,
    IN     UINT    idCmdLast,
    IN     UINT    uFlags)
{
    TraceFileFunc(ttidShellFolderIface);

    HRESULT         hr                  = S_OK;
    BOOL            fVerbsOnly          = !!(uFlags & CMF_VERBSONLY);

    if (CMF_DEFAULTONLY == uFlags)
    {
        if ( (IsMediaRASType(m_apidl[0]->ncm)) && 
            FIsUserGuest() )
        {
            (void) NcMsgBox(
                _Module.GetResourceInstance(),
                NULL,
                IDS_CONFOLD_WARNING_CAPTION,
                IDS_CONFOLD_CONNECT_NOACCESS,
                MB_OK | MB_ICONEXCLAMATION);
            
            return E_FAIL;
        }
    }

    if ( (m_apidl.size() != 0) && !(uFlags & CMF_DVFILE))
    {
        HMENU hMenuTmp = NULL;

        hMenuTmp = CreateMenu();
        if (hMenuTmp)
        {
            hr = HrBuildMenu(hMenuTmp, fVerbsOnly, m_apidl, 0);
            
            if (SUCCEEDED(hr))
            {
                UINT idMax = Shell_MergeMenus(
                    hmenu,
                    hMenuTmp,
                    0,
                    idCmdFirst,
                    idCmdLast,
                    MM_ADDSEPARATOR | MM_SUBMENUSHAVEIDS);
                
                hr = ResultFromShort(idMax - idCmdFirst);
            }
            DestroyMenu(hMenuTmp);
        }
    }
    else
    {
        // mbend - we skip this because defview does file menu merging.
    }

    // Ignore this trace if it's a short, basically.
    //
    TraceHr(ttidError, FAL, hr, SUCCEEDED(hr), "CConnectionFolderContextMenu::QueryContextMenu");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolderContextMenu::InvokeCommand
//
//  Purpose:    Carries out the command associated with a context menu item.
//
//  Arguments:
//      lpici [in]  Address of a CMINVOKECOMMANDINFO structure containing
//                  information about the command.
//
//  Returns:        Returns NOERROR if successful, or an OLE-defined
//                  error code otherwise.
//
//  Author:     jeffspr   27 Apr 1999
//
//  Notes:
//
HRESULT CConnectionFolderContextMenu::InvokeCommand(
    IN  LPCMINVOKECOMMANDINFO lpici)
{
    TraceFileFunc(ttidShellFolderIface);

    HRESULT             hr      = NOERROR;
    UINT                uiCmd   = 0;

    Assert(lpici);
    Assert(lpici->lpVerb);

    if (HIWORD(lpici->lpVerb))
    {
        // Deal with string commands
        PSTR pszCmd = (PSTR)lpici->lpVerb;

        // Only folder objects currently support string-based invoke commands.
        // (The background does not)
        //
        if (CMT_OBJECT == m_cmt)
        {
            if (0 == lstrcmpA(pszCmd, "delete"))
            {
                uiCmd = CMIDM_DELETE;
            }
            else if (0 == lstrcmpA(pszCmd, "properties"))
            {
                uiCmd = CMIDM_PROPERTIES;
            }
            else if (0 == lstrcmpA(pszCmd, "wzcproperties"))
            {
                uiCmd = CMIDM_WZCPROPERTIES;
            }
            else if (0 == lstrcmpA(pszCmd, "rename"))
            {
                uiCmd = CMIDM_RENAME;
            }
            else if (0 == lstrcmpA(pszCmd, "link"))
            {
                uiCmd = CMIDM_CREATE_SHORTCUT;
            }
        }

        if (0 == uiCmd)
        {
            TraceTag(ttidError, "Unprocessed InvokeCommand<%s>\n", pszCmd);
            hr = E_INVALIDARG;
        }
    }
    else
    {
        uiCmd = (UINT)LOWORD((DWORD_PTR)lpici->lpVerb);
    }

    if (SUCCEEDED(hr))
    {
        // Handle the actual command
        //
        hr = HrFolderCommandHandler(uiCmd, m_apidl, m_hwndOwner, lpici, m_psf);
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CConnectionFolderContextMenu::InvokeCommand");
    return hr;
}

HRESULT CConnectionFolderContextMenu::GetCommandString(
    IN  UINT_PTR    idCmd,
    IN  UINT        uType,
    OUT UINT *      pwReserved,
    OUT PSTR        pszName,
    IN  UINT        cchMax)
{
    TraceFileFunc(ttidShellFolderIface);

    HRESULT hr  = E_FAIL;   // Not handled

    *((PWSTR)pszName) = L'\0';

    if (uType == GCS_HELPTEXT)
    {
        int iLength = LoadString(   _Module.GetResourceInstance(),
                                    (UINT)(idCmd + IDS_CMIDM_START),
                                    (PWSTR) pszName,
                                    cchMax);
        if (iLength > 0)
        {
            hr = NOERROR;
        }
        else
        {
            AssertSz(FALSE, "Resource string not found for one of the connections folder commands");
        }
    }
    else
    {
        if (uType == GCS_VERB && idCmd == CMIDM_RENAME)
        {
            // "rename" is language independent
            lstrcpyW((PWSTR)pszName, L"rename");

            hr = NOERROR;
        }
    }

    TraceHr(ttidError, FAL, hr, (hr == E_FAIL), "CConnectionFolderContextMenu::GetCommandString");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\shell\folder\iqinfo.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       I Q I N F O . C P P
//
//  Contents:   IQueryInfo implementation for CConnectionFolderQueryInfo
//
//  Notes:
//
//  Author:     jeffspr   16 Oct 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "foldinc.h"    // Standard shell\folder includes
#include <nsres.h>
#include "shutil.h"



HRESULT CConnectionFolderQueryInfo::CreateInstance(
    IN  REFIID  riid,
    OUT void**  ppv)
{
    TraceFileFunc(ttidShellFolderIface);

    HRESULT hr = E_OUTOFMEMORY;

    CConnectionFolderQueryInfo * pObj    = NULL;

    pObj = new CComObject <CConnectionFolderQueryInfo>;
    if (pObj)
    {
        // Do the standard CComCreator::CreateInstance stuff.
        //
        pObj->SetVoid (NULL);
        pObj->InternalFinalConstructAddRef ();
        hr = pObj->FinalConstruct ();
        pObj->InternalFinalConstructRelease ();

        if (SUCCEEDED(hr))
        {
            hr = pObj->QueryInterface (riid, ppv);
        }

        if (FAILED(hr))
        {
            delete pObj;
        }
    }
    return hr;
}

CConnectionFolderQueryInfo::CConnectionFolderQueryInfo() throw()
{
    m_pidl.Clear();
}

CConnectionFolderQueryInfo::~CConnectionFolderQueryInfo() throw()
{
}

HRESULT CConnectionFolderQueryInfo::GetInfoTip(
    IN  DWORD dwFlags,
    OUT WCHAR **ppwszTip)
{
    TraceFileFunc(ttidShellFolderIface);

    HRESULT         hr      = NOERROR;

    if(m_pidl.empty())
    {
        hr = E_FAIL;
    }
    else
    {
        if (*m_pidl->PszGetDeviceNamePointer())
        {
            hr = HrDupeShellString(m_pidl->PszGetDeviceNamePointer(), ppwszTip);
        }
        else
        {
            hr = HrDupeShellString(m_pidl->PszGetNamePointer(), ppwszTip);
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CConnectionFolderQueryInfo::GetInfoTip");
    return hr;
}

HRESULT CConnectionFolderQueryInfo::GetInfoFlags(
    OUT DWORD *pdwFlags)
{
    TraceFileFunc(ttidShellFolderIface);

    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\shell\folder\ipersistf2.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       I P E R S I S T F 2 . C P P
//
//  Contents:   IPersistFolder2 interface for CConnectionFolder
//
//  Notes:
//
//  Author:     jeffspr   16 Mar 1998
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "foldinc.h"    // Standard shell\folder includes



//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolder::GetCurFolder
//
//  Purpose:    Return a copy of the item id list for the current folder.
//
//  Arguments:
//      ppidl [out] Return pointer for the pidl
//
//  Returns:
//
//  Author:     jeffspr   16 Mar 1998
//
//  Notes:
//
STDMETHODIMP CConnectionFolder::GetCurFolder(
    OUT LPITEMIDLIST *ppidl)
{
    TraceFileFunc(ttidShellFolder);

    HRESULT hr  = NOERROR;

    *ppidl = m_pidlFolderRoot.TearOffItemIdList();

    if (NULL == *ppidl)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    // NOTE: if this is being invoked remotely, we assume that IRemoteComputer
    // is invoked *before* IPersistFolder2.

Exit:
    TraceHr(ttidShellFolder, FAL, hr, FALSE, "CConnectionFolder::GetCurFolder");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\shell\folder\legacymenus.h ===
#pragma once

#ifdef DBG

struct CommandTableEntry
{
    int     iCommandId;         // Associated command ID
    bool    fValidOnZero;       // Is this option valid when 0 items selected?
    bool    fValidOnWizardOnly; // Is this option valid when only wizard selected?
    bool    fValidOnMultiple;   // Is this option valid with > 1 selected?
    bool    fCurrentlyValid;    // Is this option currently valid in the menu?
    bool    fNewState;          // What's the new state? (work variable)
};

typedef CommandTableEntry   COMMANDTABLEENTRY;
typedef CommandTableEntry * PCOMMANDTABLEENTRY;

extern COMMANDTABLEENTRY    g_cteFolderCommands[];
extern const DWORD          g_nFolderCommandCount;

struct CommandCheckEntry
{
    int  iCommandId;        // Associated command ID
    bool fCurrentlyChecked; // Is this menu item already checked? 
    bool fNewCheckState;    // What's the new check state?        
};

typedef CommandCheckEntry   COMMANDCHECKENTRY;
typedef CommandCheckEntry * PCOMMANDCHECKENTRY;

extern COMMANDCHECKENTRY    g_cceFolderCommands[];
extern const DWORD          g_nFolderCommandCheckCount;

HRESULT HrBuildMenuOldWay(IN OUT HMENU hmenu, IN PCONFOLDPIDLVEC& cfpl, IN HWND hwndOwner, IN CMENU_TYPE cmt, IN UINT indexMenu, IN DWORD idCmdFirst, IN UINT idCmdLast, IN BOOL fVerbsOnly);
HRESULT HrAssertIntegrityAgainstOldMatrix();
HRESULT HrAssertAllLegacyMenusAgainstNew(HWND hwndOwner);
void TraceMenu(HMENU hMenu);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\shell\folder\ishellv.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       I S H E L L V . C P P
//
//  Contents:   IShellView implementation for CConnectionFolder
//
//  Notes:      The IShellView interface is implemented to present a view
//              in the Windows Explorer or folder windows. The object that
//              exposes IShellView is created by a call to the
//              IShellFolder::CreateViewObject method. This provides the
//              channel of communication between a view object and the
//              Explorer's outermost frame window. The communication
//              involves the translation of messages, the state of the frame
//              window (activated or deactivated), and the state of the
//              document window (Activated or deactivated), and the merging
//              of menus and toolbar items. This object is created by the
//              IShellFolder object that hosts the view.
//
//  Author:     jeffspr   22 Sep 1997
//
//----------------------------------------------------------------------------
#include "pch.h"
#pragma hdrstop

#include "foldinc.h"    // Standard shell\folder includes
#include "foldres.h"    // Folder resource IDs
#include "nsres.h"      // Netshell strings
#include "oncommand.h"  // Command handlers
#include "cmdtable.h"   // Table of command properties
#include <ras.h>        // for RAS_MaxEntryName
#include "webview.h"

//---[ Compile flags ]--------------------------------------------------------

#define NEW_CONNECTION_IN_TOOLBAR       0
#define ANY_FREEKIN_THING_IN_TOOLBAR    0   // have any toolbar buttons?

//---[ Constants ]------------------------------------------------------------

#if ANY_FREEKIN_THING_IN_TOOLBAR
const TBBUTTON c_tbConnections[] = {
#if NEW_CONNECTION_IN_TOOLBAR
    { 0,    CMIDM_NEW_CONNECTION,   TBSTATE_ENABLED, TBSTYLE_BUTTON, {0,0}, 0L, IDS_TOOLBAR_MAKE_NEW_STRING },
#endif
    { 1,    CMIDM_CONNECT,          TBSTATE_ENABLED, TBSTYLE_BUTTON, {0,0}, 0L, IDS_TOOLBAR_CONNECT_STRING },
    { 0,    0,                      TBSTATE_ENABLED, TBSTYLE_SEP   , {0,0}, 0L, -1 },
    };

const DWORD c_nToolbarButtons = celems(c_tbConnections);
#else
const DWORD c_nToolbarButtons = 0;
#endif

//---[ Prototypes ]-----------------------------------------------------------

HRESULT HrOnFolderRefresh(
    IN  HWND            hwndOwner,
    IN  LPARAM          lParam,
    IN  WPARAM          wParam);

HRESULT HrOnFolderGetButtonInfo(
    IN OUT TBINFO *    ptbilParam);

HRESULT HrOnFolderGetButtons(
    IN     HWND            hwnd,
    IN     LPSHELLFOLDER   psf,
    IN     UINT            idCmdFirst,
    IN OUT LPTBBUTTON      ptButton);

HRESULT HrOnFolderInitMenuPopup(
    IN  HWND    hwnd,
    IN  UINT    idCmdFirst,
    IN  INT     iIndex,
    IN  HMENU   hmenu);

HRESULT HrOnFolderMergeMenu(
    IN OUT LPQCMINFO   pqcm);

HRESULT HrOnFolderInvokeCommand(
    IN  HWND            hwndOwner,
    IN  WPARAM          wParam,
    IN  LPSHELLFOLDER   psf);

HRESULT HrCheckFolderInvokeCommand(
    IN  HWND            hwndOwner,
    IN  WPARAM          wParam,
    IN  LPARAM          lParam,
    IN  BOOL            bLevel,
    IN  LPSHELLFOLDER   psf);

HRESULT HrOnFolderGetNotify(
    IN  HWND            hwndOwner,
    IN  LPSHELLFOLDER   psf,
    IN  WPARAM          wParam,
    IN  LPARAM          lParam);

HRESULT HrOnGetHelpTopic(
    OUT SFVM_HELPTOPIC_DATA * phtd);

HRESULT HrOnGetCchMax(
    IN  HWND            hwnd,
    IN  const PCONFOLDPIDL& pidl,
    OUT INT *           pcchMax);

HRESULT HrOnGetHelpText(
    IN  UINT idCmd, 
    IN  UINT cchMax, 
    OUT LPWSTR pszName);

VOID TraceUnhandledMessages(
    IN  UINT    uMsg,
    IN  LPARAM  lParam,
    IN  WPARAM  wParam);

//---[ Column struct and global array ]---------------------------------------

COLS c_rgCols[] =
{
    {ICOL_NAME,               IDS_CONFOLD_DETAILS_NAME,                40, LVCFMT_LEFT, SHCOLSTATE_TYPE_STR | SHCOLSTATE_ONBYDEFAULT},
    {ICOL_TYPE,               IDS_CONFOLD_DETAILS_TYPE,                24, LVCFMT_LEFT, SHCOLSTATE_TYPE_STR | SHCOLSTATE_ONBYDEFAULT},
    {ICOL_STATUS,             IDS_CONFOLD_DETAILS_STATUS,              24, LVCFMT_LEFT, SHCOLSTATE_TYPE_STR | SHCOLSTATE_ONBYDEFAULT},
    {ICOL_DEVICE_NAME,        IDS_CONFOLD_DETAILS_DEVICE_NAME,         24, LVCFMT_LEFT, SHCOLSTATE_TYPE_STR | SHCOLSTATE_ONBYDEFAULT},
    {ICOL_PHONEORHOSTADDRESS, IDS_CONFOLD_DETAILS_PHONEORHOSTADDRESS,  24, LVCFMT_LEFT, SHCOLSTATE_TYPE_STR | SHCOLSTATE_ONBYDEFAULT},
    {ICOL_OWNER,              IDS_CONFOLD_DETAILS_OWNER,               24, LVCFMT_LEFT, SHCOLSTATE_TYPE_STR | SHCOLSTATE_ONBYDEFAULT},
    
    {ICOL_ADDRESS,            IDS_CONFOLD_DETAILS_ADDRESS,             24, LVCFMT_LEFT, SHCOLSTATE_TYPE_STR | SHCOLSTATE_HIDDEN},
    {ICOL_PHONENUMBER,        IDS_CONFOLD_DETAILS_PHONENUMBER,         24, LVCFMT_LEFT, SHCOLSTATE_TYPE_STR | SHCOLSTATE_HIDDEN},
    {ICOL_HOSTADDRESS,        IDS_CONFOLD_DETAILS_HOSTADDRESS,         24, LVCFMT_LEFT, SHCOLSTATE_TYPE_STR | SHCOLSTATE_HIDDEN},
    {ICOL_WIRELESS_MODE,      IDS_CONFOLD_DETAILS_WIRELESS_MODE,       24, LVCFMT_LEFT, SHCOLSTATE_TYPE_STR | SHCOLSTATE_HIDDEN},
};

#if DBG

struct ShellViewTraceMsgEntry
{
    UINT    uMsg;
    CHAR    szMsgName[32];   // Use Char because it's for Tracing only
    CHAR    szLparamHint[32];
    CHAR    szWparamHint[32];
};

static const ShellViewTraceMsgEntry   c_SVTMEArray[] =
{
    { DVM_GETBUTTONINFO      ,  "DVM_GETBUTTONINFO"      ,"TBINFO *"           ,"-"} ,
    { DVM_GETBUTTONS         ,  "DVM_GETBUTTONS"         ,"idCmdFirst"         ,"ptButton" },
    { DVM_COLUMNCLICK        ,  "DVM_COLUMNCLICK"        ,"-"                  ,"-" },
    { DVM_DEFVIEWMODE        ,  "DVM_DEFVIEWMODE"        ,"FOLDERVIEWMODE*"    ,"-" },
    { DVM_DIDDRAGDROP        ,  "DVM_DIDDRAGDROP"        ,"-"                  ,"-" },
    { DVM_QUERYCOPYHOOK      ,  "DVM_QUERYCOPYHOOK"      ,"-"                  ,"-" },
    { DVM_SELCHANGE          ,  "DVM_SELCHANGE"          ,"-"                  ,"-" },
    { DVM_MERGEMENU          ,  "DVM_MERGEMENU"          ,"LPQCMINFO"          ,"-" },
    { DVM_INITMENUPOPUP      ,  "DVM_INITMENUPOPUP"      ,"iIndex"             ,"HMENU" },
    { DVM_REFRESH            ,  "DVM_REFRESH"            ,"-"                  ,"fPreRefresh" },
    { DVM_INVOKECOMMAND      ,  "DVM_INVOKECOMMAND"      ,"LPSHELLFOLDER"      ,"wParam" },
    { SFVM_MERGEMENU         ,  "SFVM_MERGEMENU"         ,"0"                  ,"LPQCMINFO" },
    { SFVM_INVOKECOMMAND     ,  "SFVM_INVOKECOMMAND"     ,"idCmd"              ,"0" },
    { SFVM_GETHELPTEXT       ,  "SFVM_GETHELPTEXT"       ,"idCmd,cchMax"       ,"pszText - Ansi" },
    { SFVM_GETTOOLTIPTEXT    ,  "SFVM_GETTOOLTIPTEXT"    ,"idCmd,cchMax"       ,"pszText - Ansi" },
    { SFVM_GETBUTTONINFO     ,  "SFVM_GETBUTTONINFO"     ,"0"                  ,"LPTBINFO" },
    { SFVM_GETBUTTONS        ,  "SFVM_GETBUTTONS"        ,"idCmdFirst,cbtnMax" ,"LPTBBUTTON" },
    { SFVM_INITMENUPOPUP     ,  "SFVM_INITMENUPOPUP"     ,"idCmdFirst,nIndex"  ,"hmenu" },
    { SFVM_SELCHANGE         ,  "SFVM_SELCHANGE"         ,"idCmdFirst,nItem"   ,"SFVM_SELCHANGE_DATA*" },
    { SFVM_DRAWITEM          ,  "SFVM_DRAWITEM"          ,"idCmdFirst"         ,"DRAWITEMSTRUCT*" },
    { SFVM_MEASUREITEM       ,  "SFVM_MEASUREITEM"       ,"idCmdFirst"         ,"MEASUREITEMSTRUCT*" },
    { SFVM_EXITMENULOOP      ,  "SFVM_EXITMENULOOP"      ,"-"                  ,"-" },
    { SFVM_PRERELEASE        ,  "SFVM_PRERELEASE"        ,"-"                  ,"-" },
    { SFVM_GETCCHMAX         ,  "SFVM_GETCCHMAX"         ,"LPCITEMIDLIST"      ,"pcchMax" },
    { SFVM_FSNOTIFY          ,  "SFVM_FSNOTIFY"          ,"LPCITEMIDLIST*"     ,"lEvent" },
    { SFVM_WINDOWCREATED     ,  "SFVM_WINDOWCREATED"     ,"hwnd"               ,"-" },
    { SFVM_WINDOWDESTROY     ,  "SFVM_WINDOWDESTROY"     ,"hwnd"               ,"-" },
    { SFVM_REFRESH           ,  "SFVM_REFRESH"           ,"BOOL fPreOrPost"    ,"-" },
    { SFVM_SETFOCUS          ,  "SFVM_SETFOCUS"          ,"-"                  ,"-" },
    { SFVM_QUERYCOPYHOOK     ,  "SFVM_QUERYCOPYHOOK"     ,"-"                  ,"-" },
    { SFVM_NOTIFYCOPYHOOK    ,  "SFVM_NOTIFYCOPYHOOK"    ,"-"                  ,"COPYHOOKINFO*" },
    { SFVM_COLUMNCLICK       ,  "SFVM_COLUMNCLICK"       ,"iColumn"            ,"-" },
    { SFVM_QUERYFSNOTIFY     ,  "SFVM_QUERYFSNOTIFY"     ,"-"                  ,"SHChangeNotifyEntry *" },
    { SFVM_DEFITEMCOUNT      ,  "SFVM_DEFITEMCOUNT"      ,"-"                  ,"UINT*" },
    { SFVM_DEFVIEWMODE       ,  "SFVM_DEFVIEWMODE"       ,"-"                  ,"FOLDERVIEWMODE*" },
    { SFVM_UNMERGEMENU       ,  "SFVM_UNMERGEMENU"       ,"-"                  ,"hmenu" },
    { SFVM_INSERTITEM        ,  "SFVM_INSERTITEM"        ,"pidl"               ,"-" },
    { SFVM_DELETEITEM        ,  "SFVM_DELETEITEM"        ,"pidl"               ,"-" },
    { SFVM_UPDATESTATUSBAR   ,  "SFVM_UPDATESTATUSBAR"   ,"fInitialize"        ,"-" },
    { SFVM_BACKGROUNDENUM    ,  "SFVM_BACKGROUNDENUM"    ,"-"                  ,"-" },
    { SFVM_GETWORKINGDIR     ,  "SFVM_GETWORKINGDIR"     ,"uMax"               ,"pszDir" },
    { SFVM_GETCOLSAVESTREAM  ,  "SFVM_GETCOLSAVESTREAM"  ,"flags"              ,"IStream **" },
    { SFVM_SELECTALL         ,  "SFVM_SELECTALL"         ,"-"                  ,"-" },
    { SFVM_DIDDRAGDROP       ,  "SFVM_DIDDRAGDROP"       ,"dwEffect"           ,"IDataObject *" },
    { SFVM_SUPPORTSIDENTITY  ,  "SFVM_SUPPORTSIDENTITY"  ,"-"                  ,"-" },
    { SFVM_FOLDERISPARENT    ,  "SFVM_FOLDERISPARENT"    ,"-"                  ,"pidlChild" },
    { SFVM_SETISFV           ,  "SFVM_SETISFV"           ,"-"                  ,"IShellFolderView*" },
    { SFVM_GETVIEWS          ,  "SFVM_GETVIEWS"          ,"SHELLVIEWID*"       ,"IEnumSFVViews **" },
    { SFVM_THISIDLIST        ,  "SFVM_THISIDLIST"        ,"-"                  ,"LPITMIDLIST*" },
    { SFVM_GETITEMIDLIST     ,  "SFVM_GETITEMIDLIST"     ,"iItem"              ,"LPITMIDLIST*" },
    { SFVM_SETITEMIDLIST     ,  "SFVM_SETITEMIDLIST"     ,"iItem"              ,"LPITEMIDLIST" },
    { SFVM_INDEXOFITEMIDLIST ,  "SFVM_INDEXOFITEMIDLIST" ,"*iItem"             ,"LPITEMIDLIST" },
    { SFVM_ODFINDITEM        ,  "SFVM_ODFINDITEM"        ,"*iItem"             ,"NM_FINDITEM*" },
    { SFVM_HWNDMAIN          ,  "SFVM_HWNDMAIN"          ,""                   ,"hwndMain" },
    { SFVM_ADDPROPERTYPAGES  ,  "SFVM_ADDPROPERTYPAGES"  ,"-"                  ,"SFVM_PROPPAGE_DATA *" },
    { SFVM_BACKGROUNDENUMDONE,  "SFVM_BACKGROUNDENUMDONE","-"                  ,"-" },
    { SFVM_GETNOTIFY         ,  "SFVM_GETNOTIFY"         ,"LPITEMIDLIST*"      ,"LONG*" },
    { SFVM_ARRANGE           ,  "SFVM_ARRANGE"           ,"-"                  ,"lParamSort" },
    { SFVM_QUERYSTANDARDVIEWS,  "SFVM_QUERYSTANDARDVIEWS","-"                  ,"BOOL *" },
    { SFVM_QUERYREUSEEXTVIEW ,  "SFVM_QUERYREUSEEXTVIEW" ,"-"                  ,"BOOL *" },
    { SFVM_GETSORTDEFAULTS   ,  "SFVM_GETSORTDEFAULTS"   ,"iDirection"         ,"iParamSort" },
    { SFVM_GETEMPTYTEXT      ,  "SFVM_GETEMPTYTEXT"      ,"cchMax"             ,"pszText" },
    { SFVM_GETITEMICONINDEX  ,  "SFVM_GETITEMICONINDEX"  ,"iItem"              ,"int *piIcon" },
    { SFVM_DONTCUSTOMIZE     ,  "SFVM_DONTCUSTOMIZE"     ,"-"                  ,"BOOL *pbDontCustomize" },
    { SFVM_SIZE              ,  "SFVM_SIZE"              ,"resizing flag"      ,"cx, cy" },
    { SFVM_GETZONE           ,  "SFVM_GETZONE"           ,"-"                  ,"DWORD*" },
    { SFVM_GETPANE           ,  "SFVM_GETPANE"           ,"Pane ID"            ,"DWORD*" },
    { SFVM_ISOWNERDATA       ,  "SFVM_ISOWNERDATA"       ,"ISOWNERDATA"        ,"BOOL *" },
    { SFVM_GETODRANGEOBJECT  ,  "SFVM_GETODRANGEOBJECT"  ,"iWhich"             ,"ILVRange **" },
    { SFVM_ODCACHEHINT       ,  "SFVM_ODCACHEHINT"       ,"-"                  ,"NMLVCACHEHINT *" },
    { SFVM_GETHELPTOPIC      ,  "SFVM_GETHELPTOPIC"      ,"0"                  ,"SFVM_HELPTOPIC_DATA *" },
    { SFVM_OVERRIDEITEMCOUNT ,  "SFVM_OVERRIDEITEMCOUNT" ,"-"                  ,"UINT*" },
    { SFVM_GETHELPTEXTW      ,  "SFVM_GETHELPTEXTW"      ,"idCmd,cchMax"       ,"pszText - unicode" },
    { SFVM_GETTOOLTIPTEXTW   ,  "SFVM_GETTOOLTIPTEXTW"   ,"idCmd,cchMax"       ,"pszText - unicode" },
    { SFVM_GETWEBVIEWLAYOUT  ,  "SFVM_GETWEBVIEWLAYOUT"  ,"SFVM_WEBVIEW_LAYOUT_DATA*",     "uViewMode" },
    { SFVM_GETWEBVIEWTASKS   ,  "SFVM_GETWEBVIEWTASKS"   ,"SFVM_WEBVIEW_TASKSECTION_DATA*","pv" },
    { SFVM_GETWEBVIEWCONTENT ,  "SFVM_GETWEBVIEWCONTENT" ,"SFVM_WEBVIEW_CONTENT_DATA*", "pv" }
};

const INT   g_iSVTMEArrayEntryCount = celems(c_SVTMEArray);

VOID TraceShellViewMsg(
    IN  UINT    uMsg,
    IN  LPARAM  lParam,
    IN  WPARAM  wParam)
{
    INT     iLoop       = 0;
    INT     iFoundPos   = -1;

    for (iLoop = 0; iLoop < g_iSVTMEArrayEntryCount && (-1 == iFoundPos); iLoop++)
    {
        if (c_SVTMEArray[iLoop].uMsg == uMsg)
        {
            iFoundPos = iLoop;
        }
    }

    if (-1 != iFoundPos)
    {
        UINT    uMsg;
        CHAR    szMsgName[32];   // Use Char because it's for Tracing only
        CHAR    szLparamHint[32];
        CHAR    szWparamHint[32];

        TraceTag(ttidShellViewMsgs,
            "%s (%d), lParam: 0x%08x [%s], wParam: 0x%08x [%s]",
            c_SVTMEArray[iFoundPos].szMsgName,
            c_SVTMEArray[iFoundPos].uMsg,
            lParam,
            c_SVTMEArray[iFoundPos].szLparamHint,
            wParam,
            c_SVTMEArray[iFoundPos].szWparamHint);
    }
    else
    {
#ifdef SHOW_NEW_MSG_ASSERT

        AssertSz(FALSE,
            "Totally inert assert -- Unknown message in HrShellViewCallback. "
            "I just want to know about new ones");

#endif

        TraceTag(ttidShellViewMsgs,
            "(Jeffspr) Unknown Message (%d) in HrShellViewCallback, lParam: 0x%08x, wParam, 0x%08x",
            uMsg, lParam, wParam);
    }
}

#endif

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolder::MessageSFVCB
//
//  Purpose:    Deferred Implementation of IShellViewCB::MessageSFVCB after
//              basic functionality was implemented.
//
//  Arguments:
//      uMsg [in]  Message - depends on implementation
//     wParam [in] WORD param - depends on implementation
//     lParam [in] LONG param - - depends on implementation
//
//  Returns:    S_OK is succeeded
//              COM error code if not
//
//  Author:     deonb   8 Feb 2001
//
//  Notes:      CBaseShellFolderViewCB
//
STDMETHODIMP CConnectionFolder::RealMessage(
        IN  UINT uMsg,
        IN  WPARAM wParam,
        IN  LPARAM lParam)
{
    HRESULT hr = S_OK;

    TraceFileFunc(ttidShellFolder);

#if DBG
    // Trace the shell message when we're in the checked builds
    //
    TraceShellViewMsg(uMsg, lParam, wParam);
#endif

    switch (uMsg)
    {
        case DVM_GETBUTTONINFO:
            hr = HrOnFolderGetButtonInfo((TBINFO *)lParam);
            break;

        case DVM_GETBUTTONS:
            Assert(m_hwndMain);
            if (!m_hwndMain)
            {
                hr = E_UNEXPECTED;
            }
            else
            {
                hr = HrOnFolderGetButtons(m_hwndMain, this, LOWORD(wParam), (TBBUTTON *)lParam);
            }
            break;

        case DVM_COLUMNCLICK:
            Assert(m_hwndMain);
            if (!m_hwndMain)
            {
                hr = E_UNEXPECTED;
            }
            else
            {
                ShellFolderView_ReArrange (m_hwndMain, wParam);
            }
            break;

        case DVM_DEFVIEWMODE:
            *(FOLDERVIEWMODE *)lParam = FVM_TILE;
            break;

        case DVM_DIDDRAGDROP:
        case DVM_QUERYCOPYHOOK:
        case DVM_SELCHANGE:
            hr = S_FALSE;
            break;

        case DVM_MERGEMENU :
            hr = HrOnFolderMergeMenu((LPQCMINFO)lParam);
            break;

        case DVM_INITMENUPOPUP:
            Assert(m_hwndMain);
            if (!m_hwndMain)
            {
                hr = E_UNEXPECTED;
            }
            else
            {
                hr = HrOnFolderInitMenuPopup(m_hwndMain, LOWORD(wParam), HIWORD(wParam), (HMENU) lParam);
            }
            break;

        case DVM_REFRESH:
            Assert(m_hwndMain);
            if (!m_hwndMain)
            {
                hr = E_UNEXPECTED;
            }
            else
            {
                hr = HrOnFolderRefresh(m_hwndMain, lParam, wParam);
            }
            break;

        case DVM_INVOKECOMMAND:
            Assert(m_hwndMain);
            if (!m_hwndMain)
            {
                hr = E_UNEXPECTED;
            }
            else
            {
                hr = HrOnFolderInvokeCommand(m_hwndMain, wParam, this);
            }
            break;

        case MYWM_QUERYINVOKECOMMAND_ITEMLEVEL:
            Assert(m_hwndMain);
            if (!m_hwndMain)
            {
                hr = E_UNEXPECTED;
            }
            else
            {
                hr = HrCheckFolderInvokeCommand(m_hwndMain, wParam, lParam, FALSE, this);
            }
            break;

        case MYWM_QUERYINVOKECOMMAND_TOPLEVEL:
            Assert(m_hwndMain);
            if (!m_hwndMain)
            {
                hr = E_UNEXPECTED;
            }
            else
            {
                hr = HrCheckFolderInvokeCommand(m_hwndMain, wParam, lParam, TRUE, this);
            }
            break;

        case SFVM_HWNDMAIN:
            m_hwndMain = (HWND)lParam;

            HrAssertMenuStructuresValid(m_hwndMain);
            break;

        case SFVM_GETDEFERREDVIEWSETTINGS:
            ((SFVM_DEFERRED_VIEW_SETTINGS *)lParam)->fvm = FVM_TILE;
            break;

        case SFVM_GETNOTIFY:
            Assert(m_hwndMain);
            if (!m_hwndMain)
            {
                hr = E_UNEXPECTED;
            }
            else
            {
                hr = HrOnFolderGetNotify(m_hwndMain, this, wParam, lParam);
            }
            break;

        case SFVM_GETHELPTOPIC:
            hr = HrOnGetHelpTopic((SFVM_HELPTOPIC_DATA*)lParam);
            break;

        case SFVM_GETCCHMAX:
            Assert(m_hwndMain);
            if (!m_hwndMain)
            {
                hr = E_UNEXPECTED;
            }
            else
            {
                PCONFOLDPIDL pidlParm;
                if (FAILED(pidlParm.InitializeFromItemIDList((LPCITEMIDLIST) wParam)))
                {
                    return E_INVALIDARG;
                }
                
                hr = HrOnGetCchMax(m_hwndMain, pidlParm, (INT *) lParam);
            }
            break;

        case SFVM_GETHELPTEXTW:
            hr = HrOnGetHelpText(LOWORD(wParam), HIWORD(wParam), reinterpret_cast<PWSTR>(lParam));
            break;

        default:
            hr = m_pWebView->RealMessage(uMsg, wParam, lParam); // defer to the webview's handler
            break;
       }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOnGetHelpText
//
//  Purpose:    Folder message handler for defview's SFVM_GETHELPTEXTW. This
//              message is received when the status bar text for a command is needed.
//
//  Arguments:
//      idCmd   [in]    Id of the menu command
//      cchMax  [in]    Size of buffer
//      pszName [out]   Status bar text
//
//  Returns:
//
//  Author:     mbend   3 May 2000
//
//  Notes:
//
HRESULT HrOnGetHelpText(IN  UINT idCmd, 
                        IN  UINT cchMax, 
                        OUT PWSTR pszName)
{
    HRESULT hr = E_FAIL;
    *((PWSTR)pszName) = L'\0';

    int iLength = LoadString(   _Module.GetResourceInstance(),
                                idCmd + IDS_CMIDM_START,
                                (PWSTR) pszName,
                                cchMax);
    if (iLength > 0)
    {
        hr = NOERROR;
    }
    else
    {
        AssertSz(FALSE, "Resource string not found for one of the connections folder commands");
    }
    
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOnGetCchMax
//
//  Purpose:    Folder message handler for defview's SFVM_GETCCHMAX. This
//              message is received when a rename is attempted, and causes
//              the edit control to be limited to the size returned.
//
//  Arguments:
//      hwnd    [in]    Folder window handle
//      pidl    [in]    The object pidl
//      pcchMax [out]   Return pointer for max name length
//
//  Returns:
//
//  Author:     jeffspr   21 Jul 1998
//
//  Notes:
//
HRESULT HrOnGetCchMax(IN  HWND hwnd, 
                      IN  const PCONFOLDPIDL& pidl, 
                      OUT INT * pcchMax)
{
    HRESULT hr  = S_OK;

    Assert(!pidl.empty());
    Assert(pcchMax);

    // If the passed in info is valid
    //
    if ( (!pidl.empty()) && pcchMax && pidl->IsPidlOfThisType() )
    {
        // Set the max to be the max length of a RAS entry. Currently,
        // that's our only requirement
        //
        *pcchMax = RAS_MaxEntryName; 
    }
    else
    {
        hr = E_INVALIDARG;
    }

    TraceHr(ttidShellFolder, FAL, hr, FALSE, "HrOnGetCchMax");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOnFolderRefresh
//
//  Purpose:    Folder message handler for defview's DVM_REFRESH
//
//  Arguments:
//      hwndOwner [in]  Our parent window
//      lParam    [in]  Ignored
//      wParam    [in]  BOOL -- TRUE = Pre-refresh, FALSE = Post-refresh
//
//  Returns:
//
//  Author:     jeffspr   10 Apr 1998
//
//  Notes:
//
HRESULT HrOnFolderRefresh(
    IN  HWND            hwndOwner,
    IN  LPARAM          lParam,
    IN  WPARAM          wParam)
{
    TraceFileFunc(ttidShellFolder);
    
    HRESULT hr          = S_OK;
    BOOL    fPreRefresh = (wParam > 0);

    // If this refresh notification is coming BEFORE the refresh, then we want to
    // flush the connection list. Two reasons for this:
    //
    // 1: We don't ever want to re-enumerate AFTER the refresh has occurred.
    // 2: We get a POST refresh notify on folder entry, which shouldn't necessitate
    //    a refresh
    //

    if (fPreRefresh)
    {
        // Rebuild the cache
        //
        // Note: Remove this when we get RAS notifications, because
        // we will already know about the CM connections and won't have to refresh.
        // Revert the #if 0'd code above to just do the fPreRefresh flush.
        //

        hr = g_ccl.HrRefreshConManEntries();
        if (FAILED(hr))
        {
            NcMsgBox(_Module.GetResourceInstance(), 
                NULL, 
                IDS_CONFOLD_WARNING_CAPTION,
                IDS_ERR_NO_NETMAN, 
                MB_ICONEXCLAMATION | MB_OK);
                     
        }
    }

    TraceHr(ttidShellFolder, FAL, hr, FALSE, "HrOnFolderRefresh");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOnFolderGetNotify
//
//  Purpose:    Folder message handler for defview's DVM_GETNOTIFY
//
//  Arguments:
//      hwndOwner [in]  Our parent window
//      psf       [in]  Our shell folder
//      wParam    [out] Return pointer for our folder pidl
//      lParam    [out] Return pointer for notify flags
//
//  Returns:
//
//  Author:     jeffspr   10 Apr 1998
//
//  Notes:
//
HRESULT HrOnFolderGetNotify(
    IN  HWND            hwndOwner,
    IN  LPSHELLFOLDER   psf,
    IN  WPARAM          wParam,
    IN  LPARAM          lParam)
{
    HRESULT             hr              = S_OK;
    CConnectionFolder * pcf             = static_cast<CConnectionFolder *>(psf);
    PCONFOLDPIDLFOLDER  pidlRoot;
    PCONFOLDPIDLFOLDER  pidlRootCopy;

    NETCFG_TRY
            
        if (!psf || !wParam || !lParam)
        {
            Assert(psf);
            Assert(lParam);
            Assert(wParam);

            hr = E_INVALIDARG;
        }
        else
        {
            pidlRoot = pcf->PidlGetFolderRoot();
            if (pidlRoot.empty())
            {
                hr = E_FAIL;
            }
            else
            {
                hr = pidlRootCopy.ILClone(pidlRoot);
                if (SUCCEEDED(hr))
                {
                    *(LPCITEMIDLIST*)wParam = pidlRootCopy.TearOffItemIdList();
                    *(LONG*)lParam =
                        SHCNE_RENAMEITEM|
                        SHCNE_CREATE    |
                        SHCNE_DELETE    |
                        SHCNE_UPDATEDIR |
                        SHCNE_UPDATEITEM;
                }
            }
        }

    NETCFG_CATCH(hr)

    TraceHr(ttidShellFolder, FAL, hr, FALSE, "HrOnFolderGetNotify");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOnGetHelpTopic
//
//  Purpose:    Folder message handler for defview's SFVM_GETHELPTOPIC
//
//  Arguments:
//      phtd    [in out]  Pointer to SFVM_HELPTOPIC_DATA structure with default values set
//
//  Returns:
//      S_OK    Help file name is correctly set
//
//  Author:     toddb   21 Jun 1998
//
//  Notes:
//
HRESULT HrOnGetHelpTopic(
    OUT SFVM_HELPTOPIC_DATA * phtd)
{
    Assert(phtd);
    Assert(phtd->wszHelpFile);
    
    if (IsOS(OS_PROFESSIONAL) || IsOS(OS_PERSONAL))
    {
        *(phtd->wszHelpFile) = L'\0';

        Assert(phtd->wszHelpTopic);
        lstrcpyW(phtd->wszHelpTopic, L"hcp://services/subsite?node=Unmapped/Network_connections&select=Unmapped/Network_connections/Getting_started");
    }
    else
    {
        static LPCWSTR szNetCfgHelpFile = L"netcfg.chm";

        lstrcpyW(phtd->wszHelpFile, szNetCfgHelpFile);
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOnFolderInvokeCommand
//
//  Purpose:    Folder message handler for defview's DVM_INVOKECOMMAND
//
//  Arguments:
//      hwndOwner [in]  Our window handle
//      wParam    [in]  Command that's being invoked
//      psf       [in]  Our shell folder
//
//  Returns:
//
//  Author:     jeffspr   10 Apr 1998
//
//  Notes:
//
HRESULT HrOnFolderInvokeCommand(
    IN  HWND            hwndOwner,
    IN  WPARAM          wParam,
    IN  LPSHELLFOLDER   psf)
{
    HRESULT         hr              = S_OK;
    PCONFOLDPIDLVEC apidlSelected;
    PCONFOLDPIDLVEC apidlCache;

    // Get the selected objects. If there are objects present, try to get them from the
    // cache. Regardless, call the command handler
    //
    hr = HrShellView_GetSelectedObjects(hwndOwner, apidlSelected);
    if (SUCCEEDED(hr))
    {
        // If there are objects, try to get the cached versions
        //
        if (!apidlSelected.empty())
        {
            hr = HrCloneRgIDL(apidlSelected, TRUE, TRUE, apidlCache);
        }

        // If either the clone succeeded, or there were no items, call the command handler
        //
        if (SUCCEEDED(hr))
        {
            hr = HrFolderCommandHandler(
                (UINT) wParam,
                apidlCache,
                hwndOwner,
                NULL,
                psf);
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "HrOnFolderInvokeCommand");
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrCheckFolderInvokeCommand
//
//  Purpose:    Test if a message handler can be invoked 
//
//  Arguments:
//      hwndOwner [in]  Our window handle
//      wParam    [in]  Command that's being invoked
//      psf       [in]  Our shell folder
//
//  Returns:
//
//  Author:     deonb  10 Feb 2001
//
//  Notes:
//
HRESULT HrCheckFolderInvokeCommand(
    IN  HWND            hwndOwner,
    IN  WPARAM          wParam,
    IN  LPARAM          lParam,
    IN  BOOL            bLevel,
    IN  LPSHELLFOLDER   psf)
{
    HRESULT         hr              = S_OK;
    PCONFOLDPIDLVEC apidlSelected;
    PCONFOLDPIDLVEC apidlCache;

    // Get the selected objects. If there are objects present, try to get them from the
    // cache. Regardless, call the command handler
    //
    hr = HrShellView_GetSelectedObjects(hwndOwner, apidlSelected);
    if (SUCCEEDED(hr))
    {
        // If there are objects, try to get the cached versions
        //
        if (!apidlSelected.empty())
        {
            hr = HrCloneRgIDL(apidlSelected, TRUE, TRUE, apidlCache);
        }

        // If either the clone succeeded, or there were no items, call the command handler
        //
        if (SUCCEEDED(hr))
        {
            DWORD dwVerbId = (DWORD)wParam;
            NCCS_STATE *nccsState = reinterpret_cast<NCCS_STATE *>(lParam);
            DWORD dwResourceId;

            hr = HrGetCommandState(apidlCache, dwVerbId, *nccsState, &dwResourceId, 0xFFFFFFFF, bLevel ? NB_FLAG_ON_TOPMENU : NB_NO_FLAGS);
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "HrOnFolderInvokeCommand");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOnFolderInitMenuPopup
//
//  Purpose:    Folder message handler for defview's DVM_INITMENUPOPUP
//
//  Arguments:
//      hwnd       []   Our window handle
//      idCmdFirst []   First command ID in the menu
//      iIndex     []   ???
//      hmenu      []   Our menu handle
//
//  Returns:
//
//  Author:     jeffspr   13 Jan 1998
//
//  Notes:
//
HRESULT HrOnFolderInitMenuPopup(
    IN  HWND    hwnd,
    IN  UINT    idCmdFirst,
    IN  INT     iIndex,
    IN  HMENU   hmenu)
{
    HRESULT         hr              = S_OK;
    PCONFOLDPIDLVEC apidlSelected;
    PCONFOLDPIDLVEC apidlCache;

    // Get the currently selected object
    //
    hr = HrShellView_GetSelectedObjects(hwnd, apidlSelected);
    if (SUCCEEDED(hr))
    {
        // If we have a selection, clone it. Otherwise, we can live with a NULL apidlCache
        // (HrSetConnectDisconnectMenuItem and HrEnableOrDisableMenuItems both allow
        // NULL pidl arrays
        //
        if (!apidlSelected.empty())
        {
            // Clone the pidl array using the cache
            //
            hr = HrCloneRgIDL(apidlSelected, TRUE, TRUE, apidlCache);
            if (FAILED(hr))
            {
                TraceHr(ttidError, FAL, hr, FALSE, "HrCloneRgIDL failed on apidl in "
                        "HrOnFolderInitMenuPopup");
            }
        }

        // Only do this for the file menu (iIndex=0)
        if (0 == iIndex)
        {
            // Ignore the return from this, since we want to do both regardless.
            // We retrieve this value for debugging purposes only
            //
            hr = HrSetConnectDisconnectMenuItem(apidlCache, hmenu, idCmdFirst);
            if (FAILED(hr))
            {
                AssertSz(FALSE, "Failed to set the connect/disconnect menu items");
            }
        }

        HrUpdateMenu(hmenu, apidlCache, idCmdFirst);
    }

    TraceHr(ttidShellFolder, FAL, hr, FALSE, "HrOnFolderInitMenuPopup");
    return hr;
}

HRESULT HrOnFolderMergeMenu(IN OUT LPQCMINFO pqcm)
{
    HRESULT hr    = S_OK;
    HMENU   hmenu = NULL;

    hmenu = LoadMenu(_Module.GetResourceInstance(), MAKEINTRESOURCE(MENU_MERGE_INBOUND_DISCON));

    if (hmenu)
    {
        MergeMenu(_Module.GetResourceInstance(), POPUP_MERGE_FOLDER_CONNECTIONS, MENU_MERGE_INBOUND_DISCON, pqcm);
        DestroyMenu(hmenu);
    }

    TraceHr(ttidShellFolder, FAL, hr, FALSE, "HrOnFolderMergeMenu");
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrOnFolderGetButtons
//
//  Purpose:    Folder message handler for defview's DVM_GETBUTTONS
//
//  Arguments:
//      hwnd        [in]        Folder window handle
//      psf         [in]        Pointer to the IShellFolder interface
//      idCmdFirst  [in]        Our command ID base
//      ptButton    [in/out]    Button structures to fill
//
//  Returns:
//
//  Author:     jeffspr   15 Dec 1997
//
//  Notes:
//
HRESULT HrOnFolderGetButtons(
    IN     HWND            hwnd,
    IN     LPSHELLFOLDER   psf,
    IN     UINT            idCmdFirst,
    IN OUT LPTBBUTTON      ptButton)
{
    HRESULT             hr                  = S_OK;

#if ANY_FREEKIN_THING_IN_TOOLBAR
    UINT                i                   = 0;
    LRESULT             iBtnOffset          = 0;
    IShellBrowser *     psb                 = FileCabinet_GetIShellBrowser(hwnd);
    TBADDBITMAP         ab;

    PWSTR              pszToolbarStrings[2];

    for (DWORD dwLoop = 0; dwLoop < c_nToolbarButtons; dwLoop++)
    {
        // If this isn't a separator, load the text/tip string
        //
        if (!(c_tbConnections[dwLoop].fsStyle & TBSTYLE_SEP))
        {
            Assert(c_tbConnections[dwLoop].iString != -1);
            pszToolbarStrings[dwLoop] = (PWSTR) SzLoadIds(c_tbConnections[dwLoop].iString);
        }
    }

    // Add the toolbar button bitmap, get it's offset
    //
    ab.hInst = _Module.GetResourceInstance();
    ab.nID   = IDB_TB_SMALL;        // std bitmaps

    hr = psb->SendControlMsg(FCW_TOOLBAR, TB_ADDBITMAP, c_nToolbarButtons,
                             (LONG_PTR)&ab, &iBtnOffset);
    if (SUCCEEDED(hr))
    {
        for (i = 0; i < c_nToolbarButtons; i++)
        {
            ptButton[i] = c_tbConnections[i];

            if (!(c_tbConnections[i].fsStyle & TBSTYLE_SEP))
            {
                ptButton[i].idCommand += idCmdFirst;
                ptButton[i].iBitmap += (int) iBtnOffset;
                ptButton[i].iString = (INT_PTR) pszToolbarStrings[i];
            }
        }
    }
#endif // ANY_FREEKIN_THING_IN_TOOLBAR

    // We always want to return success, even if we added nothing.
    //
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOnFolderGetButtonInfo
//
//  Purpose:    Folder message handler for defview's DVM_GETBUTTONINFO
//
//  Arguments:
//      ptbInfo [in/out]    Structure that we'll fill in (flags and button
//                          count)
//
//  Returns:
//
//  Author:     jeffspr   15 Dec 1997
//
//  Notes:
//
HRESULT HrOnFolderGetButtonInfo(IN OUT TBINFO * ptbInfo)
{
    ptbInfo->uFlags = TBIF_PREPEND;
    ptbInfo->cbuttons = c_nToolbarButtons;  // size of toolbar array

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\shell\folder\ishellei.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       I S H E L L E I . C P P
//
//  Contents:   IShellExtInit implementation for CConnectionFolder
//
//  Notes:
//
//  Author:     jeffspr   22 Sep 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "foldinc.h"    // Standard shell\folder includes



STDMETHODIMP CConnectionFolder::Initialize(
        IN  LPCITEMIDLIST   pidlFolder,
        OUT LPDATAOBJECT    lpdobj,
        IN  HKEY            hkeyProgID)
{
    TraceFileFunc(ttidShellFolderIface);

    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\shell\folder\notify.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N O T I F Y . C P P
//
//  Contents:   Implementation of INetConnectionNotifySink
//
//  Notes:
//
//  Author:     shaunco   21 Aug 1998
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "foldinc.h"
#include "nccom.h"
#include "notify.h"
#include "shutil.h"
#include "smcent.h"
#include "ctrayui.h"
#include "traymsgs.h"
#include "wzcdlg.h"

extern HWND g_hwndTray;

enum EVENT_LEVELS
{
    EVT_LVL_DISABLE_ALL    = 0,
    EVT_LVL_ENABLE_PRIVATE = 1,
    EVT_LVL_ENABLE_ALL     = 2
};

DWORD g_dwCurrentEventLevel = EVT_LVL_ENABLE_ALL;

//static
HRESULT
CConnectionNotifySink::CreateInstance (
    IN  REFIID  riid,
    OUT VOID**  ppv)
{
    TraceFileFunc(ttidNotifySink);

    HRESULT hr = E_OUTOFMEMORY;

    // Initialize the output parameter.
    //
    *ppv = NULL;

    CConnectionNotifySink* pObj;
    pObj = new CComObject <CConnectionNotifySink>;
    if (pObj)
    {
        // Do the standard CComCreator::CreateInstance stuff.
        //
        pObj->SetVoid (NULL);
        pObj->InternalFinalConstructAddRef ();
        hr = pObj->FinalConstruct ();
        pObj->InternalFinalConstructRelease ();

        if (SUCCEEDED(hr))
        {
            // Call the PidlInitialize function to allow the enumeration
            // object to copy the list.
            //
            hr = HrGetConnectionsFolderPidl(pObj->m_pidlFolder);

            if (SUCCEEDED(hr))
            {
                hr = pObj->QueryInterface (riid, ppv);
            }
        }

        if (FAILED(hr))
        {
            delete pObj;
        }
    }

    TraceHr(ttidError, FAL, hr, (S_FALSE == hr), "CConnectionNotifySink::CreateInstance");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionNotifySink::~CConnectionNotifySink
//
//  Purpose:    Clean up the sink object, deleting the folder pidl and any
//              alloc'd junk we might add in the future.
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     jeffspr   26 Aug 1998
//
//  Notes:
//
CConnectionNotifySink::~CConnectionNotifySink() throw()
{
    TraceFileFunc(ttidNotifySink);

    if (FIsDebugFlagSet (dfidBreakOnNotifySinkRelease))
    {
        AssertSz(FALSE, "THIS IS NOT A BUG!  The debug flag "
            "\"BreakOnNotifySinkRelease\" has been set. Set your breakpoints now.");
    }    
    
    TraceTag(ttidNotifySink, "Connection notify sink destroyed");
} 

HRESULT CConnectionNotifySink::HrUpdateIncomingConnection()
{
    HRESULT hr = S_OK;

    ConnListEntry cle;
    hr = g_ccl.HrFindRasServerConnection(cle);
    if (S_OK == hr)
    {
        hr = HrOnNotifyUpdateConnection(
            m_pidlFolder,
            &(cle.ccfe.GetGuidID()),
            cle.ccfe.GetNetConMediaType(),
            cle.ccfe.GetNetConSubMediaType(),
            cle.ccfe.GetNetConStatus(),
            cle.ccfe.GetCharacteristics(),
            cle.ccfe.GetName(),
            cle.ccfe.GetDeviceName(),
            cle.ccfe.GetPhoneOrHostAddress()
            );

        if (SUCCEEDED(hr))
        {
            PCONFOLDPIDL pidlShellNotify;
            hr = cle.ccfe.ConvertToPidl(pidlShellNotify);
            if (SUCCEEDED(hr))
            {
                GenerateEvent(SHCNE_UPDATEITEM, m_pidlFolder, pidlShellNotify, NULL);
            }
        }
    }

    return hr;
}

HRESULT
CConnectionNotifySink::ConnectionAdded (
    IN const NETCON_PROPERTIES_EX*    pPropsEx)
{
    TraceFileFunc(ttidNotifySink);

#ifdef DBG
    OLECHAR szGuidString[MAX_GUID_STRING_LEN];
    StringFromGUID2(pPropsEx->guidId, szGuidString, MAX_GUID_STRING_LEN);
    TraceTag(ttidNotifySink, "INetConnectionNotifySink::ConnectionAdded - %S %S [%s:%s:%s:%s]", 
        szGuidString, pPropsEx->bstrName, DbgNcm(pPropsEx->ncMediaType), DbgNcsm(pPropsEx->ncSubMediaType), DbgNcs(pPropsEx->ncStatus), DbgNccf(pPropsEx->dwCharacter) );
#endif
    if (g_dwCurrentEventLevel <= EVT_LVL_DISABLE_ALL)
    {
        TraceTag(ttidNotifySink, "Last event ignored due to g_dwCurrentEventLevel == %d", g_dwCurrentEventLevel);
        return S_FALSE;
    }

    HRESULT         hr      = S_OK;     // Only used for code paths. We don't return this.
    HRESULT         hrFind  = S_OK;     // Only for finding the connection.
    PCONFOLDPIDL    pidlNew;

    ConnListEntry cleDontCare;
    hrFind = g_ccl.HrFindConnectionByGuid(&(pPropsEx->guidId), cleDontCare);
    if (S_OK == hrFind)
    {
        // We already know about this connection. Don't bother added it.
        TraceTag(ttidShellFolder, "Ignoring known connection on ConnectionAdded notify");
    }
    else
    {
        // Create the entry in the connection list and get the returned pidl
        //
        hr = HrCreateConFoldPidl(
            *pPropsEx,
            pidlNew);
        if (SUCCEEDED(hr) && (!pidlNew.empty()))
        {
            CONFOLDENTRY  cfe;

            Assert(!m_pidlFolder.empty());

            // Convert to the confoldentry
            //
            hr = pidlNew.ConvertToConFoldEntry(cfe);
            if (SUCCEEDED(hr))
            {
                // Insert the connection in the connection list
                //
                hr = g_ccl.HrInsert(cfe);
                if (SUCCEEDED(hr))
                {
                    // Notify the shell that we have a new object
                    //
                    PCONFOLDPIDL pidlShellNotify;
                    hr = cfe.ConvertToPidl(pidlShellNotify);
                    if (SUCCEEDED(hr))
                    {
                        GenerateEvent(SHCNE_CREATE, m_pidlFolder, pidlShellNotify, NULL);
                    }
                }

                // Don't delete the cfe here because the connection list now owns it.
            }
        }
    }

    if (SUCCEEDED(hr) &&
        (NCM_NONE != pPropsEx->ncMediaType) &&
        (pPropsEx->dwCharacter & NCCF_INCOMING_ONLY) )
    {
        hr = HrUpdateIncomingConnection();
    }

    return S_OK;
}

HRESULT
CConnectionNotifySink::ConnectionBandWidthChange (
    IN const GUID* pguidId)
{
    TraceFileFunc(ttidNotifySink);
#ifdef DBG
    OLECHAR szGuidString[MAX_GUID_STRING_LEN];
    StringFromGUID2(*pguidId, szGuidString, MAX_GUID_STRING_LEN);
    TraceTag(ttidNotifySink, "INetConnectionNotifySink::ConnectionBandWidthChange - %S", szGuidString);
#endif
    if (g_dwCurrentEventLevel <= EVT_LVL_DISABLE_ALL)
    {
        TraceTag(ttidNotifySink, "Last event ignored due to g_dwCurrentEventLevel == %d", g_dwCurrentEventLevel);
        return S_FALSE;
    }

    HRESULT                 hr      = S_OK;
    CNetStatisticsCentral * pnsc    = NULL;

    hr = CNetStatisticsCentral::HrGetNetStatisticsCentral(&pnsc, FALSE);
    if (SUCCEEDED(hr))
    {
        pnsc->UpdateRasLinkList(pguidId);
        ReleaseObj(pnsc);
    }

    return S_OK;
}


HRESULT
CConnectionNotifySink::ConnectionDeleted (
    IN const GUID* pguidId)
{
    TraceFileFunc(ttidNotifySink);

    HRESULT         hr          = S_OK;
    HRESULT         hrFind      = S_OK;
    ConnListEntry   cle;
    PCONFOLDPIDL    pidlFind;
    BOOL            fFlushPosts = FALSE;

    Assert(pguidId);
    Assert(!m_pidlFolder.empty());

    if (g_dwCurrentEventLevel <= EVT_LVL_DISABLE_ALL)
    {
        TraceTag(ttidNotifySink, "CConnectionNotifySink::ConnectionDeleted event ignored due to g_dwCurrentEventLevel == %d", g_dwCurrentEventLevel);
        return S_FALSE;
    }

    // Find the connection using the GUID.
    //
    hrFind = g_ccl.HrFindConnectionByGuid(pguidId, cle);
    if (S_OK == hrFind)
    {
#ifdef DBG
        OLECHAR szGuidString[MAX_GUID_STRING_LEN];
        StringFromGUID2(cle.ccfe.GetGuidID(), szGuidString, MAX_GUID_STRING_LEN);
        TraceTag(ttidNotifySink, "INetConnectionNotifySink::ConnectionDeleted - %S %S [%s:%s:%s:%s]", szGuidString, cle.ccfe.GetName(), 
            DbgNcm(cle.ccfe.GetNetConMediaType()), DbgNcsm(cle.ccfe.GetNetConSubMediaType()), DbgNcs(cle.ccfe.GetNetConStatus()), DbgNccf(cle.ccfe.GetCharacteristics()));
#endif
        // Very important to release the lock before doing any thing which
        // calls back into the shell.  (e.g. GenerateEvent)
        
        const CONFOLDENTRY &ccfe = cle.ccfe;

        // Get the pidl for the connection so we can use it to notify
        // the shell further below.
        //
        ccfe.ConvertToPidl(pidlFind);

        // Remove this connection from the global list while we
        // have the lock held.
        //
        hr = g_ccl.HrRemove(cle.ccfe, &fFlushPosts);
    }
    else
    {
        TraceTag(ttidShellFolder, "Notify: Delete <item not found in cache>. hr = 0x%08x", hr);
    }


    // If we need to flush the posts after making tray icon changes, do so
    //
    if (g_hwndTray && fFlushPosts)
    {
        FlushTrayPosts(g_hwndTray);
    }

    if (SUCCEEDED(hr) && (!pidlFind.empty()))
    {
        GenerateEvent(SHCNE_DELETE, m_pidlFolder, pidlFind, NULL);
    }

    if (SUCCEEDED(hr))
    {
        hr = HrUpdateIncomingConnection();
    }

    // Only return S_OK from here.
    //
    return S_OK;
}

HRESULT
CConnectionNotifySink::ConnectionModified (
    IN const NETCON_PROPERTIES_EX* pPropsEx)
{
    TraceFileFunc(ttidNotifySink);

    Assert(pPropsEx);
    Assert(!m_pidlFolder.empty());

#ifdef DBG
    OLECHAR szGuidString[MAX_GUID_STRING_LEN];
    StringFromGUID2(pPropsEx->guidId, szGuidString, MAX_GUID_STRING_LEN);
    TraceTag(ttidNotifySink, "INetConnectionNotifySink::ConnectionModified - %S %S [%s:%s:%s:%s]", szGuidString, pPropsEx->bstrName, 
        DbgNcm(pPropsEx->ncMediaType), DbgNcsm(pPropsEx->ncSubMediaType), DbgNcs(pPropsEx->ncStatus), DbgNccf(pPropsEx->dwCharacter));
#endif

    if (g_dwCurrentEventLevel <= EVT_LVL_ENABLE_PRIVATE)
    {
        TraceTag(ttidNotifySink, "Last event ignored due to g_dwCurrentEventLevel == %d", g_dwCurrentEventLevel);
        return S_FALSE;
    }

    // Get the result for debugging only. We never want to fail this function
    //
    HRESULT hrTmp = HrOnNotifyUpdateConnection(
            m_pidlFolder,
            (GUID *)&(pPropsEx->guidId),
            pPropsEx->ncMediaType,
            pPropsEx->ncSubMediaType,
            pPropsEx->ncStatus,
            pPropsEx->dwCharacter,
            pPropsEx->bstrName,
            pPropsEx->bstrDeviceName,
            pPropsEx->bstrPhoneOrHostAddress);

    return S_OK;
}


HRESULT
CConnectionNotifySink::ConnectionRenamed (
    IN const GUID* pguidId,
    IN PCWSTR     pszwNewName)
{
    TraceFileFunc(ttidNotifySink);

    HRESULT         hr      = S_OK;
    PCONFOLDPIDL    pidlNew;

    Assert(pguidId);
    Assert(pszwNewName);

    if (g_dwCurrentEventLevel <= EVT_LVL_DISABLE_ALL)
    {
        TraceTag(ttidNotifySink, "CConnectionNotifySink::ConnectionRenamed event ignored due to g_dwCurrentEventLevel == %d", g_dwCurrentEventLevel);
        return S_FALSE;
    }

    // Update the name in the cache
    //

    //  Note: There exists a race condition with shutil.cpp:
    //  HrRenameConnectionInternal\HrUpdateNameByGuid can also update the cache.
    ConnListEntry cle;
    hr = g_ccl.HrFindConnectionByGuid(pguidId, cle);
    if (FAILED(hr))
    {
        return E_INVALIDARG;
    }
#ifdef DBG
    OLECHAR szGuidString[MAX_GUID_STRING_LEN];
    StringFromGUID2(cle.ccfe.GetGuidID(), szGuidString, MAX_GUID_STRING_LEN);
    TraceTag(ttidNotifySink, "INetConnectionNotifySink::ConnectionRenamed - %S %S (to %S) [%s:%s:%s:%s]", szGuidString, cle.ccfe.GetName(), pszwNewName, 
        DbgNcm(cle.ccfe.GetNetConMediaType()), DbgNcsm(cle.ccfe.GetNetConSubMediaType()), DbgNcs(cle.ccfe.GetNetConStatus()), DbgNccf(cle.ccfe.GetCharacteristics()));
#endif

    hr = g_ccl.HrUpdateNameByGuid(
        (GUID *) pguidId,
        (PWSTR) pszwNewName,
        pidlNew,
        TRUE);  // Force the update -- this is a notification, not a request

    if (S_OK == hr)
    {
        PCONFOLDPIDL pidl;
        cle.ccfe.ConvertToPidl(pidl);

        GenerateEvent(
            SHCNE_RENAMEITEM,
            m_pidlFolder,
            pidl, 
            pidlNew.GetItemIdList());

        // Update status monitor title (RAS case)
        CNetStatisticsCentral * pnsc = NULL;

        hr = CNetStatisticsCentral::HrGetNetStatisticsCentral(&pnsc, FALSE);
        if (SUCCEEDED(hr))
        {
            pnsc->UpdateTitle(pguidId, pszwNewName);
            ReleaseObj(pnsc);
        }
    }
    else
    {
        // If the connection wasn't found in the cache, then it's likely that
        // the notification engine is giving us a notification for a connection
        // that hasn't yet been given to us.
        //
        if (S_FALSE == hr)
        {
            TraceHr(ttidShellFolder, FAL, hr, FALSE, "Rename notification received on a connection we don't know about");
        }
    }

    return S_OK;
}

HRESULT
CConnectionNotifySink::ConnectionStatusChange (
    IN const GUID*     pguidId,
    IN NETCON_STATUS   Status)
{
    TraceFileFunc(ttidNotifySink);

    HRESULT         hr          = S_OK;
    HRESULT         hrFind      = S_OK;
    PCONFOLDPIDL    pidlFind;

    if (g_dwCurrentEventLevel <= EVT_LVL_ENABLE_PRIVATE)
    {
        TraceTag(ttidNotifySink, "CConnectionNotifySink::ConnectionStatusChange event ignored due to g_dwCurrentEventLevel == %d", g_dwCurrentEventLevel);
        return S_FALSE;
    }
    
    // Find the connection using the GUID. Cast the const away from the GUID
    //
    hrFind = g_ccl.HrFindPidlByGuid((GUID *) pguidId, pidlFind);

    if( S_OK != hrFind )
    {   
        GUID guidOwner;

        // We did not find the guid in connection folder. Try finding the connection in the 
        // hidden connectiod list on netmans side.
        //
        hr = g_ccl.HrMapCMHiddenConnectionToOwner(*pguidId, &guidOwner);
        if (S_OK == hr)
        {
            // The conection has a parent!!!! Use the childs status instead of the parents status.
            //
            if (Status == NCS_CONNECTED)
            {
                // This means that the child has connected and the parent still has to connect
                // the overall status should stay as connected. This was done to overrule the Multi-link
                // hack in HrOnNotifyUpdateStatus. If we did not do this it would say :
                // Child( Connecting, Connected) and then Parent(Connecting, Connected)
                //
                Status = NCS_CONNECTING;
            }

            // Get the pidl of the parent.
            //
            hrFind = g_ccl.HrFindPidlByGuid(&guidOwner, pidlFind);
        }
    }

    if (S_OK == hrFind)
    {
#ifdef DBG
    OLECHAR szGuidString[MAX_GUID_STRING_LEN];
    StringFromGUID2(pidlFind->guidId, szGuidString, MAX_GUID_STRING_LEN);
    TraceTag(ttidNotifySink, "INetConnectionNotifySink::ConnectionStatusChange - %S %S [%s:%s:%s:%s]", szGuidString, pidlFind->PszGetNamePointer(), 
        DbgNcm(pidlFind->ncm), DbgNcsm(pidlFind->ncsm), DbgNcs(Status), DbgNccf(pidlFind->dwCharacteristics));
#endif
        hr = HrOnNotifyUpdateStatus(m_pidlFolder, pidlFind, Status);
    }

    return S_OK;
}

HRESULT
CConnectionNotifySink::RefreshAll ()
{
    TraceFileFunc(ttidNotifySink);

#ifdef DBG
    TraceTag(ttidNotifySink, "INetConnectionNotifySink::RefreshAll");
#endif
    
    if (g_dwCurrentEventLevel <= EVT_LVL_DISABLE_ALL)
    {
        TraceTag(ttidNotifySink, "Last event ignored due to g_dwCurrentEventLevel == %d", g_dwCurrentEventLevel);
        return S_FALSE;
    }

    // Refresh the connections folder, without having to hook the shell view.
    // In this case, we do a non-flush refresh where we compare the new set
    // of items to the cached set and do the merge (with the correct set
    // of individual notifications).
    //
    (VOID) HrForceRefreshNoFlush(m_pidlFolder);

    return S_OK;
}

HRESULT CConnectionNotifySink::ConnectionAddressChange (
    IN const GUID* pguidId )
{
    // Find the connection using the GUID.
    //
    PCONFOLDPIDL pidlFind;
    HRESULT hr = g_ccl.HrFindPidlByGuid(pguidId, pidlFind);
    if (S_OK != hr)
    {
        return E_INVALIDARG;
    }

#ifdef DBG
    OLECHAR szGuidString[MAX_GUID_STRING_LEN];
    StringFromGUID2(pidlFind->guidId, szGuidString, MAX_GUID_STRING_LEN);
    TraceTag(ttidNotifySink, "INetConnectionNotifySink::ConnectionAddressChange - %S %S [%s:%s:%s:%s]", szGuidString, pidlFind->PszGetNamePointer(),
        DbgNcm(pidlFind->ncm), DbgNcsm(pidlFind->ncsm), DbgNcs(pidlFind->ncs), DbgNccf(pidlFind->dwCharacteristics));

#endif
    if (g_dwCurrentEventLevel <= EVT_LVL_DISABLE_ALL)
    {
        TraceTag(ttidNotifySink, "Last event ignored due to g_dwCurrentEventLevel == %d", g_dwCurrentEventLevel);
        return S_FALSE;
    }

    PCONFOLDPIDLFOLDER pidlFolder;
    hr = HrGetConnectionsFolderPidl(pidlFolder);
    if (SUCCEEDED(hr))
    {
        GenerateEvent(SHCNE_UPDATEITEM, pidlFolder, pidlFind, NULL);
    }
    
    return hr;
}

DWORD WINAPI OnTaskBarIconBalloonClickThread(IN LPVOID lpParam);

STDMETHODIMP CConnectionNotifySink::ShowBalloon(
                IN const GUID* pguidId, 
                IN const BSTR  szCookie, 
                IN const BSTR  szBalloonText)
{
    HRESULT hr;

#ifdef DBG
    OLECHAR szGuidString[MAX_GUID_STRING_LEN];
    StringFromGUID2(*pguidId, szGuidString, MAX_GUID_STRING_LEN);
    TraceTag(ttidNotifySink, "INetConnectionNotifySink::ShowBalloon - %S (%S)", szGuidString, szBalloonText);
#endif
    
    if (g_dwCurrentEventLevel <= EVT_LVL_DISABLE_ALL)
    {
        TraceTag(ttidNotifySink, "Last event ignored due to g_dwCurrentEventLevel == %d", g_dwCurrentEventLevel);
        return S_FALSE;
    }

    CComBSTR szBalloonTextTmp = szBalloonText;
    BSTR szCookieTmp = NULL;

    if (szCookie)
    {
        szCookieTmp = SysAllocStringByteLen(reinterpret_cast<LPCSTR>(szCookie), SysStringByteLen(szCookie));

        if (szCookieTmp)
        {
            ConnListEntry cleFind;
            hr = g_ccl.HrFindConnectionByGuid(pguidId, cleFind);
            if (S_OK == hr)
            {
                hr = WZCCanShowBalloon(pguidId, cleFind.ccfe.GetName(), &szBalloonTextTmp, &szCookieTmp);
                if ( (S_OK == hr) || (S_OBJECT_NO_LONGER_VALID == hr) )
                {
                    CTrayBalloon *pTrayBalloon = new CTrayBalloon();
                    if (!pTrayBalloon)
                    {
                        hr = E_OUTOFMEMORY;
                    }
                    else
                    {
                        pTrayBalloon->m_gdGuid    = *pguidId;
                        pTrayBalloon->m_dwTimeOut = 30 * 1000;
                        pTrayBalloon->m_szMessage = szBalloonTextTmp;
                        pTrayBalloon->m_pfnFuncCallback = WZCOnBalloonClick;
                        pTrayBalloon->m_szCookie  = szCookieTmp;
                        pTrayBalloon->m_szAdapterName = cleFind.ccfe.GetName();

                        if (S_OK == hr)
                        {
                            PostMessage(g_hwndTray, MYWM_SHOWBALLOON, 
                                NULL, 
                                (LPARAM) pTrayBalloon);
                        }
                        else // S_OBJECT_NO_LONGER_VALID == hr
                        {
                            CreateThread(NULL, STACK_SIZE_SMALL, OnTaskBarIconBalloonClickThread, pTrayBalloon, 0, NULL);
                        }
                    }
                }
            }
            if (S_OK != hr && S_OBJECT_NO_LONGER_VALID != hr)
            {
                SysFreeString(szCookieTmp);
            }
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE,
        "CConnectionNotifySink::ShowBalloon");

    return hr;
}

UINT_PTR uipTimer = NULL;

VOID CALLBACK EventTimerProc(
  IN HWND hwnd,         // handle to window
  IN UINT uMsg,         // WM_TIMER message
  IN UINT_PTR idEvent,  // timer identifier
  IN DWORD dwTime       // current system time
)
{
    HRESULT hr = S_OK;
    TraceTag(ttidNotifySink, "Refreshing the folder due to DisableEvents timeout reached");

    g_dwCurrentEventLevel = EVT_LVL_ENABLE_ALL;
    if (uipTimer)
    {
        KillTimer(NULL, uipTimer);
        uipTimer = NULL;
    }
    
    PCONFOLDPIDLFOLDER pcfpFolder;
    hr = HrGetConnectionsFolderPidl(pcfpFolder);
    if (SUCCEEDED(hr))
    {
        HrForceRefreshNoFlush(pcfpFolder);
    }
}

STDMETHODIMP CConnectionNotifySink::DisableEvents (
        IN const BOOL  fDisable,
        IN const ULONG ulDisableTimeout)
{
#ifdef DBG
    TraceTag(ttidNotifySink, "INetConnectionNotifySink::DisableEvents - %s 0x%08x", fDisable ? "DISABLE" : "ENABLE", ulDisableTimeout);
#endif
    HRESULT hr = S_OK;

    if (fDisable)
    {
        if (HIWORD(ulDisableTimeout) & 0x8000)
        {
            // Called from private interface - disable all the events
            g_dwCurrentEventLevel = EVT_LVL_DISABLE_ALL;
        }
        else
        {
            // Called from public interface - only disable connection modified & status change events
            g_dwCurrentEventLevel = EVT_LVL_ENABLE_PRIVATE;
        }

        UINT uiEventTimeOut = LOWORD(ulDisableTimeout);
        if (uipTimer)
        {
            KillTimer(NULL, uipTimer);
            uipTimer = NULL;
        }

        uipTimer = SetTimer(NULL, NULL, uiEventTimeOut, EventTimerProc);
    }
    else
    {
        g_dwCurrentEventLevel = EVT_LVL_ENABLE_ALL;

        if (uipTimer)
        {
            KillTimer(NULL, uipTimer);
            uipTimer = NULL;
        }
        else
        {
            hr = S_FALSE; // Timer no more.
        }

        HrForceRefreshNoFlush(m_pidlFolder);
    }
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrGetNotifyConPoint
//
//  Purpose:    Common code for getting the connection point for use in
//              NotifyAdd and NotifyRemove
//
//  Arguments:
//      ppConPoint [out]    Return ptr for IConnectionPoint
//
//  Returns:
//
//  Author:     jeffspr   24 Aug 1998
//
//  Notes:
//
HRESULT HrGetNotifyConPoint(
    IConnectionPoint **             ppConPoint)
{
    TraceFileFunc(ttidNotifySink);

    HRESULT                     hr          = S_OK;
    IConnectionPointContainer * pContainer  = NULL;

    Assert(ppConPoint);

    // Get the debug interface from the connection manager
    //
    hr = HrCreateInstance(
        CLSID_ConnectionManager,
        CLSCTX_LOCAL_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
        &pContainer);

    TraceHr(ttidError, FAL, hr, FALSE,
        "HrCreateInstance(CLSID_ConnectionManager) for IConnectionPointContainer");

    if (SUCCEEDED(hr))
    {
        IConnectionPoint * pConPoint    = NULL;
        
        // Get the connection point itself and fill in the return param
        // on success
        //
        hr = pContainer->FindConnectionPoint(
                IID_INetConnectionNotifySink,
                &pConPoint);

        TraceHr(ttidError, FAL, hr, FALSE, "pContainer->FindConnectionPoint");

        if (SUCCEEDED(hr))
        {
            NcSetProxyBlanket (pConPoint);
            *ppConPoint = pConPoint;
        }

        ReleaseObj(pContainer);
    }

    TraceHr(ttidError, FAL, hr, FALSE, "HrGetNotifyConPoint");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\shell\folder\legacymenus.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       L E G A C Y M E N U S . C P P
//
//  Contents:   Legacy menu implementation for debug purposes
//              This is used to double check the new command handler
//              implementation against the new one.
//
//              Most of the code from the previous cmdhandler.cpp has been
//              moved to this file.
//
//  Notes:
//
//  Author:     deonb   8 Feb 2001
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#ifdef DBG // Make sure this is not called in release mode.

#include "foldinc.h"    // Standard shell\folder includes
#include "foldres.h"    // Folder resource IDs
#include "nsres.h"
#include "cmdtable.h"
#include "ncperms.h"    // For checking User's rights on actions/menu items
#include "cfutils.h"
#include "oncommand.h"
#include "hnetcfg.h"
#include "legacymenus.h"
#include "nsclsid.h"

#define TRACESTRLEN 65535

//---[ Prototypes ]-----------------------------------------------------------

VOID DoMenuItemExceptionLoop(
                             const PCONFOLDPIDLVEC& apidlSelected);

VOID DoMenuItemCheckLoop(VOID);

bool FEnableConnectDisconnectMenuItem(
                                      const PCONFOLDPIDL& pcfp,
                                      int             iCommandId);

HRESULT HrEnableOrDisableMenuItems(
    HWND            hwnd,
    const PCONFOLDPIDLVEC& apidlSelected,
    HMENU           hmenu,
    UINT            idCmdFirst);

BOOL IsBridgeInstalled(
    VOID);

struct ContextMenuEntry
{
    WIZARD              wizWizard;
    NETCON_MEDIATYPE    ncm;
    BOOL                fInbound;
    BOOL                fIsDefault;     // 1 if currently the default. 0 otherwise.
    NETCON_STATUS       ncs;
    INT                 iMenu;
    INT                 iVerbMenu;      // This flag is set if the context menu is for a shortcut object.
    INT                 iDefaultCmd;
};

static const ContextMenuEntry   c_CMEArray[] =
{
   //wizWizard
   // |    ncm
   // |    |       fInbound?
   // |    |         | fIsDefault?
   // |    |         |  |      Status (ncs)
   // |    |         |  |        |                     iMenu
   // |    |         |  |        |                      |                  iVerbMenu
   // |    |         |  |        |                      |                      |                  iDefaultCmd
   // |    |         |  |        |                      |                      |                      |
   // v    v         v  v        v                      v                      v                      v
  // wizard
    { WIZARD_MNC, NCM_NONE,   0, 0, (NETCON_STATUS)0,         MENU_WIZARD,       MENU_WIZARD_V,       CMIDM_NEW_CONNECTION },

  // incoming w/ no clients
    { WIZARD_NOT_WIZARD, NCM_NONE,   1, 0, NCS_DISCONNECTED,         MENU_INCOM_DISCON, MENU_INCOM_DISCON_V, CMIDM_PROPERTIES     },

  // Note: Temporary hack for CM connections
// DEONB: ISSUE: Removing hack for CM connections. This doesn't appear to be used anymore.
//    { WIZARD_NOT_WIZARD, NCM_NONE,   0, 0, NCS_DISCONNECTED,         MENU_DIAL_DISCON,  MENU_DIAL_DISCON_V,  CMIDM_CONNECT        },
//    { WIZARD_NOT_WIZARD, NCM_NONE,   0, 0, NCS_CONNECTED,            MENU_DIAL_CON,     MENU_DIAL_CON_V,     CMIDM_STATUS         },
//    { WIZARD_NOT_WIZARD, NCM_NONE,   0, 0, NCS_HARDWARE_NOT_PRESENT, MENU_DIAL_UNAVAIL, MENU_DIAL_UNAVAIL_V, CMIDM_PROPERTIES     },
//    { WIZARD_NOT_WIZARD, NCM_NONE,   0, 0, NCS_HARDWARE_MALFUNCTION, MENU_DIAL_UNAVAIL, MENU_DIAL_UNAVAIL_V, CMIDM_PROPERTIES     },
//    { WIZARD_NOT_WIZARD, NCM_NONE,   0, 0, NCS_HARDWARE_DISABLED,    MENU_DIAL_UNAVAIL, MENU_DIAL_UNAVAIL_V, CMIDM_PROPERTIES     },
//    { WIZARD_NOT_WIZARD, NCM_NONE,   0, 1, NCS_CONNECTED,            MENU_DIAL_CON_UNSET,MENU_DIAL_CON_V,    CMIDM_STATUS         },
//    { WIZARD_NOT_WIZARD, NCM_NONE,   0, 1, NCS_HARDWARE_NOT_PRESENT, MENU_DIAL_UNAVAIL_UNSET,MENU_DIAL_UNAVAIL_V, CMIDM_PROPERTIES},
//    { WIZARD_NOT_WIZARD, NCM_NONE,   0, 1, NCS_HARDWARE_MALFUNCTION, MENU_DIAL_UNAVAIL_UNSET,MENU_DIAL_UNAVAIL_V, CMIDM_PROPERTIES},
//    { WIZARD_NOT_WIZARD, NCM_NONE,   0, 1, NCS_HARDWARE_DISABLED,    MENU_DIAL_UNAVAIL_UNSET,MENU_DIAL_UNAVAIL_V, CMIDM_PROPERTIES},

  // lan
    { WIZARD_NOT_WIZARD, NCM_LAN,    0, 0, NCS_DISCONNECTED,         MENU_LAN_DISCON   ,MENU_LAN_DISCON_V,CMIDM_ENABLE            },
    { WIZARD_NOT_WIZARD, NCM_LAN,    0, 0, NCS_CONNECTED,            MENU_LAN_CON,      MENU_LAN_CON_V,      CMIDM_STATUS         },
    { WIZARD_NOT_WIZARD, NCM_LAN,    0, 0, NCS_DISCONNECTING,        MENU_LAN_CON,      MENU_LAN_CON_V,      CMIDM_STATUS         },
// DEONB: ISSUE: What on earth is an incoming LAN card???
//  { WIZARD_NOT_WIZARD, NCM_LAN,    1, 0, NCS_CONNECTED,            MENU_LAN_CON,      MENU_INCOM_CON_V,    CMIDM_STATUS         },
//  { WIZARD_NOT_WIZARD, NCM_LAN,    1, 0, NCS_DISCONNECTING,        MENU_LAN_CON,      MENU_INCOM_CON_V,    CMIDM_STATUS         },
    { WIZARD_NOT_WIZARD, NCM_LAN,    0, 0, NCS_MEDIA_DISCONNECTED,   MENU_LAN_CON,      MENU_LAN_CON_V,      CMIDM_PROPERTIES     },
    { WIZARD_NOT_WIZARD, NCM_LAN,    0, 0, NCS_INVALID_ADDRESS,      MENU_LAN_CON,      MENU_LAN_CON_V,      CMIDM_STATUS         },
    { WIZARD_NOT_WIZARD, NCM_LAN,    0, 0, NCS_HARDWARE_NOT_PRESENT, MENU_LAN_UNAVAIL,  MENU_LAN_UNAVAIL_V,  CMIDM_PROPERTIES     },
    { WIZARD_NOT_WIZARD, NCM_LAN,    0, 0, NCS_HARDWARE_MALFUNCTION, MENU_LAN_UNAVAIL,  MENU_LAN_UNAVAIL_V,  CMIDM_PROPERTIES     },
    { WIZARD_NOT_WIZARD, NCM_LAN,    0, 0, NCS_HARDWARE_DISABLED,    MENU_LAN_UNAVAIL,  MENU_LAN_UNAVAIL_V,  CMIDM_PROPERTIES     },

  // dialup
    { WIZARD_NOT_WIZARD, NCM_PHONE,  0, 0, NCS_DISCONNECTED,         MENU_DIAL_DISCON,  MENU_DIAL_DISCON_V,  CMIDM_CONNECT        },
    { WIZARD_NOT_WIZARD, NCM_PHONE,  0, 0, NCS_CONNECTING,           MENU_DIAL_DISCON,  MENU_DIAL_DISCON_V,  CMIDM_CONNECT        },
    { WIZARD_NOT_WIZARD, NCM_PHONE,  0, 0, NCS_CONNECTED,            MENU_DIAL_CON,     MENU_DIAL_CON_V,     CMIDM_STATUS         },
    { WIZARD_NOT_WIZARD, NCM_PHONE,  0, 0, NCS_DISCONNECTING,        MENU_DIAL_CON,     MENU_DIAL_CON_V,     CMIDM_STATUS         },
    { WIZARD_NOT_WIZARD, NCM_PHONE,  0, 0, NCS_HARDWARE_NOT_PRESENT, MENU_DIAL_UNAVAIL, MENU_DIAL_UNAVAIL_V, CMIDM_PROPERTIES     },
    { WIZARD_NOT_WIZARD, NCM_PHONE,  0, 0, NCS_HARDWARE_MALFUNCTION, MENU_DIAL_UNAVAIL, MENU_DIAL_UNAVAIL_V, CMIDM_PROPERTIES     },
    { WIZARD_NOT_WIZARD, NCM_PHONE,  0, 0, NCS_HARDWARE_DISABLED,    MENU_DIAL_UNAVAIL, MENU_DIAL_UNAVAIL_V, CMIDM_PROPERTIES     },

    { WIZARD_NOT_WIZARD, NCM_PHONE,  0, 1, NCS_DISCONNECTED,         MENU_DIAL_DISCON_UNSET,MENU_DIAL_DISCON_V,  CMIDM_CONNECT    },
    { WIZARD_NOT_WIZARD, NCM_PHONE,  0, 1, NCS_CONNECTING,           MENU_DIAL_DISCON_UNSET,MENU_DIAL_DISCON_V,  CMIDM_CONNECT    },
    { WIZARD_NOT_WIZARD, NCM_PHONE,  0, 1, NCS_CONNECTED,            MENU_DIAL_CON_UNSET,MENU_DIAL_CON_V,     CMIDM_STATUS        },
    { WIZARD_NOT_WIZARD, NCM_PHONE,  0, 1, NCS_DISCONNECTING,        MENU_DIAL_CON_UNSET,MENU_DIAL_CON_V,     CMIDM_STATUS        },
    { WIZARD_NOT_WIZARD, NCM_PHONE,  0, 1, NCS_HARDWARE_NOT_PRESENT, MENU_DIAL_UNAVAIL_UNSET,MENU_DIAL_UNAVAIL_V, CMIDM_PROPERTIES},
    { WIZARD_NOT_WIZARD, NCM_PHONE,  0, 1, NCS_HARDWARE_MALFUNCTION, MENU_DIAL_UNAVAIL_UNSET,MENU_DIAL_UNAVAIL_V, CMIDM_PROPERTIES},
    { WIZARD_NOT_WIZARD, NCM_PHONE,  0, 1, NCS_HARDWARE_DISABLED,    MENU_DIAL_UNAVAIL_UNSET,MENU_DIAL_UNAVAIL_V, CMIDM_PROPERTIES},

  // dialup inbound
    { WIZARD_NOT_WIZARD, NCM_PHONE,  1, 0, NCS_CONNECTED,            MENU_INCOM_CON,    MENU_INCOM_CON_V,    CMIDM_STATUS         },
    { WIZARD_NOT_WIZARD, NCM_PHONE,  1, 0, NCS_DISCONNECTING,        MENU_INCOM_CON,    MENU_INCOM_CON_V,    CMIDM_STATUS         },

  // isdn
    { WIZARD_NOT_WIZARD, NCM_ISDN,   0, 0, NCS_DISCONNECTED,         MENU_DIAL_DISCON,  MENU_DIAL_DISCON_V,  CMIDM_CONNECT        },
    { WIZARD_NOT_WIZARD, NCM_ISDN,   0, 0, NCS_CONNECTING,           MENU_DIAL_DISCON,  MENU_DIAL_DISCON_V,  CMIDM_CONNECT        },
    { WIZARD_NOT_WIZARD, NCM_ISDN,   0, 0, NCS_CONNECTED,            MENU_DIAL_CON,     MENU_DIAL_CON_V,     CMIDM_STATUS         },
    { WIZARD_NOT_WIZARD, NCM_ISDN,   0, 0, NCS_DISCONNECTING,        MENU_DIAL_CON,     MENU_DIAL_CON_V,     CMIDM_STATUS         },
    { WIZARD_NOT_WIZARD, NCM_ISDN,   1, 0, NCS_CONNECTED,            MENU_INCOM_CON,    MENU_INCOM_CON_V,    CMIDM_STATUS         },
    { WIZARD_NOT_WIZARD, NCM_ISDN,   1, 0, NCS_DISCONNECTING,        MENU_INCOM_CON,    MENU_INCOM_CON_V,    CMIDM_STATUS         },
    { WIZARD_NOT_WIZARD, NCM_ISDN,   0, 0, NCS_HARDWARE_NOT_PRESENT, MENU_DIAL_UNAVAIL, MENU_DIAL_UNAVAIL_V, CMIDM_PROPERTIES     },
    { WIZARD_NOT_WIZARD, NCM_ISDN,   0, 0, NCS_HARDWARE_MALFUNCTION, MENU_DIAL_UNAVAIL, MENU_DIAL_UNAVAIL_V, CMIDM_PROPERTIES     },
    { WIZARD_NOT_WIZARD, NCM_ISDN,   0, 0, NCS_HARDWARE_DISABLED,    MENU_DIAL_UNAVAIL, MENU_DIAL_UNAVAIL_V, CMIDM_PROPERTIES     },

    { WIZARD_NOT_WIZARD, NCM_ISDN,   0, 1, NCS_DISCONNECTED,         MENU_DIAL_DISCON_UNSET,MENU_DIAL_DISCON_V,  CMIDM_CONNECT    },
    { WIZARD_NOT_WIZARD, NCM_ISDN,   0, 1, NCS_CONNECTING,           MENU_DIAL_DISCON_UNSET,MENU_DIAL_DISCON_V,  CMIDM_CONNECT    },
    { WIZARD_NOT_WIZARD, NCM_ISDN,   0, 1, NCS_CONNECTED,            MENU_DIAL_CON_UNSET,MENU_DIAL_CON_V,     CMIDM_STATUS        },
    { WIZARD_NOT_WIZARD, NCM_ISDN,   0, 1, NCS_DISCONNECTING,        MENU_DIAL_CON_UNSET,MENU_DIAL_CON_V,     CMIDM_STATUS        },
    { WIZARD_NOT_WIZARD, NCM_ISDN,   0, 1, NCS_HARDWARE_NOT_PRESENT, MENU_DIAL_UNAVAIL_UNSET,MENU_DIAL_UNAVAIL_V, CMIDM_PROPERTIES},
    { WIZARD_NOT_WIZARD, NCM_ISDN,   0, 1, NCS_HARDWARE_MALFUNCTION, MENU_DIAL_UNAVAIL_UNSET,MENU_DIAL_UNAVAIL_V, CMIDM_PROPERTIES},
    { WIZARD_NOT_WIZARD, NCM_ISDN,   0, 1, NCS_HARDWARE_DISABLED,    MENU_DIAL_UNAVAIL_UNSET,MENU_DIAL_UNAVAIL_V, CMIDM_PROPERTIES},

  // tunnel
    { WIZARD_NOT_WIZARD, NCM_TUNNEL, 0, 0, NCS_DISCONNECTED,         MENU_DIAL_DISCON,  MENU_DIAL_DISCON_V,  CMIDM_CONNECT        },
    { WIZARD_NOT_WIZARD, NCM_TUNNEL, 0, 0, NCS_CONNECTING,           MENU_DIAL_DISCON,  MENU_DIAL_DISCON_V,  CMIDM_CONNECT        },
    { WIZARD_NOT_WIZARD, NCM_TUNNEL, 0, 0, NCS_CONNECTED,            MENU_DIAL_CON,     MENU_DIAL_CON_V,     CMIDM_STATUS         },
    { WIZARD_NOT_WIZARD, NCM_TUNNEL, 0, 0, NCS_DISCONNECTING,        MENU_DIAL_CON,     MENU_DIAL_CON_V,     CMIDM_STATUS         },
    { WIZARD_NOT_WIZARD, NCM_TUNNEL, 1, 0, NCS_CONNECTED,            MENU_INCOM_CON,    MENU_INCOM_CON_V,    CMIDM_STATUS         },
    { WIZARD_NOT_WIZARD, NCM_TUNNEL, 1, 0, NCS_DISCONNECTING,        MENU_INCOM_CON,    MENU_INCOM_CON_V,    CMIDM_STATUS         },
    { WIZARD_NOT_WIZARD, NCM_TUNNEL, 0, 0, NCS_HARDWARE_NOT_PRESENT, MENU_DIAL_UNAVAIL, MENU_DIAL_UNAVAIL_V, CMIDM_PROPERTIES     },
    { WIZARD_NOT_WIZARD, NCM_TUNNEL, 0, 0, NCS_HARDWARE_MALFUNCTION, MENU_DIAL_UNAVAIL, MENU_DIAL_UNAVAIL_V, CMIDM_PROPERTIES     },
    { WIZARD_NOT_WIZARD, NCM_TUNNEL, 0, 0, NCS_HARDWARE_DISABLED,    MENU_DIAL_UNAVAIL, MENU_DIAL_UNAVAIL_V, CMIDM_PROPERTIES     },

    { WIZARD_NOT_WIZARD, NCM_TUNNEL, 0, 1, NCS_DISCONNECTED,         MENU_DIAL_DISCON_UNSET,MENU_DIAL_DISCON_V,  CMIDM_CONNECT    },
    { WIZARD_NOT_WIZARD, NCM_TUNNEL, 0, 1, NCS_CONNECTING,           MENU_DIAL_DISCON_UNSET,MENU_DIAL_DISCON_V,  CMIDM_CONNECT    },
    { WIZARD_NOT_WIZARD, NCM_TUNNEL, 0, 1, NCS_CONNECTED,            MENU_DIAL_CON_UNSET,MENU_DIAL_CON_V,     CMIDM_STATUS        },
    { WIZARD_NOT_WIZARD, NCM_TUNNEL, 0, 1, NCS_DISCONNECTING,        MENU_DIAL_CON_UNSET,MENU_DIAL_CON_V,     CMIDM_STATUS        },
    { WIZARD_NOT_WIZARD, NCM_TUNNEL, 0, 1, NCS_HARDWARE_NOT_PRESENT, MENU_DIAL_UNAVAIL_UNSET,MENU_DIAL_UNAVAIL_V, CMIDM_PROPERTIES},
    { WIZARD_NOT_WIZARD, NCM_TUNNEL, 0, 1, NCS_HARDWARE_MALFUNCTION, MENU_DIAL_UNAVAIL_UNSET,MENU_DIAL_UNAVAIL_V, CMIDM_PROPERTIES},
    { WIZARD_NOT_WIZARD, NCM_TUNNEL, 0, 1, NCS_HARDWARE_DISABLED,    MENU_DIAL_UNAVAIL_UNSET,MENU_DIAL_UNAVAIL_V, CMIDM_PROPERTIES},

  // direct connect
    { WIZARD_NOT_WIZARD, NCM_DIRECT, 0, 0, NCS_DISCONNECTED,         MENU_DIAL_DISCON,  MENU_DIAL_DISCON_V,  CMIDM_CONNECT        },
    { WIZARD_NOT_WIZARD, NCM_DIRECT, 0, 0, NCS_CONNECTING,           MENU_DIAL_DISCON,  MENU_DIAL_DISCON_V,  CMIDM_CONNECT        },
    { WIZARD_NOT_WIZARD, NCM_DIRECT, 0, 0, NCS_CONNECTED,            MENU_DIAL_CON,     MENU_DIAL_CON_V,     CMIDM_STATUS         },
    { WIZARD_NOT_WIZARD, NCM_DIRECT, 0, 0, NCS_DISCONNECTING,        MENU_DIAL_CON,     MENU_DIAL_CON_V,     CMIDM_STATUS         },
    { WIZARD_NOT_WIZARD, NCM_DIRECT, 1, 0, NCS_CONNECTED,            MENU_INCOM_CON,    MENU_INCOM_CON_V,    CMIDM_STATUS         },
    { WIZARD_NOT_WIZARD, NCM_DIRECT, 1, 0, NCS_DISCONNECTING,        MENU_INCOM_CON,    MENU_INCOM_CON_V,    CMIDM_STATUS         },
    { WIZARD_NOT_WIZARD, NCM_DIRECT, 0, 0, NCS_HARDWARE_NOT_PRESENT, MENU_DIAL_UNAVAIL, MENU_DIAL_UNAVAIL_V, CMIDM_PROPERTIES     },
    { WIZARD_NOT_WIZARD, NCM_DIRECT, 0, 0, NCS_HARDWARE_MALFUNCTION, MENU_DIAL_UNAVAIL, MENU_DIAL_UNAVAIL_V, CMIDM_PROPERTIES     },
    { WIZARD_NOT_WIZARD, NCM_DIRECT, 0, 0, NCS_HARDWARE_DISABLED,    MENU_DIAL_UNAVAIL, MENU_DIAL_UNAVAIL_V, CMIDM_PROPERTIES     },

    { WIZARD_NOT_WIZARD, NCM_DIRECT, 0, 1, NCS_DISCONNECTED,         MENU_DIAL_DISCON_UNSET,MENU_DIAL_DISCON_V,  CMIDM_CONNECT    },
    { WIZARD_NOT_WIZARD, NCM_DIRECT, 0, 1, NCS_CONNECTING,           MENU_DIAL_DISCON_UNSET,MENU_DIAL_DISCON_V,  CMIDM_CONNECT    },
    { WIZARD_NOT_WIZARD, NCM_DIRECT, 0, 1, NCS_CONNECTED,            MENU_DIAL_CON_UNSET,MENU_DIAL_CON_V,     CMIDM_STATUS        },
    { WIZARD_NOT_WIZARD, NCM_DIRECT, 0, 1, NCS_DISCONNECTING,        MENU_DIAL_CON_UNSET,MENU_DIAL_CON_V,     CMIDM_STATUS        },
    { WIZARD_NOT_WIZARD, NCM_DIRECT, 0, 1, NCS_HARDWARE_NOT_PRESENT, MENU_DIAL_UNAVAIL_UNSET,MENU_DIAL_UNAVAIL_V, CMIDM_PROPERTIES},
    { WIZARD_NOT_WIZARD, NCM_DIRECT, 0, 1, NCS_HARDWARE_MALFUNCTION, MENU_DIAL_UNAVAIL_UNSET,MENU_DIAL_UNAVAIL_V, CMIDM_PROPERTIES},
    { WIZARD_NOT_WIZARD, NCM_DIRECT, 0, 1, NCS_HARDWARE_DISABLED,    MENU_DIAL_UNAVAIL_UNSET,MENU_DIAL_UNAVAIL_V, CMIDM_PROPERTIES},

    // bridge - largely the same as lan
    { WIZARD_NOT_WIZARD, NCM_BRIDGE, 0, 0, NCS_DISCONNECTED,         MENU_LAN_DISCON,   MENU_LAN_DISCON_V,   CMIDM_ENABLE         },
    { WIZARD_NOT_WIZARD, NCM_BRIDGE, 0, 0, NCS_CONNECTING,           MENU_LAN_DISCON,   MENU_LAN_DISCON_V,   CMIDM_ENABLE         },
    { WIZARD_NOT_WIZARD, NCM_BRIDGE, 0, 0, NCS_CONNECTED,            MENU_LAN_CON,      MENU_LAN_CON_V,      CMIDM_STATUS         },
    { WIZARD_NOT_WIZARD, NCM_BRIDGE, 0, 0, NCS_DISCONNECTING,        MENU_LAN_CON,      MENU_LAN_CON_V,      CMIDM_STATUS         },
// DEONB: ISSUE: What on earth is an incoming bridge???
//  { WIZARD_NOT_WIZARD, NCM_BRIDGE, 1, 0, NCS_CONNECTED,            MENU_LAN_CON,      MENU_INCOM_CON_V,    CMIDM_STATUS         },
//  { WIZARD_NOT_WIZARD, NCM_BRIDGE, 1, 0, NCS_DISCONNECTING,        MENU_LAN_CON,      MENU_INCOM_CON_V,    CMIDM_STATUS         },

    { WIZARD_NOT_WIZARD, NCM_BRIDGE, 0, 0, NCS_MEDIA_DISCONNECTED,   MENU_LAN_CON,      MENU_LAN_CON_V,      CMIDM_PROPERTIES     },
    { WIZARD_NOT_WIZARD, NCM_BRIDGE, 0, 0, NCS_INVALID_ADDRESS,      MENU_LAN_CON,      MENU_LAN_CON_V,      CMIDM_STATUS         },
    { WIZARD_NOT_WIZARD, NCM_BRIDGE, 0, 0, NCS_HARDWARE_NOT_PRESENT, MENU_LAN_UNAVAIL,  MENU_LAN_UNAVAIL_V,  CMIDM_PROPERTIES     },
    { WIZARD_NOT_WIZARD, NCM_BRIDGE, 0, 0, NCS_HARDWARE_MALFUNCTION, MENU_LAN_UNAVAIL,  MENU_LAN_UNAVAIL_V,  CMIDM_PROPERTIES     },
    { WIZARD_NOT_WIZARD, NCM_BRIDGE, 0, 0, NCS_HARDWARE_DISABLED,    MENU_LAN_UNAVAIL,  MENU_LAN_UNAVAIL_V,  CMIDM_PROPERTIES     },

    { WIZARD_NOT_WIZARD, NCM_SHAREDACCESSHOST_RAS,  0, 0, NCS_DISCONNECTED,         MENU_SARAS_DISCON,  MENU_DIAL_DISCON_V,  CMIDM_CONNECT        },
    { WIZARD_NOT_WIZARD, NCM_SHAREDACCESSHOST_RAS,  0, 0, NCS_CONNECTING,           MENU_SARAS_DISCON,  MENU_DIAL_DISCON_V,  CMIDM_CONNECT        },
    { WIZARD_NOT_WIZARD, NCM_SHAREDACCESSHOST_RAS,  0, 0, NCS_CONNECTED,            MENU_SARAS_CON,     MENU_DIAL_CON_V,     CMIDM_STATUS         },
    { WIZARD_NOT_WIZARD, NCM_SHAREDACCESSHOST_RAS,  0, 0, NCS_DISCONNECTING,        MENU_SARAS_CON,     MENU_DIAL_CON_V,     CMIDM_STATUS         },
    { WIZARD_NOT_WIZARD, NCM_SHAREDACCESSHOST_RAS,  0, 0, NCS_HARDWARE_DISABLED,    MENU_SARAS_DISCON,  MENU_SARAS_DISCON, CMIDM_PROPERTIES       },

    { WIZARD_NOT_WIZARD, NCM_SHAREDACCESSHOST_LAN,    0, 0, NCS_DISCONNECTED,         MENU_SALAN_DISCON,   MENU_LAN_DISCON_V,   CMIDM_ENABLE      },
    { WIZARD_NOT_WIZARD, NCM_SHAREDACCESSHOST_LAN,    0, 0, NCS_CONNECTED,            MENU_SALAN_CON,      MENU_LAN_CON_V,      CMIDM_STATUS      },
    { WIZARD_NOT_WIZARD, NCM_SHAREDACCESSHOST_LAN,    0, 0, NCS_DISCONNECTING,        MENU_SALAN_CON,      MENU_LAN_CON_V,      CMIDM_STATUS      },
    { WIZARD_NOT_WIZARD, NCM_SHAREDACCESSHOST_LAN,    0, 0, NCS_HARDWARE_DISABLED,    MENU_SALAN_DISCON,   MENU_SALAN_DISCON,  CMIDM_PROPERTIES   },

};

const DWORD g_dwContextMenuEntryCount = celems(c_CMEArray);

COMMANDTABLEENTRY   g_cteFolderCommands[] =
{
    // command id
    //    |                           valid when 0 items selected
    //    |                             |   valid when only wizard selected
    //    |                             |       |      valid when multiple items selected
    //    |                             |       |       |       command is currently enabled
    //    |                             |       |       |        |      new state (temp)
    //    |                             |       |       |        |       |
    //    |                             |       |       |        |       |
    //    |                             |       |       |        |       |
    //    |                             |       |       |        |       |
    //    v                             v       v       v        v       v
    //
    { CMIDM_NEW_CONNECTION,             true,   true,   true,   true,   true     },
    { CMIDM_CONNECT,                    false,  false,  false,  true,   true     },
    { CMIDM_ENABLE,                     false,  false,  false,  true,   true     },
    { CMIDM_DISCONNECT,                 false,  false,  false,  true,   true     },
    { CMIDM_DISABLE,                    false,  false,  false,  true,   true     },
    { CMIDM_STATUS,                     false,  false,  false,  true,   true     },
    { CMIDM_CREATE_BRIDGE,              true,   false,  true,   true,   true     },
    { CMIDM_ADD_TO_BRIDGE,              false,  false,  true,   true,   true     },
    { CMIDM_REMOVE_FROM_BRIDGE,         false,  false,  true,   true,   true     },
    { CMIDM_CREATE_SHORTCUT,            false,  true,   false,  true,   true     },
    { SFVIDM_FILE_LINK,                 false,  true,   false,  true,   true     },
    { CMIDM_DELETE,                     false,  false,  true,   true,   true     },
    { SFVIDM_FILE_DELETE,               false,  false,  true,   true,   true     },
    { CMIDM_RENAME,                     false,  false,  false,  true,   true     },
    { CMIDM_PROPERTIES,                 false,  false,  false,  true,   true     },
    { SFVIDM_FILE_PROPERTIES,           false,  false,  false,  true,   true     },
    { CMIDM_CREATE_COPY,                false,  false,  false,  true,   true     },
    { SFVIDM_FILE_RENAME,               false,  false,  false,  true,   true     },
    { CMIDM_SET_DEFAULT,                false,  false,  false,  true,   true     },
    { CMIDM_UNSET_DEFAULT,              false,  false,  false,  true,   true     },
    { CMIDM_FIX,                        false,  false,  false,  true,   true     },
    { CMIDM_CONMENU_ADVANCED_CONFIG,    true,   true,   false,  true,   true     },
    { CMIDM_CONMENU_CREATE_BRIDGE,      true,   false,  true,   true,   true     },
    { CMIDM_CONMENU_DIALUP_PREFS,       true,   true,   true,   true,   true     },
    { CMIDM_CONMENU_NETWORK_ID,         true,   true,   true,   true,   true     },
    { CMIDM_CONMENU_OPTIONALCOMPONENTS, true,   true,   true,   true,   true     },
    { CMIDM_CONMENU_OPERATOR_ASSIST,    true,   true,   true,   true,   true     },
    { CMIDM_ARRANGE_BY_NAME,            true,   true,   true,   true,   true     },
    { CMIDM_ARRANGE_BY_TYPE,            true,   true,   true,   true,   true     },
    { CMIDM_ARRANGE_BY_STATUS,          true,   true,   true,   true,   true     },
    { CMIDM_ARRANGE_BY_OWNER,           true,   true,   true,   true,   true     },
    { CMIDM_ARRANGE_BY_PHONEORHOSTADDRESS, true, true,  true,   true,   true,    },
    { CMIDM_ARRANGE_BY_DEVICE_NAME,     true,   true,   true,   true,   true     }
};

const DWORD g_nFolderCommandCount = celems(g_cteFolderCommands);

//+---------------------------------------------------------------------------
//
//  Member:     HrBuildMenuOldWay
//
//  Purpose:    Adds menu items to the specified menu. The menu items should
//              be inserted in the menu at the position specified by
//              indexMenu, and their menu item identifiers must be between
//              the idCmdFirst and idCmdLast parameter values.
//
//  Arguments:
//      hmenu      [in out] Handle to the menu. The handler should specify this
//                      handle when adding menu items
//      cfpl       [in] List of selected PIDLS
//      hwndOwner  [in] Window owner of the menu
//      cmt        [in] Menu type (CMT_OBJECT or CMT_BACKGROUND)
//      indexMenu  [in] Zero-based position at which to insert the first
//                      menu item.
//      idCmdFirst [in] Min value the handler can specify for a menu item
//      idCmdLast  [in] Max value the handler can specify for a menu item
//      fVerbsOnly [in] Verb only required
//
//  Returns:
//
//  Author:     deonb   8 Feb 2001
//
//  Notes:
//
HRESULT HrBuildMenuOldWay(IN OUT HMENU hmenu, IN PCONFOLDPIDLVEC& cfpl, IN HWND hwndOwner, IN CMENU_TYPE cmt, IN UINT indexMenu, IN DWORD idCmdFirst, IN UINT idCmdLast, IN BOOL fVerbsOnly)
{
    TraceFileFunc(ttidMenus);

    HRESULT hr = S_OK;

    INT     iMenuResourceId     = 0;
    INT     iPopupResourceId    = 0;
    QCMINFO qcm                 = {hmenu, indexMenu, idCmdFirst, idCmdLast};
    INT     iDefaultCmd         = 0;

    BOOL            fValidMenu          = FALSE;
    const PCONFOLDPIDL& pcfp = cfpl[0];
    DWORD           dwLoop  = 0;
    for (dwLoop = 0; (dwLoop < g_dwContextMenuEntryCount) && !fValidMenu; dwLoop++)
    {
        if (c_CMEArray[dwLoop].wizWizard == pcfp->wizWizard)
        {
            if (pcfp->wizWizard != WIZARD_NOT_WIZARD)
            {
                fValidMenu = TRUE;
            }
            else
            {
                // If the mediatype is the same
                //
                if (pcfp->ncm == c_CMEArray[dwLoop].ncm)
                {
                    // If the presence of the NCCF_INCOMING_ONLY characteristic (demoted to 0 | 1),
                    // matches the inbound flag
                    //
                    if ((!!(pcfp->dwCharacteristics & NCCF_INCOMING_ONLY)) ==
                        c_CMEArray[dwLoop].fInbound)
                    {
                        // If not the wizard, then we need to check the state of the connection
                        // as well.
                        //
                        if (pcfp->ncs == c_CMEArray[dwLoop].ncs)
                        {
                            if ((!!(pcfp->dwCharacteristics & NCCF_DEFAULT)) == c_CMEArray[dwLoop].fIsDefault)
                            {
                                fValidMenu = TRUE;
                            }
                        }
                    }
                }
            }
        }

        if (fValidMenu)
        {
            iPopupResourceId = 0;
            if (fVerbsOnly)
            {
                iMenuResourceId = c_CMEArray[dwLoop].iVerbMenu;
            }
            else
            {
                iMenuResourceId = c_CMEArray[dwLoop].iMenu;
            }

            iDefaultCmd = c_CMEArray[dwLoop].iDefaultCmd;
        }
    }

    if (fValidMenu)
    {
        MergeMenu(_Module.GetResourceInstance(),
                    iMenuResourceId,
                    iPopupResourceId,
                    (LPQCMINFO)&qcm);

        // Enable/Disable the menu items as appropriate. Ignore the return from this
        // as we're getting it for debugging purposes only.
        //
        hr = HrEnableOrDisableMenuItems(
            hwndOwner,
            cfpl,
            hmenu,
            idCmdFirst);

        if (CMT_OBJECT == cmt)
        {
            // $$REVIEW: Find out why I'm only doing this for CMT_OBJECT instead of for background.
            // Pre-icomtextm|mb combine, mb had this commented out.
            //
            SetMenuDefaultItem(hmenu, idCmdFirst + iDefaultCmd, FALSE);
        }

        hr = ResultFromShort(qcm.idCmdFirst - idCmdFirst);
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

static const ContextMenuEntry  c_BadBadLegacyImplementationsToIgnore[] =
{
   //wizWizard
   // |    ncm
   // |    |         fInbound?
   // |    |           | fIsDefault?
   // |    |           |  |      Status (ncs)
   // |    |           |  |        |
   // v    v           v  v        v
    { WIZARD_NOT_WIZARD, NCM_LAN,      0, 0, NCS_DISCONNECTING,     0,0,0}, // Disabled "Status" menu item is also default.
    { WIZARD_NOT_WIZARD, NCM_LAN,      1, 0, NCS_DISCONNECTING,     0,0,0}, // Disabled "Status" menu item is also default.
    { WIZARD_NOT_WIZARD, NCM_LAN,      0, 0, NCS_DISCONNECTED,      0,0,0}, // Disabled "Status" menu item is also default.

    { WIZARD_NOT_WIZARD, NCM_SHAREDACCESSHOST_RAS,0,0, NCS_CONNECTING,     0,0,0}, // Disabled "Status" menu item is also default.
    { WIZARD_NOT_WIZARD, NCM_SHAREDACCESSHOST_RAS,0,0, NCS_DISCONNECTING,  0,0,0}, // Disabled "Status" menu item is also default.
    { WIZARD_NOT_WIZARD, NCM_SHAREDACCESSHOST_LAN,0,0, NCS_DISCONNECTING,  0,0,0}, // Disabled "Status" menu item is also default.

    { WIZARD_NOT_WIZARD, NCM_BRIDGE,   0, 0, NCS_DISCONNECTING,     0,0,0}, // Disabled "Status" menu item is also default.
    { WIZARD_NOT_WIZARD, NCM_BRIDGE,   0, 0, NCS_CONNECTING,        0,0,0}, // Disabled "Enable" menu item is also default.

    // Connection manager
    { WIZARD_NOT_WIZARD, NCM_NONE,     0, 0, NCS_DISCONNECTED,     0,0,0}, // Disabled "Connect" menu item is also default.


    { WIZARD_NOT_WIZARD, NCM_ISDN,     1, 0, NCS_DISCONNECTING,     0,0,0}, // Disabled "Status" menu item is also default.
    { WIZARD_NOT_WIZARD, NCM_ISDN,     0, 0, NCS_CONNECTING,        0,0,0}, // Disabled "Connect" menu item is also default.
    { WIZARD_NOT_WIZARD, NCM_ISDN,     0, 0, NCS_DISCONNECTING,     0,0,0}, // Disabled "Status" menu item is also default.
    { WIZARD_NOT_WIZARD, NCM_ISDN,     0, 1, NCS_CONNECTING,        0,0,0}, // Disabled "Connect" menu item is also default.
    { WIZARD_NOT_WIZARD, NCM_ISDN,     0, 1, NCS_DISCONNECTING,     0,0,0}, // Disabled "Status" menu item is also default.

    { WIZARD_NOT_WIZARD, NCM_DIRECT,   1, 0, NCS_DISCONNECTING,     0,0,0}, // Disabled "Status" menu item is also default.
    { WIZARD_NOT_WIZARD, NCM_DIRECT,   0, 0, NCS_CONNECTING,        0,0,0}, // Disabled "Connect" menu item is also default.
    { WIZARD_NOT_WIZARD, NCM_DIRECT,   0, 0, NCS_DISCONNECTING,     0,0,0}, // Disabled "Status" menu item is also default.
    { WIZARD_NOT_WIZARD, NCM_DIRECT,   0, 1, NCS_CONNECTING,        0,0,0}, // Disabled "Connect" menu item is also default.
    { WIZARD_NOT_WIZARD, NCM_DIRECT,   0, 1, NCS_DISCONNECTING,     0,0,0}, // Disabled "Status" menu item is also default.

    { WIZARD_NOT_WIZARD, NCM_TUNNEL,   1, 0, NCS_DISCONNECTING,     0,0,0}, // Disabled "Status" menu item is also default.
    { WIZARD_NOT_WIZARD, NCM_TUNNEL,   0, 0, NCS_CONNECTING,        0,0,0}, // Disabled "Connect" menu item is also default.
    { WIZARD_NOT_WIZARD, NCM_TUNNEL,   0, 0, NCS_DISCONNECTING,     0,0,0}, // Disabled "Status" menu item is also default.
    { WIZARD_NOT_WIZARD, NCM_TUNNEL,   0, 1, NCS_CONNECTING,        0,0,0}, // Disabled "Connect" menu item is also default.
    { WIZARD_NOT_WIZARD, NCM_TUNNEL,   0, 1, NCS_DISCONNECTING,     0,0,0}, // Disabled "Status" menu item is also default.

    { WIZARD_NOT_WIZARD, NCM_PHONE,    1, 0, NCS_DISCONNECTING,     0,0,0}, // Disabled "Status" menu item is also default.
    { WIZARD_NOT_WIZARD, NCM_PHONE,    0, 0, NCS_CONNECTING,        0,0,0}, // Disabled "Connect" menu item is also default.
    { WIZARD_NOT_WIZARD, NCM_PHONE,    0, 1, NCS_CONNECTING,        0,0,0}, // Disabled "Connect" menu item is also default.
    { WIZARD_NOT_WIZARD, NCM_PHONE,    0, 0, NCS_DISCONNECTING,     0,0,0}, // Disabled "Status" menu item is also default.
    { WIZARD_NOT_WIZARD, NCM_PHONE,    0, 1, NCS_DISCONNECTING,     0,0,0}  // Disabled "Status" menu item is also default.
};

const DWORD g_dwBadBadLegacyImplementationsToIgnoreCount = celems(c_BadBadLegacyImplementationsToIgnore);

//+---------------------------------------------------------------------------
//
//  Member:     IsBadBadLegacyImplementation
//
//  Purpose:    Checks against the list of known bad legacy implementations
//              This is just for the Status field, which we can ignore
//
//  Arguments:
//      [in] cme     Context Menu Entry
//
//  Returns:
//      none
//
//  Author:     deonb   8 Feb 2001
//
//  Notes:
//
BOOL IsBadBadLegacyImplementation(const ContextMenuEntry& cme)
{
    for (int x = 0; x < g_dwBadBadLegacyImplementationsToIgnoreCount; x++)
    {
        const ContextMenuEntry& bbliti = c_BadBadLegacyImplementationsToIgnore[x];
        if ( (cme.wizWizard  == bbliti.wizWizard) &&
             (cme.fInbound   == bbliti.fInbound) &&
             (cme.fIsDefault == bbliti.fIsDefault) &&
             (cme.ncs        == bbliti.ncs) &&
             (cme.ncm        == bbliti.ncm) )
        {
            return TRUE;
        }
    }
    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     GetMenuAsString
//
//  Purpose:    Gets the commands on a menu as a string.
//
//  Arguments:
//      [in] hMenu     Menu
//     [out] szMenu    Menu as a string
//
//  Returns:
//      none
//
//  Author:     deonb   8 Feb 2001
//
//  Notes:
//
void GetHMenuAsString(HMENU hMenu, LPSTR lpszMenu)
{
    int cMenuItems = GetMenuItemCount(hMenu);
    Assert(lpszMenu);

    if (!cMenuItems)
    {
        strcpy(lpszMenu, "<empty>");
        return;
    }

    LPWSTR szTmp  = new WCHAR[TRACESTRLEN];
    LPSTR  szTmp2 = lpszMenu;
    DWORD  dwLen  = 0;
    for (int x = 0; x < cMenuItems; x++)
    {
        UINT nMenuID = GetMenuItemID(hMenu, x);

        GetMenuStringW(hMenu, nMenuID, szTmp, TRACESTRLEN, MF_BYCOMMAND );

        UINT uiState = GetMenuState(hMenu, nMenuID, MF_BYCOMMAND );

        WCHAR szExtra[MAX_PATH] = {L'\0'};
        if (MF_CHECKED & uiState)
        {
            wcscat(szExtra, L"MF_CHECKED ");
        }
        if (MF_DISABLED & uiState)
        {
            wcscat(szExtra, L"MF_DISABLED ");
        }
        if (MF_GRAYED & uiState)
        {
            wcscat(szExtra, L"MF_GRAYED ");
        }
        if (MF_HILITE & uiState)
        {
            wcscat(szExtra, L"MF_HILITE ");
        }
        if (MF_MENUBARBREAK & uiState)
        {
            wcscat(szExtra, L"MF_MENUBARBREAK ");
        }
        if (MF_MENUBREAK & uiState)
        {
            wcscat(szExtra, L"MF_MENUBREAK ");
        }
        if (MF_OWNERDRAW & uiState)
        {
            wcscat(szExtra, L"MF_OWNERDRAW ");
        }
        if (MF_POPUP & uiState)
        {
            wcscat(szExtra, L"MF_POPUP ");
        }
        if (MF_SEPARATOR & uiState)
        {
            wcscat(szExtra, L"MF_SEPARATOR ");
        }
        if (MF_DEFAULT & uiState)
        {
            wcscat(szExtra, L"MF_DEFAULT ");
        }

        dwLen = sprintf(szTmp2, "\r\n  %d. %S=%x (State:%08x = %S)", x+1, szTmp, nMenuID, uiState, szExtra);
        szTmp2 += dwLen;
    }
    AssertSz( (dwLen*2) < TRACESTRLEN, "Buffer overrun");
    delete[] szTmp;
}

//+---------------------------------------------------------------------------
//
//  Member:     TraceMenu
//
//  Purpose:    Trace the commands on a menu to the trace window.
//
//  Arguments:
//      [in] hmenu     Menu to be traced
//
//  Returns:
//      none
//
//  Author:     deonb   8 Feb 2001
//
//  Notes:
//
void TraceMenu(TRACETAGID ttId, HMENU hMenu)
{
    LPSTR szMenu = new CHAR[TRACESTRLEN];
    GetHMenuAsString(hMenu, szMenu);

    TraceTag(ttId, "%s", szMenu);
    delete [] szMenu;
}

#define TRACEMENUS(ttid, hMenu1, hMenu2) \
        TraceTag(ttid, "Menu not identical to previous implementation: OLD:"); \
        TraceMenu(ttid, hMenu1); \
        TraceTag(ttid, "=== vs. NEW: === "); \
        TraceMenu(ttid, hMenu2);

//+---------------------------------------------------------------------------
//
//  Member:     HrAssertTwoMenusEqual
//
//  Purpose:    Asserts that 2 menus are equal by comparing.
//               1. Number of items
//               2. CmdID of each item
//               3. State flags of each item
//               4. String of each item
//
//  Arguments:
//      none
//
//  Returns:
//              S_OK is succeeded
//              E_FAIL if not
//
//  Author:     deonb   8 Feb 2001
//
//  Notes:      Asserts on failure
//
HRESULT HrAssertTwoMenusEqual(HMENU hMenu1, HMENU hMenu2, UINT idCmdFirst, BOOL bIgnoreFlags, BOOL fPopupAsserts)
{
    TraceFileFunc(ttidMenus);

    TRACETAGID ttid = fPopupAsserts ? ttidError : ttidMenus;

    LPSTR szErr = new CHAR[TRACESTRLEN];
    int cMenuItems = GetMenuItemCount(hMenu1);
    if (cMenuItems != GetMenuItemCount(hMenu2))
    {
        TRACEMENUS(ttid, hMenu1, hMenu2);

        sprintf(szErr, "Two menus don't have the same number of items");
        TraceTag(ttidError, szErr);
        if (fPopupAsserts)
        {
            AssertSz(FALSE, szErr);
        }
        delete[] szErr;
        return E_FAIL;
    }

    for (int x = 0; x < cMenuItems; x++)
    {
        UINT nMenuID1 = GetMenuItemID(hMenu1, x);
        UINT nMenuID2 = GetMenuItemID(hMenu2, x);
        if (nMenuID1 != nMenuID2)
        {
            if (!(((nMenuID1-idCmdFirst == CMIDM_CREATE_BRIDGE) || (nMenuID2-idCmdFirst == CMIDM_CREATE_BRIDGE)) &&
                  ((nMenuID1-idCmdFirst == CMIDM_ADD_TO_BRIDGE) || (nMenuID2-idCmdFirst == CMIDM_ADD_TO_BRIDGE)) )) // These are equivalent between old & new.
            {

                TRACEMENUS(ttid, hMenu1, hMenu2);
                sprintf(szErr, "Two menus don't have the same nMenuID for item %d", x+1);
                TraceTag(ttidError, szErr);
                if (fPopupAsserts)
                {
                    AssertSz(FALSE, szErr);
                }
                delete[] szErr;
                return E_FAIL;
            }
        }

        WCHAR szMenu1[8192];
        WCHAR szMenu2[8192];

        GetMenuString(hMenu1, nMenuID1, szMenu1, 8192, MF_BYCOMMAND );
        GetMenuString(hMenu2, nMenuID2, szMenu2, 8192, MF_BYCOMMAND );

        if (wcscmp(szMenu1, szMenu2))
        {
            TRACEMENUS(ttid, hMenu1, hMenu2);
            sprintf(szErr, "Two menus don't have the same strings for item %d (%S vs %S)", x+1, szMenu1, szMenu2);
            TraceTag(ttidError, szErr);
            if (fPopupAsserts)
            {
                AssertSz(FALSE, szErr);
            }

            delete[] szErr;
            return E_FAIL;
        }

        UINT uiState1;
        UINT uiState2;

        uiState1 = GetMenuState( hMenu1, nMenuID1, MF_BYCOMMAND );
        uiState2 = GetMenuState( hMenu2, nMenuID2, MF_BYCOMMAND );

        if (bIgnoreFlags) // Ignore Default Flags
        {
            uiState1 &= ~MF_DEFAULT;
            uiState2 &= ~MF_DEFAULT;
        }

        if (uiState1 != uiState2)
        {
            TRACEMENUS(ttid, hMenu1, hMenu2);

            sprintf(szErr, "Two menus don't have the same state for item %d (%S) ... %08x vs %08x", x+1, szMenu1, uiState1, uiState2);
            TraceTag(ttidError, szErr);
            if (fPopupAsserts)
            {
                AssertSz(FALSE, szErr);
            }
            delete[] szErr;
            return E_FAIL;
        }
    }
    delete[] szErr;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     HrAssertIntegrityAgainstOldMatrix
//
//  Purpose:    Asserts the integrity of the Command Matrix by comparing it
//              with the old implementation
//
//  Arguments:
//      none
//
//  Returns:
//              S_OK is succeeded
//              E_FAIL if not
//
//  Author:     deonb   8 Feb 2001
//
//  Notes:      Asserts on failure
//
HRESULT HrAssertIntegrityAgainstOldMatrix()
{
    TraceFileFunc(ttidMenus);

    HRESULT hr = S_OK;

    CHAR szErr[8192];
    for (DWORD x = 0; x < g_cteCommandMatrixCount; x++)
    {
        const COMMANDENTRY& cte = g_cteCommandMatrix[x];
        if (CMIDM_SEPARATOR == cte.iCommandId)
        {
            continue;
        }

        if (NCWHEN_TOPLEVEL == cte.dwValidWhen)
        {
            continue; // new commands we didn't have previously
        }

        if (CMIDM_HOMENET_WIZARD == cte.iCommandId)
        {
            continue; // new commands we didn't have previously
        }

        if ( (CMIDM_WZCDLG_SHOW  == cte.iCommandId) )
        {
            continue;
        }

        // Check that the ValidWhen flags match the ones from g_cteFolderCommands
        BOOL bMatch = FALSE;
        for (DWORD y = 0; y < g_nFolderCommandCount; y++)
        {
            COMMANDTABLEENTRY ctecmp = g_cteFolderCommands[y];
            if (cte.iCommandId == ctecmp.iCommandId)
            {
                bMatch = TRUE;

                if (ctecmp.fValidOnMultiple != (!!(cte.dwValidWhen & NCWHEN_MULTISELECT)))
                {
                    if (cte.iCommandId != CMIDM_FIX) // We know fix is broken in legacy implementation.
                    {
                        sprintf(szErr, "New (row %d) and old (row %d) multiselect fields are inconsistent", x+1, y+1);
                        AssertSz(FALSE, szErr);
                        hr = E_FAIL;
                    }
                }

                // We can check for Visible only since Active is always a subset of visible (enforced by HrAssertCommandMatrixIntegrity)
                if (ctecmp.fValidOnWizardOnly  != (!!(cte.dwMediaTypeVisible & NBM_MNC_WIZARD)))
                {
                    sprintf(szErr, "New (row %d) and old (row %d) wizard select fields are inconsistent", x+1, y+1);
                    AssertSz(FALSE, szErr);
                    hr = E_FAIL;
                }

                if (ctecmp.fValidOnZero != (!!(cte.dwValidWhen & NCWHEN_TOPLEVEL)))
                {
                    sprintf(szErr, "New (row %d) and old (row %d) Zero select fields are inconsistent", x+1, y+1);
                    AssertSz(FALSE, szErr);
                    hr = E_FAIL;
                }
            }
        }

        if (!bMatch)
        {
            sprintf(szErr, "Could not find corresponding entry for (row %d) in old table", x+1);
            AssertSz(FALSE, szErr);
            hr = E_FAIL;
        }
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     HrAssertMenuAgainstOldImplementation
//
//  Purpose:    Asserts the integrity of a menu by comparing the old and
//              new implementations
//
//  Arguments:
//      none
//
//  Returns:
//              S_OK is succeeded
//              E_FAIL if not
//
//  Author:     deonb   8 Feb 2001
//
//  Notes:      Asserts on failure
//
HRESULT HrAssertMenuAgainstOldImplementation(HWND hwndOwner, WIZARD wizWizard, NETCON_STATUS ncs, NETCON_MEDIATYPE ncm, DWORD nccf, LPDWORD pdwFailCount, LPDWORD pdwSucceedCount, DWORD dwPermOutside, DWORD dwPerm)
{
    CConFoldEntry cfe;
    PCONFOLDPIDL  pcfp;

    BYTE blob[MAX_PATH];

    HRESULT hr = cfe.HrInitData(
        wizWizard,
        ncm,
        NCSM_NONE,
        ncs,
        &CLSID_ConnectionFolder, // Bogus - but doesn't matter - as long as it's not NULL.
        &CLSID_ConnectionFolder, // Bogus - but doesn't matter - as long as it's not NULL.
        nccf,
        blob,
        MAX_PATH,
        L"Test PIDL",
        NULL,
        NULL);

    if (SUCCEEDED(hr))
    {
        hr = cfe.ConvertToPidl(pcfp);
    }

    if (SUCCEEDED(hr))
    {
        PCONFOLDPIDLVEC pcfpVec;
        pcfpVec.push_back(pcfp);

        UINT  idCmdFirst = 1234;
        UINT  idCmdLast  = idCmdFirst+1000;
        BOOL  fVerbsOnly = FALSE;

        HMENU hMenu1 = CreateMenu();
        HMENU hMenu2 = CreateMenu();
        if ( (hMenu1) && (hMenu2) )
        {
            hr = HrBuildMenuOldWay(hMenu1, pcfpVec, hwndOwner, CMT_OBJECT, 0, idCmdFirst, idCmdLast, fVerbsOnly);

            if (SUCCEEDED(hr))
            {
                hr = HrBuildMenu(hMenu2, fVerbsOnly, pcfpVec, idCmdFirst);

                if (SUCCEEDED(hr))
                {
                    BOOL bIgnoreFlags = TRUE;

                    hr = HrAssertTwoMenusEqual(hMenu1, hMenu2, idCmdFirst, bIgnoreFlags, FALSE);
                    if (FAILED(hr))
                    {
                        TraceTag(ttidMenus, "  + PIDL of failed menu compare:");
                        TraceTag(ttidMenus, "  + wizWizard       = %d\r\n", cfe.GetWizard());
                        TraceTag(ttidMenus, "  + ncm             = %d [%s]\r\n", cfe.GetNetConMediaType(), DbgNcm(cfe.GetNetConMediaType()));
                        TraceTag(ttidMenus, "  + ncs             = %d [%s]\r\n", cfe.GetNetConStatus(), DbgNcs(cfe.GetNetConStatus()));
                        TraceTag(ttidMenus, "  + Characteristics = %08x [%s]\r\n", cfe.GetCharacteristics(), DbgNccf(cfe.GetCharacteristics()));
                        TraceTag(ttidMenus, "  + Permissions     = %d (%d & %d)\r\n", g_dwDbgPermissionsFail, dwPermOutside-1, dwPerm-1);
                        *pdwFailCount++;
                    }
                    else
                    {
                        *pdwSucceedCount++;
                    }
                }
            }

            DestroyMenu(hMenu1);
            DestroyMenu(hMenu2);
            hr = S_OK;
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "HrAssertMenuAgainstOldImplementation");
    return hr;
}


extern ULONG g_dwDbgWin2kPoliciesSet;
//+---------------------------------------------------------------------------
//
//  Member:     HrAssertAllLegacyMenusAgainstNew
//
//  Purpose:    Loads each of the menus from the old Command Matrix, and
//              Compare with the newer menus
//
//  Arguments:
//      [in] hwndOwner    Owner window
//
//  Returns:
//              S_OK is succeeded
//              E_FAIL if not
//
//  Author:     deonb   8 Feb 2001
//
//  Notes:      Asserts on failure
//
HRESULT HrAssertAllLegacyMenusAgainstNew(HWND hwndOwner)
{
    TraceFileFunc(ttidMenus);

    HRESULT hr = S_OK;
    DWORD dwFailCount    = 0;
    DWORD dwSucceedCount = 0;
    DWORD dwIgnoredCount = 0;
    CHAR szErr[8192];

    const dwHighestPermissionToCheck = NCPERM_Repair+1; // 0;

    TraceTag(ttidMenus, "Asserting all Menus against their Legacy implementation. This may take a while...");

    DWORD dwCurrentCount = 0;

    DWORD dwTotalCount = 12 * (g_dwContextMenuEntryCount * (1 + ((dwHighestPermissionToCheck+1)*dwHighestPermissionToCheck/2))); // Sum of a series
                         // + ((1 + g_dwContextMenuEntryCount)*(g_dwContextMenuEntryCount))/2; // Multi-select items (sum of series)
    DWORD dwFrequency  = dwTotalCount / 200;
    dwFrequency = dwFrequency ? dwFrequency : 1;

    // 0xFFFFFFFF to NCPERM_Repair inclusive.
    g_dwDbgWin2kPoliciesSet = 1;
    for (int i = 0; i <= 1; i++, g_dwDbgWin2kPoliciesSet--)
    {
        for (DWORD dwPermOutside = 0; dwPermOutside <= dwHighestPermissionToCheck; dwPermOutside++)
        {
            for (DWORD dwPerm = dwPermOutside; dwPerm <= dwHighestPermissionToCheck; dwPerm++)
            {
                if (dwPerm == dwPermOutside)
                {
                    if (0 == dwPerm) // 0,0 is interesting - otherwise x,x is dup of x,0 (A | B == A | 0 if A==B)
                    {
                        g_dwDbgPermissionsFail = 0xFFFFFFFF;
                    }
                    else
                    {
                        continue;
                    }
                }
                else
                {
                    if (dwPermOutside)
                    {
                        g_dwDbgPermissionsFail = (1 << (dwPermOutside-1));
                    }
                    else
                    {
                        g_dwDbgPermissionsFail = 0;
                    }

                    if (dwPerm)
                    {
                        g_dwDbgPermissionsFail |= (1 << (dwPerm-1));
                    }
                }

                for (DWORD x = 0; x < g_dwContextMenuEntryCount; x++)
                {
                    for (int dwInc = 1; dwInc<= 6; dwInc++)  // we compare 6 menus at a time
                    {
                        if ( (dwCurrentCount % dwFrequency) == 0)
                        {
                            TraceTag(ttidMenus, "%d%% done with menu assertions (%d of %d menus compared. Currently using permissions: %08x)", static_cast<DWORD>( (100 * dwCurrentCount) / dwTotalCount), dwCurrentCount, dwTotalCount, g_dwDbgPermissionsFail);
                        }
                        dwCurrentCount++;
                    }

                    const ContextMenuEntry& cme = c_CMEArray[x];

                    DWORD dwCharacteristics = 0;

                    if (cme.fInbound)
                    {
                        dwCharacteristics |= NCCF_INCOMING_ONLY;
                    }

                    if (cme.fIsDefault)
                    {
                        dwCharacteristics |= NCCF_DEFAULT;
                    }

                    Sleep(0); // Yield to kernel
                    HrAssertMenuAgainstOldImplementation(hwndOwner, cme.wizWizard, cme.ncs, cme.ncm, dwCharacteristics, &dwFailCount, &dwSucceedCount, dwPermOutside, dwPerm);

                    dwCharacteristics |= NCCF_ALLOW_RENAME;
                    HrAssertMenuAgainstOldImplementation(hwndOwner, cme.wizWizard, cme.ncs, cme.ncm, dwCharacteristics, &dwFailCount, &dwSucceedCount, dwPermOutside, dwPerm);

                    if (IsMediaLocalType(cme.ncm))
                    {
                        dwCharacteristics |= NCCF_BRIDGED;
                        HrAssertMenuAgainstOldImplementation(hwndOwner, cme.wizWizard, cme.ncs, cme.ncm, dwCharacteristics, &dwFailCount, &dwSucceedCount, dwPermOutside, dwPerm);

                        dwCharacteristics |= NCCF_FIREWALLED;
                        HrAssertMenuAgainstOldImplementation(hwndOwner, cme.wizWizard, cme.ncs, cme.ncm, dwCharacteristics, &dwFailCount, &dwSucceedCount, dwPermOutside, dwPerm);
                    }
                    else
                    {
                        dwCharacteristics |= NCCF_ALL_USERS;
                        HrAssertMenuAgainstOldImplementation(hwndOwner, cme.wizWizard, cme.ncs, cme.ncm, dwCharacteristics, &dwFailCount, &dwSucceedCount, dwPermOutside, dwPerm);

                        dwCharacteristics |= NCCF_ALLOW_REMOVAL;
                        HrAssertMenuAgainstOldImplementation(hwndOwner, cme.wizWizard, cme.ncs, cme.ncm, dwCharacteristics, &dwFailCount, &dwSucceedCount, dwPermOutside, dwPerm);
                    }

                    Sleep(0); // Yield to kernel
                    dwCharacteristics |= NCCF_SHARED;
                    HrAssertMenuAgainstOldImplementation(hwndOwner, cme.wizWizard, cme.ncs, cme.ncm, dwCharacteristics, &dwFailCount, &dwSucceedCount, dwPermOutside, dwPerm);

                    dwCharacteristics |= NCCF_FIREWALLED;
                    HrAssertMenuAgainstOldImplementation(hwndOwner, cme.wizWizard, cme.ncs, cme.ncm, dwCharacteristics, &dwFailCount, &dwSucceedCount, dwPermOutside, dwPerm);
                }
            }
        }
    }

    g_dwDbgWin2kPoliciesSet = 0xFFFFFFFF; // retore to original value
    g_dwDbgPermissionsFail  = 0xFFFFFFFF; // retore to original value

    // Now, compare multiple items selected menus:
    // ***** THIS TEST IS NOT USEFUL. THE LEGACY IMPLEMENTATION SUCKS. COMMENTING OUT FOR NOW *****

//    for (DWORD x = 0; x < g_dwContextMenuEntryCount; x++)
//    {
//        for (DWORD y = x; y < g_dwContextMenuEntryCount; y++)
//        {
//            if ( (dwCurrentCount % dwFrequency) == 0)
//            {
//                TraceTag(ttidError, "%d%% done with menu assertions (%d of %d menus compared). Currently multi-comparing %d and %d", static_cast<DWORD>( (100 * dwCurrentCount) / dwTotalCount), dwCurrentCount, dwTotalCount, x, y);
//            }
//            dwCurrentCount++;
//
//            const ContextMenuEntry& cme1 = c_CMEArray[x];
//            const ContextMenuEntry& cme2 = c_CMEArray[y];
//
//            DWORD dwCharacteristics1 = 0;
//            DWORD dwCharacteristics2 = 0;
//            if (cme1.fInbound)
//            {
//                dwCharacteristics1 |= NCCF_INCOMING_ONLY;
//            }
//            if (cme2.fInbound)
//            {
//                dwCharacteristics2 |= NCCF_INCOMING_ONLY;
//            }
//
//            if (cme1.fIsDefault)
//            {
//                dwCharacteristics1 |= NCCF_DEFAULT;
//            }
//            if (cme2.fIsDefault)
//            {
//                dwCharacteristics2 |= NCCF_DEFAULT;
//            }
//
//            CConFoldEntry cfe1,  cfe2;
//            PCONFOLDPIDL  pcfp1, pcfp2;
//
//            BYTE blob[MAX_PATH];
//
//            hr = cfe1.HrInitData(
//                cme1.wizWizard, cme1.ncm, cme1.ncs, NCS_AUTHENTICATION_SUCCEEDED, &CLSID_ConnectionFolder, &CLSID_ConnectionFolder,
//                dwCharacteristics1, blob, MAX_PATH, L"Test PIDL", NULL,  NULL);
//
//            hr = cfe2.HrInitData(
//                cme2.wizWizard, cme2.ncm, cme2.ncs, NCS_AUTHENTICATION_SUCCEEDED, &CLSID_ConnectionFolder, &CLSID_ConnectionFolder,
//                dwCharacteristics2, blob, MAX_PATH, L"Test PIDL", NULL,  NULL);
//
//            if (SUCCEEDED(hr))
//            {
//                hr = cfe1.ConvertToPidl(pcfp1);
//                if (SUCCEEDED(hr))
//                {
//                    hr = cfe2.ConvertToPidl(pcfp2);
//                }
//            }
//
//            if (SUCCEEDED(hr))
//            {
//                PCONFOLDPIDLVEC pcfpVec;
//                pcfpVec.push_back(pcfp1);
//                pcfpVec.push_back(pcfp2);
//
//                UINT  idCmdFirst = 1234;
//                UINT  idCmdLast  = idCmdFirst+1000;
//                BOOL  fVerbsOnly = FALSE;
//
//                HMENU hMenu1 = CreateMenu();
//                HMENU hMenu2 = CreateMenu();
//                if ( (hMenu1) && (hMenu2) )
//                {
//                    hr = HrBuildMenuOldWay(hMenu1, pcfpVec, hwndOwner, CMT_OBJECT, 0, idCmdFirst, idCmdLast, fVerbsOnly);
//
//                    if (SUCCEEDED(hr))
//                    {
//                        hr = HrBuildMenu(hMenu2, fVerbsOnly, pcfpVec, idCmdFirst);
//
//                        if (SUCCEEDED(hr))
//                        {
//                            BOOL bIgnoreFlags = TRUE;
//                            // Ignore Default flag for multi-compare. The entire legacy implementation is wrong).
//
//                            hr = HrAssertTwoMenusEqual(hMenu1, hMenu2, idCmdFirst, bIgnoreFlags, FALSE);
//                            if (FAILED(hr))
//                            {
//                                TraceTag(ttidError, "  + PIDL of failed multi-menu compare:");
//                                TraceTag(ttidError, "  + PIDL 1:");
//                                TraceTag(ttidError, "    + wizWizard         = %d\r\n", cfe1.GetWizard());
//                                TraceTag(ttidError, "    + ncm             = %d [%s]\r\n", cfe1.GetNetConMediaType(), DBG_NCMAMES[cfe1.GetNetConMediaType()]);
//                                TraceTag(ttidError, "    + ncs             = %d [%s]\r\n", cfe1.GetNetConStatus(), DBG_NCSNAMES[cfe1.GetNetConStatus()]);
//                                TraceTag(ttidError, "    + Characteristics = %08x\r\n", cfe1.GetCharacteristics());
//                                TraceTag(ttidError, "    + Permissions     = %d\r\n", g_dwDbgPermissionsFail);
//                                TraceTag(ttidError, "  + PIDL 2:");
//                                TraceTag(ttidError, "    + wizWizard         = %d\r\n", cfe2.GetWizard());
//                                TraceTag(ttidError, "    + ncm             = %d [%s]\r\n", cfe2.GetNetConMediaType(), DBG_NCMAMES[cfe2.GetNetConMediaType()]);
//                                TraceTag(ttidError, "    + ncs             = %d [%s]\r\n", cfe2.GetNetConStatus(), DBG_NCSNAMES[cfe2.GetNetConStatus()]);
//                                TraceTag(ttidError, "    + Characteristics = %08x\r\n", cfe2.GetCharacteristics());
//                                TraceTag(ttidError, "    + Permissions     = %d\r\n", g_dwDbgPermissionsFail);
//                                dwFailCount++;
//                            }
//                            else
//                            {
//                                dwSucceedCount++;
//                            }
//                        }
//                    }
//
//                    DestroyMenu(hMenu1);
//                    DestroyMenu(hMenu2);
//                    hr = S_OK;
//                }
//            }
//
//            TraceHr(ttidError, FAL, hr, FALSE, "HrAssertAllLegacyMenusAgainstNew");
//        }
//    }


    TraceTag(ttidMenus, "Number of FAILED menu compares:    %d", dwFailCount);
    TraceTag(ttidMenus, "Number of SUCCEEDED menu compares: %d", dwSucceedCount);
    TraceTag(ttidMenus, "Number of ITEMS in menu array    : %d", (g_dwContextMenuEntryCount + 1) * dwHighestPermissionToCheck);

    sprintf(szErr, "%d of %d menus did not initialize consistend with the old way. (%d initialized correctly. %d was partially ignored due to known bad old implementation)", dwFailCount, dwTotalCount, dwSucceedCount, dwIgnoredCount);
    AssertSz(FALSE, szErr);
    return S_OK;
}

COMMANDCHECKENTRY   g_cceFolderCommands[] =
{
    // command id
    //                                  currently checked
    //                                   |      new check state
    //                                   |       |
    //                                   v       v
    { CMIDM_CONMENU_OPERATOR_ASSIST,    false,  false }
};

const DWORD g_nFolderCommandCheckCount = celems(g_cceFolderCommands);

//+---------------------------------------------------------------------------
//
//  Function:   HrEnableOrDisableMenuItems
//
//  Purpose:    Enable, disable, and or check/uncheck menu items depending
//              on the current selection count, as well as exceptions for
//              the type and state of the connections themselves
//
//  Arguments:
//      hwnd            [in]   Our window handle
//      apidlSelected   [in]   Currently selected objects
//      cPidl           [in]   Number selected
//      hmenu           [in]   Our command menu handle
//      idCmdFirst      [in]   First valid command
//
//  Returns:
//
//  Author:     jeffspr   2 Feb 1998
//
//  Notes:
//
HRESULT HrEnableOrDisableMenuItems(
                                   HWND            hwnd,
                                   const PCONFOLDPIDLVEC&  apidlSelected,
                                   HMENU           hmenu,
                                   UINT            idCmdFirst)
{
    HRESULT hr      = S_OK;
    DWORD   dwLoop  = 0;

    RefreshAllPermission();

    // Loop through, and set the new state, based on the selection
    // count compared to the flags for 0-select and multi-select
    //
    for (dwLoop = 0; dwLoop < g_nFolderCommandCount; dwLoop++)
    {
        // If nothing is selected, then check the current state, and
        // if different, adjust
        //
        if (apidlSelected.size() == 0)
        {
            g_cteFolderCommands[dwLoop].fNewState =
                g_cteFolderCommands[dwLoop].fValidOnZero;
        }
        else
        {
            // If singly-selected, then by default, we're always on.
            //
            if (apidlSelected.size() == 1)
            {
                CONFOLDENTRY  ccfe;

                // Special case this where one item is selected, but it's the
                // wizard. Use the fValidOnWizardOnly element here.
                //
                hr = apidlSelected[0].ConvertToConFoldEntry(ccfe);
                if (SUCCEEDED(hr))
                {
                    if (ccfe.GetWizard())
                    {
                        g_cteFolderCommands[dwLoop].fNewState =
                            g_cteFolderCommands[dwLoop].fValidOnWizardOnly;
                    }
                    else
                    {
                        g_cteFolderCommands[dwLoop].fNewState = true;
                    }
                }
            }
            else
            {
                // Multi-selected
                //
                g_cteFolderCommands[dwLoop].fNewState =
                    g_cteFolderCommands[dwLoop].fValidOnMultiple;
            }
        }
    }

    // Check for various menu item exceptions. Removed from this
    // function for readability's sake.
    //
    DoMenuItemExceptionLoop(apidlSelected);

    // Do the check/uncheck loop.
    //
    DoMenuItemCheckLoop();

    // Update bridge menu item


    // Check to see if it's a LAN connection. If so, disable
    // Loop through the array again, and do the actual EnableMenuItem
    // calls based on the new state compared to the current state.
    // Update the current state as well
    //
    for (dwLoop = 0; dwLoop < g_nFolderCommandCount; dwLoop++)
    {
#ifdef SHELL_CACHING_MENU_STATE
        // The shell is now enabling these for every call. If they switch
        // to a cached mechanism, change the #define above

        if (g_cteFolderCommands[dwLoop].fNewState !=
            g_cteFolderCommands[dwLoop].fCurrentlyValid)
#endif
        {
            DWORD dwCommandId = 0;

            switch(g_cteFolderCommands[dwLoop].iCommandId)
            {
            case SFVIDM_FILE_DELETE:
            case SFVIDM_FILE_RENAME:
            case SFVIDM_FILE_LINK:
            case SFVIDM_FILE_PROPERTIES:
                dwCommandId = g_cteFolderCommands[dwLoop].iCommandId;
                break;
            default:
                dwCommandId = g_cteFolderCommands[dwLoop].iCommandId +
                    idCmdFirst - CMIDM_FIRST;
                break;
            }

            // Enable or disable the menu item, as appopriate
            //
            EnableMenuItem(
                hmenu,
                dwCommandId,
                g_cteFolderCommands[dwLoop].fNewState ?
                MF_ENABLED | MF_BYCOMMAND :     // enable
            MF_GRAYED | MF_BYCOMMAND);      // disable

            // Set the state to reflect the enabling/graying
            //
            g_cteFolderCommands[dwLoop].fCurrentlyValid =
                g_cteFolderCommands[dwLoop].fNewState;
        }
    }

    // Loop through the checkmark-able command list, and mark the menu
    // items appropriately
    //
    for (dwLoop = 0; dwLoop < g_nFolderCommandCheckCount; dwLoop++)
    {

#ifdef SHELL_CACHING_MENU_STATE
        if (g_cceFolderCommands[dwLoop].fCurrentlyChecked !=
            g_cceFolderCommands[dwLoop].fNewCheckState)
#endif
        {
            DWORD dwCommandId   = 0;

            // If we re-add defview menu items that need to be checked/unchecked,
            // the code below will take care of it for us. Note that we
            // don't add the idCmdFirst + CMIDM_FIRST as we do with our own
            // commands
            //          switch(g_cceFolderCommands[dwLoop].iCommandId)
            //          {
            //              case SFVIDM_ARRANGE_AUTO:
            //                  dwCommandId = g_cceFolderCommands[dwLoop].iCommandId;
            //                  break;
            //              default:
            //                  dwCommandId = g_cceFolderCommands[dwLoop].iCommandId +
            //                      idCmdFirst - CMIDM_FIRST;
            //                  break;

            dwCommandId = g_cceFolderCommands[dwLoop].iCommandId +
                idCmdFirst - CMIDM_FIRST;

            // Check or uncheck the item, as appropriate
            //
            CheckMenuItem(
                hmenu,
                dwCommandId,
                g_cceFolderCommands[dwLoop].fNewCheckState ?
                MF_CHECKED | MF_BYCOMMAND :     // checked
            MF_UNCHECKED | MF_BYCOMMAND);   // unchecked

            // Set the state to reflect the checking/unchecking
            //
            g_cceFolderCommands[dwLoop].fCurrentlyChecked =
                g_cceFolderCommands[dwLoop].fNewCheckState;
        }
    }

    //special handling for the "Create Bridge" menu item

    //check whether "Create Bridge" exist in the menu
    BOOL fBgMenuExist = (-1 != GetMenuState(hmenu,
                                    CMIDM_CREATE_BRIDGE + idCmdFirst - CMIDM_FIRST,
                                    MF_BYCOMMAND));
    BOOL fBgCoMenuExist = (-1 != GetMenuState(hmenu,
                                    CMIDM_CONMENU_CREATE_BRIDGE + idCmdFirst - CMIDM_FIRST,
                                    MF_BYCOMMAND));

    if (fBgMenuExist || fBgCoMenuExist)
    {
        BOOL fRemoveBrdgMenu = FALSE;

#ifdef _WIN64
        // Homenet technologies are not available at all on IA64
        fRemoveBrdgMenu = TRUE;
#else
        // If the machine is Advanced server or data center, delete the bridge menu item
        OSVERSIONINFOEXW verInfo = {0};
        ULONGLONG ConditionMask = 0;

        verInfo.dwOSVersionInfoSize = sizeof(verInfo);
        verInfo.wSuiteMask = VER_SUITE_ENTERPRISE;
        verInfo.wProductType = VER_NT_SERVER;

        VER_SET_CONDITION(ConditionMask, VER_PRODUCT_TYPE, VER_GREATER_EQUAL);
        VER_SET_CONDITION(ConditionMask, VER_SUITENAME, VER_AND);

        fRemoveBrdgMenu = !!(VerifyVersionInfo(&verInfo,
                            VER_PRODUCT_TYPE | VER_SUITENAME,
                            ConditionMask));
#endif

        if (fRemoveBrdgMenu)
        {
            if (fBgMenuExist)
            {
                DeleteMenu(hmenu,
                        CMIDM_CREATE_BRIDGE + idCmdFirst - CMIDM_FIRST,
                        MF_BYCOMMAND);
            }

            if (fBgCoMenuExist)
            {
                DeleteMenu(hmenu,
                        CMIDM_CONMENU_CREATE_BRIDGE + idCmdFirst - CMIDM_FIRST,
                        MF_BYCOMMAND);
            }
        }
        else if (IsBridgeInstalled()) // REVIEW can we cache this somehow
        {
            //if the bridge is already installed, modify the menu item string
            MENUITEMINFO MenuItemInfo = {sizeof(MenuItemInfo)};
            MenuItemInfo.fMask = MIIM_STRING;
            MenuItemInfo.fType = MFT_STRING;
            MenuItemInfo.dwTypeData = const_cast<LPWSTR>(SzLoadIds(IDS_CMIDM_ADD_TO_BRIDGE));

            if (fBgMenuExist)
                SetMenuItemInfo(hmenu,
                        CMIDM_CREATE_BRIDGE + idCmdFirst - CMIDM_FIRST,
                        FALSE,
                        &MenuItemInfo);

            if (fBgCoMenuExist)
            {
                MenuItemInfo.fMask = MIIM_STATE;
                MenuItemInfo.fState = MFS_DISABLED;
                SetMenuItemInfo(hmenu,
                            CMIDM_CONMENU_CREATE_BRIDGE + idCmdFirst - CMIDM_FIRST,
                            FALSE,
                            &MenuItemInfo);
            }
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "HrEnableOrDisableMenuItems");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   FEnableConnectDisconnectMenuItem
//
//  Purpose:    Enable or disable the connect/disconnect menu item
//              depending on permissions and the current state of the
//              connection (already connected, disconnected, in the state
//              of connecting, etc.)
//
//  Arguments:
//      pcfp       [in]     Our pidl
//      iCommandId [in]     CMIDM_CONNECT, CMIDM_ENABLE, CMIDM_DISABLE, or CMIDM_DISCONNECT
//
//  Returns:
//
//  Author:     jeffspr   8 Apr 1999
//
//  Notes:
//
bool FEnableConnectDisconnectMenuItem(const PCONFOLDPIDL& pcfp, int iCommandId)
{
    bool    fEnableAction       = false;
    BOOL    fPermissionsValid   = false;

    Assert(!pcfp.empty());
    Assert(iCommandId == CMIDM_CONNECT || iCommandId == CMIDM_DISCONNECT || iCommandId == CMIDM_ENABLE || iCommandId == CMIDM_DISABLE);

    // Make the permissions check based on media type
    //
    switch(pcfp->ncm )
    {
    case NCM_BRIDGE:
        fPermissionsValid = FHasPermissionFromCache(NCPERM_AllowNetBridge_NLA);
        break;

    case NCM_SHAREDACCESSHOST_LAN:
    case NCM_SHAREDACCESSHOST_RAS:
        fPermissionsValid = FHasPermissionFromCache(NCPERM_ShowSharedAccessUi);
        break;

    case NCM_LAN:
        fPermissionsValid = FHasPermissionFromCache(NCPERM_LanConnect);
        break;
    case NCM_DIRECT:
    case NCM_ISDN:
    case NCM_PHONE:
    case NCM_TUNNEL:
        fPermissionsValid = FHasPermissionFromCache(NCPERM_RasConnect);
        break;
    case NCM_NONE:
        // No media-type, no connect
        fPermissionsValid = FALSE;
        break;
    default:
        AssertSz(FALSE, "Need to add a switch for this connection type in the menuing code");
        break;
    }

    if (fPermissionsValid)
    {
        switch(pcfp->ncs)
        {
        case NCS_CONNECTING:
            if (iCommandId == CMIDM_CONNECT || iCommandId == CMIDM_ENABLE)
            {
                if (!(pcfp->dwCharacteristics & NCCF_INCOMING_ONLY))
                {
                    fEnableAction = false;
                }
            }
            break;

        case NCS_DISCONNECTED:
            // Don't check for activating because the
            // default command "Connect" will be disabled.
            // The code currently handles attempts to connect
            // to a connected/ing connection.
            //
            if (iCommandId == CMIDM_CONNECT || iCommandId == CMIDM_ENABLE)
            {
                if (!(pcfp->dwCharacteristics & NCCF_INCOMING_ONLY))
                {
                    fEnableAction = true;
                }
            }
            break;
        case NCS_DISCONNECTING:
            if (iCommandId == CMIDM_DISCONNECT || iCommandId == CMIDM_DISABLE)
            {
                fEnableAction = false;
            }
            break;

        case NCS_CONNECTED:
        case NCS_MEDIA_DISCONNECTED:
        case NCS_INVALID_ADDRESS:
            if (iCommandId == CMIDM_DISCONNECT || iCommandId == CMIDM_DISABLE)
            {
                fEnableAction = true;
            }
            break;
        case NCS_HARDWARE_NOT_PRESENT:
        case NCS_HARDWARE_DISABLED:
        case NCS_HARDWARE_MALFUNCTION:
            // Certainly don't support connect/disconnect actions here.
            break;
        default:
            AssertSz(FALSE, "Who invented a new connection state, and when can I horsewhip them?");
            break;
        }
    }

    return (fEnableAction);
}

//+---------------------------------------------------------------------------
//
//  Function:   DoMenuItemExceptionLoop
//
//  Purpose:    Check for various menu item exceptions.
//
//  Arguments:
//      apidlSelected   [in]   Selected items
//      cPidl           [in]   Count of selected items
//
//  Returns:
//
//  Author:     jeffspr   26 Feb 1998
//
//  Notes:
//
VOID DoMenuItemExceptionLoop(const PCONFOLDPIDLVEC& apidlSelected)
{
    DWORD   dwLoop               = 0;
    PCONFOLDPIDLVEC::const_iterator iterObjectLoop;
    bool    fEnableDelete        = false;
    bool    fEnableStatus        = false;
    bool    fEnableRename        = false;
    bool    fEnableShortcut      = false;
    bool    fEnableConnect       = false;
    bool    fEnableDisconnect    = false;
    bool    fEnableCreateCopy    = false;
    bool    fEnableProperties    = false;
    bool    fEnableCreateBridge  = true;
    bool    fEnableFix           = true;

    // Loop through each of the selected objects
    //
    for (iterObjectLoop = apidlSelected.begin(); iterObjectLoop != apidlSelected.end(); iterObjectLoop++)
    {
        // Validate the pidls
        //
        const PCONFOLDPIDL& pcfp = *iterObjectLoop;
        if ( pcfp.empty() )
        {
            AssertSz(FALSE, "Bogus pidl array in DoMenuItemExceptionLoop (status)");
        }
        else
        {
            BOOL    fActivating = FALSE;

            CONFOLDENTRY cfEmpty;
            (VOID) HrCheckForActivation(pcfp, cfEmpty, &fActivating);

            // Loop through the commands
            //
            for (dwLoop = 0; dwLoop < g_nFolderCommandCount; dwLoop++)
            {
                // Only allow items to be changed to ENABLED states when they're
                // previously DISABLED
                //
                if (g_cteFolderCommands[dwLoop].fNewState)
                {
                    int iCommandId = g_cteFolderCommands[dwLoop].iCommandId;
                    switch(iCommandId)
                    {
                        // For status, verify that at least ONE of the entries is connected.
                        // If not, then we don't allow status.
                        //
                    case CMIDM_STATUS:
                        if ( ( fIsConnectedStatus(pcfp->ncs) || (pcfp->ncs == NCS_INVALID_ADDRESS) ) &&
                            FHasPermissionFromCache(NCPERM_Statistics))
                        {
                            // Raid #379459: If logged on as non-admin, disable status
                            if (!(pcfp->dwCharacteristics & NCCF_INCOMING_ONLY) ||
                                    FIsUserAdmin())
                            {
                                fEnableStatus = true;
                            }
                        }
                        break;

                    case CMIDM_CREATE_SHORTCUT:
                    case SFVIDM_FILE_LINK:
                        if (!(pcfp->dwCharacteristics & NCCF_INCOMING_ONLY))
                        {
                            fEnableShortcut = true;
                        }
                        break;

                        // For delete, verify that at least ONE of the entries has removeable
                        // flag set. If not, then disable the command
                        //
                    case CMIDM_DELETE:
                    case SFVIDM_FILE_DELETE:
                        if (pcfp->dwCharacteristics & NCCF_ALLOW_REMOVAL)
                        {
                            // Note: Need to convert this back to using
                            // the DeleteAllUserConnection when that functionality
                            // is added to the System.ADM file.
                            //
                            if (FHasPermissionFromCache(NCPERM_DeleteConnection))
                            {
                                if (!(pcfp->dwCharacteristics & NCCF_ALL_USERS) ||
                                    ((pcfp->dwCharacteristics & NCCF_ALL_USERS) &&
                                    FHasPermissionFromCache(NCPERM_DeleteAllUserConnection)))
                                {
                                    fEnableDelete = true;
                                }
                            }
                        }
                        break;

                        // For rename, verify that at least ONE of the entries has the rename
                        // flag set. If not, then disable the command
                        //
                    case CMIDM_RENAME:
                    case SFVIDM_FILE_RENAME:
                        if (pcfp->dwCharacteristics & NCCF_ALLOW_RENAME)
                        {
                            if (HasPermissionToRenameConnection(pcfp))
                            {
                                fEnableRename = true;
                            }
                        }
                        break;

                        // For duplicate, verify that at least ONE of the entries
                        // has the duplicate flag set and that the user can create
                        // new connections. If not, then disable the command.
                        //
                    case CMIDM_CREATE_COPY:
                        if ((pcfp->dwCharacteristics & NCCF_ALLOW_DUPLICATION) &&
                            FHasPermissionFromCache(NCPERM_NewConnectionWizard))
                        {
                            // In all cases except when the connection is an
                            // all user connection and the user does NOT have
                            // permissions to view all user properties, we'll
                            // allow it to be enabled.
                            //
                            if ((!(pcfp->dwCharacteristics & NCCF_ALL_USERS)) ||
                                (FHasPermissionFromCache(NCPERM_RasAllUserProperties)))
                            {
                                fEnableCreateCopy = true;
                            }
                        }
                        break;

                        case CMIDM_CONNECT:
                        case CMIDM_ENABLE:
                            // Raid #379459: If logged on as non-admin, disable connect
                            if (!(pcfp->dwCharacteristics & NCCF_INCOMING_ONLY) ||
                                FIsUserAdmin())
                            {
                                fEnableConnect = FEnableConnectDisconnectMenuItem(pcfp, CMIDM_CONNECT);
                            }
                            break;

                        case CMIDM_DISCONNECT:
                        case CMIDM_DISABLE:
                            // Raid #379459: If logged on as non-admin, disable disconnect
                            if (!(pcfp->dwCharacteristics & NCCF_INCOMING_ONLY) ||
                                FIsUserAdmin())
                            {
                                fEnableDisconnect = FEnableConnectDisconnectMenuItem(pcfp, CMIDM_DISCONNECT);
                            }
                            break;

                        case CMIDM_FIX:
                            fEnableFix = ((NCS_INVALID_ADDRESS == pcfp->ncs || fIsConnectedStatus(pcfp->ncs) ) &&
                                          FHasPermission(NCPERM_Repair));
                            break;

                        case CMIDM_PROPERTIES:
                        case SFVIDM_FILE_PROPERTIES:
                            // Raid #379459: If logged on as non-admin, disable properties
                        // We only enable if this is not a LAN connection, or the user has the correct
                        // permissions.  That way we don't accidentally give user that doesn't have permission
                        // the ability to do something they shouldn't, either in the case of a call failing or an
                        // unforeseen error occuring.
                            if (IsMediaRASType(pcfp->ncm))
                            {
                                fEnableProperties = (TRUE == ((pcfp->dwCharacteristics & NCCF_ALL_USERS) ?
                                                    (FHasPermission(NCPERM_RasAllUserProperties)) :
                                                    (FHasPermission(NCPERM_RasMyProperties))));
                            }
                            else    // This is a lan connection.
                            {
                                fEnableProperties = true;
                            }

                        case CMIDM_CREATE_BRIDGE:
                        case CMIDM_CONMENU_CREATE_BRIDGE:
                            if((NCCF_BRIDGED | NCCF_FIREWALLED | NCCF_SHARED) & pcfp->dwCharacteristics || NCM_LAN != pcfp->ncm || !FHasPermission(NCPERM_AllowNetBridge_NLA))
                            {
                                fEnableCreateBridge = false;
                            }
                            break;

                        default:
                            break;
                    }
                }
            }
        }

        // Loop through the commands, and disable the commands, if appropriate
        //
        for (dwLoop = 0; dwLoop < g_nFolderCommandCount; dwLoop++)
        {
            switch(g_cteFolderCommands[dwLoop].iCommandId)
            {
            case CMIDM_RENAME:
            case SFVIDM_FILE_RENAME:
                g_cteFolderCommands[dwLoop].fNewState = fEnableRename;
                break;

            case CMIDM_DELETE:
            case SFVIDM_FILE_DELETE:
                g_cteFolderCommands[dwLoop].fNewState = fEnableDelete;
                break;

            case CMIDM_STATUS:
                g_cteFolderCommands[dwLoop].fNewState = fEnableStatus;
                break;

            case CMIDM_CREATE_SHORTCUT:
            case SFVIDM_FILE_LINK:
                g_cteFolderCommands[dwLoop].fNewState = fEnableShortcut;
                break;

            case CMIDM_CONNECT:
            case CMIDM_ENABLE:
                g_cteFolderCommands[dwLoop].fNewState = fEnableConnect;
                break;

            case CMIDM_DISCONNECT:
            case CMIDM_DISABLE:
                g_cteFolderCommands[dwLoop].fNewState = fEnableDisconnect;
                break;

            case CMIDM_FIX:
                g_cteFolderCommands[dwLoop].fNewState = fEnableFix;
                break;
            case CMIDM_CREATE_COPY:
                g_cteFolderCommands[dwLoop].fNewState = fEnableCreateCopy;
                break;

            case CMIDM_PROPERTIES:
            case SFVIDM_FILE_PROPERTIES:
                g_cteFolderCommands[dwLoop].fNewState = fEnableProperties;
                break;

            case CMIDM_CREATE_BRIDGE:
            case CMIDM_CONMENU_CREATE_BRIDGE:
                g_cteFolderCommands[dwLoop].fNewState = fEnableCreateBridge;
                break;

            default:
                break;
            }
        }
    }

    // Process commands whose state is not controlled by selection
    //
    for (dwLoop = 0; dwLoop < g_nFolderCommandCount; dwLoop++)
    {
        // Only allow items to be changed to ENABLED states when they're
        // previously DISABLED
        //
        switch(g_cteFolderCommands[dwLoop].iCommandId)
        {
        case CMIDM_NEW_CONNECTION:
            if (!FHasPermissionFromCache(NCPERM_NewConnectionWizard))
            {
                g_cteFolderCommands[dwLoop].fNewState = false;
            }
            break;

        case CMIDM_CONMENU_ADVANCED_CONFIG:
            if (!FHasPermissionFromCache(NCPERM_AdvancedSettings))
            {
                g_cteFolderCommands[dwLoop].fNewState = false;
            }
            break;

        case CMIDM_CONMENU_OPTIONALCOMPONENTS:
            if (!FHasPermissionFromCache(NCPERM_AddRemoveComponents))
            {
                g_cteFolderCommands[dwLoop].fNewState = false;
            }
            break;

        case CMIDM_CONMENU_DIALUP_PREFS:
            if (!FHasPermissionFromCache(NCPERM_DialupPrefs))
            {
                g_cteFolderCommands[dwLoop].fNewState = false;
            }
        default:
            break;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   DoMenuItemCheckLoop
//
//  Purpose:    Walk through the list of checkmark-able commands and get
//              their values.
//
//  Arguments:
//      None
//
//  Returns:
//
//  Author:     jeffspr   26 Feb 1998
//
//  Notes:
//
VOID DoMenuItemCheckLoop(VOID)
{
    DWORD   dwLoop  = 0;

    for (; dwLoop < g_nFolderCommandCheckCount; dwLoop++)
    {
        switch(g_cceFolderCommands[dwLoop].iCommandId)
        {
            // We used to check SFVIDM_AUTO_ARRANGE, but we no longer force it on.
            //

        case CMIDM_CONMENU_OPERATOR_ASSIST:
            g_cceFolderCommands[dwLoop].fNewCheckState = g_fOperatorAssistEnabled;
            break;
        default:
            break;
        }
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\shell\folder\ishellf.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       I S H E L L F . C P P
//
//  Contents:   IShellFolder implementation for CConnectionFolder
//
//  Notes:      The IShellFolder interface is used to manage folders within
//              the namespace. Objects that support IShellFolder are
//              usually created by other shell folder objects, with the root
//              object (the Desktop shell folder) being returned from the
//              SHGetDesktopFolder function.
//
//  Author:     jeffspr   22 Sep 1997
//
//----------------------------------------------------------------------------


#include "pch.h"
#pragma hdrstop

#include "foldinc.h"    // Standard shell\folder includes
#include "cfutils.h"    // Connections folder utilities
#include "foldres.h"
#include "ncnetcon.h"
#include "ncperms.h"
#include "ncras.h"
#include "cmdtable.h"
#include "webview.h"

#define ENABLE_CONNECTION_TOOLTIP

const WCHAR c_szNetworkConnections[] = L"NetworkConnections";

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolder::ParseDisplayName
//
//  Purpose:    Translates a file object or folder's display name into an
//              item identifier.
//
//  Arguments:
//      hwndOwner       [in]    Handle of owner window
//      pbcReserved     [in]    Reserved
//      lpszDisplayName [in]    Pointer to diplay name
//      pchEaten        [out]   Pointer to value for parsed characters
//      ppidl           [out]   Pointer to new item identifier list
//      pdwAttributes   [out]   Address receiving attributes of file object
//
//  Returns:    Returns NOERROR if successful or an OLE-defined error
//              value otherwise
//
//  Author:     jeffspr   18 Oct 1997

STDMETHODIMP CConnectionFolder::ParseDisplayName(
    HWND            hwndOwner,
    LPBC            pbcReserved,
    LPOLESTR        lpszDisplayName,
    ULONG *         pchEaten,
    LPITEMIDLIST *  ppidl,
    ULONG *         pdwAttributes)
{
    HRESULT hr = S_OK;
    TraceFileFunc(ttidShellFolder);

    if (!ppidl)
    {
        return E_POINTER;
    }

    *ppidl = NULL;

    if ((lpszDisplayName == NULL) ||
        (wcslen(lpszDisplayName) < (c_cchGuidWithTerm - 1)))
    {
        return E_INVALIDARG;
    }

    while (*lpszDisplayName == ':')
    {
        lpszDisplayName++;
    }

    if (*lpszDisplayName != '{')
    {
        return E_INVALIDARG;
    }

    GUID guid;

    if (SUCCEEDED(CLSIDFromString(lpszDisplayName, &guid)))
    {
        if (g_ccl.IsInitialized() == FALSE)
        {
            g_ccl.HrRefreshConManEntries();
        }

        PCONFOLDPIDL pidl;
        hr = g_ccl.HrFindPidlByGuid(&guid, pidl);
        if (S_OK == hr)
        {
            *ppidl = pidl.TearOffItemIdList();
            TraceTag(ttidShellFolderIface, "IShellFolder::ParseDisplayName generated PIDL: 0x%08x", *ppidl);
        }
        else
        {
            hr = E_FILE_NOT_FOUND;
        }
    }
    else
    {
        return(E_FAIL);
    }

    if (SUCCEEDED(hr) && pdwAttributes)
    {   
        LPCITEMIDLIST pidlArr[1];
        pidlArr[0] = *ppidl;
        hr = GetAttributesOf(1, pidlArr, pdwAttributes);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolder::EnumObjects
//
//  Purpose:    Determines the contents of a folder by creating an item
//              enumeration object (a set of item identifiers) that can be
//              retrieved using the IEnumIDList interface.
//
//  Arguments:
//      hwndOwner    [in]   Handle of owner window
//      grfFlags     [in]   Items to include in enumeration
//      ppenumIDList [out]  Pointer to IEnumIDList
//
//  Returns:    Returns NOERROR if successful or an OLE-defined error
//              value otherwise
//
//  Author:     jeffspr   18 Oct 1997
//
//  Notes:
//
STDMETHODIMP CConnectionFolder::EnumObjects(
    HWND            hwndOwner,
    DWORD           grfFlags,
    LPENUMIDLIST *  ppenumIDList)
{
    TraceFileFunc(ttidShellFolder);

    HRESULT hr  = NOERROR;

    Assert(ppenumIDList);

    NETCFG_TRY
        // Create the IEnumIDList object (CConnectionFolderEnum)
        //
        hr = CConnectionFolderEnum::CreateInstance (
                IID_IEnumIDList,
                reinterpret_cast<void**>(ppenumIDList));

        if (SUCCEEDED(hr))
        {
            Assert(*ppenumIDList);

            // Call the PidlInitialize function to allow the enumeration
            // object to copy the list.
            //
            reinterpret_cast<CConnectionFolderEnum *>(*ppenumIDList)->PidlInitialize(
                FALSE, m_pidlFolderRoot, m_dwEnumerationType);

        }
        else
        {
            // On all failures, this should be NULL.
            if (*ppenumIDList)
            {
                ReleaseObj(*ppenumIDList);
            }

            *ppenumIDList = NULL;
        }

    NETCFG_CATCH(hr)
        
    TraceHr(ttidError, FAL, hr, FALSE, "CConnectionFolder::EnumObjects");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolder::BindToObject
//
//  Purpose:    Creates an IShellFolder object for a subfolder.
//
//  Arguments:
//      pidl        [in]    Pointer to an ITEMIDLIST
//      pbcReserved [in]    Reserved - specify NULL
//      riid        [in]    Interface to return
//      ppvOut      [out]   Address that receives interface pointer;
//
//  Returns:    Returns NOERROR if successful or an OLE-defined error
//              value otherwise
//
//  Author:     jeffspr   18 Oct 1997
//
//  Notes:      We don't need this function, since we don't have subfolders.
//
STDMETHODIMP CConnectionFolder::BindToObject(
    LPCITEMIDLIST   pidl,
    LPBC            pbcReserved,
    REFIID          riid,
    LPVOID *        ppvOut)
{
    TraceFileFunc(ttidShellFolder);

    // Note - If we add code here, then we ought to param check pidl
    //
    Assert(pidl);

    *ppvOut = NULL;

    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolder::BindToStorage
//
//  Purpose:    Reserved for a future use. This method should
//              return E_NOTIMPL.
//
//  Arguments:
//      pidl        []  Pointer to an ITEMIDLIST
//      pbcReserved []  Reservedspecify NULL
//      riid        []  Interface to return
//      ppvObj      []  Address that receives interface pointer);
//
//  Returns:    E_NOTIMPL always
//
//  Author:     jeffspr   18 Oct 1997
//
//  Notes:
//
STDMETHODIMP CConnectionFolder::BindToStorage(
    LPCITEMIDLIST   pidl,
    LPBC            pbcReserved,
    REFIID          riid,
    LPVOID *        ppvObj)
{
    TraceFileFunc(ttidShellFolder);

    // Note - If we add code here, then we ought to param check pidl
    //
    Assert(pidl);

    *ppvObj = NULL;

    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolder::CompareIDs
//
//  Purpose:    Determines the relative ordering of two file objects or
//              folders, given their item identifier lists.
//
//  Arguments:
//      lParam [in]     Type of comparison to perform
//      pidl1  [in]     Address of ITEMIDLIST structure
//      pidl2  [in]     Address of ITEMIDLIST structure
//
//  Returns:    Returns a handle to a result code. If this method is
//              successful, the CODE field of the status code (SCODE) has
//              the following meaning:
//
//              CODE field          Meaning
//              ----------          -------
//              Less than zero      The first item should precede the second
//                                  (pidl1 < pidl2).
//              Greater than zero   The first item should follow the second
//                                  (pidl1 > pidl2)
//              Zero                The two items are the same (pidl1 = pidl2)
//
//  Author:     jeffspr   18 Oct 1997
//
//  Notes:      Passing 0 as the lParam indicates sort by name.
//              0x00000001-0x7fffffff are for folder specific sorting rules.
//              0x80000000-0xfffffff are used the system.
//
STDMETHODIMP CConnectionFolder::CompareIDs(
    LPARAM          lParam,
    LPCITEMIDLIST   pidl1,
    LPCITEMIDLIST   pidl2)
{
    TraceFileFunc(ttidShellFolder);

    HRESULT         hr          = S_OK;
    int             iCompare    = 0;
    CONFOLDENTRY    pccfe1;
    CONFOLDENTRY    pccfe2;
    PCONFOLDPIDL    pcfp1;
    PCONFOLDPIDL    pcfp2;
    ConnListEntry   cle1;
    ConnListEntry   cle2;
    PCWSTR          pszString1  = NULL;
    PCWSTR          pszString2  = NULL;
    INT             iStringID1  = 0;
    INT             iStringID2  = 0;

    hr = pcfp1.InitializeFromItemIDList(pidl1);
    if (SUCCEEDED(hr))
    {
        hr = pcfp2.InitializeFromItemIDList(pidl2);
    }
    
    // Make sure that the pidls passed in are our pidls.
    //
    if (FAILED(hr))
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    if (WIZARD_NOT_WIZARD != pcfp1->wizWizard && WIZARD_NOT_WIZARD != pcfp2->wizWizard)
    {
        hr = ResultFromShort(0);

        if (pcfp1->wizWizard > pcfp2->wizWizard)
            hr = ResultFromShort(-1);

        if (pcfp1->wizWizard < pcfp2->wizWizard)
            hr = ResultFromShort(1);

        goto Exit;
    }

    // If the first item is a wizard, then it comes first.
    //
    if (WIZARD_NOT_WIZARD != pcfp1->wizWizard)
    {
        hr = ResultFromShort(-1);
        goto Exit;
    }

    // If the second item is a wizard, then, well, you get the picture.
    //
    if (WIZARD_NOT_WIZARD != pcfp2->wizWizard)
    {
        hr = ResultFromShort(1);
        goto Exit;
    }

    // Note: (jeffspr) & SHC... should be removed once Victor Tan checks in a fix 
    // for the IShellFolder2 params being used in IShellFolder
    //
    switch(lParam & SHCIDS_COLUMNMASK)
    {
        case ICOL_NAME:
            {
                // Check the name. If the name is the same, then we need to
                // check the GUID as well, because we HAVE TO allow duplicate names,
                // and this function is used to uniquely identify connections for
                // notification purposes
                //
                LPCWSTR szPcfpName1 = pcfp1->PszGetNamePointer() ? pcfp1->PszGetNamePointer() : L"\0";
                LPCWSTR szPcfpName2 = pcfp2->PszGetNamePointer() ? pcfp2->PszGetNamePointer() : L"\0";

                iCompare = lstrcmpW(szPcfpName1, szPcfpName2);
                if (iCompare == 0)
                {
                    if (!InlineIsEqualGUID(pcfp1->guidId, pcfp2->guidId))
                    {
                        // Doesn't really matter which order we put them
                        // in, as long as we call them non-equal
                        iCompare = -1;
                    }
                }
            }
            break;

        case ICOL_TYPE:
            {
                MapNCMToResourceId(pcfp1->ncm, pcfp1->dwCharacteristics, &iStringID1);
                MapNCMToResourceId(pcfp2->ncm, pcfp2->dwCharacteristics, &iStringID2);
                pszString1 = (PWSTR) SzLoadIds(iStringID1);
                pszString2 = (PWSTR) SzLoadIds(iStringID2);
                if (pszString1 && pszString2)
                {
                    iCompare = lstrcmpW(pszString1, pszString2);
                }
            }
            break;

        case ICOL_STATUS:
            {
                WCHAR szString1[CONFOLD_MAX_STATUS_LENGTH];
                WCHAR szString2[CONFOLD_MAX_STATUS_LENGTH];
                MapNCSToComplexStatus(pcfp1->ncs, pcfp1->ncm, pcfp1->ncsm, pcfp1->dwCharacteristics, szString1, CONFOLD_MAX_STATUS_LENGTH, pcfp1->guidId);
                MapNCSToComplexStatus(pcfp2->ncs, pcfp2->ncm, pcfp1->ncsm, pcfp2->dwCharacteristics, szString2, CONFOLD_MAX_STATUS_LENGTH, pcfp2->guidId);
                iCompare = lstrcmpW(szString1, szString2);
            }
            break;

        case ICOL_DEVICE_NAME:
            {
                LPCWSTR szPcfpDeviceName1 = pcfp1->PszGetDeviceNamePointer() ? pcfp1->PszGetDeviceNamePointer() : L"\0";
                LPCWSTR szPcfpDeviceName2 = pcfp2->PszGetDeviceNamePointer() ? pcfp2->PszGetDeviceNamePointer() : L"\0";
                iCompare = lstrcmpW(szPcfpDeviceName1, szPcfpDeviceName2);
            }
            break;

        case ICOL_OWNER:
            {
                pszString1 = PszGetOwnerStringFromCharacteristics(pszGetUserName(), pcfp1->dwCharacteristics);
                pszString2 = PszGetOwnerStringFromCharacteristics(pszGetUserName(), pcfp2->dwCharacteristics);
                iCompare = lstrcmpW(pszString1, pszString2);
            }
            break;

        case ICOL_PHONEORHOSTADDRESS:
            {
                LPCWSTR szPcfpPhoneHostAddress1 = pcfp1->PszGetPhoneOrHostAddressPointer() ? pcfp1->PszGetPhoneOrHostAddressPointer() : L"\0";
                LPCWSTR szPcfpPhoneHostAddress2 = pcfp2->PszGetPhoneOrHostAddressPointer() ? pcfp2->PszGetPhoneOrHostAddressPointer() : L"\0";
                iCompare = lstrcmpW(szPcfpPhoneHostAddress1, szPcfpPhoneHostAddress2);
            }
            break;

        default:
//            AssertFmt(FALSE, FAL, "Shell bug - Sorting on unknown category. Column = %x", (lParam & SHCIDS_COLUMNMASK));
            hr = E_INVALIDARG;
            break;
    }


    if (SUCCEEDED(hr))
    {
        hr = ResultFromShort(iCompare);
    }

Exit:
    // If these were allocated instead of cached, delete them
    //
    TraceHr(ttidError, FAL, hr,
            (ResultFromShort(-1) == hr) || (ResultFromShort(1) == hr),
            "CConnectionFolder::CompareIDs");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolder::CreateViewObject
//
//  Purpose:    Creates a view object of a folder.
//
//  Arguments:
//      hwndOwner [in]      Handle of owner window
//      riid      [in]      Interface identifier
//      ppvOut    [none]    Reserved
//
//  Returns:    Returns NOERROR if successful or an OLE defined error
//              value otherwise.
//
//  Author:     jeffspr   18 Oct 1997
//
//  Notes:
//
STDMETHODIMP CConnectionFolder::CreateViewObject(
    HWND        hwndOwner,
    REFIID      riid,
    LPVOID *    ppvOut)
{
    TraceFileFunc(ttidShellFolder);

    HRESULT hr  = E_NOINTERFACE;

    Assert(ppvOut);
    Assert(this);

    // Pre-initialize the out param, per OLE guidelines
    //
    *ppvOut = NULL;

    if (riid == IID_IShellView)
    {
        if (FHasPermission(NCPERM_OpenConnectionsFolder))
        {
            SFV_CREATE sfv = {0};
            sfv.cbSize         = sizeof(sfv);
            sfv.pshf           = dynamic_cast<IShellFolder2*>(this);
            sfv.psfvcb         = dynamic_cast<IShellFolderViewCB*>(this);

            // Note: The shell never gets around to freeing the last view
            //          when shutting down...
            //
            hr = SHCreateShellFolderView(&sfv, &m_pShellView);
            if (SUCCEEDED(hr))
            {
                *ppvOut = m_pShellView;
                DWORD   dwErr   = 0;

                // Get the state of the "ManualDial" flag from RAS
                // so we can initialize our global
                //
                dwErr = RasUserGetManualDial(
                    hwndOwner,
                    FALSE,
                    (PBOOL) (&g_fOperatorAssistEnabled));

                // Ignore the error (don't shove it in the Hr), because
                // we still want to run even if we failed to get the value
                // Trace it, though
                Assert(dwErr == 0);
                TraceHr(ttidShellFolder, FAL, HRESULT_FROM_WIN32(dwErr), FALSE,
                        "RasUserGetManualDial call from CreateViewObject");
            }
        }
        else
        {
            TraceTag(ttidShellFolder, "No permission to open connections folder (FHasPermission returned 0)");
            AssertSz(FALSE, "get off!");

            if (hwndOwner)
            {
                NcMsgBox(_Module.GetResourceInstance(), hwndOwner,
                    IDS_CONFOLD_WARNING_CAPTION,
                    IDS_CONFOLD_NO_PERMISSIONS_FOR_OPEN,
                    MB_ICONEXCLAMATION | MB_OK);

                hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);   // user saw the error
            }
            else
            {
                hr = E_ACCESSDENIED;
            }
        }
    }
    else if (riid == IID_IContextMenu)
    {
        // Create our context menu object for the background CMs.
        //
        hr = CConnectionFolderContextMenu::CreateInstance (
                IID_IContextMenu,
                reinterpret_cast<void**>(ppvOut),
                CMT_BACKGROUND,
                hwndOwner,
                PCONFOLDPIDLVEC(NULL),
                this);
        if (SUCCEEDED(hr))
        {
            Assert(*ppvOut);
        }
     }
     else if (riid == IID_ICategoryProvider)
     {
         // Create our context menu object for the background CMs.
         //
         
         CComPtr<IDefCategoryProvider> pDevCategoryProvider;
         hr = CoCreateInstance(CLSID_DefCategoryProvider, NULL, CLSCTX_ALL, IID_IDefCategoryProvider, reinterpret_cast<LPVOID *>(&pDevCategoryProvider));
         if (SUCCEEDED(hr))
         {
             
             SHCOLUMNID pscidType, pscidPhoneOrHostAddress;
             MapColumnToSCID(ICOL_TYPE, &pscidType);
             MapColumnToSCID(ICOL_PHONEORHOSTADDRESS, &pscidPhoneOrHostAddress);
             
             SHCOLUMNID pscidExclude[2];
             pscidExclude[0].fmtid = GUID_NETSHELL_PROPS;
             pscidExclude[0].pid   = ICOL_PHONEORHOSTADDRESS;
             
             pscidExclude[1].fmtid = GUID_NULL;
             pscidExclude[1].pid   = 0;
             
             CATLIST catList[] = 
             {
                 {&GUID_NULL, NULL}
             };
             
             if (SUCCEEDED(hr))
             {
                 pDevCategoryProvider->Initialize(&GUID_NETSHELL_PROPS,
                     &pscidType,
                     pscidExclude,
                     NULL,
                     catList,
                     this);
                 
                 hr = pDevCategoryProvider->QueryInterface(IID_ICategoryProvider, ppvOut);
             }
         }
     }
     else
     {
         goto Exit;
     }

Exit:

    TraceHr(ttidError, FAL, hr, (E_NOINTERFACE == hr),
            "CConnectionFolder::CreateViewObject");

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolder::GetAttributesOf
//
//  Purpose:    Retrieves the attributes that all passed-in objects (file
//              objects or subfolders) have in common.
//
//  Arguments:
//      cidl     [in]   Number of file objects
//      apidl    [in]   Pointer to array of pointers to ITEMIDLIST structures
//      rgfInOut [out]  Address of value containing attributes of the
//                      file objects
//
//  Returns:    Returns NOERROR if successful or an OLE-defined error
//              value otherwise.
//
//  Author:     jeffspr   18 Oct 1997
//
//  Notes:
//
STDMETHODIMP CConnectionFolder::GetAttributesOf(
    UINT            cidl,
    LPCITEMIDLIST * apidl,
    ULONG *         rgfInOut)
{
    TraceFileFunc(ttidShellFolder);

    HRESULT         hr              = S_OK;
    ULONG           rgfMask         = 0;
    PCONFOLDPIDL    pcfp;

    if (cidl > 0)
    {
        PCONFOLDPIDLVEC pcfpVec;
        hr = PConfoldPidlVecFromItemIdListArray(apidl, cidl, pcfpVec);
        if (FAILED(hr))
        {
            return E_INVALIDARG;
        }
        
        // Prepopulate with all values (removed CANCOPY and CANMOVE)
        //
        rgfMask =   SFGAO_CANDELETE |
                    SFGAO_CANRENAME     |
                    SFGAO_CANLINK       |
                    SFGAO_HASPROPSHEET;

        // Disable propsheets for > 1 connection
        //
        if (cidl > 1)
        {
            rgfMask &= ~SFGAO_HASPROPSHEET;
        }

        PCONFOLDPIDLVEC::const_iterator iterLoop;
        for (iterLoop = pcfpVec.begin(); iterLoop != pcfpVec.end(); iterLoop++)
        {
            // Translate the PIDL to our struct, and check for wizard inclusion.
            // If so, then we don't support anything but "link". If not, then
            // we support all of the standard actions

            const PCONFOLDPIDL& pcfp = *iterLoop;
            if(!pcfp.empty())
            {
                if (((*rgfInOut) & SFGAO_VALIDATE))
                {
                    ConnListEntry cleDontCare;
                    hr = g_ccl.HrFindConnectionByGuid(&(pcfp->guidId), cleDontCare);
                    if (hr != S_OK)
                    {
                        // Note: Remove this when we get RAS notifications, because
                        // we will ALWAYS have the information we need to find the connections
                        // We're doing this because the CM folks are creating RAS icons on the
                        // desktop without us knowing about it.
                        //
                        // If we didn't find it, then flush the cache and try again.
                        //
                        if (S_FALSE == hr)
                        {
                            hr = g_ccl.HrRefreshConManEntries();
                            if (SUCCEEDED(hr))
                            {
                                hr = g_ccl.HrFindConnectionByGuid(&(pcfp->guidId), cleDontCare);
                                if (hr != S_OK)
                                {
                                    hr = E_FAIL;
                                    goto Exit;
                                }
                            }
                        }
                        else
                        {
                            hr = E_FAIL;
                            goto Exit;
                        }
                    }
                }

                if (WIZARD_NOT_WIZARD != pcfp->wizWizard)
                {
                    // No support for delete/rename/etc, since it's the wizard.
                    // However, we want to provide our own "delete" warning when the
                    // wizard is selected along with deleteable connections
                    //
                    rgfMask = SFGAO_CANLINK | SFGAO_CANDELETE;
                }

                if (pcfp->dwCharacteristics & NCCF_BRANDED)
                {
                    if ( !fIsConnectedStatus(pcfp->ncs) && (pcfp->ncs != NCS_DISCONNECTING) )
                    {
                        rgfMask |= SFGAO_GHOSTED;
                    }
                }

                if (pcfp->dwCharacteristics & NCCF_INCOMING_ONLY)
                {
                    rgfMask &= ~SFGAO_CANLINK;
                }

                // Mask out the unavailable attributes for this connection
                //
                if (!(pcfp->dwCharacteristics & NCCF_ALLOW_RENAME) || !HasPermissionToRenameConnection(pcfp))
                {
                    rgfMask &= ~SFGAO_CANRENAME;
                }

    #if 0   // If I mask this out, I can't give user feedback for objects that can't be deleted.
                if (pcfp->dwCharacteristics & NCCF_ALLOW_REMOVAL)
                {
                    rgfMask |= SFGAO_CANDELETE;
                }
    #endif
            }
        }
    }
    else
    {
        // Apparently, we're called with 0 objects to indicate that we're
        // supposed to return flags for the folder itself, not an individual
        // object. Weird.
        rgfMask = SFGAO_CANCOPY   |
                  SFGAO_CANDELETE |
                  SFGAO_CANMOVE   |
                  SFGAO_CANRENAME |
                  SFGAO_DROPTARGET;
    }

Exit:
    if (SUCCEEDED(hr))
    {
        *rgfInOut &= rgfMask;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolder::GetUIObjectOf
//
//  Purpose:    Creates a COM object that can be used to carry out actions
//              on the specified file objects or folders, typically, to
//              create context menus or carry out drag-and-drop operations.
//
//  Arguments:
//      hwndOwner [in]      Handle to owner window
//      cidl      [in]      Number of objects specified in apidl
//      apidl     [in]      Pointer to an array of pointers to an ITEMIDLIST
//      riid      [in]      Interface to return
//      prgfInOut [none]    Reserved
//      ppvOut    [out]     Address to receive interface pointer
//
//  Returns:    Returns NOERROR if successful or an OLE-defined error
//              value otherwise
//
//  Author:     jeffspr   18 Oct 1997
//
//  Notes:
//
STDMETHODIMP CConnectionFolder::GetUIObjectOf(
    HWND            hwndOwner,
    UINT            cidl,
    LPCITEMIDLIST * apidl,
    REFIID          riid,
    UINT *          prgfInOut,
    LPVOID *        ppvOut)
{
    TraceFileFunc(ttidShellFolder);

    HRESULT hr  = E_NOINTERFACE;

    NETCFG_TRY
        
        if (cidl >= 1)
        {
            Assert(apidl);
            Assert(apidl[0]);
            Assert(ppvOut);

            if (riid == IID_IDataObject)
            {
                // Need to initialize so the SUCCEEED check below doesn't fail.
                //
                hr = S_OK;

                if (m_pidlFolderRoot.empty())
                {
                    hr = HrGetConnectionsFolderPidl(m_pidlFolderRoot);
                }
                
                if (SUCCEEDED(hr))
                {
                    Assert(!m_pidlFolderRoot.empty());

                    // Internal IDataObject impl removed. Replaced with common
                    // shell code.
                    //
                    hr = CIDLData_CreateFromIDArray(m_pidlFolderRoot.GetItemIdList(), cidl, apidl, (IDataObject **) ppvOut);
                }
            }
            else if (riid == IID_IContextMenu)
            {
                PCONFOLDPIDLVEC pcfpVec;
                hr = PConfoldPidlVecFromItemIdListArray(apidl, cidl, pcfpVec);
                if (FAILED(hr))
                {
                    return E_INVALIDARG;
                }
                
                // Create our context menu object for the background CMs.
                //
                if (SUCCEEDED(hr))
                {
                    hr = CConnectionFolderContextMenu::CreateInstance (
                            IID_IContextMenu,
                            reinterpret_cast<void**>(ppvOut),
                            CMT_OBJECT,
                            hwndOwner,
                            pcfpVec,
                            this);
                    if (SUCCEEDED(hr))
                    {
                        Assert(*ppvOut);
                    }
                    else
                    {
                        hr = E_NOINTERFACE;
                    }
                }
            }
            else if (riid == IID_IExtractIconA || riid == IID_IExtractIconW)
            {
                if (cidl == 1)
                {
                    hr = CConnectionFolderExtractIcon::CreateInstance (
                            apidl[0],
                            riid,
                            reinterpret_cast<void**>(ppvOut));

                    if (SUCCEEDED(hr))
                    {
                        Assert(*ppvOut);
                    }
                }
                else
                {
                    hr = E_NOINTERFACE;
                }
            }
            else if (riid == IID_IDropTarget)
            {
                hr = E_NOINTERFACE;
            }
            else if (riid == IID_IQueryAssociations)
            {
                CComPtr<IQueryAssociations> pQueryAssociations;

                hr = AssocCreate(CLSID_QueryAssociations, IID_IQueryAssociations, reinterpret_cast<LPVOID *>(&pQueryAssociations));
                if (SUCCEEDED(hr))
                {
                    hr = pQueryAssociations->Init(0, c_szNetworkConnections, NULL, NULL);
                    if (SUCCEEDED(hr))
                    {
                        hr = pQueryAssociations->QueryInterface(IID_IQueryAssociations, ppvOut);
                    }
                }
            }
            else if (riid == IID_IQueryInfo)
            {
    #ifdef ENABLE_CONNECTION_TOOLTIP
                if (cidl == 1)
                {
                    PCONFOLDPIDLVEC pcfpVec;
                    hr = PConfoldPidlVecFromItemIdListArray(apidl, cidl, pcfpVec);
                    if (FAILED(hr))
                    {
                        return E_INVALIDARG;
                    }
                    
                    const PCONFOLDPIDL& pcfp = *pcfpVec.begin();

                    // Create the IQueryInfo interface
                    hr = CConnectionFolderQueryInfo::CreateInstance (
                            IID_IQueryInfo,
                            reinterpret_cast<void**>(ppvOut));

                    if (SUCCEEDED(hr))
                    {
                        Assert(*ppvOut);

                        reinterpret_cast<CConnectionFolderQueryInfo *>
                            (*ppvOut)->PidlInitialize(*pcfpVec.begin());

                        // Normalize return code
                        //
                        hr = NOERROR;
                    }
                }
                else
                {
                    AssertSz(FALSE, "GetUIObjectOf asked for query info for more than one item!");
                    hr = E_NOINTERFACE;
                }
    #else
                hr = E_NOINTERFACE;
    #endif // ENABLE_CONNECTION_TOOLTIP

            }
            else
            {
                TraceTag(ttidShellFolder, "CConnectionFolder::GetUIObjectOf asked for object "
                         "that it didn't know how to create. 0x%08x", riid.Data1);

                hr = E_NOINTERFACE;
            }
        }

        if (FAILED(hr))
        {
            *ppvOut = NULL;
        }

    NETCFG_CATCH(hr)
        
    TraceHr(ttidError, FAL, hr, (hr == E_NOINTERFACE), "CConnectionFolder::GetUIObjectOf");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolder::GetDisplayNameOf
//
//  Purpose:    Retrieves the display name for the specified file object or
//              subfolder, returning it in a STRRET structure.
//
//  Arguments:
//      pidl   [in]     Pointer to an ITEMIDLIST
//      uFlags [in]     Type of display to return
//      lpName [out]    Pointer to a STRRET structure
//
//  Returns:    Returns NOERROR if successful or an OLE-defined error
//              value otherwise.
//
//  Author:     jeffspr   18 Oct 1997
//
//  Notes:
//
STDMETHODIMP CConnectionFolder::GetDisplayNameOf(
    LPCITEMIDLIST   pidl,
    DWORD           uFlags,
    LPSTRRET        lpName)
{
    TraceFileFunc(ttidShellFolder);

    HRESULT         hr              = S_OK;
    PWSTR           pszStrToCopy    = NULL;

    Assert(lpName);

    if (!pidl || !lpName)
    {
        return E_INVALIDARG;
    }

    PCONFOLDPIDL   pcfpLatestVersion;
    PCONFOLDPIDL   pcfpLatestVersionCached;
    PCONFOLDPIDL98 pcfp98;

    CONFOLDPIDLTYPE cfpt = GetPidlType(pidl);
    switch (cfpt)
    {
        case PIDL_TYPE_V1:
        case PIDL_TYPE_V2:
            if (FAILED(pcfpLatestVersion.InitializeFromItemIDList(pidl)))
            {
               return E_INVALIDARG;
            }
            break;
        case PIDL_TYPE_98: 
            if (FAILED(pcfp98.InitializeFromItemIDList(pidl)))
            {
                return E_INVALIDARG;
            }
            break;

        default:
            AssertSz(FALSE, "CConnectionFolder::GetDisplayNameOf - Invalid PIDL");
            return E_INVALIDARG;
            break;
    }

    if ( (PIDL_TYPE_V1 == cfpt) || (PIDL_TYPE_V2 == cfpt) )
    {
    #ifdef DBG
        // Throw these in here just so I can quickly peek at the values
        // set while I'm dorking around in the debugger.
        //
        DWORD   dwInFolder          = (uFlags & SHGDN_INFOLDER);
        DWORD   dwForAddressBar     = (uFlags & SHGDN_FORADDRESSBAR);
        DWORD   dwForParsing        = (uFlags & SHGDN_FORPARSING);
    #endif

        // Find the correct string for the display name. For the wizard, we get it
        // from the resources. Otherwise, we use the actual connection name
        //
        lpName->uType = STRRET_WSTR;

        if (uFlags & SHGDN_FORPARSING)
        {
            lpName->pOleStr = (LPWSTR)SHAlloc(c_cbGuidWithTerm);

            if (lpName->pOleStr == NULL)
            {
                return(ERROR_NOT_ENOUGH_MEMORY);
            }

            if (StringFromGUID2(pcfpLatestVersion->clsid, lpName->pOleStr, c_cbGuidWithTerm) == 0)
            {
                return(ERROR_INVALID_NAME);
            }

            return(S_OK);
        }
        else if (WIZARD_MNC == pcfpLatestVersion->wizWizard)
        {
            pszStrToCopy = (PWSTR) SzLoadIds(IDS_CONFOLD_WIZARD_DISPLAY_NAME);
        }
        else if (WIZARD_HNW == pcfpLatestVersion->wizWizard)
        {
            pszStrToCopy = (PWSTR) SzLoadIds(IDS_CONFOLD_HOMENET_WIZARD_DISPLAY_NAME);
        }
        else
        {
            hr = g_ccl.HrGetCachedPidlCopyFromPidl(pcfpLatestVersion, pcfpLatestVersionCached);
            if (S_OK == hr)
            {
                pszStrToCopy = pcfpLatestVersionCached->PszGetNamePointer();
            }
            else
            {
                pszStrToCopy = pcfpLatestVersion->PszGetNamePointer();
                hr = S_OK;
            }
        }

        Assert(pszStrToCopy);

        // Allocate a new POLESTR block, which the shell can then free,
        // and copy the displayable portion to it.
        //
        // Note that &lpName->pOleStr is likely misaligned.
        //

        LPWSTR pOleStr;

        pOleStr = lpName->pOleStr;

        hr = HrDupeShellString(pszStrToCopy, &pOleStr );

        lpName->pOleStr = pOleStr;
    }
    else if (PIDL_TYPE_98 == cfpt)
    {
        // Raid#214057, handle win98 pidl for shortcuts
        // Return the offset to the string because we store the display
        // name in the opaque structure.

        lpName->uType = STRRET_OFFSET;
        lpName->uOffset = _IOffset(CONFOLDPIDL98, szaName);
    }
    else
    {
        // not a valid connections pidl (neither Win2K nor Win98).
        //
        hr = E_INVALIDARG;
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CConnectionFolder::GetDisplayNameOf");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolder::SetNameOf
//
//  Purpose:    Changes the name of a file object or subfolder, changing its
//              item identifier in the process.
//
//  Arguments:
//      hwndOwner [in]      Handle of owner window
//      pidl      [in]      Pointer to an ITEMIDLIST structure
//      lpszName  [in]      Pointer to string specifying new display name
//      uFlags    [in]      Type of name specified in lpszName
//      ppidlOut  [out]     Pointer to new ITEMIDLIST
//
//  Returns:    Returns NOERROR if successful or an OLE-defined error
//              value otherwise.
//
//  Author:     jeffspr   18 Oct 1997
//
//  Notes:
//
STDMETHODIMP CConnectionFolder::SetNameOf(
    HWND            hwndOwner,
    LPCITEMIDLIST   pidlShell,
    LPCOLESTR       lpszName,
        DWORD           uFlags,
    LPITEMIDLIST *  ppidlOut)
{
    TraceFileFunc(ttidShellFolder);

    HRESULT             hr          = NOERROR;
    /*
    PWSTR              pszWarning  = NULL;
    INetConnection *    pNetCon     = NULL;
    LPITEMIDLIST        pidlNew     = NULL;
    BOOL                fRefresh    = FALSE;
    BOOL                fActivating = FALSE;
    PCONFOLDENTRY      pccfe       = NULL;
    */
    PCONFOLDPIDL        pcfp;

    Assert(hwndOwner);
    Assert(pidlShell);
    Assert(lpszName);

    if (!pidlShell && !lpszName)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        // check lpszName for validity

        if (!FIsValidConnectionName(lpszName))
        {
            (void) NcMsgBox(
                _Module.GetResourceInstance(),
                hwndOwner,
                IDS_CONFOLD_RENAME_FAIL_CAPTION,
                IDS_CONFOLD_RENAME_INVALID,
                MB_OK | MB_ICONEXCLAMATION);
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_NAME);
        }

        if (SUCCEEDED(hr))
        {
            // Get what's current from the cache so rename works properly
            //
            PCONFOLDPIDL pcfpShell;
            hr = pcfpShell.InitializeFromItemIDList(pidlShell);
            if (SUCCEEDED(hr))
            {
                hr = g_ccl.HrGetCachedPidlCopyFromPidl(pcfpShell, pcfp);
                if (SUCCEEDED(hr))
                {
                    PCONFOLDPIDL pidlOut;
                    hr = HrRenameConnectionInternal(pcfp, m_pidlFolderRoot, lpszName, TRUE, hwndOwner, pidlOut);
                    if ( (ppidlOut) && (SUCCEEDED(hr)) )
                    {
                        *ppidlOut = pidlOut.TearOffItemIdList();
                    }
                }
            }
        }
    }

    if (FAILED(hr) && (ppidlOut))
    {
        *ppidlOut = NULL;
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CConnectionFolder::SetNameOf");
    return hr;
}

STDMETHODIMP CConnectionFolder::MessageSFVCB(
        UINT uMsg,
        WPARAM wParam,
        LPARAM lParam)
{
    TraceFileFunc(ttidShellFolder);
    
    HRESULT hr = RealMessage(uMsg, wParam, lParam);
    if (FAILED(hr))
    {
        switch (uMsg)
        {
        case DVM_INVOKECOMMAND:
            if ((CMIDM_RENAME == wParam) && m_hwndMain && m_pShellView)
            {
                PCONFOLDPIDLVEC apidlSelected;
                PCONFOLDPIDLVEC apidlCache;
                hr = HrShellView_GetSelectedObjects(m_hwndMain, apidlSelected);
                if (SUCCEEDED(hr))
                {
                    // If there are objects, try to get the cached versions
                    if (!apidlSelected.empty())
                    {   
                        hr = HrCloneRgIDL(apidlSelected, TRUE, TRUE, apidlCache);
                    }
                }

                if (SUCCEEDED(hr))
                {
                    Assert(apidlCache.size() == 1);
                    if (apidlCache.size() == 1)
                    {
                        hr = m_pShellView->SelectItem(apidlCache[0].GetItemIdList(), SVSI_EDIT);
                    }
                    else
                    {
                        hr = E_INVALIDARG;
                    }
                }
            }
            break;

        case SFVM_HWNDMAIN:
            // _hwndMain = (HWND)lParam;
            hr = S_OK;
            break;
        }
    }
    return hr;
}

/*
//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolder::GetOverlayIndex
//
//  Purpose:    Adds icon overlays to connections that need them
//
//  Arguments:
//      pidlItem [in]     Pidl to item in question
//      pIndex [out]      Address of overlay index into system image list
//        
//
//  Returns:    Returns NOERROR if successful or an OLE-defined error
//              value otherwise.
//
//  Author:     kenwic   10 May 2000 created, support for sharing overlay
//
//  Notes:
//

STDMETHODIMP CConnectionFolder::GetOverlayIndex(
    LPCITEMIDLIST pidlItem,
    int* pIndex)
{
    TraceFileFunc(ttidShellFolder);

    HRESULT hResult = E_FAIL;
    *pIndex = -1;

    // check to see if connection is sharing, and if so add sharing hand overlay
    // i can't call HrNetConFromPidl, because it asserts if passed the wizard icon
    
    PCONFOLDPIDL pcfpItem;
    pcfpItem.InitializeFromItemIDList(pidlItem);

    CONFOLDENTRY pConnectionFolderEntry;
    hResult = pcfpItem.ConvertToConFoldEntry(pConnectionFolderEntry);
    if(SUCCEEDED(hResult))
    {
        if(FALSE == pConnectionFolderEntry.GetWizard()) // sharing the wizard is not yet supported
        {
            if(NCCF_SHARED & pConnectionFolderEntry.GetCharacteristics())
            {
                *pIndex = SHGetIconOverlayIndex(NULL, IDO_SHGIOI_SHARE);
                hResult = S_OK;
            }
            else
            {
                hResult = E_FAIL; // the docs for IShellIconOverlay are wrong, we must return failure to deny the icon
            }
        }
        else
        {
            hResult = E_FAIL;
        }
    }
    
    TraceHr(ttidShellFolder, FAL, hResult, TRUE, "CConnectionFolder::GetOverlayIndex");
    return hResult;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolder::GetOverlayIconIndex
//
//  Purpose:    Adds icon overlays to connections that need them
//
//  Arguments:
//      pidlItem [in]     Pidl to item in question
//      pIconIndex [out]      Address of index into system image list
//        
//
//  Returns:    Returns NOERROR if successful or an OLE-defined error
//              value otherwise.
//
//  Author:     kenwic   10 May 2000 created
//
//  Notes:
//
STDMETHODIMP CConnectionFolder::GetOverlayIconIndex(
    LPCITEMIDLIST pidlItem,
    int* pIconIndex)
{
    TraceFileFunc(ttidShellFolder);

    *pIconIndex = -1;

    HRESULT hResult = GetOverlayIndex(pidlItem, pIconIndex);
    if(SUCCEEDED(hResult))
    {
        *pIconIndex = INDEXTOOVERLAYMASK(*pIconIndex);
    }

    TraceHr(ttidShellFolder, FAL, hResult, TRUE, "CConnectionFolder::GetOverlayIconIndex");
    return hResult;
}*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\shell\folder\notify.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N O T I F Y . H
//
//  Contents:   Implementation of INetConnectionNotifySink
//
//  Notes:
//
//  Author:     shaunco   21 Aug 1998
//
//----------------------------------------------------------------------------

#pragma once
#include "nsbase.h"
#include "netconp.h"

class ATL_NO_VTABLE CConnectionNotifySink :
    public CComObjectRootEx <CComObjectThreadModel>,
    public INetConnectionNotifySink
{
private:
    PCONFOLDPIDLFOLDER    m_pidlFolder;
    HRESULT HrUpdateIncomingConnection();

public:
    BEGIN_COM_MAP(CConnectionNotifySink)
        COM_INTERFACE_ENTRY(INetConnectionNotifySink)
    END_COM_MAP()

    CConnectionNotifySink() throw() {};
    ~CConnectionNotifySink() throw() ;

    // INetConnectionNotifySink
    STDMETHOD(ConnectionAdded) (
        IN const NETCON_PROPERTIES_EX*    pPropsEx);

    STDMETHOD(ConnectionBandWidthChange) (
        IN const GUID* pguidId);

    STDMETHOD(ConnectionDeleted) (
        IN const GUID* pguidId);

    STDMETHOD(ConnectionModified) (
        IN const NETCON_PROPERTIES_EX* pPropsEx);

    STDMETHOD(ConnectionRenamed) (
        IN const GUID* pguidId,
        IN PCWSTR     pszwNewName);

    STDMETHOD(ConnectionStatusChange) (
        IN const GUID*     pguidId,
        IN NETCON_STATUS   Status);

    STDMETHOD(RefreshAll) ();
    
    STDMETHOD(ConnectionAddressChange) (
        IN const GUID* pguidId );

    STDMETHOD(ShowBalloon) (
        IN const GUID* pguidId, 
        IN const BSTR  szCookie, 
        IN const BSTR  szBalloonText); 

    STDMETHOD(DisableEvents) (
        IN const BOOL  fDisable,
        IN const ULONG ulDisableTimeout);

public:
    static HRESULT CreateInstance (
        IN  REFIID  riid,
        OUT VOID**  ppv);
};

// Helper functions for external modules
//
HRESULT HrGetNotifyConPoint(
    OUT IConnectionPoint **             ppConPoint);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\shell\folder\ishellf2.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       I S H E L L F 2 . C P P
//
//  Contents:   Provide IShellFolder2 interface for CConnectionsFolderDetails
//              interface. Supercedes IShellDetails. This does not describe
//              IShellFolder members of IShellFolder2 - those are provided in ishellf.cpp
//              This object is created by the ishellv code, primarily to support the 
//              WebView data pane in the folder
//
//  Notes:
//
//  Author:     deonb       18 May  20000
//
//----------------------------------------------------------------------------


#include "pch.h"
#pragma hdrstop

#include "foldinc.h"    // Standard shell\folder includes
#include "cfutils.h"    // Connections folder utilities
#include "raserror.h"
#include "naming.h"
//---[ externs ]--------------------------------------------------------------

extern COLS c_rgCols[];

inline HRESULT HrCopyToSTRRET(
    STRRET *    pstr,
    PCWSTR     pszIn)
{
    HRESULT hr          = S_OK;
    UINT    uiByteLen   = (lstrlen(pszIn) + 1) * sizeof(WCHAR);

    Assert(pstr);

    if (!pstr)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        pstr->uType   = STRRET_WSTR;
        pstr->pOleStr = (PWSTR) SHAlloc(uiByteLen);

        if (pstr->pOleStr == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            CopyMemory(pstr->pOleStr, pszIn, uiByteLen);
        }
    }

    TraceHr(ttidShellFolder, FAL, hr, FALSE, "HrCopyToSTRRET");
    return hr;
}

const WCHAR c_szDevice[] = L"\\DEVICE\\";
const WCHAR c_szLocalSubnet[] = L"255.255.255.255";
const WCHAR c_crlf[] = L"\r\n";

HRESULT HrGetAutoNetSetting(PWSTR pszGuid, DHCP_ADDRESS_TYPE * pAddrType);
HRESULT HrGetAutoNetSetting(REFGUID pGuidId, DHCP_ADDRESS_TYPE * pAddrType);

//+---------------------------------------------------------------------------
//
//  Member:     GetAutoNetSettingsForAdapter
//
//  Purpose:    Get the AutoNet settings for an adapter and return inside a
//              formatted string
//
//  Arguments:
//      cfe            [in]  The connectoid
//      uiFormatString [in]  ResourceID of the FormatMessage (not sprintf) compatible 
//                           Format string
//      szString       [out] Output string
//
//  Returns:
//
//  Author:     deonb   2 April 2001
//
//  Notes:
//
HRESULT GetAutoNetSettingsForAdapter(IN const CConFoldEntry& cfe, IN UINT uiFormatString, OUT tstring& szString)
{
    HRESULT hr = S_OK;

    LPCWSTR szTmpString = NULL;

    if (IsMediaRASType(cfe.GetNetConMediaType()))
    {
        szTmpString = SzLoadIds(IDS_DHCP_ISP);
    }
    else
    {
        DHCP_ADDRESS_TYPE DhcpAddress;
        hr = HrGetAutoNetSetting(cfe.GetGuidID(), &DhcpAddress);
        if (SUCCEEDED(hr))
        {   
            switch (DhcpAddress)
            {
                case UNKNOWN_ADDR:
                    hr = E_FAIL;
                    break;
                case NORMAL_ADDR:
                    szTmpString = SzLoadIds(IDS_DHCP);
                    break;
                case AUTONET_ADDR:
                    szTmpString = SzLoadIds(IDS_AUTONET);
                    break;
                case ALTERNATE_ADDR:
                    szTmpString = SzLoadIds(IDS_ALTERNATE_ADDR);
                    break;
                case STATIC_ADDR:
                    szTmpString = SzLoadIds(IDS_STATIC_CFG);
                    break;
                default:
                    hr = E_FAIL;
                    AssertSz(NULL, "Invalid DHCP Address type");
            }
        }
    }

    if (szTmpString)
    {
        WCHAR szFormatBuf[1024];
        if (DwFormatString(SzLoadIds(uiFormatString), szFormatBuf, 1024, szTmpString))
        {
            szString = szFormatBuf;
        }
        else
        {
            hr = HrFromLastWin32Error();
        }
    }

    TraceHr(ttidShellFolder, FAL, hr, FALSE, "GetAutoNetSettingsForAdapter");

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     GetPrimaryIPAddressForAdapter
//
//  Purpose:    Get the primary IP Address for an adapter and return inside a
//              formatted string
//
//  Arguments:
//      cfe            [in]  The connectoid
//      uiFormatString [in]  ResourceID of the FormatMessage (not sprintf) compatible 
//                           Format string
//      szString       [out] Output string
//
//  Returns:
//
//  Author:     deonb   2 April 2001
//
//  Notes:
//
HRESULT GetPrimaryIPAddressForAdapter(IN const CConFoldEntry& cfe, IN UINT uiFormatString, OUT tstring& szString)
{
    HRESULT hr = S_OK;

    if (IsMediaRASType(cfe.GetNetConMediaType()))
    {
        DWORD     cb = sizeof(RASCONN);
        DWORD     cConnections;
        DWORD     dwErr;
        LPRASCONN pRasConn = reinterpret_cast<LPRASCONN>(new BYTE[cb]);
        if (!pRasConn)
        {
            return E_OUTOFMEMORY;
        }
        pRasConn->dwSize = sizeof(RASCONN);
            
        do 
        {
            dwErr = RasEnumConnections(pRasConn, &cb, &cConnections);
            if (ERROR_BUFFER_TOO_SMALL == dwErr)
            {
                delete[] pRasConn;
                pRasConn = reinterpret_cast<LPRASCONN>(new BYTE[cb]);
                if (!pRasConn)
                {
                    return E_OUTOFMEMORY;
                }
            }
        } while (ERROR_BUFFER_TOO_SMALL == dwErr);

        if (!dwErr)
        {
            Assert( (cb % sizeof(RASCONN)) == 0);

            DWORD dwItems = cb / sizeof(RASCONN);
            for (DWORD x = 0; x < dwItems; x++)
            {
                if (pRasConn[x].guidEntry == cfe.GetGuidID())
                {
                    RASPPPIP rasPPPIP;
                    rasPPPIP.dwSize = sizeof(RASPPPIP);
                    DWORD dwSize = rasPPPIP.dwSize;
                    dwErr = RasGetProjectionInfo(pRasConn[x].hrasconn, RASP_PppIp, &rasPPPIP, &dwSize);
                    if (!dwErr)
                    {
                        WCHAR szFormatBuf[MAX_PATH];
                        if (DwFormatString(
                                    SzLoadIds(uiFormatString),
                                    szFormatBuf,
                                    MAX_PATH, 
                                    rasPPPIP.szIpAddress, 
                                    c_szLocalSubnet
                                    ) )
                        {
                            szString = szFormatBuf;
                        }
                        else
                        {
                            hr = HrFromLastWin32Error();
                        }
                    }
                    else
                    {
                        Assert(dwErr != ERROR_BUFFER_TOO_SMALL);

                        hr = HrFromLastWin32Error();
                    }
                }
            }
        }
        else
        {
            hr = HrFromLastWin32Error();
        }
    }
    else
    {
   
        PIP_ADAPTER_INFO pAdapterInfo = NULL;
        DWORD dwOutBufLen = 0;
        DWORD dwRet = ERROR_SUCCESS;

        dwRet = GetAdaptersInfo(pAdapterInfo, &dwOutBufLen);
        if (dwRet == ERROR_BUFFER_OVERFLOW)
        {
            pAdapterInfo = (PIP_ADAPTER_INFO) CoTaskMemAlloc(dwOutBufLen);
            if (NULL == pAdapterInfo)
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else if (ERROR_SUCCESS == dwRet)
        {
            hr = E_FAIL;
        }
        else
        {
            hr = HRESULT_FROM_WIN32(dwRet);
        }

        if (SUCCEEDED(hr))
        {
            dwRet = GetAdaptersInfo(pAdapterInfo, &dwOutBufLen);
            if (ERROR_SUCCESS != dwRet)
            {
                CoTaskMemFree(pAdapterInfo);
                hr = HRESULT_FROM_WIN32(dwRet);
            }

            if (SUCCEEDED(hr))
            {
                WCHAR   wszGuid[c_cchGuidWithTerm];
            
                ::StringFromGUID2(cfe.GetGuidID(), wszGuid, c_cchGuidWithTerm);

                BOOL fFound = FALSE;
                PIP_ADAPTER_INFO pAdapterInfoEnum = pAdapterInfo;
                while (pAdapterInfoEnum)
                {
                    USES_CONVERSION;

                    if (lstrcmp(wszGuid, A2W(pAdapterInfoEnum->AdapterName)) == 0)
                    {
                        LPCWSTR strIPAddress = A2W(pAdapterInfoEnum->IpAddressList.IpAddress.String);
                        LPCWSTR strSubnetMask = A2W(pAdapterInfoEnum->IpAddressList.IpMask.String);
                        LPCWSTR strGateway = A2W(pAdapterInfoEnum->GatewayList.IpAddress.String);

                        WCHAR   szFormatBuf[MAX_PATH];
                        LPCWSTR szMode = NULL;
        
                        if (strIPAddress && strSubnetMask && strGateway)
                        {
                            LPCWSTR szArgs[] = {strIPAddress, strSubnetMask};

                            if (DwFormatString(
                                        SzLoadIds(uiFormatString), // lpSource
                                        szFormatBuf,  // Buffer
                                        MAX_PATH,  // Len
                                        strIPAddress, 
                                        strSubnetMask
                                        ) )
                            {
                                szString = szFormatBuf;
                            }
                            else
                            {
                                hr = HrFromLastWin32Error();
                            }
                        }
                        break;
                    }

                    pAdapterInfoEnum = pAdapterInfoEnum->Next;
                }

                CoTaskMemFree(pAdapterInfo);
            }
        }
    }

    TraceHr(ttidShellFolder, FAL, hr, FALSE, "GetPrimaryIPAddressForAdapter");

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     GetWirelessModeForAdapter
//
//  Purpose:    Get the Wireless mode for an adapter and return inside a
//              formatted string
//
//  Arguments:
//      cfe            [in]  The connectoid
//      uiFormatString [in]  ResourceID of the FormatMessage (not sprintf) compatible 
//                           Format string
//      szString       [out] Output string
//
//  Returns:
//
//  Author:     deonb   2 April 2001
//
//  Notes:
//
HRESULT GetWirelessModeForAdapter(IN const CConFoldEntry& cfe, IN UINT uiFormatString, OUT tstring& szString)
{
    HRESULT hr = S_OK;

    DWORD dwInfraStructureMode = 0;
    DWORD dwInfraStructureModeSize = sizeof(DWORD);
    
    hr = HrQueryNDISAdapterOID(cfe.GetGuidID(), 
                          OID_802_11_INFRASTRUCTURE_MODE, 
                          &dwInfraStructureModeSize,
                          &dwInfraStructureMode);
    if (SUCCEEDED(hr))
    {
        WCHAR   szTmpBuf[MAX_PATH];
        LPCWSTR szMode = NULL;
    
        switch (dwInfraStructureMode)
        {
            case Ndis802_11IBSS:
                szMode = SzLoadIds(IDS_TOOLTIP_ADHOC);
                break;
            case Ndis802_11Infrastructure:
                szMode = SzLoadIds(IDS_TOOLTIP_INFRASTRUCTURE);
                break;
        }

        if (szMode)
        {
            if (DwFormatString(
                        SzLoadIds(uiFormatString), 
                        szTmpBuf,  // Buffer
                        MAX_PATH,  // Len
                        szMode
                        ))
            {
                szString = szTmpBuf;
            }
            else
            {
                hr = HrFromLastWin32Error();
            }
        }
    }

    TraceHr(ttidShellFolder, FAL, hr, FALSE, "GetWirelessModeForAdapter");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     GetWirelessSSIDForAdapter
//
//  Purpose:    Get the Wireless SSID for an adapter and return inside a
//              formatted string
//
//  Arguments:
//      cfe            [in]  The connectoid
//      uiFormatString [in]  ResourceID of the FormatMessage (not sprintf) compatible 
//                           Format string
//      szString       [out] Output string
//
//  Returns:
//
//  Author:     deonb   4 April 2001
//
//  Notes:
//
HRESULT GetWirelessSSIDForAdapter(IN const CConFoldEntry& cfe, IN UINT uiFormatString, OUT tstring& szString)
{
    HRESULT hr = S_OK;
    
    NDIS_802_11_SSID ndisSSID;
    DWORD dwndisSSIDSize = sizeof(NDIS_802_11_SSID);
    
    hr = HrQueryNDISAdapterOID(cfe.GetGuidID(), 
                          OID_802_11_SSID, 
                          &dwndisSSIDSize,
                          &ndisSSID);

    if (SUCCEEDED(hr))
    {
        if (ndisSSID.SsidLength > 1)
        {
            WCHAR szuSSID[sizeof(ndisSSID.Ssid)+1];

            DWORD dwLen = ndisSSID.SsidLength;
            if (dwLen > sizeof(ndisSSID.Ssid))
            {
                dwLen = sizeof(ndisSSID.Ssid);
                AssertSz(FALSE, "Unexpected SSID encountered");
            }

            ndisSSID.Ssid[dwLen] = 0;
            mbstowcs(szuSSID, reinterpret_cast<LPSTR>(ndisSSID.Ssid), celems(szuSSID));

            WCHAR   szTmpBuf[MAX_PATH];

            if (DwFormatString(
                        SzLoadIds(uiFormatString), 
                        szTmpBuf,  // Buffer
                        MAX_PATH,  // Len
                        szuSSID
                        ))
            {
                szString = szTmpBuf;
            }
            else
            {
                hr = HrFromLastWin32Error();
            }
        }
        else
        {
            hr = E_FAIL;
        }
    }

    TraceHr(ttidShellFolder, FAL, hr, FALSE, "GetWirelessModeForAdapter");
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     GetWirelessEncryptionForAdapter
//
//  Purpose:    Get the Wireless Encryption for an adapter and return inside a
//              formatted string
//
//  Arguments:
//      cfe            [in]  The connectoid
//      uiFormatString [in]  ResourceID of the FormatMessage (not sprintf) compatible 
//                           Format string
//      szString       [out] Output string
//
//  Returns:
//
//  Author:     deonb   4 April 2001
//
//  Notes:
//
HRESULT GetWirelessEncryptionForAdapter(IN const CConFoldEntry& cfe, IN UINT uiFormatString, OUT tstring& szString)
{
    HRESULT hr = S_OK;
    
    DWORD dwEncryption = 0;
    DWORD dwEncryptionSize = sizeof(DWORD);
    
    hr = HrQueryNDISAdapterOID(cfe.GetGuidID(), 
                          OID_802_11_WEP_STATUS, 
                          &dwEncryptionSize,
                          &dwEncryption);
    if (SUCCEEDED(hr))
    {
        WCHAR   szTmpBuf[MAX_PATH];
        LPCWSTR szMode = NULL;
    
        if (Ndis802_11WEPEnabled == dwEncryption)
        {
            szMode = SzLoadIds(IDS_CONFOLD_STATUS_ENABLED);
        }
        else
        {
            szMode = SzLoadIds(IDS_CONFOLD_STATUS_DISABLED);
        }

        if (szMode)
        {
            if (DwFormatString(
                        SzLoadIds(uiFormatString), 
                        szTmpBuf,  // Buffer
                        MAX_PATH,  // Len
                        szMode
                        ))
            {
                szString = szTmpBuf;
            }
            else
            {
                hr = HrFromLastWin32Error();
            }
        }
    }

    TraceHr(ttidShellFolder, FAL, hr, FALSE, "GetWirelessEncryptionForAdapter");
    return hr;
}



//+---------------------------------------------------------------------------
//
//  Member:     GetWirelessSignalStrengthForAdapter
//
//  Purpose:    Get the Wireless Signal Strength for an adapter and return inside a
//              formatted string
//
//  Arguments:
//      cfe            [in]  The connectoid
//      uiFormatString [in]  ResourceID of the FormatMessage (not sprintf) compatible 
//                           Format string
//      szString       [out] Output string
//
//  Returns:
//
//  Author:     deonb   4 April 2001
//
//  Notes:
//
HRESULT GetWirelessSignalStrengthForAdapter(IN const CConFoldEntry& cfe, IN UINT uiFormatString, OUT tstring& szString)
{
    HRESULT hr = S_OK;
    
    DWORD pdwEnumValue;

    LONG  lSignalStrength = 0;
    DWORD dwSignalStrengthSize = sizeof(DWORD);
    
    hr = HrQueryNDISAdapterOID(cfe.GetGuidID(), 
                          OID_802_11_RSSI, 
                          &dwSignalStrengthSize,
                          &lSignalStrength);
    if (SUCCEEDED(hr))
    {
        WCHAR   szTmpBuf[MAX_PATH];
 
        if (DwFormatString(
                    SzLoadIds(uiFormatString), 
                    szTmpBuf,  // Buffer
                    MAX_PATH,  // Len
                    PszGetRSSIString(lSignalStrength)))
        {
            szString = szTmpBuf;
        }
        else
        {
            hr = HrFromLastWin32Error();
        }
    }

    TraceHr(ttidShellFolder, FAL, hr, FALSE, "GetWirelessSignalStrengthForAdapter");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolderDetails::GetDetailsOf
//
//  Purpose:    Returns the column information, either for the columns
//              themselves, or for the actual details of the view items.
//
//  Arguments:
//      pidl      [in]  The pidl for the object being requested
//      iColumn   [in]  The details column needed
//      lpDetails [in]  Buffer that receives the detail data
//
//  Returns:
//
//  Author:     jeffspr   16 Mar 1998
//
//  Notes:
//
HRESULT CConnectionFolder::GetDetailsOf(
                                        LPCITEMIDLIST   pidl,
                                        UINT            iColumn,
                                        LPSHELLDETAILS  lpDetails)
{
    TraceFileFunc(ttidShellFolder);

    HRESULT         hr          = S_OK;
    PCWSTR          pszString   = NULL;
    WCHAR szStatus[CONFOLD_MAX_STATUS_LENGTH];
    tstring szTmpString;

    // If the column requested is beyond our set of columns,
    // return failure.
    //
    if (((INT)iColumn < 0) || ((INT)iColumn >= ICOL_MAX))
    {
        hr = E_FAIL;
    }
    else
    {
        // If NULL, caller wants strings for the column headers
        //
        CONFOLDENTRY  cfe; // Need this scope as we assign pszString from it.
        
        if (NULL == pidl)
        {
            if (c_rgCols[iColumn].iStringRes)
            {
                pszString = SzLoadIds(c_rgCols[iColumn].iStringRes);
            }
            lpDetails->fmt = c_rgCols[iColumn].iFormat;
            lpDetails->cxChar = c_rgCols[iColumn].iColumnSize;

        }
        else
        {
            INT             iStringRes  = 0;

            PCONFOLDPIDL  pcfp;
            hr = pcfp.InitializeFromItemIDList(pidl);
            if (FAILED(hr))
            {
                return hr;               
            }

            hr = pcfp.ConvertToConFoldEntry(cfe);

            if (SUCCEEDED(hr))
            {
                Assert(!cfe.empty());
                lpDetails->fmt = c_rgCols[iColumn].iColumnSize;
                lpDetails->cxChar = c_rgCols[iColumn].iColumnSize;

                if (!cfe.GetWizard())
                {
                    // Retrieve the appropriate column
                    //
                    switch(iColumn)
                    {
                        case ICOL_NAME:         // 0
                            pszString = cfe.GetName();
                            break;

                        case ICOL_TYPE:         // 1
                            MapNCMToResourceId(cfe.GetNetConMediaType(), cfe.GetCharacteristics(), &iStringRes);
                            pszString = SzLoadIds(iStringRes);
                            break;

                        case ICOL_STATUS:       // 2
                            MapNCSToComplexStatus(cfe.GetNetConStatus(), cfe.GetNetConMediaType(), cfe.GetNetConSubMediaType(), cfe.GetCharacteristics(), szStatus, CONFOLD_MAX_STATUS_LENGTH, cfe.GetGuidID());
                            pszString = szStatus;
                            break;

                        case ICOL_DEVICE_NAME:  // 3
                            pszString = cfe.GetDeviceName();
                            break;

                        case ICOL_PHONEORHOSTADDRESS:  // 4
                        case ICOL_PHONENUMBER:         // 7 
                        case ICOL_HOSTADDRESS:         // 8
                            pszString = cfe.GetPhoneOrHostAddress();
                            break;

                        case ICOL_OWNER:        // 5
                            if (cfe.GetCharacteristics() & NCCF_ALL_USERS)
                            {
                                pszString = SzLoadIds(IDS_CONFOLD_DETAILS_OWNER_SYSTEM);
                            }
                            else
                            {
                                pszString = PszGetOwnerStringFromCharacteristics(pszGetUserName(), cfe.GetCharacteristics() );
                            }
                            break;

                        case ICOL_ADDRESS:  //6
                            {
                                if (!fIsConnectedStatus(cfe.GetNetConStatus()))
                                {
                                    hr = E_FAIL;
                                }
                                else
                                {
                                    BOOL bSomeDetail = FALSE;
                                    tstring szAutonet;
                                    tstring szIp;

                                    hr = GetPrimaryIPAddressForAdapter(cfe, IDS_DETAILS_IP_ADDRESS, szIp);
                                    if (SUCCEEDED(hr))
                                    {
                                        szTmpString += szIp;
                                        bSomeDetail = TRUE;
                                    }

                                    hr = GetAutoNetSettingsForAdapter(cfe, IDS_DETAILS_ADDRESS_TYPE, szAutonet);
                                    if (SUCCEEDED(hr))
                                    {
                                        if (bSomeDetail)
                                        {
                                            szTmpString += c_crlf;
                                        }
                                        szTmpString += szAutonet;
                                        bSomeDetail = TRUE;
                                    }

                                    if (bSomeDetail)
                                    {
                                        hr = S_OK;
                                        pszString = szTmpString.c_str();
                                    }
                                }
                            }

                            break;

                        case ICOL_WIRELESS_MODE:
                            {
                                if ( (NCS_DISCONNECTED != cfe.GetNetConStatus()) &&
                                     (NCS_HARDWARE_DISABLED != cfe.GetNetConStatus()) &&
                                     (NCS_HARDWARE_MALFUNCTION!= cfe.GetNetConStatus()) &&
                                     (NCS_HARDWARE_NOT_PRESENT!= cfe.GetNetConStatus()) &&
                                     (NCS_MEDIA_DISCONNECTED != cfe.GetNetConStatus()) &&
                                     (cfe.GetNetConMediaType() == NCM_LAN) && 
                                     (cfe.GetNetConSubMediaType() == NCSM_WIRELESS) )
                                {
                                    BOOL bSomeDetail = FALSE;
                                    tstring szString;

                                    hr = GetWirelessModeForAdapter(cfe, IDS_DETAILS_802_11_MODE, szString);
                                    if (SUCCEEDED(hr))
                                    {
                                        szTmpString += szString;
                                        bSomeDetail = TRUE;
                                    }

                                    
                                    hr = GetWirelessSSIDForAdapter(cfe, IDS_DETAILS_802_11_SSID_TYPE, szString);
                                    if (SUCCEEDED(hr))
                                    {
                                        if (bSomeDetail)
                                        {
                                            szTmpString += c_crlf;
                                        }
                                        szTmpString += szString;
                                        bSomeDetail = TRUE;
                                    }
                                    
                                    hr = GetWirelessEncryptionForAdapter(cfe, IDS_DETAILS_802_11_ENCRYPTION_TYPE, szString);
                                    if (SUCCEEDED(hr))
                                    {
                                        if (bSomeDetail)
                                        {
                                            szTmpString += c_crlf;
                                        }
                                        szTmpString += szString;
                                        bSomeDetail = TRUE;
                                    }       
                                    
                                    hr = GetWirelessSignalStrengthForAdapter(cfe, IDS_DETAILS_802_11_SIGNAL_STRENGTH, szString);
                                    if (SUCCEEDED(hr))
                                    {
                                        if (bSomeDetail)
                                        {
                                            szTmpString += c_crlf;
                                        }
                                        szTmpString += szString;
                                        bSomeDetail = TRUE;
                                    }       
                                    
                                    if (bSomeDetail)
                                    {
                                        hr = S_OK;
                                        pszString = szTmpString.c_str();
                                    }
                                }
                                else
                                {
                                    hr = E_FAIL;
                                }
                            }

                            break;

                        default:
                            AssertSz(FALSE, "CConnectionFolder::GetDetailsOf - Invalid ICOL from the Shell");
                            pszString = NULL;
                            hr = E_FAIL;
                            break;
                    }
                }
                else
                {
                    // If we're the wizard, and they want the name, then load
                    // the friendly rendition for webview's sake
                    //
                    switch(iColumn)
                    {
                        case ICOL_NAME:         // 0
                            pszString = SzLoadIds(IDS_CONFOLD_WIZARD_DISPLAY_NAME);
                            break;
                            
                        case ICOL_TYPE:         // 1
                            pszString = SzLoadIds(IDS_CONFOLD_WIZARD_TYPE);
                            break;
                    }
                }
            }
        }
        
        if (SUCCEEDED(hr))
        {
            // Copy the string to the return buffer type. If there was no string loaded,
            // then just copy a null string a return it. This will happen for each
            // wizard item, since we provide no text.
            //
            hr = HrCopyToSTRRET(&(lpDetails->str), pszString ? pszString : L" \0");
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolderDetails::EnumSearches
//
//  Purpose:    Requests a pointer to an interface that allows a client to 
//              enumerate the available search objects.
//
//  Arguments:
//      IEnumExtraSearch  [in]  Address of a pointer to an enumerator object's 
//                              IEnumExtraSearch interface. 
//
//  Returns:   
//
//  Author:     deonb      17 May 2000
//
//  Notes:
//
STDMETHODIMP CConnectionFolder::EnumSearches (
           IEnumExtraSearch **ppEnum)
{
    TraceFileFunc(ttidShellFolder);
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolderDetails::GetDefaultColumn
//
//  Purpose:    Gets the default sorting and display columns.
//
//  Arguments:
//      dwReserved  [in] Reserved. Set to zero. 
//      pSort      [out] Pointer to a value that receives the index of the default sorted column. 
//      pDisplay   [out] Pointer to a value that receives the index of the default display column. 
//
//  Returns:
//
//  Author:     deonb      17 May 2000
//
//  Notes:
//
STDMETHODIMP CConnectionFolder::GetDefaultColumn (
            DWORD dwReserved,
            ULONG *pSort,
            ULONG *pDisplay )
{
    TraceFileFunc(ttidShellFolder);
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolderDetails::GetDefaultColumnState
//
//  Purpose:    Retrieves the default state for a specified column.
//
//  Arguments:
//      iColumn   [in] Integer that specifies the column number. 
//      pcsFlags [out] Pointer to flags that indicate the default column state. 
//
//  Returns:
//
//  Author:     deonb      17 May 2000
//
//  Notes:
//
STDMETHODIMP CConnectionFolder::GetDefaultColumnState (
            UINT iColumn,
            DWORD *pcsFlags )
{
    TraceFileFunc(ttidShellFolder);

    HRESULT hr;
    if ( (static_cast<INT>(iColumn) >= ICOL_NAME) && (static_cast<INT>(iColumn) < ICOL_MAX) )
    {
        *pcsFlags = c_rgCols[iColumn].csFlags;
        hr = S_OK;
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}            

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolderDetails::GetDefaultSearchGUID
//
//  Purpose:    Returns the globally unique identifier (GUID) of the default 
//              search object for the folder.
//
//  Arguments:
//      lpGUID  [out] GUID of the default search object. 
//
//  Returns:
//
//  Author:     deonb      17 May 2000
//
//  Notes:
//
STDMETHODIMP CConnectionFolder::GetDefaultSearchGUID (
            LPGUID lpGUID )
{
    TraceFileFunc(ttidShellFolder);
    return E_NOTIMPL;
}            

#define DEFINE_SCID(name, fmtid, pid) const SHCOLUMNID name = { fmtid, pid }

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolderDetails::GetDetailsEx
//
//  Purpose:    Retrieves detailed information, identified by a property set ID 
//              (FMTID) and property ID (PID), on an item in a shell folder.
//
//  Arguments:
//     pidl    [in] PIDL of the item, relative to the parent folder. This method accepts 
//                  only single-level PIDLs. The structure must contain exactly one 
//                  SHITEMID structure followed by a terminating zero. 
//     pscid   [in] Pointer to an SHCOLUMNID structure that identifies the column. 
//     pv     [out] Pointer to a VARIANT with the requested information. 
//                 The value will be fully typed. 
//  Returns:
//
//  Author:     deonb      17 May 2000
//
//  Notes:
//
#define STR_FMTID_DUIWebViewProp   TEXT("{4BF1583F-916B-4719-AC31-8896A4BD8D8B}")
#define PSCID_DUIWebViewProp     {0x4bf1583f, 0x916b, 0x4719, 0xac, 0x31, 0x88, 0x96, 0xa4, 0xbd, 0x8d, 0x8b}
DEFINE_SCID(SCID_WebViewDisplayProperties, PSGUID_WEBVIEW, PID_DISPLAY_PROPERTIES);
#ifdef __cplusplus
#define IsEqualSCID(a, b)   (((a).pid == (b).pid) && IsEqualIID((a).fmtid, (b).fmtid) )
#else
#define IsEqualSCID(a, b)   (((a).pid == (b).pid) && IsEqualIID(&((a).fmtid),&((b).fmtid)))
#endif

const TCHAR szDUI_LAN_Props[] = 
    TEXT("prop:")
    TEXT("Name;")                                       // ICOL_NAME (0)
    STR_FMTID_DUIWebViewProp TEXT("1")                  // ICOL_TYPE (1)
    TEXT(";")
    STR_FMTID_DUIWebViewProp TEXT("2")                  // ICOL_STATUS (2)
    TEXT(";")
    STR_FMTID_DUIWebViewProp TEXT("3")                  // ICOL_DEVICE_NAME (3)
    TEXT(";")
    STR_FMTID_DUIWebViewProp TEXT("6")                  // ICOL_ADDRESS (6)
    TEXT(";")
    ;

const TCHAR szDUI_WIRELESS_LAN_Props[] = 
    TEXT("prop:")
    TEXT("Name;")                                       // ICOL_NAME (0)
    STR_FMTID_DUIWebViewProp TEXT("2")                  // ICOL_STATUS (2)
    TEXT(";")
    STR_FMTID_DUIWebViewProp TEXT("6")                  // ICOL_ADDRESS (6)
    TEXT(";")
    STR_FMTID_DUIWebViewProp TEXT("9")                  // ICOL_WIRELESS_MODE (9)
    TEXT(";")
    ;

const TCHAR szDUI_PHONEISDN_Props[] = 
    TEXT("prop:")
    TEXT("Name;")                                       // ICOL_NAME (0)
    STR_FMTID_DUIWebViewProp TEXT("1")                  // ICOL_TYPE (1)
    TEXT(";")
    STR_FMTID_DUIWebViewProp TEXT("2")                  // ICOL_STATUS (2)
    TEXT(";")
    STR_FMTID_DUIWebViewProp TEXT("3")                  // ICOL_DEVICE_NAME (3)
    TEXT(";")
    STR_FMTID_DUIWebViewProp TEXT("7")                  // ICOL_PHONENUMBER (7)
    TEXT(";")
    STR_FMTID_DUIWebViewProp TEXT("6")                  // ICOL_ADDRESS (6)
    TEXT(";")
    ;

const TCHAR szDUI_RASOTHER_Props[] = 
    TEXT("prop:")
    TEXT("Name;")                                       // ICOL_NAME (0)
    STR_FMTID_DUIWebViewProp TEXT("1")                  // ICOL_TYPE (1)
    TEXT(";")
    STR_FMTID_DUIWebViewProp TEXT("2")                  // ICOL_STATUS (2)
    TEXT(";")
    STR_FMTID_DUIWebViewProp TEXT("3")                  // ICOL_DEVICE_NAME (3)
    TEXT(";")
    STR_FMTID_DUIWebViewProp TEXT("8")                  // ICOL_HOSTADDRESS (8)
    TEXT(";")
    STR_FMTID_DUIWebViewProp TEXT("6")                  // ICOL_ADDRESS (6)
    TEXT(";")
    ;

STDMETHODIMP CConnectionFolder::GetDetailsEx (
            LPCITEMIDLIST pidl,
            const SHCOLUMNID *pscid,
            VARIANT *pv )
{

    TraceFileFunc(ttidShellFolder);

    HRESULT         hr              = S_OK;

    if ( (!pidl) || (!pscid) || (!pv) )
    {
        return E_INVALIDARG;
    }

    VariantInit(pv);
    
    if (IsEqualSCID(*pscid, SCID_WebViewDisplayProperties))
    {
        VariantInit(pv);

        pv->vt = VT_BSTR;

        PCONFOLDPIDL  pcfp;
        hr = pcfp.InitializeFromItemIDList(pidl);
        if (FAILED(hr))
        {
            return hr;
        }

        switch (pcfp->ncm)
        {
            case NCM_LAN:
                if ( pcfp->ncsm == NCSM_WIRELESS )
                {
                    pv->bstrVal = SysAllocString(szDUI_WIRELESS_LAN_Props);
                }
                else
                {
                    pv->bstrVal = SysAllocString(szDUI_LAN_Props);
                }
                break;

            case NCM_BRIDGE:
                pv->bstrVal = SysAllocString(szDUI_LAN_Props);
                break;

            case NCM_NONE:
            case NCM_DIRECT:
            case NCM_PPPOE:
            case NCM_SHAREDACCESSHOST_LAN:
            case NCM_SHAREDACCESSHOST_RAS:
            case NCM_TUNNEL:
                pv->bstrVal = SysAllocString(szDUI_RASOTHER_Props);
                break;

            case NCM_PHONE:
            case NCM_ISDN:
                pv->bstrVal = SysAllocString(szDUI_PHONEISDN_Props);
                break;

            default:
                AssertSz(NULL, "Unexpected NetCon Media Type");
                hr = E_FAIL;
        }
    }
    else if (IsEqualIID(pscid->fmtid, FMTID_DUIWebViewProp) && pscid->pid < ICOL_MAX)
    {
        // this is a webview property -- get the value from GetDetailsOf(...)
        SHELLDETAILS sd = {0};
        hr = GetDetailsOf(pidl, pscid->pid, &sd);
        if (SUCCEEDED(hr))
        {
            WCHAR szTemp[INFOTIPSIZE];
            hr = StrRetToBufW(&sd.str, pidl, szTemp, INFOTIPSIZE);
            if (SUCCEEDED(hr))
            {
                pv->vt = VT_BSTR;
                pv->bstrVal = SysAllocString(szTemp);
            }
        }
    }
    else 
    if (IsEqualGUID(pscid->fmtid, GUID_NETSHELL_PROPS))
    {
        CComBSTR bstrDisplayString;

        PCONFOLDPIDL  pcfp;
        hr = pcfp.InitializeFromItemIDList(pidl);
        if FAILED(hr)
        {
            return hr;
        }

        CONFOLDENTRY  cfe;
        hr = pcfp.ConvertToConFoldEntry(cfe);
        
        if (SUCCEEDED(hr))
        {
            Assert(!cfe.empty());

            INT iStringRes;
            if (!cfe.GetWizard())
            {
                switch (pscid->pid)
                {
                    case ICOL_NAME:
                        WCHAR           szDisplayName[2];
                        szDisplayName[0] = towupper(*cfe.GetName());
                        szDisplayName[1] = NULL;
                        bstrDisplayString = szDisplayName;
                        break;
                        
                    case ICOL_DEVICE_NAME:
                        bstrDisplayString = cfe.GetDeviceName();
                        if (bstrDisplayString.Length() == 0) // e.g. Incoming Connections
                        {
                            bstrDisplayString = cfe.GetName();
                        }
                        break;

                    case ICOL_PHONEORHOSTADDRESS:
                        AssertSz(FALSE, "Can't group by this column - IDefCategoryProvider should have prevented this.");
                        bstrDisplayString = cfe.GetPhoneOrHostAddress();
                        break;
 
                    case ICOL_TYPE:
                        MapNCMToResourceId(pcfp->ncm, pcfp->dwCharacteristics, &iStringRes);
                        bstrDisplayString = SzLoadIds(iStringRes);
                        break;

                    case ICOL_NETCONMEDIATYPE:
                        pv->vt = VT_I4;
                        pv->lVal = pcfp->ncm;
                        return S_OK;

                    case ICOL_NETCONSUBMEDIATYPE:
                        pv->vt = VT_I4;
                        pv->lVal = pcfp->ncsm;
                        return S_OK;

                    case ICOL_NETCONSTATUS:
                        pv->vt = VT_I4;
                        pv->lVal = pcfp->ncs;
                        return S_OK;

                    case ICOL_NETCONCHARACTERISTICS:
                        pv->vt = VT_I4;
                        pv->lVal = pcfp->dwCharacteristics;
                        return S_OK;
                        
                    case ICOL_STATUS:
                        WCHAR szStatus[CONFOLD_MAX_STATUS_LENGTH];
                        MapNCSToComplexStatus(pcfp->ncs, pcfp->ncm, pcfp->ncsm, pcfp->dwCharacteristics, szStatus, CONFOLD_MAX_STATUS_LENGTH, pcfp->guidId);
                        bstrDisplayString = szStatus;
                        break;

                    case ICOL_OWNER:
                        if (cfe.GetCharacteristics() & NCCF_ALL_USERS)
                        {
                            bstrDisplayString = SzLoadIds(IDS_CONFOLD_DETAILS_OWNER_SYSTEM);
                        }
                        else
                        {
                            bstrDisplayString = PszGetOwnerStringFromCharacteristics(pszGetUserName(), cfe.GetCharacteristics() );
                        }
                        break;

                    default:
                        hr = E_FAIL;
                        break;
                }
            }
            else // if !(pccfe.GetWizard())
            {
                switch (pscid->pid)
                {
                    case ICOL_NAME:         // 0
                        WCHAR           szDisplayName[2];
                        szDisplayName[0] = towupper(*cfe.GetName());
                        szDisplayName[1] = NULL;
                        bstrDisplayString = szDisplayName;
                        break;
                    case ICOL_TYPE:         // 1
                    default:
                        bstrDisplayString = SzLoadIds(IDS_CONFOLD_WIZARD_TYPE);
                        break;
                }
            }

        }
   
        if (SUCCEEDED(hr))
        {
            if (bstrDisplayString.Length() == 0)
            {
                hr = E_FAIL;
            }
            else
            {
                pv->vt = VT_BSTR;
                pv->bstrVal = bstrDisplayString.Detach();
            }
        }
    }
    else
    {  
        hr = E_FAIL;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionFolderDetails::MapNameToSCID
//
//  Purpose:    Converts a column name to the appropriate property set ID (FMTID) 
//              and property ID (PID).
//
//  Arguments:
//    iColumn  [in] Zero-based index of the desired information field. It is 
//                  identical to the column number of the information as it is 
//                  displayed in a Microsoft Windows Explorer Details view. 
//    pscid   [out] Pointer to an SHCOLUMNID structure containing the FMTID and PID. 

//  Returns:
//
//  Author:     deonb      17 May 2000
//
//  Notes:
//
STDMETHODIMP CConnectionFolder::MapColumnToSCID (

            UINT iColumn,
            SHCOLUMNID *pscid )
{
    TraceFileFunc(ttidShellFolder);

    HRESULT hr = S_OK;
    if (!pscid)
    {
        return E_INVALIDARG;
    }

    if ( (static_cast<INT>(iColumn) >= ICOL_NAME) && (static_cast<INT>(iColumn) < ICOL_MAX) )
    {
        pscid->fmtid = GUID_NETSHELL_PROPS;
        pscid->pid = iColumn;
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\shell\folder\oncommand_dbg.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       O N C O M M A N D _ D B G . H 
//
//  Contents:   Debug command handler header
//
//  Notes:      
//
//  Author:     jeffspr   23 Jul 1998
//
//----------------------------------------------------------------------------

#ifndef _ONCOMMAND_DBG_H_
#define _ONCOMMAND_DBG_H_

// All of these below handle individual commands
//
HRESULT HrOnCommandDebugTray(
    IN const PCONFOLDPIDLVEC&   apidl,
    HWND                    hwndOwner,
    LPSHELLFOLDER           psf);

HRESULT HrOnCommandDebugTracing(
    IN const PCONFOLDPIDLVEC&   apidl,
    HWND                    hwndOwner,
    LPSHELLFOLDER           psf);

HRESULT HrOnCommandDebugNotifyAdd(
    IN const PCONFOLDPIDLVEC&   apidl,
    HWND                    hwndOwner,
    LPSHELLFOLDER           psf);

HRESULT HrOnCommandDebugNotifyRemove(
    IN const PCONFOLDPIDLVEC&   apidl,
    HWND                    hwndOwner,
    LPSHELLFOLDER           psf);

HRESULT HrOnCommandDebugNotifyTest(
    IN const PCONFOLDPIDLVEC&   apidl,
    HWND                    hwndOwner,
    LPSHELLFOLDER           psf);

HRESULT HrOnCommandDebugRefresh(
    IN const PCONFOLDPIDLVEC&   apidl,
    HWND                    hwndOwner,
    LPSHELLFOLDER           psf);

HRESULT HrOnCommandDebugRefreshNoFlush(
    IN const PCONFOLDPIDLVEC&   apidl,
    HWND                    hwndOwner,
    LPSHELLFOLDER           psf);

HRESULT HrOnCommandDebugRefreshSelected(
    IN const PCONFOLDPIDLVEC&   apidl,
    HWND                    hwndOwner,
    LPSHELLFOLDER           psf);

HRESULT HrOnCommandDebugRemoveTrayIcons(
    IN const PCONFOLDPIDLVEC&   apidl,
    HWND                    hwndOwner,
    LPSHELLFOLDER           psf);

#endif // _ONCOMMAND_DBG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\shell\folder\pidlutil.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       P I D L U T I L . C P P
//
//  Contents:   PIDL utility routines. This stuff is mainly copied from the
//              existing Namespace extension samples and real code, since
//              everyone and their gramma uses this stuff.
//
//  Notes:
//
//  Author:     jeffspr   1 Oct 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "foldinc.h"    // Standard shell\folder includes
#include "connlist.h"   // Connection list code

//+---------------------------------------------------------------------------
//
//  Function:   HrCloneRgIDL
//
//  Purpose:    Clone a pidl array
//
//  Arguments:
//      rgpidl              [in]    PIDL vector to clone
//      fUseCache           [in]    If TRUE, generate the returned IDL from the cache
//      fAllowNonCacheItems [in]    Use old version of pidl if cached version non available
//      pppidl              [out]   Return pointer for pidl array
//
//  Returns:
//
//  Author:     jeffspr   22 Oct 1997
//
//  Notes:
//
HRESULT HrCloneRgIDL(
    IN  const PCONFOLDPIDLVEC& rgpidl,
    IN  BOOL            fUseCache,
    IN  BOOL            fAllowNonCacheItems,
    OUT PCONFOLDPIDLVEC& pppidl)
{
    HRESULT          hr              = NOERROR;

    NETCFG_TRY

        PCONFOLDPIDLVEC  rgpidlReturn;
        PCONFOLDPIDLVEC::const_iterator irg;

        if (rgpidl.empty())
        {
            hr = E_INVALIDARG;
            goto Exit;
        }
        else
        {
            // Clone all elements within the passed in PIDL array
            //
            for (irg = rgpidl.begin(); irg != rgpidl.end(); irg++)
            {
                if (fUseCache)
                {
                    ConnListEntry  cle;
                    PCONFOLDPIDL   pcfp    = *irg;

                    hr = g_ccl.HrFindConnectionByGuid(&(pcfp->guidId), cle);
                    if (hr == S_OK)
                    {
                        Assert(!cle.empty());
                        Assert(!cle.ccfe.empty());

                        // Copy to the return pidl array.
                        PCONFOLDPIDL newPidl;
                        hr = cle.ccfe.ConvertToPidl(newPidl);
                        if (SUCCEEDED(hr))
                        {
                            rgpidlReturn.push_back(newPidl);
                        }
                        else
                        {
                            goto Exit;
                        }                            
                    }
                    else
                    {
                        TraceTag(ttidShellFolder, "HrCloneRgIDL: Connection find returned: 0x%08x", hr);

                        if (hr == S_FALSE)
                        {
                            if (fAllowNonCacheItems)
                            {
                                TraceTag(ttidShellFolder, "HrCloneRgIDL: Connection not found in cache, "
                                         "using non-cache item");


                                PCONFOLDPIDL newPidl;
                                newPidl = *irg;
                                rgpidlReturn.push_back(newPidl);
                            }
                            else
                            {
                                TraceTag(ttidShellFolder, "HrCloneRgIDL: Connection not found in cache. "
                                         "Dropping item from array");
                            }
                        }
                        else
                        {
                            AssertSz(FALSE, "HrCloneRgIDL: Connection find HR_FAILED");
                        }
                    }
                }
                else
                {
                    
                    PCONFOLDPIDL newPidl;
                    newPidl = *irg;
                    rgpidlReturn.push_back(newPidl);
                }
            }
        }

Exit:
        if (FAILED(hr))
        {
            rgpidlReturn.clear();
        }
        else
        {
            // Fill in the return var.
            //
            pppidl = rgpidlReturn;
        }

    NETCFG_CATCH(hr)

    TraceHr(ttidError, FAL, hr, FALSE, "HrCloneRgIDL");
    return hr;

}       //  HrCloneRgIDL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\shell\folder\shortcut.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       S h o r t C u t . C P P
//
//  Contents:   Creates shortcuts.
//
//  Notes:
//
//  Author:     scottbri    19 June 1998
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "foldinc.h"    // Standard shell\folder includes

extern const WCHAR c_szBackslash[];
const WCHAR c_szLinkExt[]           = L".lnk";
const WCHAR c_szVersionFormat[]     = L" %d";

//
// Function:    HrGenerateLinkName
//
// Purpose:     Combine the link path, name, and extension and verify the file
//              doesn't already exist.
//
// Parameters:  pstrNew     [OUT] - The name and path of the .lnk shortcut
//              pszPath      [IN] - The directory path for the link
//              pszConnName  [IN] - The connection name itself
//
// Returns:     HRESULT, S_OK on success, an error if the file will not be created
//
HRESULT HrGenerateLinkName(OUT tstring * pstrNew, IN PCWSTR pszPath, IN PCWSTR pszConnName)
{
    HRESULT hr = S_OK;
    tstring str;
    DWORD dwCnt = 0;

    do
    {
        // prepend the string with \\?\ so CreateFile will use a name buffer
        // larger than MAX_PATH
        str = L"\\\\?\\";

        str += pszPath;
        str += c_szBackslash;
        str += pszConnName;

        if (++dwCnt>1)
        {
            WCHAR szBuf[10];
            wsprintfW(szBuf, c_szVersionFormat, dwCnt);
            str += szBuf;
        }

        str += c_szLinkExt;

        HANDLE hFile = CreateFile(str.c_str(), GENERIC_READ, FILE_SHARE_READ,
                                  NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
        if (INVALID_HANDLE_VALUE == hFile)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
            {
                hr = S_OK;      // Filename is unique
            }
        }
        else
        {
            CloseHandle(hFile);
            hr = HRESULT_FROM_WIN32(ERROR_DUP_NAME);
        }
    } while (HRESULT_FROM_WIN32(ERROR_DUP_NAME) == hr);

    if (SUCCEEDED(hr))
    {
        *pstrNew = str.c_str();
    }

    return hr;
}

//
// Function:    HrCreateStartMenuShortCut
//
// Purpose:     Create a shortcut to a connection in the start menu
//
// Parameters:  hwndParent [IN] - Handle to a parent window
//              fAllUser   [IN] - Create the connection for all users
//              pwszName   [IN] - The connection name
//              pConn      [IN] - Connection for which the shortcut is created
//
// Returns:     BOOL, TRUE
//
HRESULT HrCreateStartMenuShortCut(IN  HWND hwndParent,
                                  IN  BOOL fAllUsers,
                                  IN  PCWSTR pszName,
                                  IN  INetConnection * pConn)
{
    HRESULT                 hr              = S_OK;
    PCONFOLDPIDL            pidl;
    PCONFOLDPIDLFOLDER      pidlFolder;
    LPSHELLFOLDER           psfConnections  = NULL;

    if ((NULL == pConn) || (NULL == pszName))
    {
        hr = E_INVALIDARG;
        goto Error;
    }

    // Create a pidl for the connection
    //
    hr = HrCreateConFoldPidl(WIZARD_NOT_WIZARD, pConn, pidl);
    if (SUCCEEDED(hr))
    {
        // Get the pidl for the Connections Folder
        //
        hr = HrGetConnectionsFolderPidl(pidlFolder);
        if (SUCCEEDED(hr))
        {
            // Get the Connections Folder object
            //
            hr = HrGetConnectionsIShellFolder(pidlFolder, &psfConnections);
            if (SUCCEEDED(hr))
            {
                tstring str;
                WCHAR szPath[MAX_PATH + 1] = {0};

                // Find the location to stash the shortcut
                //
                if (!SHGetSpecialFolderPath(hwndParent, szPath,
                                (fAllUsers ? CSIDL_COMMON_DESKTOPDIRECTORY :
                                             CSIDL_DESKTOPDIRECTORY), FALSE))
                {
                    hr = HrFromLastWin32Error();
                }
                else if (SUCCEEDED(hr) && wcslen(szPath))
                {
                    LPITEMIDLIST pidlFull;

                    // Combine the folder and connections pidl into a
                    // fully qualified pidl.
                    //
                    pidlFull = ILCombine(pidlFolder.GetItemIdList(), pidl.GetItemIdList());
                    if (pidlFull)
                    {
                        IShellLink *psl = NULL;

                        hr = CoCreateInstance(
                                CLSID_ShellLink,
                                NULL,
                                CLSCTX_INPROC_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
                                IID_IShellLink,
                                (LPVOID*)&psl);

                        if (SUCCEEDED(hr))
                        {
                            IPersistFile *ppf = NULL;

                            // Set the combined IDL
                            //
                            hr = psl->SetIDList(pidlFull);
                            if (SUCCEEDED(hr))
                            {
                                hr = psl->QueryInterface(IID_IPersistFile,
                                                         (LPVOID *)&ppf);
                                if (SUCCEEDED(hr))
                                {
                                    tstring strPath;

                                    // Generate the lnk filename
                                    //
                                    hr = HrGenerateLinkName(&strPath,
                                                            szPath,
                                                            pszName);
                                    if (SUCCEEDED(hr))
                                    {
                                        // Create the link file.
                                        //
                                        hr = ppf->Save(strPath.c_str(), TRUE);
                                    }

                                    ReleaseObj(ppf);
                                }
                            }

                            ReleaseObj(psl);
                        }

                        if (pidlFull)
                        {
                            FreeIDL(pidlFull);
                        }
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }
                else
                {
                    TraceError("HrCreateStartMenuShortCut - Unable to find Start Menu save location", hr);
                }

                ReleaseObj(psfConnections);
            }
        }
    }

Error:
    TraceError("HrCreateStartMenuShortCut", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\shell\folder\shutil.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       S H U T I L . H
//
//  Contents:   Various shell utilities to be used by the connections folder
//
//  Notes:
//
//  Author:     jeffspr   21 Oct 1997
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _SHUTIL_H_
#define _SHUTIL_H_

#include <ndispnp.h>
#include <ntddndis.h>
#include <ncshell.h>

HRESULT HrDupeShellStringLength(
    IN  PCWSTR     pszInput,
    IN  ULONG      cchInput,
    OUT PWSTR *    ppszOutput);

inline
HRESULT HrDupeShellString(
    IN  PCWSTR     pszInput,
    OUT PWSTR *    ppszOutput)
{
    return HrDupeShellStringLength(pszInput, wcslen(pszInput), ppszOutput);
}

HRESULT HrGetConnectionPidlWithRefresh(IN  const GUID& guidId,
                                       OUT PCONFOLDPIDL& ppidlCon);


//---[ Various refresh functions ]--------------------------------------------

// Notify the shell that an object is going away, and remove it from our list
//
HRESULT HrDeleteFromCclAndNotifyShell(
    IN  const PCONFOLDPIDLFOLDER&  pidlFolder,
    IN  const PCONFOLDPIDL&  pidlConnection,
    IN  const CONFOLDENTRY&  ccfe);

VOID ForceRefresh(IN  HWND hwnd) throw();

// Update the folder, but don't flush the items. Update them as needed.
// pidlFolder is optional -- if not passed in, we'll generate it.
//
HRESULT HrForceRefreshNoFlush(IN  const PCONFOLDPIDLFOLDER& pidlFolder);

// Update the connection data based on the pidl. Notify the shell as
// appropriate
//
HRESULT HrOnNotifyUpdateConnection(
    IN  const PCONFOLDPIDLFOLDER&        pidlFolder,
    IN  const GUID *              pguid,
    IN  NETCON_MEDIATYPE    ncm,
    IN  NETCON_SUBMEDIATYPE ncsm,
    IN  NETCON_STATUS       ncs,
    IN  DWORD               dwCharacteristics,
    IN  PCWSTR              pszwName,
    IN  PCWSTR              pszwDeviceName,
    IN  PCWSTR              pszwPhoneNumberOrHostAddress);

// Update the connection status, including sending the correct shell
// notifications for icon updates and such.
//
HRESULT HrOnNotifyUpdateStatus(
    IN  const PCONFOLDPIDLFOLDER&    pidlFolder,
    IN  const PCONFOLDPIDL&    pidlCached,
    IN  NETCON_STATUS   ncsNew);

// update the shell/connection list with the new connection status
//
HRESULT HrUpdateConnectionStatus(
    IN  const PCONFOLDPIDL&    pcfp,
    IN  NETCON_STATUS   ncs,
    IN  const PCONFOLDPIDLFOLDER&    pidlFolder,
    IN  BOOL            fUseCharacter,
    IN  DWORD           dwCharacter);


//---[ Menu merging functions ]-----------------------------------------------

VOID MergeMenu(
    IN     HINSTANCE   hinst,
    IN     UINT        idMainMerge,
    IN     UINT        idPopupMerge,
    IN OUT LPQCMINFO   pqcm);

INT IMergePopupMenus(
    IN OUT HMENU hmMain,
    IN     HMENU hmMerge,
    IN     int   idCmdFirst,
    IN     int   idCmdLast);

HRESULT HrGetMenuFromID(
    IN  HMENU   hmenuMain,
    IN  UINT    uID,
    OUT HMENU * phmenu);

HRESULT HrLoadPopupMenu(
    IN  HINSTANCE   hinst,
    IN  UINT        id,
    OUT HMENU *     phmenu);

HRESULT HrShellView_GetSelectedObjects(
    IN  HWND                hwnd,
    OUT PCONFOLDPIDLVEC&    apidlSelection);

HRESULT HrRenameConnectionInternal(
    IN  const PCONFOLDPIDL&  pidlCon,
    IN  const PCONFOLDPIDLFOLDER&  pidlFolder,
    IN  LPCWSTR         pszNewName,
    IN  BOOL            fRaiseError,
    IN  HWND            hwndOwner,
    OUT PCONFOLDPIDL&   ppidlOut);

#endif // _SHUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\shell\folder\oncommand.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       O N C O M M A N D . C P P
//
//  Contents:   Command handlers for the context menus, etc.
//
//  Notes:
//
//  Author:     jeffspr   4 Nov 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "foldinc.h"    // Standard shell\folder includes
#include "advcfg.h"
#include "conprops.h"
#include "foldres.h"
#include "oncommand.h"

#if DBG                     // Debug menu commands
#include "oncommand_dbg.h"  //
#endif

#include "shutil.h"
#include "ncras.h"
#include "traymsgs.h"
#include <ncnetcon.h>
#include <nsres.h>
#include <wizentry.h>
#include "disconnect.h"
#include "ncperms.h"
#include "smcent.h"
#include "cfutils.h"

#include "HNetCfg.h"

#include "..\lanui\lanui.h"
#include "repair.h"
#include "iconhandler.h"
#include "wzcdlg.h"

#include <clusapi.h>

//---[ Externs ]--------------------------------------------------------------

extern HWND g_hwndTray;
extern const WCHAR c_szNetShellDll[];

//---[ Constants ]------------------------------------------------------------

// Command-line for the control-panel applet.
//
static const WCHAR c_szRunDll32[]         = L"rundll32.exe";
static const WCHAR c_szNetworkIdCmdLine[] = L"shell32.dll,Control_RunDLL sysdm.cpl,,1";

//---[ Local functions ]------------------------------------------------------

    // None


class CCommandHandlerParams
{
public:
    const PCONFOLDPIDLVEC*  apidl;
    HWND                    hwndOwner;
    LPSHELLFOLDER           psf;

    UINT_PTR                nAdditionalParam;
} ;


HRESULT HrCommandHandlerThread(
    FOLDERONCOMMANDPROC     pfnCommandHandler,
    IN const PCONFOLDPIDLVEC&  apidl,
    HWND                    hwndOwner,
    LPSHELLFOLDER           psf)
{
    HRESULT          hr          = S_OK;
    PCONFOLDPIDLVEC  apidlCopy;

    // If there are pidls to copy, copy them
    //
    if (!apidl.empty())
    {
        hr = HrCloneRgIDL(apidl, FALSE, TRUE, apidlCopy);
    }

    // If either there were no pidls, or the Clone succeeded, then we want to continue
    //
    if (SUCCEEDED(hr))
    {
        PCONFOLDONCOMMANDPARAMS  pcfocp = new CONFOLDONCOMMANDPARAMS;

        if (pcfocp)
        {
            pcfocp->pfnfocp         = pfnCommandHandler;
            pcfocp->apidl           = apidlCopy;
            pcfocp->hwndOwner       = hwndOwner;
            pcfocp->psf             = psf;
            pcfocp->hInstNetShell   = NULL;

            // This should be Release'd in the thread called.
            //
            psf->AddRef();

            // This will always succeed in retail, but will test the flag in debug
            //
            if (!FIsDebugFlagSet (dfidDisableShellThreading))
            {
                // Run in a thread using the QueueUserWorkItem
                //

                HANDLE      hthrd = NULL;
                HINSTANCE   hInstNetShell = LoadLibrary(c_szNetShellDll);

                if (hInstNetShell)
                {
                    pcfocp->hInstNetShell = hInstNetShell;

                    DWORD  dwThreadId;
                    hthrd = CreateThread(NULL, STACK_SIZE_DEFAULT,
                                    (LPTHREAD_START_ROUTINE)FolderCommandHandlerThreadProc,
                                    (LPVOID)pcfocp, 0, &dwThreadId);
                }

                if (NULL != hthrd)
                {
                    CloseHandle(hthrd);
                }
                else
                {
                    pcfocp->hInstNetShell = NULL;
                    FolderCommandHandlerThreadProc(pcfocp);
                }
            }
            else
            {
                // Run directly in this same thread
                //
                FolderCommandHandlerThreadProc((PVOID) pcfocp);
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }


    // Don't release the psf here. This should have been taken care of by the called ThreadProc
    //
    return hr;
}

DWORD WINAPI FolderCommandHandlerThreadProc(LPVOID lpParam)
{
    HRESULT                     hr                  = S_OK;
    HINSTANCE hInstNetShell = NULL;

    // Create a new scope since FreeLibraryAndExitThread will not call destructors on global scope
    {
        PCONFOLDONCOMMANDPARAMS     pcfocp              = (PCONFOLDONCOMMANDPARAMS) lpParam;
        BOOL                        fCoInited           = FALSE;
        IUnknown *                  punkExplorerProcess = NULL;

        Assert(pcfocp);

        hr = SHGetInstanceExplorer(&punkExplorerProcess);
        if (FAILED(hr))
        {
            // This is ok. All we want to do, is if explorer is running, add a ref so that it doesn't
            // disappear from under us. If it's NULL, not much we can do about it.
            punkExplorerProcess = NULL;
        }

        hr = CoInitializeEx (NULL, COINIT_DISABLE_OLE1DDE | COINIT_APARTMENTTHREADED);
        if (SUCCEEDED(hr))
        {
            // We don't care if this is S_FALSE or not, since we'll soon
            // overwrite the hr. If it's already initialized, great...

            fCoInited = TRUE;

            // Call the specific handler
            //
            hr = pcfocp->pfnfocp(
                pcfocp->apidl,
                pcfocp->hwndOwner,
                pcfocp->psf);
        }

        // Remove the ref that we have on this object. The thread handler would have addref'd
        // this before queueing our action
        //
        if (pcfocp->psf)
        {
            ReleaseObj(pcfocp->psf);
        }

        // Remove this object. We're responsible for this now.
        //
        hInstNetShell = pcfocp->hInstNetShell;
        pcfocp->hInstNetShell = NULL;

        delete pcfocp;

        if (fCoInited)
        {
            CoUninitialize();
        }

        ::ReleaseObj(punkExplorerProcess);
    }

    if (hInstNetShell)
        FreeLibraryAndExitThread(hInstNetShell, hr);

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrCommandHomeNetWizard
//
//  Purpose:    Command handler to start the home networking wizard
//
//  Arguments:  none
//
//  Returns:    S_OK if succeeded
//              E_FAIL otherwise
//
//  Author:     deonb     10 Feb 2001
//
//  Notes:
//
HRESULT HrCommandHomeNetWizard()
{
    // ShellExecute returns <32 if an error
    if (ShellExecute(NULL, NULL, L"rundll32.exe", L"hnetwiz.dll,HomeNetWizardRunDll", NULL, SW_SHOWNORMAL) > reinterpret_cast<HINSTANCE>(32))
    {
        return S_OK;
    }
    else
    {
        return E_FAIL;
    }
}

#include <mprapi.h>
#include <routprot.h>

// Fix IA64 conflict with Shell Macro
#undef IS_ALIGNED
#include <ipnat.h>

BOOL IsInUseByRRAS (LPOLESTR psz)
{
    BOOL bInUse = FALSE;

    HANDLE hServer = NULL;
    DWORD dwErr = MprConfigServerConnect (NULL, &hServer);
    if (hServer) {
        DWORD dwRead = 0, dwTotal = 0;
        MPR_INTERFACE_0 * pMI0 = NULL;
        dwErr = MprConfigInterfaceEnum (hServer,
                                        0,  // level
                                        (LPBYTE*)&pMI0,    // will return array of interface info 0s
                                        -1, // all of 'em
                                        &dwRead,
                                        &dwTotal,
                                        NULL);  // resume handle
        if (pMI0) {
            for (DWORD i=0; i<dwRead; i++) {
                if (!wcscmp (psz, pMI0[i].wszInterfaceName)) {
                    // found it!
                    HANDLE hIfTransport = NULL;
                    dwErr = MprConfigInterfaceTransportGetHandle (hServer,
                                                                  pMI0[i].hInterface,
                                                                  PID_IP,
                                                                  &hIfTransport);
                    if (hIfTransport) {
                        DWORD dwSize= 0;
                        RTR_INFO_BLOCK_HEADER * pRIBH = NULL;
                        dwErr = MprConfigInterfaceTransportGetInfo (hServer,
                                                                    pMI0[i].hInterface,
                                                                    hIfTransport,
                                                                    (LPBYTE*)&pRIBH,
                                                                    &dwSize);
                        if (pRIBH) {
                            DWORD dwCount = 0;
                            dwSize = 0;
                            IP_NAT_INTERFACE_INFO * pINII = NULL;
                            dwErr = MprInfoBlockFind ((LPVOID)pRIBH,
                                                      MS_IP_NAT,
                                                      &dwSize,
                                                      &dwCount,
                                                      (LPBYTE*)&pINII);
                        #ifdef KEEP_AROUND_FOR_DOC_PURPOSES
                            if (!pINII)
                                ; // neither public or private
                            else
                            if (pINII && (pINII->Flags == 0))
                                ;   // private interface
                            else
                                ;   // public interface
                        #endif
                            if (pINII)
                                bInUse = TRUE;

                            MprConfigBufferFree (pRIBH);
                        }
                    }
                    break;  // found it
                }
            }
            MprConfigBufferFree (pMI0);
        }
        MprConfigServerDisconnect (hServer);
    }
    return bInUse;
}
BOOL
InUseByRRAS (
    IN const PCONFOLDPIDLVEC&   apidlSelected
    )
{
    //
    // Loop through each of the selected objects
    //
    for ( PCONFOLDPIDLVEC::const_iterator iterObjectLoop = apidlSelected.begin(); iterObjectLoop != apidlS