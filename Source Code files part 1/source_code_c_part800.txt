    
    NtClose(hKey);

    //
    //  pszGuid only needs to be freed if we failed. In the
    //  success case, it will be set to NULL.
    //
    LocalFree( pszGuid );

    return dwResult;
}


DWORD WINAPI 
_LogSystemSnapshot(
    void* pv)

/*++

Routine Description:

    This is the thread entry point.

Arguments:

    pv - thread parameter, a point to THREADPARAM struct.

Return Value:

    thread exit code.

--*/

{
    SYSTEMTIME              systime;
    TIME_ZONE_INFORMATION   TimeZone ;
    HANDLE                  hFile = NULL;
    UINT                    res = 0;
    LONG                    lBuffSize ;
    LPTSTR                  lpszTemp;
    PTHREADPARAM            pparam = (PTHREADPARAM)pv;
    DWORD                   Flags = pparam->Flags;
    LPCTSTR*                lpStrings = pparam->lpStrings;
    DWORD                   NumOfStrings = pparam->NumOfStrings;
    PLONG                   BuffSize = pparam->BuffSize;
    LPTSTR                  lpszBuff = pparam->lpszBuff;
    LONG                    lLength  = 0;
    LPTSTR                  pszReliabilityGuid = NULL;
    ULARGE_INTEGER          ullTotal, ullFree, ullAvailable;

    GetLocalTime(&systime);

    lBuffSize = *BuffSize ;
    *lpszBuff = 0;
    *BuffSize = 0 ;

    //
    // Set up the log path %SYSTEMDIR%\Logfiles\Shutdown
    //
    GetSystemDirectory(g_lpszFileName, MAX_PATH);
    _tcsncat(g_lpszFileName, TEXT("\\LogFiles"), 2*MAX_PATH - lstrlen(g_lpszFileName)); // making sure the directory.
    g_lpszFileName[2*MAX_PATH] = 0;
    CreateDirectory(g_lpszFileName, NULL);        
    _tcsncat(g_lpszFileName, TEXT("\\ShutDown"), 2*MAX_PATH - lstrlen(g_lpszFileName));  //  .. exists
    g_lpszFileName[2*MAX_PATH] = 0;
        
    if ( CreateDirectory(g_lpszFileName, NULL) )
    {
        //
        //  setup will create this directory, but if admin delete this directory by accident,
        //  we will recreate it with the correct ACL.
        //
        if(!AdjustAccess(g_lpszFileName))    
        {
            //
            // So only administrators and system can have read and write access.
            //
            return GetLastError();
        }
    }

    //
    //  Make sure available disk space is at least 100M.
    //
    if (GetDiskFreeSpaceEx(g_lpszFileName, &ullAvailable, &ullTotal, &ullFree))
    {
        if (ullAvailable.HighPart == 0 && ullAvailable.LowPart < 100 * 1024 * 1024)
        {
            return ERROR_DISK_FULL;
        }
    }
    else
    {
         return GetLastError();
    }

    //
    //    Delete old files first. so if the number of days is set to
    //    0, we will still has the current log file around.
    //
    DeleteOldFiles(g_lpszFileName);

    _tcsncat(g_lpszFileName, TEXT("\\ShutDown_"), 2*MAX_PATH - lstrlen(g_lpszFileName));
    g_lpszFileName[2*MAX_PATH] = 0;
    lpszTemp = (LPTSTR)(g_lpszFileName + (lstrlen(g_lpszFileName)));
    _stnprintf(lpszTemp, 2*MAX_PATH - (lstrlen(g_lpszFileName)),
                TEXT("%4d%02d%02d%02d%02d%02d.xml"),  
                systime.wYear, systime.wMonth, systime.wDay,
                systime.wHour, systime.wMinute, systime.wSecond);
    g_lpszFileName[2*MAX_PATH] = 0;

    hFile = CreateFile(g_lpszFileName, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        return HandleToUlong(INVALID_HANDLE_VALUE);
    }

    lLength = _tcslen(g_lpszFileName);
    if (lBuffSize <= lLength)
    {
        res = ERROR_INSUFFICIENT_BUFFER;
        goto cleanup;
    }

    _tcsncpy(lpszBuff, g_lpszFileName, lBuffSize);
    lpszBuff[ lLength ] = 0;
    *BuffSize = lLength ;

    gXMLOutput = new XMLOutput(TEXT("<?xml version=\"1.0\" encoding=\"UTF-8\"?>"), hFile);
    if(! gXMLOutput)
    {
        res = GetLastError();
        goto cleanup;
    }

    GetTimeZoneInformation(&TimeZone);

    //
    //  lpString Format:
    //  0:  InitiateProcess
    //  1:  SystemName
    //  2:  ReasonTitle
    //  3:  ReasonCode
    //  4:  Restart Type
    //  5:  Comment
    //  6:  UserName
    //
    gXMLOutput->Write(XMLTAG_SETSystemStateData, (LPCWSTR)NULL);
    gXMLOutput->Write(XMLTAG_SETDataType_Header, (LPCWSTR)NULL);
    
    if ( !GetReliabilityGUID( &pszReliabilityGuid ) && pszReliabilityGuid )
    {
        gXMLOutput->Write(XMLTAG_HeaderType_ReliabilityGuid, pszReliabilityGuid);
        LocalFree(pszReliabilityGuid);
    }
    else
    {
        gXMLOutput->Write(XMLTAG_HeaderType_ReliabilityGuid, (LPCSTR)NULL);
    }

    if ( NumOfStrings == REQUIRED_NUM_OF_STRINGS )
    {
        //gXMLOutput->Write(XMLTAG_HeaderType_SystemName, lpStrings[1]);
        //gXMLOutput->Write(XMLTAG_HeaderType_UserName, lpStrings[6]);
        gXMLOutput->Write(XMLTAG_HeaderType_ReasonTitle, lpStrings[2]);
        
        
        gXMLOutput->Write(XMLTAG_HeaderType_InitiatingProcess, lpStrings[0]);
    }
    else
    {
        //gXMLOutput->Write(XMLTAG_HeaderType_SystemName, (LPCSTR)NULL);
        //gXMLOutput->Write(XMLTAG_HeaderType_UserName, (LPCSTR)NULL);
        gXMLOutput->Write(XMLTAG_HeaderType_ReasonTitle, (LPCSTR)NULL);

     
        gXMLOutput->Write(XMLTAG_HeaderType_InitiatingProcess, (LPCSTR)NULL);
    }
    
    _stnprintf(g_lpszBuffer, STR_BUFFER_SIZE,
             TEXT("%d-%d-%d"),
             systime.wYear, systime.wMonth, systime.wDay);
    g_lpszBuffer[ _tsizeof(g_lpszBuffer) - 1 ] = 0;

    gXMLOutput->Write(XMLTAG_HeaderType_RestartDate, (LPCTSTR)g_lpszBuffer);

    _stnprintf(g_lpszBuffer, STR_BUFFER_SIZE,
             TEXT("%d-%d-%d (%s(%d))"),
             systime.wHour, systime.wMinute, systime.wSecond,
             TimeZone.StandardName, TimeZone.Bias);
    g_lpszBuffer[ _tsizeof(g_lpszBuffer) - 1 ] = 0;

    gXMLOutput->Write(XMLTAG_HeaderType_RestartTime, (LPCTSTR)g_lpszBuffer);

    if ( NumOfStrings == REQUIRED_NUM_OF_STRINGS )
    {
        gXMLOutput->Write(XMLTAG_HeaderType_ReasonCode, lpStrings[3]);
        gXMLOutput->Write(XMLTAG_HeaderType_RestartType, lpStrings[4]);
        gXMLOutput->Write(XMLTAG_HeaderType_Comment, lpStrings[5]);
    }
    else
    {
        gXMLOutput->Write(XMLTAG_HeaderType_ReasonCode, (LPCSTR)NULL);
        gXMLOutput->Write(XMLTAG_HeaderType_RestartType, (LPCSTR)NULL);
        gXMLOutput->Write(XMLTAG_HeaderType_Comment, (LPCSTR)NULL);
    }

    InterlockedExchange(&pparam->lCanOrphanThread, 1 );

    __try{
        //
        // Ok write the snapshot to the file
        //
        res = LogSystemSnapshotToFile(hFile);

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        //
        //  exception in extension dll.
        //
        res = ERROR_INVALID_PARAMETER;
    }

cleanup:
        
    if ( gXMLOutput )
    {
        delete gXMLOutput;
        gXMLOutput = NULL;
    }

    CloseHandle(hFile);

    return res;
}

ULONG LogSystemSnapshot(
    DWORD Flags, 
    LPCTSTR *lpStrings, 
    PLONG BuffSize, 
    LPTSTR lpszBuff)

/*++

Routine Description:

    This function exported to outsiders. This function will
    spawn a thread to do the logging and wait for certain
    amount of time. If the thread does not return by then, it will
    leave it orphan.

Arguments:

    Flags - logging flags. (Num of Strings passed)

    lpStrings - 

    BuffSize - the size of lpszBuff in TCHARs.

    lpszBuff - Hold the snapshot file name on return.

Return Value:

    exit code.

--*/

{
    THREADPARAM param;
    HANDLE        hThread = NULL;
    DWORD        tid;
    DWORD        dwTimeout = DEFAULT_TIMEOUT;
    DWORD       dwResult  = 0;

    LPCWSTR TimeOutVal = L"SnapshotTimeout";
    HANDLE  hKey;
    DWORD    dwSize;
    NTSTATUS Status = STATUS_SUCCESS;

    //A coding errror
    ASSERT (XMLTAG_END == sizeof(XMLTagNames)/sizeof(struct XMLTags));

    if ( !lpStrings || !BuffSize || *BuffSize == 0 || !lpszBuff )
        return ERROR_INVALID_PARAMETER;

    param.Flags             = Flags;
    param.NumOfStrings      = Flags;
    param.lpStrings         = lpStrings;
    param.BuffSize          = BuffSize;
    param.lpszBuff          = lpszBuff;
    param.lCanOrphanThread  = 0;

    Status = SnapshotRegOpenKey(ReliabilityKey, KEY_READ, &hKey);
    if(NT_SUCCESS(Status))
    {
        dwSize = sizeof(DWORD);
        Status = SnapshotRegQueryValueKey(hKey, TimeOutVal, dwSize, &dwTimeout, &dwSize);

        if ( NT_SUCCESS(Status) )
        {
            if (dwTimeout < MIN_TIMEOUT )
                dwTimeout = MIN_TIMEOUT;

            if (dwTimeout > MAX_TIMEOUT )
                dwTimeout = MAX_TIMEOUT;
        }
        else
        {
            dwTimeout = DEFAULT_TIMEOUT;
        }

        NtClose(hKey);
    }        

    hThread = CreateThread(NULL, 128 * 1024, _LogSystemSnapshot, &param, 0, &tid);
    
    if(hThread)
    {
        SetThreadPriority(hThread, THREAD_PRIORITY_TIME_CRITICAL); // increase priority.
        
        do 
        {
            //
            //  Normally the child thread will complete the first part within
            //  MIN_TIMEOUT seconds, but if the system was too slow, we will 
            //  wait for another wait period before we actually time out.
            //
            dwResult = WaitForSingleObject(hThread, dwTimeout * 1000);      
        }
        while ( InterlockedCompareExchange( &param.lCanOrphanThread, 0, 0 ) == 0 
               && dwResult != WAIT_OBJECT_0 );

        if ( dwResult == WAIT_OBJECT_0 )
        {
            if ( !GetExitCodeThread( hThread, &dwResult ) )
                dwResult = GetLastError();
        }
        else
        {
            dwResult = ERROR_TIMEOUT;
        }

        CloseHandle(hThread);
    }
    else
    {
        dwResult = GetLastError();
    }

    if ( ERROR_SUCCESS != dwResult )
    {
        *lpszBuff = 0;        
        *BuffSize = 0;
    }

    return dwResult ;
}



UINT LogSystemSnapshotToFile(
    HANDLE hFile
    )

/*++

Routine Description:

    This function actually does the logging.

Arguments:

    hFile - handle to the log file.

Return Value:

    exit code.

--*/

{
    PSYSTEM_PROCESS_INFORMATION ProcessInfo;
    PSYSTEM_THREAD_INFORMATION ThreadInfo;
    BYTE*    LargeBuffer1;
    NTSTATUS status;
    ULONG    i;
    ULONG    TotalOffset = 0;
    TIME_FIELDS UserTime;
    TIME_FIELDS KernelTime;
    TIME_FIELDS UpTime;
    SYSTEM_BASIC_INFORMATION BasicInfo;
    SYSTEM_TIMEOFDAY_INFORMATION TimeOfDayInfo;
    PSYSTEM_PAGEFILE_INFORMATION PageFileInfo;
    LARGE_INTEGER Time;
    ANSI_STRING pname;
    SYSTEM_PERFORMANCE_INFORMATION PerfInfo;
    SYSTEM_FILECACHE_INFORMATION FileCache;
    SIZE_T    SumCommit;
    SIZE_T    SumWorkingSet;
 
    if (hFile == INVALID_HANDLE_VALUE)
        return 1;

    //SetFileApisToOEM();

    g_pTime = new Timing();
    
    if ( !g_pTime )
        return GetLastError();

    LargeBuffer1 = (BYTE*) VirtualAlloc (NULL,
                                         MAX_BUFFER_SIZE,
                                         MEM_RESERVE,
                                         PAGE_READWRITE);
    if (LargeBuffer1 == NULL) 
    {
        goto cleanup;
    }

    if (VirtualAlloc (LargeBuffer1,
                      BUFFER_SIZE,
                      MEM_COMMIT,
                      PAGE_READWRITE) == NULL) 
    {
        goto cleanup;
    }

    CurrentBufferSize = BUFFER_SIZE;

    status = NtQuerySystemInformation(
                                     SystemBasicInformation,
                                     &BasicInfo,
                                     sizeof(SYSTEM_BASIC_INFORMATION),
                                     NULL
                                     );

    if (!NT_SUCCESS(status)) 
    {
        goto cleanup;;
    }

    status = NtQuerySystemInformation(
                                     SystemTimeOfDayInformation,
                                     &TimeOfDayInfo,
                                     sizeof(SYSTEM_TIMEOFDAY_INFORMATION),
                                     NULL
                                     );

    if (!NT_SUCCESS(status)) 
    {
        goto cleanup;
    }

    Time.QuadPart = TimeOfDayInfo.CurrentTime.QuadPart -
                    TimeOfDayInfo.BootTime.QuadPart;

    RtlTimeToElapsedTimeFields ( &Time, &UpTime);

    _stnprintf(g_lpszBuffer, STR_BUFFER_SIZE,
             TEXT("%3ld %2ld:%02ld:%02ld.%03ld"),
             UpTime.Day,
             UpTime.Hour,
             UpTime.Minute,
             UpTime.Second,
             UpTime.Milliseconds);
    g_lpszBuffer[ _tsizeof(g_lpszBuffer) - 1 ] = 0;

    gXMLOutput->Write(XMLTAG_HeaderType_SystemUptime, (LPCTSTR)g_lpszBuffer);

    _stprintf( g_lpszBuffer, TEXT("0x%04x"), GetUserDefaultLangID());
    gXMLOutput->Write(XMLTAG_HeaderType_UserLanguageID, g_lpszBuffer);

    _stprintf( g_lpszBuffer, TEXT("0x%04x"), GetSystemDefaultLangID());
    gXMLOutput->Write(XMLTAG_HeaderType_SystemLanguageID, g_lpszBuffer);


    gXMLOutput->Write(XMLTAG_HeaderType_SchemaVersion, SCHEMA_VERSION_STRING);


    PageFileInfo = (PSYSTEM_PAGEFILE_INFORMATION)LargeBuffer1;
    status = NtQuerySystemInformation(
                                     SystemPageFileInformation,
                                     PageFileInfo,
                                     CurrentBufferSize,
                                     NULL
                                     );

    if (NT_SUCCESS(status)) 
    {

        //
        // Print out the page file information.
        //

        if (PageFileInfo->TotalSize == 0) 
        {
            gXMLOutput->Write(XMLTAG_SETDataType_PageFiles, TEXT("no page files in use"));
        } 
        else 
        {
            gXMLOutput->Write(XMLTAG_SETDataType_PageFiles, (LPCWSTR)NULL);

            for (; ; ) 
            {
                gXMLOutput->Write(XMLTAG_PageFileType_PageFile, (LPCWSTR)NULL);

                _stnprintf(g_lpszBuffer, STR_BUFFER_SIZE,
                        TEXT("%ls"), PageFileInfo->PageFileName.Buffer);
                g_lpszBuffer[ _tsizeof(g_lpszBuffer) - 1 ] = 0;
                gXMLOutput->Write(XMLTAG_PageFileType_Path, (LPCTSTR)g_lpszBuffer);

                _stnprintf(g_lpszBuffer, STR_BUFFER_SIZE,
                        TEXT("%ld"),
                        PageFileInfo->TotalSize*(BasicInfo.PageSize/1024));
                gXMLOutput->Write(XMLTAG_PageFileType_CurrentSize, (LPCTSTR)g_lpszBuffer);

                _stnprintf(g_lpszBuffer, STR_BUFFER_SIZE,
                        TEXT("%ld"),
                        PageFileInfo->TotalInUse*(BasicInfo.PageSize/1024));
                gXMLOutput->Write(XMLTAG_PageFileType_Total, (LPCTSTR)g_lpszBuffer);

                _stnprintf(g_lpszBuffer, STR_BUFFER_SIZE,
                        TEXT("%ld"),
                        PageFileInfo->PeakUsage*(BasicInfo.PageSize/1024));
                gXMLOutput->Write(XMLTAG_PageFileType_Peak, (LPCTSTR)g_lpszBuffer);

                if (PageFileInfo->NextEntryOffset == 0) 
                {
                    break;
                }
                PageFileInfo = (PSYSTEM_PAGEFILE_INFORMATION)(
                                                (PCHAR)PageFileInfo + PageFileInfo->NextEntryOffset);
            }
        }
    }

retry:
    status = NtQuerySystemInformation(
                                     SystemProcessInformation,
                                     LargeBuffer1,
                                     CurrentBufferSize,
                                     NULL
                                     );

    if (status == STATUS_INFO_LENGTH_MISMATCH) 
    {

        //
        // Increase buffer size.
        //

        CurrentBufferSize += 8192;

        if (VirtualAlloc (LargeBuffer1,
                          CurrentBufferSize,
                          MEM_COMMIT,
                          PAGE_READWRITE) == NULL) 
        {
            WriteToLogFile(hFile, TEXT("Memory commit failed\n"));
            goto cleanup;
        }
        goto retry;
    }

    if (!NT_SUCCESS(status)) 
    {

        _stnprintf(g_lpszBuffer, STR_BUFFER_SIZE, TEXT("Query info failed %lx\n"),status);
        g_lpszBuffer[ _tsizeof(g_lpszBuffer) - 1 ] = 0;

        WriteToLogFile(hFile,g_lpszBuffer);
        goto cleanup;
    }

    //
    // display pmon style process output, then detailed output that includes
    // per thread stuff
    //

    TotalOffset = 0;
    SumCommit = 0;
    SumWorkingSet = 0;
    ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)LargeBuffer1;
    while (TRUE) 
    {
        SumCommit += ProcessInfo->PrivatePageCount / 1024;
        SumWorkingSet += ProcessInfo->WorkingSetSize / 1024;
        if (ProcessInfo->NextEntryOffset == 0) 
        {
            break;
        }
        TotalOffset += ProcessInfo->NextEntryOffset;
        ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)&LargeBuffer1[TotalOffset];
    }

    status = NtQuerySystemInformation(
                                     SystemPerformanceInformation,
                                     &PerfInfo,
                                     sizeof(PerfInfo),
                                     NULL
                                     );

    if ( !NT_SUCCESS(status) ) 
    {
        _stnprintf(g_lpszBuffer, STR_BUFFER_SIZE, TEXT("Query perf Failed %lx\n"),status);
        g_lpszBuffer[ _tsizeof(g_lpszBuffer) - 1 ] = 0;

        WriteToLogFile(hFile, g_lpszBuffer);
        goto cleanup;
    }

    status = NtQuerySystemInformation(
                                     SystemFileCacheInformation,
                                     &FileCache,
                                     sizeof(FileCache),
                                     NULL
                                     );

    if ( !NT_SUCCESS(status) ) 
    {
        _stnprintf(g_lpszBuffer, STR_BUFFER_SIZE, TEXT("Query file cache Failed %lx\n"),status);
        g_lpszBuffer[ _tsizeof(g_lpszBuffer) - 1 ] = 0;
        WriteToLogFile(hFile, g_lpszBuffer);
        goto cleanup;
    }

    NtQuerySystemInformation(
                            SystemBasicInformation,
                            &BasicInfo,
                            sizeof(BasicInfo),
                            NULL
                            );

    SumWorkingSet += FileCache.CurrentSize/1024;
    gXMLOutput->Write(XMLTAG_SETDataType_Memory, (LPCWSTR)NULL);
    gXMLOutput->Write(XMLTAG_Memory_PhysicalMemory,(LPCWSTR)NULL);

    _stprintf (g_lpszBuffer, TEXT("%ld"),
              BasicInfo.NumberOfPhysicalPages*(BasicInfo.PageSize/1024));
    gXMLOutput->Write(XMLTAG_PhysicalMemoryType_Total, (LPCTSTR)g_lpszBuffer);

    _stprintf (g_lpszBuffer, TEXT("%ld"),
              PerfInfo.AvailablePages*(BasicInfo.PageSize/1024));
    gXMLOutput->Write(XMLTAG_PhysicalMemoryType_Available, (LPCTSTR)g_lpszBuffer);

    _stprintf(g_lpszBuffer, TEXT("%ld"), SumWorkingSet);
    gXMLOutput->Write(XMLTAG_WorkingSetType_WorkingSet, (LPCTSTR)g_lpszBuffer);

    gXMLOutput->Write(XMLTAG_Memory_CommittedMemory, (LPCWSTR)NULL);

     _stprintf(g_lpszBuffer, TEXT("%ld"),
             PerfInfo.CommittedPages*(BasicInfo.PageSize/1024));
    gXMLOutput->Write(XMLTAG_CommittedMemoryType_Total, (LPCTSTR)g_lpszBuffer);

     _stprintf(g_lpszBuffer, TEXT("%ld"), SumCommit);
    gXMLOutput->Write(XMLTAG_CommittedMemoryType_UserMode, (LPCTSTR)g_lpszBuffer);

     _stprintf(g_lpszBuffer, TEXT("%ld"),
             PerfInfo.CommitLimit*(BasicInfo.PageSize/1024));
    gXMLOutput->Write(XMLTAG_CommittedMemoryType_Limit, (LPCTSTR)g_lpszBuffer);

     _stprintf(g_lpszBuffer, TEXT("%ld"),
             PerfInfo.PeakCommitment*(BasicInfo.PageSize/1024));
    gXMLOutput->Write(XMLTAG_CommittedMemoryType_Peak, (LPCTSTR)g_lpszBuffer);

    gXMLOutput->Write(XMLTAG_Memory_KernelMemory, (LPCWSTR)NULL);

     _stprintf(g_lpszBuffer, TEXT("%ld"),
             (PerfInfo.ResidentSystemCodePage + PerfInfo.ResidentSystemDriverPage)*(BasicInfo.PageSize/1024));
    gXMLOutput->Write(XMLTAG_KernelMemoryType_Nonpaged, (LPCTSTR)g_lpszBuffer);
    
    _stprintf(g_lpszBuffer, TEXT("%ld"),
             (PerfInfo.ResidentPagedPoolPage)*(BasicInfo.PageSize/1024));
    gXMLOutput->Write(XMLTAG_KernelMemoryType_Paged, (LPCTSTR)g_lpszBuffer);


    gXMLOutput->Write(XMLTAG_Memory_Pool, (LPCWSTR)NULL);
     _stprintf(g_lpszBuffer, TEXT("%ld"),
             PerfInfo.NonPagedPoolPages*(BasicInfo.PageSize/1024));
    gXMLOutput->Write(XMLTAG_PoolType_Nonpaged, (LPCTSTR)g_lpszBuffer);

     _stprintf(g_lpszBuffer, TEXT("%ld"),
             PerfInfo.PagedPoolPages*(BasicInfo.PageSize/1024));
    gXMLOutput->Write(XMLTAG_PoolType_Paged, (LPCTSTR)g_lpszBuffer);

    g_pTime->Timeit(hFile, L"SummaryInfo");
    
    LogPoolInfo(hFile);

    g_pTime->Timeit(hFile, L"PoolInfo");

    TotalOffset = 0;
    ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)LargeBuffer1;


    //
    //    Process summary information
    //
    gXMLOutput->Write(XMLTAG_SETDataType_ProcessSummaries, (LPCWSTR)NULL);

    while (TRUE) 
    {
        gXMLOutput->Write(XMLTAG_ProcessSummaryType_Process, (LPCWSTR) NULL );
        
        pname.Buffer = NULL;
        if ( ProcessInfo->ImageName.Buffer ) 
        {
            RtlUnicodeStringToAnsiString(&pname,(PUNICODE_STRING)&ProcessInfo->ImageName,TRUE);
        }

        RtlTimeToElapsedTimeFields ( &ProcessInfo->UserTime, &UserTime);
        RtlTimeToElapsedTimeFields ( &ProcessInfo->KernelTime, &KernelTime);

        //
        //    PID
        //
        sprintf((char*)g_lpszBuffer, "%3ld", HandleToUlong(ProcessInfo->UniqueProcessId));
        gXMLOutput->Write(XMLTAG_ProcessSummaryType_PID, (LPCSTR)g_lpszBuffer);
        
        //
        //    Name
        //
        _snprintf((char*)g_lpszBuffer, STR_BUFFER_SIZE, "%s",                     
                ProcessInfo->UniqueProcessId == 0 ? 
                "Idle Process" : (ProcessInfo->ImageName.Buffer ? pname.Buffer : "System"));
        ((char*)g_lpszBuffer)[ _tsizeof(g_lpszBuffer) - 1 ] = 0;
        gXMLOutput->Write(XMLTAG_ProcessSummaryType_Name, (LPCSTR)g_lpszBuffer);

        //
        //     UserTime
        //
        _snprintf((char*)g_lpszBuffer, STR_BUFFER_SIZE, "%3ld:%02ld:%02ld.%03ld",
                      UserTime.Hour,
                      UserTime.Minute,
                      UserTime.Second,
                      UserTime.Milliseconds );
        ((char*)g_lpszBuffer)[ _tsizeof(g_lpszBuffer) - 1 ] = 0;
        gXMLOutput->Write(XMLTAG_ProcessSummaryType_UserTime, (LPCSTR)g_lpszBuffer);

        //
        //    KernelTime
        //
        _snprintf((char*)g_lpszBuffer, STR_BUFFER_SIZE, "%3ld:%02ld:%02ld.%03ld",
                      KernelTime.Hour,
                      KernelTime.Minute,
                      KernelTime.Second,
                      KernelTime.Milliseconds );
        ((char*)g_lpszBuffer)[ _tsizeof(g_lpszBuffer) - 1 ] = 0;
        gXMLOutput->Write(XMLTAG_ProcessSummaryType_KernelTime, (LPCSTR)g_lpszBuffer);

        //
        //    Working Set
        //
        sprintf((char*)g_lpszBuffer, "%ld", ProcessInfo->WorkingSetSize / 1024);
        gXMLOutput->Write(XMLTAG_ProcessSummaryType_WorkingSet, (LPCSTR)g_lpszBuffer);

        //
        // PageFaults
        //
        sprintf((char*)g_lpszBuffer, "%ld", ProcessInfo->PageFaultCount);
        gXMLOutput->Write(XMLTAG_ProcessSummaryType_PageFaults, (LPCSTR)g_lpszBuffer);

        //
        //CommittedBytes
        //
        sprintf((char*)g_lpszBuffer, "%ld", ProcessInfo->PrivatePageCount / 1024);
        gXMLOutput->Write(XMLTAG_ProcessSummaryType_CommittedBytes, (LPCSTR)g_lpszBuffer);

        //
        // Priority
        //
        sprintf((char*)g_lpszBuffer, "%ld", ProcessInfo->BasePriority);
        gXMLOutput->Write(XMLTAG_ProcessSummaryType_Priority, (LPCSTR)g_lpszBuffer);

        //
        // HandleCount
        //
        sprintf((char*)g_lpszBuffer, "%ld", ProcessInfo->HandleCount);
        gXMLOutput->Write(XMLTAG_ProcessSummaryType_HandleCount, (LPCSTR)g_lpszBuffer);

        //
        // ThreadCount
        //
        sprintf((char*)g_lpszBuffer, "%ld", ProcessInfo->NumberOfThreads);
        gXMLOutput->Write(XMLTAG_ProcessSummaryType_ThreadCount, (LPCSTR)g_lpszBuffer);
    
        if ( pname.Buffer ) 
        {
            RtlFreeAnsiString(&pname);
        }

        if (ProcessInfo->NextEntryOffset == 0) 
        {
            break;
        }
        TotalOffset += ProcessInfo->NextEntryOffset;
        ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)&LargeBuffer1[TotalOffset];
    }

    g_pTime->Timeit(hFile, L"ProcessInfo");

    //
    //    Process Start up information
    //
    {
        ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)LargeBuffer1;
        
        TotalOffset = 0;
        gXMLOutput->Write(XMLTAG_SETDataType_ProcessStartInfo, (LPCWSTR)NULL);

        while (TRUE) 
        {
            HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, HandleToUlong(ProcessInfo->UniqueProcessId));
            if(hProcess)
            {
                PROCESS_BASIC_INFORMATION ppbi;
                status = NtQueryInformationProcess(hProcess, ProcessBasicInformation, &ppbi, sizeof(ppbi), NULL);
                if(NT_SUCCESS(status))
                {
                    PPEB ppeb = ppbi.PebBaseAddress;
                    struct _RTL_USER_PROCESS_PARAMETERS* pupp;
                    struct _RTL_USER_PROCESS_PARAMETERS rupp;
                    SIZE_T    dwRead, dwRead1, dwRead2;

                    if(ReadProcessMemory(hProcess, &ppeb->ProcessParameters, &pupp, sizeof(pupp), &dwRead)
                        && ReadProcessMemory(hProcess, pupp, &rupp, sizeof(rupp), &dwRead))
                    {
                        WCHAR CurrentDirectory[MAX_PATH];
                        WCHAR CommandLine[MAX_PATH];
                        WCHAR ImagePathName[MAX_PATH];

                        if(ReadProcessMemory(hProcess, 
                                            rupp.CurrentDirectory.DosPath.Buffer, 
                                            CurrentDirectory, 
                                            (MAX_PATH - 1) * sizeof(WCHAR) > rupp.CurrentDirectory.DosPath.Length ? 
                                            rupp.CurrentDirectory.DosPath.Length : (MAX_PATH - 1) * sizeof(WCHAR), 
                                            &dwRead)
                            && ReadProcessMemory(hProcess, 
                                            rupp.CommandLine.Buffer, 
                                            CommandLine, 
                                            (MAX_PATH - 1) * sizeof(WCHAR) > rupp.CommandLine.Length ? 
                                            rupp.CommandLine.Length : (MAX_PATH - 1) * sizeof(WCHAR), 
                                            &dwRead1)
                            && ReadProcessMemory(hProcess, 
                                            rupp.ImagePathName.Buffer, 
                                            ImagePathName, 
                                            (MAX_PATH - 1) * sizeof(WCHAR) > rupp.ImagePathName.Length ? 
                                            rupp.ImagePathName.Length : (MAX_PATH - 1) * sizeof(WCHAR), 
                                            &dwRead2)
                            )
                        {
                            CurrentDirectory[dwRead/sizeof(WCHAR)] = '\0';
                            CommandLine[dwRead1/sizeof(WCHAR)] = '\0';
                            ImagePathName[dwRead2/sizeof(WCHAR)] = '\0';
                            
                            gXMLOutput->Write(XMLTAG_ProcessStartInfoType_Process, (LPCWSTR)NULL);
                            
                            swprintf(g_lpszBuffer, L"%d", HandleToUlong(ProcessInfo->UniqueProcessId));
                            
                            gXMLOutput->Write(XMLTAG_ProcessStartInfoType_PID, (LPCWSTR)g_lpszBuffer);

                            gXMLOutput->Write(XMLTAG_ProcessStartInfoType_ImageName, (LPCWSTR)ImagePathName);
                            gXMLOutput->Write(XMLTAG_ProcessStartInfoType_CmdLine, (LPCWSTR)CommandLine);
                            gXMLOutput->Write(XMLTAG_ProcessStartInfoType_CurrentDir, (LPCWSTR)CurrentDirectory);
                        }
                    }

                }
                CloseHandle(hProcess);
            }
            if (ProcessInfo->NextEntryOffset == 0) 
            {
                break;
            }
            TotalOffset += ProcessInfo->NextEntryOffset;
            ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)&LargeBuffer1[TotalOffset];
        }
        
    }

    g_pTime->Timeit(hFile, L"ProcessStartupInfo");

    //
    //    Process thread information
    //
    {

        //WriteToLogFileA(hFile, "\nProcess thread information:\n");
        gXMLOutput->Write(XMLTAG_SETDataType_ProcessesThreadInfo, (LPCWSTR)NULL);
        TotalOffset = 0;
        ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)LargeBuffer1;
        while (TRUE) 
        {     
            DWORD dwThreadIndex = 0;
            ThreadInfo = (PSYSTEM_THREAD_INFORMATION)(ProcessInfo + 1);
            if (ProcessInfo->NumberOfThreads) 
            {
                 gXMLOutput->Write(XMLTAG_ProcessThreadInfoType_Process, (LPCWSTR)NULL);
                  
                _stprintf(g_lpszBuffer, TEXT("%d"), HandleToUlong(ProcessInfo->UniqueProcessId));
                gXMLOutput->Write(XMLTAG_ProcessThreadInfoType_PID, (LPCTSTR)g_lpszBuffer);

            }
            while (dwThreadIndex < ProcessInfo->NumberOfThreads) 
            {
                RtlTimeToElapsedTimeFields ( &ThreadInfo->UserTime, &UserTime);
                RtlTimeToElapsedTimeFields ( &ThreadInfo->KernelTime, &KernelTime);

                gXMLOutput->Write(XMLTAG_ProcessThreadInfoType_Thread, (LPCWSTR)NULL);

                //
                //    TID
                //
                wsprintf(g_lpszBuffer, TEXT("%lx"), 
                     ProcessInfo->UniqueProcessId == 0 ? 0 : HandleToUlong(ThreadInfo->ClientId.UniqueThread));
                     gXMLOutput->Write(XMLTAG_ProcessThreadInfoType_TID, (LPCWSTR)g_lpszBuffer);

                //
                // Priority
                //
                  wsprintf(g_lpszBuffer, TEXT("%ld"),     ProcessInfo->UniqueProcessId == 0 ? 0 : ThreadInfo->Priority);
                 gXMLOutput->Write(XMLTAG_ProcessThreadInfoType_Priority, (LPCWSTR)g_lpszBuffer);

                //
                //    Context Switches
                //
                  wsprintf(g_lpszBuffer, TEXT("%ld"), ThreadInfo->ContextSwitches);
                 gXMLOutput->Write(XMLTAG_ProcessThreadInfoType_ContextSwitches, (LPCWSTR)g_lpszBuffer);

                //
                //    Start Address
                //
                  wsprintf(g_lpszBuffer, TEXT("%p"), ProcessInfo->UniqueProcessId == 0 ? 0 : ThreadInfo->StartAddress);
                 gXMLOutput->Write(XMLTAG_ProcessThreadInfoType_StartAddress, (LPCWSTR)g_lpszBuffer);

                //
                //    User Time
                //
                wsprintf(g_lpszBuffer, TEXT("%2ld:%02ld:%02ld.%03ld"), 
                       UserTime.Hour,
                             UserTime.Minute,
                             UserTime.Second,
                             UserTime.Milliseconds);
                gXMLOutput->Write(XMLTAG_ProcessThreadInfoType_UserTime, (LPCWSTR)g_lpszBuffer);

                //
                //    Kernel Time
                //
                 wsprintf(g_lpszBuffer, TEXT("%2ld:%02ld:%02ld.%03ld"), 
                                 KernelTime.Hour,
                                 KernelTime.Minute,
                                 KernelTime.Second,
                                 KernelTime.Milliseconds);
                 gXMLOutput->Write(XMLTAG_ProcessThreadInfoType_KernelTime, (LPCWSTR)g_lpszBuffer);

                //
                //    State
                //
                 _snwprintf(g_lpszBuffer, STR_BUFFER_SIZE, TEXT("%s%s"), 
                             StateTable[ThreadInfo->ThreadState],  
                             (ThreadInfo->ThreadState == 5) ? WaitTable[ThreadInfo->WaitReason] : Empty    );
                 gXMLOutput->Write(XMLTAG_ProcessThreadInfoType_State, (LPCWSTR)g_lpszBuffer);

                ThreadInfo += 1;
                dwThreadIndex += 1;
            }
            if (ProcessInfo->NextEntryOffset == 0) 
            {
                break;
            }
            TotalOffset += ProcessInfo->NextEntryOffset;
            ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)&LargeBuffer1[TotalOffset];
        }
    }

    g_pTime->Timeit(hFile, L"ProcessThreadInfo");

    //
    //    Process module information
    //
    {
        gXMLOutput->Write(XMLTAG_SETDataType_ProcessesModuleInfo, (LPCWSTR)NULL);
        TotalOffset = 0;
        ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)LargeBuffer1;
        while (TRUE) 
        {   
            HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, HandleToUlong(ProcessInfo->UniqueProcessId));
            if(hProcess)
            {
#define            dwMaxModules 1024
                HMODULE modules[dwMaxModules];
                DWORD dwModules = 0;

                if(SnapshotEnumProcessModules(hProcess, modules, dwMaxModules * sizeof(HMODULE), &dwModules) && dwModules > 0)
                {
                       gXMLOutput->Write(XMLTAG_ProcessModuleInfoType_Process, (LPCWSTR)NULL);

                    _stprintf(g_lpszBuffer, TEXT("%d"), HandleToUlong(ProcessInfo->UniqueProcessId));
                    gXMLOutput->Write(XMLTAG_ProcessModuleInfoType_PID, (LPCTSTR)g_lpszBuffer);
                    
                    dwModules /= sizeof(HMODULE);
                    dwModules = dwModules > dwMaxModules? dwMaxModules : dwModules;
                    for(DWORD dwModuleIndex = 0; dwModuleIndex < dwModules; dwModuleIndex++)
                    {
                        MODULEINFO info;
                        WCHAR        szName[MAX_PATH + 1];

                        if(SnapshotGetModuleInformation(hProcess, modules[dwModuleIndex], &info, sizeof(MODULEINFO))
                            && SnapshotGetModuleFileNameExW(hProcess, modules[dwModuleIndex], szName, MAX_PATH - 1))
                        {
                               gXMLOutput->Write(XMLTAG_ProcessModuleInfoType_Module, (LPCWSTR)NULL);

                            //
                            // LoadAddr
                            //
                            _stprintf(g_lpszBuffer, TEXT("%14p"), info.lpBaseOfDll);
                            gXMLOutput->Write(XMLTAG_ProcessModuleInfoType_LoadAddr, g_lpszBuffer);

                            //
                            // ImageSize
                            //
                            _stprintf(g_lpszBuffer, TEXT("%d"), info.SizeOfImage);
                            gXMLOutput->Write(XMLTAG_ProcessModuleInfoType_ImageSize, g_lpszBuffer);

                            //
                            // Entry Point
                            //
                            _stprintf(g_lpszBuffer, TEXT("%11p"), info.EntryPoint);
                            gXMLOutput->Write(XMLTAG_ProcessModuleInfoType_EntryPoint, g_lpszBuffer);

                            //
                            // FileName
                            //
                            gXMLOutput->Write(XMLTAG_ProcessModuleInfoType_FileName, szName);
                            
                        }
                    }
                }
                CloseHandle(hProcess);
            }
            if (ProcessInfo->NextEntryOffset == 0) 
            {
                break;
            }
            TotalOffset += ProcessInfo->NextEntryOffset;
            ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)&LargeBuffer1[TotalOffset];
        }
    }

    g_pTime->Timeit(hFile, L"ProcessModuleInfo");

    PrintLoadedDrivers(hFile);

    g_pTime->Timeit(hFile, L"LoadedDrivers");

    gXMLOutput->Write(XMLTAG_SETDataType_OSInfo, (LPCWSTR)NULL);
    LogOsInfo(hFile);

    g_pTime->Timeit(hFile, L"OsInfo");

    LogHotfixes(hFile);

    g_pTime->Timeit(hFile, L"HotFixes");

    gXMLOutput->Write(XMLTAG_SETDataType_HardwareInfo, (LPCWSTR)NULL);
    LogBIOSInfo(hFile);

    g_pTime->Timeit(hFile, L"BiosInfo");

    LogHardwareInfo(hFile);

    g_pTime->Timeit(hFile, L"HardwareInfo");

    gXMLOutput->Write(XMLTAG_HardwareInfoType_DiskInfo, (LPCWSTR)NULL);
    LogPhysicalDiskInfo(hFile);

    g_pTime->Timeit(hFile, L"PhysicalDiskInfo");

    LogLogicalDriveInfo(hFile);

    g_pTime->Timeit(hFile, L"LogicalDriveInfo");

//
//  Removing ExtensionDll code
//      Right now CSRSS will call this snapshot dll, having ExtensionDll can impose
//  more security risk, so we are removing it out in production code.
//  
//    LoadExtensionDlls(hFile);
//
    g_pTime->Timeit(hFile, L"ExtensionDll");

    VirtualFree(LargeBuffer1, 0, MEM_RELEASE);
    delete g_pTime;
    g_pTime = NULL;
    return 0;

cleanup:
    VirtualFree(LargeBuffer1, 0, MEM_RELEASE);
    if(g_pTime)
    {
        delete g_pTime;
        g_pTime = NULL;
    }
    return 2;
}


typedef struct _MODULE_DATA 
{
    ULONG CodeSize;
    ULONG DataSize;
    ULONG BssSize;
    ULONG RoDataSize;
    ULONG ImportDataSize;
    ULONG ExportDataSize;
    ULONG ResourceDataSize;
    ULONG PagedSize;
    ULONG InitSize;
    ULONG CheckSum;
    ULONG TimeDateStamp;
} MODULE_DATA, *PMODULE_DATA;

typedef struct _LOADED_IMAGE 
{
    BYTE* MappedAddress;
    PIMAGE_NT_HEADERS FileHeader;
    PIMAGE_SECTION_HEADER LastRvaSection;
    int NumberOfSections;
    PIMAGE_SECTION_HEADER Sections;
} LOADED_IMAGE, *PLOADED_IMAGE;


VOID
SumModuleData(
    PMODULE_DATA Sum,
    PMODULE_DATA Current
    )
{
    Sum->CodeSize           += Current->CodeSize;
    Sum->DataSize           += Current->DataSize;
    Sum->BssSize            += Current->BssSize;
    Sum->RoDataSize         += Current->RoDataSize;
    Sum->ImportDataSize     += Current->ImportDataSize;
    Sum->ExportDataSize     += Current->ExportDataSize;
    Sum->ResourceDataSize   += Current->ResourceDataSize;
    Sum->PagedSize          += Current->PagedSize;
    Sum->InitSize           += Current->InitSize;
}

VOID
GetModuleData(
    HANDLE hFile,
    PMODULE_DATA Mod
    )

/*++

Routine Description:

    This function will Get the module data.

Arguments:

    hFile - handle to the log file.

Return Value:

    none.

--*/

{
    HANDLE    hMappedFile;
    PIMAGE_DOS_HEADER DosHeader;
    LOADED_IMAGE LoadedImage;
    ULONG SectionAlignment;
    PIMAGE_SECTION_HEADER Section;
    int        i;
    ULONG    Size;

    hMappedFile = CreateFileMapping(
                                   hFile,
                                   NULL,
                                   PAGE_READONLY,
                                   0,
                                   0,
                                   NULL
                                   );
    if ( !hMappedFile ) 
    {
        return;
    }

    LoadedImage.MappedAddress = (BYTE*) MapViewOfFile(
                                                     hMappedFile,
                                                     FILE_MAP_READ,
                                                     0,
                                                     0,
                                                     0
                                                     );
    CloseHandle(hMappedFile);

    if ( !LoadedImage.MappedAddress ) 
    {
        return;
    }

    //
    // Everything is mapped. Now check the image and find nt image headers
    //

    DosHeader = (PIMAGE_DOS_HEADER)LoadedImage.MappedAddress;

    if ( DosHeader->e_magic != IMAGE_DOS_SIGNATURE ) 
    {
        UnmapViewOfFile(LoadedImage.MappedAddress);
        return;
    }

    LoadedImage.FileHeader = (PIMAGE_NT_HEADERS)((ULONG_PTR)DosHeader + DosHeader->e_lfanew);

    if ( LoadedImage.FileHeader->Signature != IMAGE_NT_SIGNATURE ) 
    {
        UnmapViewOfFile(LoadedImage.MappedAddress);
        return;
    }

    LoadedImage.NumberOfSections = LoadedImage.FileHeader->FileHeader.NumberOfSections;
    LoadedImage.Sections = (PIMAGE_SECTION_HEADER)((ULONG_PTR)LoadedImage.FileHeader + sizeof(IMAGE_NT_HEADERS));
    LoadedImage.LastRvaSection = LoadedImage.Sections;

    //
    // Walk through the sections and tally the dater
    //

    SectionAlignment = LoadedImage.FileHeader->OptionalHeader.SectionAlignment;

    for (Section = LoadedImage.Sections,i=0; i<LoadedImage.NumberOfSections; i++,Section++) 
    {
        Size = Section->Misc.VirtualSize;

        if (Size == 0) 
        {
            Size = Section->SizeOfRawData;
        }

        Size = (Size + SectionAlignment - 1) & ~(SectionAlignment - 1);

        if (!memcmp((const char*) Section->Name,"PAGE", 4 )) 
        {
            Mod->PagedSize += Size;
        } 
        else if (!_stricmp((const char*) Section->Name,"INIT" )) 
        {
            Mod->InitSize += Size;
        } 
        else if (!_stricmp((const char*) Section->Name,".bss" )) 
        {
            Mod->BssSize = Size;
        } 
        else if (!_stricmp((const char*) Section->Name,".edata" )) 
        {
            Mod->ExportDataSize = Size;
        } 
        else if (!_stricmp((const char*) Section->Name,".idata" )) 
        {
            Mod->ImportDataSize = Size;
        } 
        else if (!_stricmp((const char*) Section->Name,".rsrc" )) 
        {
            Mod->ResourceDataSize = Size;
        } 
        else if (Section->Characteristics & IMAGE_SCN_MEM_EXECUTE) 
        {
            Mod->CodeSize += Size;
        } 
        else if (Section->Characteristics & IMAGE_SCN_MEM_WRITE) 
        {
            Mod->DataSize += Size;
        } 
        else if (Section->Characteristics & IMAGE_SCN_MEM_READ) 
        {
            Mod->RoDataSize += Size;
        } 
        else 
        {
            Mod->DataSize += Size;
        }
    }

    Mod->CheckSum = LoadedImage.FileHeader->OptionalHeader.CheckSum;
    Mod->TimeDateStamp = LoadedImage.FileHeader->FileHeader.TimeDateStamp;

    UnmapViewOfFile(LoadedImage.MappedAddress);
    return;

}


VOID
PrintLoadedDrivers(
    HANDLE hFile
    )

/*++

Routine Description:

    This function will retrieve and log the loaded drivers.

Arguments:

    hFile - handle to the log file.

Return Value:

    none.

--*/

{

    ULONG    i, j, ulLen;
    LPSTR    s;
    TCHAR    ModuleName[MAX_PATH + 1];
    HANDLE    FileHandle;
    TCHAR    KernelPath[MAX_PATH + 1];
    TCHAR    DriversPath[MAX_PATH + 1];
    LPTSTR    ModuleInfo;
    ULONG    ModuleInfoLength;
    ULONG    ReturnedLength;
    PRTL_PROCESS_MODULES Modules;
    PRTL_PROCESS_MODULE_INFORMATION Module;
    NTSTATUS    Status;
    MODULE_DATA Sum;
    MODULE_DATA Current;
    __int64        timeStamp;
    FILETIME    ft;
    SYSTEMTIME    st;

    gXMLOutput->Write(XMLTAG_SETDataType_KernelModuleInfo, (LPCWSTR)NULL);
    
    //
    // Locate system drivers.
    //

    ModuleInfoLength = 64000;
    while (1) 
    {
        ModuleInfo = (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, ModuleInfoLength * sizeof(TCHAR));
        if (ModuleInfo == NULL) 
        {
            wsprintf (g_lpszBuffer, TEXT("Failed to allocate memory for module information buffer of size %d"),
                      ModuleInfoLength);
            WriteToLogFile(hFile, g_lpszBuffer);
            return;
        }
        Status = NtQuerySystemInformation (
                                          SystemModuleInformation,
                                          ModuleInfo,
                                          ModuleInfoLength * sizeof(TCHAR),
                                          &ReturnedLength);

        if (!NT_SUCCESS(Status)) 
        {
            HeapFree(GetProcessHeap(), 0, (LPVOID)ModuleInfo);
            if (Status == STATUS_INFO_LENGTH_MISMATCH &&
                ReturnedLength > ModuleInfoLength * sizeof(TCHAR)) 
            {
                ModuleInfoLength = ReturnedLength / sizeof(TCHAR);
                continue;
            }
            _stnprintf(g_lpszBuffer, STR_BUFFER_SIZE,
                       TEXT("query system info failed status - %lx"),Status);
            g_lpszBuffer[ _tsizeof(g_lpszBuffer) - 1 ] = 0;

            WriteToLogFile(hFile, g_lpszBuffer);
            return;
        }
        break;
    }

    GetSystemDirectory(KernelPath,sizeof(KernelPath)/sizeof(TCHAR));
    lstrcpy(DriversPath, KernelPath);
    lstrcat(DriversPath,TEXT("\\Drivers"));
    ZeroMemory(&Sum,sizeof(Sum));
//    PrintModuleHeader(hFile);

    Modules = (PRTL_PROCESS_MODULES)ModuleInfo;
    Module = &Modules->Modules[ 0 ];
    for (i=0; i<Modules->NumberOfModules; i++) 
    {

        ZeroMemory(&Current,sizeof(Current));
        s = (LPSTR)&Module->FullPathName[ Module->OffsetToFileName ];
        //
        // try to open the file
        //

        SetCurrentDirectory(KernelPath);
#ifdef _UNICODE
        MultiByteToWideChar(CP_ACP, 0, s, -1, ModuleName, MAX_PATH);
#else
        strcpy(ModuleName, s);
#endif //_UNICODE
        FileHandle = CreateFile(
                               ModuleName,
                               GENERIC_READ,
                               FILE_SHARE_READ,
                               NULL,
                               OPEN_EXISTING,
                               0,
                               NULL
                               );

        if ( FileHandle == INVALID_HANDLE_VALUE ) 
        {
            SetCurrentDirectory(DriversPath);

            FileHandle = CreateFile(
                                   ModuleName,
                                   GENERIC_READ,
                                   FILE_SHARE_READ,
                                   NULL,
                                   OPEN_EXISTING,
                                   0,
                                   NULL
                                   );
        }

        if ( FileHandle != INVALID_HANDLE_VALUE ) 
        {
            GetModuleData(FileHandle,&Current);
            CloseHandle(FileHandle);
        }
        else 
        {
            continue;
        }

        gXMLOutput->Write(XMLTAG_KernelModuleInfoType_Module, (LPCWSTR)NULL);

        //
        //    Module Name
        //
        _stnprintf(g_lpszBuffer, STR_BUFFER_SIZE, TEXT("%s"), ModuleName);
        g_lpszBuffer[ _tsizeof(g_lpszBuffer) - 1 ] = 0;
        gXMLOutput->Write(XMLTAG_KernelModuleInfoType_ModuleName, (LPCTSTR)g_lpszBuffer);

        //
        // LoadAddress
        //
        _stprintf(g_lpszBuffer, TEXT("%p"), Module->ImageBase);
        gXMLOutput->Write(XMLTAG_KernelModuleInfoType_LoadAddress, (LPCTSTR)g_lpszBuffer);

        //
        // Code
        //
        _stprintf(g_lpszBuffer, TEXT("%d"), Current.CodeSize);
        gXMLOutput->Write(XMLTAG_KernelModuleInfoType_Code, (LPCTSTR)g_lpszBuffer);

        //    
        // Data
        //
        _stprintf(g_lpszBuffer, TEXT("%d"), Current.DataSize);
        gXMLOutput->Write(XMLTAG_KernelModuleInfoType_Data, (LPCTSTR)g_lpszBuffer);

        //
        // Paged
        //
        _stprintf(g_lpszBuffer, TEXT("%d"), Current.PagedSize);
        gXMLOutput->Write(XMLTAG_KernelModuleInfoType_Paged, (LPCTSTR)g_lpszBuffer);

        SumModuleData(&Sum,&Current);
        if (Current.TimeDateStamp) 
        {
            timeStamp = Current.TimeDateStamp;
            timeStamp += (__int64)11644444799;    //difference between filetime and time_t in seconds.
            timeStamp *= 10000000;                // turn into 100 nano seconds.
            ft.dwLowDateTime = (DWORD)timeStamp;
            for (j = 0; j < 32; j++)
                timeStamp /= 2;
            ft.dwHighDateTime = (DWORD)timeStamp;
            FileTimeToSystemTime(&ft, &st);

            //
            // Date & Time
            //
            _stnprintf(g_lpszBuffer, STR_BUFFER_SIZE,  TEXT("%d-%d-%d"), st.wMonth, st.wDay, st.wYear );
            g_lpszBuffer[ _tsizeof(g_lpszBuffer) - 1 ] = 0;
            gXMLOutput->Write(XMLTAG_KernelModuleInfoType_Date, (LPCTSTR)g_lpszBuffer);

            _stnprintf(g_lpszBuffer, STR_BUFFER_SIZE,  TEXT("%d:%d:%d"), st.wHour, st.wMinute, st.wSecond);
            g_lpszBuffer[ _tsizeof(g_lpszBuffer) - 1 ] = 0;
            gXMLOutput->Write(XMLTAG_KernelModuleInfoType_Time, (LPCTSTR)g_lpszBuffer);
        } 
        else 
        {
            gXMLOutput->Write(XMLTAG_KernelModuleInfoType_Date, (LPCTSTR)L"UNKNOWN");
            gXMLOutput->Write(XMLTAG_KernelModuleInfoType_Date, (LPCTSTR)L"UNKNOWN");
        }
        Module++;
    }
    
    XMLTAG_KernelModuleInfoType_TotalCode,
    XMLTAG_KernelModuleInfoType_TotalData,
    XMLTAG_KernelModuleInfoType_TotalPaged,

    _stprintf(g_lpszBuffer, TEXT("%d"), Sum.CodeSize);
    gXMLOutput->Write(XMLTAG_KernelModuleInfoType_TotalCode, (LPCTSTR)g_lpszBuffer);
    _stprintf(g_lpszBuffer, TEXT("%d"), Sum.DataSize);
    gXMLOutput->Write(XMLTAG_KernelModuleInfoType_TotalData, (LPCTSTR)g_lpszBuffer);
    _stprintf(g_lpszBuffer, TEXT("%d"), Sum.PagedSize);
    gXMLOutput->Write(XMLTAG_KernelModuleInfoType_TotalPaged, (LPCTSTR)g_lpszBuffer);

    HeapFree(GetProcessHeap(), 0, (LPVOID)ModuleInfo);
}


void 
LogLogicalDriveInfo(
     HANDLE hFile
    )

/*++

Routine Description:

    This function will retrieve and log the logical drive info.

Arguments:

    hFile - handle to the log file.

Return Value:

    none.

--*/

{
    DWORD    dwDriveMask;
    static TCHAR* tszDrives = TEXT("ABCDEFGHIJKLMNOPQRSTUVWXYZ");
    ULARGE_INTEGER i64FreeBytesToCaller;
    ULARGE_INTEGER i64TotalBytesToCaller;
    ULARGE_INTEGER i64TotalFreeBytesOnDrive;
    int        iMask;
    TCHAR    tszDrive[5];        //Buffer for drive such as "A:\".
    TCHAR    tszBuffer[NUM_OF_CHAR_IN_ULONG64];    //buffer to contain info for one logical drive.
    int        i;

    dwDriveMask = GetLogicalDrives();

    gXMLOutput->Write(XMLTAG_DiskInfoType_LogicalDrives, (LPCWSTR)NULL);

    for(i = 0; i < (int)_tcslen(tszDrives); i++)
    {
        iMask = dwDriveMask & 0x1;
        _stprintf(tszDrive, TEXT("%c:\\"), tszDrives[i]);
        dwDriveMask >>= 1;
        if(iMask && GetDriveType(tszDrive) == DRIVE_FIXED
            && GetDiskFreeSpaceEx(tszDrive, &i64FreeBytesToCaller, &i64TotalBytesToCaller, &i64TotalFreeBytesOnDrive))
        {
            gXMLOutput->Write(XMLTAG_LogicalDriveInfoType_LogicalDriveInfo, (LPCWSTR)NULL);
            gXMLOutput->Write(XMLTAG_LogicalDriveInfoType_DrivePath, tszDrive);
            _stprintf(tszBuffer, TEXT("%I64d"), i64TotalFreeBytesOnDrive.QuadPart);
            gXMLOutput->Write(XMLTAG_LogicalDriveInfoType_FreeSpaceBytes, tszBuffer);
            _stprintf(tszBuffer, TEXT("%I64d"), i64TotalBytesToCaller.QuadPart);
            gXMLOutput->Write(XMLTAG_LogicalDriveInfoType_TotalSpaceBytes, tszBuffer);
        }
    }
}

NTSTATUS 
SnapshotRegOpenKey(
    IN LPCWSTR lpKeyName,
    IN ACCESS_MASK DesiredAccess, 
    OUT PHANDLE KeyHandle
    )

/*++

Routine Description:

    This function will open a reg key.

Arguments:

    lpKeyName - name of the key.

    DesiredAccess - accecss flag.

    KeyHandle - holds the handle on success.

Return Value:

    NTSTATUS.

--*/

{
    OBJECT_ATTRIBUTES   ObjectAttributes;
    UNICODE_STRING      KeyName;
    RtlInitUnicodeString( &KeyName, lpKeyName );
    RtlZeroMemory(&ObjectAttributes, sizeof(OBJECT_ATTRIBUTES));
    NTSTATUS Status;
    InitializeObjectAttributes(
                &ObjectAttributes,
                &KeyName,
                OBJ_CASE_INSENSITIVE,
                NULL,
                NULL
                );

    Status = (NTSTATUS)NtOpenKey( KeyHandle, DesiredAccess, &ObjectAttributes );

    return Status;
}

NTSTATUS
SnapshotRegSetValueKey(
    IN HANDLE   KeyHandle,
    IN LPCWSTR  lpValueName,
    IN DWORD    dwType,
    IN LPVOID   lpData,
    IN DWORD    cbData
    )

/*++

Routine Description:

    This function will query val key.

Arguments:

    KeyHandle   - handle to the reg key.

    lpValueName - name of the reg val.

    dwType      - type of the value

    lpData      - PVOID data

    cbData      - cb of the data size    

Return Value:

    NTSTATUS.

--*/

{
    UNICODE_STRING  ValueName;

    RtlInitUnicodeString( &ValueName, lpValueName );

    return NtSetValueKey( KeyHandle,
                          &ValueName,
                          0,
                          dwType,
                          lpData,
                          cbData);
}

NTSTATUS
SnapshotRegQueryValueKey(
    IN HANDLE KeyHandle,
    IN LPCWSTR lpValueName,
    IN ULONG  Length,
    OUT PVOID KeyValue,
    OUT PULONG ResultLength
    )

/*++

Routine Description:

    This function will query val key.

Arguments:

    KeyHandle - handle to the reg key.

    lpValueName - name of the reg val.

    Length - length of lpValueName.

    KeyValue - Holds the value on return.

    ResultLength - the lenght of the result in bytes.

Return Value:

    NTSTATUS.

--*/

{
    UNICODE_STRING ValueName;
    ULONG        BufferLength;
    NTSTATUS    Status;
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation;
    RtlInitUnicodeString( &ValueName, lpValueName );

    BufferLength = FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data) + Length;
    KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION) malloc(BufferLength);
    if (KeyValueInformation == NULL) 
    {
        return STATUS_NO_MEMORY;
    }

    Status = NtQueryValueKey(
                KeyHandle,
                &ValueName,
                KeyValuePartialInformation,
                KeyValueInformation,
                BufferLength,
                ResultLength
                );
    if (NT_SUCCESS(Status)) 
    {

        RtlCopyMemory(KeyValue, 
                      KeyValueInformation->Data, 
                      KeyValueInformation->DataLength
                     );

        *ResultLength = KeyValueInformation->DataLength;
        if (KeyValueInformation->Type == REG_SZ) 
        {
            if (KeyValueInformation->DataLength + sizeof(WCHAR) > Length) 
            {
                KeyValueInformation->DataLength -= sizeof(WCHAR);
            }
            ((PUCHAR)KeyValue)[KeyValueInformation->DataLength++] = 0;
            ((PUCHAR)KeyValue)[KeyValueInformation->DataLength] = 0;
            *ResultLength = KeyValueInformation->DataLength + sizeof(WCHAR);
        }
    }
    free(KeyValueInformation);

    return Status;
}

NTSTATUS
SnapshotRegEnumKey(
    IN HANDLE KeyHandle,
    IN ULONG Index,
    OUT LPWSTR lpKeyName,
    OUT PULONG  lpNameLength
    )

/*++

Routine Description:

    This function enum reg keys.

Arguments:

    KeyHandle - handle to the reg key.

    Index - the index of the subkey.

    lpKeyName - holds the subkey name on return.

    lpNameLength - the length of the subkey name.

Return Value:

    NTSTATUS.

--*/

{
    UNICODE_STRING ValueName;
    ULONG        BufferLength;
    NTSTATUS    Status;
    PKEY_BASIC_INFORMATION pKeyBasicInformation;
    RtlInitUnicodeString( &ValueName, lpKeyName );

    BufferLength = FIELD_OFFSET(KEY_BASIC_INFORMATION, Name) + *lpNameLength;
    pKeyBasicInformation = (PKEY_BASIC_INFORMATION) malloc(BufferLength);
    if (pKeyBasicInformation == NULL)
    {
        return STATUS_NO_MEMORY;
    }

    Status = NtEnumerateKey(
        KeyHandle,
        Index,
        KeyBasicInformation,
        (PVOID)pKeyBasicInformation,
        BufferLength,
        lpNameLength
        );

    if (NT_SUCCESS(Status)) 
    {
        RtlCopyMemory(lpKeyName, 
                      pKeyBasicInformation->Name, 
                      pKeyBasicInformation->NameLength
                     );

        *lpNameLength = pKeyBasicInformation->NameLength;
        if(*lpNameLength > 0)
            lpKeyName[(*lpNameLength) - 1] = L'\0';
        else 
            lpKeyName[0] = L'\0';
    }
    free((BYTE*)pKeyBasicInformation);

    return Status;
}

void 
LogHardwareInfo(
     HANDLE hFile
     )

/*++

Routine Description:

    This function will retrieve and log hardware info
    (computer name, processor info and netcard info).

Arguments:

    hFile - handle to the log file.

Return Value:

    none

--*/

{
    LPCWSTR ComputerNameKey = L"\\Registry\\Machine\\SYSTEM\\CurrentControlSet\\Control\\ComputerName\\ActiveComputerName";
    LPCWSTR ComputerNameValsz = L"ComputerName";
    LPCWSTR ProcessorKey = L"\\Registry\\Machine\\HARDWARE\\DESCRIPTION\\System\\CentralProcessor";
    LPCWSTR ProcessorSpeedValdw = L"~MHz";
    LPCWSTR ProcessorIdentifierValsz = L"Identifier";
    LPCWSTR ProcessorVendorValsz = L"VendorIdentifier";
    LPCWSTR NetcardKey = L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\\NetworkCards";
    LPCWSTR NetcardDescsz = L"Description";
    LPCWSTR NetcardServiceNamesz = L"ServiceName";
    HANDLE  hKey;
    HANDLE  hSubkey;
    WCHAR    szVal[MAX_PATH + 1];
    WCHAR    szSubkey[MAX_PATH + 1];
    DWORD    dwVal;
    DWORD    dwSize;
    DWORD    dwSubkeyIndex;
    DWORD    dwRes;
    NTSTATUS Status = STATUS_SUCCESS;

    //Get Computer Name
    Status = SnapshotRegOpenKey(ComputerNameKey, KEY_READ, &hKey);
    if(!NT_SUCCESS(Status))
    {
        //WriteToLogFile(hFile, TEXT("Failed to open registry key for hardware information\n\n"));
        return;
    }
    dwSize = MAX_PATH * sizeof(WCHAR);
    Status = SnapshotRegQueryValueKey(hKey, ComputerNameValsz, dwSize, szVal, &dwSize);

    if(!NT_SUCCESS(Status))
    {
        NtClose(hKey);
        //WriteToLogFile(hFile, TEXT("Failed to query registry key value for hardware information\n\n"));
        return;
    }
    NtClose(hKey);
    //WriteToLogFile(hFile, TEXT("Active Computer Name: "));
    szVal[dwSize] = '\0';
    //WriteToLogFileW(hFile, szVal);
    //WriteToLogFile(hFile, TEXT("\n"));

    //Get Processor Info
    Status = SnapshotRegOpenKey(ProcessorKey, KEY_READ, &hKey);
    gXMLOutput->Write(XMLTAG_HardwareInfoType_ProcesorInfo, (LPCWSTR)NULL);
    if(!NT_SUCCESS(Status))
    {
        WriteToLogFile(hFile, TEXT("Failed to open registry key for hardware information"));
        return;
    }
    dwSubkeyIndex = 0;
    dwSize = MAX_PATH * sizeof(WCHAR);

    Status = SnapshotRegEnumKey(hKey, dwSubkeyIndex, szSubkey, &dwSize);
    while(NT_SUCCESS(Status))
    {
        wcscpy(szVal, ProcessorKey);
        wcscat(szVal, L"\\");
        wcscat(szVal, szSubkey);

        Status = SnapshotRegOpenKey(szVal, KEY_READ, &hSubkey);
        gXMLOutput->Write(XMLTAG_ProcessorInfoType_Processor, (LPCWSTR)NULL);
        if(!NT_SUCCESS(Status))
        {
            NtClose(hKey);
            WriteToLogFile(hFile, TEXT("Failed to open registry key for hardware information"));
            return;
        }

        dwSize = sizeof(DWORD);
        Status = SnapshotRegQueryValueKey(hSubkey, ProcessorSpeedValdw, dwSize, &dwVal, &dwSize);
        if(!NT_SUCCESS(Status))
        {
            NtClose(hKey);
            NtClose(hSubkey);
            WriteToLogFile(hFile, TEXT("Failed to query registry key value for hardware information"));
            return;
        }

        _stnprintf(g_lpszBuffer, STR_BUFFER_SIZE, TEXT("%s"), szSubkey);
        g_lpszBuffer[ _tsizeof(g_lpszBuffer) - 1 ] = 0;
        gXMLOutput->Write(XMLTAG_ProcessorInfoType_Number, (LPCTSTR)g_lpszBuffer);

        _stprintf(g_lpszBuffer, TEXT("%d"), dwVal);
        gXMLOutput->Write(XMLTAG_ProcessorInfoType_Speed, (LPCTSTR)g_lpszBuffer);

        dwSize = MAX_PATH * sizeof(WCHAR);
        Status = SnapshotRegQueryValueKey(hSubkey, ProcessorIdentifierValsz, dwSize, szVal, &dwSize);
        gXMLOutput->Write(XMLTAG_ProcessorInfoType_Identifier, (LPCTSTR)NULL);
        if(!NT_SUCCESS(Status))
        {
            NtClose(hKey);
            NtClose(hSubkey);
            WriteToLogFile(hFile, TEXT("Failed to query registry key value for hardware information"));
            return;
        }
        WriteToLogFileW(hFile, szVal);

        dwSize = MAX_PATH * sizeof(WCHAR);
        Status = SnapshotRegQueryValueKey(hSubkey, ProcessorVendorValsz, dwSize, szVal, &dwSize);
        gXMLOutput->Write(XMLTAG_ProcessorInfoType_VendorIdent, (LPCTSTR)NULL);
        if(!NT_SUCCESS(Status))
        {
            NtClose(hKey);
            NtClose(hSubkey);
            WriteToLogFile(hFile, TEXT("Failed to query registry key value for hardware information"));
            return;
        }
        WriteToLogFileW(hFile, szVal);

        NtClose(hSubkey);
        dwSubkeyIndex++;
        Status = SnapshotRegEnumKey(hKey, dwSubkeyIndex, szSubkey, &dwSize);
    }
    NtClose(hKey);

    //Get NetCard Info

    gXMLOutput->Write(XMLTAG_HardwareInfoType_NICInfo, (LPCWSTR)NULL);
    Status = SnapshotRegOpenKey(NetcardKey, KEY_READ, &hKey);
    if(!NT_SUCCESS(Status))
    {
        WriteToLogFile(hFile, TEXT("Failed to open registry key for hardware information"));
        return;
    }

    dwSubkeyIndex = 0;
    dwSize = MAX_PATH * sizeof(WCHAR);
    Status = SnapshotRegEnumKey(hKey, dwSubkeyIndex, szSubkey, &dwSize);
    while(NT_SUCCESS(Status))
    {
        wcscpy(szVal, NetcardKey);
        wcscat(szVal, L"\\");
        wcscat(szVal, szSubkey);
        Status = SnapshotRegOpenKey(szVal, KEY_READ, &hSubkey);
        gXMLOutput->Write(XMLTAG_NICInfoType_NIC, (LPCWSTR)NULL);
        if(!NT_SUCCESS(Status))
        {
            NtClose(hKey);
            WriteToLogFile(hFile, TEXT("Failed to open registry key for hardware information"));
            return;
        }

        dwSize = MAX_PATH * sizeof(WCHAR);
        Status = SnapshotRegQueryValueKey(hSubkey, NetcardDescsz, dwSize, szVal, &dwSize);
        if(!NT_SUCCESS(Status))
        {
            NtClose(hKey);
            NtClose(hSubkey);
            WriteToLogFile(hFile, TEXT("Failed to query registry key value for hardware information"));
            return;
        }

        gXMLOutput->Write(XMLTAG_NICInfoType_Description, (LPCWSTR)NULL);
        WriteToLogFileW(hFile, szVal);

        dwSize = MAX_PATH * sizeof(WCHAR);
        Status = SnapshotRegQueryValueKey(hSubkey, NetcardServiceNamesz, dwSize, szVal, &dwSize);
        gXMLOutput->Write(XMLTAG_NICInfoType_ServiceName, (LPCWSTR)NULL);
        if(!NT_SUCCESS(Status))
        {
            NtClose(hKey);
            NtClose(hSubkey);
            WriteToLogFile(hFile, TEXT("Failed to query registry key value for hardware information"));
            return;
        }
        WriteToLogFileW(hFile, szVal);
        NtClose(hSubkey);
        dwSubkeyIndex++;
        Status = SnapshotRegEnumKey(hKey, dwSubkeyIndex, szSubkey, &dwSize);
    }

    NtClose(hKey);

}


BOOL
SnapshotIsVolumeName(
    LPWSTR Name
    )

/*++

Routine Description:

    This function is a helper for LogPhysicalDiskInfo.

Arguments:

    Name - name to verify.

Return Value:

    TRUE if is volume name, else FALSE.

--*/

{
    if (Name[0] == '\\' &&
        (Name[1] == '?' || Name[1] == '\\') &&
        Name[2] == '?' &&
        Name[3] == '\\' &&
        Name[4] == 'V' &&
        Name[5] == 'o' &&
        Name[6] == 'l' &&
        Name[7] == 'u' &&
        Name[8] == 'm' &&
        Name[9] == 'e' &&
        Name[10] == '{' &&
        Name[19] == '-' &&
        Name[24] == '-' &&
        Name[29] == '-' &&
        Name[34] == '-' &&
        Name[47] == '}' ) {

        return TRUE;
        }
    return FALSE;
}


void 
WriteTagEntry(
    PSYSTEM_POOLTAG TagInfo,
    ULONG SessionId
)
/*++

Routine Description:

    This function will write the XML tags for a single tag entry. It is used to log both session and system pool information

Arguments:

    TagInfo - Contains the alloc info. for the particular tag
    Session id - 
                      -1            for System pool
                      Session id for Session pool

Return Value:

    None

--*/

{
    if (TagInfo == NULL) {
    	return;
    }

    if (!(TagInfo->PagedAllocs) && !(TagInfo->NonPagedAllocs)) {
    	//We don't need a TagEntry for BIG pool
    	return;
    }
    
    gXMLOutput->Write( XMLTAG_PoolInfo_TagEntry, (LPCWSTR)NULL);        
            
    //Add the entries
    _stprintf (g_lpszBuffer, TEXT("%c%c%c%c"),TagInfo->Tag[0],TagInfo->Tag[1],TagInfo->Tag[2],TagInfo->Tag[3]);

    gXMLOutput->Write(XMLTAG_PoolInfo_TagEntry_PoolTag, (LPCTSTR)g_lpszBuffer);

    if (TagInfo->PagedAllocs != 0)
    {
        gXMLOutput->Write(XMLTAG_PoolInfo_TagEntry_PoolType, _T("Paged"));               

        _stprintf (g_lpszBuffer, TEXT("%ld"),TagInfo->PagedAllocs);
        gXMLOutput->Write(XMLTAG_PoolInfo_TagEntry_NumAllocs, (LPCTSTR)g_lpszBuffer);
            
        _stprintf (g_lpszBuffer, TEXT("%ld"),TagInfo->PagedFrees);
        gXMLOutput->Write(XMLTAG_PoolInfo_TagEntry_NumFrees, (LPCTSTR)g_lpszBuffer);

        _stprintf (g_lpszBuffer, TEXT("%ld"),TagInfo->PagedUsed);
        gXMLOutput->Write(XMLTAG_PoolInfo_TagEntry_NumBytes, (LPCTSTR)g_lpszBuffer);

                
    }
    else if (TagInfo->NonPagedAllocs != 0)
    {
        gXMLOutput->Write(XMLTAG_PoolInfo_TagEntry_PoolType, _T("Nonp"));               

        _stprintf (g_lpszBuffer, TEXT("%ld"),TagInfo->NonPagedAllocs);
        gXMLOutput->Write(XMLTAG_PoolInfo_TagEntry_NumAllocs, (LPCTSTR)g_lpszBuffer);
            
        _stprintf (g_lpszBuffer, TEXT("%ld"),TagInfo->NonPagedFrees);
        gXMLOutput->Write(XMLTAG_PoolInfo_TagEntry_NumFrees, (LPCTSTR)g_lpszBuffer);

        _stprintf (g_lpszBuffer, TEXT("%ld"),TagInfo->NonPagedUsed);
        gXMLOutput->Write(XMLTAG_PoolInfo_TagEntry_NumBytes, (LPCTSTR)g_lpszBuffer);

    }
            
    _stprintf(g_lpszBuffer, TEXT("%ld"),SessionId);
    gXMLOutput->Write(XMLTAG_PoolInfo_TagEntry_SessionID, (LPCTSTR)g_lpszBuffer);               

    
}

NTSTATUS
GetSystemPoolInformation(
    PUCHAR *SystemBuffer,
    SIZE_T *SystemBufferSize
    )
/*++

Routine Description:

    This function will retrieve system pool tag information

Arguments:

    SystemBuffer - Will hold the tag information
    SystemBufferSize - Size of this buffer

Return Value:

    Status of the query

--*/

{
    size_t NewBufferSize;
    NTSTATUS ReturnedStatus = STATUS_SUCCESS;

    if( SystemBuffer == NULL || SystemBufferSize == NULL ) {
        return STATUS_INVALID_PARAMETER;

    }

    //
    // There is no buffer allocated yet.
    //

    if( *SystemBufferSize == 0 || *SystemBuffer == NULL ) {

        NewBufferSize = sizeof( UCHAR ) * BUFFER_SIZE_STEP;

        *SystemBuffer = (PUCHAR) malloc( NewBufferSize );

        if( *SystemBuffer != NULL ) {

            *SystemBufferSize = NewBufferSize;
        
        } else {

            //
            // insufficient memory
            //

            ReturnedStatus = STATUS_INSUFFICIENT_RESOURCES;

        }

    }

    //
    // Iterate by buffer's size.
    //

    while( *SystemBuffer != NULL ) {

        ReturnedStatus = NtQuerySystemInformation (
            SystemPoolTagInformation,
            *SystemBuffer,
            (ULONG)*SystemBufferSize,
            NULL );

        if( ! NT_SUCCESS(ReturnedStatus) ) {

            //
            // Free the current buffer.
            //

            free( *SystemBuffer );
            
            *SystemBuffer = NULL;

            if (ReturnedStatus == STATUS_INFO_LENGTH_MISMATCH) {

                //
                // Try with a larger buffer size.
                //

                NewBufferSize = *SystemBufferSize + BUFFER_SIZE_STEP;

                *SystemBuffer = (PUCHAR) malloc( NewBufferSize );

                if( *SystemBuffer != NULL ) {

                    //
                    // Allocated new buffer.
                    //

                    *SystemBufferSize = NewBufferSize;

                } else {

                    //
                    // Insufficient memory.
                    //

                    ReturnedStatus = STATUS_INSUFFICIENT_RESOURCES;

                    *SystemBufferSize = 0;

                }

            } else {

                *SystemBufferSize = 0;

            }

        } else  {

            //
            // NtQuerySystemInformation returned success.
            //

            break;

        }
    }

    return ReturnedStatus;
}

NTSTATUS
GetSessionPoolInformation ( )
/*++

Routine Description:

    This function will retrieve pool tag information for terminal server sessions

Arguments:

    None
    
Return Value:

    Status of the query

--*/

{
    NTSTATUS Status;
    ULONG NewBufferSize;
    SYSTEM_SESSION_PROCESS_INFORMATION SessionProcessInformation;
    ULONG SessionBufferSize = 0;
    PSYSTEM_SESSION_POOLTAG_INFORMATION SessionBuffer = NULL;
    PSYSTEM_SESSION_POOLTAG_INFORMATION CrtSessionPooltagInfo;
    ULONG SessionTag=0;
    PSYSTEM_POOLTAG TagInfo;


    //Get information for all sessions
    SessionProcessInformation.SessionId = -1;

    while (TRUE)
    {
        SessionProcessInformation.SizeOfBuf = SessionBufferSize;
        SessionProcessInformation.Buffer = SessionBuffer;

        Status = NtQuerySystemInformation (SystemSessionPoolTagInformation,
                                           &SessionProcessInformation,
                                           sizeof (SessionProcessInformation),
                                           & NewBufferSize);

        if (Status == STATUS_INFO_LENGTH_MISMATCH) {

            if (SessionBufferSize != 0) {

                //
                // Our buffer is just not large enough. Add BUFFER_SIZE_STEP
                // to its size. 

                free (SessionBuffer);

                NewBufferSize = SessionBufferSize + BUFFER_SIZE_STEP;
            }

            SessionBuffer = (PSYSTEM_SESSION_POOLTAG_INFORMATION)malloc (NewBufferSize);

            if (SessionBuffer == NULL) {
                
                //
                // Bad luck, we cannot allocate so much memory
                // so bail out.
                //

                SessionBufferSize = 0;

                if (SessionBuffer) {
                    free(SessionBuffer);
                }
                
                return STATUS_NO_MEMORY;
            }

            SessionBufferSize = NewBufferSize;
        }
        else if (Status == STATUS_INVALID_INFO_CLASS) {

            //
            // This is probably a Win2k or XP box so we just ignore the error.
            //
            
            ASSERT (SessionBuffer == NULL);

            break;
        }
        else if (!NT_SUCCESS(Status)) {

            //
            // Query failed for some reason.
            //

            return Status;
        }
        else {

            //
            // All set - we have the information.
            //

            if (NewBufferSize == 0 && SessionBuffer != NULL) {

                //
                // We didn't get back any information (e.g. the session doesn't exist).
                //

                SessionBuffer->Count = 0;
            }

            break;
        }
    }

    //No sessions in existence.. just return
    if (SessionBuffer == NULL) {
        return STATUS_SUCCESS;
    }
    
    //We have the session info. now.. ready for output
    CrtSessionPooltagInfo = SessionBuffer;

    while (TRUE) {
        
        for (SessionTag = 0; SessionTag < CrtSessionPooltagInfo->Count; SessionTag += 1) {

            TagInfo = &(CrtSessionPooltagInfo->TagInfo[ SessionTag ]);

            WriteTagEntry(TagInfo,CrtSessionPooltagInfo->SessionId);
           
        }
        
        if (CrtSessionPooltagInfo->NextEntryOffset > 0)
            CrtSessionPooltagInfo = (PSYSTEM_SESSION_POOLTAG_INFORMATION)
                    ((PCHAR)CrtSessionPooltagInfo + CrtSessionPooltagInfo->NextEntryOffset);
        else
            break;
        
    }

    if (SessionBuffer) 
    {
       free(SessionBuffer);
    }
    
    return STATUS_SUCCESS;

}

void LogPoolInfo(
	HANDLE hFile
    )

/*++

Routine Description:

    This function will retrieve and log information about the system and session pools

Arguments:

    hFile - handle to the log file.

Return Value:

    none

--*/
{
    NTSTATUS    Status;                   // status from NT api
    DWORD        x= 0;                     // counter
    PSYSTEM_POOLTAG_INFORMATION PoolInfo;
    PUCHAR        SystemBuffer = NULL;
    SIZE_T        SystemBufferSize = 0;
    
    // grab all pool information
    Status = GetSystemPoolInformation(
                &SystemBuffer,
                &SystemBufferSize
                );

    if (! NT_SUCCESS(Status)) {

        goto Error;
    }

    PoolInfo = (PSYSTEM_POOLTAG_INFORMATION)SystemBuffer;

    //Add the tags for the PoolInfo
    gXMLOutput->Write( XMLTAG_SETDataType_PoolInfo, (LPCWSTR)NULL);

    gXMLOutput->Write( XMLTAG_PoolInfo_AllocInformation, (LPCWSTR)NULL);
    
    for (x = 0; x < (int)PoolInfo->Count; x++) {
        WriteTagEntry(&(PoolInfo->TagInfo[x]),-1);
     }

    GetSessionPoolInformation();

Error:
    if(SystemBuffer) {
        free(SystemBuffer);
    }
}


void
LogPhysicalDiskInfo(
    HANDLE hFile
    )

/*++

Routine Description:

    This function will retrieve and log the physical disk infor.

Arguments:

    hFile - handle to the log file.

Return Value:

    none

--*/

{
    PMOUNTMGR_MOUNT_POINTS    mountPoints = NULL;
    MOUNTMGR_MOUNT_POINT    mountPoint;
    ULONG                    returnSize, success;
    SYSTEM_DEVICE_INFORMATION DevInfo;
    NTSTATUS                Status = STATUS_SUCCESS;
    ULONG                    NumberOfDisks;
    PWCHAR                    deviceNameBuffer;
    ULONG                    i;
    OBJECT_ATTRIBUTES        ObjectAttributes;
    IO_STATUS_BLOCK            IoStatus;

    DISK_GEOMETRY            disk_geometry;
    PDISK_CACHE_INFORMATION disk_cache;
    PSCSI_ADDRESS            scsi_address;
    PWCHAR                    KeyName;
    WCHAR                    wszVal[MAX_PATH + 1];
    HANDLE                    hDisk = INVALID_HANDLE_VALUE;
    UNICODE_STRING            UnicodeName;

    ULONG                    SizeNeeded;
    DWORD                    dwSize;
    const ULONG              MAX_MOUNT_POINTS_SIZE = 4096;
    //
    //  Get the Number of Physical Disks
    //
    gXMLOutput->Write(XMLTAG_DiskInfoType_PhysicalInfo, (LPCWSTR)NULL);

    RtlZeroMemory(&DevInfo, sizeof(DevInfo));
    Status =   NtQuerySystemInformation(
                    SystemDeviceInformation,
                    &DevInfo, sizeof (DevInfo), NULL);

    if (!NT_SUCCESS(Status))
    {
        WriteToLogFile(hFile, TEXT("Failed to query system information"));
        return;
    }

    NumberOfDisks = DevInfo.NumberOfDisks;

    //
    // Open Each Physical Disk and get Disk Layout information
    //

    for (i=0; i < NumberOfDisks; i++) 
    {

        DISK_CACHE_INFORMATION cacheInfo;
        WCHAR    driveBuffer[20];

        HANDLE    PartitionHandle;
        HANDLE    KeyHandle;
        ULONG    DataLength;

        gXMLOutput->Write(XMLTAG_PhysicalInfoType_Disk, (LPCWSTR)NULL);

        //
        // Get Partition0 handle to get the Disk layout 
        //
        deviceNameBuffer = (PWCHAR) g_lpszBuffer;
        swprintf(deviceNameBuffer, L"\\Device\\Harddisk%d\\Partition0", i);

        RtlInitUnicodeString(&UnicodeName, deviceNameBuffer);

        InitializeObjectAttributes(
                   &ObjectAttributes,
                   &UnicodeName,
                   OBJ_CASE_INSENSITIVE,
                   NULL,
                   NULL
                   );
        Status = NtOpenFile(
                &PartitionHandle,
                FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                &ObjectAttributes,
                &IoStatus,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE
                );


        if (!NT_SUCCESS(Status)) 
        {
            WriteToLogFile(hFile, TEXT("Failed calling NtOpenFile"));
            return;
        }

        RtlZeroMemory(&disk_geometry, sizeof(DISK_GEOMETRY));

        // get geomerty information, the caller wants this
        Status = NtDeviceIoControlFile(PartitionHandle,
                       0,
                       NULL,
                       NULL,
                       &IoStatus,
                       IOCTL_DISK_GET_DRIVE_GEOMETRY,
                       NULL,
                       0,
                       &disk_geometry,
                       sizeof (DISK_GEOMETRY)
                       );
        if (!NT_SUCCESS(Status)) 
        {
            NtClose(PartitionHandle);
            WriteToLogFile(hFile, TEXT("Failed calling NtDeviceIoControlFile 1"));
            return;
        }

        scsi_address = (PSCSI_ADDRESS) g_lpszBuffer;
        Status = NtDeviceIoControlFile(PartitionHandle,
                        0,
                        NULL,
                        NULL,
                        &IoStatus,
                        IOCTL_SCSI_GET_ADDRESS,
                        NULL,
                        0,
                        scsi_address,
                        sizeof (SCSI_ADDRESS)
                        );

        NtClose(PartitionHandle);

        if (!NT_SUCCESS(Status)) 
        {
            WriteToLogFile(hFile, TEXT("Failed calling NtDeviceIoControlFile 2"));
            return;
        }

        //
        // Get Manufacturer's name from Registry
        // We need to get the SCSI Address and then query the Registry with it.
        //

        KeyName = (PWCHAR) g_lpszBuffer;
        swprintf(KeyName, 
                 L"\\Registry\\Machine\\Hardware\\DeviceMap\\Scsi\\Scsi Port %d\\Scsi Bus %d\\Target ID %d\\Logical Unit Id %d",
                 scsi_address->PortNumber, scsi_address->PathId, scsi_address->TargetId, scsi_address->Lun
                );
        Status = SnapshotRegOpenKey(KeyName, KEY_READ, &KeyHandle);
        if (!NT_SUCCESS(Status))
        {
            WriteToLogFile(hFile, TEXT("Failed to open registry key for physical disk information"));
            return;
        }
        else 
        {
            dwSize = MAX_PATH * sizeof(WCHAR);
            Status = SnapshotRegQueryValueKey(KeyHandle, L"Identifier", dwSize, wszVal, &dwSize);
            if(!NT_SUCCESS(Status))
            {
                NtClose(KeyHandle);
                WriteToLogFile(hFile, TEXT("Failed to query registry value for physical disk information"));
                return;
            }
            NtClose(KeyHandle);
        }

        //
        // Package all information about this disk and write an event record
        //

        _stprintf(g_lpszBuffer, TEXT("%d"), i);
        gXMLOutput->Write(XMLTAG_PhysicalInfoType_ID, (LPCTSTR)g_lpszBuffer);
        _stprintf(g_lpszBuffer, TEXT("%d"), disk_geometry.BytesPerSector);
        gXMLOutput->Write(XMLTAG_PhysicalInfoType_BytesPerSector, (LPCTSTR)g_lpszBuffer);
        _stprintf(g_lpszBuffer, TEXT("%d"), disk_geometry.SectorsPerTrack);
        gXMLOutput->Write(XMLTAG_PhysicalInfoType_SectorsPerTrack, (LPCTSTR)g_lpszBuffer);
        _stprintf(g_lpszBuffer, TEXT("%d"), disk_geometry.TracksPerCylinder);
        gXMLOutput->Write(XMLTAG_PhysicalInfoType_TracksPerCylinder, (LPCTSTR)g_lpszBuffer);
        _stprintf(g_lpszBuffer, TEXT("%I64d"), disk_geometry.Cylinders.QuadPart);
        gXMLOutput->Write(XMLTAG_PhysicalInfoType_NumberOfCylinders, (LPCTSTR)g_lpszBuffer);
        _stprintf(g_lpszBuffer, TEXT("%d"), scsi_address->PortNumber);
        gXMLOutput->Write(XMLTAG_PhysicalInfoType_PortNumber, (LPCTSTR)g_lpszBuffer);
        _stprintf(g_lpszBuffer, TEXT("%d"), scsi_address->PathId);
        gXMLOutput->Write(XMLTAG_PhysicalInfoType_PathID, (LPCTSTR)g_lpszBuffer);
        _stprintf(g_lpszBuffer, TEXT("%d"), scsi_address->TargetId);
        gXMLOutput->Write(XMLTAG_PhysicalInfoType_TargetID, (LPCTSTR)g_lpszBuffer);
        _stprintf(g_lpszBuffer, TEXT("%d"), scsi_address->Lun);
        gXMLOutput->Write(XMLTAG_PhysicalInfoType_LUN, (LPCTSTR)g_lpszBuffer);

        gXMLOutput->Write(XMLTAG_PhysicalInfoType_Manufacturer, (LPCWSTR)NULL);
        WriteToLogFileW(hFile, wszVal);
    }

    //
    // Get Logical Disk Information
    //
    wcscpy(wszVal, MOUNTMGR_DEVICE_NAME);
    RtlInitUnicodeString(&UnicodeName, (LPWSTR)wszVal);
    UnicodeName.MaximumLength = MAXSTR;

    InitializeObjectAttributes(
                    &ObjectAttributes,
                    &UnicodeName,
                    OBJ_CASE_INSENSITIVE,
                    NULL,
                    NULL );
    Status = NtCreateFile(
                    &hDisk,
                    GENERIC_READ | SYNCHRONIZE,
                    &ObjectAttributes,
                    &IoStatus,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    FILE_OPEN_IF,
                    FILE_SYNCHRONOUS_IO_NONALERT|FILE_NON_DIRECTORY_FILE,
                    NULL, 0);

    gXMLOutput->Write(XMLTAG_DiskInfoType_PartitionByDiskInfo, (LPCWSTR)NULL);
        
    if (!NT_SUCCESS(Status) ) 
    {
        WriteToLogFile(hFile, TEXT("Failed calling NtCreateFile"));
        return;
    }

    mountPoints = (PMOUNTMGR_MOUNT_POINTS)VirtualAlloc (NULL,
                                                        MAX_MOUNT_POINTS_SIZE,
                                                        MEM_COMMIT,
                                                        PAGE_READWRITE );

    if ( !mountPoints )
    {
        WriteToLogFile(hFile, TEXT("Failed calling VirtualAlloc"));
        goto error;
    }

    RtlZeroMemory(&mountPoint, sizeof(MOUNTMGR_MOUNT_POINT));
    mountPoints->Size = 0;
    returnSize = 0;
    
    Status = NtDeviceIoControlFile(hDisk,
                    0,
                    NULL,
                    NULL,
                    &IoStatus,
                    IOCTL_MOUNTMGR_QUERY_POINTS,
                    mountPoints,
                    sizeof(MOUNTMGR_MOUNT_POINT),
                    mountPoints,
                    MAX_MOUNT_POINTS_SIZE
                    );

    if ( STATUS_BUFFER_OVERFLOW == Status )
    {
        ULONG size = mountPoints->Size;

        VirtualFree( mountPoints, 0, MEM_RELEASE);
        mountPoints = NULL;

        if ( size != 0 )
        {
            //
            //  retry with the new size
            //
            mountPoints = (PMOUNTMGR_MOUNT_POINTS)VirtualAlloc (NULL,
                                                                size,
                                                                MEM_COMMIT,
                                                                PAGE_READWRITE );

            if ( !mountPoints )
            {
                WriteToLogFile(hFile, TEXT("Failed calling VirtualAlloc"));
                goto error;
            }

            RtlZeroMemory(&mountPoint, sizeof(MOUNTMGR_MOUNT_POINT));
            returnSize = 0;
    
            Status = NtDeviceIoControlFile(hDisk,
                            0,
                            NULL,
                            NULL,
                            &IoStatus,
                            IOCTL_MOUNTMGR_QUERY_POINTS,
                            mountPoints,
                            sizeof(MOUNTMGR_MOUNT_POINT),
                            mountPoints,
                            size
                            );
        }
    }

    if (NT_SUCCESS(Status)) 
    {
        WCHAR    name[MAX_PATH + 1];
        CHAR    OutBuffer[MAXSTR];
        PMOUNTMGR_MOUNT_POINT point;
        UNICODE_STRING VolumePoint;
        PVOLUME_DISK_EXTENTS VolExt;
        PDISK_EXTENT DiskExt;
        ULONG    lMountIndex;
        int        iDisk, iPartition;
        iDisk = -1;

    
        for (lMountIndex=0; lMountIndex<mountPoints->NumberOfMountPoints; lMountIndex++) 
        {
            point = &mountPoints->MountPoints[lMountIndex];

            if (point->SymbolicLinkNameLength) 
            {
                RtlCopyMemory(name,
                    (PCHAR) mountPoints + point->SymbolicLinkNameOffset,
                    point->SymbolicLinkNameLength);
                name[point->SymbolicLinkNameLength/sizeof(WCHAR)] = 0;
                if (SnapshotIsVolumeName(name)) 
                {
                    continue;
                }
            }
            if (point->DeviceNameLength) 
            {
                HANDLE hVolume;
                ULONG dwBytesReturned;
                PSTORAGE_DEVICE_NUMBER Number;
                DWORD IErrorMode;

                RtlCopyMemory(name,
                              (PCHAR) mountPoints + point->DeviceNameOffset,
                              point->DeviceNameLength);
                name[point->DeviceNameLength/sizeof(WCHAR)] = 0;

                RtlInitUnicodeString(&UnicodeName, name);
                UnicodeName.MaximumLength = MAXSTR;

                //
                // If the device name does not have the harddisk prefix
                // then it may be a floppy or cdrom and we want avoid 
                // calling NtCreateFile on them.
                //
                if(_wcsnicmp(name,L"\\device\\harddisk",16)) 
                {
                    continue;
                }

                InitializeObjectAttributes(
                        &ObjectAttributes,
                        &UnicodeName,
                        OBJ_CASE_INSENSITIVE,
                        NULL,
                        NULL );
                //
                // We do not want any pop up dialog here in case we are unable to 
                // access the volume. 
                //
                IErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS|SEM_NOOPENFILEERRORBOX);
                Status = NtCreateFile(
                        &hVolume,
                        GENERIC_READ | SYNCHRONIZE,
                        &ObjectAttributes,
                        &IoStatus,
                        NULL,
                        FILE_ATTRIBUTE_NORMAL,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_OPEN_IF,
                        FILE_SYNCHRONOUS_IO_NONALERT,
                        NULL, 0);
                SetErrorMode(IErrorMode);
                if (!NT_SUCCESS(Status)) 
                {
                    continue;
                }


                RtlZeroMemory(OutBuffer, MAXSTR);
                dwBytesReturned = 0;
                VolExt = (PVOLUME_DISK_EXTENTS) OutBuffer;

                Status = NtDeviceIoControlFile(hVolume,
                                0,
                                NULL,
                                NULL,
                                &IoStatus,
                                IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS,
                                NULL,
                                0,
                                OutBuffer, 
                                MAXSTR
                                );
               if (NT_SUCCESS(Status) ) 
               {
                    ULONG j;
                    ULONG NumberOfExtents = VolExt->NumberOfDiskExtents;
                    TCHAR tszTemp[NUM_OF_CHAR_IN_ULONG64];
                   
                    if(iDisk == -1 || iDisk != (&VolExt->Extents[0])->DiskNumber)
                    {
                        gXMLOutput->Write(XMLTAG_PartitionByDiskInfoType_Disk, (LPCWSTR)NULL);
                        _stnprintf(tszTemp, NUM_OF_CHAR_IN_ULONG64, TEXT("%d"), (&VolExt->Extents[0])->DiskNumber);
                        tszTemp[ _tsizeof(tszTemp) - 1 ] = 0;
                        gXMLOutput->Write(XMLTAG_PartitionByDiskInfoType_DiskID, (LPCTSTR)tszTemp);
                        iDisk = (&VolExt->Extents[0])->DiskNumber;
                        iPartition = 0;
                        gXMLOutput->Write(XMLTAG_PartitionByDiskInfoType_Partitions, (LPCWSTR)NULL);        
                    }
                    gXMLOutput->Write(XMLTAG_PartitionByDiskInfoType_PartitionInfo, (LPCWSTR)NULL);

                    _stnprintf(tszTemp, NUM_OF_CHAR_IN_ULONG64,
                            TEXT("%d"),
                            iPartition);
                    tszTemp[ _tsizeof(tszTemp) - 1 ] = 0;
                    gXMLOutput->Write(XMLTAG_PartitionInfoType_PartitionID, (LPCTSTR)tszTemp);
                    
                    gXMLOutput->Write(XMLTAG_PartitionInfoType_Extents, (LPCWSTR)NULL);
                    gXMLOutput->Write(XMLTAG_PartitionInfoType_ExtentInfo, (LPCWSTR)NULL);
                    for (j=0; j < NumberOfExtents; j++) 
                    {
                        DiskExt = &VolExt->Extents[j];
                        _stnprintf(tszTemp, NUM_OF_CHAR_IN_ULONG64,TEXT("%d"),j);
                        tszTemp[ _tsizeof(tszTemp) - 1 ] = 0;
                        gXMLOutput->Write(XMLTAG_ExtentInfoType_ID, tszTemp);
                        
                        _stnprintf(tszTemp, NUM_OF_CHAR_IN_ULONG64, TEXT("%I64d"),
                            DiskExt->StartingOffset.QuadPart);
                        tszTemp[ _tsizeof(tszTemp) - 1 ] = 0;
                        gXMLOutput->Write(XMLTAG_ExtentInfoType_StartingOffset, tszTemp);

                        _stnprintf(tszTemp, NUM_OF_CHAR_IN_ULONG64, TEXT("%I64d"), DiskExt->ExtentLength.QuadPart);
                        tszTemp[ _tsizeof(tszTemp) - 1 ] = 0;
                        gXMLOutput->Write(XMLTAG_ExtentInfoType_PartitionSize, tszTemp);
                    }
                    iPartition++;
                }
                NtClose(hVolume);
            }
        }
    }

error:
    NtClose(hDisk);

    if ( mountPoints )
        VirtualFree( mountPoints, 0, MEM_RELEASE );
}

void
LogHotfixes(
    HANDLE hFile
    )

/*++

Routine Description:

    This function will retrieve and log hotfixes.

Arguments:

    hFile - handle to the log file.

Return Value:

    none

--*/

{
    LPCWSTR        HotFixKey = L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Hotfix";
    LPCWSTR        wszValName = L"Installed";
    HANDLE        hKey, hSubkey;
    NTSTATUS    Status = STATUS_SUCCESS;
    UINT        i;
    DWORD        dwSize, dwVal, dwSubkeyIndex;
    WCHAR        szKey[MAX_PATH + 1];
    WCHAR        szSubkey[MAX_PATH + 1];


    Status = SnapshotRegOpenKey(HotFixKey, KEY_READ, &hKey);
    if (!NT_SUCCESS(Status) ) 
    {
        WriteToLogFile(hFile, TEXT("Hotfix registry key does not exist or open failed"));
        return;
    }

    dwSubkeyIndex = 0;
    dwSize = MAX_PATH * sizeof(WCHAR);
    Status = SnapshotRegEnumKey(hKey, dwSubkeyIndex, szSubkey, &dwSize);
    while(NT_SUCCESS(Status))
    {
        wcscpy(szKey, HotFixKey);
        wcscat(szKey, L"\\");
        wcscat(szKey, szSubkey);

        Status = SnapshotRegOpenKey(szKey, KEY_READ, &hSubkey);
        if(!NT_SUCCESS(Status))
        {
            NtClose(hKey);
            return;
        }

        dwSize = sizeof(DWORD);
        Status = SnapshotRegQueryValueKey(hSubkey, wszValName, dwSize, &dwVal, &dwSize);
        if(!NT_SUCCESS(Status))
        {
            NtClose(hKey);
            NtClose(hSubkey);
            WriteToLogFile(hFile, TEXT("Failed to query registry key value for hotfix info"));
            return;
        }

        _stnprintf(g_lpszBuffer, STR_BUFFER_SIZE,
                       TEXT("%s"), 
                       szSubkey);
        if(dwVal == 1)
        {
            gXMLOutput->Write(XMLTAG_OSInfoType_Hotfix, (LPCWSTR)NULL);
            WriteToLogFile(hFile, g_lpszBuffer);
        }

        NtClose(hSubkey);
        dwSubkeyIndex++;
        Status = SnapshotRegEnumKey(hKey, dwSubkeyIndex, szSubkey, &dwSize);
    }
    NtClose(hKey);
}

void
LogOsInfo(
    HANDLE hFile
    )

/*++

Routine Description:

    This function will retrieve and log OS infor.

Arguments:

    hFile - handle to the log file.

Return Value:

    none

--*/

{
    LPCWSTR        OsInfoKey = L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion";
    LPCWSTR        awszValName[] = 
    {
        //L"BuildLab",
        L"CurrentBuildNumber",
        L"CurrentType",
        L"CurrentVersion",
        //L"InstallDate",
        L"PathName",
        //L"ProductId",
        L"ProductName",
        //L"RegDone",
        //L"RegisteredOrgnization",
        //L"RegisteredOwner",
        L"SoftwareType",
        L"SourcePath",
        L"SystemRoot"
    };

    XMLTAG tags[] =
    {
        XMLTAG_OSInfoType_CurrentBuild,
        XMLTAG_OSInfoType_CurrentType,
        XMLTAG_OSInfoType_CurrentVersion,
        XMLTAG_OSInfoType_Path,
        XMLTAG_OSInfoType_ProductName,
        XMLTAG_OSInfoType_SoftwareType,
        XMLTAG_OSInfoType_SourcePath,
        XMLTAG_OSInfoType_SystemRoot
    };

    UINT        uVals = sizeof(awszValName) / sizeof(LPCWSTR);
    HANDLE        hKey;
    NTSTATUS    Status = STATUS_SUCCESS;
    UINT        i;
    WCHAR        wszVal[MAX_PATH + 1];
    DWORD        dwSize;
    SYSTEM_KERNEL_DEBUGGER_INFORMATION KdInfo = { 0 };

    Status = SnapshotRegOpenKey(OsInfoKey, KEY_READ, &hKey);
    if (!NT_SUCCESS(Status) ) 
    {
        WriteToLogFile(hFile, TEXT("Failed to open registry key for os version info"));
        return;
    }

    for(i = 0; i < uVals; i++)
    {
        dwSize = MAX_PATH * sizeof(WCHAR);
        Status = SnapshotRegQueryValueKey(hKey, awszValName[i], dwSize, wszVal, &dwSize);
        if(!NT_SUCCESS(Status))
        {
            continue;
        }

        gXMLOutput->Write(tags[i], (LPCWSTR)NULL);

        WriteToLogFileW(hFile, wszVal);
    }
    NtClose(hKey);

    Status = NtQuerySystemInformation(
            SystemKernelDebuggerInformation,
            &KdInfo,
            sizeof(KdInfo),
            NULL);

    if ((NT_SUCCESS(Status)) && KdInfo.KernelDebuggerEnabled)
    {
        _stprintf(g_lpszBuffer, TEXT("YES"));
    }
    else
    {
        _stprintf(g_lpszBuffer, TEXT("NO"));
    }
    gXMLOutput->Write(XMLTAG_OSInfoType_DebuggerEnabled, (LPCTSTR)g_lpszBuffer);
        
}

void
LogBIOSInfo(
    HANDLE hFile
    )

/*++

Routine Description:

    This function will retrieve and log the system BIOS info.

Arguments:

    hFile - handle to the log file.

Return Value:

    none

--*/

{
    LPCWSTR        BiosInfoKey = L"\\Registry\\Machine\\Hardware\\Description\\System";
    LPCWSTR        awszValName[] = 
    {
        L"Identifier",
        L"SystemBiosDate",
        L"SystemBiosVersion",
        L"VideoBiosDate",
        L"VideoBiosVersion"
    };
    XMLTAG        tags[] =
    {
        XMLTAG_BiosInfoType_Identifier,
        XMLTAG_BiosInfoType_SystemBiosDate,
        XMLTAG_BiosInfoType_SystemBiosVersion,
        XMLTAG_BiosInfoType_VideoBiosDate,
        XMLTAG_BiosInfoType_VideoBiosVersion
    };

    UINT        uVals = sizeof(awszValName) / sizeof(LPCWSTR);
    HANDLE        hKey;
    NTSTATUS    Status = STATUS_SUCCESS;
    UINT        i;
    WCHAR        wszVal[MAX_PATH + 1];
    LPWSTR        pwsz;
    DWORD        dwSize, dwLen;

    gXMLOutput->Write(XMLTAG_HardwareInfoType_BiosInfo, (LPCWSTR)NULL);

    Status = SnapshotRegOpenKey(BiosInfoKey, KEY_READ, &hKey);
    if (!NT_SUCCESS(Status) ) 
    {
        WriteToLogFile(hFile, TEXT("Failed to open registry key for BIOS info"));
        return;
    }
    //WriteToLogFile(hFile, TEXT("BIOS Info:\n"));

    for(i = 0; i < uVals; i++)
    {
        dwSize = MAX_PATH * sizeof(WCHAR);

        Status = SnapshotRegQueryValueKey(hKey, awszValName[i], dwSize, wszVal, &dwSize);
        if(!NT_SUCCESS(Status))
        {
            continue;
        }
        gXMLOutput->Write(tags[i], (LPCWSTR)NULL);

        dwLen = 0;
        pwsz = wszVal;
        while(dwLen + 1< dwSize / sizeof(WCHAR))
        {
            WriteToLogFileW(hFile, pwsz);
            dwLen += wcslen(pwsz) + 1;
            pwsz += wcslen(pwsz) + 1;
        }
    }
    NtClose(hKey);
}

void
DeleteOldFiles(
   LPCTSTR lpPath
   )

/*++

Routine Description:

    This function delete the old log files. The time is in number of days.
    We will first check the registry, if user has a specifid number of days,
    it will be used, else the default will be used.

Arguments:

    lpPath - the directory where snapshot are logged.

Return Value:

    none

--*/

{
    LPCWSTR                lpValName = L"SnapshotHistoryFiles";
    HANDLE                hKey, hFile;
    NTSTATUS            Status = STATUS_SUCCESS;
    DWORD                dwSize, dwVal;
    TCHAR                szFileName[MAX_PATH + 1];
    WIN32_FIND_DATA        winData;
    BOOL                bFound = TRUE;
    SYSTEMTIME            systime;
    FILETIME            filetime;
    __int64                i64Filetime, i64Filetime1;

    GetSystemTime(&systime);
    SystemTimeToFileTime(&systime, &filetime);
    i64Filetime = (__int64)filetime.dwHighDateTime;
    i64Filetime <<= 32;
    i64Filetime |= (__int64)filetime.dwLowDateTime;

    Status = SnapshotRegOpenKey(ReliabilityKey, KEY_ALL_ACCESS, &hKey);
    if (NT_SUCCESS(Status))
    {
        dwSize = sizeof(DWORD);
        Status = SnapshotRegQueryValueKey(hKey, lpValName, dwSize, &dwVal, &dwSize);
        if(!NT_SUCCESS(Status))
        {
            dwVal = DEFAULT_HISTORYFILES;
        }
        else if (dwVal > MAX_HISTORYFILES)
        {
            dwVal = MAX_HISTORYFILES;
        }

        NtClose(hKey);
    }
    else 
    {
        dwVal = DEFAULT_HISTORYFILES;
    }
    
    //
    //  make sure buffer won't overflow.
    //  32: shutdown_YYYYMMDDHHMMSS.xml
    //
    if ( wcslen( lpPath ) > _tsizeof(szFileName) - 32 )
        return;

    lstrcpy(szFileName, lpPath);
    lstrcat(szFileName, TEXT("\\ShutDown_*"));

    hFile = FindFirstFile(szFileName, &winData);
    while(hFile != INVALID_HANDLE_VALUE && bFound)
    {
        i64Filetime1 = (__int64)winData.ftCreationTime.dwHighDateTime;
        i64Filetime1 <<= 32;
        i64Filetime1 |= (__int64)winData.ftCreationTime.dwLowDateTime;

        if(i64Filetime - i64Filetime1 >= (const __int64)24*60*60*10000000 * dwVal)
        {
            lstrcpy(szFileName, lpPath);
            lstrcat(szFileName, TEXT("\\"));
            lstrcat(szFileName,winData.cFileName);
            DeleteFile(szFileName);
        }
        bFound = FindNextFile(hFile, &winData);
    }

    if(hFile != INVALID_HANDLE_VALUE)
    {
        FindClose(hFile);
    }
}

#if 0
//
//  Removing Extension DLL function
//

//
//    Each extension DLL must implment and export the following function.
//
typedef BOOL (* EXTENSIONDLLPROC)(LPWSTR , LPDWORD);

void
LoadExtensionDlls(
    HANDLE hFile)

/*++

Routine Description:

    This function will load all extension dlls. All extension dlls
    are reg val keys under the ExtensionDlls key (which is under the 
    reliability key). The values are all DWORD, 0 means dont load, 
    any other value means load.

Arguments:

    hFile - Handle to the file to write to.

Return Value:

    none

--*/

{
    LPCWSTR                lpKeyName = L"ExtensionDlls";
    LPCSTR                szProcName = "GetSnapShotInfo";
    HANDLE                hKey;
    NTSTATUS            Status = STATUS_SUCCESS;
    DWORD                dwSize, dwVal;
    WCHAR                szSysdir[MAX_PATH + 1];
    WCHAR                szDll[MAX_PATH + 1];
    WCHAR               szPath[MAX_PATH + 1];
    LPTSTR              szTempFileName;
    

    _stnprintf(g_lpszBuffer, STR_BUFFER_SIZE,
            TEXT("%s\\%s"),
            ReliabilityKey,
            lpKeyName
            );
    g_lpszBuffer[ _tsizeof(g_lpszBuffer) - 1 ] = 0;

    GetSystemDirectory(szSysdir, MAX_PATH); 

    Status = SnapshotRegOpenKey(g_lpszBuffer, KEY_ALL_ACCESS, &hKey);
    if (NT_SUCCESS(Status))
    {
        ULONG        index = 0;
        ULONG        resultlen;
        DWORD        dwVal;
        PKEY_VALUE_FULL_INFORMATION pv = (PKEY_VALUE_FULL_INFORMATION)g_lpszBuffer;
        HMODULE        hExtDll = NULL;
        EXTENSIONDLLPROC pnExtproc = NULL;
        LPWSTR        psz = NULL;
        
        psz = (LPWSTR)LocalAlloc(LMEM_FIXED, BUFFER_SIZE);
        if(!psz)
        {
            NtClose(hKey);
            return;
        }

        while(1)
        {
            Status = NtEnumerateValueKey(
                    hKey,
                    index,
                    KeyValueFullInformation,
                    pv,
                    (ULONG)STR_BUFFER_SIZE - 1,
                    &resultlen
                );
            index++;

            //
            //    If we cannot hold in a 64k buffer, forget about it.
            //
            if(Status == STATUS_BUFFER_OVERFLOW)
                continue;
            
            if(Status == STATUS_NO_MORE_ENTRIES)
                break;

            //
            //    Type must be DWORD and name cannot be longer than MAXSTR/2.
            //
            if(pv->Type != REG_DWORD || pv->NameLength >= MAXSTR/2)
                continue;

            //
            //    Now we get one. Check val, if 0 skip.
            //
            dwVal = *((DWORD*)((LPBYTE)pv + pv->DataOffset));
            if(dwVal == 0)
                continue;

            wcscpy(szDll, szSysdir);
            wcscat(szDll, L"\\");
            wcsncat(szDll, pv->Name, pv->NameLength/sizeof(WCHAR));
            szDll[wcslen(szSysdir) + pv->NameLength/sizeof(WCHAR) + 1] = L'\0';

            //
            // Now check to make sure the dll we load is still in the
            // system directory.
            //
            if ( GetFullPathName( szDll, MAX_PATH, szPath, &szTempFileName ) )
            {
                szPath[ wcslen( szSysdir ) ] = 0;

                if ( _tcschr( &szPath[ wcslen(szSysdir ) + 1 ], TEXT('\\') ) ||
                    _tcsicmp( szPath, szSysdir ) )
                {
                    gXMLOutput->Write(XMLTAG_SETDataType_ExtensionDLL, (LPCWSTR)NULL);
                    _snwprintf(g_lpszBuffer, 
                               STR_BUFFER_SIZE, 
                               TEXT("Invalid extension dll: '%s'\n"), 
                               szDll);
                    WriteToLogFileW(hFile, g_lpszBuffer);

                    continue;
                }
            }
            else
            {
                continue;
            }

            hExtDll = LoadLibraryW(szDll);
            if(hExtDll)
            {
                pnExtproc = (EXTENSIONDLLPROC)GetProcAddress(hExtDll, szProcName);
                if(pnExtproc)
                {
                    DWORD len = BUFFER_SIZE / sizeof(WCHAR);
                    if((*pnExtproc)(psz, &len))
                    {
                        gXMLOutput->Write(XMLTAG_SETDataType_ExtensionDLL, (LPCWSTR)NULL);
                        psz[BUFFER_SIZE /sizeof(WCHAR)] = L'\0';
                        WriteToLogFileW(hFile, (LPCWSTR)psz);
                    }
                    pnExtproc = NULL;
                }
                FreeLibrary(hExtDll);
                hExtDll = NULL;
            }
            else
            {
                gXMLOutput->Write(XMLTAG_SETDataType_ExtensionDLL, (LPCWSTR)NULL);
                _snwprintf(g_lpszBuffer, 
                           STR_BUFFER_SIZE, 
                           TEXT("Load extension dll: '%s' failed\n"), 
                           szDll);
                WriteToLogFileW(hFile, g_lpszBuffer);
            }
        }
        LocalFree(psz);
        NtClose(hKey);
    }
}

#endif

BOOL
SnapshotFindModule(
    IN HANDLE hProcess,
    IN HMODULE hModule,
    OUT PLDR_DATA_TABLE_ENTRY LdrEntryData
    )

/*++

Routine Description:

    This function retrieves the loader table entry for the specified
    module.  The function copies the entry into the buffer pointed to
    by the LdrEntryData parameter.

Arguments:

    hProcess - Supplies the target process.

    hModule - Identifies the module whose loader entry is being
        requested.  A value of NULL references the module handle
        associated with the image file that was used to create the
        process.

    LdrEntryData - Returns the requested table entry.

Return Value:

    TRUE if a matching entry was found.

--*/

{
    PROCESS_BASIC_INFORMATION BasicInfo;
    NTSTATUS        Status;
    PPEB            Peb;
    PPEB_LDR_DATA    Ldr;
    PLIST_ENTRY        LdrHead;
    PLIST_ENTRY        LdrNext;

    Status = NtQueryInformationProcess(
                hProcess,
                ProcessBasicInformation,
                &BasicInfo,
                sizeof(BasicInfo),
                NULL
                );

    if ( !NT_SUCCESS(Status) ) {
        SetLastError( RtlNtStatusToDosError( Status ) );
        return(FALSE);
    }

    Peb = BasicInfo.PebBaseAddress;


    if ( !ARGUMENT_PRESENT( hModule )) {
        if (!ReadProcessMemory(hProcess, &Peb->ImageBaseAddress, &hModule, sizeof(hModule), NULL)) {
            return(FALSE);
        }
    }

    //
    // Ldr = Peb->Ldr
    //

    if (!ReadProcessMemory(hProcess, &Peb->Ldr, &Ldr, sizeof(Ldr), NULL)) {
        return (FALSE);
    }

    if (!Ldr) {
        // Ldr might be null (for instance, if the process hasn't started yet).
        SetLastError(ERROR_INVALID_HANDLE);
        return (FALSE);
    }


    LdrHead = &Ldr->InMemoryOrderModuleList;

    //
    // LdrNext = Head->Flink;
    //

    if (!ReadProcessMemory(hProcess, &LdrHead->Flink, &LdrNext, sizeof(LdrNext), NULL)) {
        return(FALSE);
    }

    while (LdrNext != LdrHead) {
        PLDR_DATA_TABLE_ENTRY LdrEntry;

        LdrEntry = CONTAINING_RECORD(LdrNext, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks);

        if (!ReadProcessMemory(hProcess, LdrEntry, LdrEntryData, sizeof(*LdrEntryData), NULL)) {
            return(FALSE);
        }

        if ((HMODULE) LdrEntryData->DllBase == hModule) {
            return(TRUE);
        }

        LdrNext = LdrEntryData->InMemoryOrderLinks.Flink;
    }

    SetLastError(ERROR_INVALID_HANDLE);
    return(FALSE);
}


BOOL
WINAPI
SnapshotEnumProcessModules(
    HANDLE hProcess,
    HMODULE *lphModule,
    DWORD cb,
    LPDWORD lpcbNeeded
    )

/*++

Routine Description:

    This function Enums all of the modules in the given process.

Arguments:

    hProcess - Identifies process for which to enum modules.

    lphModule - Points to the buffer that is to receive the Module handles.

    cb - size of the buffer in bytes.

    lpcbNeeded - if buffer if not enough, give the needed size in bytes.

Return Value:

    TRUE on success, FALSE on failure.

--*/

{
    PROCESS_BASIC_INFORMATION BasicInfo;
    NTSTATUS        Status;
    PPEB            Peb;
    PPEB_LDR_DATA    Ldr;
    PLIST_ENTRY        LdrHead;
    PLIST_ENTRY        LdrNext;
    DWORD            chMax;
    DWORD            ch;

    Status = NtQueryInformationProcess(
                hProcess,
                ProcessBasicInformation,
                &BasicInfo,
                sizeof(BasicInfo),
                NULL
                );

    if ( !NT_SUCCESS(Status) ) 
    {
        SetLastError( RtlNtStatusToDosError( Status ) );
        return(FALSE); 
    }

    Peb = BasicInfo.PebBaseAddress;

    //
    // Ldr = Peb->Ldr
    //

    if (!ReadProcessMemory(hProcess, &Peb->Ldr, &Ldr, sizeof(Ldr), NULL))
    {
        return(FALSE);
    }

    LdrHead = &Ldr->InMemoryOrderModuleList;

    //
    // LdrNext = Head->Flink;
    //

    if (!ReadProcessMemory(hProcess, &LdrHead->Flink, &LdrNext, sizeof(LdrNext), NULL)) 
    {
        return(FALSE);
    }

    chMax = cb / sizeof(HMODULE);
    ch = 0;

    while (LdrNext != LdrHead) 
    {
        PLDR_DATA_TABLE_ENTRY LdrEntry;
        LDR_DATA_TABLE_ENTRY LdrEntryData;

        LdrEntry = CONTAINING_RECORD(LdrNext, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks);

        if (!ReadProcessMemory(hProcess, LdrEntry, &LdrEntryData, sizeof(LdrEntryData), NULL)) 
        {
            return(FALSE);
        }

        if (ch < chMax) 
        {
            __try 
            {
                   lphModule[ch] = (HMODULE) LdrEntryData.DllBase;
            }
            __except (EXCEPTION_EXECUTE_HANDLER) 
            {
                SetLastError( RtlNtStatusToDosError( GetExceptionCode() ) );
                return(FALSE);
            }
        }

        ch++;

        LdrNext = LdrEntryData.InMemoryOrderLinks.Flink;
    }

    __try 
    {
        *lpcbNeeded = ch * sizeof(HMODULE);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) 
    {
        SetLastError( RtlNtStatusToDosError( GetExceptionCode() ) );
        return(FALSE);
    }

    return(TRUE);
}


DWORD
WINAPI
SnapshotGetModuleFileNameExW(
    HANDLE hProcess,
    HMODULE hModule,
    LPWSTR lpFilename,
    DWORD nSize
    )

/*++

Routine Description:

    This function retrieves the full pathname of the executable file
    from which the specified module was loaded.  The function copies the
    null-terminated filename into the buffer pointed to by the
    lpFilename parameter.

Arguments:

    hModule - Identifies the module whose executable file name is being
        requested.  A value of NULL references the module handle
        associated with the image file that was used to create the
        process.

    lpFilename - Points to the buffer that is to receive the filename.

    nSize - Specifies the maximum number of characters to copy.  If the
        filename is longer than the maximum number of characters
        specified by the nSize parameter, it is truncated.

Return Value:

    The return value specifies the actual length of the string copied to
    the buffer.  A return value of zero indicates an error and extended
    error status is available using the GetLastError function.

--*/

{
    LDR_DATA_TABLE_ENTRY LdrEntryData;
    DWORD cb;

    if (!SnapshotFindModule(hProcess, hModule, &LdrEntryData)) 
    {
        return(0);
    }

    nSize *= sizeof(WCHAR);

    cb = LdrEntryData.FullDllName.Length + sizeof (WCHAR);
    if ( nSize < cb ) 
    {
        cb = nSize;
    }

    if (!ReadProcessMemory(hProcess, LdrEntryData.FullDllName.Buffer, lpFilename, cb, NULL)) 
    {
        return(0);
    }

    if (cb == LdrEntryData.FullDllName.Length + sizeof (WCHAR)) 
    {
        cb -= sizeof(WCHAR);
    }

    return(cb / sizeof(WCHAR));
}


DWORD
WINAPI
SnapshotGetModuleBaseNameW(
    HANDLE hProcess,
    HMODULE hModule,
    LPWSTR lpFilename,
    DWORD nSize
    )

/*++

Routine Description:

    This function retrieves base name of the executable file
    from which the specified module was loaded.  The function copies the
    null-terminated filename into the buffer pointed to by the
    lpFilename parameter.

Arguments:

    hModule - Identifies the module whose executable file name is being
        requested.  A value of NULL references the module handle
        associated with the image file that was used to create the
        process.

    lpFilename - Points to the buffer that is to receive the filename.

    nSize - Specifies the maximum number of characters to copy.  If the
        filename is longer than the maximum number of characters
        specified by the nSize parameter, it is truncated.

Return Value:

    The number of WCHARs in lpFilename.

--*/
{
    LDR_DATA_TABLE_ENTRY LdrEntryData;
    DWORD cb;

    if (!SnapshotFindModule(hProcess, hModule, &LdrEntryData)) 
    {
        return(0); 
    }

    nSize *= sizeof(WCHAR);

    cb = LdrEntryData.BaseDllName.Length + sizeof (WCHAR);
    if ( nSize < cb ) 
    {
        cb = nSize;
    }

    if (!ReadProcessMemory(hProcess, LdrEntryData.BaseDllName.Buffer, lpFilename, cb, NULL)) 
    {
        return(0); 
    }

    if (cb == LdrEntryData.BaseDllName.Length + sizeof (WCHAR)) 
    {
        cb -= sizeof(WCHAR);
    }

    return(cb / sizeof(WCHAR));
}



BOOL
WINAPI
SnapshotGetModuleInformation(
    HANDLE hProcess,
    HMODULE hModule,
    LPMODULEINFO lpmodinfo,
    DWORD cb
    )
/*++

Routine Description:

    This function gets the module information given a module handle and its
    process handle.

Arguments:

    hProcess - Supplies the target process.

    hModule - Identifies the module whose information will be retrieved.

    lpmodinfo - Holds module infor on return.

    cb - size of the buffer in bytes.

Return Value:

    TRUE on success.
    FALSES on failure.

--*/
{
    LDR_DATA_TABLE_ENTRY LdrEntryData;
    MODULEINFO modinfo;

    if (cb < sizeof(MODULEINFO)) 
    {
        SetLastError( ERROR_INSUFFICIENT_BUFFER );
        return(FALSE);
    }

    if (!SnapshotFindModule(hProcess, hModule, &LdrEntryData)) 
    {
        return(0);
    }

    modinfo.lpBaseOfDll = (PVOID) hModule;
    modinfo.SizeOfImage = LdrEntryData.SizeOfImage;
    modinfo.EntryPoint  = LdrEntryData.EntryPoint;

    __try 
    {
        *lpmodinfo = modinfo;
    }
    __except (EXCEPTION_EXECUTE_HANDLER) 
    {
        SetLastError( RtlNtStatusToDosError( GetExceptionCode() ) );
        return(FALSE);
    }

    return(TRUE);
}

WCHAR  g_pszWriteBuffer[ MAX_PATH + 1 ];

void 
WriteToLogFileW(
    HANDLE hFile,
    LPCWSTR lpwszInput
    )

/*++

Routine Description:

    This function will write a unicode string to the file.

Arguments:

    hFile - handle to the log file.

    lpwszInput - the string to write.

Return Value:

    none.

--*/

{
    DWORD    dwWriten        = 0;
    BYTE    *bBuffer        = NULL;
    BYTE    *bConvertBuffer = NULL;
    int        nLen, nRetLen;

    nLen = wcslen(lpwszInput);

    if ( nLen > (sizeof(g_pszWriteBuffer)/sizeof(WCHAR) - 1) )
    {
        if ( !(bBuffer = (BYTE*)malloc((nLen + 1) * sizeof(WCHAR)) ) )
            return;
    
        bConvertBuffer = bBuffer;
        nLen = (nLen + 1) * sizeof(WCHAR);
    }
    else
    {
        bConvertBuffer = (BYTE*) g_pszWriteBuffer;
        nLen = sizeof(g_pszWriteBuffer);
    }

    nRetLen = WideCharToMultiByte(CP_UTF8, 0, lpwszInput, -1, (LPSTR)bConvertBuffer, nLen, NULL, NULL);
    if(nRetLen != 0)
    {
        WriteFile(hFile, (LPVOID)bConvertBuffer, nRetLen-1, &dwWriten, NULL);
    }
    else
    {
        //
        // if WideCharToMultiByte failed, we will double the allocation size
        //
        BYTE    *bNewBuffer = NULL;

        nLen = wcslen(lpwszInput) * sizeof(WCHAR) * 2 + 1;

        if ( (bNewBuffer = (BYTE*)malloc( nLen ) ) )
        {
            nRetLen = WideCharToMultiByte(CP_UTF8, 0, lpwszInput, -1, (LPSTR)bNewBuffer, nLen, NULL, NULL);

            if (nRetLen != 0 )
                WriteFile(hFile, (LPVOID)bNewBuffer, nRetLen-1, &dwWriten, NULL);

            free(bNewBuffer);
        }
    }

    if ( bBuffer )
        free(bBuffer);
}

void 
WriteToLogFileA(
    HANDLE hFile,
    LPCSTR lpszInput
    )

/*++

Routine Description:

    This function will write a ansi string to the file.

Arguments:

    hFile - handle to the log file.

    lpwszInput - the string to write.

Return Value:

    none.

--*/

{
    DWORD dwWriten;
    WriteFile(hFile, (LPVOID)lpszInput, strlen(lpszInput), &dwWriten, NULL);
}


void 
WriteToLogFile(
    HANDLE hFile,
    LPCTSTR lpszInput
    )
{
#ifdef _UNICODE
    WriteToLogFileW(hFile, lpszInput);
#else
    WriteToLogFileA(hFile, lpszInput);
#endif //_UNICODE
}

BOOL
AdjustAccess(
    LPCWSTR lpszDir
    )

/*++

Routine Description:

    This function will ajust access to the log file dir.
    We will give System and Admins full rights.

Arguments:

    lpszDir - path to the log files.

Return Value:

    TRUE on success, FALSE on failure.

--*/

{
    PACL    pAcl=NULL;
    DWORD    dwStatus = ERROR_SUCCESS;
    PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL;
    DWORD    dwSDLen = 0;

    DWORD    cbAcl = 0;
    PSID    pSidSystem = NULL;
    PSID    pSidAdmin = NULL;
    DWORD    dwSidSystemLen = 0;
    DWORD    dwSidAdminLen = 0;
    SID_NAME_USE    snu;

    pSecurityDescriptor = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, sizeof(SECURITY_DESCRIPTOR));
    if( NULL == pSecurityDescriptor )
    {
        dwStatus = GetLastError();
        goto CLEANUPANDEXIT;
    }

    //
    //  Initialize the security descriptor.
    //
    if (!InitializeSecurityDescriptor(
                    pSecurityDescriptor,
                    SECURITY_DESCRIPTOR_REVISION
                    )) 
    {
        dwStatus = GetLastError();
        goto CLEANUPANDEXIT;
    }

    {
        NTSTATUS Status;
        SID_IDENTIFIER_AUTHORITY SidAuthority = SECURITY_NT_AUTHORITY;

        Status = RtlAllocateAndInitializeSid(
                &SidAuthority,
                1,
                SECURITY_LOCAL_SYSTEM_RID,
                0, 0, 0, 0, 0, 0, 0,
                &pSidSystem
                );

        if (!NT_SUCCESS(Status))
        {
            SetLastError(RtlNtStatusToDosError(Status));
            dwStatus = GetLastError();
            goto CLEANUPANDEXIT;
        }

        Status = RtlAllocateAndInitializeSid(
                &SidAuthority,
                2,
                SECURITY_BUILTIN_DOMAIN_RID,
                DOMAIN_ALIAS_RID_ADMINS,
                0, 0, 0, 0, 0, 0,
                &pSidAdmin
                );

        if (!NT_SUCCESS(Status))
        {
            SetLastError(RtlNtStatusToDosError(Status));
            dwStatus = GetLastError();
            goto CLEANUPANDEXIT;
        }
    }

    cbAcl = GetLengthSid(pSidSystem) + GetLengthSid(pSidAdmin) + sizeof(ACL) + (3 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)));
    pAcl = (PACL) LocalAlloc( LPTR, cbAcl );
    if( NULL == pAcl )
    {
        dwStatus = GetLastError();
        goto CLEANUPANDEXIT;
    }

    //
    //  Initialize the ACL.
    //
    if (!InitializeAcl(pAcl, cbAcl, ACL_REVISION)) 
    {
        dwStatus = GetLastError();
        goto CLEANUPANDEXIT;
    }

    if (!AddAccessAllowedAceEx(pAcl,
                        ACL_REVISION,
                        OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE,
                        GENERIC_READ | GENERIC_WRITE | GENERIC_ALL,
                        pSidSystem
                        )) 
    {
        dwStatus = GetLastError();
        goto CLEANUPANDEXIT;
    }

    if (!AddAccessAllowedAceEx(pAcl,
                        ACL_REVISION,
                        OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE,
                        GENERIC_READ | GENERIC_WRITE | GENERIC_ALL,
                        pSidAdmin
                        )) 
    {
        dwStatus = GetLastError();
        goto CLEANUPANDEXIT;
    }

    if (!SetSecurityDescriptorDacl(pSecurityDescriptor,
                                  TRUE, pAcl, FALSE)) 
    {
        dwStatus = GetLastError();
        goto CLEANUPANDEXIT;
    }   

    if(!SetFileSecurityW(lpszDir, DACL_SECURITY_INFORMATION, pSecurityDescriptor))
    {
        dwStatus = GetLastError();
        goto CLEANUPANDEXIT;
    } 

CLEANUPANDEXIT:
    if(pAcl != NULL)
    {
        LocalFree(pAcl);
    }

    if( pSecurityDescriptor != NULL )
    {
        LocalFree( pSecurityDescriptor );
    }

    if( pSidSystem != NULL )
    {
        FreeSid( pSidSystem );
    }

    if( pSidAdmin != NULL )
    {
        FreeSid( pSidAdmin );
    }
    
    return dwStatus == ERROR_SUCCESS;
}

DWORD WINAPI
GetTimeOut(
    void* pv
    )
/*++

Routine Description:

    Thread proc to get timeout from registry.

Arguments:

    pv - thread param.

Return Value:

    0 if success, non-zero if fail.

--*/
{
    LPCWSTR TimeOutVal = L"SnapshotTimeout";
    HANDLE  hKey;
    DWORD    dwSize;
    NTSTATUS Status = STATUS_SUCCESS;

    Status = SnapshotRegOpenKey(ReliabilityKey, KEY_READ, &hKey);
    if(!NT_SUCCESS(Status))
    {
        SetLastError( RtlNtStatusToDosError( Status ) );
        return GetLastError();
    }
    dwSize = sizeof(DWORD);
    Status = SnapshotRegQueryValueKey(hKey, TimeOutVal, dwSize, pv, &dwSize);

    if(!NT_SUCCESS(Status))
    {
        SetLastError( RtlNtStatusToDosError( Status ) );
        NtClose(hKey);
        return GetLastError();
    }
    NtClose(hKey);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\srcsrv\copystr.cpp ===
#define COPYSTR_MOD
#include <copystr.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\symchk\com\checksymbols.h ===
// CheckSymbols.h : Declaration of the CCheckSymbols

#ifndef __CHECKSYMBOLS_H_
#define __CHECKSYMBOLS_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CCheckSymbols
class ATL_NO_VTABLE CCheckSymbols : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CCheckSymbols, &CLSID_CheckSymbols>,
	public IDispatchImpl<ICheckSymbols, &IID_ICheckSymbols, &LIBID_CHECKSYMBOLSLIBLib>
{
public:
	CCheckSymbols()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_CHECKSYMBOLS)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CCheckSymbols)
	COM_INTERFACE_ENTRY(ICheckSymbols)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// ICheckSymbols
public:
	STDMETHOD(CheckSymbols)(/*[in]*/ BSTR FilePath, /*[in]*/ BSTR SymPath, /*[in]*/ BSTR StripSym, /*[out, retval]*/ BSTR *OutputString);
	
};

#endif //__CHECKSYMBOLS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\symchk\com\checksymbols.cpp ===
// CheckSymbols.cpp : Implementation of CCheckSymbols
#include "stdafx.h"
#include "CheckSymbolsLib.h"
#include "CheckSymbols.h"
#include "..\symutil.h"


/////////////////////////////////////////////////////////////////////////////
// CCheckSymbols


STDMETHODIMP CCheckSymbols::CheckSymbols(BSTR FilePath, BSTR SymPath, BSTR StripSym, BSTR *OutputString)
{
	// TODO: Add your implementation code here

/*	ATL release builds has a macro defined that prevents crt functions from being 
	included. If you need to call any c runtime functions you'll need to remove the macro 
	_ATL_MIN_CRT first.

*/

    TCHAR MyOutputString[MAX_SYM_ERR];
    TCHAR MySymPath[_MAX_PATH];
    TCHAR MyFilePath[_MAX_PATH]; 

    CComBSTR bstrFilePath = FilePath;
    CComBSTR bstrSymPath = SymPath;
    CComBSTR bstrStripSym = StripSym;
    CComBSTR bstrOutputString;

    USES_CONVERSION;

    //Make sure buffer is big enough. CComBSTR.Length() doesn't include terminating NULL.
    if (bstrFilePath.Length() >= _MAX_PATH)
    {
        //Path too long...
        Error("The specified file path is too long");
        return E_FAIL;
    }
    
    if (bstrSymPath.Length() >= _MAX_PATH)
    {
        //Path too long...
        Error("The specified symbol path is too long");
        return E_FAIL;
    }

    //Might want to validate StripSym parameter here...


    lstrcpyn(MyFilePath, OLE2T(bstrFilePath), bstrFilePath.Length() + 1);
    lstrcpyn(MySymPath, OLE2T(bstrSymPath), bstrSymPath.Length() + 1);


    // Input values:
    //    MySymPath    Full path to directory where symbols are located
    //    MyFilePath   Full path and name of file to verify symbols for.
    //
    // Return values:
    //    MyOutputString=  empty string =>  Symbol checking passed.
    //    MyOutputString!= empty string =>  Symbol checking failed.  String has the binary name
    //                                      followed by spaces, and then the text reason.

    MyCheckSymbols( MyOutputString, MySymPath, MyFilePath, NULL, 0, 0 );


    bstrOutputString = T2OLE(MyOutputString);
    *OutputString = bstrOutputString.Copy();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\symchk\msvcrtp.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    msvcrtp.c

Abstract:

    This module implements vector new and delete so that
    dbghelp will run on systems with old copies of msvcrt.dll

Author:

    Pat Styles (patst) 09-November-2000

Revision History:

--*/

#ifdef _X86_
              
// these two exist so that we can work with old
// versions of msvcrt.dll that ships in NT4, SP6 and earlier

void __cdecl operator delete[](void * p)
{
    operator delete( p );
}

void * __cdecl operator new[]( size_t cb )
{
    void *res = operator new(cb);
    return res;
}

#endif // #ifdef _X86_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\symchk\symutil_c.h ===
// Typedefs

BOOL 
PDBPrivateStripped(
    PDB *ppdb,
    DBI *pdbi
);

BOOL 
PDBTypesStripped(
    PDB *ppdb,
    DBI *pdbi
);

BOOL
PDBLinesStripped(
    PDB *ppdb,
    DBI *pdbi
);

BOOL 
DBGPrivateStripped(
    PCHAR DebugData,
    ULONG DebugSize
);

PIMAGE_SEPARATE_DEBUG_HEADER
MapDbgHeader (
    LPTSTR szFileName,
    PHANDLE phFile
);


BOOL
UnmapFile(
    LPCVOID phFileMap,
    HANDLE hFile
);

IMAGE_DEBUG_DIRECTORY UNALIGNED *
GetDebugDirectoryInDbg(
    PIMAGE_SEPARATE_DEBUG_HEADER pDbgHeader,
    ULONG *NumberOfDebugDirectories
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\symchk\symutil_c.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>

#include <assert.h>
#define PDB_LIBRARY
#include "pdb.h"
#include "dbghelp.h"
#include "cvinfo.h"
#include "cvexefmt.h"
#include "share.h"
#include "winbase.h"

#include "symutil_c.h"


BOOL PDBPrivateStripped(PDB *ppdb,
                        DBI *pdbi
                       )
{
AGE age;
BOOL PrivateStripped;
GSI *pgsi;
BOOL valid;

    age = pdbi->QueryAge();

    if (age == 0) {

        // If the age is 0, then check for types to determine if this is
        // a private pdb or not.  PDB 5.0 and earlier may have types and no
        // globals if the age is 0.

        PrivateStripped= PDBTypesStripped(ppdb, pdbi) &&
                         PDBLinesStripped(ppdb, pdbi);

    } else {
        // Otherwise, use globals to determine if the private info is
        // stripped or not.  No globals means that private is stripped.

        __try
        {
            valid = pdbi->OpenGlobals(&pgsi);
        }
        __except( EXCEPTION_EXECUTE_HANDLER )
        {
            valid= FALSE;
        }

        if ( !valid ) {
            return FALSE;
        }

        // Now, see if there are any globals in the pdb.

        valid=TRUE;
        __try
        {
            PrivateStripped= ((pgsi->NextSym(NULL)) == NULL);
        }
        __except( EXCEPTION_EXECUTE_HANDLER )
        {
            valid= FALSE;
        }

        GSIClose(pgsi);
        if ( !valid ) {
            return FALSE;
        }
    }
    return (PrivateStripped);
}


BOOL PDBLinesStripped(
                       PDB *ppdb,
                       DBI *pdbi
                       )
{
    // Return values:
    // FALSE - Private Information has NOT been stripped
    // TRUE - Private Information has been stripped

    Mod *pmod;
    Mod *prevmod;
    long cb;

    pmod = NULL;
    prevmod=NULL;
    while (DBIQueryNextMod(pdbi, pmod, &pmod) && pmod) {
        if (prevmod != NULL) ModClose(prevmod);

        // Check that Source line info is removed
        ModQueryLines(pmod, NULL, &cb);

        if (cb != 0) {
            ModClose(pmod);
            return FALSE;
        }

        // Check that local symbols are removed
        ModQuerySymbols(pmod, NULL, &cb);

        if (cb != 0) {
            ModClose(pmod);
            return FALSE;
        }
        prevmod=pmod;
    }
    if (pmod != NULL) ModClose(pmod);
    if (prevmod != NULL) ModClose(prevmod);

    return (TRUE);
}

BOOL PDBTypesStripped(
                       PDB *ppdb,
                       DBI *pdbi
                       )
{
    // Return values:
    // FALSE - Private Information has NOT been stripped
    // TRUE - Private Information has been stripped

    unsigned itsm;
    TPI *ptpi;
    TI  tiMin;
    TI  tiMac;

    // Check that types are removed
    for ( itsm = 0; itsm < 256; itsm++) {
        ptpi = 0;
        if (DBIQueryTypeServer(pdbi, (ITSM) itsm, &ptpi)) {
            continue;
        }
        if (!ptpi) {

            PDBOpenTpi(ppdb, pdbRead, &ptpi);
            tiMin = TypesQueryTiMinEx(ptpi);
            tiMac = TypesQueryTiMacEx(ptpi);
            if (tiMin < tiMac) {
                TypesClose(ptpi);
                return FALSE;
            }
        }
    }
    TypesClose(ptpi);
    return (TRUE);
}


BOOL DBGPrivateStripped(
    PCHAR    DebugData,
    ULONG    DebugSize
    )

{

    OMFSignature       *CvDebugData, *NewStartCvSig, *NewEndCvSig;
    OMFDirEntry        *CvDebugDirEntry;
    OMFDirHeader       *CvDebugDirHead;
    unsigned int        i, j;
    BOOL                RC = TRUE;

    // All the NT4 DBG's are coming returning FALSE.  Make this return TRUE until
    // we figure out exactly how to do it.

    return (TRUE);

    if (DebugSize == 0) return (TRUE);

    __try {
       CvDebugDirHead  = NULL;
       CvDebugDirEntry = NULL;
       CvDebugData = (OMFSignature *)DebugData;

       if ((((*(PULONG)(CvDebugData->Signature)) == '90BN') ||
            ((*(PULONG)(CvDebugData->Signature)) == '80BN') ||
            ((*(PULONG)(CvDebugData->Signature)) == '11BN'))  &&
           ((CvDebugDirHead = (OMFDirHeader *)((PUCHAR) CvDebugData + CvDebugData->filepos)) != NULL) &&
           ((CvDebugDirEntry = (OMFDirEntry *)((PUCHAR) CvDebugDirHead + CvDebugDirHead->cbDirHeader)) != NULL)) {

           // Walk the directory.  Keep what we want, zero out the rest.

            for (i=0, j=0; i < CvDebugDirHead->cDir; i++) {
                switch (CvDebugDirEntry[i].SubSection) {
                    case sstSegMap:
                    case sstSegName:
                    case sstOffsetMap16:
                    case sstOffsetMap32:
                    case sstModule:
                    case SSTMODULE:
                    case SSTPUBLIC:
                    case sstPublic:
                    case sstPublicSym:
                    case sstGlobalPub:
                        break;

                    default: 
                        // If we find any other subsections, the dbg has private symbols
                        RC = FALSE;
                        break;
                }
            }

        }  
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        RC = FALSE;
    }

    return(RC);
}

PIMAGE_SEPARATE_DEBUG_HEADER
MapDbgHeader (
    LPTSTR szFileName,
    PHANDLE phFile
)
{
    HANDLE hFileMap;
    PIMAGE_SEPARATE_DEBUG_HEADER pDbgHeader;

    (*phFile) = CreateFile( (LPCTSTR) szFileName,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                        );

    if (*phFile == INVALID_HANDLE_VALUE) {
        CloseHandle(*phFile);
        return(NULL);
    }

    hFileMap = CreateFileMapping( *phFile,
                                  NULL,
                                  PAGE_READONLY,
                                  0,
                                  0,
                                  NULL
                                  );

    if ( !hFileMap) {
        CloseHandle(*phFile);
        CloseHandle(hFileMap);
        return(NULL);
    }


    pDbgHeader = (PIMAGE_SEPARATE_DEBUG_HEADER) MapViewOfFile( hFileMap,
                            FILE_MAP_READ,
                            0,  // high
                            0,  // low
                            0   // whole file
                            );
    CloseHandle(hFileMap);

    if ( !pDbgHeader ) {
        UnmapFile((LPCVOID)pDbgHeader, *phFile);
        return(NULL);
    }

    return (pDbgHeader);
}

BOOL
UnmapFile( LPCVOID phFileMap, HANDLE hFile )
{
    if ((PHANDLE)phFileMap != NULL) {
        UnmapViewOfFile( phFileMap );
    }
    if (hFile) {
        CloseHandle(hFile);
    }
    return(TRUE);
}


IMAGE_DEBUG_DIRECTORY UNALIGNED *
GetDebugDirectoryInDbg(
                      PIMAGE_SEPARATE_DEBUG_HEADER pDbgHeader,
                      ULONG *NumberOfDebugDirectories
                      )
/*  Dbg is already mapped and a pointer to the base is
    passed in.  Returns a pointer to the Debug directories
*/
{
    IMAGE_DEBUG_DIRECTORY UNALIGNED *pDebugDirectory = NULL;

    pDebugDirectory = (PIMAGE_DEBUG_DIRECTORY) ((PCHAR)pDbgHeader +
                                                sizeof(IMAGE_SEPARATE_DEBUG_HEADER) +
                                                pDbgHeader->NumberOfSections * sizeof(IMAGE_SECTION_HEADER) +
                                                pDbgHeader->ExportedNamesSize);

    if (!pDebugDirectory) {
        return(NULL);
    }

    (*NumberOfDebugDirectories) =   pDbgHeader->DebugDirectorySize /
                                    sizeof(IMAGE_DEBUG_DIRECTORY);
    return (pDebugDirectory);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\srcsrv\pch.h ===
/*
 * pch.h for srcsrv project
 */

#include <windows.h>
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <memory.h>
#include <malloc.h>
#include <dbgeng.h>
#include <assert.h>
#include <string.h>
#include <time.h>
#include <ntverp.h>
#include <copystr.h>
#include <srcsrv.h>


// this defines all text replacement variables
                      
typedef struct _VARIABLE {
    char *key;
    char *val;
} VARIABLE, *PVARIABLE;

// this defines the location of a source file in source depot
                      
typedef struct _SDFILE {
    char *path;
    char *depot;
    char *loc;
} SDFILE, *PSDFILE;

// Define some list prototypes

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))

#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }

// for every process being handled

typedef struct _PROCESS_ENTRY {
    LIST_ENTRY          ListEntry;
    LIST_ENTRY          ModuleList;
    ULONG               cRefs;
    HANDLE              hProcess;
    PSRCSRVCALLBACKPROC callback;
    DWORD64             context;
    char                path[MAX_PATH + 1];
} PROCESS_ENTRY, *PPROCESS_ENTRY;

// for every module within a process

typedef struct _MODULE_ENTRY {
    LIST_ENTRY ListEntry;
    ULONG64    base;
    char       name[MAX_PATH + 1];
    char      *stream;
    DWORD      cbStream;
    PVARIABLE  vars;
    int        cvars;
    PSDFILE    sdfiles;
    int        cfiles;
} MODULE_ENTRY, *PMODULE_ENTRY;

// defines blocks of the stream

typedef enum {
    blNone,
    blVars,
    blSource,
    blMax
};


// from util.cpp

void
EnsureTrailingBackslash(
    char *sz
    );

BOOL
EnsurePathExists(
    const char *path,
    char       *existing,
    DWORD       existingsize,
    BOOL        fNoFileName
    );

__inline
BOOL
CreateDir(
    const char *path,
    char       *existing,
    DWORD       existingsize
    )
{
    return EnsurePathExists(path, existing, 0, TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\srcsrv\util.cpp ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

   util.cpp

Abstract:

    This code performs file systme and string functions

Author:

    patst

--*/

#include "pch.h"

void
EnsureTrailingChar(
    char *sz,
    char  c
    )
{
    int i;

    assert(sz);

    i = lstrlen(sz);
    if (!i)
        return;

    if (sz[i - 1] == c)
        return;

    sz[i] = c;
    sz[i + 1] = '\0';
}


void
EnsureTrailingBackslash(
    char *sz
    )
{
    return EnsureTrailingChar(sz, '\\');
}


void
EnsureTrailingSlash(
    char *sz
    )
{
    return EnsureTrailingChar(sz, '/');
}


void
EnsureTrailingCR(
    char *sz
    )
{
    return EnsureTrailingChar(sz, '\n');
}


void
pathcpy(
    LPSTR  trg,
    LPCSTR path,
    LPCSTR node,
    DWORD  trgsize
    )
{
    assert (trg && path && node);

    CopyString(trg, path, trgsize);
    EnsureTrailingBackslash(trg);
    CatString(trg, node, trgsize);
}


BOOL
EnsurePathExists(
    const char *path,
    char       *existing,
    DWORD       existingsize,
    BOOL        fNoFileName
    )
{
    CHAR dir[_MAX_PATH + 1];
    LPSTR p;
    DWORD dw;

    __try {

        if (existing)
            *existing = 0;

        // Make a copy of the string for editing.

        CopyStrArray(dir, path);
        if (fNoFileName)
            EnsureTrailingBackslash(dir);

        p = dir;

        //  If the second character in the path is "\", then this is a UNC
        //  path, and we should skip forward until we reach the 2nd \ in the path.

        if ((*p == '\\') && (*(p+1) == '\\')) {
            p++;            // Skip over the first \ in the name.
            p++;            // Skip over the second \ in the name.

            //  Skip until we hit the first "\" (\\Server\).

            while (*p && *p != '\\') {
                p++;
            }

            // Advance over it.

            if (*p) {
                p++;
            }

            //  Skip until we hit the second "\" (\\Server\Share\).

            while (*p && *p != '\\') {
                p++;
            }

            // Advance over it also.

            if (*p) {
                p++;
            }

        } else
        // Not a UNC.  See if it's <drive>:
        if (*(p+1) == ':' ) {

            p++;
            p++;

            // If it exists, skip over the root specifier

            if (*p && (*p == '\\')) {
                p++;
            }
        }

        while( *p ) {
            if ( *p == '\\' ) {
                *p = 0;
                dw = GetFileAttributes(dir);
                // Nothing exists with this name.  Try to make the directory name and error if unable to.
                if ( dw == 0xffffffff ) {
                    if ( !CreateDirectory(dir,NULL) ) {
                        if( GetLastError() != ERROR_ALREADY_EXISTS ) {
                            return false;
                        }
                    }
                } else {
                    if ( (dw & FILE_ATTRIBUTE_DIRECTORY) != FILE_ATTRIBUTE_DIRECTORY ) {
                        // Something exists with this name, but it's not a directory... Error
                        return false;
                    } else {
                        if (existing)
                            CopyString(existing, dir, existingsize);
                    }
                }

                *p = '\\';
            }
            p++;
        }
        SetLastError(NO_ERROR);

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SetLastError( GetExceptionCode() );
        return false;
    }

    return true;
}


BOOL
UndoPath(
    char *path,
    char *BasePath
    )
{
    CHAR dir[MAX_PATH + 1];
    LPSTR p;
    DWORD dw;

    dw = GetLastError();

    __try
    {
        CopyStrArray(dir, path);
        for (p = dir + strlen(dir); p > dir; p--)
        {
            if (*p == '\\')
            {
                *p = 0;
                if (*BasePath && !_stricmp(dir, BasePath))
                    break;
                if (!RemoveDirectory(dir))
                    break;
            }
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        SetLastError( GetExceptionCode() );
        return false;
    }

    SetLastError(dw);

    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\symchk\com\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\srcsrv\srcsrv.cpp ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

   srcsrv.cpp

Abstract:

    This code obtaining version-controlled source.

Author:

    patst

--*/

#include "pch.h"

BOOL       gInitialized = false;
LIST_ENTRY gProcessList;
DWORD      gProcessListCount = 0;
DWORD      gOptions = 0;

BOOL
DllMain(
    IN PVOID hdll,
    IN ULONG reason,
    IN PCONTEXT context OPTIONAL
    )

{
    switch (reason)
    {
    case DLL_PROCESS_ATTACH:
        break;

    case DLL_PROCESS_DETACH:
        break;
    }

    return true;
}


BOOL error(DWORD err)
{
    SetLastError(err);
    return false;
}

PVOID MemAlloc(DWORD size)
{
    PVOID rc;

    rc = LocalAlloc(LPTR, size);
    if (!rc)
        return rc;

    ZeroMemory(rc, size);
    return rc;
}


void MemFree(PVOID p)
{
    if (p)
        LocalFree(p);
}


PPROCESS_ENTRY FindProcessEntry(HANDLE hp)
{
    PLIST_ENTRY    next;
    PPROCESS_ENTRY pe;
    DWORD          count;

    next = gProcessList.Flink;
    if (!next)
        return NULL;

    for (count = 0; (PVOID)next != (PVOID)&gProcessList; count++)
    {
        assert(count < gProcessListCount);
        if (count >= gProcessListCount)
            return NULL;
        pe = CONTAINING_RECORD(next, PROCESS_ENTRY, ListEntry);
        next = pe->ListEntry.Flink;
        if (pe->hProcess == hp)
            return pe;
    }

    return NULL;
}


PPROCESS_ENTRY
FindFirstProcessEntry(
    )
{
    return CONTAINING_RECORD(gProcessList.Flink, PROCESS_ENTRY, ListEntry);
}


void
SendDebugString(
    PPROCESS_ENTRY pe,
    LPSTR          sz
    )
{
    __try
    {
        if (!pe)
            pe = FindFirstProcessEntry();

        if (!pe || !pe->callback)
            return;
        pe->callback(SRCSRVACTION_TRACE, (DWORD64)sz, pe->context);
    } __except (EXCEPTION_EXECUTE_HANDLER) {
    }
}


#define dprint ((gOptions & SRCSRVOPT_DEBUG) == SRCSRVOPT_DEBUG)&&_dprint
#define eprint ((gOptions & SRCSRVOPT_DEBUG) == SRCSRVOPT_DEBUG)&&_eprint

#define pdprint ((gOptions & SRCSRVOPT_DEBUG) == SRCSRVOPT_DEBUG)&&_pdprint
#define pdeprint ((gOptions & SRCSRVOPT_DEBUG) == SRCSRVOPT_DEBUG)&&_pdeprint

bool
_pdprint(
    PPROCESS_ENTRY pe,
    LPSTR          format,
    ...
    )
{
    static char buf[1000] = "SRCSRV:  ";
    va_list args;

    va_start(args, format);
    _vsnprintf(buf+9, sizeof(buf)-9, format, args);
    va_end(args);
    SendDebugString(pe, buf);
    return true;
}

bool
_peprint(
    PPROCESS_ENTRY pe,
    LPSTR          format,
    ...
    )
{
    static char buf[1000] = "";
    va_list args;

    va_start(args, format);
    _vsnprintf(buf, sizeof(buf), format, args);
    va_end(args);
    SendDebugString(pe, buf);
    return true;
}


bool
_dprint(
    LPSTR format,
    ...
    )
{
    static char buf[1000] = "SRCSRV:  ";
    va_list args;

    va_start(args, format);
    _vsnprintf(buf+9, sizeof(buf)-9, format, args);
    va_end(args);
    SendDebugString(NULL, buf);
    return true;
}

bool
_eprint(
    LPSTR format,
    ...
    )
{
    static char buf[1000] = "";
    va_list args;

    va_start(args, format);
    _vsnprintf(buf, sizeof(buf), format, args);
    va_end(args);
    SendDebugString(NULL, buf);
    return true;
}


void FreeModuleEntry(PPROCESS_ENTRY pe, PMODULE_ENTRY  me)
{
    MemFree(me->stream);
    MemFree(me);
}


PMODULE_ENTRY
FindModuleEntry(
    PPROCESS_ENTRY pe,
    DWORD64        base
    )
{
    static PLIST_ENTRY next = NULL;
    PMODULE_ENTRY      me;

    if (base == (DWORD64)-1)
    {
        if (!next)
            return NULL;
        if ((PVOID)next == (PVOID)&pe->ModuleList)
        {
            // Reset to NULL so the list can be re-walked
            next = NULL;
            return NULL;
        }
        me = CONTAINING_RECORD( next, MODULE_ENTRY, ListEntry );
        next = me->ListEntry.Flink;
        return me;
    }

    next = pe->ModuleList.Flink;
    if (!next)
        return NULL;

    while ((PVOID)next != (PVOID)&pe->ModuleList)
    {
        me = CONTAINING_RECORD(next, MODULE_ENTRY, ListEntry);
        next = me->ListEntry.Flink;
        if (base == me->base)
            return me;
    }

    return NULL;
}


char *
dotranslate(
    PMODULE_ENTRY  me,
    char          *input,
    char          *output,
    DWORD          outsize
    )
{
    int       i;
    char      key[MAX_PATH + 1];
    PVARIABLE var;
    int       cbkey;
    char     *s;
    char     *p;

    assert(me && input && *input && output);

    *output = 0;

    for (i = 0, var = me->vars; i < me->cvars; i++, var++)
    {
        CopyStrArray(key, "${");
        CatStrArray(key, var->key);
        CatStrArray(key, "}");
        cbkey = strlen(var->key) + 3;
        for (s = input, p = strstr(s, key); p; s = p + cbkey, p = strstr(s, key))
        {
            CatNString(output, s, p - s, outsize);
            CatString(output, var->val, outsize);
        }
    }

    if (!*output)
        CopyString(output, input, outsize);

    return output;
}

#define translate(me, input, output) dotranslate(me, input, output, DIMA(output))

PSDFILE
find(
    PMODULE_ENTRY me,
    const char   *file
    )
{
    int i;
    PSDFILE sdf;

    for (i = 0, sdf = me->sdfiles; i < me->cfiles; i++, sdf++)
    {
        if (!_strcmpi(sdf->path, file))
            return sdf;
    }

    return NULL;
}



void
DumpModuleEntries(
    PPROCESS_ENTRY pe
    )
{
    static PLIST_ENTRY next = NULL;
    PMODULE_ENTRY      me;
    PVARIABLE          vars;
    PSDFILE            sdfiles;
    char               path[MAX_PATH + 1];
    char               depot[MAX_PATH + 1];
    char               loc[MAX_PATH + 1];

    next = pe->ModuleList.Flink;
    if (!next)
        return;

    while ((PVOID)next != (PVOID)&pe->ModuleList)
    {
        me = CONTAINING_RECORD(next, MODULE_ENTRY, ListEntry);
        dprint("%s 0x%x\n", me->name, me->base);
        dprint("variables:\n");
        for (vars = me->vars; vars->key; vars++)
            dprint("%s=%s\n", vars->key, vars->val);
        dprint("source depot files:\n");
        for (sdfiles = me->sdfiles; sdfiles->path; sdfiles++)
        {
            translate(me, sdfiles->path, path);
            translate(me, sdfiles->depot, depot);
            translate(me, sdfiles->loc, loc);
            dprint("%s  %s  %s\n", path, depot, loc);
        }
        eprint("\n");
        next = me->ListEntry.Flink;
    }
}


char *
GetLine(
    char *sz
    )
{
    for (;*sz; sz++)
    {
        if (*sz == '\n' || *sz == '\r')
        {
            *sz++ = 0;
            if (*sz == 10)
                sz++;
            return (*sz) ? sz : NULL;
        }
    }

    return NULL;
}


int
SetBlock(
    char *sz
    )
{
    static char *labels[blMax] =
    {
        "SRCSRV: end",          // blNone
        "SRCSRV: variables",    // blVars
        "SRCSRV: source files"  // blSource
    };
    static int lens[blMax] =
    {
        sizeof("SRCSRV: end") / sizeof(char) -1 ,          // blNone
        sizeof("SRCSRV: variables") / sizeof(char) -1 ,    // blVars
        sizeof("SRCSRV: source files") / sizeof(char) -1   // blSource
    };

    int   i;
    char *label;

    for (i = blNone; i < blMax; i++)
    {
        label = labels[i];
        if (!strncmp(sz, label, lens[i]))
            return i;
    }

    return blMax;
}


bool
ParseVars(
    char      *sz,
    PVARIABLE  var
    )
{
    char *p;

    p = (strchr(sz, '='));
    if (!p)
        return false;

    *p = 0;
    var->key = sz;
    var->val = p + 1;

    return true;
}


bool
ParseSD(
    char   *sz,
    PSDFILE sdfile
    )
{
    char *p;
    char *g;

    sz += 4;

    p = (strchr(sz, '*'));
    if (!p)
        return false;
    *p++ = 0;

    g = (strchr(p, '*'));
    if (!g)
        return false;
    *g++ = 0;

    sdfile->path = sz;
    sdfile->depot = p;
    sdfile->loc = g;

    return true;
}


BOOL
IndexStream(
    PMODULE_ENTRY me
    )
{
    char     *sz;
    char     *next;
    int       block;
    int       lines;
    int       bl;
    PVARIABLE vars;
    PSDFILE   sdfiles;

    // count the lines

    for (sz = me->stream, lines = 0; *sz; sz++)
    {
        if (*sz == '\n')
            lines++;
    }
    if (!lines)
        return false;

    me->vars = (PVARIABLE)MemAlloc(lines * sizeof(VARIABLE));
    if (!me->vars)
        return error(ERROR_NOT_ENOUGH_MEMORY);
    me->sdfiles = (PSDFILE)MemAlloc(lines * sizeof(SDFILE));
    if (!me->sdfiles)
        return error(ERROR_NOT_ENOUGH_MEMORY);

    block = blNone;
    vars = me->vars;
    sdfiles = me->sdfiles;
    me->cfiles = 0;
    me->cvars = 0;
    for (sz = me->stream; sz; sz = next)
    {
        next = GetLine(sz);
        bl = SetBlock(sz);
//      dprint("%s\n", sz);
        if (bl != blMax)
        {
            block = bl;
            continue;
        }

        switch(block)
        {
        case blVars:
            if (ParseVars(sz, vars))
            {
                vars++;
                me->cvars++;
            }
            break;
        case blSource:
            if (ParseSD(sz, sdfiles))
            {
                sdfiles++;
                me->cfiles++;
            }
            break;
        }
    }

#if 0
    DumpIndexes(me);
#endif

    return true;
}


DWORD
WINAPI
SrcSrvSetOptions(
    DWORD opts
    )
{
    DWORD rc = gOptions;
    gOptions = opts;
    return rc;
}


DWORD
WINAPI
SrcSrvGetOptions(
    )
{
    return gOptions;
}


BOOL
WINAPI
SrcSrvInit(
    HANDLE hProcess,
    LPCSTR path
    )
{
    PPROCESS_ENTRY pe;

    // test the path for copying files to...

    if (!path || !*path)
        return error(ERROR_INVALID_PARAMETER);

    if (!EnsurePathExists(path, NULL, 0, TRUE))
        return false;

    if (!gInitialized)
    {
        gInitialized = true;
        InitializeListHead(&gProcessList);
    }

    if (pe = FindProcessEntry(hProcess))
    {
        pe->cRefs++;
        return error(ERROR_INVALID_HANDLE);
    }

    pe = (PPROCESS_ENTRY)MemAlloc(sizeof(PROCESS_ENTRY));
    if (!pe)
        return error(ERROR_NOT_ENOUGH_MEMORY);

    pe->hProcess = hProcess;
    pe->cRefs = 1;
    CopyStrArray(pe->path, path);
    gProcessListCount++;
    InitializeListHead(&pe->ModuleList);
    InsertTailList(&gProcessList, &pe->ListEntry);

    return true;
}


BOOL
WINAPI
SrcSrvCleanup(
    HANDLE hProcess
    )
{
    PPROCESS_ENTRY pe;
    PLIST_ENTRY    next;
    PMODULE_ENTRY  me;

    pe = FindProcessEntry(hProcess);
    if (!pe)
        return error(ERROR_INVALID_HANDLE);

    if (--pe->cRefs)
        return true;

    next = pe->ModuleList.Flink;
    if (next)
    {
        while (next != &pe->ModuleList)
        {
            me = CONTAINING_RECORD(next, MODULE_ENTRY, ListEntry);
            next = me->ListEntry.Flink;
            FreeModuleEntry(pe, me);
        }
    }

    RemoveEntryList(&pe->ListEntry);
    MemFree(pe);
    gProcessListCount--;

    return true;
}


BOOL
WINAPI
SrcSrvSetTargetPath(
    HANDLE hProcess,
    LPCSTR path
    )
{
    PPROCESS_ENTRY pe;

    pe = FindProcessEntry(hProcess);
    if (!pe)
        return error(ERROR_INVALID_HANDLE);

    // test the path for copying files to...

    if (!path || !*path)
        return error(ERROR_INVALID_PARAMETER);

    if (!EnsurePathExists(path, NULL, 0, TRUE))
        return false;

    // store the new path

    CopyStrArray(pe->path, path);

    return true;
}


BOOL
WINAPI
SrcSrvLoadModule(
    HANDLE  hProcess,
    LPCSTR  name,
    DWORD64 base,
    PVOID   stream,
    DWORD   size
    )
{
    PPROCESS_ENTRY pe;
    PMODULE_ENTRY  me;

    if (!base || !name || !*name || !stream || !*(PCHAR)stream || !size)
        return error(ERROR_INVALID_PARAMETER);

    pe = FindProcessEntry(hProcess);
    if (!pe)
        return error(ERROR_INVALID_PARAMETER);

    me = FindModuleEntry(pe, base);
    if (me)
        SrcSrvUnloadModule(pe, base);

    me = (PMODULE_ENTRY)MemAlloc(sizeof(MODULE_ENTRY));
    if (!me)
        return error(ERROR_NOT_ENOUGH_MEMORY);

    me->base = base;
    CopyStrArray(me->name, name);
    me->stream = (char *)MemAlloc(size);
    if (!me->stream)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto error;
    }
    memcpy(me->stream, stream, size);
    me->cbStream = size;
    dprint(me->stream);
    IndexStream(me);
    InsertTailList(&pe->ModuleList, &me->ListEntry);
    DumpModuleEntries(pe);

    return true;

error:
    FreeModuleEntry(pe, me);
    return false;
}


BOOL
WINAPI
SrcSrvUnloadModule(
    HANDLE  hProcess,
    DWORD64 base
    )
{
    PPROCESS_ENTRY  pe;
    PLIST_ENTRY     next;
    PMODULE_ENTRY   me;

    pe = FindProcessEntry(hProcess);
    if (!pe)
        return error(ERROR_INVALID_PARAMETER);

    next = pe->ModuleList.Flink;
    if (!next)
        return error(ERROR_MOD_NOT_FOUND);

    while (next != &pe->ModuleList)
    {
        me = CONTAINING_RECORD(next, MODULE_ENTRY, ListEntry);
        if (me->base == base)
        {
            RemoveEntryList(next);
            FreeModuleEntry(pe, me);
            return true;
        }
        next = me->ListEntry.Flink;
    }

    return error(ERROR_MOD_NOT_FOUND);
}


BOOL
WINAPI
SrcSrvRegisterCallback(
    HANDLE              hProcess,
    PSRCSRVCALLBACKPROC callback,
    DWORD64             context
    )
{
    PPROCESS_ENTRY  pe;

    pe = FindProcessEntry(hProcess);
    if (!pe)
        return error(ERROR_INVALID_PARAMETER);

    pe->callback = callback;
    pe->context = context;

    return true;
}


BOOL
WINAPI
SrcSrvGetFile(
    HANDLE  hProcess,
    DWORD64 base,
    LPCSTR  filename,
    LPSTR   target,
    DWORD   trgsize
    )
{
    PPROCESS_ENTRY pe;
    PMODULE_ENTRY  me;
    PSDFILE        sdf;
    char           name[MAX_PATH + 1];
    char           ext[MAX_PATH + 1];
    BOOL           rc;
    char           depot[MAX_PATH + 1];
    char           loc[MAX_PATH + 1];
    char           cmd[MAX_PATH * 2];
    STARTUPINFO    si;
    PROCESS_INFORMATION pi;

    if (!base || !filename || !*filename || !target)
        return error(ERROR_INVALID_PARAMETER);

    *target = 0;

    pe = FindProcessEntry(hProcess);
    if (!pe)
        return error(ERROR_INVALID_HANDLE);

    me = FindModuleEntry(pe, base);
    if (!me)
        return error(ERROR_MOD_NOT_FOUND);

    // get the matching file entry

    sdf = find(me, filename);
    if (!sdf)
        return error(ERROR_FILE_NOT_FOUND);

    // build the target path and command line for source depot

#if 0
    _splitpath(filename, NULL, NULL, name, ext);
    strcpy(target, pe->path);   // SECURITY: Don't know size of target buffer.
    EnsureTrailingBackslash(target);
    strcat(target, name);       // SECURITY: Don't know size of target buffer.
    strcat(target, ext);        // SECURITY: Don't know size of target buffer.

    CreateTargetPath(pe, sdf, target);
#else
    strcpy(target, pe->path);   // SECURITY: Don't know size of target buffer.
    EnsureTrailingBackslash(target);
    _splitpath(filename, NULL, NULL, name, ext);
    strcat(target, name);       // SECURITY: Don't know size of target buffer.
    if (*ext)
        strcat(target, ext);    // SECURITY: Don't know size of target buffer.
#endif

    PrintString(cmd,
                DIMA(cmd),
                "sd.exe -p %s print -o %s -q %s",
                translate(me, sdf->depot, depot),
                target,
                translate(me, sdf->loc, loc));

    // execute the source depot command

    ZeroMemory((void *)&si, sizeof(si));
    rc = CreateProcess(NULL,
                       cmd,
                       NULL,
                       NULL,
                       false,
                       0,
                       NULL,
                       pe->path,
                       &si,
                       &pi);
    if (!rc)
        *target = 0;

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\symchk\com\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by CheckSymbolsLib.rc
//
#define IDS_PROJNAME                    100
#define IDR_CHECKSYMBOLS                101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\symchk\com\checksymbolslib_p.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the proxy stub code */


 /* File created by MIDL compiler version 6.00.0354 */
/* Compiler settings for checksymbolslib.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)
#define USE_STUBLESS_PROXY


/* verify that the <rpcproxy.h> version is high enough to compile this file*/
#ifndef __REDQ_RPCPROXY_H_VERSION__
#define __REQUIRED_RPCPROXY_H_VERSION__ 475
#endif


#include "rpcproxy.h"
#ifndef __RPCPROXY_H_VERSION__
#error this stub requires an updated version of <rpcproxy.h>
#endif // __RPCPROXY_H_VERSION__


#include "checksymbolslib.h"

#define TYPE_FORMAT_STRING_SIZE   57                                
#define PROC_FORMAT_STRING_SIZE   55                                
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   1            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ICheckSymbols_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ICheckSymbols_ProxyInfo;


extern const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ];

#if !defined(__RPC_WIN32__)
#error  Invalid build platform for this stub.
#endif

#if !(TARGET_IS_NT50_OR_LATER)
#error You need a Windows 2000 or later to run this stub because it uses these features:
#error   /robust command line switch.
#error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
#error This app will die there with the RPC_X_WRONG_STUB_VERSION error.
#endif


static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure CheckSymbols */

			0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x7 ),	/* 7 */
/*  8 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 10 */	NdrFcShort( 0x0 ),	/* 0 */
/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
/* 14 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 16 */	0x8,		/* 8 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 18 */	NdrFcShort( 0x1 ),	/* 1 */
/* 20 */	NdrFcShort( 0x3 ),	/* 3 */
/* 22 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter FilePath */

/* 24 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 26 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 28 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */

	/* Parameter SymPath */

/* 30 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 32 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 34 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */

	/* Parameter StripSym */

/* 36 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 38 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 40 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */

	/* Parameter OutputString */

/* 42 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 44 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 46 */	NdrFcShort( 0x2e ),	/* Type Offset=46 */

	/* Return value */

/* 48 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 50 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 52 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x12, 0x0,	/* FC_UP */
/*  4 */	NdrFcShort( 0xe ),	/* Offset= 14 (18) */
/*  6 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/*  8 */	NdrFcShort( 0x2 ),	/* 2 */
/* 10 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 12 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 14 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 16 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 18 */	
			0x17,		/* FC_CSTRUCT */
			0x3,		/* 3 */
/* 20 */	NdrFcShort( 0x8 ),	/* 8 */
/* 22 */	NdrFcShort( 0xfffffff0 ),	/* Offset= -16 (6) */
/* 24 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 26 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 28 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 30 */	NdrFcShort( 0x0 ),	/* 0 */
/* 32 */	NdrFcShort( 0x4 ),	/* 4 */
/* 34 */	NdrFcShort( 0x0 ),	/* 0 */
/* 36 */	NdrFcShort( 0xffffffde ),	/* Offset= -34 (2) */
/* 38 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 40 */	NdrFcShort( 0x6 ),	/* Offset= 6 (46) */
/* 42 */	
			0x13, 0x0,	/* FC_OP */
/* 44 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (18) */
/* 46 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 48 */	NdrFcShort( 0x0 ),	/* 0 */
/* 50 */	NdrFcShort( 0x4 ),	/* 4 */
/* 52 */	NdrFcShort( 0x0 ),	/* 0 */
/* 54 */	NdrFcShort( 0xfffffff4 ),	/* Offset= -12 (42) */

			0x0
        }
    };

static const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ] = 
        {
            
            {
            BSTR_UserSize
            ,BSTR_UserMarshal
            ,BSTR_UserUnmarshal
            ,BSTR_UserFree
            }

        };



/* Object interface: IUnknown, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IDispatch, ver. 0.0,
   GUID={0x00020400,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: ICheckSymbols, ver. 0.0,
   GUID={0x4C23935E,0xAE26,0x42E7,{0x8C,0xF9,0x0C,0x17,0xCD,0x5D,0xEA,0x12}} */

#pragma code_seg(".orpc")
static const unsigned short ICheckSymbols_FormatStringOffsetTable[] =
    {
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    0
    };

static const MIDL_STUBLESS_PROXY_INFO ICheckSymbols_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ICheckSymbols_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ICheckSymbols_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ICheckSymbols_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(8) _ICheckSymbolsProxyVtbl = 
{
    &ICheckSymbols_ProxyInfo,
    &IID_ICheckSymbols,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    0 /* (void *) (INT_PTR) -1 /* IDispatch::GetTypeInfoCount */ ,
    0 /* (void *) (INT_PTR) -1 /* IDispatch::GetTypeInfo */ ,
    0 /* (void *) (INT_PTR) -1 /* IDispatch::GetIDsOfNames */ ,
    0 /* IDispatch_Invoke_Proxy */ ,
    (void *) (INT_PTR) -1 /* ICheckSymbols::CheckSymbols */
};


static const PRPC_STUB_FUNCTION ICheckSymbols_table[] =
{
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    NdrStubCall2
};

CInterfaceStubVtbl _ICheckSymbolsStubVtbl =
{
    &IID_ICheckSymbols,
    &ICheckSymbols_ServerInfo,
    8,
    &ICheckSymbols_table[-3],
    CStdStubBuffer_DELEGATING_METHODS
};

static const MIDL_STUB_DESC Object_StubDesc = 
    {
    0,
    NdrOleAllocate,
    NdrOleFree,
    0,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x50002, /* Ndr library version */
    0,
    0x6000162, /* MIDL Version 6.0.354 */
    0,
    UserMarshalRoutines,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };

const CInterfaceProxyVtbl * _checksymbolslib_ProxyVtblList[] = 
{
    ( CInterfaceProxyVtbl *) &_ICheckSymbolsProxyVtbl,
    0
};

const CInterfaceStubVtbl * _checksymbolslib_StubVtblList[] = 
{
    ( CInterfaceStubVtbl *) &_ICheckSymbolsStubVtbl,
    0
};

PCInterfaceName const _checksymbolslib_InterfaceNamesList[] = 
{
    "ICheckSymbols",
    0
};

const IID *  _checksymbolslib_BaseIIDList[] = 
{
    &IID_IDispatch,
    0
};


#define _checksymbolslib_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _checksymbolslib, pIID, n)

int __stdcall _checksymbolslib_IID_Lookup( const IID * pIID, int * pIndex )
{
    
    if(!_checksymbolslib_CHECK_IID(0))
        {
        *pIndex = 0;
        return 1;
        }

    return 0;
}

const ExtendedProxyFileInfo checksymbolslib_ProxyFileInfo = 
{
    (PCInterfaceProxyVtblList *) & _checksymbolslib_ProxyVtblList,
    (PCInterfaceStubVtblList *) & _checksymbolslib_StubVtblList,
    (const PCInterfaceName * ) & _checksymbolslib_InterfaceNamesList,
    (const IID ** ) & _checksymbolslib_BaseIIDList,
    & _checksymbolslib_IID_Lookup, 
    1,
    2,
    0, /* table of [async_uuid] interfaces */
    0, /* Filler1 */
    0, /* Filler2 */
    0  /* Filler3 */
};


#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the proxy stub code */


 /* File created by MIDL compiler version 6.00.0354 */
/* Compiler settings for checksymbolslib.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)
#define USE_STUBLESS_PROXY


/* verify that the <rpcproxy.h> version is high enough to compile this file*/
#ifndef __REDQ_RPCPROXY_H_VERSION__
#define __REQUIRED_RPCPROXY_H_VERSION__ 475
#endif


#include "rpcproxy.h"
#ifndef __RPCPROXY_H_VERSION__
#error this stub requires an updated version of <rpcproxy.h>
#endif // __RPCPROXY_H_VERSION__


#include "checksymbolslib.h"

#define TYPE_FORMAT_STRING_SIZE   57                                
#define PROC_FORMAT_STRING_SIZE   57                                
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   1            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ICheckSymbols_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ICheckSymbols_ProxyInfo;


extern const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ];

#if !defined(__RPC_WIN64__)
#error  Invalid build platform for this stub.
#endif

static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure CheckSymbols */

			0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x7 ),	/* 7 */
/*  8 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 10 */	NdrFcShort( 0x0 ),	/* 0 */
/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
/* 14 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 16 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 18 */	NdrFcShort( 0x1 ),	/* 1 */
/* 20 */	NdrFcShort( 0x3 ),	/* 3 */
/* 22 */	NdrFcShort( 0x0 ),	/* 0 */
/* 24 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter FilePath */

/* 26 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 28 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 30 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */

	/* Parameter SymPath */

/* 32 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 34 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 36 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */

	/* Parameter StripSym */

/* 38 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 40 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 42 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */

	/* Parameter OutputString */

/* 44 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 46 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 48 */	NdrFcShort( 0x2e ),	/* Type Offset=46 */

	/* Return value */

/* 50 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 52 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 54 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x12, 0x0,	/* FC_UP */
/*  4 */	NdrFcShort( 0xe ),	/* Offset= 14 (18) */
/*  6 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/*  8 */	NdrFcShort( 0x2 ),	/* 2 */
/* 10 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 12 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 14 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 16 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 18 */	
			0x17,		/* FC_CSTRUCT */
			0x3,		/* 3 */
/* 20 */	NdrFcShort( 0x8 ),	/* 8 */
/* 22 */	NdrFcShort( 0xfffffff0 ),	/* Offset= -16 (6) */
/* 24 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 26 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 28 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 30 */	NdrFcShort( 0x0 ),	/* 0 */
/* 32 */	NdrFcShort( 0x8 ),	/* 8 */
/* 34 */	NdrFcShort( 0x0 ),	/* 0 */
/* 36 */	NdrFcShort( 0xffffffde ),	/* Offset= -34 (2) */
/* 38 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 40 */	NdrFcShort( 0x6 ),	/* Offset= 6 (46) */
/* 42 */	
			0x13, 0x0,	/* FC_OP */
/* 44 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (18) */
/* 46 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 48 */	NdrFcShort( 0x0 ),	/* 0 */
/* 50 */	NdrFcShort( 0x8 ),	/* 8 */
/* 52 */	NdrFcShort( 0x0 ),	/* 0 */
/* 54 */	NdrFcShort( 0xfffffff4 ),	/* Offset= -12 (42) */

			0x0
        }
    };

static const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ] = 
        {
            
            {
            BSTR_UserSize
            ,BSTR_UserMarshal
            ,BSTR_UserUnmarshal
            ,BSTR_UserFree
            }

        };



/* Object interface: IUnknown, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IDispatch, ver. 0.0,
   GUID={0x00020400,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: ICheckSymbols, ver. 0.0,
   GUID={0x4C23935E,0xAE26,0x42E7,{0x8C,0xF9,0x0C,0x17,0xCD,0x5D,0xEA,0x12}} */

#pragma code_seg(".orpc")
static const unsigned short ICheckSymbols_FormatStringOffsetTable[] =
    {
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    0
    };

static const MIDL_STUBLESS_PROXY_INFO ICheckSymbols_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ICheckSymbols_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ICheckSymbols_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ICheckSymbols_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(8) _ICheckSymbolsProxyVtbl = 
{
    &ICheckSymbols_ProxyInfo,
    &IID_ICheckSymbols,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    0 /* (void *) (INT_PTR) -1 /* IDispatch::GetTypeInfoCount */ ,
    0 /* (void *) (INT_PTR) -1 /* IDispatch::GetTypeInfo */ ,
    0 /* (void *) (INT_PTR) -1 /* IDispatch::GetIDsOfNames */ ,
    0 /* IDispatch_Invoke_Proxy */ ,
    (void *) (INT_PTR) -1 /* ICheckSymbols::CheckSymbols */
};


static const PRPC_STUB_FUNCTION ICheckSymbols_table[] =
{
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    NdrStubCall2
};

CInterfaceStubVtbl _ICheckSymbolsStubVtbl =
{
    &IID_ICheckSymbols,
    &ICheckSymbols_ServerInfo,
    8,
    &ICheckSymbols_table[-3],
    CStdStubBuffer_DELEGATING_METHODS
};

static const MIDL_STUB_DESC Object_StubDesc = 
    {
    0,
    NdrOleAllocate,
    NdrOleFree,
    0,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x50002, /* Ndr library version */
    0,
    0x6000162, /* MIDL Version 6.0.354 */
    0,
    UserMarshalRoutines,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };

const CInterfaceProxyVtbl * _checksymbolslib_ProxyVtblList[] = 
{
    ( CInterfaceProxyVtbl *) &_ICheckSymbolsProxyVtbl,
    0
};

const CInterfaceStubVtbl * _checksymbolslib_StubVtblList[] = 
{
    ( CInterfaceStubVtbl *) &_ICheckSymbolsStubVtbl,
    0
};

PCInterfaceName const _checksymbolslib_InterfaceNamesList[] = 
{
    "ICheckSymbols",
    0
};

const IID *  _checksymbolslib_BaseIIDList[] = 
{
    &IID_IDispatch,
    0
};


#define _checksymbolslib_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _checksymbolslib, pIID, n)

int __stdcall _checksymbolslib_IID_Lookup( const IID * pIID, int * pIndex )
{
    
    if(!_checksymbolslib_CHECK_IID(0))
        {
        *pIndex = 0;
        return 1;
        }

    return 0;
}

const ExtendedProxyFileInfo checksymbolslib_ProxyFileInfo = 
{
    (PCInterfaceProxyVtblList *) & _checksymbolslib_ProxyVtblList,
    (PCInterfaceStubVtblList *) & _checksymbolslib_StubVtblList,
    (const PCInterfaceName * ) & _checksymbolslib_InterfaceNamesList,
    (const IID ** ) & _checksymbolslib_BaseIIDList,
    & _checksymbolslib_IID_Lookup, 
    1,
    2,
    0, /* table of [async_uuid] interfaces */
    0, /* Filler1 */
    0, /* Filler2 */
    0  /* Filler3 */
};


#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\symchk\com\checksymbolslib.cpp ===
// CheckSymbolsLib.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f CheckSymbolsLibps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "CheckSymbolsLib.h"

#include "CheckSymbolsLib_i.c"
#include "CheckSymbols.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_CheckSymbols, CCheckSymbols)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_CHECKSYMBOLSLIBLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\symchk\com\dlldata.c ===
/*********************************************************
   DllData file -- generated by MIDL compiler 

        DO NOT ALTER THIS FILE

   This file is regenerated by MIDL on every IDL file compile.

   To completely reconstruct this file, delete it and rerun MIDL
   on all the IDL files in this DLL, specifying this file for the
   /dlldata command line option

*********************************************************/

#define PROXY_DELEGATION

#include <rpcproxy.h>

#ifdef __cplusplus
extern "C"   {
#endif

EXTERN_PROXY_FILE( CheckSymbolsLib )
EXTERN_PROXY_FILE( checksymbolslib )


PROXYFILE_LIST_START
/* Start of list */
  REFERENCE_PROXY_FILE( CheckSymbolsLib ),
  REFERENCE_PROXY_FILE( checksymbolslib ),
/* End of list */
PROXYFILE_LIST_END


DLLDATA_ROUTINES( aProxyFileList, GET_DLL_CLSID )

#ifdef __cplusplus
}  /*extern "C" */
#endif

/* end of generated dlldata file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\symchk\com\checksymbolslib.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0354 */
/* Compiler settings for checksymbolslib.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __checksymbolslib_h__
#define __checksymbolslib_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ICheckSymbols_FWD_DEFINED__
#define __ICheckSymbols_FWD_DEFINED__
typedef interface ICheckSymbols ICheckSymbols;
#endif 	/* __ICheckSymbols_FWD_DEFINED__ */


#ifndef __CheckSymbols_FWD_DEFINED__
#define __CheckSymbols_FWD_DEFINED__

#ifdef __cplusplus
typedef class CheckSymbols CheckSymbols;
#else
typedef struct CheckSymbols CheckSymbols;
#endif /* __cplusplus */

#endif 	/* __CheckSymbols_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

#ifndef __ICheckSymbols_INTERFACE_DEFINED__
#define __ICheckSymbols_INTERFACE_DEFINED__

/* interface ICheckSymbols */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICheckSymbols;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4C23935E-AE26-42E7-8CF9-0C17CD5DEA12")
    ICheckSymbols : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CheckSymbols( 
            /* [in] */ BSTR FilePath,
            /* [in] */ BSTR SymPath,
            /* [in] */ BSTR StripSym,
            /* [retval][out] */ BSTR *OutputString) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICheckSymbolsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICheckSymbols * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICheckSymbols * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICheckSymbols * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ICheckSymbols * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ICheckSymbols * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ICheckSymbols * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ICheckSymbols * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CheckSymbols )( 
            ICheckSymbols * This,
            /* [in] */ BSTR FilePath,
            /* [in] */ BSTR SymPath,
            /* [in] */ BSTR StripSym,
            /* [retval][out] */ BSTR *OutputString);
        
        END_INTERFACE
    } ICheckSymbolsVtbl;

    interface ICheckSymbols
    {
        CONST_VTBL struct ICheckSymbolsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICheckSymbols_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICheckSymbols_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICheckSymbols_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICheckSymbols_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICheckSymbols_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICheckSymbols_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICheckSymbols_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICheckSymbols_CheckSymbols(This,FilePath,SymPath,StripSym,OutputString)	\
    (This)->lpVtbl -> CheckSymbols(This,FilePath,SymPath,StripSym,OutputString)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICheckSymbols_CheckSymbols_Proxy( 
    ICheckSymbols * This,
    /* [in] */ BSTR FilePath,
    /* [in] */ BSTR SymPath,
    /* [in] */ BSTR StripSym,
    /* [retval][out] */ BSTR *OutputString);


void __RPC_STUB ICheckSymbols_CheckSymbols_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICheckSymbols_INTERFACE_DEFINED__ */



#ifndef __CHECKSYMBOLSLIBLib_LIBRARY_DEFINED__
#define __CHECKSYMBOLSLIBLib_LIBRARY_DEFINED__

/* library CHECKSYMBOLSLIBLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_CHECKSYMBOLSLIBLib;

EXTERN_C const CLSID CLSID_CheckSymbols;

#ifdef __cplusplus

class DECLSPEC_UUID("773B2A62-B1E7-45F0-B837-8C47042FB265")
CheckSymbols;
#endif
#endif /* __CHECKSYMBOLSLIBLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\symchk\com\checksymbolslib_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0354 */
/* Compiler settings for checksymbolslib.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_ICheckSymbols,0x4C23935E,0xAE26,0x42E7,0x8C,0xF9,0x0C,0x17,0xCD,0x5D,0xEA,0x12);


MIDL_DEFINE_GUID(IID, LIBID_CHECKSYMBOLSLIBLib,0x8A6FE0DC,0xCE1D,0x4490,0x90,0x22,0xAC,0x75,0x5C,0x32,0x0E,0x82);


MIDL_DEFINE_GUID(CLSID, CLSID_CheckSymbols,0x773B2A62,0xB1E7,0x45F0,0xB8,0x37,0x8C,0x47,0x04,0x2F,0xB2,0x65);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0354 */
/* Compiler settings for checksymbolslib.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_ICheckSymbols,0x4C23935E,0xAE26,0x42E7,0x8C,0xF9,0x0C,0x17,0xCD,0x5D,0xEA,0x12);


MIDL_DEFINE_GUID(IID, LIBID_CHECKSYMBOLSLIBLib,0x8A6FE0DC,0xCE1D,0x4490,0x90,0x22,0xAC,0x75,0x5C,0x32,0x0E,0x82);


MIDL_DEFINE_GUID(CLSID, CLSID_CheckSymbols,0x773B2A62,0xB1E7,0x45F0,0xB8,0x37,0x8C,0x47,0x04,0x2F,0xB2,0x65);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\symchk\com\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__42A7B09B_A6D8_4A69_8665_C3EEFAEAF712__INCLUDED_)
#define AFX_STDAFX_H__42A7B09B_A6D8_4A69_8665_C3EEFAEAF712__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__42A7B09B_A6D8_4A69_8665_C3EEFAEAF712__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\symchk\symchk\sharedutils.c ===
#include <Windows.h>
#include <strsafe.h>

///////////////////////////////////////////////////////////////////////////////
//
// Local replacement for GetFullPathName that correctly handles lpFileName when
// it begins with '\'
//
DWORD PrivateGetFullPathName(LPCTSTR lpFilename, DWORD nBufferLength, LPTSTR lpBuffer, LPTSTR *lpFilePart) {
    DWORD Return = 0;
    CHAR* ch;

    //
    // GetFullPath flounders when referring to the root of the drive, so use
    // a private version that handles it
    //
    if ( lpFilename[0] == '\\' ) {

        //  handle network paths
        if ( lpFilename[1] == '\\' ) {
            if ( StringCchCopy(lpBuffer, nBufferLength, lpFilename)!=S_OK ) {
                Return = 0;
            } else {
                // fill in the return data
                ch = strrchr(lpBuffer, '\\');
                ch++;
                lpFilePart = (LPTSTR*)ch;
                Return = strlen(lpBuffer);
            }

        } else {
            Return = GetCurrentDirectory(nBufferLength, lpBuffer);

            // truncate everything after drive name
            if ( (Return!=0) &&  (Return <= MAX_PATH+1)) {
                ch = strchr(lpBuffer, '\\');
                if (ch!=NULL) {
                    *ch = '\0';
                }

                // push in the filename
                if ( StringCchCat(lpBuffer, nBufferLength, lpFilename)!=S_OK ) {
                    Return = 0;
                } else {
                    // fill in the return data
                    ch = strrchr(lpBuffer, '\\');
                    ch++;
                    lpFilePart = (LPTSTR*)ch;
                    Return = strlen(lpBuffer);
                }
            } else {
                // return the needed size
            }
        }
    } else {
        //
        // Not refering to driver root, just call the API
        //
        Return = GetFullPathName(lpFilename, nBufferLength, lpBuffer, lpFilePart);
    }

    return(Return);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\symchk\symchk\dll\symbolcheckapi.c ===
#include "SymbolCheckAPI.h"
#include <malloc.h>
#include <dbhpriv.h>
#include <strsafe.h>

#ifdef SYMCHK_DBG
VOID SymbolCheckDumpModuleInfo(IMAGEHLP_MODULE64 Info64) {
    fprintf(stderr, "------------------------------------\n");
    fprintf(stderr, "Struct size: %d bytes\n", Info64.SizeOfStruct);
    fprintf(stderr, "Base: 0x%p\n",            Info64.BaseOfImage);
    fprintf(stderr, "Image size: %d bytes\n",  Info64.ImageSize);
    fprintf(stderr, "Date: 0x%08x\n",          Info64.TimeDateStamp);
    fprintf(stderr, "Checksum: 0x%08x\n",      Info64.CheckSum);
    fprintf(stderr, "NumSyms: %d\n",           Info64.NumSyms);

    fprintf(stderr, "SymType: ");
    switch (Info64.SymType) {
        case SymNone:
            fprintf(stderr, "SymNone");
            break;
        case SymCoff:
            fprintf(stderr, "SymCoff");
            break;
        case SymCv:
            fprintf(stderr, "SymCV");
            break;
        case SymPdb:
            fprintf(stderr, "SymPDB");
            break;
        case SymExport:
            fprintf(stderr, "SymExport");
            break;
        case SymDeferred:
            fprintf(stderr, "SymDeferred");
            break;
        case SymSym:
            fprintf(stderr, "SymSym");
            break;
        case SymDia:
            fprintf(stderr, "SymDia");
            break;
        case SymVirtual:
            fprintf(stderr, "SymVirtual");
            break;
        default:
            fprintf(stderr, "<unknown>");
            break;
    }
    fprintf(stderr, "\n");

    fprintf(stderr, "ModName: %s\n",           Info64.ModuleName);
    fprintf(stderr, "ImageName: %s\n",         Info64.ImageName);
    fprintf(stderr, "LoadedImage: %s\n",       Info64.LoadedImageName);
    fprintf(stderr, "PDB: \"%s\"\n",           Info64.LoadedPdbName);
    fprintf(stderr, "CV: %c%c%c%c\n",          Info64.CVSig,
                                               Info64.CVSig>>8,
                                               Info64.CVSig>>16,
                                               Info64.CVSig>>24);
    fprintf(stderr, "CV Data: %s\n",           Info64.CVData);
    fprintf(stderr, "PDB Sig:  %x\n",          Info64.PdbSig);
    fprintf(stderr, "PDB7 Sig: %x\n",          Info64.PdbSig70);
    fprintf(stderr, "Age: %x\n",               Info64.PdbAge);
    fprintf(stderr, "PDB Matched:  %s\n",      Info64.PdbUnmatched  ? "FALSE": "TRUE");
    fprintf(stderr, "DBG Matched:  %s\n",      Info64.DbgUnmatched  ? "FALSE": "TRUE");
    fprintf(stderr, "Line nubmers: %s\n",      Info64.LineNumbers   ? "TRUE" : "FALSE");
    fprintf(stderr, "Global syms:  %s\n",      Info64.GlobalSymbols ? "TRUE" : "FALSE");
    fprintf(stderr, "Type Info:    %s\n",      Info64.TypeInfo      ? "TRUE" : "FALSE");

    fprintf(stderr, "------------------------------------\n");
    return;
}
#endif

// local functions
DWORD SymbolCheckEarlyChecks(LPTSTR Filename, SYMBOL_CHECK_DATA* Result);

///////////////////////////////////////////////////////////////////////////////
//
// Given two paths ending in filenames, make sure the filename and extension
// match.
//
BOOL SymbolCheckFilenameMatch(CHAR* Path1, CHAR* Path2) {
    if ( Path1 == NULL || Path2 == NULL ) {
        return(FALSE);
    } else {
        CHAR            drive1[_MAX_DRIVE];
        CHAR            dir1[  _MAX_DIR];
        CHAR            file1[ _MAX_FNAME];
        CHAR            ext1[  _MAX_EXT];
        CHAR            drivedir1[_MAX_DRIVE+_MAX_DIR];
        CHAR            drive2[_MAX_DRIVE];
        CHAR            dir2[  _MAX_DIR];
        CHAR            file2[ _MAX_FNAME];
        CHAR            ext2[  _MAX_EXT];
        CHAR            drivedir2[_MAX_DRIVE+_MAX_DIR];

        _splitpath(Path1, drive1, dir1, file1, ext1);
        _splitpath(Path2, drive2, dir2, file2, ext2);

        if ( _stricmp(ext1, ext2)==0 && _stricmp(file1, file2)==0 ) {
            return(TRUE);
        } else {
            return(FALSE);
        }
    }
}

#ifdef SYMCHK_DBG
///////////////////////////////////////////////////////////////////////////////
//
// THIS IS ONLY HERE WHILE I'M STILL DEBUGGING THIS CODE
//
BOOL CALLBACK SymbolCheckNoisy(HANDLE hProcess,  ULONG ActionCode,  ULONG64 CallbackData,  ULONG64 UserContext) {
    if ( ActionCode==CBA_DEBUG_INFO) {
        fprintf(stderr, "%s", (CHAR*)CallbackData); // cast to avoid PREfast warning
    }
    return(FALSE);
}
#endif

///////////////////////////////////////////////////////////////////////////////
//
// DLL ENTRY POINT - SEE THE HEADER OR DOCS FOR INFO
//
SYMBOL_CHECK_API DWORD SymbolCheckByFilename(LPTSTR             Filename,
                                             LPTSTR             SymbolPath,
                                             DWORD              Options,
                                             SYMBOL_CHECK_DATA* Result) {
    INT     iTempVal;
    DWORD   ReturnValue = 0;
    CHAR    InternalFilename[MAX_SYMPATH];
    CHAR*   InternalSymbolPath = NULL;

    if (Filename==NULL || SymbolPath==NULL || Result==NULL) {
        ReturnValue = SYMBOL_CHECK_RESULT_INVALID_PARAMETER;
    } else {

        ///////////////////////////////////////////////////////////////////////////
        //
        // vaild provided parameters
        //
        ///////////////////////////////////////////////////////////////////////////
        _try {
            //
            // try to ensure the incoming Filename is okay, then make
            // a local copy to work with
            //
            iTempVal = strlen(Filename);

            if ( iTempVal < 1 || iTempVal > MAX_SYMPATH ) {
                ReturnValue = SYMBOL_CHECK_RESULT_INVALID_PARAMETER;
                __leave;
            }

           if (StringCchCopy(InternalFilename, sizeof(InternalFilename), Filename)!=S_OK) {
                ReturnValue = SYMBOL_CHECK_INTERNAL_FAILURE;
                __leave;
            }

            //
            // try to ensure the incoming SymbolPath is okay, then make
            // a local copy to work with
            //
            iTempVal = strlen(SymbolPath);

            InternalSymbolPath = (CHAR*)malloc(sizeof(CHAR)*(iTempVal+1));

            if ( InternalSymbolPath==NULL ) {
                ReturnValue = SYMBOL_CHECK_INTERNAL_FAILURE;
                __leave;
            }

            if (StringCchCopy(InternalSymbolPath, _msize(InternalSymbolPath), SymbolPath)!=S_OK) {
                ReturnValue = SYMBOL_CHECK_INTERNAL_FAILURE;
                __leave;
            }

            //
            // Goes inside the _try to ensure we can write to it
            //
            ZeroMemory(Result, sizeof(SYMBOL_CHECK_DATA));
            Result->SymbolCheckVersion = SYMBOL_CHECK_CURRENT_VERSION;


        } _except (EXCEPTION_EXECUTE_HANDLER) {
            ReturnValue = SYMBOL_CHECK_RESULT_INVALID_PARAMETER;
        }
    }

    ///////////////////////////////////////////////////////////////////////////
    //
    // Check conditions that cause early return.  If result is 0, some file
    // characteristics are put into Result->Result for later use.  See the
    // function definition for more information.
    //
    ///////////////////////////////////////////////////////////////////////////
    ReturnValue = SymbolCheckEarlyChecks(Filename, Result);

    ///////////////////////////////////////////////////////////////////////////
    //
    // If our sanity checks passed, start talking to DBGHELP
    // Currently, this just gets us our DBG and PDB filenames, some day, it'll
    // provide all of the information we need =-)
    //
    ///////////////////////////////////////////////////////////////////////////
    if ( ReturnValue==0 ) {

        HANDLE              hProc = GetCurrentProcess();
        IMAGEHLP_MODULE64   ModuleInfo;
        CHAR                DebugFile[MAX_SYMPATH] = {0};
        DWORD               i;
        DWORD64             dw64Status = 0;
        LPTSTR              FilenameOnly;


        ZeroMemory(&ModuleInfo, sizeof(ModuleInfo));
        ModuleInfo.SizeOfStruct = sizeof(ModuleInfo);

        if (! SymInitialize(hProc, InternalSymbolPath, FALSE) ) {
            ReturnValue    = SYMBOL_CHECK_CANT_INIT_DBGHELP;
            Result->Result = GetLastError();
        } else {

            // symbol loading options:
            dw64Status = SymSetOptions((SYMOPT_IGNORE_NT_SYMPATH|    // ignore _NT_SYMBOL_PATH
                                        SYMOPT_FAIL_CRITICAL_ERRORS| // no dialogs for crit. errors
                                        SYMOPT_IGNORE_CVREC));       // ignore path info in PDB header

#ifdef SYMCHK_DBG
            if ( Options & SYMBOL_CHECK_NOISY ) {
                if ( SymRegisterCallback64(hProc, &SymbolCheckNoisy, NULL) ) {
                    dw64Status = SymSetOptions( (DWORD)dw64Status | SYMOPT_DEBUG );
                }
            }
#endif
            dw64Status = SymLoadModule64(hProc, NULL, InternalFilename, NULL, 0, 0);

            if ( dw64Status==0 ) {
                //
                // GetLastError()==ERROR_FILE_NOT_FOUND (2) if debug file not found
                // GetLastError()==ERROR_PATH_NOT_FOUND (3) if binary not found
                // GetLastError()==ERROR_BAD_FORMAT    (11) is 16-bit binary
                //
                //      "IGNORED - Image does not have an NT header"
                ReturnValue    = SYMBOL_CHECK_CANT_LOAD_MODULE;
                Result->Result = GetLastError();
            } else {

                if (! SymGetModuleInfo64(hProc, dw64Status, &ModuleInfo) ) {
                    // fprintf(stderr, "[SYMBOLCHECK] GetModuleInfo64 failed with error code %d\n", GetLastError());
                    ReturnValue    = SYMBOL_CHECK_CANT_QUERY_DBGHELP;
                    Result->Result = GetLastError();
                } else {
                    //
                    // get the *.pdb info.  Currently, we use private functions, but this will
                    // eventually get replaced with DbgHelp APIs once they're written
                    //

#ifdef SYMCHK_DBG
                    SymbolCheckDumpModuleInfo(ModuleInfo);
#endif

                    if ( ModuleInfo.LineNumbers ) {
                        SET_DWORD_BIT(Result->Result, SYMBOL_CHECK_PDB_LINEINFO);
                        SET_DWORD_BIT(Result->Result, SYMBOL_CHECK_PDB_PRIVATEINFO);
                    }

                    if ( ModuleInfo.GlobalSymbols ) {
                        SET_DWORD_BIT(Result->Result, SYMBOL_CHECK_PDB_PRIVATEINFO);
                    }

                    if ( ModuleInfo.TypeInfo ) {
                        SET_DWORD_BIT(Result->Result, SYMBOL_CHECK_PDB_TYPEINFO);
                    }

                    if ( ModuleInfo.SymType==SymNone ) {
                        CHAR drive[_MAX_DRIVE];
                        CHAR dir[  _MAX_DIR];
                        CHAR file[ _MAX_FNAME];
                        CHAR ext[  _MAX_EXT];

                        _splitpath(ModuleInfo.LoadedImageName, drive, dir, file, ext);

                        if (!( StringCchCopy(Result->PdbFilename, MAX_SYMPATH, file)   == S_OK &&
                               StringCchCat( Result->PdbFilename, MAX_SYMPATH, ".pdb") == S_OK) ) {
                            Result->PdbFilename[0] = '\0';
                        }

                        if (!( StringCchCopy(Result->DbgFilename, MAX_SYMPATH, file)   == S_OK &&
                               StringCchCat( Result->DbgFilename, MAX_SYMPATH, ".dbg") == S_OK) ) {
                            Result->DbgFilename[0] = '\0';
                        }

                    } else {
                        Result->PdbFilename[0] = '\0';

                        switch (ModuleInfo.CVSig) {
                            case 'SDSR':
                                SET_DWORD_BIT(Result->Result, SYMBOL_CHECK_CV_FOUND);
                                SET_DWORD_BIT(Result->Result, SYMBOL_CHECK_PDB_EXPECTED);
                                break;

                            case '01BN':
                                SET_DWORD_BIT(Result->Result, SYMBOL_CHECK_CV_FOUND);
                                SET_DWORD_BIT(Result->Result, SYMBOL_CHECK_PDB_EXPECTED);
                                break;

                            default:
                                break;
                        }

                        if ( CHECK_DWORD_BIT(Result->Result, SYMBOL_CHECK_PDB_EXPECTED) ) {
                            if ( ModuleInfo.LoadedPdbName[0] != '\0') {
                                SET_DWORD_BIT(Result->Result, SYMBOL_CHECK_PDB_FOUND);

                                Result->PdbDbiAge    = ModuleInfo.PdbAge;
                                Result->PdbSignature = ModuleInfo.PdbSig;
                           }
                        }

                        if ( CHECK_DWORD_BIT(Result->Result, SYMBOL_CHECK_DBG_EXPECTED) ) {
                            CHAR drive[_MAX_DRIVE];
                            CHAR dir[  _MAX_DIR];
                            CHAR file[ _MAX_FNAME];
                            CHAR ext[  _MAX_EXT];

                            _splitpath(ModuleInfo.LoadedImageName, drive, dir, file, ext);

                            //
                            // Found the DBG we wanted
                            //
                            if ( _stricmp( ".dbg", ext ) == 0 ) {
                                SET_DWORD_BIT(Result->Result, SYMBOL_CHECK_DBG_FOUND);
                                SymCommonGetFullPathName(ModuleInfo.LoadedImageName, MAX_SYMPATH, Result->DbgFilename, &FilenameOnly);

                            //
                            // Drop an approximated DBG name
                            //
                            } else {
                                if (!( StringCchCopy(Result->DbgFilename, MAX_SYMPATH, file)   == S_OK &&
                                       StringCchCat( Result->DbgFilename, MAX_SYMPATH, ".dbg") == S_OK) ) {
                                    Result->DbgFilename[0] = '\0';
                                }
                            }
                        }

                        SymCommonGetFullPathName(ModuleInfo.LoadedPdbName,   MAX_SYMPATH, Result->PdbFilename, &FilenameOnly);
                        Result->DbgSizeOfImage   = ModuleInfo.ImageSize;
                        Result->DbgTimeDateStamp = ModuleInfo.TimeDateStamp;
                        Result->DbgChecksum      = ModuleInfo.CheckSum;
                    }

                    if ( CHECK_DWORD_BIT(Result->Result, SYMBOL_CHECK_PDB_EXPECTED) &&
                        !CHECK_DWORD_BIT(Result->Result, SYMBOL_CHECK_PDB_FOUND)) {

                        switch (ModuleInfo.CVSig) {
                            case 'SDSR':
                                if ( StringCchCopy(Result->PdbFilename, MAX_SYMPATH, ModuleInfo.CVData) != S_OK) {
                                    Result->PdbFilename[0] = '\0';
                                }
                                break;

                            case '01BN':
                                if ( StringCchCopy(Result->PdbFilename, MAX_SYMPATH, ModuleInfo.CVData) != S_OK ) {
                                    Result->PdbFilename[0] = '\0';
                                }
                                break;

                            default:
                                if ( StringCchCopy(Result->PdbFilename, MAX_SYMPATH, "<unknown>") != S_OK ) {
                                    Result->PdbFilename[0] = '\0';
                                }
                                break;
                        }
                    }

                }

                ///////////////////////////////////////////////////////////////////////////
                //
                // calls to new symbol query API go here...
                //
                ///////////////////////////////////////////////////////////////////////////
                if (! SymUnloadModule64(hProc, ModuleInfo.BaseOfImage) ) {
                    ReturnValue    = SYMBOL_CHECK_CANT_UNLOAD_MODULE;
                    Result->Result = GetLastError();
                }
            }

            if (! SymCleanup(hProc) ) {
                ReturnValue    = SYMBOL_CHECK_CANT_CLEANUP;
                Result->Result = GetLastError();
            }
        }
    }

    if ( InternalSymbolPath!=NULL ) {
        free(InternalSymbolPath);
    }
    return(ReturnValue);
}


///////////////////////////////////////////////////////////////////////////////
//
// Performs only-out checks and/or gathers some info for future use.
// Return values can be:
//      SYMBOL_CHECK_HEADER_NOT_ON_LONG_BOUNDARY
//      SYMBOL_CHECK_FILEINFO_QUERY_FAILED
//      SYMBOL_CHECK_IMAGE_LARGER_THAN_FILE
//      SYMBOL_CHECK_RESOURCE_ONLY_DLL
//      SYMBOL_CHECK_TLBIMP_MANAGED_DLL
//      SYMBOL_CHECK_NOT_NT_IMAGE
//      SYMBOL_CHECK_NO_DOS_HEADER
//  in which case we won't check the binary or
//      0
//  in which case this function may also set the following bits in Result->Result:
//      SYMBOL_CHECK_DBG_EXPECTED
//      SYMBOL_CHECK_DBG_SPLIT
//      SYMBOL_CHECK_CV_FOUND
//      SYMBOL_CHECK_PDB_EXPECTED
//      SYMBOL_CHECK_DBG_IN_BINARY
//
DWORD SymbolCheckEarlyChecks(LPTSTR Filename, SYMBOL_CHECK_DATA* Result) {
    DWORD                           ReturnValue = 0;
    BY_HANDLE_FILE_INFORMATION      HandleFileInfo;
    DWORD                           dwTempVal;
    HANDLE                          hFile;
    PIMAGE_DOS_HEADER               pDosHeader;
    PIMAGE_NT_HEADERS               pNtHeader;
    PCVDD                           pCVData;

    // Get the DOS header for this image
    if ( (pDosHeader=SymCommonMapFileHeader(Filename, &hFile, &dwTempVal))!=NULL ) {
        // Get the PE header for this image
        if ( ((ULONG)(pDosHeader->e_lfanew) & 3) != 0) {
            // The image header is not aligned on an 8-byte boundary, thus
            // it's not a valid PE header
            ReturnValue = SYMBOL_CHECK_HEADER_NOT_ON_LONG_BOUNDARY;
        } else if (!GetFileInformationByHandle( hFile, &HandleFileInfo)) {
            // Function must pass to do validation
            ReturnValue = SYMBOL_CHECK_FILEINFO_QUERY_FAILED;
        } else if ((ULONG)(pDosHeader->e_lfanew) > HandleFileInfo.nFileSizeLow) {
            // Indicator that this isn't really a PE header pointer
            ReturnValue = SYMBOL_CHECK_IMAGE_LARGER_THAN_FILE;
        } else {
            pNtHeader = (PIMAGE_NT_HEADERS)((PCHAR)(pDosHeader) + (ULONG)(pDosHeader)->e_lfanew);
            if ((pNtHeader)->Signature == IMAGE_NT_SIGNATURE) {
                // PE signature is IMAGE_NT_SIGNATURE ('PE\0\0') - image good

                // Is it a resource only DLL?
                if ( SymCommonResourceOnlyDll((PVOID)pDosHeader) ) {
                    ReturnValue = SYMBOL_CHECK_RESOURCE_ONLY_DLL;
                } else {
                    // Is it a tlbimp managed DLL?
                    if ( SymCommonTlbImpManagedDll((PVOID)pDosHeader, pNtHeader) ) {
                        ReturnValue = SYMBOL_CHECK_TLBIMP_MANAGED_DLL;
                    } else {
                        // We know now that we have a valid PE binary that we're actually going
                        // to check, so gather a little more info to use later.
                        DWORD i;
                        DWORD DirCount = 0;
                        IMAGE_DEBUG_DIRECTORY UNALIGNED *DebugDirectory = SymCommonGetDebugDirectoryInExe(pDosHeader, &DirCount);
                        IMAGE_DEBUG_DIRECTORY UNALIGNED *pDbgDir=NULL;

                        if ( DirCount == 0 ) {
                            Result->Result |= SYMBOL_CHECK_NO_DEBUG_DIRS_IN_EXE;
                        }

                        if (pNtHeader->FileHeader.Characteristics & IMAGE_FILE_DEBUG_STRIPPED) {
                            Result->Result |= SYMBOL_CHECK_DBG_EXPECTED;
                            Result->Result |= SYMBOL_CHECK_DBG_SPLIT;
                            // we don't know where the DBG is yet, so these checks come later
                        } else {

                            pCVData = SymCommonDosHeaderToCVDD(pDosHeader);

                            if (pCVData != NULL ) {
                                CHAR* chTemp;
                                BOOL   Misc  = FALSE;
                                BOOL   Other = FALSE;

                                Result->Result |= SYMBOL_CHECK_CV_FOUND;

                                switch (pCVData->dwSig) {
                                    case '01BN':
                                        Result->Result |= SYMBOL_CHECK_PDB_EXPECTED;
                                        // for VC6.0 this doesn't imply DBG data, but for VC5.0 it does,
                                        // check which we have.  SplitSym doesn't more checking then this,
                                        // but it looks like it goes overboard.
                                        if ( ((IMAGE_OPTIONAL_HEADER)((pNtHeader)->OptionalHeader)).MajorLinkerVersion == 5 ) {
                                            if ( DebugDirectory != NULL ) {

                                                for ( i=0; i<DirCount; i++) {
                                                    pDbgDir = DebugDirectory + i;
                                                    switch (pDbgDir->Type) {
                                                        case IMAGE_DEBUG_TYPE_CODEVIEW:
                                                             break;

                                                        case IMAGE_DEBUG_TYPE_MISC:
                                                            Misc = TRUE;
                                                            break;

                                                        default:
                                                            Other = TRUE;
                                                            break;
                                                    }
                                                }
                                            }
                                        }

                                        if ( Misc ) {
                                            Result->Result |= SYMBOL_CHECK_DBG_EXPECTED;
                                            Result->Result |= SYMBOL_CHECK_DBG_IN_BINARY;
                                        }

                                        break;

                                    case 'SDSR':
                                        Result->Result |= SYMBOL_CHECK_PDB_EXPECTED;
                                        break;

                                    case '05BN':
                                    case '90BN':
                                    case '11BN':
                                        Result->Result |= SYMBOL_CHECK_DBG_IN_BINARY;
                                        Result->Result |= SYMBOL_CHECK_DBG_EXPECTED;
                                        break;

                                    default:
                                        break;
                                }
                            }
                        }
                    }
                }
            } else {
                ReturnValue = SYMBOL_CHECK_NOT_NT_IMAGE;
            }
        }

        SymCommonUnmapFile(pDosHeader, hFile);

    } else { // pDosHeader==NULL
        ReturnValue = SYMBOL_CHECK_NO_DOS_HEADER;
    }

    return(ReturnValue);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\symchk\symchk\dll\symbolcheckapi.h ===
#include "SymCommon.h"

//@@BEGIN_SYMCHK_SPLIT
//
// Allow internal token to determine if we're building the DLL.
// Split the token before publishing so we don't mess up someone
// else's code.
//
#ifdef BUILDING_DLL

#define SYMBOL_CHECK_API __declspec( dllexport )
#define SYMBOL_CHECK_NOISY              0x40000000
#define SYMBOL_CHECK_NO_BIN_CHECK       0x10000000
// Just some handy macros
#define SET_DWORD_BIT(  dw, b)  dw |= b
#define CLEAR_DWORD_BIT(dw, b)  dw &= (~b)
#define CHECK_DWORD_BIT(dw, b)  (dw&b)

#else
//@@END_SYMCHK_SPLIT
#define SYMBOL_CHECK_API __declspec( dllimport )

//@@BEGIN_SYMCHK_SPLIT
#endif
//@@END_SYMCHK_SPLIT

#define SYMBOL_CHECK_CURRENT_VERSION         0x00000001
#define MAX_SYMPATH                          MAX_PATH

///////////////////////////////////////////////////////////////////////////////
//
// Flags for SymbolCheckData.Results when SymbolCheckBy* returns success
//
//  _________ _________ _________ _________
// |         |         |         |         |
// |RESERVED |PDB INFO |DBG INFO |MISC INFO|
// |_________|_________|_________|_________|
// bit 31                             bit 0
//
//

// MISC bits 0-7
#define SYMBOL_CHECK_CV_FOUND                0x00000001 // CodeView found
#define SYMBOL_CHECK_NO_DEBUG_DIRS_IN_EXE    0x00000002 // no debug dirs in exe
// reserved 0x000000FE

//
// DBG bits 8-15
//
#define SYMBOL_CHECK_DBG_EXPECTED            0x00000100 // sig implies .DBG
#define SYMBOL_CHECK_DBG_SPLIT               0x00000200 // DBG is split from bin
#define SYMBOL_CHECK_DBG_FOUND               0x00000400 // found the .DBG
#define SYMBOL_CHECK_DBG_IN_BINARY           0x00000800 // image not split
#define SYMBOL_CHECK_NO_MISC_DATA            0x00001000 // can't get DBG info
// reserved 0x0000E000

//
// PDB bits 16-23
//
#define SYMBOL_CHECK_PDB_EXPECTED            0x00010000 // sig implies PDB
#define SYMBOL_CHECK_PDB_FOUND               0x00020000 // found the .PDB
#define SYMBOL_CHECK_PDB_PRIVATEINFO         0x00040000 // PDB contain private info
#define SYMBOL_CHECK_PDB_LINEINFO            0x00080000 // PDB has line number info
#define SYMBOL_CHECK_PDB_TYPEINFO            0x00100000 // PDB has type info
#define SYMBOL_CHECK_EXTRA_RAW_DATA          0x00200000 // more info than expected in PDB
// reserved 0x00E00000


///////////////////////////////////////////////////////////////////////////////
//
//
//  Return values for SymbolCheckBy*
//
//

// returns that cause SymbolCheckBy* to not attempt to check the file given
#define SYMBOL_CHECK_NO_DOS_HEADER                0x40000001 // file isn't a binary
#define SYMBOL_CHECK_HEADER_NOT_ON_LONG_BOUNDARY  0x40000002 // Given file isn't a valid PE binary
#define SYMBOL_CHECK_FILEINFO_QUERY_FAILED        0x40000003 // implies file isn't a valid PE binary
#define SYMBOL_CHECK_IMAGE_LARGER_THAN_FILE       0x40000004 // implies file isn't a valid PE binary
#define SYMBOL_CHECK_NOT_NT_IMAGE                 0x40000005 // Given file isn't a valid PE binary
#define SYMBOL_CHECK_RESOURCE_ONLY_DLL            0x40000007 // binary is a resource only DLL
#define SYMBOL_CHECK_TLBIMP_MANAGED_DLL           0x40000008 // binary is a managed wrapper dll for a typelib

// returns resulting from invocation or internal errors - SymbolCheck results are unreliable if these occur
#define SYMBOL_CHECK_RESULT_INVALID_PARAMETER     0x80000001 // ome (or more) parameters were invalid
#define SYMBOL_CHECK_RESULT_FILE_DOESNT_EXIST     0x80000002 // file doesn't exist
#define SYMBOL_CHECK_CANT_INIT_DBGHELP            0x80000003 // Result->Result contains the result of GetLastError()
#define SYMBOL_CHECK_CANT_LOAD_MODULE             0x80000004 // Result->Result contains the result of GetLastError()
#define SYMBOL_CHECK_CANT_QUERY_DBGHELP           0x80000005 // Result->Result contains the result of GetLastError()
#define SYMBOL_CHECK_CANT_UNLOAD_MODULE           0x80000006 // Result->Result contains the result of GetLastError()
#define SYMBOL_CHECK_CANT_CLEANUP                 0x80000007 // Result->Result contains the result of GetLastError()
#define SYMBOL_CHECK_INTERNAL_FAILURE             0x80000100 // any other error
//
// All others reserved
//

///////////////////////////////////////////////////////////////////////////////
//
// structure returned by SymbolCheckByFilename
//
typedef struct _SYMBOL_CHECK_DATA {
    DWORD   SymbolCheckVersion;         // version of SymbolCheck used
    DWORD   Result;                     // summary of check results.  See SYMBOL_CHECK_SUMMARY_* flags above
    CHAR    DbgFilename[MAX_SYMPATH];   // full path and filename for DBG file or empty string
    DWORD   DbgTimeDateStamp;           // time-date stamp of DBG file or 0
    DWORD   DbgSizeOfImage;             // size of DBG file or 0
    DWORD   DbgChecksum;                // checksum of DBG file or 0
    CHAR    PdbFilename[MAX_SYMPATH];   // full path and filename for PDB file or empty string
    DWORD   PdbSignature;               // signature of PDB file of 0
    DWORD   PdbDbiAge;                  // DBI Age of PDB file of 0
} SYMBOL_CHECK_DATA, *PSYMBOL_CHECK_DATA;

///////////////////////////////////////////////////////////////////////////////
//
// DLL Entry points
//
SYMBOL_CHECK_API
DWORD SymbolCheckByFilename(IN  LPTSTR             Filename,   // IN file to check
                            IN  LPTSTR             SymbolPath, // IN symbols path to use
                            IN  DWORD              Options,    // RESERVED - not currently used
                            OUT SYMBOL_CHECK_DATA* Result);    // struct must be pre-allocated and
                                                               // writable by SymbolCheckByFilename
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\symchk\symchk\exe\attach.cpp ===
#include <windows.h>
#include <dbgeng.h>
#include <tchar.h>
#include <dbghelp.h>
#include "Common.h"


#define MAX_SYM_ERR     (MAX_PATH*9)
#define INTERNAL_ERROR  0x20000008

IDebugClient*   g_Client;
IDebugControl*  g_Control;
IDebugSymbols2* g_Symbols;

// Local funcitons
BOOL SymChkCreateInterfaces(DWORD* ErrorLevel);
BOOL SymChkGetDir(LPTSTR Path, LPTSTR DirOnly);
BOOL SymChkGetFileName(LPTSTR Path, LPTSTR FileName);
BOOL SymChkProcessAttach(DWORD ProcessId, LPTSTR SymbolPath, DWORD* ErrorLevel);
void SymChkReleaseInterfaces(void);

#define PROCESS_NOT_FOUND 0xDEADBEEF

/////////////////////////////////////////////////////////////////////////////// 
//
// Creates the required debug interfaces
//
// Return values:
//  TRUE if interfaces were create
//  FALSE otherwise
//
// Parameters:
//  ErrorLevel (OUT) - on failure, contains the internal fault code
//
BOOL SymChkCreateInterfaces(DWORD* ErrorLevel) {
    HRESULT Status;
    BOOL    ReturnValue = TRUE;

    // Start things off by getting an initial interface from
    // the engine.  This can be any engine interface but is
    // generally IDebugClient as the client interface is
    // where sessions are started.
    if ((Status = DebugCreate(__uuidof(IDebugClient), (void**)&g_Client)) != S_OK) {
        *ErrorLevel = INTERNAL_ERROR;
        ReturnValue = FALSE;

    // Query for some other interfaces that we'll need.
    } else if ((Status = g_Client->QueryInterface(__uuidof(IDebugControl),  (void**)&g_Control)) != S_OK ||
        (Status = g_Client->QueryInterface(__uuidof(IDebugSymbols2), (void**)&g_Symbols)) != S_OK) {
        *ErrorLevel = INTERNAL_ERROR;
        ReturnValue = FALSE;
    }
    return(ReturnValue);
}

/////////////////////////////////////////////////////////////////////////////// 
//
// Assumes that Path ends in a file name and that DirOnly is _MAX_PATH
// characters long.
//
// Return values:
//  TRUE  if the dir was gotten
//  FALSE otherwise
//
// Parameters:
//   IN Path      MAX_PATH buffer that contains a dir and file name.
//   OUT DirOnly  MAX_PATH buffer that contains only the DIr.
//
BOOL SymChkGetDir(LPTSTR Path, LPTSTR DirOnly) {
    LONG i;
    BOOL ReturnValue = FALSE;

    if ( StringCchCopy(DirOnly, _MAX_PATH, Path ) == S_OK ) {
        i = strlen(DirOnly)-1;

        while ( i>0 && *(DirOnly+i) != '\\' ) {
            i--;
        }
        *(DirOnly+i) = '\0';
        ReturnValue = TRUE;
    }
    
    return(ReturnValue);
}

/////////////////////////////////////////////////////////////////////////////// 
//
// copies just the filename from Path intp Filename
//
// Return Value:
//  TRUE  if the filename was successfully copied into Filename
//  FALSE otherwise
//
// Paramters:
//  IN Path         MAX_PATH buffer that a file name that may or may not be
//                  preceded with a path.
//  OUT FileName    MAX_PATH buffer that contains only the FileName
//
BOOL SymChkGetFileName(LPTSTR Path, LPTSTR Filename) {
    LONG i;
    BOOL ReturnValue = FALSE;

    i = strlen( Path )-1;

    while ( i>0 && *(Path+i) != '\\' ) {
        i--;
    }

    if ( *(Path+i) ==  '\\' ) {
        if ( StringCchCopy(Filename, _MAX_PATH, Path+1+i ) == S_OK ) {
            ReturnValue = TRUE;
        }

    } else {
        // There were no backslashes, so copy the whole path
        if ( StringCchCopy(Filename, _MAX_PATH, Path ) == S_OK ) {
            ReturnValue = TRUE;
        }
    }
    return (ReturnValue);
}

/////////////////////////////////////////////////////////////////////////////// 
//
// Attaches to a process, finds the modules in use and calls SymChkCheckFiles()
// for each of those modules
//
// Return values:
//      status value:
//
// Parameters:
//      SymChkData (IN) a structure that defines what kind of checking to
//                      do and what process to check
//      FileCounts (OUT) counts for passed/failed/ignored files
//
DWORD SymChkGetSymbolsForProcess(SYMCHK_DATA* SymChkData, FILE_COUNTS* FileCounts) {
    DWORD  Error = SYMCHK_ERROR_SUCCESS;
    DEBUG_MODULE_PARAMETERS Params;
    ULONG  Loaded, i;
    ULONG  Unloaded;
    CHAR   SymbolBuf[_MAX_PATH];
    CHAR   NameBuf[_MAX_PATH];
    CHAR   ExeDir[_MAX_PATH];
    CHAR   SymPathDir[_MAX_PATH];
    CHAR   FileName[_MAX_PATH];
    ULONG  NameSize, SymbolSize;
    DWORD  pId    = 0xBADBADBA;
    DWORD  ErrLvl = 0;

    if ( !SymChkCreateInterfaces(&ErrLvl) ) {
        return(ErrLvl);
    }

    if (SymChkData->InputPID == 0 ) {
        if ( g_Client->GetRunningProcessSystemIdByExecutableName(0, SymChkData->InputFileName, DEBUG_GET_PROC_DEFAULT, &pId ) != S_OK ) {
            pId = 0;
            printf("SYMCHK: Process \"%s\" wasn't found\n", SymChkData->InputFileName);
            return(PROCESS_NOT_FOUND);
        }
    } else {
        pId = SymChkData->InputPID;
    }

    if (!SymChkProcessAttach(pId, SymChkData->SymbolsPath, &Error)) {
        printf("SYMCHK: Process ID %d wasn't found\n", pId);

        SymChkReleaseInterfaces();
        return(PROCESS_NOT_FOUND);
    }

    g_Symbols->RemoveSymbolOptions(SYMOPT_DEFERRED_LOADS);
    g_Symbols->GetNumberModules( &Loaded, &Unloaded ); 

    for ( i=0; i< Loaded; i++ ) {
        SymbolBuf[0] = '\0';
        NameBuf[0]   = '\0';

        g_Symbols->GetModuleParameters( 1, NULL, i, &Params );
        g_Symbols->GetModuleNameString(
                       DEBUG_MODNAME_IMAGE,
                       i,
                       Params.Base,
                       NameBuf,
                       _MAX_PATH,
                       &NameSize );
        g_Symbols->GetModuleNameString( 
                       DEBUG_MODNAME_SYMBOL_FILE,
                       i,
                       Params.Base,
                       SymbolBuf,
                       _MAX_PATH,
                       &SymbolSize );

        // Call symbol checking with the exe and its symbol

        if ( ! SymChkGetDir(NameBuf, ExeDir) ) {
            if ( CHECK_DWORD_BIT(SymChkData->OutputOptions, SYMCHK_OPTION_OUTPUT_VERBOSE)) {
                fprintf(stderr, "[SYMCHK] Couldn't get filename (209)\n");
            }
            SymChkReleaseInterfaces();
            continue;
        }

        if (! SymChkGetFileName(NameBuf, FileName) ) {
            if ( CHECK_DWORD_BIT(SymChkData->OutputOptions, SYMCHK_OPTION_OUTPUT_VERBOSE)) {
                fprintf(stderr, "[SYMCHK] Couldn't get filename (218)\n");
            }
            SymChkReleaseInterfaces();
            continue;
        }

        if ( ! SymChkGetDir(SymbolBuf, SymPathDir) ) {
            if ( CHECK_DWORD_BIT(SymChkData->OutputOptions, SYMCHK_OPTION_OUTPUT_VERBOSE)) {
                fprintf(stderr, "[SYMCHK] Couldn't get filename (221)\n");
            }
            continue;
        }

        if ( CHECK_DWORD_BIT(SymChkData->OutputOptions, SYMCHK_OPTION_OUTPUT_VERBOSE)) {
            if ( CHECK_DWORD_BIT(SymChkData->OutputOptions, SYMCHK_OPTION_OUTPUT_VERBOSE)) {
                fprintf(stderr, "[SYMCHK] Checking: %s\n", NameBuf); 
            }
        }
        if ( StringCchCopy(SymChkData->InputFileName, MAX_PATH, NameBuf) == S_OK ) {
            SymChkCheckFiles(SymChkData, FileCounts);
        } else {
            printf("SYMCHK: Internal error checking %s\n", NameBuf);
        }
    } 

    SymChkReleaseInterfaces();

    return(Error);
}

/////////////////////////////////////////////////////////////////////////////// 
//
// Cleans up the required debug interfaces
//
// Return values:
//  TRUE  - we attached to the process
//  FALSE - couldn't attach to the process
//
// Parameters:
//  ProcessId   (IN)  - PID of the process to attach to
//  SymbolPath  (IN)  - path to search for symbols in OPTIONAL
//  *ErrorLevel (OUT) - on failure, contains an error code
//
BOOL SymChkProcessAttach(DWORD ProcessId, LPTSTR SymbolPath, DWORD* ErrorLevel) {
    HRESULT Status;
    BOOL    ReturnValue = TRUE;
    *ErrorLevel = 0;

    // Don't set the output callbacks yet as we don't want
    // to see any of the initial debugger output.
    if (SymbolPath != NULL) {
        if ((Status = g_Symbols->SetSymbolPath(SymbolPath)) != S_OK) {
            ReturnValue = FALSE;
        }
    }

    if ( ReturnValue==TRUE ) {
        // Everything's set up so do the attach. This suspends the process so it's not so
        // rude as to exit while we're trying to get it's symbols.
        if ((Status = g_Client->AttachProcess(0, ProcessId, DEBUG_ATTACH_NONINVASIVE)) != S_OK) {
            *ErrorLevel = INTERNAL_ERROR;
            ReturnValue = FALSE;

        // Finish initialization by waiting for the attach event.
        // This should return quickly as a non-invasive attach
        // can complete immediately.
        } else if ((Status = g_Control->WaitForEvent(DEBUG_WAIT_DEFAULT, INFINITE)) != S_OK) {
            *ErrorLevel = INTERNAL_ERROR;
            ReturnValue = FALSE;
        }
    }

    // Everything is now initialized and we can make any
    // queries we want.
    return(ReturnValue);
}

/////////////////////////////////////////////////////////////////////////////// 
//
// Cleans up the required debug interfaces
//
// Return values: (NONE)
//
// Parameters: (NONE)
//
void SymChkReleaseInterfaces(void) {
    __try { // this is AVing, temporarily wrap it in a _try
            // until I find the exact cause of the error
        if (g_Symbols != NULL) {
            g_Symbols->Release();
        }
        if (g_Control != NULL) {
            g_Control->Release();
        }
        if (g_Client != NULL) {
            // Request a simple end to any current session.
            // This may or may not do anything but it isn't
            // harmful to call it.
    
            // We don't want to see any output from the shutdown.
            g_Client->SetOutputCallbacks(NULL);
            //  currently, and active detach will cause an invalid handle exception
            // when running under app verifier.  This is a bug in dbgeng that's
            // being fixed.
            g_Client->EndSession(DEBUG_END_ACTIVE_DETACH);
            g_Client->Release();
        }
    } _except (EXCEPTION_EXECUTE_HANDLER) {
        // nothing to do
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\symchk\symchk\exe\de_utils.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// This file contains all of the SymChk code that relies on dbgeng.dll
//
#include <windows.h>
#include <dbgeng.h>
#include <dbghelp.h>
#include "Common.h"

#define INTERNAL_ERROR    0x20000008
#define PROCESS_NOT_FOUND 0xDEADBEEF

typedef struct _SYMCHK_INTERFACES {
    IDebugClient*   Client;
    IDebugControl*  Control;
    IDebugSymbols2* Symbols;
} SYMCHK_INTERFACES;

// Local funcitons
BOOL  SymChkCreateInterfaces(SYMCHK_INTERFACES*  Interfaces, DWORD* ErrorLevel);
BOOL  SymChkProcessAttach(SYMCHK_INTERFACES*  Interfaces, DWORD ProcessId, LPTSTR SymbolPath, DWORD Options, DWORD* ErrorLevel);
void  SymChkReleaseInterfaces(SYMCHK_INTERFACES* Interfaces);

/////////////////////////////////////////////////////////////////////////////// 
//
// Creates the required debug interfaces
//
// Return values:
//  TRUE if interfaces were create
//  FALSE otherwise
//
// Parameters:
//  Interfaces (INOUT) - Interfaces to create
//  ErrorLevel (OUT) - on failure, contains the internal fault code
//
BOOL SymChkCreateInterfaces(SYMCHK_INTERFACES* Interfaces, DWORD* ErrorLevel) {
    HRESULT Status;
    BOOL    ReturnValue = TRUE;

    // Start things off by getting an initial interface from
    // the engine.  This can be any engine interface but is
    // generally IDebugClient as the client interface is
    // where sessions are started.
    if ((Status = DebugCreate(__uuidof(IDebugClient), (void**)&(Interfaces->Client))) != S_OK) {
        *ErrorLevel = INTERNAL_ERROR;
        ReturnValue = FALSE;

    // Query for some other interfaces that we'll need.
    } else if ((Status = (Interfaces->Client)->QueryInterface(__uuidof(IDebugControl),  (void**)&(Interfaces->Control))) != S_OK ||
        (Status = (Interfaces->Client)->QueryInterface(__uuidof(IDebugSymbols2), (void**)&(Interfaces->Symbols))) != S_OK) {
        *ErrorLevel = INTERNAL_ERROR;
        ReturnValue = FALSE;
    }
    return(ReturnValue);
}

/////////////////////////////////////////////////////////////////////////////// 
//
// Attaches to a process, finds the modules in use and calls SymChkCheckFiles()
// for each of those modules
//
// Return values:
//      status value:
//
// Parameters:
//      SymChkData (IN) a structure that defines what kind of checking to
//                      do and what process to check
//      FileCounts (OUT) counts for passed/failed/ignored files
//
DWORD SymChkGetSymbolsForDump(SYMCHK_DATA* SymChkData, FILE_COUNTS* FileCounts) {
    ULONG                   i        = 0;
    ULONG                   Loaded   = 0;
    ULONG                   Unloaded = 0;
    SYMCHK_INTERFACES       Interfaces;
    DEBUG_MODULE_PARAMETERS Params;
    DWORD                   Error    = SYMCHK_ERROR_SUCCESS;
    DWORD                   ErrLvl   = 0;
    CHAR                    NameBuf[_MAX_PATH];
    CHAR                    FullNameBuf[MAX_PATH+1];
    ULONG                   NameSize;
    CHAR                    SymbolBuf[_MAX_PATH];
    ULONG                   SymbolSize;
    HRESULT                 Status  = 0;
    HRESULT                 hr      = 0;
    SYMCHK_DATA             SymChkLocalData;


    ZeroMemory(&Interfaces, sizeof(Interfaces));
    memcpy(&SymChkLocalData, SymChkData, sizeof(SymChkLocalData));

    if ( !SymChkCreateInterfaces(&Interfaces, &ErrLvl) ) {
        return(ErrLvl);
    }

    if (SymChkData->SymbolsPath != NULL) {
        if ((Status = (Interfaces.Symbols)->SetSymbolPath(SymChkData->SymbolsPath)) != S_OK) {
            SymChkReleaseInterfaces(&Interfaces);
            Error = INTERNAL_ERROR;
            return(Error);
        }
    }

    // Everything's set up so open the dump file.
    if ( (hr=(Interfaces.Client->OpenDumpFile(SymChkData->InputFilename))) != S_OK) {
        fprintf(stderr, "Failed to open dump file %s (0x%08x)\n", SymChkData->InputFilename, hr);
        Error = INTERNAL_ERROR;
    } else {
        if ( (Interfaces.Control)->WaitForEvent(DEBUG_WAIT_DEFAULT, INFINITE) == S_OK) {

            (Interfaces.Symbols)->RemoveSymbolOptions(SYMOPT_DEFERRED_LOADS);
            (Interfaces.Symbols)->GetNumberModules( &Loaded, &Unloaded ); 

            for ( i=0; i< Loaded; i++ ) {
                (Interfaces.Symbols)->GetModuleParameters(1, NULL, i, &Params );
                (Interfaces.Symbols)->GetModuleNameString(DEBUG_MODNAME_IMAGE, i,
                                                          Params.Base,         NameBuf,
                                                          _MAX_PATH,           &NameSize );

                if ( SymFindFileInPath(NULL,
                                       SymChkData->SymbolsPath,
                                       NameBuf,
                                       ULongToPtr(Params.TimeDateStamp),
                                       Params.Size,
                                       0,
                                       SSRVOPT_DWORD,
                                       SymChkLocalData.InputFilename,
                                       NULL,
                                       NULL) ) {


                    SymChkCheckFiles(&SymChkLocalData, FileCounts);

                } else {
                    if ( CHECK_DWORD_BIT(SymChkData->OutputOptions, SYMCHK_OPTION_OUTPUT_IGNORES) ) {
                        printf("SYMCHK: %-20s IGNORED - Can't find binary in path.\n", NameBuf);
                    }
                    FileCounts->NumIgnoredFiles++;
                }
            }
        }
    }

    SymChkReleaseInterfaces(&Interfaces);

    return(Error);
}

/////////////////////////////////////////////////////////////////////////////// 
//
// Attaches to a process, finds the modules in use and calls SymChkCheckFiles()
// for each of those modules
//
// Return values:
//      status value:
//
// Parameters:
//      SymChkData (IN) a structure that defines what kind of checking to
//                      do and what process to check
//      FileCounts (OUT) counts for passed/failed/ignored files
//
DWORD SymChkGetSymbolsForProcess(SYMCHK_DATA* SymChkData, FILE_COUNTS* FileCounts) {
    DWORD  Error = SYMCHK_ERROR_SUCCESS;
    ULONG  Loaded, i;
    ULONG  Unloaded;
    CHAR   NameBuf[_MAX_PATH];
    CHAR   ExeDir[_MAX_PATH];
    CHAR   Filename[_MAX_PATH];
    ULONG  NameSize;
    DWORD  pId    = 0;
    DWORD  ErrLvl = 0;
    SYMCHK_INTERFACES       Interfaces;
    DEBUG_MODULE_PARAMETERS Params;

    if ( !SymChkCreateInterfaces(&Interfaces, &ErrLvl) ) {
        return(ErrLvl);
    }

    if (SymChkData->InputPID == 0 ) {
        if ( (Interfaces.Client)->GetRunningProcessSystemIdByExecutableName(0, SymChkData->InputFilename, DEBUG_GET_PROC_DEFAULT, &pId ) != S_OK ) {
            pId = 0;
            printf("SYMCHK: Process \"%s\" wasn't found\n", SymChkData->InputFilename);
            return(PROCESS_NOT_FOUND);
        }
    } else {
        pId = SymChkData->InputPID;
    }

    if (!SymChkProcessAttach(&Interfaces, pId, SymChkData->SymbolsPath, SymChkData->InputOptions, &Error)) {
        printf("SYMCHK: Process ID %d wasn't found\n", pId);

        SymChkReleaseInterfaces(&Interfaces);
        return(PROCESS_NOT_FOUND);
    }

    Interfaces.Symbols->RemoveSymbolOptions(SYMOPT_DEFERRED_LOADS);
    Interfaces.Symbols->GetNumberModules( &Loaded, &Unloaded ); 

    for ( i=0; i< Loaded; i++ ) {
        NameBuf[0]   = '\0';

        Interfaces.Symbols->GetModuleParameters( 1, NULL, i, &Params );
        Interfaces.Symbols->GetModuleNameString( DEBUG_MODNAME_IMAGE,
                                                 i,
                                                 Params.Base,
                                                 NameBuf,
                                                 _MAX_PATH,
                                                 &NameSize );

        if ( CHECK_DWORD_BIT(SymChkData->OutputOptions, SYMCHK_OPTION_OUTPUT_VERBOSE)) {
            if ( CHECK_DWORD_BIT(SymChkData->OutputOptions, SYMCHK_OPTION_OUTPUT_VERBOSE)) {
                fprintf(stderr, "[SYMCHK] Checking: %s\n", NameBuf); 
            }
        }

        if ( StringCchCopy(SymChkData->InputFilename, MAX_PATH, NameBuf) == S_OK ) {
            SymChkCheckFiles(SymChkData, FileCounts);
        } else {
            printf("SYMCHK: Internal error checking %s\n", NameBuf);
        }
    } 

    SymChkReleaseInterfaces(&Interfaces);

    return(Error);
}

/////////////////////////////////////////////////////////////////////////////// 
//
// Cleans up the required debug interfaces
//
// Return values:
//  TRUE  - we attached to the process
//  FALSE - couldn't attach to the process
//
// Parameters:
//  ProcessId   (IN)  - PID of the process to attach to
//  SymbolPath  (IN)  - path to search for symbols in OPTIONAL
//  *ErrorLevel (OUT) - on failure, contains an error code
//
BOOL SymChkProcessAttach(SYMCHK_INTERFACES* Interfaces, DWORD ProcessId, LPTSTR SymbolPath, DWORD Options, DWORD* ErrorLevel) {
    HRESULT Status;
    BOOL    ReturnValue = TRUE;
    DWORD   AttachOptions = DEBUG_ATTACH_NONINVASIVE;

    //
    // Allow option to not suspend a running process.  Set by using /cn at the command line
    //
    if ( CHECK_DWORD_BIT(Options, SYMCHK_OPTION_INPUT_NOSUSPEND) ) {
        AttachOptions |= DEBUG_ATTACH_NONINVASIVE_NO_SUSPEND;
    }

    *ErrorLevel = 0;

    // Don't set the output callbacks yet as we don't want
    // to see any of the initial debugger output.
    if (SymbolPath != NULL) {
        if ((Status = (Interfaces->Symbols)->SetSymbolPath(SymbolPath)) != S_OK) {
            ReturnValue = FALSE;
        }
    }

    if ( ReturnValue==TRUE ) {
        // Everything's set up so do the attach. This suspends the process so it's not so
        // rude as to exit while we're trying to get it's symbols.
        if ((Status = (Interfaces->Client)->AttachProcess(0, ProcessId, AttachOptions)) != S_OK) {
            *ErrorLevel = INTERNAL_ERROR;
            ReturnValue = FALSE;

        // Finish initialization by waiting for the attach event.
        // This should return quickly as a non-invasive attach
        // can complete immediately.
        } else if ((Status = (Interfaces->Control)->WaitForEvent(DEBUG_WAIT_DEFAULT, INFINITE)) != S_OK) {
            *ErrorLevel = INTERNAL_ERROR;
            ReturnValue = FALSE;
        }
    }

    // Everything is now initialized and we can make any
    // queries we want.
    return(ReturnValue);
}

/////////////////////////////////////////////////////////////////////////////// 
//
// Cleans up the required debug interfaces
//
// Return values: (NONE)
//
// Parameters:
//  Interfaces (INOUT) - Interfaces to release
//
void SymChkReleaseInterfaces(SYMCHK_INTERFACES* Interfaces) {
    __try { // this is AVing, temporarily wrap it in a _try
            // until I find the exact cause of the error
        if ((Interfaces->Symbols) != NULL) {
            (Interfaces->Symbols)->Release();
            (Interfaces->Symbols) = NULL;
        }
        if ((Interfaces->Control) != NULL) {
            (Interfaces->Control)->Release();
            (Interfaces->Control) = NULL;
        }
        if ((Interfaces->Client) != NULL) {
            // Request a simple end to any current session.
    
            // We don't want to see any output from the shutdown.
            (Interfaces->Client)->SetOutputCallbacks(NULL);
            // currently, and active detach will cause an invalid handle exception
            // when running under app verifier.  This is a bug in dbgeng that's
            // being fixed.
            (Interfaces->Client)->EndSession(DEBUG_END_ACTIVE_DETACH);
            (Interfaces->Client)->Release();
            (Interfaces->Client) = NULL;
        }
    } _except (EXCEPTION_EXECUTE_HANDLER) {
        // nothing to do
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\symchk\symchk\exe\common.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Include files
//
///////////////////////////////////////////////////////////////////////////////
#include <windows.h>
#include <malloc.h>
#include <stdlib.h>
#include <strsafe.h>
#include "SymbolCheckAPI.h"

#if SYM_DEBUG
#define LOGMSG(a)   a
#else
#define LOGMSG(a)
#endif

///////////////////////////////////////////////////////////////////////////////
//
// Structures
//
///////////////////////////////////////////////////////////////////////////////

//
// For use with /ee and /ef
//
typedef struct _FILE_LIST {
    LPTSTR *szFiles;      // Pointers to the file names
    DWORD   dNumFiles;
} FILE_LIST, *PFILE_LIST;

//
// Holds file count results
//
typedef struct _FILE_COUNTS {
    DWORD   NumPassedFiles;
    DWORD   NumIgnoredFiles;
    DWORD   NumFailedFiles;
} FILE_COUNTS, *PFILE_COUNTS;

//
// Holds all of the input options
//
typedef struct _SYMCHK_DATA {
    // input options
    DWORD           InputOptions;
    DWORD           InputPID;                     // only used with SYMCHK_OPTION_INPUT_PID
    CHAR            InputFilename[MAX_PATH+1];    // for SYMCHK_OPTION_INPUT_FILENAME is dir+filemask
                                                  // for SYMCHK_OPTION_INPUT_FILELIST is full path and filename
                                                  // for SYMCHK_OPTION_INPUT_EXE is exe name
    CHAR            InputFileMask[_MAX_FNAME+1];  // only used with SYMCHK_OPTION_INPUT_FILENAME

    // output options
    DWORD           OutputOptions;
    CHAR            OutputCSVFilename[MAX_PATH+1];// used with /ol

    // checking options
    DWORD           CheckingAttributes;           // flags to pass to SymbolCheckByFilename()

    // extended options
    CHAR*           SymbolsPath;                  // _NT_SYMBOL_PATH or /s* option
    CHAR            FilterErrorList[MAX_PATH+1];  // used with /ee
    FILE_LIST*      pFilterErrorList;             // file to ignore only on error
    CHAR            FilterIgnoreList[MAX_PATH+1]; // used with /ef
    FILE_LIST*      pFilterIgnoreList;            // files to always ignore
    CHAR            CDIncludeList[MAX_PATH+1];    // used with /y 
    FILE_LIST*      pCDIncludeList;               // files to include on CD
    CHAR            SymbolsCDFile[MAX_PATH+1];    // used with /c
    FILE*           SymbolsCDFileHandle;          // used with /c
} SYMCHK_DATA;

///////////////////////////////////////////////////////////////////////////////
//
// Just some handy macros
//
///////////////////////////////////////////////////////////////////////////////
#define SET_DWORD_BIT(  dw, b)  dw |= b
#define CLEAR_DWORD_BIT(dw, b)  dw &= (~b)
#define CHECK_DWORD_BIT(dw, b)  (dw&b) 

#define SYMCHK_CHECK_CV                0x00000001

//
// DBG bits - only 1
//
#define SYMCHK_NO_DBG_DATA             0x00000002 // don't allow DBG data
#define SYMCHK_DBG_SPLIT               0x00000004 // DBG must be split from bin
#define SYMCHK_DBG_IN_BINARY           0x00000008 // DBG must be in binary

//
// PDB bits - only 1
//
#define SYMCHK_PDB_STRIPPED            0x00001000 // PDB must be stripped
#define SYMCHK_PDB_TYPEINFO            0x00002000 // PDB should contain type info
#define SYMCHK_PDB_PRIVATE             0x00004000 // PDB must not be stripped

///////////////////////////////////////////////////////////////////////////////
//
// Defines
//
///////////////////////////////////////////////////////////////////////////////
// input options for use by symchk.exe
#define SYMCHK_OPTION_INPUT_FILENAME    0x00000001 // bits 0-3 are mutually exclusive
#define SYMCHK_OPTION_INPUT_FILELIST    0x00000002
#define SYMCHK_OPTION_INPUT_PID         0x00000004
#define SYMCHK_OPTION_INPUT_EXE         0x00000008
#define SYMCHK_OPTION_INPUT_DUMPFILE    0x00000010

#define SYMCHK_EXCLUSIVE_INPUT_BITS     (SYMCHK_OPTION_INPUT_FILENAME | \
                                         SYMCHK_OPTION_INPUT_FILELIST | \
                                         SYMCHK_OPTION_INPUT_PID      | \
                                         SYMCHK_OPTION_INPUT_EXE      | \
                                         SYMCHK_OPTION_INPUT_DUMPFILE)

// 0x3FFFFFF0 - RESERVED
#define SYMCHK_OPTION_INPUT_NOSUSPEND   0x40000000
#define SYMCHK_OPTION_INPUT_RECURSE     0x80000000


#define SYMCHK_OPTION_OUTPUT_VERBOSE        0x00000001
#define SYMCHK_OPTION_OUTPUT_ERRORS         0x00000002
#define SYMCHK_OPTION_OUTPUT_IGNORES        0x00000004
#define SYMCHK_OPTION_OUTPUT_PASSES         0x00000008
#define SYMCHK_OPTION_OUTPUT_TOTALS         0x00000010
#define SYMCHK_OPTION_OUTPUT_FULLBINPATH    0x00000020
#define SYMCHK_OPTION_OUTPUT_FULLSYMPATH    0x00000040
#define SYMCHK_OPTION_OUTPUT_CSVFILE        0x00000080

// same as 0xE
#define SYMCHK_OUTPUT_OPTION_ALL_DETAILS ( SYMCHK_OPTION_OUTPUT_ERRORS |\
                                           SYMCHK_OPTION_OUTPUT_PASSES|\
                                           SYMCHK_OPTION_OUTPUT_IGNORES)

#define SYMCHK_OPTION_OUTPUT_MASK_ALL       ( SYMCHK_OPTION_OUTPUT_VERBOSE    | \
                                              SYMCHK_OPTION_OUTPUT_ERRORS     | \
                                              SYMCHK_OPTION_OUTPUT_IGNORES    | \
                                              SYMCHK_OPTION_OUTPUT_PASSES     | \
                                              SYMCHK_OPTION_OUTPUT_TOTALS     | \
                                              SYMCHK_OPTION_OUTPUT_FULLBINPATH| \
                                              SYMCHK_OPTION_OUTPUT_FULLSYMPATH| \
                                              SYMCHK_OPTION_OUTPUT_CSVFILE    )

// 0x00000100 - RESERVED
// 0x00000200 - RESERVED
// 0x00000400 - RESERVED
// 0x00000800 - RESERVED

#define SYMCHK_ERROR_SUCCESS                ERROR_SUCCESS
#define SYMCHK_ERROR_FILE_NOT_FOUND         ERROR_FILE_NOT_FOUND
#define SYMCHK_ERROR_STRCPY_FAILED          ERROR_INSUFFICIENT_BUFFER
///////////////////////////////////////////////////////////////////////////////
//
// functions external to SymChk.c
//
///////////////////////////////////////////////////////////////////////////////

//
// Functions in CmdLine.c
//
SYMCHK_DATA*      SymChkGetCommandLineArgs(int argc, char **argv);

//
// Functions in SymChkUtils.c
//
DWORD             SymChkCheckFiles(   SYMCHK_DATA* SymChkData, FILE_COUNTS* FileCounts);
DWORD             SymChkCheckFileList(SYMCHK_DATA* SymChkData, FILE_COUNTS* FileCounts);
PFILE_LIST        SymChkGetFileList(LPTSTR szFilename, BOOL Verbose);
BOOL              SymChkFileInList( LPTSTR szFilename, PFILE_LIST pFileList);
BOOL              SymChkInputToValidFilename(LPTSTR Input, LPTSTR ValidFilename, LPTSTR ValidMask);

//
// from DE_Utils.cpp
//
DWORD             SymChkGetSymbolsForDump(SYMCHK_DATA* SymChkData, FILE_COUNTS* FileCounts);
DWORD             SymChkGetSymbolsForProcess(SYMCHK_DATA* SymChkData, FILE_COUNTS* FileCounts);

// implemented in ..\SharedUtils.c, included via SymChkUtils.c
DWORD PrivateGetFullPathName(LPCTSTR lpFilename, DWORD nBufferLength, LPTSTR lpBuffer, LPTSTR *lpFilePart);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\symchk\symchk\exe\cmdline.c ===
#include "Common.h"
#define SYMBOL_CHECK_NOISY              0x40000000
#define SYMBOL_CHECK_NO_BIN_CHECK       0x10000000
//
// Private local functions
//
BOOL  SymChkShowPortGuide(void);
void  SymChkUsage(void);

///////////////////////////////////////////////////////////////////////////////
// read in the entire command line and do some basic validation on it
///////////////////////////////////////////////////////////////////////////////
SYMCHK_DATA* SymChkGetCommandLineArgs(int argc, char **argv) {

    // working vars
    INT   i  = 0;
    CHAR  c;
    LPSTR szTemp; 
    DWORD dwTemp;

    SYMCHK_DATA* SymChkData_Local = (SYMCHK_DATA*)malloc(sizeof(SYMCHK_DATA));

#ifdef SYMCHK_SUPPORT_DEPRECATED_COMMAND_LINE
    BOOL fUsedOldArgument = FALSE;
#endif


    if ( SymChkData_Local==NULL ) {
        fprintf(stderr, "Out of memory!\n");
        exit(1);
    }

    ZeroMemory(SymChkData_Local, _msize(SymChkData_Local));

    // set defaults
    SymChkData_Local->SymbolsPath = NULL;

    SET_DWORD_BIT(SymChkData_Local->InputOptions,       SYMCHK_OPTION_INPUT_FILENAME);
    SET_DWORD_BIT(SymChkData_Local->OutputOptions,      SYMCHK_OPTION_OUTPUT_TOTALS);
    SET_DWORD_BIT(SymChkData_Local->OutputOptions,      SYMCHK_OPTION_OUTPUT_ERRORS);
    SET_DWORD_BIT(SymChkData_Local->CheckingAttributes, SYMCHK_CHECK_CV);
    SET_DWORD_BIT(SymChkData_Local->CheckingAttributes, SYMCHK_DBG_SPLIT);

    // The default is to allow private symbols in PDBs.  It can be changed here.
    //SET_DWORD_BIT(SymChkData_Local->CheckingAttributes, SYMCHK_PDB_STRIPPED);

    while ( ++i < argc ) {
        if ( (argv[i][0] == '/') || (argv[i][0] == '-') ) {
            c = argv[i][1];

            switch (tolower(c)) {
#ifdef SYMCHK_SUPPORT_DEPRECATED_COMMAND_LINE // these options will be deprecated
                 case 'b':  CLEAR_DWORD_BIT(SymChkData_Local->CheckingAttributes, SYMCHK_CHECK_CV);
                            fUsedOldArgument = TRUE;
                            break;

                 case 'f':  CLEAR_DWORD_BIT(SymChkData_Local->OutputOptions, SYMCHK_OPTION_OUTPUT_TOTALS);
                            fUsedOldArgument = TRUE;
                            break;


                 case 'l':  fUsedOldArgument = TRUE;
                            i++;
                            CLEAR_DWORD_BIT(SymChkData_Local->InputOptions, SYMCHK_EXCLUSIVE_INPUT_BITS);
                            SET_DWORD_BIT(  SymChkData_Local->InputOptions, SYMCHK_OPTION_INPUT_FILELIST);
                            SymChkData_Local->InputPID = 0;
                            if ( i < argc ) {
                                dwTemp = SymCommonGetFullPathName(argv[i], MAX_PATH+1, SymChkData_Local->InputFilename, &szTemp);

                                if (dwTemp==0 || dwTemp > (MAX_PATH+1) ) {
                                    if ( CHECK_DWORD_BIT(SymChkData_Local->OutputOptions, SYMCHK_OPTION_OUTPUT_VERBOSE) ) {
                                        fprintf(stderr, "Failed to get input list!\n");
                                    }
                                }

                            } else {
                                SymChkUsage();
                            }
                            break;

                 case 'm':  i++;
                            CLEAR_DWORD_BIT(SymChkData_Local->InputOptions, SYMCHK_EXCLUSIVE_INPUT_BITS);
                            SET_DWORD_BIT(  SymChkData_Local->InputOptions, SYMCHK_OPTION_INPUT_PID);
                            SymChkData_Local->InputFilename[0] = '\0';
                            fUsedOldArgument = TRUE;
                            if ( i < argc ) {
                                SymChkData_Local->InputPID = (DWORD)atoi(argv[i]);
                            } else {
                                SymChkUsage();
                            }
                            break;

                 case 'n':  i++;
                            CLEAR_DWORD_BIT(SymChkData_Local->InputOptions, SYMCHK_EXCLUSIVE_INPUT_BITS);
                            SET_DWORD_BIT(  SymChkData_Local->InputOptions, SYMCHK_OPTION_INPUT_EXE);
                            SymChkData_Local->InputPID = 0;
                            fUsedOldArgument = TRUE;
                            if ( i < argc ) {
                                if ( StringCchCopy(SymChkData_Local->InputFilename, MAX_PATH+1, argv[i]) != S_OK ) {
                                    fprintf(stderr, "Failed to read input exe name!\n");
                                }
                            } else {
                                SymChkUsage();
                            }
                            break;


                 case 't':   
                            SET_DWORD_BIT(  SymChkData_Local->CheckingAttributes, SYMCHK_NO_DBG_DATA);
                            CLEAR_DWORD_BIT(SymChkData_Local->CheckingAttributes, SYMCHK_DBG_IN_BINARY);
                            CLEAR_DWORD_BIT(SymChkData_Local->CheckingAttributes, SYMCHK_DBG_SPLIT);
                            fUsedOldArgument = TRUE;
                            break;

                 case 'u':  SET_DWORD_BIT( SymChkData_Local->CheckingAttributes,  SYMCHK_DBG_IN_BINARY);
                            CLEAR_DWORD_BIT(SymChkData_Local->CheckingAttributes, SYMCHK_NO_DBG_DATA);
                            CLEAR_DWORD_BIT(SymChkData_Local->CheckingAttributes, SYMCHK_DBG_SPLIT);
                            fUsedOldArgument = TRUE;
                            break;


                 case 'x':  i++;
                            fUsedOldArgument = TRUE;
                            if ( i < argc ) {
                                if ( StringCchCopy(SymChkData_Local->FilterErrorList, MAX_PATH+1, argv[i]) != S_OK ) {
                                    if ( CHECK_DWORD_BIT(SymChkData_Local->OutputOptions, SYMCHK_OPTION_OUTPUT_VERBOSE) ) {
                                        fprintf(stderr, "Failed to read error filter list name!\n");
                                    }
                                }
                            } else {
                                SymChkUsage();
                            }
                            break;

                 case 'y':  i++;
                            fUsedOldArgument = TRUE;
                            if ( i < argc ) {
                                if ( StringCchCopy(SymChkData_Local->CDIncludeList, MAX_PATH+1, argv[i]) != S_OK ) {
                                    if ( CHECK_DWORD_BIT(SymChkData_Local->OutputOptions, SYMCHK_OPTION_OUTPUT_VERBOSE) ) {
                                        fprintf(stderr, "Failed to read CD include list name!\n");
                                    }
                                }
                            } else {
                                SymChkUsage();
                            }
                            break;
#endif
                // begin new/current options
                case 'a':   if ( argv[i][2] == 'v') {
                                // old default, nothing to do for now.
#ifdef SYMCHK_SUPPORT_VERIFY_EXISTS_IN_SYMPATH
                            } else if ( argv[i][2] == 'e') {
                                SET_DWORD_BIT(SymChkData_Local->CheckingAttributes, SYMBOL_CHECK_NO_BIN_CHECK);
#endif
                            } else {
                               SymChkUsage();
                            }
                            break;

                case 'c':   if ( argv[i][2] == 's') {
                                // codeview skip
                                // old /b
                                CLEAR_DWORD_BIT(SymChkData_Local->CheckingAttributes, SYMCHK_CHECK_CV);
                            } else if (argv[i][2] == 'n') {
                                SET_DWORD_BIT(SymChkData_Local->InputOptions, SYMCHK_OPTION_INPUT_NOSUSPEND);
#ifdef SYMCHK_SUPPORT_DEPRECATED_COMMAND_LINE
                            } else if (argv[i][2] == '\0') {
                                i++;
                                fUsedOldArgument = TRUE;
                                if ( i < argc ) {
                                    if ( StringCchCopy(SymChkData_Local->SymbolsCDFile, MAX_PATH+1, argv[i]) != S_OK ) {
                                        if ( CHECK_DWORD_BIT(SymChkData_Local->OutputOptions, SYMCHK_OPTION_OUTPUT_VERBOSE) ) {
                                            fprintf(stderr, "Failed to read symbolscd file name!\n");
                                        }
                                    }
                                } else {
                                    SymChkUsage();
                                }
#endif
                            } else {
                                SymChkUsage();
                            }
                            break;

                case 'd':   if ( argv[i][2] == 's') {
                                // dbg split
                                // old default- nothing to do
                                SET_DWORD_BIT(  SymChkData_Local->CheckingAttributes, SYMCHK_DBG_SPLIT);
                                CLEAR_DWORD_BIT(SymChkData_Local->CheckingAttributes, SYMCHK_NO_DBG_DATA);
                                CLEAR_DWORD_BIT(SymChkData_Local->CheckingAttributes, SYMCHK_DBG_IN_BINARY);
                            } else if ( argv[i][2] == 'n') {
                                // dbg none
                                // old /t
                                SET_DWORD_BIT(  SymChkData_Local->CheckingAttributes, SYMCHK_NO_DBG_DATA);
                                CLEAR_DWORD_BIT(SymChkData_Local->CheckingAttributes, SYMCHK_DBG_IN_BINARY);
                                CLEAR_DWORD_BIT(SymChkData_Local->CheckingAttributes, SYMCHK_DBG_SPLIT);
                            } else if ( argv[i][2] == 'e') {
                                // dbg in exe
                                // old /u
                                SET_DWORD_BIT( SymChkData_Local->CheckingAttributes,  SYMCHK_DBG_IN_BINARY);
                                CLEAR_DWORD_BIT(SymChkData_Local->CheckingAttributes, SYMCHK_NO_DBG_DATA);
                                CLEAR_DWORD_BIT(SymChkData_Local->CheckingAttributes, SYMCHK_DBG_SPLIT);
                            } else {
                                SymChkUsage();
                            }
                            break;

                case 'e':   if ( argv[i][2] == 'a') {
                                // exclude filelist
                                // old /e
                                i++;
                                if ( i < argc ) {
                                    if ( StringCchCopy(SymChkData_Local->FilterIgnoreList, MAX_PATH+1, argv[i]) != S_OK ) {
                                        if ( CHECK_DWORD_BIT(SymChkData_Local->OutputOptions, SYMCHK_OPTION_OUTPUT_VERBOSE) ) {
                                            fprintf(stderr, "Failed to read filter ignore list name!\n");
                                        }
                                    }
                                } else {
                                    SymChkUsage();
                                }
                            } else if ( argv[i][2] == 'e') {
                                i++;
                                if ( i < argc ) {
                                    if ( StringCchCopy(SymChkData_Local->FilterErrorList, MAX_PATH+1, argv[i]) != S_OK ) {
                                        if ( CHECK_DWORD_BIT(SymChkData_Local->OutputOptions, SYMCHK_OPTION_OUTPUT_VERBOSE) ) {
                                            fprintf(stderr, "Failed to read error filter list name!\n");
                                        }
                                    }
                                } else {
                                    SymChkUsage();
                                }
#ifdef SYMCHK_SUPPORT_DEPRECATED_COMMAND_LINE
                            } else if ( argv[i][2] == '\0' ) {
                                i++;
                                if ( i < argc ) {
                                    if ( StringCchCopy(SymChkData_Local->FilterIgnoreList, MAX_PATH+1, argv[i]) != S_OK ) {
                                        if ( CHECK_DWORD_BIT(SymChkData_Local->OutputOptions, SYMCHK_OPTION_OUTPUT_VERBOSE) ) {
                                            fprintf(stderr, "Failed to read filter ignore list name!\n");
                                        }
                                    }
                                } else {
                                    SymChkUsage();
                                }
#endif
                            } else {
                                SymChkUsage();
                            }
                            break;

                case 'i':   if ( argv[i][2] == 'f') {
                                i++;
                                CLEAR_DWORD_BIT(SymChkData_Local->InputOptions, SYMCHK_EXCLUSIVE_INPUT_BITS);
                                SET_DWORD_BIT(  SymChkData_Local->InputOptions, SYMCHK_OPTION_INPUT_FILENAME);
                                SymChkData_Local->InputPID = 0;
                                if ( i < argc ) {
                                    dwTemp = SymCommonGetFullPathName(argv[i], MAX_PATH+1, SymChkData_Local->InputFilename, &szTemp);

                                    if (dwTemp==0 || dwTemp > (MAX_PATH+1) ) {
                                        if ( CHECK_DWORD_BIT(SymChkData_Local->OutputOptions, SYMCHK_OPTION_OUTPUT_VERBOSE) ) {
                                            fprintf(stderr, "Failed to get input filename!\n");
                                        }
                                    }
                                } else {
                                    SymChkUsage();
                                }
                            } else if ( argv[i][2] == 't') {
                                i++;
                                CLEAR_DWORD_BIT(SymChkData_Local->InputOptions, SYMCHK_EXCLUSIVE_INPUT_BITS);
                                SET_DWORD_BIT(  SymChkData_Local->InputOptions, SYMCHK_OPTION_INPUT_FILELIST);
                                SymChkData_Local->InputPID = 0;
                                if ( i < argc ) {
                                    dwTemp = SymCommonGetFullPathName(argv[i], MAX_PATH+1, SymChkData_Local->InputFilename, &szTemp);

                                    if (dwTemp==0 || dwTemp > (MAX_PATH+1) ) {
                                        if ( CHECK_DWORD_BIT(SymChkData_Local->OutputOptions, SYMCHK_OPTION_OUTPUT_VERBOSE) ) {
                                            fprintf(stderr, "Failed to get input list!\n");
                                        }
                                    }

                                } else {
                                    SymChkUsage();
                                }
                            } else if ( argv[i][2] == 'd') {
                                i++;
                                CLEAR_DWORD_BIT(SymChkData_Local->InputOptions, SYMCHK_EXCLUSIVE_INPUT_BITS);
                                SET_DWORD_BIT(  SymChkData_Local->InputOptions, SYMCHK_OPTION_INPUT_DUMPFILE);
                                SymChkData_Local->InputPID = 0;
                                if ( i < argc ) {
                                    dwTemp = SymCommonGetFullPathName(argv[i], MAX_PATH+1, SymChkData_Local->InputFilename, &szTemp);

                                    if (dwTemp==0 || dwTemp > (MAX_PATH+1) ) {
                                        if ( CHECK_DWORD_BIT(SymChkData_Local->OutputOptions, SYMCHK_OPTION_OUTPUT_VERBOSE) ) {
                                            fprintf(stderr, "Failed to get dump file name!\n");
                                        }
                                    }

                                } else {
                                    SymChkUsage();
                                }
                            } else if ( argv[i][2] == 'p') {
                                i++;
                                CLEAR_DWORD_BIT(SymChkData_Local->InputOptions, SYMCHK_EXCLUSIVE_INPUT_BITS);
                                SET_DWORD_BIT(  SymChkData_Local->InputOptions, SYMCHK_OPTION_INPUT_PID);
                                SymChkData_Local->InputFilename[0] = '\0';
                                if ( i < argc ) {
                                    // need to validate that the given parameter is numeric
                                    SymChkData_Local->InputPID = (DWORD)atoi(argv[i]);
                                } else {
                                    SymChkUsage();
                                }
                            } else if ( argv[i][2] == 'e') {
                                i++;
                                CLEAR_DWORD_BIT(SymChkData_Local->InputOptions, SYMCHK_EXCLUSIVE_INPUT_BITS);
                                SET_DWORD_BIT(  SymChkData_Local->InputOptions, SYMCHK_OPTION_INPUT_EXE);
                                SymChkData_Local->InputPID = 0;
                                if ( i < argc ) {
                                    if ( StringCchCopy(SymChkData_Local->InputFilename, MAX_PATH+1, argv[i]) != S_OK ) {
                                        if ( CHECK_DWORD_BIT(SymChkData_Local->OutputOptions, SYMCHK_OPTION_OUTPUT_VERBOSE) ) {
                                            fprintf(stderr, "Failed to read input exe name!\n");
                                        }
                                    }
                                } else {
                                    SymChkUsage();
                                }
                            } else {
                                SymChkUsage();
                            }
                            break;

                case 'o':   if ( argv[i][2] == 't') {
                                // output totals
                                // on by default, only needed
                                // if /q is used
                                SET_DWORD_BIT(SymChkData_Local->OutputOptions, SYMCHK_OPTION_OUTPUT_TOTALS);
                            } else if ( argv[i][2] == 'e') {
                                // output individual errored files
                                // not supported yet
                                // on by default, only needed
                                // if /q is used
                                SET_DWORD_BIT(SymChkData_Local->OutputOptions, SYMCHK_OPTION_OUTPUT_ERRORS);
                            } else if ( argv[i][2] == 'p') {
                                // output individual passed files
                                // not supported yet
                                SET_DWORD_BIT(SymChkData_Local->OutputOptions, SYMCHK_OPTION_OUTPUT_PASSES);
                            } else if ( argv[i][2] == 'i') {
                                // output individual ignored files
                                // not supported yet
                                SET_DWORD_BIT(SymChkData_Local->OutputOptions, SYMCHK_OPTION_OUTPUT_IGNORES);
                            } else if ( argv[i][2] == 'b') {
                                // output fll binary path
                                // not supported yet
                                SET_DWORD_BIT(SymChkData_Local->OutputOptions, SYMCHK_OPTION_OUTPUT_FULLBINPATH);
                            } else if ( argv[i][2] == 's') {
                                // output full symbol path
                                // no supported yet
                                SET_DWORD_BIT(SymChkData_Local->OutputOptions, SYMCHK_OPTION_OUTPUT_FULLSYMPATH);
                            } else if ( argv[i][2] == 'd') {
                                // output details
                                // turns on /oe, /op, /oi and /ot
                                SET_DWORD_BIT(SymChkData_Local->OutputOptions, SYMCHK_OUTPUT_OPTION_ALL_DETAILS);
#ifdef SYMCHK_SUPPORT_NEW_OUTPUT_OPTIONS
                            } else if ( argv[i][2] == 'l') {
                                // output comma seperated list of:
                                // <binary>,<symbol>
                                // for all symbols that pass
                                SET_DWORD_BIT(SymChkData_Local->OutputOptions, SYMCHK_OUTPUT_OPTION_CSVFILE);
                                i++;
                                if ( i < argc ) {
                                    if ( StringCchCopy(SymChkData_Local->OutputCSVFilename, MAX_PATH+1, argv[i]) != S_OK ) {
                                        if ( CHECK_DWORD_BIT(SymChkData_Local->OutputOptions, SYMCHK_OPTION_OUTPUT_VERBOSE) ) {
                                            fprintf(stderr, "Failed to read CSV file name!\n");
                                        }
                                    }
                                } else {
                                    SymChkUsage();
                                }
#endif
#ifdef SYMCHK_SUPPORT_DEPRECATED_COMMAND_LINE
                            } else if ( argv[i][2] == '\0') {
                                SET_DWORD_BIT(  SymChkData_Local->CheckingAttributes, SYMCHK_PDB_TYPEINFO);
                                CLEAR_DWORD_BIT(SymChkData_Local->CheckingAttributes, SYMCHK_PDB_STRIPPED);
                                fUsedOldArgument = TRUE;
#endif
                            } else {
                                SymChkUsage();
                            }
                            break;

                case 'p':  
#ifdef SYMCHK_SUPPORT_DEPRECATED_COMMAND_LINE
                            if (_stricmp(argv[i], "/port")==0) {
                                SymChkShowPortGuide();
                            } else
#endif
                            if ( argv[i][2] == 'f') {
                                // full source
                                // old default - nothing to do
                                SET_DWORD_BIT(  SymChkData_Local->CheckingAttributes, SYMCHK_PDB_PRIVATE);
                                CLEAR_DWORD_BIT(SymChkData_Local->CheckingAttributes, SYMCHK_PDB_STRIPPED);
                                CLEAR_DWORD_BIT(SymChkData_Local->CheckingAttributes, SYMCHK_PDB_TYPEINFO);
                            } else if ( argv[i][2] == 'a') {
                                // pdb stripped
                                // old /p
                                CLEAR_DWORD_BIT(SymChkData_Local->CheckingAttributes, SYMCHK_PDB_STRIPPED);
                                CLEAR_DWORD_BIT(SymChkData_Local->CheckingAttributes, SYMCHK_PDB_PRIVATE);
                                CLEAR_DWORD_BIT(SymChkData_Local->CheckingAttributes, SYMCHK_PDB_TYPEINFO);
                            } else if ( argv[i][2] == 's') {
                                // pdb stripped
                                // old /p
                                SET_DWORD_BIT(  SymChkData_Local->CheckingAttributes, SYMCHK_PDB_STRIPPED);
                                CLEAR_DWORD_BIT(SymChkData_Local->CheckingAttributes, SYMCHK_PDB_TYPEINFO);
                                CLEAR_DWORD_BIT(SymChkData_Local->CheckingAttributes, SYMCHK_PDB_PRIVATE);
                            } else if ( argv[i][2] == 't') {
                                // pdb some type info re-added
                                // old /o
                                SET_DWORD_BIT(  SymChkData_Local->CheckingAttributes, SYMCHK_PDB_TYPEINFO);
                                CLEAR_DWORD_BIT(SymChkData_Local->CheckingAttributes, SYMCHK_PDB_STRIPPED);
                                CLEAR_DWORD_BIT(SymChkData_Local->CheckingAttributes, SYMCHK_PDB_PRIVATE);
#ifdef SYMCHK_SUPPORT_DEPRECATED_COMMAND_LINE
                            } else if ( argv[i][2] == '\0') {
                                SET_DWORD_BIT(  SymChkData_Local->CheckingAttributes, SYMCHK_PDB_STRIPPED);
                                CLEAR_DWORD_BIT(SymChkData_Local->CheckingAttributes, SYMCHK_PDB_TYPEINFO);
                                CLEAR_DWORD_BIT(SymChkData_Local->CheckingAttributes, SYMCHK_PDB_PRIVATE);
                                fUsedOldArgument = TRUE;
#endif
                            } else {
                                SymChkUsage();
                            }
                            break;

                case 'q':   // quiet mode
                            CLEAR_DWORD_BIT(SymChkData_Local->OutputOptions, SYMCHK_OPTION_OUTPUT_MASK_ALL);
                            break;

                case 'r':   SET_DWORD_BIT(SymChkData_Local->InputOptions, SYMCHK_OPTION_INPUT_RECURSE);
                            break;

                case 's':
                           if ( argv[i][2] == '\0') {
                                i++;
                                if ( i < argc ) {
                                    SymChkData_Local->SymbolsPath = (CHAR*)malloc(sizeof(CHAR) * (strlen(argv[i])+1));
                                    if ( SymChkData_Local->SymbolsPath != NULL ) {
                                        if ( StringCchCopy(SymChkData_Local->SymbolsPath, _msize(SymChkData_Local->SymbolsPath), argv[i]) != S_OK ) {
                                            if ( CHECK_DWORD_BIT(SymChkData_Local->OutputOptions, SYMCHK_OPTION_OUTPUT_VERBOSE) ) {
                                                fprintf(stderr, "Failed to read symbols path!\n");
                                            }
                                            free(SymChkData_Local->SymbolsPath);
                                        }
                                    } else {
                                        if ( CHECK_DWORD_BIT(SymChkData_Local->OutputOptions, SYMCHK_OPTION_OUTPUT_VERBOSE) ) {
                                            fprintf(stderr, "Out of memory!\n");
                                        }
                                    }
                                } else {
                                    SymChkUsage();
                                }
#ifdef SYMCHK_SUPPORT_NEW_SYMPATH_OPTIONS
                           } else if ( argv[i][2] == 's') {
                               // always check against symbols server
                               // even when downstream store is in the
                               // path
                               cur = length;
                           } else if ( argv[i][2] == 'u') {
                               // always make sure the downstream store
                               // has the most recent copy of the symbols
                               // from the symbols server
                               cur = length;
#endif
                           } else {
                                SymChkUsage();
                           }

                           break;

                case 'v':  SET_DWORD_BIT(SymChkData_Local->OutputOptions, SYMCHK_OPTION_OUTPUT_VERBOSE);
                           SET_DWORD_BIT(SymChkData_Local->CheckingAttributes, 0x40000000); // symnoisy for private symbolcheck.dll
                           break;

                default:    SymChkUsage();
            }
        } else {
            // verify that this isn't an extranaeous file on the command line after
            // a valid other input option.
            if ( (SymChkData_Local->InputFilename[0]=='\0') && (SymChkData_Local->InputPID==0) ) {
                dwTemp = SymCommonGetFullPathName(argv[i], MAX_PATH+1, SymChkData_Local->InputFilename, &szTemp);

                if (dwTemp==0 || dwTemp > (MAX_PATH+1) ) {
                    if ( CHECK_DWORD_BIT(SymChkData_Local->OutputOptions, SYMCHK_OPTION_OUTPUT_VERBOSE) ) {
                        fprintf(stderr, "Failed to get input list!\n");
                    }
                }

            } else {
                SymChkUsage();
            }
        }
    } // end while()


#if 0
#ifdef SYMCHK_SUPPORT_DEPRECATED_COMMAND_LINE
    if ( fUsedOldArgument && CHECK_DWORD_BIT(SymChkData_Local->OutputOptions, SYMCHK_OPTION_OUTPUT_VERBOSE) ) {
        fprintf(stderr, "*----------------------------------------------------------------*\n");
        fprintf(stderr, "SYMCHK: One or more of the command line options you used are\n");
        fprintf(stderr, "        being deprecated.  Please switch to the new option syntax.\n");
        fprintf(stderr, "        See 'symchk /port' for a quick conversion reference.\n");
        fprintf(stderr, "*----------------------------------------------------------------*\n");
    }
#endif
#endif

    ///////////////////////////////////////////////////////////////////////////
    //
    // Post parsing validation
    //
    ///////////////////////////////////////////////////////////////////////////


    //
    // Verify we have something to check symbols for - if any /i option was used, we
    // did validation on input.  Here, we just need to check for the condition of
    // the default option plus a missing file name
    //
    if ( CHECK_DWORD_BIT(SymChkData_Local->InputOptions, SYMCHK_OPTION_INPUT_FILENAME) ) {
        CHAR    NewFilename[MAX_PATH+1];

        //
        // PrivateInputXxx assumes the size of the returned parameters are (MAX_PATH+1) and (_MAX_FNAME+1) respectively
        //
        if ( !SymChkInputToValidFilename(SymChkData_Local->InputFilename, NewFilename, SymChkData_Local->InputFileMask) ) {
            SymChkUsage();
        } else {
            if (StringCchCopy(SymChkData_Local->InputFilename, MAX_PATH+1, NewFilename) != S_OK ) {
                fprintf(stderr, "SYMCHK: Internal failure\n");
                exit(1);
            }
        }
    }

    //
    // Only allow wildcards and recursing when SYMCHK_OPTION_INPUT_FILENAME
    //
    if ( CHECK_DWORD_BIT(SymChkData_Local->InputOptions, SYMCHK_OPTION_INPUT_FILELIST) ||
         CHECK_DWORD_BIT(SymChkData_Local->InputOptions, SYMCHK_OPTION_INPUT_EXE) ) {
        if ( strchr(SymChkData_Local->InputFilename, '?') != NULL || 
             strchr(SymChkData_Local->InputFilename, '*') != NULL ) {
            fprintf(stderr, "Wildcards are not permitted when using the /it or /ie options!\n");
            exit(1);
        }

        if ( CHECK_DWORD_BIT(SymChkData_Local->InputOptions, SYMCHK_OPTION_INPUT_RECURSE) ) {
            if ( CHECK_DWORD_BIT(SymChkData_Local->OutputOptions, SYMCHK_OPTION_OUTPUT_VERBOSE) ) {
                fprintf(stderr, "Recursing is not permitted with the /it or /ie options. Ignoring.\n");
            }
            CLEAR_DWORD_BIT(SymChkData_Local->InputOptions, SYMCHK_OPTION_INPUT_RECURSE);
        }
    }

    if ( CHECK_DWORD_BIT(SymChkData_Local->InputOptions, SYMCHK_OPTION_INPUT_PID) ) {
        if ( CHECK_DWORD_BIT(SymChkData_Local->InputOptions, SYMCHK_OPTION_INPUT_RECURSE) ) {
            if ( CHECK_DWORD_BIT(SymChkData_Local->OutputOptions, SYMCHK_OPTION_OUTPUT_VERBOSE) ) {
                fprintf(stderr, "Recursing is not permitted with the /ip option. Ignoring.\n");
            }
            CLEAR_DWORD_BIT(SymChkData_Local->InputOptions, SYMCHK_OPTION_INPUT_RECURSE);
        }
    }

    //
    // If we weren't given a symbols path, try to get it from the environment
    //
    if ( SymChkData_Local->SymbolsPath==NULL ) {
        CHAR* env;
        env = getenv("_NT_SYMBOL_PATH");

        if (env==NULL) {
            fprintf(stderr, "ERROR: No symbols path specified and _NT_SYMBOL_PATH is not defined!\n");
            exit(1);
        } else {

            SymChkData_Local->SymbolsPath = (CHAR*)malloc(sizeof(CHAR) * (strlen(env)+1));
            if ( SymChkData_Local->SymbolsPath != NULL ) {
                if ( StringCchCopy(SymChkData_Local->SymbolsPath, _msize(SymChkData_Local->SymbolsPath), env) != S_OK ) {
                    fprintf(stderr, "Failed to read symbols path!\n");
                    free(SymChkData_Local->SymbolsPath);
                    exit(1);
                }
            } else {
                fprintf(stderr, "Out of memory!\n");
                exit(1);
            }
        }
    }

    //
    // If we were given a symbolcd log, make sure we can access it
    //
    if (SymChkData_Local->SymbolsCDFile[0] != '\0') {

        if ( (SymChkData_Local->SymbolsCDFileHandle = (FILE*)fopen(SymChkData_Local->SymbolsCDFile, "a+")) == NULL ) {
            fprintf(stderr, "Cannot open %s for appending\n",SymChkData_Local->SymbolsCDFile);
            exit(1);
        }
    }

    //
    // Get the optional exclude lists
    //
    if ( SymChkData_Local->FilterIgnoreList[0] != '\0') {
        SymChkData_Local->pFilterIgnoreList = SymChkGetFileList(SymChkData_Local->FilterIgnoreList,
                                                                CHECK_DWORD_BIT(SymChkData_Local->OutputOptions, SYMCHK_OPTION_OUTPUT_VERBOSE));
        if ( SymChkData_Local->pFilterIgnoreList != NULL ) {
            if ( CHECK_DWORD_BIT(SymChkData_Local->OutputOptions, SYMCHK_OPTION_OUTPUT_VERBOSE) ) {
                fprintf(stderr, "Found %d files in ignore always list!\n", SymChkData_Local->pFilterIgnoreList->dNumFiles);
            }
        } else {
            if ( CHECK_DWORD_BIT(SymChkData_Local->OutputOptions, SYMCHK_OPTION_OUTPUT_VERBOSE) ) {
                fprintf(stderr, "Didn't get ignore list!\n");
            }
        }
    }

    if ( SymChkData_Local->FilterErrorList[0] != '\0') {
        SymChkData_Local->pFilterErrorList = SymChkGetFileList(SymChkData_Local->FilterErrorList,
                                                               CHECK_DWORD_BIT(SymChkData_Local->OutputOptions, SYMCHK_OPTION_OUTPUT_VERBOSE));
        if ( SymChkData_Local->pFilterErrorList != NULL ) {
            if ( CHECK_DWORD_BIT(SymChkData_Local->OutputOptions, SYMCHK_OPTION_OUTPUT_VERBOSE) ) {
                fprintf(stderr, "Found %d files in error list!\n", SymChkData_Local->pFilterErrorList->dNumFiles);
            }
        } else {
            if ( CHECK_DWORD_BIT(SymChkData_Local->OutputOptions, SYMCHK_OPTION_OUTPUT_VERBOSE) ) {
                fprintf(stderr, "Didn't get ignore errors list!\n");
            }
        }
    }

    //
    // Get the CD Include list
    //
    if ( SymChkData_Local->CDIncludeList[0] != '\0') {
        SymChkData_Local->pCDIncludeList = SymChkGetFileList(SymChkData_Local->CDIncludeList,
                                                             CHECK_DWORD_BIT(SymChkData_Local->OutputOptions, SYMCHK_OPTION_OUTPUT_VERBOSE));
        if ( SymChkData_Local->pCDIncludeList != NULL ) {
            if ( CHECK_DWORD_BIT(SymChkData_Local->OutputOptions, SYMCHK_OPTION_OUTPUT_VERBOSE) ) {
                fprintf(stderr, "Found %d files in symbol CD list!\n", SymChkData_Local->pCDIncludeList->dNumFiles);
            }
        } else {
            if ( CHECK_DWORD_BIT(SymChkData_Local->OutputOptions, SYMCHK_OPTION_OUTPUT_VERBOSE) ) {
                fprintf(stderr, "Didn't get symbol CD list!\n");
            }
        }
    }

    return(SymChkData_Local);

} // end GetCommandLineArgs


///////////////////////////////////////////////////////////////////////////////
// Temp porting guide spew
///////////////////////////////////////////////////////////////////////////////
BOOL SymChkShowPortGuide(void) {
    puts(
        "\n"
        "------------------------------------------------------------------------------\n"
        "Quick porting guide for converting from the old SymChk command line syntax\n"
        "------------------------------------------------------------------------------\n"
        " No changes:\n"
        "   /r          has not changed\n"
        "   /s <path>   has not changed\n"
        "   /v          has not changed\n"
        "\n"
        " Input options:\n"
        "   /l          should be changed to /it\n"
        "   /m          should be changed to /ip\n"
        "   /n          should be changed to /ie\n"
        "\n"
        " Output options:\n"
        "   /f          should be changed to /q /oe\n"
        "\n"
        " Other options:\n"
        "   /b          should be changed to /cs\n"
        "   /e <file>   should be changed to /ef <file>\n"
        "   /o          should be changed to /pt\n"
        "   /p          should be changed to /ps\n"
        "   /t          should be changed to /dn\n"
        "   /u          should be changed to /de\n"
        "   /x <file>   should be changed to /ee <file>\n"
        "------------------------------------------------------------------------------\n"
        "\n"
    );

    exit(1);
}

///////////////////////////////////////////////////////////////////////////////
// Command line help
///////////////////////////////////////////////////////////////////////////////
VOID SymChkUsage(VOID) {

    puts(
        "\n"
        "symchk [/r] [/q] [Input options] <Filename> /s <SymbolPath> [options]\n"
        "\n"
        "<Filename>      Name of the file or directory that contains the executables\n"
        "                to perform symbol checking on.\n"
        "\n"
        "/s <SymbolPath> Semi-colon separated list of symbol paths.  Symbol server\n"
        "                paths are allowed.  To retrieve symbols to a downstream\n"
        "                store, use \"SRV*<downstream store>*<symbol server>\" for\n"
        "                the symbol path.  See the debugger documentation for more\n"
        "                details.\n"
        "\n"
        "/r              Perform recursive operations on the <Filename> specified.  The\n"
        "                wildcard * can be used in filenames.\n"
        "\n"
        "/q              Turn off all output options by default. Only output turned on\n"
        "                with a output flag (see below) will be printed\n"
        "\n"
        "-----------------------------------------------------------------------------\n"
        "* Input options (choose only one):\n"
        "/if <Filename>       Input is a file name.  Wildcards can be used to specify\n"
        "                     the file name. Default if nothing is specified.\n"
        "/id <DumpFile>       Input is a dump file.\n"
        "/ie <ExeName>        Input is an application name that is currently running.\n"
        "/ip <ProcessId>      Input is a process id.\n"
        "/it <TextFileList>   Input is a list of files, one per line, inside of a text\n"
        "                     file.\n"
        "\n"
        "-----------------------------------------------------------------------------\n"
        "* Action options (choose only one):\n"
        "/av  For each binary, Verify symbols exist and match.  Default.\n"
#ifdef SYMCHK_SUPPORT_VERIFY_EXISTS_IN_SYMPATH
        "/ae  For each binary or symbol file, verify that it exists in the path. This\n"
        "     option may be used to determine if a particular file is indexed on a symbol\n"
        "     server.\n"
#endif
        "\n"
        "-----------------------------------------------------------------------------\n"
        "* Symbol checking options:\n"
        "/cs  Skip verifying that there is CodeView data. Symchk will verify that there\n"
        "     IS codeview data by default.\n"
        "/cn  When symbol checking a running process, don't suspend that process.  User\n"
        "     must ensure the process doesn't exit before symbol checking finishes.\n"
        "\n"
        "- Symbol checking options for DBG information (choose one):\n"
        "/ds  If image was built so that there is information that belongs in a DBG\n"
        "     file, then this option verifies that the DBG information is stripped\n"
        "     from the image and that the image points to a DBG file. Default.\n"
        "/de  If image was built so that there is information that belongs in a DBG\n"
        "     file, then this option verifies that the DBG information is STILL in the\n"
        "     image and that the image does not point to a DBG file.\n"
        "/dn  Verify that the image does not point to a DBG file and that DBG\n"
        "     information is not in the image.\n"
        "\n"
        "- Symbol checking options for PDB files:\n"
        "/pa  Allow both public and private PDBs.  Default.\n"
        "/pf  Verify that PDB files contain full source information.\n"
        "/ps  Verify that PDB files are stripped and do not contain full source\n"
        "     (private) information.\n"
        "/pt  Verify that PDB files are stripped, but do have type information.  Some\n"
        "     PDB files may be stripped but have type information added back in.\n"
        "\n"
        "-----------------------------------------------------------------------------\n"
        "* Symbol checking exclude options:\n"
        "/ea <Filename>  Don't perform symbol checking for the binaries listed in the\n"
        "                file specified.  <Filename> is a text file that contains the\n"
        "                name of each binary, one per line.\n"
        "/ee <Filename>  Perform symbol checking and report files that pass or are\n"
        "                ignored, but don't report errors for binaries listed in the\n"
        "                file specified.  <Filename> is a text file that contains the\n"
        "                name of each binary, one per line.\n"
        "\n"
        "-----------------------------------------------------------------------------\n"
        "* Symbol path options (choose one):\n"
        "/s  <SymbolPath>  Use <SymbolPath> as the search path instead of the value in\n"
        "                  _NT_SYMBOL_PATH.\n"
#ifdef SYMCHK_SUPPORT_NEW_SYMPATH_OPTIONS
        "/ss <SymbolPath>  If a downstream store is specified in the symbol server\n"
        "                  path, verify against the symbol server and not the downstream\n"
        "                  store.\n"
        "/su <SymbolPath>  Same as /ss, but in addition update the downstream store with\n"
        "                  the file that is on the symbol server."
#endif
        "\n"
        "-----------------------------------------------------------------------------\n"
        "* Output options (choose all that apply):\n"
        "/ob    Give the full path for binaries in the output messages for symbol\n"
        "       checking.\n"
        "/od    List all details.  Same as /oe /op /oi\n"
        "/oe    List individual errors.  Errors will be sent to the output by default.\n"
        "       This option is only needed when using /q\n"
        "/oi    List each file that is ignored.\n"
        "/op    List each file that passes.\n"
        "/os    Give the full path for symbols in the output messages for symbol\n"
        "       checking.\n"
        "/ot    Send totals to the output.  Totals are sent to the output by default.\n"
        "       This option is only needed when using /q\n"
#ifdef SYMCHK_SUPPORT_NEW_OUTPUT_OPTIONS
        "\n"
        "- Extended output options:\n"
        "/ol <Filename>     In addition to the messages sent to standard out, write a\n"
        "                   file that contains a comma separated list of all the\n"
        "                   binaries and their symbols that pass symbol checking.\n"
#endif
        "/v     Turn on verbose output mode.\n"
#ifdef SYMCHK_SUPPORT_DEPRECATED_COMMAND_LINE
        "-----------------------------------------------------------------------------\n"
        "* Misc options\n"
        " /port     Old usage to new usage quick porting table\n"
        " *** This option is only temporary while everyone gets use to the new syntax\n"
        "-----------------------------------------------------------------------------\n"
        "\n"
#endif
    ); // end of usage spew
    exit(1);

    // The purpose of /x is to not log errors for symbols in symbad.txt.  However, symchk
    // should check all of the files in symbad.txt when it is creating the list of file
    // in case some of them actually have correct symbols and symbad hasn't been updated yet.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\symchk\symchk\exe\symchk.c ===
#include "Common.h"

VOID DumpSymChkData(SYMCHK_DATA*    SymChkData) {
    fprintf(stderr, "[SYMCHK] InputOptions      : 0x%08x\n", SymChkData->InputOptions);
    fprintf(stderr, "[SYMCHK] InputPID          : %u\n",     SymChkData->InputPID);
    fprintf(stderr, "[SYMCHK] InputFilename     : %s\n",     SymChkData->InputFilename);
    fprintf(stderr, "[SYMCHK] InputFileMask     : %s\n",     SymChkData->InputFileMask);
    fprintf(stderr, "[SYMCHK] OutputOptions     : 0x%08x\n", SymChkData->OutputOptions);
    fprintf(stderr, "[SYMCHK] OutputCSVFilename : %s\n",     SymChkData->OutputCSVFilename);
    fprintf(stderr, "[SYMCHK] CheckingAttributes: 0x%08x\n", SymChkData->CheckingAttributes);

    return;
}

int _cdecl main(int argc, char** argv) {
    int             ExitCode     = 0;
    SYMCHK_DATA*    SymChkData   = SymChkGetCommandLineArgs(argc, argv); // get opts and perform related init
    FILE_COUNTS     FileCounts;
    DWORD           ErrorStatus  = SYMCHK_ERROR_SUCCESS;


#if DBG
    if ( CHECK_DWORD_BIT(SymChkData->OutputOptions, SYMCHK_OPTION_OUTPUT_VERBOSE) ) {
        DumpSymChkData(SymChkData);
    }
#endif

    // clear the totals
    ZeroMemory(&FileCounts, sizeof(FileCounts));

    //
    // handle the input options
    //
    switch (SymChkData->InputOptions & SYMCHK_EXCLUSIVE_INPUT_BITS) {
        case SYMCHK_OPTION_INPUT_FILENAME:
            if ( CHECK_DWORD_BIT(SymChkData->OutputOptions, SYMCHK_OPTION_OUTPUT_VERBOSE) ) {
                fprintf(stderr, "[SYMCHK] Searching for symbols to %s in path %s\n", SymChkData->InputFilename, SymChkData->SymbolsPath);
            }
            ErrorStatus = SymChkCheckFiles(SymChkData, &FileCounts);
            break;

        case SYMCHK_OPTION_INPUT_FILELIST:
            if ( CHECK_DWORD_BIT(SymChkData->OutputOptions, SYMCHK_OPTION_OUTPUT_VERBOSE) ) {
                fprintf(stderr, "[SYMCHK] Searching for symbols to files in %s in path %s\n", SymChkData->InputFilename, SymChkData->SymbolsPath);
            }
            ErrorStatus = SymChkCheckFileList(SymChkData, &FileCounts);
            break;

        case SYMCHK_OPTION_INPUT_DUMPFILE:
            if ( CHECK_DWORD_BIT(SymChkData->OutputOptions, SYMCHK_OPTION_OUTPUT_VERBOSE) ) {
                fprintf(stderr, "[SYMCHK] Searching for symbols to modules in dump file %s using path %s\n", SymChkData->InputFilename, SymChkData->SymbolsPath);
            }
            ErrorStatus = SymChkGetSymbolsForDump(SymChkData, &FileCounts);
            break;


        case SYMCHK_OPTION_INPUT_PID:
            if ( CHECK_DWORD_BIT(SymChkData->OutputOptions, SYMCHK_OPTION_OUTPUT_VERBOSE) ) {
                fprintf(stderr, "[SYMCHK] Searching for symbols to process ID %d in path %s\n", SymChkData->InputPID, SymChkData->SymbolsPath);
            }
            ErrorStatus = SymChkGetSymbolsForProcess(SymChkData, &FileCounts);
            break;

        case SYMCHK_OPTION_INPUT_EXE:
            if ( CHECK_DWORD_BIT(SymChkData->OutputOptions, SYMCHK_OPTION_OUTPUT_VERBOSE) ) {
                fprintf(stderr, "[SYMCHK] Searching for symbols to process %s in path %s\n", SymChkData->InputFilename, SymChkData->SymbolsPath);
            }
            ErrorStatus = SymChkGetSymbolsForProcess(SymChkData, &FileCounts);
            break;

        default:
            if ( CHECK_DWORD_BIT(SymChkData->OutputOptions, SYMCHK_OPTION_OUTPUT_VERBOSE) ) {
                fprintf(stderr, "[SYMCHK] UNKNOWN INPUT OPTION!\n");
            }
            ExitCode = 1;
            break;
    }

    //
    // Signify an error if any files failed.
    //
    if ( FileCounts.NumFailedFiles!=0 ) {
        ExitCode = 1;
    }

    if ( ErrorStatus!=SYMCHK_ERROR_SUCCESS ) {
        printf("SYMCHK: Warning: Processing errors were encountered. Results may be inaccurate.\n");
    }

    if ( CHECK_DWORD_BIT(SymChkData->OutputOptions, SYMCHK_OPTION_OUTPUT_TOTALS) ) {
        printf("\nSYMCHK: FAILED files = %u\n", FileCounts.NumFailedFiles);
        printf("SYMCHK: PASSED + IGNORED files = %u\n", FileCounts.NumPassedFiles + FileCounts.NumIgnoredFiles);
    }


    exit(ExitCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\symchk\symcommon\exefuncs.c ===
#include "SymCommon.h"
#include <strsafe.h>

IMAGE_DEBUG_DIRECTORY UNALIGNED *
SymCommonGetDebugDirectoryInExe(PIMAGE_DOS_HEADER pDosHeader, DWORD* NumberOfDebugDirectories) {
    /* Exe is already mapped and a pointer to the base is
       passed in. Find a pointer to the Debug Directories
    */
    ULONG size;

    IMAGE_DEBUG_DIRECTORY UNALIGNED *pDebugDirectory = NULL;
    ULONG DebugDirectorySize;
    PIMAGE_SECTION_HEADER pSectionHeader;

    size = sizeof(IMAGE_DEBUG_DIRECTORY);

    pDebugDirectory = (PIMAGE_DEBUG_DIRECTORY)
                      ImageDirectoryEntryToDataEx (
                                                  (PVOID)pDosHeader,
                                                  FALSE,
                                                  IMAGE_DIRECTORY_ENTRY_DEBUG,
                                                  &DebugDirectorySize,
                                                  &pSectionHeader );


    if (pDebugDirectory) {
        (*NumberOfDebugDirectories) = DebugDirectorySize / sizeof(IMAGE_DEBUG_DIRECTORY);
        return (pDebugDirectory);
    } else {
        (*NumberOfDebugDirectories) = 0;
        return(NULL);
    }
}

 
///////////////////////////////////////////////////////////////////////////////
//
// Returns true if the image is a resource only dll.
//
// Return values:
//      TRUE, FALSE
//
// Parameters:
//      PVOID pImageBase (IN)
//      BOOOLEAN bMapedAsImage (IN)
//
// [ copied from original SymChk.exe ]
//
BOOL SymCommonResourceOnlyDll(PVOID pImageBase) {
    BOOLEAN bMappedAsImage   = FALSE;
    BOOL    fResourceOnlyDll = TRUE;

    PVOID   pExports,
            pImports,
            pResources;

    DWORD   dwExportSize,
            dwImportSize,
            dwResourceSize;

    pExports  = ImageDirectoryEntryToData(pImageBase,
                                          bMappedAsImage,
                                          IMAGE_DIRECTORY_ENTRY_EXPORT,
                                          &dwExportSize);

    pImports  = ImageDirectoryEntryToData(pImageBase,
                                          bMappedAsImage,
                                          IMAGE_DIRECTORY_ENTRY_IMPORT,
                                          &dwImportSize);

    pResources= ImageDirectoryEntryToData(pImageBase,
                                          bMappedAsImage,
                                          IMAGE_DIRECTORY_ENTRY_RESOURCE,
                                          &dwResourceSize);

    // if resources are found, but imports and exports are not,
    // then this is a resource only DLL
    if ( (pResources     != NULL) &&
         (dwResourceSize != 0   ) &&
         (pImports       == NULL) &&
         (dwImportSize   == 0   ) &&  // this check may not be needed
         (pExports       == NULL) &&
         (dwExportSize   == 0   ) ) { // this check may not be needed
        fResourceOnlyDll = TRUE;
    } else {
        fResourceOnlyDll = FALSE;
    }

    return(fResourceOnlyDll);
}

/////////////////////////////////////////////////////////////////////////////// 
//
// Returns true if the image is a managed dll built from tlbimp.
//
// Return values:
//      TRUE, FALSE
//
// Parameters:
//      PVOID pImageBase (IN)
//          pointer to image mapping
//      PIMAGE_NT_HEADER pNtHEader (IN)
//          pointer to image's NT headers
//
// [ copied from original SymChk.exe ]
//
BOOL SymCommonTlbImpManagedDll(PVOID pImageBase, PIMAGE_NT_HEADERS pNtHeader) {
    // tlbimp generated binaries have no data, no exports, and only import _CorDllMain from mscoree.dll.
    // if this is true, let it through.

    BOOL                        retVal            = TRUE;
    PVOID                       pData;
    DWORD                       dwDataSize;
    PCHAR                       pImportModule;
    PIMAGE_IMPORT_DESCRIPTOR    pImportDescriptor = NULL;
    PIMAGE_IMPORT_BY_NAME       pImportName       = NULL;

    pData = ImageDirectoryEntryToData(pImageBase,
                                      FALSE,
                                      IMAGE_DIRECTORY_ENTRY_EXPORT,
                                      &dwDataSize);
    if (pData || dwDataSize) {
        // exports exist - not a tlbimp output file
        retVal = FALSE;
    } else {

        pData = ImageDirectoryEntryToData(pImageBase,
                                          FALSE,
                                          IMAGE_DIRECTORY_ENTRY_IMPORT,
                                          &dwDataSize);

        if (!pData || !dwDataSize) {
            // no imports - not a tlbimp output file
            retVal = FALSE;
        } else {

            pImportDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)pData;

            if (!pImportDescriptor->Name ||
                !pImportDescriptor->OriginalFirstThunk ||
                pImportDescriptor->ForwarderChain ||
                (pImportDescriptor+1)->Name) {
                // Empty/malformed import table or more than just one dll imported.
                retVal = FALSE;
            } else {

                pImportModule = (PCHAR) ImageRvaToVa(pNtHeader, pImageBase, pImportDescriptor->Name, NULL);
                if (_memicmp(pImportModule, "mscoree.dll", sizeof("mcsoree.dll"))) {
                    // Import dll name is not mscoree.dll - not what we're looking for.
                    retVal = FALSE;
                }
            }
        }
    }

    // if we haven't invalidated the image yet, keep checking
    if (retVal) {
        if (pNtHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
            // 32bit image
            PIMAGE_THUNK_DATA32 pThunkData = (PIMAGE_THUNK_DATA32)ImageRvaToVa(pNtHeader,
                                                                               pImageBase,
                                                                               pImportDescriptor->OriginalFirstThunk,
                                                                               NULL);
            if (IMAGE_SNAP_BY_ORDINAL32(pThunkData->u1.Ordinal)) {
                // We're looking for a name - not this one.
                retVal = FALSE;
            } else {
                if ((pThunkData+1)->u1.AddressOfData) {
                    // There's another import after this - that's an error too.
                    retVal = FALSE;
                } else {
                    // set pImportName for comparison below
                    pImportName = (PIMAGE_IMPORT_BY_NAME)ImageRvaToVa(pNtHeader,
                                                                      pImageBase,
                                                                      pThunkData->u1.AddressOfData,
                                                                      NULL);
                }
            }
        } else if (pNtHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
            // 64-bit image
            PIMAGE_THUNK_DATA64 pThunkData = (PIMAGE_THUNK_DATA64)ImageRvaToVa(pNtHeader,
                                                                               pImageBase,
                                                                               pImportDescriptor->OriginalFirstThunk,
                                                                               NULL);
            if (IMAGE_SNAP_BY_ORDINAL64(pThunkData->u1.Ordinal)) {
                // We're looking for a name - not this one.
                retVal = FALSE;
            } else {
                if ((pThunkData+1)->u1.AddressOfData) {
                    // There's another import after this - that's an error too.
                    retVal = FALSE;
                } else {
                    pImportName = (PIMAGE_IMPORT_BY_NAME)ImageRvaToVa(pNtHeader,
                                                                      pImageBase,
                                                                      (ULONG)(pThunkData->u1.AddressOfData),
                                                                      NULL);
                }
            }
        } else {
            // unknown image - not what we're looking for
            retVal = FALSE;
        }
    }

    // still valid- do the last check
    if (retVal) {
        if (memcmp(pImportName->Name, "_CorDllMain", sizeof("_CorDllMain"))) {
            // The import from mscoree isn't _CorDllMain.
            retVal = FALSE;
        }
    }

    return(retVal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\symchk\symchk\exe\symchkutils.c ===
#include "Common.h"
#include "dbghelp.h"

#define SYM_PASSED   0x1
#define SYM_IGNORED  0x2
#define SYM_FAILED   0x3

BOOL  AddToSymbolsCDLog(SYMCHK_DATA *SymChkData, SYMBOL_CHECK_DATA *Results, CHAR* InputFile) {

    // creates a line like:
    // z:\binaries.x86fre\FE\graftabl.com,graftabl_FE.pdb,FE\symbols\retail\com\graftabl_FE.pdb,com
    // in the symbolscd log.
    // binary, symbol, symbolpath, binary ext

    LPSTR szSrc;
    LPSTR szDest;
    LPSTR szTmp;
    LPSTR szSymbolPath;
    LPSTR szSymFile;

    CHAR szFName[    _MAX_FNAME+1];
    CHAR szBinaryExt[_MAX_EXT+1];
    CHAR szCurName[  _MAX_FNAME + _MAX_EXT + 1];
    CHAR szDestDir[  _MAX_PATH];
    CHAR szSymName[  _MAX_FNAME + 1];
    CHAR szSymExt[   _MAX_EXT + 1];


    if ( CHECK_DWORD_BIT(Results->Result, SYMBOL_CHECK_PDB_FOUND) ) {
        szSymbolPath = Results->PdbFilename;
    } else if ( CHECK_DWORD_BIT(Results->Result, SYMBOL_CHECK_DBG_FOUND) ) {
        szSymbolPath = Results->DbgFilename;
    } else {
        return(FALSE);
    }

    if ( (szSymFile = strrchr(szSymbolPath, '\\')) == NULL ) {
        szSymFile = szSymbolPath;
    } else {
        szSymFile++;
    }

    // If there is a list of the files that belong on the
    // CD, then only write this file to the log for the
    // symbol CD if the file is in the list
    //
    // Originally, this was used for the international
    // incremental builds.
    //
    if ( SymChkData->pCDIncludeList != NULL ) {
        if ( ! SymChkFileInList(InputFile, SymChkData->pCDIncludeList) ) {
            return(TRUE);
        }
    }

    // Get the file name without any path info:
    _splitpath(InputFile,NULL,NULL,szFName,szBinaryExt);

    if ( StringCbCopy(szCurName, sizeof(szCurName), szFName) != S_OK ) {
        printf("SYMUTIL: Failed to initialize szCurName (2051)\n");
        return(FALSE);
    }

    // Put the path below "binaries" as the source
    szSrc = strstr(szSymbolPath, "symbols\\" );
    if (szSrc == NULL) {
        szSrc = strstr(szSymbolPath, "Symbols\\" );
    }

    if (szSrc == NULL) {
        printf("%s: Cannot find \"symbols\\\" in the symbol file's path\n", szCurName);
        return(FALSE);
    }
    if ( (strcmp( szSrc, "symbols\\" ) == 0 )  &&
         (strcmp( szSrc, "Symbols\\" ) == 0 ) ) {
        printf("Symbol file name cannot end with \"symbols\\\"\n");
        return(FALSE);
    }

    // Move the Destination up to the directory after symbols.  If this is
    // the retail directory, don't include retail in the path.
    szDest = szSrc + strlen("symbols\\");

    if ( strncmp( szDest, "retail\\", strlen("retail\\") ) == 0 ) {
        szDest = szDest + strlen("retail\\");
    }

    _splitpath(szDest,NULL,szDestDir,NULL,NULL);

    // Remove the '\' from the end of the string;
    szTmp = szDestDir + strlen(szDestDir) - 1;
    while ( strcmp( szTmp, "\\") == 0 ) {
        *szTmp = '\0';
        szTmp--;
    }

    // get the symbol file name
    _splitpath(szSymbolPath,NULL,NULL,szSymName,szSymExt);

    fprintf(SymChkData->SymbolsCDFileHandle,
            "%s,%s,%s,%s\n",
            InputFile,
            szSymFile,
            szSrc,
            szDestDir);

    return (TRUE);
}

VOID PrintErrorMessage(DWORD ErrNum, CHAR* InputFile, DWORD OutputOptions, SYMBOL_CHECK_DATA Data) {
    CHAR* BinName = InputFile;
    CHAR* PdbName = Data.PdbFilename;
    CHAR* DbgName = Data.DbgFilename;

    if ( !CHECK_DWORD_BIT(OutputOptions, SYMCHK_OPTION_OUTPUT_FULLBINPATH) ) {
        if ( (BinName = strrchr(InputFile, '\\')) == NULL ) {
            BinName = InputFile;
        } else {
            BinName++;
        }

    }

    if ( !CHECK_DWORD_BIT(OutputOptions, SYMCHK_OPTION_OUTPUT_FULLSYMPATH) ) {
        if ( (PdbName = strrchr(Data.PdbFilename, '\\')) == NULL ) {
            PdbName = Data.PdbFilename;
        } else {
            PdbName++;
        }

        if ( (DbgName = strrchr(Data.DbgFilename, '\\')) == NULL ) {
            DbgName = Data.DbgFilename;
        } else {
            DbgName++;
        }
    }

    printf("SYMCHK: %-20s FAILED  - ", BinName);

    switch (ErrNum) {
        case 4:
            printf("%s is missing type information.\n", PdbName);
            break;

        case 5:
            printf("%s is stripped.\n", PdbName);
            break;

        case 6:
            printf("Image contains .DBG file data - fix with dbgtopdb.exe.\n", PdbName);
            break;

        case 8:
            printf("dbg data split into %s\n", DbgName);
            break;

        case 9:
            if (CHECK_DWORD_BIT(Data.Result, SYMBOL_CHECK_DBG_EXPECTED)) {
                printf("%s does not point to CodeView information.\n", DbgName);
            } else {
                printf("CV data not found.\n");
            }
            break;

        case 10:
            printf("%s mismatched or not found\n", PdbName);
            break;

        case 11:
            printf("%s is not stripped.\n", PdbName);
            break;

        case 12:
            printf("DBG data not found.\n");
            break;


        case 20:
            printf("Image is split correctly, but %s is missing\n", DbgName);
            break;

        case 29:
            printf("Built without debugging information.\n");
            break;

        case SYMBOL_CHECK_CANT_LOAD_MODULE:
            switch (Data.Result) {
                case ERROR_FILE_NOT_FOUND:
                    printf("%s is missing\n", PdbName);
                    break;

                case ERROR_PATH_NOT_FOUND:
                    printf("%s not found.\n", BinName);
                    break;

                case ERROR_BAD_FORMAT:
                    printf("corrupt binary format.\n");
                    break;

                default:
                    printf("Error querying DBGHelp\n");
                    break;
            }
            break;

        case SYMBOL_CHECK_INTERNAL_FAILURE:
        case SYMBOL_CHECK_RESULT_INVALID_PARAMETER:
        case SYMBOL_CHECK_RESULT_FILE_DOESNT_EXIST:
            printf("Internal failure.\n");
            break;

        case SYMBOL_CHECK_CANT_INIT_DBGHELP:
        case SYMBOL_CHECK_CANT_QUERY_DBGHELP:
        case SYMBOL_CHECK_CANT_UNLOAD_MODULE:
        case SYMBOL_CHECK_CANT_CLEANUP:
            printf("Error querying DBGHelp\n");
            break;

        default:
            printf("unspecified error (0x%08x)\n", ErrNum);
            break;
    }

}
VOID PrintPassMessage(DWORD ErrNum, CHAR* InputFile, DWORD OutputOptions, SYMBOL_CHECK_DATA Data) {
    CHAR* BinName = InputFile;
    CHAR* PdbName = Data.PdbFilename;
    CHAR* DbgName = Data.DbgFilename;

    if ( !CHECK_DWORD_BIT(OutputOptions, SYMCHK_OPTION_OUTPUT_FULLBINPATH) ) {
        if ( (BinName = strrchr(InputFile, '\\')) == NULL ) {
            BinName = InputFile;
        } else {
            BinName++;
        }

    }

    printf("SYMCHK: %-20s PASSED\n", BinName);
}

VOID PrintIgnoreMessage(DWORD ErrNum, CHAR* InputFile, DWORD OutputOptions, SYMBOL_CHECK_DATA Data) {
    CHAR* BinName = InputFile;
    CHAR* PdbName = Data.PdbFilename;
    CHAR* DbgName = Data.DbgFilename;

    if ( !CHECK_DWORD_BIT(OutputOptions, SYMCHK_OPTION_OUTPUT_FULLBINPATH) ) {
        if ( (BinName = strrchr(InputFile, '\\')) == NULL ) {
            BinName = InputFile;
        } else {
            BinName++;
        }

    }

    if ( !CHECK_DWORD_BIT(OutputOptions, SYMCHK_OPTION_OUTPUT_FULLSYMPATH) ) {
        if ( (PdbName = strrchr(Data.PdbFilename, '\\')) == NULL ) {
            PdbName = Data.PdbFilename;
        } else {
            PdbName++;
        }

        if ( (DbgName = strrchr(Data.DbgFilename, '\\')) == NULL ) {
            DbgName = Data.DbgFilename;
        } else {
            DbgName++;
        }
    }

    printf("SYMCHK: %-20s IGNORED - ", BinName);

    switch (ErrNum) {
        case 3:
            printf("Error, but file is in exlude list.\n");
            break;

        case SYMBOL_CHECK_NO_DOS_HEADER:
            printf("Image does not have a DOS header\n");
            break;

        case SYMBOL_CHECK_IMAGE_LARGER_THAN_FILE:
        case SYMBOL_CHECK_HEADER_NOT_ON_LONG_BOUNDARY:
            printf("This is either corrupt or a DOS image\n");
            break;

        case SYMBOL_CHECK_FILEINFO_QUERY_FAILED:
        case SYMBOL_CHECK_NOT_NT_IMAGE:
            printf("Image is not a valid NT image.\n");
            break;

        case SYMBOL_CHECK_TLBIMP_MANAGED_DLL: // this is the same lie the old symchk made
        case SYMBOL_CHECK_RESOURCE_ONLY_DLL:
            printf("Resource only DLL\n");
            break;

        default:
            printf("unspecified reason (0x%08x)\n", ErrNum);
            break;
    }

}

VOID DumpSymbolCheckData(SYMBOL_CHECK_DATA *Struct) {
    fprintf(stderr, "SymbolCheckVersion  0x%08x\n", Struct->SymbolCheckVersion);
    fprintf(stderr, "Result              0x%08x\n", Struct->Result);
    fprintf(stderr, "DbgFilename         %s\n",     Struct->DbgFilename);
    fprintf(stderr, "DbgTimeDateStamp    0x%08x\n", Struct->DbgTimeDateStamp);
    fprintf(stderr, "DbgSizeOfImage      0x%08x\n", Struct->DbgSizeOfImage);
    fprintf(stderr, "DbgChecksum         0x%08x\n", Struct->DbgChecksum);
    fprintf(stderr, "PdbFilename         %s\n",     Struct->PdbFilename);
    fprintf(stderr, "PdbSignature        0x%08x\n", Struct->PdbSignature);
    fprintf(stderr, "PdbDbiAge           0x%08x\n", Struct->PdbDbiAge);
    return;
}

//
// Create the SymChkDbgSort function using _qsort.h
//
#define NEW_QSORT_NAME SymChkDbgSort
#include "_qsort.h"

/////////////////////////////////////////////////////////////////////////////// 
//
// sorting routine for SymChkDbgSort
//
// [ copied from original SymChk.exe ]
//
int __cdecl SymChkStringComp(const void *e1, const void *e2) {
    LPTSTR* p1;
    LPTSTR* p2;

    p1 = (LPTSTR*)e1;
    p2 = (LPTSTR*)e2;

    return ( _stricmp(*p1,*p2) );
}

/////////////////////////////////////////////////////////////////////////////// 
//
// Runs symbol checking code on one or more files
//
// Return values:
//  status value:
//      SYMCHK_ERROR_SUCCESS        Success
//      SYMCHK_ERROR_STRCPY_FAILED  Initialization failed
//
// Parameters:
//      SymChkData (IN) a structure that defines what kind of checking to
//                      do and a filemask that determines what files to
//                      check
//      FileCounts (OUT) counts for passed/failed/ignored files
//
DWORD SymChkCheckFiles(SYMCHK_DATA* SymChkData, FILE_COUNTS* FileCounts) {
    CHAR              drive[_MAX_DRIVE];
    CHAR              dir[  _MAX_DIR];
    CHAR              file[ _MAX_FNAME];
    CHAR              ext[  _MAX_EXT];
    CHAR              drivedir[_MAX_DRIVE+_MAX_DIR];

    CHAR              WorkingFilename[_MAX_PATH+1];
    LPTSTR            FilenameOnly;

    DWORD             ReturnValue = SYMCHK_ERROR_SUCCESS;
    DWORD             APIReturn;

    HANDLE            hFile;
    SYMBOL_CHECK_DATA CheckResult;
    WIN32_FIND_DATA   FindFileData;

    DWORD             Status;
    DWORD             ErrIndex;

    CHAR              LastPath[MAX_PATH+2];
    CHAR              TempPath[MAX_PATH+2];

    ZeroMemory(&CheckResult, sizeof(CheckResult));

    _splitpath(SymChkData->InputFilename, drive, dir, file, ext);

    // for quick updating of the recursive structure
    if ( StringCchCopy(drivedir, sizeof(drivedir), drive) != S_OK ||
         StringCchCat( drivedir, sizeof(drivedir), dir)   != S_OK ) {

        // should get the HRESULTs from above and make a better error message
        if ( CHECK_DWORD_BIT(SymChkData->OutputOptions, SYMCHK_OPTION_OUTPUT_VERBOSE) ) {
            fprintf(stderr, "[SYMCHK] Internal procedure failed.\n");
        }
        ReturnValue = SYMCHK_ERROR_STRCPY_FAILED;
    } else if ( (hFile=FindFirstFile(SymChkData->InputFilename, &FindFileData)) != INVALID_HANDLE_VALUE ) {

        // Check all files in the given directory that match the filemask
        do { 
            Status = SYM_PASSED;

            // if the file is in the IgnoreAlways list, skip it
            if ( !SymChkFileInList(FindFileData.cFileName, SymChkData->pFilterIgnoreList) ) {

                // don't accidently check a directory that matches the file mask
                if (!(FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {

                    if ( StringCchCopy(WorkingFilename, _MAX_PATH+1, drivedir)               != S_OK ||
                         StringCchCat( WorkingFilename, _MAX_PATH+1, FindFileData.cFileName) != S_OK ) {

                        // should get the HRESULTs from above an make a better error message
                        if ( CHECK_DWORD_BIT(SymChkData->OutputOptions, SYMCHK_OPTION_OUTPUT_VERBOSE) ) {
                            fprintf(stderr, "[SYMCHK] Internal procedure failed.\n");
                        }
                        continue;
                    }

                    //
                    // check the file
                    //
                    APIReturn = SymbolCheckByFilename(WorkingFilename,
                                                      SymChkData->SymbolsPath,
                                                      SymChkData->CheckingAttributes,
                                                      &CheckResult);

                    if ( CHECK_DWORD_BIT(SymChkData->OutputOptions, SYMCHK_OPTION_OUTPUT_VERBOSE) ) {
                        DumpSymbolCheckData(&CheckResult);
                    }
                    //
                    // This will go away, but for now, show status....
                    //
                    if ( CHECK_DWORD_BIT(SymChkData->OutputOptions, SYMCHK_OPTION_OUTPUT_VERBOSE) ) {
                        fprintf(stderr, "[SYMCHK] [ 0x%08x - 0x%08x ] Checked \"%s\"\n",
                                        APIReturn,
                                        CheckResult.Result,
                                        WorkingFilename);
                    }

                    //
                    // Expect a return of 0 if symbol checking succeeded
                    //
                    if (APIReturn != 0) {
                        // ignore results are in the 0x40000000 set while
                        // error  results are in the 0x8000000 set
                        if ( CHECK_DWORD_BIT(APIReturn, 0x40000000) ) {
                            Status   = SYM_IGNORED;
                            ErrIndex = APIReturn;
                        } else {
                            Status   = SYM_FAILED;
                            ErrIndex = APIReturn;
                        }
                    } else {
                        if ( CHECK_DWORD_BIT(SymChkData->CheckingAttributes, SYMCHK_CHECK_CV) &&
                            !CHECK_DWORD_BIT(CheckResult.Result,             SYMBOL_CHECK_CV_FOUND) ) {
                            Status   = SYM_FAILED;
                            ErrIndex = 9;
                        }

                        if ( CHECK_DWORD_BIT(CheckResult.Result, SYMBOL_CHECK_NO_DEBUG_DIRS_IN_EXE) ) {
                            Status   = SYM_FAILED;
                            ErrIndex = 29;
                        }

                        //
                        // Check PDB Options
                        //
                        if ( CHECK_DWORD_BIT(CheckResult.Result, SYMBOL_CHECK_PDB_EXPECTED) &&
                            !CHECK_DWORD_BIT(CheckResult.Result, SYMBOL_CHECK_PDB_FOUND) ) {
                            Status = SYM_FAILED;
                            ErrIndex = 10;
                        } else if ( CHECK_DWORD_BIT(CheckResult.Result, SYMBOL_CHECK_PDB_EXPECTED) ) {
                            if ( CheckResult.PdbFilename[0] != '\0' ) {
                                _splitpath(CheckResult.PdbFilename, drive, dir, file, ext);

                                if ( _stricmp(ext, ".pdb") == 0 ) {

                                    if ( CHECK_DWORD_BIT(SymChkData->CheckingAttributes, SYMCHK_PDB_TYPEINFO) &&
                                        !CHECK_DWORD_BIT(CheckResult.Result,             SYMBOL_CHECK_PDB_TYPEINFO) ) {
                                        Status   = SYM_FAILED;
                                        ErrIndex = 4;
                                    }
                                    if ( CHECK_DWORD_BIT(SymChkData->CheckingAttributes, SYMCHK_PDB_STRIPPED) &&
                                         CHECK_DWORD_BIT(CheckResult.Result,             SYMBOL_CHECK_PDB_PRIVATEINFO) ) {
                                        Status = SYM_FAILED;
                                        ErrIndex = 11;
                                    }

                                    if ( CHECK_DWORD_BIT(SymChkData->CheckingAttributes, SYMCHK_PDB_PRIVATE) &&
                                        !CHECK_DWORD_BIT(CheckResult.Result,             SYMBOL_CHECK_PDB_PRIVATEINFO) ) {
                                        Status   = SYM_FAILED;
                                        ErrIndex = 5;
                                    }
                                } else {
                                    //printf("Oh where, oh where, can he be?\n");
                                }
                            }
                        } // end PDB checks

                        //
                        // Check DBG Options
                        //
                        if ( CHECK_DWORD_BIT(CheckResult.Result, SYMBOL_CHECK_DBG_EXPECTED) ) {

                            if ( CHECK_DWORD_BIT(CheckResult.Result, SYMBOL_CHECK_DBG_SPLIT) &&
                                !CHECK_DWORD_BIT(CheckResult.Result, SYMBOL_CHECK_DBG_FOUND) ) {
                                Status   = SYM_FAILED;
                                ErrIndex = 20;
                            }
                            if ( CHECK_DWORD_BIT(SymChkData->CheckingAttributes, SYMCHK_DBG_SPLIT) &&
                                !CHECK_DWORD_BIT(CheckResult.Result,             SYMBOL_CHECK_DBG_SPLIT) &&
                                 CHECK_DWORD_BIT(CheckResult.Result,             SYMBOL_CHECK_DBG_EXPECTED)) {
                                Status   = SYM_FAILED;
                                ErrIndex = 6;
                            }

                            if ( CHECK_DWORD_BIT(SymChkData->CheckingAttributes, SYMCHK_DBG_IN_BINARY) &&
                                !CHECK_DWORD_BIT(CheckResult.Result,             SYMBOL_CHECK_DBG_IN_BINARY) &&
                                 CHECK_DWORD_BIT(CheckResult.Result,             SYMBOL_CHECK_DBG_EXPECTED)) {
                                Status   = SYM_FAILED;
                                ErrIndex = 8;
                            }

                            if ( CHECK_DWORD_BIT(SymChkData->CheckingAttributes, SYMCHK_NO_DBG_DATA) &&
                                (CHECK_DWORD_BIT(CheckResult.Result,             SYMBOL_CHECK_DBG_IN_BINARY) ||
                                 CHECK_DWORD_BIT(CheckResult.Result,             SYMBOL_CHECK_DBG_SPLIT)    ) ) {
                                Status   = SYM_FAILED;
                                ErrIndex = 7;
                            }

                        } // end DBG checks
                    }

                    // if the file is in the ignore errors list, don't increment the error counter
                    if ( (Status==SYM_FAILED) && SymChkFileInList(FindFileData.cFileName, SymChkData->pFilterErrorList) ) {
                        Status   = SYM_IGNORED;
                        ErrIndex = 3;
                    }


                    switch (Status) {
                        case SYM_PASSED:
                                        // only files that pass are allowed in the symbolscd log
                                        if ( SymChkData->SymbolsCDFileHandle != NULL ) {
                                            AddToSymbolsCDLog(SymChkData, &CheckResult, WorkingFilename);
                                         }

                                        FileCounts->NumPassedFiles++;
                                        if ( CHECK_DWORD_BIT(SymChkData->OutputOptions, SYMCHK_OPTION_OUTPUT_PASSES) ) {
                                            PrintPassMessage(ErrIndex, WorkingFilename, SymChkData->OutputOptions, CheckResult);
                                        }
                                        break;
                        case SYM_FAILED:
                                        FileCounts->NumFailedFiles++;
                                        if ( CHECK_DWORD_BIT(SymChkData->OutputOptions, SYMCHK_OPTION_OUTPUT_ERRORS) ) {
                                            PrintErrorMessage(ErrIndex, WorkingFilename, SymChkData->OutputOptions, CheckResult);
                                        }
                                        break;
                        case SYM_IGNORED:
                                        FileCounts->NumIgnoredFiles++;
                                        if ( CHECK_DWORD_BIT(SymChkData->OutputOptions, SYMCHK_OPTION_OUTPUT_IGNORES) ) {
                                            PrintIgnoreMessage(ErrIndex, WorkingFilename, SymChkData->OutputOptions, CheckResult);
                                        }
                                        break;
                        default:
                                        break;
                    }
                } // is a directory
            } else { // in always ignore list
                // these files are treated like they don't even exist
                // we don't update counters, display messages, or anything else
                // Status   = SYM_IGNORED;
                // ErrIndex = 9;
            }

        } while ( FindNextFile(hFile, &FindFileData) );
        FindClose(hFile);
    }

    // if we're doing a recursive check, check all child directories of given
    // directory unless we had errors above
    if ( CHECK_DWORD_BIT(SymChkData->InputOptions, SYMCHK_OPTION_INPUT_RECURSE) &&
         ReturnValue == SYMCHK_ERROR_SUCCESS) {

        SYMCHK_DATA SymChkData_Recurse;

        memcpy(&SymChkData_Recurse, SymChkData, sizeof(SYMCHK_DATA));

        // filemask to get child dirs
        if ( StringCchCopy(WorkingFilename, _MAX_PATH+1, drivedir) != S_OK ||
             StringCchCat( WorkingFilename, _MAX_PATH+1, "*")      != S_OK ) {

            // should get the HRESULTs from above an make a better error message
            if ( CHECK_DWORD_BIT(SymChkData->OutputOptions, SYMCHK_OPTION_OUTPUT_VERBOSE) ) {
                fprintf(stderr, "[SYMCHK] Internal procedure failed.\n");
            }
        } else if ( (hFile=FindFirstFile(WorkingFilename, &FindFileData)) != INVALID_HANDLE_VALUE ) {
            // printf("WorkingFilename is \"%s\"\n", WorkingFilename);
            do { 
                // make sure this is a directory
                if ( FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) {

                    // don't check '.' and '..'
                    if ( strcmp(FindFileData.cFileName, ".")  != 0 && 
                         strcmp(FindFileData.cFileName, "..") != 0) {

                        // create the new InputFilename
                        if ( StringCchCopy(SymChkData_Recurse.InputFilename, _MAX_PATH+1, drivedir)  != S_OK ||
                             StringCchCat( SymChkData_Recurse.InputFilename, _MAX_PATH+1, FindFileData.cFileName) != S_OK ||
                             StringCchCat( SymChkData_Recurse.InputFilename, _MAX_PATH+1, "\\")      != S_OK ||
                             StringCchCat( SymChkData_Recurse.InputFilename, _MAX_PATH+1, SymChkData->InputFileMask) != S_OK) {
                            // should get the HRESULTs from above an make a better error message
                            if ( CHECK_DWORD_BIT(SymChkData->OutputOptions, SYMCHK_OPTION_OUTPUT_VERBOSE) ) {
                                fprintf(stderr, "[SYMCHK] Internal procedure failed.\n");
                            }
                            continue;
                        }

                        // call ourselves recursively, no need to check the return value
                        SymChkCheckFiles(&SymChkData_Recurse, FileCounts);
                    }
                }

            } while ( FindNextFile(hFile, &FindFileData) );
            FindClose(hFile);
        }
    } else {
        //printf("ReturnValue is 0x%08x\n", ReturnValue);
        //printf("Recurse is %s\n", CHECK_DWORD_BIT(SymChkData->InputOptions, SYMCHK_OPTION_INPUT_RECURSE) ? "TRUE":"FALSE");
    }

/*
    if ( LastPath[0] != '\0' ) {
        SetCurrentDirectory(LastPath);
    }
*/
    return(ReturnValue); 
}

/////////////////////////////////////////////////////////////////////////////// 
//
// Runs SymChkCheckFiles against every entry in a text file. Entries must be
// one per line and no longer than _MAX_PATH in length
//
// Return values:
//  status value:
//      SYMCHK_ERROR_SUCCESS        Operation complete successfully
//      SYMCHK_ERROR_FILE_NOT_FOUND List file couldn't be opened
//                  
//
// Parameters:
//      SymChkData (IN) a structure that defines what kind of checking to
//                      do and a file to read the list from
//      FileCounts (OUT) counts for passed/failed/ignored files
//
DWORD SymChkCheckFileList(SYMCHK_DATA* SymChkData, FILE_COUNTS* FileCounts) {
    CHAR*           ch;
    DWORD           retVal     = SYMCHK_ERROR_SUCCESS;
    DWORD           LineCount  = 0;
    DWORD           LineLength = 0;

    FILE*           fInput;
    // needs to be 1 longer than max allowed, plus 1 for \0
    CHAR        InputLine[_MAX_PATH+2];

    SYMCHK_DATA     SymChkData_OneFile;

    // used to validate file existance
    WIN32_FIND_DATA FindFileData;
    HANDLE          hFile;
    LPTSTR          Filename;

    // init the structure we're passing downline
    memcpy(&SymChkData_OneFile, SymChkData, sizeof(SYMCHK_DATA));

    // open the file
    if ( (fInput = fopen(SymChkData->InputFilename,"rt")) != NULL ) {

        // process each line
        while ( fgets(InputLine, sizeof(InputLine), fInput) != NULL ) {

            LineCount += 1;
            LineLength = strlen(InputLine);

            // clean off the end of the line
            ch = InputLine + LineLength - 1;
            while ( isspace(*ch) || (*ch=='\n') ) {
                *ch = '\0';
                ch--;
            }
            LineLength = strlen(InputLine);
            if ( LineLength == 0 )
                continue;

            // findfirstfile fails if the path ends in '\\'
            if ( InputLine[LineLength-1] == '\\' ) {
                if ( StringCchCat(InputLine, MAX_PATH+1, "*")!=S_OK ) {
                    if ( CHECK_DWORD_BIT(SymChkData->OutputOptions, SYMCHK_OPTION_OUTPUT_VERBOSE) ) {
                        fprintf(stderr, "[SYMCHK] Unable to process line %d - memory access failed\n", LineCount);
                    }
                    continue;
                }

                // recalc line length
                LineLength = strlen(InputLine);
            }

            // make sure the line isn't longer than is allowed
            if ( LineLength <= _MAX_PATH) {
                // now, try to get the FULL path name
                LineLength = SymCommonGetFullPathName(InputLine, MAX_PATH+1, SymChkData_OneFile.InputFilename, &Filename);

                if ( LineLength==0 || LineLength > MAX_PATH+1 ) {
                    if ( CHECK_DWORD_BIT(SymChkData->OutputOptions, SYMCHK_OPTION_OUTPUT_VERBOSE) ) {
                        fprintf(stderr, "[SYMCHK] Unable to process line %d - final path name too long\n", LineCount);
                    }
                    continue;
                }

                SymChkCheckFiles(&SymChkData_OneFile, FileCounts);

            // line too long- skip over the whole thing
            } else {
                if ( CHECK_DWORD_BIT(SymChkData->OutputOptions, SYMCHK_OPTION_OUTPUT_VERBOSE) ) {
                    fprintf(stderr, "[SYMCHK] Unable to process line %d - line too long\n", LineCount);
                }

                // remove the rest of this line
                while ( fgets(InputLine, sizeof(InputLine), fInput) != NULL &&
                        InputLine[(strlen(InputLine)-1)]            != '\n') {
                }

                if ( CHECK_DWORD_BIT(SymChkData->OutputOptions, SYMCHK_OPTION_OUTPUT_VERBOSE) ) {
                    fprintf(stderr, "[SYMCHK] removed the rest of line %d\n", LineCount);
                }
            }
        }
        fclose(fInput);

    } else { // fopen failed
        if ( CHECK_DWORD_BIT(SymChkData->OutputOptions, SYMCHK_OPTION_OUTPUT_VERBOSE) ) {
            fprintf(stderr, "[SYMCHK] Unable to open '%s' for processing.\n", SymChkData->InputFilename);
        }
        retVal = SYMCHK_ERROR_FILE_NOT_FOUND;
    }

    return(retVal); 
}

/////////////////////////////////////////////////////////////////////////////// 
//
// Checks if a given file is in the provided list
//
// Return values:
//      TRUE if the file is in the list, FALSE otherwise
//
// Parameters:
//      szFilename (IN)   - Name of file to look for
//      pFileList (IN) - List to look in
//
// [ copied from original SymChk.exe ]
//
BOOL SymChkFileInList(LPTSTR szFilename, PFILE_LIST pFileList) {
    DWORD i;
    int High;
    int Low;
    int Middle;
    int Result;

    // Lookup the name using a binary search
    if ( pFileList == NULL ) {
        return FALSE;
    }

    if ( pFileList->dNumFiles == 0 ) {
        return FALSE;
    }

    Low = 0;
    High = pFileList->dNumFiles - 1;
    while ( High >= Low ) {

        Middle = (Low + High) >> 1;
        Result = _stricmp( szFilename, pFileList->szFiles[Middle] );

        if ( Result < 0 ) {
            High = Middle - 1;

        } else if ( Result > 0 ) {
            Low = Middle + 1;

        } else {
            break;
        }
    }

    // return
    if ( High < Low ) {
        return FALSE;
    } else {
        return TRUE;
    }
}

/////////////////////////////////////////////////////////////////////////////// 
//
// Loads a list of files from a file into an array of strings
//
// Return values:
//      pointer to an array of FILE_LIST or NULL on error
//
// Parameters:
//      szFilename (IN) - Name of file to read list from
//
// [ copied from original SymChk.exe ]
//
PFILE_LIST SymChkGetFileList(LPTSTR szFilename, BOOL Verbose) {

    PFILE_LIST pExcList = NULL;

    FILE  *fFile;
    CHAR szCurFile[_MAX_FNAME+1], *c;
    CHAR fname[_MAX_FNAME+1], ext[_MAX_EXT+1];
    DWORD i, rc;
    LPTSTR szEndName;

    if (  (fFile = fopen(szFilename, "r")) != NULL ) {
        if ( (pExcList=(PFILE_LIST)malloc(sizeof(FILE_LIST))) != NULL ) {

            pExcList->dNumFiles = 0;

            while ( fgets(szCurFile,_MAX_FNAME,fFile) ) {
                if ( szCurFile[0] == ';' ) continue;
                (pExcList->dNumFiles)++;
            }

            // Go back to the beginning of the file
            if ( (rc=fseek( fFile,0,0)) == 0 ) {

                pExcList->szFiles = (LPTSTR*)malloc( sizeof(LPTSTR) * (pExcList->dNumFiles) );

                if (pExcList->szFiles == NULL) {
                    free(pExcList);
        
                    if ( Verbose) {
                        fprintf(stderr, "[SYMCHK] Not enough memory to read in \"%s\".\n", szFilename);
                    }

                    pExcList = NULL;
                } else {
                    i = 0;

                    while ( i < pExcList->dNumFiles ) {
                        pExcList->szFiles[i] = NULL;

                        memset(szCurFile,'\0',sizeof(CHAR) * (_MAX_FNAME+1) );

                        // szCurFile is guarenteed to be null terminated
                        if ( fgets(szCurFile,_MAX_FNAME,fFile) == NULL ) {
                            // assume we miscounted earlier
                            pExcList->dNumFiles = i;
                        } else {

                            if ( szCurFile[0] == ';' ) {
                                continue;
                            }

                            // Replace the \n with \0
                            c = NULL;
                            c  = strchr(szCurFile, '\n');
                            if ( c != NULL) {
                                *c='\0';
                            }

                            // Allow for spaces and a ; after the file name
                            // Move the '\0' back until it has erased the ';' and any
                            // tabs and spaces that might come before it

                            // Set the pointer to the ; if there is a comment
                            szEndName = strchr(szCurFile, ';');

                            // Set the pointer to the last character in the string if 
                            // there wasn't a comment
                            if (szEndName == NULL ) {
                                if ( strlen(szCurFile) > 0 ) {
                                    szEndName = szCurFile + strlen(szCurFile) - 1;
                                }
                            }

                            if (szEndName != NULL ) {
                                while ( *szEndName == ';' || *szEndName == ' ' || *szEndName == '\t' ) {
                                    *szEndName = '\0';
                                    if ( szEndName > szCurFile ) szEndName--;
                                }
                            }

                            pExcList->szFiles[i]=(LPTSTR)malloc( sizeof(CHAR)*(_MAX_FNAME+1) );

                            if (pExcList->szFiles[i] != NULL ) {
                                _splitpath(szCurFile,NULL,NULL,fname,ext);

                                if ( StringCbCopy(pExcList->szFiles[i], sizeof(TCHAR) * (_MAX_FNAME + 1), fname) != S_OK ||
                                     StringCbCat( pExcList->szFiles[i], sizeof(TCHAR) * (_MAX_FNAME + 1), ext)   != S_OK ) {
                                    pExcList->szFiles[i][0] = '\0';
                                    if ( Verbose) {
                                        fprintf(stderr, "[SYMCHK] Failed to initialize pExcList->szFiles[%d] (292)\n", i);
                                    }
                                }
                            }
                        }
                        i++;

                    }

                    // Sort the List
                    SymChkDbgSort( (void*)pExcList->szFiles, (size_t)pExcList->dNumFiles, (size_t)sizeof(LPTSTR), SymChkStringComp );
                }
            } else {
                free(pExcList);
                if ( Verbose) {
                    fprintf(stderr, "[SYMCHK] Seek on \"%s\" failed.\n", szFilename);
                }

                pExcList = NULL;
            } // fseek

        }

        fclose(fFile);

    } else { // fopen
        if ( Verbose) {
            fprintf(stderr, "[SYMCHK] Failed to open \"%s\"\n", szFilename);
        }
    }

    return (pExcList);
}

/////////////////////////////////////////////////////////////////////////////// 
//
// Converts the given filename to a filename and filemask based on whether
// the name matches a directory or not.
//
// Return values:
//      TRUE if successful
//      FALSE otherwise
//
// Parameters:
//      Input         (IN)  - Name of file given
//      ValidFilename (OUT) - new filename, buffer must be MAX_PATH+1 in size
//      ValidMask     (OUT) - new filemaks, buffer must be _MAX_FNAME+1 in size or
//                            parameter may be null.
//
BOOL SymChkInputToValidFilename(LPTSTR Input, LPTSTR ValidFilename, LPTSTR ValidMask) {
    BOOL Return = TRUE;     

    HANDLE          hFile;
    WIN32_FIND_DATA FindFileData;

    CHAR fdir1[_MAX_DIR];
    CHAR fname1[_MAX_FNAME];
    CHAR fext1[_MAX_EXT];

    if ( Input[0]!='\0' ) {
        if ( StringCchCopy(ValidFilename, MAX_PATH+1, Input) == S_OK ) {

            // FindFirstFile fails if given a path ending in a '\', so fix the filename
            if ( ValidFilename[strlen(ValidFilename)-1] == '\\' ) {
                if (StringCchCat(ValidFilename, MAX_PATH+1, "*")!=S_OK) {
                    Return = FALSE;
                }
            }

            if ( Return ) {
                _splitpath(ValidFilename, NULL, fdir1, fname1, fext1);

                // if using SYMCHK_OPTION_FILENAME, check whether the user entered only
                // a directory, which implies a wildcard of '*'
                if ( (hFile=FindFirstFile(ValidFilename, &FindFileData)) != INVALID_HANDLE_VALUE ) {
                    // If its a directory and the name of the directory matches
                    // the filename.ext from the command line parameter, then the user
                    // entered a directory, so add * to the end.
                    if (FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                        // temp vars for comparison
                        CHAR fdir2[_MAX_DIR];
                        CHAR fname2[_MAX_FNAME];
                        CHAR fext2[_MAX_EXT];

                        _splitpath(FindFileData.cFileName, NULL, fdir2, fname2, fext2 );
                            
                        if (_stricmp(fname1, fname2)==0 && _stricmp(fext1, fext2)==0 ) {
                            // this is a directory as input!
                            if (StringCchCat(ValidFilename, MAX_PATH+1, "\\*")!=S_OK) {
                                Return = FALSE;
                            } else {
                                // re-split to account for appending a '*' above
                                _splitpath(ValidFilename, NULL, fdir1, fname1, fext1);
                            }
                        }
                    }
                    FindClose(hFile);
                }

                // now, fill in the file mask
                if (ValidMask!=NULL) {
                    if (StringCchCopy(ValidMask, _MAX_FNAME+1, fname1)!=S_OK) {
                        Return = FALSE;
                    } else if (StringCchCat(ValidMask, _MAX_FNAME+1, fext1)!=S_OK) {
                        Return = FALSE;
                    }
                }
            }
        } else { // StringCchCopy failed
            Return = FALSE;
        }

    } else { // input is null string
        Return = FALSE;
    }

    return(Return);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\symchk\symcommon\dbgfuncs.c ===
#include "SymCommon.h"
#include <strsafe.h>

BOOL SymCommonDBGPrivateStripped(PCHAR DebugData, ULONG DebugSize) {

    OMFSignature       *CvDebugData, *NewStartCvSig, *NewEndCvSig;
    OMFDirEntry        *CvDebugDirEntry;
    OMFDirHeader       *CvDebugDirHead;
    unsigned int        i, j;
    BOOL                RC = TRUE;

    // All the NT4 DBG's are coming returning FALSE.  Make this return TRUE until
    // we figure out exactly how to do it.

    return (TRUE);

    if (DebugSize == 0) return (TRUE);

    __try {
       CvDebugDirHead  = NULL;
       CvDebugDirEntry = NULL;
       CvDebugData = (OMFSignature *)DebugData;

       if ((((*(PULONG)(CvDebugData->Signature)) == '90BN') ||
            ((*(PULONG)(CvDebugData->Signature)) == '80BN') ||
            ((*(PULONG)(CvDebugData->Signature)) == '11BN'))  &&
           ((CvDebugDirHead = (OMFDirHeader *)((PUCHAR) CvDebugData + CvDebugData->filepos)) != NULL) &&
           ((CvDebugDirEntry = (OMFDirEntry *)((PUCHAR) CvDebugDirHead + CvDebugDirHead->cbDirHeader)) != NULL)) {

           // Walk the directory.  Keep what we want, zero out the rest.

            for (i=0, j=0; i < CvDebugDirHead->cDir; i++) {
                switch (CvDebugDirEntry[i].SubSection) {
                    case sstSegMap:
                    case sstSegName:
                    case sstOffsetMap16:
                    case sstOffsetMap32:
                    case sstModule:
                    case SSTMODULE:
                    case SSTPUBLIC:
                    case sstPublic:
                    case sstPublicSym:
                    case sstGlobalPub:
                        break;

                    default: 
                        // If we find any other subsections, the dbg has private symbols
                        RC = FALSE;
                        break;
                }
            }

        }  
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        RC = FALSE;
    }

    return(RC);
}

PCVDD SymCommonDosHeaderToCVDD(PIMAGE_DOS_HEADER pDosHeader) {
    PCVDD pDebugCV = NULL;
    DWORD DirCount = 0;
    DWORD i;
    IMAGE_DEBUG_DIRECTORY UNALIGNED *DebugDirectory = SymCommonGetDebugDirectoryInExe(pDosHeader, &DirCount);
    IMAGE_DEBUG_DIRECTORY UNALIGNED *pDbgDir=NULL;

    if ( DebugDirectory != NULL ) {

        for ( i=0; i<DirCount; i++) {
            pDbgDir = DebugDirectory + i;
            switch (pDbgDir->Type) {
                case IMAGE_DEBUG_TYPE_CODEVIEW:
                     pDebugCV = (PCVDD) ((PCHAR)pDosHeader + pDbgDir->PointerToRawData );
                     break;

                default:
                    break;
            }
        }
    }

    return(pDebugCV);
}

/*  Dbg is already mapped and a pointer to the base is
    passed in.  Returns a pointer to the Debug directories
*/
IMAGE_DEBUG_DIRECTORY UNALIGNED* SymCommonGetDebugDirectoryInDbg(PIMAGE_SEPARATE_DEBUG_HEADER pDbgHeader,
                                                                  ULONG                       *NumberOfDebugDirectories) {
    IMAGE_DEBUG_DIRECTORY UNALIGNED *pDebugDirectory = NULL;

    pDebugDirectory = (PIMAGE_DEBUG_DIRECTORY) ((PCHAR)pDbgHeader +
                                                sizeof(IMAGE_SEPARATE_DEBUG_HEADER) +
                                                pDbgHeader->NumberOfSections * sizeof(IMAGE_SECTION_HEADER) +
                                                pDbgHeader->ExportedNamesSize);

    if (!pDebugDirectory) {
        return(NULL);
    }

    (*NumberOfDebugDirectories) =   pDbgHeader->DebugDirectorySize /
                                    sizeof(IMAGE_DEBUG_DIRECTORY);
    return (pDebugDirectory);

}

PIMAGE_SEPARATE_DEBUG_HEADER SymCommonMapDbgHeader(LPCTSTR szFileName, PHANDLE phFile) {
    HANDLE                          hFileMap;
    PIMAGE_SEPARATE_DEBUG_HEADER    pDbgHeader;
    DWORD                           dFileType;

    (*phFile) = CreateFile( (LPCTSTR) szFileName,
                            GENERIC_READ,
                            FILE_SHARE_READ,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL);

    if ( (*phFile) == INVALID_HANDLE_VALUE) {
        return(NULL);
    }

    hFileMap = CreateFileMapping( *phFile,
                                  NULL,
                                  PAGE_READONLY,
                                  0,
                                  0,
                                  NULL);

    if ( hFileMap == INVALID_HANDLE_VALUE) {
        CloseHandle(*phFile);
        return(NULL);
    }


    pDbgHeader = (PIMAGE_SEPARATE_DEBUG_HEADER)MapViewOfFile(hFileMap, FILE_MAP_READ, 0, 0, 0);
    CloseHandle(hFileMap);

    if ( !pDbgHeader ) {
        SymCommonUnmapFile((LPCVOID)pDbgHeader, *phFile);
        return(NULL);
    }

    return (pDbgHeader);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\symchk\symcommon\genfuncs.c ===
#include "SymCommon.h"
#include <strsafe.h>

///////////////////////////////////////////////////////////////////////////////
//
// Local replacement for GetFullPathName that correctly handles lpFileName when
// it begins with '\'
//
DWORD SymCommonGetFullPathName(LPCTSTR lpFilename, DWORD nBufferLength, LPTSTR lpBuffer, LPTSTR *lpFilePart) {
    DWORD Return = 0;
    CHAR* ch;

    //
    // GetFullPath flounders when referring to the root of the drive, so use
    // a private version that handles it
    //
    if ( lpFilename[0] == '\\' ) {

        //  handle network paths
        if ( lpFilename[1] == '\\' ) {
            if ( StringCchCopy(lpBuffer, nBufferLength, lpFilename)!=S_OK ) {
                Return = 0;
            } else {
                // fill in the return data
                ch = strrchr(lpBuffer, '\\');
                ch++;
                lpFilePart = (LPTSTR*)ch;
                Return = strlen(lpBuffer);
            }

        } else {
            Return = GetCurrentDirectory(nBufferLength, lpBuffer);

            // truncate everything after drive name
            if ( (Return!=0) &&  (Return <= MAX_PATH+1)) {
                ch = strchr(lpBuffer, '\\');
                if (ch!=NULL) {
                    *ch = '\0';
                }

                // push in the filename
                if ( StringCchCat(lpBuffer, nBufferLength, lpFilename)!=S_OK ) {
                    Return = 0;
                } else {
                    // fill in the return data
                    ch = strrchr(lpBuffer, '\\');
                    ch++;
                    lpFilePart = (LPTSTR*)ch;
                    Return = strlen(lpBuffer);
                }
            } else {
                // return the needed size
            }
        }
    } else {
        //
        // Not refering to driver root, just call the API
        //
        Return = GetFullPathName(lpFilename, nBufferLength, lpBuffer, lpFilePart);
    }

    return(Return);
}
 
///////////////////////////////////////////////////////////////////////////////
//
// Creates a file mapping and returns Handle for the DOS_HEADER
// If the file does not have a DOS_HEADER, then it returns NULL.
//
// Return values:
//      Pointer to IMAGE_DOS_HEADER or NULL [on error]
//
// Parameters:
//      LPTSTR szFileName (IN)
//          file to map
//      PHANDLE phFile (OUT)
//          handle to file
//      DWORD *dwError (OUT)
//          error code: ERROR_SUCCESS (success)
//                      ERROR_OPEN_FAILED
//                      ERROR_FILE_MAPPING_FAILED
//                      ERROR_MAPVIEWOFFILE_FAILED
//                      ERROR_NO_DOS_HEADER
//
// [ copied from original SymChk.exe ]
//
PIMAGE_DOS_HEADER SymCommonMapFileHeader(
                                 LPCTSTR  szFileName,
                                 PHANDLE  phFile,
                                 DWORD   *dwError) {
    HANDLE            hFileMap;
    PIMAGE_DOS_HEADER pDosHeader = NULL;
    DWORD             dFileType;
    BOOL              rc;

    *dwError = ERROR_SUCCESS;

    // phFile map needs to be returned, so it can be closed later
    (*phFile) = CreateFile( (LPCTSTR) szFileName,
                            GENERIC_READ,
                            FILE_SHARE_READ,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL);

    if (*phFile != INVALID_HANDLE_VALUE) {
        hFileMap = CreateFileMapping(*phFile, NULL, PAGE_READONLY, 0, 0, NULL);

        if ( hFileMap!=INVALID_HANDLE_VALUE ) {
            pDosHeader = (PIMAGE_DOS_HEADER)MapViewOfFile(hFileMap, FILE_MAP_READ, 0, 0, 0);

            rc = CloseHandle(hFileMap);

            if ( pDosHeader!=NULL ) {

                // Check to determine if this is an NT image (PE format)
                if (pDosHeader->e_magic != IMAGE_DOS_SIGNATURE) {
                    *dwError =  ERROR_NO_DOS_HEADER;
                    UnmapViewOfFile(pDosHeader);
                    CloseHandle(*phFile);
                    pDosHeader = NULL;
                }

            } else {
                *dwError = ERROR_MAPVIEWOFFILE_FAILED;
                CloseHandle(*phFile);
            } // pDosHeader!=NULL

        } else {
            *dwError = ERROR_FILE_MAPPING_FAILED;
            CloseHandle(*phFile);
        } // hFileMap!=INVALID_HANDLE_VALUE

    } else {
        *dwError = ERROR_OPEN_FAILURE;
    } // *phFile!=INVALID_HANDLE_VALUE

    return (pDosHeader);
}

///////////////////////////////////////////////////////////////////////////////
//
// unmaps a file
//
// [ copied from original SymChk.exe ]
//
BOOL SymCommonUnmapFile(LPCVOID phFileMap, HANDLE hFile) {
    BOOL rc;

    if ((PHANDLE)phFileMap != NULL) {
        FlushViewOfFile(phFileMap,0);
        rc = UnmapViewOfFile( phFileMap );
    }

    if (hFile!=INVALID_HANDLE_VALUE) {
        rc = CloseHandle(hFile);
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\symchk\symcommon\pdbfuncs.c ===
#include "SymCommon.h"
#include <strsafe.h>

BOOL SymCommonPDBLinesStripped(PDB *ppdb, DBI *pdbi) {
    // Return values:
    // FALSE - Private Information has NOT been stripped
    // TRUE - Private Information has been stripped

    Mod *pmod;
    Mod *prevmod;
    long cb;

    pmod = NULL;
    prevmod=NULL;
    while (DBIQueryNextMod(pdbi, pmod, &pmod) && pmod) {
        if (prevmod != NULL) ModClose(prevmod);

        // Check that Source line info is removed
        ModQueryLines(pmod, NULL, &cb);

        if (cb != 0) {
            ModClose(pmod);
            return FALSE;
        }

        // Check that local symbols are removed
        ModQuerySymbols(pmod, NULL, &cb);

        if (cb != 0) {
            ModClose(pmod);
            return FALSE;
        }
        prevmod=pmod;
    }
    if (pmod != NULL) ModClose(pmod);
    if (prevmod != NULL) ModClose(prevmod);

    return (TRUE);
}

BOOL SymCommonPDBPrivateStripped(PDB *ppdb, DBI *pdbi) {
	AGE   age;
	BOOL  PrivateStripped;
	GSI  *pgsi;
	BOOL  valid;

    age = pdbi->QueryAge();

    if (age == 0) {
        // If the age is 0, then check for types to determine if this is
        // a private pdb or not.  PDB 5.0 and earlier may have types and no
        // globals if the age is 0.

        PrivateStripped= SymCommonPDBTypesStripped(ppdb, pdbi) &&
                         SymCommonPDBLinesStripped(ppdb, pdbi);

    } else {
        // Otherwise, use globals to determine if the private info is
        // stripped or not.  No globals means that private is stripped.
        __try {
            valid = pdbi->OpenGlobals(&pgsi);
        } __except( EXCEPTION_EXECUTE_HANDLER ) {
            valid= FALSE;
        }

        if ( !valid ) {
            return FALSE;
        }

        // Now, see if there are any globals in the pdb.

        valid=TRUE;
        __try {
            PrivateStripped= ((pgsi->NextSym(NULL)) == NULL);
        } __except( EXCEPTION_EXECUTE_HANDLER ) {
            valid= FALSE;
        }

        GSIClose(pgsi);
        if ( !valid ) {
            return FALSE;
        }
    }
    return (PrivateStripped);
}

BOOL SymCommonPDBTypesStripped(PDB *ppdb, DBI *pdbi) {
    // Return values:
    // FALSE - Private Information has NOT been stripped
    // TRUE - Private Information has been stripped

    unsigned itsm;
    TPI *ptpi;
    TI  tiMin;
    TI  tiMac;

    // Check that types are removed
    for ( itsm = 0; itsm < 256; itsm++) {
        ptpi = 0;
        if (DBIQueryTypeServer(pdbi, (ITSM) itsm, &ptpi)) {
            continue;
        }
        if (!ptpi) {

            PDBOpenTpi(ppdb, pdbRead, &ptpi);
            tiMin = TypesQueryTiMinEx(ptpi);
            tiMac = TypesQueryTiMacEx(ptpi);
            if (tiMin < tiMac) {
                TypesClose(ptpi);
                return FALSE;
            }
        }
    }
    TypesClose(ptpi);
    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\symchk\symcommon\symcommon.h ===
// System includes come from SymbolCheckAPI.h
#include <windows.h>
#include <winnt.h>
#include <dbghelp.h>
#include <dbgimage.h>
#include <stdio.h>
#define PDB_LIBRARY
#include <pdb.h>
#include <Dia2.h>
#include <stdlib.h>
#include "cvinfo.h"
#include "cvexefmt.h"

//#ifdef __cplusplus
//extern "C" {
//#endif // __cplusplus

///////////////////////////////////////////////////////////////////////////////
//
// Error values for the mapping functions
//

//#define  ERROR_SUCCESS                    0x0000000  // completed successfully - defined by windows.h
#define ERROR_OPEN_FAILURE                  0x20000001 // couldn't open file
#define ERROR_FILE_MAPPING_FAILED           0x20000002 // couldn't map file
#define ERROR_MAPVIEWOFFILE_FAILED          0x20000003 // couldn't map
#define ERROR_NO_DOS_HEADER                 0x20000004 // not a DOS file
#define ERROR_HEADER_NOT_ON_LONG_BOUNDARY   0x20000005 // bad header
#define ERROR_IMAGE_BIGGER_THAN_FILE        0x20000006 // bad file mapping
#define ERROR_NOT_NT_IMAGE                  0x20000007 // not an NT image
#define ERROR_GET_FILE_INFO_FAILED          0x20000008 // couldn't get file info

BOOL  							 SymCommonDBGPrivateStripped(PCHAR DebugData, ULONG DebugSize);
PCVDD                            SymCommonDosHeaderToCVDD(PIMAGE_DOS_HEADER pDosHeader);
IMAGE_DEBUG_DIRECTORY UNALIGNED* SymCommonGetDebugDirectoryInDbg(PIMAGE_SEPARATE_DEBUG_HEADER pDbgHeader, ULONG *NumberOfDebugDirectories);
IMAGE_DEBUG_DIRECTORY UNALIGNED* SymCommonGetDebugDirectoryInExe(PIMAGE_DOS_HEADER pDosHeader, DWORD* NumberOfDebugDirectories);
DWORD                            SymCommonGetFullPathName(LPCTSTR lpFilename, DWORD nBufferLength, LPTSTR lpBuffer, LPTSTR *lpFilePart);
PIMAGE_SEPARATE_DEBUG_HEADER     SymCommonMapDbgHeader( LPCTSTR szFileName, PHANDLE phFile);
PIMAGE_DOS_HEADER                SymCommonMapFileHeader(LPCTSTR szFileName, PHANDLE  phFile, DWORD   *dwError);
BOOL                             SymCommonPDBLinesStripped(  PDB *ppdb, DBI *pdbi);
BOOL                             SymCommonPDBPrivateStripped(PDB *ppdb, DBI *pdbi);
BOOL                             SymCommonPDBTypesStripped(  PDB *ppdb, DBI *pdbi);
BOOL                             SymCommonResourceOnlyDll( PVOID pImageBase);
BOOL                             SymCommonTlbImpManagedDll(PVOID pImageBase, PIMAGE_NT_HEADERS pNtHeader);
BOOL                             SymCommonUnmapFile(LPCVOID phFileMap, HANDLE hFile);


__inline PIMAGE_NT_HEADERS SymCommonGetNtHeader (PIMAGE_DOS_HEADER pDosHeader, HANDLE hDosFile) {
    /*
        Returns the pointer the address of the NT Header.  If there isn't
        an NT header, it returns NULL
    */
    PIMAGE_NT_HEADERS pNtHeader = NULL;
    BY_HANDLE_FILE_INFORMATION FileInfo;

    //
    // If the image header is not aligned on a long boundary.
    // Report this as an invalid protect mode image.
    //
    if ( ((ULONG)(pDosHeader->e_lfanew) & 3) == 0) {
        if (GetFileInformationByHandle( hDosFile, &FileInfo) &&
            ((ULONG)(pDosHeader->e_lfanew) <= FileInfo.nFileSizeLow)) {
            pNtHeader = (PIMAGE_NT_HEADERS)((PCHAR)pDosHeader +
                                            (ULONG)pDosHeader->e_lfanew);

            if (pNtHeader->Signature != IMAGE_NT_SIGNATURE) {
                pNtHeader = NULL;
            }
        }
    }
    return pNtHeader;
}

//#ifdef __cplusplus
//}
//#endif // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\symchk\symstore\msvcrtp.c ===
#include <..\..\imagehlp\msvcrtp.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\symchk\symstore\output.cpp ===
/*
     This is the class that is used for printing output to a log file
     or to standard output.
*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <assert.h>
#include "output.hpp"
#include "strsafe.h"

FILE *SymOutput::Open(LPTSTR szFileName)
{

    //
    // If we assigned szFileName as filename, we do not need to copy it to itself.
    //

    if ( (szFileName != NULL) && (_tcscmp(szFileName, filename) != 0) ) {
        StringCbCopy(filename, sizeof(filename), szFileName);
    }

    //
    // If we assigned the NULL value, we point fh back to stdout.
    // Otherwise, we fopen this file
    //
    
    if (szFileName == NULL) {
        fh = stdout;
    } else if ( ( fh = fopen(filename, "a+t") ) == NULL ) {
        this->printf( "Standard output redirect failed.");
        return NULL;
    }
    return fh;
    
}

void SymOutput::Close(void)
{
    //
    // Close File Handle, if it is not NULL or stdout.
    //

    if ((fh != NULL) && (fh != stdout)) { 
        fflush(fh);
        fclose(fh);
    }
}

void SymOutput::FreeFileName(void)
{
    if ( _tcscmp( filename, _T("") ) != 0 ) {
        StringCbCopy( filename, sizeof(filename), _T("") );
    }
}

FILE *SymOutput::SetFileName(LPTSTR szFileName)
{
    //
    // We set the new file name, only if we specified the /d option.
    // Otherwise, the result goes to standard out
    //

    this->Close();
    this->FreeFileName();
    return this->Open(szFileName);
}

int SymOutput::stdprintf(const char *format, ...)
{
    va_list ap;
    int r;

    //
    // If we previous use printf, print '\n' if fh goes to standard out
    //

    if ( ( ( sw & 2 ) == 0 ) && ( stdout == fh ) ) {
        r = _tprintf("\n");
    }
    sw = 2;
    va_start(ap, format);
    r = _vtprintf(format, ap);
    va_end(ap);

    return r;
}

int SymOutput::printf(const char *format, ...)
{
    va_list ap;
    int r;

    // If we previous use stdprintf, print '\n' if fh goes to standard out
    if ( ( ( sw & 1 ) == 0 ) && ( stdout == fh ) ) {
        r = _ftprintf(fh, "\n");
    }

    sw = 1;
    va_start(ap, format);
    r = _vftprintf(fh, format, ap);
    if (fh != stdout) {
        fflush(fh);
    }
    va_end(ap);

    return r;
}

SymOutput::SymOutput()
{
    fh       = stdout;
    StringCbCopy( filename, sizeof(filename), _T("") );
    sw       = 3;
}

SymOutput::~SymOutput()
{
    this->Close();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\symchk\symstore\output.hpp ===
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>

class SymOutput {

private:

    FILE *fh;
    TCHAR filename[_MAX_PATH];

    // We use variable sw to provide '\n' if program switch in between printf and stdprintf.
    int sw;

    FILE *Open(LPTSTR szFileName);
    void Close(void);
    void FreeFileName(void);

public:
    // Set the log file to store the result we so->printf
    FILE *SetFileName(LPTSTR szFileName);

    // Printf to the output
    int printf(const char *,...);

    // Printf to standard output instead write to so->fh
    int stdprintf(const char *format, ...);

    SymOutput();     // Constructor
    ~SymOutput();    // Distructor

};

typedef class SymOutput *pSymOutput;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\symchk\symstore\pewhack.c ===
/*
    PEWhack - Corrupts a PE binary to be non-executable but still useful when
              debugging memory dumps.

*/

#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <dbghelp.h>
#include <strsafe.h>
#include <PEWhack.h>


BOOL CorruptDataDirectories(PIMAGE_DOS_HEADER pDosHdr, ULONG DirCount); 
BOOL CorruptSections(PIMAGE_SECTION_HEADER pSection, ULONG ulSections, PIMAGE_DOS_HEADER ImageBase);

BOOL CorruptSections(PIMAGE_SECTION_HEADER pSection, ULONG ulSections, PIMAGE_DOS_HEADER ImageBase) {
    BOOL  ReturnValue = FALSE;
    ULONG i;

    for ( i=0; i < ulSections; i++ ) {
        // .data sections can be killed
        if ( strncmp(".data", (CHAR*)(pSection[i].Name), 5) == 0 ) {
            // writeable sections can go away...
            if ( (pSection[i].Characteristics & IMAGE_SCN_MEM_WRITE) ) {

                if ( pSection[i].PointerToRawData != 0 ) {
                    ZeroMemory( (VOID*)( (pSection+i)->PointerToRawData + (ULONG_PTR)ImageBase), pSection[i].SizeOfRawData);
                }

                pSection[i].PointerToRawData= 0;
                pSection[i].SizeOfRawData   = 0;
                pSection[i].Characteristics = 0;
                ReturnValue = TRUE;
            }
        }
    }

    return(ReturnValue);
}

//
// Verifies an image is a PE binary and, if so, corrupts it to be
// non-executable but still useful for debugging memory dumps.
//
DWORD CorruptFile(LPCTSTR Filename) {
    DWORD                               Return         = PEWHACK_SUCCESS;
    HANDLE                              hFile;
    HANDLE                              hFileMap;
    PIMAGE_DOS_HEADER                   pDosHeader     = NULL;
    PIMAGE_NT_HEADERS32                 pPe32Header    = NULL;
    PIMAGE_SECTION_HEADER               pSectionHeader = NULL;
    IMAGE_DEBUG_DIRECTORY UNALIGNED    *pDebugDir      = NULL;
    ULONG                               DebugSize;
    ULONG                               SectionIndex;

    hFile = CreateFile( (LPCTSTR)Filename,
                        GENERIC_WRITE|GENERIC_READ,
                        0,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

    if (hFile != INVALID_HANDLE_VALUE) {
        hFileMap = CreateFileMapping(hFile, NULL, PAGE_READWRITE, 0, 0, NULL);

        if (hFileMap != NULL) {
            pDosHeader = (PIMAGE_DOS_HEADER)MapViewOfFile(hFileMap, FILE_MAP_WRITE, 0, 0, 0);

            if (pDosHeader != NULL) {

                // Verify this is an PE image
                if (pDosHeader->e_magic == IMAGE_DOS_SIGNATURE) {
                    //
                    // Start by assuming a 32bit binary until we check the machine type
                    //
                    pPe32Header = (PIMAGE_NT_HEADERS32)( (PCHAR)(pDosHeader) + (ULONG)(pDosHeader)->e_lfanew);

                    if (pPe32Header->Signature == IMAGE_NT_SIGNATURE) {
                        //
                        // 32bit header
                        //
                        if (pPe32Header->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {

                            // Mark the image as non-executable
                            pPe32Header->FileHeader.Characteristics &= ~IMAGE_FILE_EXECUTABLE_IMAGE;

 
                            // Whack some optional header info
                            pPe32Header->OptionalHeader.SizeOfInitializedData       = 0;
                            pPe32Header->OptionalHeader.SizeOfUninitializedData     = 0;
                            pPe32Header->OptionalHeader.MajorOperatingSystemVersion = 0xFFFF; // absurdly high
                            pPe32Header->OptionalHeader.MinorOperatingSystemVersion = 0xFFFF; // absurdly high
                            pPe32Header->OptionalHeader.Subsystem                   = IMAGE_SUBSYSTEM_UNKNOWN;

                            // Corrupt the section data
                            pSectionHeader = IMAGE_FIRST_SECTION(pPe32Header);
                            CorruptSections(pSectionHeader, pPe32Header->FileHeader.NumberOfSections, pDosHeader);

                            // Corrupt data directories
                            CorruptDataDirectories(pDosHeader, pPe32Header->OptionalHeader.NumberOfRvaAndSizes);

                            pPe32Header->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG].VirtualAddress = 0;
                            pPe32Header->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG].Size = 0;

                            pPe32Header->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress = 0;
                            pPe32Header->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size = 0;

                        //
                        // 64bit header
                        //
                        } else if (pPe32Header->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
                            PIMAGE_NT_HEADERS64 pPe64Header = (PIMAGE_NT_HEADERS64)pPe32Header;

                            // Mark the image as non-executable
                            pPe64Header->FileHeader.Characteristics &= ~IMAGE_FILE_EXECUTABLE_IMAGE;

                            // Whack some optional header info
                            pPe64Header->OptionalHeader.SizeOfInitializedData       = 0;
                            pPe64Header->OptionalHeader.SizeOfUninitializedData     = 0;
                            pPe64Header->OptionalHeader.MajorOperatingSystemVersion = 0xFFFF; // absurdly high
                            pPe64Header->OptionalHeader.MinorOperatingSystemVersion = 0xFFFF; // absurdly high
                            pPe64Header->OptionalHeader.Subsystem                   = IMAGE_SUBSYSTEM_UNKNOWN;

                            // Corrupt the section data
                            pSectionHeader = IMAGE_FIRST_SECTION(pPe64Header);
                            CorruptSections( pSectionHeader, pPe64Header->FileHeader.NumberOfSections, pDosHeader);

                            // Corrupt data directories
                            CorruptDataDirectories(pDosHeader, pPe64Header->OptionalHeader.NumberOfRvaAndSizes);

                            pPe64Header->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG].VirtualAddress = 0;
                            pPe64Header->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG].Size = 0;

                            pPe64Header->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress = 0;
                            pPe64Header->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size = 0;

                        } else {
                            Return = PEWHACK_BAD_ARCHITECTURE;
                        }

                    } else {
                        Return = PEWHACK_BAD_PE_SIG;
                    }
                } else {
                    Return = PEWHACK_BAD_DOS_SIG;
                }
                FlushViewOfFile(pDosHeader, 0);
                UnmapViewOfFile(pDosHeader);
            } else {
                Return = PEWHACK_MAPVIEW_FAILED;
            }
            CloseHandle(hFileMap);

        } else {
            Return = PEWHACK_CREATEMAP_FAILED;
        }
        CloseHandle(hFile);

    } else {
        Return = PEWHACK_CREATEFILE_FAILED;
    }

    return(Return);
}

//
// Corrupts the data directories of a binary.  Machine independent.
//
BOOL CorruptDataDirectories(PIMAGE_DOS_HEADER pDosHdr, ULONG DirCount) {
    PIMAGE_SECTION_HEADER pImageSectionHeader = NULL;

    ULONG  Loop;
    BOOL   RetVal = FALSE;

    for (Loop=0;Loop<DirCount;Loop++) {
        PCHAR   pData;
        ULONG   Size;

        pData = (PCHAR)ImageDirectoryEntryToDataEx(pDosHdr, FALSE, (USHORT)Loop, &Size, &pImageSectionHeader);

        if (pData) {
            switch (Loop) {
                //
                // Sections to corrupt wholesale
                //
                case IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG:
                case IMAGE_DIRECTORY_ENTRY_BASERELOC:
                    ZeroMemory(pData, Size);

                    pImageSectionHeader->Misc.PhysicalAddress = 0;
                    pImageSectionHeader->VirtualAddress       = 0;
                    pImageSectionHeader->SizeOfRawData        = 0;
                    pImageSectionHeader->Characteristics      = 0;
                    pImageSectionHeader->PointerToRawData     = 0;

                    RetVal = TRUE;
                    break;

                //
                // Wholesale corruption of these sections make it impossible
                // to use the binary with the debugger.  It may be worthwhile
                // to look into limited corruption of each section.
                //
                case IMAGE_DIRECTORY_ENTRY_IMPORT:
                case IMAGE_DIRECTORY_ENTRY_EXPORT:
                case IMAGE_DIRECTORY_ENTRY_DEBUG:
                case IMAGE_DIRECTORY_ENTRY_IAT:
                case IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT:
                case IMAGE_DIRECTORY_ENTRY_RESOURCE:
                    break;

                //
                // The binaries I've checked so far lack these sections, so I'm
                // not sure if they're corruptable or not.
                //
                case IMAGE_DIRECTORY_ENTRY_EXCEPTION:
                case IMAGE_DIRECTORY_ENTRY_SECURITY:
                case IMAGE_DIRECTORY_ENTRY_ARCHITECTURE:
                case IMAGE_DIRECTORY_ENTRY_GLOBALPTR:
                case IMAGE_DIRECTORY_ENTRY_TLS:
                case IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT:
                case IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR:
                default:
                    break;
            }
        }
    }

    return(RetVal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\symchk\symstore\symutil.c ===
#include <assert.h>
#include <SymCommon.h>

#include "symutil.h"
#include "symutil_c.h"

#include "share.h"
#include "winbase.h"
#include "symsrv.h"
#include "output.hpp"
#include "PEWhack.h"
#include <string.h>

#include "strsafe.h"



// SymOutput *so;
extern pSymOutput so;
extern BOOL MSArchive;
TCHAR szPriPubBin[4] = "";
BOOL  PrivateStripped=FALSE;


// Stuff for Checking symbols

// Typedefs
typedef struct _FILE_INFO {
    DWORD       TimeDateStamp;
    DWORD       CheckSum;
    TCHAR       szName[MAX_PATH];
} FILE_INFO, *PFILE_INFO;

BOOL
AddToReferenceCount(
    LPTSTR szDir,           // Directory where refs.ptr belongs
    LPTSTR szFileName,      // Full path and name of the file that is referenced.
    LPTSTR szPtrOrFile,     // Was a file or a pointer written
    BOOL   DeleteRefsPtr    // Flag to delete current refs.ptr and start over
);

BOOL 
DecidePriority( 
    LPTSTR szCurrentFilePtr,
    LPTSTR szCandidateFilePtr,
    LPTSTR szRefsDir,
    PUINT  choice
);

BOOL
CheckPriPub(
    LPTSTR szDir,
    LPTSTR szFilePtr,    // Current string that is in file.ptr
    LPTSTR szPubPriType  // Return value - whether file.ptr is
);                       // a pri, pub, bin, or unknown

PCHAR
GetFileNameStart( 
    LPTSTR FileName 
);

PIMAGE_NT_HEADERS
GetNtHeader (
    PIMAGE_DOS_HEADER pDosHeader,
    HANDLE hDosFile
);

BOOL
GetSymbolServerDirs(
    LPTSTR szFileName,
    GUID *guid,
    DWORD dwNum1,
    DWORD dwNum2,
    LPTSTR szDirName
);

BOOL
ReadFilePtr(
    LPTSTR szContents,
    HANDLE hFile
);

BOOL
StoreFile(
    LPTSTR szDestDir,
    LPTSTR szFileName,
    LPTSTR szString2,
    LPTSTR szPtrFileName
);

BOOL
StoreFilePtr(
    LPTSTR szDestDir,
    LPTSTR szString2,
    LPTSTR szPtrFileName
);

_TCHAR* _tcsistr(_TCHAR *s1, _TCHAR *s2) {

/* Do case insensitve search for string 2 in string 1.

*/
    LONG i,j,k;
    k = _tcslen(s2);
    j = _tcslen(s1) - k + 1;

    // it is not fast way, but works

    for (i=0; i<j; i++)
    {
        if (_tcsnicmp( &s1[i], s2, k) == NULL) 
        {
            return &s1[i];      
        }
    }
    return NULL;
}

BOOL
AddToReferenceCount(
    LPTSTR szDir,           // Directory where refs.ptr belongs
    LPTSTR szFileName,      // Full path and name of the file that is referenced.
    LPTSTR szPtrOrFile,     // Was a file or a pointer written
    BOOL   DeleteRefsPtr    // Should we delete the current refs.ptr?
)
{

    HANDLE hFile;
    TCHAR szRefsEntry[_MAX_PATH * 3];
    TCHAR szRefsFileName[_MAX_PATH + 1];
    DWORD dwPtr=0;
    DWORD dwError=0;
    DWORD dwNumBytesToWrite=0;
    DWORD dwNumBytesWritten=0;
    BOOL  FirstEntry = FALSE;
    DWORD First;

    StringCbPrintf( szRefsFileName, sizeof(szRefsFileName), "%s\\%s", szDir, _T("refs.ptr") );

    // Find out if this is the first entry in the file or not
    // First, try opening an existing file. If that doesn't work
    // then create a new one.

    First=1;
    do {
        FirstEntry = FALSE;
        hFile = CreateFile( szRefsFileName,
                            GENERIC_READ | GENERIC_WRITE,
                            0,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL );

        if ( hFile == INVALID_HANDLE_VALUE ) {
            FirstEntry = TRUE;
            hFile = CreateFile( szRefsFileName,
                                GENERIC_READ | GENERIC_WRITE,
                                0,
                                NULL,
                                CREATE_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL );
        }

        // Only print a message the first time through

        if ( First  && hFile == INVALID_HANDLE_VALUE ) {
            First = 0;
            so->printf( "Trying to get write access to %s ...\n", szRefsFileName);
        }
    } while ( hFile == INVALID_HANDLE_VALUE);


    if (DeleteRefsPtr) {
        FirstEntry = TRUE;
        dwPtr = SetFilePointer ( hFile,
                    0,
                    NULL,
                    FILE_BEGIN );

    } else {

        dwPtr = SetFilePointer( hFile,
                    0,
                    NULL,
                    FILE_END );
    }

    if (dwPtr == INVALID_SET_FILE_POINTER) {
        // Obtain the error code.
        dwError = GetLastError() ;
        so->printf("Failed to set end of the file %s with GetLastError = %d\n",
                szRefsFileName, dwError);

        SetEndOfFile(hFile);
        CloseHandle(hFile);
        return(FALSE);
    }

    //
    // Put in a '\n' if this isn't the first entry
    //

    if ( FirstEntry ) {
        StringCbPrintf( szRefsEntry, 
                        sizeof(szRefsEntry),
                        "%s,%s,%s,%s,,,,", 
                        pTrans->szId, 
                        szPtrOrFile, 
                        szFileName, 
                        szPriPubBin 
                      );
    } else {
        StringCbPrintf( szRefsEntry, sizeof(szRefsEntry), "\n%s,%s,%s,%s,,,,", 
                        pTrans->szId, szPtrOrFile, szFileName, szPriPubBin 
                      ); 
    }


    dwNumBytesToWrite = (_tcslen(szRefsEntry)  ) * sizeof(TCHAR);

    WriteFile( hFile,
               (LPCVOID) szRefsEntry,
               dwNumBytesToWrite,
               &dwNumBytesWritten,
               NULL
             );

    if ( dwNumBytesToWrite != dwNumBytesWritten ) {
        so->printf( "FAILED to write %s, with GetLastError = %d\n",
                szRefsEntry,
                GetLastError()
              );
        SetEndOfFile(hFile);
        CloseHandle(hFile);
        return (FALSE);
    }

    SetEndOfFile(hFile);
    CloseHandle(hFile);
    return (TRUE);
}


BOOL
CheckPriPub(
    LPTSTR szDir,
    LPTSTR szFilePtr,     // Current string that is in file.ptr
    LPTSTR szPubPriType   // Return value - whether file.ptr is
                          // a pri, pub, bin, or unknown
)
/*++ Figure out if the current entry is a public or private symbol

   IN szDir          Directory where refs.ptr should be
   In szFilePtr      Contents of current file.ptr
   OUT szPubPriType  Result equal to "pub", "pri", or "bin", according
                     to the pub/pri/bin field for this entry in refs.ptr.
                     If the entry isn't found or the entry does not have
                     the type of file filled in, this is the empty string.

   Return value:     This returns TRUE, if the file.ptr contents were found
                     in refs.ptr.  It returns FALSE otherwise.

-- */

{
    TCHAR szRefsFile[_MAX_PATH]; // Full path and name of the refs.ptr file
    FILE *fRefsFile;

    LPTSTR szBuf;      // Used to process entries in the refs file


    TCHAR *token;
    TCHAR seps[] = _T(",");

    BOOL rc = FALSE;
    ULONG MaxLine;     // Maximim length of a record in refs.ptr
    DWORD len;

    StringCbCopy( szPubPriType, sizeof(szPubPriType), _T("") );

    StringCbPrintf(szRefsFile, sizeof(szRefsFile), "%srefs.ptr", szDir );

    MaxLine = GetMaxLineOfRefsPtrFile();
    szBuf = (LPTSTR) malloc( MaxLine * sizeof(TCHAR) );
    if ( !szBuf ) MallocFailed();
    ZeroMemory(szBuf,MaxLine*sizeof(TCHAR));

    fRefsFile = _tfopen(szRefsFile, _T("r+") );
    if ( fRefsFile == NULL ) {
       // BARB - Check for corruption -- if the file doesn't exist,
       // verify that the parent directory structure doesn't exist either
       goto finish_CheckPriPub;
    }

    //
    // Read through the refs.ptr file and gather information
    //

    while ( _fgetts( szBuf, MaxLine, fRefsFile) != NULL ) {

      len=_tcslen(szBuf);
      if ( len > 3 ) {

        // See if this has a match with the current value in file.ptr

        if ( _tcsistr( szBuf, szFilePtr ) != NULL ) {
            rc = TRUE;
            token = _tcstok(szBuf, seps);  // Look at the ID
            if (token) {
                token = _tcstok(NULL, seps);      // "file" or "ptr"
            }
            if (token) {
                token = _tcstok(NULL, seps);      // value of file.ptr
                }
        if (token) {
            token = _tcstok(NULL, seps);      // bin, pri, pub
        }
        if (token) {
            if ( _tcsicmp( token, _T("pri"))== 0 ||
                 _tcsicmp( token, _T("pub"))== 0 ||
                 _tcsicmp( token, _T("bin"))== 0 ) {

                StringCbCopy( szPubPriType, sizeof(szPubPriType), token);
                goto finish_CheckPriPub;
            }
        }
     }
   }
   ZeroMemory(szBuf, MaxLine*sizeof(TCHAR));
 }

 finish_CheckPriPub:

 if ( fRefsFile != NULL) 
 {
    fclose(fRefsFile);
 }
 free (szBuf);
 return (rc);
} 

/* Decides if the current string has priority over the
   new string.  This is used for deciding whether or not to add
   the new string to file.ptr and refs.ptr.

   There are 3 choices:
   1.  Add it to file.ptr and refs.ptr
   2.  Add it to refs.ptr, but not file.ptr
   3.  Don't add it at all. 

   IN LPTSTR current -- The current string in file.ptr
   IN LPTSTR new     -- The new replacement candidate for file.ptr
   IN LPTSTR szRefsDir  The directory where refs.ptr is
   OUT choice        -- SKIP_ENTIRE_ENTRY, ADD_ENTIRE_ENTRY, or ADD_ONLY_REFSPTR

*/

BOOL 
DecidePriority( 
    LPTSTR szCurrentFilePtr,
    LPTSTR szCandidateFilePtr,
    LPTSTR szRefsDir,
    PUINT  choice
)
{

BOOL CurrentIsArch=FALSE;
BOOL NewIsArch=FALSE;
BOOL UpdateFilePtr=TRUE;
BOOL CurrentIsEnglish=FALSE;
BOOL NewIsEnglish=FALSE;
TCHAR szPubPriType[4] = "";

    *choice = 0;

    CurrentIsArch=(_tcsnicmp( szCurrentFilePtr, "\\\\arch\\", 7) == 0 );
    NewIsArch=(_tcsnicmp( szCandidateFilePtr, "\\\\arch\\", 7) == 0 );

    if ( CurrentIsArch && !NewIsArch)
    {
        // Don't store it
        *choice = SKIP_ENTIRE_ENTRY;
        return(TRUE);
    }

    if ( NewIsArch && !CurrentIsArch)
    {
        *choice = ADD_ENTIRE_ENTRY | DELETE_REFSPTR;  // Overwrite file.ptr no matter what
        return(TRUE);
    }

    // Look at private versus public priority

    if ( PubPriPriority > 0  &&                                         // We're checking private and
                                                                        // public priority
         CheckPriPub( szRefsDir, szCurrentFilePtr, szPubPriType ) &&    // There is something in current
         _tcsicmp( szPubPriType, szPriPubBin ) != 0 )                    // Current and candidate are not
                                                                        // the same.  Note:  they can be
                                                                        // "pub", "pri", "bin", or "null"
                                                                        // because earlier index files didn't
                                                                        // have a type in pub, pri, bin.
    {

        if (  _tcsicmp( szPubPriType, _T("")) == 0 )         // Current doesn't have types defined
        {
            *choice = ADD_ENTIRE_ENTRY;
            return(TRUE);
        } 
       
        if ( _tcsicmp( szPriPubBin, _T("")) == 0 )           // Candidate doesn't have types defined
        {
            *choice = ADD_ONLY_REFSPTR;
            return(TRUE);
        }

        if (  ( PubPriPriority == 1 &&                       // Give priority to public files
                _tcsicmp( szPubPriType, _T("pub")) == 0 ) || // and current is a public, or

              ( PubPriPriority == 2 &&                       // Give priority to private files
                _tcsicmp( szPubPriType, _T("pri")) == 0 ) )  // and current is a private
        {
            
            *choice = ADD_ONLY_REFSPTR;
            return(TRUE);
        } 

        if (  ( PubPriPriority == 1 &&                      // Give priority to public files
                _tcsicmp( szPubPriType, _T("pri")) == 0 ) || // and current is a private

              ( PubPriPriority == 2 &&                      // Give priority to private files
                _tcsicmp( szPubPriType, _T("pub")) == 0 ) )  // and current is a public
        {
            *choice = ADD_ENTIRE_ENTRY;
            return(TRUE);
        } 
    }

    // At this point both are on the archive or both are not on the archive.
    // Next, give priority to English vs. non-English.  If this is non-English,
    // then put it in refs.ptr, but don't update file.ptr. 


    if ( _tcsistr(szCurrentFilePtr,_T("\\enu\\")) != NULL  ||
         _tcsistr(szCurrentFilePtr,_T("\\en\\"))  != NULL  ||
         _tcsistr(szCurrentFilePtr,_T("\\usa\\")) != NULL )
    {
        CurrentIsEnglish=TRUE;
    }

    if ( _tcsistr(szCandidateFilePtr,_T("\\enu\\")) != NULL  ||
        _tcsistr(szCandidateFilePtr,_T("\\en\\"))  != NULL  ||
        _tcsistr(szCandidateFilePtr,_T("\\usa\\")) != NULL )
    {
        NewIsEnglish=TRUE;
    }
          
    if ( CurrentIsEnglish == TRUE && NewIsEnglish == FALSE )
    {
        *choice = ADD_ONLY_REFSPTR;
        return(TRUE);
    } 

    *choice = ADD_ENTIRE_ENTRY;
    return(TRUE);
}

BOOL
DeleteAllFilesInDirectory(
    LPTSTR szDir
)
{

    HANDLE hFindFile;
    BOOL Found = FALSE;
    BOOL rc = TRUE;
    TCHAR szBuf[_MAX_PATH];
    TCHAR szDir2[_MAX_PATH];
    WIN32_FIND_DATA FindFileData;

    StringCbCopy( szDir2, sizeof(szDir2), szDir);
    StringCbCat( szDir2, sizeof(szDir2), _T("*.*") );

    Found = TRUE;
    hFindFile = FindFirstFile((LPCTSTR)szDir2, &FindFileData);
    if ( hFindFile == INVALID_HANDLE_VALUE) 
    {
        Found = FALSE;
    }

    while ( Found ) 
    {
        if ( !(FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ) {
            StringCbPrintf(szBuf, sizeof(szBuf), "%s%s", szDir, FindFileData.cFileName);
            if (!DeleteFile(szBuf)) 
            {
                rc = FALSE;
            }
        }
        Found = FindNextFile(hFindFile, &FindFileData);
    }
    FindClose(hFindFile);
    return(rc);
}

//
// Filename is expected to point to the complete path+filename (relative or absolute)
// returns TRUE if Filename matches the regexp /.*~\d+\..{0,3}/
//
BOOL DoesThisLookLikeAShortFilenameHack(char *Filename) {
    BOOL  bReturnValue = FALSE;

    CHAR  FilenameOnly[_MAX_FNAME+1];
    CHAR  FileExtOnly[ _MAX_EXT+1];

    CHAR* Temp;
    CHAR* chTilde   = NULL;

    if (Filename != NULL) {

        _splitpath(Filename, NULL, NULL, FilenameOnly, FileExtOnly);

        if ( strlen(FileExtOnly) > 4 || strlen(FilenameOnly) > 8) {
            // a short filename will never be generated that is bigger than 8.3
            // but FileExtOnly will also contain the '.', so account for it
            bReturnValue = FALSE;
        } else {
            if ( (chTilde = strrchr(FilenameOnly, '~')) == NULL ) {
                // generated  short filenames always contain a '~'
                bReturnValue = FALSE;

            } else {
                // point to the end of the filename
                Temp = (CHAR*)FilenameOnly + strlen(FilenameOnly);
                bReturnValue = TRUE; // start with true              

                while (++chTilde < Temp) {
                    // only stay true if all characters past the '~' are digits
                    bReturnValue = bReturnValue && isdigit(*chTilde);
                }
            }
        }
    } else { // if (Filename != NULL) {
        bReturnValue = FALSE;
    }

    return(bReturnValue); 
}

BOOL FileExists(IN  LPCSTR FileName,
                OUT PWIN32_FIND_DATA FindData) {

    UINT OldMode;
    BOOL Found;
    HANDLE FindHandle;

    OldMode = SetErrorMode(SEM_FAILCRITICALERRORS);

    FindHandle = FindFirstFile(FileName,FindData);
    if (FindHandle == INVALID_HANDLE_VALUE) {
        Found = FALSE;
    } else {
        FindClose(FindHandle);
        Found = TRUE;
    }

    SetErrorMode(OldMode);
    return(Found);
}

/* GetFileNameStart This returns the address of the first character of the file name */
PCHAR GetFileNameStart(LPTSTR FileName) {
    LPTSTR c_ptr;

    c_ptr = FileName + _tcslen(FileName) - 1;
  
    while ( c_ptr > FileName ) {
        if ( *c_ptr == _T('\\') ) {
            return (++c_ptr); 
        } else {
            c_ptr--;
        }
    }
    return(FileName);
}


P_LIST GetList(LPTSTR szFileName) {

    /* GetList gets the list and keeps the original file name which could
     * have included the path to the file
     * Note, it can be merged with GetExcludeList.  I first created it for
     * use in creating the symbols CD, and didn't want to risk entering a
     * bug into symchk
     */

    P_LIST pList;

    FILE  *fFile;
    TCHAR szCurFile[_MAX_FNAME+1], *c;
    TCHAR fname[_MAX_FNAME+1], ext[_MAX_EXT+1];
    DWORD i, rc;
    LPTSTR szEndName;
    ULONG RetVal = FALSE;


    pList = (P_LIST)malloc(sizeof(LIST));
    if (pList)
    {
        pList->dNumFiles = 0;
        if (  (fFile = _tfopen(szFileName,_T("r") )) == NULL )
        {
            // printf( "Cannot open the exclude file %s\n",szFileName );
        }
        else
        {
            while ( _fgetts(szCurFile,_MAX_FNAME,fFile) ) {
                if ( szCurFile[0] == ';' ) continue;
                (pList->dNumFiles)++;
            }

            // Go back to the beginning of the file
            rc = fseek(fFile,0,0);
            if ( rc != 0 )
            {
                free(pList);
                fclose(fFile);
                return(NULL);
            }
            pList->List = (LIST_ELEM*)malloc( sizeof(LIST_ELEM) *
                                                   (pList->dNumFiles));
            if (pList->List)
            {
                i = 0;
                while ( i < pList->dNumFiles )
                {
                    memset(szCurFile,'\0',sizeof(TCHAR) * (_MAX_FNAME+1) );
                    if ( _fgetts(szCurFile,_MAX_FNAME,fFile) == NULL )
                    {
                        fclose(fFile);
                        return(NULL);
                    }

                    // Replace the \n with \0
                    c = NULL;
                    c  = _tcschr(szCurFile, '\n');
                    if ( c != NULL) *c='\0';

                    if ( szCurFile[0] == ';' ) continue;

                    if ( _tcslen(szCurFile) > _MAX_FNAME ) {
                        so->printf("File %s has a string that is too large\n",szFileName);
                        break;
                    }

                    // Allow for spaces and a ; after the file name
                    // Move the '\0' back until it has erased the ';' and any
                    // tabs and spaces that might come before it
                    szEndName = _tcschr(szCurFile, ';');
                    if (szEndName != NULL ) {
                        while ( *szEndName == ';' || *szEndName == ' '
                                                || *szEndName == '\t' ){
                            *szEndName = '\0';
                            if ( szEndName > szCurFile ) szEndName--;
                        }
                    }

                    StringCbCopy(pList->List[i].Path, sizeof(pList->List[i].Path), szCurFile);

                    _tsplitpath(szCurFile,NULL,NULL,fname,ext);

                    StringCbCopy(pList->List[i].FName,sizeof(pList->List[i].FName), fname);
                    StringCbCat( pList->List[i].FName,sizeof(pList->List[i].FName), ext);
                    i++;
                }

                if (i == pList->dNumFiles)
                {
                    RetVal = TRUE;
                }
                else
                {
                    free(pList->List);
                }
            }

            fclose(fFile);
        }

        if (!RetVal)
        {
            free(pList);
            pList = NULL;
        }
    }

            // Sort the List
            // qsort( (void*)pList->List, (size_t)pList->dNumFiles,
            //       (size_t)sizeof(LIST_ELEM), SymComp2 );


    return (pList);

}

PIMAGE_NT_HEADERS
GetNtHeader ( PIMAGE_DOS_HEADER pDosHeader,
              HANDLE hDosFile
            )
{

    /*
        Returns the pointer the address of the NT Header.  If there isn't
        an NT header, it returns NULL
    */
    PIMAGE_NT_HEADERS pNtHeader = NULL;
    BY_HANDLE_FILE_INFORMATION FileInfo;


    //
    // If the image header is not aligned on a long boundary.
    // Report this as an invalid protect mode image.
    //
    if ( ((ULONG)(pDosHeader->e_lfanew) & 3) == 0)
    {
        if (GetFileInformationByHandle( hDosFile, &FileInfo) &&
            ((ULONG)(pDosHeader->e_lfanew) <= FileInfo.nFileSizeLow))
        {
            pNtHeader = (PIMAGE_NT_HEADERS)((PCHAR)pDosHeader +
                                            (ULONG)pDosHeader->e_lfanew);

            if (pNtHeader->Signature != IMAGE_NT_SIGNATURE)
            {
                pNtHeader = NULL;
            }
        }
    }

    return pNtHeader;
}

/***********************************************************************************
  Function: GetSymbolServerDirs

  Purpose:
     To get the directory structure on the symbol server for the file passed in.

  Parameters:
     IN szFileName File name that is being stored on the symbol server.  
                   If it has path information, that will get stripped off.

     IN guid       This is a Guid for the PDB that is being stored.

     IN dwNum1     This is a timedatestamp for exe's or dbg's that are being stored.
                   Note:  Either guid must be null or dwNum1 must be 0.
     IN dwNum2     SizeOfImage for exe's and dbg's.  Age for PDb's.
     

     OUT szString  String with the two directories on the symbol server that this
                   file is stored under.
  Return value:
     Returns TRUE is the function succeeds.  Returns FALSE if it fails.

************************************************************************************/
BOOL GetSymbolServerDirs(
    LPTSTR szFileName,
    GUID *guid,
    DWORD dwNum1,
    DWORD dwNum2,
    LPTSTR szString
)
{

    BOOL   rc;
    GUID   MyGuid;
    PCHAR  FileNameStart;
    CHAR   Buf[_MAX_PATH] = _T("");

    FileNameStart = GetFileNameStart(szFileName);

    if (guid != NULL) 
    {
        rc = SymbolServer( _T("X"), FileNameStart, guid, dwNum2, 0, Buf ); 

    } else {

        // Turn this into a GUID so that we don't have to reset the SymbolServerOptions
        // SymbolServerSetOptions was set in main.
 
        memset( &MyGuid, 0, sizeof(MyGuid) );
        MyGuid.Data1 = dwNum1;
        rc = SymbolServer( _T("X"), FileNameStart, &MyGuid, dwNum2, 0, Buf );
    }

    // Remove the X\ that comes back at the beginning of Buf
    StringCchCopy(szString, _MAX_PATH, Buf+2 );
    
    // Remove the "\filename" that is at the end of Buf

    FileNameStart = GetFileNameStart( szString );
    *(FileNameStart-1) = _T('\0');

    return (TRUE);
}

BOOL
MyCopyFile(
    LPCTSTR lpExistingFileName,
    LPCTSTR lpNewFileName
)
/*++

Routine description:
    This handles whether the file is a compressed file or not.  First it
    tries to copy in the compressed version of the file.  If that works,
    then it will delete the uncompressed file if it exists in the target.

    If the compressed file is not there, then it copies in the 
    uncompressed file.

--*/
{

    TCHAR ExistingFileName_C[_MAX_PATH];  // Compressed version name
    TCHAR NewFileName_C[_MAX_PATH];       // Compressed version
    DWORD dw;
    BOOL rc;


    // Put a _ at the end of the compressed names

    StringCbCopy( ExistingFileName_C, sizeof(ExistingFileName_C), lpExistingFileName );
    ExistingFileName_C[ _tcslen(ExistingFileName_C) - 1 ] = _T('_');

    StringCbCopy( NewFileName_C, sizeof(NewFileName_C), lpNewFileName );
    NewFileName_C[ _tcslen( NewFileName_C ) - 1 ] = _T('_');

    // If the compressed file exists, copy it instead of the uncompressed file

    dw = GetFileAttributes( ExistingFileName_C );
    if ( dw != 0xffffffff) {
        rc = CopyFile( ExistingFileName_C, NewFileName_C, TRUE );
        if ( !rc && GetLastError() != ERROR_FILE_EXISTS  ) {
            so->printf("CopyFile failed to copy %s to %s - GetLastError() = %d\n",
                   ExistingFileName_C, NewFileName_C, GetLastError() );
            return (FALSE);
        }
        SetFileAttributes( NewFileName_C, FILE_ATTRIBUTE_NORMAL );

        // If the uncompressed file exists, delete it
        dw = GetFileAttributes( lpNewFileName );
        if ( dw != 0xffffffff ) {
           rc = DeleteFile( lpNewFileName );
           if (!rc) {
               so->printf("Keeping %s, but could not delete %s\n",
                  NewFileName_C, lpNewFileName );
           }
        }
    } else {
        // Compressed file doesn't exist, try the uncompressed
        dw = GetFileAttributes( lpExistingFileName );
        if ( dw != 0xffffffff ) {
            rc = CopyFile( lpExistingFileName, lpNewFileName, TRUE );
            if ( !rc && GetLastError() != ERROR_FILE_EXISTS ) {
                so->printf("CopyFile failed to copy %s to %s - GetLastError() = %d\n",
                       lpExistingFileName, lpNewFileName, GetLastError() );
                return (FALSE);
            }
            SetFileAttributes( lpNewFileName, FILE_ATTRIBUTE_NORMAL );
        }
    }
    return(TRUE);
}

void MyEnsureTrailingBackslash(char *sz) {
    return MyEnsureTrailingChar(sz, '\\');
}

void MyEnsureTrailingChar(char *sz, char  c) {
    int i;

    assert(sz);

    i = strlen(sz);
    if (!i)
        return;

    if (sz[i - 1] == c)
        return;

    sz[i] = c;
    sz[i + 1] = '\0';
}

void MyEnsureTrailingCR(char *sz) {
    return MyEnsureTrailingChar(sz, '\n');
}

void MyEnsureTrailingSlash(char *sz) {
    return MyEnsureTrailingChar(sz, '/');
}

BOOL
ReadFilePtr(
    LPTSTR szContents,
    HANDLE hFile
    )
{
    BOOL   rc;
    DWORD  size;
    DWORD  cb;
    LPTSTR p;
    DWORD high;


    size = GetFileSize(hFile, NULL);
    if (!size || size > _MAX_PATH) {
        return FALSE;
    }

    // read it

    if (!ReadFile(hFile, szContents, size, &cb, 0)) {
        rc=FALSE;
        goto cleanup;
    }

    if (cb != size) {
        rc=FALSE;
        goto cleanup;
    }

    rc = true;

    // trim string down to the CR

    for (p = szContents; *p; p++) {
        if (*p == 10  || *p == 13)
        {
            *p = 0;
            break;
        }
    }

cleanup:

    // done
    SetFilePointer( hFile, 0, NULL, FILE_BEGIN);
    return rc;
}

BOOL
StoreDbg(
    LPTSTR szDestDir,
    LPTSTR szFileName,
    LPTSTR szPtrFileName,
    USHORT *rc_flag
    )

/* ++

    Routine Description:
        Stores this file as "szDestDir\szFileName\Checksum"

    Return Value:
        TRUE -  file was stored successfully
        FALSE - file was not stored successfully

-- */
{

    PIMAGE_SEPARATE_DEBUG_HEADER pDbgHeader;
    HANDLE hFile;
    BOOL rc;
    TCHAR szString[_MAX_PATH];
    UINT i;
    IMAGE_DEBUG_DIRECTORY UNALIGNED *DebugDirectory, *pDbgDir;
    ULONG NumberOfDebugDirectories;


    ZeroMemory(szString, _MAX_PATH * sizeof(TCHAR) );

    pDbgHeader = SymCommonMapDbgHeader ( szFileName, &hFile );

    if (pDbgHeader == NULL) {
        so->printf("ERROR: StoreDbg(), %s was not opened successfully\n",szFileName);
        SymCommonUnmapFile((LPCVOID)pDbgHeader, hFile);
        return FALSE;
    }


    DebugDirectory = NULL;
    DebugDirectory = GetDebugDirectoryInDbg(
                                       pDbgHeader,
                                       &NumberOfDebugDirectories
                                       );
    PrivateStripped = TRUE;

    if (DebugDirectory != NULL) {

        for ( i=0; i< NumberOfDebugDirectories; i++ ) {
            pDbgDir = DebugDirectory + i;
            __try
            {
                switch (pDbgDir->Type) {
                    case IMAGE_DEBUG_TYPE_MISC:
                        break;

                    case IMAGE_DEBUG_TYPE_CODEVIEW:
                        if ( !DBGPrivateStripped(
                                DebugDirectory->PointerToRawData + (PCHAR)pDbgHeader, 
                                DebugDirectory->SizeOfData
                                ) ) {
                           PrivateStripped = FALSE; 
                        }
                        if (PrivateStripped) {
                            StringCbCopy(szPriPubBin, sizeof(szPriPubBin), _T("pub") );
                        }  
                        break;

                    default:
                        // Nothing except the CV entry should point to raw data
                        if ( pDbgDir->SizeOfData != 0 ) {
                            PrivateStripped = FALSE;
                        }
                        break;
                }
            }
             __except( EXCEPTION_EXECUTE_HANDLER )
            {
                SymCommonUnmapFile((LPCVOID)pDbgHeader, hFile);
                return FALSE;
            }
        }
    }

    // Something is wrong with how we are figuring out what has private info stripped.
    // Go back to saying that every DBG is public until we get it figured out.

    PrivateStripped = TRUE;

    if (PrivateStripped) {
        StringCbCopy(szPriPubBin, sizeof(szPriPubBin), _T("pub") );
    } else {
        StringCbCopy(szPriPubBin, sizeof(szPriPubBin), _T("pri") );
    } 

    if ( ( (pArgs->Filter == 2) && PrivateStripped ) || 
         ( (pArgs->Filter == 1) && !PrivateStripped ) ) {
        SymCommonUnmapFile((LPCVOID)pDbgHeader, hFile);
        *rc_flag = FILE_SKIPPED;
        return TRUE;
    }


    GetSymbolServerDirs( szFileName,
                NULL, 
                (DWORD) pDbgHeader->TimeDateStamp,
                (DWORD) pDbgHeader->SizeOfImage,
                szString
              ); 

    rc = StoreFile( szDestDir, 
                    szFileName,
                    szString,
                    szPtrFileName );

    SymCommonUnmapFile((LPCVOID)pDbgHeader, hFile);
    return rc;
}

BOOL
StoreFile(
    LPTSTR szDestDir,
    LPTSTR szFileName,
    LPTSTR szString2,
    LPTSTR szPtrFileName
)
{
    TCHAR szPathName[_MAX_PATH + _MAX_FNAME + 2];
    TCHAR szFileNameOnly[_MAX_FNAME + _MAX_EXT];
    TCHAR szExt[_MAX_EXT];
    TCHAR szBuf[_MAX_PATH * 3];
    TCHAR szRefsDir[_MAX_PATH * 3];

    DWORD dwNumBytesToWrite;
    DWORD dwNumBytesWritten;
    BOOL rc;
    DWORD dwSizeDestDir;

    DWORD dwFileSizeLow;
    DWORD dwFileSizeHigh;


    if (DoesThisLookLikeAShortFilenameHack(szFileName)) {
        fprintf(stderr, "SYMSTORE: Skipping bad filename: %s\n", szFileName);
        return(FILE_SKIPPED);
    }

    // If ADD_DONT_STORE, then write the function parameters
    // to a file so we can call this function exactly when
    // running ADD_STORE_FROM_FILE

    if ( StoreFlags == ADD_DONT_STORE ) {

        // Don't need to store szDestDir because it will
        // be given when adding from file

        dwFileSizeLow = GetFileSize(hTransFile, &dwFileSizeHigh);

        StringCbPrintf( szBuf,
                        sizeof(szBuf),
                        "%s,%s,",
                        szFileName+pArgs->ShareNameLength,
                        szString2
                      );

        if ( szPtrFileName != NULL ) {
            StringCbCat(szBuf, sizeof(szBuf), szPtrFileName+pArgs->ShareNameLength);
        }
      
        StringCbCat(szBuf, sizeof(szBuf), _T(",") ); 
        StringCbCat(szBuf, sizeof(szBuf), szPriPubBin); 
        StringCbCat(szBuf, sizeof(szBuf), _T(",,,,\r\n") );

        dwNumBytesToWrite = _tcslen(szBuf) * sizeof(TCHAR);
        WriteFile(  hTransFile,
                    (LPCVOID)szBuf,
                    dwNumBytesToWrite,
                    &dwNumBytesWritten,
                    NULL
                    );

        if ( dwNumBytesToWrite != dwNumBytesWritten ) {
            so->printf( "FAILED to write to %s, with GetLastError = %d\n",
                    szPathName,
                    GetLastError()
                    );
            return (FALSE);
        } else {
            return (TRUE);

        }
    }

    if ( szPtrFileName != NULL ) {
        rc = StoreFilePtr ( szDestDir,
                            szString2,
                            szPtrFileName
                          );
        return (rc);
    }

    _tsplitpath(szFileName, NULL, NULL, szFileNameOnly, szExt);
    StringCbCat(szFileNameOnly, sizeof(szFileNameOnly), szExt);

    StringCbPrintf( szPathName, 
                    sizeof(szPathName), 
                    "%s%s", 
                    szDestDir, 
                    szString2 
                  );

    // Save a copy for writing refs.ptr
    StringCbCopy(szRefsDir, sizeof(szRefsDir), szPathName);

    // Create the directory to store the file if its not already there
    MyEnsureTrailingBackslash(szPathName);

    if ( pArgs->TransState != TRANSACTION_QUERY ) {
        if ( !MakeSureDirectoryPathExists( szPathName ) ) {
            so->printf("Could not create %s\n", szPathName);
            return (FALSE);
        }
    }

    StringCbCat( szPathName, sizeof(szPathName), szFileNameOnly );

    // Enter this into the log, skipping the Destination directory
    // at the beginning of szPathName
    //
    dwSizeDestDir = _tcslen(szDestDir);

    dwFileSizeLow = GetFileSize(hTransFile, &dwFileSizeHigh);

    if ( dwFileSizeLow == 0 && dwFileSizeHigh == 0 ) {
        StringCbPrintf( szBuf, sizeof(szBuf), "%s,%s", szRefsDir+dwSizeDestDir, szFileName );
    } else {
        StringCbPrintf( szBuf, sizeof(szBuf), "\n%s,%s", szRefsDir+dwSizeDestDir, szFileName );
    }

    if ( pArgs->TransState == TRANSACTION_QUERY ) {
        WIN32_FIND_DATA FindData;

        if ( FileExists(szPathName, &FindData) ) {
            if ( !(FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ) {
                printf("SYMSTORE: \"%s\"\t\"%s\"\n", szFileName, szPathName);
            } else {
                // handle the case of it being a directory
                printf("SYMSTORE: ERROR: %s is a directory!\n", szPathName);
            }
        } else {
            // handle the case of file.ptr
            CHAR  drive[_MAX_DRIVE];
            CHAR  dir[  _MAX_DIR];
            CHAR  file[ _MAX_FNAME];
            CHAR  ext[  _MAX_EXT];
            CHAR  NewFilename[MAX_PATH];

            _splitpath(szPathName, drive, dir, file, ext);

            //
            // 'Magic' to handle the fact that splitpath() doesn't do the
            // Right Thing(tm) with UNC paths.
            //
            if ( drive[0] != '\0') {
                StringCbCopy(NewFilename, sizeof(NewFilename), drive);
                StringCbCat( NewFilename, sizeof(NewFilename), "\\");
            } else {
                NewFilename[0] = '\0';
            }
            StringCbCat( NewFilename, sizeof(NewFilename), dir);
            StringCbCat( NewFilename, sizeof(NewFilename), "file.ptr");

            if ( FileExists(NewFilename, &FindData) ) {
                if ( !(FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ) {
                    HANDLE hFile = CreateFile( NewFilename,
                                               GENERIC_READ,
                                               0,
                                               NULL,
                                               OPEN_ALWAYS,
                                               FILE_ATTRIBUTE_NORMAL,
                                               NULL );

                    if (hFile != INVALID_HANDLE_VALUE) {
                        if ( ReadFilePtr(szBuf, hFile) ) {
                            if ( FileExists(szBuf, &FindData) ) {
                                printf("SYMSTORE: \"%s\"\t\"%s\"\n", szFileName, szBuf);
                            } else {
                                if(pArgs->VerboseOutput) {
                                    printf("SYMSTORE: Skipped \"%s\" - doesn't exist!\n", szBuf);
                                }
                            }
                        }
                    } else {
                        printf("SYMSTORE: ERROR: Couldn't read %s!\n", NewFilename);
                    }
                } else {
                    printf("SYMSTORE: ERROR: %s is a directory!\n", NewFilename);
                }
            } else {
                if(pArgs->VerboseOutput) {
                    printf("SYMSTORE: Skipped \"%s\" - doesn't exist!\n", szPathName);
                }
            }
        }
        return(1); // so we don't get a failed store message

    }

    if ( pArgs->TransState != TRANSACTION_QUERY ) {
        dwNumBytesToWrite = _tcslen(szBuf) * sizeof(TCHAR);
        WriteFile( hTransFile,
                   (LPCVOID)szBuf,
                   dwNumBytesToWrite,
                   &dwNumBytesWritten,
                   NULL
                   );

        if ( dwNumBytesToWrite != dwNumBytesWritten ) {
            so->printf( "FAILED to write to %s, with GetLastError = %d\n",
                    szPathName,
                    GetLastError()
                  );
            return (FALSE);
        }
   
        rc = MyCopyFile(szFileName, szPathName);

        if (!rc) return (FALSE);

        MyEnsureTrailingBackslash(szRefsDir);

        rc = AddToReferenceCount(szRefsDir, szFileName, _T("file"), FALSE );
    }

    return (rc);
}


BOOL
StoreFilePtr(
    LPTSTR szDestDir,
    LPTSTR szString2,
    LPTSTR szPtrFileName
)
{

    /*
        szPathName  The full path with "file.ptr" appended to it.
                    This is the path for storing file.ptr

    */

    TCHAR szPathName[_MAX_PATH];
    TCHAR szRefsDir[_MAX_PATH];
    TCHAR szPubPriType[4]="";

    HANDLE hFile;
    DWORD dwNumBytesToWrite;
    DWORD dwNumBytesWritten;
    DWORD rc=1;
    DWORD dwSizeDestDir;

    DWORD dwFileSizeLow;
    DWORD dwFileSizeHigh;
    DWORD timeout;
    TCHAR szCurrentFilePtr[_MAX_PATH]= "";
    DWORD size=0;
    DWORD highsize=0;
    DWORD dwError;
    BOOL UpdateRefsPtr=TRUE;
    BOOL UpdateFilePtr=TRUE;
    BOOL DeleteRefsPtr=FALSE;
    UINT DecisionFlags;

    StringCbPrintf( szPathName, sizeof(szPathName), "%s%s", 
               szDestDir, 
               szString2 );

    MyEnsureTrailingBackslash( szPathName );
    
    // Save this for passing in the refs.ptr directory
    StringCbCopy(szRefsDir, sizeof(szRefsDir), szPathName);
    StringCbPrintf( szPathName, 
                    sizeof(szPathName), 
                    "%s%s", 
                    szPathName, 
                    _T("file.ptr") 
                  );


    if ( !MakeSureDirectoryPathExists( szPathName ) ) {
        so->printf("Could not create %s\n", szPathName);
        return (FALSE);
    }

    // Put this file into file.ptr.  If file.ptr is already there, then
    // replace the contents with this pointer

    // Wait for the file to become available
    timeout=0;

    do {
        hFile = CreateFile( szPathName,
                            GENERIC_WRITE | GENERIC_READ,
                            0,
                            NULL,
                            OPEN_ALWAYS,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL );


        // Make sure that delete didn't come through and remove the directory
        if ( !MakeSureDirectoryPathExists( szPathName ) ) {
            so->printf("Could not create %s\n", szPathName);
            return (FALSE);
        }

        if ( hFile == INVALID_HANDLE_VALUE ) {
            SleepEx(1000,0);
            timeout++;
        }

    } while ( hFile == INVALID_HANDLE_VALUE  && timeout <= 50 ) ;

    if ( (hFile == INVALID_HANDLE_VALUE) || (timeout > 50) ) {
        so->printf( "Failed to open %s for writing, with GetLastError = %d\n", szPathName, GetLastError() );
        return(FALSE);
    }

    // If the pointer we are adding points to \\arch\, then add it.
    // If the pointer we are adding doesn't point to \\arch\, then
    // don't overwrite a file.ptr that does point to \\arch\.

    UpdateFilePtr = TRUE;
    UpdateRefsPtr = TRUE;
    DeleteRefsPtr = FALSE;

    if ( MSArchive && ReadFilePtr( szCurrentFilePtr, hFile ) )
    {

        DecidePriority( szCurrentFilePtr,
                        szPtrFileName,
                        szRefsDir,
                        &DecisionFlags
                      );

        if ( DecisionFlags & SKIP_ENTIRE_ENTRY )
        {
            UpdateFilePtr = FALSE;
            UpdateRefsPtr = FALSE;
        }
                        
        if ( DecisionFlags & ADD_ONLY_REFSPTR )
        {
            UpdateFilePtr = FALSE;
        }

        if ( DecisionFlags & DELETE_REFSPTR )
        {
            DeleteRefsPtr = TRUE;
        }
    }

    if ( UpdateFilePtr ) {

        dwNumBytesToWrite = _tcslen(szPtrFileName) * sizeof(TCHAR);

        WriteFile( hFile,
                   (LPCVOID)szPtrFileName,
                   dwNumBytesToWrite,
                   &dwNumBytesWritten,
                   NULL
                 );

        if ( dwNumBytesToWrite != dwNumBytesWritten ) {
              so->printf( "FAILED to write %s, with GetLastError = %d\n",
                          szPathName,
                          GetLastError()
                        );
              CloseHandle(hFile);
              return (FALSE);
        }
        SetEndOfFile(hFile);
   
    }

    if ( UpdateRefsPtr ) {

        // Enter this into the log, skipping the first part that is the root
        // of the symbols server
    
        dwSizeDestDir = _tcslen(szDestDir);
        dwFileSizeLow = GetFileSize(hTransFile, &dwFileSizeHigh);

        if ( dwFileSizeLow == 0 && dwFileSizeHigh == 0 ) {
            StringCbPrintf( szPathName, sizeof(szPathName), "%s,%s", szRefsDir + dwSizeDestDir, szPtrFileName);
        } else {
            StringCbPrintf( szPathName, sizeof(szPathName), "\n%s,%s", szRefsDir + dwSizeDestDir, szPtrFileName);
        }

        dwNumBytesToWrite = _tcslen(szPathName) * sizeof(TCHAR);
        WriteFile( hTransFile,
                   (LPCVOID)(szPathName),
                   dwNumBytesToWrite,
                   &dwNumBytesWritten,
                   NULL
                 );

        if ( dwNumBytesToWrite != dwNumBytesWritten ) {
            so->printf( "FAILED to write to %s, with GetLastError = %d\n",
                        szPathName,
                        GetLastError()
                      );
            return (FALSE);
        }

        // File.ptr was created successfully, now, add the contents of
        // szPathName to refs.ptr

        MyEnsureTrailingBackslash(szRefsDir);
        rc = AddToReferenceCount( szRefsDir, szPtrFileName, "ptr", DeleteRefsPtr );
        if (!rc) {
            so->printf("AddToReferenceCount failed for %s,ptr,%s",
                        szDestDir, szPtrFileName);
        }

    }

    // If you close this handle sooner, there will be problems if add and
    // delete are running at the same time.  The delete process can come in
    // and delete the directory before AddToReferenceCount gets called.
    // Then the CreateFile in there fails.


    CloseHandle(hFile);
    return (rc);
}

DWORD
StoreFromFile(
    FILE *pStoreFromFile,
    LPTSTR szDestDir,
    PFILE_COUNTS pFileCounts) {

    LPTSTR szFileName;
    DWORD  dw1,dw2;
    LPTSTR szPtrFileName;
    LPTSTR szBufCut;

    TCHAR szFullFileName[_MAX_PATH];
    TCHAR szFullPtrFileName[_MAX_PATH];
    TCHAR szBuf[_MAX_PATH*4];

    TCHAR szString[_MAX_PATH];
    LPTSTR token2,token3,token4,token5,token6,token7;
    ULONG i,comma_count,token_start;

    BOOL rc;

    ZeroMemory( szString, sizeof(szString) );

    // Read in each line of the file
    while ( !feof( pStoreFromFile) ) {

        szFileName    = NULL;
        szPtrFileName = NULL;
        StringCbCopy(szBuf, sizeof(szBuf), _T("") );

        if (!fgets( szBuf, _MAX_PATH*4, pStoreFromFile)) {
            break;
        }

        // Cut the comment
        if ( (szBufCut = _tcschr( szBuf, ';' ) ) != NULL ) {
            szBufCut[0] = '\0';
        }

        // skip no fields line
        if (_tcschr( szBuf, ',' ) == NULL)
        {
            continue;
        }

        StringCbCopy( szFullFileName,    sizeof(szFullFileName),    pArgs->szShareName );
        StringCbCopy( szFullPtrFileName, sizeof(szFullPtrFileName), pArgs->szShareName );


        // Step through szBuf and count how many commas there are
        // If there are 3 commas, this is a new style file.  If there
        // are 4 commas, this is an old style file.
        // If there are 7 commas, this is the newest style file.

        token2=NULL;
        token3=NULL;
        token4=NULL;
        token5=NULL;
        token6=NULL;
        token7=NULL;

        comma_count=0;
        i=0;
        token_start=i;

        while ( szBuf[i] != _T('\0') && comma_count < 7 ) {
            if ( szBuf[i] == _T(',') ) {
                switch (comma_count) {
                    case 0: szFileName=szBuf;
                            break;
                    case 1: token2=szBuf+token_start;
                            break;
                    case 2: token3=szBuf+token_start;
                            break;
                    case 3: token4=szBuf+token_start;
                            break;
                    case 4: token5=szBuf+token_start;
                            break;
                    case 5: token6=szBuf+token_start;
                            break;
                    case 6: token7=szBuf+token_start;
                            break;
                    default: break; 
                }
                token_start=i+1;
                szBuf[i]=_T('\0');
                comma_count++;
            }
            i++;
        }

        if ( szFileName != NULL ) {
            StringCbCat( szFullFileName, sizeof(szFullFileName), szFileName);

            if ( comma_count == 3  || comma_count == 7 ) {
                //This is the new style
                StringCbCopy( szString, sizeof(szString), token2);
                if ( (token3 != NULL ) && (*token3 != _T('\0')) ) {
                    szPtrFileName=token3;
                }
            } else  {
                dw1=atoi(token2);
                dw2=atoi(token3);
                if ( *token4 != _T('\0') ) {
                    szPtrFileName=token4;
                }
                GetSymbolServerDirs( szFileName, NULL, dw1, dw2, szString );
            } 

            if ( comma_count == 7 ) {
                StringCbCopy( szPriPubBin, sizeof(szPriPubBin), token4 );
            } 

            if (pArgs->StorePtrs == TRUE) {
                szPtrFileName=szFileName;
            }

            if ( szPtrFileName != NULL ) {
                StringCbCat( szFullPtrFileName, sizeof(szFullPtrFileName), szPtrFileName);
            }


            if ( szPtrFileName == NULL ) {
                rc = StoreFile(szDestDir,szFullFileName,szString,NULL);

            } else {
                rc = StoreFile(szDestDir,szFullFileName,szString,szFullPtrFileName);
            }

            if (rc) {
                pFileCounts->NumPassedFiles++;
            } else {
                pFileCounts->NumFailedFiles++;
            }
        }
    }
    free(szBuf);
    return(pFileCounts->NumFailedFiles);
}

BOOL
StoreNtFile(
    LPTSTR szDestDir,
    LPTSTR szFileName,
    LPTSTR szPtrFileName,
    USHORT *rc
    )

/*++

    Routine Description:
        Stores this file as "szDestDir\szFileName\Checksum"

    Return Value:
        TRUE -  file was stored successfully
        FALSE - file was not stored successfully

--*/
{

    BOOL   temp_rc;
    HANDLE DosFile = 0;
    DWORD  dwErrorCode = 0;

    PIMAGE_DOS_HEADER pDosHeader = NULL;
    PIMAGE_NT_HEADERS pNtHeader = NULL;
    ULONG TimeDateStamp;
    ULONG SizeOfImage;
    TCHAR szString[_MAX_PATH];

    ZeroMemory(szString, _MAX_PATH*sizeof(TCHAR) );

    pDosHeader = SymCommonMapFileHeader( szFileName, &DosFile, &dwErrorCode );
    if ( pDosHeader == NULL ) {
        *rc = FILE_SKIPPED;
        return FALSE;
    };

    pNtHeader = GetNtHeader( pDosHeader, DosFile);
    if ( pNtHeader == NULL ) {
        SymCommonUnmapFile((LPCVOID)pDosHeader,DosFile);
        *rc = FILE_SKIPPED;
        return FALSE;
    }

    __try {
        // Resource Dll's shouldn't have symbols
        if ( SymCommonResourceOnlyDll((PVOID)pDosHeader) ) {
            *rc = FILE_SKIPPED;
            __leave;
        }

        TimeDateStamp = pNtHeader->FileHeader.TimeDateStamp;

        if (pNtHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
            SizeOfImage = ((PIMAGE_NT_HEADERS32)pNtHeader)->OptionalHeader.SizeOfImage;
        } else {
            if (pNtHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
                SizeOfImage = ((PIMAGE_NT_HEADERS64)pNtHeader)->OptionalHeader.SizeOfImage;
            } else {
                SizeOfImage = 0;
            }
        }

    } __finally {
        SymCommonUnmapFile((LPCVOID)pDosHeader,DosFile);
    }

    if (*rc == FILE_SKIPPED)
    {
        return(FALSE);
    }

    StringCbCopy( szPriPubBin, sizeof(szPriPubBin), _T("bin") );

    GetSymbolServerDirs( szFileName,
                NULL,
                (DWORD) TimeDateStamp,
                (DWORD) SizeOfImage,
                szString );

    temp_rc = StoreFile( szDestDir, 
                         szFileName, 
                         szString,
                         szPtrFileName );

    *rc = (USHORT)temp_rc;
    if (temp_rc) {
        if (pArgs->CorruptBinaries) {
            TCHAR  BinToCorrupt[_MAX_PATH];
            TCHAR  Temp[_MAX_PATH];
            LPTSTR pFilename;
            DWORD  dwRet = 0xFFFFFFFF;

            SymCommonGetFullPathName(szDestDir, sizeof(BinToCorrupt)/sizeof(BinToCorrupt[0]), BinToCorrupt, &pFilename);
            SymCommonGetFullPathName(szFileName, sizeof(Temp)/sizeof(Temp[0]), Temp, &pFilename);
            StringCbCat(BinToCorrupt, sizeof(BinToCorrupt), szString ); 
            StringCbCat(BinToCorrupt, sizeof(BinToCorrupt), TEXT("\\") ); 
            StringCbCat(BinToCorrupt, sizeof(BinToCorrupt), pFilename ); 

            if (! (dwRet=CorruptFile(BinToCorrupt))==PEWHACK_SUCCESS ) {
                fprintf(stderr, "Unable to corrupt %s (0x%08x).\n", BinToCorrupt, dwRet);
            }
        }

        return (TRUE);
    }
    else {
        return (FALSE);
    }
}

BOOL
StorePdb(
    LPTSTR szDestDir,
    LPTSTR szFileName,
    LPTSTR szPtrFileName,
    USHORT *rc_flag
    )

/*++

    Routine Description:
        Validates the PDB

    Return Value:
        TRUE    PDB validates
        FALSE   PDB doesn't validate
--*/

{

    BOOL rc;

    BOOL valid;
    PDB *pdb;
    EC ec;
    char szError[cbErrMax] = _T("");
    SIG sig;
    AGE age=0;
    SIG70 sig70;
    TCHAR szString[_MAX_PATH];

    DBI *pdbi;
    GSI *pgsi;
   
    ZeroMemory( szString, _MAX_PATH * sizeof(TCHAR) ); 
    ZeroMemory( &sig70, sizeof(SIG70) );
    pdb=NULL;

    __try
    {
        valid = PDBOpen( szFileName,
                   _T("r"),
                   0,
                   &ec,
                   szError,
                   &pdb
                   );

    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
       valid=FALSE;
    }

    if ( !valid ) {
        SetLastError(ec);
        *rc_flag = (USHORT)ec;
        return FALSE;
    }

    // The DBI age is created when the exe is created.
    // This age will not change if an operation is performed
    // on the PDB that increments its PDB age.

    __try
    {
        valid = PDBOpenDBI(pdb, pdbRead, NULL, &pdbi);
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        valid=FALSE;
    }

    if ( !valid ) {
        SetLastError(ec);
        *rc_flag = (USHORT)ec;
        PDBClose(pdb);
        return FALSE;
    }


    // Do we need to determine if this is a public or private pdb?
    // If we do, then proceed through the next section.
    //
    // Windows stuffs type info into the kernels so this section tries
    // a way around checking for type info to determine if this is a
    // private pdb or not.  

    valid = TRUE; 

    __try
    {
        PrivateStripped=PDBPrivateStripped(pdb, pdbi);
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        valid = FALSE;
    }

    if ( !valid) {
        DBIClose(pdbi);
        PDBClose(pdb);
        return FALSE;
    }

    if (PrivateStripped) {
        StringCbCopy( szPriPubBin, sizeof(szPriPubBin), _T("pub") );
    } else {
        StringCbCopy( szPriPubBin, sizeof(szPriPubBin), _T("pri") );
    }

    // Determine if we are supposed to skip this file or index it.

    if ( ( PrivateStripped && (pArgs->Filter == 2)) ||  // public pdb and index private pdbs
         (!PrivateStripped && (pArgs->Filter == 1)) ) { // private pdb and index public pdbs
        *rc_flag = FILE_SKIPPED;
        DBIClose(pdbi);
        PDBClose(pdb);
        return TRUE;
    }

    if (PrivateStripped) {
        StringCbCopy( szPriPubBin, sizeof(szPriPubBin), _T("pub") );
    } else {
        StringCbCopy( szPriPubBin, sizeof(szPriPubBin), _T("pri") );
    }

    age = pdbi->QueryAge();
    // If the DBI age is zero, then use the pdb age
    if ( age == 0 )
    {
        age = pdb->QueryAge();
    }
    sig = PDBQuerySignature(pdb);
    rc = PDBQuerySignature2(pdb, &sig70);

    DBIClose(pdbi);
    PDBClose(pdb);

    if (rc) {
        GetSymbolServerDirs( szFileName,
                    &sig70,
                    (DWORD) sig,
                    (DWORD) age,
                    szString );
    } else {
        GetSymbolServerDirs( szFileName,
                    NULL,
                    (DWORD) sig,
                    (DWORD) age,
                    szString );
    }

    rc = StoreFile( szDestDir,
                    szFileName,
                    szString,
                    szPtrFileName
                  );

    return (rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\symchk\symstore\symutil.h ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>
#include <assert.h>

#define IGNORE_IF_SPLIT     130
#define ERROR_IF_SPLIT      131
#define ERROR_IF_NOT_SPLIT  132

#define TRANSACTION_ADD     201
#define TRANSACTION_DEL     202
#define DONT_STORE_FILES    203
#define STORE_FILE          204
#define STORE_PTR           205
#define TRANSACTION_QUERY   220

#define DEL                 210
#define ADD_STORE           206
#define ADD_DONT_STORE      207
#define ADD_STORE_FROM_FILE 208
#define QUERY               221

#define MAX_VERSION          20
#define MAX_PRODUCT         120
#define MAX_COMMENT         346
#define MAX_ID               10
#define MAX_DATE              8
#define MAX_TIME              8
#define MAX_UNUSED            0

// Define some constants for lengths in the transaction record
// in order to define the maximum length of the record that will
// be written to the master file.
#define TRANS_NUM_COMMAS       8
#define TRANS_EOL              1
#define TRANS_ADD_DEL          3
#define TRANS_FILE_PTR         4


// Define some constants for determining what happened when an NT
// file was stored
#define FILE_STORED             1
#define FILE_SKIPPED            2
#define FILE_ERRORED            3

// Define some flag values for determing whether or not to add the file
// pointer to refs.ptr and file.ptr.
#define ADD_ENTIRE_ENTRY    1
#define SKIP_ENTIRE_ENTRY   2
#define ADD_ONLY_REFSPTR    4
#define DELETE_REFSPTR      8


typedef struct _TRANSACTION {
    LPTSTR szId;          // Id for this transaction
                          // This always refers to the transaction file that
                          // is being deleted or added

    LPTSTR szDelId;       // Id for a delete transaction
                          // This is just appended to the master file, there is
                          // no file created for it.

    DWORD  TransState;    // State of this transaction
    DWORD  FileOrPtr;     // Are we storing files or pointers?
    LPTSTR szProduct;     // Name of the product being added
    LPTSTR szVersion;     // Version of the product
    LPTSTR szComment;     // Description
    LPTSTR szTransFileName; // Full Path and name of the Transaction file
    LPTSTR szTime;
    LPTSTR szDate;
    LPTSTR szUnused;
} TRANSACTION, *PTRANSACTION;

/* ++
    Description of the fields in COM_ARGS

    szSrcDir        Directory where source files exist

    szFileName      File name(s) to store in the symbols server.
                    This may contain wild card characters

    Recurse         Recurse into subdirectories

    szRootDir       Root Directory of the symbols server

    szSymbolsDir    Symbols Directory under the root of the symbols server

    szSrcPath       Path to the files.  If this is not NULL,
                    then store a pointer to the files instead of
                    the files. Typically, this is the same as szSrcDir.
                    The difference is that szSrcPath is the path that
                    the debugger will use to find the symbol file.
                    Thus, it needs to be a network share, whereas szSrcDir
                    can be a local path.

    szId            Reference string for this transaction.  This must be
                    unique for each transaction.

    szAdminDir      Admin directory under the root of the symbols server

    szProduct       Name of the product
    szVersion       Version of the product
    szComment       Text description ... optional
    szMasterFileName The full path and name of the master file.  This contains
                     the master transaction record for each transaction.
    szServerFileName The full path and name of the file that contains a list of
                     all the transactions that are currently stored in the server.
    szTransFileName The full path and name of the file that contains a list of
                    all the files added by this transaction.  This only gets
                    initialized during GetCommandLineArgs if symstore is only
                    supposed to store the transaction file and not store any
                    files on the symbol server.
    szShareName     This is used with the /x option.  It is a prefix of
                    szFileName.  It is the part of szFileName that may
                    change later when the files are added to the server.
    TransState     Is this TRANSACTION_ADD or TRANSACTION_DEL 
    StoreFlags     Possible values: STORE or DONT_STORE
    AppendStoreFile When storing to a file instead of adding the files to the
                    symbol server, open the file with append.

-- */
typedef struct _COMMAND_ARGS {
    LPTSTR  szSrcDir;
    LPTSTR  szFileName;
    BOOL    StorePtrs;
    BOOL    Recurse;
    LPTSTR  szRootDir;
    LPTSTR  szSymbolsDir;
    LPTSTR  szSrcPath;
    LPTSTR  szId;
    LPTSTR  szAdminDir;
    LPTSTR  szProduct;
    LPTSTR  szVersion;
    LPTSTR  szComment;
    LPTSTR  szUnused;
    LPTSTR  szMasterFileName;
    LPTSTR  szServerFileName;
    LPTSTR  szTransFileName;  
    LPTSTR  szShareName;
    DWORD   ShareNameLength;
    DWORD   TransState;
    DWORD   StoreFlags;
    BOOL    AppendStoreFile;
    FILE    *pStoreFromFile;
    BOOL    AppendIDToFile;
    BOOL    VerboseOutput;
    DWORD   Filter;
    BOOL    CorruptBinaries;
} COM_ARGS, *PCOM_ARGS;

typedef struct _FILE_COUNTS {
    DWORD   NumPassedFiles;
    DWORD   NumIgnoredFiles;
    DWORD   NumFailedFiles;
} FILE_COUNTS, *PFILE_COUNTS;


BOOL
StoreDbg(
    LPTSTR szDestDir,
    LPTSTR szFileName,
    LPTSTR szPtrFileName,
    USHORT *rc_flag
);

BOOL
StorePdb(
    LPTSTR szDestDir,
    LPTSTR szFileName,
    LPTSTR szPtrFileName,       // If this is NULL, then the file is stored.
                                // If this is not NULL, then a pointer to 
                                // the file is stored.
    USHORT *rc_flag

);

BOOL
DeleteAllFilesInDirectory(
    LPTSTR szDir
);

ULONG GetMaxLineOfRefsPtrFile(
    VOID
);

DECLSPEC_NORETURN
VOID
MallocFailed(
    VOID
);


typedef struct _LIST_ELEM {
    CHAR FName[_MAX_PATH];
    CHAR Path[_MAX_PATH];
} LIST_ELEM, *P_LIST_ELEM;

typedef struct _LIST {
    LIST_ELEM *List;      // Pointers to the file names
    DWORD dNumFiles;
} LIST, *P_LIST;

P_LIST
GetList(
    LPTSTR szFileName
);

BOOL
InList(
    LPTSTR szFileName,
    P_LIST pExcludeList
);

BOOL
StoreNtFile(
    LPTSTR szDestDir,
    LPTSTR szFileName,
    LPTSTR szPtrFileName,
    USHORT *rc
);

DWORD
StoreFromFile(
    FILE *pStoreFromFile,
    LPTSTR szDestDir,
    PFILE_COUNTS pFileCounts
);

BOOL
MyCopyFile(
    LPCTSTR lpExistingFileName,
    LPCTSTR lpNewFileName
);

_TCHAR *
_tcsistr(
     _TCHAR *s1, 
     _TCHAR *s2
);

void
MyEnsureTrailingChar(
    char *sz,
    char  c
);

void
MyEnsureTrailingBackslash(
    char *sz
);

void
MyEnsureTrailingSlash(
    char *sz
);

void
MyEnsureTrailingCR(
    char *sz
);

// returns TRUE if Filename matches the regexp /.*~\d+\..{0,3}/
BOOL DoesThisLookLikeAShortFilenameHack(char *Filename);

// from sharedutils.c
DWORD PrivateGetFullPathName(LPCTSTR lpFilename, DWORD nBufferLength, LPTSTR lpBuffer, LPTSTR *lpFilePart);

extern HANDLE hTransFile;
extern DWORD StoreFlags;
extern PCOM_ARGS pArgs;
extern PTRANSACTION pTrans;
extern LONG lMaxTrans;  // Maximum number of characters in a transaction record
extern BOOL PubPriPriority;

BOOL FileExists(IN  LPCSTR FileName,
                OUT PWIN32_FIND_DATA FindData);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\symchk\symstore\pewhack.h ===
//
// Return values
//
#define PEWHACK_SUCCESS             0x0000
#define PEWHACK_BAD_COMMANDLINE     0x0001
#define PEWHACK_CREATEFILE_FAILED   0x0002
#define PEWHACK_CREATEMAP_FAILED    0x0003
#define PEWHACK_MAPVIEW_FAILED      0x0004
#define PEWHACK_BAD_DOS_SIG         0x0005
#define PEWHACK_BAD_PE_SIG          0x0006
#define PEWHACK_BAD_ARCHITECTURE    0x0007

//
// Verifies an image is a PE binary and, if so, corrupts it to be
// non-executable but still useful for debugging memory dumps.
//
DWORD CorruptFile(LPCTSTR Filename);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\symchk\symstore\symstore.cpp ===
#include <windows.h>
#include <lmcons.h>
#include <lmapibuf.h>
#include <lmerr.h>
#include <lmshare.h>
#include <malloc.h>

#include "symutil.h"
#include "symsrv.h"
#include "output.hpp"
#include <SymCommon.h>
#include <strsafe.h>


#define FILE_ID_NOT_FOUND     ((DWORD) -1)

typedef struct _FILE_INFO {
    DWORD       TimeDateStamp;
    DWORD       CheckSum;
    DWORD       Signature;
    TCHAR       szName[_MAX_PATH];
} FILE_INFO, *PFILE_INFO;

// Prototypes
PCOM_ARGS
GetCommandLineArgs(
    int argc,
    char **argv
);

BOOL
InitializeTrans(
    PTRANSACTION *pTrans,
    PCOM_ARGS pArgs,
    PHANDLE hFile
);

BOOL
DeleteTrans(
    PTRANSACTION pTrans,
    PCOM_ARGS pArgs
);


VOID
Usage (
    VOID
);

StoreDirectory(
    LPTSTR szDir,
    LPTSTR szFName,
    LPTSTR szDestDir,
    PFILE_COUNTS pFileCounts,
    LPTSTR szPath
);

DWORD
StoreAllDirectories(
    LPTSTR szDir,
    LPTSTR szFName,
    LPTSTR szDestDir,
    PFILE_COUNTS pFileCounts,
    LPTSTR szPath
);

BOOL
CorrectPath(
    LPTSTR szFileName,
    LPTSTR szPathName,
    LPTSTR szCorrectPath
);

BOOL
AddTransToFile(
    PTRANSACTION pTrans,
    LPTSTR szFileName,
    PHANDLE hFile
);

BOOL
UpdateServerFile(
    PTRANSACTION pTrans,
    LPTSTR szServerFileName
);

BOOL GetNextId(
    LPTSTR szMasterFileName,
    LPTSTR *szId,
    PHANDLE hFile
);

BOOL
DeleteEntry(
    LPTSTR szDir,
    LPTSTR szId
);

BOOL
ForceDeleteFile(
    LPTSTR szPtrFile
);

BOOL
ForceRemoveDirectory(
    LPTSTR szDir
);

BOOL
ForceClosePath(
    LPTSTR szDir
);

BOOL
CopyTheFile(
    LPTSTR szDir,
    LPTSTR szFilePathName
);

BOOL
DeleteTheFile(
    LPTSTR szDir,
    LPTSTR szFilePathName
);

BOOL
StoreSystemTime(
    LPTSTR *szTime,
    LPSYSTEMTIME lpSystemTime
);

BOOL
StoreSystemDate(
    LPTSTR *szDate,
    LPSYSTEMTIME lpSystemTime
);

ULONG GetMaxLineOfHistoryFile(
    VOID
);

ULONG GetMaxLineOfTransactionFile(
    VOID
);

BOOL GetSrcDirandFileName (
    LPTSTR szStr,
    LPTSTR szSrcDir,
    LPTSTR szFileName,
    BOOL   LocalFile
);

DWORD AppendTransIDToFile (
    FILE *AppendToFile,
    LPTSTR szId
);

PCOM_ARGS pArgs;

HANDLE hTransFile;
DWORD StoreFlags;

PTRANSACTION pTrans;
LONG lMaxTrans;
LONG NumSkippedFiles=0;
LPTSTR szPingMe;
BOOL MSArchive=FALSE;
BOOL PubPriPriority=FALSE;

// SymOutput *so;
SymOutput *so;

// display specific text for an error if defined.
void DisplayErrorText(DWORD dwError);

int _cdecl main( int argc, char **argv) {

    DWORD       NumErrors = 0;
    FILE_COUNTS FileCounts;
    BOOL        rc;
    HANDLE      hFile;
    FILE       *hPingMe = NULL;

    hFile=0;

    so = new SymOutput();

    // This also initializes the name of the Log File
    pArgs = GetCommandLineArgs(argc, argv);

    // Initialize the SymbolServer() function
    SymbolServerSetOptions(SSRVOPT_NOCOPY, 1 );
    SymbolServerSetOptions(SSRVOPT_PARAMTYPE, SSRVOPT_GUIDPTR);

    // Create the pingme.txt
    if (pArgs->StoreFlags != ADD_DONT_STORE) {
        if ( (hPingMe=_tfopen(szPingMe, "r")) == NULL ) {
        hPingMe = _tfopen(szPingMe, "w+");
            if (  hPingMe == NULL ) {
                so->printf("Cannot create %s.\n", szPingMe);
            } 
        }
        if ( hPingMe != NULL ) {
            fflush(hPingMe);
            fclose(hPingMe);
        }
    }

    // Initialize the transaction record
    // Opens the master file (hFile) and leaves it open
    // Get exclusive access to this file

    // QUERIES don't update the server
    if (pArgs->TransState != TRANSACTION_QUERY) {
        InitializeTrans(&pTrans, pArgs, &hFile);
    }

    if ( pArgs->StoreFlags==ADD_STORE_FROM_FILE  && 
         pArgs->AppendIDToFile ) {
        AppendTransIDToFile(pArgs->pStoreFromFile,
                            pTrans->szId
        );
    }

    if (pArgs->StoreFlags != ADD_DONT_STORE && pArgs->StoreFlags != QUERY) {
        AddTransToFile(pTrans, pArgs->szMasterFileName, &hFile);
    }

    CloseHandle(hFile);

    //
    // Handle TRANSACTION_DEL and exit
    //
    if (pArgs->TransState==TRANSACTION_DEL) {

        rc = DeleteTrans(pTrans,pArgs);
        UpdateServerFile(pTrans, pArgs->szServerFileName);

        return(rc);
    }

    //
    // Only TRANSACTION_ADD and TRANSACTION_QUERY get here
    //

    // QUERY and ADD_DONT_STORE shouldn't update the server file
    if ( pArgs->StoreFlags == ADD_STORE ||
         pArgs->StoreFlags == ADD_STORE_FROM_FILE ) {

        // Update server file
        UpdateServerFile(pTrans, pArgs->szServerFileName);
    }

    // Make sure the directory path exists for the transaction
    // file if we are doing ADD_DONT_STORE
    if ( pArgs->StoreFlags == ADD_DONT_STORE ) {

        if ( !MakeSureDirectoryPathExists(pTrans->szTransFileName) ) {
            so->printf("Cannot create the directory %s - GetLastError() = %d\n",
                   pTrans->szTransFileName, GetLastError() );
            exit(1);
        }

        // Open the file and move the file pointer to the end if we are
        // in appending mode.

        if (pArgs->AppendStoreFile) {
            hTransFile = CreateFile(pTrans->szTransFileName,
                          GENERIC_WRITE,
                          FILE_SHARE_READ,
                          NULL,
                          OPEN_ALWAYS,
                          FILE_ATTRIBUTE_NORMAL,
                          NULL
                         );
            if (hTransFile == INVALID_HANDLE_VALUE ) {
                so->printf("Cannot create file %s - GetLastError = %d\n",
                        pTrans->szTransFileName, GetLastError() );
                exit(1);
            }

            if ( SetFilePointer( hTransFile, 0, NULL, FILE_END )
                 == INVALID_SET_FILE_POINTER ) {
                so->printf("Cannot move to end of file %s - GetLastError = %d\n",
                       pTrans->szTransFileName, GetLastError() );
                exit(1);
            }

        } else {
            hTransFile = CreateFile(pTrans->szTransFileName,
                          GENERIC_WRITE,
                          FILE_SHARE_READ,
                          NULL,
                          CREATE_ALWAYS,
                          FILE_ATTRIBUTE_NORMAL,
                          NULL
                         );

            if (hTransFile == INVALID_HANDLE_VALUE ) {
                so->printf("Cannot create file %s - GetLastError = %d\n",
                        pTrans->szTransFileName, GetLastError() );
                exit(1);
            }
        }

    } else {
        if (pArgs->TransState!=TRANSACTION_QUERY) {
            hTransFile = CreateFile(pTrans->szTransFileName,
                              GENERIC_WRITE,
                              FILE_SHARE_READ,
                              NULL,
                              CREATE_NEW,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL
                             );
            if (hTransFile == INVALID_HANDLE_VALUE ) {
                so->printf("Cannot create a new file %s - GetLastError = %d\n",
                        pTrans->szTransFileName, GetLastError() );
                exit(1);
            }
        }
    }

    StoreFlags=pArgs->StoreFlags;


    if (pArgs->TransState!=TRANSACTION_QUERY) {
        if (hTransFile == INVALID_HANDLE_VALUE ) {
            so->printf("Cannot create a new file %s - GetLastError = %d\n",
                   pTrans->szTransFileName, GetLastError() );
            exit(1);
        }
    }

    memset( &FileCounts, 0, sizeof(FILE_COUNTS) );

    if ( pArgs->StoreFlags==ADD_STORE_FROM_FILE ) {

        // This will only store pointers
        NumErrors += StoreFromFile(
                            pArgs->pStoreFromFile,
                            pArgs->szSymbolsDir,
                            &FileCounts);

        fflush(pArgs->pStoreFromFile);
        fclose(pArgs->pStoreFromFile);

    } else if ( !pArgs->Recurse ) {

        NumErrors += StoreDirectory(
                            pArgs->szSrcDir,
                            pArgs->szFileName,
                            pArgs->szSymbolsDir,
                            &FileCounts,
                            pArgs->szSrcPath
                            );
    } else {

        NumErrors += StoreAllDirectories(
                            pArgs->szSrcDir,
                            pArgs->szFileName,
                            pArgs->szSymbolsDir,
                            &FileCounts,
                            pArgs->szSrcPath
                            );
    }

    if ( pArgs->TransState != TRANSACTION_QUERY ) {
        if (pArgs->szSrcPath) {
            so->printf("SYMSTORE: Number of pointers stored = %d\n",FileCounts.NumPassedFiles);
        } else {
            so->printf("SYMSTORE: Number of files stored = %d\n",FileCounts.NumPassedFiles);
        }
        so->printf("SYMSTORE: Number of errors = %d\n",NumErrors);
        so->printf("SYMSTORE: Number of ignored files = %d\n", NumSkippedFiles);

        SetEndOfFile(hTransFile);
        CloseHandle(hTransFile);
    }

    SymbolServerClose();

    delete so;

    return (0);

}

DWORD AppendTransIDToFile(FILE *AppendToFile, LPTSTR szId) {
    TCHAR   szBuffer[35];
    long    pos;
    int     i=0;

    fflush(AppendToFile);    
    pos = ftell(AppendToFile);

    if ( fseek( AppendToFile, -4, SEEK_END ) != 0) {
        so->printf("Cannot move to end of index file - GetLastError = %d\n", GetLastError() );
        exit(1);
    }

    if ( _fgetts(szBuffer, 10, AppendToFile) == NULL) {
        so->printf("Cannot read from file - GetLastError = %d\n", GetLastError() );
        exit(1);
    }
   
    if ( fseek( AppendToFile, -4, SEEK_END ) != 0) {
        so->printf("Cannot move to end of index file - GetLastError = %d\n", GetLastError() );
        exit(1);
    }

    fflush(AppendToFile);
    while(!iscntrl(szBuffer[i]) && !iswcntrl(szBuffer[i])) {
        i++;
    }

    StringCchPrintf(&szBuffer[i], (sizeof(szBuffer)/sizeof(TCHAR) ) - i, "\r\n;Transaction=%s\r\n", szId);
    
    _fputts(szBuffer, AppendToFile);
    fflush(AppendToFile);

    if ( fseek( AppendToFile, pos, SEEK_SET ) != 0 ) {
        so->printf("Cannot move to offset (%d) of index file - GetLastError = %d\n", pos, GetLastError() );
        exit(1);
    }

    return TRUE;
}

//
// AddTransToFile
//
// Purpose - Add a record to the end of the Master File
//
BOOL
AddTransToFile(
    PTRANSACTION pTrans,
    LPTSTR szFileName,
    PHANDLE hFile
)
{
    LPTSTR szBuf=NULL;
    LPTSTR szBuf2=NULL;
    TCHAR szTransState[4];
    TCHAR szFileOrPtr[10];
    DWORD dwNumBytesToWrite;
    DWORD dwNumBytesWritten;
    DWORD FileSizeHigh;
    DWORD FileSizeLow;

    assert (pTrans);

    // Master file should already be opened
    assert(*hFile);

    // Create the buffer to store one record in
    szBuf = (LPTSTR) malloc( sizeof(TCHAR) * (lMaxTrans + 1) );
    if (!szBuf) {
        CloseHandle(*hFile);
        MallocFailed();
    }

    // Create the buffer to store one record in
    szBuf2 = (LPTSTR) malloc( sizeof(TCHAR) * (lMaxTrans + 1) );

    if (!szBuf2) {
        CloseHandle(*hFile);
        MallocFailed();
    }

    // Move to the end of the file
    SetFilePointer( *hFile,
                    0,
                    NULL,
                    FILE_END );


    if (pTrans->TransState == TRANSACTION_ADD)
    {
        StringCbCopy(szTransState, sizeof(szTransState), _T("add"));
        switch (pTrans->FileOrPtr) {
          case STORE_FILE:      StringCbCopy(szFileOrPtr, sizeof(szFileOrPtr), _T("file"));
                                break;
          default:              so->printf("Incorrect value for pTrans->FileOrPtr - assuming ptr\n");
          case STORE_PTR:       StringCbCopy(szFileOrPtr, sizeof(szFileOrPtr), _T("ptr"));
                                break;
        }
        StringCbPrintf(szBuf2,
                       _msize(szBuf2),
                       "%s,%s,%s,%s,%s,%s,%s,%s,%s",
                       pTrans->szId,
                       szTransState,
                       szFileOrPtr,
                       pTrans->szDate,
                       pTrans->szTime,
                       pTrans->szProduct,
                       pTrans->szVersion,
                       pTrans->szComment,
                       pTrans->szUnused);
    }
    else if (pTrans->TransState == TRANSACTION_DEL)
    {
        StringCbCopy(szTransState, sizeof(szTransState), _T("del"));
        StringCbPrintf(szBuf2,
                       _msize(szBuf2),
                       "%s,%s,%s",
                       pTrans->szDelId,
                       szTransState,
                       pTrans->szId);

    } else {
        so->printf("SYMSTORE: The transaction state is unknown\n");
        free(szBuf);
        free(szBuf2);
        return (FALSE);
    }


    // If this is not the first line in the file, then put a '\n' before the
    // line.

    FileSizeLow = GetFileSize(*hFile, &FileSizeHigh);
    dwNumBytesToWrite = (_tcslen(szBuf2) ) * sizeof(TCHAR);

    if ( FileSizeLow == 0 && FileSizeHigh == 0 ) {

        StringCbCopy(szBuf, _msize(szBuf), szBuf2);
    } else {
        StringCbPrintf(szBuf, _msize(szBuf), "\n%s", szBuf2);
        dwNumBytesToWrite += 1 * sizeof(TCHAR);
    }

    // Append this to the master file

    WriteFile( *hFile,
               (LPCVOID)szBuf,
               dwNumBytesToWrite,
               &dwNumBytesWritten,
               NULL
             );

    free(szBuf);
    free(szBuf2);

    if ( dwNumBytesToWrite != dwNumBytesWritten )
    {
        so->printf( "FAILED to write to %s, with GetLastError = %d\n",
                szFileName,
                GetLastError());
        return (FALSE);
    }

    return (TRUE);
}

BOOL
CopyTheFile(
    LPTSTR szDir,
    LPTSTR szFilePathName
)
/*++

    IN szDir            The directory that the file is copied to
    IN szFilePathName   The full path and name of the file to be copied

    "CopyTheFile" copies szFilePathName to the directory
    szDir, if the file does not already exist in szDir

--*/
{
BOOL rc;
USHORT j;
LPTSTR szFileName;


    // Figure out index in "szFilePathName" where the file name starts
    j = _tcslen(szFilePathName) - 1;

    if ( szFilePathName[j] == '\\' ) {
        so->printf("SYMSTORE: %s\refs.ptr has a bad file name %s\n",
                szDir, szFilePathName);
        return(FALSE);
    }

    while ( szFilePathName[j] != '\\' && j != 0 ) j--;

    if ( j == 0 ) {
        so->printf("SYMSTORE: %s\refs.ptr has a bad file name for %s\n",
                szDir, szFilePathName );
        return(FALSE);
    }

    // Set j == the index of first character after the last '\' in szFilePathName
    j++;

    // Allocate and store the full path and name of
    szFileName = (LPTSTR) malloc ( sizeof(TCHAR) *
                                               (_tcslen(szDir) + _tcslen(szFilePathName+j) + 1) );
    if ( szFileName == NULL ) MallocFailed();

    StringCbPrintf(szFileName, _msize(szFileName), "%s%s", szDir, szFilePathName+j );

    // If this file doesn't exist, then copy it
    rc = MyCopyFile( szFilePathName, szFileName );

    free(szFileName);
    return(rc);
}


BOOL
CorrectPath(
    LPTSTR szFileName,
    LPTSTR szPathName,
    LPTSTR szCorrectPath
)
{
    // To return TRUE, szPathName should equal szCorrectPath + \ + szFileName
    // The only hitch is that there could be extraneous \'s

    TCHAR CorrectPathx[_MAX_PATH + _MAX_FNAME + _MAX_EXT + 2];
    TCHAR PathNamex[_MAX_PATH + _MAX_FNAME + _MAX_EXT + 2];

    LONG length, index, i;

    // Get rid of any extra \'s
    length = _tcslen(szPathName);
    PathNamex[0] = szPathName[0];
    index = 1;
    for (i=1; i<=length; i++) {
        if ( (szPathName[i-1] != '\\') || (szPathName[i] != '\\') ) {
            PathNamex[index] = szPathName[i];
            index++;
        }
    }

    length = _tcslen(szCorrectPath);
    CorrectPathx[0] = szCorrectPath[0];
    index = 1;
    for (i=1; i<=length; i++) {
        if ( (szCorrectPath[i-1] != '\\') || (szCorrectPath[i] != '\\') ) {
            CorrectPathx[index] = szCorrectPath[i];
            index++;
        }
    }

    // Make sure that the correct path doesn't end in a '\'
    length = _tcslen(CorrectPathx);
    if ( CorrectPathx[length-1] == '\\' ) CorrectPathx[length-1] = '\0';

    StringCbCat( CorrectPathx, sizeof(CorrectPathx), "\\");
    StringCbCat( CorrectPathx, sizeof(CorrectPathx), szFileName);

    if ( _tcsicmp(CorrectPathx, szPathName) == 0) return TRUE;
    else return FALSE;
}

BOOL
DeleteEntry(
    LPTSTR szDir,
    LPTSTR szId
)
/*++ This deletes szID from the directory szDir on the symbols server

-- */

{
    LPTSTR szRefsFile; // Full path and name of the refs.ptr file
    LPTSTR szTempFile; // Full path and name for a temporaty refs.ptr file
    LPTSTR szPtrFile;  // Full path and name of the pointer file
    LPTSTR szParentDir;
    FILE *fRefsFile;
    FILE *fTempFile;
    FILE *fPtrFile;

    LPTSTR szBuf;      // Used to process entries in the refs file


    TCHAR *token;
    TCHAR seps[] = _T(",");

    fpos_t CurFilePos;
    fpos_t IdFilePos;
    fpos_t PrevFilePos;
    fpos_t Prev2FilePos;
    fpos_t PubFilePos;
    fpos_t PriFilePos;

    BOOL IdIsFile;
    BOOL Found;
    BOOL rc = FALSE;
    ULONG MaxLine;     // Maximim length of a record in refs.ptr
    ULONG NumLines = 0;
    ULONG NumFiles = 0;
    ULONG NumPtrs = 0;
    ULONG IdLineNum = 0;
    ULONG PubLineNum = 0;
    ULONG PriLineNum = 0;
    ULONG CurLine = 0;
    ULONG i;
    LONG j;
    DWORD len;

    ULONG ReplaceIsFile;
    ULONG ReplaceLineNum;

    szRefsFile = (LPTSTR) malloc ( (_tcslen(szDir) + _tcslen(_T("refs.ptr")) + 1) * sizeof(TCHAR) );
    if (!szRefsFile) MallocFailed();
    StringCbPrintf(szRefsFile, _msize(szRefsFile), "%srefs.ptr", szDir );

    szPtrFile = (LPTSTR) malloc ( (_tcslen(szDir) + _tcslen(_T("file.ptr")) + 1) * sizeof(TCHAR) );
    if (!szPtrFile) MallocFailed();
    StringCbPrintf(szPtrFile, _msize(szPtrFile), "%sfile.ptr", szDir);

    szTempFile = (LPTSTR) malloc ( (_tcslen(szRefsFile) + _tcslen(".tmp") + 1) * sizeof(TCHAR) );
    if (!szTempFile) MallocFailed();
    StringCbPrintf(szTempFile, _msize(szTempFile), "%s.tmp", szRefsFile );

    MaxLine = GetMaxLineOfRefsPtrFile();
    szBuf = (LPTSTR) malloc( MaxLine * sizeof(TCHAR) );
    if ( !szBuf ) MallocFailed();
    ZeroMemory(szBuf,MaxLine*sizeof(TCHAR));

    fRefsFile = _tfopen(szRefsFile, _T("r+") );
    if ( fRefsFile == NULL ) {
       // BARB - Check for corruption -- if the file doesn't exist,
       // verify that the parent directory structure doesn't exist either
       goto finish_DeleteEntry;
    }

    //
    // Read through the refs.ptr file and gather information
    //

    NumFiles = 0;
    NumPtrs = 0;

    Found = FALSE;
    NumLines = 0;
    fgetpos( fRefsFile, &CurFilePos);
    PrevFilePos = CurFilePos;   // Position of the current line
    Prev2FilePos = CurFilePos;  // Position of the line before the current line

    while ( _fgetts( szBuf, MaxLine, fRefsFile) != NULL ) {

      len=_tcslen(szBuf);
      if ( len > 3 ) {


        // CurFilePos is set to the next character to be read
        // We need to remember the beginning position of this line (PrevFilePos)
        // And the beginning position of the line before this line (Prev2FilePos)

        Prev2FilePos = PrevFilePos;
        PrevFilePos = CurFilePos;
        fgetpos( fRefsFile, &CurFilePos);

        NumLines++;

        token = _tcstok(szBuf, seps);  // Look at the ID

        if ( _tcscmp(token,szId) == 0 ) {

            // We found the ID
            Found = TRUE;
            IdFilePos = PrevFilePos;
            IdLineNum = NumLines;

            token = _tcstok(NULL, seps);  // Look at the "file" or "ptr" field

            if (token && ( _tcscmp(token,_T("file")) == 0)) {
                IdIsFile = TRUE;
            } else if (token && ( _tcscmp(token,_T("ptr")) == 0 )) {
                IdIsFile = FALSE;
            } else {
                so->printf("SYMSTORE: Error in %s - entry for %s does not contain ""file"" or ""ptr""\n",
                        szRefsFile, szId);
                rc = FALSE;
                goto finish_DeleteEntry;
            }
        } else {

            // Record info about the other records
            token = _tcstok(NULL, seps);  // Look at the "file" or "ptr" field

            if (token && ( _tcscmp(token,_T("file")) == 0)) {
                NumFiles++;
            } else if (token && ( _tcscmp(token,_T("ptr")) == 0 )) {
                NumPtrs++;
            } else {
                so->printf("SYMSTORE: Error in %s - entry for %s does not contain ""file"" or ""ptr""\n",
                        szRefsFile, szId);
                rc = FALSE;
                goto finish_DeleteEntry;
            }
       
            if ( PubPriPriority > 0 ) { 

                // Now, see if the next token is pub or pri
                token = _tcstok(NULL, seps);

                if ( token && PubPriPriority == 1  && (_tcscmp(token,_T("pub")) == 0) ) {

                    PubFilePos=PrevFilePos;
                    PubLineNum = NumLines;

                } else if ( token && PubPriPriority == 1 && (_tcscmp(token,_T("pri")) == 0) ) {
                
                    PriFilePos = PrevFilePos;
                    PriLineNum = NumLines;
                }
            }
        }

      }

      ZeroMemory(szBuf, MaxLine*sizeof(TCHAR));
    }

    fflush(fRefsFile);
    fclose(fRefsFile);

    // If we didn't find the ID we are deleting, then don't do anything in this directory

    if (IdLineNum == 0 ) goto finish_DeleteEntry;

    // If there was only one record, then just delete everything
    if (NumLines == 1) {
        DeleteAllFilesInDirectory(szDir);

        // Delete this directory
        rc = ForceRemoveDirectory(szDir);

        if ( !rc ) {
            goto finish_DeleteEntry;
        }

        // If the first directory was deleted, remove the parent directory

        szParentDir=(LPTSTR)malloc(_tcslen(szDir) + 1 );
        if ( szParentDir == NULL  ) MallocFailed();

        // First figure out the parent directory

        StringCbCopy(szParentDir, _msize(szParentDir), szDir);

        // szDir ended with a '\' -- find the previous one
        j = _tcslen(szParentDir)-2;
        while (  j >=0 && szParentDir[j] != '\\' ) {
            j--;
        }

        if (j<0) {
            so->printf("SYMSTORE: Could not delete the parent directory of %s\n", szDir);
        }
        else {
            szParentDir[j+1] = '\0';
            // This call will remove the directory only if its empty
            rc = RemoveDirectory(szParentDir);

            if ( !rc ) {
                goto finish_DeleteEntry;
            }
        }

        free(szParentDir);
        goto finish_DeleteEntry;
    }

    //
    // Get the replacement info for this deletion
    //

    if ( PubPriPriority == 1 && PubLineNum > 0 ) {
        ReplaceLineNum = PubLineNum;
    } else if ( PubPriPriority == 2 && PriLineNum > 0 ) {
        ReplaceLineNum = PriLineNum;
    } else if ( IdLineNum == NumLines ) {
        ReplaceLineNum = NumLines-1;
    } else {
        ReplaceLineNum = NumLines;
    }

    //
    // Now, delete the entry from refs.ptr
    // Rename "refs.ptr" to "refs.ptr.tmp"
    // Then copy refs.ptr.tmp line by line to refs.ptr, skipping the line we are
    // supposed to delete
    //

    rename( szRefsFile, szTempFile);

    fTempFile= _tfopen(szTempFile, "r" );
    if (fTempFile == NULL) {
        goto finish_DeleteEntry;
    }
    fRefsFile= _tfopen(szRefsFile, "w" );
    if (fRefsFile == NULL) {
        fflush(fTempFile);
        fclose(fTempFile);
        goto finish_DeleteEntry;
    }

    CurLine = 0;

    i=0;
    while ( _fgetts( szBuf, MaxLine, fTempFile) != NULL ) {

      len=_tcslen(szBuf);
      if ( len > 3 ) {
        i++;
        if ( i != IdLineNum ) {

            // Make sure that the last line doesn't end with a '\n'
            if ( i == NumLines || (IdLineNum == NumLines && i == NumLines-1) ) {
                if ( token[_tcslen(token)-1] == '\n' ) {
                    token[_tcslen(token)-1] = '\0';
                }
            }

            _fputts( szBuf, fRefsFile);

        }


        // This is the replacement, either get the new file, or update file.ptr

        if ( i == ReplaceLineNum ) {

            // This is the replacement information,
            // Figure out if it is a file or a pointer

            token = _tcstok(szBuf, seps);  // Skip the ID number
            token = _tcstok(NULL, seps);   // Get "file" or "ptr" field

            if ( _tcscmp(token,_T("file")) == 0) {
                ReplaceIsFile = TRUE;
            } else if ( _tcscmp(token,_T("ptr")) == 0 ) {
                ReplaceIsFile = FALSE;
            } else {
                so->printf("SYMSTORE: Error in %s - entry for %s does not contain ""file"" or ""ptr""\n",
                        szRefsFile, szId);
                rc = FALSE;
                goto finish_DeleteEntry;
            }

            token = _tcstok(NULL, seps);  // Get the replacement path and filename

            // Strip off the last character if it is a '\n'
            if ( token[_tcslen(token)-1] == '\n' ) {
                token[_tcslen(token)-1] = '\0';
            }

            //
            // If the replacement is a file, then copy the file
            // If the replacement if a ptr, then update "file.ptr"
            //

            rc = TRUE;

            if (ReplaceIsFile) {
                rc = CopyTheFile(szDir, token);
                rc = rc && ForceDeleteFile(szPtrFile);

            } else {

                //
                // Put the new pointer into "file.ptr"
                //

                rc = ForceClosePath(szPtrFile);
                fPtrFile = _tfopen(szPtrFile, _T("w") );
                if ( !fPtrFile ) {
                    so->printf("SYMSTORE: Could not open %s for writing\n", szPtrFile);
                    rc = FALSE;
                } else {
                    _fputts( token, fPtrFile);
                    fflush(fPtrFile);
                    fclose(fPtrFile);
                }


                //
                // If the deleted record was a "file", and we are placing it with a
                // pointer, and there are no other "file" records in refs.ptr, then
                // delete the file from the directory.
                //
                if ( IdIsFile && (NumFiles == 0 )) {
                    DeleteTheFile(szDir, token);
                }
            }
        }
      }
    }

    fflush(fTempFile);
    fclose(fTempFile);
    fflush(fRefsFile);
    fclose(fRefsFile);

    // Now, delete the temporary file

    DeleteFile(szTempFile);

    finish_DeleteEntry:

    free (szBuf);
    free (szRefsFile);
    free (szPtrFile);
    free (szTempFile);
    return (rc);
}

BOOL
DeleteTheFile(
    LPTSTR szDir,
    LPTSTR szFilePathName
)
/*++

    IN szDir            The directory that the file is to be deleted from

    IN szFilePathName   The file name of the file to be deleted.  It is
                        preceded by the wrong path.  That's why we need to
                        strip off the file name and add it to szDir


    "DeleteTheFile" figures out the file name at the end of szFilePathName,
    and deletes it from szDir if it exists.  It will delete the file and/or
    the corresponding compressed file name that has the same name with a _
    at the end of it.

--*/
{
BOOL rc,returnval=TRUE;
USHORT j;
LPTSTR szFileName;
DWORD dw;


    // Figure out index in "szFilePathName" where the file name starts
    j = _tcslen(szFilePathName) - 1;

    if ( szFilePathName[j] == '\\' ) {
        so->printf("SYMSTORE: %s\refs.ptr has a bad file name %s\n",
                szDir, szFilePathName);
        return(FALSE);
    }

    while ( szFilePathName[j] != '\\' && j != 0 ) j--;

    if ( j == 0 ) {
        so->printf("SYMSTORE: %s\refs.ptr has a bad file name for %s\n",
                szDir, szFilePathName );
        return(FALSE);
    }

    // Set j == the index of first character after the last '\' in szFilePathName
    j++;

    // Allocate and store the full path and name of
    szFileName = (LPTSTR) malloc ( sizeof(TCHAR) *
                                               (_tcslen(szDir) + _tcslen(szFilePathName+j) + 1) );
    if ( szFileName == NULL ) MallocFailed();

    StringCbPrintf(szFileName, _msize(szFileName), "%s%s", szDir, szFilePathName+j );

    // See if the file exists
    dw = GetFileAttributes( szFileName );    
    if ( dw != 0xffffffff ) {
        rc = DeleteFile( szFileName );
        if (!rc && GetLastError() != ERROR_NOT_FOUND ) {
            rc = ForceDeleteFile( szFileName );
            if ( !rc ) {
                so->printf("SYMSTORE: Could not delete %s - GetLastError = %d\n",
                    szFileName, GetLastError() );
                returnval=FALSE;
            }
        } 
    }

    // See if the compressed file exists and delete it.

    szFileName[ _tcslen(szFileName) -1 ] = _T('_');
    dw = GetFileAttributes( szFileName );    
    if ( dw != 0xffffffff ) {
        rc = DeleteFile( szFileName );
        if (!rc && GetLastError() != ERROR_NOT_FOUND ) {
            so->printf("SYMSTORE: Could not delete %s - GetLastError = %d\n",
                   szFileName, GetLastError() );
            returnval=FALSE;
        } 
    }

    free(szFileName);
    return(returnval);
}

BOOL
DeleteTrans(
    PTRANSACTION pTrans,
    PCOM_ARGS pArgs
)
{
FILE *pFile;
LONG MaxLine;
LPTSTR szBuf;
TCHAR szDir[_MAX_PATH + 2];
TCHAR *token;
TCHAR seps[] = _T(",");


    // First, go get the transaction file
    // and delete its entries from the symbols server
    pFile = _tfopen(pTrans->szTransFileName, _T("r") );

    if (!pFile ) {
        DWORD Error = GetLastError();
 
        switch(Error) {
            case ERROR_FILE_NOT_FOUND:
                so->printf("Transaction %s doesn't exist\n", pTrans->szId);
                break;

            default:
                so->printf("Cannot open file %s - GetLastError = %d\n", pTrans->szTransFileName, GetLastError() );
                break;
        }
        exit(1);
    }

    // Figure out the maximum line length
    // Add space for 1 commas and a '\0'
    MaxLine = GetMaxLineOfTransactionFile();
    szBuf = (LPTSTR)malloc(MaxLine * sizeof(TCHAR) );
    if (!szBuf) {
        fclose(pFile);
        MallocFailed();
    }

    while ( (!feof(pFile)) && fgets(szBuf, MaxLine, pFile)) {
        // Find the first token that ends with ','
        token=_tcstok(szBuf, seps);

        // Compute the directory we are deleting from
        StringCbCopy(szDir, sizeof(szDir), pArgs->szSymbolsDir);
        StringCbCat( szDir, sizeof(szDir), token);
        MyEnsureTrailingBackslash(szDir);

        // Delete entry
        DeleteEntry(szDir, pTrans->szId);
    }

    free(szBuf);
    fflush(pFile);
    fclose(pFile);

    // Don't do this quite yet...
    // DeleteFile(pTrans->szTransFileName);
    return(TRUE);
}

// display specific text for an error if defined.
void DisplayErrorText(DWORD dwError) {
    switch (dwError) {

        case ERROR_BAD_FORMAT:
            printf("because it is in an unsupported format.");
            break;

        default:
            so->printf("because it is corrupt. (0x%08x)", dwError);
            break;
    }
}

BOOL
ForceClosePath(
    LPTSTR szDir
)
{
    LPBYTE BufPtr;
    DWORD EntriesRead;
    DWORD FileId = FILE_ID_NOT_FOUND;
    const DWORD InfoLevel = 2;
    NET_API_STATUS Status;
    DWORD TotalAvail;
    LPFILE_INFO_2 InfoArray;

    Status = NetFileEnum(
        NULL,
        (LPWSTR)szDir,
        NULL,
        InfoLevel,
        &BufPtr,
        MAX_PREFERRED_LENGTH,
        &EntriesRead,
        &TotalAvail,
        NULL);  // no resume handle

    InfoArray = (LPFILE_INFO_2) BufPtr;
    if (Status != NERR_Success) {
        NetApiBufferFree( (LPVOID) InfoArray );

        so->printf( "SYMSTORE: Could not get file ID number for %s. ", szDir);
        switch (Status) { 
            case ERROR_ACCESS_DENIED:
                so->printf( "The user does not have access to the requested information.\n");
                break;

            case ERROR_INVALID_LEVEL:
                so->printf( "Requested information level is not supported.\n");
                break;

            case ERROR_MORE_DATA:
                so->printf( "Too many entries were available.\n");
                break;

            case ERROR_NOT_ENOUGH_MEMORY:
                so->printf( "Insufficient memory is available.\n");
                break;

            case NERR_BufTooSmall:
                so->printf("The available memory is insufficient.");
                break;

            default:
                so->printf( "Status=%d, GetLastError=%d.\n", Status, GetLastError() );

        }

        // Does this really need to be here?  Status is locally scoped and we immediately return?
        //if (Status == ERROR_NOT_SUPPORTED) {
        //    Status = FILE_ID_NOT_FOUND;   // WFW does not implement this API.
        //}
        return FALSE;
    }

    if (EntriesRead > 0) {
        FileId = InfoArray->fi2_id;
        if ( FileId == FILE_ID_NOT_FOUND ) {
            NetApiBufferFree( InfoArray );
            return TRUE;        // Not an error
        }

        Status = NetFileClose( NULL, FileId );
        if (Status != NERR_Success) {
            NetApiBufferFree( InfoArray );
            so->printf( "SYMSTORE: Could not close net file %s.  GetLastError=%d\n",
                        szDir, GetLastError() );
            return FALSE;
        }
    }
    return TRUE;
}

BOOL ForceDeleteFile(LPTSTR szPtrFile) {
    BOOL rc;
    DWORD dw;
    DWORD lasterror;

    dw = GetFileAttributes( szPtrFile );

    if ( dw != 0xffffffff ) {
        rc = DeleteFile(szPtrFile);
    } else {
        return TRUE;
    }
    if ( !rc ) { // If failed, try to close the path.
        rc = ForceClosePath(szPtrFile);
        if ( rc ) { // If success, try to delete this file.
            rc        = DeleteFile(szPtrFile);
            lasterror = GetLastError();
            dw        = GetFileAttributes( szPtrFile );

            if (( dw != 0xffffffff ) && (!rc)) {
                so->printf("SYMSTORE: Could not delete %s.  GetLastError=%d\n", szPtrFile, lasterror);
            } else {
                return TRUE;
            }

        }
    }
    return rc;
}


BOOL
ForceRemoveDirectory(
    LPTSTR szDir
)
/*++
    IN szDir            The directory that need force removed

    ForceRemoveDirectory removed the directory that could not be delete
    by RemoveDirectory.  It use NetFileClose to stop any user lock this
    file, then call RemoveDirectory to remove it.
--*/
{
    BOOL rc;
    DWORD dw;
    DWORD lasterror;

        dw = GetFileAttributes( szDir );    
        if ( dw != 0xffffffff ) {
                rc = RemoveDirectory(szDir);
        } else {
                return TRUE;
        }
        if ( !rc ) {    // If failed, try to close the path.
                rc = ForceClosePath(szDir);
                if ( rc ) { // If success, try to remove this path again.
                        rc = RemoveDirectory(szDir);
            lasterror = GetLastError();
            dw = GetFileAttributes( szDir );    
            if (( dw != 0xffffffff ) && (!rc)) {
                so->printf("SYMSTORE: Could not delete %s.  GetLastError=%d\n",
                        szDir, lasterror );
            } else {
                return TRUE;
            }
        }
    }
    return rc;
}

PCOM_ARGS
GetCommandLineArgs(
    int argc,
    char **argv
)

{
   PCOM_ARGS pLocalArgs;
   LONG i,cur,length;
   TCHAR c;
   BOOL NeedSecond = FALSE;
   BOOL AllowLocalNames = FALSE;
   BOOL rc;

   LPTSTR szFileArg = NULL;

   if (argc <= 2) Usage();

   pLocalArgs = (PCOM_ARGS)malloc( sizeof(COM_ARGS) );
   if (!pLocalArgs) MallocFailed();
   memset( pLocalArgs, 0, sizeof(COM_ARGS) );

   pLocalArgs->StorePtrs = FALSE;
   pLocalArgs->Filter = 0;
   if (!_tcsicmp(argv[1], _T("add")) ){
      pLocalArgs->TransState = TRANSACTION_ADD;
      pLocalArgs->StoreFlags=ADD_STORE;

   } else if (!_tcsicmp(argv[1], _T("del")) ) {
      pLocalArgs->TransState = TRANSACTION_DEL;
      pLocalArgs->StoreFlags=DEL;

   } else if (!_tcsicmp(argv[1], _T("query")) ) {
      pLocalArgs->TransState = TRANSACTION_QUERY;
      pLocalArgs->StoreFlags = QUERY;

   } else {
      so->printf("ERROR: First argument needs to be \"add\", \"del\", or \"query\"\n");
      exit(1);
   }

   for (i=2; i<argc; i++) {

     if (!NeedSecond) {
        if ( (argv[i][0] == '/') || (argv[i][0] == '-') ) {
          length = _tcslen(argv[i]);

          cur=1;
          while ( cur < length ) {
            c = argv[i][cur];

            switch (c) {
                case 'a':   pLocalArgs->AppendStoreFile = TRUE;
                            if (pLocalArgs->TransState==TRANSACTION_QUERY) {
                                so->printf("ERROR: /%c is an incorrect parameter with query\n\n", c);
                                exit(1);
                            }
                            break;
                case 'c':   NeedSecond = TRUE;
                            if (pLocalArgs->TransState==TRANSACTION_QUERY) {
                                so->printf("ERROR: /%c is an incorrect parameter with query\n\n", c);
                                exit(1);
                            }
                            break;
                case 'd':   NeedSecond = TRUE;
                            if (pLocalArgs->TransState==TRANSACTION_QUERY) {
                                so->printf("ERROR: /%c is an incorrect parameter with query\n\n", c);
                                exit(1);
                            }
                            break;
                case 'f':   NeedSecond = TRUE;
                            break;
                case 'g':   NeedSecond = TRUE;
                            if (pLocalArgs->TransState==TRANSACTION_QUERY) {
                                so->printf("ERROR: /%c is an incorrect parameter with query\n\n", c);
                                exit(1);
                            }
                            break;
                case 'h':   NeedSecond = TRUE;
                            if (pLocalArgs->TransState==TRANSACTION_QUERY) {
                                so->printf("ERROR: /%c is an incorrect parameter with query\n\n", c);
                                exit(1);
                            }
                            break;
                case 'i':   NeedSecond = TRUE;
                            if (pLocalArgs->TransState==TRANSACTION_QUERY) {
                                so->printf("ERROR: /%c is an incorrect parameter with query\n\n", c);
                                exit(1);
                            }
                            break;
                case 'k':   pLocalArgs->CorruptBinaries = TRUE;
                            if (pLocalArgs->TransState==TRANSACTION_QUERY) {
                                so->printf("ERROR: /%c is an incorrect parameter with query\n\n", c);
                                exit(1);
                            }
                            break;
                case 'l':   AllowLocalNames=TRUE;
                            if (pLocalArgs->TransState==TRANSACTION_QUERY) {
                                so->printf("ERROR: /%c is an incorrect parameter with query\n\n", c);
                                exit(1);
                            }
                            break;
                case 'm':   MSArchive=TRUE;
                            if (pLocalArgs->TransState==TRANSACTION_QUERY) {
                                so->printf("ERROR: /%c is an incorrect parameter with query\n\n", c);
                                exit(1);
                            }
                            break;
                case 'r':   if (pLocalArgs->TransState==TRANSACTION_DEL) {
                                so->printf("ERROR: /r is an incorrect parameter with del\n\n");
                                exit(1);
                            }
                            pLocalArgs->Recurse = TRUE;
                            break;
                case 'p':   pLocalArgs->StorePtrs = TRUE;
                            if (pLocalArgs->TransState==TRANSACTION_DEL) {
                                so->printf("ERROR: /p is an incorrect parameter with del\n\n");
                                exit(1);
                            } else if (pLocalArgs->TransState==TRANSACTION_QUERY) {
                                so->printf("ERROR: /p is an incorrect parameter with query\n\n");
                                exit(1);
                            }
                            break;
                case 's':   NeedSecond = TRUE;
                            break;
                case 't':   NeedSecond = TRUE;
                            if (pLocalArgs->TransState==TRANSACTION_QUERY) {
                                so->printf("ERROR: /%c is an incorrect parameter with query\n\n", c);
                                exit(1);
                            }
                            break;
                case 'v':   NeedSecond = TRUE;
                            if (pLocalArgs->TransState==TRANSACTION_QUERY) {
                                so->printf("ERROR: /%c is an incorrect parameter with query\n\n", c);
                                exit(1);
                            }
                            break;
                case 'x':   NeedSecond = TRUE;
                            if (pLocalArgs->TransState==TRANSACTION_QUERY) {
                                so->printf("ERROR: /%c is an incorrect parameter with query\n\n", c);
                                exit(1);
                            }
                            break;
                case 'y':   NeedSecond = TRUE;
                            if (pLocalArgs->TransState==TRANSACTION_QUERY) {
                                so->printf("ERROR: /%c is an incorrect parameter with query\n\n", c);
                                exit(1);
                            }

                            if (cur < length-1) {
                               cur++; 
                               switch(argv[i][cur]) {
                                   case 'i': pLocalArgs->AppendIDToFile = TRUE;
                                             break;

                                   default:  so->printf("ERROR: /y%c is an incorrect parameter\n\n",argv[i][cur]);
                                             exit(1);
                               }
                            } 
                            break;
                case 'z':   NeedSecond = TRUE;
                            if (pLocalArgs->TransState==TRANSACTION_QUERY) {
                                so->printf("ERROR: /%c is an incorrect parameter with query\n\n", c);
                                exit(1);
                            }
                            break;
                case 'o':   pLocalArgs->VerboseOutput = TRUE;
                            break;
                            
                default:    Usage();
            }
            cur++;
          }
        }
        else {
            so->printf("ERROR: Expecting a / option before %s\n", argv[i] );
            exit(1);
        }
     }
     else {
        NeedSecond = FALSE;
        switch (c) {
            case 'c':   if (pLocalArgs->TransState==TRANSACTION_DEL) {
                            so->printf("ERROR: /c is an incorrect parameter with del\n\n");
                            exit(1);
                        }
                        if ( _tcslen(argv[i]) > MAX_COMMENT ) {
                            so->printf("ERROR: Comment must be %d characters or less\n", MAX_COMMENT);
                            exit(1);
                        }
                        pLocalArgs->szComment = (LPTSTR)malloc( (_tcslen(argv[i]) + 1) * sizeof(TCHAR) );
                        if (!pLocalArgs->szComment) MallocFailed();
                        StringCbCopy(pLocalArgs->szComment, _msize(pLocalArgs->szComment), argv[i]);
                        break;

            case 'd':   so->SetFileName(argv[i]);
                        break;

            case 'i':   if (pLocalArgs->TransState==TRANSACTION_ADD) {
                            so->printf("ERROR: /i is an incorrect parameter with add\n\n");
                            exit(1);
                        }
                        if ( _tcslen(argv[i]) != MAX_ID ) {
                            so->printf("ERROR: /i ID is not a valid ID length\n");
                            exit(1);
                        }
                        pLocalArgs->szId = (LPTSTR)malloc( (_tcslen(argv[i]) + 1) * sizeof(TCHAR) );
                        if (!pLocalArgs->szId) MallocFailed();
                        StringCbCopy(pLocalArgs->szId, _msize(pLocalArgs->szId), argv[i]);
                        break;

            case 'f':   if (pLocalArgs->TransState==TRANSACTION_DEL) {
                            so->printf("ERROR:  /f is an incorrect parameter with del\n\n");
                            exit(1);
                        }
                        szFileArg = argv[i];
                        break;
            case 'g':   if (pLocalArgs->TransState==TRANSACTION_DEL) {
                            so->printf("ERROR:  /g is an incorrect parameter with del\n\n");
                            exit(1);
                        }
                        pLocalArgs->szShareName=(LPTSTR) malloc( (_tcslen(argv[i]) + 2) * sizeof(TCHAR) );
                        if (!pLocalArgs->szShareName) MallocFailed();
                        StringCbCopy(pLocalArgs->szShareName, _msize(pLocalArgs->szShareName), argv[i]);
                        pLocalArgs->ShareNameLength=_tcslen(pLocalArgs->szShareName);
                        break;

            case 'h':   if ( _tcscmp( argv[i], _T("pri")) == 0 ) {
                            PubPriPriority = 2;
                        } else if ( _tcscmp( argv[i], _T("pub")) == 0 ) {
                            PubPriPriority = 1;
                        } else {
                            so->printf("ERROR: /h must be followed by pri or pub\n");
                            exit(1);
                        }
                        break;

            case 's':   if ( _tcslen(argv[i]) > (_MAX_PATH-2) ) {
                            so->printf("ERROR: Path following /s is too long\n");
                            exit(1);
                        }
                        // Be sure to allocate enough to add a trailing backslash
                        pLocalArgs->szRootDir = (LPTSTR) malloc ( (_tcslen(argv[i]) + 2) * sizeof(TCHAR) );
                        if (!pLocalArgs->szRootDir) MallocFailed();
                        StringCbCopy(pLocalArgs->szRootDir, _msize(pLocalArgs->szRootDir), argv[i]);
                        MyEnsureTrailingBackslash(pLocalArgs->szRootDir);
                        break;

            case 't':   if (pLocalArgs->TransState==TRANSACTION_DEL) {
                            so->printf("ERROR: /t is an incorrect parameter with del\n\n");
                            exit(1);
                        }
                        if ( _tcslen(argv[i]) > MAX_PRODUCT ) {
                            so->printf("ERROR: Product following /t must be <= %d characters\n",
                                    MAX_PRODUCT);
                            exit(1);
                        }
                        pLocalArgs->szProduct = (LPTSTR) malloc ( (_tcslen(argv[i]) + 1) * sizeof(TCHAR) );
                        if (!pLocalArgs->szProduct) MallocFailed();
                        StringCbCopy(pLocalArgs->szProduct, _msize(pLocalArgs->szProduct), argv[i]);
                        break;

            case 'v':   if (pLocalArgs->TransState==TRANSACTION_DEL) {
                            so->printf("ERROR: /v is an incorrect parameter with del\n\n");
                            exit(1);
                        }
                        if ( _tcslen(argv[i]) > MAX_VERSION  ) {
                            so->printf("ERROR: Version following /v must be <= %d characters\n",
                                    MAX_VERSION);
                            exit(1);
                        }
                        pLocalArgs->szVersion = (LPTSTR) malloc ( (_tcslen(argv[i]) + 1) * sizeof(TCHAR) );
                        if (!pLocalArgs->szVersion) MallocFailed();
                        StringCbCopy(pLocalArgs->szVersion, _msize(pLocalArgs->szVersion), argv[i]);
                        break;

            case 'x':   pLocalArgs->szTransFileName = (LPTSTR) malloc ( (_tcslen(argv[i]) + 1) * sizeof(TCHAR) );
                        if (!pLocalArgs->szTransFileName) MallocFailed();
                        StringCbCopy(pLocalArgs->szTransFileName, _msize(pLocalArgs->szTransFileName), argv[i]);
                        pLocalArgs->StoreFlags = ADD_DONT_STORE;

                        // Since we are throwing away the first part of this path, we can allow
                        // local paths for the files to be stored on the symbols server
                        AllowLocalNames=TRUE;

                        break;

            case 'y':   if (pLocalArgs->TransState==TRANSACTION_DEL) {
                            so->printf("ERROR:  /f is an incorrect parameter with del\n\n");
                            exit(1);
                        }
                        pLocalArgs->StoreFlags = ADD_STORE_FROM_FILE;
                        szFileArg = argv[i];
                        break;

            case 'z':   if (_tcsncmp(_tcslwr(argv[i]),"pub", 3)==0) {
                            pLocalArgs->Filter=1;
                        } else if (_tcsncmp(argv[i],"pri", 3)==0) {
                            pLocalArgs->Filter=2;
                        } else {
                            so->printf("ERROR: only accept pub or pri in -z option");
                            exit(1);
                        }

                        break;

            default:    Usage();
        }
     }
   }
   // Check that everything has been entered
   if (NeedSecond) {
        so->printf("ERROR: /%c must be followed by an argument\n\n", c);
        exit(1);
   }


    // RAID 680688 - Using /a option in symstore add that does not involve /x is not prevented.
    if ( pLocalArgs->AppendStoreFile && (pLocalArgs->szTransFileName==NULL) ) {
        so->printf("ERROR: /a requires /x to also be used.\n\n");
        exit(1);
    }

    if (pLocalArgs->CorruptBinaries && pLocalArgs->StorePtrs) {
        so->printf("ERROR: /p cannot be used with /k.\n");
        exit(1);
    }

   if ( pLocalArgs->StoreFlags == ADD_STORE_FROM_FILE ) {

        if (pLocalArgs->szShareName == NULL ) {
            so->printf("/g must be used when /y is used. \n");
            exit(1);
        }

        MyEnsureTrailingBackslash(pLocalArgs->szShareName);

        pLocalArgs->pStoreFromFile = _tfopen(szFileArg, "r+" );
        if (!pLocalArgs->pStoreFromFile ) {
            so->printf("Cannot open file %s - GetLastError = %d\n",
                szFileArg, GetLastError() );
            exit(1);
        }

   }


   if ( pLocalArgs->StoreFlags == ADD_DONT_STORE ) {

       if (pLocalArgs->szShareName == NULL ) {
            so->printf("/g must be used when /x is used. \n");
            exit(1);
       }

       // Verify that szShare is a prefix of szFileArg

       if (szFileArg == NULL ) {
            so->printf("/f <file> is a required parameter\n");
            exit(1);
       }

       if ( _tcslen(szFileArg) < pLocalArgs->ShareNameLength ) {
            so->printf("/g %s must be a prefix of /f %s\n",pLocalArgs->szShareName, szFileArg);
            exit(1);
       }

       if ( _tcsncicmp(pLocalArgs->szShareName, szFileArg, pLocalArgs->ShareNameLength) != 0 ) {
            so->printf("/g %s must be a prefix of /f %s\n", pLocalArgs->szShareName, szFileArg);
            exit(1);
       }

       // Now, make sure that szFileArg has a trailing backslash
       MyEnsureTrailingBackslash(pLocalArgs->szShareName);
       pLocalArgs->ShareNameLength=_tcslen(pLocalArgs->szShareName);

       // Set the symbol directory under the server to ""
       // so that tcscpy's will work correctly in the rest of the

       pLocalArgs->szSymbolsDir = (LPTSTR) malloc ( sizeof(TCHAR) * 2 );
       if ( !pLocalArgs->szSymbolsDir) MallocFailed();
       StringCbCopy(pLocalArgs->szSymbolsDir, _msize(pLocalArgs->szSymbolsDir), _T(""));
   }

   // Get the various symbol server related file names

   if ( pLocalArgs->StoreFlags == ADD_STORE ||
        pLocalArgs->StoreFlags == ADD_STORE_FROM_FILE  ||
        pLocalArgs->StoreFlags == DEL ||
        pLocalArgs->StoreFlags == QUERY ) {

       if ( pLocalArgs->szRootDir == NULL ) {

            // Verify that the root of the symbols server was entered
            so->printf("ERROR: /s server is a required parameter\n\n");
            exit(1);
       }

       // Store the name of the symbols dir

       pLocalArgs->szSymbolsDir = (LPTSTR) malloc ( sizeof(TCHAR) *
                                   (_tcslen(pLocalArgs->szRootDir) + 1) );
       if (!pLocalArgs->szSymbolsDir) MallocFailed();
       StringCbCopy(pLocalArgs->szSymbolsDir, _msize(pLocalArgs->szSymbolsDir), pLocalArgs->szRootDir);

       // Verify that the symbols dir exists

       if ( !MakeSureDirectoryPathExists(pLocalArgs->szSymbolsDir) ) {
           so->printf("Cannot create the directory %s - GetLastError() = %d\n",
           pLocalArgs->szSymbolsDir, GetLastError() );
           exit(1);
       }

       // Store the pingme.txt
       szPingMe = (LPTSTR) malloc( sizeof(TCHAR) * 
                (_tcslen(pLocalArgs->szRootDir) + _tcslen(_T("\\pingme.txt")) + 1) );
       
       if (!szPingMe) MallocFailed();
       StringCbPrintf(szPingMe, _msize(szPingMe), "%s\\pingme.txt", pLocalArgs->szRootDir);

       // Store the name of the admin dir

       pLocalArgs->szAdminDir = (LPTSTR) malloc ( sizeof(TCHAR) *
                                (_tcslen(pLocalArgs->szRootDir) + _tcslen(_T("000admin\\")) + 1) );
       if (!pLocalArgs->szAdminDir) MallocFailed();
       StringCbPrintf(pLocalArgs->szAdminDir, _msize(pLocalArgs->szAdminDir), "%s000admin\\", pLocalArgs->szRootDir);

       // Verify that the Admin dir exists

       if ( !MakeSureDirectoryPathExists(pLocalArgs->szAdminDir) ) {
            so->printf("Cannot create the directory %s - GetLastError() = %d\n",
            pLocalArgs->szAdminDir, GetLastError() );
            exit(1);
       }

       // Store the name of the master file

       pLocalArgs->szMasterFileName = (LPTSTR) malloc ( sizeof(TCHAR) *
                                      (_tcslen(pLocalArgs->szAdminDir) + _tcslen(_T("history.txt")) + 1) );
       if (!pLocalArgs->szMasterFileName ) MallocFailed();
       StringCbPrintf(pLocalArgs->szMasterFileName, _msize(pLocalArgs->szMasterFileName), "%shistory.txt", pLocalArgs->szAdminDir);

       //
       // Store the name of the "server" file - this contains all
       // the transactions that currently make up the server
       //

       pLocalArgs->szServerFileName = (LPTSTR) malloc ( sizeof(TCHAR) *
                                      (_tcslen(pLocalArgs->szAdminDir) + _tcslen(_T("server.txt")) + 1) );
       if (!pLocalArgs->szServerFileName ) MallocFailed();
       StringCbPrintf(pLocalArgs->szServerFileName, _msize(pLocalArgs->szServerFileName), "%sserver.txt", pLocalArgs->szAdminDir);

   }

   if ( pLocalArgs->StoreFlags==DEL && !pLocalArgs->szId ) {
        so->printf("ERROR: /i id is a required parameter\n\n");
        exit(1);
   }

   // Done if this is a delete transaction

   if ( pLocalArgs->StoreFlags == DEL ) {
        return(pLocalArgs);
   }

   if ( pLocalArgs->StoreFlags == ADD_STORE ||
        pLocalArgs->StoreFlags == ADD_STORE_FROM_FILE ) {

       if ( !pLocalArgs->szProduct ) {
          so->printf("ERROR: /t product is a required parameter\n\n");
          exit(1);
       }

       // Since Version and Comment are optional parameters, initialize them to
       // the empty string if they haven't been assigned

       if ( !pLocalArgs->szVersion ) {
           pLocalArgs->szVersion = (LPTSTR)malloc(sizeof(TCHAR) );
           if (!pLocalArgs->szVersion) MallocFailed();
           StringCbCopy(pLocalArgs->szVersion, _msize(pLocalArgs->szVersion), _T(""));
       }

       if ( !pLocalArgs->szComment ) {
           pLocalArgs->szComment = (LPTSTR)malloc(sizeof(TCHAR) );
           if (!pLocalArgs->szComment) MallocFailed();
           StringCbCopy(pLocalArgs->szComment, _msize(pLocalArgs->szComment), _T(""));
       }

       if ( !pLocalArgs->szUnused ) {
           pLocalArgs->szUnused = (LPTSTR)malloc(sizeof(TCHAR) );
           if (!pLocalArgs->szUnused) MallocFailed();
           StringCbCopy(pLocalArgs->szUnused, _msize(pLocalArgs->szUnused), _T(""));
       }
   }


   if ( pLocalArgs->StoreFlags == ADD_STORE ||
        pLocalArgs->StoreFlags == ADD_DONT_STORE ||
        pLocalArgs->StoreFlags == QUERY)
   {
     pLocalArgs->szSrcDir = (LPTSTR) malloc ( (_MAX_PATH) * sizeof(TCHAR) );
     if (!pLocalArgs->szSrcDir ) MallocFailed();
     pLocalArgs->szFileName = (LPTSTR) malloc ( (_MAX_PATH) * sizeof(TCHAR) );
     if (!pLocalArgs->szFileName ) MallocFailed();

     // Decide what part of szFileArg is a file name and what part of it
     // is a directory

     rc = GetSrcDirandFileName( szFileArg, pLocalArgs->szSrcDir, pLocalArgs->szFileName, AllowLocalNames);

     if (!rc) {
         Usage();
     }

     // Get the pointer path if we are storing pointers
     // Later, if pArgs->szSrcPath == NULL is used as a way of telling if
     // the user wanted pointers or files.

     if ( pLocalArgs->StorePtrs ) {
        if ( !AllowLocalNames ) {
            // Make sure that they are entering a network path.
            // The reason is that this is the path that will be used to
            // add and delete entries from the symbols server.  And, when
            // pointers are used, this is the path the debugger will use to
            // get the file.

            if ( _tcslen(szFileArg) >= 2 ) {
                if ( szFileArg[0] != '\\' || szFileArg[1] != '\\' ) {
                    so->printf("ERROR: /f must be followed by a network path\n");
                    exit(1);
                }
            } else {
                so->printf("ERROR: /f must be followed by a network path\n");
                exit(1);
            }
        }
        pLocalArgs->szSrcPath = (LPTSTR) malloc ( (_tcslen(pLocalArgs->szSrcDir)+1) * sizeof(TCHAR) );
        if (pLocalArgs->szSrcPath == NULL ) MallocFailed();
        StringCbCopy(pLocalArgs->szSrcPath, _msize(pLocalArgs->szSrcPath), pLocalArgs->szSrcDir);
     }
   }

   return (pLocalArgs);
}

ULONG GetMaxLineOfHistoryFile(
    VOID
)
/*++
    This returns the maximum length of a line in the history file.
    The history file contains one line for every transaction.  It exists
    in the admin directory.
--*/

{
ULONG Max;

    Max = MAX_ID + MAX_VERSION + MAX_PRODUCT + MAX_COMMENT +
            TRANS_NUM_COMMAS + TRANS_EOL + TRANS_ADD_DEL + TRANS_FILE_PTR +
            MAX_DATE + MAX_TIME + MAX_UNUSED;
    Max *= sizeof(TCHAR);
    return(Max);
}

ULONG GetMaxLineOfRefsPtrFile(
    VOID
)
/* ++
    This returns the maximum length of a line in the refs.ptr file.
    This file exists in the individual directories of the symbols server.
-- */

{
ULONG Max;

    Max = _MAX_PATH+2 + MAX_ID + TRANS_FILE_PTR + 3;
    Max *= sizeof(TCHAR);
    return(Max);
}

ULONG GetMaxLineOfTransactionFile(
    VOID
)

/*++
    This returns the maximum length of a line in a transaction file.
    The transaction file is a unique file for each transaction that
    gets created in the admin directory.  Its name is a number
    (i.e., "0000000001")
--*/

{
ULONG Max;

    Max = (_MAX_PATH * 2 + 3) * sizeof(TCHAR);
    return(Max);
}

BOOL GetNextId(
    LPTSTR szMasterFileName,
    LPTSTR *szId,
    PHANDLE hFile
) {
    WIN32_FIND_DATA  FindFileData;
    HANDLE           hFoundFile = INVALID_HANDLE_VALUE;

    LONG lFileSize,lId;
    LPTSTR szbuf;
    LONG i,NumLeftZeros;
    BOOL Found;
    LONG lNumBytesToRead;

    DWORD dwNumBytesRead;
    DWORD dwNumBytesToRead;
    DWORD dwrc;
    BOOL  rc;
    TCHAR TempId[MAX_ID + 1];
    DWORD First;
    DWORD timeout;

    *szId = (LPTSTR)malloc( (MAX_ID + 1) * sizeof(TCHAR) );
    if (!*szId) MallocFailed();
    memset(*szId,0,MAX_ID + 1);

    szbuf = (LPTSTR) malloc( (lMaxTrans + 1) * sizeof(TCHAR) );
    if (!szbuf) MallocFailed();
    memset(szbuf,0,lMaxTrans+1);

    // If the MasterFile is empty, then use the number "0000000001"
    *hFile = FindFirstFile((LPCTSTR)szMasterFileName, &FindFileData);
    if ( *hFile == INVALID_HANDLE_VALUE) {
        StringCbCopy(*szId, _msize(*szId), _T("0000000001"));
    }

    // Otherwise, get the last number from the master file
    // Open the Master File

    timeout=0;
    First = 1;
    do {

        *hFile = CreateFile(
                    szMasterFileName,
                    GENERIC_READ | GENERIC_WRITE,
                    0,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL );

        if ( *hFile == INVALID_HANDLE_VALUE ) {
            *hFile = CreateFile( szMasterFileName,
                                GENERIC_READ | GENERIC_WRITE,
                                0,
                                NULL,
                                CREATE_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL );
        }

        // Only print a message the first time through

        if ( First && *hFile == INVALID_HANDLE_VALUE ) {
            First = 0;
            so->printf("Waiting to open %s ... \n", szMasterFileName);
        }

        if ( *hFile == INVALID_HANDLE_VALUE ) {
            SleepEx(1000,0);
            timeout+=1;
        }

    } while ( *hFile == INVALID_HANDLE_VALUE && timeout <= 50 );

    if (timeout > 50 ) {
        so->printf("Timed out -- could not open %s\n", szMasterFileName);
        return(1);
    }

    if (!_tcscmp(*szId, _T("0000000001") ) ) goto finish_GetNextId;

    // Read the last record in from the end of the file.  Allocate one more space to
    // read in the next to last '\n', so we can verify that we are at the beginning of
    // the last record

    lFileSize = GetFileSize(*hFile,NULL);
    if ( lFileSize < (TRANS_NUM_COMMAS + TRANS_EOL + TRANS_ADD_DEL + TRANS_FILE_PTR + MAX_ID) ) {
        //
        // History.txt is corrupt, delete the corrupt file and start a new one
        //
        so->printf("The file %s does not have accurate transaction records in it\n", szMasterFileName);
        CloseHandle(*hFile);


        //
        // This code is a nasty "fix" !
        //

        // kill the existing file
        if ( ! DeleteFile(szMasterFileName) ) {
            so->printf("Couldn't delete corrupt %s.  Please send mail to symadmn.\n", szMasterFileName);
            exit(1);
        } else {
            DWORD Temp;

            CHAR  drive[_MAX_DRIVE];
            CHAR  dir[  _MAX_DIR];
            CHAR  file[ _MAX_FNAME];
            CHAR  ext[  _MAX_EXT];
            CHAR  FileMask[_MAX_PATH];
            CHAR  NextId[_MAX_PATH];

            so->printf("Searching for next valid ID");
            // get the path to the transaction files
            _splitpath(szMasterFileName, drive, dir, file, ext);

            // create a filemask for FindFile
            FileMask[0] = '\0';
            StringCbCat(FileMask, sizeof(FileMask), drive);
            StringCbCat(FileMask, sizeof(FileMask), dir);
            StringCbCat(FileMask, sizeof(FileMask), "\\??????????");

            // loop until all are found
            hFoundFile = FindFirstFile(FileMask, &FindFileData);
            while (hFoundFile != INVALID_HANDLE_VALUE) {
                so->printf(".");
                _splitpath(FindFileData.cFileName, drive, dir, file, ext);

                // transaction files don't have an extension
                if ( ext[0] == '\0' ) {
                    StringCbCopy(NextId, sizeof(NextId), file);
                }

                if (!FindNextFile(hFoundFile, &FindFileData)) {
                    FindClose(hFoundFile);
                    hFoundFile = INVALID_HANDLE_VALUE;
                }
            }

            // increment by one
            Temp = atol(NextId);
            Temp++;

            StringCbPrintf(*szId, _msize(*szId), "%010d", Temp);
            so->printf("using %s\n", *szId);

            *hFile = CreateFile( szMasterFileName,
                                GENERIC_READ | GENERIC_WRITE,
                                0,
                                NULL,
                                CREATE_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL );

            if ( *hFile == INVALID_HANDLE_VALUE ) {
                so->printf("Re-creation of %s failed.  Send mail to symadm.\n", szMasterFileName);
                exit(1);
            }
            goto finish_GetNextId;
        }
    }


    lNumBytesToRead = lFileSize < (lMaxTrans+1) ? lFileSize : (lMaxTrans + 1);
    lNumBytesToRead *= sizeof(TCHAR);

    dwNumBytesToRead = (DWORD)lNumBytesToRead;

    dwrc = SetFilePointer(*hFile,(-1 * dwNumBytesToRead),NULL,FILE_END);
    if ( dwrc == INVALID_SET_FILE_POINTER) {
        so->printf("SYMSTORE: Could not set file pointer\n");
        CloseHandle(*hFile);
        exit(1);
    }

    rc = ReadFile(*hFile,(LPVOID)szbuf,dwNumBytesToRead,&dwNumBytesRead,NULL);
    if ( !rc ) {
        so->printf("SYMSTORE: Read file of %s failed - GetLastError() == %d\n",
                szMasterFileName, GetLastError() );
        CloseHandle(*hFile);
        exit(1);
    }

    if ( dwNumBytesToRead != dwNumBytesRead ) {
        so->printf("SYMSTORE: Read file failure for %s - dwNumBytesToRead = %d, dwNumBytesRead = %d\n",
                szMasterFileName,dwNumBytesToRead, dwNumBytesRead );
        CloseHandle(*hFile);
        exit(1);
    }

    // Now search from the end of the string until you get to the beginning of the string
    // or a '\n'. Count down from the end of the file.

    i = lNumBytesToRead - TRANS_NUM_COMMAS;
    Found = FALSE;

    while ( !Found && (i != 0 ) ) {
        if ( szbuf[i] == '\n' ) {
            Found = TRUE;
        } else {
            i--;
        }
    }

    // Move to the first character of the record
    if (Found) i++;

    // Now, verify that the next ten characters are the ID
    if ( szbuf[i + MAX_ID] != ',' ) {
        so->printf("There is a comma missing after the ID number of the\n");
        so->printf("last record in the file %s\n", szMasterFileName);
        CloseHandle(*hFile);
        exit(1);
    } else {
        szbuf[i + MAX_ID] = '\0';
    }

    // Now increment the number
    lId = atoi(szbuf + i);
    if (lId == 9999999999) {
        so->printf("The last ID number has been used.  No more transactions are allowed\n");
        CloseHandle(*hFile);
        exit(1);
    }
    lId++;
    _itoa(lId, TempId, 10);

    // Now pad the left side with zeros
    // *szId was already set to 0
    NumLeftZeros = MAX_ID - _tcslen(TempId);
    StringCbCopy( (*szId) + NumLeftZeros, _msize(*szId) - (sizeof(TCHAR)*NumLeftZeros), TempId);
    for (i=0; i < NumLeftZeros; i++) {
        (*szId)[i] = '0';
    }

    if (_tcslen(*szId) != MAX_ID ) {
        so->printf("Could not obtain a correct Id number\n");
        CloseHandle(*hFile);
        exit(1);
    }


    finish_GetNextId:

    free(szbuf);
    return (TRUE);
}

/*
    GetSrcDirandFileName

    This procedure takes a path and separates it into two
    strings.  One string for the directory portion of the path
    and one string for the file name portion of the path.


    szStr      - INPUT string that contains a path
    szSrcDir   - OUTPUT string that contains the directory
                 followed by a backslash
    szFileName - OUTPUT string that contains the file name

*/

BOOL GetSrcDirandFileName(LPTSTR szStr, LPTSTR szSrcDir, LPTSTR szFileName, BOOL LocalFile) {
    // NOTE: szSrcDir and szFileName are assumed to be TCHAR arrays on _MAX_PATH length
    DWORD           szStrLength;
    DWORD           found, i, j, lastslash;
    HANDLE          fHandle;
    WIN32_FIND_DATA FindFileData;
    TCHAR           FullPath[_MAX_PATH];
    LPTSTR          pFilename = NULL;

    if (szStr==NULL) {
        return(FALSE);
    }

    if (LocalFile) {
        SymCommonGetFullPathName(szStr, sizeof(FullPath)/sizeof(FullPath[0]), FullPath, &pFilename);
    } else {
        StringCbCopy(FullPath, sizeof(FullPath), szStr);
    }


    szStrLength = _tcslen(FullPath);

    if ( szStrLength == 0 ) {
        return (FALSE);
    }

    // See if the user entered "."
    // If so, set the src directory to . followed by a \, and
    // set the file name to *
    if ( szStrLength == 1 && FullPath[0] == _T('.') ) {
        if ( StringCchCopy(szSrcDir,   _MAX_PATH, _T(".\\")) != S_OK ) {
            return(FALSE);
        }

        if ( StringCchCopy(szFileName, _MAX_PATH, _T("*")) != S_OK ) {
            return(FALSE);
        }
        return (TRUE);
    }

    // Give an error if the end of the string is a colon
    if ( FullPath[szStrLength-1] == _T(':') ) {
        so->printf("SYMSTORE: ERROR: path %s does not specify a file\n", szStr);
        return (FALSE);
    }


    // See if this is a file name only.  See if there are no
    // backslashes in the string.

    found = 0;
    for ( i=0; i<szStrLength; i++ ) {
        if ( FullPath[i] == _T('\\') )
        {
            found = 1;
        }
    }
    if ( !found ) {
        // This is a file name only, so set the directory to
        // the current directory.
        if ( StringCchCopy(szSrcDir, _MAX_PATH, _T(".\\")) != S_OK ) {
            return(FALSE);
        }

        // Set the file name to szStr
        if( StringCchCopy(szFileName, _MAX_PATH, FullPath) != S_OK ) {
            return(FALSE);
        }
        return (TRUE);
    }

    // See if this is a network server and share with no file
    // name after it.  If it is, use * for the file name.

    if ( FullPath[0] == FullPath[1] && FullPath[0] == _T('\\') ) {
        // Check the third character to see if its part of
        // a machine name.
        if (szStrLength < 3 ) {
            so->printf("SYMSTORE: ERROR: %s is not a correct UNC path\n", FullPath);
            return (FALSE);
        }

        switch (FullPath[2]) {
            case _T('.'):
            case _T('*'):
            case _T(':'):
            case _T('\\'):
            case _T('?'):
                so->printf("SYMSTORE: ERROR: %s is not a correct UNC path\n",FullPath);
                return (FALSE);
            default: break;
        }

        // Search for the next backslash.  This is the backslash between
        // the server and the share (\\server'\'share)

        i=3;
        while ( i<szStrLength && FullPath[i] != _T('\\') ) {
            i++;
        }

        // If the next backslash is at the end of the string, then
        // this is an error because the share part of \\server\share
        // is empty.

        if ( i == szStrLength ) {
            so->printf("SYMSTORE: ERROR: %s is not a correct UNC path\n",FullPath);
            return (FALSE);
        }

        // We've found \\server\ so far.
        // see if there is at least one more character.

        i++;
        if ( i >= szStrLength ) {
            so->printf("SYMSTORE: ERROR: %s is not a correct UNC path\n", FullPath);
            return (FALSE);
        }

        switch (FullPath[i]) {
            case _T('.'):
            case _T('*'):
            case _T(':'):
            case _T('\\'):
            case _T('?'):
                so->printf("SYMSTORE: ERROR: %s is not correct UNC path\n",FullPath);
                return (FALSE);
            default: break;
        }

        // Now, we have \\server\share so far -- if there are no more
        // backslashes, then the filename is * and the directory is
        // szStr
        i++;
        while ( i < szStrLength && FullPath[i] != _T('\\') ) {
            i++;
        }

        if ( i == szStrLength ) {

            // verify that there are no wildcards in this
            found = 0;
            for ( j=0; j<szStrLength; j++ ) {
              if ( FullPath[j] == _T('*') || FullPath[j] == _T('?') ) {
                so->printf("SYMSTORE: ERROR: Wildcards are not allowed in \\\\server\\share\n");
                return (FALSE);
              }
            }

            if ( StringCchCopy(szSrcDir, _MAX_PATH, FullPath) != S_OK ) {
                return(FALSE);
            }

            if ( StringCchCat( szSrcDir, _MAX_PATH, _T("\\")) != S_OK ) {
                return(FALSE);
            }

            if ( StringCchCopy(szFileName, _MAX_PATH, _T("*")) != S_OK ) {
                return(FALSE);
            }
            return (TRUE);
        }
    }

    // See if this has wildcards in it.  If it does, then the
    // wildcards are only allowed in the file name part of the
    // string.  The last entry is a file name then.

    found = 0;
    for ( i=0; i<szStrLength; i++ ) {
        // Keep track of where the last directory ended
        if ( FullPath[i] == _T('\\') ) {
            lastslash=i;
        }

        if ( FullPath[i] == _T('*') || FullPath[i] == _T('?') ) {
            found = 1;
        }

        if ( found && FullPath[i] == _T('\\') ) {
            so->printf("SYMSTORE: ERROR: Wildcards are only allowed in the filename\n");
            return (FALSE);
        }
    }

    // If there was a wildcard
    // then use the last backslash as the location for splitting between
    // the directory and the file name.

    if ( found ) {
        _tcsncpy( szSrcDir, FullPath, (lastslash+1) * sizeof (TCHAR) );
        *(szSrcDir+lastslash+1)=_T('\0');

        if ( StringCchCopy(szFileName, _MAX_PATH, FullPath+lastslash + 1 ) != S_OK ) {
            return(FALSE);
        }
        return (TRUE);
    }


    // See if this is a directory.  If it is then make sure there is
    // a blackslash after the directory and use * for the file name.

    fHandle = FindFirstFile(FullPath, &FindFileData);

    if ( fHandle != INVALID_HANDLE_VALUE &&
         (FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ) {
        // If it is a directory then make sure that it ends in a \
        // and use * for the filename

        if ( StringCchCopy(szSrcDir,   _MAX_PATH, FullPath) != S_OK ) {
            return(FALSE);
        }

        MyEnsureTrailingBackslash(szSrcDir);
        if ( StringCchCopy(szFileName, _MAX_PATH, _T("*")) != S_OK ) {
            return(FALSE);
        }
        return (TRUE);
    }

    // Otherwise, go backwards from the end of the string and find
    // the last backslash.  Divide it up into directory and file name.

    i=szStrLength-1;
    while ( FullPath[i] != _T('\\') ) {
        i--;
    }
    _tcsncpy( szSrcDir, FullPath, i+1 );
    *(szSrcDir+i+1)=_T('\0');

    if ( StringCchCopy(szFileName, _MAX_PATH, FullPath+i+1) != S_OK ) {
        return(FALSE);
    }
    return (TRUE);
}

BOOL
InitializeTrans(
    PTRANSACTION *pTrans,
    PCOM_ARGS pArgs,
    PHANDLE hFile
)
{
    BOOL rc;
    SYSTEMTIME SystemTime;

    lMaxTrans = MAX_ID + MAX_VERSION + MAX_PRODUCT + MAX_COMMENT +
                TRANS_NUM_COMMAS + TRANS_EOL + TRANS_ADD_DEL + TRANS_FILE_PTR +
                MAX_DATE + MAX_TIME + MAX_UNUSED;

    *pTrans = NULL;
    *pTrans = (PTRANSACTION) malloc( sizeof(TRANSACTION) );
    if (!*pTrans) {
        so->printf("SYMSTORE: Not enough memory to allocate a TRANSACTION\n");
        exit(1);
    }
    memset(*pTrans,0,sizeof(TRANSACTION) );

    //
    // If this is a delete transaction, then use the ID that was entered from
    // the command line to set the ID of the transaction to be deleted.
    //
    if (pArgs->TransState==TRANSACTION_DEL ) {
        (*pTrans)->TransState = pArgs->TransState;
        (*pTrans)->szId       = pArgs->szId;
        rc = GetNextId(pArgs->szMasterFileName,&((*pTrans)->szDelId),hFile);

    } else if ( pArgs->StoreFlags == ADD_DONT_STORE ) {
        rc = TRUE;
    } else{

        rc = GetNextId(pArgs->szMasterFileName,&((*pTrans)->szId),hFile );
    }

    if (!rc) {
        so->printf("SYMSTORE: Cannot create a new transaction ID number\n");
        exit(1);
    }

    // If the things that are needed for both types of adding
    // That is, creating a transaction file only, and adding the
    // files to the symbols server

    if (pArgs->TransState==TRANSACTION_ADD) {
        (*pTrans)->TransState = pArgs->TransState;
        (*pTrans)->FileOrPtr = pArgs->szSrcPath ? STORE_PTR : STORE_FILE;
    }

    // If this is a add, but don't store the files, then the transaction
    // file name is already in pArgs.

    if (pArgs->StoreFlags == ADD_DONT_STORE) {
        (*pTrans)->szTransFileName=(LPTSTR)malloc( sizeof(TCHAR) *(_tcslen(pArgs->szTransFileName) + 1) );

        if (!(*pTrans)->szTransFileName ) {
            so->printf("Malloc cannot allocate memory for (*pTrans)->szTransFileName \n");
            exit(1);
        }
        StringCbCopy((*pTrans)->szTransFileName, _msize((*pTrans)->szTransFileName), pArgs->szTransFileName);
        return TRUE;
    }

    // Now, set the full path name of the transaction file
    (*pTrans)->szTransFileName=(LPTSTR)malloc( sizeof(TCHAR) *
                    (_tcslen( pArgs->szAdminDir ) +
                     _tcslen( (*pTrans)->szId   ) +
                     1 ) );
    if (!(*pTrans)->szTransFileName ) {
        so->printf("Malloc cannot allocate memory for (*pTrans)->szTransFilename \n");
        exit(1);
    }
    StringCbPrintf( (*pTrans)->szTransFileName,
                    _msize((*pTrans)->szTransFileName),
                    "%s%s",
                    pArgs->szAdminDir,
                    (*pTrans)->szId );

    (*pTrans)->szProduct = pArgs->szProduct;
    (*pTrans)->szVersion = pArgs->szVersion;
    (*pTrans)->szComment = pArgs->szComment;
    (*pTrans)->szUnused = pArgs->szUnused;


    // Set the time and date
    GetLocalTime(&SystemTime);
    StoreSystemTime( & ((*pTrans)->szTime), &SystemTime );
    StoreSystemDate( & ((*pTrans)->szDate), &SystemTime );


    return (TRUE);
}

VOID MallocFailed() {
    so->printf("SYMSTORE: Malloc failed to allocate enough memory\n");
    exit(1);
}

DWORD
StoreAllDirectories(
    LPTSTR szDir,
    LPTSTR szFName,
    LPTSTR szDestDir,
    PFILE_COUNTS pFileCounts,
    LPTSTR szPath
)

/* ++

   IN szDir     Directory of files to Store

-- */

{

    HANDLE hFindFile;
    TCHAR szCurPath[_MAX_PATH];
    TCHAR szFilePtrPath[_MAX_PATH];      // This is the path that will get stored as a
                                         // pointer to the file.
    LPTSTR szPtrPath = NULL;

    BOOL Found = FALSE;
    DWORD NumBadFiles=0;

    LPWIN32_FIND_DATA lpFindFileData;



    NumBadFiles += StoreDirectory(szDir,
                                  szFName,
                                  szDestDir,
                                  pFileCounts,
                                  szPath
                                  );

    lpFindFileData = (LPWIN32_FIND_DATA) malloc (sizeof(WIN32_FIND_DATA) );
    if (!lpFindFileData) {
        so->printf("Symchk: Not enough memory.\n");
        exit(1);
    }

    // Look for all the subdirectories
    StringCbCopy(szCurPath, sizeof(szCurPath), szDir);
    StringCbCat( szCurPath, sizeof(szCurPath),  _T("*.*") );

    Found = TRUE;
    hFindFile = FindFirstFile((LPCTSTR)szCurPath, lpFindFileData);
    if ( hFindFile == INVALID_HANDLE_VALUE) {
        Found = FALSE;
    }

    while ( Found ) {
        if ( lpFindFileData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

            if ( !_tcscmp(lpFindFileData->cFileName, _T(".")) ||
                 !_tcscmp(lpFindFileData->cFileName, _T("..")) ) {
            } else {
                // Get the current path that we are searching in
                StringCbCopy(szCurPath, sizeof(szCurPath), szDir);
                StringCbCat( szCurPath, sizeof(szCurPath), lpFindFileData->cFileName);
                MyEnsureTrailingBackslash(szCurPath);

                // Get the current path to use as the pointer to the
                // file, if we are storing file pointers instead of
                // files in this tree.
                if ( szPath ) {
                    StringCbCopy(szFilePtrPath, sizeof(szFilePtrPath), szPath);
                    StringCbCat( szFilePtrPath, sizeof(szFilePtrPath), lpFindFileData->cFileName);
                    MyEnsureTrailingBackslash(szFilePtrPath);
                    szPtrPath = szFilePtrPath;
                }

                NumBadFiles += StoreAllDirectories(
                                    szCurPath,
                                    szFName,
                                    szDestDir,
                                    pFileCounts,
                                    szPtrPath
                                    );
            }
        }
        Found = FindNextFile(hFindFile, lpFindFileData);

        if ( !Found ) {
            DWORD LastError = GetLastError();

            switch (LastError) {
                case ERROR_NO_MORE_FILES: // Completed successfully because there are no
                                          // more files to process.
                    break;

                case ERROR_FILE_NOT_FOUND: {// Possible network error, try again for up to 30 sec
                        DWORD SleepCount = 0;

                        // Loop until one of the following:
                        //  1) A file is found
                        //  2) FindNextFile returns an error code other than ERROR_FILE_NOT_FOUND
                        //  3) 30 seconds have elapsed
                        while ( (Found = FindNextFile(hFindFile, lpFindFileData)) ||
                                ( (GetLastError() == ERROR_FILE_NOT_FOUND)  &&
                                  (SleepCount     <= 60                  ) )    ) {
                            SleepCount++;
                            Sleep(500); // sleep 1/2 second
                        }
                    }
                    break;

                default:
                    so->printf("Symchk: Failed to get next filename. Error code was 0x%08x.\n", LastError);
                    break;
            }
        }
    }

    free(lpFindFileData);
    FindClose(hFindFile);
    return(NumBadFiles);
}


StoreDirectory(
    LPTSTR szDir,
    LPTSTR szFName,
    LPTSTR szDestDir,
    PFILE_COUNTS pFileCounts,
    LPTSTR szPath
)
{
    HANDLE hFindFile;
    TCHAR  szFileName[_MAX_PATH];
    TCHAR  szCurPath[_MAX_PATH];
    TCHAR  szCurFileName[_MAX_PATH];
    TCHAR  szCurPtrFileName[_MAX_PATH];  // Ptr to the file to put in "file.ptr"
                                        // instead of storing the file.
    TCHAR  szFullFilename[_MAX_PATH];
    LPTSTR pFilename;

    BOOL   Found, length;
    DWORD  rc;
    DWORD  NumBadFiles=0;
    BOOL   skipped = 0;
    USHORT rc_flag;
    BOOL   unknowntype = FALSE;

    LPWIN32_FIND_DATA lpFindFileData;

    // Create the file name
    StringCbCopy(szFileName, sizeof(szFileName), szDir);
    StringCbCat( szFileName, sizeof(szFileName), szFName);

    // Get the current path that we are searching in
    StringCbCopy(szCurPath, sizeof(szCurPath), szDir);

    lpFindFileData = (LPWIN32_FIND_DATA) malloc (sizeof(WIN32_FIND_DATA) );
    if (!lpFindFileData) {
        so->printf("Symchk: Not enough memory.\n");
        exit(1);
    }

    Found = TRUE;
    hFindFile = FindFirstFile((LPCTSTR)szFileName, lpFindFileData);
    if ( hFindFile == INVALID_HANDLE_VALUE ) {
        Found = FALSE;
    }

    while ( Found ) {
        // Found a file, not a directory
        if ( !(lpFindFileData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ) {

            rc_flag=0;

            StringCbCopy(szCurFileName, sizeof(szCurFileName), szCurPath);
            StringCbCat( szCurFileName, sizeof(szCurFileName), lpFindFileData->cFileName);

            if ( szPath ) {
                StringCbCopy(szCurPtrFileName, sizeof(szCurPtrFileName), szCurFileName);
                //PrivateGetFullPathName(szCurFileName, sizeof(szCurPtrFileName)/sizeof(szCurPtrFileName[0]), szCurPtrFileName, &pFilename);
            }

            // Figure out if its a dbg or pdb
            length = _tcslen(szCurFileName);
            rc = FALSE;
            skipped = FALSE;
            if (length > 4 ) {
                if ( _tcsicmp(_T(".dbg"), szCurFileName + length - 4) == 0 ) {
                   if ( szPath ) {
                       rc = StoreDbg( szDestDir, szCurFileName, szCurPtrFileName, &rc_flag );
                   }
                   else {
                       rc = StoreDbg( szDestDir, szCurFileName, NULL, &rc_flag );
                   }
                }
                else if ( _tcsicmp(_T(".pdb"), szCurFileName + length - 4) == 0 ) {
                   if ( szPath ) {
                       rc = StorePdb( szDestDir, szCurFileName, szCurPtrFileName, &rc_flag );
                   } else {
                       rc = StorePdb( szDestDir, szCurFileName, NULL, &rc_flag );
                   }
                }
                else {
                   if ( szPath ) {
                       rc = StoreNtFile( szDestDir, szCurFileName, szCurPtrFileName, &rc_flag );
                   } else {
                       rc = StoreNtFile( szDestDir, szCurFileName, NULL, &rc_flag );
                   }
                   if (rc_flag == FILE_SKIPPED) {
                       unknowntype = TRUE;
                   }    

                }
           
            }
            
            if (rc_flag == FILE_SKIPPED) {

                NumSkippedFiles++;
                skipped = TRUE;
                
                if(pArgs->VerboseOutput) {
                    if (unknowntype) {
                        so->printf("SYMSTORE: Skipping %s - not a dbg, pdb, or executable\n", szCurFileName);
                        unknowntype = FALSE;
                    } else {
                        so->printf("SYMSTORE: Skipping %s - filter out by -z option\n", szCurFileName);
                        unknowntype = FALSE;
                    }
                }

            }

            if (!skipped && !rc) {
                pFileCounts->NumFailedFiles++;

                if ( pArgs->TransState != TRANSACTION_QUERY ) {
                    NumBadFiles++;
                    so->printf("SYMSTORE: ERROR: Cannot store %s ", szCurFileName);
                    DisplayErrorText(rc_flag);
                    so->printf("\n");
                } else {
                    NumSkippedFiles++; // don't fail invalid files when doing query
                    if(pArgs->VerboseOutput) {
                        so->printf("SYMSTORE: Skipping: %s - not a valid file for symbol server.\n", szCurFileName);
                    }
                }

            } else if (!skipped) {
                pFileCounts->NumPassedFiles++;
                if ( pArgs->TransState != TRANSACTION_QUERY ) {
                    if (pFileCounts->NumPassedFiles % 50 == 0) {
                        so->stdprintf(".");
                    }
                }
            }
        }
        Found = FindNextFile(hFindFile, lpFindFileData);
    }
    free(lpFindFileData);
    FindClose(hFindFile);
    return(NumBadFiles);
}


BOOL
StoreSystemDate(
    LPTSTR *szBuf,
    LPSYSTEMTIME lpSystemTime
)
{

    TCHAR Day[20];
    TCHAR Month[20];
    TCHAR Year[20];

    (*szBuf) = (LPTSTR) malloc (20 * sizeof(TCHAR) );
    if ( (*szBuf) == NULL ) MallocFailed();

    _itoa(lpSystemTime->wMonth, Month, 10);
    _itoa(lpSystemTime->wDay, Day, 10);
    _itoa(lpSystemTime->wYear, Year, 10);

    StringCbPrintf(*szBuf, _msize(*szBuf), "%2s/%2s/%2s", Month, Day, Year+2 );

    if ( (*szBuf)[0] == ' ' ) (*szBuf)[0] = '0';
    if ( (*szBuf)[3] == ' ' ) (*szBuf)[3] = '0';

    return(TRUE);
}

BOOL
StoreSystemTime(
    LPTSTR *szBuf,
    LPSYSTEMTIME lpSystemTime
)
{

    TCHAR Hour[20];
    TCHAR Minute[20];
    TCHAR Second[20];

    (*szBuf) = (LPTSTR) malloc (20 * sizeof(TCHAR) );
    if ( (*szBuf) == NULL ) MallocFailed();

    _itoa(lpSystemTime->wHour, Hour, 10);
    _itoa(lpSystemTime->wMinute, Minute, 10);
    _itoa(lpSystemTime->wSecond, Second, 10);

    StringCbPrintf(*szBuf, _msize(*szBuf), "%2s:%2s:%2s", Hour, Minute, Second );

    if ( (*szBuf)[0] == ' ' ) (*szBuf)[0] = '0';
    if ( (*szBuf)[3] == ' ' ) (*szBuf)[3] = '0';
    if ( (*szBuf)[6] == ' ' ) (*szBuf)[6] = '0';

    return(TRUE);
}

BOOL
UpdateServerFile(
    PTRANSACTION pTrans,
    LPTSTR szServerFileName
)
/* ++
    IN pTrans         // Transaction Info
    IN szServerFile   // Full path and name of the server transaction file
                      // This file tells what is currently on the server

    Purpose:  UpdateServerFile adds the transaction to the server text file if this is an
    "add.  If this is a "del", it deletes it from the server file.  The "server.txt" file
    is in the admin directory.

-- */
{
ULONG i;
ULONG NumLines;
ULONG IdLineNum;
LPTSTR szBuf;
LPTSTR szTempFileName;
FILE *fTempFile;
FILE *fServerFile;
ULONG MaxLine;

TCHAR *token;
TCHAR seps[]=",";

BOOL rc;
HANDLE hFile;
DWORD First;
DWORD timeout;

    if (pTrans->TransState == TRANSACTION_ADD ) {

        // Open the File -- wait until we can get access to it

        First = 1;
        timeout=0;
        do {

            hFile = CreateFile(
                        szServerFileName,
                        GENERIC_READ | GENERIC_WRITE,
                        0,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL );

            if ( hFile == INVALID_HANDLE_VALUE ) {
                hFile = CreateFile(
                            szServerFileName,
                            GENERIC_READ | GENERIC_WRITE,
                            0,
                            NULL,
                            CREATE_ALWAYS,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL );
            }

            if ( First && hFile == INVALID_HANDLE_VALUE ) {
                First = 0;
                so->printf("Waiting to open %s ... \n", szServerFileName);
            }

            if ( hFile == INVALID_HANDLE_VALUE ) {
                SleepEx(1000,0);
                timeout++;

            }

        } while ( hFile == INVALID_HANDLE_VALUE && timeout <= 50 );

        if ( timeout > 50 ) {
            so->printf("Timed out -- could not open %s\n", szServerFileName);
            CloseHandle(hFile);
            return (1);
        }

        rc = AddTransToFile(pTrans, szServerFileName,&hFile);

        CloseHandle(hFile);
        return(rc);
    }

    if (pTrans->TransState != TRANSACTION_DEL) {
        return(FALSE);
    }

    //
    // Now, delete this transaction ID from the file
    // Get the name of the temporary file
    // and open it for writing
    //

    szTempFileName = (LPTSTR)malloc(sizeof(TCHAR) *
                                    _tcslen(szServerFileName) + _tcslen(".tmp") + 1 );
    if (szTempFileName == NULL) MallocFailed();
    StringCbPrintf(szTempFileName, _msize(szTempFileName), "%s.tmp", szServerFileName);

    fTempFile = _tfopen(szTempFileName, _T("w") );
    if ( fTempFile == NULL ) {
        so->printf("SYMSTORE: Cannot create a temporary file %s\n", szTempFileName);
        exit(1);
    }


    //
    // Open the Server file for reading
    //

    fServerFile = _tfopen(szServerFileName, _T("r") );
    if ( fServerFile == NULL ) {
        so->printf("SYMSTORE: Cannot create a temporary file %s\n", szServerFileName);
        exit(1);
    }


    //
    // Allocate enough space to hold a line of the master file
    //
    MaxLine = GetMaxLineOfHistoryFile();

    szBuf = (LPTSTR)malloc(sizeof(TCHAR) * MaxLine);
    if (szBuf == NULL) MallocFailed();

    //
    // Copy the master file to the temporary file.
    //

    // Do some stuff so that we don't put an extra '\n' at the end of the file
    // Figure out how many lines there are and which line the ID is on.
    // If we are removing the last line of the file, then the next to the last
    // line needs to have a '\n' stripped from it.
    //
    NumLines = 0;
    IdLineNum = 0;

    while ( _fgetts( szBuf, MaxLine, fServerFile) != NULL ) {

        NumLines++;

        token = _tcstok(szBuf,seps);
        if (_tcscmp(token, pTrans->szId) == 0 ) {
            IdLineNum = NumLines;
        }

    }
    fflush(fServerFile);
    fclose(fServerFile);

    // Now, reopen it and copy it, deleting the line with ID in it

    fServerFile = _tfopen(szServerFileName, _T("r") );
    if ( fServerFile == NULL ) {
        so->printf("SYMSTORE: Cannot create a temporary file %s\n", szServerFileName);
        exit(1);
    }

    for (i=1; i<=NumLines; i++ ) {

        if ( _fgetts( szBuf, MaxLine, fServerFile) == NULL )
        {
            so->printf( "SYMSTORE: Cannot read from %s - GetLastError = %d\n",  
                        szServerFileName, GetLastError() 
                      ); 
            exit(1);
        }

        if ( i != IdLineNum ) {

           // Make sure that the last line doesn't end with a '\n'
           if ( i == NumLines || (IdLineNum == NumLines && i == NumLines-1) ) {
               if ( szBuf[_tcslen(szBuf)-1] == '\n' ) {
                   szBuf[_tcslen(szBuf)-1] = '\0';
               }
           }

           _fputts( szBuf, fTempFile);

        }
    }

    fflush(fServerFile);
    fclose(fServerFile);
    fflush(fTempFile);
    fclose(fTempFile);

    // Now, delete the original Server file and
    // replace it with the temporary file

    rc = DeleteFile(szServerFileName);
    if (!rc) {
        so->printf("SYMSTORE: Could not delete %s to update it with %s\n",
                szServerFileName, szTempFileName);
        exit(1);
    }

    rc = _trename(szTempFileName, szServerFileName);
    if ( rc != 0 ) {
        so->printf("SYMSTORE: Could not rename %s to %s\n",
                szTempFileName, szServerFileName);
        exit(1);
    }

    free(szBuf);
    free(szTempFileName);

    return(TRUE);
}

VOID
Usage (
    VOID
    )

{
    so->printf("\n"
         "Usage:\n"
         "symstore add [/r] [/p] [/l] /f File /s Store /t Product [/v Version]\n"
         "             [/c Comment] [/d LogFile]\n\n"
         "symstore add [/r] [/p] [/l] /g Share /f File /x IndexFile [/a] [/d LogFile]\n\n"
         "symstore add /y IndexFile /g Share /s Store [/p] /t Product [/v Version]\n"
         "             [/c Comment] [/d LogFile]\n\n"
         "symstore del /i ID /s Store [/d LogFile]\n\n"
         "symstore query [/r] [/o] /f File /s Store\n\n"
         "    add             Add files to server or create an index file.\n\n"
         "    del             Delete a transaction from the server.\n\n"
         "    query           Check if file(s) are indexed on the server.\n\n"
         "    /f File         Network path of files or directories to add.\n\n"
         "    /g Share        This is the server and share where the symbol files were\n"
         "                    originally stored.  When used with /f, Share should be\n"
         "                    identical to the beginning of the File specifier.  When\n"
         "                    used with the /y, Share should be the location of the\n"
         "                    original symbol files, not the index file.  This allows\n"
         "                    you to later change this portion of the file path in case\n"
         "                    you move the symbol files to a different server and share.\n\n"
         "    /i ID           Transaction ID string.\n\n"
         "    /l              Allows the file to be in a local directory rather than a\n"
         "                    network path.(This option is only used with the /p option.)\n\n"
         "    /p              Causes SymStore to store a pointer to the file, rather than\n"
         "                    the file itself.\n\n"
         "    /r              Add files or directories recursively.\n\n"
         "    /s Store        Root directory for the symbol store.\n\n"
         "    /t Product      Name of the product.\n\n"
         "    /v Version      Version of the product.\n\n"
         "    /c Comment      Comment for the transaction.\n\n"
         "    /d LogFile      Send output to LogFile instead of standard output.\n\n"
         "    /x IndexFile    Causes SymStore not to store the actual symbol files in the\n"
         "                    symbol store.  Instead, information is stored which will\n"
         "                    allow the files to be added later.\n\n"
         "    /y IndexFile    This reads the data from a file created with /x.\n\n"
         "    /yi IndexFile   Append a comment with the transaction ID to the end of the\n"
         "                    index file.\n\n"
/*
         "    /z pub | pri    Put option will only index symbols that have had the full\n"
         "                    source information stripped.  Pri will only index symbols\n"
         "                    that contain the full source information.  Both options\n"
         "                    will index binaries.\n\n"
         "    /m              MSarchive\n\n"
         "    /h pub | pri    Give priority to pub or pri."
*/
         "    /a              Causes SymStore to append new indexing information\n"
         "                    to an existing index file. (This option is only used with\n"
         "                    /x option.)\n\n"
         "    /o              Give verbose output.\n\n"
         "\n" );
    exit(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\symsrv\copystr.cpp ===
/*
 * copystr.cpp
 */
 
#define COPYSTR_MOD
#define COPYSTR_NO_WCHAR
#define COPYSTR_NO_PRINTSTRING

#include <copystr.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\symsrv\pch.h ===
/*
 * pch.h  for symsrv.dll
 */

#include <stdlib.h>
#include <stdio.h>
#include <assert.h>
#include <windows.h>
#include <wininet.h>
#include <dbghelp.h>
#include <dbgver.h>
#include <copystr.h>
#include "symsrv.h"
#include "crt.h"
#include "util.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\symsrv\crt.h ===
/*
 * crt.h
 *
 * forces all appropriate functions to be intrinsic
 */

#pragma intrinsic(strcat)
#pragma intrinsic(strcpy)
#pragma intrinsic(strlen)
#pragma intrinsic(strcmp)
#pragma intrinsic(memset)
#pragma intrinsic(memcmp)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\symsrv\crt.cpp ===
/*
 * crt.cpp
 */

#define _CRTIMP
#include <windows.h>
#include <assert.h>
#include "crt.h"

void * __cdecl operator new(size_t cb)
{
    void *res = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, cb);
    return res;
}


void __cdecl operator delete(void * p)
{
    HeapFree(GetProcessHeap(), 0, p);;
}


#ifdef _X86_

#undef  tolower

#define isupper(c) ((c) >= 'A' && (c) <= 'Z')
#define mklower(c)  ((c) - 'A' + 'a')

int __cdecl tolower(
    int c
    )
{
    return (isupper(c)) ? mklower(c) : c;
}


int __cdecl _stricmp(
    const char *one,
    const char *two
    )
{
    assert(one && two);

    for (; tolower(*one) == tolower(*two); one++, two++)
    {
        if (!*one)
            return 0;
    }

    if (!*one)
        return -1;
    if (!*two)
        return 1;
    return (tolower(*one) - tolower(*two));
}


int __cdecl strncmp(
    const char *one,
    const char *two,
    size_t      len
    )
{
    size_t i;

    for (i = 0; i < len; i++, one++, two++) {
        if (*one == *two)
            continue;
        if (!*one)
            return -1;
        if (!*two)
            return 1;
        return (*one - *two);
    }

    return 0;
}


int __cdecl _strnicmp(
    const char *one,
    const char *two,
    size_t      len
    )
{
    size_t i;
    int    c1;
    int    c2;

    for (i = 0; i < len; i++, one++, two++)
    {
        c1 = tolower(*one);
        c2 = tolower(*two);
        if (c1 == c2)
            continue;
        if (!c1)
            return -1;
        if (!c2)
            return 1;
        return (c1 - c2);
    }

    return 0;
}


char * __cdecl strchr(
    const char *sz,
    int         c
    )
{
    for (; *sz; sz++)
    {
        if (*sz == c)
            return (char *)sz;
    }

    return NULL;
}


char * __cdecl strrchr(
    const char *sz,
    int         c
    )
{
    const char *p;

    if (!c)
        return NULL;

    for (p = sz + strlen(sz); p >= sz; p--)
    {
        if (*p == c)
            return (char *)p;
    }

    return NULL;
}


char * __cdecl strstr(
    const char *sz,
    const char *token
    )
{
    int len;

    len = strlen(token);

    for (; *sz; sz++)
    {
        if (*sz == *token)
        {
            if (!strncmp(sz, token, len))
                return (char *)sz;
        }
    }

    return NULL;
}


int __cdecl isspace(int c)
{
    switch (c)
    {
    case 0x9:   // tab
    case 0xD:   // CR
    case 0x20:  // space
        return true;
    }

    return false;
}

#pragma function(memcpy)

void * __cdecl memcpy(void *dest, const void *src, size_t count)
{
    while (count) {
        *(char *)dest = *(char *)src;
        count--;
    }
    return dest;
}

#endif // #ifdef _X86_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\symsrv\symsrv.cpp ===
#include "pch.h"

#include "store.hpp"

#define CF_COMPRESSED   0x1


#define TLS // __declspec( thread )

#if defined(_WIN64) && defined(_M_IA64)
#pragma section(".base", long, read, write)
extern "C"
__declspec(allocate(".base"))
extern
IMAGE_DOS_HEADER __ImageBase;
#else
extern "C"
extern
IMAGE_DOS_HEADER __ImageBase;
#endif

HINSTANCE ghSymSrv = (HINSTANCE)&__ImageBase;
UINT_PTR  goptions = SSRVOPT_DWORD;
DWORD     gptype = SSRVOPT_DWORD;
PSYMBOLSERVERCALLBACKPROC gcallback = NULL;
ULONG64   gcontext = 0;
HWND      ghwndParent = (HWND)0;
char      gproxy[MAX_PATH + 1] = "";
int       gdbgout = -1;
char      gdstore[MAX_PATH + 1] = "";


void 
PrepOutputString(
    char *in, 
    char *out, 
    int len
    )
{
    int i;

    *out = 0;

    for (i = 0; *in && i < len; i++, in++, out++) {
        if (*in == '\b') 
            break;
        *out = *in;
    }
    
    *out = 0;
}


VOID 
OutputDbgString(
    char *sz
    )
{
    char sztxt[3000];
    
    PrepOutputString(sz, sztxt, 3000);
    if (*sztxt)
        OutputDebugString(sztxt);
}


__inline
BOOL
DoCallback(
    DWORD action,
    ULONG64 data
    )
{
    return gcallback(action, data, gcontext);
}


BOOL
PostEvent(
    PIMAGEHLP_CBA_EVENT evt
    )
{
    BOOL fdbgout = false;
    
    if (!*evt->desc)
        return true;

    // write to debug terminal, if called for

    if (gdbgout == 1) {
        fdbgout = true;
        OutputDbgString(evt->desc);
    }

    // don't pass info-level messages, unless told to

    if ((evt->severity <= sevInfo) && !(goptions & SSRVOPT_TRACE))
        return true;

    // If there is no callback function, send to the debug terminal.

    if (!gcallback) {
        if (!fdbgout)
            OutputDbgString(evt->desc);
        return true;
    }

    // Otherwise call the callback function.

    return DoCallback(SSRVACTION_EVENT, (ULONG64)evt);
}

BOOL
WINAPIV
evtprint(
    DWORD          severity,
    DWORD          code,
    PVOID          object,
    LPSTR          format,
    ...
    )
{
    static char buf[1000] = "";
    IMAGEHLP_CBA_EVENT evt;
    va_list args;

    va_start(args, format);
    wvsprintf(buf, format, args);
    va_end(args);
    if (!*buf)
        return true;

    evt.severity = severity;
    evt.code = code;
    evt.desc = buf;
    evt.object = object;

    return PostEvent(&evt);
}


int
_eprint(
    LPSTR format,
    ...
    )
{
    static char buf[1000] = "";
    va_list args;

    if (!format || !*format)
        return 1;

    if (!(goptions & SSRVOPT_TRACE) && gdbgout != 1)
        return 1;

    va_start(args, format);
    wvsprintf(buf, format, args);
    va_end(args);
    
    if (!evtprint(sevInfo, 0, NULL, buf))
        if (gcallback)
            gcallback(SSRVACTION_TRACE, (ULONG64)buf, gcontext);
    
    return 1;
}

DBGEPRINT  geprint = _eprint;

int
_dprint(
    LPSTR format,
    ...
    )
{
    static char buf[1000] = "SYMSRV:  ";
    va_list args;

    if (!format || !*format)
        return 1;

    if (!(goptions & SSRVOPT_TRACE) && gdbgout != 1)
        return 1;

    va_start(args, format);
    wvsprintf(buf + 9, format, args);
    va_end(args);

    return _eprint(buf);
}

DBGPRINT  gdprint = NULL; // _dprint;


// this one is for calling from dload.cpp

int
__dprint(
    LPSTR sz
    )
{
    static char buf[1000] = "SYMSRV:  ";
    va_list args;

    if (!sz || !*sz)
        return 1;

    CopyStrArray(buf, "SYMSRV:  ");
    CatStrArray(buf, sz);

    if (gcallback)
        gcallback(SSRVACTION_TRACE, (ULONG64)buf, gcontext);
    if (!gcallback || (gdbgout == 1))
        OutputDbgString(buf);

    return 1;
}


int
_querycancel(
    )
{
    BOOL rc;
    BOOL cancel = false;

    if (!gcallback)
        return false;

    rc = gcallback(SSRVACTION_QUERYCANCEL, (ULONG64)&cancel, gcontext);
    if (rc && cancel)
        return true;

    return false;
}


QUERYCANCEL gquerycancel = _querycancel;

BOOL
SetError(
    DWORD err
    )
{
    SetLastError(err);
    return 0;
}


BOOL
copy(
    IN  PCSTR trgsite,
    IN  PCSTR srcsite,
    IN  PCSTR rpath,
    IN  PCSTR file,
    OUT PSTR  trg,      // must be at least MAX_PATH elements
    IN  DWORD flags
    )
{
    BOOL  rc;
    DWORD type = stUNC;
    CHAR  epath[MAX_PATH + 1];
    CHAR  srcbuf[MAX_PATH + 1];
    CHAR  tsite[MAX_PATH + 1];
    CHAR  ssite[MAX_PATH + 1];
    PSTR  src;
    Store *store;
    DWORD ec;

    assert(trgsite && srcsite);

    // use the default downstream store, if specified

    CopyStrArray(tsite, (*trgsite) ? trgsite : gdstore);
    CopyStrArray(ssite, srcsite);

    // get the store type of the target store

    type = GetStoreType(tsite);
    switch (type) {
    case stUNC:
        break;
    case stHTTP:
    case stHTTPS:
        // Can't use http for the target.
        // If a source is specifed, then bail.
        if (*ssite) 
            return SetError(ERROR_INVALID_PARAMETER);
        // Otherwise, just use the default downstream store for a target.
        CopyStrArray(ssite, tsite);
        CopyStrArray(tsite, gdstore);
        break;
    case stError:
        return SetError(ERROR_INVALID_PARAMETER);
    default:
        return SetError(ERROR_INVALID_NAME);    }

    // MAYBE PUT A CHECK IN HERE FOR A CAB.  LIKE IF THE DIRECTORY IS
    // ACTUALLY A COMPRESSED FILE AND RETURN stCAB.

    // generate full target path

    pathcpy(trg, tsite, rpath, MAX_PATH);
    pathcat(trg, file, MAX_PATH);

    // if file exists, return it

    ec = FileStatus(trg);
    if (!ec) {
        return true;
    } else if (ec == ERROR_NOT_READY) {
        dprint("%s - drive not ready\n", trg);
        return false;
    }

    if (ReadFilePtr(trg, MAX_PATH)) {
        ec = FileStatus(trg);
        if (ec == NO_ERROR) 
            return true;
        dprint("%s - %s\n", trg, FormatStatus(ec));
        return false;
    }

    if (!*ssite) {
        ec = FileStatus(CompressedFileName(trg));
        if (ec != NO_ERROR) {
            // if there is no source to copy from, then error
            dprint("%s - file not found\n", trg);
            return SetError(ERROR_FILE_NOT_FOUND);
        }

        // There is a compressed file..
        // Expand it to the default store.

        CopyStrArray(ssite, tsite);
        CopyStrArray(tsite, gdstore);
        pathcpy(trg, tsite, rpath, MAX_PATH);
        pathcat(trg, file, MAX_PATH);
        ec = FileStatus(trg);
        if (ec == NO_ERROR)
            return true;
    }

    if (goptions & SSRVOPT_SECURE) {
        dprint("%s - file copy not allowed in secure mode\n", trg);
        return SetError(ERROR_ACCESS_DENIED);
    }

    if (!EnsurePathExists(trg, epath, DIMA(epath))) {
        dprint("%s - couldn't create target path\n", trg);
        return SetError(ERROR_PATH_NOT_FOUND);
    }

    store = GetStore(ssite);
    if (!store)
        return false;

    rc = store->init();
    if (!rc)
        return false;

    rc = store->copy(rpath, file, tsite);

    // test the results and set the return value

    if (rc && !FileStatus(trg)) 
        return true;

    UndoPath(trg, epath);

    return false;
}


BOOL
ping(
    IN  PCSTR trgsite,
    IN  PCSTR srcsite,
    IN  PCSTR rpath,
    IN  PCSTR file,
    OUT PSTR  trg,
    IN  DWORD flags
    )
{
    BOOL  rc;
    DWORD type = stUNC;
    CHAR  epath[_MAX_PATH];
    CHAR  srcbuf[_MAX_PATH];
    PSTR  src;
    Store *store;
    DWORD ec;


    store = GetStore(srcsite);
    if (!store)
        return false;

    rc = store->init();
    if (!rc)
        return false;

    rc = store->ping();

    return rc;
}


void
CatStrDWORD(
    IN OUT PSTR  sz,
    IN     DWORD value,
    IN     DWORD size
    )
{
    CHAR buf[MAX_PATH + 256];

    assert(sz);

    if (!value)
        return;

    wsprintf(buf, "%s%x", sz, value);  // SECURITY: This will take a 256 digit DWORD.
    CopyString(sz, buf, size);
}


void
CatStrGUID(
    IN OUT PSTR  sz,
    IN     GUID *guid,
    IN     DWORD size
    )
{
    CHAR buf[MAX_PATH + 256];
    BYTE byte;
    int i;

    assert(sz);

    if (!guid)
        return;

    // append the first DWORD in the pointer

    wsprintf(buf, "%08X", guid->Data1);
    CatString(sz, buf, size);

    // this will catch the passing of a PDWORD and avoid
    // all the GUID parsing

    if (!guid->Data2 && !guid->Data3) {
        for (i = 0, byte = 0; i < 8; i++) {
            byte |= guid->Data4[i];
            if (byte)
                break;
        }
        if (!byte)
            return;
    }

    // go ahead and add the rest of the GUID

    wsprintf(buf, "%04X", guid->Data2);
    CatString(sz, buf, size);
    wsprintf(buf, "%04X", guid->Data3);
    CatString(sz, buf, size);
    wsprintf(buf, "%02X", guid->Data4[0]);
    CatString(sz, buf, size);
    wsprintf(buf, "%02X", guid->Data4[1]);
    CatString(sz, buf, size);
    wsprintf(buf, "%02X", guid->Data4[2]);
    CatString(sz, buf, size);
    wsprintf(buf, "%02X", guid->Data4[3]);
    CatString(sz, buf, size);
    wsprintf(buf, "%02X", guid->Data4[4]);
    CatString(sz, buf, size);
    wsprintf(buf, "%02X", guid->Data4[5]);
    CatString(sz, buf, size);
    wsprintf(buf, "%02X", guid->Data4[6]);
    CatString(sz, buf, size);
    wsprintf(buf, "%02X", guid->Data4[7]);
    CatString(sz, buf, size);
}


void
CatStrOldGUID(
    IN OUT PSTR  sz,
    IN     GUID *guid,
    IN     DWORD size
    )
{
    CHAR buf[MAX_PATH + 256];
    BYTE byte;
    int i;

    assert(sz);

    if (!guid)
        return;

    // append the first DWORD in the pointer

    wsprintf(buf, "%8x", guid->Data1);
    CatString(sz, buf, size);

    // this will catch the passing of a PDWORD and avoid
    // all the GUID parsing

    if (!guid->Data2 && !guid->Data3) {
        for (i = 0, byte = 0; i < 8; i++) {
            byte |= guid->Data4[i];
            if (byte)
                break;
        }
        if (!byte)
            return;
    }

    // go ahead and add the rest of the GUID

    wsprintf(buf, "%4x", guid->Data2);
    CatString(sz, buf, size);
    wsprintf(buf, "%4x", guid->Data3);
    CatString(sz, buf, size);
    wsprintf(buf, "%2x", guid->Data4[0]);
    CatString(sz, buf, size);
    wsprintf(buf, "%2x", guid->Data4[1]);
    CatString(sz, buf, size);
    wsprintf(buf, "%2x", guid->Data4[2]);
    CatString(sz, buf, size);
    wsprintf(buf, "%2x", guid->Data4[3]);
    CatString(sz, buf, size);
    wsprintf(buf, "%2x", guid->Data4[4]);
    CatString(sz, buf, size);
    wsprintf(buf, "%2x", guid->Data4[5]);
    CatString(sz, buf, size);
    wsprintf(buf, "%2x", guid->Data4[6]);
    CatString(sz, buf, size);
    wsprintf(buf, "%2x", guid->Data4[7]);
    CatString(sz, buf, size);
}


void
CatStrID(
    IN OUT PSTR sz,
    PVOID id,
    DWORD paramtype,
    DWORD size
    )
{
    switch (paramtype)
    {
    case SSRVOPT_DWORD:
        CatStrDWORD(sz, PtrToUlong(id), size);
        break;
    case SSRVOPT_DWORDPTR:
        CatStrDWORD(sz, *(DWORD *)id, size);
        break;
    case SSRVOPT_GUIDPTR:
        CatStrGUID(sz, (GUID *)id, size);
        break;
    case SSRVOPT_OLDGUIDPTR:
        CatStrOldGUID(sz, (GUID *)id, size);
        break;
    default:
        break;
    }
}


// for Barb and Greg only.  I'm going to get rid of these...

void
AppendHexStringWithDWORD(
    IN OUT PSTR sz,
    IN DWORD value
    )
{
    return CatStrDWORD(sz, value, MAX_PATH);
}


void
AppendHexStringWithGUID(
    IN OUT PSTR sz,
    IN GUID *guid
    )
{
    return CatStrGUID(sz, guid, MAX_PATH);
}


void
AppendHexStringWithOldGUID(
    IN OUT PSTR sz,
    IN GUID *guid
    )
{
    return CatStrOldGUID(sz, guid, MAX_PATH);
}


void
AppendHexStringWithID(
    IN OUT PSTR sz,
    PVOID id,
    DWORD paramtype
    )
{
    return CatStrID(sz, id, paramtype, MAX_PATH);
}

/*
 * Given a string, find the next '*' and zero it
 * out to convert the current token into it's
 * own string.  Return the address of the next character,
 * if there are any more strings to parse.
 */


PSTR
ExtractToken(
    PSTR   in, 
    PSTR   out,
    size_t size
    )
{
    PSTR p = in;

    *out = 0;

    if (!in || !*in)
        return NULL;

    for (;*p; p++) {
        if (*p == '*') {
            *p = 0;
            p++;
            break;
        }
    }
    CopyString(out, in, size);

    return (*p) ? p : NULL;
}


BOOL
BuildRelativePath(
    OUT LPSTR rpath,
    IN  LPCSTR filename,
    IN  PVOID id,       // first number in directory name
    IN  DWORD val2,     // second number in directory name
    IN  DWORD val3,     // third number in directory name
    IN  DWORD size
    )
{
    LPSTR p;

    assert(rpath);

    CopyString(rpath, filename, size);
    EnsureTrailingBackslash(rpath);
    CatStrID(rpath, id, gptype, size);
    CatStrDWORD(rpath, val2, size);
    CatStrDWORD(rpath, val3, size);

    for (p = rpath + strlen(rpath) - 1; p > rpath; p--) {
        if (*p == '\\') {
            dprint("Insufficient information querying for %s\n", filename);
            SetLastError(ERROR_MORE_DATA);
            return false;
        }
        if (*p != '0')
            return true;
    }

    return true;
}


BOOL
SymbolServerClose()
{
    return true;
}


BOOL
TestParameters(
    IN  PCSTR params,   // server and cache path
    IN  PCSTR filename, // name of file to search for
    IN  PVOID id,       // first number in directory name
    IN  DWORD val2,     // second number in directory name
    IN  DWORD val3,     // third number in directory name
    OUT PSTR  path      // return validated file path here
    )
{
    __try {
        if (path)
            *path = 0;
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        return SetError(ERROR_INVALID_PARAMETER);
    }

    if (!path || !params || !*params || !filename || !*filename || (!id && !val2 && !val3))
        return SetError(ERROR_INVALID_PARAMETER);

    if (strlen(filename) > 100) {
        dprint("%s - filename cannot exceed 100 characters\n", filename);
        return SetError(ERROR_INVALID_PARAMETER);
    }

    switch (gptype)
    {
    case SSRVOPT_GUIDPTR:
    case SSRVOPT_OLDGUIDPTR:
        // this test should AV if a valid GUID pointer wasn't passed in
        __try {
            GUID *guid = (GUID *)id;
            BYTE b;
            b = guid->Data4[8];
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            return SetError(ERROR_INVALID_PARAMETER);
        }
        break;
    case SSRVOPT_DWORDPTR:
        // this test should AV if a valid DWORD pointer wasn't passed in
        __try {
            DWORD dword = *(DWORD *)id;
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            return SetError(ERROR_INVALID_PARAMETER);
        }
        break;
    }

    return true;
}


BOOL
SymbolServer(
    IN  PCSTR params,   // server and cache path
    IN  PCSTR filename, // name of file to search for
    IN  PVOID id,       // first number in directory name
    IN  DWORD val2,     // second number in directory name
    IN  DWORD val3,     // third number in directory name
    OUT PSTR  path      // return validated file path here
    )
{
    CHAR *p;
    CHAR  tdir[MAX_PATH + 1] = "";
    CHAR  sdir[MAX_PATH + 1] = "";
    CHAR  sz[MAX_PATH * 2 + 3];
    CHAR  rpath[MAX_PATH + 1];
    BOOL  rc;

    if (!TestParameters(params, filename, id, val2, val3, path))
        return false;

    // test environment

    if (gdbgout == -1) {
        if (GetEnvironmentVariable("SYMSRV_DBGOUT", sz, MAX_PATH))
            gdbgout = 1;
        else
            gdbgout = 0;
        *sz = 0;
    }

    // parse parameters

    CopyStrArray(sz, params);
    p = ExtractToken(sz, tdir, DIMA(tdir));  // 1st path is where the symbol should be
    p = ExtractToken(p, sdir, DIMA(sdir));   // 2nd optional path is the server to copy from

    // build the relative path to the target symbol file

    if (!BuildRelativePath(rpath, filename, id, val2, val3, DIMA(rpath)))
        return false;

    // if no_copy option is set, just return the path to the target

    if (goptions & SSRVOPT_NOCOPY) {
        pathcpy(path, tdir, rpath, MAX_PATH);
        pathcat(path, filename, MAX_PATH);
        return true;
    }

    // copy from server to specified symbol path

    rc = copy(tdir, sdir, rpath, filename, path, 0);
    if (!rc)
        *path = 0;

    return rc;
}

BOOL
SymbolServerSetOptions(
    UINT_PTR options,
    ULONG64  data
    )
{
    DWORD ptype;

    // set the callback function

    if (options & SSRVOPT_CALLBACK) {
        if (data) {
            goptions |= SSRVOPT_CALLBACK;
            gcallback = (PSYMBOLSERVERCALLBACKPROC)data;
        } else {
            goptions &= ~SSRVOPT_CALLBACK;
            gcallback = NULL;
        }
    }

    // set the callback context

    if (options & SSRVOPT_SETCONTEXT)
        gcontext = data;

    // when this flags is set, trace output will be delivered

    if (options & SSRVOPT_TRACE) {
        if (data) {
            goptions |= SSRVOPT_TRACE;
            setdprint(_dprint);
        } else {
            goptions &= ~SSRVOPT_TRACE;
            setdprint(NULL);
        }
    }

    // set the parameter type for the first ID parameter

    if (options & SSRVOPT_PARAMTYPE) {
        switch(data) {
        case SSRVOPT_DWORD:
        case SSRVOPT_DWORDPTR:
        case SSRVOPT_GUIDPTR:
        case SSRVOPT_OLDGUIDPTR:
            goptions &= ~(SSRVOPT_DWORD | SSRVOPT_DWORDPTR | SSRVOPT_GUIDPTR | SSRVOPT_OLDGUIDPTR);
            goptions |= data;
            gptype = (DWORD)data;
            break;
        default:
            SetLastError(ERROR_INVALID_PARAMETER);
            return false;
        }
    }

    // set the parameter type for the first ID paramter - OLD SYNTAX
    // the if statements provide and order of precedence

    ptype = 0;
    if (options & SSRVOPT_DWORD)
        ptype = SSRVOPT_DWORD;
    if (options & SSRVOPT_DWORDPTR)
        ptype = SSRVOPT_DWORDPTR;
    if (options & SSRVOPT_GUIDPTR)
        ptype = SSRVOPT_GUIDPTR;
    if (options & SSRVOPT_OLDGUIDPTR)
        ptype = SSRVOPT_OLDGUIDPTR;
    if (ptype) {
        goptions &= ~(SSRVOPT_DWORD | SSRVOPT_DWORDPTR | SSRVOPT_GUIDPTR | SSRVOPT_OLDGUIDPTR);
        if (data) {
            goptions |= ptype;
            gptype = ptype;
        } else if (gptype == ptype) {
            // when turning off a type, reset it to DWORD
            goptions |= SSRVOPT_DWORD;
            gptype = SSRVOPT_DWORD;
        }
    }

    // if this flag is set, no GUI will be displayed

    if (options & SSRVOPT_UNATTENDED) {
        if (data)
            goptions |= SSRVOPT_UNATTENDED;
        else
            goptions &= ~SSRVOPT_UNATTENDED;
    }

    // when this is set, the existence of the returned file path is not checked

    if (options & SSRVOPT_NOCOPY) {
        if (data)
            goptions |= SSRVOPT_NOCOPY;
        else
            goptions &= ~SSRVOPT_NOCOPY;
    }

    // this window handle is used as a parent for dialog boxes

    if (options & SSRVOPT_PARENTWIN) {
        SetParentWindow((HWND)data);
        if (data)
            goptions |= SSRVOPT_PARENTWIN;
        else
            goptions &= ~SSRVOPT_PARENTWIN;
    }

    // when running in secure mode, we don't copy files to downstream stores

    if (options & SSRVOPT_SECURE) {
        if (data)
            goptions |= SSRVOPT_SECURE;
        else
            goptions &= ~SSRVOPT_SECURE;
    }

    // set http proxy

    if (options & SSRVOPT_PROXY) {
        if (data) {
            goptions |= SSRVOPT_PROXY;
            CopyStrArray(gproxy, (char *)data);
            setproxy(gproxy);
        } else {
            goptions &= ~SSRVOPT_PROXY;
            *gproxy = 0;
            setproxy(NULL);
        }
    }

    // set default downstream store

    if (options & SSRVOPT_DOWNSTREAM_STORE) {
        if (data) {
            goptions |= SSRVOPT_DOWNSTREAM_STORE;
            CopyStrArray(gdstore, (char *)data);
            setdstore(gdstore);
        } else {
            goptions &= ~SSRVOPT_DOWNSTREAM_STORE;
            *gdstore = 0;
            setdstore(NULL);
        }
    }

    SetStoreOptions(goptions);

    return true;
}


UINT_PTR
SymbolServerGetOptions(
    )
{
    return goptions;
}


BOOL
SymbolServerPing(
    IN  PCSTR params   // server and cache path
    )
{
    CHAR *p;
    CHAR  sz[MAX_PATH * 2 + 3];
    CHAR  tdir[MAX_PATH + 1] = "";
    CHAR  sdir[MAX_PATH + 1] = "";
    CHAR  rpath[MAX_PATH + 1];
    CHAR  filename[MAX_PATH + 1];
    CHAR  path[MAX_PATH + 1];

    if (!params || !*params)
        return SetError(ERROR_INVALID_PARAMETER);

    // parse parameters

    // parse parameters

    CopyStrArray(sz, params);
    p = ExtractToken(sz, tdir, DIMA(tdir));  // 1st path is where the symbol should be
    p = ExtractToken(p, sdir, DIMA(sdir));   // 2nd optional path is the server to copy from

    // copy from server to specified symbol path

    return ping(tdir, sdir, rpath, filename, path, 0);

    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\symsrv\http.cpp ===
/*
 * http.cpp
 *
 * These routines are exported to privately support the
 * debugger's http source lookup cababilities.
 */

#include "pch.h"
#include "store.hpp"

BOOL
httpOpenFileHandle(
    IN  LPCSTR srv,
    IN  LPCSTR path,
    IN  DWORD  options,
    OUT HANDLE *hsite,
    OUT HANDLE *hfile
    )
{
    CHAR          file[MAX_PATH + 1];
    CHAR          srvsite[MAX_PATH + 1];
    CHAR          trgfile[MAX_PATH + 1];
    DWORD         type;
    StoreHTTP    *store;

    if (strstr(path, "dll.c"))
        dprint("%s\n", path);

    if (srv && *srv) {
        CopyStrArray(srvsite, srv);
        if (strstr(path, srvsite) == path)
            CopyStrArray(file, path + strlen(srvsite) + 1);
        else
            CopyStrArray(file, path);
        ConvertBackslashes(file);
        type = GetStoreType(srvsite);
    } else {
        type = ParsePath(path, srvsite, file, NULL, false);
    }
    if (type != stHTTP && type != stHTTPS) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return false;
    }

    store = (StoreHTTP *)FindStore(srvsite);
    if (!store) {
        store = (StoreHTTP *)AddStore(srvsite);
        if (!store)
            return false;
    }

    if (!store->init())
        return false;

    if (!store->open(NULL, file))
        return false;

    *hsite = store->hsite();
    *hfile = store->hfile();

    return true;
}


BOOL
httpQueryDataAvailable(
    IN HINTERNET hFile,
    OUT LPDWORD lpdwNumberOfBytesAvailable OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )
{
    return InternetQueryDataAvailable(hFile, lpdwNumberOfBytesAvailable, dwFlags, dwContext);
}



BOOL
httpReadFile(
    IN HINTERNET hFile,
    IN LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpdwNumberOfBytesRead
    )
{
    return InternetReadFile(hFile, lpBuffer, dwNumberOfBytesToRead, lpdwNumberOfBytesRead);
}


BOOL
httpCloseHandle(
    IN HINTERNET hInternet
    )
{
    return InternetCloseHandle(hInternet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\symsrv\store.cpp ===
/*
 * store.cpp
 */

#define STORE_DOT_CPP

#include "pch.h"
#include "store.hpp"

#define MAX_STORES          50

#define CHUNK_SIZE			4096L

static SRVTYPEINFO gtypeinfo[stError] =
{
    {"http://",  0, 7}, // inetCopy, 7},
    {"https://", 0, 8}, // inetCopy, 8},
    {"",         0, 0}  // fileCopy, 0}
};

static HINTERNET ghint = INVALID_HANDLE_VALUE;
static HWND      ghwnd = 0;
static UINT_PTR  gopts;
static char     *gproxy = NULL;
static char     *gdstore = NULL;
static BOOL      gcancel = false;

void disperror(
    DWORD err,
    char *file
    )
{
    if (!err || err == ERROR_REQUEST_ABORTED)
        return;

    if (err == ERROR_FILE_NOT_FOUND)
        dprint("%s - file not found\n", file);
    else
        dprint("%s\n         %s\n", file, FormatStatus(err));
}


void
dumpproxyinfo(
    VOID
    )
{
    HINTERNET hint;
    INTERNET_PROXY_INFO *pi;
    DWORD size;
    BOOL rc;
    DWORD err;

    hint = (gproxy) ? ghint : NULL;

    size = 0;
    rc = InternetQueryOption(hint, INTERNET_OPTION_PROXY, NULL, &size);
    if (rc) {
        SetLastError(ERROR_INVALID_DATA);
        return;
    }
    if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
        return;

    pi = (INTERNET_PROXY_INFO *)LocalAlloc(LPTR, size);
    if (!pi)
        return;
    ZeroMemory(pi, size);
    rc = InternetQueryOption(hint, INTERNET_OPTION_PROXY, pi, &size);
    if (rc && pi->lpszProxy && *pi->lpszProxy)
        dprint("Using proxy server: %s\n", pi->lpszProxy);
    
    if (pi) 
        LocalFree(pi);
}


DWORD
fixerror(
    DWORD err
    )
{
    if (err == ERROR_PATH_NOT_FOUND)
        return ERROR_FILE_NOT_FOUND;

    return err;
}

void
setdprint(
    DBGPRINT fndprint
    )
{
    gdprint = fndprint;
}


void
setproxy(
    char *proxy
    )
{
    gproxy = proxy;
}


void
setdstore(
    char *dstore
    )
{
    gdstore = dstore;
}


void
SetParentWindow(
    HWND hwnd
    )
{
    ghwnd = hwnd;
}


void
SetStoreOptions(
    UINT_PTR opts
    )
{
    gopts = opts;
}


DWORD
GetStoreType(
    LPCSTR sz
    )
{
    DWORD i;

    for (i = 0; i < stError; i++) {
        if (!_strnicmp(sz, gtypeinfo[i].tag, gtypeinfo[i].taglen)) {
            return i;
        }
    }

    return stError;
}


BOOL
ParsePath(
    IN  LPCSTR ipath,
    OUT LPSTR  site,
    OUT LPSTR  path,
    OUT LPSTR  file,
    IN  BOOL   striptype
    )
{
    char  sz[_MAX_PATH + 1];
    char *c;
    char *p;
    DWORD type;

    assert(ipath && site && path);

    *site = 0;
    *path = 0;
    if (file)
        *file = 0;

    if (!CopyString(sz, ipath, _MAX_PATH))
        return false;
    ConvertBackslashes(sz);

    // get start of site string

    type = GetStoreType(sz);
    p = sz + gtypeinfo[type].taglen;

    // there has to be at least a site

    c = strchr(p, '/');
    if (!c) {
        strcpy(site, p);    // SECURITy: ParsePath is a safe function.
        return true;
    }

    // copy site name

    *c = 0;
    strcpy(site, (striptype) ? p : sz); // SECURITy: ParsePath is a safe function.
    p = c + 1;

    // if no file parameter, include the file in the path parameter

    if (!file) {
        strcpy(path, p);    // SECURITy: ParsePath is a safe function.
        return true;
    }

    // look for path in the middle

    for (c = p + strlen(p); p < c; c--) {
        if (*c == '/') {
            *c = 0;
            strcpy(path, p);    // SECURITy: ParsePath is a safe function.
            p = c + 1;
            break;
        }
    }
    strcpy(file, p);        // SECURITy: ParsePath is a safe function.

    return true;
}


static char
ChangeLastChar(
    LPSTR sz,
    char  newchar
    )
{
    char c;
    DWORD len;

    len = strlen(sz) - 1;
    c = sz[len];
    sz[len] = newchar;

    return c;
}


static BOOL
ReplaceFileName(
    LPSTR  path,
    LPCSTR file,
    DWORD  size
    )
{
    char *p;

    assert(path && *path && file && *file);

    for (p = path + strlen(path) - 1; *p; p--) {
        if (*p == '\\' || *p == '/') {
            CopyString(++p, file, size - (ULONG)(ULONG_PTR)(p - path));
            return true;
        }
    }

    return false;
}


DWORD CALLBACK cbCopyProgress(
    LARGE_INTEGER TotalFileSize,          // file size
    LARGE_INTEGER TotalBytesTransferred,  // bytes transferred
    LARGE_INTEGER StreamSize,             // bytes in stream
    LARGE_INTEGER StreamBytesTransferred, // bytes transferred for stream
    DWORD dwStreamNumber,                 // current stream
    DWORD dwCallbackReason,               // callback reason
    HANDLE hSourceFile,                   // handle to source file
    HANDLE hDestinationFile,              // handle to destination file
    LPVOID lpData                         // from CopyFileEx
)
{
    Store *store = (Store *)lpData;

    store->setsize(TotalFileSize.QuadPart);
    store->setbytes(TotalBytesTransferred.QuadPart);
    store->progress();
    
    if (querycancel()) {
        store->setbytes((LONGLONG)-1);
        store->progress();
        return PROGRESS_CANCEL;
    }
    
    return PROGRESS_CONTINUE;
}

BOOL
ReadFilePtr(
    LPSTR path,
    DWORD size
    )
{
    BOOL   rc;
    HANDLE hptr;
    DWORD  fsize;
    DWORD  cb;
    LPSTR  p;
    char   ptrfile[MAX_PATH + 1];
    char   file[MAX_PATH + 1];

    assert(path && *path);

    rc = false;

    // check for existance of file pointer

    if (!CopyString(ptrfile, path, _MAX_PATH))
        return false;
    if (!ReplaceFileName(ptrfile, "file.ptr", DIMA(ptrfile)))
        return false;

    if (FileStatus(ptrfile))
        return false;

    hptr = CreateFile(ptrfile,
                      GENERIC_READ,
                      FILE_SHARE_READ,
                      NULL,
                      OPEN_EXISTING,
                      FILE_ATTRIBUTE_NORMAL,
                      NULL);

    if (hptr == INVALID_HANDLE_VALUE)
        return false;

    // test validity of file pointer

    fsize = GetFileSize(hptr, NULL);
    if (!fsize || fsize > MAX_PATH)
        goto cleanup;

    // read it

    ZeroMemory(file, _MAX_PATH * sizeof(path[0]));
    if (!ReadFile(hptr, file, fsize, &cb, 0))
        goto cleanup;

    if (cb != fsize)
        goto cleanup;

    rc = true;

    // trim string down to the CR

    for (p = file; *p; p++) {
        if (*p == 10  || *p == 13)
        {
            *p = 0;
            break;
        }
    }
    CopyString(path, file, size);
    dprint("%s\n", ptrfile);

cleanup:

    // done

    if (hptr)
        CloseHandle(hptr);

    return rc;
}


#ifdef USE_INERROR
DWORD inerror(DWORD error)
{
    char  *detail = NULL;
    DWORD  iErr;
    DWORD  len = 0;
    static char message[256]="";

    if (error == ERROR_SUCCESS)
        return error;

    FormatMessage(FORMAT_MESSAGE_FROM_HMODULE,
                  GetModuleHandle("wininet.dll"),
                  error,
                  0,
                  message,
                  256,
                  NULL);
    EnsureTrailingCR(message);
    dprint("Internet error code: %d\n         Message: %s\n", error, message);

    if (error != ERROR_INTERNET_EXTENDED_ERROR)
        return error;

    InternetGetLastResponseInfo(&iErr, NULL, &len);
    if (!len)
        return error;

    detail = (char *)LocalAlloc(LPTR, len + 1000);
    if (!detail)
        return error;

    if (!InternetGetLastResponseInfo(&iErr, (LPTSTR)detail, &len))
        return error;

    dprint(detail);
    LocalFree(detail);

    return error;
}
#endif

Store *gstores[MAX_STORES];
DWORD  gcstores = 0;

Store *
FindStore(
    PCSTR name
    )
{
    DWORD i;

    for (i = 0; i < gcstores; i++) {
        if (gstores[i] && !strcmp((gstores[i])->name(), name))
            return gstores[i];
    }

    return NULL;
}


Store *
AddStore(
    PCSTR name
    )
{
    DWORD   type;
    Store  *store;

    type = GetStoreType(name);
    switch (type) {
    case stUNC:
        store = new StoreUNC();
        break;
    case stHTTP:
    case stHTTPS:
        store = new StoreHTTP();
        break;
    case stError:
    default:
        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }

    if (!store) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return NULL;
    }

    store->assign(name);

    if (gcstores >= MAX_STORES) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return false;
    }

    if (!gcstores)
        ZeroMemory(gstores, sizeof(gstores));

    gstores[gcstores] = store;
    gcstores++;

    return store;
}


Store *
GetStore(
    PCSTR name
    )
{
    Store *store;

    store = FindStore(name);
    if (!store)
        store = AddStore(name);

    return store;
}



BOOL
DeleteStore(
    Store *store
    )
{
    DWORD   i;

    for (i = 0; i < gcstores; i++) {
        if (gstores[i] == store) {
            gstores[i] = NULL;
            delete store;
            return true;
        }
    }

    return false;
}




DWORD Store::assign(PCSTR name)
{
    CopyStrArray(m_name, name);
    m_type = GetStoreType(name);
    m_flags = 0;

    return m_type;
}


char *Store::target()
{
    return m_tpath;
}


BOOL Store::init()
{
    if (m_flags & SF_DISABLED)
        return false;

    *m_tpath = 0;

    return true;
}


BOOL Store::ping()
{
    return false;
}


BOOL Store::open(PCSTR rpath, PCSTR file)
{
    CopyStrArray(m_rpath, rpath ? rpath : "");
    CopyStrArray(m_file, file ? file : "");

    return true;
}


VOID Store::close()
{
    return;
}


BOOL Store::get(PCSTR trg)
{
    pathcpy(m_tpath, trg, m_rpath, DIMA(m_tpath));
    pathcat(m_tpath, m_file, DIMA(m_tpath));
    EnsurePathExists(m_tpath, m_epath, DIMA(m_epath));

    return true;
}

BOOL Store::copy(PCSTR rpath, PCSTR file, PCSTR trg)
{
    if (m_flags & SF_DISABLED)
        return false;

    return true;
}


BOOL Store::progress()
{
    SYSTEMTIME st;

    if (!*m_file)
        return true;

    // Do not condense these print statements into single lines.
    // They are split up to work with dbghelp's backspace filtering.

    switch (m_bytes) 
    {
    case (LONGLONG)-1:
        eprint("\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b");
        eprint("cancelled      \n");
        SetLastError(ERROR_REQUEST_ABORTED);
        break;
    case 0:
        dprint("%s from %s: %ld bytes -  ", m_file, m_name, m_size);
        eprint("\b%12ld ", 0);
        break;
    default:
        GetSystemTime(&st);
        if (st.wSecond != m_tic)
            eprint("\b\b\b\b\b\b\b\b\b\b\b\b%12ld", m_bytes);   
        m_tic = st.wSecond;
        break;
    }
    
    if (m_bytes && (m_bytes == m_size)) {
        eprint("\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b");
        eprint("copied         \n");
    }

    return true;
}


void Store::setsize(LONGLONG size)
{
    m_size = size;
}


void Store::setbytes(LONGLONG bytes)
{
    m_bytes = bytes;
}


BOOL StoreUNC::get(PCSTR trg)
{
    BOOL  rc;
    DWORD err;
    char  c;

    pathcpy(m_spath, m_name, m_rpath, DIMA(m_spath));
    pathcat(m_spath, m_file, DIMA(m_spath));

    Store::get(trg);

    do {
        // try to copy the file, first

        if (gdprint)
            rc = CopyFileEx(m_spath, m_tpath, cbCopyProgress, this, &gcancel, COPY_FILE_FAIL_IF_EXISTS);
        else
            rc = CopyFile(m_spath, m_tpath, true);
        if (rc) 
            return true;

        err = GetLastError();
        err = fixerror(err);
        if (err != ERROR_FILE_NOT_FOUND) {
            disperror(err, m_spath);
            return false;
        }

        // now try to uncompress the file

        c = ChangeLastChar(m_spath, '_');
        if (!FileStatus(m_spath)) {
            rc = UncompressFile(m_spath, m_tpath);
            if (!rc)
                disperror(GetLastError(), m_spath);
            return rc;
        }
        ChangeLastChar(m_spath, c);

        // try to read from a file pointer

    } while (ReadFilePtr(m_spath, DIMA(m_spath)));

    err = GetLastError();
    err = fixerror(err);
    disperror(err, m_spath);

    return false;
}


BOOL StoreUNC::copy(PCSTR rpath, PCSTR file, PCSTR trg)
{
    if (!Store::copy(rpath, file, trg))
        return false;

    if (!open(rpath, file))
        return false;

    return get(trg);
}


BOOL StoreUNC::ping()
{
    BOOL rc;

    CopyStrArray(m_spath, m_name);
    EnsureTrailingBackslash(m_spath);
    CatStrArray(m_spath, "pingme.txt");
    rc = (GetFileAttributes(m_spath) == 0xFFFFFFFF);
    if (!rc)
        m_flags |= SF_DISABLED;

    return rc;
}


BOOL StoreInet::init()
{
    char  sz[_MAX_PATH];
    static char uasz[_MAX_PATH] = "";

    // internet handle is null, then we know from previous
    // attempts that it can't be opened, so bail

    if (!ghint)
        return false;

    if (!*uasz) {
        CopyStrArray(uasz, "Microsoft-Symbol-Server/");
        CatStrArray(uasz, VER_PRODUCTVERSION_STR);
    }

    *m_spath  = 0;
    *m_rpath  = 0;
    *m_file   = 0;
    ParsePath(m_name, m_site, sz, NULL, true);
    CopyStrArray(m_srpath, "/");
    CatStrArray(m_srpath, sz);

    if (ghint == INVALID_HANDLE_VALUE) {
        ghint = InternetOpen(uasz,
                             (gproxy) ? INTERNET_OPEN_TYPE_PROXY : INTERNET_OPEN_TYPE_PRECONFIG,
                             gproxy,
                             NULL,
                             0);
        if (!ghint)
            return false;
        
        dumpproxyinfo();
    }

    if (m_hsite)
        return true;

    m_hsite = InternetConnect(ghint,
                              m_site,
                              m_port,
                              NULL,
                              NULL,
                              m_service,
                              0,
                              NULL);//m_context ? (DWORD_PTR)&m_context : NULL);
    if (!m_hsite)
        return false;

    return true;
}


BOOL StoreInet::open(PCSTR rpath, PCSTR file)
{
    Store::open(rpath, file);

    CopyStrArray(m_spath, m_srpath);
    pathcat(m_spath, m_rpath, DIMA(m_spath));

    return true;
}


BOOL StoreInet::copy(PCSTR rpath, PCSTR file, PCSTR trg)
{
    BOOL rc;
    DWORD err;
    char cfile[MAX_PATH + 1];
    char c;

    if (!Store::copy(rpath, file, trg))
        return false;

    if (m_flags & SF_INTERNET_DISABLED)
        return false;

    // open and copy the file

    if (open(rpath, file)) {
        rc = get(trg);
        close();
        return rc;
    }

    // if file wasn't found, look for a compressed version

    err = GetLastError();
    if (err != ERROR_FILE_NOT_FOUND)
        return false;

    CopyStrArray(cfile, file);
    c = ChangeLastChar(cfile, '_');

    if (!open(rpath, cfile)) {
        dprint("%s%s%s not found\n", gtypeinfo[m_type].tag, m_site, m_spath);
        return false;
    }

    rc = get(trg);
    close();
    if (!rc)
        return false;

    // if we found a compressed version, expand it

    CopyStrArray(cfile, m_tpath);
    ChangeLastChar(m_tpath, c);
    rc = UncompressFile(cfile, m_tpath);
    DeleteFile(cfile);
    if (!rc)
        DeleteFile(m_tpath);

    return rc;
}


BOOL StoreInet::ping()
{
    return open("", "pingme.txt");
}


BOOL StoreHTTP::init()
{
    BOOL          rc;

    m_iflags = INTERNET_FLAG_RELOAD | INTERNET_FLAG_DONT_CACHE | INTERNET_FLAG_KEEP_CONNECTION;
    m_service = INTERNET_SERVICE_HTTP;
    m_context = 0;
    if (m_type == stHTTPS) {
        m_port = INTERNET_DEFAULT_HTTPS_PORT;
        m_iflags |= INTERNET_FLAG_SECURE;
    } else {
        m_port  = INTERNET_DEFAULT_HTTP_PORT;
    }
    *m_srpath = 0;

    return StoreInet::init();
}


BOOL StoreHTTP::open(PCSTR rpath, PCSTR file)
{
    DWORD err = ERROR_NOT_FOUND;

    Store::open(rpath, file);

    CopyStrArray(m_spath, m_srpath);
    pathcat(m_spath, m_rpath, DIMA(m_spath));
    pathcat(m_spath, m_file, DIMA(m_spath));
    ConvertBackslashes(m_spath);

    close();
    m_hfile = HttpOpenRequest(m_hsite,
                              "GET",
                              m_spath,
                              HTTP_VERSION,
                              NULL,
                              NULL,
                              m_iflags,
                              0);
    if (!m_hfile)
        goto error;

    err = fileinfo();
    if (!err)
        return true;

error:
    close();
    SetLastError(err);
    return false;
}


VOID StoreHTTP::close()
{
    DWORD err;

    if (!m_hfile)
        return;

    // InternetCloseHandle resets last error to zero.
    // Preserve it and restore it afterwards.

    err = GetLastError();
    InternetCloseHandle(m_hfile);
    if (err)
        SetLastError(err);
    m_hfile = 0;
}


DWORD StoreHTTP::fileinfo()
{
    BOOL  rc;
    DWORD err;
    DWORD status;
    DWORD cbstatus;
    DWORD index;
    DWORD cbsize;

#ifdef PROXYTEST
    dprint("FILE %s\n", m_spath);
#endif

    do {
        err = request();
        if (err != ERROR_SUCCESS) 
            return err;
        
        index = 0;
        m_size = 0;
        cbsize = sizeof(m_size);
        rc = HttpQueryInfo(m_hfile,
                           HTTP_QUERY_CONTENT_LENGTH | HTTP_QUERY_FLAG_NUMBER,
                           &m_size,
                           &cbsize,
                           &index);
        if (!rc) {
            if (GetLastError())
                return err;
            return ERROR_INTERNET_EXTENDED_ERROR;
        }

        index = 0;
        cbstatus = sizeof(status);
        rc = HttpQueryInfo(m_hfile,
                           HTTP_QUERY_STATUS_CODE | HTTP_QUERY_FLAG_NUMBER,
                           &status,
                           &cbstatus,
                           &index);
        if (!rc) {
            if (GetLastError())
                return err;
            return ERROR_INTERNET_EXTENDED_ERROR;
        }

        switch (status)
        {
        case HTTP_STATUS_DENIED:    // need a valid login?
//          dprint("status HTTP_STATUS_DENIED\n");
            err = prompt(m_hfile, ERROR_INTERNET_INCORRECT_PASSWORD);
            // user entered a password - try again
            if (err == ERROR_INTERNET_FORCE_RETRY)
                break;
            // user cancelled
            m_flags |= SF_DISABLED;
            return ERROR_NOT_READY;

        case HTTP_STATUS_PROXY_AUTH_REQ:
//          dprint("status HTTP_STATUS_PROXY_AUTH_REQ\n");
            err = prompt(m_hfile, err);
            // user entered a password - try again
            if (err == ERROR_INTERNET_FORCE_RETRY)
                break;
            // user cancelled
            m_flags |= SF_INTERNET_DISABLED;
            return ERROR_NOT_READY;

        case HTTP_STATUS_FORBIDDEN:
//          dprint("status HTTP_STATUS_FORBIDDEN\n");
            m_flags |= SF_DISABLED;
            return ERROR_ACCESS_DENIED;

        case HTTP_STATUS_NOT_FOUND:
//          dprint("status HTTP_STATUS_NOT_FOUND\n");
            return ERROR_FILE_NOT_FOUND;

        case HTTP_STATUS_OK:
//         dprint("status HTTP_STATUS_OK\n");
           return ERROR_SUCCESS;
        }
    } while (err == ERROR_INTERNET_FORCE_RETRY);

    return ERROR_INTERNET_EXTENDED_ERROR;
}


DWORD StoreHTTP::request()
{
    DWORD err = ERROR_SUCCESS;

    while (!HttpSendRequest(m_hfile, NULL, 0, NULL, 0))
    {
        err = GetLastError();
        switch (err)
        {
        // These cases get input from the user in oder to try again.
        case ERROR_INTERNET_INCORRECT_PASSWORD:
        case ERROR_INTERNET_CLIENT_AUTH_CERT_NEEDED:
            err = prompt(m_hfile, err);
            if (err != ERROR_SUCCESS && err != ERROR_INTERNET_FORCE_RETRY)
            {
                err = ERROR_ACCESS_DENIED;
                return err;
            }
            break;

        // These cases get input from the user in order to try again.
        // However, if the user bails, don't use this internet
        // connection again in this session.
        case ERROR_INTERNET_INVALID_CA:
        case ERROR_INTERNET_SEC_CERT_DATE_INVALID:
        case ERROR_INTERNET_SEC_CERT_CN_INVALID:
        case ERROR_INTERNET_POST_IS_NON_SECURE:
            err = prompt(m_hfile, err);
            if (err != ERROR_SUCCESS && err != ERROR_INTERNET_FORCE_RETRY)
            {
                m_flags |= SF_DISABLED;
                err = ERROR_NOT_READY;
                return err;
            }
            break;

        // no go - give up the channel
        case ERROR_INTERNET_SECURITY_CHANNEL_ERROR:
            m_flags |= SF_DISABLED;
            err = ERROR_NOT_READY;
            return err;

        // Tell the user something went wrong and get out of here.
        case ERROR_INTERNET_HTTP_TO_HTTPS_ON_REDIR:
        default:
            prompt(m_hfile, err);
            return err;
        }
    }

    return err;
}


DWORD StoreHTTP::prompt(HINTERNET hreq, DWORD err)
{
    if (gopts & SSRVOPT_UNATTENDED)
        return err;

    if (!ghwnd)
        ghwnd = GetDesktopWindow();
    if (!ghwnd)
        return err;

    err = InternetErrorDlg(ghwnd,
                           hreq,
                           err,
                           FLAGS_ERROR_UI_FILTER_FOR_ERRORS       |
                           FLAGS_ERROR_UI_FLAGS_GENERATE_DATA     |
                           FLAGS_ERROR_UI_FLAGS_CHANGE_OPTIONS,
                           NULL);
    return err;
}


BOOL StoreHTTP::get(PCSTR trg)
{
    DWORD         read;
    DWORD         written;
    DWORD         err = 0;
    BYTE         *buf;
    BOOL          rc = false;
    HANDLE        hf = INVALID_HANDLE_VALUE;
    ULONG64       copied;

    buf = (BYTE *)LocalAlloc(LPTR, CHUNK_SIZE);
    if (!buf) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return false;
    }

    Store::get(trg);

    hf = CreateFile(m_tpath,
                    GENERIC_WRITE,
                    0,
                    NULL,
                    CREATE_ALWAYS,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL);

    if (hf == INVALID_HANDLE_VALUE)
        goto cleanup;

    m_bytes = 0;
    do
    {
        if (!progress()) 
            goto cleanup;

        rc = InternetReadFile(m_hfile,
                              (LPVOID)buf,
                              CHUNK_SIZE,
                              &read);
        if (!rc || !read)
            break;
        rc = WriteFile(hf, (LPVOID)buf, read, &written, NULL);
        m_bytes += written;
    }
    while (rc);

cleanup:

    // if there was an error, save it and set it later

    if (!err)
        err = GetLastError();
     
    disperror(err || GetLastError(), m_spath);
    
    // If target file is open, close it.

    if (hf != INVALID_HANDLE_VALUE)
        CloseHandle(hf);

    // free the memory

    LocalFree(buf);

    SetLastError(err);

    return err ? false : true;
}

BOOL StoreHTTP::progress()
{
    Store::progress();
    
    if (!m_bytes || !querycancel())
        return true;

     setbytes((LONGLONG)-1);
     Store::progress();
     return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\symsrv\store.hpp ===
/*
 * store.hpp
 */

enum {
    stHTTP = 0,
    stHTTPS,
    stUNC,
    stError
};

typedef BOOL (*COPYPROC)(DWORD, LPCSTR, LPCSTR, DWORD);

typedef struct _SRVTYPEINFO {
    LPCSTR   tag;
    COPYPROC copyproc;
    int      taglen;
} SRVTYPEINFO, *PSRVTYPEINFO;

#define SF_DISABLED             0X1
#define SF_INTERNET_DISABLED    0x2


typedef int (*DBGPRINT)(LPSTR, ...);
extern DBGPRINT  gdprint;
#define dprint (gdprint)&&gdprint

typedef int (*DBGEPRINT)(LPSTR, ...);
extern DBGEPRINT  geprint;
#define eprint (geprint)&&geprint

typedef int (*QUERYCANCEL)();
extern QUERYCANCEL gquerycancel;
__inline BOOL querycancel()
{
    if (!gquerycancel)
        return false;
    return gquerycancel();
}


class Store
{
public:
    Store()
    {
        *m_name = 0;
        m_type  = 0;
        m_flags = 0;
    }
      
    DWORD  assign(PCSTR name);
    char  *target();
    void   setsize(LONGLONG size);
    void   setbytes(LONGLONG bytes);

    virtual BOOL init();
    virtual BOOL open(PCSTR rpath, PCSTR file);
    virtual BOOL get(PCSTR trg);
    virtual VOID close();
    virtual BOOL copy(PCSTR rpath, PCSTR file, PCSTR trg);
    virtual BOOL ping();
    virtual BOOL progress();

protected:
    DWORD     m_type;                  // type of site
    char      m_name[MAX_PATH + 1];    // name of site
    DWORD     m_flags;                 // options
    char      m_rpath[MAX_PATH + 1];   // relative path from node
    char      m_file[MAX_PATH + 1];    // name of file
    char      m_spath[MAX_PATH + 1];   // source file path
    char      m_tpath[MAX_PATH + 1];   // fully qualified target file path
    char      m_epath[MAX_PATH + 1];   // save last existing node of a path being created
    LONGLONG  m_size;                  // size of file
    LONGLONG  m_bytes;                 // amount of bytes copied
    DWORD     m_tic;                   // last tic count for timing counters

public:
    char *name() {return m_name;}
};


class StoreUNC : public Store
{
public:
    virtual BOOL init() {return true;}
    virtual BOOL get(PCSTR trg);
    virtual BOOL copy(PCSTR rpath, PCSTR file, PCSTR trg);
    virtual BOOL ping();
};


class StoreInet : public Store
{
public:
    StoreInet()
    {
        *m_name = 0;
        m_type  = 0;
        m_flags = 0;
        m_hsite = 0;
    }

    ~StoreInet()
    {
        if (m_hsite)
            InternetCloseHandle(m_hsite);
    }

    virtual BOOL init();
    virtual BOOL open(PCSTR rpath, PCSTR file);
    virtual BOOL copy(PCSTR rpath, PCSTR file, PCSTR trg);
    virtual BOOL ping();

protected:
    HINTERNET     m_hsite;
    INTERNET_PORT m_port;
    DWORD         m_iflags;
    DWORD         m_service;
    DWORD         m_context;
    char          m_site[MAX_PATH + 1];
    char          m_srpath[MAX_PATH + 1];
};


class StoreHTTP : public StoreInet
{
public:
    ~StoreHTTP()
    {
        if (m_file)
            InternetCloseHandle(m_hfile);
        if (m_hsite)
            InternetCloseHandle(m_hsite);
    }

    virtual BOOL init();
    virtual BOOL open(PCSTR rpath, PCSTR file);
    virtual VOID close();
    virtual BOOL get(PCSTR trg);
    virtual BOOL progress();
    HINTERNET    hsite() {return m_hsite;}
    HINTERNET    hfile() {return m_hfile;}

protected:
    HINTERNET m_hfile;
    DWORD request();
    DWORD prompt(HINTERNET hreq, DWORD err);
    DWORD fileinfo();
};


// these manage the list of store objects

Store *GetStore(PCSTR name);
Store *FindStore(PCSTR name);
Store *AddStore(PCSTR name);

// utility functions

#ifdef __cplusplus
 extern "C" {
#endif

void SetParentWindow(HWND hwnd);
void setproxy(char *proxy);
void setdstore(char *proxy);
void SetStoreOptions(UINT_PTR opts);
void setdprint(DBGPRINT fndprint);
DWORD GetStoreType(LPCSTR sz);
BOOL ReadFilePtr(LPSTR path, DWORD size);
BOOL UncompressFile(LPCSTR Source, LPCSTR Target);

BOOL  ParsePath(LPCSTR ipath, LPSTR  site, LPSTR  path, LPSTR  file, BOOL striptype);

#ifdef __cplusplus
 };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\symsrv\dload.cpp ===
/*
 * dload.cpp
 */

#include "pch.h"
#include <delayimp.h>

#define FreeLib(hDll)   \
    {if (hDll && hDll != INVALID_HANDLE_VALUE) FreeLibrary(hDll);}

typedef struct
{
    PCHAR Name;
    FARPROC Function;
} FUNCPTRS;

#if DBG
void
OutputDBString(
    CHAR *text
    );
#endif

extern int __dprint(LPSTR sz);

extern HINSTANCE ghSymSrv;

// from lz32.dll

LONG fail_LZCopy(
    INT hfSource,  
    INT hfDest     
)
{ 
    SetLastError(ERROR_MOD_NOT_FOUND);
    __dprint("LZCopy() not found in module LZ32.DLL\n");
    return false;
}

VOID fail_LZClose(
    INT hFile
)
{ 
    SetLastError(ERROR_MOD_NOT_FOUND);
    __dprint("LZClose() not found in module LZ32.DLL\n");
}

INT fail_LZOpenFileA(
    LPTSTR lpFileName,      
    LPOFSTRUCT lpReOpenBuf, 
    WORD wStyle             
)
{ 
    SetLastError(ERROR_MOD_NOT_FOUND);
    __dprint("LZOpenFileA() not found in module LZ32.DLL\n");
    return false;
}

// from wininet.dll

BOOL fail_HttpSendRequestA(
    HINTERNET hRequest,
    LPCTSTR lpszHeaders,
    DWORD dwHeadersLength,
    LPVOID lpOptional,
    DWORD dwOptionalLength
    )
{
    SetLastError(ERROR_MOD_NOT_FOUND);
    __dprint("HttpSEndRequestA() not found in module WININET.DLL\n");
    return 0;
}

BOOL fail_HttpQueryInfoA(
    HINTERNET hRequest, 
    DWORD dwInfoLevel, 
    LPVOID lpBuffer, 
    LPDWORD lpdwBufferLength, 
    LPDWORD lpdwIndex
    )
{ 
    SetLastError(ERROR_MOD_NOT_FOUND);
    __dprint("HttpQueryInfoA() not found in module WININET.DLL\n");
    return false;
}

BOOL fail_InternetReadFile(
    IN HINTERNET hFile, 
    IN LPVOID lpBuffer, 
    IN DWORD dwNumberOfBytesToRead, 
    OUT LPDWORD lpdwNumberOfBytesRead
    )
{
    SetLastError(ERROR_MOD_NOT_FOUND);
    __dprint("InternetReadFile() not found in module WININET.DLL\n");
    return ERROR_MOD_NOT_FOUND;
}

BOOL fail_InternetQueryDataAvailable(
    HINTERNET hFile,  
    LPDWORD lpdwNumberOfBytesAvailable, 
    DWORD dwFlags, 
    DWORD dwContext
    )
{
    SetLastError(ERROR_MOD_NOT_FOUND);
    __dprint("InternetQueryDataAvailable() not found in module WININET.DLL\n");
    return ERROR_MOD_NOT_FOUND;
}

HINTERNET fail_HttpOpenRequestA(
    HINTERNET hConnect, 
    LPCTSTR lpszVerb,  
    LPCTSTR lpszObjectName, 
    LPCTSTR lpszVersion, 
    LPCTSTR lpszReferrer, 
    LPCTSTR *lplpszAcceptTypes, 
    DWORD dwFlags, 
    DWORD dwContext 
    )
{ 
    SetLastError(ERROR_MOD_NOT_FOUND);
    __dprint("HttpOpenRequestA() not found in module WININET.DLL\n");
    return false;
}

BOOL fail_FtpGetFileA(
    HINTERNET hConnect, 
    LPCTSTR lpszRemoteFile, 
    LPCTSTR lpszNewFile, 
    BOOL fFailIfExists, 
    DWORD dwFlagsAndAttributes, 
    DWORD dwFlags, 
    DWORD dwContext
    )
{ 
    SetLastError(ERROR_MOD_NOT_FOUND);
    __dprint("FtpGEtFileA() not found in module WININET.DLL\n");
    return false;
}

BOOL fail_FtpSetCurrentDirectoryA(
    HINTERNET hConnect, 
    LPCTSTR lpszDirectory
    )
{ 
    SetLastError(ERROR_MOD_NOT_FOUND);
    __dprint("FtpSetCurrentDirectoryA() not found in module WININET.DLL\n");
    return false;
}

BOOL fail_FtpFindFirstFileA(
    HINTERNET hConnect, 
    LPCTSTR lpszSearchFile, 
    LPWIN32_FIND_DATA lpFindFileData , 
    DWORD dwFlags, 
    DWORD dwContext
    )
{
    SetLastError(ERROR_MOD_NOT_FOUND);
    __dprint("FtpFindFirstFileA() not found in module WININET.DLL\n");
    return ERROR_MOD_NOT_FOUND;
}

BOOL fail_InternetCloseHandle(
    IN HINTERNET hInternet
    )
{
    SetLastError(ERROR_MOD_NOT_FOUND);
    __dprint("InternetCloseHandle() not found in module WININET.DLL\n");
    return false;
}

HINTERNET fail_InternetOpenA(
    IN LPCTSTR lpszAgent,
    IN DWORD dwAccessType,
    IN LPCTSTR lpszProxyName,
    IN LPCTSTR lpszProxyBypass,
    IN DWORD dwFlags
    )
{
    SetLastError(ERROR_MOD_NOT_FOUND);
    __dprint("InternetOpenA() not found in module WININET.DLL\n");
    return 0;
}

DWORD fail_InternetErrorDlg(
    IN HWND hWnd,
    IN OUT HINTERNET hRequest,
    IN DWORD dwError,
    IN DWORD dwFlags,
    IN OUT LPVOID *lppvData
    )
{
    SetLastError(ERROR_MOD_NOT_FOUND);
    __dprint("InternetErrorDlg() not found in module WININET.DLL\n");
    return ERROR_MOD_NOT_FOUND;
}

HINTERNET fail_InternetConnectA(
    IN HINTERNET hInternet,
    IN LPCTSTR lpszServerName,
    IN INTERNET_PORT nServerPort,
    IN LPCTSTR lpszUserName,
    IN LPCTSTR lpszPassword,
    IN DWORD dwService,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )
{
    SetLastError(ERROR_MOD_NOT_FOUND);
    __dprint("InternetConnectA() not found in module WININET.DLL\n");
    return 0;
}

// from user32.dll

int fail_wvsprintfA(
    LPTSTR lpOutput, 
    LPCTSTR lpFormat,
    va_list arglist  
    )
{
    SetLastError(ERROR_MOD_NOT_FOUND);
    __dprint("wvsprintfA() not found in module USER32.DLL\n");
    return 0;
}

int fail_wsprintfA(
    LPTSTR lpOut,  
    LPCTSTR lpFmt, 
    ...            
    )
{
    SetLastError(ERROR_MOD_NOT_FOUND);
    __dprint("wsprintfA() not found in module USER32.DLL\n");
    return 0;
}

LPTSTR fail_CharLowerA(
    LPTSTR lpsz  
    )
{
    SetLastError(ERROR_MOD_NOT_FOUND);
    __dprint("CharLowerA() not found in module USER32.DLL\n");
    return 0;
}

HWND fail_GetDesktopWindow(VOID)
{
    SetLastError(ERROR_MOD_NOT_FOUND);
    __dprint("GetDeskTopWindow() not found in module USER32.DLL\n");
    return 0;
}

#if 0
// from ntdll.dll

char *fail_strstr(
    const char *sz,
    const char *token
    )
{
    SetLastError(ERROR_MOD_NOT_FOUND);
    __dprint("strstr() not found in module NTDLL.DLL\n");
    return 0;
}

char *fail_strchr(
    const char *sz,
    int         c
    )
{
    SetLastError(ERROR_MOD_NOT_FOUND);
    __dprint("strchr() not found in module NTDLL.DLL\n");
    return 0;
}

int fail__strnicmp(
    const char *one,
    const char *two,
    size_t      len
    )
{
    SetLastError(ERROR_MOD_NOT_FOUND);
    __dprint("_strnicmp() not found in module NTDLL.DLL\n");
    return 1;
}

int fail_isspace(int c)
{
    SetLastError(ERROR_MOD_NOT_FOUND);
    __dprint("isspace() not found in module NTDLL.DLL\n");
    return 0;
}
#endif

FUNCPTRS FailPtrs[] = {
    
    // lz32.dll

    {"LZCopy",                      (FARPROC)fail_LZCopy},
    {"LZClose",                     (FARPROC)fail_LZClose},
    {"LZOpenFileA",                 (FARPROC)fail_LZOpenFileA},

    // wininet.dll

    {"HttpSendRequestA",            (FARPROC)fail_HttpSendRequestA},
    {"HttpQueryInfoA",              (FARPROC)fail_HttpQueryInfoA},
    {"InternetReadFile",            (FARPROC)fail_InternetReadFile},
    {"InternetQueryDataAvailable",  (FARPROC)fail_InternetQueryDataAvailable},
    {"HttpOpenRequestA",            (FARPROC)fail_HttpOpenRequestA},
    {"FtpGetFileA",                 (FARPROC)fail_FtpGetFileA},
    {"FtpSetCurrentDirectoryA",     (FARPROC)fail_FtpSetCurrentDirectoryA},
    {"FtpFindFirstFileA",           (FARPROC)fail_FtpFindFirstFileA},
    {"InternetCloseHandle",         (FARPROC)fail_InternetCloseHandle},
    {"InternetOpenA",               (FARPROC)fail_InternetOpenA},
    {"InternetErrorDlg",            (FARPROC)fail_InternetErrorDlg},
    {"InternetConnectA",            (FARPROC)fail_InternetConnectA},

    // user32.dll

    {"wvsprintfA",                  (FARPROC)fail_wvsprintfA},
    {"wsprintfA",                   (FARPROC)fail_wsprintfA},
    {"CharLowerA",                  (FARPROC)fail_CharLowerA},
    {"GetDesktopWindow",            (FARPROC)fail_GetDesktopWindow},
    
#if 0
    // ntdll.dll    
    
    {"strstr",                      (FARPROC)fail_strstr},
    {"strchr",                      (FARPROC)fail_strchr},
    {"_strnicmp",                   (FARPROC)fail__strnicmp},
    {"isspace",                     (FARPROC)fail_isspace},
#endif

    // cabinet.dll is called by ordinal.  We will AV here

    {NULL, NULL}
};

#define cDLLs   4

enum {
    modLZ32 = 0,
    modWININET,
    modUSER32,
    modCABINET,
    modMax
};

HINSTANCE   hDelayLoadDll[modMax];


const char *szModList[modMax] = 
{
    "lz32.dll", "wininet.dll", "user32.dll", "cabinet.dll"
};


int
FindSupportedDelayLoadModule(
    const char *name
    )
{
    int i;

    for (i = 0; i < modMax; i++) {
        if (!_stricmp(name, szModList[i]))
            return i;
    }

    return -1;

}


FARPROC
FindFailureProc(
    const char *szProcName)
{
    FUNCPTRS *fp;

    for (fp = FailPtrs; fp->Name; fp++) {
        if (!_stricmp(fp->Name, szProcName)) 
            return fp->Function;
    }

    return NULL;
}


FARPROC
WINAPI
SymSrvDelayLoadHook (
    UINT            unReason,
    PDelayLoadInfo  pDelayInfo
    )
{
    FARPROC rc = NULL;

    if (dliStartProcessing == unReason)
    {
        DWORD iDll = FindSupportedDelayLoadModule(pDelayInfo->szDll);
        if (iDll == -1)
            return 0;
        
        if (!hDelayLoadDll[iDll] || hDelayLoadDll[iDll] == INVALID_HANDLE_VALUE) {
            hDelayLoadDll[iDll] = LoadLibrary(pDelayInfo->szDll);
            if (!hDelayLoadDll[iDll]) {
                hDelayLoadDll[iDll] = (HINSTANCE)INVALID_HANDLE_VALUE;
            }
        }
            
        if (INVALID_HANDLE_VALUE != hDelayLoadDll[iDll] && ghSymSrv) 
            rc = GetProcAddress(hDelayLoadDll[iDll], pDelayInfo->dlp.szProcName);

        if (!rc) 
            rc = FindFailureProc(pDelayInfo->dlp.szProcName);
#if DBG
        if (!rc) {
            OutputDBString("BogusDelayLoad function encountered...\n");
        }
#endif
    }

    if (rc && ghSymSrv) 
        *pDelayInfo->ppfn = rc;
    
    return rc;
}


#if 0
typedef struct tagVERHEAD {
    WORD wTotLen;
    WORD wValLen;
    WORD wType;         /* always 0 */
    WCHAR szKey[(sizeof("VS_VERSION_INFO")+3)&~03];
    VS_FIXEDFILEINFO vsf;
} VERHEAD ;
#endif



PfnDliHook __pfnDliNotifyHook = SymSrvDelayLoadHook;
PfnDliHook __pfnDliFailureHook = NULL;


#if DBG

void
OutputDBString(
    char *text
    )
{
    char sz[256];

    CopyStrArray(sz, "SYMSRV:  ");
    CatStrArray(sz, text);
    OutputDebugString(sz);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\symsrv\util.cpp ===
/*
 * util.cpp
 */

#include <pch.h>

char *CompressedFileName(char *name)
{
    char c;
    DWORD len;
    static char sz[MAX_PATH + 1];

    CopyStrArray(sz, name);
    len = strlen(sz) - 1;
    sz[len] = '_';

    return sz;
}


void
EnsureTrailingChar(
    char *sz,
    char  c
    )
{
    int i;

    assert(sz);

    i = strlen(sz);
    if (!i)
        return;

    if (sz[i - 1] == c)
        return;

    sz[i] = c;
    sz[i + 1] = '\0';
}


void EnsureTrailingBackslash(char *sz)
{
    return EnsureTrailingChar(sz, '\\');
}


void EnsureTrailingSlash(char *sz)
{
    return EnsureTrailingChar(sz, '/');
}


void EnsureTrailingCR(char *sz)
{
    return EnsureTrailingChar(sz, '\n');
}


void
pathcpy(
    LPSTR  trg,
    LPCSTR path,
    LPCSTR node,
    DWORD  size
    )
{
    assert (trg && path && node);

    CopyString(trg, path, size);
    EnsureTrailingBackslash(trg);
    CatString(trg, node, size);
}


void
pathcat(
    LPSTR  path,
    LPCSTR node,
    DWORD  size
    )
{
    assert(path && node);

    EnsureTrailingBackslash(path);
    CatString(path, node, size);
}


void ConvertBackslashes(LPSTR sz)
{
    for (; *sz; sz++) {
        if (*sz == '\\')
            *sz = '/';
    }
}


DWORD FileStatus(LPCSTR file)
{
    DWORD rc;

    if (GetFileAttributes(file) != 0xFFFFFFFF)
        return NO_ERROR;

    rc = GetLastError();
    if (rc)
        rc = ERROR_FILE_NOT_FOUND;

    return rc;
}


char *FormatStatus(HRESULT status)
{
    static char buf[2048];
    DWORD len = 0;
    PVOID hm;
    DWORD flags;

if (status == 0x50)
    assert(0);

    // By default, get error text from the system error list.
    flags = FORMAT_MESSAGE_FROM_SYSTEM;

    // If this is an NT code and ntdll is around,
    // allow messages to be retrieved from it also.

    if ((DWORD)status & FACILITY_NT_BIT) {
        hm = GetModuleHandle("ntdll");
        if (hm) {
            flags |= FORMAT_MESSAGE_FROM_HMODULE;
            status &= ~FACILITY_NT_BIT;
        }
    }

    if (!len)
        len = FormatMessage(flags | FORMAT_MESSAGE_IGNORE_INSERTS, 
                            hm,
                            status, 
                            0, 
                            buf, 
                            2048, 
                            NULL);

    if (len > 0) {
        while (len > 0 && isspace(buf[len - 1]))
            buf[--len] = 0;
    }

    if (len < 1)
        wsprintf(buf, "error 0x%x", status);

    if (*(buf + strlen(buf) - 1) == '\n')
        *(buf + strlen(buf) - 1) = 0;

    return buf;
}


/*
 * stolen from dbghelp.dll to avoid circular dll loads
 */

BOOL
EnsurePathExists(
    LPCSTR DirPath,
    LPSTR  ExistingPath,
    DWORD  ExistingPathSize
    )
{
    CHAR dir[_MAX_PATH + 1];
    LPSTR p;
    DWORD dw;

    __try {

        if (ExistingPath)
            *ExistingPath = 0;

        // Make a copy of the string for editing.

        if (!CopyString(dir, DirPath, _MAX_PATH))
            return false;

        p = dir;

        //  If the second character in the path is "\", then this is a UNC
        //  path, and we should skip forward until we reach the 2nd \ in the path.

        if ((*p == '\\') && (*(p+1) == '\\')) {
            p++;            // Skip over the first \ in the name.
            p++;            // Skip over the second \ in the name.

            //  Skip until we hit the first "\" (\\Server\).

            while (*p && *p != '\\') {
                p++;
            }

            // Advance over it.

            if (*p) {
                p++;
            }

            //  Skip until we hit the second "\" (\\Server\Share\).

            while (*p && *p != '\\') {
                p++;
            }

            // Advance over it also.

            if (*p) {
                p++;
            }

        } else
        // Not a UNC.  See if it's <drive>:
        if (*p && *(p+1) == ':' ) {

            p++;
            p++;

            // If it exists, skip over the root specifier

            if (*p && (*p == '\\')) {
                p++;
            }
        }

        while( *p ) {
            if ( *p == '\\' ) {
                *p = 0;
                dw = GetFileAttributes(dir);
                // Nothing exists with this name.  Try to make the directory name and error if unable to.
                if ( dw == 0xffffffff ) {
                    if ( !CreateDirectory(dir,NULL) ) {
                        if( GetLastError() != ERROR_ALREADY_EXISTS ) {
                            return false;
                        }
                    }
                } else {
                    if ( (dw & FILE_ATTRIBUTE_DIRECTORY) != FILE_ATTRIBUTE_DIRECTORY ) {
                        // Something exists with this name, but it's not a directory... Error
                        return false;
                    } else {
                        if (ExistingPath)
                            CopyString(ExistingPath, dir, ExistingPathSize);
                    }
                }

                *p = '\\';
            }
            p++;
        }
        SetLastError(NO_ERROR);

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SetLastError( GetExceptionCode() );
        return false;
    }

    return true;
}


BOOL
UndoPath(
    LPCSTR DirPath,
    LPCSTR BasePath
    )
{
    CHAR dir[_MAX_PATH + 1];
    LPSTR p;
    DWORD dw;

    dw = GetLastError();

    __try
    {
        if (!CopyString(dir, DirPath, _MAX_PATH))
            return false;
        for (p = dir + strlen(dir); p > dir; p--)
        {
            if (*p == '\\')
            {
                *p = 0;
                if (*BasePath && !_stricmp(dir, BasePath))
                    break;
                if (!RemoveDirectory(dir))
                    break;
            }
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        SetLastError( GetExceptionCode() );
        return false;
    }

    SetLastError(dw);

    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\symtodbg\sources.inc ===
INCLUDES=..\include;..\..\dbg-common

C_DEFINES=$(C_DEFINES) -DUNICODE -D_UNICODE

USE_CRTDLL = 1

TARGETLIBS      =  $(SDK_LIB_PATH)\kernel32.lib   \
                   $(SDK_LIB_PATH)\shlwapi.lib    \
                   $(SDK_LIB_PATH)\dbghelp.lib    \
                   $(SDK_LIB_PATH)\version.lib    \
                   $(SDK_LIB_PATH)\imagehlp.lib   \
                   $(SDK_LIB_PATH)\user32.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\symsrv\util.h ===
/*
 * util.h
 */

char *CompressedFileName(char *name);
void  ConvertBackslashes(LPSTR sz);
void  EnsureTrailingBackslash(char *sz);
void  EnsureTrailingChar(char *sz, char c);
void  EnsureTrailingCR(char *sz);
void  EnsureTrailingSlash(char *sz);
DWORD FileStatus(LPCSTR file);
void  pathcat(char *path, const char *node, DWORD size);
void  pathcpy(LPSTR  trg, LPCSTR path, LPCSTR node, DWORD size);
char *FormatStatus(HRESULT status);
BOOL  EnsurePathExists(LPCSTR DirPath, LPSTR  ExistingPath, DWORD  ExistingPathSize);
BOOL  UndoPath(LPCSTR DirPath, LPCSTR BasePath);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\symtodbg\cvtodbg\makefile.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\symsrv\uncomp.cpp ===
#include "pch.h"
#include <fdi.h>
#include <io.h>
#include <fcntl.h>
#include <sys\stat.h>
#include <malloc.h>
#include <lzexpand.h>

#ifdef __cplusplus
 extern "C" {
#endif

BOOL
UncompressFile(
    IN LPCSTR CompressedFileName,
    IN LPCSTR UncompressedFileName
    );

DWORD
UncompressLZFile(
    IN LPCSTR CompressedFileName,
    IN LPCSTR UncompressedFileName
    );

#ifdef __cplusplus
 }
#endif


typedef struct
{
    LPCSTR TargetFileName;   // pathname of file to create
    LPCSTR SymbolFileName;   // name of file to uncompress
    DWORD  FileSize;         // expected file size
    DWORD  LastError;        // completion code
} OPCONTEXT;


DWORD
ExtractSingleFileFromCabinet(
    IN LPCSTR CabinetFileName,
    IN LPCSTR TargetFileName,
    IN LPCSTR FileNameInCabinet
    );


INT_PTR
DIAMONDAPI
FdiNotification(
    FDINOTIFICATIONTYPE fdint,
    PFDINOTIFICATION    pfdin
    );

void HUGE *
FAR DIAMONDAPI
FdiAlloc(
    ULONG cb
    );

void
FAR DIAMONDAPI
FdiFree(
    void HUGE *pv
    );

INT_PTR
FAR DIAMONDAPI
FdiOpen(
    char FAR *pszFile,
    int oflag,
    int pmode
    );

UINT
FAR DIAMONDAPI
FdiRead(
    INT_PTR hf,
    void FAR *pv,
    UINT cb
    );

UINT
FAR DIAMONDAPI
FdiWrite(
    INT_PTR hf,
    void FAR *pv,
    UINT cb
    );

long
FAR DIAMONDAPI
FdiSeek(
    INT_PTR hf,
    long dist,
    int seektype
    );

int
FAR DIAMONDAPI
FdiClose(
    INT_PTR hf
    );

DWORD
GetLastErrorWithDefault(
    DWORD DefaultError
    );

#ifdef STANDALONE

int __cdecl main( int argc, char * argv[] )
{
    BOOL rc;

    printf( "UncompressFile( \"%s\", \"%s\" )\n", argv[ 1 ], argv[ 2 ] );

    rc = UncompressFile( argv[1], argv[2] );

    if ( rc == TRUE )
    {
        printf( "Expanded \"%s\" to \"%s\"\n", argv[1], argv[2] );
    }
    else
    {
        printf( "Failed to expand, GLE=%u\n", GetLastError());
    }

    return rc;
}

#endif


BOOL
UncompressFile(
    IN LPCSTR CompressedFileName,
    IN LPCSTR UncompressedFileName
    )
{
    DWORD   rc;
    LPCSTR  FileNameInCabinet;

    // Assume the name to be extracted from the
    // compressed file is the same as the base
    // name of the specified target file.

    FileNameInCabinet = strrchr( UncompressedFileName, '\\' );
    if ( FileNameInCabinet == NULL )
    {
         FileNameInCabinet = UncompressedFileName;
    }
    else
    {
         FileNameInCabinet++;
    }

    __try
    {
        rc = ExtractSingleFileFromCabinet(
                CompressedFileName,
                UncompressedFileName,
                FileNameInCabinet
                );

        //
        //  If the file is not a cabinet, it might be an LZExpand file
        //

        if ( rc == ERROR_FILE_CORRUPT )
        {
            rc = UncompressLZFile(
                CompressedFileName,
                UncompressedFileName
                );
        }
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        rc = GetExceptionCode();

        if ( rc == ERROR_SUCCESS )
        {
            rc = E_UNEXPECTED;
        }
    }

    if ( rc != ERROR_SUCCESS )
    {
        SetLastError( rc );

        return( FALSE );
    }

    return( TRUE );
}


DWORD
ExtractSingleFileFromCabinet(
    IN LPCSTR CabinetFileName,
    IN LPCSTR TargetFileName,
    IN LPCSTR FileNameInCabinet
    )
{
    HFDI       hFDI;
    OPCONTEXT  Context;
    ERF        Erf;
    DWORD      rc;

    memset( &Context, 0, sizeof( Context ));
    Context.TargetFileName = TargetFileName;
    Context.SymbolFileName = FileNameInCabinet;
    Context.LastError = ERROR_FILE_NOT_FOUND;

    memset( &Erf, 0, sizeof( Erf ));

    hFDI = FDICreate(
                FdiAlloc,
                FdiFree,
                FdiOpen,
                FdiRead,
                FdiWrite,
                FdiClose,
                FdiSeek,
                cpuUNKNOWN,
                &Erf
                );

    if ( hFDI == NULL )
    {
        Context.LastError = GetLastErrorWithDefault( ERROR_NOT_ENOUGH_MEMORY );
    }
    else
    {
        rc = FDICopy(
                hFDI,
                "",
                (char *) CabinetFileName,
                0,
                FdiNotification,
                NULL,
                &Context
                );

        FDIDestroy( hFDI );

        if (( rc == FALSE ) &&
            ( Context.LastError == ERROR_FILE_NOT_FOUND ))
        {
            switch ( Erf.erfOper )
            {
            case FDIERROR_NOT_A_CABINET:
            case FDIERROR_UNKNOWN_CABINET_VERSION:
            case FDIERROR_CORRUPT_CABINET:
            case FDIERROR_BAD_COMPR_TYPE:
            case FDIERROR_MDI_FAIL:

                Context.LastError = ERROR_FILE_CORRUPT;
            }
        }
    }

    return( Context.LastError );
}


DWORD
UncompressLZFile(
    IN LPCSTR CompressedFileName,
    IN LPCSTR UncompressedFileName
    )
{
    INT_PTR  hSource;
    int      hSrc,  hDst;
    OFSTRUCT ofSrc, ofDst;
    long     l;
    static unsigned char Signature[] = { 'S', 'Z', 'D', 'D', 0x88, 0xF0, 0x27, 0x33 };
    unsigned char SignatureBuffer[ sizeof( Signature ) ];

    //
    //  Make sure it really is an LZExpand file
    //

    memset( SignatureBuffer, 0xFF, sizeof( Signature ));

    hSource = FdiOpen(
        (char *) CompressedFileName,
        _O_BINARY,
        0
        );

    if ( hSource != -1 )
    {
        FdiRead( hSource, SignatureBuffer, sizeof( Signature ));
        FdiClose( hSource );
    }

    if ( memcmp( Signature, SignatureBuffer, sizeof( Signature )))
    {
        return ERROR_FILE_CORRUPT;
    }

    //
    //  Use LZ32.DLL functions to decompress
    //

    hSrc = LZOpenFile(
        (char *) CompressedFileName,
        &ofSrc,
        OF_READ | OF_SHARE_DENY_WRITE
        );

    if ( hSrc >= 0 )
    {
        hDst = LZOpenFile(
                   (char *) UncompressedFileName,
                   &ofDst,
                   OF_CREATE | OF_WRITE | OF_SHARE_EXCLUSIVE
                   );

        if ( hDst >= 0 )
        {
            l = LZCopy( hSrc, hDst );

            if ( l >= 0 )
            {
                l = 0;
            }

            LZClose( hDst );
        }
        else
        {
            l = hDst;
        }

        LZClose( hSrc );
    }
    else
    {
        l = hSrc;
    }

    switch( l )
    {
    case NO_ERROR:
        return( NO_ERROR );

    case LZERROR_BADINHANDLE:
    case LZERROR_READ:
        return( ERROR_READ_FAULT );

    case LZERROR_BADOUTHANDLE:
    case LZERROR_WRITE:
        return( ERROR_WRITE_FAULT );

    case LZERROR_GLOBALLOC:
    case LZERROR_GLOBLOCK:
        return( ERROR_NOT_ENOUGH_MEMORY );

    case LZERROR_BADVALUE:
    case LZERROR_UNKNOWNALG:
        return( ERROR_INVALID_DATA );

    default:
        return( ERROR_INVALID_FUNCTION );
    }
}


DWORD
GetLastErrorWithDefault(
    DWORD DefaultError
    )
{
    DWORD LastError;

    LastError = GetLastError();

    if ( LastError == ERROR_SUCCESS )
    {
        LastError = DefaultError;
    }

    return( LastError );
}


INT_PTR
DIAMONDAPI
FdiNotification(
    FDINOTIFICATIONTYPE fdint,
    PFDINOTIFICATION    pfdin
    )
{
    OPCONTEXT * Context = (OPCONTEXT *) pfdin->pv;
    FILETIME    LocalTime;
    FILETIME    FileTime;
    INT_PTR     hFile;

    switch ( fdint )
    {
    case fdintCOPY_FILE:

        hFile = 0;

        if ( _stricmp( pfdin->psz1, Context->SymbolFileName ) == 0 )
        {
            Context->FileSize = pfdin->cb;

            hFile = FdiOpen(
                        (char *) Context->TargetFileName,
                        _O_CREAT,
                        0
                        );

            if ( hFile == -1 )
            {
                Context->LastError = GetLastErrorWithDefault( ERROR_CANNOT_MAKE );
            }
        }

        return( hFile );  // 0 = skip, -1 = abort, other = handle

    case fdintCLOSE_FILE_INFO:

        if ( DosDateTimeToFileTime( pfdin->date, pfdin->time, &LocalTime ) &&
             LocalFileTimeToFileTime( &LocalTime, &FileTime ))
        {
            SetFileTime(
                (HANDLE) pfdin->hf,
                NULL,
                NULL,
                &FileTime            // last-modified date/time
                );
        }

        if ( GetFileSize( (HANDLE) pfdin->hf, NULL ) == Context->FileSize )
        {
            Context->LastError = ERROR_SUCCESS;
        }

        FdiClose( pfdin->hf );

        return 0;

    case fdintNEXT_CABINET:

        return -1;                  // multi-part cabinets not supported

    default:

        return 0;                   // disregard any other messages
    }
}


//
//  FDI I/O callback functions
//

void HUGE *
FAR DIAMONDAPI
FdiAlloc(
    ULONG cb
    )
{
    void HUGE * pv;

    pv = LocalAlloc(LPTR, cb);

    return( pv );
}


void
FAR DIAMONDAPI
FdiFree(
    void HUGE *pv
    )
{
    LocalFree( pv );
}


INT_PTR
FAR DIAMONDAPI
FdiOpen(
    char FAR *pszFile,
    int oflag,
    int pmode
    )
{
    HANDLE Handle;
    BOOL Create = ( oflag & _O_CREAT );

    Handle = CreateFile(
                 pszFile,
                 Create ? GENERIC_WRITE : GENERIC_READ,
                 Create ? 0 : FILE_SHARE_READ,
                 NULL,
                 Create ? CREATE_ALWAYS : OPEN_EXISTING,
                 FILE_ATTRIBUTE_NORMAL,
                 NULL
                 );

    if ( Handle == INVALID_HANDLE_VALUE )
    {
        return( -1 );
    }

    return( (INT_PTR) Handle );
}


UINT
FAR DIAMONDAPI
FdiRead(
    INT_PTR hf,
    void FAR *pv,
    UINT cb
    )
{
    BOOL  rc;
    DWORD cbActual;

    rc = ReadFile((HANDLE)hf,
                  pv,
                  cb,
                  &cbActual,
                  NULL);

    return rc ? cbActual : 0;
}


UINT
FAR DIAMONDAPI
FdiWrite(
    INT_PTR hf,
    void FAR *pv,
    UINT cb
    )
{
    DWORD cbActual = 0;

    WriteFile((HANDLE)hf,
              pv,
              cb,
              &cbActual,
              NULL);

    return cbActual;
}


long
FAR DIAMONDAPI
FdiSeek(
    INT_PTR hf,
    long dist,
    int seektype
    )
{
    long result;
    DWORD NewPosition;

    NewPosition = SetFilePointer(
                      (HANDLE) hf,
                      dist,
                      NULL,
                      (DWORD) seektype
                      );

    if ( NewPosition == INVALID_SET_FILE_POINTER )
    {
        return( -1 );
    }

    return( (long) NewPosition );
}


int
FAR DIAMONDAPI
FdiClose(
    INT_PTR hf
    )
{
    if ( ! CloseHandle( (HANDLE) hf ))
    {
        return( -1 );
    }

    return( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\symtodbg\cvtodbg\cvtodbg.cpp ===
//
// cvtodbg.cpp
//
// Takes a PE file and a file containing CV info, and jams the CV info
// into the PE file (trashing it). However, The Jammed PE File when 
// splitsym'ed gives a dbg file, which can be used for debugging. 
// 
//
#undef UNICODE

#include "windows.h"
#include "imagehlp.h"
#include "stdio.h"
#include "stdlib.h"
////////////////////////////////////////
//
// Data
//
char    szImageName[MAX_PATH];
char    szCVName[MAX_PATH];
char    szPdbName[MAX_PATH];
char    szPdbCurrentPath[MAX_PATH];
HANDLE  hFile           = INVALID_HANDLE_VALUE;
HANDLE  hMappedFile     = INVALID_HANDLE_VALUE;
LPVOID  pvImageBase     = NULL;

BOOL    fVerbose        = FALSE;
BOOL    fForce 			= FALSE;

typedef struct NB10I                   // NB10 debug info
    {
    DWORD   nb10;                      // NB10
    DWORD   off;                       // offset, always 0
    DWORD   sig;
    DWORD   age;
    } NB10I;

typedef struct cvinfo
    {
    NB10I nb10;
    char rgb[0x200 - sizeof(NB10I)];
    } CVINFO;


////////////////////////////////////////
//
// Forward declarations
// 
BOOL    ParseArgs(int argc, WCHAR* argv[]);
void    UpdateCodeViewInfo();
void    Usage();
void    Message(const char* szFormat, ...);
void    Error(const char *sz, ...);
void    ErrorThrow(DWORD, const char *sz, ...);
void    Throw(DWORD);
void    MapImage();
void    UnmapImage(BOOL fTouch);
BOOL    DebugDirectoryIsUseful(LPVOID, ULONG);
void    RecalculateChecksum();
ULONG   FileSize(HANDLE);


class FileMapping {
public:
    FileMapping()
        : hFile(NULL), hMapping(NULL), pView(NULL)
    {
    }

    ~FileMapping()
    {
        Cleanup();
    }

    void Cleanup()
    {
        if (pView != NULL)
            UnmapViewOfFile(pView);
        if (hMapping != NULL)
            CloseHandle(hMapping);
        if (hFile != NULL && hFile != INVALID_HANDLE_VALUE)
            CloseHandle(hFile);
    }

    bool Open(LPCTSTR szFile)
    {
        hFile = CreateFile(szFile,
                           GENERIC_READ,
                           FILE_SHARE_READ | FILE_SHARE_WRITE,
                           NULL,
                           OPEN_EXISTING,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL);
        if (hFile != INVALID_HANDLE_VALUE) {
            hMapping = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
            if (hMapping != NULL) {
                pView = MapViewOfFile(hMapping, FILE_MAP_READ, 0, 0, 0);
                return true;
            }
        }

        Cleanup();
        return false;
    }

    PVOID GetDataPtr()
    {
        return pView;
    }

    DWORD GetSize()
    {
        return GetFileSize(hFile, NULL);
    }

    bool IsValid()
    {
        return (pView != NULL);
    }
    
private:
    HANDLE hFile;
    HANDLE hMapping;
    PVOID pView;
};



////////////////////////////////////////
//
// Code
//
void __cdecl wmain(int argc, WCHAR* argv[])
// Main entry point
//
     {
    szPdbName[0] = 0;
    szPdbCurrentPath[0] = 0;
    if (ParseArgs(argc, argv))
        {
        __try
            {
            UpdateCodeViewInfo();
            }
        __except(EXCEPTION_EXECUTE_HANDLER)
            {
            // nothing, just don't propagate it higher to the user
            }
        }
    }


// find the code view info; 
// if new info fits in old space, rewrite; else append new cv record and fix up 
// debug directory to point to the new record; append cv info to file.
void UpdateCodeViewInfo()
    {
    PIMAGE_NT_HEADERS pntHeaders;
    ULONG cbWritten;

    MapImage();

    FileMapping cvMapping;
    if (!cvMapping.Open(szCVName))
        ErrorThrow(666, "Couldn't open CV file");
    
    pntHeaders = ImageNtHeader(pvImageBase);
    if (pntHeaders)
        {
        if (pntHeaders->OptionalHeader.MajorLinkerVersion >= 3 ||
            pntHeaders->OptionalHeader.MinorLinkerVersion >= 5)
            {
            // make it non vc generated image, we are trashing the binary anyway
            if ( pntHeaders->OptionalHeader.MajorLinkerVersion > 5)
                pntHeaders->OptionalHeader.MajorLinkerVersion = 5;

            // put dbg info back in if its already stripped.
            if (pntHeaders->FileHeader.Characteristics & IMAGE_FILE_DEBUG_STRIPPED)
                pntHeaders->FileHeader.Characteristics ^= IMAGE_FILE_DEBUG_STRIPPED;
            
            ULONG ibFileCvStart = FileSize(hFile);
            SetFilePointer(hFile, 0, NULL, FILE_END);

            while (ibFileCvStart & 7)                       // Align file length to 8-bytes. Slow, but clearly 
                {                                           // works! And for 7 bytes, who cares.
                BYTE zero = 0;
                WriteFile(hFile, &zero, 1, &cbWritten, NULL);
                ibFileCvStart++;
                }

            // Write out the CV info.
            WriteFile(hFile, cvMapping.GetDataPtr(), cvMapping.GetSize(), &cbWritten, NULL);
            
            // Make up a debug directory
            IMAGE_DEBUG_DIRECTORY dbgdirs[2];

            dbgdirs[0].Characteristics = pntHeaders->FileHeader.Characteristics;
            dbgdirs[0].TimeDateStamp = pntHeaders->FileHeader.TimeDateStamp;
            dbgdirs[0].MajorVersion = 0;
            dbgdirs[0].MinorVersion = 0;
            dbgdirs[0].Type = IMAGE_DEBUG_TYPE_MISC;
            dbgdirs[0].SizeOfData = 0;
            dbgdirs[0].AddressOfRawData = ibFileCvStart;
            dbgdirs[0].PointerToRawData = ibFileCvStart;

            dbgdirs[1].Characteristics = pntHeaders->FileHeader.Characteristics;
            dbgdirs[1].TimeDateStamp = pntHeaders->FileHeader.TimeDateStamp;
            dbgdirs[1].MajorVersion = 0;
            dbgdirs[1].MinorVersion = 0;
            dbgdirs[1].Type = IMAGE_DEBUG_TYPE_CODEVIEW;
            dbgdirs[1].SizeOfData = cvMapping.GetSize();
            dbgdirs[1].AddressOfRawData = ibFileCvStart;
            dbgdirs[1].PointerToRawData = ibFileCvStart;

            // Find the beginning of the first section and stick the debug directory there
            // (did we mention we're trashing the file?)

            IMAGE_SECTION_HEADER* pFirstSection = IMAGE_FIRST_SECTION(pntHeaders);

            memcpy((PBYTE)((DWORD)pvImageBase + pFirstSection->PointerToRawData), &dbgdirs, sizeof(dbgdirs));

            pntHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress = pFirstSection->VirtualAddress;
            pntHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size = sizeof(dbgdirs);

            }
        }
    UnmapImage(TRUE);
    }



void MapImage()
// Map the image into memory for read-write. Caller MUST call 
// Unmapimage to clean up even on failure.
    {
    if (fForce)
        SetFileAttributesA(szImageName, FILE_ATTRIBUTE_NORMAL);

    hFile = CreateFileA( szImageName,
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL
                        );

    if (hFile == INVALID_HANDLE_VALUE) 
        {
        ErrorThrow(GetLastError(), "unable to open '%s'\n", szImageName);
        }


    hMappedFile = CreateFileMapping( hFile,
                                     NULL,
                                     PAGE_READWRITE,
                                     0,
                                     0,
                                     NULL
                                   );
    if (!hMappedFile) 
        {
        ErrorThrow(GetLastError(), "un`able to create file mapping for '%s'\n", szImageName);
        }

    pvImageBase = MapViewOfFile(hMappedFile, FILE_MAP_WRITE, 0, 0, 0);

    if (!pvImageBase)
        {
        ErrorThrow(GetLastError(), "unable to map view of '%s'\n", szImageName);
        }
    
    }


void UnmapImage(BOOL fTouch)
// Clean up whatever MapImage does
    {
    if (pvImageBase)
        {
        FlushViewOfFile(pvImageBase, 0);
        UnmapViewOfFile(pvImageBase);
        pvImageBase = NULL;
        }

    if (hMappedFile != INVALID_HANDLE_VALUE)
        {
        CloseHandle(hMappedFile);
        hMappedFile = INVALID_HANDLE_VALUE;
        }

    if (hFile != INVALID_HANDLE_VALUE)
        {
        if (fTouch)
            {
            TouchFileTimes(hFile, NULL);
            }
        CloseHandle(hFile);
        hFile = INVALID_HANDLE_VALUE;
        }
    }


BOOL ParseArgs(int argc, WCHAR* argv[])
// Parse the arguments and set our flags appropriately
    {
    WCHAR* wszString;
    WCHAR c;

    szImageName[0] = L'\0';
    szCVName[0] = L'\0';

    while (--argc) 
        {
        wszString = *++argv;
        if (*wszString == L'/' || *wszString == L'-') 
            {
            while ((c = *++wszString) != L'\0')
                {
                switch (towupper( c )) 
                    {
                case L'?':
                    Usage();
                    return FALSE;

                case L'V':
                    fVerbose = TRUE;
                    break;

                default:
                    Error("invalid switch - /%c\n", c );
                    Usage();
                    return FALSE;
                    }
                }
            }
        else
            {
            if (szImageName[0] == L'\0')
                {
                wcstombs(szImageName, wszString, MAX_PATH);
                }
            else if (szCVName[0] == L'\0') 
                {
                wcstombs(szCVName, wszString, MAX_PATH);
                }
            else
                {
                Error("too many files specified\n");
                Usage();
                return FALSE;
                }
            }
        }

    if (szImageName==NULL)
        {
        Error("no image name specified\n");
        Usage();
        return FALSE;
        }

    if (szCVName==NULL)
        {
        Error("no CV filename specified\n");
        Usage();
        return FALSE;
        }

    return TRUE;
    }


void Usage()
    {
    fprintf(stderr, "Usage: cvtodbg [options] imageName cvFile\n"
            "              [-?] display this message\n"
            "              [-f] overwrite readonly files\n");
    }

void Message(const char* szFormat, ...)
    {
    va_list va;
    va_start(va, szFormat);
    fprintf (stdout, "resetpdb: ");
    vfprintf(stdout, szFormat, va);
    va_end(va);
    }

void Error(const char* szFormat, ...)
    {
    va_list va;
    va_start(va, szFormat);
    fprintf (stderr, "resetpdb: error: ");
    vfprintf(stderr, szFormat, va);
    va_end(va);
    }

void ErrorThrow(DWORD dw, const char* szFormat, ...)
    {
    va_list va;
    va_start(va, szFormat);
    fprintf (stderr, "resetpdb: error: ");
    vfprintf(stderr, szFormat, va);
    va_end(va);
    Throw(dw);
    }

void Throw(DWORD dw)
    {
    RaiseException(dw, EXCEPTION_NONCONTINUABLE, 0, NULL);
    }

BOOL DebugDirectoryIsUseful(LPVOID Pointer, ULONG Size) 
    {
    return (Pointer != NULL) &&                          
        (Size >= sizeof(IMAGE_DEBUG_DIRECTORY)) &&    
        ((Size % sizeof(IMAGE_DEBUG_DIRECTORY)) == 0);
    }

ULONG FileSize(HANDLE h)
// Answer the size of the file with this handle
    {
    BY_HANDLE_FILE_INFORMATION info;
    GetFileInformationByHandle(h, &info);
    return info.nFileSizeLow;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\symtodbg\matchsym\makefile.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\symtodbg\include\cv.h ===
/*++


Copyright 1996 - 1997 Microsoft Corporation

Module Name:

    cv.h

Abstract:

    This file contains all of the type definitions for accessing
    CODEVIEW data.

Environment:

    Win32, User Mode

--*/
#include <cvinfo.h>
#include <cvexefmt.h>

// from types.h

typedef USHORT      SEGMENT;    // 32-bit compiler doesn't like "_segment"
typedef ULONG       UOFF32;
typedef USHORT      UOFF16;
typedef LONG        OFF32;
typedef SHORT       OFF16;

#if defined (ADDR_16)
    // we are operating as a 16:16 evaluator only
    // the address packet will be defined as an offset and a 16 bit filler
    typedef OFF16       OFFSET;
    typedef UOFF16      UOFFSET;
#else
    typedef OFF32       OFFSET;
    typedef UOFF32      UOFFSET;
#endif // ADDR_16

typedef UOFFSET FAR *LPUOFFSET;

// Global Segment Info table
typedef struct _sgf {
    unsigned short      fRead   :1;
    unsigned short      fWrite  :1;
    unsigned short      fExecute:1;
    unsigned short      f32Bit  :1;
    unsigned short      res1    :4;
    unsigned short      fSel    :1;
    unsigned short      fAbs    :1;
    unsigned short      res2    :2;
    unsigned short      fGroup  :1;
    unsigned short      res3    :3;
} SGF;

typedef struct _sgi {
    SGF                 sgf;        // Segment flags
    unsigned short      iovl;       // Overlay number
    unsigned short      igr;        // Group index
    unsigned short      isgPhy;     // Physical segment index
    unsigned short      isegName;   // Index to segment name
    unsigned short      iclassName; // Index to segment class name
    unsigned long       doffseg;    // Starting offset inside physical segment
    unsigned long       cbSeg;      // Logical segment size
} SGI;

typedef struct _sgm {
    unsigned short      cSeg;       // number of segment descriptors
    unsigned short      cSegLog;    // number of logical segment descriptors
} SGM;

#define FileAlign(x)  ( ((x) + p->optrs.optHdr->FileAlignment - 1) &  \
                            ~(p->optrs.optHdr->FileAlignment - 1) )
#define SectionAlign(x) (((x) + p->optrs.optHdr->SectionAlignment - 1) &  \
                            ~(p->optrs.optHdr->SectionAlignment - 1) )

#define NextSym32(m)  ((DATASYM32 *) \
  (((DWORD)(m) + sizeof(DATASYM32) + \
    ((DATASYM32*)(m))->name[0] + 3) & ~3))

#define NextSym16(m)  ((DATASYM16 *) \
  (((DWORD)(m) + sizeof(DATASYM16) + \
    ((DATASYM16*)(m))->name[0] + 1) & ~1))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\symtodbg\include\cvcommon.h ===
/*
 *   PROTOTYPES, TYPEDEFS and other items for cvcommon.c
 */

DWORD   CreateSignature( PPOINTERS p );
DWORD   CreateDirectories( PPOINTERS p );
DWORD   CreateModuleDirectoryEntries( PPOINTERS p );
DWORD   CreateSegMapDirectoryEntries( PPOINTERS p );
DWORD   CreateSrcModulesDirectoryEntries( PPOINTERS p );
DWORD   CreatePublicDirectoryEntries( PPOINTERS p );
DWORD   CreateSymbolHashTable( PPOINTERS p );
DWORD   CreateAddressSortTable( PPOINTERS p );
DWORD   DWordXorLrl(char * szSym);
OMFModule *     NextMod(OMFModule * pMod);
VOID    UpdatePtrs( PPOINTERS p, PPTRINFO pi, LPVOID lpv, DWORD count );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\symtodbg\include\cvinfo.h ===
/***    cvinfo.h - Generic CodeView information definitions
 *
 *      Version 5.0 (using 32-bit types)
 *      Structures, constants, etc. for accessing and interpreting
 *      CodeView information.
 *
 */

#ifndef _CV_INFO_INCLUDED
#define _CV_INFO_INCLUDED

#ifdef  __cplusplus
#pragma warning ( disable: 4200 )
#endif

#ifndef __INLINE
#ifdef  __cplusplus
#define __INLINE inline
#else
#define __INLINE __inline
#endif
#endif

#pragma pack ( push, 1 )
typedef unsigned long   CV_uoff32_t;
typedef          long   CV_off32_t;
typedef unsigned short  CV_uoff16_t;
typedef          short  CV_off16_t;
typedef unsigned short  CV_typ16_t;
typedef unsigned long   CV_typ_t;
typedef unsigned short	_2BYTEPAD;

#if !defined (CV_ZEROLEN)
#define CV_ZEROLEN
#endif

#if !defined (FLOAT10)
#if defined(_M_I86)                    // 16 bit x86 supporting long double
typedef long double FLOAT10;
#else                                  // 32 bit w/o long double support
typedef struct FLOAT10
{
    char b[10];
} FLOAT10;
#endif
#endif


#define CV_SIGNATURE_C6         0L  // Actual signature is >64K
#define CV_SIGNATURE_C7         1L  // First explicit signature
#define CV_SIGNATURE_C11        2L  // C11 (vc5.x) 32-bit types
#define CV_SIGNATURE_RESERVED   3L  // All signatures from 3 to 64K are reserved

#define CV_MAXOFFSET   0xffffffff

/**     CodeView Symbol and Type OMF type information is broken up into two
 *      ranges.  Type indices less than 0x1000 describe type information
 *      that is frequently used.  Type indices above 0x1000 are used to
 *      describe more complex features such as functions, arrays and
 *      structures.
 */




/**     Primitive types have predefined meaning that is encoded in the
 *      values of the various bit fields in the value.
 *
 *      A CodeView primitive type is defined as:
 *
 *      1 1
 *      1 089  7654  3  210
 *      r mode type  r  sub
 *
 *      Where
 *          mode is the pointer mode
 *          type is a type indicator
 *          sub  is a subtype enumeration
 *          r    is a reserved field
 *
 *      See Microsoft Symbol and Type OMF (Version 4.0) for more
 *      information.
 */


#define CV_MMASK        0x700       // mode mask
#define CV_TMASK        0x0f0       // type mask

// can we use the reserved bit ??
#define CV_SMASK        0x00f       // subtype mask

#define CV_MSHIFT       8           // primitive mode right shift count
#define CV_TSHIFT       4           // primitive type right shift count
#define CV_SSHIFT       0           // primitive subtype right shift count

// macros to extract primitive mode, type and size

#define CV_MODE(typ)    (((typ) & CV_MMASK) >> CV_MSHIFT)
#define CV_TYPE(typ)    (((typ) & CV_TMASK) >> CV_TSHIFT)
#define CV_SUBT(typ)    (((typ) & CV_SMASK) >> CV_SSHIFT)

// macros to insert new primitive mode, type and size

#define CV_NEWMODE(typ, nm)     ((CV_typ_t)(((typ) & ~CV_MMASK) | ((nm) << CV_MSHIFT)))
#define CV_NEWTYPE(typ, nt)     (((typ) & ~CV_TMASK) | ((nt) << CV_TSHIFT))
#define CV_NEWSUBT(typ, ns)     (((typ) & ~CV_SMASK) | ((ns) << CV_SSHIFT))



//     pointer mode enumeration values

typedef enum CV_prmode_e {
    CV_TM_DIRECT = 0,       // mode is not a pointer
    CV_TM_NPTR   = 1,       // mode is a near pointer
    CV_TM_FPTR   = 2,       // mode is a far pointer
    CV_TM_HPTR   = 3,       // mode is a huge pointer
    CV_TM_NPTR32 = 4,       // mode is a 32 bit near pointer
    CV_TM_FPTR32 = 5,       // mode is a 32 bit far pointer
    CV_TM_NPTR64 = 6,       // mode is a 64 bit near pointer
    CV_TM_NPTR128 = 7       // mode is a 128 bit near pointer
} CV_prmode_e;




//      type enumeration values


typedef enum CV_type_e {
    CV_SPECIAL      = 0x00,         // special type size values
    CV_SIGNED       = 0x01,         // signed integral size values
    CV_UNSIGNED     = 0x02,         // unsigned integral size values
    CV_BOOLEAN      = 0x03,         // Boolean size values
    CV_REAL         = 0x04,         // real number size values
    CV_COMPLEX      = 0x05,         // complex number size values
    CV_SPECIAL2     = 0x06,         // second set of special types
    CV_INT          = 0x07,         // integral (int) values
    CV_CVRESERVED   = 0x0f
} CV_type_e;




//      subtype enumeration values for CV_SPECIAL


typedef enum CV_special_e {
    CV_SP_NOTYPE    = 0x00,
    CV_SP_ABS       = 0x01,
    CV_SP_SEGMENT   = 0x02,
    CV_SP_VOID      = 0x03,
    CV_SP_CURRENCY  = 0x04,
    CV_SP_NBASICSTR = 0x05,
    CV_SP_FBASICSTR = 0x06,
    CV_SP_NOTTRANS  = 0x07
} CV_special_e;




//      subtype enumeration values for CV_SPECIAL2


typedef enum CV_special2_e {
    CV_S2_BIT       = 0x00,
    CV_S2_PASCHAR   = 0x01          // Pascal CHAR
} CV_special2_e;





//      subtype enumeration values for CV_SIGNED, CV_UNSIGNED and CV_BOOLEAN


typedef enum CV_integral_e {
    CV_IN_1BYTE     = 0x00,
    CV_IN_2BYTE     = 0x01,
    CV_IN_4BYTE     = 0x02,
    CV_IN_8BYTE     = 0x03,
    CV_IN_16BYTE    = 0x04
} CV_integral_e;





//      subtype enumeration values for CV_REAL and CV_COMPLEX


typedef enum CV_real_e {
    CV_RC_REAL32    = 0x00,
    CV_RC_REAL64    = 0x01,
    CV_RC_REAL80    = 0x02,
    CV_RC_REAL128   = 0x03,
    CV_RC_REAL48    = 0x04
} CV_real_e;




//      subtype enumeration values for CV_INT (really int)


typedef enum CV_int_e {
    CV_RI_CHAR      = 0x00,
    CV_RI_INT1      = 0x00,
    CV_RI_WCHAR     = 0x01,
    CV_RI_UINT1     = 0x01,
    CV_RI_INT2      = 0x02,
    CV_RI_UINT2     = 0x03,
    CV_RI_INT4      = 0x04,
    CV_RI_UINT4     = 0x05,
    CV_RI_INT8      = 0x06,
    CV_RI_UINT8     = 0x07,
    CV_RI_INT16     = 0x08,
    CV_RI_UINT16    = 0x09
} CV_int_e;




// macros to check the type of a primitive

#define CV_TYP_IS_DIRECT(typ)   (CV_MODE(typ) == CV_TM_DIRECT)
#define CV_TYP_IS_PTR(typ)      (CV_MODE(typ) != CV_TM_DIRECT)
#define CV_TYP_IS_NPTR(typ)     (CV_MODE(typ) == CV_TM_NPTR)
#define CV_TYP_IS_FPTR(typ)     (CV_MODE(typ) == CV_TM_FPTR)
#define CV_TYP_IS_HPTR(typ)     (CV_MODE(typ) == CV_TM_HPTR)
#define CV_TYP_IS_NPTR32(typ)   (CV_MODE(typ) == CV_TM_NPTR32)
#define CV_TYP_IS_FPTR32(typ)   (CV_MODE(typ) == CV_TM_FPTR32)

#define CV_TYP_IS_SIGNED(typ)   (((CV_TYPE(typ) == CV_SIGNED) && CV_TYP_IS_DIRECT(typ)) || \
                                 (typ == T_INT1)  || \
                                 (typ == T_INT2)  || \
                                 (typ == T_INT4)  || \
                                 (typ == T_INT8)  || \
                                 (typ == T_INT16) || \
                                 (typ == T_RCHAR))

#define CV_TYP_IS_UNSIGNED(typ) (((CV_TYPE(typ) == CV_UNSIGNED) && CV_TYP_IS_DIRECT(typ)) || \
                                 (typ == T_UINT1) || \
                                 (typ == T_UINT2) || \
                                 (typ == T_UINT4) || \
                                 (typ == T_UINT8) || \
                                 (typ == T_UINT16))

#define CV_TYP_IS_REAL(typ)     ((CV_TYPE(typ) == CV_REAL)  && CV_TYP_IS_DIRECT(typ))

#define CV_FIRST_NONPRIM 0x1000
#define CV_IS_PRIMITIVE(typ)    ((typ) < CV_FIRST_NONPRIM)
#define CV_TYP_IS_COMPLEX(typ)  ((CV_TYPE(typ) == CV_COMPLEX)   && CV_TYP_IS_DIRECT(typ))




// selected values for type_index - for a more complete definition, see
// Microsoft Symbol and Type OMF document




//      Special Types


#define T_NOTYPE        0x0000      // uncharacterized type (no type)
#define T_ABS           0x0001      // absolute symbol
#define T_SEGMENT       0x0002      // segment type
#define T_VOID          0x0003      // void
#define T_PVOID         0x0103      // near pointer to void
#define T_PFVOID        0x0203      // far pointer to void
#define T_PHVOID        0x0303      // huge pointer to void
#define T_32PVOID       0x0403      // 16:32 near pointer to void
#define T_32PFVOID      0x0503      // 16:32 far pointer to void
#define T_64PVOID       0x0603      // 64 bit pointer to void
#define T_CURRENCY      0x0004      // BASIC 8 byte currency value
#define T_NBASICSTR     0x0005      // Near BASIC string
#define T_FBASICSTR     0x0006      // Far BASIC string
#define T_NOTTRANS      0x0007      // type not translated by cvpack
#define T_BIT           0x0060      // bit
#define T_PASCHAR       0x0061      // Pascal CHAR



//      Character types


#define T_CHAR          0x0010      // 8 bit signed
#define T_UCHAR         0x0020      // 8 bit unsigned
#define T_PCHAR         0x0110      // near pointer to 8 bit signed
#define T_PUCHAR        0x0120      // near pointer to 8 bit unsigned
#define T_PFCHAR        0x0210      // far pointer to 8 bit signed
#define T_PFUCHAR       0x0220      // far pointer to 8 bit unsigned
#define T_PHCHAR        0x0310      // huge pointer to 8 bit signed
#define T_PHUCHAR       0x0320      // huge pointer to 8 bit unsigned
#define T_32PCHAR       0x0410      // 16:32 near pointer to 8 bit signed
#define T_32PUCHAR      0x0420      // 16:32 near pointer to 8 bit unsigned
#define T_32PFCHAR      0x0510      // 16:32 far pointer to 8 bit signed
#define T_32PFUCHAR     0x0520      // 16:32 far pointer to 8 bit unsigned
#define T_64PCHAR       0X0610      // 64 bit pointer to 8 bit signed
#define T_64PUCHAR      0X0620      // 64 bit pointer to 8 bit unsigned




//      really a character types

#define T_RCHAR         0x0070      // really a char
#define T_PRCHAR        0x0170      // 16:16 near pointer to a real char
#define T_PFRCHAR       0x0270      // 16:16 far pointer to a real char
#define T_PHRCHAR       0x0370      // 16:16 huge pointer to a real char
#define T_32PRCHAR      0x0470      // 16:32 near pointer to a real char
#define T_32PFRCHAR     0x0570      // 16:32 far pointer to a real char
#define T_64PRCHAR      0x0670      // 64 bit pointer to a real char



//      really a wide character types

#define T_WCHAR         0x0071      // wide char
#define T_PWCHAR        0x0171      // 16:16 near pointer to a wide char
#define T_PFWCHAR       0x0271      // 16:16 far pointer to a wide char
#define T_PHWCHAR       0x0371      // 16:16 huge pointer to a wide char
#define T_32PWCHAR      0x0471      // 16:32 near pointer to a wide char
#define T_32PFWCHAR     0x0571      // 16:32 far pointer to a wide char
#define T_64PWCHAR      0x0671      // 64 bit pointer to a wide char


//      8 bit int types


#define T_INT1          0x0068      // 8 bit signed int
#define T_UINT1         0x0069      // 8 bit unsigned int
#define T_PINT1         0x0168      // near pointer to 8 bit signed int
#define T_PUINT1        0x0169      // near pointer to 8 bit unsigned int
#define T_PFINT1        0x0268      // far pointer to 8 bit signed int
#define T_PFUINT1       0x0269      // far pointer to 8 bit unsigned int
#define T_PHINT1        0x0368      // huge pointer to 8 bit signed int
#define T_PHUINT1       0x0369      // huge pointer to 8 bit unsigned int

#define T_32PINT1       0x0468      // 16:32 near pointer to 8 bit signed int
#define T_32PUINT1      0x0469      // 16:32 near pointer to 8 bit unsigned int
#define T_32PFINT1      0x0568      // 16:32 far pointer to 8 bit signed int
#define T_32PFUINT1     0x0569      // 16:32 far pointer to 8 bit unsigned int
#define T_64PINT1       0x0668      // 64 bit pointer to 8 bit signed int
#define T_64PUINT1      0x0669      // 64 bit pointer to 8 bit unsigned int


//      16 bit short types


#define T_SHORT         0x0011      // 16 bit signed
#define T_USHORT        0x0021      // 16 bit unsigned
#define T_PSHORT        0x0111      // near pointer to 16 bit signed
#define T_PUSHORT       0x0121      // near pointer to 16 bit unsigned
#define T_PFSHORT       0x0211      // far pointer to 16 bit signed
#define T_PFUSHORT      0x0221      // far pointer to 16 bit unsigned
#define T_PHSHORT       0x0311      // huge pointer to 16 bit signed
#define T_PHUSHORT      0x0321      // huge pointer to 16 bit unsigned

#define T_32PSHORT      0x0411      // 16:32 near pointer to 16 bit signed
#define T_32PUSHORT     0x0421      // 16:32 near pointer to 16 bit unsigned
#define T_32PFSHORT     0x0511      // 16:32 far pointer to 16 bit signed
#define T_32PFUSHORT    0x0521      // 16:32 far pointer to 16 bit unsigned
#define T_64PSHORT      0x0611      // 64 bit pointer to 16 bit signed
#define T_64PUSHORT     0x0621      // 64 bit pointer to 16 bit unsigned




//      16 bit int types


#define T_INT2          0x0072      // 16 bit signed int
#define T_UINT2         0x0073      // 16 bit unsigned int
#define T_PINT2         0x0172      // near pointer to 16 bit signed int
#define T_PUINT2        0x0173      // near pointer to 16 bit unsigned int
#define T_PFINT2        0x0272      // far pointer to 16 bit signed int
#define T_PFUINT2       0x0273      // far pointer to 16 bit unsigned int
#define T_PHINT2        0x0372      // huge pointer to 16 bit signed int
#define T_PHUINT2       0x0373      // huge pointer to 16 bit unsigned int

#define T_32PINT2       0x0472      // 16:32 near pointer to 16 bit signed int
#define T_32PUINT2      0x0473      // 16:32 near pointer to 16 bit unsigned int
#define T_32PFINT2      0x0572      // 16:32 far pointer to 16 bit signed int
#define T_32PFUINT2     0x0573      // 16:32 far pointer to 16 bit unsigned int
#define T_64PINT2       0x0672      // 64 bit pointer to 16 bit signed int
#define T_64PUINT2      0x0673      // 64 bit pointer to 16 bit unsigned int




//      32 bit long types


#define T_LONG          0x0012      // 32 bit signed
#define T_ULONG         0x0022      // 32 bit unsigned
#define T_PLONG         0x0112      // near pointer to 32 bit signed
#define T_PULONG        0x0122      // near pointer to 32 bit unsigned
#define T_PFLONG        0x0212      // far pointer to 32 bit signed
#define T_PFULONG       0x0222      // far pointer to 32 bit unsigned
#define T_PHLONG        0x0312      // huge pointer to 32 bit signed
#define T_PHULONG       0x0322      // huge pointer to 32 bit unsigned

#define T_32PLONG       0x0412      // 16:32 near pointer to 32 bit signed
#define T_32PULONG      0x0422      // 16:32 near pointer to 32 bit unsigned
#define T_32PFLONG      0x0512      // 16:32 far pointer to 32 bit signed
#define T_32PFULONG     0x0522      // 16:32 far pointer to 32 bit unsigned
#define T_64PLONG       0x0612      // 64 bit pointer to 32 bit signed
#define T_64PULONG      0x0622      // 64 bit pointer to 32 bit unsigned




//      32 bit int types


#define T_INT4          0x0074      // 32 bit signed int
#define T_UINT4         0x0075      // 32 bit unsigned int
#define T_PINT4         0x0174      // near pointer to 32 bit signed int
#define T_PUINT4        0x0175      // near pointer to 32 bit unsigned int
#define T_PFINT4        0x0274      // far pointer to 32 bit signed int
#define T_PFUINT4       0x0275      // far pointer to 32 bit unsigned int
#define T_PHINT4        0x0374      // huge pointer to 32 bit signed int
#define T_PHUINT4       0x0375      // huge pointer to 32 bit unsigned int

#define T_32PINT4       0x0474      // 16:32 near pointer to 32 bit signed int
#define T_32PUINT4      0x0475      // 16:32 near pointer to 32 bit unsigned int
#define T_32PFINT4      0x0574      // 16:32 far pointer to 32 bit signed int
#define T_32PFUINT4     0x0575      // 16:32 far pointer to 32 bit unsigned int
#define T_64PINT4       0x0674      // 64 bit pointer to 32 bit signed int
#define T_64PUINT4      0x0675      // 64 bit pointer to 32 bit unsigned int




//      64 bit quad types


#define T_QUAD          0x0013      // 64 bit signed
#define T_UQUAD         0x0023      // 64 bit unsigned
#define T_PQUAD         0x0113      // near pointer to 64 bit signed
#define T_PUQUAD        0x0123      // near pointer to 64 bit unsigned
#define T_PFQUAD        0x0213      // far pointer to 64 bit signed
#define T_PFUQUAD       0x0223      // far pointer to 64 bit unsigned
#define T_PHQUAD        0x0313      // huge pointer to 64 bit signed
#define T_PHUQUAD       0x0323      // huge pointer to 64 bit unsigned
#define T_32PQUAD       0x0413      // 16:32 near pointer to 64 bit signed
#define T_32PUQUAD      0x0423      // 16:32 near pointer to 64 bit unsigned
#define T_32PFQUAD      0x0513      // 16:32 far pointer to 64 bit signed
#define T_32PFUQUAD     0x0523      // 16:32 far pointer to 64 bit unsigned
#define T_64PQUAD       0x0613      // 64 bit pointer to 64 bit signed
#define T_64PUQUAD      0x0623      // 64 bit pointer to 64 bit unsigned



//      64 bit int types


#define T_INT8          0x0076      // 64 bit signed int
#define T_UINT8         0x0077      // 64 bit unsigned int
#define T_PINT8         0x0176      // near pointer to 64 bit signed int
#define T_PUINT8        0x0177      // near pointer to 64 bit unsigned int
#define T_PFINT8        0x0276      // far pointer to 64 bit signed int
#define T_PFUINT8       0x0277      // far pointer to 64 bit unsigned int
#define T_PHINT8        0x0376      // huge pointer to 64 bit signed int
#define T_PHUINT8       0x0377      // huge pointer to 64 bit unsigned int

#define T_32PINT8       0x0476      // 16:32 near pointer to 64 bit signed int
#define T_32PUINT8      0x0477      // 16:32 near pointer to 64 bit unsigned int
#define T_32PFINT8      0x0576      // 16:32 far pointer to 64 bit signed int
#define T_32PFUINT8     0x0577      // 16:32 far pointer to 64 bit unsigned int
#define T_64PINT8       0x0676      // 64 bit pointer to 64 bit signed int
#define T_64PUINT8      0x0677      // 64 bit pointer to 64 bit unsigned int


//      128 bit octet types


#define T_OCT           0x0014      // 128 bit signed
#define T_UOCT          0x0024      // 128 bit unsigned
#define T_POCT          0x0114      // near pointer to 128 bit signed
#define T_PUOCT         0x0124      // near pointer to 128 bit unsigned
#define T_PFOCT         0x0214      // far pointer to 128 bit signed
#define T_PFUOCT        0x0224      // far pointer to 128 bit unsigned
#define T_PHOCT         0x0314      // huge pointer to 128 bit signed
#define T_PHUOCT        0x0324      // huge pointer to 128 bit unsigned

#define T_32POCT        0x0414      // 16:32 near pointer to 128 bit signed
#define T_32PUOCT       0x0424      // 16:32 near pointer to 128 bit unsigned
#define T_32PFOCT       0x0514      // 16:32 far pointer to 128 bit signed
#define T_32PFUOCT      0x0524      // 16:32 far pointer to 128 bit unsigned
#define T_64POCT        0x0614      // 64 bit pointer to 128 bit signed
#define T_64PUOCT       0x0624      // 64 bit pointer to 128 bit unsigned

//      128 bit int types


#define T_INT16         0x0078      // 128 bit signed int
#define T_UINT16        0x0079      // 128 bit unsigned int
#define T_PINT16        0x0178      // near pointer to 128 bit signed int
#define T_PUINT16       0x0179      // near pointer to 128 bit unsigned int
#define T_PFINT16       0x0278      // far pointer to 128 bit signed int
#define T_PFUINT16      0x0279      // far pointer to 128 bit unsigned int
#define T_PHINT16       0x0378      // huge pointer to 128 bit signed int
#define T_PHUINT16      0x0379      // huge pointer to 128 bit unsigned int

#define T_32PINT16      0x0478      // 16:32 near pointer to 128 bit signed int
#define T_32PUINT16     0x0479      // 16:32 near pointer to 128 bit unsigned int
#define T_32PFINT16     0x0578      // 16:32 far pointer to 128 bit signed int
#define T_32PFUINT16    0x0579      // 16:32 far pointer to 128 bit unsigned int
#define T_64PINT16      0x0678      // 64 bit pointer to 128 bit signed int
#define T_64PUINT16     0x0679      // 64 bit pointer to 128 bit unsigned int





//      32 bit real types


#define T_REAL32        0x0040      // 32 bit real
#define T_PREAL32       0x0140      // near pointer to 32 bit real
#define T_PFREAL32      0x0240      // far pointer to 32 bit real
#define T_PHREAL32      0x0340      // huge pointer to 32 bit real
#define T_32PREAL32     0x0440      // 16:32 near pointer to 32 bit real
#define T_32PFREAL32    0x0540      // 16:32 far pointer to 32 bit real
#define T_64PREAL32     0x0640      // 64 bit pointer to 32 bit real



//      48 bit real types


#define T_REAL48        0x0044      // 48 bit real
#define T_PREAL48       0x0144      // near pointer to 48 bit real
#define T_PFREAL48      0x0244      // far pointer to 48 bit real
#define T_PHREAL48      0x0344      // huge pointer to 48 bit real
#define T_32PREAL48     0x0444      // 16:32 near pointer to 48 bit real
#define T_32PFREAL48    0x0544      // 16:32 far pointer to 48 bit real
#define T_64PREAL48     0x0644      // 64 bit pointer to 48 bit real




//      64 bit real types


#define T_REAL64        0x0041      // 64 bit real
#define T_PREAL64       0x0141      // near pointer to 64 bit real
#define T_PFREAL64      0x0241      // far pointer to 64 bit real
#define T_PHREAL64      0x0341      // huge pointer to 64 bit real
#define T_32PREAL64     0x0441      // 16:32 near pointer to 64 bit real
#define T_32PFREAL64    0x0541      // 16:32 far pointer to 64 bit real
#define T_64PREAL64     0x0641      // 64 bit pointer to 64 bit real




//      80 bit real types


#define T_REAL80        0x0042      // 80 bit real
#define T_PREAL80       0x0142      // near pointer to 80 bit real
#define T_PFREAL80      0x0242      // far pointer to 80 bit real
#define T_PHREAL80      0x0342      // huge pointer to 80 bit real
#define T_32PREAL80     0x0442      // 16:32 near pointer to 80 bit real
#define T_32PFREAL80    0x0542      // 16:32 far pointer to 80 bit real
#define T_64PREAL80     0x0642      // 64 bit pointer to 80 bit real




//      128 bit real types


#define T_REAL128       0x0043      // 128 bit real
#define T_PREAL128      0x0143      // near pointer to 128 bit real
#define T_PFREAL128     0x0243      // far pointer to 128 bit real
#define T_PHREAL128     0x0343      // huge pointer to 128 bit real
#define T_32PREAL128    0x0443      // 16:32 near pointer to 128 bit real
#define T_32PFREAL128   0x0543      // 16:32 far pointer to 128 bit real
#define T_64PREAL128    0x0643      // 64 bit pointer to 128 bit real




//      32 bit complex types


#define T_CPLX32        0x0050      // 32 bit complex
#define T_PCPLX32       0x0150      // near pointer to 32 bit complex
#define T_PFCPLX32      0x0250      // far pointer to 32 bit complex
#define T_PHCPLX32      0x0350      // huge pointer to 32 bit complex
#define T_32PCPLX32     0x0450      // 16:32 near pointer to 32 bit complex
#define T_32PFCPLX32    0x0550      // 16:32 far pointer to 32 bit complex
#define T_64PCPLX32     0x0650      // 64 bit pointer to 32 bit complex




//      64 bit complex types


#define T_CPLX64        0x0051      // 64 bit complex
#define T_PCPLX64       0x0151      // near pointer to 64 bit complex
#define T_PFCPLX64      0x0251      // far pointer to 64 bit complex
#define T_PHCPLX64      0x0351      // huge pointer to 64 bit complex
#define T_32PCPLX64     0x0451      // 16:32 near pointer to 64 bit complex
#define T_32PFCPLX64    0x0551      // 16:32 far pointer to 64 bit complex
#define T_64PCPLX64     0x0651      // 64 bit pointer to 64 bit complex




//      80 bit complex types


#define T_CPLX80        0x0052      // 80 bit complex
#define T_PCPLX80       0x0152      // near pointer to 80 bit complex
#define T_PFCPLX80      0x0252      // far pointer to 80 bit complex
#define T_PHCPLX80      0x0352      // huge pointer to 80 bit complex
#define T_32PCPLX80     0x0452      // 16:32 near pointer to 80 bit complex
#define T_32PFCPLX80    0x0552      // 16:32 far pointer to 80 bit complex
#define T_64PCPLX80     0x0652      // 64 bit pointer to 80 bit complex




//      128 bit complex types


#define T_CPLX128       0x0053      // 128 bit complex
#define T_PCPLX128      0x0153      // near pointer to 128 bit complex
#define T_PFCPLX128     0x0253      // far pointer to 128 bit complex
#define T_PHCPLX128     0x0353      // huge pointer to 128 bit real
#define T_32PCPLX128    0x0453      // 16:32 near pointer to 128 bit complex
#define T_32PFCPLX128   0x0553      // 16:32 far pointer to 128 bit complex
#define T_64PCPLX128    0x0653      // 64 bit pointer to 128 bit complex




//      boolean types


#define T_BOOL08        0x0030      // 8 bit boolean
#define T_BOOL16        0x0031      // 16 bit boolean
#define T_BOOL32        0x0032      // 32 bit boolean
#define T_BOOL64        0x0033      // 64 bit boolean
#define T_PBOOL08       0x0130      // near pointer to  8 bit boolean
#define T_PBOOL16       0x0131      // near pointer to 16 bit boolean
#define T_PBOOL32       0x0132      // near pointer to 32 bit boolean
#define T_PBOOL64       0x0133      // near pointer to 64 bit boolean
#define T_PFBOOL08      0x0230      // far pointer to  8 bit boolean
#define T_PFBOOL16      0x0231      // far pointer to 16 bit boolean
#define T_PFBOOL32      0x0232      // far pointer to 32 bit boolean
#define T_PFBOOL64      0x0233      // far pointer to 64 bit boolean
#define T_PHBOOL08      0x0330      // huge pointer to  8 bit boolean
#define T_PHBOOL16      0x0331      // huge pointer to 16 bit boolean
#define T_PHBOOL32      0x0332      // huge pointer to 32 bit boolean
#define T_PHBOOL64      0x0333      // huge pointer to 64 bit boolean

#define T_32PBOOL08     0x0430      // 16:32 near pointer to 8 bit boolean
#define T_32PFBOOL08    0x0530      // 16:32 far pointer to 8 bit boolean
#define T_32PBOOL16     0x0431      // 16:32 near pointer to 18 bit boolean
#define T_32PFBOOL16    0x0531      // 16:32 far pointer to 16 bit boolean
#define T_32PBOOL32     0x0432      // 16:32 near pointer to 32 bit boolean
#define T_32PFBOOL32    0x0532      // 16:32 far pointer to 32 bit boolean
#define T_32PBOOL64     0x0433      // 16:32 near pointer to 64 bit boolean
#define T_32PFBOOL64    0x0533      // 16:32 far pointer to 64 bit boolean

#define T_64PBOOL08     0x0630      // 64 bit pointer to 8 bit boolean
#define T_64PBOOL16     0x0631      // 64 bit pointer to 18 bit boolean
#define T_64PBOOL32     0x0632      // 64 bit pointer to 32 bit boolean
#define T_64PBOOL64     0x0633      // 64 bit pointer to 64 bit boolean


#define T_NCVPTR        0x01f0      // CV Internal type for created near pointers
#define T_FCVPTR        0x02f0      // CV Internal type for created far pointers
#define T_HCVPTR        0x03f0      // CV Internal type for created huge pointers
#define T_32NCVPTR      0x04f0      // CV Internal type for created near 32-bit pointers
#define T_32FCVPTR      0x05f0      // CV Internal type for created far 32-bit pointers
#define T_64NCVPTR      0x06f0      // CV Internal type for created near 64-bit pointers

#define CV_IS_INTERNAL_PTR(typ) (CV_IS_PRIMITIVE(typ) && \
                                 CV_TYPE(typ) == CV_CVRESERVED && \
                                 CV_TYP_IS_PTR(typ))


/**     No leaf index can have a value of 0x0000.  The leaf indices are
 *      separated into ranges depending upon the use of the type record.
 *      The second range is for the type records that are directly referenced
 *      in symbols. The first range is for type records that are not
 *      referenced by symbols but instead are referenced by other type
 *      records.  All type records must have a starting leaf index in these
 *      first two ranges.  The third range of leaf indices are used to build
 *      up complex lists such as the field list of a class type record.  No
 *      type record can begin with one of the leaf indices. The fourth ranges
 *      of type indices are used to represent numeric data in a symbol or
 *      type record. These leaf indices are greater than 0x8000.  At the
 *      point that type or symbol processor is expecting a numeric field, the
 *      next two bytes in the type record are examined.  If the value is less
 *      than 0x8000, then the two bytes contain the numeric value.  If the
 *      value is greater than 0x8000, then the data follows the leaf index in
 *      a format specified by the leaf index. The final range of leaf indices
 *      are used to force alignment of subfields within a complex type record..
 */



    // leaf indices starting records but referenced from symbol records

#define LF_MODIFIER_16t     0x0001
#define LF_POINTER_16t      0x0002
#define LF_ARRAY_16t        0x0003
#define LF_CLASS_16t        0x0004
#define LF_STRUCTURE_16t    0x0005
#define LF_UNION_16t        0x0006
#define LF_ENUM_16t         0x0007
#define LF_PROCEDURE_16t    0x0008
#define LF_MFUNCTION_16t    0x0009
#define LF_VTSHAPE          0x000a
#define LF_COBOL0_16t       0x000b
#define LF_COBOL1           0x000c
#define LF_BARRAY_16t       0x000d
#define LF_LABEL            0x000e
#define LF_NULL             0x000f
#define LF_NOTTRAN          0x0010
#define LF_DIMARRAY_16t     0x0011
#define LF_VFTPATH_16t      0x0012
#define LF_PRECOMP_16t      0x0013      // not referenced from symbol
#define LF_ENDPRECOMP       0x0014      // not referenced from symbol
#define LF_OEM_16t          0x0015      // oem definable type string
#define LF_TYPESERVER       0x0016      // not referenced from symbol

    // leaf indices starting records but referenced only from type records

#define LF_SKIP_16t         0x0200
#define LF_ARGLIST_16t      0x0201
#define LF_DEFARG_16t       0x0202
#define LF_LIST             0x0203
#define LF_FIELDLIST_16t    0x0204
#define LF_DERIVED_16t      0x0205
#define LF_BITFIELD_16t     0x0206
#define LF_METHODLIST_16t   0x0207
#define LF_DIMCONU_16t      0x0208
#define LF_DIMCONLU_16t     0x0209
#define LF_DIMVARU_16t      0x020a
#define LF_DIMVARLU_16t     0x020b
#define LF_REFSYM           0x020c
                            
#define LF_BCLASS_16t       0x0400
#define LF_VBCLASS_16t      0x0401
#define LF_IVBCLASS_16t     0x0402
#define LF_ENUMERATE        0x0403
#define LF_FRIENDFCN_16t    0x0404
#define LF_INDEX_16t        0x0405
#define LF_MEMBER_16t       0x0406
#define LF_STMEMBER_16t     0x0407
#define LF_METHOD_16t       0x0408
#define LF_NESTTYPE_16t     0x0409
#define LF_VFUNCTAB_16t     0x040a
#define LF_FRIENDCLS_16t    0x040b
#define LF_ONEMETHOD_16t    0x040c
#define LF_VFUNCOFF_16t     0x040d

// 32-bit type index versions of leaves, all have the 0x1000 bit set
//
#define LF_TI16_MAX         0x1000

#define LF_MODIFIER         0x1001
#define LF_POINTER          0x1002
#define LF_ARRAY            0x1003
#define LF_CLASS            0x1004
#define LF_STRUCTURE        0x1005
#define LF_UNION            0x1006
#define LF_ENUM             0x1007
#define LF_PROCEDURE        0x1008
#define LF_MFUNCTION        0x1009
#define LF_COBOL0           0x100a
#define LF_BARRAY           0x100b
#define LF_DIMARRAY         0x100c
#define LF_VFTPATH          0x100d
#define LF_PRECOMP          0x100e      // not referenced from symbol
#define LF_OEM              0x100f      // oem definable type string
                            
    // leaf indices starting records but referenced only from type records
                            
#define LF_SKIP             0x1200
#define LF_ARGLIST          0x1201
#define LF_DEFARG           0x1202
#define LF_FIELDLIST        0x1203
#define LF_DERIVED          0x1204
#define LF_BITFIELD         0x1205
#define LF_METHODLIST       0x1206
#define LF_DIMCONU          0x1207
#define LF_DIMCONLU         0x1208
#define LF_DIMVARU          0x1209
#define LF_DIMVARLU         0x120a
                            
#define LF_BCLASS           0x1400
#define LF_VBCLASS          0x1401
#define LF_IVBCLASS         0x1402
#define LF_FRIENDFCN        0x1403
#define LF_INDEX            0x1404
#define LF_MEMBER           0x1405
#define LF_STMEMBER         0x1406
#define LF_METHOD           0x1407
#define LF_NESTTYPE         0x1408
#define LF_VFUNCTAB         0x1409
#define LF_FRIENDCLS        0x140a
#define LF_ONEMETHOD        0x140b
#define LF_VFUNCOFF         0x140c
#define LF_NESTTYPEEX       0x140d
#define LF_MEMBERMODIFY     0x140e




#define LF_NUMERIC          0x8000
#define LF_CHAR             0x8000
#define LF_SHORT            0x8001
#define LF_USHORT           0x8002
#define LF_LONG             0x8003
#define LF_ULONG            0x8004
#define LF_REAL32           0x8005
#define LF_REAL64           0x8006
#define LF_REAL80           0x8007
#define LF_REAL128          0x8008
#define LF_QUADWORD         0x8009
#define LF_UQUADWORD        0x800a
#define LF_REAL48           0x800b
#define LF_COMPLEX32        0x800c
#define LF_COMPLEX64        0x800d
#define LF_COMPLEX80        0x800e
#define LF_COMPLEX128       0x800f
#define LF_VARSTRING        0x8010
                            
#define LF_OCTWORD          0x8017
#define LF_UOCTWORD         0x8018
                            
#define LF_PAD0             0xf0
#define LF_PAD1             0xf1
#define LF_PAD2             0xf2
#define LF_PAD3             0xf3
#define LF_PAD4             0xf4
#define LF_PAD5             0xf5
#define LF_PAD6             0xf6
#define LF_PAD7             0xf7
#define LF_PAD8             0xf8
#define LF_PAD9             0xf9
#define LF_PAD10            0xfa
#define LF_PAD11            0xfb
#define LF_PAD12            0xfc
#define LF_PAD13            0xfd
#define LF_PAD14            0xfe
#define LF_PAD15            0xff

// end of leaf indices




//      Type enum for pointer records
//      Pointers can be one of the following types


typedef enum CV_ptrtype_e {
    CV_PTR_NEAR         = 0x00, // near pointer
    CV_PTR_FAR          = 0x01, // far pointer
    CV_PTR_HUGE         = 0x02, // huge pointer
    CV_PTR_BASE_SEG     = 0x03, // based on segment
    CV_PTR_BASE_VAL     = 0x04, // based on value of base
    CV_PTR_BASE_SEGVAL  = 0x05, // based on segment value of base
    CV_PTR_BASE_ADDR    = 0x06, // based on address of base
    CV_PTR_BASE_SEGADDR = 0x07, // based on segment address of base
    CV_PTR_BASE_TYPE    = 0x08, // based on type
    CV_PTR_BASE_SELF    = 0x09, // based on self
    CV_PTR_NEAR32       = 0x0a, // 16:32 near pointer
    CV_PTR_FAR32        = 0x0b, // 16:32 far pointer
    CV_PTR_64           = 0x0c, // 64 bit pointer
    CV_PTR_UNUSEDPTR    = 0x0d  // first unused pointer type
} CV_ptrtype_e;





//      Mode enum for pointers
//      Pointers can have one of the following modes


typedef enum CV_ptrmode_e {
    CV_PTR_MODE_PTR     = 0x00, // "normal" pointer
    CV_PTR_MODE_REF     = 0x01, // reference
    CV_PTR_MODE_PMEM    = 0x02, // pointer to data member
    CV_PTR_MODE_PMFUNC  = 0x03, // pointer to member function
    CV_PTR_MODE_RESERVED= 0x04  // first unused pointer mode
} CV_ptrmode_e;




//      Enumeration for function call type


typedef enum CV_call_e {
    CV_CALL_NEAR_C      = 0x00, // near right to left push, caller pops stack
    CV_CALL_FAR_C       = 0x01, // far right to left push, caller pops stack
    CV_CALL_NEAR_PASCAL = 0x02, // near left to right push, callee pops stack
    CV_CALL_FAR_PASCAL  = 0x03, // far left to right push, callee pops stack
    CV_CALL_NEAR_FAST   = 0x04, // near left to right push with regs, callee pops stack
    CV_CALL_FAR_FAST    = 0x05, // far left to right push with regs, callee pops stack
    CV_CALL_SKIPPED     = 0x06, // skipped (unused) call index
    CV_CALL_NEAR_STD    = 0x07, // near standard call
    CV_CALL_FAR_STD     = 0x08, // far standard call
    CV_CALL_NEAR_SYS    = 0x09, // near sys call
    CV_CALL_FAR_SYS     = 0x0a, // far sys call
    CV_CALL_THISCALL    = 0x0b, // this call (this passed in register)
    CV_CALL_MIPSCALL    = 0x0c, // Mips call
    CV_CALL_GENERIC     = 0x0d, // Generic call sequence
    CV_CALL_ALPHACALL   = 0x0e, // Alpha call
    CV_CALL_PPCCALL     = 0x0f, // PPC call
    CV_CALL_RESERVED    = 0x10  // first unused call enumeration
} CV_call_e;




//      Values for the access protection of class attributes


typedef enum CV_access_e {
    CV_private   = 1,
    CV_protected = 2,
    CV_public    = 3
} CV_access_e;



//      enumeration for method properties

typedef enum CV_methodprop_e {
    CV_MTvanilla        = 0x00,
    CV_MTvirtual        = 0x01,
    CV_MTstatic         = 0x02,
    CV_MTfriend         = 0x03,
    CV_MTintro          = 0x04,
    CV_MTpurevirt       = 0x05,
    CV_MTpureintro      = 0x06
} CV_methodprop_e;




//      enumeration for virtual shape table entries

typedef enum CV_VTS_desc_e {
    CV_VTS_near         = 0x00,
    CV_VTS_far          = 0x01,
    CV_VTS_thin         = 0x02,
    CV_VTS_outer        = 0x03,
    CV_VTS_meta         = 0x04,
    CV_VTS_near32       = 0x05,
    CV_VTS_far32        = 0x06,
    CV_VTS_unused       = 0x07
} CV_VTS_desc_e;




//      enumeration for LF_LABEL address modes

typedef enum CV_LABEL_TYPE_e {
    CV_LABEL_NEAR = 0,       // near return
    CV_LABEL_FAR  = 4        // far return
} CV_LABEL_TYPE_e;



//      enumeration for LF_MODIFIER values


typedef struct CV_modifier_t {
    unsigned short  MOD_const       :1;
    unsigned short  MOD_volatile    :1;
    unsigned short  MOD_unaligned   :1;
    unsigned short  MOD_unused      :13;
} CV_modifier_t;


//  bit field structure describing class/struct/union/enum properties

typedef struct CV_prop_t {
    unsigned short  packed      :1;     // true if structure is packed
    unsigned short  ctor        :1;     // true if constructors or destructors present
    unsigned short  ovlops      :1;     // true if overloaded operators present
    unsigned short  isnested    :1;     // true if this is a nested class
    unsigned short  cnested     :1;     // true if this class contains nested types
    unsigned short  opassign    :1;     // true if overloaded assignment (=)
    unsigned short  opcast      :1;     // true if casting methods
    unsigned short  fwdref      :1;     // true if forward reference (incomplete defn)
    unsigned short  scoped      :1;     // scoped definition
    unsigned short  reserved    :7;
} CV_prop_t;




//  class field attribute

typedef struct CV_fldattr_t {
    unsigned short  access      :2;     // access protection CV_access_t
    unsigned short  mprop       :3;     // method properties CV_methodprop_t
    unsigned short  pseudo      :1;     // compiler generated fcn and does not exist
    unsigned short  noinherit   :1;     // true if class cannot be inherited
    unsigned short  noconstruct :1;     // true if class cannot be constructed
    unsigned short  compgenx    :1;     // compiler generated fcn and does exist
    unsigned short  unused      :7;     // unused
} CV_fldattr_t;



//  Structures to access to the type records


typedef struct TYPTYPE {
    unsigned short  len;
    unsigned short  leaf;
    unsigned char   data[CV_ZEROLEN];
} TYPTYPE;          // general types record


__INLINE char *NextType (char * pType) {
    return (pType + ((TYPTYPE *)pType)->len + sizeof(unsigned short));
}

typedef enum CV_PMEMBER {
    CV_PDM16_NONVIRT    = 0x00, // 16:16 data no virtual fcn or base
    CV_PDM16_VFCN       = 0x01, // 16:16 data with virtual functions
    CV_PDM16_VBASE      = 0x02, // 16:16 data with virtual bases
    CV_PDM32_NVVFCN     = 0x03, // 16:32 data w/wo virtual functions
    CV_PDM32_VBASE      = 0x04, // 16:32 data with virtual bases

    CV_PMF16_NEARNVSA   = 0x05, // 16:16 near method nonvirtual single address point
    CV_PMF16_NEARNVMA   = 0x06, // 16:16 near method nonvirtual multiple address points
    CV_PMF16_NEARVBASE  = 0x07, // 16:16 near method virtual bases
    CV_PMF16_FARNVSA    = 0x08, // 16:16 far method nonvirtual single address point
    CV_PMF16_FARNVMA    = 0x09, // 16:16 far method nonvirtual multiple address points
    CV_PMF16_FARVBASE   = 0x0a, // 16:16 far method virtual bases

    CV_PMF32_NVSA       = 0x0b, // 16:32 method nonvirtual single address point
    CV_PMF32_NVMA       = 0x0c, // 16:32 method nonvirtual multiple address point
    CV_PMF32_VBASE      = 0x0d  // 16:32 method virtual bases
} CV_PMEMBER;



//  memory representation of pointer to member.  These representations are
//  indexed by the enumeration above in the LF_POINTER record




//  representation of a 16:16 pointer to data for a class with no
//  virtual functions or virtual bases


struct CV_PDMR16_NONVIRT {
    CV_off16_t      mdisp;      // displacement to data (NULL = -1)
};




//  representation of a 16:16 pointer to data for a class with virtual
//  functions


struct CV_PMDR16_VFCN {
    CV_off16_t      mdisp;      // displacement to data ( NULL = 0)
};




//  representation of a 16:16 pointer to data for a class with
//  virtual bases


struct CV_PDMR16_VBASE {
    CV_off16_t      mdisp;      // displacement to data
    CV_off16_t      pdisp;      // this pointer displacement to vbptr
    CV_off16_t      vdisp;      // displacement within vbase table
                                // NULL = (,,0xffff)
};




//  representation of a 16:32 near pointer to data for a class with
//  or without virtual functions and no virtual bases


struct CV_PDMR32_NVVFCN {
    CV_off32_t      mdisp;      // displacement to data (NULL = 0x80000000)
};




//  representation of a 16:32 near pointer to data for a class
//  with virtual bases


struct CV_PDMR32_VBASE {
    CV_off32_t      mdisp;      // displacement to data
    CV_off32_t      pdisp;      // this pointer displacement
    CV_off32_t      vdisp;      // vbase table displacement
                                // NULL = (,,0xffffffff)
};




//  representation of a 16:16 pointer to near member function for a
//  class with no virtual functions or bases and a single address point


struct CV_PMFR16_NEARNVSA {
    CV_uoff16_t     off;        // near address of function (NULL = 0)
};



//  representation of a 16:16 near pointer to member functions of a
//  class with no virtual bases and multiple address points


struct CV_PMFR16_NEARNVMA {
    CV_uoff16_t     off;        // offset of function (NULL = 0,x)
    signed short    disp;
};




//  representation of a 16:16 near pointer to member function of a
//  class with virtual bases


struct CV_PMFR16_NEARVBASE {
    CV_uoff16_t     off;        // offset of function (NULL = 0,x,x,x)
    CV_off16_t      mdisp;      // displacement to data
    CV_off16_t      pdisp;      // this pointer displacement
    CV_off16_t      vdisp;      // vbase table displacement
};




//  representation of a 16:16 pointer to far member function for a
//  class with no virtual bases and a single address point


struct CV_PMFR16_FARNVSA {
    CV_uoff16_t     off;        // offset of function (NULL = 0:0)
    unsigned short  seg;        // segment of function
};




//  representation of a 16:16 far pointer to member functions of a
//  class with no virtual bases and multiple address points


struct CV_PMFR16_FARNVMA {
    CV_uoff16_t     off;        // offset of function (NULL = 0:0,x)
    unsigned short  seg;
    signed short    disp;
};




//  representation of a 16:16 far pointer to member function of a
//  class with virtual bases


struct CV_PMFR16_FARVBASE {
    CV_uoff16_t     off;        // offset of function (NULL = 0:0,x,x,x)
    unsigned short  seg;
    CV_off16_t      mdisp;      // displacement to data
    CV_off16_t      pdisp;      // this pointer displacement
    CV_off16_t      vdisp;      // vbase table displacement

};




//  representation of a 16:32 near pointer to member function for a
//  class with no virtual bases and a single address point


struct CV_PMFR32_NVSA {
    CV_uoff32_t      off;        // near address of function (NULL = 0L)
};




//  representation of a 16:32 near pointer to member function for a
//  class with no virtual bases and multiple address points


struct CV_PMFR32_NVMA {
    CV_uoff32_t     off;        // near address of function (NULL = 0L,x)
    CV_off32_t      disp;
};




//  representation of a 16:32 near pointer to member function for a
//  class with virtual bases


struct CV_PMFR32_VBASE {
    CV_uoff32_t     off;        // near address of function (NULL = 0L,x,x,x)
    CV_off32_t      mdisp;      // displacement to data
    CV_off32_t      pdisp;      // this pointer displacement
    CV_off32_t      vdisp;      // vbase table displacement
};





//  Easy leaf - used for generic casting to reference leaf field
//  of a subfield of a complex list

typedef struct lfEasy {
    unsigned short  leaf;           // LF_...
} lfEasy;


/**     The following type records are basically variant records of the
 *      above structure.  The "unsigned short leaf" of the above structure and
 *      the "unsigned short leaf" of the following type definitions are the same
 *      symbol.  When the OMF record is locked via the MHOMFLock API
 *      call, the address of the "unsigned short leaf" is returned
 */

/**		Notes on alignment
 *		Alignment of the fields in most of the type records is done on the 
 *		basis of the TYPTYPE record base.  That is why in most of the lf*
 *		records that the CV_typ_t (32-bit types) is located on what appears to
 *		be a offset mod 4 == 2 boundary.  The exception to this rule are those
 *		records that are in a list (lfFieldList, lfMethodList), which are
 *		aligned to their own bases since they don't have the length field
 */

/**** Change log for 16-bit to 32-bit type and symbol records

	Record type			Change (f == field arrangement, p = padding added)
	----------------------------------------------------------------------
	lfModifer			f
	lfPointer			fp
	lfClass				f
	lfStructure			f
	lfUnion				f
	lfEnum				f
	lfVFTPath			p
    lfPreComp           p
	lfOEM				p
	lfArgList			p
	lfDerived			p
	mlMethod			p	(method list member)
	lfBitField			f
	lfDimCon			f
	lfDimVar			p
	lfIndex				p	(field list member)
	lfBClass			f	(field list member)
	lfVBClass			f	(field list member)
	lfFriendCls			p	(field list member)
	lfFriendFcn			p	(field list member)
	lfMember			f	(field list member)
	lfSTMember			f	(field list member)
	lfVFuncTab			p	(field list member)
	lfVFuncOff			p	(field list member)
	lfNestType			p	(field list member)

	DATASYM32			f
	PROCSYM32			f
	VPATHSYM32			f
	REGREL32			f
	THREADSYM32			f
	PROCSYMMIPS			f

	
*/

//      Type record for LF_MODIFIER

typedef struct lfModifier_16t {
    unsigned short  leaf;           // LF_MODIFIER_16t
    CV_modifier_t   attr;           // modifier attribute modifier_t
    CV_typ16_t      type;           // modified type
} lfModifier_16t;

typedef struct lfModifier {
    unsigned short  leaf;           // LF_MODIFIER
    CV_typ_t        type;           // modified type
    CV_modifier_t   attr;           // modifier attribute modifier_t
} lfModifier;




//      type record for LF_POINTER

#ifndef __cplusplus
typedef struct lfPointer_16t {
#endif
    struct lfPointerBody_16t {
        unsigned short      leaf;           // LF_POINTER_16t
        struct lfPointerAttr_16t {
            unsigned char   ptrtype     :5; // ordinal specifying pointer type (CV_ptrtype_e)
            unsigned char   ptrmode     :3; // ordinal specifying pointer mode (CV_ptrmode_e)
            unsigned char   isflat32    :1; // true if 0:32 pointer
            unsigned char   isvolatile  :1; // TRUE if volatile pointer
            unsigned char   isconst     :1; // TRUE if const pointer
            unsigned char   isunaligned :1; // TRUE if unaligned pointer
            unsigned char   unused      :4;
        } attr;
        CV_typ16_t  utype;          // type index of the underlying type
#if (defined(__cplusplus) || defined(_MSC_VER)) // for C++ and MS compilers that support unnamed unions
    };
#else
    } u;
#endif
#ifdef  __cplusplus
typedef struct lfPointer_16t : public lfPointerBody_16t {
#endif
    union  {
        struct {
            CV_typ16_t      pmclass;    // index of containing class for pointer to member
            unsigned short  pmenum;     // enumeration specifying pm format
        } pm;
        unsigned short      bseg;       // base segment if PTR_BASE_SEG
        unsigned char       Sym[1];     // copy of base symbol record (including length)
        struct  {
            CV_typ16_t      index;      // type index if CV_PTR_BASE_TYPE
            unsigned char   name[1];    // name of base type
        } btype;
    } pbase;
} lfPointer_16t;

#ifndef __cplusplus
typedef struct lfPointer {
#endif
    struct lfPointerBody {
        unsigned short      leaf;           // LF_POINTER
        CV_typ_t			utype;          // type index of the underlying type
        struct lfPointerAttr {
            unsigned long   ptrtype     :5; // ordinal specifying pointer type (CV_ptrtype_e)
            unsigned long   ptrmode     :3; // ordinal specifying pointer mode (CV_ptrmode_e)
            unsigned long   isflat32    :1; // true if 0:32 pointer
            unsigned long   isvolatile  :1; // TRUE if volatile pointer
            unsigned long   isconst     :1; // TRUE if const pointer
            unsigned long   isunaligned :1; // TRUE if unaligned pointer
            unsigned long   isrestrict  :1; // TRUE if restricted pointer (allow agressive opts)
            unsigned long   unused      :19;// pad out to 32-bits for following cv_typ_t's
        } attr;
#if (defined(__cplusplus) || defined(_MSC_VER)) // for C++ and MS compilers that support unnamed unions
    };
#else
    } u;
#endif
#ifdef  __cplusplus
typedef struct lfPointer : public lfPointerBody {
#endif
    union  {
        struct {
            CV_typ_t        pmclass;    // index of containing class for pointer to member
            unsigned short  pmenum;     // enumeration specifying pm format
        } pm;
        unsigned short      bseg;       // base segment if PTR_BASE_SEG
        unsigned char       Sym[1];     // copy of base symbol record (including length)
        struct  {
            CV_typ_t        index;      // type index if CV_PTR_BASE_TYPE
            unsigned char   name[1];    // name of base type
        } btype;
    } pbase;
} lfPointer;




//      type record for LF_ARRAY


typedef struct lfArray_16t {
    unsigned short  leaf;           // LF_ARRAY_16t
    CV_typ16_t      elemtype;       // type index of element type
    CV_typ16_t      idxtype;        // type index of indexing type
    unsigned char   data[CV_ZEROLEN];         // variable length data specifying
                                    // size in bytes and name
} lfArray_16t;

typedef struct lfArray {
    unsigned short  leaf;           // LF_ARRAY
    CV_typ_t        elemtype;       // type index of element type
    CV_typ_t        idxtype;        // type index of indexing type
    unsigned char   data[CV_ZEROLEN];         // variable length data specifying
                                    // size in bytes and name
} lfArray;




//      type record for LF_CLASS, LF_STRUCTURE


typedef struct lfClass_16t {
    unsigned short  leaf;           // LF_CLASS_16t, LF_STRUCT_16t
    unsigned short  count;          // count of number of elements in class
    CV_typ16_t      field;          // type index of LF_FIELD descriptor list
    CV_prop_t       property;       // property attribute field (prop_t)
    CV_typ16_t      derived;        // type index of derived from list if not zero
    CV_typ16_t      vshape;         // type index of vshape table for this class
    unsigned char   data[CV_ZEROLEN];         // data describing length of structure in
                                    // bytes and name
} lfClass_16t;
typedef lfClass_16t lfStructure_16t;


typedef struct lfClass {
    unsigned short  leaf;           // LF_CLASS, LF_STRUCT
    unsigned short  count;          // count of number of elements in class
    CV_prop_t       property;       // property attribute field (prop_t)
    CV_typ_t        field;          // type index of LF_FIELD descriptor list
    CV_typ_t        derived;        // type index of derived from list if not zero
    CV_typ_t        vshape;         // type index of vshape table for this class
    unsigned char   data[CV_ZEROLEN];         // data describing length of structure in
                                    // bytes and name
} lfClass;
typedef lfClass lfStructure;




//      type record for LF_UNION


typedef struct lfUnion_16t {
    unsigned short  leaf;           // LF_UNION_16t
    unsigned short  count;          // count of number of elements in class
    CV_typ16_t      field;          // type index of LF_FIELD descriptor list
    CV_prop_t       property;       // property attribute field
    unsigned char   data[CV_ZEROLEN];         // variable length data describing length of
                                    // structure and name
} lfUnion_16t;


typedef struct lfUnion {
    unsigned short  leaf;           // LF_UNION
    unsigned short  count;          // count of number of elements in class
    CV_prop_t       property;       // property attribute field
    CV_typ_t        field;          // type index of LF_FIELD descriptor list
    unsigned char   data[CV_ZEROLEN];         // variable length data describing length of
                                    // structure and name
} lfUnion;




//      type record for LF_ENUM


typedef struct lfEnum_16t {
    unsigned short  leaf;           // LF_ENUM_16t
    unsigned short  count;          // count of number of elements in class
    CV_typ16_t      utype;          // underlying type of the enum
    CV_typ16_t      field;          // type index of LF_FIELD descriptor list
    CV_prop_t       property;       // property attribute field
    unsigned char   Name[1];        // length prefixed name of enum
} lfEnum_16t;

typedef struct lfEnum {
    unsigned short  leaf;           // LF_ENUM
    unsigned short  count;          // count of number of elements in class
    CV_prop_t       property;       // property attribute field
    CV_typ_t        utype;          // underlying type of the enum
    CV_typ_t        field;          // type index of LF_FIELD descriptor list
    unsigned char   Name[1];        // length prefixed name of enum
} lfEnum;




//      Type record for LF_PROCEDURE


typedef struct lfProc_16t {
    unsigned short  leaf;           // LF_PROCEDURE_16t
    CV_typ16_t      rvtype;         // type index of return value
    unsigned char   calltype;       // calling convention (CV_call_t)
    unsigned char   reserved;       // reserved for future use
    unsigned short  parmcount;      // number of parameters
    CV_typ16_t      arglist;        // type index of argument list
} lfProc_16t;

typedef struct lfProc {
    unsigned short  leaf;           // LF_PROCEDURE
    CV_typ_t        rvtype;         // type index of return value
    unsigned char   calltype;       // calling convention (CV_call_t)
    unsigned char   reserved;       // reserved for future use
    unsigned short  parmcount;      // number of parameters
    CV_typ_t        arglist;        // type index of argument list
} lfProc;



//      Type record for member function


typedef struct lfMFunc_16t {
    unsigned short  leaf;           // LF_MFUNCTION_16t
    CV_typ16_t      rvtype;         // type index of return value
    CV_typ16_t      classtype;      // type index of containing class
    CV_typ16_t      thistype;       // type index of this pointer (model specific)
    unsigned char   calltype;       // calling convention (call_t)
    unsigned char   reserved;       // reserved for future use
    unsigned short  parmcount;      // number of parameters
    CV_typ16_t      arglist;        // type index of argument list
    long            thisadjust;     // this adjuster (long because pad required anyway)
} lfMFunc_16t;

typedef struct lfMFunc {
    unsigned short  leaf;           // LF_MFUNCTION
    CV_typ_t        rvtype;         // type index of return value
    CV_typ_t        classtype;      // type index of containing class
    CV_typ_t        thistype;       // type index of this pointer (model specific)
    unsigned char   calltype;       // calling convention (call_t)
    unsigned char   reserved;       // reserved for future use
    unsigned short  parmcount;      // number of parameters
    CV_typ_t        arglist;        // type index of argument list
    long            thisadjust;     // this adjuster (long because pad required anyway)
} lfMFunc;




//     type record for virtual function table shape


typedef struct lfVTShape {
    unsigned short  leaf;       // LF_VTSHAPE
    unsigned short  count;      // number of entries in vfunctable
    unsigned char   desc[CV_ZEROLEN];     // 4 bit (CV_VTS_desc) descriptors
} lfVTShape;




//      type record for cobol0


typedef struct lfCobol0_16t {
    unsigned short  leaf;       // LF_COBOL0_16t
    CV_typ16_t      type;       // parent type record index
    unsigned char   data[CV_ZEROLEN];
} lfCobol0_16t;

typedef struct lfCobol0 {
    unsigned short  leaf;       // LF_COBOL0
    CV_typ_t        type;       // parent type record index
    unsigned char   data[CV_ZEROLEN];
} lfCobol0;




//      type record for cobol1


typedef struct lfCobol1 {
    unsigned short  leaf;       // LF_COBOL1
    unsigned char   data[CV_ZEROLEN];
} lfCobol1;




//      type record for basic array


typedef struct lfBArray_16t {
    unsigned short  leaf;       // LF_BARRAY_16t
    CV_typ16_t      utype;      // type index of underlying type
} lfBArray_16t;

typedef struct lfBArray {
    unsigned short  leaf;       // LF_BARRAY
    CV_typ_t        utype;      // type index of underlying type
} lfBArray;

//      type record for assembler labels


typedef struct lfLabel {
    unsigned short  leaf;       // LF_LABEL
    unsigned short  mode;       // addressing mode of label
} lfLabel;



//      type record for dimensioned arrays


typedef struct lfDimArray_16t {
    unsigned short  leaf;       // LF_DIMARRAY_16t
    CV_typ16_t      utype;      // underlying type of the array
    CV_typ16_t      diminfo;    // dimension information
    unsigned char   name[1];    // length prefixed name
} lfDimArray_16t;

typedef struct lfDimArray {
    unsigned short  leaf;       // LF_DIMARRAY
    CV_typ_t        utype;      // underlying type of the array
    CV_typ_t        diminfo;    // dimension information
    unsigned char   name[1];    // length prefixed name
} lfDimArray;



//      type record describing path to virtual function table


typedef struct lfVFTPath_16t {
    unsigned short  leaf;       // LF_VFTPATH_16t
    unsigned short  count;      // count of number of bases in path
    CV_typ16_t      base[1];    // bases from root to leaf
} lfVFTPath_16t;

typedef struct lfVFTPath {
    unsigned short  leaf;       // LF_VFTPATH
    unsigned long   count;      // count of number of bases in path
    CV_typ_t        base[1];    // bases from root to leaf
} lfVFTPath;


//      type record describing inclusion of precompiled types


typedef struct lfPreComp_16t {
    unsigned short  leaf;       // LF_PRECOMP_16t
    unsigned short  start;      // starting type index included
    unsigned short  count;      // number of types in inclusion
    unsigned long   signature;  // signature
    unsigned char   name[CV_ZEROLEN];     // length prefixed name of included type file
} lfPreComp_16t;

typedef struct lfPreComp {
    unsigned short  leaf;       // LF_PRECOMP
    unsigned long   start;      // starting type index included
    unsigned long   count;      // number of types in inclusion
    unsigned long   signature;  // signature
    unsigned char   name[CV_ZEROLEN];     // length prefixed name of included type file
} lfPreComp;



//      type record describing end of precompiled types that can be
//      included by another file


typedef struct lfEndPreComp {
    unsigned short  leaf;       // LF_ENDPRECOMP
    unsigned long   signature;  // signature
} lfEndPreComp;





//      type record for OEM definable type strings


typedef struct lfOEM_16t {
    unsigned short  leaf;       // LF_OEM_16t
    unsigned short  cvOEM;      // MS assigned OEM identified
    unsigned short  recOEM;     // OEM assigned type identifier
    unsigned short  count;      // count of type indices to follow
    CV_typ16_t      index[CV_ZEROLEN];  // array of type indices followed
                                // by OEM defined data
} lfOEM_16t;

typedef struct lfOEM {
    unsigned short  leaf;       // LF_OEM
    unsigned short  cvOEM;      // MS assigned OEM identified
    unsigned short  recOEM;     // OEM assigned type identifier
    unsigned long   count;      // count of type indices to follow
    CV_typ_t        index[CV_ZEROLEN];  // array of type indices followed
                                // by OEM defined data
} lfOEM;

#define OEM_MS_FORTRAN90        0xF090
#define OEM_ODI                 0x0010
#define OEM_THOMSON_SOFTWARE    0x5453
#define OEM_ODI_REC_BASELIST    0x0000


//      type record describing using of a type server

typedef struct lfTypeServer {
    unsigned short  leaf;       // LF_TYPESERVER
    unsigned long   signature;  // signature
    unsigned long   age;        // age of database used by this module
    unsigned char   name[CV_ZEROLEN];     // length prefixed name of PDB
} lfTypeServer;

//      description of type records that can be referenced from
//      type records referenced by symbols



//      type record for skip record


typedef struct lfSkip_16t {
    unsigned short  leaf;       // LF_SKIP_16t
    CV_typ16_t      type;       // next valid index
    unsigned char   data[CV_ZEROLEN];     // pad data
} lfSkip_16t;

typedef struct lfSkip {
    unsigned short  leaf;       // LF_SKIP
    CV_typ_t        type;       // next valid index
    unsigned char   data[CV_ZEROLEN];     // pad data
} lfSkip;



//      argument list leaf


typedef struct lfArgList_16t {
    unsigned short  leaf;           // LF_ARGLIST_16t
    unsigned short  count;          // number of arguments
    CV_typ16_t      arg[CV_ZEROLEN];      // number of arguments
} lfArgList_16t;

typedef struct lfArgList {
    unsigned short  leaf;           // LF_ARGLIST
    unsigned long   count;          // number of arguments
    CV_typ_t        arg[CV_ZEROLEN];      // number of arguments
} lfArgList;




//      derived class list leaf


typedef struct lfDerived_16t {
    unsigned short  leaf;           // LF_DERIVED_16t
    unsigned short  count;          // number of arguments
    CV_typ16_t      drvdcls[CV_ZEROLEN];      // type indices of derived classes
} lfDerived_16t;

typedef struct lfDerived {
    unsigned short  leaf;           // LF_DERIVED
    unsigned long   count;          // number of arguments
    CV_typ_t        drvdcls[CV_ZEROLEN];      // type indices of derived classes
} lfDerived;




//      leaf for default arguments


typedef struct lfDefArg_16t {
    unsigned short  leaf;               // LF_DEFARG_16t
    CV_typ16_t      type;               // type of resulting expression
    unsigned char   expr[CV_ZEROLEN];   // length prefixed expression string
} lfDefArg_16t;

typedef struct lfDefArg {
    unsigned short  leaf;               // LF_DEFARG
    CV_typ_t        type;               // type of resulting expression
    unsigned char   expr[CV_ZEROLEN];   // length prefixed expression string
} lfDefArg;



//      list leaf
//          This list should no longer be used because the utilities cannot
//          verify the contents of the list without knowing what type of list
//          it is.  New specific leaf indices should be used instead.


typedef struct lfList {
    unsigned short  leaf;           // LF_LIST
    char            data[CV_ZEROLEN];         // data format specified by indexing type
} lfList;




//      field list leaf
//      This is the header leaf for a complex list of class and structure
//      subfields.


typedef struct lfFieldList_16t {
    unsigned short  leaf;           // LF_FIELDLIST_16t
    char            data[CV_ZEROLEN];         // field list sub lists
} lfFieldList_16t;


typedef struct lfFieldList {
    unsigned short  leaf;           // LF_FIELDLIST
    char            data[CV_ZEROLEN];         // field list sub lists
} lfFieldList;







//  type record for non-static methods and friends in overloaded method list

typedef struct mlMethod_16t {
    CV_fldattr_t   attr;           // method attribute
    CV_typ16_t     index;          // index to type record for procedure
    unsigned long  vbaseoff[CV_ZEROLEN];    // offset in vfunctable if intro virtual
} mlMethod_16t;

typedef struct mlMethod {
    CV_fldattr_t	attr;           // method attribute
	_2BYTEPAD       pad0;			// internal padding, must be 0
    CV_typ_t		index;          // index to type record for procedure
    unsigned long	vbaseoff[CV_ZEROLEN];    // offset in vfunctable if intro virtual
} mlMethod;


typedef struct lfMethodList_16t {
    unsigned short leaf;
    unsigned char  mList[CV_ZEROLEN];         // really a mlMethod_16t type
} lfMethodList_16t;

typedef struct lfMethodList {
    unsigned short leaf;
    unsigned char  mList[CV_ZEROLEN];         // really a mlMethod type
} lfMethodList;





//      type record for LF_BITFIELD


typedef struct lfBitfield_16t {
    unsigned short  leaf;           // LF_BITFIELD_16t
    unsigned char   length;
    unsigned char   position;
    CV_typ16_t      type;           // type of bitfield

} lfBitfield_16t;

typedef struct lfBitfield {
    unsigned short  leaf;           // LF_BITFIELD
    CV_typ_t        type;           // type of bitfield
    unsigned char   length;
    unsigned char   position;

} lfBitfield;




//      type record for dimensioned array with constant bounds


typedef struct lfDimCon_16t {
    unsigned short  leaf;           // LF_DIMCONU_16t or LF_DIMCONLU_16t
    unsigned short  rank;           // number of dimensions
    CV_typ16_t      typ;            // type of index
    unsigned char   dim[CV_ZEROLEN];          // array of dimension information with
                                    // either upper bounds or lower/upper bound
} lfDimCon_16t;

typedef struct lfDimCon {
    unsigned short  leaf;           // LF_DIMCONU or LF_DIMCONLU
    CV_typ_t        typ;            // type of index
    unsigned short  rank;           // number of dimensions
    unsigned char   dim[CV_ZEROLEN];          // array of dimension information with
                                    // either upper bounds or lower/upper bound
} lfDimCon;




//      type record for dimensioned array with variable bounds


typedef struct lfDimVar_16t {
    unsigned short  leaf;           // LF_DIMVARU_16t or LF_DIMVARLU_16t
    unsigned short  rank;           // number of dimensions
    CV_typ16_t      typ;            // type of index
    unsigned char   dim[CV_ZEROLEN];          // array of type indices for either
                                    // variable upper bound or variable
                                    // lower/upper bound.  The referenced
                                    // types must be LF_REFSYM or T_VOID
} lfDimVar_16t;

typedef struct lfDimVar {
    unsigned short  leaf;           // LF_DIMVARU or LF_DIMVARLU
    unsigned long   rank;           // number of dimensions
    CV_typ_t        typ;            // type of index
    CV_typ_t        dim[CV_ZEROLEN];          // array of type indices for either
                                    // variable upper bound or variable
                                    // lower/upper bound.  The count of type
                                    // indices is rank or rank*2 depending on
	                                // whether it is LFDIMVARU or LF_DIMVARLU.
                                    // The referenced types must be
	                                // LF_REFSYM or T_VOID
} lfDimVar;




//      type record for referenced symbol


typedef struct lfRefSym {
    unsigned short  leaf;           // LF_REFSYM
    unsigned char   Sym[1];         // copy of referenced symbol record
                                    // (including length)
} lfRefSym;





/**     the following are numeric leaves.  They are used to indicate the
 *      size of the following variable length data.  When the numeric
 *      data is a single byte less than 0x8000, then the data is output
 *      directly.  If the data is more the 0x8000 or is a negative value,
 *      then the data is preceeded by the proper index.
 */



//      signed character leaf

typedef struct lfChar {
    unsigned short  leaf;           // LF_CHAR
    signed char     val;            // signed 8-bit value
} lfChar;




//      signed short leaf

typedef struct lfShort {
    unsigned short  leaf;           // LF_SHORT
    short           val;            // signed 16-bit value
} lfShort;




//      unsigned short leaf

typedef struct lfUShort {
    unsigned short  leaf;           // LF_unsigned short
    unsigned short  val;            // unsigned 16-bit value
} lfUShort;




//      signed long leaf

typedef struct lfLong {
    unsigned short  leaf;           // LF_LONG
    long            val;            // signed 32-bit value
} lfLong;




//      unsigned long leaf

typedef struct lfULong {
    unsigned short  leaf;           // LF_ULONG
    unsigned long   val;            // unsigned 32-bit value
} lfULong;




//      signed quad leaf

typedef struct lfQuad {
    unsigned short  leaf;           // LF_QUAD
    unsigned char   val[8];         // signed 64-bit value
} lfQuad;




//      unsigned quad leaf

typedef struct lfUQuad {
    unsigned short  leaf;           // LF_UQUAD
    unsigned char   val[8];         // unsigned 64-bit value
} lfUQuad;


//      signed int128 leaf

typedef struct lfOct {
    unsigned short  leaf;           // LF_OCT
    unsigned char   val[16];        // signed 128-bit value
} lfOct;

//      unsigned int128 leaf

typedef struct lfUOct {
    unsigned short  leaf;           // LF_UOCT
    unsigned char   val[16];        // unsigned 128-bit value
} lfUOct;




//      real 32-bit leaf

typedef struct lfReal32 {
    unsigned short  leaf;           // LF_REAL32
    float           val;            // 32-bit real value
} lfReal32;




//      real 48-bit leaf

typedef struct lfReal48 {
    unsigned short  leaf;           // LF_REAL48
    unsigned char   val[6];         // 48-bit real value
} lfReal48;




//      real 64-bit leaf

typedef struct lfReal64 {
    unsigned short  leaf;           // LF_REAL64
    double          val;            // 64-bit real value
} lfReal64;




//      real 80-bit leaf

typedef struct lfReal80 {
    unsigned short  leaf;           // LF_REAL80
    FLOAT10         val;            // real 80-bit value
} lfReal80;




//      real 128-bit leaf

typedef struct lfReal128 {
    unsigned short  leaf;           // LF_REAL128
    char            val[16];        // real 128-bit value
} lfReal128;




//      complex 32-bit leaf

typedef struct lfCmplx32 {
    unsigned short  leaf;           // LF_COMPLEX32
    float           val_real;       // real component
    float           val_imag;       // imaginary component
} lfCmplx32;




//      complex 64-bit leaf

typedef struct lfCmplx64 {
    unsigned short  leaf;           // LF_COMPLEX64
    double          val_real;       // real component
    double          val_imag;       // imaginary component
} flCmplx64;




//      complex 80-bit leaf

typedef struct lfCmplx80 {
    unsigned short  leaf;           // LF_COMPLEX80
    FLOAT10         val_real;       // real component
    FLOAT10         val_imag;       // imaginary component
} lfCmplx80;




//      complex 128-bit leaf

typedef struct lfCmplx128 {
    unsigned short  leaf;           // LF_COMPLEX128
    char            val_real[16];   // real component
    char            val_imag[16];   // imaginary component
} lfCmplx128;



//  variable length numeric field

typedef struct lfVarString {
    unsigned short  leaf;       // LF_VARSTRING
    unsigned short  len;        // length of value in bytes
    unsigned char   value[CV_ZEROLEN];  // value
} lfVarString;

//***********************************************************************


//      index leaf - contains type index of another leaf
//      a major use of this leaf is to allow the compilers to emit a
//      long complex list (LF_FIELD) in smaller pieces.

typedef struct lfIndex_16t {
    unsigned short  leaf;           // LF_INDEX_16t
    CV_typ16_t      index;          // type index of referenced leaf
} lfIndex_16t;

typedef struct lfIndex {
    unsigned short  leaf;           // LF_INDEX
	_2BYTEPAD       pad0;			// internal padding, must be 0
    CV_typ_t        index;          // type index of referenced leaf
} lfIndex;


//      subfield record for base class field

typedef struct lfBClass_16t {
    unsigned short  leaf;           // LF_BCLASS_16t
    CV_typ16_t      index;          // type index of base class
    CV_fldattr_t    attr;           // attribute
    unsigned char   offset[CV_ZEROLEN];       // variable length offset of base within class
} lfBClass_16t;

typedef struct lfBClass {
    unsigned short  leaf;           // LF_BCLASS
    CV_fldattr_t    attr;           // attribute
    CV_typ_t        index;          // type index of base class
    unsigned char   offset[CV_ZEROLEN];       // variable length offset of base within class
} lfBClass;





//      subfield record for direct and indirect virtual base class field

typedef struct lfVBClass_16t {
    unsigned short  leaf;           // LF_VBCLASS_16t | LV_IVBCLASS_16t
    CV_typ16_t      index;          // type index of direct virtual base class
    CV_typ16_t      vbptr;          // type index of virtual base pointer
    CV_fldattr_t    attr;           // attribute
    unsigned char   vbpoff[CV_ZEROLEN];       // virtual base pointer offset from address point
                                    // followed by virtual base offset from vbtable
} lfVBClass_16t;

typedef struct lfVBClass {
    unsigned short  leaf;           // LF_VBCLASS | LV_IVBCLASS
    CV_fldattr_t    attr;           // attribute
    CV_typ_t        index;          // type index of direct virtual base class
    CV_typ_t        vbptr;          // type index of virtual base pointer
    unsigned char   vbpoff[CV_ZEROLEN];       // virtual base pointer offset from address point
                                    // followed by virtual base offset from vbtable
} lfVBClass;





//      subfield record for friend class


typedef struct lfFriendCls_16t {
    unsigned short  leaf;           // LF_FRIENDCLS_16t
    CV_typ16_t      index;          // index to type record of friend class
} lfFriendCls_16t;

typedef struct lfFriendCls {
    unsigned short  leaf;           // LF_FRIENDCLS
	_2BYTEPAD       pad0;			// internal padding, must be 0
    CV_typ_t        index;          // index to type record of friend class
} lfFriendCls;





//      subfield record for friend function


typedef struct lfFriendFcn_16t {
    unsigned short  leaf;           // LF_FRIENDFCN_16t
    CV_typ16_t      index;          // index to type record of friend function
    unsigned char   Name[1];        // name of friend function
} lfFriendFcn_16t;

typedef struct lfFriendFcn {
    unsigned short  leaf;           // LF_FRIENDFCN
	_2BYTEPAD       pad0;			// internal padding, must be 0
    CV_typ_t        index;          // index to type record of friend function
    unsigned char   Name[1];        // name of friend function
} lfFriendFcn;



//      subfield record for non-static data members

typedef struct lfMember_16t {
    unsigned short  leaf;           // LF_MEMBER_16t
    CV_typ16_t      index;          // index of type record for field
    CV_fldattr_t    attr;           // attribute mask
    unsigned char   offset[CV_ZEROLEN];       // variable length offset of field followed
                                    // by length prefixed name of field
} lfMember_16t;

typedef struct lfMember {
    unsigned short  leaf;           // LF_MEMBER
    CV_fldattr_t    attr;           // attribute mask
    CV_typ_t        index;          // index of type record for field
    unsigned char   offset[CV_ZEROLEN];       // variable length offset of field followed
                                    // by length prefixed name of field
} lfMember;



//  type record for static data members

typedef struct lfSTMember_16t {
    unsigned short  leaf;           // LF_STMEMBER_16t
    CV_typ16_t      index;          // index of type record for field
    CV_fldattr_t    attr;           // attribute mask
    unsigned char   Name[1];        // length prefixed name of field
} lfSTMember_16t;

typedef struct lfSTMember {
    unsigned short  leaf;           // LF_STMEMBER
    CV_fldattr_t    attr;           // attribute mask
    CV_typ_t        index;          // index of type record for field
    unsigned char   Name[1];        // length prefixed name of field
} lfSTMember;



//      subfield record for virtual function table pointer

typedef struct lfVFuncTab_16t {
    unsigned short  leaf;           // LF_VFUNCTAB_16t
    CV_typ16_t      type;           // type index of pointer
} lfVFuncTab_16t;

typedef struct lfVFuncTab {
    unsigned short  leaf;           // LF_VFUNCTAB
	_2BYTEPAD       pad0;			// internal padding, must be 0
    CV_typ_t        type;           // type index of pointer
} lfVFuncTab;



//      subfield record for virtual function table pointer with offset

typedef struct lfVFuncOff_16t {
    unsigned short  leaf;           // LF_VFUNCOFF_16t
    CV_typ16_t      type;           // type index of pointer
    CV_off32_t      offset;         // offset of virtual function table pointer
} lfVFuncOff_16t;

typedef struct lfVFuncOff {
    unsigned short  leaf;           // LF_VFUNCOFF
	_2BYTEPAD       pad0;			// internal padding, must be 0.
    CV_typ_t        type;           // type index of pointer
    CV_off32_t      offset;         // offset of virtual function table pointer
} lfVFuncOff;



//      subfield record for overloaded method list


typedef struct lfMethod_16t {
    unsigned short  leaf;           // LF_METHOD_16t
    unsigned short  count;          // number of occurrences of function
    CV_typ16_t      mList;          // index to LF_METHODLIST record
    unsigned char   Name[1];        // length prefixed name of method
} lfMethod_16t;

typedef struct lfMethod {
    unsigned short  leaf;           // LF_METHOD
    unsigned short  count;          // number of occurrences of function
    CV_typ_t        mList;          // index to LF_METHODLIST record
    unsigned char   Name[1];        // length prefixed name of method
} lfMethod;



//      subfield record for nonoverloaded method


typedef struct lfOneMethod_16t {
    unsigned short leaf;            // LF_ONEMETHOD_16t
    CV_fldattr_t   attr;            // method attribute
    CV_typ16_t     index;           // index to type record for procedure
    unsigned long  vbaseoff[CV_ZEROLEN];    // offset in vfunctable if
                                    // intro virtual followed by
                                    // length prefixed name of method
} lfOneMethod_16t;

typedef struct lfOneMethod {
    unsigned short leaf;            // LF_ONEMETHOD
    CV_fldattr_t   attr;            // method attribute
    CV_typ_t       index;           // index to type record for procedure
    unsigned long  vbaseoff[CV_ZEROLEN];    // offset in vfunctable if
                                    // intro virtual followed by
                                    // length prefixed name of method
} lfOneMethod;


//      subfield record for enumerate

typedef struct lfEnumerate {
    unsigned short  leaf;       // LF_ENUMERATE
    CV_fldattr_t    attr;       // access
    unsigned char   value[CV_ZEROLEN];    // variable length value field followed
                                // by length prefixed name
} lfEnumerate;


//  type record for nested (scoped) type definition

typedef struct lfNestType_16t {
    unsigned short  leaf;       // LF_NESTTYPE_16t
    CV_typ16_t      index;      // index of nested type definition
    unsigned char   Name[1];    // length prefixed type name
} lfNestType_16t;

typedef struct lfNestType {
    unsigned short  leaf;       // LF_NESTTYPE
	_2BYTEPAD       pad0;		// internal padding, must be 0
    CV_typ_t        index;      // index of nested type definition
    unsigned char   Name[1];    // length prefixed type name
} lfNestType;

//  type record for nested (scoped) type definition, with attributes
//  new records for vC v5.0, no need to have 16-bit ti versions.

typedef struct lfNestTypeEx {
    unsigned short  leaf;       // LF_NESTTYPEEX
    CV_fldattr_t    attr;       // member access
    CV_typ_t        index;      // index of nested type definition
    unsigned char   Name[1];    // length prefixed type name
} lfNestTypeEx;

//  type record for modifications to members

typedef struct lfMemberModify {
    unsigned short  leaf;       // LF_MEMBERMODIFY
    CV_fldattr_t    attr;       // the new attributes
    CV_typ_t        index;      // index of base class type definition
    unsigned char   Name[1];    // length prefixed member name
} lfMemberModify;

//  type record for pad leaf

typedef struct lfPad {
    unsigned char   leaf;
} SYM_PAD;



//  Symbol definitions

typedef enum SYM_ENUM_e {
    S_COMPILE       =  0x0001, // Compile flags symbol
	S_REGISTER_16t	=  0x0002, // Register variable
	S_CONSTANT_16t	=  0x0003, // constant symbol
	S_UDT_16t		=  0x0004, // User defined type
    S_SSEARCH       =  0x0005, // Start Search
    S_END           =  0x0006, // Block, procedure, "with" or thunk end
    S_SKIP          =  0x0007, // Reserve symbol space in $$Symbols table
    S_CVRESERVE     =  0x0008, // Reserved symbol for CV internal use
    S_OBJNAME       =  0x0009, // path to object file name
    S_ENDARG        =  0x000a, // end of argument/return list
	S_COBOLUDT_16t	=  0x000b, // special UDT for cobol that does not symbol pack
	S_MANYREG_16t	=  0x000c, // multiple register variable
    S_RETURN        =  0x000d, // return description symbol
    S_ENTRYTHIS     =  0x000e, // description of this pointer on entry
                       
    S_BPREL16       =  0x0100, // BP-relative
    S_LDATA16       =  0x0101, // Module-local symbol
    S_GDATA16       =  0x0102, // Global data symbol
    S_PUB16         =  0x0103, // a public symbol
    S_LPROC16       =  0x0104, // Local procedure start
    S_GPROC16       =  0x0105, // Global procedure start
    S_THUNK16       =  0x0106, // Thunk Start
    S_BLOCK16       =  0x0107, // block start
    S_WITH16        =  0x0108, // with start
    S_LABEL16       =  0x0109, // code label
    S_CEXMODEL16    =  0x010a, // change execution model
    S_VFTABLE16     =  0x010b, // address of virtual function table
    S_REGREL16      =  0x010c, // register relative address
                       
    S_BPREL32_16t   =  0x0200, // BP-relative
    S_LDATA32_16t   =  0x0201, // Module-local symbol
    S_GDATA32_16t   =  0x0202, // Global data symbol
    S_PUB32_16t     =  0x0203, // a public symbol (CV internal reserved)
    S_LPROC32_16t   =  0x0204, // Local procedure start
    S_GPROC32_16t   =  0x0205, // Global procedure start
    S_THUNK32       =  0x0206, // Thunk Start
    S_BLOCK32       =  0x0207, // block start
    S_WITH32        =  0x0208, // with start
    S_LABEL32       =  0x0209, // code label
    S_CEXMODEL32    =  0x020a, // change execution model
    S_VFTABLE32_16t =  0x020b, // address of virtual function table
    S_REGREL32_16t  =  0x020c, // register relative address
    S_LTHREAD32_16t =  0x020d, // local thread storage
    S_GTHREAD32_16t =  0x020e, // global thread storage
    S_SLINK32       =  0x020f, // static link for MIPS EH implementation
                       
    S_LPROCMIPS_16t =  0x0300, // Local procedure start
    S_GPROCMIPS_16t =  0x0301, // Global procedure start
                       
    S_PROCREF       =  0x0400, // Reference to a procedure
    S_DATAREF       =  0x0401, // Reference to data
    S_ALIGN         =  0x0402, // Used for page alignment of symbols
    S_LPROCREF      =  0x0403, // Local Reference to a procedure

    // sym records with 32-bit types embedded instead of 16-bit
    // all have 0x1000 bit set for easy identification
    // only do the 32-bit target versions since we don't really
    // care about 16-bit ones anymore.
S_TI16_MAX          =  0x1000,
	S_REGISTER		=  0x1001, // Register variable
	S_CONSTANT		=  0x1002, // constant symbol
	S_UDT			=  0x1003, // User defined type
	S_COBOLUDT		=  0x1004, // special UDT for cobol that does not symbol pack
	S_MANYREG		=  0x1005, // multiple register variable
	S_BPREL32		=  0x1006, // BP-relative
	S_LDATA32		=  0x1007, // Module-local symbol
	S_GDATA32		=  0x1008, // Global data symbol
	S_PUB32 		=  0x1009, // a public symbol (CV internal reserved)
	S_LPROC32		=  0x100a, // Local procedure start
	S_GPROC32		=  0x100b, // Global procedure start
	S_VFTABLE32 	=  0x100c, // address of virtual function table
	S_REGREL32		=  0x100d, // register relative address
	S_LTHREAD32 	=  0x100e, // local thread storage
	S_GTHREAD32 	=  0x100f, // global thread storage

	S_LPROCMIPS 	=  0x1010, // Local procedure start
	S_GPROCMIPS 	=  0x1011, // Global procedure start
                       
} SYM_ENUM_e;




//  enum describing the compile flag source language


typedef enum CV_CFL_LANG {
    CV_CFL_C        = 0x00,
    CV_CFL_CXX      = 0x01,
    CV_CFL_FORTRAN  = 0x02,
    CV_CFL_MASM     = 0x03,
    CV_CFL_PASCAL   = 0x04,
    CV_CFL_BASIC    = 0x05,
    CV_CFL_COBOL    = 0x06,
    CV_CFL_LINK     = 0x07,
    CV_CFL_CVTRES   = 0x08,
} CV_CFL_LANG;



//  enum describing target processor


typedef enum CV_CPU_TYPE_e {
    CV_CFL_8080         = 0x00,
    CV_CFL_8086         = 0x01,
    CV_CFL_80286        = 0x02,
    CV_CFL_80386        = 0x03,
    CV_CFL_80486        = 0x04,
    CV_CFL_PENTIUM      = 0x05,
    CV_CFL_PENTIUMPRO   = 0x06,
    CV_CFL_MIPSR4000    = 0x10,
    CV_CFL_M68000       = 0x20,
    CV_CFL_M68010       = 0x21,
    CV_CFL_M68020       = 0x22,
    CV_CFL_M68030       = 0x23,
    CV_CFL_M68040       = 0x24,
    CV_CFL_ALPHA        = 0x30,
    CV_CFL_PPC601       = 0x40,
    CV_CFL_PPC603       = 0x41,
    CV_CFL_PPC604       = 0x42,
    CV_CFL_PPC620       = 0x43

} CV_CPU_TYPE_e;




//  enum describing compile flag ambient data model


typedef enum CV_CFL_DATA {
    CV_CFL_DNEAR    = 0x00,
    CV_CFL_DFAR     = 0x01,
    CV_CFL_DHUGE    = 0x02
} CV_CFL_DATA;




//  enum describing compile flag ambiant code model


typedef enum CV_CFL_CODE_e {
    CV_CFL_CNEAR    = 0x00,
    CV_CFL_CFAR     = 0x01,
    CV_CFL_CHUGE    = 0x02
} CV_CFL_CODE_e;




//  enum describing compile flag target floating point package

typedef enum CV_CFL_FPKG_e {
    CV_CFL_NDP      = 0x00,
    CV_CFL_EMU      = 0x01,
    CV_CFL_ALT      = 0x02
} CV_CFL_FPKG_e;


// enum describing function return method


typedef struct CV_PROCFLAGS {
    union {
        unsigned char   bAll;
        struct {
            unsigned char CV_PFLAG_NOFPO:1; // frame pointer present
            unsigned char CV_PFLAG_INT  :1; // interrupt return
            unsigned char CV_PFLAG_FAR  :1; // far return
            unsigned char CV_PFLAG_NEVER:1; // function does not return
            unsigned char unused        :4; //
        };
    };
} CV_PROCFLAGS;


// enum describing function data return method

typedef enum CV_GENERIC_STYLE_e {
    CV_GENERIC_VOID   = 0x00,       // void return type
    CV_GENERIC_REG    = 0x01,       // return data is in registers
    CV_GENERIC_ICAN   = 0x02,       // indirect caller allocated near
    CV_GENERIC_ICAF   = 0x03,       // indirect caller allocated far
    CV_GENERIC_IRAN   = 0x04,       // indirect returnee allocated near
    CV_GENERIC_IRAF   = 0x05,       // indirect returnee allocated far
    CV_GENERIC_UNUSED = 0x06        // first unused
} CV_GENERIC_STYLE_e;


typedef struct CV_GENERIC_FLAG {
    unsigned short  cstyle  :1;     // true push varargs right to left
    unsigned short  rsclean :1;     // true if returnee stack cleanup
    unsigned short  unused  :14;    // unused
} CV_GENERIC_FLAG;





typedef struct SYMTYPE {
    unsigned short      reclen;     // Record length
    unsigned short      rectyp;     // Record type
    char                data[CV_ZEROLEN];
} SYMTYPE;

__INLINE SYMTYPE *NextSym (SYMTYPE * pSym) {
    return (SYMTYPE *) ((char *)pSym + pSym->reclen + sizeof(unsigned short));
}

//      non-model specific symbol types



typedef struct REGSYM_16t {
    unsigned short  reclen;     // Record length
	unsigned short	rectyp; 	// S_REGISTER_16t
	CV_typ16_t		typind; 	// Type index
    unsigned short  reg;        // register enumerate
    unsigned char   name[1];    // Length-prefixed name
} REGSYM_16t;

typedef struct REGSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_REGISTER
    CV_typ_t        typind;     // Type index
    unsigned short  reg;        // register enumerate
    unsigned char   name[1];    // Length-prefixed name
} REGSYM;



typedef struct MANYREGSYM_16t {
    unsigned short  reclen;     // Record length
	unsigned short	rectyp; 	// S_MANYREG_16t
	CV_typ16_t		typind; 	// Type index
    unsigned char   count;      // count of number of registers
    unsigned char   reg[1];     // count register enumerates followed by
                                // length-prefixed name.  Registers are
                                // most significant first.
} MANYREGSYM_16t;

typedef struct MANYREGSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_MANYREG
    CV_typ_t        typind;     // Type index
    unsigned char   count;      // count of number of registers
    unsigned char   reg[1];     // count register enumerates followed by
                                // length-prefixed name.  Registers are
                                // most significant first.
} MANYREGSYM;



typedef struct CONSTSYM_16t {
    unsigned short  reclen;     // Record length
	unsigned short	rectyp; 	// S_CONSTANT_16t
	CV_typ16_t		typind; 	// Type index (containing enum if enumerate)
    unsigned short  value;      // numeric leaf containing value
    unsigned char   name[CV_ZEROLEN];     // Length-prefixed name
} CONSTSYM_16t;

typedef struct CONSTSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_CONSTANT
    CV_typ_t        typind;     // Type index (containing enum if enumerate)
    unsigned short  value;      // numeric leaf containing value
    unsigned char   name[CV_ZEROLEN];     // Length-prefixed name
} CONSTSYM;


typedef struct UDTSYM_16t {
    unsigned short  reclen;     // Record length
	unsigned short	rectyp; 	// S_UDT_16t | S_COBOLUDT_16t
	CV_typ16_t		typind; 	// Type index
    unsigned char   name[1];    // Length-prefixed name
} UDTSYM_16t;

typedef struct UDTSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_UDT | S_COBOLUDT
    CV_typ_t        typind;     // Type index
    unsigned char   name[1];    // Length-prefixed name
} UDTSYM;

typedef struct SEARCHSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_SSEARCH
    unsigned long   startsym;   // offset of the procedure
    unsigned short  seg;        // segment of symbol
} SEARCHSYM;

typedef struct CFLAGSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_COMPILE
    unsigned char   machine;    // target processor
    struct  {
        unsigned char   language    :8; // language index
        unsigned char   pcode       :1; // true if pcode present
        unsigned char   floatprec   :2; // floating precision
        unsigned char   floatpkg    :2; // float package
        unsigned char   ambdata     :3; // ambient data model
        unsigned char   ambcode     :3; // ambient code model
        unsigned char   mode32      :1; // true if compiled 32 bit mode
        unsigned char   pad         :4; // reserved
    } flags;
    unsigned char       ver[1];     // Length-prefixed compiler version string
} CFLAGSYM;





typedef struct OBJNAMESYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_OBJNAME
    unsigned long   signature;  // signature
    unsigned char   name[1];    // Length-prefixed name
} OBJNAMESYM;




typedef struct ENDARGSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_ENDARG
} ENDARGSYM;


typedef struct RETURNSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_RETURN
    CV_GENERIC_FLAG flags;      // flags
    CV_GENERIC_STYLE_e style;   // return style
                                // followed by return method data
} RETURNSYM;


typedef struct ENTRYTHISSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_ENTRYTHIS
    unsigned char   thissym;    // symbol describing this pointer on entry
} ENTRYTHISSYM;


//      symbol types for 16:16 memory model


typedef struct BPRELSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_BPREL16
    CV_off16_t      off;        // BP-relative offset
	CV_typ16_t		typind; 	// Type index
    unsigned char   name[1];    // Length-prefixed name
} BPRELSYM16;



typedef struct DATASYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_LDATA or S_GDATA
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
	CV_typ16_t		typind; 	// Type index
    unsigned char   name[1];    // Length-prefixed name
} DATASYM16;
typedef DATASYM16 PUBSYM16;


typedef struct PROCSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_GPROC16 or S_LPROC16
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    unsigned short  len;        // Proc length
    unsigned short  DbgStart;   // Debug start offset
    unsigned short  DbgEnd;     // Debug end offset
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
	CV_typ16_t		typind; 	// Type index
    CV_PROCFLAGS    flags;      // Proc flags
    unsigned char   name[1];    // Length-prefixed name
} PROCSYM16;




typedef struct THUNKSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_THUNK
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    unsigned short  len;        // length of thunk
    unsigned char   ord;        // ordinal specifying type of thunk
    unsigned char   name[1];    // name of thunk
    unsigned char   variant[CV_ZEROLEN]; // variant portion of thunk
} THUNKSYM16;

typedef enum {
    THUNK_ORDINAL_NOTYPE,
    THUNK_ORDINAL_ADJUSTOR,
    THUNK_ORDINAL_VCALL,
    THUNK_ORDINAL_PCODE
} THUNK_ORDINAL;

typedef struct LABELSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_LABEL16
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    CV_PROCFLAGS    flags;      // flags
    unsigned char   name[1];    // Length-prefixed name
} LABELSYM16;

typedef struct BLOCKSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_BLOCK16
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned short  len;        // Block length
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    unsigned char   name[1];    // Length-prefixed name
} BLOCKSYM16;

typedef struct WITHSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_WITH16
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned short  len;        // Block length
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    unsigned char   expr[1];    // Length-prefixed expression
} WITHSYM16;




typedef enum CEXM_MODEL_e {
    CEXM_MDL_table			= 0x00,	// not executable
    CEXM_MDL_jumptable		= 0x01, // Compiler generated jump table
    CEXM_MDL_datapad		= 0x02, // Data padding for alignment
    CEXM_MDL_native			= 0x20, // native (actually not-pcode)
    CEXM_MDL_cobol			= 0x21, // cobol
    CEXM_MDL_codepad		= 0x22, // Code padding for alignment
    CEXM_MDL_code			= 0x23, // code
	CEXM_MDL_sql			= 0x30,	// sql
    CEXM_MDL_pcode			= 0x40, // pcode
    CEXM_MDL_pcode32Mac		= 0x41,	// macintosh 32 bit pcode
    CEXM_MDL_pcode32MacNep  = 0x42, // macintosh 32 bit pcode native entry point
    CEXM_MDL_javaInt        = 0x50,
    CEXM_MDL_unknown        = 0xff
} CEXM_MODEL_e;

// use the correct enumerate name
#define CEXM_MDL_SQL CEXM_MDL_sql

typedef enum CV_COBOL_e {
    CV_COBOL_dontstop,
    CV_COBOL_pfm,
    CV_COBOL_false,
    CV_COBOL_extcall
} CV_COBOL_e;

typedef struct CEXMSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_CEXMODEL16
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    unsigned short  model;      // execution model
    union var16 {
        struct  {
            CV_uoff16_t pcdtable;   // offset to pcode function table
            CV_uoff16_t pcdspi;     // offset to segment pcode information
        } pcode;
        struct {
            unsigned short  subtype;   // see CV_COBOL_e above
            unsigned short  flag;
        } cobol;
    };
} CEXMSYM16;




typedef struct VPATHSYM16 {
    unsigned short  reclen;     // record length
    unsigned short  rectyp;     // S_VFTPATH16
    CV_uoff16_t     off;        // offset of virtual function table
    unsigned short  seg;        // segment of virtual function table
	CV_typ16_t		root;		// type index of the root of path
	CV_typ16_t		path;		// type index of the path record
} VPATHSYM16;




typedef struct REGREL16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_REGREL16
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  reg;        // register index
	CV_typ16_t		typind; 	// Type index
    unsigned char   name[1];    // Length-prefixed name
} REGREL16;





typedef struct BPRELSYM32_16t {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_BPREL32_16t
    CV_off32_t      off;        // BP-relative offset
    CV_typ16_t      typind;     // Type index
    unsigned char   name[1];    // Length-prefixed name
} BPRELSYM32_16t;

typedef struct BPRELSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_BPREL32
    CV_off32_t      off;        // BP-relative offset
    CV_typ_t        typind;     // Type index
    unsigned char   name[1];    // Length-prefixed name
} BPRELSYM32;

typedef struct DATASYM32_16t {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_LDATA32_16t, S_GDATA32_16t or S_PUB32_16t
    CV_uoff32_t     off;
    unsigned short  seg;
    CV_typ16_t      typind;     // Type index
    unsigned char   name[1];    // Length-prefixed name
} DATASYM32_16t;
typedef DATASYM32_16t PUBSYM32_16t;

typedef struct DATASYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_LDATA32, S_GDATA32 or S_PUB32
    CV_typ_t        typind;     // Type index
    CV_uoff32_t     off;
    unsigned short  seg;
    unsigned char   name[1];    // Length-prefixed name
} DATASYM32;
typedef DATASYM32 PUBSYM32;



typedef struct PROCSYM32_16t {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_GPROC32_16t or S_LPROC32_16t
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    unsigned long   len;        // Proc length
    unsigned long   DbgStart;   // Debug start offset
    unsigned long   DbgEnd;     // Debug end offset
    CV_uoff32_t     off;
    unsigned short  seg;
    CV_typ16_t      typind;     // Type index
    CV_PROCFLAGS    flags;      // Proc flags
    unsigned char   name[1];    // Length-prefixed name
} PROCSYM32_16t;

typedef struct PROCSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_GPROC32 or S_LPROC32
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    unsigned long   len;        // Proc length
    unsigned long   DbgStart;   // Debug start offset
    unsigned long   DbgEnd;     // Debug end offset
    CV_typ_t        typind;     // Type index
    CV_uoff32_t     off;
    unsigned short  seg;
    CV_PROCFLAGS    flags;      // Proc flags
    unsigned char   name[1];    // Length-prefixed name
} PROCSYM32;




typedef struct THUNKSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_THUNK32
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    CV_uoff32_t     off;
    unsigned short  seg;
    unsigned short  len;        // length of thunk
    unsigned char   ord;        // ordinal specifying type of thunk
    unsigned char   name[1];    // Length-prefixed name
    unsigned char   variant[CV_ZEROLEN]; // variant portion of thunk
} THUNKSYM32;




typedef struct LABELSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_LABEL32
    CV_uoff32_t     off;
    unsigned short  seg;
    CV_PROCFLAGS    flags;      // flags
    unsigned char   name[1];    // Length-prefixed name
} LABELSYM32;


typedef struct BLOCKSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_BLOCK32
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   len;        // Block length
    CV_uoff32_t     off;        // Offset in code segment
    unsigned short  seg;        // segment of label
    unsigned char   name[1];    // Length-prefixed name
} BLOCKSYM32;


typedef struct WITHSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_WITH32
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   len;        // Block length
    CV_uoff32_t     off;        // Offset in code segment
    unsigned short  seg;        // segment of label
    unsigned char   expr[1];    // Length-prefixed expression string
} WITHSYM32;



typedef struct CEXMSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_CEXMODEL32
    CV_uoff32_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    unsigned short  model;      // execution model
    union var32 {
        struct  {
            CV_uoff32_t pcdtable;   // offset to pcode function table
            CV_uoff32_t pcdspi;     // offset to segment pcode information
        } pcode;
        struct {
            unsigned short  subtype;   // see CV_COBOL_e above
            unsigned short  flag;
        } cobol;
        struct {
            CV_uoff32_t calltableOff; // offset to function table
            unsigned short calltableSeg; // segment of function table
        } pcode32Mac;
    };
} CEXMSYM32;



typedef struct VPATHSYM32_16t {
    unsigned short  reclen;     // record length
    unsigned short  rectyp;     // S_VFTABLE32_16t
    CV_uoff32_t     off;        // offset of virtual function table
    unsigned short  seg;        // segment of virtual function table
    CV_typ16_t      root;       // type index of the root of path
    CV_typ16_t      path;       // type index of the path record
} VPATHSYM32_16t;

typedef struct VPATHSYM32 {
    unsigned short  reclen;     // record length
    unsigned short  rectyp;     // S_VFTABLE32
    CV_typ_t        root;       // type index of the root of path
    CV_typ_t        path;       // type index of the path record
    CV_uoff32_t     off;        // offset of virtual function table
    unsigned short  seg;        // segment of virtual function table
} VPATHSYM32;





typedef struct REGREL32_16t {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_REGREL32_16t
    CV_uoff32_t     off;        // offset of symbol
    unsigned short  reg;        // register index for symbol
    CV_typ16_t      typind;     // Type index
    unsigned char   name[1];    // Length-prefixed name
} REGREL32_16t;

typedef struct REGREL32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_REGREL32
    CV_uoff32_t     off;        // offset of symbol
    CV_typ_t        typind;     // Type index
    unsigned short  reg;        // register index for symbol
    unsigned char   name[1];    // Length-prefixed name
} REGREL32;



typedef struct THREADSYM32_16t {
    unsigned short  reclen;     // record length
    unsigned short  rectyp;     // S_LTHREAD32_16t | S_GTHREAD32_16t
    CV_uoff32_t     off;        // offset into thread storage
    unsigned short  seg;        // segment of thread storage
    CV_typ16_t      typind;     // type index
    unsigned char   name[1];    // length prefixed name
} THREADSYM32_16t;

typedef struct THREADSYM32 {
    unsigned short  reclen;     // record length
    unsigned short  rectyp;     // S_LTHREAD32 | S_GTHREAD32
    CV_typ_t        typind;     // type index
    CV_uoff32_t     off;        // offset into thread storage
    unsigned short  seg;        // segment of thread storage
    unsigned char   name[1];    // length prefixed name
} THREADSYM32;

typedef struct SLINK32 {
    unsigned short  reclen;     // record length
    unsigned short  rectyp;     // S_SLINK32
    unsigned long   framesize;  // frame size of parent procedure
    CV_off32_t      off;        // signed offset where the static link was saved relative to the value of reg
    unsigned short  reg;
} SLINK32;

typedef struct PROCSYMMIPS_16t {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_GPROCMIPS_16t or S_LPROCMIPS_16t
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    unsigned long   len;        // Proc length
    unsigned long   DbgStart;   // Debug start offset
    unsigned long   DbgEnd;     // Debug end offset
    unsigned long   regSave;    // int register save mask
    unsigned long   fpSave;     // fp register save mask
    CV_uoff32_t     intOff;     // int register save offset
    CV_uoff32_t     fpOff;      // fp register save offset
    CV_uoff32_t     off;        // Symbol offset
    unsigned short  seg;        // Symbol segment
    CV_typ16_t      typind;     // Type index
    unsigned char   retReg;     // Register return value is in
    unsigned char   frameReg;   // Frame pointer register
    unsigned char   name[1];    // Length-prefixed name
} PROCSYMMIPS_16t;

typedef struct PROCSYMMIPS {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_GPROCMIPS or S_LPROCMIPS
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    unsigned long   len;        // Proc length
    unsigned long   DbgStart;   // Debug start offset
    unsigned long   DbgEnd;     // Debug end offset
    unsigned long   regSave;    // int register save mask
    unsigned long   fpSave;     // fp register save mask
    CV_uoff32_t     intOff;     // int register save offset
    CV_uoff32_t     fpOff;      // fp register save offset
    CV_typ_t        typind;     // Type index
    CV_uoff32_t     off;        // Symbol offset
    unsigned short  seg;        // Symbol segment
    unsigned char   retReg;     // Register return value is in
    unsigned char   frameReg;   // Frame pointer register
    unsigned char   name[1];    // Length-prefixed name
} PROCSYMMIPS;


typedef struct REFSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_PROCREF or S_DATAREF
    unsigned long   sumName;    // SUC of the name
    unsigned long   ibSym;      // Offset of actual symbol in $$Symbols
    unsigned short  imod;       // Module containing the actual symbol
    unsigned short  usFill;     // align this record
} REFSYM;

typedef struct ALIGNSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_PROCREF or S_DATAREF
} ALIGNSYM;

//  generic block definition symbols
//  these are similar to the equivalent 16:16 or 16:32 symbols but
//  only define the length, type and linkage fields

typedef struct PROCSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_GPROC16 or S_LPROC16
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
} PROCSYM;


typedef struct THUNKSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_THUNK
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
} THUNKSYM;

typedef struct BLOCKSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_BLOCK16
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
} BLOCKSYM;


typedef struct WITHSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_WITH16
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
} WITHSYM;


typedef enum CV_HREG_e {
    //  Register set for the Intel 80x86 and ix86 processor series
    //  (plus PCODE registers)

    CV_REG_NONE     =   0,
    CV_REG_AL       =   1,
    CV_REG_CL       =   2,
    CV_REG_DL       =   3,
    CV_REG_BL       =   4,
    CV_REG_AH       =   5,
    CV_REG_CH       =   6,
    CV_REG_DH       =   7,
    CV_REG_BH       =   8,
    CV_REG_AX       =   9,
    CV_REG_CX       =  10,
    CV_REG_DX       =  11,
    CV_REG_BX       =  12,
    CV_REG_SP       =  13,
    CV_REG_BP       =  14,
    CV_REG_SI       =  15,
    CV_REG_DI       =  16,
    CV_REG_EAX      =  17,
    CV_REG_ECX      =  18,
    CV_REG_EDX      =  19,
    CV_REG_EBX      =  20,
    CV_REG_ESP      =  21,
    CV_REG_EBP      =  22,
    CV_REG_ESI      =  23,
    CV_REG_EDI      =  24,
    CV_REG_ES       =  25,
    CV_REG_CS       =  26,
    CV_REG_SS       =  27,
    CV_REG_DS       =  28,
    CV_REG_FS       =  29,
    CV_REG_GS       =  30,
    CV_REG_IP       =  31,
    CV_REG_FLAGS    =  32,
    CV_REG_EIP      =  33,
    CV_REG_EFLAGS   =  34,
    CV_REG_TEMP     =  40,          // PCODE Temp
    CV_REG_TEMPH    =  41,          // PCODE TempH
    CV_REG_QUOTE    =  42,          // PCODE Quote
    CV_REG_PCDR3    =  43,          // PCODE reserved
    CV_REG_PCDR4    =  44,          // PCODE reserved
    CV_REG_PCDR5    =  45,          // PCODE reserved
    CV_REG_PCDR6    =  46,          // PCODE reserved
    CV_REG_PCDR7    =  47,          // PCODE reserved
    CV_REG_CR0      =  80,          // CR0 -- control registers
    CV_REG_CR1      =  81,
    CV_REG_CR2      =  82,
    CV_REG_CR3      =  83,
    CV_REG_CR4      =  84,          // Pentium
    CV_REG_DR0      =  90,          // Debug register
    CV_REG_DR1      =  91,
    CV_REG_DR2      =  92,
    CV_REG_DR3      =  93,
    CV_REG_DR4      =  94,
    CV_REG_DR5      =  95,
    CV_REG_DR6      =  96,
    CV_REG_DR7      =  97,
    CV_REG_GDTR     =  110,
    CV_REG_GDTL     =  111,
    CV_REG_IDTR     =  112,
    CV_REG_IDTL     =  113,
    CV_REG_LDTR     =  114,
    CV_REG_TR       =  115,

    CV_REG_PSEUDO1  =  116,
    CV_REG_PSEUDO2  =  117,
    CV_REG_PSEUDO3  =  118,
    CV_REG_PSEUDO4  =  119,
    CV_REG_PSEUDO5  =  120,
    CV_REG_PSEUDO6  =  121,
    CV_REG_PSEUDO7  =  122,
    CV_REG_PSEUDO8  =  123,
    CV_REG_PSEUDO9  =  124,

    CV_REG_ST0      =  128,
    CV_REG_ST1      =  129,
    CV_REG_ST2      =  130,
    CV_REG_ST3      =  131,
    CV_REG_ST4      =  132,
    CV_REG_ST5      =  133,
    CV_REG_ST6      =  134,
    CV_REG_ST7      =  135,
    CV_REG_CTRL     =  136,
    CV_REG_STAT     =  137,
    CV_REG_TAG      =  138,
    CV_REG_FPIP     =  139,
    CV_REG_FPCS     =  140,
    CV_REG_FPDO     =  141,
    CV_REG_FPDS     =  142,
    CV_REG_ISEM     =  143,
    CV_REG_FPEIP    =  144,
    CV_REG_FPEDO    =  145,

    // registers for the 68K processors

    CV_R68_D0       =    0,
    CV_R68_D1       =    1,
    CV_R68_D2       =    2,
    CV_R68_D3       =    3,
    CV_R68_D4       =    4,
    CV_R68_D5       =    5,
    CV_R68_D6       =    6,
    CV_R68_D7       =    7,
    CV_R68_A0       =    8,
    CV_R68_A1       =    9,
    CV_R68_A2       =   10,
    CV_R68_A3       =   11,
    CV_R68_A4       =   12,
    CV_R68_A5       =   13,
    CV_R68_A6       =   14,
    CV_R68_A7       =   15,
    CV_R68_CCR      =   16,
    CV_R68_SR       =   17,
    CV_R68_USP      =   18,
    CV_R68_MSP      =   19,
    CV_R68_SFC      =   20,
    CV_R68_DFC      =   21,
    CV_R68_CACR     =   22,
    CV_R68_VBR      =   23,
    CV_R68_CAAR     =   24,
    CV_R68_ISP      =   25,
    CV_R68_PC       =   26,
    //reserved  27
    CV_R68_FPCR     =   28,
    CV_R68_FPSR     =   29,
    CV_R68_FPIAR    =   30,
    //reserved  31
    CV_R68_FP0      =   32,
    CV_R68_FP1      =   33,
    CV_R68_FP2      =   34,
    CV_R68_FP3      =   35,
    CV_R68_FP4      =   36,
    CV_R68_FP5      =   37,
    CV_R68_FP6      =   38,
    CV_R68_FP7      =   39,
    //reserved  40
    CV_R68_MMUSR030 =   41,
    CV_R68_MMUSR    =   42,
    CV_R68_URP      =   43,
    CV_R68_DTT0     =   44,
    CV_R68_DTT1     =   45,
    CV_R68_ITT0     =   46,
    CV_R68_ITT1     =   47,
    //reserved  50
    CV_R68_PSR      =   51,
    CV_R68_PCSR     =   52,
    CV_R68_VAL      =   53,
    CV_R68_CRP      =   54,
    CV_R68_SRP      =   55,
    CV_R68_DRP      =   56,
    CV_R68_TC       =   57,
    CV_R68_AC       =   58,
    CV_R68_SCC      =   59,
    CV_R68_CAL      =   60,
    CV_R68_TT0      =   61,
    CV_R68_TT1      =   62,
    //reserved  63
    CV_R68_BAD0     =   64,
    CV_R68_BAD1     =   65,
    CV_R68_BAD2     =   66,
    CV_R68_BAD3     =   67,
    CV_R68_BAD4     =   68,
    CV_R68_BAD5     =   69,
    CV_R68_BAD6     =   70,
    CV_R68_BAD7     =   71,
    CV_R68_BAC0     =   72,
    CV_R68_BAC1     =   73,
    CV_R68_BAC2     =   74,
    CV_R68_BAC3     =   75,
    CV_R68_BAC4     =   76,
    CV_R68_BAC5     =   77,
    CV_R68_BAC6     =   78,
    CV_R68_BAC7     =   79,

     // Register set for the MIPS 4000

    CV_M4_NOREG     =   CV_REG_NONE,

    CV_M4_IntZERO   =   10,      /* CPU REGISTER */
    CV_M4_IntAT     =   11,
    CV_M4_IntV0     =   12,
    CV_M4_IntV1     =   13,
    CV_M4_IntA0     =   14,
    CV_M4_IntA1     =   15,
    CV_M4_IntA2     =   16,
    CV_M4_IntA3     =   17,
    CV_M4_IntT0     =   18,
    CV_M4_IntT1     =   19,
    CV_M4_IntT2     =   20,
    CV_M4_IntT3     =   21,
    CV_M4_IntT4     =   22,
    CV_M4_IntT5     =   23,
    CV_M4_IntT6     =   24,
    CV_M4_IntT7     =   25,
    CV_M4_IntS0     =   26,
    CV_M4_IntS1     =   27,
    CV_M4_IntS2     =   28,
    CV_M4_IntS3     =   29,
    CV_M4_IntS4     =   30,
    CV_M4_IntS5     =   31,
    CV_M4_IntS6     =   32,
    CV_M4_IntS7     =   33,
    CV_M4_IntT8     =   34,
    CV_M4_IntT9     =   35,
    CV_M4_IntKT0    =   36,
    CV_M4_IntKT1    =   37,
    CV_M4_IntGP     =   38,
    CV_M4_IntSP     =   39,
    CV_M4_IntS8     =   40,
    CV_M4_IntRA     =   41,
    CV_M4_IntLO     =   42,
    CV_M4_IntHI     =   43,

    CV_M4_Fir       =   50,
    CV_M4_Psr       =   51,

    CV_M4_FltF0     =   60,      /* Floating point registers */
    CV_M4_FltF1     =   61,
    CV_M4_FltF2     =   62,
    CV_M4_FltF3     =   63,
    CV_M4_FltF4     =   64,
    CV_M4_FltF5     =   65,
    CV_M4_FltF6     =   66,
    CV_M4_FltF7     =   67,
    CV_M4_FltF8     =   68,
    CV_M4_FltF9     =   69,
    CV_M4_FltF10    =   70,
    CV_M4_FltF11    =   71,
    CV_M4_FltF12    =   72,
    CV_M4_FltF13    =   73,
    CV_M4_FltF14    =   74,
    CV_M4_FltF15    =   75,
    CV_M4_FltF16    =   76,
    CV_M4_FltF17    =   77,
    CV_M4_FltF18    =   78,
    CV_M4_FltF19    =   79,
    CV_M4_FltF20    =   80,
    CV_M4_FltF21    =   81,
    CV_M4_FltF22    =   82,
    CV_M4_FltF23    =   83,
    CV_M4_FltF24    =   84,
    CV_M4_FltF25    =   85,
    CV_M4_FltF26    =   86,
    CV_M4_FltF27    =   87,
    CV_M4_FltF28    =   88,
    CV_M4_FltF29    =   89,
    CV_M4_FltF30    =   90,
    CV_M4_FltF31    =   91,
    CV_M4_FltFsr    =   92,


    // Register set for the ALPHA AXP

    CV_ALPHA_NOREG  = CV_REG_NONE,

    CV_ALPHA_FltF0  =   10,   // Floating point registers
    CV_ALPHA_FltF1  =   11,
    CV_ALPHA_FltF2  =   12,
    CV_ALPHA_FltF3  =   13,
    CV_ALPHA_FltF4  =   14,
    CV_ALPHA_FltF5  =   15,
    CV_ALPHA_FltF6  =   16,
    CV_ALPHA_FltF7  =   17,
    CV_ALPHA_FltF8  =   18,
    CV_ALPHA_FltF9  =   19,
    CV_ALPHA_FltF10 =   20,
    CV_ALPHA_FltF11 =   21,
    CV_ALPHA_FltF12 =   22,
    CV_ALPHA_FltF13 =   23,
    CV_ALPHA_FltF14 =   24,
    CV_ALPHA_FltF15 =   25,
    CV_ALPHA_FltF16 =   26,
    CV_ALPHA_FltF17 =   27,
    CV_ALPHA_FltF18 =   28,
    CV_ALPHA_FltF19 =   29,
    CV_ALPHA_FltF20 =   30,
    CV_ALPHA_FltF21 =   31,
    CV_ALPHA_FltF22 =   32,
    CV_ALPHA_FltF23 =   33,
    CV_ALPHA_FltF24 =   34,
    CV_ALPHA_FltF25 =   35,
    CV_ALPHA_FltF26 =   36,
    CV_ALPHA_FltF27 =   37,
    CV_ALPHA_FltF28 =   38,
    CV_ALPHA_FltF29 =   39,
    CV_ALPHA_FltF30 =   40,
    CV_ALPHA_FltF31 =   41,

    CV_ALPHA_IntV0  =   42,   // Integer registers
    CV_ALPHA_IntT0  =   43,
    CV_ALPHA_IntT1  =   44,
    CV_ALPHA_IntT2  =   45,
    CV_ALPHA_IntT3  =   46,
    CV_ALPHA_IntT4  =   47,
    CV_ALPHA_IntT5  =   48,
    CV_ALPHA_IntT6  =   49,
    CV_ALPHA_IntT7  =   50,
    CV_ALPHA_IntS0  =   51,
    CV_ALPHA_IntS1  =   52,
    CV_ALPHA_IntS2  =   53,
    CV_ALPHA_IntS3  =   54,
    CV_ALPHA_IntS4  =   55,
    CV_ALPHA_IntS5  =   56,
    CV_ALPHA_IntFP  =   57,
    CV_ALPHA_IntA0  =   58,
    CV_ALPHA_IntA1  =   59,
    CV_ALPHA_IntA2  =   60,
    CV_ALPHA_IntA3  =   61,
    CV_ALPHA_IntA4  =   62,
    CV_ALPHA_IntA5  =   63,
    CV_ALPHA_IntT8  =   64,
    CV_ALPHA_IntT9  =   65,
    CV_ALPHA_IntT10 =   66,
    CV_ALPHA_IntT11 =   67,
    CV_ALPHA_IntRA  =   68,
    CV_ALPHA_IntT12 =   69,
    CV_ALPHA_IntAT  =   70,
    CV_ALPHA_IntGP  =   71,
    CV_ALPHA_IntSP  =   72,
    CV_ALPHA_IntZERO =  73,


    CV_ALPHA_Fpcr   =   74,   // Control registers
    CV_ALPHA_Fir    =   75,
    CV_ALPHA_Psr    =   76,
    CV_ALPHA_FltFsr =   77,
    CV_ALPHA_SoftFpcr =   78,

    // Register Set for Motorola/IBM PowerPC

    /*
    ** PowerPC General Registers ( User Level )
    */
    CV_PPC_GPR0     =  1,
    CV_PPC_GPR1     =  2,
    CV_PPC_GPR2     =  3,
    CV_PPC_GPR3     =  4,
    CV_PPC_GPR4     =  5,
    CV_PPC_GPR5     =  6,
    CV_PPC_GPR6     =  7,
    CV_PPC_GPR7     =  8,
    CV_PPC_GPR8     =  9,
    CV_PPC_GPR9     = 10,
    CV_PPC_GPR10    = 11,
    CV_PPC_GPR11    = 12,
    CV_PPC_GPR12    = 13,
    CV_PPC_GPR13    = 14,
    CV_PPC_GPR14    = 15,
    CV_PPC_GPR15    = 16,
    CV_PPC_GPR16    = 17,
    CV_PPC_GPR17    = 18,
    CV_PPC_GPR18    = 19,
    CV_PPC_GPR19    = 20,
    CV_PPC_GPR20    = 21,
    CV_PPC_GPR21    = 22,
    CV_PPC_GPR22    = 23,
    CV_PPC_GPR23    = 24,
    CV_PPC_GPR24    = 25,
    CV_PPC_GPR25    = 26,
    CV_PPC_GPR26    = 27,
    CV_PPC_GPR27    = 28,
    CV_PPC_GPR28    = 29,
    CV_PPC_GPR29    = 30,
    CV_PPC_GPR30    = 31,
    CV_PPC_GPR31    = 32,

    /*
    ** PowerPC Condition Register ( User Level )
    */
    CV_PPC_CR       = 33,
    CV_PPC_CR0      = 34,
    CV_PPC_CR1      = 35,
    CV_PPC_CR2      = 36,
    CV_PPC_CR3      = 37,
    CV_PPC_CR4      = 38,
    CV_PPC_CR5      = 39,
    CV_PPC_CR6      = 40,
    CV_PPC_CR7      = 41,

    /*
    ** PowerPC Floating Point Registers ( User Level )
    */
    CV_PPC_FPR0     = 42,
    CV_PPC_FPR1     = 43,
    CV_PPC_FPR2     = 44,
    CV_PPC_FPR3     = 45,
    CV_PPC_FPR4     = 46,
    CV_PPC_FPR5     = 47,
    CV_PPC_FPR6     = 48,
    CV_PPC_FPR7     = 49,
    CV_PPC_FPR8     = 50,
    CV_PPC_FPR9     = 51,
    CV_PPC_FPR10    = 52,
    CV_PPC_FPR11    = 53,
    CV_PPC_FPR12    = 54,
    CV_PPC_FPR13    = 55,
    CV_PPC_FPR14    = 56,
    CV_PPC_FPR15    = 57,
    CV_PPC_FPR16    = 58,
    CV_PPC_FPR17    = 59,
    CV_PPC_FPR18    = 60,
    CV_PPC_FPR19    = 61,
    CV_PPC_FPR20    = 62,
    CV_PPC_FPR21    = 63,
    CV_PPC_FPR22    = 64,
    CV_PPC_FPR23    = 65,
    CV_PPC_FPR24    = 66,
    CV_PPC_FPR25    = 67,
    CV_PPC_FPR26    = 68,
    CV_PPC_FPR27    = 69,
    CV_PPC_FPR28    = 70,
    CV_PPC_FPR29    = 71,
    CV_PPC_FPR30    = 72,
    CV_PPC_FPR31    = 73,

    /*
    ** PowerPC Floating Point Status and Control Register ( User Level )
    */
    CV_PPC_FPSCR    = 74,

    /*
    ** PowerPC Machine State Register ( Supervisor Level )
    */
    CV_PPC_MSR      = 75,

    /*
    ** PowerPC Segment Registers ( Supervisor Level )
    */
    CV_PPC_SR0      = 76,
    CV_PPC_SR1      = 77,
    CV_PPC_SR2      = 78,
    CV_PPC_SR3      = 79,
    CV_PPC_SR4      = 80,
    CV_PPC_SR5      = 81,
    CV_PPC_SR6      = 82,
    CV_PPC_SR7      = 83,
    CV_PPC_SR8      = 84,
    CV_PPC_SR9      = 85,
    CV_PPC_SR10     = 86,
    CV_PPC_SR11     = 87,
    CV_PPC_SR12     = 88,
    CV_PPC_SR13     = 89,
    CV_PPC_SR14     = 90,
    CV_PPC_SR15     = 91,

    /*
    ** For all of the special purpose registers add 100 to the SPR# that the
    ** Motorola/IBM documentation gives with the exception of any imaginary
    ** registers.
    */

    /*
    ** PowerPC Special Purpose Registers ( User Level )
    */
    CV_PPC_PC       = 99,     // PC (imaginary register)

    CV_PPC_MQ       = 100,    // MPC601
    CV_PPC_XER      = 101,
    CV_PPC_RTCU     = 104,    // MPC601
    CV_PPC_RTCL     = 105,    // MPC601
    CV_PPC_LR       = 108,
    CV_PPC_CTR      = 109,

    CV_PPC_COMPARE  = 110,    // part of XER (internal to the debugger only)
    CV_PPC_COUNT    = 111,    // part of XER (internal to the debugger only)

    /*
    ** PowerPC Special Purpose Registers ( Supervisor Level )
    */
    CV_PPC_DSISR    = 118,
    CV_PPC_DAR      = 119,
    CV_PPC_DEC      = 122,
    CV_PPC_SDR1     = 125,
    CV_PPC_SRR0     = 126,
    CV_PPC_SRR1     = 127,
    CV_PPC_SPRG0    = 372,
    CV_PPC_SPRG1    = 373,
    CV_PPC_SPRG2    = 374,
    CV_PPC_SPRG3    = 375,
    CV_PPC_ASR      = 280,    // 64-bit implementations only
    CV_PPC_EAR      = 382,
    CV_PPC_PVR      = 287,
    CV_PPC_BAT0U    = 628,
    CV_PPC_BAT0L    = 629,
    CV_PPC_BAT1U    = 630,
    CV_PPC_BAT1L    = 631,
    CV_PPC_BAT2U    = 632,
    CV_PPC_BAT2L    = 633,
    CV_PPC_BAT3U    = 634,
    CV_PPC_BAT3L    = 635,
    CV_PPC_DBAT0U   = 636,
    CV_PPC_DBAT0L   = 637,
    CV_PPC_DBAT1U   = 638,
    CV_PPC_DBAT1L   = 639,
    CV_PPC_DBAT2U   = 640,
    CV_PPC_DBAT2L   = 641,
    CV_PPC_DBAT3U   = 642,
    CV_PPC_DBAT3L   = 643,

    /*
    ** PowerPC Special Purpose Registers Implementation Dependent ( Supervisor Level )
    */

    /*
    ** Doesn't appear that IBM/Motorola has finished defining these.
    */

    CV_PPC_PMR0     = 1044,   // MPC620,
    CV_PPC_PMR1     = 1045,   // MPC620,
    CV_PPC_PMR2     = 1046,   // MPC620,
    CV_PPC_PMR3     = 1047,   // MPC620,
    CV_PPC_PMR4     = 1048,   // MPC620,
    CV_PPC_PMR5     = 1049,   // MPC620,
    CV_PPC_PMR6     = 1050,   // MPC620,
    CV_PPC_PMR7     = 1051,   // MPC620,
    CV_PPC_PMR8     = 1052,   // MPC620,
    CV_PPC_PMR9     = 1053,   // MPC620,
    CV_PPC_PMR10    = 1054,   // MPC620,
    CV_PPC_PMR11    = 1055,   // MPC620,
    CV_PPC_PMR12    = 1056,   // MPC620,
    CV_PPC_PMR13    = 1057,   // MPC620,
    CV_PPC_PMR14    = 1058,   // MPC620,
    CV_PPC_PMR15    = 1059,   // MPC620,

    CV_PPC_DMISS    = 1076,   // MPC603
    CV_PPC_DCMP     = 1077,   // MPC603
    CV_PPC_HASH1    = 1078,   // MPC603
    CV_PPC_HASH2    = 1079,   // MPC603
    CV_PPC_IMISS    = 1080,   // MPC603
    CV_PPC_ICMP     = 1081,   // MPC603
    CV_PPC_RPA      = 1082,   // MPC603

    CV_PPC_HID0     = 1108,   // MPC601, MPC603, MPC620
    CV_PPC_HID1     = 1109,   // MPC601
    CV_PPC_HID2     = 1110,   // MPC601, MPC603, MPC620 ( IABR )
    CV_PPC_HID3     = 1111,   // Not Defined
    CV_PPC_HID4     = 1112,   // Not Defined
    CV_PPC_HID5     = 1113,   // MPC601, MPC604, MPC620 ( DABR )
    CV_PPC_HID6     = 1114,   // Not Defined
    CV_PPC_HID7     = 1115,   // Not Defined
    CV_PPC_HID8     = 1116,   // MPC620 ( BUSCSR )
    CV_PPC_HID9     = 1117,   // MPC620 ( L2CSR )
    CV_PPC_HID10    = 1118,   // Not Defined
    CV_PPC_HID11    = 1119,   // Not Defined
    CV_PPC_HID12    = 1120,   // Not Defined
    CV_PPC_HID13    = 1121,   // MPC604 ( HCR )
    CV_PPC_HID14    = 1122,   // Not Defined
    CV_PPC_HID15    = 1123,   // MPC601, MPC604, MPC620 ( PIR )

	//
	// JAVA VM registers
	//

	CV_JAVA_PC		= 1,


} CV_HREG_e;

#pragma pack ( pop )

#endif /* CV_INFO_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\symtodbg\include\strings.h ===
#if ! defined( _RES_STR_ )
#define _RES_STR_

#ifdef RESOURCES
#define RES_STR(a, b, c) b, c
STRINGTABLE
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
BEGIN
#else

enum _RESOURCEIDS {
#define RES_STR(a, b, c) a = b,
#endif


RES_STR(ERR_OPEN_INPUT_FILE,    1,      "The file '%s' could not be openned for reading")
RES_STR(ERR_INVALID_PE,         2,      "'%s' is not a valid PE exe file with debug info")
RES_STR(ERR_NO_DEST,            3,      "Need to specify a destination for the converted debug information")
RES_STR(ERR_OPEN_WRITE_FILE,    4,      "Cannot open the file '%s' for writing")
RES_STR(ERR_EDIT_DBG_FILE,      5,      "Cannot edit name file in DBG file")
RES_STR(ERR_MAP_FILE,           6,      "Cannot map the file '%s'")
RES_STR(ERR_NO_COFF,            7,      "No COFF debug information present to be converted")
RES_STR(ERR_NOT_MAPPED,         8,      "Cannot add CV info unless debug information is mapped")
RES_STR(ERR_COFF_TO_CV,         9,      "Cannot convert COFF debug information to CodeView debug information")
RES_STR(ERR_OP_UNKNOWN,         10,     "Operation '%s' is unknown")
RES_STR(ERR_NO_MEMORY,          11,     "Out of memory")
RES_STR(ERR_FILE_PTRS,          12,     "INTERNAL: cannot set file pointers")
RES_STR(ERR_SET_EOF,            13,     "INTERNAL: cannot set the end of file markder")
RES_STR(ERR_CHECKSUM_CALC,      14,     "INTERNAL: cannot compute the image checksum")

#ifdef RESOURCES
END
#else
};
#endif

#endif // _RES_STR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\symtodbg\include\cvexefmt.h ===
/***    cvexefmt.h - format of CodeView information in exe
 *
 *      Structures, constants, etc. for reading CodeView information
 *      from the executable.
 *
 */

//  The following structures and constants describe the format of the
//  CodeView Debug OMF for that will be accepted by CodeView 4.0 and
//  later.  These are executables with signatures of NB05, NB06 and NB08.
//  There is some confusion about the signatures NB03 and NB04 so none
//  of the utilites will accept executables with these signatures.  NB07 is
//  the signature for QCWIN 1.0 packed executables.

//  All of the structures described below must start on a long word boundary
//  to maintain natural alignment.  Pad space can be inserted during the
//  write operation and the addresses adjusted without affecting the contents
//  of the structures.

#ifndef _CV_INFO_INCLUDED
#include "cvinfo.h"
#endif

#ifndef    FAR
#if _M_IX86 >= 300
#define    FAR
#else
#define FAR far
#endif
#endif


//  Type of subsection entry.

#define sstModule           0x120
#define sstTypes            0x121
#define sstPublic           0x122
#define sstPublicSym        0x123   // publics as symbol (waiting for link)
#define sstSymbols          0x124
#define sstAlignSym         0x125
#define sstSrcLnSeg         0x126   // because link doesn't emit SrcModule
#define sstSrcModule        0x127
#define sstLibraries        0x128
#define sstGlobalSym        0x129
#define sstGlobalPub        0x12a
#define sstGlobalTypes      0x12b
#define sstMPC              0x12c
#define sstSegMap           0x12d
#define sstSegName          0x12e
#define sstPreComp          0x12f   // precompiled types
#define sstPreCompMap       0x130   // map precompiled types in global types
#define sstOffsetMap16      0x131
#define sstOffsetMap32      0x132
#define sstFileIndex        0x133   // Index of file names
#define sstStaticSym        0x134

typedef enum OMFHash {
    OMFHASH_NONE,           // no hashing
    OMFHASH_SUMUC16,        // upper case sum of chars in 16 bit table
    OMFHASH_SUMUC32,        // upper case sum of chars in 32 bit table
    OMFHASH_ADDR16,         // sorted by increasing address in 16 bit table
    OMFHASH_ADDR32          // sorted by increasing address in 32 bit table
} OMFHASH;

//  CodeView Debug OMF signature.  The signature at the end of the file is
//  a negative offset from the end of the file to another signature.  At
//  the negative offset (base address) is another signature whose filepos
//  field points to the first OMFDirHeader in a chain of directories.
//  The NB05 signature is used by the link utility to indicated a completely
//  unpacked file.  The NB06 signature is used by ilink to indicate that the
//  executable has had CodeView information from an incremental link appended
//  to the executable.  The NB08 signature is used by cvpack to indicate that
//  the CodeView Debug OMF has been packed.  CodeView will only process
//  executables with the NB08 signature.


typedef struct OMFSignature {
    char        Signature[4];   // "NBxx"
    long        filepos;        // offset in file
} OMFSignature;



//  directory information structure
//  This structure contains the information describing the directory.
//  It is pointed to by the signature at the base address or the directory
//  link field of a preceeding directory.  The directory entries immediately
//  follow this structure.


typedef struct OMFDirHeader {
    unsigned short  cbDirHeader;    // length of this structure
    unsigned short  cbDirEntry;     // number of bytes in each directory entry
    unsigned long   cDir;           // number of directorie entries
    long            lfoNextDir;     // offset from base of next directory
    unsigned long   flags;          // status flags
} OMFDirHeader;




//  directory structure
//  The data in this structure is used to reference the data for each
//  subsection of the CodeView Debug OMF information.  Tables that are
//  not associated with a specific module will have a module index of
//  oxffff.  These tables are the global types table, the global symbol
//  table, the global public table and the library table.


typedef struct OMFDirEntry {
    unsigned short  SubSection;     // subsection type (sst...)
    unsigned short  iMod;           // module index
    long            lfo;            // large file offset of subsection
    unsigned long   cb;             // number of bytes in subsection
} OMFDirEntry;



//  information decribing each segment in a module

typedef struct OMFSegDesc {
    unsigned short  Seg;            // segment index
    unsigned short  pad;            // pad to maintain alignment
    unsigned long   Off;            // offset of code in segment
    unsigned long   cbSeg;          // number of bytes in segment
} OMFSegDesc;




//  per module information
//  There is one of these subsection entries for each module
//  in the executable.  The entry is generated by link/ilink.
//  This table will probably require padding because of the
//  variable length module name.

typedef struct OMFModule {
    unsigned short  ovlNumber;      // overlay number
    unsigned short  iLib;           // library that the module was linked from
    unsigned short  cSeg;           // count of number of segments in module
    char            Style[2];       // debugging style "CV"
    OMFSegDesc      SegInfo[1];     // describes segments in module
    char            Name[];         // length prefixed module name padded to
                                    // long word boundary
} OMFModule;



//  Symbol hash table format
//  This structure immediately preceeds the global publics table
//  and global symbol tables.

typedef struct OMFSymHash {
    unsigned short  symhash;        // symbol hash function index
    unsigned short  addrhash;       // address hash function index
    unsigned long   cbSymbol;       // length of symbol information
    unsigned long   cbHSym;         // length of symbol hash data
    unsigned long   cbHAddr;        // length of address hashdata
} OMFSymHash;



//  Global types subsection format
//  This structure immediately preceeds the global types table.
//  The offsets in the typeOffset array are relative to the address
//  of ctypes.  Each type entry following the typeOffset array must
//  begin on a long word boundary.

typedef struct OMFTypeFlags {
    unsigned long   sig     :8;
    unsigned long   unused  :24;
} OMFTypeFlags;


typedef struct OMFGlobalTypes {
    OMFTypeFlags    flags;
    unsigned long   cTypes;         // number of types
    unsigned long   typeOffset[];   // array of offsets to types
} OMFGlobalTypes;




//  Precompiled types mapping table
//  This table should be ignored by all consumers except the incremental
//  packer.


typedef struct OMFPreCompMap {
    unsigned short  FirstType;      // first precompiled type index
    unsigned short  cTypes;         // number of precompiled types
    unsigned long   signature;      // precompiled types signature
    unsigned short  pad;
    CV_typ_t        map[];          // mapping of precompiled types
} OMFPreCompMap;




//  Source line to address mapping table.
//  This table is generated by the link/ilink utility from line number
//  information contained in the object file OMF data.  This table contains
//  only the code contribution for one segment from one source file.


typedef struct OMFSourceLine {
    unsigned short  Seg;            // linker segment index
    unsigned short  cLnOff;         // count of line/offset pairs
    unsigned long   offset[1];      // array of offsets in segment
    unsigned short  lineNbr[1];     // array of line lumber in source
} OMFSourceLine;

typedef OMFSourceLine FAR * LPSL;


//  Source file description
//  This table is generated by the linker


typedef struct OMFSourceFile {
    unsigned short  cSeg;           // number of segments from source file
    unsigned short  reserved;       // reserved
    unsigned long   baseSrcLn[1];   // base of OMFSourceLine tables
                                    // this array is followed by array
                                    // of segment start/end pairs followed by
                                    // an array of linker indices
                                    // for each segment in the file
    unsigned short  cFName;         // length of source file name
    char            Name;           // name of file padded to long boundary
} OMFSourceFile;

typedef OMFSourceFile FAR * LPSF;


//  Source line to address mapping header structure
//  This structure describes the number and location of the
//  OMFAddrLine tables for a module.  The offSrcLine entries are
//  relative to the beginning of this structure.


typedef struct OMFSourceModule {
    unsigned short  cFile;          // number of OMFSourceTables
    unsigned short  cSeg;           // number of segments in module
    unsigned long   baseSrcFile[1]; // base of OMFSourceFile table
                                    // this array is followed by array
                                    // of segment start/end pairs followed
                                    // by an array of linker indices
                                    // for each segment in the module
} OMFSourceModule;

typedef OMFSourceModule FAR * LPSM;

//  sstLibraries

typedef struct OMFLibrary {
    unsigned char   cbLibs;     // count of library names
    char            Libs[1];    // array of length prefixed lib names (first entry zero length)
} OMFLibrary;


// sstFileIndex - An index of all of the files contributing to an
//  executable.

typedef struct OMFFileIndex {
    unsigned short  cmodules;       // Number of modules
    unsigned short  cfilerefs;      // Number of file references
    unsigned short  modulelist[1];  // Index to beginning of list of files
                                    // for module i. (0 for module w/o files)
    unsigned short  cfiles[1];      // Number of file names associated
                                    // with module i.
    unsigned long   ulNames[1];     // Offsets from the beginning of this
                                    // table to the file names
    char            Names[];        // The length prefixed names of files
} OMFFileIndex;


//  Offset mapping table
//  This table provides a mapping from logical to physical offsets.
//  This mapping is applied between the logical to physical mapping
//  described by the seg map table.

typedef struct OMFOffsetMap16 {
    unsigned long   csegment;       // Count of physical segments

    // The next six items are repeated for each segment

    unsigned long   crangeLog;      // Count of logical offset ranges
    unsigned short  rgoffLog[1];    // Array of logical offsets
    short           rgbiasLog[1];   // Array of logical->physical bias
    unsigned long   crangePhys;     // Count of physical offset ranges
    unsigned short  rgoffPhys[1];   // Array of physical offsets
    short           rgbiasPhys[1];  // Array of physical->logical bias
} OMFOffsetMap16;

typedef struct OMFOffsetMap32 {
    unsigned long   csection;       // Count of physical sections

    // The next six items are repeated for each section

    unsigned long   crangeLog;      // Count of logical offset ranges
    unsigned long   rgoffLog[1];    // Array of logical offsets
    long            rgbiasLog[1];   // Array of logical->physical bias
    unsigned long   crangePhys;     // Count of physical offset ranges
    unsigned long   rgoffPhys[1];   // Array of physical offsets
    long            rgbiasPhys[1];  // Array of physical->logical bias
} OMFOffsetMap32;

//  Pcode support.  This subsection contains debug information generated
//  by the MPC utility used to process Pcode executables.  Currently
//  it contains a mapping table from segment index (zero based) to
//  frame paragraph.  MPC converts segmented exe's to non-segmented
//  exe's for DOS support.  To avoid backpatching all CV info, this
//  table is provided for the mapping.  Additional info may be provided
//  in the future for profiler support.

typedef struct OMFMpcDebugInfo {
    unsigned short  cSeg;           // number of segments in module
    unsigned short  mpSegFrame[1];  // map seg (zero based) to frame
} OMFMpcDebugInfo;

//  The following structures and constants describe the format of the
//  CodeView Debug OMF for linkers that emit executables with the NB02
//  signature.  Current utilities with the exception of cvpack and cvdump
//  will not accept or emit executables with the NB02 signature.  Cvdump
//  will dump an unpacked executable with the NB02 signature.  Cvpack will
//  read an executable with the NB02 signature but the packed executable
//  will be written with the table format, contents and signature of NB08.


//  subsection type constants

#define SSTMODULE       0x101    // Basic info. about object module
#define SSTPUBLIC       0x102    // Public symbols
#define SSTTYPES        0x103    // Type information
#define SSTSYMBOLS      0x104    // Symbol Data
#define SSTSRCLINES     0x105    // Source line information
#define SSTLIBRARIES    0x106    // Names of all library files used
#define SSTIMPORTS      0x107    // Symbols for DLL fixups
#define SSTCOMPACTED    0x108    // Compacted types section
#define SSTSRCLNSEG     0x109    // Same as source lines, contains segment


typedef struct DirEntry{
    unsigned short  SubSectionType;
    unsigned short  ModuleIndex;
    long            lfoStart;
    unsigned short  Size;
} DirEntry;


//  information decribing each segment in a module

typedef struct oldnsg {
    unsigned short  Seg;         // segment index
    unsigned short  Off;         // offset of code in segment
    unsigned short  cbSeg;       // number of bytes in segment
} oldnsg;


//  old subsection module information

typedef struct oldsmd {
    oldnsg          SegInfo;     // describes first segment in module
    unsigned short  ovlNbr;      // overlay number
    unsigned short  iLib;
    unsigned char   cSeg;        // Number of segments in module
    char            reserved;
    unsigned char   cbName[1];   // length prefixed name of module
    oldnsg          arnsg[];     // cSeg-1 structures exist for alloc text or comdat code
} oldsmd;

typedef struct{
    unsigned short  Seg;
    unsigned long   Off;
    unsigned long   cbSeg;
} oldnsg32;

typedef struct {
    oldnsg32        SegInfo;     // describes first segment in module
    unsigned short  ovlNbr;      // overlay number
    unsigned short  iLib;
    unsigned char   cSeg;        // Number of segments in module
    char            reserved;
    unsigned char   cbName[1];   // length prefixed name of module
    oldnsg32        arnsg[];     // cSeg-1 structures exist for alloc text or comdat code
} oldsmd32;

// OMFSegMap - This table contains the mapping between the logical segment indices
// used in the symbol table and the physical segments where the program is loaded

typedef struct OMFSegMapDesc {
    unsigned short  flags;       // descriptor flags bit field.
    unsigned short  ovl;         // the logical overlay number
    unsigned short  group;       // group index into the descriptor array
    unsigned short  frame;       // logical segment index - interpreted via flags
    unsigned short  iSegName;    // segment or group name - index into sstSegName
    unsigned short  iClassName;  // class name - index into sstSegName
    unsigned long   offset;      // byte offset of the logical within the physical segment
    unsigned long   cbSeg;       // byte count of the logical segment or group
} OMFSegMapDesc;

typedef struct OMFSegMap {
    unsigned short  cSeg;        // total number of segment descriptors
    unsigned short  cSegLog;     // number of logical segment descriptors
    OMFSegMapDesc   rgDesc[0];   // array of segment descriptors
} OMFSegMap;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\symtodbg\include\symcvt.h ===
/*++


Copyright 1996 - 1997 Microsoft Corporation

Module Name:

    symcvt.h

Abstract:

    This file contains all of the type definitions and prototypes
    necessary to access the symcvt library.

Environment:

    Win32, User Mode

--*/


typedef struct tagPTRINFO {
    DWORD                       size;
    DWORD                       count;
    PUCHAR                      ptr;
} PTRINFO, *PPTRINFO;

typedef struct tagIMAGEPOINTERS {
    char                        szName[MAX_PATH];
    HANDLE                      hFile;
    HANDLE                      hMap;
    DWORD                       fsize;
    PUCHAR                      fptr;
    BOOLEAN                     fRomImage;
    PIMAGE_DOS_HEADER           dosHdr;
    PIMAGE_NT_HEADERS           ntHdr;
    PIMAGE_ROM_HEADERS          romHdr;
    PIMAGE_FILE_HEADER          fileHdr;
    PIMAGE_OPTIONAL_HEADER      optHdr;
    PIMAGE_SEPARATE_DEBUG_HEADER sepHdr;
    int                         cDebugDir;
    PIMAGE_DEBUG_DIRECTORY *    rgDebugDir;
    PIMAGE_SECTION_HEADER       sectionHdrs;
    PIMAGE_SECTION_HEADER       debugSection;
    PIMAGE_SYMBOL               AllSymbols;
    PUCHAR                      stringTable;
    int                         numberOfSymbols;
    int                         numberOfSections;
    PCHAR *                     rgpbDebugSave;
} IMAGEPOINTERS, *PIMAGEPOINTERS;

#define COFF_DIR(x)             ((x)->rgDebugDir[IMAGE_DEBUG_TYPE_COFF])
#define CV_DIR(x)               ((x)->rgDebugDir[IMAGE_DEBUG_TYPE_CODEVIEW])

typedef struct _MODULEINFO {
    DWORD               iMod;
    DWORD               cb;
    DWORD               SrcModule;
    LPSTR               name;
} MODULEINFO, *LPMODULEINFO;

typedef struct tagPOINTERS {
    IMAGEPOINTERS               iptrs;         // input file pointers
    IMAGEPOINTERS               optrs;         // output file pointers
    PTRINFO                     pCvStart;      // start of cv info
    PUCHAR                      pCvCurr;       // current cv pointer
    size_t                      cbCvData;      // size of CV data
    PTRINFO                     pCvModules;    // module information
    PTRINFO                     pCvSrcModules; // source module information
    PTRINFO                     pCvPublics;    // publics information
    PTRINFO                     pCvSegName;    // segment names
    PTRINFO                     pCvSegMap;     // segment map
    PTRINFO                     pCvSymHash;    // symbol hash table
    PTRINFO                     pCvAddrSort;   // address sort table
    LPMODULEINFO                pMi;
    DWORD                       modcnt;
} POINTERS, *PPOINTERS;

typedef  char *  (* CONVERTPROC) (HANDLE, char *);

#define align(_n)       ((4 - (( (DWORD)_n ) % 4 )) & 3)

#ifdef _SYMCVT_SOURCE_
#define SYMCVTAPI
#else
#define SYMCVTAPI DECLSPEC_IMPORT
#endif

PUCHAR  SYMCVTAPI ConvertSymbolsForImage( HANDLE, char * );
BOOL    SYMCVTAPI ConvertCoffToCv( PPOINTERS p );
BOOL    SYMCVTAPI ConvertSymToCv( PPOINTERS p );
BOOL    SYMCVTAPI MapInputFile ( PPOINTERS p, HANDLE hFile, char *fname);
BOOL    SYMCVTAPI UnMapInputFile ( PPOINTERS p );
BOOL    SYMCVTAPI CalculateNtImagePointers( PIMAGEPOINTERS p );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\symtodbg\matchsym\symres.cpp ===
/*
    Copyright 1999 Microsoft Corporation

    Neptune data collection server

    Walter Smith (wsmith)

    Matches Symbols with The Corresponding Binary

 */

#include <windows.h>


#include <dbghelp.h>
#include <symres.h>
#include <stdio.h>
#include <stdlib.h>
#include <shlwapi.h>
#include <sys\stat.h>
#include <string.h>
#undef UNICODE
#include <strsafe.h>

#ifndef DIMA
 #define DIMAT(Array, EltType) (sizeof(Array) / sizeof(EltType))
 #define DIMA(Array) DIMAT(Array, (Array)[0])
#endif

void
UndecorateSymbol(
        LPTSTR szSymbol         // [in] [out] function name undecorated in place
        )
{
    char             szTemp[MAX_PATH];
    PIMAGEHLP_SYMBOL pihsym;
    DWORD            dwSize;

    dwSize = sizeof(IMAGEHLP_SYMBOL)+MAX_PATH;
    pihsym = (IMAGEHLP_SYMBOL *) malloc(dwSize);
    pihsym->SizeOfStruct = dwSize;
    pihsym->Address = 0;
    pihsym->Flags = 0;
    pihsym->MaxNameLength = MAX_PATH;
    wcstombs(pihsym->Name,szSymbol, lstrlen(szSymbol));
    SymUnDName(pihsym,szTemp,MAX_PATH);
    mbstowcs(szSymbol,szTemp, strlen(szTemp));
}

// select file from list of open files, or open and add to list
// maintain files in usage order, least recently used at end of list
OPENFILE*                                           // pointer to open file info
SymbolResolver::GetFile(
        LPWSTR szwModule                            // [in] name of file
        )
{
    OPENFILE*                       pFile = NULL;
    MAPDEF                          map;
    DWORD                           dwCread;
    WCHAR                           wszBuffer[MAX_PATH];

    StringCchCopyW(wszBuffer, DIMA(wszBuffer), szwModule);
    PathRemoveExtension(wszBuffer);
    PathAddExtension(wszBuffer, L".sym");

    pFile = new OPENFILE;
        // open SYM file
    pFile->hfFile = CreateFileW(wszBuffer,
                               GENERIC_READ,
                               FILE_SHARE_READ,
                               NULL,
                               OPEN_EXISTING,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL);

    if (pFile->hfFile == INVALID_HANDLE_VALUE) return NULL;
    // copy filename and version into pFile node
    StringCchCopyW(pFile->szwName, DIMA(pFile->szwName), szwModule);

    // read map definition
    ReadFile(pFile->hfFile, &map, sizeof(MAPDEF)-1, &dwCread, NULL);

    if (dwCread != sizeof(MAPDEF)-1)
    {
        if (pFile->hfFile)
            CloseHandle(pFile->hfFile);
        if (pFile)
            delete pFile;
        throw E_FAIL;
    }

    pFile->ulFirstSeg = map.md_spseg*16;
    pFile->nSeg = map.md_cseg;
    pFile->psCurSymDefPtrs = NULL;

    return pFile;
}


// parse sym file to resolve address
// read segment defintion for dwSection
ULONG                                   // return offset of segment definition, 0 if failed
SymbolResolver::GetSegDef(OPENFILE*     pFile,            // [in] pointer to open file info
        DWORD         dwSection,        // [in] section number
        SEGDEF*       pSeg)              // [out] pointer to segment definition
{
    ULONG   ulCurSeg = pFile->ulFirstSeg;
    int     iSectionIndex = 0;
    DWORD   dwCread;

    // step through segments
    while (iSectionIndex < pFile->nSeg)
    {
        // go to segment beginning
        if (SetFilePointer(pFile->hfFile, ulCurSeg, NULL, FILE_BEGIN) == 0xFFFFFFFF)
        {
            ulCurSeg = 0;
            break;
        }

        // read seg defn
        if (!ReadFile(pFile->hfFile, pSeg, sizeof(SEGDEF)-1, &dwCread, NULL))
        {
            ulCurSeg = 0;
            break;
        }

        iSectionIndex++;
        if (iSectionIndex == (int)dwSection)   // gotcha
        {
            break;
        }

        // go to next segment definition
        ulCurSeg = pSeg->gd_spsegnext*16;
    }

    // found our section and it's non-empty?
    if (iSectionIndex != (int)dwSection || !pSeg->gd_csym) // no
    {
        ulCurSeg = 0;
    }

    return ulCurSeg;
}

// parse sym file to resolve address
bool
SymbolResolver::GetNameFromAddr(
        LPWSTR      szwModule,           // [in] name of symbol file
        DWORD       dwSection,           // [in] section part of address to resolve
        DWORD       dwOffsetToRva,      // [in] Section base
        UINT_PTR     uRva,              // [in] offset part of address to resolve
        LPWSTR      wszFuncName          // [out] resolved function name,
        )
{
    SEGDEF              seg;
    DWORD               dwSymAddr;
    TCHAR               sztFuncName[MAX_NAME+1];
    int                 i;
    int                 nNameLen;
    DWORD               dwCread;
    int                 nToRead;
    unsigned char       cName;
    ULONG               ulCurSeg;
    ULONG               ulSymNameOffset = 0;
    HANDLE              hfFile;
    OPENFILE*           pFile = NULL;
    DWORD               dwArrayOffset;
    DWORD               dwSymOffset;
    bool fResult = false;

    // get file from open list, or open file
    pFile = GetFile(szwModule);

    if (!pFile)
        return false;

    if ((ulCurSeg = GetSegDef(pFile, dwSection, &seg)) == 0)
    {
        goto Cleanup;
    }

    BYTE* pSymDefPtrs;

    // big symbols?
    if (seg.gd_type & MSF_BIGSYMDEF)
    {
        dwArrayOffset = seg.gd_psymoff * 16;
        pSymDefPtrs = (BYTE*)(new BYTE[seg.gd_csym*3]);
    }
    else
    {
        dwArrayOffset = seg.gd_psymoff;
        pSymDefPtrs = (BYTE*)(new BYTE[seg.gd_csym*2]);
    }
    hfFile = pFile->hfFile;

    SetFilePointer(hfFile, ulCurSeg + dwArrayOffset, NULL, FILE_BEGIN);

        // read symbol definition pointers array
    ReadFile(hfFile, pSymDefPtrs, seg.gd_csym * ((seg.gd_type & MSF_BIGSYMDEF)?3:2), &dwCread, NULL);

    pFile->psCurSymDefPtrs = pSymDefPtrs;

    // save this section
    pFile->dwCurSection = dwSection;

    // read symbols

    for (i = 0; i < seg.gd_csym; i++)
    {
        // go to offset of sym defintion
        if (seg.gd_type & MSF_BIGSYMDEF)
        {
            dwSymOffset = pFile->psCurSymDefPtrs[i*3+0]
                          + pFile->psCurSymDefPtrs[i*3+1]*256
                          + pFile->psCurSymDefPtrs[i*3+2]*65536;
        }
        else
        {
            dwSymOffset = pFile->psCurSymDefPtrs[i*2+0]
                          + pFile->psCurSymDefPtrs[i*2+1]*256;
        }

        SetFilePointer(hfFile, ulCurSeg + dwSymOffset, NULL, FILE_BEGIN);

        // read symbol address DWORD
        ReadFile(hfFile,&dwSymAddr,sizeof(DWORD),&dwCread,NULL);

        // symbol address is 1 word or two?
        nToRead = sizeof(SHORT) + ((seg.gd_type & MSF_32BITSYMS) * sizeof(SHORT));

        // calculate offset of symbol name
        ulSymNameOffset = ulCurSeg + dwSymOffset + nToRead;

        // use just lower word of address if 16-bit symbol
        if (!(seg.gd_type & MSF_32BITSYMS))
        {
            dwSymAddr = dwSymAddr & 0x0000FFFF;
        }
        dwSymAddr += dwOffsetToRva;

        if (dwSymAddr > uRva )  break;
        if (dwSymAddr == uRva )
        {
            // do we have our function?
            // if current address is greater than offset, then since we are
            // traversing in the increasing order of addresses, the previous
            // symbol must be our quarry

            SetFilePointer(hfFile, ulSymNameOffset, NULL, FILE_BEGIN);

            // read length of name
            ReadFile(hfFile,&cName,sizeof(TCHAR),&dwCread,NULL);

            nNameLen = (int) cName;

            // read symbol name
            ReadFile(hfFile,sztFuncName,nNameLen,&dwCread,NULL);

            sztFuncName[nNameLen/2 - (nNameLen+1)%2] = TCHAR('\0');

            UndecorateSymbol(sztFuncName);

            StrCpyNW(wszFuncName, sztFuncName, MAX_NAME);
            fResult = true;
        }
    }

Cleanup:

    if (pFile->hfFile)
        CloseHandle(pFile->hfFile);

    if (pFile->psCurSymDefPtrs)
        delete pFile->psCurSymDefPtrs;

    if (pFile)
        delete pFile;

    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\symtodbg\matchsym\symdef.h ===
/********************************************************************
Copyright (c) 1999 Microsoft Corporation

Module Name:
    symdef.h

Abstract:
    SYM file structures header

Revision History:

    Brijesh Krishnaswami (brijeshk) - 04/29/99 - Created
********************************************************************/

#ifndef _SYMDEF_H
#define _SYMDEF_H





#define MAX_PATH    260
#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus


// SYM File Structures

#pragma pack(1)                     // pack all data structures declared here 


// For each map within a symbol file (MAPDEF)

struct mapdef_s {
    unsigned short md_spmap;        // 16 bit SEG ptr to next map (0 if end) 
    unsigned char  md_abstype;      //  8 bit map/abs sym flags 
    unsigned char  md_pad;          //  8 bit pad 
    unsigned short md_segentry;     // 16 bit entry point segment value 
    unsigned short md_cabs;         // 16 bit count of constants in map 
    unsigned short md_pabsoff;      // 16 bit ptr to constant offsets 
    unsigned short md_cseg;         // 16 bit count of segments in map 
    unsigned short md_spseg;        // 16 bit SEG ptr to segment chain 
    unsigned char  md_cbnamemax;    //  8 bit maximum symbol name length 
    unsigned char  md_cbname;       //  8 bit symbol table name length 
    unsigned char  md_achname[1];   // <n> name of symbol table (.sym ) 
};

//#define CBMAPDEF    FIELDOFFSET(struct mapdef_s, md_achname)

struct endmap_s {
    unsigned short em_spmap;        // end of map chain (SEG ptr 0) 
    unsigned char  em_rel;          // release 
    unsigned char  em_ver;          // version 
};




// For each segment/group within a symbol table: (SEGDEF)


struct segdef_s {
    unsigned short gd_spsegnext;    // 16 bit SEG ptr to next segdef (0 if end),
                                    //  relative to mapdef 
    unsigned short gd_csym;         // 16 bit count of symbols in sym list 
    unsigned short gd_psymoff;      // 16 bit ptr to symbol offsets array,
                                    // 16 bit SEG ptr if MSF_BIG_GROUP set,
                                    //  either relative to segdef 
    unsigned short gd_lsa;          // 16 bit Load Segment address 
    unsigned short gd_in0;          // 16 bit instance 0 physical address 
    unsigned short gd_in1;          // 16 bit instance 1 physical address 
    unsigned short gd_in2;          // 16 bit instance 2 physical address 
    unsigned char  gd_type;         // 16 or 32 bit symbols in group 
    unsigned char  gd_pad;          // pad byte to fill space for gd_in3 
    unsigned short gd_spline;       // 16 bit SEG ptr to linedef,
                                    //  relative to mapdef 
    unsigned char  gd_fload;        // 8 bit boolean 0 if seg not loaded 
    unsigned char  gd_curin;        // 8 bit current instance 
    unsigned char  gd_cbname;       // 8 bit Segment name length 
    unsigned char  gd_achname[1];   // <n>  name of segment or group 
};

// values for md_abstype, gd_type 
#define MSF_32BITSYMS   0x01        // 32-bit symbols 
#define MSF_ALPHASYMS   0x02        // symbols sorted alphabetically, too 


// values for gd_type only 
#define MSF_BIGSYMDEF   0x04        // bigger than 64K of symdefs 


// values for md_abstype only 
#define MSF_ALIGN32 0x10            // 2MEG max symbol file, 32 byte alignment 
#define MSF_ALIGN64 0x20            // 4MEG max symbol file, 64 byte alignment 
#define MSF_ALIGN128    0x30        // 8MEG max symbol file, 128 byte alignment 
#define MSF_ALIGN_MASK  0x30





//  Followed by a list of SYMDEF's..
//  for each symbol within a segment/group: (SYMDEF)
 
struct symdef16_s {
    unsigned short sd_val;          // 16 bit symbol addr or const 
    unsigned char  sd_cbname;       //  8 bit symbol name length 
    unsigned char  sd_achname[1];   // <n> symbol name 
};


struct symdef_s {
    unsigned long sd_lval;          // 32 bit symbol addr or const 
    unsigned char sd_cbname;        //  8 bit symbol name length 
    unsigned char sd_achname[1];    // <n> symbol name 
};




#pragma pack()            // stop packing 


typedef struct mapdef_s MAPDEF;
typedef struct segdef_s SEGDEF;


// SYM file info for open files
typedef struct _osf {
    WCHAR   szwName[MAX_PATH];         // file name
    WCHAR   szwVersion[MAX_PATH];      // version
    DWORD   dwCheckSum;                 // checksum
    HANDLE  hfFile;                     // file handle 
    ULONG   ulFirstSeg;                 // first section's offset
    int     nSeg;                       // number of sections
    DWORD   dwCurSection;               // section for which symbol defintion ptrs are already available
    BYTE*  psCurSymDefPtrs;            // pointer to array of symbol defintion offsets
}   OPENFILE;


#define MAXOPENFILES 10
#define MAX_NAME 256


#ifdef __cplusplus
}
#endif  // __cplusplus


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\symtodbg\matchsym\symres.h ===
/*
    Copyright 1999 Microsoft Corporation
    
    Symbol resolver class

    Walter Smith (wsmith)

    changed Sivarudrappa Mahesh (smahesh)
 */

#pragma once

#include "symdef.h"

class SymbolResolver {
public:
    
OPENFILE*                                           // pointer to open file info
GetFile(LPWSTR szwModule                            // [in] name of file
        );

ULONG                                   // return offset of segment definition, 0 if failed
GetSegDef(OPENFILE*     pFile,            // [in] pointer to open file info
        DWORD         dwSection,        // [in] section number
        SEGDEF*       pSeg);              // [out] pointer to segment definition

bool 
GetNameFromAddr(
        LPWSTR      szwModule,           // [in] name of symbol file
        DWORD       dwSection,           // [in] section part of address to resolve
        DWORD       dwOffsetToRva,
        UINT_PTR    UOffset,              // [in] offset part of address to resolve
        LPWSTR      szwFuncName          // [out] resolved function name, 
        );       

private:
    WCHAR       m_szwSymDir[MAX_PATH];

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\symtodbg\symedit\makefile.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\symtodbg\matchsym\matchsym.cpp ===
// Adapted from Minidbg.c
// Original Authors : Matthew Hendel (math) and Matt Ruhlen (mruhlen)
// Copyright (c) 1999 Microsoft Corporation
// 
// Changed by (smahesh)
// The MdpExc Program which resolves sym files has been adapted to match sym files with
// the corresponding binary images. This is done by comparing the RVA's of the exported
// functions in the binary image with the RVA's of their symbols in the sym file.


#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys\stat.h>
#include <string.h>
#include <shlwapi.h>
#include "symres.h"
#include <dbghelp.h>

#define MAX_PATH 260
#define MAXSYMNAME 512

// parameter is used to typecast the result to the appropriate pointer type.
#define MakePtr( cast, ptr, addValue ) (cast)( (DWORD)(ptr) + (addValue) )

typedef DWORD ULONG_PTR;


PVOID
OpenMapping(
    IN PCWSTR FilePath
    )
{
    HANDLE hFile;
    HANDLE hMappedFile;
    PVOID MappedFile;
    

    hFile = CreateFileW(
                FilePath,
                GENERIC_READ,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                OPEN_EXISTING,
                0,
                NULL
                );

    if (hFile == INVALID_HANDLE_VALUE) {
        return NULL;
    }

    hMappedFile = CreateFileMapping(
                        hFile,
                        NULL,
                        PAGE_READONLY,
                        0,
                        0,
                        NULL
                        );

    if (!hMappedFile) {
        CloseHandle (hFile);
        return FALSE;
    }

    MappedFile = MapViewOfFile (
                        hMappedFile,
                        FILE_MAP_READ,
                        0,
                        0,
                        0
                        );

    CloseHandle (hMappedFile);
    CloseHandle (hFile);

    return MappedFile;
}


PIMAGE_SECTION_HEADER GetEnclosingSectionHeader(DWORD rva, PIMAGE_NT_HEADERS pNTHeader)
{
	PIMAGE_SECTION_HEADER section = IMAGE_FIRST_SECTION(pNTHeader);
    unsigned i;
    
    for ( i=0; i < pNTHeader->FileHeader.NumberOfSections; i++, section++ )  {
        // Is the RVA within this section?
        if ( (rva >= section->VirtualAddress) && 
             (rva < (section->VirtualAddress + section->Misc.VirtualSize)))
            return section;
    }
    
    return 0;

}


//   Compares the RVA's of the Exported Methods in the Binary with the RVA's of the corresponding
//   Symbols in the Sym file.
bool CheckSymFile(LPWSTR wszDllFileName, LPWSTR wszSymFileName)
{
    PVOID Mapping;
    PIMAGE_DOS_HEADER dosHeader;
    PIMAGE_EXPORT_DIRECTORY exportDir;
    PIMAGE_SECTION_HEADER header;
    PIMAGE_NT_HEADERS pNTHeader;
    INT delta;
    LPSTR filename;
    DWORD base;
    DWORD i;
    PDWORD functions;
    PWORD  ordinals;
    LPSTR *name;
    DWORD exportsStartRVA, exportsEndRVA;

    bool fResult = true;
    Mapping   = OpenMapping(wszDllFileName);
    dosHeader = (PIMAGE_DOS_HEADER)Mapping;

    if (dosHeader->e_magic != IMAGE_DOS_SIGNATURE )	{
        return false;
    }

    base            = (DWORD) dosHeader;
    pNTHeader       = MakePtr(PIMAGE_NT_HEADERS, dosHeader, dosHeader->e_lfanew );
    exportsStartRVA = pNTHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
    exportsEndRVA   = exportsStartRVA + pNTHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size;

    // Get the IMAGE_SECTION_HEADER that contains the exports.  This is
    // usually the .edata section, but doesn't have to be.
    header = GetEnclosingSectionHeader(exportsStartRVA, pNTHeader);
    if ( !header ) {
        printf("No Exports Table Found:");
        return false; 
    }

    delta     = (INT)(header->VirtualAddress - header->PointerToRawData);
    exportDir = MakePtr(PIMAGE_EXPORT_DIRECTORY, base, exportsStartRVA - delta);
    filename  = (PSTR)(exportDir->Name - delta + base);
    functions = (PDWORD)((DWORD)exportDir->AddressOfFunctions - delta + base);
    ordinals  = (PWORD)((DWORD)exportDir->AddressOfNameOrdinals - delta + base);
    name      = (PSTR *)((DWORD)exportDir->AddressOfNames - delta + base);

    PIMAGE_SECTION_HEADER pSecHeader;
    
    for (i=0; i < exportDir->NumberOfFunctions; i++) {
        DWORD entryPointRVA = functions[i];
        DWORD j;

        if ( entryPointRVA == 0 )   // Skip over gaps in exported function
            continue;               // ordinals (the entrypoint is 0 for
                                    // these functions).
                                    
        pSecHeader = ImageRvaToSection(pNTHeader, Mapping, entryPointRVA);
                                    
        // See if this function has an associated name exported for it.
        
        for ( j=0; j < exportDir->NumberOfNames; j++ ) {
            if ( ordinals[j] == i ) {
                SymbolResolver sr;
                WCHAR wszFunctionName[MAX_NAME];
                wszFunctionName[0] = L'\0';
				
                if (sr.GetNameFromAddr(wszSymFileName, 1, pSecHeader->VirtualAddress, entryPointRVA, wszFunctionName)) 
                    ;
                else if (sr.GetNameFromAddr(wszSymFileName, 2, pSecHeader->VirtualAddress, entryPointRVA, wszFunctionName))
                    ;
                else {
                    printf("\nNot Found  %s %S", (char *)(name[j] - delta + base), wszFunctionName );
                    fResult = false;
                }    
            }
        }

        // Is it a forwarder?  If so, the entry point RVA is inside the
        // .edata section, and is an RVA to the DllName.EntryPointName
        if ((entryPointRVA >= exportsStartRVA) &&
                (entryPointRVA <= exportsEndRVA)) {
            SymbolResolver sr;
            WCHAR wszFunctionName[MAX_NAME];
            wszFunctionName[0] = L'\0';
            if (sr.GetNameFromAddr(wszSymFileName, 1, pSecHeader->VirtualAddress, entryPointRVA, wszFunctionName)) 
                ;
            else if (sr.GetNameFromAddr(wszSymFileName, 2, pSecHeader->VirtualAddress, entryPointRVA, wszFunctionName))
                ;
            else {
                printf("Not Found  %s %S", (char *)(entryPointRVA - delta + base), wszFunctionName );
                fResult = false;
            }
        }
    }

    return fResult; 
}


void __cdecl wmain(int argc,WCHAR ** argv)
{
    WCHAR wszDllFileName[MAX_PATH] = L"";
    WCHAR wszSymFileName[MAX_PATH] = L"";
    bool fVerbose = false;
    int  nCount   = 0;
    
    __try {

        if (argc < 2 || argc > 4) {
            printf("\nUsage: Symchk [-v] [Binary] [Sym File]");
            printf("\n[v] Verbose");
            return;
        }    

        nCount++;

        if (argv[nCount][0] == L'-' && argc > 3) {
            fVerbose = true;
            nCount++;
        } 

        StrCpyNW(wszDllFileName, argv[nCount], MAX_NAME);
        nCount++;
        StrCpyNW(wszSymFileName, argv[nCount], MAX_NAME);

        if (CheckSymFile(wszDllFileName, wszSymFileName))
            printf("\n Result: Sym File Matched");
    }
    __except(1)	{
        // do nothing, just don't pass it to the user.
    }

    return;         
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\symtodbg\symcvt\cofftocv.c ===
/*++


Copyright 1996 - 1997 Microsoft Corporation

Module Name:

    cv.c

Abstract:

    This module handles the conversion activities requires for converting
    COFF debug data to CODEVIEW debug data.

Author:

    Wesley A. Witt (wesw) 19-April-1993

Environment:

    Win32, User Mode

--*/

#include <windows.h>
#include <imagehlp.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <strsafe.h>

#include "cv.h"
#define _SYMCVT_SOURCE_
#include "symcvt.h"
#include "cvcommon.h"

#ifndef DIMA
 #define DIMAT(Array, EltType) (sizeof(Array) / sizeof(EltType))
 #define DIMA(Array) DIMAT(Array, (Array)[0])
#endif

typedef struct tagOFFSETSORT {
    DWORD       dwOffset;          // offset for the symbol
    DWORD       dwSection;         // section number of the symbol
    DATASYM32   *dataSym;          // pointer to the symbol info
} OFFSETSORT;


#define n_name          N.ShortName
#define n_zeroes        N.Name.Short
#define n_nptr          N.LongName[1]
#define n_offset        N.Name.Long

static LPSTR GetSymName( PIMAGE_SYMBOL Symbol, PUCHAR StringTable, char *s, DWORD size );
DWORD  CreateModulesFromCoff( PPOINTERS p );
DWORD  CreatePublicsFromCoff( PPOINTERS p );
DWORD  CreateSegMapFromCoff( PPOINTERS p );
DWORD  CreateSrcLinenumbers( PPOINTERS p );



LONG
GuardPageFilterFunction(
    DWORD                ec,
    LPEXCEPTION_POINTERS lpep
    )

/*++

Routine Description:

    This function catches all exceptions from the convertcofftocv function
    and all that it calls.  The purpose of this function is allocate memory
    when it is necessary.  This happens because the cofftocv conversion cannot
    estimate the memory requirements before the conversion takes place.  To
    handle this properly space in the virtual address space is reserved, the
    reservation amount is 10 times the image size.  The first page is commited
    and then the conversion is started.  When an access violation occurs and the
    page that is trying to be access has a protection of noaccess then the
    page is committed.  Any other exception is not handled.

Arguments:

    ec      - the ecxeption code (should be EXCEPTION_ACCESS_VIOLATION)
    lpep    - pointer to the exception record and context record


Return Value:

    EXCEPTION_CONTINUE_EXECUTION    - access violation handled
    EXCEPTION_EXECUTE_HANDLER       - unknown exception and is not handled

--*/

{
    LPVOID                      vaddr;
    SYSTEM_INFO                 si;
    MEMORY_BASIC_INFORMATION    mbi;


    if (ec == EXCEPTION_ACCESS_VIOLATION) {
        vaddr = (LPVOID)lpep->ExceptionRecord->ExceptionInformation[1];
        VirtualQuery( vaddr, &mbi, sizeof(mbi) );
        if (mbi.AllocationProtect == PAGE_NOACCESS) {
            GetSystemInfo( &si );
            VirtualAlloc( vaddr, si.dwPageSize, MEM_COMMIT, PAGE_READWRITE );
            return EXCEPTION_CONTINUE_EXECUTION;
        }
    }

//  return EXCEPTION_CONTINUE_SEARCH;
    return EXCEPTION_EXECUTE_HANDLER;
}


BOOL
ConvertCoffToCv( PPOINTERS p )

/*++

Routine Description:

    This is the control function for the conversion of COFF to CODEVIEW
    debug data.  It calls individual functions for the conversion of
    specific types of debug data.


Arguments:

    p        - pointer to a POINTERS structure


Return Value:

    TRUE     - conversion succeded
    FALSE    - conversion failed

--*/

{
    SYSTEM_INFO                 si;
    DWORD                       cbsize;
    BOOL                        rval = TRUE;


    GetSystemInfo( &si );
    cbsize = max( p->iptrs.fsize * 10, si.dwPageSize * 10 );
    p->cbCvData = cbsize;

    //
    // reserve all necessary pages
    //
    p->pCvCurr = p->pCvStart.ptr = VirtualAlloc( NULL, cbsize, MEM_RESERVE, PAGE_NOACCESS );

    //
    // commit the first pages
    //
    VirtualAlloc( p->pCvCurr, min( cbsize, 5 * si.dwPageSize), MEM_COMMIT, PAGE_READWRITE );


    try {

        CreateSignature( p );
        CreateModulesFromCoff( p );
        CreatePublicsFromCoff( p );
        CreateSymbolHashTable( p );
        CreateAddressSortTable( p );
        CreateSegMapFromCoff( p );
//      CreateSrcLinenumbers( p );
        CreateDirectories( p );

    } except ( GuardPageFilterFunction( GetExceptionCode(), GetExceptionInformation() )) {

        VirtualFree( p->pCvStart.ptr, cbsize, MEM_DECOMMIT );
        p->pCvStart.ptr = NULL;
        rval = FALSE;

    }

    if (rval) {
        p->pCvCurr = malloc( p->pCvStart.size );
        CopyMemory( p->pCvCurr, p->pCvStart.ptr, p->pCvStart.size );
        VirtualFree( p->pCvStart.ptr, cbsize, MEM_DECOMMIT );
        p->pCvStart.ptr = p->pCvCurr;
    }

    return rval;
}


DWORD
CreateModulesFromCoff( PPOINTERS p )

/*++

Routine Description:

    Creates the individual CV module records.  There is one CV module
    record for each .FILE record in the COFF debug data.  This is true
    even if the COFF size is zero.


Arguments:

    p        - pointer to a POINTERS structure


Return Value:

    The number of modules that were created.

--*/

{
    int                 i,j;
    DWORD               dwOff;
    DWORD               numaux;
    DWORD               nummods = 0;
    char                szSymName[256];
    PIMAGE_SYMBOL       Symbol;
    PIMAGE_AUX_SYMBOL   AuxSymbol;
    OMFModule           *m = NULL;
    int                 cSeg = 0;
    char *              pb;
    BOOLEAN             rgfCode[500];


    memset(rgfCode, 2, sizeof(rgfCode));

    for (i=0,j=0, Symbol=p->iptrs.AllSymbols;
         i<(int)p->iptrs.numberOfSymbols;
         i+=numaux+1,Symbol+=numaux+1) {

        numaux = Symbol->NumberOfAuxSymbols;
        if (Symbol->StorageClass == IMAGE_SYM_CLASS_FILE) {
            j++;
        }

    }

    p->pMi = (LPMODULEINFO) malloc( sizeof(MODULEINFO) * (j + 1) );
    ZeroMemory( p->pMi, sizeof(MODULEINFO) * (j + 1) );


    if (!j) {
        //
        //  Handle the situation where there are not any .file records in the
        //  COFF symbol table.  This can happen for ROM images.  If this happens
        //  then we will fabricate a bogus module.
        //
        m = (OMFModule *) p->pCvCurr;
        m->ovlNumber = 0;
        m->iLib = 0;
        m->Style[0] = 'C';
        m->Style[1] = 'V';

        for (i=0,j=0, dwOff=0; i<p->iptrs.numberOfSections; i++) {
            if (p->iptrs.sectionHdrs[i].Characteristics & IMAGE_SCN_MEM_EXECUTE) {
                m->SegInfo[j].Seg = i + 1;
                m->SegInfo[j].cbSeg = p->iptrs.sectionHdrs[i].SizeOfRawData;
                m->SegInfo[j++].Off = dwOff;
            }
            dwOff += p->iptrs.sectionHdrs[i].SizeOfRawData;
        }

        m->cSeg = (unsigned short) j;

        StringCchCopyA(szSymName, DIMA(szSymName), "foo.c");
        pb = (char *) &m->SegInfo[j];
        *pb = (char)strlen(szSymName);
        memcpy(pb+1, szSymName, *pb);

        p->pMi[0].name = _strdup(szSymName);
        p->pMi[0].iMod = 1;
        p->pMi[0].cb = 0;
        p->pMi[0].SrcModule = 0;

        m = NextMod(m);
        p->modcnt = 1;
        UpdatePtrs( p, &p->pCvModules, (LPVOID)m, 1 );

        return 1;
    }


    for (i=0, Symbol = p->iptrs.AllSymbols;
         i < (int) p->iptrs.numberOfSymbols;
         i += numaux + 1, Symbol += numaux + 1) {

        //
        // Get the number of aux symbol records for this symbol
        //
        numaux = Symbol->NumberOfAuxSymbols;
        AuxSymbol = (PIMAGE_AUX_SYMBOL) (Symbol+1);

        if ((i == 0) && ((Symbol+numaux+1)->StorageClass != IMAGE_SYM_CLASS_FILE)) {
            //
            // we have a situation where the first '.file' record
            // is missing.  currently this only happens with the
            // claxp compiler on alpha.
            //
            m = (OMFModule *) p->pCvCurr;
            cSeg = 0;
            m->ovlNumber = 0;
            m->iLib = 0;
            m->Style[0] = 'C';
            m->Style[1] = 'V';
            StringCchCopyA( szSymName, DIMA(szSymName), "fake.c" );
        } else

        //
        //  If this is a FILE record -- then we need to create a
        //      module item to correspond to this file record.
        //

        if (Symbol->StorageClass == IMAGE_SYM_CLASS_FILE) {
            if (m == NULL) {
                m = (OMFModule *) p->pCvCurr;
            } else {
                //
                //      Clean up the last item,  if we saw any
                //      section records then drop them in here
                //

                if (cSeg > 0) {
                    m->cSeg  = (unsigned short) cSeg;
                    pb = (char *) &m->SegInfo[cSeg];
                    *pb = (char)strlen(szSymName);
                    memcpy(pb+1, szSymName, *pb);

                    p->pMi[nummods].name = _strdup(szSymName);
                    p->pMi[nummods].iMod = nummods + 1;
                    p->pMi[nummods].cb = 0;
                    p->pMi[nummods].SrcModule = 0;

                    m = NextMod(m);
                    nummods++;
                }
            }

            cSeg = 0;
            m->ovlNumber        = 0;
            m->iLib             = 0;
            m->Style[0]         = 'C';
            m->Style[1]         = 'V';

            /*
             *  Save off the file name to use when we have finished
             *  processing this module
             */

            memcpy(szSymName, (char *)AuxSymbol, numaux*sizeof(IMAGE_AUX_SYMBOL));
            szSymName[numaux*sizeof(IMAGE_AUX_SYMBOL)] = 0;

        }
        /*
         *  We have found a "SECTION" record.  Add the info to the
         *      module record
         */
        else
        if ((Symbol->SectionNumber & 0xffff) > 0xfff0) {
            continue;
        } else
        if (Symbol->SectionNumber > sizeof(rgfCode)/sizeof(rgfCode[0])) {
            return 0;
        } else
        if ((m != NULL) &&
            (rgfCode[Symbol->SectionNumber] != 0) &&
            (Symbol->StorageClass == IMAGE_SYM_CLASS_STATIC) &&
            ((*Symbol->n_name == '.') ||
             (Symbol->Type == IMAGE_SYM_TYPE_NULL)) &&
            (Symbol->NumberOfAuxSymbols == 1) &&
            (AuxSymbol->Section.Length != 0)) {

            if (rgfCode[Symbol->SectionNumber] == 2) {
                if ((p->iptrs.sectionHdrs[Symbol->SectionNumber - 1].
                    Characteristics & IMAGE_SCN_CNT_CODE) == 0) {
                    rgfCode[Symbol->SectionNumber] = 0;
                    continue;
                }
                rgfCode[Symbol->SectionNumber] = 1;
            }

            m->SegInfo[cSeg].Seg = Symbol->SectionNumber;
            m->SegInfo[cSeg].cbSeg = AuxSymbol->Section.Length;
            m->SegInfo[cSeg].Off = Symbol->Value -
                     p->iptrs.sectionHdrs[Symbol->SectionNumber-1].
                       VirtualAddress;
            cSeg += 1;
        }
    }

    /*
     *  Wrap up the last possible open module record
     */

    if (m != NULL) {
        if (cSeg > 0) {
            m->cSeg             = (unsigned short) cSeg;
            pb = (char *) &m->SegInfo[cSeg];
            *pb = (char)strlen(szSymName);
            memcpy(pb+1, szSymName, *pb);

            p->pMi[nummods].name = _strdup(szSymName);
            p->pMi[nummods].iMod = nummods + 1;
            p->pMi[nummods].cb = 0;
            p->pMi[nummods].SrcModule = 0;

            m = NextMod(m);
            nummods++;
        }
    }


    p->modcnt = nummods;
    UpdatePtrs( p, &p->pCvModules, (LPVOID)m, nummods );

    return nummods;
}


DWORD
CreatePublicsFromCoff( PPOINTERS p )

/*++

Routine Description:

    Creates the individual CV public symbol records.  There is one CV
    public record created for each COFF symbol that is marked as EXTERNAL
    and has a section number greater than zero.  The resulting CV publics
    are sorted by section and offset.


Arguments:

    p        - pointer to a POINTERS structure


Return Value:

    The number of publics created.

--*/

{
    int                 i;
    DWORD               numaux;
    DWORD               numsyms = 0;
    char                szSymName[256];
    PIMAGE_SYMBOL       Symbol;
    OMFSymHash          *omfSymHash;
    DATASYM32           *dataSym;
    DATASYM32           *dataSym2;
    size_t              size;

    omfSymHash = (OMFSymHash *) p->pCvCurr;
    size = (DWORD)omfSymHash + sizeof(OMFSymHash);
    dataSym = (DATASYM32 *) (PUCHAR)((DWORD)omfSymHash + sizeof(OMFSymHash));

    for (i= 0, Symbol = p->iptrs.AllSymbols;
         i < p->iptrs.numberOfSymbols;
         i += numaux + 1, Symbol += numaux + 1) {

        if ((Symbol->StorageClass == IMAGE_SYM_CLASS_EXTERNAL) &&
            (Symbol->SectionNumber > 0)) {

            if (GetSymName( Symbol, p->iptrs.stringTable, szSymName, DIMA(szSymName) )) {
                dataSym->rectyp = S_PUB32;
                dataSym->seg = Symbol->SectionNumber;
                dataSym->off = Symbol->Value -
                     p->iptrs.sectionHdrs[Symbol->SectionNumber-1].VirtualAddress;
                dataSym->typind = 0;
                dataSym->name[0] = (char)strlen( szSymName );
#if 0
                strcpy( &dataSym->name[1], szSymName );
#endif                
                StringCchCopyA(&dataSym->name[1],
                               p->cbCvData - (&dataSym->name[1] - p->pCvStart.ptr),
                               szSymName);
                dataSym2 = NextSym32( dataSym );
                dataSym->reclen = (USHORT) ((DWORD)dataSym2 - (DWORD)dataSym) - 2;
                dataSym = dataSym2;
                numsyms += 1;
            }
        }
        numaux = Symbol->NumberOfAuxSymbols;
    }

    UpdatePtrs( p, &p->pCvPublics, (LPVOID)dataSym, numsyms );

    omfSymHash->cbSymbol = p->pCvPublics.size - sizeof(OMFSymHash);
    omfSymHash->symhash  = 0;
    omfSymHash->addrhash = 0;
    omfSymHash->cbHSym   = 0;
    omfSymHash->cbHAddr  = 0;

    return numsyms;
}                               /* CreatePublisFromCoff() */


DWORD
CreateSrcLinenumbers(
    PPOINTERS p
    )

/*++

Routine Description:

    Creates the individual CV soure line number records.


Arguments:

    p        - pointer to a POINTERS structure


Return Value:

    The number of publics created.

--*/

{
    typedef struct _SEGINFO {
        DWORD   start;
        DWORD   end;
        DWORD   cbLines;
        DWORD   ptrLines;
        DWORD   va;
        DWORD   num;
        BOOL    used;
    } SEGINFO, *LPSEGINFO;

    typedef struct _SRCINFO {
        LPSEGINFO   seg;
        DWORD       numSeg;
        DWORD       cbSeg;
        CHAR        name[MAX_PATH+1];
    } SRCINFO, *LPSRCINFO;

    typedef struct _SECTINFO {
        DWORD       va;
        DWORD       size;
        DWORD       ptrLines;
        DWORD       numLines;
    } SECTINFO, *LPSECTINFO;


    DWORD               i;
    DWORD               j;
    DWORD               k;
    DWORD               l;
    DWORD               actual;
    DWORD               sidx;
    DWORD               NumSrcFiles;
    DWORD               SrcFileCnt;
    DWORD               numaux;
    PIMAGE_SYMBOL       Symbol;
    PIMAGE_AUX_SYMBOL   AuxSymbol;
    BOOL                first = TRUE;
    OMFSourceModule     *SrcModule;
    OMFSourceFile       *SrcFile;
    OMFSourceLine       *SrcLine;
    LPBYTE              lpb;
    LPDWORD             lpdw;
    PUSHORT             lps;
    PUCHAR              lpc;
    PIMAGE_LINENUMBER   pil, pilSave;
    LPSRCINFO           si;
    LPSECTINFO          sections;


    //
    // setup the section info structure
    //
    sections = (LPSECTINFO) malloc( sizeof(SECTINFO) * p->iptrs.numberOfSections );
    for (i=0; i<(DWORD)p->iptrs.numberOfSections; i++) {
        sections[i].va        = p->iptrs.sectionHdrs[i].VirtualAddress;
        sections[i].size      = p->iptrs.sectionHdrs[i].SizeOfRawData;
        sections[i].ptrLines  = p->iptrs.sectionHdrs[i].PointerToLinenumbers;
        sections[i].numLines  = p->iptrs.sectionHdrs[i].NumberOfLinenumbers;
    }

    //
    // count the number of source files that contibute linenumbers
    //
    SrcFileCnt = 100;
    si = (LPSRCINFO) malloc( sizeof(SRCINFO) * SrcFileCnt );
    ZeroMemory( si, sizeof(SRCINFO) * SrcFileCnt );
    for (i=0, j=0, Symbol=p->iptrs.AllSymbols, NumSrcFiles=0;
         i<(DWORD)p->iptrs.numberOfSymbols;
         i+=(numaux+1), Symbol+=(numaux + 1)) {

        numaux = Symbol->NumberOfAuxSymbols;
        AuxSymbol = (PIMAGE_AUX_SYMBOL) (Symbol+1);

        if (Symbol->StorageClass == IMAGE_SYM_CLASS_FILE) {

            if (!first) {
                si[NumSrcFiles].cbSeg = j;
                NumSrcFiles++;
                if (NumSrcFiles == SrcFileCnt) {
                    SrcFileCnt += 100;
                    si = (LPSRCINFO) realloc( si, sizeof(SRCINFO) * SrcFileCnt );
                }
            }

            memcpy(si[NumSrcFiles].name, (char *)AuxSymbol, numaux*sizeof(IMAGE_AUX_SYMBOL));
            si[NumSrcFiles].name[numaux*sizeof(IMAGE_AUX_SYMBOL)] = 0;
            si[NumSrcFiles].numSeg = 100;
            si[NumSrcFiles].seg = (LPSEGINFO) malloc( sizeof(SEGINFO) * si[NumSrcFiles].numSeg );
            ZeroMemory( si[NumSrcFiles].seg, sizeof(SEGINFO) * si[NumSrcFiles].numSeg );
            first = FALSE;
            j = 0;

        }

        //
        // we do not want to look for segment information until we
        // have found a valid source file
        //
        if (first) {
            continue;
        }

        //
        // check the symbol to see if it is a segment record
        //
        if (numaux && Symbol->StorageClass == IMAGE_SYM_CLASS_STATIC &&
            (*Symbol->n_name == '.' ||
             ((Symbol->Type & 0xf) == IMAGE_SYM_TYPE_NULL && AuxSymbol->Section.Length)) &&
            AuxSymbol->Section.NumberOfLinenumbers > 0) {

            //
            // find the section that this symbol belongs to
            //
            for (k=0; k<(DWORD)p->iptrs.numberOfSections; k++) {
                if (Symbol->Value >= sections[k].va &&
                    Symbol->Value < sections[k].va + sections[k].size) {

                    sidx = k;
                    break;

                }
            }

            if (k != (DWORD)p->iptrs.numberOfSections &&
                p->iptrs.sectionHdrs[k].NumberOfLinenumbers) {

                pil = (PIMAGE_LINENUMBER) (p->iptrs.fptr + sections[sidx].ptrLines);
                k = 0;

                while( k < AuxSymbol->Section.NumberOfLinenumbers ) {

                    //
                    // count the linenumbers in this section or sub-section
                    //
                    for ( pilSave=pil,l=0;
                          k<AuxSymbol->Section.NumberOfLinenumbers;
                          k++,pilSave++,l++ ) {

                        if ((k != (DWORD)AuxSymbol->Section.NumberOfLinenumbers-1) &&
                            (pilSave->Linenumber > (pilSave+1)->Linenumber)) {
                            pilSave++;
                            l++;
                            break;
                        }

                    }

                    //
                    // pil     == beginning of the range
                    // pilSave == end of the range
                    //

                    si[NumSrcFiles].seg[j].start =
                                     (pil->Type.VirtualAddress - sections[sidx].va);

                    if (sections[sidx].numLines == l) {
                        pilSave--;
                        si[NumSrcFiles].seg[j].end =
                                     (pilSave->Type.VirtualAddress - sections[sidx].va) + 1;
//                                   (Symbol->Value - sections[sidx].va) + 1;
                    } else {
                        si[NumSrcFiles].seg[j].end =
                                     (pilSave->Type.VirtualAddress - sections[sidx].va) - 1;
//                                   (Symbol->Value - sections[sidx].va) - 1;
                    }

                    si[NumSrcFiles].seg[j].ptrLines = sections[sidx].ptrLines;
                    si[NumSrcFiles].seg[j].cbLines = l;
                    si[NumSrcFiles].seg[j].va = sections[sidx].va;
                    si[NumSrcFiles].seg[j].num = sidx + 1;
                    si[NumSrcFiles].seg[j].used = FALSE;

                    sections[sidx].ptrLines += (l * sizeof(IMAGE_LINENUMBER));
                    sections[sidx].numLines -= l;

                    j++;
                    if (j == si[NumSrcFiles].numSeg) {
                        si[NumSrcFiles].numSeg += 100;
                        si[NumSrcFiles].seg = (LPSEGINFO) realloc( si[NumSrcFiles].seg, sizeof(SEGINFO) * si[NumSrcFiles].numSeg );
                    }
                    k++;
                    pil = pilSave;
                }

            }

        }

    }

    lpb = (LPBYTE) p->pCvCurr;

    //
    // if there is nothing to do then bail out
    //
    if (!NumSrcFiles) {
        UpdatePtrs( p, &p->pCvSrcModules, (LPVOID)lpb, 0 );
        return 0;
    }

    for (i=0,actual=0,l=0; i<NumSrcFiles; i++) {

        if (si[i].cbSeg == 0) {
            continue;
        }

        //
        // create the source module header
        //
        SrcModule = (OMFSourceModule*) lpb;
        SrcModule->cFile = 1;
        SrcModule->cSeg = (USHORT)si[i].cbSeg;
        SrcModule->baseSrcFile[0] = 0;

        //
        // write the start/end pairs
        //
        lpdw = (LPDWORD) ((LPBYTE)SrcModule + sizeof(OMFSourceModule));
        for (k=0; k<si[i].cbSeg; k++) {
            *lpdw++ = si[i].seg[k].start;
            *lpdw++ = si[i].seg[k].end;
        }

        //
        // write the segment numbers
        //
        lps = (PUSHORT) lpdw;
        for (k=0; k<si[i].cbSeg; k++) {
            *lps++ = (USHORT)si[i].seg[k].num;
        }

        //
        // align to a dword boundry
        //
        lps = (PUSHORT) ((LPBYTE)lps + align(lps));

        //
        // update the base pointer
        //
        SrcModule->baseSrcFile[0] = (DWORD) ((LPBYTE)lps - (LPBYTE)SrcModule);

        //
        // write the source file record
        //
        SrcFile = (OMFSourceFile*) lps;
        SrcFile->cSeg = (USHORT)si[i].cbSeg;
        SrcFile->reserved = 0;

        for (k=0; k<si[i].cbSeg; k++) {
            SrcFile->baseSrcLn[k] = 0;
        }

        //
        // write the start/end pairs
        //
        lpdw = (LPDWORD) ((LPBYTE)SrcFile + 4 + (4 * si[i].cbSeg));
        for (k=0; k<si[i].cbSeg; k++) {
            *lpdw++ = si[i].seg[k].start;
            *lpdw++ = si[i].seg[k].end;
        }

        //
        // write the source file name
        //
        lpc = (PUCHAR) lpdw;
        k = strlen(si[i].name);
        *lpc++ = (UCHAR) k;
        StringCchCopyA(lpc, p->cbCvData - (lpc - p->pCvStart.ptr), si[i].name);
        lpb = lpc + k;

        //
        // find the module info struct
        //
        for (; l<p->modcnt; l++) {
            if (_stricmp(p->pMi[l].name,si[i].name)==0) {
                break;
            }
        }

        p->pMi[l].SrcModule = (DWORD) SrcModule;

        //
        // align to a dword boundry
        //
        lpb = (LPBYTE) (lpb + align(lpb));

        //
        // create the line number pairs
        //
        for (k=0; k<si[i].cbSeg; k++) {

            //
            // find the first line number that applies to this segment
            //
            pil = (PIMAGE_LINENUMBER) (p->iptrs.fptr + si[i].seg[k].ptrLines);

            //
            // update the base pointer
            //
            SrcFile->baseSrcLn[k] = (DWORD) (lpb - (LPBYTE)SrcModule);

            //
            // write the line numbers
            //
            SrcLine = (OMFSourceLine*) lpb;
            SrcLine->Seg = (USHORT)si[i].seg[k].num;
            SrcLine->cLnOff = (USHORT) si[i].seg[k].cbLines;
            pilSave = pil;
            lpdw = (LPDWORD) (lpb + 4);
            for (j=0; j<SrcLine->cLnOff; j++) {
                *lpdw++ = pil->Type.VirtualAddress - si[i].seg[k].va;
                pil++;
            }
            lps = (PUSHORT) lpdw;
            pil = pilSave;
            for (j=0; j<SrcLine->cLnOff; j++) {
                *lps++ = pil->Linenumber;
                pil++;
            }

            //
            // align to a dword boundry
            //
            lps = (PUSHORT) ((LPBYTE)lps + align(lps));

            lpb = (LPBYTE) lps;
        }

        p->pMi[l].cb = (DWORD)lpb - (DWORD)SrcModule;
        actual++;

    }

    UpdatePtrs( p, &p->pCvSrcModules, (LPVOID)lpb, actual );

    //
    // cleanup all allocated memory
    //

    free( sections );

    for (i=0; i<SrcFileCnt; i++) {
        if (si[i].seg) {
            free( si[i].seg );
        }
    }

    free( si );

    return NumSrcFiles;
}                               /* CreateSrcLinenumbers() */


DWORD
CreateSegMapFromCoff( PPOINTERS p )

/*++

Routine Description:

    Creates the CV segment map.  The segment map is used by debuggers
    to aid in address lookups.  One segment is created for each COFF
    section in the image.

Arguments:

    p        - pointer to a POINTERS structure


Return Value:

    The number of segments in the map.

--*/

{
    int                         i;
    SGM                         *sgm;
    SGI                         *sgi;
    PIMAGE_SECTION_HEADER       sh;


    sgm = (SGM *) p->pCvCurr;
    sgi = (SGI *) ((DWORD)p->pCvCurr + sizeof(SGM));

    sgm->cSeg = (unsigned short) p->iptrs.numberOfSections;
    sgm->cSegLog = (unsigned short) p->iptrs.numberOfSections;

    sh = p->iptrs.sectionHdrs;

    for (i=0; i<p->iptrs.numberOfSections; i++, sh++) {
        sgi->sgf.fRead        = (USHORT) (sh->Characteristics & IMAGE_SCN_MEM_READ) ==    IMAGE_SCN_MEM_READ;
        sgi->sgf.fWrite       = (USHORT) (sh->Characteristics & IMAGE_SCN_MEM_WRITE) ==   IMAGE_SCN_MEM_WRITE;
        sgi->sgf.fExecute     = (USHORT) (sh->Characteristics & IMAGE_SCN_MEM_EXECUTE) == IMAGE_SCN_MEM_EXECUTE;
        sgi->sgf.f32Bit       = 1;
        sgi->sgf.fSel         = 0;
        sgi->sgf.fAbs         = 0;
        sgi->sgf.fGroup       = 1;
        sgi->iovl             = 0;
        sgi->igr              = 0;
        sgi->isgPhy           = (USHORT) i + 1;
        sgi->isegName         = 0;
        sgi->iclassName       = 0;
        sgi->doffseg          = 0;
        sgi->cbSeg            = sh->SizeOfRawData;
        sgi++;
    }

    UpdatePtrs( p, &p->pCvSegMap, (LPVOID)sgi, i );

    return i;
}


LPSTR
GetSymName( PIMAGE_SYMBOL Symbol, PUCHAR StringTable, char *s, DWORD size )

/*++

Routine Description:

    Extracts the COFF symbol from the image symbol pointer and puts
    the ascii text in the character pointer passed in.


Arguments:

    Symbol        - COFF Symbol Record
    StringTable   - COFF string table
    s             - buffer for the symbol string


Return Value:

    void

--*/

{
    DWORD i;

    if (Symbol->n_zeroes) {
        for (i=0; i<8; i++) {
            if ((Symbol->n_name[i]>0x1f) && (Symbol->n_name[i]<0x7f)) {
                *s++ = Symbol->n_name[i];
            }
        }
        *s = 0;
    }
    else {
        if (StringTable[Symbol->n_offset] == '?') {
            i = UnDecorateSymbolName( &StringTable[Symbol->n_offset],
                                  s,
                                  255,
                                  UNDNAME_COMPLETE                |
                                  UNDNAME_NO_LEADING_UNDERSCORES  |
                                  UNDNAME_NO_MS_KEYWORDS          |
                                  UNDNAME_NO_FUNCTION_RETURNS     |
                                  UNDNAME_NO_ALLOCATION_MODEL     |
                                  UNDNAME_NO_ALLOCATION_LANGUAGE  |
                                  UNDNAME_NO_MS_THISTYPE          |
                                  UNDNAME_NO_CV_THISTYPE          |
                                  UNDNAME_NO_THISTYPE             |
                                  UNDNAME_NO_ACCESS_SPECIFIERS    |
                                  UNDNAME_NO_THROW_SIGNATURES     |
                                  UNDNAME_NO_MEMBER_TYPE          |
                                  UNDNAME_NO_RETURN_UDT_MODEL     |
                                  UNDNAME_NO_ARGUMENTS            |
                                  UNDNAME_NO_SPECIAL_SYMS         |
                                  UNDNAME_NAME_ONLY
                                );
            if (!i) {
                return NULL;
            }
        } else {
            StringCchCopyA( s, size, &StringTable[Symbol->n_offset] );
        }
    }

    return s;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\symtodbg\symcvt\cvcommon.c ===
/*++

Copyright 1996 - 1997 Microsoft Corporation

Module Name:

    cvcommon.c

Abstract:

    This file contians a set of common routines which are used in
    doing symbol conversions from one type of symbols to CodeView
    symbols.

Author:

    Wesley A. Witt (wesw) 19-April-1993
    Jim Schaad (jimsch) 22 May 1993

--*/

#include        <windows.h>
#include        <stdlib.h>
#include        "cv.h"
#include        "symcvt.h"
#include        "cvcommon.h"

typedef struct tagSYMHASH {
    DWORD       dwHashVal;         // hash value for the symbol
    DWORD       dwHashBucket;      // hash bucket number
    DATASYM32 * dataSym;           // pointer to the symbol info
} SYMHASH;

typedef struct tagOFFSETSORT {
    DWORD       dwOffset;          // offset for the symbol
    DWORD       dwSection;         // section number of the symbol
    DATASYM32 * dataSym;           // pointer to the symbol info
} OFFSETSORT;


int __cdecl SymHashCompare( const void *arg1, const void *arg2 );
int __cdecl OffsetSortCompare( const void *arg1, const void *arg2 );

DWORD
CreateSignature( PPOINTERS p )

/*++

Routine Description:

    Creates the CODEVIEW signature record.  Currently this converter only
    generates NB09 data (MS C/C++ 8.0).


Arguments:

    p        - pointer to a POINTERS structure (see symcvt.h)


Return Value:

    number of records generates, this is always 1.

--*/

{
    OMFSignature        *omfSig;

    omfSig = (OMFSignature *) p->pCvCurr;
    strcpy( omfSig->Signature, "NB09" );
    omfSig->filepos = 0;
    p->pCvStart.size += sizeof(OMFSignature);
    p->pCvCurr = (PUCHAR) p->pCvCurr + sizeof(OMFSignature);
    return 1;
}                               /* CreateSignature() */

DWORD
CreateDirectories( PPOINTERS p )

/*++

Routine Description:

    This is the control function for the generation of the CV directories.
    It calls individual functions for the generation of specific types of
    debug directories.


Arguments:

    p        - pointer to a POINTERS structure (see symcvt.h)


Return Value:

    the number of directories created.

--*/

{
    OMFDirHeader        *omfDir = (OMFDirHeader *)p->pCvCurr;
    OMFSignature        *omfSig = (OMFSignature *)p->pCvStart.ptr;
    OMFDirEntry         *omfDirEntry = NULL;

    omfSig->filepos = (DWORD)p->pCvCurr - (DWORD)p->pCvStart.ptr;

    omfDir->cbDirHeader = sizeof(OMFDirHeader);
    omfDir->cbDirEntry  = sizeof(OMFDirEntry);
    omfDir->cDir        = 0;
    omfDir->lfoNextDir  = 0;
    omfDir->flags       = 0;

    p->pCvStart.size += sizeof(OMFDirHeader);
    p->pCvCurr = (PUCHAR) p->pCvCurr + sizeof(OMFDirHeader);

    omfDir->cDir += CreateModuleDirectoryEntries( p );
    omfDir->cDir += CreatePublicDirectoryEntries( p );
    omfDir->cDir += CreateSegMapDirectoryEntries( p );
    omfDir->cDir += CreateSrcModulesDirectoryEntries( p );

    strcpy(p->pCvCurr, "NB090000");
    p->pCvStart.size += 8;
    p->pCvCurr += 8;
    *((DWORD *) (p->pCvCurr-4)) = p->pCvStart.size;

    return omfDir->cDir;
}                               /* CreateDirectories() */

DWORD
CreateModuleDirectoryEntries( PPOINTERS p )

/*++

Routine Description:

    Creates directory entries for each module in the image.


Arguments:

    p        - pointer to a POINTERS structure (see symcvt.h)


Return Value:

    the number of directory entries created.

--*/

{
    OMFDirEntry   *omfDirEntry = NULL;
    OMFModule     *m = NULL;
    OMFModule     *mNext = NULL;
    DWORD         i = 0;
    DWORD         mSize = 0;
    DWORD         lfo = (DWORD)p->pCvModules.ptr - (DWORD)p->pCvStart.ptr;

    m = (OMFModule *) p->pCvModules.ptr;
    for (i=0; i<p->pCvModules.count; i++) {
        mNext = NextMod(m);

        omfDirEntry = (OMFDirEntry *) p->pCvCurr;

        mSize = (DWORD)mNext - (DWORD)m;
        omfDirEntry->SubSection = sstModule;
        omfDirEntry->iMod       = (USHORT) i + 1;
        omfDirEntry->lfo        = lfo;
        omfDirEntry->cb         = mSize;

        lfo += mSize;

        p->pCvStart.size += sizeof(OMFDirEntry);
        p->pCvCurr = (PUCHAR) p->pCvCurr + sizeof(OMFDirEntry);

        m = mNext;
    }

    return p->pCvModules.count;
}                               /* CreateModuleDirectoryEntries() */

DWORD
CreatePublicDirectoryEntries( PPOINTERS p )

/*++

Routine Description:

    Creates the directory entry for the global publics.

Arguments:

    p        - pointer to a POINTERS structure (see symcvt.h)


Return Value:

    the number of directory entries created, always 1.

--*/

{
    OMFDirEntry   *omfDirEntry = (OMFDirEntry *) p->pCvCurr;

    omfDirEntry->SubSection = sstGlobalPub;
    omfDirEntry->iMod       = 0xffff;
    omfDirEntry->lfo        = (DWORD)p->pCvPublics.ptr - (DWORD)p->pCvStart.ptr;
    omfDirEntry->cb         = p->pCvPublics.size;

    p->pCvStart.size += sizeof(OMFDirEntry);
    p->pCvCurr = (PUCHAR) p->pCvCurr + sizeof(OMFDirEntry);

    return 1;
}                               /* CreatePublicDirectoryEntries() */


DWORD
CreateSegMapDirectoryEntries( PPOINTERS p )

/*++

Routine Description:

    Creates the directory entry for the segment map.


Arguments:

    p        - pointer to a POINTERS structure (see symcvt.h)


Return Value:

    the number of directory entries created, always 1.

--*/

{
    OMFDirEntry   *omfDirEntry = (OMFDirEntry *) p->pCvCurr;

    omfDirEntry->SubSection = sstSegMap;
    omfDirEntry->iMod       = 0xffff;
    omfDirEntry->lfo        = (DWORD)p->pCvSegMap.ptr - (DWORD)p->pCvStart.ptr;
    omfDirEntry->cb         = p->pCvSegMap.size;

    p->pCvStart.size += sizeof(OMFDirEntry);
    p->pCvCurr = (PUCHAR) p->pCvCurr + sizeof(OMFDirEntry);

    return 1;
}                               /* CreateSegMapDirectoryEntries() */

DWORD
CreateSrcModulesDirectoryEntries( PPOINTERS p )

/*++

Routine Description:

    Creates directory entries for each source module in the image.


Arguments:

    p        - pointer to a POINTERS structure (see symcvt.h)


Return Value:

    the number of directory entries created.

--*/

{
    OMFDirEntry         *omfDirEntry = NULL;
    DWORD               i;
    DWORD               lfo = (DWORD)p->pCvSrcModules.ptr - (DWORD)p->pCvStart.ptr;
    DWORD               j = lfo;
    OMFSourceModule     *m;


    //
    // if there were no linenumber conversions then bail out
    //
    if (!p->pCvSrcModules.count) {
        return 0;
    }

    for (i=0; i<p->pCvSrcModules.count; i++) {

        if (!p->pMi[i].SrcModule) {
            continue;
        }

        omfDirEntry = (OMFDirEntry *) p->pCvCurr;

        omfDirEntry->SubSection = sstSrcModule;
        omfDirEntry->iMod = (USHORT) p->pMi[i].iMod;
        omfDirEntry->lfo = lfo;
        omfDirEntry->cb = p->pMi[i].cb;

        m = (OMFSourceModule*) p->pMi[i].SrcModule;

        lfo += omfDirEntry->cb;

        p->pCvStart.size += sizeof(OMFDirEntry);
        p->pCvCurr = (PUCHAR) p->pCvCurr + sizeof(OMFDirEntry);
    }

    free( p->pMi );

    return p->pCvSrcModules.count;
}                               /* CreateSrcModulesDirectoryEntries() */


#define byt_toupper(b)      (b & 0xDF)
#define dwrd_toupper(dw)    (dw & 0xDFDFDFDF)

DWORD
DWordXorLrl( char *szSym )

/*++

Routine Description:

    This function will take an ascii character string and generate
    a hash for that string.  The hash algorithm is the CV NB09 hash
    algorithm.


Arguments:

    szSym    - a character pointer, the first char is the string length


Return Value:

    The generated hash value.

--*/

{
    char                *pName = szSym+1;
    int                 cb =  (int)(*szSym & 0x000000FF); // byte to int conversion.
    char                *pch;
    char                c;
    DWORD               hash = 0, ulEnd = 0;
    DWORD UNALIGNED     *pul;

    // Replace all "::" with "__" for hashing purposes

    c = *(pName+cb);
    *(pName+cb) = '\0';
    pch = strstr( pName, "::" );
    if ( pch ) {
        *pch++ = '_';
        *pch   = '_';
    }
    *(pName+cb) = c;

    // If we're standard call, skip the trailing @999

    pch = pName + cb - 1;
    while (isdigit(*pch)) {
        pch--;
    }

    if (*pch == '@') {
        cb = pch - pName;
    }

    // If we're fastcall, skip the leading '@'

    if (*pName == '@') {
        pName++;
        cb--;
    }

    // Calculate the odd byte hash.

    while (cb & 3) {
        ulEnd |= byt_toupper (pName[cb-1]);
        ulEnd <<=8;
        cb--;
    }

    pul = (DWORD UNALIGNED *)pName;

    // calculate the dword hash for the remaining

    while (cb) {
        hash ^= dwrd_toupper(*pul);
        hash = _lrotl (hash, 4);
        pul++;
        cb -=4;
    }

    // or in the remainder

    hash ^= ulEnd;

    return hash;
}                               /* DWordXorLrl() */


OMFModule *
NextMod(
        OMFModule *             pMod
        )
/*++

Routine Description:

    description-of-function.

Arguments:

    argument-name - Supplies | Returns description of argument.
    .
    .

Return Value:

    return-value - Description of conditions needed to return value. - or -
    None.

--*/

{
    char *      pb;

    pb = (char *) &(pMod->SegInfo[pMod->cSeg]);
    pb += *pb + 1;
    pb = (char *) (((unsigned long) pb + 3) & ~3);

    return (OMFModule *) pb;
}                               /* NextMod() */


int
__cdecl
SymHashCompare(
               const void *     arg1,
               const void *     arg2
               )
/*++

Routine Description:

    Sort compare function for sorting SYMHASH records by hashed
    bucket number.


Arguments:

    arg1     - record #1
    arg2     - record #2


Return Value:

   -1        - record #1 is < record #2
    0        - records are equal
    1        - record #1 is > record #2

--*/

{
    if (((SYMHASH*)arg1)->dwHashBucket < ((SYMHASH*)arg2)->dwHashBucket) {
        return -1;
    }
    if (((SYMHASH*)arg1)->dwHashBucket > ((SYMHASH*)arg2)->dwHashBucket) {
        return 1;
    }

    // BUGBUG: Should we second sort on the hash value?

    return 0;
}                               /* SymHashCompare() */

// Symbol Offset/Hash structure

typedef struct _SOH {
    DWORD uoff;
    DWORD ulHash;
} SOH;

#define MINHASH     6           // Don't create a hash with fewer than 6 slots

DWORD
CreateSymbolHashTable(
    PPOINTERS p
    )
/*++

Routine Description:

    Creates the CV symbol hash table.  This hash table is used
    primarily by debuggers to access symbols in a quick manner.

Arguments:

    p        - pointer to a POINTERS structure (see symcvt.h)

Return Value:

    The number of buckets is the hash table.

--*/
{
    DWORD           i;
    DWORD           j;
    int             k;
    DWORD           numsyms;
    DWORD           numbuckets;
    OMFSymHash      *omfSymHash;
    DATASYM32       *dataSymStart;
    DATASYM32       *dataSym;
    LPVOID          pHashData;
    USHORT          *pCHash;
    DWORD           *pHashTable;
    DWORD           *pBucketCounts;
    DWORD           *pChainTable;
    SYMHASH         *symHashStart;
    SYMHASH         *symHash;
//    DWORD           dwHashVal;
    char *          sz;

    numsyms = p->pCvPublics.count;
    numbuckets = (numsyms+9) / 10;
    numbuckets = (1 + numbuckets) & ~1;
    numbuckets = __max(numbuckets, MINHASH);

    symHashStart =
    symHash = (SYMHASH *) malloc( numsyms * sizeof(SYMHASH) );
    if (symHashStart == NULL) {
        return 0;
    }

    memset( symHashStart, 0, numsyms * sizeof(SYMHASH) );

    pHashData = (LPVOID) p->pCvCurr;
    pCHash = (USHORT *) pHashData;
    pHashTable = (DWORD *) ((DWORD)pHashData + sizeof(DWORD));
    pBucketCounts = (DWORD *) ((DWORD)pHashTable +
                                  (sizeof(DWORD) * numbuckets));
    memset(pBucketCounts, 0, sizeof(DWORD) * numbuckets);

    pChainTable = (DWORD *) ((DWORD)pBucketCounts +
                                 ((sizeof(ULONG) * numbuckets)));

    omfSymHash = (OMFSymHash *) p->pCvPublics.ptr;
    dataSymStart =
    dataSym = (DATASYM32 *) ((DWORD)omfSymHash + sizeof(OMFSymHash));

    *pCHash = (USHORT)numbuckets;

    /*
     *  cruise thru the symbols and calculate the hash values
     *  and the hash bucket numbers; save the info away for later use
     */
    for (i=0; i<numsyms; i++, symHash++) {
        switch( dataSym->rectyp ) {
        case S_PUB16:
            sz = dataSym->name;
            break;

        case S_PUB32:
            sz = ((DATASYM32 *) dataSym)->name;
            break;

        default:
            continue;
        }

        symHash->dwHashVal = DWordXorLrl( sz );
        symHash->dwHashBucket = symHash->dwHashVal % numbuckets;
        pBucketCounts[symHash->dwHashBucket] += 1;
        symHash->dataSym = dataSym;
        dataSym = ((DATASYM32 *) ((char *) dataSym + dataSym->reclen + 2));
    }

    qsort( (void*)symHashStart, numsyms, sizeof(SYMHASH), SymHashCompare );

    j = (char *)pChainTable - (char *)pHashData;
    for (i=0, k = 0;
         i < numbuckets;
         k += pBucketCounts[i], i += 1, pHashTable++ )
    {
        *pHashTable = (DWORD) j + (k * sizeof(DWORD) * 2);
    }

    dataSymStart = (DATASYM32 *) (PUCHAR)((DWORD)omfSymHash);
    for (i=0,symHash=symHashStart; i<numsyms; i++,symHash++,pChainTable++) {
        *pChainTable = (DWORD) (DWORD)symHash->dataSym - (DWORD)dataSymStart;
        ++pChainTable;
        *pChainTable = symHash->dwHashVal;
    }

    UpdatePtrs( p, &p->pCvSymHash, (LPVOID)pChainTable, numsyms );

    omfSymHash->symhash = 10;
    omfSymHash->cbHSym = p->pCvSymHash.size;

    free( symHashStart );

    return numbuckets;
}                               /* CreateSymbolHashTable() */

VOID
UpdatePtrs( PPOINTERS p, PPTRINFO pi, LPVOID lpv, DWORD count )

/*++

Routine Description:

    This function is called by ALL functions that put data into the
    CV data area.  After putting the data into the CV memory this function
    must be called.  It will adjust all of the necessary pointers so the
    the next guy doesn't get hosed.


Arguments:

    p        - pointer to a POINTERS structure (see symcvt.h)
    pi       - the CV pointer that is to be updated
    lpv      - current pointer into the CV data
    count    - the number of items that were placed into the CV data


Return Value:

    void

--*/

{
    if (!count) {
        return;
    }

    pi->ptr = p->pCvCurr;
    pi->size = (DWORD) ((DWORD)lpv - (DWORD)p->pCvCurr);
    pi->count = count;

    p->pCvStart.size += pi->size;
    p->pCvCurr = (PUCHAR) lpv;

    return;
}                               /* UpdatePtrs() */

int
__cdecl
OffsetSortCompare( const void *arg1, const void *arg2 )

/*++

Routine Description:

    Sort compare function for sorting OFFETSORT records by section number.


Arguments:

    arg1     - record #1
    arg2     - record #2


Return Value:

   -1        - record #1 is < record #2
    0        - records are equal
    1        - record #1 is > record #2

--*/

{
    if (((OFFSETSORT*)arg1)->dwSection < ((OFFSETSORT*)arg2)->dwSection) {
        return -1;
    }
    if (((OFFSETSORT*)arg1)->dwSection > ((OFFSETSORT*)arg2)->dwSection) {
        return 1;
    }
    if (((OFFSETSORT*)arg1)->dwOffset < ((OFFSETSORT*)arg2)->dwOffset) {
        return -1;
    }
    if (((OFFSETSORT*)arg1)->dwOffset > ((OFFSETSORT*)arg2)->dwOffset) {
        return 1;
    }
    return 0;
}                               /* OffsetSortCompare() */

DWORD
CreateAddressSortTable( PPOINTERS p )

/*++

Routine Description:


    Creates the CV address sort table. This hash table is used
    primarily by debuggers to access symbols in a quick manner when
    all you have is an address.

Arguments:

    p        - pointer to a POINTERS structure (see symcvt.h)


Return Value:

    The number of sections in the table.

--*/

{
    DWORD               i;
    DWORD               j;
    int                 k;
    DWORD               numsyms = p->pCvPublics.count;
    DWORD               numsections;
    OMFSymHash          *omfSymHash;
    DATASYM32           *dataSymStart;
    DATASYM32           *dataSym;
    LPVOID              pAddressData;
    USHORT              *pCSeg;
    DWORD               *pSegTable;
    DWORD               *pOffsetCounts;
    DWORD               *pOffsetTable;
    OFFSETSORT          *pOffsetSortStart;
    OFFSETSORT          *pOffsetSort;

    extern int          CSymSegs;

    if (p->iptrs.fileHdr) {
        numsections = p->iptrs.fileHdr->NumberOfSections;
    } else if (p->iptrs.sepHdr) {
        numsections = p->iptrs.sepHdr->NumberOfSections;
    } else {
        numsections = CSymSegs;
    }

    pOffsetSortStart =
      pOffsetSort = (OFFSETSORT *) malloc( numsyms * sizeof(OFFSETSORT) );

    if (pOffsetSort == NULL) {
        return 0;
    }

    memset( pOffsetSortStart, 0, numsyms * sizeof(OFFSETSORT) );

    pAddressData = (LPVOID) p->pCvCurr;
    pCSeg = (USHORT *) pAddressData;
    pSegTable = (DWORD *) ((DWORD)pAddressData + sizeof(DWORD));
    pOffsetCounts = (DWORD *) ((DWORD)pSegTable +
                                (sizeof(DWORD) * numsections));
    pOffsetTable = (DWORD *) ((DWORD)pOffsetCounts +
                              ((sizeof(DWORD) * numsections)));
//    if (numsections & 1) {
//        pOffsetTable = (DWORD *) ((DWORD)pOffsetTable + 2);
//    }

    omfSymHash = (OMFSymHash *) p->pCvPublics.ptr;
    dataSymStart =
      dataSym = (DATASYM32 *) ((DWORD)omfSymHash + sizeof(OMFSymHash));

    *pCSeg = (USHORT)numsections;

    for (i=0;
         i<numsyms;
         i++, pOffsetSort++)
    {
        switch(dataSym->rectyp) {
        case S_PUB16:
            pOffsetSort->dwOffset = dataSym->off;
            pOffsetSort->dwSection = dataSym->seg;
            break;

        case S_PUB32:
            pOffsetSort->dwOffset = ((DATASYM32 *) dataSym)->off;
            pOffsetSort->dwSection = ((DATASYM32 *) dataSym)->seg;
        }

        pOffsetSort->dataSym = dataSym;
        pOffsetCounts[pOffsetSort->dwSection - 1] += 1;
        dataSym = ((DATASYM32 *) ((char *) dataSym + dataSym->reclen + 2));    }

//#if 0
    qsort((void*)pOffsetSortStart, numsyms, sizeof(OFFSETSORT), OffsetSortCompare );
//#endif

    j = (DWORD) (DWORD)pOffsetTable - (DWORD)pAddressData;
    for (i=0, k=0;
         i < numsections;
         k += pOffsetCounts[i], i += 1, pSegTable++)
    {
        *pSegTable = (DWORD) j + (k * sizeof(DWORD) * 2);
    }

    dataSymStart = (DATASYM32 *) (PUCHAR)((DWORD)omfSymHash);
    for (i=0, pOffsetSort=pOffsetSortStart;
         i < numsyms;
         i++, pOffsetSort++, pOffsetTable++)
    {
        *pOffsetTable = (DWORD)pOffsetSort->dataSym - (DWORD)dataSymStart;
        pOffsetTable++;
        *pOffsetTable = pOffsetSort->dwOffset;
    }

    UpdatePtrs( p, &p->pCvAddrSort, (LPVOID)pOffsetTable, numsyms );

    omfSymHash->addrhash = 12;
    omfSymHash->cbHAddr = p->pCvAddrSort.size;

    free( pOffsetSortStart );

    return numsections;
}                               /* CreateAddressSort() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\symtodbg\symcvt\makefile.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\symtodbg\symcvt\file.c ===
/*++


Copyright 1996 - 1997 Microsoft Corporation

Module Name:

    file.c

Abstract:

    This module handles all file i/o for SYMCVT.  This includes the
    mapping of all files and establishing all file pointers for the
    mapped file(s).

Author:

    Wesley A. Witt (wesw) 19-April-1993

Environment:

    Win32, User Mode

--*/

#include <windows.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#define _SYMCVT_SOURCE_
#include "symcvt.h"

static BOOL CalculateOutputFilePointers( PIMAGEPOINTERS pi, PIMAGEPOINTERS po );
static BOOL CalculateInputFilePointers( PIMAGEPOINTERS p );

 
MapInputFile (
              PPOINTERS   p,
              HANDLE      hFile,
              char *      fname
              )
/*++

Routine Description:

    Maps the input file specified by the fname argument and saves the
    file handle & file pointer in the POINTERS structure.


Arguments:

    p        - Supplies pointer to a POINTERS structure
    hFile    - OPTIONAL Supplies handle for file if already open
    fname    - Supplies ascii string for the file name

Return Value:

    TRUE     - file mapped ok
    FALSE    - file could not be mapped

--*/

{
    BOOL        rVal = TRUE;

    memset( p, 0, sizeof(POINTERS) );

    strcpy( p->iptrs.szName, fname );

    if (hFile != NULL) {

        p->iptrs.hFile = hFile;

    } else {

        p->iptrs.hFile = CreateFileA(p->iptrs.szName,
                                    GENERIC_READ,
                                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                                    NULL,
                                    OPEN_EXISTING,
                                    0,
                                    NULL );
    }

    if (p->iptrs.hFile == INVALID_HANDLE_VALUE) {

        rVal = FALSE;

    } else {

        p->iptrs.fsize = GetFileSize( p->iptrs.hFile, NULL );
        p->iptrs.hMap = CreateFileMapping( p->iptrs.hFile,
                                           NULL,
                                           PAGE_READONLY,
                                           0,
                                           0,
                                           NULL
                                         );

        if (p->iptrs.hMap == INVALID_HANDLE_VALUE) {

            p->iptrs.hMap = NULL;
            rVal = FALSE;

        } else {

            p->iptrs.fptr = MapViewOfFile( p->iptrs.hMap,
                                           FILE_MAP_READ,
                                           0, 0, 0 );
            if (p->iptrs.fptr == NULL) {
                CloseHandle( p->iptrs.hMap );
                p->iptrs.hMap = NULL;
                rVal = FALSE;
            }
        }
    }

    if (!hFile && p->iptrs.hFile != INVALID_HANDLE_VALUE) {
        CloseHandle(p->iptrs.hFile);
        p->iptrs.hFile = NULL;
    }

    return rVal;
}                               /* MapInputFile() */



BOOL
UnMapInputFile (
    PPOINTERS p
    )
/*++

Routine Description:

    Unmaps the input file specified by the fname argument and then
    closes the file.


Arguments:

    p        - pointer to a POINTERS structure

Return Value:

    TRUE     - file mapped ok
    FALSE    - file could not be mapped

--*/

{
    if ( p->iptrs.fptr ) {
        UnmapViewOfFile( p->iptrs.fptr );
        p->iptrs.fptr = NULL;
    }
    if ( p->iptrs.hMap ) {
        CloseHandle( p->iptrs.hMap );
        p->iptrs.hMap = NULL;
    }
    if (p->iptrs.hFile != NULL) {
        CloseHandle( p->iptrs.hFile );
        p->iptrs.hFile = NULL;
    }
    return TRUE;
}                               /* UnMapInputFile() */


BOOL
FillInSeparateImagePointers(
                            PIMAGEPOINTERS      p
                            )
/*++

Routine Description:

    This routine will go through the exe file and fill in the
    pointers needed relative to the separate debug information files

Arguments:

    p  - Supplies the structure to fill in

Return Value:

    TRUE if successful and FALSE otherwise.

--*/

{
    int                         li;
    int                         numDebugDirs;
    PIMAGE_DEBUG_DIRECTORY      pDebugDir;
    PIMAGE_COFF_SYMBOLS_HEADER  pCoffHdr;

    p->sectionHdrs = (PIMAGE_SECTION_HEADER)
      (p->fptr + sizeof(IMAGE_SEPARATE_DEBUG_HEADER));

    numDebugDirs = p->sepHdr->DebugDirectorySize/sizeof(IMAGE_DEBUG_DIRECTORY);

    if (numDebugDirs == 0) {
        return FALSE;
    }

    /*
     *  For each debug directory, determine the debug directory type
     *  and cache any information about them.
     */

    pDebugDir = (PIMAGE_DEBUG_DIRECTORY)
      (p->fptr + sizeof(IMAGE_SEPARATE_DEBUG_HEADER) +
       p->sepHdr->NumberOfSections * sizeof(IMAGE_SECTION_HEADER) +
       p->sepHdr->ExportedNamesSize);

    for (li=0; li<numDebugDirs; li++, pDebugDir++) {
        if (((int) pDebugDir->Type) > p->cDebugDir) {
            p->cDebugDir += 10;
            p->rgDebugDir = realloc((char *) p->rgDebugDir,
                                    p->cDebugDir * sizeof(p->rgDebugDir[0]));
            memset(&p->rgDebugDir[p->cDebugDir-10], 0,
                   10*sizeof(p->rgDebugDir[0]));
        }

        p->rgDebugDir[pDebugDir->Type] = pDebugDir;
    }

    if (p->rgDebugDir[IMAGE_DEBUG_TYPE_COFF] != NULL) {
        pCoffHdr = (PIMAGE_COFF_SYMBOLS_HEADER) (p->fptr +
          p->rgDebugDir[IMAGE_DEBUG_TYPE_COFF]->PointerToRawData);
        p->AllSymbols = (PIMAGE_SYMBOL)
          ((char *) pCoffHdr + pCoffHdr->LvaToFirstSymbol);
        p->stringTable = pCoffHdr->NumberOfSymbols * IMAGE_SIZEOF_SYMBOL +
          (char *) p->AllSymbols;
        p->numberOfSymbols = pCoffHdr->NumberOfSymbols;
    }
    p->numberOfSections = p->sepHdr->NumberOfSections;

    return TRUE;
}                               /* FillInSeparateImagePointers() */



BOOL
CalculateNtImagePointers(
    PIMAGEPOINTERS p
    )
/*++

Routine Description:

    This function reads an NT image and its associated COFF headers
    and file pointers and build a set of pointers into the mapped image.
    The pointers are all relative to the image's mapped file pointer
    and allow direct access to the necessary data.

Arguments:

    p        - pointer to a IMAGEPOINTERS structure

Return Value:

    TRUE     - pointers were created
    FALSE    - pointers could not be created

--*/
{
    PIMAGE_DEBUG_DIRECTORY      debugDir;
    PIMAGE_SECTION_HEADER       sh;
    DWORD                       i, li, rva, numDebugDirs;
    PIMAGE_FILE_HEADER          pFileHdr;
    PIMAGE_OPTIONAL_HEADER      pOptHdr;
    DWORD                       offDebugInfo;

    try {
        /*
         *      Based on wheither or not we find the dos (MZ) header
         *      at the beginning of the file, attempt to get a pointer
         *      to where the PE header is suppose to be.
         */

        p->dosHdr = (PIMAGE_DOS_HEADER) p->fptr;
        if (p->dosHdr->e_magic == IMAGE_DOS_SIGNATURE) {
            p->ntHdr = (PIMAGE_NT_HEADERS)
              ((DWORD)p->dosHdr->e_lfanew + p->fptr);
            p->fRomImage = FALSE;
        } else if (p->dosHdr->e_magic == IMAGE_SEPARATE_DEBUG_SIGNATURE) {
            p->sepHdr = (PIMAGE_SEPARATE_DEBUG_HEADER) p->fptr;
            p->dosHdr = NULL;
            p->fRomImage = FALSE;
            return FillInSeparateImagePointers(p);
        } else {
            p->romHdr = (PIMAGE_ROM_HEADERS) p->fptr;
            if (p->romHdr->FileHeader.SizeOfOptionalHeader ==
                                          IMAGE_SIZEOF_ROM_OPTIONAL_HEADER &&
                p->romHdr->OptionalHeader.Magic ==
                                          IMAGE_ROM_OPTIONAL_HDR_MAGIC) {
                //
                // its a rom image
                //
                p->fRomImage = TRUE;
                p->ntHdr = NULL;
                p->dosHdr = NULL;
            } else {
                p->fRomImage = FALSE;
                p->ntHdr = (PIMAGE_NT_HEADERS) p->fptr;
                p->dosHdr = NULL;
                p->romHdr = NULL;
            }
        }

        /*
         *  What comes next must be a PE header.  If not then pop out
         */

        if ( p->ntHdr ) {
            if ( p->dosHdr && (DWORD)p->dosHdr->e_lfanew > (DWORD)p->fsize ) {
                return FALSE;
            }

            if ( p->ntHdr->Signature != IMAGE_NT_SIGNATURE ) {
                return FALSE;
            }

            /*
             *  We did find a PE header so start setting pointers to various
             *      structures in the exe file.
             */

            pFileHdr = p->fileHdr = &p->ntHdr->FileHeader;
            pOptHdr = p->optHdr = &p->ntHdr->OptionalHeader;
        } else if (p->romHdr) {
            pFileHdr = p->fileHdr = &p->romHdr->FileHeader;
            pOptHdr = (PIMAGE_OPTIONAL_HEADER) &p->romHdr->OptionalHeader;
            p->optHdr = (PIMAGE_OPTIONAL_HEADER) &p->romHdr->OptionalHeader;
        } else {
            return FALSE;
        }

        if (!(pFileHdr->Characteristics & IMAGE_FILE_EXECUTABLE_IMAGE)) {
            return FALSE;
        }

        if (pFileHdr->Characteristics & IMAGE_FILE_DEBUG_STRIPPED) {
            return(FALSE);
        }

        /*
         *  If they exists then get a pointer to the symbol table and
         *      the string table
         */

        if (pFileHdr->PointerToSymbolTable) {
            p->AllSymbols = (PIMAGE_SYMBOL)
                              (pFileHdr->PointerToSymbolTable + p->fptr);
            p->stringTable = (LPSTR)((ULONG)p->AllSymbols +
                           (IMAGE_SIZEOF_SYMBOL * pFileHdr->NumberOfSymbols));
            p->numberOfSymbols = pFileHdr->NumberOfSymbols;
        }

        p->numberOfSections = pFileHdr->NumberOfSections;

        if (p->romHdr) {

            sh = p->sectionHdrs = (PIMAGE_SECTION_HEADER) (p->romHdr+1);

            p->cDebugDir = 10;
            p->rgDebugDir = calloc(sizeof(IMAGE_DEBUG_DIRECTORY) * 10, 1);

            debugDir = 0;

            for (i=0; i<pFileHdr->NumberOfSections; i++, sh++) {
                if (!strcmp(sh->Name, ".rdata")) {
                    debugDir = (PIMAGE_DEBUG_DIRECTORY)(sh->PointerToRawData + p->fptr);
                }

                if (strncmp(sh->Name,".debug",8)==0) {
                    p->debugSection = sh;
                }
            }

            if (debugDir) {
                do {
                    if ((int)debugDir->Type > p->cDebugDir) {
                        p->cDebugDir += 10;
                        p->rgDebugDir = realloc((char *) p->rgDebugDir,
                                            p->cDebugDir * sizeof(p->rgDebugDir[0]));
                        memset(&p->rgDebugDir[p->cDebugDir-10],
                                0,
                                10*sizeof(IMAGE_DEBUG_DIRECTORY));
                    }
                    p->rgDebugDir[debugDir->Type] = debugDir;
                    debugDir++;
                } while (debugDir->Type != 0);
            }
        } else {

            /*
             *  Locate the debug directory
             */

            rva =
              pOptHdr->DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress;

            numDebugDirs =
              pOptHdr->DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size /
                sizeof(IMAGE_DEBUG_DIRECTORY);

            if (numDebugDirs == 0) {
                return FALSE;
            }

            sh = p->sectionHdrs = IMAGE_FIRST_SECTION( p->ntHdr );

            /*
             * Find the section the debug directory is in.
             */

            for (i=0; i<pFileHdr->NumberOfSections; i++, sh++) {
                if (rva >= sh->VirtualAddress &&
                    rva < sh->VirtualAddress+sh->SizeOfRawData) {
                    break;
                }
            }

            /*
             *   For each debug directory, determine the debug directory
             *      type and cache any information about them.
             */

            debugDir = (PIMAGE_DEBUG_DIRECTORY) ( rva - sh->VirtualAddress +
                                                 sh->PointerToRawData +
                                                 p->fptr );

            for (li=0; li<numDebugDirs; li++, debugDir++) {
                if (((int) debugDir->Type) > p->cDebugDir) {
                    p->cDebugDir += 10;
                    p->rgDebugDir = realloc((char *) p->rgDebugDir,
                                            p->cDebugDir * sizeof(p->rgDebugDir[0]));
                    memset(&p->rgDebugDir[p->cDebugDir-10], 0,
                           10*sizeof(p->rgDebugDir[0]));
                }
                p->rgDebugDir[debugDir->Type] = debugDir;
                offDebugInfo = debugDir->AddressOfRawData;
            }

            /*
             *  Check to see if the debug information is mapped and if
             *      there is a section called .debug
             */

            sh = p->sectionHdrs = IMAGE_FIRST_SECTION( p->ntHdr );

            for (i=0; i<pFileHdr->NumberOfSections; i++, sh++) {
                if ((offDebugInfo >= sh->VirtualAddress) &&
                    (offDebugInfo < sh->VirtualAddress+sh->SizeOfRawData)) {
                    p->debugSection = sh;
                    break;
                }
            }
        }

        return TRUE;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        return FALSE;
    }
}                               /* CalcuateNtImagePointers() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\symtodbg\symedit\symedit.c ===
/*++

Copyright 1996 - 1997 Microsoft Corporation

Module Name:

    symedit.c

Abstract:


Author:

    Wesley A. Witt (wesw) 19-April-1993

Environment:

    Win32, User Mode

--*/

#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <symcvt.h>
#include <cv.h>
#include "strings.h"
#include <imagehlp.h>

#undef UNICODE

#define MAX_PATH 260 

//  prototypes for this module

BOOL    CalculateOutputFilePointers( PIMAGEPOINTERS pi, PIMAGEPOINTERS po );
void    ProcessCommandLineArgs( int argc, WCHAR *argv[] );
void    PrintCopyright( void );
void    PrintUsage( void );
void    FatalError( int, ... );
BOOL    MapOutputFile ( PPOINTERS p, char *fname, int );
void    ComputeChecksum(  char *szExeFile );
void    ReadDebugInfo( PPOINTERS p );
void    WriteDebugInfo( PPOINTERS p, BOOL);
void    MungeDebugHeadersCoffToCv( PPOINTERS  p, BOOL fAddCV );
void    MungeExeName( PPOINTERS p, char * szExeName );
void    DoCoffToCv(char *, char *, BOOL);
void    DoSymToCv(char *, char *, char *, char *);
void    DoNameChange(char *, char *, char *);
void    DoExtract(char *, char *, char *);
void    DoStrip(char *, char *);

IMAGE_DEBUG_DIRECTORY   DbgDirSpare;

#define AdjustPtr(ptr) (((ptr) != NULL) ? \
                          ((DWORD)ptr - (DWORD)pi->fptr + (DWORD)po->fptr) : \
                          ((DWORD)(ptr)))


int _cdecl
wmain(
    int        argc,
    WCHAR *     argv[]
    )
/*++

Routine Description:

    Shell for this utility.

Arguments:

    argc     - argument count
    argv     - argument pointers


Return Value:

    0        - image was converted
    >0       - image could not be converted

--*/

{
    // Scan the command line and check what operations we are doing

    ProcessCommandLineArgs( argc, argv );
    return 0;
}


__inline void PrintCopyright( void )
{
    puts( "\nMicrosoft(R) Windows NT SymEdit Version 1.0\n"
          "(C) 1989-1995 Microsoft Corp. All rights reserved.\n");
}


__inline void PrintUsage( void )
{
    PrintCopyright();
    puts ("\nUsage: SYMEDIT <OPERATION> -q -o<file out> <file in>\n\n"
          "\t<OPERATION> is:\n"
          "\tC\tModify CodeView symbol information\n"
          "\tN\tEdit name field\n"
          "\tX\tExtract debug information\n"
          "\tS\tStrip all debug information\n\n"
          "Options:\n"
          "\t-a\t\tAdd CodeView debug info to file\n" 
          "\t-n<name>\tName to change to\n"
          "\t-o<file>\tspecify output file\n"
          "\t-q\t\tquiet mode\n"
          "\t-r\t\tReplace COFF debug info with CV info\n"
          "\t-s<file>\tSym file source");
}


void
ProcessCommandLineArgs(
    int argc,
    WCHAR *argv[]
    )

/*++

Routine Description:

    Processes the command line arguments and sets global flags to
    indicate the user's desired behavior.

Arguments:

    argc     - argument count
    argv     - argument pointers


Return Value:

    void

--*/

{
    int     i;
    BOOL    fQuiet = FALSE;
    BOOL    fSilent = FALSE;
    char    szOutputFile[MAX_PATH];
    char    szInputFile[MAX_PATH];
    char    szExeName[MAX_PATH];
    char    szDbgFile[MAX_PATH];
    char    szSymFile[MAX_PATH];
    int     iOperation;
    BOOLEAN fAddCV = FALSE;

    // Minimun number of of arguments is 2 -- program and operation

    if (argc < 2 ||
        (wcscmp(argv[1], L"-?") == 0) ||
        (wcscmp(argv[1], L"?") == 0) )
    {
        PrintUsage();
        exit(1);
    }

    // All operations on 1 character wide

    if (argv[1][1] != 0) {
        FatalError(ERR_OP_UNKNOWN, argv[1]);
    }

    // Validate the operation

    switch( argv[1][0] ) {
        case L'C':
        case L'N':
        case L'X':
        case L'S':
            iOperation = argv[1][0];
            break;
        default:
            FatalError(ERR_OP_UNKNOWN, argv[1]);
    }

    // Parse out any other switches on the command line

    for (i=2; i<argc; i++) {
        if ((argv[i][0] == '-') || (argv[i][0] == '/')) {
            switch (towupper(argv[i][1])) {

                // Add the CV debug information section rather than
                // replace the COFF section with the CV info.

                case L'A':
                    fAddCV = TRUE;
                    break;

                // Specify the output name for the DBG file

                case L'D':
                    if (argv[i][2] == 0) {
                        i += 1;
                        wcstombs(szDbgFile, argv[i], MAX_PATH);
                    } else {
                        wcstombs(szDbgFile, &argv[i][2], MAX_PATH);
                    }
                    break;

                // Specify a new name to shove into the name of the
                // debuggee field in the Misc. Debug info field

                case L'N':
                    if (argv[i][2] == 0) {
                        i += 1;
                        wcstombs(szExeName, argv[i], MAX_PATH);
                    } else {
                        wcstombs(szExeName, &argv[i][2], MAX_PATH);
                    }
                    break;

                // Specify the name of the output file

                case L'O':
                    if (argv[i][2] == 0) {
                        i += 1;
                        wcstombs(szOutputFile,argv[i], MAX_PATH);
                    } else {
                        wcstombs(szOutputFile, &argv[i][2], MAX_PATH);
                    }
                    break;

                // Be quite and don't put out the banner

                case L'Q':
                    fQuiet = TRUE;
                    fSilent = TRUE;
                    break;

                //  Replace COFF debug information with CODEVIEW debug information

                case L'R':
                    break;

                //  Convert a Symbol File to CV info

                case L'S':
                    if (argv[i][2] == 0) {
                        i += 1;
                        wcstombs(szSymFile, argv[i], MAX_PATH);
                    } else {
                        wcstombs(szSymFile, &argv[i][2], MAX_PATH);
                    }
                    break;

                // Print the command line options

                case L'?':
                    PrintUsage();
                    exit(1);
                    break;

                // Unrecognized option

                default:
                    FatalError( ERR_OP_UNKNOWN, argv[i] );
                    break;
            }
        } else {
            //  No leading switch character -- must be a file name

            wcstombs(szInputFile, &argv[i][0], MAX_PATH);

            //  Process the file(s)

            if (!fQuiet) {
                PrintCopyright();
                fQuiet = TRUE;
            }

            if (!fSilent) {
                printf("processing file: %s\n", szInputFile );
            }

            //  Do switch validation cheching and setup any missing global variables

            switch ( iOperation ) {

                // For conversions -- there are three types
                //
                //      1.  Coff to CV -- add
                //      2.  Coff to CV -- replace
                //      3.  SYM to CV --- add
                //      4.  SYM to CV -- seperate file
                //
                //      Optional input file (not needed for case 4)
                //      Optional output file
                //      Optional sym file (implys sym->CV)
                //      Optional DBG file

                case 'C':
                    if (szSymFile == NULL) {
                        DoCoffToCv(szInputFile, szOutputFile, fAddCV);
                    } else {
                        DoSymToCv(szInputFile, szOutputFile, szDbgFile, szSymFile);
                    }
                    break;

                //  For changing the name of the debuggee --
                //      Must specify input file
                //      Must specify new name
                //      Optional output file

                case 'N':
                    DoNameChange(szInputFile, szOutputFile, szExeName);
                    break;

                //  For extraction of debug information
                //      Must specify input file
                //      Optional output file name
                //      Optional debug file name

                case 'X':
                    DoExtract(szInputFile, szOutputFile, szDbgFile);
                    break;

                //  For full strip of debug information
                //      Must specify input file
                //      Optional output file

                case 'S':
                    DoStrip(szInputFile, szOutputFile);
                    break;
            }
        }
    }
    return;
}


void
ReadDebugInfo(
    PPOINTERS   p
    )

/*++

Routine Description:

    This function will go out and read in all of the debug information
    into memory -- this is required because the input and output
    files might be the same, if so then writing out informaiton may
    destory data we need at a later time.

Arguments:

    p   - Supplies a pointer to the structure describing the debug info file

Return Value:

    None.

--*/

{
    int                         i;
//    int                         cb;
//    char *                      pb;
//    PIMAGE_COFF_SYMBOLS_HEADER  pCoffDbgInfo;

    // Allocate space to save pointers to debug info

    p->iptrs.rgpbDebugSave = (PCHAR *) malloc(p->iptrs.cDebugDir * sizeof(PCHAR));
    memset(p->iptrs.rgpbDebugSave, 0, p->iptrs.cDebugDir * sizeof(PCHAR));

    // Check each possible debug type record

    for (i=0; i<p->iptrs.cDebugDir; i++) {

        // If there was debug information then copy over the
        // description block and cache in the actual debug data.

        if (p->iptrs.rgDebugDir[i] != NULL) {
            p->iptrs.rgpbDebugSave[i] =
              malloc( p->iptrs.rgDebugDir[i]->SizeOfData );
            if (p->iptrs.rgpbDebugSave[i] == NULL) {
                FatalError(ERR_NO_MEMORY);
            }
            __try {
                memcpy(p->iptrs.rgpbDebugSave[i],
                       p->iptrs.fptr +
                       p->iptrs.rgDebugDir[i]->PointerToRawData,
                       p->iptrs.rgDebugDir[i]->SizeOfData );
            } __except(EXCEPTION_EXECUTE_HANDLER ) {
                free(p->iptrs.rgpbDebugSave[i]);
                p->iptrs.rgpbDebugSave[i] = NULL;
            }
        }
    }
    return;
}


void
WriteDebugInfo(
    PPOINTERS   p,
    BOOL        fAddCV
    )
/*++

Routine Description:

    This function will go out and read in all of the debug information
    into memory -- this is required because the input and output
    files might be the same, if so then writing out informaiton may
    destory data we need at a later time.

Arguments:

    p   - Supplies a pointer to the structure describing the debug info file

Return Value:

    None.

--*/

{
    ULONG  PointerToDebugData = 0; //  Offset from the start of the file
                                   //  to the current location to write
                                   //  debug information out.
    ULONG  BaseOfDebugData = 0;
    int    i, flen;
    PIMAGE_DEBUG_DIRECTORY  pDir, pDbgDir = NULL;

    if (p->optrs.debugSection) {
        BaseOfDebugData = PointerToDebugData =
          p->optrs.debugSection->PointerToRawData;
    } else if (p->optrs.sepHdr) {
        BaseOfDebugData =  PointerToDebugData =
          sizeof(IMAGE_SEPARATE_DEBUG_HEADER) +
          p->optrs.sepHdr->NumberOfSections * sizeof(IMAGE_SECTION_HEADER) +
          p->optrs.sepHdr->ExportedNamesSize;
    }

    //  Step 2. If the debug information is mapped, we know this
    //          from the section headers, then we may need to write
    //          out a new debug director to point to the debug information

    if (fAddCV) {
        if (p->optrs.optHdr) {
            p->optrs.optHdr->DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].
              VirtualAddress = p->optrs.debugSection->VirtualAddress;
            p->optrs.optHdr->DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size +=
              sizeof(IMAGE_DEBUG_DIRECTORY);
        } else if (p->optrs.sepHdr) {
            p->optrs.sepHdr->DebugDirectorySize += sizeof(IMAGE_DEBUG_DIRECTORY);
        } else {
            exit(1);
        }

        if (p->optrs.sepHdr) {
            pDbgDir = (PIMAGE_DEBUG_DIRECTORY) malloc(p->optrs.cDebugDir * sizeof(IMAGE_DEBUG_DIRECTORY));
            for (i=0; i<p->optrs.cDebugDir; i++) {
                if (p->optrs.rgDebugDir[i] != NULL) {
                    pDbgDir[i] = *(p->optrs.rgDebugDir[i]);
                    p->optrs.rgDebugDir[i] = &pDbgDir[i];
                }
            }
        }
        for (i=0; i<p->optrs.cDebugDir; i++) {
            if (p->optrs.rgDebugDir[i]) {
                pDir = (PIMAGE_DEBUG_DIRECTORY) (PointerToDebugData +
                                                 p->optrs.fptr);
                *pDir = *(p->optrs.rgDebugDir[i]);
                p->optrs.rgDebugDir[i] = pDir;
                PointerToDebugData += sizeof(IMAGE_DEBUG_DIRECTORY);
            }
        }
    }

    // Step 3.  For every debug info type, write out the debug information
    //          and update any header information required

    for (i=0; i<p->optrs.cDebugDir; i++) {
        if (p->optrs.rgDebugDir[i] != NULL) {
            if (p->optrs.rgpbDebugSave[i] != NULL) {
                p->optrs.rgDebugDir[i]->PointerToRawData =
                  PointerToDebugData;
                if (p->optrs.debugSection) {
                    p->optrs.rgDebugDir[i]->AddressOfRawData =
                      p->optrs.debugSection->VirtualAddress +
                        PointerToDebugData - BaseOfDebugData;
                }
                memcpy(p->optrs.fptr + PointerToDebugData,
                       p->optrs.rgpbDebugSave[i],
                       p->optrs.rgDebugDir[i]->SizeOfData);

                if ((i == IMAGE_DEBUG_TYPE_COFF) &&
                    (p->optrs.fileHdr != NULL)) {

                    PIMAGE_COFF_SYMBOLS_HEADER  pCoffDbgInfo;
                    pCoffDbgInfo = (PIMAGE_COFF_SYMBOLS_HEADER)p->optrs.rgpbDebugSave[i];
                    p->optrs.fileHdr->PointerToSymbolTable =
                      PointerToDebugData + pCoffDbgInfo->LvaToFirstSymbol;
                }
            }
            PointerToDebugData += p->optrs.rgDebugDir[i]->SizeOfData;
        }
    }

    // Step 4.  Clean up any COFF structures if we are replacing
    //          the coff information with CV info.

    if ((p->optrs.rgDebugDir[IMAGE_DEBUG_TYPE_COFF] == NULL) &&
        (p->optrs.fileHdr != NULL)) {

        // Since there is no coff debug information -- clean out
        // both fields pointing to the debug info

        p->optrs.fileHdr->PointerToSymbolTable = 0;
        p->optrs.fileHdr->NumberOfSymbols = 0;
    }

    // Step 5.  Correct the alignments if needed.  If there is a real .debug
    //          section in the file (i.e. it is mapped) then update it.

    if (p->optrs.debugSection) {
        p->optrs.debugSection->SizeOfRawData =
          FileAlign(PointerToDebugData - BaseOfDebugData);

        // update the optional header with the new image size

        p->optrs.optHdr->SizeOfImage =
          SectionAlign(p->optrs.debugSection->VirtualAddress +
                       p->optrs.debugSection->SizeOfRawData);
        p->optrs.optHdr->SizeOfInitializedData +=
          p->optrs.debugSection->SizeOfRawData;
    }

    // calculate the new file size

    if (p->optrs.optHdr != NULL) {
        flen = FileAlign(PointerToDebugData);
    } else {
        flen = PointerToDebugData;
    }

    // finally, update the eof pointer and close the file

    UnmapViewOfFile( p->optrs.fptr );

    if (!SetFilePointer( p->optrs.hFile, flen, 0, FILE_BEGIN )) {
        FatalError( ERR_FILE_PTRS );
    }

    if (!SetEndOfFile( p->optrs.hFile )) {
        FatalError( ERR_SET_EOF );
    }

    CloseHandle( p->optrs.hFile );

    // Exit -- we are done.

    return;
}



void
MungeDebugHeadersCoffToCv(
    PPOINTERS   p,
    BOOL        fAddCV
    )

/*++

Routine Description:


Arguments:

    p        - pointer to a POINTERS structure (see symcvt.h)

Return Value:

    void

--*/

{
    if (!fAddCV) {
        CV_DIR(&p->optrs) = COFF_DIR(&p->optrs);
        COFF_DIR(&p->optrs) = 0;
    } else {
        CV_DIR(&p->optrs) = &DbgDirSpare;
        *(COFF_DIR(&p->optrs)) = *(COFF_DIR(&p->iptrs));
    };

    *CV_DIR(&p->optrs) = *(COFF_DIR(&p->iptrs));
    CV_DIR(&p->optrs)->Type = IMAGE_DEBUG_TYPE_CODEVIEW;
    CV_DIR(&p->optrs)->SizeOfData =  p->pCvStart.size;
    p->optrs.rgpbDebugSave[IMAGE_DEBUG_TYPE_CODEVIEW] = p->pCvStart.ptr;

    return;
}



BOOL
MapOutputFile (
    PPOINTERS p,
    char *fname,
    int cb
    )

/*++

Routine Description:

    Maps the output file specified by the fname argument and saves the
    file handle & file pointer in the POINTERS structure.


Arguments:

    p        - pointer to a POINTERS structure (see symcvt.h)
    fname    - ascii string for the file name


Return Value:

    TRUE     - file mapped ok
    FALSE    - file could not be mapped

--*/

{
    BOOL    rval;
    HANDLE  hMap   = NULL;
    DWORD   oSize;

    rval = FALSE;

    p->optrs.hFile = CreateFileA( fname,
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_ALWAYS,
                        0,
                        NULL );

    if (p->optrs.hFile == INVALID_HANDLE_VALUE) {
       goto exit;
    }

    oSize = p->iptrs.fsize;
    if (p->pCvStart.ptr != NULL) {
        oSize += p->pCvStart.size;
    }
    oSize += cb;
    oSize += p->iptrs.cDebugDir * sizeof(IMAGE_DEBUG_DIRECTORY);

    hMap = CreateFileMapping( p->optrs.hFile, NULL, PAGE_READWRITE,
                                0, oSize, NULL );

    if (hMap == NULL) {
       goto exit;
    }

    p->optrs.fptr = MapViewOfFile( hMap, FILE_MAP_WRITE, 0, 0, 0 );

    CloseHandle(hMap);

    if (p->optrs.fptr == NULL) {
       goto exit;
    }
    rval = TRUE;
exit:
    return rval;
}


BOOL
CalculateOutputFilePointers(
    PIMAGEPOINTERS pi,
    PIMAGEPOINTERS po
    )

/*++

Routine Description:

    This function calculates the output file pointers based on the
    input file pointers.  The same address is used but they are all
    re-based off the output file's file pointer.

Arguments:

    p        - pointer to a IMAGEPOINTERS structure (see symcvt.h)


Return Value:

    TRUE     - pointers were created
    FALSE    - pointers could not be created

--*/
{
    int i;

    // fixup the pointers relative the fptr for the output file
    po->dosHdr       = (PIMAGE_DOS_HEADER)      AdjustPtr(pi->dosHdr);
    po->ntHdr        = (PIMAGE_NT_HEADERS)      AdjustPtr(pi->ntHdr);
    po->fileHdr      = (PIMAGE_FILE_HEADER)     AdjustPtr(pi->fileHdr);
    po->optHdr       = (PIMAGE_OPTIONAL_HEADER) AdjustPtr(pi->optHdr);
    po->sectionHdrs  = (PIMAGE_SECTION_HEADER)  AdjustPtr(pi->sectionHdrs);
    po->sepHdr       = (PIMAGE_SEPARATE_DEBUG_HEADER) AdjustPtr(pi->sepHdr);
    po->debugSection = (PIMAGE_SECTION_HEADER)  AdjustPtr(pi->debugSection);
    po->AllSymbols   = (PIMAGE_SYMBOL)          AdjustPtr(pi->AllSymbols);
    po->stringTable  = (PUCHAR)                 AdjustPtr(pi->stringTable);

    // move the data from the input file to the output file
    memcpy( po->fptr, pi->fptr, pi->fsize );

    po->cDebugDir = pi->cDebugDir;
    po->rgDebugDir = malloc(po->cDebugDir * sizeof(po->rgDebugDir[0]));
    memset(po->rgDebugDir, 0, po->cDebugDir * sizeof(po->rgDebugDir[0]));

    for (i=0; i<po->cDebugDir; i++) {
        po->rgDebugDir[i] = (PIMAGE_DEBUG_DIRECTORY) AdjustPtr(pi->rgDebugDir[i]);
    }
    po->rgpbDebugSave = pi->rgpbDebugSave;

    return TRUE;
}


void
FatalError(
    int  idMsg,
    ...
    )
/*++

Routine Description:

    Prints a message string to stderr and then exits.

Arguments:

    s        - message string to be printed

Return Value:

    void

--*/

{
    va_list marker;
    char    rgchFormat[256];
    char    rgch[256];

    LoadStringA(GetModuleHandle(NULL), idMsg, rgchFormat, sizeof(rgchFormat));

    va_start(marker, idMsg);
    vsprintf(rgch, rgchFormat, marker);
    va_end(marker);

    fprintf(stderr, "%s\n", rgch);

    exit(1);
}


void
ComputeChecksum(
    char *szExeFile
    )

/*++

Routine Description:

    Computes a new checksum for the image by calling imagehlp.dll

Arguments:

    szExeFile - exe file name


Return Value:

    void

--*/

{
    DWORD              dwHeaderSum = 0;
    DWORD              dwCheckSum = 0;
    HANDLE             hFile;
    DWORD              cb;
    IMAGE_DOS_HEADER   dosHdr;
    IMAGE_NT_HEADERS   ntHdr;

    if (MapFileAndCheckSumA(szExeFile, &dwHeaderSum, &dwCheckSum) != CHECKSUM_SUCCESS) {
        FatalError( ERR_CHECKSUM_CALC );
    }

    hFile = CreateFileA( szExeFile,
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL
                      );

    // seek to the beginning of the file
    SetFilePointer( hFile, 0, 0, FILE_BEGIN );

    // read in the dos header
    if ((ReadFile(hFile, &dosHdr, sizeof(dosHdr), &cb, 0) == FALSE) || (cb != sizeof(dosHdr))) {
        FatalError( ERR_CHECKSUM_CALC );
    }

    // read in the pe header
    if ((dosHdr.e_magic != IMAGE_DOS_SIGNATURE) ||
        (SetFilePointer(hFile, dosHdr.e_lfanew, 0, FILE_BEGIN) == -1L)) {
        FatalError( ERR_CHECKSUM_CALC );
    }

    // read in the nt header
    if ((!ReadFile(hFile, &ntHdr, sizeof(ntHdr), &cb, 0)) || (cb != sizeof(ntHdr))) {
        FatalError( ERR_CHECKSUM_CALC );
    }

    if (SetFilePointer(hFile, dosHdr.e_lfanew, 0, FILE_BEGIN) == -1L) {
        FatalError( ERR_CHECKSUM_CALC );
    }

    ntHdr.OptionalHeader.CheckSum = dwCheckSum;

    if (!WriteFile(hFile, &ntHdr, sizeof(ntHdr), &cb, NULL)) {
        FatalError( ERR_CHECKSUM_CALC );
    }

    CloseHandle(hFile);
    return;
}


void
MungeExeName(
    PPOINTERS   p,
    char *      szExeName
    )
/*++

Routine Description:

    description-of-function.

Arguments:

    argument-name - Supplies | Returns description of argument.
    .
    .

Return Value:

    None.

--*/

{
    PIMAGE_DEBUG_MISC   pMiscIn;
    PIMAGE_DEBUG_MISC   pMiscOut;
    int                 cb;
    int                 i;

    for (i=0; i<p->iptrs.cDebugDir; i++) {
        if (p->optrs.rgDebugDir[i] != 0) {
            *(p->optrs.rgDebugDir[i]) = *(p->iptrs.rgDebugDir[i]);
        }
    }

    pMiscIn = (PIMAGE_DEBUG_MISC)
      p->iptrs.rgpbDebugSave[IMAGE_DEBUG_TYPE_MISC];

    if (p->optrs.rgDebugDir[IMAGE_DEBUG_TYPE_MISC] == NULL) {
        p->optrs.rgDebugDir[IMAGE_DEBUG_TYPE_MISC] = &DbgDirSpare;
        memset(&DbgDirSpare, 0, sizeof(DbgDirSpare));
    }

    pMiscOut = (PIMAGE_DEBUG_MISC)
      p->optrs.rgpbDebugSave[IMAGE_DEBUG_TYPE_MISC] =
      malloc(p->optrs.rgDebugDir[IMAGE_DEBUG_TYPE_MISC]->SizeOfData +
             strlen(szExeName));
    cb = p->optrs.rgDebugDir[IMAGE_DEBUG_TYPE_MISC]->SizeOfData;

    while ( cb > 0 ) {
        if (pMiscIn->DataType == IMAGE_DEBUG_MISC_EXENAME) {
            pMiscOut->DataType = IMAGE_DEBUG_MISC_EXENAME;
            pMiscOut->Length = (sizeof(IMAGE_DEBUG_MISC) +
                                strlen(szExeName) + 3) & ~3;
            pMiscOut->Unicode = FALSE;
            strcpy(&pMiscOut->Data[0], szExeName);
            szExeName = NULL;
        } else {
            memcpy(pMiscOut, pMiscIn, pMiscIn->Length);
        }

        p->optrs.rgDebugDir[IMAGE_DEBUG_TYPE_MISC]->SizeOfData +=
          (pMiscOut->Length - pMiscIn->Length);

        cb -= pMiscIn->Length;
        pMiscIn = (PIMAGE_DEBUG_MISC) (((char *) pMiscIn) + pMiscIn->Length);
        pMiscOut = (PIMAGE_DEBUG_MISC) (((char *) pMiscOut) + pMiscOut->Length);
    }

    if (szExeName) {
        pMiscOut->DataType = IMAGE_DEBUG_MISC_EXENAME;
        pMiscOut->Length = (sizeof(IMAGE_DEBUG_MISC) +
                            strlen(szExeName) + 3) & ~3;
        pMiscOut->Unicode = FALSE;
        strcpy(&pMiscOut->Data[0], szExeName);
    }

    return;
}


/***    DoCoffToCv
 *
 *
 */

void DoCoffToCv(
    char * szInput,
    char * szOutput,
    BOOL fAddCV
    )
{
    POINTERS    p;

    // Do default checking

    if (szOutput == NULL) {
        szOutput = szInput;
    }

    // Open the input file name and setup the pointers into the file

    if (!MapInputFile( &p, NULL, szInput )) {
        FatalError( ERR_OPEN_INPUT_FILE, szInput );
    }

    // Now, if we thing we are playing with PE exes then we need
    // to setup the pointers into the map file

    if (!CalculateNtImagePointers( &p.iptrs )) {
        FatalError( ERR_INVALID_PE, szInput );
    }

    // We are about to try and do the coff to cv symbol conversion.
    //
    // Verify that the operation is legal.
    //
    // 1.  We need to have coff debug information to start with
    // 2.  If the debug info is not mapped then we must not
    //     be trying to add CodeView info.

    if ((p.iptrs.AllSymbols == NULL) || (COFF_DIR(&p.iptrs) == NULL)) {
        FatalError( ERR_NO_COFF );
    }

    if (fAddCV && (p.iptrs.debugSection == 0) && (p.iptrs.sepHdr == NULL)) {
        FatalError( ERR_NOT_MAPPED );
    }

    // Now go out an preform the acutal conversion.

    if (!ConvertCoffToCv( &p )) {
        FatalError( ERR_COFF_TO_CV );
    }

    // Read in any additional debug information in the file

    ReadDebugInfo(&p);

    // Open the output file and adjust the pointers so that we are ok.

    if (!MapOutputFile( &p, szOutput, 0 )) {
        FatalError( ERR_MAP_FILE, szOutput );
    }

    CalculateOutputFilePointers( &p.iptrs, &p.optrs );

    // Munge the various debug information structures to preform the correct
    // operations

    MungeDebugHeadersCoffToCv( &p, fAddCV );

    // Free our handles on the input file

    UnMapInputFile(&p);

    // Write out the debug information to the end of the exe

    WriteDebugInfo( &p, fAddCV );

    // and finally compute the checksum

    if (p.iptrs.fileHdr != NULL) {
        ComputeChecksum( szOutput );
    }

    return;
}

/***    DoSymToCv
 *
 */

void
DoSymToCv(
    char * szInput,
    char * szOutput,
    char * szDbg,
    char * szSym
    )
{
    POINTERS    p;
    HANDLE      hFile;
    DWORD       cb;
    OFSTRUCT    ofs;

    // Open the input file name and setup the pointers into the file

    if (!MapInputFile( &p, NULL, szSym )) {
        FatalError(ERR_OPEN_INPUT_FILE, szSym);
    }

    // Now preform the desired operation

    if ((szOutput == NULL) && (szDbg == NULL)) {
        szOutput = szInput;
    }

    ConvertSymToCv( &p );

    if (szOutput) {
        if (szOutput != szInput) {
            if (OpenFile(szInput, &ofs, OF_EXIST) == 0) {
                FatalError(ERR_OPEN_INPUT_FILE, szInput);
            }
            if (CopyFileA(szInput, szOutput, FALSE) == 0) {
                FatalError(ERR_OPEN_WRITE_FILE, szOutput);
            }
        }
        hFile = CreateFileA(szOutput, GENERIC_WRITE, 0, NULL,
                           CREATE_ALWAYS,
                           FILE_ATTRIBUTE_NORMAL,  NULL);
        if (hFile == INVALID_HANDLE_VALUE) {
            FatalError(ERR_OPEN_WRITE_FILE, szOutput);
        }
        SetFilePointer(hFile, 0, 0, FILE_END);
    } else if (szDbg) {
        hFile = CreateFileA(szDbg, GENERIC_WRITE, 0, NULL,
                               OPEN_ALWAYS,
                               FILE_ATTRIBUTE_NORMAL,  NULL);
        if (hFile == INVALID_HANDLE_VALUE) {
            FatalError(ERR_OPEN_WRITE_FILE, szDbg);
        }
    }

    WriteFile(hFile, p.pCvStart.ptr, p.pCvStart.size, &cb, NULL);
    CloseHandle(hFile);

    return;
}


void
DoNameChange(
    char * szInput,
    char * szOutput,
    char * szNewName
    )
{
    POINTERS    p;

    // Open the input file name and setup the pointers into the file

    if (!MapInputFile( &p, NULL, szInput )) {
        FatalError(ERR_OPEN_INPUT_FILE, szInput);
    }

    // Now, if we thing we are playing with PE exes then we need
    // to setup the pointers into the map file

    if (!CalculateNtImagePointers( &p.iptrs )) {
        FatalError(ERR_INVALID_PE, szInput);
    }

    //  Now preform the desired operation

    if (szOutput == NULL) {
        szOutput = szInput;
    }

    if (szNewName == NULL) {
        szNewName = szOutput;
    }

    if (p.iptrs.sepHdr != NULL) {
        FatalError(ERR_EDIT_DBG_FILE);
    }

    // Read in all of the debug information

    ReadDebugInfo(&p);

    // Open the output file and adjust the pointers.

    if (!MapOutputFile(&p, szOutput,
                       sizeof(szNewName) * 2 + sizeof(IMAGE_DEBUG_MISC))) {
        FatalError(ERR_MAP_FILE, szOutput);
    }

    CalculateOutputFilePointers(&p.iptrs, &p.optrs);

    // Munge the name of the file

    MungeExeName(&p, szNewName);

    // Close the input file

    UnMapInputFile(&p);

    // Write out the debug information to the end of the exe

    WriteDebugInfo(&p, FALSE);

    // and finally compute the checksum

    if (p.iptrs.fileHdr != NULL) {
        ComputeChecksum( szOutput );
    }

    return;
}


void
DoStrip(
    char * szInput,
    char * szOutput
    )
{
    char OutputFile[_MAX_PATH];

    // Make sure we only have the path to the output file (it will always be
    //  named filename.DBG)

    if (szOutput != NULL) {
        CopyFileA(szInput, szOutput, FALSE);
    }

    SplitSymbols(szOutput, NULL, OutputFile, SPLITSYM_EXTRACT_ALL);

    // Always delete the output file.

    DeleteFileA(OutputFile);

    return;
}


void
DoExtract(
    char * szInput,
    char * szOutput,
    char * szDbgFile
    )
{
    char OutputFile[_MAX_PATH];
    char szExt[_MAX_EXT];
    char szFileName[_MAX_FNAME];

    if (szOutput != NULL) {
        CopyFileA(szInput, szOutput, FALSE);
        szInput = _strdup(szOutput);
        _splitpath(szOutput, NULL, NULL, szFileName, szExt);
        *(szOutput + strlen(szOutput) - strlen(szFileName) - strlen(szExt)) = '\0';
    }

    SplitSymbols(szInput, szOutput, OutputFile, 0);

    CopyFileA(szDbgFile, OutputFile, TRUE);

    if (szOutput) {
        free(szInput);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\symtodbg\symcvt\symcvt.c ===
/*++


Copyright 1996 - 1997 Microsoft Corporation

Module Name:

    symcvt.c

Abstract:

    This module is the shell for the SYMCVT DLL.  The DLL's purpose is
    to convert the symbols for the specified image.  The resulting
    debug data must conform to the CODEVIEW spec.

    Currently this DLL converts COFF symbols and C7/C8 MAPTOSYM SYM files.

Author:

    Wesley A. Witt (wesw) 19-April-1993

Environment:

    Win32, User Mode

--*/

#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#define _SYMCVT_SOURCE_
#include "symcvt.h"

PUCHAR
ConvertSymbolsForImage(
                       HANDLE      hFile,
                       char *      fname
    )
/*++

Routine Description:

    Calls the appropriate conversion routine based on the file contents.


Arguments:

    hFile         -  file handle for the image (may be NULL)
    fname         -  file name for the image (may not have correct path)


Return Value:

    NULL             - could not convert the symbols
    Valid Pointer    - a pointer to malloc'ed memory that contains the
                       CODEVIEW symbols

--*/
{
    POINTERS   p;
    char       szDrive    [_MAX_DRIVE];
    char       szDir      [_MAX_DIR];
    char       szFname    [_MAX_FNAME];
    char       szExt      [_MAX_EXT];
    char       szSymName  [MAX_PATH];
    PUCHAR     rVal;


    if (!MapInputFile( &p, hFile, fname)) {

        rVal = NULL;

    } else if (CalculateNtImagePointers( &p.iptrs )) {

        //
        // we were able to compute the nt image pointers so this must be
        // a nt PE image.  now we must decide if there are coff symbols
        // if there are then we do the cofftocv conversion.
        //
        // btw, this is where someone would convert some other type of
        // symbols that are in a nt PE image. (party on garth..)
        //

//      if (!COFF_DIR(&p.iptrs)) {
        if (!p.iptrs.numberOfSymbols) {
            rVal = NULL;
        } else {
            ConvertCoffToCv( &p );
            rVal = p.pCvStart.ptr;
        }
        UnMapInputFile( &p );

    } else {

        UnMapInputFile ( &p );

        _splitpath( fname, szDrive, szDir, szFname, szExt );
        _makepath( szSymName, szDrive, szDir, szFname, "sym" );

        if (!MapInputFile( &p, NULL, szSymName)) {

            rVal = NULL;

        } else {

            //
            // must be a wow/dos app and there is a .sym file so lets to
            // the symtocv conversion
            //

            ConvertSymToCv( &p );
            UnMapInputFile( &p );

            rVal = p.pCvStart.ptr;
        }

    }

    return rVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\ticket\ticket.cpp ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>
#include <windows.h>
#include <winbase.h>
#include <lmcons.h>
#include <lmalert.h>
#include <ntiodump.h>
#define INITGUID
#include <dbgeng.h>
#include <guiddef.h>
#include <cmnutil.hpp>
#include "extsfns.h"
#include <lmuse.h>
#include <lmerr.h>
#include <strsafe.h>
#include "inetupld.h"

PSTR g_AppName;
PSTR g_ArchiveShare = NULL;
//
// Outputcallbacks for ticket
//
class DumpChkOutputCallbacks : public IDebugOutputCallbacks
{
public:
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        );
    STDMETHOD_(ULONG, AddRef)(
        THIS
        );
    STDMETHOD_(ULONG, Release)(
        THIS
        );
    // IDebugOutputCallbacks.
    STDMETHOD(Output)(
        THIS_
        IN ULONG Mask,
        IN PCSTR Text
        );
};

STDMETHODIMP
DumpChkOutputCallbacks::QueryInterface(
    THIS_
    IN REFIID InterfaceId,
    OUT PVOID* Interface
    )
{
    *Interface = NULL;

    if (IsEqualIID(InterfaceId, IID_IUnknown) ||
        IsEqualIID(InterfaceId, IID_IDebugOutputCallbacks))
    {
        *Interface = (IDebugOutputCallbacks *)this;
        AddRef();
        return S_OK;
    }
    else
    {
        return E_NOINTERFACE;
    }
}

STDMETHODIMP_(ULONG)
DumpChkOutputCallbacks::AddRef(
    THIS
    )
{
    // This class is designed to be static so
    // there's no true refcount.
    return 1;
}

STDMETHODIMP_(ULONG)
DumpChkOutputCallbacks::Release(
    THIS
    )
{
    // This class is designed to be static so
    // there's no true refcount.
    return 0;
}

STDMETHODIMP
DumpChkOutputCallbacks::Output(
    THIS_
    IN ULONG Mask,
    IN PCSTR Text
    )
{
    if (Text) fputs(Text, stdout);
    fflush(stdout);
    return S_OK;
}

DumpChkOutputCallbacks g_OutputCallback;



DWORD WINAPI
DisplayStatus(
    LPVOID Context
    )
{
    POCA_UPLOADFILE pUpload = (POCA_UPLOADFILE) Context;
    DWORD percent;
    while (1)
    {
        percent = pUpload->GetPercentComplete();
        if (percent > 100)
        {
            fprintf(stderr, "Upload complete.                                 \n");
            return 1;
        }
        fprintf(stderr, "Uploading: %02ld%% done.\r", percent);
        Sleep(700);
    }
    return 1;
}

void
UploadDumpFile(
    PSTR DumpFile,
    PSTR SR
    )
{
    HRESULT Hr = S_OK;
    WCHAR wszLocalDump[MAX_PATH] = {0};
    WCHAR wszRemoteName[MAX_PATH] = {0};
    WCHAR ResultUrl[MAX_PATH];
    WCHAR IsapiUrl[MAX_PATH];
    POCA_UPLOADFILE pUpload;
    HANDLE hThread = NULL;
    DWORD dwThreadId;
    PSTR FileExtension;

    FileExtension = DumpFile + strlen(DumpFile) - 4;
    if (_stricmp(FileExtension, ".cab"))
    {
        fprintf(stderr, "Please upload only the cab dump files.\n");
        return;
    }
    if (!OcaUpldCreate(&pUpload))
    {
        fprintf(stderr, "Cannot create UPLOAD object\n");
        return;
    }

    if (!MultiByteToWideChar(CP_ACP,0, DumpFile, strlen(DumpFile), wszLocalDump,
                             MAX_PATH))
    {
        fprintf(stderr, "Cannot conver %s to widechar\n", DumpFile);
        Hr = E_FAIL;
    }

    if (SUCCEEDED(Hr))
    {
        if ((Hr = pUpload->InitializeSession(L"910", wszLocalDump)) != S_OK )
        {
            fprintf(stderr, "Initilaize Upload session failed %lx.\n", Hr);
        }
    }
    if (SUCCEEDED(Hr))
    {
        if ((Hr = StringCbPrintfW(wszRemoteName, sizeof(wszRemoteName), L"/OCA/%S.cab", SR)) != S_OK)
        {
            fprintf(stderr, "Error in generating remote file name %lx \n", Hr);
        }
    }

    if (SUCCEEDED(Hr))
    {
        hThread = CreateThread(NULL, 0, &DisplayStatus, (PVOID) pUpload,
                           0, &dwThreadId);

        if ((Hr = pUpload->SendFile(wszRemoteName, FALSE)) != S_OK)
        {
            fprintf(stderr, "Send dumpfile failed %lx.\n", Hr);
        }
        pUpload->UnInitialize();
    }

    if (Hr == S_OK)
    {
        if ((Hr = StringCbPrintfW(IsapiUrl,sizeof( IsapiUrl ),
                                  L"/isapi/oca_extension.dll?id=%S.cab&Type=%ld&SR=%S",
                                  SR,
                                  8,
                                  SR)) != S_OK)
        {
            fprintf(stderr, "Cannot build IsapiUrl string. %lx\n", Hr);
        }
    }

    if (SUCCEEDED(Hr))
    {

        Hr = pUpload->GetUrlPageData(IsapiUrl, ResultUrl, sizeof(ResultUrl));

        Sleep(700);// To let DisplayStatus finish
        if (Hr != S_OK)
        {
            fprintf(stderr, "Cannot isapi return URL %lx\n", Hr);
        } else
        {
            fprintf(stderr, "File succesfully uploaded as %s.cab\n", SR);
            fprintf(stderr, "Received response URL: %ws\n", ResultUrl);
        }

    }

    if (hThread && hThread != INVALID_HANDLE_VALUE)
    {
        TerminateThread(hThread, 1);
        CloseHandle(hThread);
    }
    pUpload->UnInitialize();
    pUpload->Release();
    return;
}

void
Usage(void)
{
    fprintf(stderr, "Usage: %s [-i <imgpath>] [-y <sympath>] -s SR [-d <dumpfile>]\n", g_AppName);
}

HRESULT GetPasswdInput(
    LPWSTR wszPwd,
    ULONG PwdSize)
{
    int     err;
    DWORD   mode;
    WCHAR   Buff[51];

    fprintf(stdout, "Enter Password to connect to archive server: ");

    GetConsoleMode(GetStdHandle(STD_INPUT_HANDLE), &mode);
    SetConsoleMode(GetStdHandle(STD_INPUT_HANDLE),
                   (~(ENABLE_ECHO_INPUT)) & mode);

    if (scanf("%50ws", Buff) == 0)
    {
        return E_FAIL;
    }
    SetConsoleMode(GetStdHandle(STD_INPUT_HANDLE), mode);
    fprintf(stdout, "\n");
    return StringCbCopyW(wszPwd, PwdSize, Buff);
}


//
// This add access to Share
//
HRESULT
NetworkAccessShare(
    PSTR szShare,
    LPWSTR szPassword
    )
{
    USE_INFO_2 UseInfo;
    WCHAR wszShare[MAX_PATH], wszDomain[MAX_PATH], *pDir;


    if (MultiByteToWideChar(CP_ACP, 0, szShare, strlen(szShare)+1,
                            wszShare, sizeof(wszShare)/sizeof(WCHAR)) == FALSE)
    {
        return E_FAIL;
    }
    StringCbCopyW(wszDomain, sizeof(wszDomain), &wszShare[2]);
    pDir = wcsrchr(wszDomain, L'\\');
    if (pDir == NULL)
    {
        // bad share name
        return FALSE;
    }
    *pDir = 0;

    UseInfo.ui2_local = NULL;
    UseInfo.ui2_remote = wszShare;
    UseInfo.ui2_password = szPassword;
    UseInfo.ui2_username = L"OcaArchive";
    UseInfo.ui2_domainname = wszDomain;
    UseInfo.ui2_asg_type = 0;
    UseInfo.ui2_status = 0;
    if (NetUseAdd(NULL, 2, (LPBYTE) &UseInfo, NULL) != NERR_Success)
    {
        return E_FAIL;
    }
    return S_OK;
}

//
// Deletes any access granted to a remote share
//
HRESULT
NetworkDeleteShare(
    void
    )
{
    WCHAR wszShare[MAX_PATH];


    if (g_ArchiveShare == NULL)
    {
        return S_OK;
    }
    if (MultiByteToWideChar(CP_ACP, 0, g_ArchiveShare, strlen(g_ArchiveShare)+1,
                            wszShare, sizeof(wszShare)/sizeof(WCHAR)) == FALSE)
    {
        return E_FAIL;
    }
    if (NetUseDel(NULL, wszShare, USE_NOFORCE) != NERR_Success)
    {
        return E_FAIL;
    }
    return S_OK;
}

//
// This grants users archive access to OCA share for archiving dumps
//
BOOL
AddArchiveAccess(
    PDEBUG_CLIENT4 Client,
    PDEBUG_CONTROL3 DebugControl,
    ULONG Qualifier
    )
{
    HMODULE Ext = NULL;
    EXT_TRIAGE_FOLLOWUP fnGetFollowup;
    DEBUG_TRIAGE_FOLLOWUP_INFO Info;
    CHAR szShare[MAX_PATH];
    WCHAR Passwd[100];
    PSTR szLookup1 = "debugger-params!archshare-k-full";
    PSTR szLookup2 = "debugger-params!archshare-k-mini";
    PSTR szLookup;

    if (DebugControl->GetExtensionFunction(0, "GetTriageFollowupFromSymbol",
                                           (FARPROC*)&fnGetFollowup) != S_OK)
    {
        return FALSE;
    }

    if (Qualifier == DEBUG_DUMP_FULL)
    {
        szLookup = szLookup1;
    } else
    {
        szLookup = szLookup2;
    }

    Info.SizeOfStruct = sizeof(Info);
    Info.OwnerName = szShare;
    Info.OwnerNameSize = sizeof(szShare);

    if ((*fnGetFollowup)((PDEBUG_CLIENT) Client, szLookup, &Info) <= TRIAGE_FOLLOWUP_IGNORE)
    {
        return FALSE;
    }

    if (GetPasswdInput(Passwd, sizeof(Passwd)) != S_OK)
    {
        return FALSE;
    }
    //
    // Grant Access to szShare
    //
    if (NetworkAccessShare(szShare, Passwd) != S_OK)
    {
        return FALSE;
    }
    g_ArchiveShare = szShare;
    return TRUE;
}

HRESULT
CreateCabinetFromDump(
    PCSTR DumpFile,
    PSTR CabFile,
    ULONG cbCabFile
    )
{
    HRESULT Status;
    CHAR TempFile[MAX_PATH];
    PSTR Tail;

    Tail = strrchr(DumpFile, '\\');
    if (Tail == NULL) {
        Tail = (PSTR) DumpFile;
    } else {
        ++Tail;
    }
    if (!GetTempPathA(cbCabFile, CabFile)) {
        StringCbCopy(CabFile, cbCabFile, ".\\");
    }

    // Use the CAB name as the dump file name so the
    // name in the CAB will match.
    StringCbCat(CabFile, cbCabFile, Tail);
    StringCbCat(CabFile, cbCabFile, ".cab" );

    fprintf(stdout, "\nCreating %s, this could take some time...\n", CabFile);
    fflush(stdout);
    if ((Status = CreateDumpCab(CabFile)) != S_OK) {
        fprintf(stderr, "Unable to create CAB, %s\n", FormatStatusCode(Status));
        return Status;
    }
    else {
        //
        // add dump file.
        //
        Status = AddToDumpCab(DumpFile);
        CloseDumpCab();

    }

    return S_OK;
}
typedef HRESULT (WINAPI * RETRIVETICKET)(
                                         PSTR szSR,
                                         PSTR szPath,
                                         PDEBUG_CONTROL3 DebugControl
                                         );

HRESULT
RetriveSrTicket(
    PTSTR szSR
    )
{
    HRESULT Hr = S_OK;
    IDebugClient4 *DebugClient;
    IDebugControl3 *DebugControl;
    HMODULE Ext = NULL;
    RETRIVETICKET fnTicket;

    if ((Hr = DebugCreate(__uuidof(IDebugClient),
                          (void **)&DebugClient)) != S_OK) {
        fprintf(stderr, "Cannot initialize DebugClient\n");
        return Hr;
    }
    if ((DebugClient->QueryInterface(__uuidof(IDebugControl3),
                                    (void **)&DebugControl) != S_OK)) {
        fprintf(stderr, "QueryInterface failed for DebugClient\n");
        return Hr;
    }
    DebugClient->SetOutputCallbacks(&g_OutputCallback);

    Ext = LoadLibrary("winext\\ext.dll");
    if (!Ext) {
        fprintf(stderr,"Cannot load ext.dll.\n");
        Hr = E_FAIL;
    } else {

        fnTicket = (RETRIVETICKET) GetProcAddress(Ext, "_EFN_FindSrInfo");
        if (!fnTicket) {
            fprintf(stderr, "Cannot find _EFN_FindSrInfo\n");
            Hr = E_FAIL;
        } else {
            Hr = fnTicket(szSR, NULL, DebugControl);
        }
    }


    DebugControl->Release();
    DebugClient->Release();
    return Hr;
}

HRESULT
AddSrTicket(
    PTSTR szSR,
    PTSTR szDumpFile,
    PTSTR szSymbolPath,
    PTSTR szImagePath
    )
{
    HRESULT Hr = E_FAIL;
    IDebugClient4 *DebugClient;
    IDebugControl3 *DebugControl;
    IDebugSymbols2 *DebugSymbols;
    IDebugSystemObjects3 *DebugSysObjects;
    RETRIVETICKET fnTicket;
    CHAR Buffer[MAX_PATH*2];
    CHAR szCabFile[MAX_PATH];

    if ((Hr = DebugCreate(__uuidof(IDebugClient),
                          (void **)&DebugClient)) != S_OK) {
        fprintf(stderr, "Cannot initialize DebugClient\n");
        return Hr;
    }

    if ((DebugClient->QueryInterface(__uuidof(IDebugControl3),
                                    (void **)&DebugControl) != S_OK) ||
        (DebugClient->QueryInterface(__uuidof(IDebugSymbols2),
                                    (void **)&DebugSymbols) != S_OK) ||
        (DebugClient->QueryInterface(__uuidof(IDebugSystemObjects3),
                                    (void **)&DebugSysObjects) != S_OK)) {
        fprintf(stderr, "QueryInterface failed for DebugClient\n");
        return Hr;
    }

    DebugClient->SetOutputCallbacks(&g_OutputCallback);
    StringCbPrintf(Buffer, sizeof(Buffer),"Loading dump file %s\n", szDumpFile);
    g_OutputCallback.Output(-1, Buffer);
    if ((Hr = DebugClient->OpenDumpFile(szDumpFile)) != S_OK) {
        fprintf(stderr, "**** DebugClient cannot open DumpFile - error %lx\n", Hr);
        if (Hr == HRESULT_FROM_WIN32(ERROR_FILE_CORRUPT)) {
            fprintf(stderr, "DumpFile is corrupt\n");

        }
        return Hr;
    }
    if (szSymbolPath) {
        DebugSymbols->SetSymbolPath(szSymbolPath);
    }
    if (szImagePath) {
        DebugSymbols->SetImagePath(szImagePath);
    }

    DebugControl->WaitForEvent(DEBUG_WAIT_DEFAULT, INFINITE);

    DebugControl->Execute(DEBUG_OUTCTL_ALL_CLIENTS, "version", DEBUG_EXECUTE_DEFAULT);

    ULONG Class, Qual;
    if ((Hr = DebugControl->GetDebuggeeType(&Class, &Qual)) != S_OK) {
        Class = Qual = 0;
    }
    if (Class == DEBUG_CLASS_USER_WINDOWS) {
        //
        // User Mode dump
        //

        fprintf(stderr, "Usermode dumps are not handled\n");

    } else {
        //
        //  Kernel Mode dump
        //
        CHAR ExtensionCmd[100];

        DebugControl->Execute(DEBUG_OUTCTL_ALL_CLIENTS, "!analyze -v", DEBUG_EXECUTE_DEFAULT);

        if (DebugControl->GetExtensionFunction(0, "FindSrInfo",
                                               (FARPROC*)&fnTicket) != S_OK) {
            fnTicket = NULL;
        }
        if (!fnTicket) {
            g_OutputCallback.Output(0, "Cannot find _EFN_FindSrInfo\n");
            Hr = E_FAIL;
        } else {
            g_OutputCallback.Output(0, "Checking if SR exists in DB\n");
            Hr = fnTicket(szSR, NULL, DebugControl);
        }
//            StringCchPrintf(ExtensionCmd, sizeof(ExtensionCmd), "!ticket %s", szSR);
//            if (DebugControl->Execute(DEBUG_OUTCTL_ALL_CLIENTS, ExtensionCmd, DEBUG_EXECUTE_DEFAULT) == S_FALSE)
        if (Hr == S_FALSE) {

            if (_stricmp(szDumpFile + strlen(szDumpFile) - 4, ".cab")) {
                if ((Hr = CreateCabinetFromDump(szDumpFile, szCabFile,
                                                sizeof(szCabFile))) != S_OK) {
                    g_OutputCallback.Output(0,"Could not cab the dump file\n");
                }
            } else {
                StringCbCopy(szCabFile, sizeof(szCabFile), szDumpFile);
            }


            g_OutputCallback.Output(0,"... uploading dump file to the server\n");
            UploadDumpFile(szCabFile, szSR);

            if (strcmp(szCabFile, szDumpFile)) {
                DeleteFile(szCabFile);
            }
        }
    }
    DebugSysObjects->Release();
    DebugControl->Release();
    DebugSymbols->Release();
    DebugClient->Release();
    return S_OK;
}

void
__cdecl
main (
    int Argc,
    PCHAR *Argv
    )

{
    LONG arg;
    PCHAR DumpFileName = NULL;
    PCHAR SymbolPath = NULL;
    PCHAR ImagePath = NULL;
    PCHAR SR = NULL;

    g_AppName = Argv[0];

    for (arg = 1; arg < Argc; arg++) {
        if (Argv[arg][0] == '-' || Argv[arg][0] == '/') {
            switch (Argv[arg][1]) {
            case 'd':
            case 'D':
                if (++arg < Argc) {
                    DumpFileName = Argv[arg];
                }
                break;
            case 's':
            case 'S':
                if (++arg < Argc) {
                    SR = Argv[arg];
                }
                break;
            case 'i':
            case 'I':
                if (++arg < Argc) {
                    ImagePath = Argv[arg];
                }
                break;
            case 'y':
            case 'Y':
                if (++arg < Argc) {
                    SymbolPath = Argv[arg];
                }
                break;
            default:
                break;
            }
        }
    }

    if (!SR) {
        Usage();
        return;
    } else if (!DumpFileName) {
        RetriveSrTicket(SR);
        return;
    }
    if (SymbolPath == NULL) {
        SymbolPath = "SRV*";
    }
    AddSrTicket(SR, DumpFileName, SymbolPath, ImagePath);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\symtodbg\symcvt\symtocv.c ===
/*++


Copyright 1996 - 1997 Microsoft Corporation

Module Name:

    symtocv.c

Abstract:

    This module handles the conversion activities requires for converting
    C7/C8 SYM files to CODEVIEW debug data.

Author:

    Wesley A. Witt (wesw) 13-April-1993
    Modified: Sivarudrappa Mahesh (smahesh) 08-September-2000

Environment:

    Win32, User Mode

--*/

#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include "cv.h"
#define _SYMCVT_SOURCE_
#include "symcvt.h"
#include "cvcommon.h"

typedef struct tagSYMNAME {
    BYTE        length;
    char        name[1];
} SYMNAME, *PSYMNAME;

typedef struct tagSYMSYMBOL {
    DWORD       offset;
    SYMNAME     symName;
} SYMSYMBOL, *PSYMSYMBOL;

typedef struct tagSYMFILEHEADER {
    DWORD       fileSize;
    WORD        reserved1;
    WORD        numSyms;
    DWORD       reserved2;
    WORD        nextOffset;
    BYTE        reserved3;
    SYMNAME     symName;
} SYMFILEHEADER, *PSYMFILEHEADER;

typedef struct tagSYMHEADER {
    WORD        nextOffset;
    WORD        numSyms;
    WORD        symOffsetsOffset;
    WORD        segment;
    BYTE        reserved2[6];
    BYTE        type;
    BYTE        reserved3[5];
    SYMNAME     symName;
} SYMHEADER, *PSYMHEADER;

#define SIZEOFSYMFILEHEADER   16
#define SIZEOFSYMHEADER       21
#define SIZEOFSYMBOL           3

#define SYM_SEGMENT_NAME       0
#define SYM_SYMBOL_NAME        1
#define SYM_SEGMENT_ABS        2
#define SYM_SYMBOL_ABS         3

typedef struct tagENUMINFO {
    DATASYM32           *dataSym;
    DATASYM32           *dataSym2;
    DWORD               numsyms;
    SGI                 *sgi;
} ENUMINFO, *PENUMINFO;

typedef BOOL (CALLBACK* SYMBOLENUMPROC)(PSYMNAME pSymName, int symType,
                                        SEGMENT segment, UOFF32 offset,
                                        PENUMINFO pEnumInfo);


static VOID   GetSymName( PIMAGE_SYMBOL Symbol, PUCHAR StringTable,
                          char * s );
DWORD  CreateModulesFromSyms( PPOINTERS p );
DWORD  CreatePublicsFromSyms( PPOINTERS p );
DWORD  CreateSegMapFromSyms( PPOINTERS p );
static BOOL   EnumSymbols( PPOINTERS p, SYMBOLENUMPROC lpEnumProc,
                           PENUMINFO pEnumInfo  );

int             CSymSegs;


BOOL CALLBACK
SymbolCount(PSYMNAME pSymName, int symType, SEGMENT segment,
            UOFF32 offset, PENUMINFO pEnumInfo )
{
    if ((symType == SYM_SEGMENT_NAME) && (segment > 0)) {
        CSymSegs += 1;
    }
    pEnumInfo->numsyms++;
    return TRUE;
}


BOOL
ConvertSymToCv( PPOINTERS p )

/*++

Routine Description:

    This is the control function for the conversion of COFF to CODEVIEW
    debug data.  It calls individual functions for the conversion of
    specific types of debug data.


Arguments:

    p        - pointer to a POINTERS structure (see symcvt.h)


Return Value:

    TRUE     - conversion succeded
    FALSE    - conversion failed

--*/

{
    ENUMINFO            enumInfo;
    DWORD               dwSize;
    
    CSymSegs         = 0;
    enumInfo.numsyms = 0;
    
    EnumSymbols( p, SymbolCount, &enumInfo );
    
    dwSize = (enumInfo.numsyms * (sizeof(DATASYM32) + 10)) + 512000;
    p->pCvCurr = p->pCvStart.ptr = malloc(dwSize);
    
    if (p->pCvStart.ptr == NULL) {
        return FALSE;
    }
    memset( p->pCvStart.ptr, 0, dwSize );

    try {
        CreateSignature( p );
        CreatePublicsFromSyms( p );
        CreateSymbolHashTable( p );
        CreateAddressSortTable( p );
        CreateSegMapFromSyms( p );
        CreateModulesFromSyms( p );
        CreateDirectories( p );
        p->pCvStart.ptr = realloc( p->pCvStart.ptr, p->pCvStart.size );
        return TRUE;

    } except (EXCEPTION_EXECUTE_HANDLER) {

        free( p->pCvStart.ptr );
        p->pCvStart.ptr = NULL;
        return FALSE;

    }
}


DWORD
CreateModulesFromSyms( PPOINTERS p )

/*++

Routine Description:

    Creates the individual CV module records.  There is one CV module
    record for each .FILE record in the COFF debug data.  This is true
    even if the COFF size is zero.


Arguments:

    p        - pointer to a POINTERS structure (see symcvt.h)


Return Value:

    The number of modules that were created.

--*/

{
    char                szDrive    [_MAX_DRIVE];
    char                szDir      [_MAX_DIR];
    char                szFname    [_MAX_FNAME];
    char                szExt      [_MAX_EXT];
    OMFModule           *m;
    int                 i;
    char *              pb;

    _splitpath( p->iptrs.szName, szDrive, szDir, szFname, szExt );

    m = (OMFModule *) p->pCvCurr;

    m->ovlNumber        = 0;
    m->iLib             = 0;
    m->cSeg             = (unsigned short) CSymSegs;
    m->Style[0]         = 'C';
    m->Style[1]         = 'V';
    for (i=0; i<CSymSegs; i++) {
        m->SegInfo[i].Seg   = i+1;
        m->SegInfo[i].pad   = 0;
        m->SegInfo[i].Off   = 0;
        m->SegInfo[i].cbSeg = 0xffff;
    }
    pb = (char *) &m->SegInfo[CSymSegs];
    sprintf( &pb[1], "%s.c", szFname );
    pb[0] = (char)strlen( &pb[1] );

    pb = (char *) NextMod(m);

    UpdatePtrs( p, &p->pCvModules, (LPVOID)pb, 1 );

    return 1;
}


BOOL CALLBACK
ConvertASymtoPublic(PSYMNAME pSymName, int symType, SEGMENT segment,
                    UOFF32 offset, PENUMINFO pEnumInfo )
{
    if (symType != SYM_SYMBOL_NAME) {
        return TRUE;
    }

    pEnumInfo->dataSym->rectyp     = S_PUB32;
    pEnumInfo->dataSym->seg        = segment;
    pEnumInfo->dataSym->off        = offset;
    pEnumInfo->dataSym->typind     = 0;
    pEnumInfo->dataSym->name[0]    = pSymName->length;
    strncpy( &pEnumInfo->dataSym->name[1], pSymName->name, pSymName->length );
    pEnumInfo->dataSym2 = NextSym32( pEnumInfo->dataSym );
    pEnumInfo->dataSym->reclen = (USHORT) ((DWORD)pEnumInfo->dataSym2 -
                                  (DWORD)pEnumInfo->dataSym) - 2;
    pEnumInfo->dataSym = pEnumInfo->dataSym2;
    pEnumInfo->numsyms++;

    return TRUE;
}


DWORD
CreatePublicsFromSyms( PPOINTERS p )

/*++

Routine Description:

    Creates the individual CV public symbol records.  There is one CV
    public record created for each COFF symbol that is marked as EXTERNAL
    and has a section number greater than zero.  The resulting CV publics
    are sorted by section and offset.


Arguments:

    p        - pointer to a POINTERS structure (see symcvt.h)


Return Value:

    The number of publics created.

--*/

{
    OMFSymHash          *omfSymHash;
    ENUMINFO            enumInfo;


    enumInfo.dataSym = (DATASYM32 *)
                 (PUCHAR)((DWORD)p->pCvCurr + sizeof(OMFSymHash));
    enumInfo.numsyms = 0;

    EnumSymbols( p, ConvertASymtoPublic, &enumInfo );

    omfSymHash = (OMFSymHash *) p->pCvCurr;
    UpdatePtrs(p, &p->pCvPublics, (LPVOID)enumInfo.dataSym,
               enumInfo.numsyms );

    omfSymHash->cbSymbol = p->pCvPublics.size - sizeof(OMFSymHash);
    omfSymHash->symhash  = 0;
    omfSymHash->addrhash = 0;
    omfSymHash->cbHSym   = 0;
    omfSymHash->cbHAddr  = 0;

    return enumInfo.numsyms;
}


BOOL CALLBACK
ConvertASegment( PSYMNAME pSymName, int symType, SEGMENT segment,
            UOFF32 offset, PENUMINFO pEnumInfo )
{
    if (symType != SYM_SEGMENT_NAME) {
        return TRUE;
    }

    if (segment == 0) {
        return TRUE;
    }

    pEnumInfo->numsyms++;

    pEnumInfo->sgi->sgf.fRead        = TRUE;
    pEnumInfo->sgi->sgf.fWrite       = TRUE;
    pEnumInfo->sgi->sgf.fExecute     = TRUE;
    pEnumInfo->sgi->sgf.f32Bit       = 0;
    pEnumInfo->sgi->sgf.fSel         = 0;
    pEnumInfo->sgi->sgf.fAbs         = 0;
    pEnumInfo->sgi->sgf.fGroup       = 1;
    pEnumInfo->sgi->iovl             = 0;
    pEnumInfo->sgi->igr              = 0;
    pEnumInfo->sgi->isgPhy           = (USHORT) pEnumInfo->numsyms;
    pEnumInfo->sgi->isegName         = 0;
    pEnumInfo->sgi->iclassName       = 0;
    pEnumInfo->sgi->doffseg          = offset;
    pEnumInfo->sgi->cbSeg            = 0xFFFF;
    pEnumInfo->sgi++;

    return TRUE;
}


DWORD
CreateSegMapFromSyms( PPOINTERS p )

/*++

Routine Description:

    Creates the CV segment map.  The segment map is used by debuggers
    to aid in address lookups.  One segment is created for each COFF
    section in the image.

Arguments:

    p        - pointer to a POINTERS structure (see symcvt.h)


Return Value:

    The number of segments in the map.

--*/

{
    SGM          *sgm;
    ENUMINFO     enumInfo;


    sgm = (SGM *) p->pCvCurr;
    enumInfo.sgi = (SGI *) ((DWORD)p->pCvCurr + sizeof(SGM));
    enumInfo.numsyms = 0;

    EnumSymbols( p, ConvertASegment, &enumInfo );

    sgm->cSeg = (USHORT)enumInfo.numsyms;
    sgm->cSegLog = (USHORT)enumInfo.numsyms;

    UpdatePtrs( p, &p->pCvSegMap, (LPVOID)enumInfo.sgi, enumInfo.numsyms );

    return enumInfo.numsyms;
}


BOOL
EnumSymbols( PPOINTERS p, SYMBOLENUMPROC lpEnumProc, PENUMINFO pEnumInfo )

/*++

Routine Description:

    This function enumerates all symbols ine the mapped SYM file


Arguments:

    p             -  pointer to a POINTERS structure
    lpEnumProc    -  function to be called once for each function
    pEnumInfo     -  data to be passed between the caller and the enum func

Return Value:

    TRUE     - success
    FALSE    - failure

--*/

{
    PSYMFILEHEADER      pSymFileHead;
    PSYMHEADER          pSymHead;
    PSYMHEADER          pSymHead2;
    PSYMSYMBOL          pSymSymbol;
    DWORD               i;
    DWORD               startPosition;
    DWORD               position;
    BOOL                fV86Mode;
    WORD                Segment;
    UOFF32              Offset;
    BYTE*               pSymOffsets;
    DWORD               dwSymOffset;

    pSymFileHead = (PSYMFILEHEADER) p->iptrs.fptr;
    pSymSymbol = (PSYMSYMBOL) ((DWORD)pSymFileHead + SIZEOFSYMFILEHEADER +
                               pSymFileHead->symName.length + 1);

    if (!lpEnumProc(&pSymFileHead->symName, SYM_SEGMENT_ABS,
                    0, 0, pEnumInfo )) {
        return FALSE;
    }

    for (i=0; i<pSymFileHead->numSyms; i++) {
        if (!lpEnumProc(&pSymSymbol->symName, SYM_SYMBOL_ABS,
                        0, pSymSymbol->offset, pEnumInfo )) {
            return FALSE;
        }
        pSymSymbol = (PSYMSYMBOL) ((DWORD)pSymSymbol + SIZEOFSYMBOL +
                                   pSymSymbol->symName.length);
    }

    position = startPosition = ((LONG)pSymFileHead->nextOffset) << 4;

    //
    //  Determine if this is a V86Mode sym file.
    //
    //  We'll read the first two headers. If their segment numbers are
    //  not 1 and 2, then we assume V86Mode.
    //
    pSymHead  = (PSYMHEADER) ((DWORD)p->iptrs.fptr + position);
    position  = ((LONG)pSymHead->nextOffset) << 4;
    if ( position != startPosition && position != 0 ) {
        pSymHead2 = (PSYMHEADER) ((DWORD)p->iptrs.fptr + position);
    } else {
        pSymHead2 = NULL;
    }

    if ( pSymHead->segment == 1 &&
         (!pSymHead2 || pSymHead2->segment == 2)) {
        fV86Mode = FALSE;
    } else {
        fV86Mode = TRUE;
        Segment  = 0;
    }

    position = startPosition;

    do {
        pSymHead = (PSYMHEADER) ((DWORD)p->iptrs.fptr + position);
        // BIG SYMDEF
        if (pSymHead->type & 0x04) { 
            pSymOffsets = (BYTE*) ((DWORD)pSymHead + (pSymHead->symOffsetsOffset << 4));
        }
        else {
            pSymOffsets = (BYTE*) ((DWORD)pSymHead + pSymHead->symOffsetsOffset);
        }

        if ( fV86Mode ) {
            Segment++;
            Offset  = pSymHead->segment;
        } else {
            Segment = pSymHead->segment;
            Offset  = 0;
        }

        position = ((LONG)pSymHead->nextOffset) << 4;

        if (!lpEnumProc( &pSymHead->symName, SYM_SEGMENT_NAME,
                        Segment, Offset, pEnumInfo )) {
            return FALSE;
        }

        for (i=0; i<pSymHead->numSyms; i++) {
            // BIG SYMDEF
            if (pSymHead->type & 0x04) { 
                pSymSymbol = (PSYMSYMBOL) ((DWORD)pSymHead + 
                                            pSymOffsets[i*3+0] + 
                                            pSymOffsets[i*3+1] * 256 + 
                                            pSymOffsets[i*3+2] * 65536);
                dwSymOffset = pSymSymbol->offset;
            }    
            else {
                // HACKHACK: The Symbol Name and Offset are contiguous in the case of
                // MSF_32BITSYMS and are separated by 2 bytes in all other cases. 
                pSymSymbol  = (PSYMSYMBOL)((DWORD)pSymHead + 
                                            pSymOffsets[i*2+0] + 
                                            pSymOffsets[i*2+1] * 256);
                dwSymOffset = pSymSymbol->offset;
                pSymSymbol  = (PSYMSYMBOL)((DWORD)pSymHead + 
                                            pSymOffsets[i*2+0] + 
                                            pSymOffsets[i*2+1] * 256 - 
                                            sizeof(SHORT) * (1 - (pSymHead->type & 0x01)));
            }
            // MSF_32BITSYMS
            if (pSymHead->type & 0x01) { 
                if (!lpEnumProc(&pSymSymbol->symName, SYM_SYMBOL_NAME,
                                Segment, dwSymOffset,
                                pEnumInfo )) {
                    return FALSE;
                }
            }
            // 16 BIT SYMS 
            else { 
                if (!lpEnumProc(&pSymSymbol->symName, SYM_SYMBOL_NAME,
                                Segment, dwSymOffset & 0x0000FFFF,
                                pEnumInfo )) {
                    return FALSE;
                }
            }
        }
    } while ( position != startPosition && position != 0 );

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\vs\cvconst.h ===
// cvconst.h - codeview constant definitions
//-----------------------------------------------------------------
//
// Copyright Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------
#ifndef _CVCONST_H_
#define _CVCONST_H_



//      Enumeration for function call type


typedef enum CV_call_e {
    CV_CALL_NEAR_C      = 0x00, // near right to left push, caller pops stack
    CV_CALL_FAR_C       = 0x01, // far right to left push, caller pops stack
    CV_CALL_NEAR_PASCAL = 0x02, // near left to right push, callee pops stack
    CV_CALL_FAR_PASCAL  = 0x03, // far left to right push, callee pops stack
    CV_CALL_NEAR_FAST   = 0x04, // near left to right push with regs, callee pops stack
    CV_CALL_FAR_FAST    = 0x05, // far left to right push with regs, callee pops stack
    CV_CALL_SKIPPED     = 0x06, // skipped (unused) call index
    CV_CALL_NEAR_STD    = 0x07, // near standard call
    CV_CALL_FAR_STD     = 0x08, // far standard call
    CV_CALL_NEAR_SYS    = 0x09, // near sys call
    CV_CALL_FAR_SYS     = 0x0a, // far sys call
    CV_CALL_THISCALL    = 0x0b, // this call (this passed in register)
    CV_CALL_MIPSCALL    = 0x0c, // Mips call
    CV_CALL_GENERIC     = 0x0d, // Generic call sequence
    CV_CALL_ALPHACALL   = 0x0e, // Alpha call
    CV_CALL_PPCCALL     = 0x0f, // PPC call
    CV_CALL_SHCALL      = 0x10, // Hitachi SuperH call
    CV_CALL_ARMCALL     = 0x11, // ARM call
    CV_CALL_AM33CALL    = 0x12, // AM33 call
    CV_CALL_TRICALL     = 0x13, // TriCore Call
    CV_CALL_SH5CALL     = 0x14, // Hitachi SuperH-5 call
    CV_CALL_M32RCALL    = 0x15, // M32R Call
    CV_CALL_RESERVED    = 0x16  // first unused call enumeration
} CV_call_e;




//      Values for the access protection of class attributes


typedef enum CV_access_e {
    CV_private   = 1,
    CV_protected = 2,
    CV_public    = 3
} CV_access_e;

typedef enum THUNK_ORDINAL {
    THUNK_ORDINAL_NOTYPE,       // standard thunk
    THUNK_ORDINAL_ADJUSTOR,     // "this" adjustor thunk
    THUNK_ORDINAL_VCALL,        // virtual call thunk
    THUNK_ORDINAL_PCODE,        // pcode thunk
    THUNK_ORDINAL_LOAD,         // thunk which loads the address to jump to
                                //  via unknown means...

 // trampoline thunk ordinals   - only for use in Trampoline thunk symbols
    THUNK_ORDINAL_TRAMP_INCREMENTAL,
    THUNK_ORDINAL_TRAMP_BRANCHISLAND,

} THUNK_ORDINAL;


enum CV_SourceChksum_t {
    CHKSUM_TYPE_NONE = 0,        // indicates no checksum is available
    CHKSUM_TYPE_MD5
};

//
// DIA enums
//

enum SymTagEnum
{
    SymTagNull,
    SymTagExe,
    SymTagCompiland,
    SymTagCompilandDetails,
    SymTagCompilandEnv,
    SymTagFunction,
    SymTagBlock,
    SymTagData,
    SymTagAnnotation,
    SymTagLabel,
    SymTagPublicSymbol,
    SymTagUDT,
    SymTagEnum,
    SymTagFunctionType,
    SymTagPointerType,
    SymTagArrayType,
    SymTagBaseType,
    SymTagTypedef,
    SymTagBaseClass,
    SymTagFriend,
    SymTagFunctionArgType,
    SymTagFuncDebugStart,
    SymTagFuncDebugEnd,
    SymTagUsingNamespace,
    SymTagVTableShape,
    SymTagVTable,
    SymTagCustom,
    SymTagThunk,
    SymTagCustomType,
    SymTagManagedType,
    SymTagDimension,
    SymTagMax
};

enum LocationType
{
    LocIsNull,
    LocIsStatic,
    LocIsTLS,
    LocIsRegRel,
    LocIsThisRel,
    LocIsEnregistered,
    LocIsBitField,
    LocIsSlot,
    LocIsIlRel,
    LocInMetaData,
    LocIsConstant,
    LocTypeMax
};

enum DataKind
{
    DataIsUnknown,
    DataIsLocal,
    DataIsStaticLocal,
    DataIsParam,
    DataIsObjectPtr,
    DataIsFileStatic,
    DataIsGlobal,
    DataIsMember,
    DataIsStaticMember,
    DataIsConstant
};

enum UdtKind
{
    UdtStruct,
    UdtClass,
    UdtUnion
};

enum BasicType
{
    btNoType = 0,
    btVoid = 1,
    btChar = 2,
    btWChar = 3,
    btInt = 6,
    btUInt = 7,
    btFloat = 8,
    btBCD = 9,
    btBool = 10,
    btLong = 13,
    btULong = 14,
    btCurrency = 25,
    btDate = 26,
    btVariant = 27,
    btComplex = 28,
    btBit = 29,
    btBSTR = 30,
    btHresult = 31
};


//  enum describing the compile flag source language


typedef enum CV_CFL_LANG {
    CV_CFL_C        = 0x00,
    CV_CFL_CXX      = 0x01,
    CV_CFL_FORTRAN  = 0x02,
    CV_CFL_MASM     = 0x03,
    CV_CFL_PASCAL   = 0x04,
    CV_CFL_BASIC    = 0x05,
    CV_CFL_COBOL    = 0x06,
    CV_CFL_LINK     = 0x07,
    CV_CFL_CVTRES   = 0x08,
    CV_CFL_CVTPGD   = 0x09,
} CV_CFL_LANG;


//  enum describing target processor


typedef enum CV_CPU_TYPE_e {
    CV_CFL_8080         = 0x00,
    CV_CFL_8086         = 0x01,
    CV_CFL_80286        = 0x02,
    CV_CFL_80386        = 0x03,
    CV_CFL_80486        = 0x04,
    CV_CFL_PENTIUM      = 0x05,
    CV_CFL_PENTIUMII    = 0x06,
    CV_CFL_PENTIUMPRO   = CV_CFL_PENTIUMII,
    CV_CFL_PENTIUMIII   = 0x07,
    CV_CFL_MIPS         = 0x10,
    CV_CFL_MIPSR4000    = CV_CFL_MIPS,  // don't break current code
    CV_CFL_MIPS16       = 0x11,
    CV_CFL_MIPS32       = 0x12,
    CV_CFL_MIPS64       = 0x13,
    CV_CFL_MIPSI        = 0x14,
    CV_CFL_MIPSII       = 0x15,
    CV_CFL_MIPSIII      = 0x16,
    CV_CFL_MIPSIV       = 0x17,
    CV_CFL_MIPSV        = 0x18,
    CV_CFL_M68000       = 0x20,
    CV_CFL_M68010       = 0x21,
    CV_CFL_M68020       = 0x22,
    CV_CFL_M68030       = 0x23,
    CV_CFL_M68040       = 0x24,
    CV_CFL_ALPHA        = 0x30,
    CV_CFL_ALPHA_21064  = 0x30,
    CV_CFL_ALPHA_21164  = 0x31,
    CV_CFL_ALPHA_21164A = 0x32,
    CV_CFL_ALPHA_21264  = 0x33,
    CV_CFL_ALPHA_21364  = 0x34,
    CV_CFL_PPC601       = 0x40,
    CV_CFL_PPC603       = 0x41,
    CV_CFL_PPC604       = 0x42,
    CV_CFL_PPC620       = 0x43,
    CV_CFL_PPCFP        = 0x44,
    CV_CFL_SH3          = 0x50,
    CV_CFL_SH3E         = 0x51,
    CV_CFL_SH3DSP       = 0x52,
    CV_CFL_SH4          = 0x53,
    CV_CFL_SHMEDIA      = 0x54,
    CV_CFL_ARM3         = 0x60,
    CV_CFL_ARM4         = 0x61,
    CV_CFL_ARM4T        = 0x62,
    CV_CFL_ARM5         = 0x63,
    CV_CFL_ARM5T        = 0x64,
    CV_CFL_OMNI         = 0x70,
    CV_CFL_IA64         = 0x80,
    CV_CFL_IA64_1       = 0x80,
    CV_CFL_IA64_2       = 0x81,
    CV_CFL_CEE          = 0x90,
    CV_CFL_AM33         = 0xA0,
    CV_CFL_M32R         = 0xB0,
    CV_CFL_TRICORE      = 0xC0,
    CV_CFL_X8664        = 0xD0,
    CV_CFL_AMD64        = CV_CFL_X8664,
    CV_CFL_EBC          = 0xE0,
    CV_CFL_THUMB        = 0xF0,
} CV_CPU_TYPE_e;

typedef enum CV_HREG_e {
    // Register subset shared by all processor types,
    // must not overlap with any of the ranges below, hence the high values

    CV_ALLREG_ERR   =   30000,
    CV_ALLREG_TEB   =   30001,
    CV_ALLREG_TIMER =   30002,
    CV_ALLREG_EFAD1 =   30003,
    CV_ALLREG_EFAD2 =   30004,
    CV_ALLREG_EFAD3 =   30005,
    CV_ALLREG_VFRAME=   30006,
    CV_ALLREG_HANDLE=   30007,
    CV_ALLREG_PARAMS=   30008,
    CV_ALLREG_LOCALS=   30009,
    CV_ALLREG_TID   =   30010,
    CV_ALLREG_ENV   =   30011,
    CV_ALLREG_CMDLN =   30012,


    //  Register set for the Intel 80x86 and ix86 processor series
    //  (plus PCODE registers)

    CV_REG_NONE     =   0,
    CV_REG_AL       =   1,
    CV_REG_CL       =   2,
    CV_REG_DL       =   3,
    CV_REG_BL       =   4,
    CV_REG_AH       =   5,
    CV_REG_CH       =   6,
    CV_REG_DH       =   7,
    CV_REG_BH       =   8,
    CV_REG_AX       =   9,
    CV_REG_CX       =  10,
    CV_REG_DX       =  11,
    CV_REG_BX       =  12,
    CV_REG_SP       =  13,
    CV_REG_BP       =  14,
    CV_REG_SI       =  15,
    CV_REG_DI       =  16,
    CV_REG_EAX      =  17,
    CV_REG_ECX      =  18,
    CV_REG_EDX      =  19,
    CV_REG_EBX      =  20,
    CV_REG_ESP      =  21,
    CV_REG_EBP      =  22,
    CV_REG_ESI      =  23,
    CV_REG_EDI      =  24,
    CV_REG_ES       =  25,
    CV_REG_CS       =  26,
    CV_REG_SS       =  27,
    CV_REG_DS       =  28,
    CV_REG_FS       =  29,
    CV_REG_GS       =  30,
    CV_REG_IP       =  31,
    CV_REG_FLAGS    =  32,
    CV_REG_EIP      =  33,
    CV_REG_EFLAGS   =  34,
    CV_REG_TEMP     =  40,          // PCODE Temp
    CV_REG_TEMPH    =  41,          // PCODE TempH
    CV_REG_QUOTE    =  42,          // PCODE Quote
    CV_REG_PCDR3    =  43,          // PCODE reserved
    CV_REG_PCDR4    =  44,          // PCODE reserved
    CV_REG_PCDR5    =  45,          // PCODE reserved
    CV_REG_PCDR6    =  46,          // PCODE reserved
    CV_REG_PCDR7    =  47,          // PCODE reserved
    CV_REG_CR0      =  80,          // CR0 -- control registers
    CV_REG_CR1      =  81,
    CV_REG_CR2      =  82,
    CV_REG_CR3      =  83,
    CV_REG_CR4      =  84,          // Pentium
    CV_REG_DR0      =  90,          // Debug register
    CV_REG_DR1      =  91,
    CV_REG_DR2      =  92,
    CV_REG_DR3      =  93,
    CV_REG_DR4      =  94,
    CV_REG_DR5      =  95,
    CV_REG_DR6      =  96,
    CV_REG_DR7      =  97,
    CV_REG_GDTR     =  110,
    CV_REG_GDTL     =  111,
    CV_REG_IDTR     =  112,
    CV_REG_IDTL     =  113,
    CV_REG_LDTR     =  114,
    CV_REG_TR       =  115,

    CV_REG_PSEUDO1  =  116,
    CV_REG_PSEUDO2  =  117,
    CV_REG_PSEUDO3  =  118,
    CV_REG_PSEUDO4  =  119,
    CV_REG_PSEUDO5  =  120,
    CV_REG_PSEUDO6  =  121,
    CV_REG_PSEUDO7  =  122,
    CV_REG_PSEUDO8  =  123,
    CV_REG_PSEUDO9  =  124,

    CV_REG_ST0      =  128,
    CV_REG_ST1      =  129,
    CV_REG_ST2      =  130,
    CV_REG_ST3      =  131,
    CV_REG_ST4      =  132,
    CV_REG_ST5      =  133,
    CV_REG_ST6      =  134,
    CV_REG_ST7      =  135,
    CV_REG_CTRL     =  136,
    CV_REG_STAT     =  137,
    CV_REG_TAG      =  138,
    CV_REG_FPIP     =  139,
    CV_REG_FPCS     =  140,
    CV_REG_FPDO     =  141,
    CV_REG_FPDS     =  142,
    CV_REG_ISEM     =  143,
    CV_REG_FPEIP    =  144,
    CV_REG_FPEDO    =  145,

    CV_REG_MM0      =  146,
    CV_REG_MM1      =  147,
    CV_REG_MM2      =  148,
    CV_REG_MM3      =  149,
    CV_REG_MM4      =  150,
    CV_REG_MM5      =  151,
    CV_REG_MM6      =  152,
    CV_REG_MM7      =  153,

    CV_REG_XMM0     =  154, // KATMAI registers
    CV_REG_XMM1     =  155,
    CV_REG_XMM2     =  156,
    CV_REG_XMM3     =  157,
    CV_REG_XMM4     =  158,
    CV_REG_XMM5     =  159,
    CV_REG_XMM6     =  160,
    CV_REG_XMM7     =  161,

    CV_REG_XMM00    =  162, // KATMAI sub-registers
    CV_REG_XMM01    =  163,
    CV_REG_XMM02    =  164,
    CV_REG_XMM03    =  165,
    CV_REG_XMM10    =  166,
    CV_REG_XMM11    =  167,
    CV_REG_XMM12    =  168,
    CV_REG_XMM13    =  169,
    CV_REG_XMM20    =  170,
    CV_REG_XMM21    =  171,
    CV_REG_XMM22    =  172,
    CV_REG_XMM23    =  173,
    CV_REG_XMM30    =  174,
    CV_REG_XMM31    =  175,
    CV_REG_XMM32    =  176,
    CV_REG_XMM33    =  177,
    CV_REG_XMM40    =  178,
    CV_REG_XMM41    =  179,
    CV_REG_XMM42    =  180,
    CV_REG_XMM43    =  181,
    CV_REG_XMM50    =  182,
    CV_REG_XMM51    =  183,
    CV_REG_XMM52    =  184,
    CV_REG_XMM53    =  185,
    CV_REG_XMM60    =  186,
    CV_REG_XMM61    =  187,
    CV_REG_XMM62    =  188,
    CV_REG_XMM63    =  189,
    CV_REG_XMM70    =  190,
    CV_REG_XMM71    =  191,
    CV_REG_XMM72    =  192,
    CV_REG_XMM73    =  193,

    CV_REG_XMM0L    =  194,
    CV_REG_XMM1L    =  195,
    CV_REG_XMM2L    =  196,
    CV_REG_XMM3L    =  197,
    CV_REG_XMM4L    =  198,
    CV_REG_XMM5L    =  199,
    CV_REG_XMM6L    =  200,
    CV_REG_XMM7L    =  201,

    CV_REG_XMM0H    =  202,
    CV_REG_XMM1H    =  203,
    CV_REG_XMM2H    =  204,
    CV_REG_XMM3H    =  205,
    CV_REG_XMM4H    =  206,
    CV_REG_XMM5H    =  207,
    CV_REG_XMM6H    =  208,
    CV_REG_XMM7H    =  209,

    CV_REG_MXCSR    =  211, // XMM status register

    CV_REG_EDXEAX   =  212, // EDX:EAX pair

    CV_REG_EMM0L    =  220, // XMM sub-registers (WNI integer)
    CV_REG_EMM1L    =  221,
    CV_REG_EMM2L    =  222,
    CV_REG_EMM3L    =  223,
    CV_REG_EMM4L    =  224,
    CV_REG_EMM5L    =  225,
    CV_REG_EMM6L    =  226,
    CV_REG_EMM7L    =  227,

    CV_REG_EMM0H    =  228,
    CV_REG_EMM1H    =  229,
    CV_REG_EMM2H    =  230,
    CV_REG_EMM3H    =  231,
    CV_REG_EMM4H    =  232,
    CV_REG_EMM5H    =  233,
    CV_REG_EMM6H    =  234,
    CV_REG_EMM7H    =  235,

    // do not change the order of these regs, first one must be even too
    CV_REG_MM00     =  236,
    CV_REG_MM01     =  237,
    CV_REG_MM10     =  238,
    CV_REG_MM11     =  239,
    CV_REG_MM20     =  240,
    CV_REG_MM21     =  241,
    CV_REG_MM30     =  242,
    CV_REG_MM31     =  243,
    CV_REG_MM40     =  244,
    CV_REG_MM41     =  245,
    CV_REG_MM50     =  246,
    CV_REG_MM51     =  247,
    CV_REG_MM60     =  248,
    CV_REG_MM61     =  249,
    CV_REG_MM70     =  250,
    CV_REG_MM71     =  251,

    // registers for the 68K processors

    CV_R68_D0       =    0,
    CV_R68_D1       =    1,
    CV_R68_D2       =    2,
    CV_R68_D3       =    3,
    CV_R68_D4       =    4,
    CV_R68_D5       =    5,
    CV_R68_D6       =    6,
    CV_R68_D7       =    7,
    CV_R68_A0       =    8,
    CV_R68_A1       =    9,
    CV_R68_A2       =   10,
    CV_R68_A3       =   11,
    CV_R68_A4       =   12,
    CV_R68_A5       =   13,
    CV_R68_A6       =   14,
    CV_R68_A7       =   15,
    CV_R68_CCR      =   16,
    CV_R68_SR       =   17,
    CV_R68_USP      =   18,
    CV_R68_MSP      =   19,
    CV_R68_SFC      =   20,
    CV_R68_DFC      =   21,
    CV_R68_CACR     =   22,
    CV_R68_VBR      =   23,
    CV_R68_CAAR     =   24,
    CV_R68_ISP      =   25,
    CV_R68_PC       =   26,
    //reserved  27
    CV_R68_FPCR     =   28,
    CV_R68_FPSR     =   29,
    CV_R68_FPIAR    =   30,
    //reserved  31
    CV_R68_FP0      =   32,
    CV_R68_FP1      =   33,
    CV_R68_FP2      =   34,
    CV_R68_FP3      =   35,
    CV_R68_FP4      =   36,
    CV_R68_FP5      =   37,
    CV_R68_FP6      =   38,
    CV_R68_FP7      =   39,
    //reserved  40
    CV_R68_MMUSR030 =   41,
    CV_R68_MMUSR    =   42,
    CV_R68_URP      =   43,
    CV_R68_DTT0     =   44,
    CV_R68_DTT1     =   45,
    CV_R68_ITT0     =   46,
    CV_R68_ITT1     =   47,
    //reserved  50
    CV_R68_PSR      =   51,
    CV_R68_PCSR     =   52,
    CV_R68_VAL      =   53,
    CV_R68_CRP      =   54,
    CV_R68_SRP      =   55,
    CV_R68_DRP      =   56,
    CV_R68_TC       =   57,
    CV_R68_AC       =   58,
    CV_R68_SCC      =   59,
    CV_R68_CAL      =   60,
    CV_R68_TT0      =   61,
    CV_R68_TT1      =   62,
    //reserved  63
    CV_R68_BAD0     =   64,
    CV_R68_BAD1     =   65,
    CV_R68_BAD2     =   66,
    CV_R68_BAD3     =   67,
    CV_R68_BAD4     =   68,
    CV_R68_BAD5     =   69,
    CV_R68_BAD6     =   70,
    CV_R68_BAD7     =   71,
    CV_R68_BAC0     =   72,
    CV_R68_BAC1     =   73,
    CV_R68_BAC2     =   74,
    CV_R68_BAC3     =   75,
    CV_R68_BAC4     =   76,
    CV_R68_BAC5     =   77,
    CV_R68_BAC6     =   78,
    CV_R68_BAC7     =   79,

     // Register set for the MIPS 4000

    CV_M4_NOREG     =   CV_REG_NONE,

    CV_M4_IntZERO   =   10,      /* CPU REGISTER */
    CV_M4_IntAT     =   11,
    CV_M4_IntV0     =   12,
    CV_M4_IntV1     =   13,
    CV_M4_IntA0     =   14,
    CV_M4_IntA1     =   15,
    CV_M4_IntA2     =   16,
    CV_M4_IntA3     =   17,
    CV_M4_IntT0     =   18,
    CV_M4_IntT1     =   19,
    CV_M4_IntT2     =   20,
    CV_M4_IntT3     =   21,
    CV_M4_IntT4     =   22,
    CV_M4_IntT5     =   23,
    CV_M4_IntT6     =   24,
    CV_M4_IntT7     =   25,
    CV_M4_IntS0     =   26,
    CV_M4_IntS1     =   27,
    CV_M4_IntS2     =   28,
    CV_M4_IntS3     =   29,
    CV_M4_IntS4     =   30,
    CV_M4_IntS5     =   31,
    CV_M4_IntS6     =   32,
    CV_M4_IntS7     =   33,
    CV_M4_IntT8     =   34,
    CV_M4_IntT9     =   35,
    CV_M4_IntKT0    =   36,
    CV_M4_IntKT1    =   37,
    CV_M4_IntGP     =   38,
    CV_M4_IntSP     =   39,
    CV_M4_IntS8     =   40,
    CV_M4_IntRA     =   41,
    CV_M4_IntLO     =   42,
    CV_M4_IntHI     =   43,

    CV_M4_Fir       =   50,
    CV_M4_Psr       =   51,

    CV_M4_FltF0     =   60,      /* Floating point registers */
    CV_M4_FltF1     =   61,
    CV_M4_FltF2     =   62,
    CV_M4_FltF3     =   63,
    CV_M4_FltF4     =   64,
    CV_M4_FltF5     =   65,
    CV_M4_FltF6     =   66,
    CV_M4_FltF7     =   67,
    CV_M4_FltF8     =   68,
    CV_M4_FltF9     =   69,
    CV_M4_FltF10    =   70,
    CV_M4_FltF11    =   71,
    CV_M4_FltF12    =   72,
    CV_M4_FltF13    =   73,
    CV_M4_FltF14    =   74,
    CV_M4_FltF15    =   75,
    CV_M4_FltF16    =   76,
    CV_M4_FltF17    =   77,
    CV_M4_FltF18    =   78,
    CV_M4_FltF19    =   79,
    CV_M4_FltF20    =   80,
    CV_M4_FltF21    =   81,
    CV_M4_FltF22    =   82,
    CV_M4_FltF23    =   83,
    CV_M4_FltF24    =   84,
    CV_M4_FltF25    =   85,
    CV_M4_FltF26    =   86,
    CV_M4_FltF27    =   87,
    CV_M4_FltF28    =   88,
    CV_M4_FltF29    =   89,
    CV_M4_FltF30    =   90,
    CV_M4_FltF31    =   91,
    CV_M4_FltFsr    =   92,


    // Register set for the ALPHA AXP

    CV_ALPHA_NOREG  = CV_REG_NONE,

    CV_ALPHA_FltF0  =   10,   // Floating point registers
    CV_ALPHA_FltF1  =   11,
    CV_ALPHA_FltF2  =   12,
    CV_ALPHA_FltF3  =   13,
    CV_ALPHA_FltF4  =   14,
    CV_ALPHA_FltF5  =   15,
    CV_ALPHA_FltF6  =   16,
    CV_ALPHA_FltF7  =   17,
    CV_ALPHA_FltF8  =   18,
    CV_ALPHA_FltF9  =   19,
    CV_ALPHA_FltF10 =   20,
    CV_ALPHA_FltF11 =   21,
    CV_ALPHA_FltF12 =   22,
    CV_ALPHA_FltF13 =   23,
    CV_ALPHA_FltF14 =   24,
    CV_ALPHA_FltF15 =   25,
    CV_ALPHA_FltF16 =   26,
    CV_ALPHA_FltF17 =   27,
    CV_ALPHA_FltF18 =   28,
    CV_ALPHA_FltF19 =   29,
    CV_ALPHA_FltF20 =   30,
    CV_ALPHA_FltF21 =   31,
    CV_ALPHA_FltF22 =   32,
    CV_ALPHA_FltF23 =   33,
    CV_ALPHA_FltF24 =   34,
    CV_ALPHA_FltF25 =   35,
    CV_ALPHA_FltF26 =   36,
    CV_ALPHA_FltF27 =   37,
    CV_ALPHA_FltF28 =   38,
    CV_ALPHA_FltF29 =   39,
    CV_ALPHA_FltF30 =   40,
    CV_ALPHA_FltF31 =   41,

    CV_ALPHA_IntV0  =   42,   // Integer registers
    CV_ALPHA_IntT0  =   43,
    CV_ALPHA_IntT1  =   44,
    CV_ALPHA_IntT2  =   45,
    CV_ALPHA_IntT3  =   46,
    CV_ALPHA_IntT4  =   47,
    CV_ALPHA_IntT5  =   48,
    CV_ALPHA_IntT6  =   49,
    CV_ALPHA_IntT7  =   50,
    CV_ALPHA_IntS0  =   51,
    CV_ALPHA_IntS1  =   52,
    CV_ALPHA_IntS2  =   53,
    CV_ALPHA_IntS3  =   54,
    CV_ALPHA_IntS4  =   55,
    CV_ALPHA_IntS5  =   56,
    CV_ALPHA_IntFP  =   57,
    CV_ALPHA_IntA0  =   58,
    CV_ALPHA_IntA1  =   59,
    CV_ALPHA_IntA2  =   60,
    CV_ALPHA_IntA3  =   61,
    CV_ALPHA_IntA4  =   62,
    CV_ALPHA_IntA5  =   63,
    CV_ALPHA_IntT8  =   64,
    CV_ALPHA_IntT9  =   65,
    CV_ALPHA_IntT10 =   66,
    CV_ALPHA_IntT11 =   67,
    CV_ALPHA_IntRA  =   68,
    CV_ALPHA_IntT12 =   69,
    CV_ALPHA_IntAT  =   70,
    CV_ALPHA_IntGP  =   71,
    CV_ALPHA_IntSP  =   72,
    CV_ALPHA_IntZERO =  73,


    CV_ALPHA_Fpcr   =   74,   // Control registers
    CV_ALPHA_Fir    =   75,
    CV_ALPHA_Psr    =   76,
    CV_ALPHA_FltFsr =   77,
    CV_ALPHA_SoftFpcr =   78,

    // Register Set for Motorola/IBM PowerPC

    /*
    ** PowerPC General Registers ( User Level )
    */
    CV_PPC_GPR0     =  1,
    CV_PPC_GPR1     =  2,
    CV_PPC_GPR2     =  3,
    CV_PPC_GPR3     =  4,
    CV_PPC_GPR4     =  5,
    CV_PPC_GPR5     =  6,
    CV_PPC_GPR6     =  7,
    CV_PPC_GPR7     =  8,
    CV_PPC_GPR8     =  9,
    CV_PPC_GPR9     = 10,
    CV_PPC_GPR10    = 11,
    CV_PPC_GPR11    = 12,
    CV_PPC_GPR12    = 13,
    CV_PPC_GPR13    = 14,
    CV_PPC_GPR14    = 15,
    CV_PPC_GPR15    = 16,
    CV_PPC_GPR16    = 17,
    CV_PPC_GPR17    = 18,
    CV_PPC_GPR18    = 19,
    CV_PPC_GPR19    = 20,
    CV_PPC_GPR20    = 21,
    CV_PPC_GPR21    = 22,
    CV_PPC_GPR22    = 23,
    CV_PPC_GPR23    = 24,
    CV_PPC_GPR24    = 25,
    CV_PPC_GPR25    = 26,
    CV_PPC_GPR26    = 27,
    CV_PPC_GPR27    = 28,
    CV_PPC_GPR28    = 29,
    CV_PPC_GPR29    = 30,
    CV_PPC_GPR30    = 31,
    CV_PPC_GPR31    = 32,

    /*
    ** PowerPC Condition Register ( User Level )
    */
    CV_PPC_CR       = 33,
    CV_PPC_CR0      = 34,
    CV_PPC_CR1      = 35,
    CV_PPC_CR2      = 36,
    CV_PPC_CR3      = 37,
    CV_PPC_CR4      = 38,
    CV_PPC_CR5      = 39,
    CV_PPC_CR6      = 40,
    CV_PPC_CR7      = 41,

    /*
    ** PowerPC Floating Point Registers ( User Level )
    */
    CV_PPC_FPR0     = 42,
    CV_PPC_FPR1     = 43,
    CV_PPC_FPR2     = 44,
    CV_PPC_FPR3     = 45,
    CV_PPC_FPR4     = 46,
    CV_PPC_FPR5     = 47,
    CV_PPC_FPR6     = 48,
    CV_PPC_FPR7     = 49,
    CV_PPC_FPR8     = 50,
    CV_PPC_FPR9     = 51,
    CV_PPC_FPR10    = 52,
    CV_PPC_FPR11    = 53,
    CV_PPC_FPR12    = 54,
    CV_PPC_FPR13    = 55,
    CV_PPC_FPR14    = 56,
    CV_PPC_FPR15    = 57,
    CV_PPC_FPR16    = 58,
    CV_PPC_FPR17    = 59,
    CV_PPC_FPR18    = 60,
    CV_PPC_FPR19    = 61,
    CV_PPC_FPR20    = 62,
    CV_PPC_FPR21    = 63,
    CV_PPC_FPR22    = 64,
    CV_PPC_FPR23    = 65,
    CV_PPC_FPR24    = 66,
    CV_PPC_FPR25    = 67,
    CV_PPC_FPR26    = 68,
    CV_PPC_FPR27    = 69,
    CV_PPC_FPR28    = 70,
    CV_PPC_FPR29    = 71,
    CV_PPC_FPR30    = 72,
    CV_PPC_FPR31    = 73,

    /*
    ** PowerPC Floating Point Status and Control Register ( User Level )
    */
    CV_PPC_FPSCR    = 74,

    /*
    ** PowerPC Machine State Register ( Supervisor Level )
    */
    CV_PPC_MSR      = 75,

    /*
    ** PowerPC Segment Registers ( Supervisor Level )
    */
    CV_PPC_SR0      = 76,
    CV_PPC_SR1      = 77,
    CV_PPC_SR2      = 78,
    CV_PPC_SR3      = 79,
    CV_PPC_SR4      = 80,
    CV_PPC_SR5      = 81,
    CV_PPC_SR6      = 82,
    CV_PPC_SR7      = 83,
    CV_PPC_SR8      = 84,
    CV_PPC_SR9      = 85,
    CV_PPC_SR10     = 86,
    CV_PPC_SR11     = 87,
    CV_PPC_SR12     = 88,
    CV_PPC_SR13     = 89,
    CV_PPC_SR14     = 90,
    CV_PPC_SR15     = 91,

    /*
    ** For all of the special purpose registers add 100 to the SPR# that the
    ** Motorola/IBM documentation gives with the exception of any imaginary
    ** registers.
    */

    /*
    ** PowerPC Special Purpose Registers ( User Level )
    */
    CV_PPC_PC       = 99,     // PC (imaginary register)

    CV_PPC_MQ       = 100,    // MPC601
    CV_PPC_XER      = 101,
    CV_PPC_RTCU     = 104,    // MPC601
    CV_PPC_RTCL     = 105,    // MPC601
    CV_PPC_LR       = 108,
    CV_PPC_CTR      = 109,

    CV_PPC_COMPARE  = 110,    // part of XER (internal to the debugger only)
    CV_PPC_COUNT    = 111,    // part of XER (internal to the debugger only)

    /*
    ** PowerPC Special Purpose Registers ( Supervisor Level )
    */
    CV_PPC_DSISR    = 118,
    CV_PPC_DAR      = 119,
    CV_PPC_DEC      = 122,
    CV_PPC_SDR1     = 125,
    CV_PPC_SRR0     = 126,
    CV_PPC_SRR1     = 127,
    CV_PPC_SPRG0    = 372,
    CV_PPC_SPRG1    = 373,
    CV_PPC_SPRG2    = 374,
    CV_PPC_SPRG3    = 375,
    CV_PPC_ASR      = 280,    // 64-bit implementations only
    CV_PPC_EAR      = 382,
    CV_PPC_PVR      = 287,
    CV_PPC_BAT0U    = 628,
    CV_PPC_BAT0L    = 629,
    CV_PPC_BAT1U    = 630,
    CV_PPC_BAT1L    = 631,
    CV_PPC_BAT2U    = 632,
    CV_PPC_BAT2L    = 633,
    CV_PPC_BAT3U    = 634,
    CV_PPC_BAT3L    = 635,
    CV_PPC_DBAT0U   = 636,
    CV_PPC_DBAT0L   = 637,
    CV_PPC_DBAT1U   = 638,
    CV_PPC_DBAT1L   = 639,
    CV_PPC_DBAT2U   = 640,
    CV_PPC_DBAT2L   = 641,
    CV_PPC_DBAT3U   = 642,
    CV_PPC_DBAT3L   = 643,

    /*
    ** PowerPC Special Purpose Registers Implementation Dependent ( Supervisor Level )
    */

    /*
    ** Doesn't appear that IBM/Motorola has finished defining these.
    */

    CV_PPC_PMR0     = 1044,   // MPC620,
    CV_PPC_PMR1     = 1045,   // MPC620,
    CV_PPC_PMR2     = 1046,   // MPC620,
    CV_PPC_PMR3     = 1047,   // MPC620,
    CV_PPC_PMR4     = 1048,   // MPC620,
    CV_PPC_PMR5     = 1049,   // MPC620,
    CV_PPC_PMR6     = 1050,   // MPC620,
    CV_PPC_PMR7     = 1051,   // MPC620,
    CV_PPC_PMR8     = 1052,   // MPC620,
    CV_PPC_PMR9     = 1053,   // MPC620,
    CV_PPC_PMR10    = 1054,   // MPC620,
    CV_PPC_PMR11    = 1055,   // MPC620,
    CV_PPC_PMR12    = 1056,   // MPC620,
    CV_PPC_PMR13    = 1057,   // MPC620,
    CV_PPC_PMR14    = 1058,   // MPC620,
    CV_PPC_PMR15    = 1059,   // MPC620,

    CV_PPC_DMISS    = 1076,   // MPC603
    CV_PPC_DCMP     = 1077,   // MPC603
    CV_PPC_HASH1    = 1078,   // MPC603
    CV_PPC_HASH2    = 1079,   // MPC603
    CV_PPC_IMISS    = 1080,   // MPC603
    CV_PPC_ICMP     = 1081,   // MPC603
    CV_PPC_RPA      = 1082,   // MPC603

    CV_PPC_HID0     = 1108,   // MPC601, MPC603, MPC620
    CV_PPC_HID1     = 1109,   // MPC601
    CV_PPC_HID2     = 1110,   // MPC601, MPC603, MPC620 ( IABR )
    CV_PPC_HID3     = 1111,   // Not Defined
    CV_PPC_HID4     = 1112,   // Not Defined
    CV_PPC_HID5     = 1113,   // MPC601, MPC604, MPC620 ( DABR )
    CV_PPC_HID6     = 1114,   // Not Defined
    CV_PPC_HID7     = 1115,   // Not Defined
    CV_PPC_HID8     = 1116,   // MPC620 ( BUSCSR )
    CV_PPC_HID9     = 1117,   // MPC620 ( L2CSR )
    CV_PPC_HID10    = 1118,   // Not Defined
    CV_PPC_HID11    = 1119,   // Not Defined
    CV_PPC_HID12    = 1120,   // Not Defined
    CV_PPC_HID13    = 1121,   // MPC604 ( HCR )
    CV_PPC_HID14    = 1122,   // Not Defined
    CV_PPC_HID15    = 1123,   // MPC601, MPC604, MPC620 ( PIR )

    //
    // JAVA VM registers
    //

    CV_JAVA_PC      = 1,

    //
    // Register set for the Hitachi SH3
    //

    CV_SH3_NOREG    =   CV_REG_NONE,

    CV_SH3_IntR0    =   10,   // CPU REGISTER
    CV_SH3_IntR1    =   11,
    CV_SH3_IntR2    =   12,
    CV_SH3_IntR3    =   13,
    CV_SH3_IntR4    =   14,
    CV_SH3_IntR5    =   15,
    CV_SH3_IntR6    =   16,
    CV_SH3_IntR7    =   17,
    CV_SH3_IntR8    =   18,
    CV_SH3_IntR9    =   19,
    CV_SH3_IntR10   =   20,
    CV_SH3_IntR11   =   21,
    CV_SH3_IntR12   =   22,
    CV_SH3_IntR13   =   23,
    CV_SH3_IntFp    =   24,
    CV_SH3_IntSp    =   25,
    CV_SH3_Gbr      =   38,
    CV_SH3_Pr       =   39,
    CV_SH3_Mach     =   40,
    CV_SH3_Macl     =   41,

    CV_SH3_Pc       =   50,
    CV_SH3_Sr       =   51,

    CV_SH3_BarA     =   60,
    CV_SH3_BasrA    =   61,
    CV_SH3_BamrA    =   62,
    CV_SH3_BbrA     =   63,
    CV_SH3_BarB     =   64,
    CV_SH3_BasrB    =   65,
    CV_SH3_BamrB    =   66,
    CV_SH3_BbrB     =   67,
    CV_SH3_BdrB     =   68,
    CV_SH3_BdmrB    =   69,
    CV_SH3_Brcr     =   70,

    //
    // Additional registers for Hitachi SH processors
    //

    CV_SH_Fpscr    =   75,    // floating point status/control register
    CV_SH_Fpul     =   76,    // floating point communication register

    CV_SH_FpR0     =   80,    // Floating point registers
    CV_SH_FpR1     =   81,
    CV_SH_FpR2     =   82,
    CV_SH_FpR3     =   83,
    CV_SH_FpR4     =   84,
    CV_SH_FpR5     =   85,
    CV_SH_FpR6     =   86,
    CV_SH_FpR7     =   87,
    CV_SH_FpR8     =   88,
    CV_SH_FpR9     =   89,
    CV_SH_FpR10    =   90,
    CV_SH_FpR11    =   91,
    CV_SH_FpR12    =   92,
    CV_SH_FpR13    =   93,
    CV_SH_FpR14    =   94,
    CV_SH_FpR15    =   95,

    CV_SH_XFpR0    =   96,
    CV_SH_XFpR1    =   97,
    CV_SH_XFpR2    =   98,
    CV_SH_XFpR3    =   99,
    CV_SH_XFpR4    =  100,
    CV_SH_XFpR5    =  101,
    CV_SH_XFpR6    =  102,
    CV_SH_XFpR7    =  103,
    CV_SH_XFpR8    =  104,
    CV_SH_XFpR9    =  105,
    CV_SH_XFpR10   =  106,
    CV_SH_XFpR11   =  107,
    CV_SH_XFpR12   =  108,
    CV_SH_XFpR13   =  109,
    CV_SH_XFpR14   =  110,
    CV_SH_XFpR15   =  111,

    //
    // Register set for the ARM processor.
    //

    CV_ARM_NOREG    =   CV_REG_NONE,

    CV_ARM_R0       =   10,
    CV_ARM_R1       =   11,
    CV_ARM_R2       =   12,
    CV_ARM_R3       =   13,
    CV_ARM_R4       =   14,
    CV_ARM_R5       =   15,
    CV_ARM_R6       =   16,
    CV_ARM_R7       =   17,
    CV_ARM_R8       =   18,
    CV_ARM_R9       =   19,
    CV_ARM_R10      =   20,
    CV_ARM_R11      =   21, // Frame pointer, if allocated
    CV_ARM_R12      =   22,
    CV_ARM_SP       =   23, // Stack pointer
    CV_ARM_LR       =   24, // Link Register
    CV_ARM_PC       =   25, // Program counter
    CV_ARM_CPSR     =   26, // Current program status register

    //
    // Register set for Intel IA64
    //

    CV_IA64_NOREG   =   CV_REG_NONE,

    // Branch Registers

    CV_IA64_Br0     =   512,
    CV_IA64_Br1     =   513,
    CV_IA64_Br2     =   514,
    CV_IA64_Br3     =   515,
    CV_IA64_Br4     =   516,
    CV_IA64_Br5     =   517,
    CV_IA64_Br6     =   518,
    CV_IA64_Br7     =   519,

    // Predicate Registers

    CV_IA64_P0    =   704,
    CV_IA64_P1    =   705,
    CV_IA64_P2    =   706,
    CV_IA64_P3    =   707,
    CV_IA64_P4    =   708,
    CV_IA64_P5    =   709,
    CV_IA64_P6    =   710,
    CV_IA64_P7    =   711,
    CV_IA64_P8    =   712,
    CV_IA64_P9    =   713,
    CV_IA64_P10   =   714,
    CV_IA64_P11   =   715,
    CV_IA64_P12   =   716,
    CV_IA64_P13   =   717,
    CV_IA64_P14   =   718,
    CV_IA64_P15   =   719,
    CV_IA64_P16   =   720,
    CV_IA64_P17   =   721,
    CV_IA64_P18   =   722,
    CV_IA64_P19   =   723,
    CV_IA64_P20   =   724,
    CV_IA64_P21   =   725,
    CV_IA64_P22   =   726,
    CV_IA64_P23   =   727,
    CV_IA64_P24   =   728,
    CV_IA64_P25   =   729,
    CV_IA64_P26   =   730,
    CV_IA64_P27   =   731,
    CV_IA64_P28   =   732,
    CV_IA64_P29   =   733,
    CV_IA64_P30   =   734,
    CV_IA64_P31   =   735,
    CV_IA64_P32   =   736,
    CV_IA64_P33   =   737,
    CV_IA64_P34   =   738,
    CV_IA64_P35   =   739,
    CV_IA64_P36   =   740,
    CV_IA64_P37   =   741,
    CV_IA64_P38   =   742,
    CV_IA64_P39   =   743,
    CV_IA64_P40   =   744,
    CV_IA64_P41   =   745,
    CV_IA64_P42   =   746,
    CV_IA64_P43   =   747,
    CV_IA64_P44   =   748,
    CV_IA64_P45   =   749,
    CV_IA64_P46   =   750,
    CV_IA64_P47   =   751,
    CV_IA64_P48   =   752,
    CV_IA64_P49   =   753,
    CV_IA64_P50   =   754,
    CV_IA64_P51   =   755,
    CV_IA64_P52   =   756,
    CV_IA64_P53   =   757,
    CV_IA64_P54   =   758,
    CV_IA64_P55   =   759,
    CV_IA64_P56   =   760,
    CV_IA64_P57   =   761,
    CV_IA64_P58   =   762,
    CV_IA64_P59   =   763,
    CV_IA64_P60   =   764,
    CV_IA64_P61   =   765,
    CV_IA64_P62   =   766,
    CV_IA64_P63   =   767,

    CV_IA64_Preds   =   768,

    // Banked General Registers

    CV_IA64_IntH0   =   832,
    CV_IA64_IntH1   =   833,
    CV_IA64_IntH2   =   834,
    CV_IA64_IntH3   =   835,
    CV_IA64_IntH4   =   836,
    CV_IA64_IntH5   =   837,
    CV_IA64_IntH6   =   838,
    CV_IA64_IntH7   =   839,
    CV_IA64_IntH8   =   840,
    CV_IA64_IntH9   =   841,
    CV_IA64_IntH10  =   842,
    CV_IA64_IntH11  =   843,
    CV_IA64_IntH12  =   844,
    CV_IA64_IntH13  =   845,
    CV_IA64_IntH14  =   846,
    CV_IA64_IntH15  =   847,

    // Special Registers

    CV_IA64_Ip      =   1016,
    CV_IA64_Umask   =   1017,
    CV_IA64_Cfm     =   1018,
    CV_IA64_Psr     =   1019,

    // Banked General Registers

    CV_IA64_Nats    =   1020,
    CV_IA64_Nats2   =   1021,
    CV_IA64_Nats3   =   1022,

    // General-Purpose Registers

    // Integer registers
    CV_IA64_IntR0   =   1024,
    CV_IA64_IntR1   =   1025,
    CV_IA64_IntR2   =   1026,
    CV_IA64_IntR3   =   1027,
    CV_IA64_IntR4   =   1028,
    CV_IA64_IntR5   =   1029,
    CV_IA64_IntR6   =   1030,
    CV_IA64_IntR7   =   1031,
    CV_IA64_IntR8   =   1032,
    CV_IA64_IntR9   =   1033,
    CV_IA64_IntR10  =   1034,
    CV_IA64_IntR11  =   1035,
    CV_IA64_IntR12  =   1036,
    CV_IA64_IntR13  =   1037,
    CV_IA64_IntR14  =   1038,
    CV_IA64_IntR15  =   1039,
    CV_IA64_IntR16  =   1040,
    CV_IA64_IntR17  =   1041,
    CV_IA64_IntR18  =   1042,
    CV_IA64_IntR19  =   1043,
    CV_IA64_IntR20  =   1044,
    CV_IA64_IntR21  =   1045,
    CV_IA64_IntR22  =   1046,
    CV_IA64_IntR23  =   1047,
    CV_IA64_IntR24  =   1048,
    CV_IA64_IntR25  =   1049,
    CV_IA64_IntR26  =   1050,
    CV_IA64_IntR27  =   1051,
    CV_IA64_IntR28  =   1052,
    CV_IA64_IntR29  =   1053,
    CV_IA64_IntR30  =   1054,
    CV_IA64_IntR31  =   1055,

    // Register Stack
    CV_IA64_IntR32  =   1056,
    CV_IA64_IntR33  =   1057,
    CV_IA64_IntR34  =   1058,
    CV_IA64_IntR35  =   1059,
    CV_IA64_IntR36  =   1060,
    CV_IA64_IntR37  =   1061,
    CV_IA64_IntR38  =   1062,
    CV_IA64_IntR39  =   1063,
    CV_IA64_IntR40  =   1064,
    CV_IA64_IntR41  =   1065,
    CV_IA64_IntR42  =   1066,
    CV_IA64_IntR43  =   1067,
    CV_IA64_IntR44  =   1068,
    CV_IA64_IntR45  =   1069,
    CV_IA64_IntR46  =   1070,
    CV_IA64_IntR47  =   1071,
    CV_IA64_IntR48  =   1072,
    CV_IA64_IntR49  =   1073,
    CV_IA64_IntR50  =   1074,
    CV_IA64_IntR51  =   1075,
    CV_IA64_IntR52  =   1076,
    CV_IA64_IntR53  =   1077,
    CV_IA64_IntR54  =   1078,
    CV_IA64_IntR55  =   1079,
    CV_IA64_IntR56  =   1080,
    CV_IA64_IntR57  =   1081,
    CV_IA64_IntR58  =   1082,
    CV_IA64_IntR59  =   1083,
    CV_IA64_IntR60  =   1084,
    CV_IA64_IntR61  =   1085,
    CV_IA64_IntR62  =   1086,
    CV_IA64_IntR63  =   1087,
    CV_IA64_IntR64  =   1088,
    CV_IA64_IntR65  =   1089,
    CV_IA64_IntR66  =   1090,
    CV_IA64_IntR67  =   1091,
    CV_IA64_IntR68  =   1092,
    CV_IA64_IntR69  =   1093,
    CV_IA64_IntR70  =   1094,
    CV_IA64_IntR71  =   1095,
    CV_IA64_IntR72  =   1096,
    CV_IA64_IntR73  =   1097,
    CV_IA64_IntR74  =   1098,
    CV_IA64_IntR75  =   1099,
    CV_IA64_IntR76  =   1100,
    CV_IA64_IntR77  =   1101,
    CV_IA64_IntR78  =   1102,
    CV_IA64_IntR79  =   1103,
    CV_IA64_IntR80  =   1104,
    CV_IA64_IntR81  =   1105,
    CV_IA64_IntR82  =   1106,
    CV_IA64_IntR83  =   1107,
    CV_IA64_IntR84  =   1108,
    CV_IA64_IntR85  =   1109,
    CV_IA64_IntR86  =   1110,
    CV_IA64_IntR87  =   1111,
    CV_IA64_IntR88  =   1112,
    CV_IA64_IntR89  =   1113,
    CV_IA64_IntR90  =   1114,
    CV_IA64_IntR91  =   1115,
    CV_IA64_IntR92  =   1116,
    CV_IA64_IntR93  =   1117,
    CV_IA64_IntR94  =   1118,
    CV_IA64_IntR95  =   1119,
    CV_IA64_IntR96  =   1120,
    CV_IA64_IntR97  =   1121,
    CV_IA64_IntR98  =   1122,
    CV_IA64_IntR99  =   1123,
    CV_IA64_IntR100 =   1124,
    CV_IA64_IntR101 =   1125,
    CV_IA64_IntR102 =   1126,
    CV_IA64_IntR103 =   1127,
    CV_IA64_IntR104 =   1128,
    CV_IA64_IntR105 =   1129,
    CV_IA64_IntR106 =   1130,
    CV_IA64_IntR107 =   1131,
    CV_IA64_IntR108 =   1132,
    CV_IA64_IntR109 =   1133,
    CV_IA64_IntR110 =   1134,
    CV_IA64_IntR111 =   1135,
    CV_IA64_IntR112 =   1136,
    CV_IA64_IntR113 =   1137,
    CV_IA64_IntR114 =   1138,
    CV_IA64_IntR115 =   1139,
    CV_IA64_IntR116 =   1140,
    CV_IA64_IntR117 =   1141,
    CV_IA64_IntR118 =   1142,
    CV_IA64_IntR119 =   1143,
    CV_IA64_IntR120 =   1144,
    CV_IA64_IntR121 =   1145,
    CV_IA64_IntR122 =   1146,
    CV_IA64_IntR123 =   1147,
    CV_IA64_IntR124 =   1148,
    CV_IA64_IntR125 =   1149,
    CV_IA64_IntR126 =   1150,
    CV_IA64_IntR127 =   1151,

    // Floating-Point Registers

    // Low Floating Point Registers
    CV_IA64_FltF0   =   2048,
    CV_IA64_FltF1   =   2049,
    CV_IA64_FltF2   =   2050,
    CV_IA64_FltF3   =   2051,
    CV_IA64_FltF4   =   2052,
    CV_IA64_FltF5   =   2053,
    CV_IA64_FltF6   =   2054,
    CV_IA64_FltF7   =   2055,
    CV_IA64_FltF8   =   2056,
    CV_IA64_FltF9   =   2057,
    CV_IA64_FltF10  =   2058,
    CV_IA64_FltF11  =   2059,
    CV_IA64_FltF12  =   2060,
    CV_IA64_FltF13  =   2061,
    CV_IA64_FltF14  =   2062,
    CV_IA64_FltF15  =   2063,
    CV_IA64_FltF16  =   2064,
    CV_IA64_FltF17  =   2065,
    CV_IA64_FltF18  =   2066,
    CV_IA64_FltF19  =   2067,
    CV_IA64_FltF20  =   2068,
    CV_IA64_FltF21  =   2069,
    CV_IA64_FltF22  =   2070,
    CV_IA64_FltF23  =   2071,
    CV_IA64_FltF24  =   2072,
    CV_IA64_FltF25  =   2073,
    CV_IA64_FltF26  =   2074,
    CV_IA64_FltF27  =   2075,
    CV_IA64_FltF28  =   2076,
    CV_IA64_FltF29  =   2077,
    CV_IA64_FltF30  =   2078,
    CV_IA64_FltF31  =   2079,

    // High Floating Point Registers
    CV_IA64_FltF32  =   2080,
    CV_IA64_FltF33  =   2081,
    CV_IA64_FltF34  =   2082,
    CV_IA64_FltF35  =   2083,
    CV_IA64_FltF36  =   2084,
    CV_IA64_FltF37  =   2085,
    CV_IA64_FltF38  =   2086,
    CV_IA64_FltF39  =   2087,
    CV_IA64_FltF40  =   2088,
    CV_IA64_FltF41  =   2089,
    CV_IA64_FltF42  =   2090,
    CV_IA64_FltF43  =   2091,
    CV_IA64_FltF44  =   2092,
    CV_IA64_FltF45  =   2093,
    CV_IA64_FltF46  =   2094,
    CV_IA64_FltF47  =   2095,
    CV_IA64_FltF48  =   2096,
    CV_IA64_FltF49  =   2097,
    CV_IA64_FltF50  =   2098,
    CV_IA64_FltF51  =   2099,
    CV_IA64_FltF52  =   2100,
    CV_IA64_FltF53  =   2101,
    CV_IA64_FltF54  =   2102,
    CV_IA64_FltF55  =   2103,
    CV_IA64_FltF56  =   2104,
    CV_IA64_FltF57  =   2105,
    CV_IA64_FltF58  =   2106,
    CV_IA64_FltF59  =   2107,
    CV_IA64_FltF60  =   2108,
    CV_IA64_FltF61  =   2109,
    CV_IA64_FltF62  =   2110,
    CV_IA64_FltF63  =   2111,
    CV_IA64_FltF64  =   2112,
    CV_IA64_FltF65  =   2113,
    CV_IA64_FltF66  =   2114,
    CV_IA64_FltF67  =   2115,
    CV_IA64_FltF68  =   2116,
    CV_IA64_FltF69  =   2117,
    CV_IA64_FltF70  =   2118,
    CV_IA64_FltF71  =   2119,
    CV_IA64_FltF72  =   2120,
    CV_IA64_FltF73  =   2121,
    CV_IA64_FltF74  =   2122,
    CV_IA64_FltF75  =   2123,
    CV_IA64_FltF76  =   2124,
    CV_IA64_FltF77  =   2125,
    CV_IA64_FltF78  =   2126,
    CV_IA64_FltF79  =   2127,
    CV_IA64_FltF80  =   2128,
    CV_IA64_FltF81  =   2129,
    CV_IA64_FltF82  =   2130,
    CV_IA64_FltF83  =   2131,
    CV_IA64_FltF84  =   2132,
    CV_IA64_FltF85  =   2133,
    CV_IA64_FltF86  =   2134,
    CV_IA64_FltF87  =   2135,
    CV_IA64_FltF88  =   2136,
    CV_IA64_FltF89  =   2137,
    CV_IA64_FltF90  =   2138,
    CV_IA64_FltF91  =   2139,
    CV_IA64_FltF92  =   2140,
    CV_IA64_FltF93  =   2141,
    CV_IA64_FltF94  =   2142,
    CV_IA64_FltF95  =   2143,
    CV_IA64_FltF96  =   2144,
    CV_IA64_FltF97  =   2145,
    CV_IA64_FltF98  =   2146,
    CV_IA64_FltF99  =   2147,
    CV_IA64_FltF100 =   2148,
    CV_IA64_FltF101 =   2149,
    CV_IA64_FltF102 =   2150,
    CV_IA64_FltF103 =   2151,
    CV_IA64_FltF104 =   2152,
    CV_IA64_FltF105 =   2153,
    CV_IA64_FltF106 =   2154,
    CV_IA64_FltF107 =   2155,
    CV_IA64_FltF108 =   2156,
    CV_IA64_FltF109 =   2157,
    CV_IA64_FltF110 =   2158,
    CV_IA64_FltF111 =   2159,
    CV_IA64_FltF112 =   2160,
    CV_IA64_FltF113 =   2161,
    CV_IA64_FltF114 =   2162,
    CV_IA64_FltF115 =   2163,
    CV_IA64_FltF116 =   2164,
    CV_IA64_FltF117 =   2165,
    CV_IA64_FltF118 =   2166,
    CV_IA64_FltF119 =   2167,
    CV_IA64_FltF120 =   2168,
    CV_IA64_FltF121 =   2169,
    CV_IA64_FltF122 =   2170,
    CV_IA64_FltF123 =   2171,
    CV_IA64_FltF124 =   2172,
    CV_IA64_FltF125 =   2173,
    CV_IA64_FltF126 =   2174,
    CV_IA64_FltF127 =   2175,

    // Application Registers

    CV_IA64_ApKR0   =   3072,
    CV_IA64_ApKR1   =   3073,
    CV_IA64_ApKR2   =   3074,
    CV_IA64_ApKR3   =   3075,
    CV_IA64_ApKR4   =   3076,
    CV_IA64_ApKR5   =   3077,
    CV_IA64_ApKR6   =   3078,
    CV_IA64_ApKR7   =   3079,
    CV_IA64_AR8     =   3080,
    CV_IA64_AR9     =   3081,
    CV_IA64_AR10    =   3082,
    CV_IA64_AR11    =   3083,
    CV_IA64_AR12    =   3084,
    CV_IA64_AR13    =   3085,
    CV_IA64_AR14    =   3086,
    CV_IA64_AR15    =   3087,
    CV_IA64_RsRSC   =   3088,
    CV_IA64_RsBSP   =   3089,
    CV_IA64_RsBSPSTORE  =   3090,
    CV_IA64_RsRNAT  =   3091,
    CV_IA64_AR20    =   3092,
    CV_IA64_StFCR   =   3093,
    CV_IA64_AR22    =   3094,
    CV_IA64_AR23    =   3095,
    CV_IA64_EFLAG   =   3096,
    CV_IA64_CSD     =   3097,
    CV_IA64_SSD     =   3098,
    CV_IA64_CFLG    =   3099,
    CV_IA64_StFSR   =   3100,
    CV_IA64_StFIR   =   3101,
    CV_IA64_StFDR   =   3102,
    CV_IA64_AR31    =   3103,
    CV_IA64_ApCCV   =   3104,
    CV_IA64_AR33    =   3105,
    CV_IA64_AR34    =   3106,
    CV_IA64_AR35    =   3107,
    CV_IA64_ApUNAT  =   3108,
    CV_IA64_AR37    =   3109,
    CV_IA64_AR38    =   3110,
    CV_IA64_AR39    =   3111,
    CV_IA64_StFPSR  =   3112,
    CV_IA64_AR41    =   3113,
    CV_IA64_AR42    =   3114,
    CV_IA64_AR43    =   3115,
    CV_IA64_ApITC   =   3116,
    CV_IA64_AR45    =   3117,
    CV_IA64_AR46    =   3118,
    CV_IA64_AR47    =   3119,
    CV_IA64_AR48    =   3120,
    CV_IA64_AR49    =   3121,
    CV_IA64_AR50    =   3122,
    CV_IA64_AR51    =   3123,
    CV_IA64_AR52    =   3124,
    CV_IA64_AR53    =   3125,
    CV_IA64_AR54    =   3126,
    CV_IA64_AR55    =   3127,
    CV_IA64_AR56    =   3128,
    CV_IA64_AR57    =   3129,
    CV_IA64_AR58    =   3130,
    CV_IA64_AR59    =   3131,
    CV_IA64_AR60    =   3132,
    CV_IA64_AR61    =   3133,
    CV_IA64_AR62    =   3134,
    CV_IA64_AR63    =   3135,
    CV_IA64_RsPFS   =   3136,
    CV_IA64_ApLC    =   3137,
    CV_IA64_ApEC    =   3138,
    CV_IA64_AR67    =   3139,
    CV_IA64_AR68    =   3140,
    CV_IA64_AR69    =   3141,
    CV_IA64_AR70    =   3142,
    CV_IA64_AR71    =   3143,
    CV_IA64_AR72    =   3144,
    CV_IA64_AR73    =   3145,
    CV_IA64_AR74    =   3146,
    CV_IA64_AR75    =   3147,
    CV_IA64_AR76    =   3148,
    CV_IA64_AR77    =   3149,
    CV_IA64_AR78    =   3150,
    CV_IA64_AR79    =   3151,
    CV_IA64_AR80    =   3152,
    CV_IA64_AR81    =   3153,
    CV_IA64_AR82    =   3154,
    CV_IA64_AR83    =   3155,
    CV_IA64_AR84    =   3156,
    CV_IA64_AR85    =   3157,
    CV_IA64_AR86    =   3158,
    CV_IA64_AR87    =   3159,
    CV_IA64_AR88    =   3160,
    CV_IA64_AR89    =   3161,
    CV_IA64_AR90    =   3162,
    CV_IA64_AR91    =   3163,
    CV_IA64_AR92    =   3164,
    CV_IA64_AR93    =   3165,
    CV_IA64_AR94    =   3166,
    CV_IA64_AR95    =   3167,
    CV_IA64_AR96    =   3168,
    CV_IA64_AR97    =   3169,
    CV_IA64_AR98    =   3170,
    CV_IA64_AR99    =   3171,
    CV_IA64_AR100   =   3172,
    CV_IA64_AR101   =   3173,
    CV_IA64_AR102   =   3174,
    CV_IA64_AR103   =   3175,
    CV_IA64_AR104   =   3176,
    CV_IA64_AR105   =   3177,
    CV_IA64_AR106   =   3178,
    CV_IA64_AR107   =   3179,
    CV_IA64_AR108   =   3180,
    CV_IA64_AR109   =   3181,
    CV_IA64_AR110   =   3182,
    CV_IA64_AR111   =   3183,
    CV_IA64_AR112   =   3184,
    CV_IA64_AR113   =   3185,
    CV_IA64_AR114   =   3186,
    CV_IA64_AR115   =   3187,
    CV_IA64_AR116   =   3188,
    CV_IA64_AR117   =   3189,
    CV_IA64_AR118   =   3190,
    CV_IA64_AR119   =   3191,
    CV_IA64_AR120   =   3192,
    CV_IA64_AR121   =   3193,
    CV_IA64_AR122   =   3194,
    CV_IA64_AR123   =   3195,
    CV_IA64_AR124   =   3196,
    CV_IA64_AR125   =   3197,
    CV_IA64_AR126   =   3198,
    CV_IA64_AR127   =   3199,

    // CPUID Registers

    CV_IA64_CPUID0  =   3328,
    CV_IA64_CPUID1  =   3329,
    CV_IA64_CPUID2  =   3330,
    CV_IA64_CPUID3  =   3331,
    CV_IA64_CPUID4  =   3332,

    // Control Registers

    CV_IA64_ApDCR   =   4096,
    CV_IA64_ApITM   =   4097,
    CV_IA64_ApIVA   =   4098,
    CV_IA64_CR3     =   4099,
    CV_IA64_CR4     =   4100,
    CV_IA64_CR5     =   4101,
    CV_IA64_CR6     =   4102,
    CV_IA64_CR7     =   4103,
    CV_IA64_ApPTA   =   4104,
    CV_IA64_ApGPTA  =   4105,
    CV_IA64_CR10    =   4106,
    CV_IA64_CR11    =   4107,
    CV_IA64_CR12    =   4108,
    CV_IA64_CR13    =   4109,
    CV_IA64_CR14    =   4110,
    CV_IA64_CR15    =   4111,
    CV_IA64_StIPSR  =   4112,
    CV_IA64_StISR   =   4113,
    CV_IA64_CR18    =   4114,
    CV_IA64_StIIP   =   4115,
    CV_IA64_StIFA   =   4116,
    CV_IA64_StITIR  =   4117,
    CV_IA64_StIIPA  =   4118,
    CV_IA64_StIFS   =   4119,
    CV_IA64_StIIM   =   4120,
    CV_IA64_StIHA   =   4121,
    CV_IA64_CR26    =   4122,
    CV_IA64_CR27    =   4123,
    CV_IA64_CR28    =   4124,
    CV_IA64_CR29    =   4125,
    CV_IA64_CR30    =   4126,
    CV_IA64_CR31    =   4127,
    CV_IA64_CR32    =   4128,
    CV_IA64_CR33    =   4129,
    CV_IA64_CR34    =   4130,
    CV_IA64_CR35    =   4131,
    CV_IA64_CR36    =   4132,
    CV_IA64_CR37    =   4133,
    CV_IA64_CR38    =   4134,
    CV_IA64_CR39    =   4135,
    CV_IA64_CR40    =   4136,
    CV_IA64_CR41    =   4137,
    CV_IA64_CR42    =   4138,
    CV_IA64_CR43    =   4139,
    CV_IA64_CR44    =   4140,
    CV_IA64_CR45    =   4141,
    CV_IA64_CR46    =   4142,
    CV_IA64_CR47    =   4143,
    CV_IA64_CR48    =   4144,
    CV_IA64_CR49    =   4145,
    CV_IA64_CR50    =   4146,
    CV_IA64_CR51    =   4147,
    CV_IA64_CR52    =   4148,
    CV_IA64_CR53    =   4149,
    CV_IA64_CR54    =   4150,
    CV_IA64_CR55    =   4151,
    CV_IA64_CR56    =   4152,
    CV_IA64_CR57    =   4153,
    CV_IA64_CR58    =   4154,
    CV_IA64_CR59    =   4155,
    CV_IA64_CR60    =   4156,
    CV_IA64_CR61    =   4157,
    CV_IA64_CR62    =   4158,
    CV_IA64_CR63    =   4159,
    CV_IA64_SaLID   =   4160,
    CV_IA64_SaIVR   =   4161,
    CV_IA64_SaTPR   =   4162,
    CV_IA64_SaEOI   =   4163,
    CV_IA64_SaIRR0  =   4164,
    CV_IA64_SaIRR1  =   4165,
    CV_IA64_SaIRR2  =   4166,
    CV_IA64_SaIRR3  =   4167,
    CV_IA64_SaITV   =   4168,
    CV_IA64_SaPMV   =   4169,
    CV_IA64_SaCMCV  =   4170,
    CV_IA64_CR75    =   4171,
    CV_IA64_CR76    =   4172,
    CV_IA64_CR77    =   4173,
    CV_IA64_CR78    =   4174,
    CV_IA64_CR79    =   4175,
    CV_IA64_SaLRR0  =   4176,
    CV_IA64_SaLRR1  =   4177,
    CV_IA64_CR82    =   4178,
    CV_IA64_CR83    =   4179,
    CV_IA64_CR84    =   4180,
    CV_IA64_CR85    =   4181,
    CV_IA64_CR86    =   4182,
    CV_IA64_CR87    =   4183,
    CV_IA64_CR88    =   4184,
    CV_IA64_CR89    =   4185,
    CV_IA64_CR90    =   4186,
    CV_IA64_CR91    =   4187,
    CV_IA64_CR92    =   4188,
    CV_IA64_CR93    =   4189,
    CV_IA64_CR94    =   4190,
    CV_IA64_CR95    =   4191,
    CV_IA64_CR96    =   4192,
    CV_IA64_CR97    =   4193,
    CV_IA64_CR98    =   4194,
    CV_IA64_CR99    =   4195,
    CV_IA64_CR100   =   4196,
    CV_IA64_CR101   =   4197,
    CV_IA64_CR102   =   4198,
    CV_IA64_CR103   =   4199,
    CV_IA64_CR104   =   4200,
    CV_IA64_CR105   =   4201,
    CV_IA64_CR106   =   4202,
    CV_IA64_CR107   =   4203,
    CV_IA64_CR108   =   4204,
    CV_IA64_CR109   =   4205,
    CV_IA64_CR110   =   4206,
    CV_IA64_CR111   =   4207,
    CV_IA64_CR112   =   4208,
    CV_IA64_CR113   =   4209,
    CV_IA64_CR114   =   4210,
    CV_IA64_CR115   =   4211,
    CV_IA64_CR116   =   4212,
    CV_IA64_CR117   =   4213,
    CV_IA64_CR118   =   4214,
    CV_IA64_CR119   =   4215,
    CV_IA64_CR120   =   4216,
    CV_IA64_CR121   =   4217,
    CV_IA64_CR122   =   4218,
    CV_IA64_CR123   =   4219,
    CV_IA64_CR124   =   4220,
    CV_IA64_CR125   =   4221,
    CV_IA64_CR126   =   4222,
    CV_IA64_CR127   =   4223,

    // Protection Key Registers

    CV_IA64_Pkr0    =   5120,
    CV_IA64_Pkr1    =   5121,
    CV_IA64_Pkr2    =   5122,
    CV_IA64_Pkr3    =   5123,
    CV_IA64_Pkr4    =   5124,
    CV_IA64_Pkr5    =   5125,
    CV_IA64_Pkr6    =   5126,
    CV_IA64_Pkr7    =   5127,
    CV_IA64_Pkr8    =   5128,
    CV_IA64_Pkr9    =   5129,
    CV_IA64_Pkr10   =   5130,
    CV_IA64_Pkr11   =   5131,
    CV_IA64_Pkr12   =   5132,
    CV_IA64_Pkr13   =   5133,
    CV_IA64_Pkr14   =   5134,
    CV_IA64_Pkr15   =   5135,

    // Region Registers

    CV_IA64_Rr0     =   6144,
    CV_IA64_Rr1     =   6145,
    CV_IA64_Rr2     =   6146,
    CV_IA64_Rr3     =   6147,
    CV_IA64_Rr4     =   6148,
    CV_IA64_Rr5     =   6149,
    CV_IA64_Rr6     =   6150,
    CV_IA64_Rr7     =   6151,

    // Performance Monitor Data Registers

    CV_IA64_PFD0    =   7168,
    CV_IA64_PFD1    =   7169,
    CV_IA64_PFD2    =   7170,
    CV_IA64_PFD3    =   7171,
    CV_IA64_PFD4    =   7172,
    CV_IA64_PFD5    =   7173,
    CV_IA64_PFD6    =   7174,
    CV_IA64_PFD7    =   7175,

    // Performance Monitor Config Registers

    CV_IA64_PFC0    =   7424,
    CV_IA64_PFC1    =   7425,
    CV_IA64_PFC2    =   7426,
    CV_IA64_PFC3    =   7427,
    CV_IA64_PFC4    =   7428,
    CV_IA64_PFC5    =   7429,
    CV_IA64_PFC6    =   7430,
    CV_IA64_PFC7    =   7431,

    // Instruction Translation Registers

    CV_IA64_TrI0    =   8192,
    CV_IA64_TrI1    =   8193,
    CV_IA64_TrI2    =   8194,
    CV_IA64_TrI3    =   8195,
    CV_IA64_TrI4    =   8196,
    CV_IA64_TrI5    =   8197,
    CV_IA64_TrI6    =   8198,
    CV_IA64_TrI7    =   8199,

    // Data Translation Registers

    CV_IA64_TrD0    =   8320,
    CV_IA64_TrD1    =   8321,
    CV_IA64_TrD2    =   8322,
    CV_IA64_TrD3    =   8323,
    CV_IA64_TrD4    =   8324,
    CV_IA64_TrD5    =   8325,
    CV_IA64_TrD6    =   8326,
    CV_IA64_TrD7    =   8327,

    // Instruction Breakpoint Registers

    CV_IA64_DbI0    =   8448,
    CV_IA64_DbI1    =   8449,
    CV_IA64_DbI2    =   8450,
    CV_IA64_DbI3    =   8451,
    CV_IA64_DbI4    =   8452,
    CV_IA64_DbI5    =   8453,
    CV_IA64_DbI6    =   8454,
    CV_IA64_DbI7    =   8455,

    // Data Breakpoint Registers

    CV_IA64_DbD0    =   8576,
    CV_IA64_DbD1    =   8577,
    CV_IA64_DbD2    =   8578,
    CV_IA64_DbD3    =   8579,
    CV_IA64_DbD4    =   8580,
    CV_IA64_DbD5    =   8581,
    CV_IA64_DbD6    =   8582,
    CV_IA64_DbD7    =   8583,

    //
    // Register set for the TriCore processor.
    //

    CV_TRI_NOREG    =   CV_REG_NONE,

    // General Purpose Data Registers

    CV_TRI_D0   =   10,
    CV_TRI_D1   =   11,
    CV_TRI_D2   =   12,
    CV_TRI_D3   =   13,
    CV_TRI_D4   =   14,
    CV_TRI_D5   =   15,
    CV_TRI_D6   =   16,
    CV_TRI_D7   =   17,
    CV_TRI_D8   =   18,
    CV_TRI_D9   =   19,
    CV_TRI_D10  =   20,
    CV_TRI_D11  =   21,
    CV_TRI_D12  =   22,
    CV_TRI_D13  =   23,
    CV_TRI_D14  =   24,
    CV_TRI_D15  =   25,

    // General Purpose Address Registers

    CV_TRI_A0   =   26,
    CV_TRI_A1   =   27,
    CV_TRI_A2   =   28,
    CV_TRI_A3   =   29,
    CV_TRI_A4   =   30,
    CV_TRI_A5   =   31,
    CV_TRI_A6   =   32,
    CV_TRI_A7   =   33,
    CV_TRI_A8   =   34,
    CV_TRI_A9   =   35,
    CV_TRI_A10  =   36,
    CV_TRI_A11  =   37,
    CV_TRI_A12  =   38,
    CV_TRI_A13  =   39,
    CV_TRI_A14  =   40,
    CV_TRI_A15  =   41,

    // Extended (64-bit) data registers

    CV_TRI_E0   =   42,
    CV_TRI_E2   =   43,
    CV_TRI_E4   =   44,
    CV_TRI_E6   =   45,
    CV_TRI_E8   =   46,
    CV_TRI_E10  =   47,
    CV_TRI_E12  =   48,
    CV_TRI_E14  =   49,

    // Extended (64-bit) address registers

    CV_TRI_EA0  =   50,
    CV_TRI_EA2  =   51,
    CV_TRI_EA4  =   52,
    CV_TRI_EA6  =   53,
    CV_TRI_EA8  =   54,
    CV_TRI_EA10 =   55,
    CV_TRI_EA12 =   56,
    CV_TRI_EA14 =   57,

    CV_TRI_PSW  =   58,
    CV_TRI_PCXI =   59,
    CV_TRI_PC   =   60,
    CV_TRI_FCX  =   61,
    CV_TRI_LCX  =   62,
    CV_TRI_ISP  =   63,
    CV_TRI_ICR  =   64,
    CV_TRI_BIV  =   65,
    CV_TRI_BTV  =   66,
    CV_TRI_SYSCON   =   67,
    CV_TRI_DPRx_0   =   68,
    CV_TRI_DPRx_1   =   69,
    CV_TRI_DPRx_2   =   70,
    CV_TRI_DPRx_3   =   71,
    CV_TRI_CPRx_0   =   68,
    CV_TRI_CPRx_1   =   69,
    CV_TRI_CPRx_2   =   70,
    CV_TRI_CPRx_3   =   71,
    CV_TRI_DPMx_0   =   68,
    CV_TRI_DPMx_1   =   69,
    CV_TRI_DPMx_2   =   70,
    CV_TRI_DPMx_3   =   71,
    CV_TRI_CPMx_0   =   68,
    CV_TRI_CPMx_1   =   69,
    CV_TRI_CPMx_2   =   70,
    CV_TRI_CPMx_3   =   71,
    CV_TRI_DBGSSR   =   72,
    CV_TRI_EXEVT    =   73,
    CV_TRI_SWEVT    =   74,
    CV_TRI_CREVT    =   75,
    CV_TRI_TRnEVT   =   76,
    CV_TRI_MMUCON   =   77,
    CV_TRI_ASI      =   78,
    CV_TRI_TVA      =   79,
    CV_TRI_TPA      =   80,
    CV_TRI_TPX      =   81,
    CV_TRI_TFA      =   82,

    //
    // Register set for the AM33 and related processors.
    //

    CV_AM33_NOREG   =   CV_REG_NONE,

    // "Extended" (general purpose integer) registers
    CV_AM33_E0      =   10,
    CV_AM33_E1      =   11,
    CV_AM33_E2      =   12,
    CV_AM33_E3      =   13,
    CV_AM33_E4      =   14,
    CV_AM33_E5      =   15,
    CV_AM33_E6      =   16,
    CV_AM33_E7      =   17,

    // Address registers
    CV_AM33_A0      =   20,
    CV_AM33_A1      =   21,
    CV_AM33_A2      =   22,
    CV_AM33_A3      =   23,

    // Integer data registers
    CV_AM33_D0      =   30,
    CV_AM33_D1      =   31,
    CV_AM33_D2      =   32,
    CV_AM33_D3      =   33,

    // (Single-precision) floating-point registers
    CV_AM33_FS0     =   40,
    CV_AM33_FS1     =   41,
    CV_AM33_FS2     =   42,
    CV_AM33_FS3     =   43,
    CV_AM33_FS4     =   44,
    CV_AM33_FS5     =   45,
    CV_AM33_FS6     =   46,
    CV_AM33_FS7     =   47,
    CV_AM33_FS8     =   48,
    CV_AM33_FS9     =   49,
    CV_AM33_FS10    =   50,
    CV_AM33_FS11    =   51,
    CV_AM33_FS12    =   52,
    CV_AM33_FS13    =   53,
    CV_AM33_FS14    =   54,
    CV_AM33_FS15    =   55,
    CV_AM33_FS16    =   56,
    CV_AM33_FS17    =   57,
    CV_AM33_FS18    =   58,
    CV_AM33_FS19    =   59,
    CV_AM33_FS20    =   60,
    CV_AM33_FS21    =   61,
    CV_AM33_FS22    =   62,
    CV_AM33_FS23    =   63,
    CV_AM33_FS24    =   64,
    CV_AM33_FS25    =   65,
    CV_AM33_FS26    =   66,
    CV_AM33_FS27    =   67,
    CV_AM33_FS28    =   68,
    CV_AM33_FS29    =   69,
    CV_AM33_FS30    =   70,
    CV_AM33_FS31    =   71,

    // Special purpose registers

    // Stack pointer
    CV_AM33_SP      =   80,

    // Program counter
    CV_AM33_PC      =   81,

    // Multiply-divide/accumulate registers
    CV_AM33_MDR     =   82,
    CV_AM33_MDRQ    =   83,
    CV_AM33_MCRH    =   84,
    CV_AM33_MCRL    =   85,
    CV_AM33_MCVF    =   86,

    // CPU status words
    CV_AM33_EPSW    =   87,
    CV_AM33_FPCR    =   88,

    // Loop buffer registers
    CV_AM33_LIR     =   89,
    CV_AM33_LAR     =   90,

    //
    // Register set for the Mitsubishi M32R
    //

    CV_M32R_NOREG    =   CV_REG_NONE,

    CV_M32R_R0    =   10,
    CV_M32R_R1    =   11,
    CV_M32R_R2    =   12,
    CV_M32R_R3    =   13,
    CV_M32R_R4    =   14,
    CV_M32R_R5    =   15,
    CV_M32R_R6    =   16,
    CV_M32R_R7    =   17,
    CV_M32R_R8    =   18,
    CV_M32R_R9    =   19,
    CV_M32R_R10   =   20,
    CV_M32R_R11   =   21,
    CV_M32R_R12   =   22,   // Gloabal Pointer, if used
    CV_M32R_R13   =   23,   // Frame Pointer, if allocated
    CV_M32R_R14   =   24,   // Link Register
    CV_M32R_R15   =   25,   // Stack Pointer
    CV_M32R_PSW   =   26,   // Preocessor Status Register
    CV_M32R_CBR   =   27,   // Condition Bit Register
    CV_M32R_SPI   =   28,   // Interrupt Stack Pointer
    CV_M32R_SPU   =   29,   // User Stack Pointer
    CV_M32R_SPO   =   30,   // OS Stack Pointer
    CV_M32R_BPC   =   31,   // Backup Program Counter
    CV_M32R_ACHI  =   32,   // Accumulator High
    CV_M32R_ACLO  =   33,   // Accumulator Low
    CV_M32R_PC    =   34,   // Program Counter

    //
    // Register set for the SuperH SHMedia processor including compact
    // mode
    //

    // Integer - 64 bit general registers
    CV_SHMEDIA_NOREG   =   CV_REG_NONE,
    CV_SHMEDIA_R0      =   10,
    CV_SHMEDIA_R1      =   11,
    CV_SHMEDIA_R2      =   12,
    CV_SHMEDIA_R3      =   13,
    CV_SHMEDIA_R4      =   14,
    CV_SHMEDIA_R5      =   15,
    CV_SHMEDIA_R6      =   16,
    CV_SHMEDIA_R7      =   17,
    CV_SHMEDIA_R8      =   18,
    CV_SHMEDIA_R9      =   19,
    CV_SHMEDIA_R10     =   20,
    CV_SHMEDIA_R11     =   21,
    CV_SHMEDIA_R12     =   22,
    CV_SHMEDIA_R13     =   23,
    CV_SHMEDIA_R14     =   24,
    CV_SHMEDIA_R15     =   25,
    CV_SHMEDIA_R16     =   26,
    CV_SHMEDIA_R17     =   27,
    CV_SHMEDIA_R18     =   28,
    CV_SHMEDIA_R19     =   29,
    CV_SHMEDIA_R20     =   30,
    CV_SHMEDIA_R21     =   31,
    CV_SHMEDIA_R22     =   32,
    CV_SHMEDIA_R23     =   33,
    CV_SHMEDIA_R24     =   34,
    CV_SHMEDIA_R25     =   35,
    CV_SHMEDIA_R26     =   36,
    CV_SHMEDIA_R27     =   37,
    CV_SHMEDIA_R28     =   38,
    CV_SHMEDIA_R29     =   39,
    CV_SHMEDIA_R30     =   40,
    CV_SHMEDIA_R31     =   41,
    CV_SHMEDIA_R32     =   42,
    CV_SHMEDIA_R33     =   43,
    CV_SHMEDIA_R34     =   44,
    CV_SHMEDIA_R35     =   45,
    CV_SHMEDIA_R36     =   46,
    CV_SHMEDIA_R37     =   47,
    CV_SHMEDIA_R38     =   48,
    CV_SHMEDIA_R39     =   49,
    CV_SHMEDIA_R40     =   50,
    CV_SHMEDIA_R41     =   51,
    CV_SHMEDIA_R42     =   52,
    CV_SHMEDIA_R43     =   53,
    CV_SHMEDIA_R44     =   54,
    CV_SHMEDIA_R45     =   55,
    CV_SHMEDIA_R46     =   56,
    CV_SHMEDIA_R47     =   57,
    CV_SHMEDIA_R48     =   58,
    CV_SHMEDIA_R49     =   59,
    CV_SHMEDIA_R50     =   60,
    CV_SHMEDIA_R51     =   61,
    CV_SHMEDIA_R52     =   62,
    CV_SHMEDIA_R53     =   63,
    CV_SHMEDIA_R54     =   64,
    CV_SHMEDIA_R55     =   65,
    CV_SHMEDIA_R56     =   66,
    CV_SHMEDIA_R57     =   67,
    CV_SHMEDIA_R58     =   68,
    CV_SHMEDIA_R59     =   69,
    CV_SHMEDIA_R60     =   70,
    CV_SHMEDIA_R61     =   71,
    CV_SHMEDIA_R62     =   72,
    CV_SHMEDIA_R63     =   73,
    
    // Target Registers - 32 bit
    CV_SHMEDIA_TR0     =   74,
    CV_SHMEDIA_TR1     =   75,
    CV_SHMEDIA_TR2     =   76,
    CV_SHMEDIA_TR3     =   77,
    CV_SHMEDIA_TR4     =   78,
    CV_SHMEDIA_TR5     =   79,
    CV_SHMEDIA_TR6     =   80,
    CV_SHMEDIA_TR7     =   81,
    CV_SHMEDIA_TR8     =   82, // future-proof
    CV_SHMEDIA_TR9     =   83, // future-proof
    CV_SHMEDIA_TR10    =   84, // future-proof
    CV_SHMEDIA_TR11    =   85, // future-proof
    CV_SHMEDIA_TR12    =   86, // future-proof
    CV_SHMEDIA_TR13    =   87, // future-proof
    CV_SHMEDIA_TR14    =   88, // future-proof
    CV_SHMEDIA_TR15    =   89, // future-proof

    // Single - 32 bit fp registers
    CV_SHMEDIA_FR0     =   128,
    CV_SHMEDIA_FR1     =   129,
    CV_SHMEDIA_FR2     =   130,
    CV_SHMEDIA_FR3     =   131,
    CV_SHMEDIA_FR4     =   132,
    CV_SHMEDIA_FR5     =   133,
    CV_SHMEDIA_FR6     =   134,
    CV_SHMEDIA_FR7     =   135,
    CV_SHMEDIA_FR8     =   136,
    CV_SHMEDIA_FR9     =   137,
    CV_SHMEDIA_FR10    =   138,
    CV_SHMEDIA_FR11    =   139,
    CV_SHMEDIA_FR12    =   140,
    CV_SHMEDIA_FR13    =   141,
    CV_SHMEDIA_FR14    =   142,
    CV_SHMEDIA_FR15    =   143,
    CV_SHMEDIA_FR16    =   144,
    CV_SHMEDIA_FR17    =   145,
    CV_SHMEDIA_FR18    =   146,
    CV_SHMEDIA_FR19    =   147,
    CV_SHMEDIA_FR20    =   148,
    CV_SHMEDIA_FR21    =   149,
    CV_SHMEDIA_FR22    =   150,
    CV_SHMEDIA_FR23    =   151,
    CV_SHMEDIA_FR24    =   152,
    CV_SHMEDIA_FR25    =   153,
    CV_SHMEDIA_FR26    =   154,
    CV_SHMEDIA_FR27    =   155,
    CV_SHMEDIA_FR28    =   156,
    CV_SHMEDIA_FR29    =   157,
    CV_SHMEDIA_FR30    =   158,
    CV_SHMEDIA_FR31    =   159,
    CV_SHMEDIA_FR32    =   160,
    CV_SHMEDIA_FR33    =   161,
    CV_SHMEDIA_FR34    =   162,
    CV_SHMEDIA_FR35    =   163,
    CV_SHMEDIA_FR36    =   164,
    CV_SHMEDIA_FR37    =   165,
    CV_SHMEDIA_FR38    =   166,
    CV_SHMEDIA_FR39    =   167,
    CV_SHMEDIA_FR40    =   168,
    CV_SHMEDIA_FR41    =   169,
    CV_SHMEDIA_FR42    =   170,
    CV_SHMEDIA_FR43    =   171,
    CV_SHMEDIA_FR44    =   172,
    CV_SHMEDIA_FR45    =   173,
    CV_SHMEDIA_FR46    =   174,
    CV_SHMEDIA_FR47    =   175,
    CV_SHMEDIA_FR48    =   176,
    CV_SHMEDIA_FR49    =   177,
    CV_SHMEDIA_FR50    =   178,
    CV_SHMEDIA_FR51    =   179,
    CV_SHMEDIA_FR52    =   180,
    CV_SHMEDIA_FR53    =   181,
    CV_SHMEDIA_FR54    =   182,
    CV_SHMEDIA_FR55    =   183,
    CV_SHMEDIA_FR56    =   184,
    CV_SHMEDIA_FR57    =   185,
    CV_SHMEDIA_FR58    =   186,
    CV_SHMEDIA_FR59    =   187,
    CV_SHMEDIA_FR60    =   188,
    CV_SHMEDIA_FR61    =   189,
    CV_SHMEDIA_FR62    =   190,
    CV_SHMEDIA_FR63    =   191,

    // Double - 64 bit synonyms for 32bit fp register pairs
    //          subtract 128 to find first base single register
    CV_SHMEDIA_DR0     =   256,
    CV_SHMEDIA_DR2     =   258,
    CV_SHMEDIA_DR4     =   260,
    CV_SHMEDIA_DR6     =   262,
    CV_SHMEDIA_DR8     =   264,
    CV_SHMEDIA_DR10    =   266,
    CV_SHMEDIA_DR12    =   268,
    CV_SHMEDIA_DR14    =   270,
    CV_SHMEDIA_DR16    =   272,
    CV_SHMEDIA_DR18    =   274,
    CV_SHMEDIA_DR20    =   276,
    CV_SHMEDIA_DR22    =   278,
    CV_SHMEDIA_DR24    =   280,
    CV_SHMEDIA_DR26    =   282,
    CV_SHMEDIA_DR28    =   284,
    CV_SHMEDIA_DR30    =   286,
    CV_SHMEDIA_DR32    =   288,
    CV_SHMEDIA_DR34    =   290,
    CV_SHMEDIA_DR36    =   292,
    CV_SHMEDIA_DR38    =   294,
    CV_SHMEDIA_DR40    =   296,
    CV_SHMEDIA_DR42    =   298,
    CV_SHMEDIA_DR44    =   300,
    CV_SHMEDIA_DR46    =   302,
    CV_SHMEDIA_DR48    =   304,
    CV_SHMEDIA_DR50    =   306,
    CV_SHMEDIA_DR52    =   308,
    CV_SHMEDIA_DR54    =   310,
    CV_SHMEDIA_DR56    =   312,
    CV_SHMEDIA_DR58    =   314,
    CV_SHMEDIA_DR60    =   316,
    CV_SHMEDIA_DR62    =   318,

    // Vector - 128 bit synonyms for 32bit fp register quads
    //          subtract 384 to find first base single register
    CV_SHMEDIA_FV0     =   512,
    CV_SHMEDIA_FV4     =   516,
    CV_SHMEDIA_FV8     =   520,
    CV_SHMEDIA_FV12    =   524,
    CV_SHMEDIA_FV16    =   528,
    CV_SHMEDIA_FV20    =   532,
    CV_SHMEDIA_FV24    =   536,
    CV_SHMEDIA_FV28    =   540,
    CV_SHMEDIA_FV32    =   544,
    CV_SHMEDIA_FV36    =   548,
    CV_SHMEDIA_FV40    =   552,
    CV_SHMEDIA_FV44    =   556,
    CV_SHMEDIA_FV48    =   560,
    CV_SHMEDIA_FV52    =   564,
    CV_SHMEDIA_FV56    =   568,
    CV_SHMEDIA_FV60    =   572,

    // Matrix - 512 bit synonyms for 16 adjacent 32bit fp registers
    //          subtract 896 to find first base single register
    CV_SHMEDIA_MTRX0   =   1024,
    CV_SHMEDIA_MTRX16  =   1040,
    CV_SHMEDIA_MTRX32  =   1056,
    CV_SHMEDIA_MTRX48  =   1072,

    // Control - Implementation defined 64bit control registers
    CV_SHMEDIA_CR0     =   2000,
    CV_SHMEDIA_CR1     =   2001,
    CV_SHMEDIA_CR2     =   2002,
    CV_SHMEDIA_CR3     =   2003,
    CV_SHMEDIA_CR4     =   2004,
    CV_SHMEDIA_CR5     =   2005,
    CV_SHMEDIA_CR6     =   2006,
    CV_SHMEDIA_CR7     =   2007,
    CV_SHMEDIA_CR8     =   2008,
    CV_SHMEDIA_CR9     =   2009,
    CV_SHMEDIA_CR10    =   2010,
    CV_SHMEDIA_CR11    =   2011,
    CV_SHMEDIA_CR12    =   2012,
    CV_SHMEDIA_CR13    =   2013,
    CV_SHMEDIA_CR14    =   2014,
    CV_SHMEDIA_CR15    =   2015,
    CV_SHMEDIA_CR16    =   2016,
    CV_SHMEDIA_CR17    =   2017,
    CV_SHMEDIA_CR18    =   2018,
    CV_SHMEDIA_CR19    =   2019,
    CV_SHMEDIA_CR20    =   2020,
    CV_SHMEDIA_CR21    =   2021,
    CV_SHMEDIA_CR22    =   2022,
    CV_SHMEDIA_CR23    =   2023,
    CV_SHMEDIA_CR24    =   2024,
    CV_SHMEDIA_CR25    =   2025,
    CV_SHMEDIA_CR26    =   2026,
    CV_SHMEDIA_CR27    =   2027,
    CV_SHMEDIA_CR28    =   2028,
    CV_SHMEDIA_CR29    =   2029,
    CV_SHMEDIA_CR30    =   2030,
    CV_SHMEDIA_CR31    =   2031,
    CV_SHMEDIA_CR32    =   2032,
    CV_SHMEDIA_CR33    =   2033,
    CV_SHMEDIA_CR34    =   2034,
    CV_SHMEDIA_CR35    =   2035,
    CV_SHMEDIA_CR36    =   2036,
    CV_SHMEDIA_CR37    =   2037,
    CV_SHMEDIA_CR38    =   2038,
    CV_SHMEDIA_CR39    =   2039,
    CV_SHMEDIA_CR40    =   2040,
    CV_SHMEDIA_CR41    =   2041,
    CV_SHMEDIA_CR42    =   2042,
    CV_SHMEDIA_CR43    =   2043,
    CV_SHMEDIA_CR44    =   2044,
    CV_SHMEDIA_CR45    =   2045,
    CV_SHMEDIA_CR46    =   2046,
    CV_SHMEDIA_CR47    =   2047,
    CV_SHMEDIA_CR48    =   2048,
    CV_SHMEDIA_CR49    =   2049,
    CV_SHMEDIA_CR50    =   2050,
    CV_SHMEDIA_CR51    =   2051,
    CV_SHMEDIA_CR52    =   2052,
    CV_SHMEDIA_CR53    =   2053,
    CV_SHMEDIA_CR54    =   2054,
    CV_SHMEDIA_CR55    =   2055,
    CV_SHMEDIA_CR56    =   2056,
    CV_SHMEDIA_CR57    =   2057,
    CV_SHMEDIA_CR58    =   2058,
    CV_SHMEDIA_CR59    =   2059,
    CV_SHMEDIA_CR60    =   2060,
    CV_SHMEDIA_CR61    =   2061,
    CV_SHMEDIA_CR62    =   2062,
    CV_SHMEDIA_CR63    =   2063,

    CV_SHMEDIA_FPSCR   =   2064,

    // Compact mode synonyms
    CV_SHMEDIA_GBR     =   CV_SHMEDIA_R16,
    CV_SHMEDIA_MACL    =   90, // synonym for lower 32bits of media R17
    CV_SHMEDIA_MACH    =   91, // synonym for upper 32bits of media R17
    CV_SHMEDIA_PR      =   CV_SHMEDIA_R18,
    CV_SHMEDIA_T       =   92, // synonym for lowest bit of media R19
    CV_SHMEDIA_FPUL    =   CV_SHMEDIA_FR32,
    CV_SHMEDIA_PC      =   93,
    CV_SHMEDIA_SR      =   CV_SHMEDIA_CR0,

    //
    // AMD64/X8664 registers
    //

    CV_AMD64_AL       =   1,
    CV_AMD64_CL       =   2,
    CV_AMD64_DL       =   3,
    CV_AMD64_BL       =   4,
    CV_AMD64_AH       =   5,
    CV_AMD64_CH       =   6,
    CV_AMD64_DH       =   7,
    CV_AMD64_BH       =   8,
    CV_AMD64_AX       =   9,
    CV_AMD64_CX       =  10,
    CV_AMD64_DX       =  11,
    CV_AMD64_BX       =  12,
    CV_AMD64_SP       =  13,
    CV_AMD64_BP       =  14,
    CV_AMD64_SI       =  15,
    CV_AMD64_DI       =  16,
    CV_AMD64_EAX      =  17,
    CV_AMD64_ECX      =  18,
    CV_AMD64_EDX      =  19,
    CV_AMD64_EBX      =  20,
    CV_AMD64_ESP      =  21,
    CV_AMD64_EBP      =  22,
    CV_AMD64_ESI      =  23,
    CV_AMD64_EDI      =  24,
    CV_AMD64_ES       =  25,
    CV_AMD64_CS       =  26,
    CV_AMD64_SS       =  27,
    CV_AMD64_DS       =  28,
    CV_AMD64_FS       =  29,
    CV_AMD64_GS       =  30,
    CV_AMD64_FLAGS    =  32,
    CV_AMD64_RIP      =  33,
    CV_AMD64_EFLAGS   =  34,

    // Control registers
    CV_AMD64_CR0      =  80,
    CV_AMD64_CR1      =  81,
    CV_AMD64_CR2      =  82,
    CV_AMD64_CR3      =  83,
    CV_AMD64_CR4      =  84,
    CV_AMD64_CR8      =  88,

    // Debug registers
    CV_AMD64_DR0      =  90,
    CV_AMD64_DR1      =  91,
    CV_AMD64_DR2      =  92,
    CV_AMD64_DR3      =  93,
    CV_AMD64_DR4      =  94,
    CV_AMD64_DR5      =  95,
    CV_AMD64_DR6      =  96,
    CV_AMD64_DR7      =  97,
    CV_AMD64_DR8      =  98,
    CV_AMD64_DR9      =  99,
    CV_AMD64_DR10     =  100,
    CV_AMD64_DR11     =  101,
    CV_AMD64_DR12     =  102,
    CV_AMD64_DR13     =  103,
    CV_AMD64_DR14     =  104,
    CV_AMD64_DR15     =  105,

    CV_AMD64_GDTR     =  110,
    CV_AMD64_GDTL     =  111,
    CV_AMD64_IDTR     =  112,
    CV_AMD64_IDTL     =  113,
    CV_AMD64_LDTR     =  114,
    CV_AMD64_TR       =  115,

    CV_AMD64_ST0      =  128,
    CV_AMD64_ST1      =  129,
    CV_AMD64_ST2      =  130,
    CV_AMD64_ST3      =  131,
    CV_AMD64_ST4      =  132,
    CV_AMD64_ST5      =  133,
    CV_AMD64_ST6      =  134,
    CV_AMD64_ST7      =  135,
    CV_AMD64_CTRL     =  136,
    CV_AMD64_STAT     =  137,
    CV_AMD64_TAG      =  138,
    CV_AMD64_FPIP     =  139,
    CV_AMD64_FPCS     =  140,
    CV_AMD64_FPDO     =  141,
    CV_AMD64_FPDS     =  142,
    CV_AMD64_ISEM     =  143,
    CV_AMD64_FPEIP    =  144,
    CV_AMD64_FPEDO    =  145,

    CV_AMD64_MM0      =  146,
    CV_AMD64_MM1      =  147,
    CV_AMD64_MM2      =  148,
    CV_AMD64_MM3      =  149,
    CV_AMD64_MM4      =  150,
    CV_AMD64_MM5      =  151,
    CV_AMD64_MM6      =  152,
    CV_AMD64_MM7      =  153,

    CV_AMD64_XMM0     =  154,   // KATMAI registers
    CV_AMD64_XMM1     =  155,
    CV_AMD64_XMM2     =  156,
    CV_AMD64_XMM3     =  157,
    CV_AMD64_XMM4     =  158,
    CV_AMD64_XMM5     =  159,
    CV_AMD64_XMM6     =  160,
    CV_AMD64_XMM7     =  161,

    CV_AMD64_XMM0_0   =  162,   // KATMAI sub-registers
    CV_AMD64_XMM0_1   =  163,
    CV_AMD64_XMM0_2   =  164,
    CV_AMD64_XMM0_3   =  165,
    CV_AMD64_XMM1_0   =  166,
    CV_AMD64_XMM1_1   =  167,
    CV_AMD64_XMM1_2   =  168,
    CV_AMD64_XMM1_3   =  169,
    CV_AMD64_XMM2_0   =  170,
    CV_AMD64_XMM2_1   =  171,
    CV_AMD64_XMM2_2   =  172,
    CV_AMD64_XMM2_3   =  173,
    CV_AMD64_XMM3_0   =  174,
    CV_AMD64_XMM3_1   =  175,
    CV_AMD64_XMM3_2   =  176,
    CV_AMD64_XMM3_3   =  177,
    CV_AMD64_XMM4_0   =  178,
    CV_AMD64_XMM4_1   =  179,
    CV_AMD64_XMM4_2   =  180,
    CV_AMD64_XMM4_3   =  181,
    CV_AMD64_XMM5_0   =  182,
    CV_AMD64_XMM5_1   =  183,
    CV_AMD64_XMM5_2   =  184,
    CV_AMD64_XMM5_3   =  185,
    CV_AMD64_XMM6_0   =  186,
    CV_AMD64_XMM6_1   =  187,
    CV_AMD64_XMM6_2   =  188,
    CV_AMD64_XMM6_3   =  189,
    CV_AMD64_XMM7_0   =  190,
    CV_AMD64_XMM7_1   =  191,
    CV_AMD64_XMM7_2   =  192,
    CV_AMD64_XMM7_3   =  193,

    CV_AMD64_XMM0L    =  194,
    CV_AMD64_XMM1L    =  195,
    CV_AMD64_XMM2L    =  196,
    CV_AMD64_XMM3L    =  197,
    CV_AMD64_XMM4L    =  198,
    CV_AMD64_XMM5L    =  199,
    CV_AMD64_XMM6L    =  200,
    CV_AMD64_XMM7L    =  201,

    CV_AMD64_XMM0H    =  202,
    CV_AMD64_XMM1H    =  203,
    CV_AMD64_XMM2H    =  204,
    CV_AMD64_XMM3H    =  205,
    CV_AMD64_XMM4H    =  206,
    CV_AMD64_XMM5H    =  207,
    CV_AMD64_XMM6H    =  208,
    CV_AMD64_XMM7H    =  209,

    CV_AMD64_MXCSR    =  211,   // XMM status register

    CV_AMD64_EMM0L    =  220,   // XMM sub-registers (WNI integer)
    CV_AMD64_EMM1L    =  221,
    CV_AMD64_EMM2L    =  222,
    CV_AMD64_EMM3L    =  223,
    CV_AMD64_EMM4L    =  224,
    CV_AMD64_EMM5L    =  225,
    CV_AMD64_EMM6L    =  226,
    CV_AMD64_EMM7L    =  227,

    CV_AMD64_EMM0H    =  228,
    CV_AMD64_EMM1H    =  229,
    CV_AMD64_EMM2H    =  230,
    CV_AMD64_EMM3H    =  231,
    CV_AMD64_EMM4H    =  232,
    CV_AMD64_EMM5H    =  233,
    CV_AMD64_EMM6H    =  234,
    CV_AMD64_EMM7H    =  235,

    // do not change the order of these regs, first one must be even too
    CV_AMD64_MM00     =  236,
    CV_AMD64_MM01     =  237,
    CV_AMD64_MM10     =  238,
    CV_AMD64_MM11     =  239,
    CV_AMD64_MM20     =  240,
    CV_AMD64_MM21     =  241,
    CV_AMD64_MM30     =  242,
    CV_AMD64_MM31     =  243,
    CV_AMD64_MM40     =  244,
    CV_AMD64_MM41     =  245,
    CV_AMD64_MM50     =  246,
    CV_AMD64_MM51     =  247,
    CV_AMD64_MM60     =  248,
    CV_AMD64_MM61     =  249,
    CV_AMD64_MM70     =  250,
    CV_AMD64_MM71     =  251,

    // Extended KATMAI registers
    CV_AMD64_XMM8     =  252,   // KATMAI registers
    CV_AMD64_XMM9     =  253,
    CV_AMD64_XMM10    =  254,
    CV_AMD64_XMM11    =  255,
    CV_AMD64_XMM12    =  256,
    CV_AMD64_XMM13    =  257,
    CV_AMD64_XMM14    =  258,
    CV_AMD64_XMM15    =  259,

    CV_AMD64_XMM8_0   =  260,   // KATMAI sub-registers
    CV_AMD64_XMM8_1   =  261,
    CV_AMD64_XMM8_2   =  262,
    CV_AMD64_XMM8_3   =  263,
    CV_AMD64_XMM9_0   =  264,
    CV_AMD64_XMM9_1   =  265,
    CV_AMD64_XMM9_2   =  266,
    CV_AMD64_XMM9_3   =  267,
    CV_AMD64_XMM10_0  =  268,
    CV_AMD64_XMM10_1  =  269,
    CV_AMD64_XMM10_2  =  270,
    CV_AMD64_XMM10_3  =  271,
    CV_AMD64_XMM11_0  =  272,
    CV_AMD64_XMM11_1  =  273,
    CV_AMD64_XMM11_2  =  274,
    CV_AMD64_XMM11_3  =  275,
    CV_AMD64_XMM12_0  =  276,
    CV_AMD64_XMM12_1  =  277,
    CV_AMD64_XMM12_2  =  278,
    CV_AMD64_XMM12_3  =  279,
    CV_AMD64_XMM13_0  =  280,
    CV_AMD64_XMM13_1  =  281,
    CV_AMD64_XMM13_2  =  282,
    CV_AMD64_XMM13_3  =  283,
    CV_AMD64_XMM14_0  =  284,
    CV_AMD64_XMM14_1  =  285,
    CV_AMD64_XMM14_2  =  286,
    CV_AMD64_XMM14_3  =  287,
    CV_AMD64_XMM15_0  =  288,
    CV_AMD64_XMM15_1  =  289,
    CV_AMD64_XMM15_2  =  290,
    CV_AMD64_XMM15_3  =  291,

    CV_AMD64_XMM8L    =  292,
    CV_AMD64_XMM9L    =  293,
    CV_AMD64_XMM10L   =  294,
    CV_AMD64_XMM11L   =  295,
    CV_AMD64_XMM12L   =  296,
    CV_AMD64_XMM13L   =  297,
    CV_AMD64_XMM14L   =  298,
    CV_AMD64_XMM15L   =  299,

    CV_AMD64_XMM8H    =  300,
    CV_AMD64_XMM9H    =  301,
    CV_AMD64_XMM10H   =  301,
    CV_AMD64_XMM11H   =  302,
    CV_AMD64_XMM12H   =  303,
    CV_AMD64_XMM13H   =  304,
    CV_AMD64_XMM14H   =  305,
    CV_AMD64_XMM15H   =  306,

    CV_AMD64_EMM8L    =  307,   // XMM sub-registers (WNI integer)
    CV_AMD64_EMM9L    =  308,
    CV_AMD64_EMM10L   =  309,
    CV_AMD64_EMM11L   =  310,
    CV_AMD64_EMM12L   =  311,
    CV_AMD64_EMM13L   =  312,
    CV_AMD64_EMM14L   =  313,
    CV_AMD64_EMM15L   =  314,

    CV_AMD64_EMM8H    =  315,
    CV_AMD64_EMM9H    =  316,
    CV_AMD64_EMM10H   =  317,
    CV_AMD64_EMM11H   =  318,
    CV_AMD64_EMM12H   =  319,
    CV_AMD64_EMM13H   =  320,
    CV_AMD64_EMM14H   =  321,
    CV_AMD64_EMM15H   =  322,

    // Low byte forms of some standard registers
    CV_AMD64_SIL      =  323,
    CV_AMD64_DIL      =  324,
    CV_AMD64_BPL      =  325,
    CV_AMD64_SPL      =  326,

    // 64-bit regular registers
    CV_AMD64_RAX      =  327,
    CV_AMD64_RBX      =  328,
    CV_AMD64_RCX      =  329,
    CV_AMD64_RDX      =  330,
    CV_AMD64_RSI      =  331,
    CV_AMD64_RDI      =  332,
    CV_AMD64_RBP      =  333,
    CV_AMD64_RSP      =  334,

    // 64-bit integer registers with 8-, 16-, and 32-bit forms (B, W, and D)
    CV_AMD64_R8       =  335,
    CV_AMD64_R9       =  336,
    CV_AMD64_R10      =  337,
    CV_AMD64_R11      =  338,
    CV_AMD64_R12      =  339,
    CV_AMD64_R13      =  340,
    CV_AMD64_R14      =  341,
    CV_AMD64_R15      =  342,

    CV_AMD64_R8B      =  343,
    CV_AMD64_R9B      =  344,
    CV_AMD64_R10B     =  345,
    CV_AMD64_R11B     =  346,
    CV_AMD64_R12B     =  347,
    CV_AMD64_R13B     =  348,
    CV_AMD64_R14B     =  349,
    CV_AMD64_R15B     =  350,

    CV_AMD64_R8W      =  351,
    CV_AMD64_R9W      =  352,
    CV_AMD64_R10W     =  353,
    CV_AMD64_R11W     =  354,
    CV_AMD64_R12W     =  355,
    CV_AMD64_R13W     =  356,
    CV_AMD64_R14W     =  357,
    CV_AMD64_R15W     =  358,

    CV_AMD64_R8D      =  359,
    CV_AMD64_R9D      =  360,
    CV_AMD64_R10D     =  361,
    CV_AMD64_R11D     =  362,
    CV_AMD64_R12D     =  363,
    CV_AMD64_R13D     =  364,
    CV_AMD64_R14D     =  365,
    CV_AMD64_R15D     =  366,

    // Note:  Next set of platform registers need to go into a new enum...
    // this one is above 44K now.

} CV_HREG_e;

enum StackFrameTypeEnum
{
    FrameTypeFPO,                   // Frame pointer omitted, FPO info available
    FrameTypeTrap,                  // Kernel Trap frame
    FrameTypeTSS,                   // Kernel Trap frame
    FrameTypeStandard,              // Standard EBP stackframe
    FrameTypeFrameData,             // Frame pointer omitted, FrameData info available

    FrameTypeUnknown = -1,          // Frame which does not have any debug info
};

enum MemoryTypeEnum
{
    MemTypeCode,                    // Read only code memory
    MemTypeData,                    // Read only data/stack memory
    MemTypeStack,                   // Read only stack memory

    MemTypeAny = -1,
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\vs\cvexefmt.h ===
/***    cvexefmt.h - format of CodeView information in exe
 *
 *      Structures, constants, etc. for reading CodeView information
 *      from the executable.
 *
 */


/***    The master copy of this file resides in the LANGAPI project.
 *      All Microsoft projects are required to use the master copy without
 *      modification.  Modification of the master version or a copy
 *      without consultation with all parties concerned is extremely
 *      risky.
 *
 */


#ifndef _VC_VER_INC
#include "..\include\vcver.h"
#endif



//  The following structures and constants describe the format of the
//  CodeView Debug OMF for that will be accepted by CodeView 4.0 and
//  later.  These are executables with signatures of NB05, NB06 and NB08.
//  There is some confusion about the signatures NB03 and NB04 so none
//  of the utilites will accept executables with these signatures.  NB07 is
//  the signature for QCWIN 1.0 packed executables.

//  All of the structures described below must start on a long word boundary
//  to maintain natural alignment.  Pad space can be inserted during the
//  write operation and the addresses adjusted without affecting the contents
//  of the structures.

#ifndef _CV_INFO_INCLUDED
#include "cvinfo.h"
#endif

#ifndef FAR
#if _M_IX86 >= 300
#define FAR
#else
#define FAR far
#endif
#endif


//  Type of subsection entry.

#define sstModule           0x120
#define sstTypes            0x121
#define sstPublic           0x122
#define sstPublicSym        0x123   // publics as symbol (waiting for link)
#define sstSymbols          0x124
#define sstAlignSym         0x125
#define sstSrcLnSeg         0x126   // because link doesn't emit SrcModule
#define sstSrcModule        0x127
#define sstLibraries        0x128
#define sstGlobalSym        0x129
#define sstGlobalPub        0x12a
#define sstGlobalTypes      0x12b
#define sstMPC              0x12c
#define sstSegMap           0x12d
#define sstSegName          0x12e
#define sstPreComp          0x12f   // precompiled types
#define sstPreCompMap       0x130   // map precompiled types in global types
#define sstOffsetMap16      0x131
#define sstOffsetMap32      0x132
#define sstFileIndex        0x133   // Index of file names
#define sstStaticSym        0x134

typedef enum OMFHash {
    OMFHASH_NONE,           // no hashing
    OMFHASH_SUMUC16,        // upper case sum of chars in 16 bit table
    OMFHASH_SUMUC32,        // upper case sum of chars in 32 bit table
    OMFHASH_ADDR16,         // sorted by increasing address in 16 bit table
    OMFHASH_ADDR32          // sorted by increasing address in 32 bit table
} OMFHASH;

//  CodeView Debug OMF signature.  The signature at the end of the file is
//  a negative offset from the end of the file to another signature.  At
//  the negative offset (base address) is another signature whose filepos
//  field points to the first OMFDirHeader in a chain of directories.
//  The NB05 signature is used by the link utility to indicated a completely
//  unpacked file.  The NB06 signature is used by ilink to indicate that the
//  executable has had CodeView information from an incremental link appended
//  to the executable.  The NB08 signature is used by cvpack to indicate that
//  the CodeView Debug OMF has been packed.  CodeView will only process
//  executables with the NB08 signature.


typedef struct OMFSignature {
    char            Signature[4];   // "NBxx"
    long            filepos;        // offset in file
} OMFSignature;



//  directory information structure
//  This structure contains the information describing the directory.
//  It is pointed to by the signature at the base address or the directory
//  link field of a preceeding directory.  The directory entries immediately
//  follow this structure.


typedef struct OMFDirHeader {
    unsigned short  cbDirHeader;    // length of this structure
    unsigned short  cbDirEntry;     // number of bytes in each directory entry
    unsigned long   cDir;           // number of directorie entries
    long            lfoNextDir;     // offset from base of next directory
    unsigned long   flags;          // status flags
} OMFDirHeader;




//  directory structure
//  The data in this structure is used to reference the data for each
//  subsection of the CodeView Debug OMF information.  Tables that are
//  not associated with a specific module will have a module index of
//  oxffff.  These tables are the global types table, the global symbol
//  table, the global public table and the library table.


typedef struct OMFDirEntry {
    unsigned short  SubSection;     // subsection type (sst...)
    unsigned short  iMod;           // module index
    long            lfo;            // large file offset of subsection
    unsigned long   cb;             // number of bytes in subsection
} OMFDirEntry;



//  information decribing each segment in a module

typedef struct OMFSegDesc {
    unsigned short  Seg;            // segment index
    unsigned short  pad;            // pad to maintain alignment
    unsigned long   Off;            // offset of code in segment
    unsigned long   cbSeg;          // number of bytes in segment
} OMFSegDesc;




//  per module information
//  There is one of these subsection entries for each module
//  in the executable.  The entry is generated by link/ilink.
//  This table will probably require padding because of the
//  variable length module name.

typedef struct OMFModule {
    unsigned short  ovlNumber;      // overlay number
    unsigned short  iLib;           // library that the module was linked from
    unsigned short  cSeg;           // count of number of segments in module
    char            Style[2];       // debugging style "CV"
    OMFSegDesc      SegInfo[1];     // describes segments in module
    char            Name[];         // length prefixed module name padded to
                                    // long word boundary
} OMFModule;



//  Symbol hash table format
//  This structure immediately preceeds the global publics table
//  and global symbol tables.

typedef struct  OMFSymHash {
    unsigned short  symhash;        // symbol hash function index
    unsigned short  addrhash;       // address hash function index
    unsigned long   cbSymbol;       // length of symbol information
    unsigned long   cbHSym;         // length of symbol hash data
    unsigned long   cbHAddr;        // length of address hashdata
} OMFSymHash;



//  Global types subsection format
//  This structure immediately preceeds the global types table.
//  The offsets in the typeOffset array are relative to the address
//  of ctypes.  Each type entry following the typeOffset array must
//  begin on a long word boundary.

typedef struct OMFTypeFlags {
    unsigned long   sig     :8;
    unsigned long   unused  :24;
} OMFTypeFlags;


typedef struct OMFGlobalTypes {
    OMFTypeFlags    flags;
    unsigned long   cTypes;         // number of types
    unsigned long   typeOffset[];   // array of offsets to types
} OMFGlobalTypes;




//  Precompiled types mapping table
//  This table should be ignored by all consumers except the incremental
//  packer.


typedef struct OMFPreCompMap {
    CV_typ_t        FirstType;      // first precompiled type index
    CV_typ_t        cTypes;         // number of precompiled types
    unsigned long   signature;      // precompiled types signature
    CV_typ_t        map[];          // mapping of precompiled types
} OMFPreCompMap;



//  Source line to address mapping table.
//  This table is generated by the link/ilink utility from line number
//  information contained in the object file OMF data.  This table contains
//  only the code contribution for one segment from one source file.


typedef struct OMFSourceLine {
    unsigned short  Seg;            // linker segment index
    unsigned short  cLnOff;         // count of line/offset pairs
    unsigned long   offset[1];      // array of offsets in segment
    unsigned short  lineNbr[1];     // array of line lumber in source
} OMFSourceLine;

typedef OMFSourceLine * LPSL;


//  Source file description
//  This table is generated by the linker


typedef struct OMFSourceFile {
    unsigned short  cSeg;           // number of segments from source file
    unsigned short  reserved;       // reserved
    unsigned long   baseSrcLn[1];   // base of OMFSourceLine tables
                                    // this array is followed by array
                                    // of segment start/end pairs followed by
                                    // an array of linker indices
                                    // for each segment in the file
    unsigned short  cFName;         // length of source file name
    char            Name;           // name of file padded to long boundary
} OMFSourceFile;

typedef OMFSourceFile * LPSF;


//  Source line to address mapping header structure
//  This structure describes the number and location of the
//  OMFAddrLine tables for a module.  The offSrcLine entries are
//  relative to the beginning of this structure.


typedef struct OMFSourceModule {
    unsigned short  cFile;          // number of OMFSourceTables
    unsigned short  cSeg;           // number of segments in module
    unsigned long   baseSrcFile[1]; // base of OMFSourceFile table
                                    // this array is followed by array
                                    // of segment start/end pairs followed
                                    // by an array of linker indices
                                    // for each segment in the module
} OMFSourceModule;

typedef OMFSourceModule * LPSM;

//  sstLibraries

typedef struct OMFLibrary {
    unsigned char   cbLibs;     // count of library names
    char            Libs[1];    // array of length prefixed lib names (first entry zero length)
} OMFLibrary;


// sstFileIndex - An index of all of the files contributing to an
//  executable.

typedef struct OMFFileIndex {
    unsigned short  cmodules;       // Number of modules
    unsigned short  cfilerefs;      // Number of file references
    unsigned short  modulelist[1];  // Index to beginning of list of files
                                    // for module i. (0 for module w/o files)
    unsigned short  cfiles[1];      // Number of file names associated
                                    // with module i.
    unsigned long   ulNames[1];     // Offsets from the beginning of this
                                    // table to the file names
    char            Names[];        // The length prefixed names of files
} OMFFileIndex;


//  Offset mapping table
//  This table provides a mapping from logical to physical offsets.
//  This mapping is applied between the logical to physical mapping
//  described by the seg map table.

typedef struct OMFOffsetMap16 {
    unsigned long   csegment;       // Count of physical segments

    // The next six items are repeated for each segment

    unsigned long   crangeLog;      // Count of logical offset ranges
    unsigned short  rgoffLog[1];    // Array of logical offsets
    short           rgbiasLog[1];   // Array of logical->physical bias
    unsigned long   crangePhys;     // Count of physical offset ranges
    unsigned short  rgoffPhys[1];   // Array of physical offsets
    short           rgbiasPhys[1];  // Array of physical->logical bias
} OMFOffsetMap16;

typedef struct OMFOffsetMap32 {
    unsigned long   csection;       // Count of physical sections

    // The next six items are repeated for each section

    unsigned long   crangeLog;      // Count of logical offset ranges
    unsigned long   rgoffLog[1];    // Array of logical offsets
    long            rgbiasLog[1];   // Array of logical->physical bias
    unsigned long   crangePhys;     // Count of physical offset ranges
    unsigned long   rgoffPhys[1];   // Array of physical offsets
    long            rgbiasPhys[1];  // Array of physical->logical bias
} OMFOffsetMap32;

//  Pcode support.  This subsection contains debug information generated
//  by the MPC utility used to process Pcode executables.  Currently
//  it contains a mapping table from segment index (zero based) to
//  frame paragraph.  MPC converts segmented exe's to non-segmented
//  exe's for DOS support.  To avoid backpatching all CV info, this
//  table is provided for the mapping.  Additional info may be provided
//  in the future for profiler support.

typedef struct OMFMpcDebugInfo {
    unsigned short  cSeg;       // number of segments in module
    unsigned short  mpSegFrame[1];  // map seg (zero based) to frame
} OMFMpcDebugInfo;

//  The following structures and constants describe the format of the
//  CodeView Debug OMF for linkers that emit executables with the NB02
//  signature.  Current utilities with the exception of cvpack and cvdump
//  will not accept or emit executables with the NB02 signature.  Cvdump
//  will dump an unpacked executable with the NB02 signature.  Cvpack will
//  read an executable with the NB02 signature but the packed executable
//  will be written with the table format, contents and signature of NB08.





//  subsection type constants

#define SSTMODULE       0x101   // Basic info. about object module
#define SSTPUBLIC       0x102   // Public symbols
#define SSTTYPES        0x103   // Type information
#define SSTSYMBOLS      0x104   // Symbol Data
#define SSTSRCLINES     0x105   // Source line information
#define SSTLIBRARIES    0x106   // Names of all library files used
#define SSTIMPORTS      0x107   // Symbols for DLL fixups
#define SSTCOMPACTED    0x108   // Compacted types section
#define SSTSRCLNSEG     0x109   // Same as source lines, contains segment


typedef struct DirEntry{
    unsigned short  SubSectionType;
    unsigned short  ModuleIndex;
    long            lfoStart;
    unsigned short  Size;
} DirEntry;


//  information decribing each segment in a module

typedef struct oldnsg {
    unsigned short  Seg;            // segment index
    unsigned short  Off;            // offset of code in segment
    unsigned short  cbSeg;          // number of bytes in segment
} oldnsg;


//   old subsection module information

typedef struct oldsmd {
    oldnsg          SegInfo;        // describes first segment in module
    unsigned short  ovlNbr;         // overlay number
    unsigned short  iLib;
    unsigned char   cSeg;           // Number of segments in module
    char            reserved;
    unsigned char   cbName[1];      // length prefixed name of module
    oldnsg          arnsg[];        // cSeg-1 structures exist for alloc text or comdat code
} oldsmd;

typedef struct{
    unsigned short  Seg;
    unsigned long   Off;
    unsigned long   cbSeg;
} oldnsg32;

typedef struct {
    oldnsg32        SegInfo;        // describes first segment in module
    unsigned short  ovlNbr;         // overlay number
    unsigned short  iLib;
    unsigned char   cSeg;           // Number of segments in module
    char            reserved;
    unsigned char   cbName[1];      // length prefixed name of module
    oldnsg32        arnsg[];        // cSeg-1 structures exist for alloc text or comdat code
} oldsmd32;


// OMFSegMap - This table contains the mapping between the logical segment indices
// used in the symbol table and the physical segments where the program is loaded

typedef struct OMFSegMapFlags {
    union {
        struct {
            unsigned short      fRead   :1;
            unsigned short      fWrite  :1;
            unsigned short      fExecute:1;
            unsigned short      f32Bit  :1;
            unsigned short      res1    :4;
            unsigned short      fSel    :1;
            unsigned short      fAbs    :1;
            unsigned short      res2    :2;
            unsigned short      fGroup  :1;  // OBSOLETE - do not use, debugger will assert
            unsigned short      res3    :3;
        };
        unsigned short fAll;
    };
} OMFSegMapFlags;

typedef struct OMFSegMapDesc {
    OMFSegMapFlags  flags;          // descriptor flags bit field.
    unsigned short  ovl;            // the logical overlay number
    unsigned short  group;          // group index into the descriptor array
    unsigned short  frame;          // logical segment index - interpreted via flags
    unsigned short  iSegName;       // segment or group name - index into sstSegName
    unsigned short  iClassName;     // class name - index into sstSegName
    unsigned long   offset;         // byte offset of the logical within the physical segment
    unsigned long   cbSeg;          // byte count of the logical segment or group
} OMFSegMapDesc;

typedef struct OMFSegMap {
    unsigned short  cSeg;           // total number of segment descriptors
    unsigned short  cSegLog;        // number of logical segment descriptors
    OMFSegMapDesc   rgDesc[0];      // array of segment descriptors
} OMFSegMap;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\vs\cvinfo.h ===
/***    cvinfo.h - Generic CodeView information definitions
 *
 *      Structures, constants, etc. for accessing and interpreting
 *      CodeView information.
 *
 */


/***    The master copy of this file resides in the langapi project.
 *      All Microsoft projects are required to use the master copy without
 *      modification.  Modification of the master version or a copy
 *      without consultation with all parties concerned is extremely
 *      risky.
 *
 *      When this file is modified, the corresponding documentation file
 *      omfdeb.doc in the langapi project must be updated.
 */

#ifndef _VC_VER_INC
#include "..\include\vcver.h"
#endif

#pragma once

#include "cvconst.h"

#ifndef _CV_INFO_INCLUDED
#define _CV_INFO_INCLUDED

#ifdef  __cplusplus
#pragma warning ( disable: 4200 )
#endif

#ifndef __INLINE
#ifdef  __cplusplus
#define __INLINE inline
#else
#define __INLINE __inline
#endif
#endif

#pragma pack ( push, 1 )
typedef unsigned long   CV_uoff32_t;
typedef          long   CV_off32_t;
typedef unsigned short  CV_uoff16_t;
typedef          short  CV_off16_t;
typedef unsigned short  CV_typ16_t;
typedef unsigned long   CV_typ_t;
typedef unsigned long   CV_pubsymflag_t;    // must be same as CV_typ_t.
typedef unsigned short  _2BYTEPAD;
typedef unsigned long   CV_tkn_t;

#if !defined (CV_ZEROLEN)
#define CV_ZEROLEN
#endif

#if !defined (FLOAT10)
#if defined(_M_I86)                    // 16 bit x86 supporting long double
typedef long double FLOAT10;
#else                                  // 32 bit w/o long double support
typedef struct FLOAT10
{
    char b[10];
} FLOAT10;
#endif
#endif


#define CV_SIGNATURE_C6         0L  // Actual signature is >64K
#define CV_SIGNATURE_C7         1L  // First explicit signature
#define CV_SIGNATURE_C11        2L  // C11 (vc5.x) 32-bit types
#define CV_SIGNATURE_C13        4L  // C13 (vc7.x) zero terminated names
#define CV_SIGNATURE_RESERVED   5L  // All signatures from 5 to 64K are reserved

#define CV_MAXOFFSET   0xffffffff

#ifndef GUID_DEFINED
#define GUID_DEFINED

typedef struct _GUID {          // size is 16
    unsigned long   Data1;
    unsigned short  Data2;
    unsigned short  Data3;
    unsigned char   Data4[8];
} GUID;

#endif // !GUID_DEFINED

typedef GUID            SIG70;      // new to 7.0 are 16-byte guid-like signatures
typedef SIG70 *         PSIG70;
typedef const SIG70 *   PCSIG70;



/**     CodeView Symbol and Type OMF type information is broken up into two
 *      ranges.  Type indices less than 0x1000 describe type information
 *      that is frequently used.  Type indices above 0x1000 are used to
 *      describe more complex features such as functions, arrays and
 *      structures.
 */




/**     Primitive types have predefined meaning that is encoded in the
 *      values of the various bit fields in the value.
 *
 *      A CodeView primitive type is defined as:
 *
 *      1 1
 *      1 089  7654  3  210
 *      r mode type  r  sub
 *
 *      Where
 *          mode is the pointer mode
 *          type is a type indicator
 *          sub  is a subtype enumeration
 *          r    is a reserved field
 *
 *      See Microsoft Symbol and Type OMF (Version 4.0) for more
 *      information.
 */


#define CV_MMASK        0x700       // mode mask
#define CV_TMASK        0x0f0       // type mask

// can we use the reserved bit ??
#define CV_SMASK        0x00f       // subtype mask

#define CV_MSHIFT       8           // primitive mode right shift count
#define CV_TSHIFT       4           // primitive type right shift count
#define CV_SSHIFT       0           // primitive subtype right shift count

// macros to extract primitive mode, type and size

#define CV_MODE(typ)    (((typ) & CV_MMASK) >> CV_MSHIFT)
#define CV_TYPE(typ)    (((typ) & CV_TMASK) >> CV_TSHIFT)
#define CV_SUBT(typ)    (((typ) & CV_SMASK) >> CV_SSHIFT)

// macros to insert new primitive mode, type and size

#define CV_NEWMODE(typ, nm)     ((CV_typ_t)(((typ) & ~CV_MMASK) | ((nm) << CV_MSHIFT)))
#define CV_NEWTYPE(typ, nt)     (((typ) & ~CV_TMASK) | ((nt) << CV_TSHIFT))
#define CV_NEWSUBT(typ, ns)     (((typ) & ~CV_SMASK) | ((ns) << CV_SSHIFT))



//     pointer mode enumeration values

typedef enum CV_prmode_e {
    CV_TM_DIRECT = 0,       // mode is not a pointer
    CV_TM_NPTR   = 1,       // mode is a near pointer
    CV_TM_FPTR   = 2,       // mode is a far pointer
    CV_TM_HPTR   = 3,       // mode is a huge pointer
    CV_TM_NPTR32 = 4,       // mode is a 32 bit near pointer
    CV_TM_FPTR32 = 5,       // mode is a 32 bit far pointer
    CV_TM_NPTR64 = 6,       // mode is a 64 bit near pointer
    CV_TM_NPTR128 = 7,      // mode is a 128 bit near pointer
} CV_prmode_e;




//      type enumeration values


typedef enum CV_type_e {
    CV_SPECIAL      = 0x00,         // special type size values
    CV_SIGNED       = 0x01,         // signed integral size values
    CV_UNSIGNED     = 0x02,         // unsigned integral size values
    CV_BOOLEAN      = 0x03,         // Boolean size values
    CV_REAL         = 0x04,         // real number size values
    CV_COMPLEX      = 0x05,         // complex number size values
    CV_SPECIAL2     = 0x06,         // second set of special types
    CV_INT          = 0x07,         // integral (int) values
    CV_CVRESERVED   = 0x0f,
} CV_type_e;




//      subtype enumeration values for CV_SPECIAL


typedef enum CV_special_e {
    CV_SP_NOTYPE    = 0x00,
    CV_SP_ABS       = 0x01,
    CV_SP_SEGMENT   = 0x02,
    CV_SP_VOID      = 0x03,
    CV_SP_CURRENCY  = 0x04,
    CV_SP_NBASICSTR = 0x05,
    CV_SP_FBASICSTR = 0x06,
    CV_SP_NOTTRANS  = 0x07,
    CV_SP_HRESULT   = 0x08,
} CV_special_e;




//      subtype enumeration values for CV_SPECIAL2


typedef enum CV_special2_e {
    CV_S2_BIT       = 0x00,
    CV_S2_PASCHAR   = 0x01          // Pascal CHAR
} CV_special2_e;





//      subtype enumeration values for CV_SIGNED, CV_UNSIGNED and CV_BOOLEAN


typedef enum CV_integral_e {
    CV_IN_1BYTE     = 0x00,
    CV_IN_2BYTE     = 0x01,
    CV_IN_4BYTE     = 0x02,
    CV_IN_8BYTE     = 0x03,
    CV_IN_16BYTE    = 0x04
} CV_integral_e;





//      subtype enumeration values for CV_REAL and CV_COMPLEX


typedef enum CV_real_e {
    CV_RC_REAL32    = 0x00,
    CV_RC_REAL64    = 0x01,
    CV_RC_REAL80    = 0x02,
    CV_RC_REAL128   = 0x03,
    CV_RC_REAL48    = 0x04
} CV_real_e;




//      subtype enumeration values for CV_INT (really int)


typedef enum CV_int_e {
    CV_RI_CHAR      = 0x00,
    CV_RI_INT1      = 0x00,
    CV_RI_WCHAR     = 0x01,
    CV_RI_UINT1     = 0x01,
    CV_RI_INT2      = 0x02,
    CV_RI_UINT2     = 0x03,
    CV_RI_INT4      = 0x04,
    CV_RI_UINT4     = 0x05,
    CV_RI_INT8      = 0x06,
    CV_RI_UINT8     = 0x07,
    CV_RI_INT16     = 0x08,
    CV_RI_UINT16    = 0x09
} CV_int_e;




// macros to check the type of a primitive

#define CV_TYP_IS_DIRECT(typ)   (CV_MODE(typ) == CV_TM_DIRECT)
#define CV_TYP_IS_PTR(typ)      (CV_MODE(typ) != CV_TM_DIRECT)
#define CV_TYP_IS_NPTR(typ)     (CV_MODE(typ) == CV_TM_NPTR)
#define CV_TYP_IS_FPTR(typ)     (CV_MODE(typ) == CV_TM_FPTR)
#define CV_TYP_IS_HPTR(typ)     (CV_MODE(typ) == CV_TM_HPTR)
#define CV_TYP_IS_NPTR32(typ)   (CV_MODE(typ) == CV_TM_NPTR32)
#define CV_TYP_IS_FPTR32(typ)   (CV_MODE(typ) == CV_TM_FPTR32)

#define CV_TYP_IS_SIGNED(typ)   (((CV_TYPE(typ) == CV_SIGNED) && CV_TYP_IS_DIRECT(typ)) || \
                                 (typ == T_INT1)  || \
                                 (typ == T_INT2)  || \
                                 (typ == T_INT4)  || \
                                 (typ == T_INT8)  || \
                                 (typ == T_INT16) || \
                                 (typ == T_RCHAR))

#define CV_TYP_IS_UNSIGNED(typ) (((CV_TYPE(typ) == CV_UNSIGNED) && CV_TYP_IS_DIRECT(typ)) || \
                                 (typ == T_UINT1) || \
                                 (typ == T_UINT2) || \
                                 (typ == T_UINT4) || \
                                 (typ == T_UINT8) || \
                                 (typ == T_UINT16))

#define CV_TYP_IS_REAL(typ)     ((CV_TYPE(typ) == CV_REAL)  && CV_TYP_IS_DIRECT(typ))

#define CV_FIRST_NONPRIM 0x1000
#define CV_IS_PRIMITIVE(typ)    ((typ) < CV_FIRST_NONPRIM)
#define CV_TYP_IS_COMPLEX(typ)  ((CV_TYPE(typ) == CV_COMPLEX)   && CV_TYP_IS_DIRECT(typ))
#define CV_IS_INTERNAL_PTR(typ) (CV_IS_PRIMITIVE(typ) && \
                                 CV_TYPE(typ) == CV_CVRESERVED && \
                                 CV_TYP_IS_PTR(typ))






// selected values for type_index - for a more complete definition, see
// Microsoft Symbol and Type OMF document




//      Special Types

typedef enum TYPE_ENUM_e {
//      Special Types

    T_NOTYPE        = 0x0000,   // uncharacterized type (no type)
    T_ABS           = 0x0001,   // absolute symbol
    T_SEGMENT       = 0x0002,   // segment type
    T_VOID          = 0x0003,   // void
    T_HRESULT       = 0x0008,   // OLE/COM HRESULT
    T_32PHRESULT    = 0x0408,   // OLE/COM HRESULT __ptr32 *
    T_64PHRESULT    = 0x0608,   // OLE/COM HRESULT __ptr64 *
    T_PVOID         = 0x0103,   // near pointer to void
    T_PFVOID        = 0x0203,   // far pointer to void
    T_PHVOID        = 0x0303,   // huge pointer to void
    T_32PVOID       = 0x0403,   // 32 bit pointer to void
    T_32PFVOID      = 0x0503,   // 16:32 pointer to void
    T_64PVOID       = 0x0603,   // 64 bit pointer to void
    T_CURRENCY      = 0x0004,   // BASIC 8 byte currency value
    T_NBASICSTR     = 0x0005,   // Near BASIC string
    T_FBASICSTR     = 0x0006,   // Far BASIC string
    T_NOTTRANS      = 0x0007,   // type not translated by cvpack
    T_BIT           = 0x0060,   // bit
    T_PASCHAR       = 0x0061,   // Pascal CHAR


//      Character types

    T_CHAR          = 0x0010,   // 8 bit signed
    T_PCHAR         = 0x0110,   // 16 bit pointer to 8 bit signed
    T_PFCHAR        = 0x0210,   // 16:16 far pointer to 8 bit signed
    T_PHCHAR        = 0x0310,   // 16:16 huge pointer to 8 bit signed
    T_32PCHAR       = 0x0410,   // 32 bit pointer to 8 bit signed
    T_32PFCHAR      = 0x0510,   // 16:32 pointer to 8 bit signed
    T_64PCHAR       = 0x0610,   // 64 bit pointer to 8 bit signed

    T_UCHAR         = 0x0020,   // 8 bit unsigned
    T_PUCHAR        = 0x0120,   // 16 bit pointer to 8 bit unsigned
    T_PFUCHAR       = 0x0220,   // 16:16 far pointer to 8 bit unsigned
    T_PHUCHAR       = 0x0320,   // 16:16 huge pointer to 8 bit unsigned
    T_32PUCHAR      = 0x0420,   // 32 bit pointer to 8 bit unsigned
    T_32PFUCHAR     = 0x0520,   // 16:32 pointer to 8 bit unsigned
    T_64PUCHAR      = 0x0620,   // 64 bit pointer to 8 bit unsigned


//      really a character types

    T_RCHAR         = 0x0070,   // really a char
    T_PRCHAR        = 0x0170,   // 16 bit pointer to a real char
    T_PFRCHAR       = 0x0270,   // 16:16 far pointer to a real char
    T_PHRCHAR       = 0x0370,   // 16:16 huge pointer to a real char
    T_32PRCHAR      = 0x0470,   // 32 bit pointer to a real char
    T_32PFRCHAR     = 0x0570,   // 16:32 pointer to a real char
    T_64PRCHAR      = 0x0670,   // 64 bit pointer to a real char


//      really a wide character types

    T_WCHAR         = 0x0071,   // wide char
    T_PWCHAR        = 0x0171,   // 16 bit pointer to a wide char
    T_PFWCHAR       = 0x0271,   // 16:16 far pointer to a wide char
    T_PHWCHAR       = 0x0371,   // 16:16 huge pointer to a wide char
    T_32PWCHAR      = 0x0471,   // 32 bit pointer to a wide char
    T_32PFWCHAR     = 0x0571,   // 16:32 pointer to a wide char
    T_64PWCHAR      = 0x0671,   // 64 bit pointer to a wide char


//      8 bit int types

    T_INT1          = 0x0068,   // 8 bit signed int
    T_PINT1         = 0x0168,   // 16 bit pointer to 8 bit signed int
    T_PFINT1        = 0x0268,   // 16:16 far pointer to 8 bit signed int
    T_PHINT1        = 0x0368,   // 16:16 huge pointer to 8 bit signed int
    T_32PINT1       = 0x0468,   // 32 bit pointer to 8 bit signed int
    T_32PFINT1      = 0x0568,   // 16:32 pointer to 8 bit signed int
    T_64PINT1       = 0x0668,   // 64 bit pointer to 8 bit signed int

    T_UINT1         = 0x0069,   // 8 bit unsigned int
    T_PUINT1        = 0x0169,   // 16 bit pointer to 8 bit unsigned int
    T_PFUINT1       = 0x0269,   // 16:16 far pointer to 8 bit unsigned int
    T_PHUINT1       = 0x0369,   // 16:16 huge pointer to 8 bit unsigned int
    T_32PUINT1      = 0x0469,   // 32 bit pointer to 8 bit unsigned int
    T_32PFUINT1     = 0x0569,   // 16:32 pointer to 8 bit unsigned int
    T_64PUINT1      = 0x0669,   // 64 bit pointer to 8 bit unsigned int


//      16 bit short types

    T_SHORT         = 0x0011,   // 16 bit signed
    T_PSHORT        = 0x0111,   // 16 bit pointer to 16 bit signed
    T_PFSHORT       = 0x0211,   // 16:16 far pointer to 16 bit signed
    T_PHSHORT       = 0x0311,   // 16:16 huge pointer to 16 bit signed
    T_32PSHORT      = 0x0411,   // 32 bit pointer to 16 bit signed
    T_32PFSHORT     = 0x0511,   // 16:32 pointer to 16 bit signed
    T_64PSHORT      = 0x0611,   // 64 bit pointer to 16 bit signed

    T_USHORT        = 0x0021,   // 16 bit unsigned
    T_PUSHORT       = 0x0121,   // 16 bit pointer to 16 bit unsigned
    T_PFUSHORT      = 0x0221,   // 16:16 far pointer to 16 bit unsigned
    T_PHUSHORT      = 0x0321,   // 16:16 huge pointer to 16 bit unsigned
    T_32PUSHORT     = 0x0421,   // 32 bit pointer to 16 bit unsigned
    T_32PFUSHORT    = 0x0521,   // 16:32 pointer to 16 bit unsigned
    T_64PUSHORT     = 0x0621,   // 64 bit pointer to 16 bit unsigned


//      16 bit int types

    T_INT2          = 0x0072,   // 16 bit signed int
    T_PINT2         = 0x0172,   // 16 bit pointer to 16 bit signed int
    T_PFINT2        = 0x0272,   // 16:16 far pointer to 16 bit signed int
    T_PHINT2        = 0x0372,   // 16:16 huge pointer to 16 bit signed int
    T_32PINT2       = 0x0472,   // 32 bit pointer to 16 bit signed int
    T_32PFINT2      = 0x0572,   // 16:32 pointer to 16 bit signed int
    T_64PINT2       = 0x0672,   // 64 bit pointer to 16 bit signed int

    T_UINT2         = 0x0073,   // 16 bit unsigned int
    T_PUINT2        = 0x0173,   // 16 bit pointer to 16 bit unsigned int
    T_PFUINT2       = 0x0273,   // 16:16 far pointer to 16 bit unsigned int
    T_PHUINT2       = 0x0373,   // 16:16 huge pointer to 16 bit unsigned int
    T_32PUINT2      = 0x0473,   // 32 bit pointer to 16 bit unsigned int
    T_32PFUINT2     = 0x0573,   // 16:32 pointer to 16 bit unsigned int
    T_64PUINT2      = 0x0673,   // 64 bit pointer to 16 bit unsigned int


//      32 bit long types

    T_LONG          = 0x0012,   // 32 bit signed
    T_ULONG         = 0x0022,   // 32 bit unsigned
    T_PLONG         = 0x0112,   // 16 bit pointer to 32 bit signed
    T_PULONG        = 0x0122,   // 16 bit pointer to 32 bit unsigned
    T_PFLONG        = 0x0212,   // 16:16 far pointer to 32 bit signed
    T_PFULONG       = 0x0222,   // 16:16 far pointer to 32 bit unsigned
    T_PHLONG        = 0x0312,   // 16:16 huge pointer to 32 bit signed
    T_PHULONG       = 0x0322,   // 16:16 huge pointer to 32 bit unsigned

    T_32PLONG       = 0x0412,   // 32 bit pointer to 32 bit signed
    T_32PULONG      = 0x0422,   // 32 bit pointer to 32 bit unsigned
    T_32PFLONG      = 0x0512,   // 16:32 pointer to 32 bit signed
    T_32PFULONG     = 0x0522,   // 16:32 pointer to 32 bit unsigned
    T_64PLONG       = 0x0612,   // 64 bit pointer to 32 bit signed
    T_64PULONG      = 0x0622,   // 64 bit pointer to 32 bit unsigned


//      32 bit int types

    T_INT4          = 0x0074,   // 32 bit signed int
    T_PINT4         = 0x0174,   // 16 bit pointer to 32 bit signed int
    T_PFINT4        = 0x0274,   // 16:16 far pointer to 32 bit signed int
    T_PHINT4        = 0x0374,   // 16:16 huge pointer to 32 bit signed int
    T_32PINT4       = 0x0474,   // 32 bit pointer to 32 bit signed int
    T_32PFINT4      = 0x0574,   // 16:32 pointer to 32 bit signed int
    T_64PINT4       = 0x0674,   // 64 bit pointer to 32 bit signed int

    T_UINT4         = 0x0075,   // 32 bit unsigned int
    T_PUINT4        = 0x0175,   // 16 bit pointer to 32 bit unsigned int
    T_PFUINT4       = 0x0275,   // 16:16 far pointer to 32 bit unsigned int
    T_PHUINT4       = 0x0375,   // 16:16 huge pointer to 32 bit unsigned int
    T_32PUINT4      = 0x0475,   // 32 bit pointer to 32 bit unsigned int
    T_32PFUINT4     = 0x0575,   // 16:32 pointer to 32 bit unsigned int
    T_64PUINT4      = 0x0675,   // 64 bit pointer to 32 bit unsigned int


//      64 bit quad types

    T_QUAD          = 0x0013,   // 64 bit signed
    T_PQUAD         = 0x0113,   // 16 bit pointer to 64 bit signed
    T_PFQUAD        = 0x0213,   // 16:16 far pointer to 64 bit signed
    T_PHQUAD        = 0x0313,   // 16:16 huge pointer to 64 bit signed
    T_32PQUAD       = 0x0413,   // 32 bit pointer to 64 bit signed
    T_32PFQUAD      = 0x0513,   // 16:32 pointer to 64 bit signed
    T_64PQUAD       = 0x0613,   // 64 bit pointer to 64 bit signed

    T_UQUAD         = 0x0023,   // 64 bit unsigned
    T_PUQUAD        = 0x0123,   // 16 bit pointer to 64 bit unsigned
    T_PFUQUAD       = 0x0223,   // 16:16 far pointer to 64 bit unsigned
    T_PHUQUAD       = 0x0323,   // 16:16 huge pointer to 64 bit unsigned
    T_32PUQUAD      = 0x0423,   // 32 bit pointer to 64 bit unsigned
    T_32PFUQUAD     = 0x0523,   // 16:32 pointer to 64 bit unsigned
    T_64PUQUAD      = 0x0623,   // 64 bit pointer to 64 bit unsigned


//      64 bit int types

    T_INT8          = 0x0076,   // 64 bit signed int
    T_PINT8         = 0x0176,   // 16 bit pointer to 64 bit signed int
    T_PFINT8        = 0x0276,   // 16:16 far pointer to 64 bit signed int
    T_PHINT8        = 0x0376,   // 16:16 huge pointer to 64 bit signed int
    T_32PINT8       = 0x0476,   // 32 bit pointer to 64 bit signed int
    T_32PFINT8      = 0x0576,   // 16:32 pointer to 64 bit signed int
    T_64PINT8       = 0x0676,   // 64 bit pointer to 64 bit signed int

    T_UINT8         = 0x0077,   // 64 bit unsigned int
    T_PUINT8        = 0x0177,   // 16 bit pointer to 64 bit unsigned int
    T_PFUINT8       = 0x0277,   // 16:16 far pointer to 64 bit unsigned int
    T_PHUINT8       = 0x0377,   // 16:16 huge pointer to 64 bit unsigned int
    T_32PUINT8      = 0x0477,   // 32 bit pointer to 64 bit unsigned int
    T_32PFUINT8     = 0x0577,   // 16:32 pointer to 64 bit unsigned int
    T_64PUINT8      = 0x0677,   // 64 bit pointer to 64 bit unsigned int


//      128 bit octet types

    T_OCT           = 0x0014,   // 128 bit signed
    T_POCT          = 0x0114,   // 16 bit pointer to 128 bit signed
    T_PFOCT         = 0x0214,   // 16:16 far pointer to 128 bit signed
    T_PHOCT         = 0x0314,   // 16:16 huge pointer to 128 bit signed
    T_32POCT        = 0x0414,   // 32 bit pointer to 128 bit signed
    T_32PFOCT       = 0x0514,   // 16:32 pointer to 128 bit signed
    T_64POCT        = 0x0614,   // 64 bit pointer to 128 bit signed

    T_UOCT          = 0x0024,   // 128 bit unsigned
    T_PUOCT         = 0x0124,   // 16 bit pointer to 128 bit unsigned
    T_PFUOCT        = 0x0224,   // 16:16 far pointer to 128 bit unsigned
    T_PHUOCT        = 0x0324,   // 16:16 huge pointer to 128 bit unsigned
    T_32PUOCT       = 0x0424,   // 32 bit pointer to 128 bit unsigned
    T_32PFUOCT      = 0x0524,   // 16:32 pointer to 128 bit unsigned
    T_64PUOCT       = 0x0624,   // 64 bit pointer to 128 bit unsigned


//      128 bit int types

    T_INT16         = 0x0078,   // 128 bit signed int
    T_PINT16        = 0x0178,   // 16 bit pointer to 128 bit signed int
    T_PFINT16       = 0x0278,   // 16:16 far pointer to 128 bit signed int
    T_PHINT16       = 0x0378,   // 16:16 huge pointer to 128 bit signed int
    T_32PINT16      = 0x0478,   // 32 bit pointer to 128 bit signed int
    T_32PFINT16     = 0x0578,   // 16:32 pointer to 128 bit signed int
    T_64PINT16      = 0x0678,   // 64 bit pointer to 128 bit signed int

    T_UINT16        = 0x0079,   // 128 bit unsigned int
    T_PUINT16       = 0x0179,   // 16 bit pointer to 128 bit unsigned int
    T_PFUINT16      = 0x0279,   // 16:16 far pointer to 128 bit unsigned int
    T_PHUINT16      = 0x0379,   // 16:16 huge pointer to 128 bit unsigned int
    T_32PUINT16     = 0x0479,   // 32 bit pointer to 128 bit unsigned int
    T_32PFUINT16    = 0x0579,   // 16:32 pointer to 128 bit unsigned int
    T_64PUINT16     = 0x0679,   // 64 bit pointer to 128 bit unsigned int


//      32 bit real types

    T_REAL32        = 0x0040,   // 32 bit real
    T_PREAL32       = 0x0140,   // 16 bit pointer to 32 bit real
    T_PFREAL32      = 0x0240,   // 16:16 far pointer to 32 bit real
    T_PHREAL32      = 0x0340,   // 16:16 huge pointer to 32 bit real
    T_32PREAL32     = 0x0440,   // 32 bit pointer to 32 bit real
    T_32PFREAL32    = 0x0540,   // 16:32 pointer to 32 bit real
    T_64PREAL32     = 0x0640,   // 64 bit pointer to 32 bit real


//      48 bit real types

    T_REAL48        = 0x0044,   // 48 bit real
    T_PREAL48       = 0x0144,   // 16 bit pointer to 48 bit real
    T_PFREAL48      = 0x0244,   // 16:16 far pointer to 48 bit real
    T_PHREAL48      = 0x0344,   // 16:16 huge pointer to 48 bit real
    T_32PREAL48     = 0x0444,   // 32 bit pointer to 48 bit real
    T_32PFREAL48    = 0x0544,   // 16:32 pointer to 48 bit real
    T_64PREAL48     = 0x0644,   // 64 bit pointer to 48 bit real


//      64 bit real types

    T_REAL64        = 0x0041,   // 64 bit real
    T_PREAL64       = 0x0141,   // 16 bit pointer to 64 bit real
    T_PFREAL64      = 0x0241,   // 16:16 far pointer to 64 bit real
    T_PHREAL64      = 0x0341,   // 16:16 huge pointer to 64 bit real
    T_32PREAL64     = 0x0441,   // 32 bit pointer to 64 bit real
    T_32PFREAL64    = 0x0541,   // 16:32 pointer to 64 bit real
    T_64PREAL64     = 0x0641,   // 64 bit pointer to 64 bit real


//      80 bit real types

    T_REAL80        = 0x0042,   // 80 bit real
    T_PREAL80       = 0x0142,   // 16 bit pointer to 80 bit real
    T_PFREAL80      = 0x0242,   // 16:16 far pointer to 80 bit real
    T_PHREAL80      = 0x0342,   // 16:16 huge pointer to 80 bit real
    T_32PREAL80     = 0x0442,   // 32 bit pointer to 80 bit real
    T_32PFREAL80    = 0x0542,   // 16:32 pointer to 80 bit real
    T_64PREAL80     = 0x0642,   // 64 bit pointer to 80 bit real


//      128 bit real types

    T_REAL128       = 0x0043,   // 128 bit real
    T_PREAL128      = 0x0143,   // 16 bit pointer to 128 bit real
    T_PFREAL128     = 0x0243,   // 16:16 far pointer to 128 bit real
    T_PHREAL128     = 0x0343,   // 16:16 huge pointer to 128 bit real
    T_32PREAL128    = 0x0443,   // 32 bit pointer to 128 bit real
    T_32PFREAL128   = 0x0543,   // 16:32 pointer to 128 bit real
    T_64PREAL128    = 0x0643,   // 64 bit pointer to 128 bit real


//      32 bit complex types

    T_CPLX32        = 0x0050,   // 32 bit complex
    T_PCPLX32       = 0x0150,   // 16 bit pointer to 32 bit complex
    T_PFCPLX32      = 0x0250,   // 16:16 far pointer to 32 bit complex
    T_PHCPLX32      = 0x0350,   // 16:16 huge pointer to 32 bit complex
    T_32PCPLX32     = 0x0450,   // 32 bit pointer to 32 bit complex
    T_32PFCPLX32    = 0x0550,   // 16:32 pointer to 32 bit complex
    T_64PCPLX32     = 0x0650,   // 64 bit pointer to 32 bit complex


//      64 bit complex types

    T_CPLX64        = 0x0051,   // 64 bit complex
    T_PCPLX64       = 0x0151,   // 16 bit pointer to 64 bit complex
    T_PFCPLX64      = 0x0251,   // 16:16 far pointer to 64 bit complex
    T_PHCPLX64      = 0x0351,   // 16:16 huge pointer to 64 bit complex
    T_32PCPLX64     = 0x0451,   // 32 bit pointer to 64 bit complex
    T_32PFCPLX64    = 0x0551,   // 16:32 pointer to 64 bit complex
    T_64PCPLX64     = 0x0651,   // 64 bit pointer to 64 bit complex


//      80 bit complex types

    T_CPLX80        = 0x0052,   // 80 bit complex
    T_PCPLX80       = 0x0152,   // 16 bit pointer to 80 bit complex
    T_PFCPLX80      = 0x0252,   // 16:16 far pointer to 80 bit complex
    T_PHCPLX80      = 0x0352,   // 16:16 huge pointer to 80 bit complex
    T_32PCPLX80     = 0x0452,   // 32 bit pointer to 80 bit complex
    T_32PFCPLX80    = 0x0552,   // 16:32 pointer to 80 bit complex
    T_64PCPLX80     = 0x0652,   // 64 bit pointer to 80 bit complex


//      128 bit complex types

    T_CPLX128       = 0x0053,   // 128 bit complex
    T_PCPLX128      = 0x0153,   // 16 bit pointer to 128 bit complex
    T_PFCPLX128     = 0x0253,   // 16:16 far pointer to 128 bit complex
    T_PHCPLX128     = 0x0353,   // 16:16 huge pointer to 128 bit real
    T_32PCPLX128    = 0x0453,   // 32 bit pointer to 128 bit complex
    T_32PFCPLX128   = 0x0553,   // 16:32 pointer to 128 bit complex
    T_64PCPLX128    = 0x0653,   // 64 bit pointer to 128 bit complex


//      boolean types

    T_BOOL08        = 0x0030,   // 8 bit boolean
    T_PBOOL08       = 0x0130,   // 16 bit pointer to  8 bit boolean
    T_PFBOOL08      = 0x0230,   // 16:16 far pointer to  8 bit boolean
    T_PHBOOL08      = 0x0330,   // 16:16 huge pointer to  8 bit boolean
    T_32PBOOL08     = 0x0430,   // 32 bit pointer to 8 bit boolean
    T_32PFBOOL08    = 0x0530,   // 16:32 pointer to 8 bit boolean
    T_64PBOOL08     = 0x0630,   // 64 bit pointer to 8 bit boolean

    T_BOOL16        = 0x0031,   // 16 bit boolean
    T_PBOOL16       = 0x0131,   // 16 bit pointer to 16 bit boolean
    T_PFBOOL16      = 0x0231,   // 16:16 far pointer to 16 bit boolean
    T_PHBOOL16      = 0x0331,   // 16:16 huge pointer to 16 bit boolean
    T_32PBOOL16     = 0x0431,   // 32 bit pointer to 18 bit boolean
    T_32PFBOOL16    = 0x0531,   // 16:32 pointer to 16 bit boolean
    T_64PBOOL16     = 0x0631,   // 64 bit pointer to 18 bit boolean

    T_BOOL32        = 0x0032,   // 32 bit boolean
    T_PBOOL32       = 0x0132,   // 16 bit pointer to 32 bit boolean
    T_PFBOOL32      = 0x0232,   // 16:16 far pointer to 32 bit boolean
    T_PHBOOL32      = 0x0332,   // 16:16 huge pointer to 32 bit boolean
    T_32PBOOL32     = 0x0432,   // 32 bit pointer to 32 bit boolean
    T_32PFBOOL32    = 0x0532,   // 16:32 pointer to 32 bit boolean
    T_64PBOOL32     = 0x0632,   // 64 bit pointer to 32 bit boolean

    T_BOOL64        = 0x0033,   // 64 bit boolean
    T_PBOOL64       = 0x0133,   // 16 bit pointer to 64 bit boolean
    T_PFBOOL64      = 0x0233,   // 16:16 far pointer to 64 bit boolean
    T_PHBOOL64      = 0x0333,   // 16:16 huge pointer to 64 bit boolean
    T_32PBOOL64     = 0x0433,   // 32 bit pointer to 64 bit boolean
    T_32PFBOOL64    = 0x0533,   // 16:32 pointer to 64 bit boolean
    T_64PBOOL64     = 0x0633,   // 64 bit pointer to 64 bit boolean


//      ???

    T_NCVPTR        = 0x01f0,   // CV Internal type for created near pointers
    T_FCVPTR        = 0x02f0,   // CV Internal type for created far pointers
    T_HCVPTR        = 0x03f0,   // CV Internal type for created huge pointers
    T_32NCVPTR      = 0x04f0,   // CV Internal type for created near 32-bit pointers
    T_32FCVPTR      = 0x05f0,   // CV Internal type for created far 32-bit pointers
    T_64NCVPTR      = 0x06f0,   // CV Internal type for created near 64-bit pointers

} TYPE_ENUM_e;

/**     No leaf index can have a value of 0x0000.  The leaf indices are
 *      separated into ranges depending upon the use of the type record.
 *      The second range is for the type records that are directly referenced
 *      in symbols. The first range is for type records that are not
 *      referenced by symbols but instead are referenced by other type
 *      records.  All type records must have a starting leaf index in these
 *      first two ranges.  The third range of leaf indices are used to build
 *      up complex lists such as the field list of a class type record.  No
 *      type record can begin with one of the leaf indices. The fourth ranges
 *      of type indices are used to represent numeric data in a symbol or
 *      type record. These leaf indices are greater than 0x8000.  At the
 *      point that type or symbol processor is expecting a numeric field, the
 *      next two bytes in the type record are examined.  If the value is less
 *      than 0x8000, then the two bytes contain the numeric value.  If the
 *      value is greater than 0x8000, then the data follows the leaf index in
 *      a format specified by the leaf index. The final range of leaf indices
 *      are used to force alignment of subfields within a complex type record..
 */


typedef enum LEAF_ENUM_e {
    // leaf indices starting records but referenced from symbol records

    LF_MODIFIER_16t     = 0x0001,
    LF_POINTER_16t      = 0x0002,
    LF_ARRAY_16t        = 0x0003,
    LF_CLASS_16t        = 0x0004,
    LF_STRUCTURE_16t    = 0x0005,
    LF_UNION_16t        = 0x0006,
    LF_ENUM_16t         = 0x0007,
    LF_PROCEDURE_16t    = 0x0008,
    LF_MFUNCTION_16t    = 0x0009,
    LF_VTSHAPE          = 0x000a,
    LF_COBOL0_16t       = 0x000b,
    LF_COBOL1           = 0x000c,
    LF_BARRAY_16t       = 0x000d,
    LF_LABEL            = 0x000e,
    LF_NULL             = 0x000f,
    LF_NOTTRAN          = 0x0010,
    LF_DIMARRAY_16t     = 0x0011,
    LF_VFTPATH_16t      = 0x0012,
    LF_PRECOMP_16t      = 0x0013,       // not referenced from symbol
    LF_ENDPRECOMP       = 0x0014,       // not referenced from symbol
    LF_OEM_16t          = 0x0015,       // oem definable type string
#ifdef LNGNM
    LF_TYPESERVER_ST    = 0x0016,       // not referenced from symbol
#else
    LF_TYPESERVER       = 0x0016,       // not referenced from symbol
#endif

    // leaf indices starting records but referenced only from type records

    LF_SKIP_16t         = 0x0200,
    LF_ARGLIST_16t      = 0x0201,
    LF_DEFARG_16t       = 0x0202,
    LF_LIST             = 0x0203,
    LF_FIELDLIST_16t    = 0x0204,
    LF_DERIVED_16t      = 0x0205,
    LF_BITFIELD_16t     = 0x0206,
    LF_METHODLIST_16t   = 0x0207,
    LF_DIMCONU_16t      = 0x0208,
    LF_DIMCONLU_16t     = 0x0209,
    LF_DIMVARU_16t      = 0x020a,
    LF_DIMVARLU_16t     = 0x020b,
    LF_REFSYM           = 0x020c,

    LF_BCLASS_16t       = 0x0400,
    LF_VBCLASS_16t      = 0x0401,
    LF_IVBCLASS_16t     = 0x0402,
#ifdef LNGNM
    LF_ENUMERATE_ST     = 0x0403,
#else
    LF_ENUMERATE        = 0x0403,
#endif
    LF_FRIENDFCN_16t    = 0x0404,
    LF_INDEX_16t        = 0x0405,
    LF_MEMBER_16t       = 0x0406,
    LF_STMEMBER_16t     = 0x0407,
    LF_METHOD_16t       = 0x0408,
    LF_NESTTYPE_16t     = 0x0409,
    LF_VFUNCTAB_16t     = 0x040a,
    LF_FRIENDCLS_16t    = 0x040b,
    LF_ONEMETHOD_16t    = 0x040c,
    LF_VFUNCOFF_16t     = 0x040d,

// 32-bit type index versions of leaves, all have the 0x1000 bit set
//
    LF_TI16_MAX         = 0x1000,

    LF_MODIFIER         = 0x1001,
    LF_POINTER          = 0x1002,
#ifdef LNGNM
    LF_ARRAY_ST         = 0x1003,
    LF_CLASS_ST         = 0x1004,
    LF_STRUCTURE_ST     = 0x1005,
    LF_UNION_ST         = 0x1006,
    LF_ENUM_ST          = 0x1007,
#else
    LF_ARRAY            = 0x1003,
    LF_CLASS            = 0x1004,
    LF_STRUCTURE        = 0x1005,
    LF_UNION            = 0x1006,
    LF_ENUM             = 0x1007,
#endif
    LF_PROCEDURE        = 0x1008,
    LF_MFUNCTION        = 0x1009,
    LF_COBOL0           = 0x100a,
    LF_BARRAY           = 0x100b,
#ifdef LNGNM
    LF_DIMARRAY_ST      = 0x100c,
#else
    LF_DIMARRAY         = 0x100c,
#endif
    LF_VFTPATH          = 0x100d,
#ifdef LNGNM
    LF_PRECOMP_ST       = 0x100e,       // not referenced from symbol
#else
    LF_PRECOMP          = 0x100e,       // not referenced from symbol
#endif
    LF_OEM              = 0x100f,       // oem definable type string
#ifdef LNGNM
    LF_ALIAS_ST         = 0x1010,       // alias (typedef) type
#else
    LF_ALIAS            = 0x1010,       // alias (typedef) type
#endif
    LF_OEM2             = 0x1011,       // oem definable type string

    // leaf indices starting records but referenced only from type records

    LF_SKIP             = 0x1200,
    LF_ARGLIST          = 0x1201,
#ifdef LNGNM
    LF_DEFARG_ST        = 0x1202,
#else
    LF_DEFARG           = 0x1202,
#endif
    LF_FIELDLIST        = 0x1203,
    LF_DERIVED          = 0x1204,
    LF_BITFIELD         = 0x1205,
    LF_METHODLIST       = 0x1206,
    LF_DIMCONU          = 0x1207,
    LF_DIMCONLU         = 0x1208,
    LF_DIMVARU          = 0x1209,
    LF_DIMVARLU         = 0x120a,

    LF_BCLASS           = 0x1400,
    LF_VBCLASS          = 0x1401,
    LF_IVBCLASS         = 0x1402,
#ifdef LNGNM
    LF_FRIENDFCN_ST     = 0x1403,
#else
    LF_FRIENDFCN        = 0x1403,
#endif
    LF_INDEX            = 0x1404,
#ifdef LNGNM
    LF_MEMBER_ST        = 0x1405,
    LF_STMEMBER_ST      = 0x1406,
    LF_METHOD_ST        = 0x1407,
    LF_NESTTYPE_ST      = 0x1408,
#else
    LF_MEMBER           = 0x1405,
    LF_STMEMBER         = 0x1406,
    LF_METHOD           = 0x1407,
    LF_NESTTYPE         = 0x1408,
#endif
    LF_VFUNCTAB         = 0x1409,
    LF_FRIENDCLS        = 0x140a,
#ifdef LNGNM
    LF_ONEMETHOD_ST     = 0x140b,
#else
    LF_ONEMETHOD        = 0x140b,
#endif
    LF_VFUNCOFF         = 0x140c,
#ifndef LNGNM
    LF_NESTTYPEEX       = 0x140d,
    LF_MEMBERMODIFY     = 0x140e,
    LF_MANAGED          = 0x140f,

#else
    LF_NESTTYPEEX_ST    = 0x140d,
    LF_MEMBERMODIFY_ST  = 0x140e,
    LF_MANAGED_ST       = 0x140f,

    // Types w/ SZ names

    LF_ST_MAX           = 0x1500,

    LF_TYPESERVER       = 0x1501,       // not referenced from symbol
    LF_ENUMERATE        = 0x1502,
    LF_ARRAY            = 0x1503,
    LF_CLASS            = 0x1504,
    LF_STRUCTURE        = 0x1505,
    LF_UNION            = 0x1506,
    LF_ENUM             = 0x1507,
    LF_DIMARRAY         = 0x1508,
    LF_PRECOMP          = 0x1509,       // not referenced from symbol
    LF_ALIAS            = 0x150a,       // alias (typedef) type
    LF_DEFARG           = 0x150b,
    LF_FRIENDFCN        = 0x150c,
    LF_MEMBER           = 0x150d,
    LF_STMEMBER         = 0x150e,
    LF_METHOD           = 0x150f,
    LF_NESTTYPE         = 0x1510,
    LF_ONEMETHOD        = 0x1511,
    LF_NESTTYPEEX       = 0x1512,
    LF_MEMBERMODIFY     = 0x1513,
    LF_MANAGED          = 0x1514,
    LF_TYPESERVER2      = 0x1515,
#endif


    LF_NUMERIC          = 0x8000,
    LF_CHAR             = 0x8000,
    LF_SHORT            = 0x8001,
    LF_USHORT           = 0x8002,
    LF_LONG             = 0x8003,
    LF_ULONG            = 0x8004,
    LF_REAL32           = 0x8005,
    LF_REAL64           = 0x8006,
    LF_REAL80           = 0x8007,
    LF_REAL128          = 0x8008,
    LF_QUADWORD         = 0x8009,
    LF_UQUADWORD        = 0x800a,
    LF_REAL48           = 0x800b,
    LF_COMPLEX32        = 0x800c,
    LF_COMPLEX64        = 0x800d,
    LF_COMPLEX80        = 0x800e,
    LF_COMPLEX128       = 0x800f,
    LF_VARSTRING        = 0x8010,

    LF_OCTWORD          = 0x8017,
    LF_UOCTWORD         = 0x8018,

    LF_DECIMAL          = 0x8019,
    LF_DATE             = 0x801a,
    LF_UTF8STRING       = 0x801b,

    LF_PAD0             = 0xf0,
    LF_PAD1             = 0xf1,
    LF_PAD2             = 0xf2,
    LF_PAD3             = 0xf3,
    LF_PAD4             = 0xf4,
    LF_PAD5             = 0xf5,
    LF_PAD6             = 0xf6,
    LF_PAD7             = 0xf7,
    LF_PAD8             = 0xf8,
    LF_PAD9             = 0xf9,
    LF_PAD10            = 0xfa,
    LF_PAD11            = 0xfb,
    LF_PAD12            = 0xfc,
    LF_PAD13            = 0xfd,
    LF_PAD14            = 0xfe,
    LF_PAD15            = 0xff,

} LEAF_ENUM_e;

// end of leaf indices




//      Type enum for pointer records
//      Pointers can be one of the following types


typedef enum CV_ptrtype_e {
    CV_PTR_NEAR         = 0x00, // 16 bit pointer
    CV_PTR_FAR          = 0x01, // 16:16 far pointer
    CV_PTR_HUGE         = 0x02, // 16:16 huge pointer
    CV_PTR_BASE_SEG     = 0x03, // based on segment
    CV_PTR_BASE_VAL     = 0x04, // based on value of base
    CV_PTR_BASE_SEGVAL  = 0x05, // based on segment value of base
    CV_PTR_BASE_ADDR    = 0x06, // based on address of base
    CV_PTR_BASE_SEGADDR = 0x07, // based on segment address of base
    CV_PTR_BASE_TYPE    = 0x08, // based on type
    CV_PTR_BASE_SELF    = 0x09, // based on self
    CV_PTR_NEAR32       = 0x0a, // 32 bit pointer
    CV_PTR_FAR32        = 0x0b, // 16:32 pointer
    CV_PTR_64           = 0x0c, // 64 bit pointer
    CV_PTR_UNUSEDPTR    = 0x0d  // first unused pointer type
} CV_ptrtype_e;





//      Mode enum for pointers
//      Pointers can have one of the following modes


typedef enum CV_ptrmode_e {
    CV_PTR_MODE_PTR     = 0x00, // "normal" pointer
    CV_PTR_MODE_REF     = 0x01, // reference
    CV_PTR_MODE_PMEM    = 0x02, // pointer to data member
    CV_PTR_MODE_PMFUNC  = 0x03, // pointer to member function
    CV_PTR_MODE_RESERVED= 0x04  // first unused pointer mode
} CV_ptrmode_e;


//      enumeration for method properties

typedef enum CV_methodprop_e {
    CV_MTvanilla        = 0x00,
    CV_MTvirtual        = 0x01,
    CV_MTstatic         = 0x02,
    CV_MTfriend         = 0x03,
    CV_MTintro          = 0x04,
    CV_MTpurevirt       = 0x05,
    CV_MTpureintro      = 0x06
} CV_methodprop_e;




//      enumeration for virtual shape table entries

typedef enum CV_VTS_desc_e {
    CV_VTS_near         = 0x00,
    CV_VTS_far          = 0x01,
    CV_VTS_thin         = 0x02,
    CV_VTS_outer        = 0x03,
    CV_VTS_meta         = 0x04,
    CV_VTS_near32       = 0x05,
    CV_VTS_far32        = 0x06,
    CV_VTS_unused       = 0x07
} CV_VTS_desc_e;




//      enumeration for LF_LABEL address modes

typedef enum CV_LABEL_TYPE_e {
    CV_LABEL_NEAR = 0,       // near return
    CV_LABEL_FAR  = 4        // far return
} CV_LABEL_TYPE_e;



//      enumeration for LF_MODIFIER values


typedef struct CV_modifier_t {
    unsigned short  MOD_const       :1;
    unsigned short  MOD_volatile    :1;
    unsigned short  MOD_unaligned   :1;
    unsigned short  MOD_unused      :13;
} CV_modifier_t;


//  bit field structure describing class/struct/union/enum properties

typedef struct CV_prop_t {
    unsigned short  packed      :1;     // true if structure is packed
    unsigned short  ctor        :1;     // true if constructors or destructors present
    unsigned short  ovlops      :1;     // true if overloaded operators present
    unsigned short  isnested    :1;     // true if this is a nested class
    unsigned short  cnested     :1;     // true if this class contains nested types
    unsigned short  opassign    :1;     // true if overloaded assignment (=)
    unsigned short  opcast      :1;     // true if casting methods
    unsigned short  fwdref      :1;     // true if forward reference (incomplete defn)
    unsigned short  scoped      :1;     // scoped definition
    unsigned short  reserved    :7;
} CV_prop_t;




//  class field attribute

typedef struct CV_fldattr_t {
    unsigned short  access      :2;     // access protection CV_access_t
    unsigned short  mprop       :3;     // method properties CV_methodprop_t
    unsigned short  pseudo      :1;     // compiler generated fcn and does not exist
    unsigned short  noinherit   :1;     // true if class cannot be inherited
    unsigned short  noconstruct :1;     // true if class cannot be constructed
    unsigned short  compgenx    :1;     // compiler generated fcn and does exist
    unsigned short  unused      :7;     // unused
} CV_fldattr_t;



//  Structures to access to the type records


typedef struct TYPTYPE {
    unsigned short  len;
    unsigned short  leaf;
    unsigned char   data[CV_ZEROLEN];
} TYPTYPE;          // general types record


__INLINE char *NextType (char * pType) {
    return (pType + ((TYPTYPE *)pType)->len + sizeof(unsigned short));
}

typedef enum CV_PMEMBER {
    CV_PDM16_NONVIRT    = 0x00, // 16:16 data no virtual fcn or base
    CV_PDM16_VFCN       = 0x01, // 16:16 data with virtual functions
    CV_PDM16_VBASE      = 0x02, // 16:16 data with virtual bases
    CV_PDM32_NVVFCN     = 0x03, // 16:32 data w/wo virtual functions
    CV_PDM32_VBASE      = 0x04, // 16:32 data with virtual bases

    CV_PMF16_NEARNVSA   = 0x05, // 16:16 near method nonvirtual single address point
    CV_PMF16_NEARNVMA   = 0x06, // 16:16 near method nonvirtual multiple address points
    CV_PMF16_NEARVBASE  = 0x07, // 16:16 near method virtual bases
    CV_PMF16_FARNVSA    = 0x08, // 16:16 far method nonvirtual single address point
    CV_PMF16_FARNVMA    = 0x09, // 16:16 far method nonvirtual multiple address points
    CV_PMF16_FARVBASE   = 0x0a, // 16:16 far method virtual bases

    CV_PMF32_NVSA       = 0x0b, // 16:32 method nonvirtual single address point
    CV_PMF32_NVMA       = 0x0c, // 16:32 method nonvirtual multiple address point
    CV_PMF32_VBASE      = 0x0d  // 16:32 method virtual bases
} CV_PMEMBER;



//  memory representation of pointer to member.  These representations are
//  indexed by the enumeration above in the LF_POINTER record




//  representation of a 16:16 pointer to data for a class with no
//  virtual functions or virtual bases


struct CV_PDMR16_NONVIRT {
    CV_off16_t      mdisp;      // displacement to data (NULL = -1)
};




//  representation of a 16:16 pointer to data for a class with virtual
//  functions


struct CV_PMDR16_VFCN {
    CV_off16_t      mdisp;      // displacement to data ( NULL = 0)
};




//  representation of a 16:16 pointer to data for a class with
//  virtual bases


struct CV_PDMR16_VBASE {
    CV_off16_t      mdisp;      // displacement to data
    CV_off16_t      pdisp;      // this pointer displacement to vbptr
    CV_off16_t      vdisp;      // displacement within vbase table
                                // NULL = (,,0xffff)
};




//  representation of a 32 bit pointer to data for a class with
//  or without virtual functions and no virtual bases


struct CV_PDMR32_NVVFCN {
    CV_off32_t      mdisp;      // displacement to data (NULL = 0x80000000)
};




//  representation of a 32 bit pointer to data for a class
//  with virtual bases


struct CV_PDMR32_VBASE {
    CV_off32_t      mdisp;      // displacement to data
    CV_off32_t      pdisp;      // this pointer displacement
    CV_off32_t      vdisp;      // vbase table displacement
                                // NULL = (,,0xffffffff)
};




//  representation of a 16:16 pointer to near member function for a
//  class with no virtual functions or bases and a single address point


struct CV_PMFR16_NEARNVSA {
    CV_uoff16_t     off;        // near address of function (NULL = 0)
};



//  representation of a 16 bit pointer to member functions of a
//  class with no virtual bases and multiple address points


struct CV_PMFR16_NEARNVMA {
    CV_uoff16_t     off;        // offset of function (NULL = 0,x)
    signed short    disp;
};




//  representation of a 16 bit pointer to member function of a
//  class with virtual bases


struct CV_PMFR16_NEARVBASE {
    CV_uoff16_t     off;        // offset of function (NULL = 0,x,x,x)
    CV_off16_t      mdisp;      // displacement to data
    CV_off16_t      pdisp;      // this pointer displacement
    CV_off16_t      vdisp;      // vbase table displacement
};




//  representation of a 16:16 pointer to far member function for a
//  class with no virtual bases and a single address point


struct CV_PMFR16_FARNVSA {
    CV_uoff16_t     off;        // offset of function (NULL = 0:0)
    unsigned short  seg;        // segment of function
};




//  representation of a 16:16 far pointer to member functions of a
//  class with no virtual bases and multiple address points


struct CV_PMFR16_FARNVMA {
    CV_uoff16_t     off;        // offset of function (NULL = 0:0,x)
    unsigned short  seg;
    signed short    disp;
};




//  representation of a 16:16 far pointer to member function of a
//  class with virtual bases


struct CV_PMFR16_FARVBASE {
    CV_uoff16_t     off;        // offset of function (NULL = 0:0,x,x,x)
    unsigned short  seg;
    CV_off16_t      mdisp;      // displacement to data
    CV_off16_t      pdisp;      // this pointer displacement
    CV_off16_t      vdisp;      // vbase table displacement

};




//  representation of a 32 bit pointer to member function for a
//  class with no virtual bases and a single address point


struct CV_PMFR32_NVSA {
    CV_uoff32_t      off;        // near address of function (NULL = 0L)
};




//  representation of a 32 bit pointer to member function for a
//  class with no virtual bases and multiple address points


struct CV_PMFR32_NVMA {
    CV_uoff32_t     off;        // near address of function (NULL = 0L,x)
    CV_off32_t      disp;
};




//  representation of a 32 bit pointer to member function for a
//  class with virtual bases


struct CV_PMFR32_VBASE {
    CV_uoff32_t     off;        // near address of function (NULL = 0L,x,x,x)
    CV_off32_t      mdisp;      // displacement to data
    CV_off32_t      pdisp;      // this pointer displacement
    CV_off32_t      vdisp;      // vbase table displacement
};





//  Easy leaf - used for generic casting to reference leaf field
//  of a subfield of a complex list

typedef struct lfEasy {
    unsigned short  leaf;           // LF_...
} lfEasy;


/**     The following type records are basically variant records of the
 *      above structure.  The "unsigned short leaf" of the above structure and
 *      the "unsigned short leaf" of the following type definitions are the same
 *      symbol.  When the OMF record is locked via the MHOMFLock API
 *      call, the address of the "unsigned short leaf" is returned
 */

/**     Notes on alignment
 *      Alignment of the fields in most of the type records is done on the
 *      basis of the TYPTYPE record base.  That is why in most of the lf*
 *      records that the CV_typ_t (32-bit types) is located on what appears to
 *      be a offset mod 4 == 2 boundary.  The exception to this rule are those
 *      records that are in a list (lfFieldList, lfMethodList), which are
 *      aligned to their own bases since they don't have the length field
 */

/**** Change log for 16-bit to 32-bit type and symbol records

    Record type         Change (f == field arrangement, p = padding added)
    ----------------------------------------------------------------------
    lfModifer           f
    lfPointer           fp
    lfClass             f
    lfStructure         f
    lfUnion             f
    lfEnum              f
    lfVFTPath           p
    lfPreComp           p
    lfOEM               p
    lfArgList           p
    lfDerived           p
    mlMethod            p   (method list member)
    lfBitField          f
    lfDimCon            f
    lfDimVar            p
    lfIndex             p   (field list member)
    lfBClass            f   (field list member)
    lfVBClass           f   (field list member)
    lfFriendCls         p   (field list member)
    lfFriendFcn         p   (field list member)
    lfMember            f   (field list member)
    lfSTMember          f   (field list member)
    lfVFuncTab          p   (field list member)
    lfVFuncOff          p   (field list member)
    lfNestType          p   (field list member)

    DATASYM32           f
    PROCSYM32           f
    VPATHSYM32          f
    REGREL32            f
    THREADSYM32         f
    PROCSYMMIPS         f


*/

//      Type record for LF_MODIFIER

typedef struct lfModifier_16t {
    unsigned short  leaf;           // LF_MODIFIER_16t
    CV_modifier_t   attr;           // modifier attribute modifier_t
    CV_typ16_t      type;           // modified type
} lfModifier_16t;

typedef struct lfModifier {
    unsigned short  leaf;           // LF_MODIFIER
    CV_typ_t        type;           // modified type
    CV_modifier_t   attr;           // modifier attribute modifier_t
} lfModifier;




//      type record for LF_POINTER

#ifndef __cplusplus
typedef struct lfPointer_16t {
#endif
    struct lfPointerBody_16t {
        unsigned short      leaf;           // LF_POINTER_16t
        struct lfPointerAttr_16t {
            unsigned char   ptrtype     :5; // ordinal specifying pointer type (CV_ptrtype_e)
            unsigned char   ptrmode     :3; // ordinal specifying pointer mode (CV_ptrmode_e)
            unsigned char   isflat32    :1; // true if 0:32 pointer
            unsigned char   isvolatile  :1; // TRUE if volatile pointer
            unsigned char   isconst     :1; // TRUE if const pointer
            unsigned char   isunaligned :1; // TRUE if unaligned pointer
            unsigned char   unused      :4;
        } attr;
        CV_typ16_t  utype;          // type index of the underlying type
#if (defined(__cplusplus) || defined(_MSC_VER)) // for C++ and MS compilers that support unnamed unions
    };
#else
    } u;
#endif
#ifdef  __cplusplus
typedef struct lfPointer_16t : public lfPointerBody_16t {
#endif
    union {
        struct {
            CV_typ16_t      pmclass;    // index of containing class for pointer to member
            unsigned short  pmenum;     // enumeration specifying pm format
        } pm;
        unsigned short      bseg;       // base segment if PTR_BASE_SEG
        unsigned char       Sym[1];     // copy of base symbol record (including length)
        struct  {
            CV_typ16_t      index;      // type index if CV_PTR_BASE_TYPE
            unsigned char   name[1];    // name of base type
        } btype;
    } pbase;
} lfPointer_16t;

#ifndef __cplusplus
typedef struct lfPointer {
#endif
    struct lfPointerBody {
        unsigned short      leaf;           // LF_POINTER
        CV_typ_t            utype;          // type index of the underlying type
        struct lfPointerAttr {
            unsigned long   ptrtype     :5; // ordinal specifying pointer type (CV_ptrtype_e)
            unsigned long   ptrmode     :3; // ordinal specifying pointer mode (CV_ptrmode_e)
            unsigned long   isflat32    :1; // true if 0:32 pointer
            unsigned long   isvolatile  :1; // TRUE if volatile pointer
            unsigned long   isconst     :1; // TRUE if const pointer
            unsigned long   isunaligned :1; // TRUE if unaligned pointer
            unsigned long   isrestrict  :1; // TRUE if restricted pointer (allow agressive opts)
            unsigned long   unused      :19;// pad out to 32-bits for following cv_typ_t's
        } attr;
#if (defined(__cplusplus) || defined(_MSC_VER)) // for C++ and MS compilers that support unnamed unions
    };
#else
    } u;
#endif
#ifdef  __cplusplus
typedef struct lfPointer : public lfPointerBody {
#endif
    union {
        struct {
            CV_typ_t        pmclass;    // index of containing class for pointer to member
            unsigned short  pmenum;     // enumeration specifying pm format
        } pm;
        unsigned short      bseg;       // base segment if PTR_BASE_SEG
        unsigned char       Sym[1];     // copy of base symbol record (including length)
        struct  {
            CV_typ_t        index;      // type index if CV_PTR_BASE_TYPE
            unsigned char   name[1];    // name of base type
        } btype;
    } pbase;
} lfPointer;




//      type record for LF_ARRAY


typedef struct lfArray_16t {
    unsigned short  leaf;           // LF_ARRAY_16t
    CV_typ16_t      elemtype;       // type index of element type
    CV_typ16_t      idxtype;        // type index of indexing type
    unsigned char   data[CV_ZEROLEN];         // variable length data specifying
                                    // size in bytes and name
} lfArray_16t;

typedef struct lfArray {
    unsigned short  leaf;           // LF_ARRAY
    CV_typ_t        elemtype;       // type index of element type
    CV_typ_t        idxtype;        // type index of indexing type
    unsigned char   data[CV_ZEROLEN];         // variable length data specifying
                                    // size in bytes and name
} lfArray;




//      type record for LF_CLASS, LF_STRUCTURE


typedef struct lfClass_16t {
    unsigned short  leaf;           // LF_CLASS_16t, LF_STRUCT_16t
    unsigned short  count;          // count of number of elements in class
    CV_typ16_t      field;          // type index of LF_FIELD descriptor list
    CV_prop_t       property;       // property attribute field (prop_t)
    CV_typ16_t      derived;        // type index of derived from list if not zero
    CV_typ16_t      vshape;         // type index of vshape table for this class
    unsigned char   data[CV_ZEROLEN];         // data describing length of structure in
                                    // bytes and name
} lfClass_16t;
typedef lfClass_16t lfStructure_16t;


typedef struct lfClass {
    unsigned short  leaf;           // LF_CLASS, LF_STRUCT
    unsigned short  count;          // count of number of elements in class
    CV_prop_t       property;       // property attribute field (prop_t)
    CV_typ_t        field;          // type index of LF_FIELD descriptor list
    CV_typ_t        derived;        // type index of derived from list if not zero
    CV_typ_t        vshape;         // type index of vshape table for this class
    unsigned char   data[CV_ZEROLEN];         // data describing length of structure in
                                    // bytes and name
} lfClass;
typedef lfClass lfStructure;




//      type record for LF_UNION


typedef struct lfUnion_16t {
    unsigned short  leaf;           // LF_UNION_16t
    unsigned short  count;          // count of number of elements in class
    CV_typ16_t      field;          // type index of LF_FIELD descriptor list
    CV_prop_t       property;       // property attribute field
    unsigned char   data[CV_ZEROLEN];         // variable length data describing length of
                                    // structure and name
} lfUnion_16t;


typedef struct lfUnion {
    unsigned short  leaf;           // LF_UNION
    unsigned short  count;          // count of number of elements in class
    CV_prop_t       property;       // property attribute field
    CV_typ_t        field;          // type index of LF_FIELD descriptor list
    unsigned char   data[CV_ZEROLEN];         // variable length data describing length of
                                    // structure and name
} lfUnion;


//      type record for LF_ALIAS

typedef struct lfAlias {
    unsigned short  leaf;           // LF_ALIAS
    CV_typ_t        utype;          // underlying type
    unsigned char   Name[1];        // alias name
} lfAlias;


//      type record for LF_MANAGED

typedef struct lfManaged {
    unsigned short  leaf;           // LF_MANAGED
    unsigned char   Name[1];        // utf8, zero terminated managed type name
} lfManaged;


//      type record for LF_ENUM


typedef struct lfEnum_16t {
    unsigned short  leaf;           // LF_ENUM_16t
    unsigned short  count;          // count of number of elements in class
    CV_typ16_t      utype;          // underlying type of the enum
    CV_typ16_t      field;          // type index of LF_FIELD descriptor list
    CV_prop_t       property;       // property attribute field
    unsigned char   Name[1];        // length prefixed name of enum
} lfEnum_16t;

typedef struct lfEnum {
    unsigned short  leaf;           // LF_ENUM
    unsigned short  count;          // count of number of elements in class
    CV_prop_t       property;       // property attribute field
    CV_typ_t        utype;          // underlying type of the enum
    CV_typ_t        field;          // type index of LF_FIELD descriptor list
    unsigned char   Name[1];        // length prefixed name of enum
} lfEnum;




//      Type record for LF_PROCEDURE


typedef struct lfProc_16t {
    unsigned short  leaf;           // LF_PROCEDURE_16t
    CV_typ16_t      rvtype;         // type index of return value
    unsigned char   calltype;       // calling convention (CV_call_t)
    unsigned char   reserved;       // reserved for future use
    unsigned short  parmcount;      // number of parameters
    CV_typ16_t      arglist;        // type index of argument list
} lfProc_16t;

typedef struct lfProc {
    unsigned short  leaf;           // LF_PROCEDURE
    CV_typ_t        rvtype;         // type index of return value
    unsigned char   calltype;       // calling convention (CV_call_t)
    unsigned char   reserved;       // reserved for future use
    unsigned short  parmcount;      // number of parameters
    CV_typ_t        arglist;        // type index of argument list
} lfProc;



//      Type record for member function


typedef struct lfMFunc_16t {
    unsigned short  leaf;           // LF_MFUNCTION_16t
    CV_typ16_t      rvtype;         // type index of return value
    CV_typ16_t      classtype;      // type index of containing class
    CV_typ16_t      thistype;       // type index of this pointer (model specific)
    unsigned char   calltype;       // calling convention (call_t)
    unsigned char   reserved;       // reserved for future use
    unsigned short  parmcount;      // number of parameters
    CV_typ16_t      arglist;        // type index of argument list
    long            thisadjust;     // this adjuster (long because pad required anyway)
} lfMFunc_16t;

typedef struct lfMFunc {
    unsigned short  leaf;           // LF_MFUNCTION
    CV_typ_t        rvtype;         // type index of return value
    CV_typ_t        classtype;      // type index of containing class
    CV_typ_t        thistype;       // type index of this pointer (model specific)
    unsigned char   calltype;       // calling convention (call_t)
    unsigned char   reserved;       // reserved for future use
    unsigned short  parmcount;      // number of parameters
    CV_typ_t        arglist;        // type index of argument list
    long            thisadjust;     // this adjuster (long because pad required anyway)
} lfMFunc;




//     type record for virtual function table shape


typedef struct lfVTShape {
    unsigned short  leaf;       // LF_VTSHAPE
    unsigned short  count;      // number of entries in vfunctable
    unsigned char   desc[CV_ZEROLEN];     // 4 bit (CV_VTS_desc) descriptors
} lfVTShape;




//      type record for cobol0


typedef struct lfCobol0_16t {
    unsigned short  leaf;       // LF_COBOL0_16t
    CV_typ16_t      type;       // parent type record index
    unsigned char   data[CV_ZEROLEN];
} lfCobol0_16t;

typedef struct lfCobol0 {
    unsigned short  leaf;       // LF_COBOL0
    CV_typ_t        type;       // parent type record index
    unsigned char   data[CV_ZEROLEN];
} lfCobol0;




//      type record for cobol1


typedef struct lfCobol1 {
    unsigned short  leaf;       // LF_COBOL1
    unsigned char   data[CV_ZEROLEN];
} lfCobol1;




//      type record for basic array


typedef struct lfBArray_16t {
    unsigned short  leaf;       // LF_BARRAY_16t
    CV_typ16_t      utype;      // type index of underlying type
} lfBArray_16t;

typedef struct lfBArray {
    unsigned short  leaf;       // LF_BARRAY
    CV_typ_t        utype;      // type index of underlying type
} lfBArray;

//      type record for assembler labels


typedef struct lfLabel {
    unsigned short  leaf;       // LF_LABEL
    unsigned short  mode;       // addressing mode of label
} lfLabel;



//      type record for dimensioned arrays


typedef struct lfDimArray_16t {
    unsigned short  leaf;       // LF_DIMARRAY_16t
    CV_typ16_t      utype;      // underlying type of the array
    CV_typ16_t      diminfo;    // dimension information
    unsigned char   name[1];    // length prefixed name
} lfDimArray_16t;

typedef struct lfDimArray {
    unsigned short  leaf;       // LF_DIMARRAY
    CV_typ_t        utype;      // underlying type of the array
    CV_typ_t        diminfo;    // dimension information
    unsigned char   name[1];    // length prefixed name
} lfDimArray;



//      type record describing path to virtual function table


typedef struct lfVFTPath_16t {
    unsigned short  leaf;       // LF_VFTPATH_16t
    unsigned short  count;      // count of number of bases in path
    CV_typ16_t      base[1];    // bases from root to leaf
} lfVFTPath_16t;

typedef struct lfVFTPath {
    unsigned short  leaf;       // LF_VFTPATH
    unsigned long   count;      // count of number of bases in path
    CV_typ_t        base[1];    // bases from root to leaf
} lfVFTPath;


//      type record describing inclusion of precompiled types


typedef struct lfPreComp_16t {
    unsigned short  leaf;       // LF_PRECOMP_16t
    unsigned short  start;      // starting type index included
    unsigned short  count;      // number of types in inclusion
    unsigned long   signature;  // signature
    unsigned char   name[CV_ZEROLEN];     // length prefixed name of included type file
} lfPreComp_16t;

typedef struct lfPreComp {
    unsigned short  leaf;       // LF_PRECOMP
    unsigned long   start;      // starting type index included
    unsigned long   count;      // number of types in inclusion
    unsigned long   signature;  // signature
    unsigned char   name[CV_ZEROLEN];     // length prefixed name of included type file
} lfPreComp;



//      type record describing end of precompiled types that can be
//      included by another file


typedef struct lfEndPreComp {
    unsigned short  leaf;       // LF_ENDPRECOMP
    unsigned long   signature;  // signature
} lfEndPreComp;





//      type record for OEM definable type strings


typedef struct lfOEM_16t {
    unsigned short  leaf;       // LF_OEM_16t
    unsigned short  cvOEM;      // MS assigned OEM identified
    unsigned short  recOEM;     // OEM assigned type identifier
    unsigned short  count;      // count of type indices to follow
    CV_typ16_t      index[CV_ZEROLEN];  // array of type indices followed
                                // by OEM defined data
} lfOEM_16t;

typedef struct lfOEM {
    unsigned short  leaf;       // LF_OEM
    unsigned short  cvOEM;      // MS assigned OEM identified
    unsigned short  recOEM;     // OEM assigned type identifier
    unsigned long   count;      // count of type indices to follow
    CV_typ_t        index[CV_ZEROLEN];  // array of type indices followed
                                // by OEM defined data
} lfOEM;

#define OEM_MS_FORTRAN90        0xF090
#define OEM_ODI                 0x0010
#define OEM_THOMSON_SOFTWARE    0x5453
#define OEM_ODI_REC_BASELIST    0x0000

typedef struct lfOEM2 {
    unsigned short  leaf;       // LF_OEM2
    unsigned char   idOem[16];  // an oem ID (GUID)
    unsigned long   count;      // count of type indices to follow
    CV_typ_t        index[CV_ZEROLEN];  // array of type indices followed
                                // by OEM defined data
} lfOEM2;

//      type record describing using of a type server

typedef struct lfTypeServer {
    unsigned short  leaf;       // LF_TYPESERVER
    unsigned long   signature;  // signature
    unsigned long   age;        // age of database used by this module
    unsigned char   name[CV_ZEROLEN];     // length prefixed name of PDB
} lfTypeServer;

//      type record describing using of a type server with v7 (GUID) signatures

typedef struct lfTypeServer2 {
    unsigned short  leaf;       // LF_TYPESERVER2
    SIG70           sig70;      // guid signature
    unsigned long   age;        // age of database used by this module
    unsigned char   name[CV_ZEROLEN];     // length prefixed name of PDB
} lfTypeServer2;

//      description of type records that can be referenced from
//      type records referenced by symbols



//      type record for skip record


typedef struct lfSkip_16t {
    unsigned short  leaf;       // LF_SKIP_16t
    CV_typ16_t      type;       // next valid index
    unsigned char   data[CV_ZEROLEN];     // pad data
} lfSkip_16t;

typedef struct lfSkip {
    unsigned short  leaf;       // LF_SKIP
    CV_typ_t        type;       // next valid index
    unsigned char   data[CV_ZEROLEN];     // pad data
} lfSkip;



//      argument list leaf


typedef struct lfArgList_16t {
    unsigned short  leaf;           // LF_ARGLIST_16t
    unsigned short  count;          // number of arguments
    CV_typ16_t      arg[CV_ZEROLEN];      // number of arguments
} lfArgList_16t;

typedef struct lfArgList {
    unsigned short  leaf;           // LF_ARGLIST
    unsigned long   count;          // number of arguments
    CV_typ_t        arg[CV_ZEROLEN];      // number of arguments
} lfArgList;




//      derived class list leaf


typedef struct lfDerived_16t {
    unsigned short  leaf;           // LF_DERIVED_16t
    unsigned short  count;          // number of arguments
    CV_typ16_t      drvdcls[CV_ZEROLEN];      // type indices of derived classes
} lfDerived_16t;

typedef struct lfDerived {
    unsigned short  leaf;           // LF_DERIVED
    unsigned long   count;          // number of arguments
    CV_typ_t        drvdcls[CV_ZEROLEN];      // type indices of derived classes
} lfDerived;




//      leaf for default arguments


typedef struct lfDefArg_16t {
    unsigned short  leaf;               // LF_DEFARG_16t
    CV_typ16_t      type;               // type of resulting expression
    unsigned char   expr[CV_ZEROLEN];   // length prefixed expression string
} lfDefArg_16t;

typedef struct lfDefArg {
    unsigned short  leaf;               // LF_DEFARG
    CV_typ_t        type;               // type of resulting expression
    unsigned char   expr[CV_ZEROLEN];   // length prefixed expression string
} lfDefArg;



//      list leaf
//          This list should no longer be used because the utilities cannot
//          verify the contents of the list without knowing what type of list
//          it is.  New specific leaf indices should be used instead.


typedef struct lfList {
    unsigned short  leaf;           // LF_LIST
    char            data[CV_ZEROLEN];         // data format specified by indexing type
} lfList;




//      field list leaf
//      This is the header leaf for a complex list of class and structure
//      subfields.


typedef struct lfFieldList_16t {
    unsigned short  leaf;           // LF_FIELDLIST_16t
    char            data[CV_ZEROLEN];         // field list sub lists
} lfFieldList_16t;


typedef struct lfFieldList {
    unsigned short  leaf;           // LF_FIELDLIST
    char            data[CV_ZEROLEN];         // field list sub lists
} lfFieldList;







//  type record for non-static methods and friends in overloaded method list

typedef struct mlMethod_16t {
    CV_fldattr_t   attr;           // method attribute
    CV_typ16_t     index;          // index to type record for procedure
    unsigned long  vbaseoff[CV_ZEROLEN];    // offset in vfunctable if intro virtual
} mlMethod_16t;

typedef struct mlMethod {
    CV_fldattr_t    attr;           // method attribute
    _2BYTEPAD       pad0;           // internal padding, must be 0
    CV_typ_t        index;          // index to type record for procedure
    unsigned long   vbaseoff[CV_ZEROLEN];    // offset in vfunctable if intro virtual
} mlMethod;


typedef struct lfMethodList_16t {
    unsigned short leaf;
    unsigned char  mList[CV_ZEROLEN];         // really a mlMethod_16t type
} lfMethodList_16t;

typedef struct lfMethodList {
    unsigned short leaf;
    unsigned char  mList[CV_ZEROLEN];         // really a mlMethod type
} lfMethodList;





//      type record for LF_BITFIELD


typedef struct lfBitfield_16t {
    unsigned short  leaf;           // LF_BITFIELD_16t
    unsigned char   length;
    unsigned char   position;
    CV_typ16_t      type;           // type of bitfield

} lfBitfield_16t;

typedef struct lfBitfield {
    unsigned short  leaf;           // LF_BITFIELD
    CV_typ_t        type;           // type of bitfield
    unsigned char   length;
    unsigned char   position;

} lfBitfield;




//      type record for dimensioned array with constant bounds


typedef struct lfDimCon_16t {
    unsigned short  leaf;           // LF_DIMCONU_16t or LF_DIMCONLU_16t
    unsigned short  rank;           // number of dimensions
    CV_typ16_t      typ;            // type of index
    unsigned char   dim[CV_ZEROLEN];          // array of dimension information with
                                    // either upper bounds or lower/upper bound
} lfDimCon_16t;

typedef struct lfDimCon {
    unsigned short  leaf;           // LF_DIMCONU or LF_DIMCONLU
    CV_typ_t        typ;            // type of index
    unsigned short  rank;           // number of dimensions
    unsigned char   dim[CV_ZEROLEN];          // array of dimension information with
                                    // either upper bounds or lower/upper bound
} lfDimCon;




//      type record for dimensioned array with variable bounds


typedef struct lfDimVar_16t {
    unsigned short  leaf;           // LF_DIMVARU_16t or LF_DIMVARLU_16t
    unsigned short  rank;           // number of dimensions
    CV_typ16_t      typ;            // type of index
    CV_typ16_t      dim[CV_ZEROLEN];          // array of type indices for either
                                    // variable upper bound or variable
                                    // lower/upper bound.  The referenced
                                    // types must be LF_REFSYM or T_VOID
} lfDimVar_16t;

typedef struct lfDimVar {
    unsigned short  leaf;           // LF_DIMVARU or LF_DIMVARLU
    unsigned long   rank;           // number of dimensions
    CV_typ_t        typ;            // type of index
    CV_typ_t        dim[CV_ZEROLEN];          // array of type indices for either
                                    // variable upper bound or variable
                                    // lower/upper bound.  The count of type
                                    // indices is rank or rank*2 depending on
                                    // whether it is LFDIMVARU or LF_DIMVARLU.
                                    // The referenced types must be
                                    // LF_REFSYM or T_VOID
} lfDimVar;




//      type record for referenced symbol


typedef struct lfRefSym {
    unsigned short  leaf;           // LF_REFSYM
    unsigned char   Sym[1];         // copy of referenced symbol record
                                    // (including length)
} lfRefSym;





/**     the following are numeric leaves.  They are used to indicate the
 *      size of the following variable length data.  When the numeric
 *      data is a single byte less than 0x8000, then the data is output
 *      directly.  If the data is more the 0x8000 or is a negative value,
 *      then the data is preceeded by the proper index.
 */



//      signed character leaf

typedef struct lfChar {
    unsigned short  leaf;           // LF_CHAR
    signed char     val;            // signed 8-bit value
} lfChar;




//      signed short leaf

typedef struct lfShort {
    unsigned short  leaf;           // LF_SHORT
    short           val;            // signed 16-bit value
} lfShort;




//      unsigned short leaf

typedef struct lfUShort {
    unsigned short  leaf;           // LF_unsigned short
    unsigned short  val;            // unsigned 16-bit value
} lfUShort;




//      signed long leaf

typedef struct lfLong {
    unsigned short  leaf;           // LF_LONG
    long            val;            // signed 32-bit value
} lfLong;




//      unsigned long leaf

typedef struct lfULong {
    unsigned short  leaf;           // LF_ULONG
    unsigned long   val;            // unsigned 32-bit value
} lfULong;




//      signed quad leaf

typedef struct lfQuad {
    unsigned short  leaf;           // LF_QUAD
    unsigned char   val[8];         // signed 64-bit value
} lfQuad;




//      unsigned quad leaf

typedef struct lfUQuad {
    unsigned short  leaf;           // LF_UQUAD
    unsigned char   val[8];         // unsigned 64-bit value
} lfUQuad;


//      signed int128 leaf

typedef struct lfOct {
    unsigned short  leaf;           // LF_OCT
    unsigned char   val[16];        // signed 128-bit value
} lfOct;

//      unsigned int128 leaf

typedef struct lfUOct {
    unsigned short  leaf;           // LF_UOCT
    unsigned char   val[16];        // unsigned 128-bit value
} lfUOct;




//      real 32-bit leaf

typedef struct lfReal32 {
    unsigned short  leaf;           // LF_REAL32
    float           val;            // 32-bit real value
} lfReal32;




//      real 48-bit leaf

typedef struct lfReal48 {
    unsigned short  leaf;           // LF_REAL48
    unsigned char   val[6];         // 48-bit real value
} lfReal48;




//      real 64-bit leaf

typedef struct lfReal64 {
    unsigned short  leaf;           // LF_REAL64
    double          val;            // 64-bit real value
} lfReal64;




//      real 80-bit leaf

typedef struct lfReal80 {
    unsigned short  leaf;           // LF_REAL80
    FLOAT10         val;            // real 80-bit value
} lfReal80;




//      real 128-bit leaf

typedef struct lfReal128 {
    unsigned short  leaf;           // LF_REAL128
    char            val[16];        // real 128-bit value
} lfReal128;




//      complex 32-bit leaf

typedef struct lfCmplx32 {
    unsigned short  leaf;           // LF_COMPLEX32
    float           val_real;       // real component
    float           val_imag;       // imaginary component
} lfCmplx32;




//      complex 64-bit leaf

typedef struct lfCmplx64 {
    unsigned short  leaf;           // LF_COMPLEX64
    double          val_real;       // real component
    double          val_imag;       // imaginary component
} flCmplx64;




//      complex 80-bit leaf

typedef struct lfCmplx80 {
    unsigned short  leaf;           // LF_COMPLEX80
    FLOAT10         val_real;       // real component
    FLOAT10         val_imag;       // imaginary component
} lfCmplx80;




//      complex 128-bit leaf

typedef struct lfCmplx128 {
    unsigned short  leaf;           // LF_COMPLEX128
    char            val_real[16];   // real component
    char            val_imag[16];   // imaginary component
} lfCmplx128;



//  variable length numeric field

typedef struct lfVarString {
    unsigned short  leaf;       // LF_VARSTRING
    unsigned short  len;        // length of value in bytes
    unsigned char   value[CV_ZEROLEN];  // value
} lfVarString;

//***********************************************************************


//      index leaf - contains type index of another leaf
//      a major use of this leaf is to allow the compilers to emit a
//      long complex list (LF_FIELD) in smaller pieces.

typedef struct lfIndex_16t {
    unsigned short  leaf;           // LF_INDEX_16t
    CV_typ16_t      index;          // type index of referenced leaf
} lfIndex_16t;

typedef struct lfIndex {
    unsigned short  leaf;           // LF_INDEX
    _2BYTEPAD       pad0;           // internal padding, must be 0
    CV_typ_t        index;          // type index of referenced leaf
} lfIndex;


//      subfield record for base class field

typedef struct lfBClass_16t {
    unsigned short  leaf;           // LF_BCLASS_16t
    CV_typ16_t      index;          // type index of base class
    CV_fldattr_t    attr;           // attribute
    unsigned char   offset[CV_ZEROLEN];       // variable length offset of base within class
} lfBClass_16t;

typedef struct lfBClass {
    unsigned short  leaf;           // LF_BCLASS
    CV_fldattr_t    attr;           // attribute
    CV_typ_t        index;          // type index of base class
    unsigned char   offset[CV_ZEROLEN];       // variable length offset of base within class
} lfBClass;





//      subfield record for direct and indirect virtual base class field

typedef struct lfVBClass_16t {
    unsigned short  leaf;           // LF_VBCLASS_16t | LV_IVBCLASS_16t
    CV_typ16_t      index;          // type index of direct virtual base class
    CV_typ16_t      vbptr;          // type index of virtual base pointer
    CV_fldattr_t    attr;           // attribute
    unsigned char   vbpoff[CV_ZEROLEN];       // virtual base pointer offset from address point
                                    // followed by virtual base offset from vbtable
} lfVBClass_16t;

typedef struct lfVBClass {
    unsigned short  leaf;           // LF_VBCLASS | LV_IVBCLASS
    CV_fldattr_t    attr;           // attribute
    CV_typ_t        index;          // type index of direct virtual base class
    CV_typ_t        vbptr;          // type index of virtual base pointer
    unsigned char   vbpoff[CV_ZEROLEN];       // virtual base pointer offset from address point
                                    // followed by virtual base offset from vbtable
} lfVBClass;





//      subfield record for friend class


typedef struct lfFriendCls_16t {
    unsigned short  leaf;           // LF_FRIENDCLS_16t
    CV_typ16_t      index;          // index to type record of friend class
} lfFriendCls_16t;

typedef struct lfFriendCls {
    unsigned short  leaf;           // LF_FRIENDCLS
    _2BYTEPAD       pad0;           // internal padding, must be 0
    CV_typ_t        index;          // index to type record of friend class
} lfFriendCls;





//      subfield record for friend function


typedef struct lfFriendFcn_16t {
    unsigned short  leaf;           // LF_FRIENDFCN_16t
    CV_typ16_t      index;          // index to type record of friend function
    unsigned char   Name[1];        // name of friend function
} lfFriendFcn_16t;

typedef struct lfFriendFcn {
    unsigned short  leaf;           // LF_FRIENDFCN
    _2BYTEPAD       pad0;           // internal padding, must be 0
    CV_typ_t        index;          // index to type record of friend function
    unsigned char   Name[1];        // name of friend function
} lfFriendFcn;



//      subfield record for non-static data members

typedef struct lfMember_16t {
    unsigned short  leaf;           // LF_MEMBER_16t
    CV_typ16_t      index;          // index of type record for field
    CV_fldattr_t    attr;           // attribute mask
    unsigned char   offset[CV_ZEROLEN];       // variable length offset of field followed
                                    // by length prefixed name of field
} lfMember_16t;

typedef struct lfMember {
    unsigned short  leaf;           // LF_MEMBER
    CV_fldattr_t    attr;           // attribute mask
    CV_typ_t        index;          // index of type record for field
    unsigned char   offset[CV_ZEROLEN];       // variable length offset of field followed
                                    // by length prefixed name of field
} lfMember;



//  type record for static data members

typedef struct lfSTMember_16t {
    unsigned short  leaf;           // LF_STMEMBER_16t
    CV_typ16_t      index;          // index of type record for field
    CV_fldattr_t    attr;           // attribute mask
    unsigned char   Name[1];        // length prefixed name of field
} lfSTMember_16t;

typedef struct lfSTMember {
    unsigned short  leaf;           // LF_STMEMBER
    CV_fldattr_t    attr;           // attribute mask
    CV_typ_t        index;          // index of type record for field
    unsigned char   Name[1];        // length prefixed name of field
} lfSTMember;



//      subfield record for virtual function table pointer

typedef struct lfVFuncTab_16t {
    unsigned short  leaf;           // LF_VFUNCTAB_16t
    CV_typ16_t      type;           // type index of pointer
} lfVFuncTab_16t;

typedef struct lfVFuncTab {
    unsigned short  leaf;           // LF_VFUNCTAB
    _2BYTEPAD       pad0;           // internal padding, must be 0
    CV_typ_t        type;           // type index of pointer
} lfVFuncTab;



//      subfield record for virtual function table pointer with offset

typedef struct lfVFuncOff_16t {
    unsigned short  leaf;           // LF_VFUNCOFF_16t
    CV_typ16_t      type;           // type index of pointer
    CV_off32_t      offset;         // offset of virtual function table pointer
} lfVFuncOff_16t;

typedef struct lfVFuncOff {
    unsigned short  leaf;           // LF_VFUNCOFF
    _2BYTEPAD       pad0;           // internal padding, must be 0.
    CV_typ_t        type;           // type index of pointer
    CV_off32_t      offset;         // offset of virtual function table pointer
} lfVFuncOff;



//      subfield record for overloaded method list


typedef struct lfMethod_16t {
    unsigned short  leaf;           // LF_METHOD_16t
    unsigned short  count;          // number of occurrences of function
    CV_typ16_t      mList;          // index to LF_METHODLIST record
    unsigned char   Name[1];        // length prefixed name of method
} lfMethod_16t;

typedef struct lfMethod {
    unsigned short  leaf;           // LF_METHOD
    unsigned short  count;          // number of occurrences of function
    CV_typ_t        mList;          // index to LF_METHODLIST record
    unsigned char   Name[1];        // length prefixed name of method
} lfMethod;



//      subfield record for nonoverloaded method


typedef struct lfOneMethod_16t {
    unsigned short leaf;            // LF_ONEMETHOD_16t
    CV_fldattr_t   attr;            // method attribute
    CV_typ16_t     index;           // index to type record for procedure
    unsigned long  vbaseoff[CV_ZEROLEN];    // offset in vfunctable if
                                    // intro virtual followed by
                                    // length prefixed name of method
} lfOneMethod_16t;

typedef struct lfOneMethod {
    unsigned short leaf;            // LF_ONEMETHOD
    CV_fldattr_t   attr;            // method attribute
    CV_typ_t       index;           // index to type record for procedure
    unsigned long  vbaseoff[CV_ZEROLEN];    // offset in vfunctable if
                                    // intro virtual followed by
                                    // length prefixed name of method
} lfOneMethod;


//      subfield record for enumerate

typedef struct lfEnumerate {
    unsigned short  leaf;       // LF_ENUMERATE
    CV_fldattr_t    attr;       // access
    unsigned char   value[CV_ZEROLEN];    // variable length value field followed
                                // by length prefixed name
} lfEnumerate;


//  type record for nested (scoped) type definition

typedef struct lfNestType_16t {
    unsigned short  leaf;       // LF_NESTTYPE_16t
    CV_typ16_t      index;      // index of nested type definition
    unsigned char   Name[1];    // length prefixed type name
} lfNestType_16t;

typedef struct lfNestType {
    unsigned short  leaf;       // LF_NESTTYPE
    _2BYTEPAD       pad0;       // internal padding, must be 0
    CV_typ_t        index;      // index of nested type definition
    unsigned char   Name[1];    // length prefixed type name
} lfNestType;

//  type record for nested (scoped) type definition, with attributes
//  new records for vC v5.0, no need to have 16-bit ti versions.

typedef struct lfNestTypeEx {
    unsigned short  leaf;       // LF_NESTTYPEEX
    CV_fldattr_t    attr;       // member access
    CV_typ_t        index;      // index of nested type definition
    unsigned char   Name[1];    // length prefixed type name
} lfNestTypeEx;

//  type record for modifications to members

typedef struct lfMemberModify {
    unsigned short  leaf;       // LF_MEMBERMODIFY
    CV_fldattr_t    attr;       // the new attributes
    CV_typ_t        index;      // index of base class type definition
    unsigned char   Name[1];    // length prefixed member name
} lfMemberModify;

//  type record for pad leaf

typedef struct lfPad {
    unsigned char   leaf;
} SYM_PAD;



//  Symbol definitions

typedef enum SYM_ENUM_e {
    S_COMPILE       =  0x0001, // Compile flags symbol
    S_REGISTER_16t  =  0x0002, // Register variable
    S_CONSTANT_16t  =  0x0003, // constant symbol
    S_UDT_16t       =  0x0004, // User defined type
    S_SSEARCH       =  0x0005, // Start Search
    S_END           =  0x0006, // Block, procedure, "with" or thunk end
    S_SKIP          =  0x0007, // Reserve symbol space in $$Symbols table
    S_CVRESERVE     =  0x0008, // Reserved symbol for CV internal use
#ifdef LNGNM
    S_OBJNAME_ST    =  0x0009, // path to object file name
#else
    S_OBJNAME       =  0x0009, // path to object file name
#endif
    S_ENDARG        =  0x000a, // end of argument/return list
    S_COBOLUDT_16t  =  0x000b, // special UDT for cobol that does not symbol pack
    S_MANYREG_16t   =  0x000c, // multiple register variable
    S_RETURN        =  0x000d, // return description symbol
    S_ENTRYTHIS     =  0x000e, // description of this pointer on entry

    S_BPREL16       =  0x0100, // BP-relative
    S_LDATA16       =  0x0101, // Module-local symbol
    S_GDATA16       =  0x0102, // Global data symbol
    S_PUB16         =  0x0103, // a public symbol
    S_LPROC16       =  0x0104, // Local procedure start
    S_GPROC16       =  0x0105, // Global procedure start
    S_THUNK16       =  0x0106, // Thunk Start
    S_BLOCK16       =  0x0107, // block start
    S_WITH16        =  0x0108, // with start
    S_LABEL16       =  0x0109, // code label
    S_CEXMODEL16    =  0x010a, // change execution model
    S_VFTABLE16     =  0x010b, // address of virtual function table
    S_REGREL16      =  0x010c, // register relative address

    S_BPREL32_16t   =  0x0200, // BP-relative
    S_LDATA32_16t   =  0x0201, // Module-local symbol
    S_GDATA32_16t   =  0x0202, // Global data symbol
    S_PUB32_16t     =  0x0203, // a public symbol (CV internal reserved)
    S_LPROC32_16t   =  0x0204, // Local procedure start
    S_GPROC32_16t   =  0x0205, // Global procedure start
#ifdef LNGNM
    S_THUNK32_ST    =  0x0206, // Thunk Start
    S_BLOCK32_ST    =  0x0207, // block start
    S_WITH32_ST     =  0x0208, // with start
    S_LABEL32_ST    =  0x0209, // code label
#else
    S_THUNK32       =  0x0206, // Thunk Start
    S_BLOCK32       =  0x0207, // block start
    S_WITH32        =  0x0208, // with start
    S_LABEL32       =  0x0209, // code label
#endif
    S_CEXMODEL32    =  0x020a, // change execution model
    S_VFTABLE32_16t =  0x020b, // address of virtual function table
    S_REGREL32_16t  =  0x020c, // register relative address
    S_LTHREAD32_16t =  0x020d, // local thread storage
    S_GTHREAD32_16t =  0x020e, // global thread storage
    S_SLINK32       =  0x020f, // static link for MIPS EH implementation

    S_LPROCMIPS_16t =  0x0300, // Local procedure start
    S_GPROCMIPS_16t =  0x0301, // Global procedure start

#ifdef LNGNM
    // if these ref symbols have names following then the names are in ST format
    S_PROCREF_ST    =  0x0400, // Reference to a procedure
    S_DATAREF_ST    =  0x0401, // Reference to data
#else
    S_PROCREF       =  0x0400, // Reference to a procedure
    S_DATAREF       =  0x0401, // Reference to data
#endif
    S_ALIGN         =  0x0402, // Used for page alignment of symbols

#ifdef LNGNM
    S_LPROCREF_ST   =  0x0403, // Local Reference to a procedure
#else
    S_LPROCREF      =  0x0403, // Local Reference to a procedure
#endif
    S_OEM           =  0x0404, // OEM defined symbol

    // sym records with 32-bit types embedded instead of 16-bit
    // all have 0x1000 bit set for easy identification
    // only do the 32-bit target versions since we don't really
    // care about 16-bit ones anymore.
    S_TI16_MAX          =  0x1000,
#ifndef LNGNM
    S_REGISTER      =  0x1001, // Register variable
    S_CONSTANT      =  0x1002, // constant symbol
    S_UDT           =  0x1003, // User defined type
    S_COBOLUDT      =  0x1004, // special UDT for cobol that does not symbol pack
    S_MANYREG       =  0x1005, // multiple register variable
    S_BPREL32       =  0x1006, // BP-relative
    S_LDATA32       =  0x1007, // Module-local symbol
    S_GDATA32       =  0x1008, // Global data symbol
    S_PUB32         =  0x1009, // a public symbol (CV internal reserved)
    S_LPROC32       =  0x100a, // Local procedure start
    S_GPROC32       =  0x100b, // Global procedure start
    S_VFTABLE32     =  0x100c, // address of virtual function table
    S_REGREL32      =  0x100d, // register relative address
    S_LTHREAD32     =  0x100e, // local thread storage
    S_GTHREAD32     =  0x100f, // global thread storage

    S_LPROCMIPS     =  0x1010, // Local procedure start
    S_GPROCMIPS     =  0x1011, // Global procedure start

    // new symbol records for edit and continue information

    S_FRAMEPROC     =  0x1012, // extra frame and proc information
    S_COMPILE2      =  0x1013, // extended compile flags and info

    // new symbols necessary for 16-bit enumerates of IA64 registers
    // and IA64 specific symbols

    S_MANYREG2      =  0x1014, // multiple register variable
    S_LPROCIA64     =  0x1015, // Local procedure start (IA64)
    S_GPROCIA64     =  0x1016, // Global procedure start (IA64)

    // Local symbols for IL
    S_LOCALSLOT     = 0x1017,  // local IL sym with field for local slot index
    S_SLOT          = S_LOCALSLOT,  // alias for LOCALSLOT
    S_PARAMSLOT     = 0x1018,  // local IL sym with field for parameter slot index

    S_ANNOTATION    =  0x1019, // Annotation string literals

    // symbols to support managed code debugging
    S_GMANPROC      =  0x101a,  // Global proc
    S_LMANPROC      =  0x101b,  // Local proc
    S_RESERVED1     =  0x101c,  // reserved
    S_RESERVED2     =  0x101d,  // reserved
    S_RESERVED3     =  0x101e,  // reserved
    S_RESERVED4     =  0x101f,  // reserved
    S_LMANDATA      =  0x1020,  // Static data
    S_GMANDATA      =  0x1021,  // Global data
    S_MANFRAMEREL   =  0x1022,  // Frame relative local var or param
    S_MANREGISTER   =  0x1023,  // Register local var or param
    S_MANSLOT       =  0x1024,  // Slot local var or param
    S_MANMANYREG    =  0x1025,  // Multiple register local var or param
    S_MANREGREL     =  0x1026,  // Register relative local var or param
    S_MANMANYREG2   =  0x1027,  // Multiple register local var or param
    S_MANTYPREF     =  0x1028,  // Index for type referenced by name from metadata
    S_UNAMESPACE    =  0x1029,  // Using namespace

    S_NOLNGNAMEMAX,
    S_NOLNGNAMELAST = S_NOLNGNAMEMAX - 1,

    // Keep the long name and non-long name versions of S_ANNOTATIONREF
    // and S_TOKENREF the same
    //
    S_ANNOTATIONREF =  0x1128,  // Reference to S_ANNOTATION symbol

#else
    S_REGISTER_ST   =  0x1001, // Register variable
    S_CONSTANT_ST   =  0x1002, // constant symbol
    S_UDT_ST        =  0x1003, // User defined type
    S_COBOLUDT_ST   =  0x1004, // special UDT for cobol that does not symbol pack
    S_MANYREG_ST    =  0x1005, // multiple register variable
    S_BPREL32_ST    =  0x1006, // BP-relative
    S_LDATA32_ST    =  0x1007, // Module-local symbol
    S_GDATA32_ST    =  0x1008, // Global data symbol
    S_PUB32_ST      =  0x1009, // a public symbol (CV internal reserved)
    S_LPROC32_ST    =  0x100a, // Local procedure start
    S_GPROC32_ST    =  0x100b, // Global procedure start
    S_VFTABLE32     =  0x100c, // address of virtual function table
    S_REGREL32_ST   =  0x100d, // register relative address
    S_LTHREAD32_ST  =  0x100e, // local thread storage
    S_GTHREAD32_ST  =  0x100f, // global thread storage

    S_LPROCMIPS_ST  =  0x1010, // Local procedure start
    S_GPROCMIPS_ST  =  0x1011, // Global procedure start

    // new symbol records for edit and continue information

    S_FRAMEPROC     =  0x1012, // extra frame and proc information
    S_COMPILE2_ST   =  0x1013, // extended compile flags and info

    // new symbols necessary for 16-bit enumerates of IA64 registers
    // and IA64 specific symbols

    S_MANYREG2_ST   =  0x1014, // multiple register variable
    S_LPROCIA64_ST  =  0x1015, // Local procedure start (IA64)
    S_GPROCIA64_ST  =  0x1016, // Global procedure start (IA64)

    // Local symbols for IL
    S_LOCALSLOT_ST  = 0x1017,  // local IL sym with field for local slot index
    S_PARAMSLOT_ST  = 0x1018,  // local IL sym with field for parameter slot index

    S_ANNOTATION    =  0x1019, // Annotation string literals

    // symbols to support managed code debugging
    S_GMANPROC_ST   =  0x101a,  // Global proc
    S_LMANPROC_ST   =  0x101b,  // Local proc
    S_RESERVED1     =  0x101c,  // reserved
    S_RESERVED2     =  0x101d,  // reserved
    S_RESERVED3     =  0x101e,  // reserved
    S_RESERVED4     =  0x101f,  // reserved
    S_LMANDATA_ST   =  0x1020,
    S_GMANDATA_ST   =  0x1021,
    S_MANFRAMEREL_ST=  0x1022,
    S_MANREGISTER_ST=  0x1023,
    S_MANSLOT_ST    =  0x1024,
    S_MANMANYREG_ST =  0x1025,
    S_MANREGREL_ST  =  0x1026,
    S_MANMANYREG2_ST=  0x1027,
    S_MANTYPREF     =  0x1028,  // Index for type referenced by name from metadata
    S_UNAMESPACE_ST =  0x1029,  // Using namespace

    // Symbols w/ SZ name fields. All name fields contain utf8 encoded strings.
    S_ST_MAX        =  0x1100,  // starting point for SZ name symbols

    S_OBJNAME       =  0x1101, // path to object file name
    S_THUNK32       =  0x1102, // Thunk Start
    S_BLOCK32       =  0x1103, // block start
    S_WITH32        =  0x1104, // with start
    S_LABEL32       =  0x1105, // code label
    S_REGISTER      =  0x1106, // Register variable
    S_CONSTANT      =  0x1107, // constant symbol
    S_UDT           =  0x1108, // User defined type
    S_COBOLUDT      =  0x1109, // special UDT for cobol that does not symbol pack
    S_MANYREG       =  0x110a, // multiple register variable
    S_BPREL32       =  0x110b, // BP-relative
    S_LDATA32       =  0x110c, // Module-local symbol
    S_GDATA32       =  0x110d, // Global data symbol
    S_PUB32         =  0x110e, // a public symbol (CV internal reserved)
    S_LPROC32       =  0x110f, // Local procedure start
    S_GPROC32       =  0x1110, // Global procedure start
    S_REGREL32      =  0x1111, // register relative address
    S_LTHREAD32     =  0x1112, // local thread storage
    S_GTHREAD32     =  0x1113, // global thread storage

    S_LPROCMIPS     =  0x1114, // Local procedure start
    S_GPROCMIPS     =  0x1115, // Global procedure start
    S_COMPILE2      =  0x1116, // extended compile flags and info
    S_MANYREG2      =  0x1117, // multiple register variable
    S_LPROCIA64     =  0x1118, // Local procedure start (IA64)
    S_GPROCIA64     =  0x1119, // Global procedure start (IA64)
    S_LOCALSLOT     =  0x111a, // local IL sym with field for local slot index
    S_SLOT          = S_LOCALSLOT,  // alias for LOCALSLOT
    S_PARAMSLOT     =  0x111b, // local IL sym with field for parameter slot index

    // symbols to support managed code debugging
    S_LMANDATA      =  0x111c,
    S_GMANDATA      =  0x111d,
    S_MANFRAMEREL   =  0x111e,
    S_MANREGISTER   =  0x111f,
    S_MANSLOT       =  0x1120,
    S_MANMANYREG    =  0x1121,
    S_MANREGREL     =  0x1122,
    S_MANMANYREG2   =  0x1123,
    S_UNAMESPACE    =  0x1124,  // Using namespace

    // ref symbols with name fields
    S_PROCREF       =  0x1125, // Reference to a procedure
    S_DATAREF       =  0x1126, // Reference to data
    S_LPROCREF      =  0x1127, // Local Reference to a procedure
    S_ANNOTATIONREF =  0x1128,  // Reference to an S_ANNOTATION symbol
    S_TOKENREF      =  0x1129,  // Reference to one of the many MANPROCSYM's

    // continuation of managed symbols
    S_GMANPROC      =  0x112a,  // Global proc
    S_LMANPROC      =  0x112b,  // Local proc

    // short, light-weight thunks
    S_TRAMPOLINE    =  0x112c,  // trampoline thunks
    S_MANCONSTANT   =  0x112d,  // constants with metadata type info

    // native attributed local/parms
    S_ATTR_FRAMEREL =  0x112e,  // relative to virtual frame ptr
    S_ATTR_REGISTER =  0x112f,  // stored in a register
    S_ATTR_REGREL   =  0x1130,  // relative to register (alternate frame ptr)
    S_ATTR_MANYREG  =  0x1131,  // stored in >1 register

    // Separated code (from the compiler) support
    S_SEPCODE       =  0x1132,

#endif

    S_RECTYPE_MAX,             // one greater than last
    S_RECTYPE_LAST  = S_RECTYPE_MAX - 1,

} SYM_ENUM_e;






//  enum describing compile flag ambient data model


typedef enum CV_CFL_DATA {
    CV_CFL_DNEAR    = 0x00,
    CV_CFL_DFAR     = 0x01,
    CV_CFL_DHUGE    = 0x02
} CV_CFL_DATA;




//  enum describing compile flag ambiant code model


typedef enum CV_CFL_CODE_e {
    CV_CFL_CNEAR    = 0x00,
    CV_CFL_CFAR     = 0x01,
    CV_CFL_CHUGE    = 0x02
} CV_CFL_CODE_e;




//  enum describing compile flag target floating point package

typedef enum CV_CFL_FPKG_e {
    CV_CFL_NDP      = 0x00,
    CV_CFL_EMU      = 0x01,
    CV_CFL_ALT      = 0x02
} CV_CFL_FPKG_e;


// enum describing function return method


typedef struct CV_PROCFLAGS {
    union {
        unsigned char   bAll;
        unsigned char   grfAll;
        struct {
            unsigned char CV_PFLAG_NOFPO     :1; // frame pointer present
            unsigned char CV_PFLAG_INT       :1; // interrupt return
            unsigned char CV_PFLAG_FAR       :1; // far return
            unsigned char CV_PFLAG_NEVER     :1; // function does not return
            unsigned char CV_PFLAG_NOTREACHED:1; // label isn't fallen into
            unsigned char CV_PFLAG_CUST_CALL :1; // custom calling convention
            unsigned char CV_PFLAG_NOINLINE  :1; // function marked as noinline
            unsigned char unused             :1; //
        };
    };
} CV_PROCFLAGS;

// Extended proc flags
//
typedef struct CV_EXPROCFLAGS {
    CV_PROCFLAGS cvpf;
    union {
        unsigned char   grfAll;
        struct {
            unsigned char   __reserved      :8; // must be zero
        };
    };
} CV_EXPROCFLAGS;

// local variable flags
typedef struct CV_LVARFLAGS {
    unsigned short fIsParam          :1; // variable is a parameter
    unsigned short fAddrTaken        :1; // address is taken
    unsigned short fCompGenx         :1; // variable is compiler generated
    unsigned short unused            :13;// must be zero
} CV_LVARFLAGS;

// extended attributes common to all local variables
typedef struct CV_lvar_attr {
    CV_uoff32_t     off;        // first code address where var is live
    unsigned short  seg;
    CV_LVARFLAGS    flags;      // local var flags
} CV_lvar_attr;

// enum describing function data return method

typedef enum CV_GENERIC_STYLE_e {
    CV_GENERIC_VOID   = 0x00,       // void return type
    CV_GENERIC_REG    = 0x01,       // return data is in registers
    CV_GENERIC_ICAN   = 0x02,       // indirect caller allocated near
    CV_GENERIC_ICAF   = 0x03,       // indirect caller allocated far
    CV_GENERIC_IRAN   = 0x04,       // indirect returnee allocated near
    CV_GENERIC_IRAF   = 0x05,       // indirect returnee allocated far
    CV_GENERIC_UNUSED = 0x06        // first unused
} CV_GENERIC_STYLE_e;


typedef struct CV_GENERIC_FLAG {
    unsigned short  cstyle  :1;     // true push varargs right to left
    unsigned short  rsclean :1;     // true if returnee stack cleanup
    unsigned short  unused  :14;    // unused
} CV_GENERIC_FLAG;


// flag bitfields for separated code attributes

typedef struct CV_SEPCODEFLAGS {
    unsigned long fIsLexicalScope : 1;     // S_SEPCODE doubles as lexical scope
    unsigned long fReturnsToParent : 1;    // code frag returns to parent
    unsigned long pad : 30;                // must be zero
} CV_SEPCODEFLAGS;

// Generic layout for symbol records

typedef struct SYMTYPE {
    unsigned short      reclen;     // Record length
    unsigned short      rectyp;     // Record type
    char                data[CV_ZEROLEN];
} SYMTYPE;

__INLINE SYMTYPE *NextSym (SYMTYPE * pSym) {
    return (SYMTYPE *) ((char *)pSym + pSym->reclen + sizeof(unsigned short));
}

//      non-model specific symbol types



typedef struct REGSYM_16t {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_REGISTER_16t
    CV_typ16_t      typind;     // Type index
    unsigned short  reg;        // register enumerate
    unsigned char   name[1];    // Length-prefixed name
} REGSYM_16t;

typedef struct REGSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_REGISTER
    CV_typ_t        typind;     // Type index or Metadata token
    unsigned short  reg;        // register enumerate
    unsigned char   name[1];    // Length-prefixed name
} REGSYM;

typedef struct ATTRREGSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_MANREGISTER | S_ATTR_REGISTER
    CV_typ_t        typind;     // Type index or Metadata token
    CV_lvar_attr    attr;       // local var attributes
    unsigned short  reg;        // register enumerate
    unsigned char   name[1];    // Length-prefixed name
} ATTRREGSYM;

typedef struct MANYREGSYM_16t {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_MANYREG_16t
    CV_typ16_t      typind;     // Type index
    unsigned char   count;      // count of number of registers
    unsigned char   reg[1];     // count register enumerates followed by
                                // length-prefixed name.  Registers are
                                // most significant first.
} MANYREGSYM_16t;

typedef struct MANYREGSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_MANYREG
    CV_typ_t        typind;     // Type index or metadata token
    unsigned char   count;      // count of number of registers
    unsigned char   reg[1];     // count register enumerates followed by
                                // length-prefixed name.  Registers are
                                // most significant first.
} MANYREGSYM;

typedef struct MANYREGSYM2 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_MANYREG2
    CV_typ_t        typind;     // Type index or metadata token
    unsigned short  count;      // count of number of registers
    unsigned short  reg[1];     // count register enumerates followed by
                                // length-prefixed name.  Registers are
                                // most significant first.
} MANYREGSYM2;

typedef struct ATTRMANYREGSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_MANMANYREG
    CV_typ_t        typind;     // Type index or metadata token
    CV_lvar_attr    attr;       // local var attributes
    unsigned char   count;      // count of number of registers
    unsigned char   reg[1];     // count register enumerates followed by
                                // length-prefixed name.  Registers are
                                // most significant first.
    unsigned char   name[CV_ZEROLEN];   // utf-8 encoded zero terminate name
} ATTRMANYREGSYM;

typedef struct ATTRMANYREGSYM2 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_MANMANYREG2 | S_ATTR_MANYREG
    CV_typ_t        typind;     // Type index or metadata token
    CV_lvar_attr    attr;       // local var attributes
    unsigned short  count;      // count of number of registers
    unsigned short  reg[1];     // count register enumerates followed by
                                // length-prefixed name.  Registers are
                                // most significant first.
    unsigned char   name[CV_ZEROLEN];   // utf-8 encoded zero terminate name
} ATTRMANYREGSYM2;

typedef struct CONSTSYM_16t {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_CONSTANT_16t
    CV_typ16_t      typind;     // Type index (containing enum if enumerate)
    unsigned short  value;      // numeric leaf containing value
    unsigned char   name[CV_ZEROLEN];     // Length-prefixed name
} CONSTSYM_16t;

typedef struct CONSTSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_CONSTANT or S_MANCONSTANT
    CV_typ_t        typind;     // Type index (containing enum if enumerate) or metadata token
    unsigned short  value;      // numeric leaf containing value
    unsigned char   name[CV_ZEROLEN];     // Length-prefixed name
} CONSTSYM;


typedef struct UDTSYM_16t {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_UDT_16t | S_COBOLUDT_16t
    CV_typ16_t      typind;     // Type index
    unsigned char   name[1];    // Length-prefixed name
} UDTSYM_16t;


typedef struct UDTSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_UDT | S_COBOLUDT
    CV_typ_t        typind;     // Type index
    unsigned char   name[1];    // Length-prefixed name
} UDTSYM;

typedef struct MANTYPREF {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_MANTYPREF
    CV_typ_t        typind;     // Type index
} MANTYPREF;

typedef struct SEARCHSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_SSEARCH
    unsigned long   startsym;   // offset of the procedure
    unsigned short  seg;        // segment of symbol
} SEARCHSYM;


typedef struct CFLAGSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_COMPILE
    unsigned char   machine;    // target processor
    struct  {
        unsigned char   language    :8; // language index
        unsigned char   pcode       :1; // true if pcode present
        unsigned char   floatprec   :2; // floating precision
        unsigned char   floatpkg    :2; // float package
        unsigned char   ambdata     :3; // ambient data model
        unsigned char   ambcode     :3; // ambient code model
        unsigned char   mode32      :1; // true if compiled 32 bit mode
        unsigned char   pad         :4; // reserved
    } flags;
    unsigned char       ver[1];     // Length-prefixed compiler version string
} CFLAGSYM;


typedef struct COMPILESYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_COMPILE2
    struct {
        unsigned long   iLanguage       :  8;   // language index
        unsigned long   fEC             :  1;   // compiled for E/C
        unsigned long   fNoDbgInfo      :  1;   // not compiled with debug info
        unsigned long   fLTCG           :  1;   // compiled with LTCG
        unsigned long   fNoDataAlign    :  1;   // compiled with -Bzalign
        unsigned long   fManagedPresent :  1;   // managed code/data present
        unsigned long   pad             : 19;   // reserved, must be 0
    } flags;
    unsigned short  machine;    // target processor
    unsigned short  verFEMajor; // front end major version #
    unsigned short  verFEMinor; // front end minor version #
    unsigned short  verFEBuild; // front end build version #
    unsigned short  verMajor;   // back end major version #
    unsigned short  verMinor;   // back end minor version #
    unsigned short  verBuild;   // back end build version #
    unsigned char   verSt[1];   // Length-prefixed compiler version string, followed
                                //  by an optional block of zero terminated strings
                                //  terminated with a double zero.
} COMPILESYM;


typedef struct OBJNAMESYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_OBJNAME
    unsigned long   signature;  // signature
    unsigned char   name[1];    // Length-prefixed name
} OBJNAMESYM;


typedef struct ENDARGSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_ENDARG
} ENDARGSYM;


typedef struct RETURNSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_RETURN
    CV_GENERIC_FLAG flags;      // flags
    unsigned char   style;      // CV_GENERIC_STYLE_e return style
                                // followed by return method data
} RETURNSYM;


typedef struct ENTRYTHISSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_ENTRYTHIS
    unsigned char   thissym;    // symbol describing this pointer on entry
} ENTRYTHISSYM;


//      symbol types for 16:16 memory model


typedef struct BPRELSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_BPREL16
    CV_off16_t      off;        // BP-relative offset
    CV_typ16_t      typind;     // Type index
    unsigned char   name[1];    // Length-prefixed name
} BPRELSYM16;


typedef struct DATASYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_LDATA or S_GDATA
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    CV_typ16_t      typind;     // Type index
    unsigned char   name[1];    // Length-prefixed name
} DATASYM16;
typedef DATASYM16 PUBSYM16;


typedef struct PROCSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_GPROC16 or S_LPROC16
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    unsigned short  len;        // Proc length
    unsigned short  DbgStart;   // Debug start offset
    unsigned short  DbgEnd;     // Debug end offset
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    CV_typ16_t      typind;     // Type index
    CV_PROCFLAGS    flags;      // Proc flags
    unsigned char   name[1];    // Length-prefixed name
} PROCSYM16;


typedef struct THUNKSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_THUNK
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    unsigned short  len;        // length of thunk
    unsigned char   ord;        // THUNK_ORDINAL specifying type of thunk
    unsigned char   name[1];    // name of thunk
    unsigned char   variant[CV_ZEROLEN]; // variant portion of thunk
} THUNKSYM16;

typedef struct LABELSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_LABEL16
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    CV_PROCFLAGS    flags;      // flags
    unsigned char   name[1];    // Length-prefixed name
} LABELSYM16;


typedef struct BLOCKSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_BLOCK16
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned short  len;        // Block length
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    unsigned char   name[1];    // Length-prefixed name
} BLOCKSYM16;


typedef struct WITHSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_WITH16
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned short  len;        // Block length
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    unsigned char   expr[1];    // Length-prefixed expression
} WITHSYM16;


typedef enum CEXM_MODEL_e {
    CEXM_MDL_table          = 0x00, // not executable
    CEXM_MDL_jumptable      = 0x01, // Compiler generated jump table
    CEXM_MDL_datapad        = 0x02, // Data padding for alignment
    CEXM_MDL_native         = 0x20, // native (actually not-pcode)
    CEXM_MDL_cobol          = 0x21, // cobol
    CEXM_MDL_codepad        = 0x22, // Code padding for alignment
    CEXM_MDL_code           = 0x23, // code
    CEXM_MDL_sql            = 0x30, // sql
    CEXM_MDL_pcode          = 0x40, // pcode
    CEXM_MDL_pcode32Mac     = 0x41, // macintosh 32 bit pcode
    CEXM_MDL_pcode32MacNep  = 0x42, // macintosh 32 bit pcode native entry point
    CEXM_MDL_javaInt        = 0x50,
    CEXM_MDL_unknown        = 0xff
} CEXM_MODEL_e;

// use the correct enumerate name
#define CEXM_MDL_SQL CEXM_MDL_sql

typedef enum CV_COBOL_e {
    CV_COBOL_dontstop,
    CV_COBOL_pfm,
    CV_COBOL_false,
    CV_COBOL_extcall
} CV_COBOL_e;

typedef struct CEXMSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_CEXMODEL16
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    unsigned short  model;      // execution model
    union {
        struct  {
            CV_uoff16_t pcdtable;   // offset to pcode function table
            CV_uoff16_t pcdspi;     // offset to segment pcode information
        } pcode;
        struct {
            unsigned short  subtype;   // see CV_COBOL_e above
            unsigned short  flag;
        } cobol;
    };
} CEXMSYM16;


typedef struct VPATHSYM16 {
    unsigned short  reclen;     // record length
    unsigned short  rectyp;     // S_VFTPATH16
    CV_uoff16_t     off;        // offset of virtual function table
    unsigned short  seg;        // segment of virtual function table
    CV_typ16_t      root;       // type index of the root of path
    CV_typ16_t      path;       // type index of the path record
} VPATHSYM16;


typedef struct REGREL16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_REGREL16
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  reg;        // register index
    CV_typ16_t      typind;     // Type index
    unsigned char   name[1];    // Length-prefixed name
} REGREL16;


typedef struct BPRELSYM32_16t {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_BPREL32_16t
    CV_off32_t      off;        // BP-relative offset
    CV_typ16_t      typind;     // Type index
    unsigned char   name[1];    // Length-prefixed name
} BPRELSYM32_16t;

typedef struct BPRELSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_BPREL32
    CV_off32_t      off;        // BP-relative offset
    CV_typ_t        typind;     // Type index or Metadata token
    unsigned char   name[1];    // Length-prefixed name
} BPRELSYM32;

typedef struct FRAMERELSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_MANFRAMEREL | S_ATTR_FRAMEREL
    CV_off32_t      off;        // Frame relative offset
    CV_typ_t        typind;     // Type index or Metadata token
    CV_lvar_attr    attr;       // local var attributes
    unsigned char   name[1];    // Length-prefixed name
} FRAMERELSYM;

typedef FRAMERELSYM ATTRFRAMERELSYM;


typedef struct SLOTSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_LOCALSLOT or S_PARAMSLOT
    unsigned long   iSlot;      // slot index
    CV_typ_t        typind;     // Type index or Metadata token
    unsigned char   name[1];    // Length-prefixed name
} SLOTSYM32;

typedef struct ATTRSLOTSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_MANSLOT
    unsigned long   iSlot;      // slot index
    CV_typ_t        typind;     // Type index or Metadata token
    CV_lvar_attr    attr;       // local var attributes
    unsigned char   name[1];    // Length-prefixed name
} ATTRSLOTSYM;

typedef struct ANNOTATIONSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_ANNOTATION
    CV_uoff32_t     off;
    unsigned short  seg;
    unsigned short  csz;        // Count of zero terminated annotation strings
    unsigned char   rgsz[1];    // Sequence of zero terminated annotation strings
} ANNOTATIONSYM;

typedef struct DATASYM32_16t {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_LDATA32_16t, S_GDATA32_16t or S_PUB32_16t
    CV_uoff32_t     off;
    unsigned short  seg;
    CV_typ16_t      typind;     // Type index
    unsigned char   name[1];    // Length-prefixed name
} DATASYM32_16t;
typedef DATASYM32_16t PUBSYM32_16t;

typedef struct DATASYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_LDATA32, S_GDATA32 or S_PUB32, S_LMANDATA, S_GMANDATA
    CV_typ_t        typind;     // Type index, or Metadata token if a managed symbol
    CV_uoff32_t     off;
    unsigned short  seg;
    unsigned char   name[1];    // Length-prefixed name
} DATASYM32;

typedef enum CV_PUBSYMFLAGS_e
 {
    cvpsfNone     = 0,
    cvpsfCode     = 0x00000001,
    cvpsfFunction = 0x00000002,
    cvpsfManaged  = 0x00000004,
    cvpsfMSIL     = 0x00000008,
} CV_PUBSYMFLAGS_e;

typedef union CV_PUBSYMFLAGS {
    CV_pubsymflag_t grfFlags;
    struct {
        CV_pubsymflag_t fCode       : 1;    // set if public symbol refers to a code address
        CV_pubsymflag_t fFunction   : 1;    // set if public symbol is a function
        CV_pubsymflag_t fManaged    : 1;    // set if managed code (native or IL)
        CV_pubsymflag_t fMSIL       : 1;    // set if managed IL code
        CV_pubsymflag_t __unused    :28;    // must be zero
    };
} CV_PUBSYMFLAGS;

typedef struct PUBSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_PUB32
    CV_PUBSYMFLAGS  pubsymflags;
    CV_uoff32_t     off;
    unsigned short  seg;
    unsigned char   name[1];    // Length-prefixed name
} PUBSYM32;


typedef struct PROCSYM32_16t {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_GPROC32_16t or S_LPROC32_16t
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    unsigned long   len;        // Proc length
    unsigned long   DbgStart;   // Debug start offset
    unsigned long   DbgEnd;     // Debug end offset
    CV_uoff32_t     off;
    unsigned short  seg;
    CV_typ16_t      typind;     // Type index
    CV_PROCFLAGS    flags;      // Proc flags
    unsigned char   name[1];    // Length-prefixed name
} PROCSYM32_16t;

typedef struct PROCSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_GPROC32 or S_LPROC32
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    unsigned long   len;        // Proc length
    unsigned long   DbgStart;   // Debug start offset
    unsigned long   DbgEnd;     // Debug end offset
    CV_typ_t        typind;     // Type index
    CV_uoff32_t     off;
    unsigned short  seg;
    CV_PROCFLAGS    flags;      // Proc flags
    unsigned char   name[1];    // Length-prefixed name
} PROCSYM32;

typedef struct MANPROCSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_GMANPROC, S_LMANPROC, S_GMANPROCIA64 or S_LMANPROCIA64
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    unsigned long   len;        // Proc length
    unsigned long   DbgStart;   // Debug start offset
    unsigned long   DbgEnd;     // Debug end offset
    CV_tkn_t        token;      // COM+ metadata token for method
    CV_uoff32_t     off;
    unsigned short  seg;
    CV_PROCFLAGS    flags;      // Proc flags
    unsigned short  retReg;     // Register return value is in (may not be used for all archs)
    unsigned char   name[1];    // optional name field
} MANPROCSYM;

typedef struct MANPROCSYMMIPS {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_GMANPROCMIPS or S_LMANPROCMIPS
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    unsigned long   len;        // Proc length
    unsigned long   DbgStart;   // Debug start offset
    unsigned long   DbgEnd;     // Debug end offset
    unsigned long   regSave;    // int register save mask
    unsigned long   fpSave;     // fp register save mask
    CV_uoff32_t     intOff;     // int register save offset
    CV_uoff32_t     fpOff;      // fp register save offset
    CV_tkn_t        token;      // COM+ token type
    CV_uoff32_t     off;
    unsigned short  seg;
    unsigned char   retReg;     // Register return value is in
    unsigned char   frameReg;   // Frame pointer register
    unsigned char   name[1];    // optional name field
} MANPROCSYMMIPS;

typedef struct THUNKSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_THUNK32
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    CV_uoff32_t     off;
    unsigned short  seg;
    unsigned short  len;        // length of thunk
    unsigned char   ord;        // THUNK_ORDINAL specifying type of thunk
    unsigned char   name[1];    // Length-prefixed name
    unsigned char   variant[CV_ZEROLEN]; // variant portion of thunk
} THUNKSYM32;

typedef enum TRAMP_e {      // Trampoline subtype
    trampIncremental,           // incremental thunks
    trampBranchIsland,          // Branch island thunks
} TRAMP_e;

typedef struct TRAMPOLINESYM {  // Trampoline thunk symbol
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_TRAMPOLINE
    unsigned short  trampType;  // trampoline sym subtype
    unsigned short  cbThunk;    // size of the thunk
    CV_uoff32_t     offThunk;   // offset of the thunk
    CV_uoff32_t     offTarget;  // offset of the target of the thunk
    unsigned short  sectThunk;  // section index of the thunk
    unsigned short  sectTarget; // section index of the target of the thunk
} TRAMPOLINE;

typedef struct LABELSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_LABEL32
    CV_uoff32_t     off;
    unsigned short  seg;
    CV_PROCFLAGS    flags;      // flags
    unsigned char   name[1];    // Length-prefixed name
} LABELSYM32;


typedef struct BLOCKSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_BLOCK32
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   len;        // Block length
    CV_uoff32_t     off;        // Offset in code segment
    unsigned short  seg;        // segment of label
    unsigned char   name[1];    // Length-prefixed name
} BLOCKSYM32;


typedef struct WITHSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_WITH32
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   len;        // Block length
    CV_uoff32_t     off;        // Offset in code segment
    unsigned short  seg;        // segment of label
    unsigned char   expr[1];    // Length-prefixed expression string
} WITHSYM32;



typedef struct CEXMSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_CEXMODEL32
    CV_uoff32_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    unsigned short  model;      // execution model
    union {
        struct  {
            CV_uoff32_t pcdtable;   // offset to pcode function table
            CV_uoff32_t pcdspi;     // offset to segment pcode information
        } pcode;
        struct {
            unsigned short  subtype;   // see CV_COBOL_e above
            unsigned short  flag;
        } cobol;
        struct {
            CV_uoff32_t calltableOff; // offset to function table
            unsigned short calltableSeg; // segment of function table
        } pcode32Mac;
    };
} CEXMSYM32;



typedef struct VPATHSYM32_16t {
    unsigned short  reclen;     // record length
    unsigned short  rectyp;     // S_VFTABLE32_16t
    CV_uoff32_t     off;        // offset of virtual function table
    unsigned short  seg;        // segment of virtual function table
    CV_typ16_t      root;       // type index of the root of path
    CV_typ16_t      path;       // type index of the path record
} VPATHSYM32_16t;

typedef struct VPATHSYM32 {
    unsigned short  reclen;     // record length
    unsigned short  rectyp;     // S_VFTABLE32
    CV_typ_t        root;       // type index of the root of path
    CV_typ_t        path;       // type index of the path record
    CV_uoff32_t     off;        // offset of virtual function table
    unsigned short  seg;        // segment of virtual function table
} VPATHSYM32;





typedef struct REGREL32_16t {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_REGREL32_16t
    CV_uoff32_t     off;        // offset of symbol
    unsigned short  reg;        // register index for symbol
    CV_typ16_t      typind;     // Type index
    unsigned char   name[1];    // Length-prefixed name
} REGREL32_16t;

typedef struct REGREL32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_REGREL32
    CV_uoff32_t     off;        // offset of symbol
    CV_typ_t        typind;     // Type index or metadata token
    unsigned short  reg;        // register index for symbol
    unsigned char   name[1];    // Length-prefixed name
} REGREL32;

typedef struct ATTRREGREL {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_MANREGREL | S_ATTR_REGREL
    CV_uoff32_t     off;        // offset of symbol
    CV_typ_t        typind;     // Type index or metadata token
    unsigned short  reg;        // register index for symbol
    CV_lvar_attr    attr;       // local var attributes
    unsigned char   name[1];    // Length-prefixed name
} ATTRREGREL;

typedef ATTRREGREL  ATTRREGRELSYM;

typedef struct THREADSYM32_16t {
    unsigned short  reclen;     // record length
    unsigned short  rectyp;     // S_LTHREAD32_16t | S_GTHREAD32_16t
    CV_uoff32_t     off;        // offset into thread storage
    unsigned short  seg;        // segment of thread storage
    CV_typ16_t      typind;     // type index
    unsigned char   name[1];    // length prefixed name
} THREADSYM32_16t;

typedef struct THREADSYM32 {
    unsigned short  reclen;     // record length
    unsigned short  rectyp;     // S_LTHREAD32 | S_GTHREAD32
    CV_typ_t        typind;     // type index
    CV_uoff32_t     off;        // offset into thread storage
    unsigned short  seg;        // segment of thread storage
    unsigned char   name[1];    // length prefixed name
} THREADSYM32;

typedef struct SLINK32 {
    unsigned short  reclen;     // record length
    unsigned short  rectyp;     // S_SLINK32
    unsigned long   framesize;  // frame size of parent procedure
    CV_off32_t      off;        // signed offset where the static link was saved relative to the value of reg
    unsigned short  reg;
} SLINK32;

typedef struct PROCSYMMIPS_16t {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_GPROCMIPS_16t or S_LPROCMIPS_16t
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    unsigned long   len;        // Proc length
    unsigned long   DbgStart;   // Debug start offset
    unsigned long   DbgEnd;     // Debug end offset
    unsigned long   regSave;    // int register save mask
    unsigned long   fpSave;     // fp register save mask
    CV_uoff32_t     intOff;     // int register save offset
    CV_uoff32_t     fpOff;      // fp register save offset
    CV_uoff32_t     off;        // Symbol offset
    unsigned short  seg;        // Symbol segment
    CV_typ16_t      typind;     // Type index
    unsigned char   retReg;     // Register return value is in
    unsigned char   frameReg;   // Frame pointer register
    unsigned char   name[1];    // Length-prefixed name
} PROCSYMMIPS_16t;

typedef struct PROCSYMMIPS {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_GPROCMIPS or S_LPROCMIPS
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    unsigned long   len;        // Proc length
    unsigned long   DbgStart;   // Debug start offset
    unsigned long   DbgEnd;     // Debug end offset
    unsigned long   regSave;    // int register save mask
    unsigned long   fpSave;     // fp register save mask
    CV_uoff32_t     intOff;     // int register save offset
    CV_uoff32_t     fpOff;      // fp register save offset
    CV_typ_t        typind;     // Type index
    CV_uoff32_t     off;        // Symbol offset
    unsigned short  seg;        // Symbol segment
    unsigned char   retReg;     // Register return value is in
    unsigned char   frameReg;   // Frame pointer register
    unsigned char   name[1];    // Length-prefixed name
} PROCSYMMIPS;

typedef struct PROCSYMIA64 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_GPROCIA64 or S_LPROCIA64
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    unsigned long   len;        // Proc length
    unsigned long   DbgStart;   // Debug start offset
    unsigned long   DbgEnd;     // Debug end offset
    CV_typ_t        typind;     // Type index
    CV_uoff32_t     off;        // Symbol offset
    unsigned short  seg;        // Symbol segment
    unsigned short  retReg;     // Register return value is in
    CV_PROCFLAGS    flags;      // Proc flags
    unsigned char   name[1];    // Length-prefixed name
} PROCSYMIA64;

typedef struct REFSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_PROCREF_ST, S_DATAREF_ST, or S_LPROCREF_ST
    unsigned long   sumName;    // SUC of the name
    unsigned long   ibSym;      // Offset of actual symbol in $$Symbols
    unsigned short  imod;       // Module containing the actual symbol
    unsigned short  usFill;     // align this record
} REFSYM;

typedef struct REFSYM2 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_PROCREF, S_DATAREF, or S_LPROCREF
    unsigned long   sumName;    // SUC of the name
    unsigned long   ibSym;      // Offset of actual symbol in $$Symbols
    unsigned short  imod;       // Module containing the actual symbol
    unsigned char   name[1];    // hidden name made a first class member
} REFSYM2;

typedef struct ALIGNSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_ALIGN
} ALIGNSYM;

typedef struct OEMSYMBOL {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_OEM
    unsigned char   idOem[16];  // an oem ID (GUID)
    CV_typ_t        typind;     // Type index
    unsigned long   rgl[];      // user data, force 4-byte alignment
} OEMSYMBOL;

//  generic block definition symbols
//  these are similar to the equivalent 16:16 or 16:32 symbols but
//  only define the length, type and linkage fields

typedef struct PROCSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_GPROC16 or S_LPROC16
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
} PROCSYM;


typedef struct THUNKSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_THUNK
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
} THUNKSYM;

typedef struct BLOCKSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_BLOCK16
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
} BLOCKSYM;


typedef struct WITHSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_WITH16
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
} WITHSYM;

typedef struct FRAMEPROCSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_FRAMEPROC
    unsigned long   cbFrame;    // count of bytes of total frame of procedure
    unsigned long   cbPad;      // count of bytes of padding in the frame
    CV_uoff32_t     offPad;     // offset (relative to frame poniter) to where
                                //  padding starts
    unsigned long   cbSaveRegs; // count of bytes of callee save registers
    CV_uoff32_t     offExHdlr;  // offset of exception handler
    unsigned short  sectExHdlr; // section id of exception handler

    struct {
        unsigned long   fHasAlloca  :  1;   // function uses _alloca()
        unsigned long   fHasSetJmp  :  1;   // function uses setjmp()
        unsigned long   fHasLongJmp :  1;   // function uses longjmp()
        unsigned long   fHasInlAsm  :  1;   // function uses inline asm
        unsigned long   fHasEH      :  1;   // function has EH states
        unsigned long   fInlSpec    :  1;   // function was speced as inline
        unsigned long   fHasSEH     :  1;   // function has SEH
        unsigned long   fNaked      :  1;   // function is __declspec(naked)
        unsigned long   pad         : 24;   // must be zero
    } flags;
} FRAMEPROCSYM;

typedef struct UNAMESPACE {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_UNAMESPACE
    unsigned char   name[1];    // name
} UNAMESPACE;

typedef struct SEPCODESYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_SEPCODE
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this block's end
    unsigned long   length;     // count of bytes of this block
    CV_SEPCODEFLAGS scf;        // flags
    CV_uoff32_t     off;        // sect:off of the separated code
    CV_uoff32_t     offParent;  // sectParent:offParent of the enclosing scope
    unsigned short  sect;       //  (proc, block, or sepcode)
    unsigned short  sectParent;
} SEPCODESYM;


//
// V7 line number data types
//

enum DEBUG_S_SUBSECTION_TYPE {
    DEBUG_S_IGNORE = 0x80000000,   // if this bit is set in a subsection type then ignore the subsection contents

    DEBUG_S_SYMBOLS = 0xf1,
    DEBUG_S_LINES,
    DEBUG_S_STRINGTABLE,
    DEBUG_S_FILECHKSMS,
    DEBUG_S_FRAMEDATA,
};

//
// Line flags (data present)
//
#define CV_LINES_HAVE_COLUMNS 0x0001

struct CV_Line_t {
        unsigned long   offset;             // Offset to start of code bytes for line number
        unsigned long   linenumStart:24;    // line where statement/expression starts
        unsigned long   deltaLineEnd:7;     // delta to line where statement ends (optional)
        unsigned long   fStatement:1;       // true if a statement linenumber, else an expression line num
};

typedef unsigned short CV_columnpos_t;    // byte offset in a source line

struct CV_Column_t {
    CV_columnpos_t offColumnStart;
    CV_columnpos_t offColumnEnd;
};


struct tagFRAMEDATA {
    unsigned long   ulRvaStart;
    unsigned long   cbBlock;
    unsigned long   cbLocals;
    unsigned long   cbParams;
    unsigned long   cbStkMax;
    unsigned long   frameFunc;
    unsigned short  cbProlog;
    unsigned short  cbSavedRegs;
    unsigned long   fHasSEH:1;
    unsigned long   fHasEH:1;
    unsigned long   fIsFunctionStart:1;
    unsigned long   fHasBufferCheck:1;
    unsigned long   reserved:28;
};

typedef struct tagFRAMEDATA FRAMEDATA, * PFRAMEDATA;

typedef struct tagXFIXUP_DATA {
   unsigned short wType;
   unsigned short wExtra;
   unsigned long rva;
   unsigned long rvaTarget;
} XFIXUP_DATA;


#pragma pack ( pop )

#endif /* CV_INFO_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\vs\dia2.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0361 */
/* at Fri Oct 04 19:15:45 2002
 */
/* Compiler settings for d:\v7\LangAPI\idl\dia2_internal.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __dia2_h__
#define __dia2_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IDiaLoadCallback_FWD_DEFINED__
#define __IDiaLoadCallback_FWD_DEFINED__
typedef interface IDiaLoadCallback IDiaLoadCallback;
#endif 	/* __IDiaLoadCallback_FWD_DEFINED__ */


#ifndef __IDiaLoadCallback2_FWD_DEFINED__
#define __IDiaLoadCallback2_FWD_DEFINED__
typedef interface IDiaLoadCallback2 IDiaLoadCallback2;
#endif 	/* __IDiaLoadCallback2_FWD_DEFINED__ */


#ifndef __IDiaReadExeAtOffsetCallback_FWD_DEFINED__
#define __IDiaReadExeAtOffsetCallback_FWD_DEFINED__
typedef interface IDiaReadExeAtOffsetCallback IDiaReadExeAtOffsetCallback;
#endif 	/* __IDiaReadExeAtOffsetCallback_FWD_DEFINED__ */


#ifndef __IDiaReadExeAtRVACallback_FWD_DEFINED__
#define __IDiaReadExeAtRVACallback_FWD_DEFINED__
typedef interface IDiaReadExeAtRVACallback IDiaReadExeAtRVACallback;
#endif 	/* __IDiaReadExeAtRVACallback_FWD_DEFINED__ */


#ifndef __IDiaDataSource_FWD_DEFINED__
#define __IDiaDataSource_FWD_DEFINED__
typedef interface IDiaDataSource IDiaDataSource;
#endif 	/* __IDiaDataSource_FWD_DEFINED__ */


#ifndef __IDiaEnumSymbols_FWD_DEFINED__
#define __IDiaEnumSymbols_FWD_DEFINED__
typedef interface IDiaEnumSymbols IDiaEnumSymbols;
#endif 	/* __IDiaEnumSymbols_FWD_DEFINED__ */


#ifndef __IDiaEnumSymbolsByAddr_FWD_DEFINED__
#define __IDiaEnumSymbolsByAddr_FWD_DEFINED__
typedef interface IDiaEnumSymbolsByAddr IDiaEnumSymbolsByAddr;
#endif 	/* __IDiaEnumSymbolsByAddr_FWD_DEFINED__ */


#ifndef __IDiaEnumSourceFiles_FWD_DEFINED__
#define __IDiaEnumSourceFiles_FWD_DEFINED__
typedef interface IDiaEnumSourceFiles IDiaEnumSourceFiles;
#endif 	/* __IDiaEnumSourceFiles_FWD_DEFINED__ */


#ifndef __IDiaEnumLineNumbers_FWD_DEFINED__
#define __IDiaEnumLineNumbers_FWD_DEFINED__
typedef interface IDiaEnumLineNumbers IDiaEnumLineNumbers;
#endif 	/* __IDiaEnumLineNumbers_FWD_DEFINED__ */


#ifndef __IDiaEnumInjectedSources_FWD_DEFINED__
#define __IDiaEnumInjectedSources_FWD_DEFINED__
typedef interface IDiaEnumInjectedSources IDiaEnumInjectedSources;
#endif 	/* __IDiaEnumInjectedSources_FWD_DEFINED__ */


#ifndef __IDiaEnumSegments_FWD_DEFINED__
#define __IDiaEnumSegments_FWD_DEFINED__
typedef interface IDiaEnumSegments IDiaEnumSegments;
#endif 	/* __IDiaEnumSegments_FWD_DEFINED__ */


#ifndef __IDiaEnumSectionContribs_FWD_DEFINED__
#define __IDiaEnumSectionContribs_FWD_DEFINED__
typedef interface IDiaEnumSectionContribs IDiaEnumSectionContribs;
#endif 	/* __IDiaEnumSectionContribs_FWD_DEFINED__ */


#ifndef __IDiaEnumFrameData_FWD_DEFINED__
#define __IDiaEnumFrameData_FWD_DEFINED__
typedef interface IDiaEnumFrameData IDiaEnumFrameData;
#endif 	/* __IDiaEnumFrameData_FWD_DEFINED__ */


#ifndef __IDiaEnumDebugStreamData_FWD_DEFINED__
#define __IDiaEnumDebugStreamData_FWD_DEFINED__
typedef interface IDiaEnumDebugStreamData IDiaEnumDebugStreamData;
#endif 	/* __IDiaEnumDebugStreamData_FWD_DEFINED__ */


#ifndef __IDiaEnumDebugStreams_FWD_DEFINED__
#define __IDiaEnumDebugStreams_FWD_DEFINED__
typedef interface IDiaEnumDebugStreams IDiaEnumDebugStreams;
#endif 	/* __IDiaEnumDebugStreams_FWD_DEFINED__ */


#ifndef __IDiaAddressMap_FWD_DEFINED__
#define __IDiaAddressMap_FWD_DEFINED__
typedef interface IDiaAddressMap IDiaAddressMap;
#endif 	/* __IDiaAddressMap_FWD_DEFINED__ */


#ifndef __IDiaSession_FWD_DEFINED__
#define __IDiaSession_FWD_DEFINED__
typedef interface IDiaSession IDiaSession;
#endif 	/* __IDiaSession_FWD_DEFINED__ */


#ifndef __IDiaSymbol_FWD_DEFINED__
#define __IDiaSymbol_FWD_DEFINED__
typedef interface IDiaSymbol IDiaSymbol;
#endif 	/* __IDiaSymbol_FWD_DEFINED__ */


#ifndef __IDiaSourceFile_FWD_DEFINED__
#define __IDiaSourceFile_FWD_DEFINED__
typedef interface IDiaSourceFile IDiaSourceFile;
#endif 	/* __IDiaSourceFile_FWD_DEFINED__ */


#ifndef __IDiaLineNumber_FWD_DEFINED__
#define __IDiaLineNumber_FWD_DEFINED__
typedef interface IDiaLineNumber IDiaLineNumber;
#endif 	/* __IDiaLineNumber_FWD_DEFINED__ */


#ifndef __IDiaSectionContrib_FWD_DEFINED__
#define __IDiaSectionContrib_FWD_DEFINED__
typedef interface IDiaSectionContrib IDiaSectionContrib;
#endif 	/* __IDiaSectionContrib_FWD_DEFINED__ */


#ifndef __IDiaSegment_FWD_DEFINED__
#define __IDiaSegment_FWD_DEFINED__
typedef interface IDiaSegment IDiaSegment;
#endif 	/* __IDiaSegment_FWD_DEFINED__ */


#ifndef __IDiaInjectedSource_FWD_DEFINED__
#define __IDiaInjectedSource_FWD_DEFINED__
typedef interface IDiaInjectedSource IDiaInjectedSource;
#endif 	/* __IDiaInjectedSource_FWD_DEFINED__ */


#ifndef __IDiaStackWalkFrame_FWD_DEFINED__
#define __IDiaStackWalkFrame_FWD_DEFINED__
typedef interface IDiaStackWalkFrame IDiaStackWalkFrame;
#endif 	/* __IDiaStackWalkFrame_FWD_DEFINED__ */


#ifndef __IDiaFrameData_FWD_DEFINED__
#define __IDiaFrameData_FWD_DEFINED__
typedef interface IDiaFrameData IDiaFrameData;
#endif 	/* __IDiaFrameData_FWD_DEFINED__ */


#ifndef __IDiaImageData_FWD_DEFINED__
#define __IDiaImageData_FWD_DEFINED__
typedef interface IDiaImageData IDiaImageData;
#endif 	/* __IDiaImageData_FWD_DEFINED__ */


#ifndef __IDiaTable_FWD_DEFINED__
#define __IDiaTable_FWD_DEFINED__
typedef interface IDiaTable IDiaTable;
#endif 	/* __IDiaTable_FWD_DEFINED__ */


#ifndef __IDiaEnumTables_FWD_DEFINED__
#define __IDiaEnumTables_FWD_DEFINED__
typedef interface IDiaEnumTables IDiaEnumTables;
#endif 	/* __IDiaEnumTables_FWD_DEFINED__ */


#ifndef __DiaSource_FWD_DEFINED__
#define __DiaSource_FWD_DEFINED__

#ifdef __cplusplus
typedef class DiaSource DiaSource;
#else
typedef struct DiaSource DiaSource;
#endif /* __cplusplus */

#endif 	/* __DiaSource_FWD_DEFINED__ */


#ifndef __DiaSourceAlt_FWD_DEFINED__
#define __DiaSourceAlt_FWD_DEFINED__

#ifdef __cplusplus
typedef class DiaSourceAlt DiaSourceAlt;
#else
typedef struct DiaSourceAlt DiaSourceAlt;
#endif /* __cplusplus */

#endif 	/* __DiaSourceAlt_FWD_DEFINED__ */


#ifndef __DiaStackWalker_FWD_DEFINED__
#define __DiaStackWalker_FWD_DEFINED__

#ifdef __cplusplus
typedef class DiaStackWalker DiaStackWalker;
#else
typedef struct DiaStackWalker DiaStackWalker;
#endif /* __cplusplus */

#endif 	/* __DiaStackWalker_FWD_DEFINED__ */


#ifndef __IDiaPropertyStorage_FWD_DEFINED__
#define __IDiaPropertyStorage_FWD_DEFINED__
typedef interface IDiaPropertyStorage IDiaPropertyStorage;
#endif 	/* __IDiaPropertyStorage_FWD_DEFINED__ */


#ifndef __IDiaStackFrame_FWD_DEFINED__
#define __IDiaStackFrame_FWD_DEFINED__
typedef interface IDiaStackFrame IDiaStackFrame;
#endif 	/* __IDiaStackFrame_FWD_DEFINED__ */


#ifndef __IDiaEnumStackFrames_FWD_DEFINED__
#define __IDiaEnumStackFrames_FWD_DEFINED__
typedef interface IDiaEnumStackFrames IDiaEnumStackFrames;
#endif 	/* __IDiaEnumStackFrames_FWD_DEFINED__ */


#ifndef __IDiaStackWalkHelper_FWD_DEFINED__
#define __IDiaStackWalkHelper_FWD_DEFINED__
typedef interface IDiaStackWalkHelper IDiaStackWalkHelper;
#endif 	/* __IDiaStackWalkHelper_FWD_DEFINED__ */


#ifndef __IDiaStackWalker_FWD_DEFINED__
#define __IDiaStackWalker_FWD_DEFINED__
typedef interface IDiaStackWalker IDiaStackWalker;
#endif 	/* __IDiaStackWalker_FWD_DEFINED__ */


#ifndef __IDiaDataSource2_FWD_DEFINED__
#define __IDiaDataSource2_FWD_DEFINED__
typedef interface IDiaDataSource2 IDiaDataSource2;
#endif 	/* __IDiaDataSource2_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"
#include "oaidl.h"
#include "propidl.h"
#include "cvconst.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_dia2_internal_0000 */
/* [local] */ 


enum NameSearchOptions
    {	nsNone	= 0,
	nsfCaseSensitive	= 0x1,
	nsfCaseInsensitive	= 0x2,
	nsfFNameExt	= 0x4,
	nsfRegularExpression	= 0x8,
	nsfUndecoratedName	= 0x10,
	nsCaseSensitive	= nsfCaseSensitive,
	nsCaseInsensitive	= nsfCaseInsensitive,
	nsFNameExt	= nsfCaseInsensitive | nsfFNameExt,
	nsRegularExpression	= nsfRegularExpression | nsfCaseSensitive,
	nsCaseInRegularExpression	= nsfRegularExpression | nsfCaseInsensitive
    } ;

enum __MIDL___MIDL_itf_dia2_internal_0000_0001
    {	E_PDB_OK	= ( HRESULT  )(( unsigned long  )1 << 31 | ( unsigned long  )( LONG  )0x6d << 16 | ( unsigned long  )1),
	E_PDB_USAGE	= E_PDB_OK + 1,
	E_PDB_OUT_OF_MEMORY	= E_PDB_USAGE + 1,
	E_PDB_FILE_SYSTEM	= E_PDB_OUT_OF_MEMORY + 1,
	E_PDB_NOT_FOUND	= E_PDB_FILE_SYSTEM + 1,
	E_PDB_INVALID_SIG	= E_PDB_NOT_FOUND + 1,
	E_PDB_INVALID_AGE	= E_PDB_INVALID_SIG + 1,
	E_PDB_PRECOMP_REQUIRED	= E_PDB_INVALID_AGE + 1,
	E_PDB_OUT_OF_TI	= E_PDB_PRECOMP_REQUIRED + 1,
	E_PDB_NOT_IMPLEMENTED	= E_PDB_OUT_OF_TI + 1,
	E_PDB_V1_PDB	= E_PDB_NOT_IMPLEMENTED + 1,
	E_PDB_FORMAT	= E_PDB_V1_PDB + 1,
	E_PDB_LIMIT	= E_PDB_FORMAT + 1,
	E_PDB_CORRUPT	= E_PDB_LIMIT + 1,
	E_PDB_TI16	= E_PDB_CORRUPT + 1,
	E_PDB_ACCESS_DENIED	= E_PDB_TI16 + 1,
	E_PDB_ILLEGAL_TYPE_EDIT	= E_PDB_ACCESS_DENIED + 1,
	E_PDB_INVALID_EXECUTABLE	= E_PDB_ILLEGAL_TYPE_EDIT + 1,
	E_PDB_DBG_NOT_FOUND	= E_PDB_INVALID_EXECUTABLE + 1,
	E_PDB_NO_DEBUG_INFO	= E_PDB_DBG_NOT_FOUND + 1,
	E_PDB_INVALID_EXE_TIMESTAMP	= E_PDB_NO_DEBUG_INFO + 1,
	E_PDB_RESERVED	= E_PDB_INVALID_EXE_TIMESTAMP + 1,
	E_PDB_DEBUG_INFO_NOT_IN_PDB	= E_PDB_RESERVED + 1,
	E_PDB_MAX	= E_PDB_DEBUG_INFO_NOT_IN_PDB + 1
    } ;

enum __MIDL___MIDL_itf_dia2_internal_0000_0002
    {	DIA_E_MODNOTFOUND	= E_PDB_MAX + 1,
	DIA_E_PROCNOTFOUND	= DIA_E_MODNOTFOUND + 1
    } ;
typedef void ( __cdecl *PfnPDBDebugDirV )( 
    BOOL __MIDL_0014,
    void *__MIDL_0015);












extern RPC_IF_HANDLE __MIDL_itf_dia2_internal_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dia2_internal_0000_v0_0_s_ifspec;

#ifndef __IDiaLoadCallback_INTERFACE_DEFINED__
#define __IDiaLoadCallback_INTERFACE_DEFINED__

/* interface IDiaLoadCallback */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaLoadCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C32ADB82-73F4-421b-95D5-A4706EDF5DBE")
    IDiaLoadCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE NotifyDebugDir( 
            /* [in] */ BOOL fExecutable,
            /* [in] */ DWORD cbData,
            /* [size_is][in] */ BYTE data[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NotifyOpenDBG( 
            /* [in] */ LPCOLESTR dbgPath,
            /* [in] */ HRESULT resultCode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NotifyOpenPDB( 
            /* [in] */ LPCOLESTR pdbPath,
            /* [in] */ HRESULT resultCode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RestrictRegistryAccess( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RestrictSymbolServerAccess( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaLoadCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaLoadCallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaLoadCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaLoadCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyDebugDir )( 
            IDiaLoadCallback * This,
            /* [in] */ BOOL fExecutable,
            /* [in] */ DWORD cbData,
            /* [size_is][in] */ BYTE data[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyOpenDBG )( 
            IDiaLoadCallback * This,
            /* [in] */ LPCOLESTR dbgPath,
            /* [in] */ HRESULT resultCode);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyOpenPDB )( 
            IDiaLoadCallback * This,
            /* [in] */ LPCOLESTR pdbPath,
            /* [in] */ HRESULT resultCode);
        
        HRESULT ( STDMETHODCALLTYPE *RestrictRegistryAccess )( 
            IDiaLoadCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *RestrictSymbolServerAccess )( 
            IDiaLoadCallback * This);
        
        END_INTERFACE
    } IDiaLoadCallbackVtbl;

    interface IDiaLoadCallback
    {
        CONST_VTBL struct IDiaLoadCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaLoadCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaLoadCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaLoadCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaLoadCallback_NotifyDebugDir(This,fExecutable,cbData,data)	\
    (This)->lpVtbl -> NotifyDebugDir(This,fExecutable,cbData,data)

#define IDiaLoadCallback_NotifyOpenDBG(This,dbgPath,resultCode)	\
    (This)->lpVtbl -> NotifyOpenDBG(This,dbgPath,resultCode)

#define IDiaLoadCallback_NotifyOpenPDB(This,pdbPath,resultCode)	\
    (This)->lpVtbl -> NotifyOpenPDB(This,pdbPath,resultCode)

#define IDiaLoadCallback_RestrictRegistryAccess(This)	\
    (This)->lpVtbl -> RestrictRegistryAccess(This)

#define IDiaLoadCallback_RestrictSymbolServerAccess(This)	\
    (This)->lpVtbl -> RestrictSymbolServerAccess(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDiaLoadCallback_NotifyDebugDir_Proxy( 
    IDiaLoadCallback * This,
    /* [in] */ BOOL fExecutable,
    /* [in] */ DWORD cbData,
    /* [size_is][in] */ BYTE data[  ]);


void __RPC_STUB IDiaLoadCallback_NotifyDebugDir_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaLoadCallback_NotifyOpenDBG_Proxy( 
    IDiaLoadCallback * This,
    /* [in] */ LPCOLESTR dbgPath,
    /* [in] */ HRESULT resultCode);


void __RPC_STUB IDiaLoadCallback_NotifyOpenDBG_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaLoadCallback_NotifyOpenPDB_Proxy( 
    IDiaLoadCallback * This,
    /* [in] */ LPCOLESTR pdbPath,
    /* [in] */ HRESULT resultCode);


void __RPC_STUB IDiaLoadCallback_NotifyOpenPDB_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaLoadCallback_RestrictRegistryAccess_Proxy( 
    IDiaLoadCallback * This);


void __RPC_STUB IDiaLoadCallback_RestrictRegistryAccess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaLoadCallback_RestrictSymbolServerAccess_Proxy( 
    IDiaLoadCallback * This);


void __RPC_STUB IDiaLoadCallback_RestrictSymbolServerAccess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaLoadCallback_INTERFACE_DEFINED__ */


#ifndef __IDiaLoadCallback2_INTERFACE_DEFINED__
#define __IDiaLoadCallback2_INTERFACE_DEFINED__

/* interface IDiaLoadCallback2 */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaLoadCallback2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4688a074-5a4d-4486-aea8-7b90711d9f7c")
    IDiaLoadCallback2 : public IDiaLoadCallback
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RestrictOriginalPathAccess( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RestrictReferencePathAccess( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RestrictDBGAccess( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaLoadCallback2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaLoadCallback2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaLoadCallback2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaLoadCallback2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyDebugDir )( 
            IDiaLoadCallback2 * This,
            /* [in] */ BOOL fExecutable,
            /* [in] */ DWORD cbData,
            /* [size_is][in] */ BYTE data[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyOpenDBG )( 
            IDiaLoadCallback2 * This,
            /* [in] */ LPCOLESTR dbgPath,
            /* [in] */ HRESULT resultCode);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyOpenPDB )( 
            IDiaLoadCallback2 * This,
            /* [in] */ LPCOLESTR pdbPath,
            /* [in] */ HRESULT resultCode);
        
        HRESULT ( STDMETHODCALLTYPE *RestrictRegistryAccess )( 
            IDiaLoadCallback2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *RestrictSymbolServerAccess )( 
            IDiaLoadCallback2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *RestrictOriginalPathAccess )( 
            IDiaLoadCallback2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *RestrictReferencePathAccess )( 
            IDiaLoadCallback2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *RestrictDBGAccess )( 
            IDiaLoadCallback2 * This);
        
        END_INTERFACE
    } IDiaLoadCallback2Vtbl;

    interface IDiaLoadCallback2
    {
        CONST_VTBL struct IDiaLoadCallback2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaLoadCallback2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaLoadCallback2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaLoadCallback2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaLoadCallback2_NotifyDebugDir(This,fExecutable,cbData,data)	\
    (This)->lpVtbl -> NotifyDebugDir(This,fExecutable,cbData,data)

#define IDiaLoadCallback2_NotifyOpenDBG(This,dbgPath,resultCode)	\
    (This)->lpVtbl -> NotifyOpenDBG(This,dbgPath,resultCode)

#define IDiaLoadCallback2_NotifyOpenPDB(This,pdbPath,resultCode)	\
    (This)->lpVtbl -> NotifyOpenPDB(This,pdbPath,resultCode)

#define IDiaLoadCallback2_RestrictRegistryAccess(This)	\
    (This)->lpVtbl -> RestrictRegistryAccess(This)

#define IDiaLoadCallback2_RestrictSymbolServerAccess(This)	\
    (This)->lpVtbl -> RestrictSymbolServerAccess(This)


#define IDiaLoadCallback2_RestrictOriginalPathAccess(This)	\
    (This)->lpVtbl -> RestrictOriginalPathAccess(This)

#define IDiaLoadCallback2_RestrictReferencePathAccess(This)	\
    (This)->lpVtbl -> RestrictReferencePathAccess(This)

#define IDiaLoadCallback2_RestrictDBGAccess(This)	\
    (This)->lpVtbl -> RestrictDBGAccess(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDiaLoadCallback2_RestrictOriginalPathAccess_Proxy( 
    IDiaLoadCallback2 * This);


void __RPC_STUB IDiaLoadCallback2_RestrictOriginalPathAccess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaLoadCallback2_RestrictReferencePathAccess_Proxy( 
    IDiaLoadCallback2 * This);


void __RPC_STUB IDiaLoadCallback2_RestrictReferencePathAccess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaLoadCallback2_RestrictDBGAccess_Proxy( 
    IDiaLoadCallback2 * This);


void __RPC_STUB IDiaLoadCallback2_RestrictDBGAccess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaLoadCallback2_INTERFACE_DEFINED__ */


#ifndef __IDiaReadExeAtOffsetCallback_INTERFACE_DEFINED__
#define __IDiaReadExeAtOffsetCallback_INTERFACE_DEFINED__

/* interface IDiaReadExeAtOffsetCallback */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaReadExeAtOffsetCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("587A461C-B80B-4f54-9194-5032589A6319")
    IDiaReadExeAtOffsetCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ReadExecutableAt( 
            /* [in] */ DWORDLONG fileOffset,
            /* [in] */ DWORD cbData,
            /* [out] */ DWORD *pcbData,
            /* [length_is][size_is][out] */ BYTE data[  ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaReadExeAtOffsetCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaReadExeAtOffsetCallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaReadExeAtOffsetCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaReadExeAtOffsetCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *ReadExecutableAt )( 
            IDiaReadExeAtOffsetCallback * This,
            /* [in] */ DWORDLONG fileOffset,
            /* [in] */ DWORD cbData,
            /* [out] */ DWORD *pcbData,
            /* [length_is][size_is][out] */ BYTE data[  ]);
        
        END_INTERFACE
    } IDiaReadExeAtOffsetCallbackVtbl;

    interface IDiaReadExeAtOffsetCallback
    {
        CONST_VTBL struct IDiaReadExeAtOffsetCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaReadExeAtOffsetCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaReadExeAtOffsetCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaReadExeAtOffsetCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaReadExeAtOffsetCallback_ReadExecutableAt(This,fileOffset,cbData,pcbData,data)	\
    (This)->lpVtbl -> ReadExecutableAt(This,fileOffset,cbData,pcbData,data)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDiaReadExeAtOffsetCallback_ReadExecutableAt_Proxy( 
    IDiaReadExeAtOffsetCallback * This,
    /* [in] */ DWORDLONG fileOffset,
    /* [in] */ DWORD cbData,
    /* [out] */ DWORD *pcbData,
    /* [length_is][size_is][out] */ BYTE data[  ]);


void __RPC_STUB IDiaReadExeAtOffsetCallback_ReadExecutableAt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaReadExeAtOffsetCallback_INTERFACE_DEFINED__ */


#ifndef __IDiaReadExeAtRVACallback_INTERFACE_DEFINED__
#define __IDiaReadExeAtRVACallback_INTERFACE_DEFINED__

/* interface IDiaReadExeAtRVACallback */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaReadExeAtRVACallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8E3F80CA-7517-432a-BA07-285134AAEA8E")
    IDiaReadExeAtRVACallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ReadExecutableAtRVA( 
            /* [in] */ DWORD relativeVirtualAddress,
            /* [in] */ DWORD cbData,
            /* [out] */ DWORD *pcbData,
            /* [length_is][size_is][out] */ BYTE data[  ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaReadExeAtRVACallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaReadExeAtRVACallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaReadExeAtRVACallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaReadExeAtRVACallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *ReadExecutableAtRVA )( 
            IDiaReadExeAtRVACallback * This,
            /* [in] */ DWORD relativeVirtualAddress,
            /* [in] */ DWORD cbData,
            /* [out] */ DWORD *pcbData,
            /* [length_is][size_is][out] */ BYTE data[  ]);
        
        END_INTERFACE
    } IDiaReadExeAtRVACallbackVtbl;

    interface IDiaReadExeAtRVACallback
    {
        CONST_VTBL struct IDiaReadExeAtRVACallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaReadExeAtRVACallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaReadExeAtRVACallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaReadExeAtRVACallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaReadExeAtRVACallback_ReadExecutableAtRVA(This,relativeVirtualAddress,cbData,pcbData,data)	\
    (This)->lpVtbl -> ReadExecutableAtRVA(This,relativeVirtualAddress,cbData,pcbData,data)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDiaReadExeAtRVACallback_ReadExecutableAtRVA_Proxy( 
    IDiaReadExeAtRVACallback * This,
    /* [in] */ DWORD relativeVirtualAddress,
    /* [in] */ DWORD cbData,
    /* [out] */ DWORD *pcbData,
    /* [length_is][size_is][out] */ BYTE data[  ]);


void __RPC_STUB IDiaReadExeAtRVACallback_ReadExecutableAtRVA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaReadExeAtRVACallback_INTERFACE_DEFINED__ */


#ifndef __IDiaDataSource_INTERFACE_DEFINED__
#define __IDiaDataSource_INTERFACE_DEFINED__

/* interface IDiaDataSource */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaDataSource;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79F1BB5F-B66E-48e5-B6A9-1545C323CA3D")
    IDiaDataSource : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_lastError( 
            /* [retval][out] */ BSTR *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE loadDataFromPdb( 
            /* [in] */ LPCOLESTR pdbPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE loadAndValidateDataFromPdb( 
            /* [in] */ LPCOLESTR pdbPath,
            /* [in] */ GUID *pcsig70,
            /* [in] */ DWORD sig,
            /* [in] */ DWORD age) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE loadDataForExe( 
            /* [in] */ LPCOLESTR executable,
            /* [in] */ LPCOLESTR searchPath,
            /* [in] */ IUnknown *pCallback) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE loadDataFromIStream( 
            /* [in] */ IStream *pIStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE openSession( 
            /* [out] */ IDiaSession **ppSession) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaDataSourceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaDataSource * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaDataSource * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaDataSource * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lastError )( 
            IDiaDataSource * This,
            /* [retval][out] */ BSTR *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *loadDataFromPdb )( 
            IDiaDataSource * This,
            /* [in] */ LPCOLESTR pdbPath);
        
        HRESULT ( STDMETHODCALLTYPE *loadAndValidateDataFromPdb )( 
            IDiaDataSource * This,
            /* [in] */ LPCOLESTR pdbPath,
            /* [in] */ GUID *pcsig70,
            /* [in] */ DWORD sig,
            /* [in] */ DWORD age);
        
        HRESULT ( STDMETHODCALLTYPE *loadDataForExe )( 
            IDiaDataSource * This,
            /* [in] */ LPCOLESTR executable,
            /* [in] */ LPCOLESTR searchPath,
            /* [in] */ IUnknown *pCallback);
        
        HRESULT ( STDMETHODCALLTYPE *loadDataFromIStream )( 
            IDiaDataSource * This,
            /* [in] */ IStream *pIStream);
        
        HRESULT ( STDMETHODCALLTYPE *openSession )( 
            IDiaDataSource * This,
            /* [out] */ IDiaSession **ppSession);
        
        END_INTERFACE
    } IDiaDataSourceVtbl;

    interface IDiaDataSource
    {
        CONST_VTBL struct IDiaDataSourceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaDataSource_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaDataSource_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaDataSource_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaDataSource_get_lastError(This,pRetVal)	\
    (This)->lpVtbl -> get_lastError(This,pRetVal)

#define IDiaDataSource_loadDataFromPdb(This,pdbPath)	\
    (This)->lpVtbl -> loadDataFromPdb(This,pdbPath)

#define IDiaDataSource_loadAndValidateDataFromPdb(This,pdbPath,pcsig70,sig,age)	\
    (This)->lpVtbl -> loadAndValidateDataFromPdb(This,pdbPath,pcsig70,sig,age)

#define IDiaDataSource_loadDataForExe(This,executable,searchPath,pCallback)	\
    (This)->lpVtbl -> loadDataForExe(This,executable,searchPath,pCallback)

#define IDiaDataSource_loadDataFromIStream(This,pIStream)	\
    (This)->lpVtbl -> loadDataFromIStream(This,pIStream)

#define IDiaDataSource_openSession(This,ppSession)	\
    (This)->lpVtbl -> openSession(This,ppSession)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaDataSource_get_lastError_Proxy( 
    IDiaDataSource * This,
    /* [retval][out] */ BSTR *pRetVal);


void __RPC_STUB IDiaDataSource_get_lastError_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaDataSource_loadDataFromPdb_Proxy( 
    IDiaDataSource * This,
    /* [in] */ LPCOLESTR pdbPath);


void __RPC_STUB IDiaDataSource_loadDataFromPdb_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaDataSource_loadAndValidateDataFromPdb_Proxy( 
    IDiaDataSource * This,
    /* [in] */ LPCOLESTR pdbPath,
    /* [in] */ GUID *pcsig70,
    /* [in] */ DWORD sig,
    /* [in] */ DWORD age);


void __RPC_STUB IDiaDataSource_loadAndValidateDataFromPdb_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaDataSource_loadDataForExe_Proxy( 
    IDiaDataSource * This,
    /* [in] */ LPCOLESTR executable,
    /* [in] */ LPCOLESTR searchPath,
    /* [in] */ IUnknown *pCallback);


void __RPC_STUB IDiaDataSource_loadDataForExe_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaDataSource_loadDataFromIStream_Proxy( 
    IDiaDataSource * This,
    /* [in] */ IStream *pIStream);


void __RPC_STUB IDiaDataSource_loadDataFromIStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaDataSource_openSession_Proxy( 
    IDiaDataSource * This,
    /* [out] */ IDiaSession **ppSession);


void __RPC_STUB IDiaDataSource_openSession_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaDataSource_INTERFACE_DEFINED__ */


#ifndef __IDiaEnumSymbols_INTERFACE_DEFINED__
#define __IDiaEnumSymbols_INTERFACE_DEFINED__

/* interface IDiaEnumSymbols */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaEnumSymbols;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CAB72C48-443B-48f5-9B0B-42F0820AB29A")
    IDiaEnumSymbols : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ LONG *pRetVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ DWORD index,
            /* [retval][out] */ IDiaSymbol **symbol) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [out] */ IDiaSymbol **rgelt,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IDiaEnumSymbols **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaEnumSymbolsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaEnumSymbols * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaEnumSymbols * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaEnumSymbols * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IDiaEnumSymbols * This,
            /* [retval][out] */ IUnknown **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IDiaEnumSymbols * This,
            /* [retval][out] */ LONG *pRetVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Item )( 
            IDiaEnumSymbols * This,
            /* [in] */ DWORD index,
            /* [retval][out] */ IDiaSymbol **symbol);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IDiaEnumSymbols * This,
            /* [in] */ ULONG celt,
            /* [out] */ IDiaSymbol **rgelt,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IDiaEnumSymbols * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IDiaEnumSymbols * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IDiaEnumSymbols * This,
            /* [out] */ IDiaEnumSymbols **ppenum);
        
        END_INTERFACE
    } IDiaEnumSymbolsVtbl;

    interface IDiaEnumSymbols
    {
        CONST_VTBL struct IDiaEnumSymbolsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaEnumSymbols_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaEnumSymbols_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaEnumSymbols_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaEnumSymbols_get__NewEnum(This,pRetVal)	\
    (This)->lpVtbl -> get__NewEnum(This,pRetVal)

#define IDiaEnumSymbols_get_Count(This,pRetVal)	\
    (This)->lpVtbl -> get_Count(This,pRetVal)

#define IDiaEnumSymbols_Item(This,index,symbol)	\
    (This)->lpVtbl -> Item(This,index,symbol)

#define IDiaEnumSymbols_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IDiaEnumSymbols_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IDiaEnumSymbols_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IDiaEnumSymbols_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumSymbols_get__NewEnum_Proxy( 
    IDiaEnumSymbols * This,
    /* [retval][out] */ IUnknown **pRetVal);


void __RPC_STUB IDiaEnumSymbols_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumSymbols_get_Count_Proxy( 
    IDiaEnumSymbols * This,
    /* [retval][out] */ LONG *pRetVal);


void __RPC_STUB IDiaEnumSymbols_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDiaEnumSymbols_Item_Proxy( 
    IDiaEnumSymbols * This,
    /* [in] */ DWORD index,
    /* [retval][out] */ IDiaSymbol **symbol);


void __RPC_STUB IDiaEnumSymbols_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumSymbols_Next_Proxy( 
    IDiaEnumSymbols * This,
    /* [in] */ ULONG celt,
    /* [out] */ IDiaSymbol **rgelt,
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB IDiaEnumSymbols_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumSymbols_Skip_Proxy( 
    IDiaEnumSymbols * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IDiaEnumSymbols_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumSymbols_Reset_Proxy( 
    IDiaEnumSymbols * This);


void __RPC_STUB IDiaEnumSymbols_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumSymbols_Clone_Proxy( 
    IDiaEnumSymbols * This,
    /* [out] */ IDiaEnumSymbols **ppenum);


void __RPC_STUB IDiaEnumSymbols_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaEnumSymbols_INTERFACE_DEFINED__ */


#ifndef __IDiaEnumSymbolsByAddr_INTERFACE_DEFINED__
#define __IDiaEnumSymbolsByAddr_INTERFACE_DEFINED__

/* interface IDiaEnumSymbolsByAddr */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaEnumSymbolsByAddr;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("624B7D9C-24EA-4421-9D06-3B577471C1FA")
    IDiaEnumSymbolsByAddr : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE symbolByAddr( 
            /* [in] */ DWORD isect,
            /* [in] */ DWORD offset,
            /* [retval][out] */ IDiaSymbol **ppSymbol) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE symbolByRVA( 
            /* [in] */ DWORD relativeVirtualAddress,
            /* [retval][out] */ IDiaSymbol **ppSymbol) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE symbolByVA( 
            /* [in] */ ULONGLONG virtualAddress,
            /* [retval][out] */ IDiaSymbol **ppSymbol) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [out] */ IDiaSymbol **rgelt,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Prev( 
            /* [in] */ ULONG celt,
            /* [out] */ IDiaSymbol **rgelt,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IDiaEnumSymbolsByAddr **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaEnumSymbolsByAddrVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaEnumSymbolsByAddr * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaEnumSymbolsByAddr * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaEnumSymbolsByAddr * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *symbolByAddr )( 
            IDiaEnumSymbolsByAddr * This,
            /* [in] */ DWORD isect,
            /* [in] */ DWORD offset,
            /* [retval][out] */ IDiaSymbol **ppSymbol);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *symbolByRVA )( 
            IDiaEnumSymbolsByAddr * This,
            /* [in] */ DWORD relativeVirtualAddress,
            /* [retval][out] */ IDiaSymbol **ppSymbol);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *symbolByVA )( 
            IDiaEnumSymbolsByAddr * This,
            /* [in] */ ULONGLONG virtualAddress,
            /* [retval][out] */ IDiaSymbol **ppSymbol);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IDiaEnumSymbolsByAddr * This,
            /* [in] */ ULONG celt,
            /* [out] */ IDiaSymbol **rgelt,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Prev )( 
            IDiaEnumSymbolsByAddr * This,
            /* [in] */ ULONG celt,
            /* [out] */ IDiaSymbol **rgelt,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IDiaEnumSymbolsByAddr * This,
            /* [out] */ IDiaEnumSymbolsByAddr **ppenum);
        
        END_INTERFACE
    } IDiaEnumSymbolsByAddrVtbl;

    interface IDiaEnumSymbolsByAddr
    {
        CONST_VTBL struct IDiaEnumSymbolsByAddrVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaEnumSymbolsByAddr_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaEnumSymbolsByAddr_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaEnumSymbolsByAddr_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaEnumSymbolsByAddr_symbolByAddr(This,isect,offset,ppSymbol)	\
    (This)->lpVtbl -> symbolByAddr(This,isect,offset,ppSymbol)

#define IDiaEnumSymbolsByAddr_symbolByRVA(This,relativeVirtualAddress,ppSymbol)	\
    (This)->lpVtbl -> symbolByRVA(This,relativeVirtualAddress,ppSymbol)

#define IDiaEnumSymbolsByAddr_symbolByVA(This,virtualAddress,ppSymbol)	\
    (This)->lpVtbl -> symbolByVA(This,virtualAddress,ppSymbol)

#define IDiaEnumSymbolsByAddr_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IDiaEnumSymbolsByAddr_Prev(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Prev(This,celt,rgelt,pceltFetched)

#define IDiaEnumSymbolsByAddr_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDiaEnumSymbolsByAddr_symbolByAddr_Proxy( 
    IDiaEnumSymbolsByAddr * This,
    /* [in] */ DWORD isect,
    /* [in] */ DWORD offset,
    /* [retval][out] */ IDiaSymbol **ppSymbol);


void __RPC_STUB IDiaEnumSymbolsByAddr_symbolByAddr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDiaEnumSymbolsByAddr_symbolByRVA_Proxy( 
    IDiaEnumSymbolsByAddr * This,
    /* [in] */ DWORD relativeVirtualAddress,
    /* [retval][out] */ IDiaSymbol **ppSymbol);


void __RPC_STUB IDiaEnumSymbolsByAddr_symbolByRVA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDiaEnumSymbolsByAddr_symbolByVA_Proxy( 
    IDiaEnumSymbolsByAddr * This,
    /* [in] */ ULONGLONG virtualAddress,
    /* [retval][out] */ IDiaSymbol **ppSymbol);


void __RPC_STUB IDiaEnumSymbolsByAddr_symbolByVA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumSymbolsByAddr_Next_Proxy( 
    IDiaEnumSymbolsByAddr * This,
    /* [in] */ ULONG celt,
    /* [out] */ IDiaSymbol **rgelt,
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB IDiaEnumSymbolsByAddr_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumSymbolsByAddr_Prev_Proxy( 
    IDiaEnumSymbolsByAddr * This,
    /* [in] */ ULONG celt,
    /* [out] */ IDiaSymbol **rgelt,
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB IDiaEnumSymbolsByAddr_Prev_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumSymbolsByAddr_Clone_Proxy( 
    IDiaEnumSymbolsByAddr * This,
    /* [out] */ IDiaEnumSymbolsByAddr **ppenum);


void __RPC_STUB IDiaEnumSymbolsByAddr_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaEnumSymbolsByAddr_INTERFACE_DEFINED__ */


#ifndef __IDiaEnumSourceFiles_INTERFACE_DEFINED__
#define __IDiaEnumSourceFiles_INTERFACE_DEFINED__

/* interface IDiaEnumSourceFiles */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaEnumSourceFiles;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("10F3DBD9-664F-4469-B808-9471C7A50538")
    IDiaEnumSourceFiles : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ LONG *pRetVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ DWORD index,
            /* [retval][out] */ IDiaSourceFile **sourceFile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [out] */ IDiaSourceFile **rgelt,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IDiaEnumSourceFiles **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaEnumSourceFilesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaEnumSourceFiles * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaEnumSourceFiles * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaEnumSourceFiles * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IDiaEnumSourceFiles * This,
            /* [retval][out] */ IUnknown **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IDiaEnumSourceFiles * This,
            /* [retval][out] */ LONG *pRetVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Item )( 
            IDiaEnumSourceFiles * This,
            /* [in] */ DWORD index,
            /* [retval][out] */ IDiaSourceFile **sourceFile);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IDiaEnumSourceFiles * This,
            /* [in] */ ULONG celt,
            /* [out] */ IDiaSourceFile **rgelt,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IDiaEnumSourceFiles * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IDiaEnumSourceFiles * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IDiaEnumSourceFiles * This,
            /* [out] */ IDiaEnumSourceFiles **ppenum);
        
        END_INTERFACE
    } IDiaEnumSourceFilesVtbl;

    interface IDiaEnumSourceFiles
    {
        CONST_VTBL struct IDiaEnumSourceFilesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaEnumSourceFiles_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaEnumSourceFiles_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaEnumSourceFiles_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaEnumSourceFiles_get__NewEnum(This,pRetVal)	\
    (This)->lpVtbl -> get__NewEnum(This,pRetVal)

#define IDiaEnumSourceFiles_get_Count(This,pRetVal)	\
    (This)->lpVtbl -> get_Count(This,pRetVal)

#define IDiaEnumSourceFiles_Item(This,index,sourceFile)	\
    (This)->lpVtbl -> Item(This,index,sourceFile)

#define IDiaEnumSourceFiles_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IDiaEnumSourceFiles_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IDiaEnumSourceFiles_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IDiaEnumSourceFiles_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumSourceFiles_get__NewEnum_Proxy( 
    IDiaEnumSourceFiles * This,
    /* [retval][out] */ IUnknown **pRetVal);


void __RPC_STUB IDiaEnumSourceFiles_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumSourceFiles_get_Count_Proxy( 
    IDiaEnumSourceFiles * This,
    /* [retval][out] */ LONG *pRetVal);


void __RPC_STUB IDiaEnumSourceFiles_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDiaEnumSourceFiles_Item_Proxy( 
    IDiaEnumSourceFiles * This,
    /* [in] */ DWORD index,
    /* [retval][out] */ IDiaSourceFile **sourceFile);


void __RPC_STUB IDiaEnumSourceFiles_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumSourceFiles_Next_Proxy( 
    IDiaEnumSourceFiles * This,
    /* [in] */ ULONG celt,
    /* [out] */ IDiaSourceFile **rgelt,
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB IDiaEnumSourceFiles_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumSourceFiles_Skip_Proxy( 
    IDiaEnumSourceFiles * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IDiaEnumSourceFiles_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumSourceFiles_Reset_Proxy( 
    IDiaEnumSourceFiles * This);


void __RPC_STUB IDiaEnumSourceFiles_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumSourceFiles_Clone_Proxy( 
    IDiaEnumSourceFiles * This,
    /* [out] */ IDiaEnumSourceFiles **ppenum);


void __RPC_STUB IDiaEnumSourceFiles_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaEnumSourceFiles_INTERFACE_DEFINED__ */


#ifndef __IDiaEnumLineNumbers_INTERFACE_DEFINED__
#define __IDiaEnumLineNumbers_INTERFACE_DEFINED__

/* interface IDiaEnumLineNumbers */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaEnumLineNumbers;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FE30E878-54AC-44f1-81BA-39DE940F6052")
    IDiaEnumLineNumbers : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ LONG *pRetVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ DWORD index,
            /* [retval][out] */ IDiaLineNumber **lineNumber) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [out] */ IDiaLineNumber **rgelt,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IDiaEnumLineNumbers **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaEnumLineNumbersVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaEnumLineNumbers * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaEnumLineNumbers * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaEnumLineNumbers * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IDiaEnumLineNumbers * This,
            /* [retval][out] */ IUnknown **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IDiaEnumLineNumbers * This,
            /* [retval][out] */ LONG *pRetVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Item )( 
            IDiaEnumLineNumbers * This,
            /* [in] */ DWORD index,
            /* [retval][out] */ IDiaLineNumber **lineNumber);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IDiaEnumLineNumbers * This,
            /* [in] */ ULONG celt,
            /* [out] */ IDiaLineNumber **rgelt,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IDiaEnumLineNumbers * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IDiaEnumLineNumbers * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IDiaEnumLineNumbers * This,
            /* [out] */ IDiaEnumLineNumbers **ppenum);
        
        END_INTERFACE
    } IDiaEnumLineNumbersVtbl;

    interface IDiaEnumLineNumbers
    {
        CONST_VTBL struct IDiaEnumLineNumbersVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaEnumLineNumbers_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaEnumLineNumbers_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaEnumLineNumbers_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaEnumLineNumbers_get__NewEnum(This,pRetVal)	\
    (This)->lpVtbl -> get__NewEnum(This,pRetVal)

#define IDiaEnumLineNumbers_get_Count(This,pRetVal)	\
    (This)->lpVtbl -> get_Count(This,pRetVal)

#define IDiaEnumLineNumbers_Item(This,index,lineNumber)	\
    (This)->lpVtbl -> Item(This,index,lineNumber)

#define IDiaEnumLineNumbers_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IDiaEnumLineNumbers_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IDiaEnumLineNumbers_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IDiaEnumLineNumbers_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumLineNumbers_get__NewEnum_Proxy( 
    IDiaEnumLineNumbers * This,
    /* [retval][out] */ IUnknown **pRetVal);


void __RPC_STUB IDiaEnumLineNumbers_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumLineNumbers_get_Count_Proxy( 
    IDiaEnumLineNumbers * This,
    /* [retval][out] */ LONG *pRetVal);


void __RPC_STUB IDiaEnumLineNumbers_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDiaEnumLineNumbers_Item_Proxy( 
    IDiaEnumLineNumbers * This,
    /* [in] */ DWORD index,
    /* [retval][out] */ IDiaLineNumber **lineNumber);


void __RPC_STUB IDiaEnumLineNumbers_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumLineNumbers_Next_Proxy( 
    IDiaEnumLineNumbers * This,
    /* [in] */ ULONG celt,
    /* [out] */ IDiaLineNumber **rgelt,
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB IDiaEnumLineNumbers_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumLineNumbers_Skip_Proxy( 
    IDiaEnumLineNumbers * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IDiaEnumLineNumbers_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumLineNumbers_Reset_Proxy( 
    IDiaEnumLineNumbers * This);


void __RPC_STUB IDiaEnumLineNumbers_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumLineNumbers_Clone_Proxy( 
    IDiaEnumLineNumbers * This,
    /* [out] */ IDiaEnumLineNumbers **ppenum);


void __RPC_STUB IDiaEnumLineNumbers_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaEnumLineNumbers_INTERFACE_DEFINED__ */


#ifndef __IDiaEnumInjectedSources_INTERFACE_DEFINED__
#define __IDiaEnumInjectedSources_INTERFACE_DEFINED__

/* interface IDiaEnumInjectedSources */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaEnumInjectedSources;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D5612573-6925-4468-8883-98CDEC8C384A")
    IDiaEnumInjectedSources : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ LONG *pRetVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ DWORD index,
            /* [retval][out] */ IDiaInjectedSource **injectedSource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [out] */ IDiaInjectedSource **rgelt,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IDiaEnumInjectedSources **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaEnumInjectedSourcesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaEnumInjectedSources * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaEnumInjectedSources * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaEnumInjectedSources * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IDiaEnumInjectedSources * This,
            /* [retval][out] */ IUnknown **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IDiaEnumInjectedSources * This,
            /* [retval][out] */ LONG *pRetVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Item )( 
            IDiaEnumInjectedSources * This,
            /* [in] */ DWORD index,
            /* [retval][out] */ IDiaInjectedSource **injectedSource);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IDiaEnumInjectedSources * This,
            /* [in] */ ULONG celt,
            /* [out] */ IDiaInjectedSource **rgelt,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IDiaEnumInjectedSources * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IDiaEnumInjectedSources * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IDiaEnumInjectedSources * This,
            /* [out] */ IDiaEnumInjectedSources **ppenum);
        
        END_INTERFACE
    } IDiaEnumInjectedSourcesVtbl;

    interface IDiaEnumInjectedSources
    {
        CONST_VTBL struct IDiaEnumInjectedSourcesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaEnumInjectedSources_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaEnumInjectedSources_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaEnumInjectedSources_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaEnumInjectedSources_get__NewEnum(This,pRetVal)	\
    (This)->lpVtbl -> get__NewEnum(This,pRetVal)

#define IDiaEnumInjectedSources_get_Count(This,pRetVal)	\
    (This)->lpVtbl -> get_Count(This,pRetVal)

#define IDiaEnumInjectedSources_Item(This,index,injectedSource)	\
    (This)->lpVtbl -> Item(This,index,injectedSource)

#define IDiaEnumInjectedSources_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IDiaEnumInjectedSources_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IDiaEnumInjectedSources_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IDiaEnumInjectedSources_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumInjectedSources_get__NewEnum_Proxy( 
    IDiaEnumInjectedSources * This,
    /* [retval][out] */ IUnknown **pRetVal);


void __RPC_STUB IDiaEnumInjectedSources_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumInjectedSources_get_Count_Proxy( 
    IDiaEnumInjectedSources * This,
    /* [retval][out] */ LONG *pRetVal);


void __RPC_STUB IDiaEnumInjectedSources_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDiaEnumInjectedSources_Item_Proxy( 
    IDiaEnumInjectedSources * This,
    /* [in] */ DWORD index,
    /* [retval][out] */ IDiaInjectedSource **injectedSource);


void __RPC_STUB IDiaEnumInjectedSources_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumInjectedSources_Next_Proxy( 
    IDiaEnumInjectedSources * This,
    /* [in] */ ULONG celt,
    /* [out] */ IDiaInjectedSource **rgelt,
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB IDiaEnumInjectedSources_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumInjectedSources_Skip_Proxy( 
    IDiaEnumInjectedSources * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IDiaEnumInjectedSources_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumInjectedSources_Reset_Proxy( 
    IDiaEnumInjectedSources * This);


void __RPC_STUB IDiaEnumInjectedSources_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumInjectedSources_Clone_Proxy( 
    IDiaEnumInjectedSources * This,
    /* [out] */ IDiaEnumInjectedSources **ppenum);


void __RPC_STUB IDiaEnumInjectedSources_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaEnumInjectedSources_INTERFACE_DEFINED__ */


#ifndef __IDiaEnumSegments_INTERFACE_DEFINED__
#define __IDiaEnumSegments_INTERFACE_DEFINED__

/* interface IDiaEnumSegments */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaEnumSegments;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E8368CA9-01D1-419d-AC0C-E31235DBDA9F")
    IDiaEnumSegments : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ LONG *pRetVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ DWORD index,
            /* [retval][out] */ IDiaSegment **segment) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [out] */ IDiaSegment **rgelt,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IDiaEnumSegments **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaEnumSegmentsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaEnumSegments * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaEnumSegments * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaEnumSegments * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IDiaEnumSegments * This,
            /* [retval][out] */ IUnknown **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IDiaEnumSegments * This,
            /* [retval][out] */ LONG *pRetVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Item )( 
            IDiaEnumSegments * This,
            /* [in] */ DWORD index,
            /* [retval][out] */ IDiaSegment **segment);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IDiaEnumSegments * This,
            /* [in] */ ULONG celt,
            /* [out] */ IDiaSegment **rgelt,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IDiaEnumSegments * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IDiaEnumSegments * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IDiaEnumSegments * This,
            /* [out] */ IDiaEnumSegments **ppenum);
        
        END_INTERFACE
    } IDiaEnumSegmentsVtbl;

    interface IDiaEnumSegments
    {
        CONST_VTBL struct IDiaEnumSegmentsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaEnumSegments_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaEnumSegments_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaEnumSegments_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaEnumSegments_get__NewEnum(This,pRetVal)	\
    (This)->lpVtbl -> get__NewEnum(This,pRetVal)

#define IDiaEnumSegments_get_Count(This,pRetVal)	\
    (This)->lpVtbl -> get_Count(This,pRetVal)

#define IDiaEnumSegments_Item(This,index,segment)	\
    (This)->lpVtbl -> Item(This,index,segment)

#define IDiaEnumSegments_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IDiaEnumSegments_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IDiaEnumSegments_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IDiaEnumSegments_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumSegments_get__NewEnum_Proxy( 
    IDiaEnumSegments * This,
    /* [retval][out] */ IUnknown **pRetVal);


void __RPC_STUB IDiaEnumSegments_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumSegments_get_Count_Proxy( 
    IDiaEnumSegments * This,
    /* [retval][out] */ LONG *pRetVal);


void __RPC_STUB IDiaEnumSegments_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDiaEnumSegments_Item_Proxy( 
    IDiaEnumSegments * This,
    /* [in] */ DWORD index,
    /* [retval][out] */ IDiaSegment **segment);


void __RPC_STUB IDiaEnumSegments_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumSegments_Next_Proxy( 
    IDiaEnumSegments * This,
    /* [in] */ ULONG celt,
    /* [out] */ IDiaSegment **rgelt,
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB IDiaEnumSegments_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumSegments_Skip_Proxy( 
    IDiaEnumSegments * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IDiaEnumSegments_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumSegments_Reset_Proxy( 
    IDiaEnumSegments * This);


void __RPC_STUB IDiaEnumSegments_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumSegments_Clone_Proxy( 
    IDiaEnumSegments * This,
    /* [out] */ IDiaEnumSegments **ppenum);


void __RPC_STUB IDiaEnumSegments_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaEnumSegments_INTERFACE_DEFINED__ */


#ifndef __IDiaEnumSectionContribs_INTERFACE_DEFINED__
#define __IDiaEnumSectionContribs_INTERFACE_DEFINED__

/* interface IDiaEnumSectionContribs */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaEnumSectionContribs;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1994DEB2-2C82-4b1d-A57F-AFF424D54A68")
    IDiaEnumSectionContribs : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ LONG *pRetVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ DWORD index,
            /* [retval][out] */ IDiaSectionContrib **section) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [out] */ IDiaSectionContrib **rgelt,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IDiaEnumSectionContribs **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaEnumSectionContribsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaEnumSectionContribs * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaEnumSectionContribs * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaEnumSectionContribs * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IDiaEnumSectionContribs * This,
            /* [retval][out] */ IUnknown **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IDiaEnumSectionContribs * This,
            /* [retval][out] */ LONG *pRetVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Item )( 
            IDiaEnumSectionContribs * This,
            /* [in] */ DWORD index,
            /* [retval][out] */ IDiaSectionContrib **section);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IDiaEnumSectionContribs * This,
            /* [in] */ ULONG celt,
            /* [out] */ IDiaSectionContrib **rgelt,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IDiaEnumSectionContribs * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IDiaEnumSectionContribs * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IDiaEnumSectionContribs * This,
            /* [out] */ IDiaEnumSectionContribs **ppenum);
        
        END_INTERFACE
    } IDiaEnumSectionContribsVtbl;

    interface IDiaEnumSectionContribs
    {
        CONST_VTBL struct IDiaEnumSectionContribsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaEnumSectionContribs_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaEnumSectionContribs_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaEnumSectionContribs_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaEnumSectionContribs_get__NewEnum(This,pRetVal)	\
    (This)->lpVtbl -> get__NewEnum(This,pRetVal)

#define IDiaEnumSectionContribs_get_Count(This,pRetVal)	\
    (This)->lpVtbl -> get_Count(This,pRetVal)

#define IDiaEnumSectionContribs_Item(This,index,section)	\
    (This)->lpVtbl -> Item(This,index,section)

#define IDiaEnumSectionContribs_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IDiaEnumSectionContribs_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IDiaEnumSectionContribs_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IDiaEnumSectionContribs_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumSectionContribs_get__NewEnum_Proxy( 
    IDiaEnumSectionContribs * This,
    /* [retval][out] */ IUnknown **pRetVal);


void __RPC_STUB IDiaEnumSectionContribs_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumSectionContribs_get_Count_Proxy( 
    IDiaEnumSectionContribs * This,
    /* [retval][out] */ LONG *pRetVal);


void __RPC_STUB IDiaEnumSectionContribs_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDiaEnumSectionContribs_Item_Proxy( 
    IDiaEnumSectionContribs * This,
    /* [in] */ DWORD index,
    /* [retval][out] */ IDiaSectionContrib **section);


void __RPC_STUB IDiaEnumSectionContribs_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumSectionContribs_Next_Proxy( 
    IDiaEnumSectionContribs * This,
    /* [in] */ ULONG celt,
    /* [out] */ IDiaSectionContrib **rgelt,
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB IDiaEnumSectionContribs_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumSectionContribs_Skip_Proxy( 
    IDiaEnumSectionContribs * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IDiaEnumSectionContribs_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumSectionContribs_Reset_Proxy( 
    IDiaEnumSectionContribs * This);


void __RPC_STUB IDiaEnumSectionContribs_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumSectionContribs_Clone_Proxy( 
    IDiaEnumSectionContribs * This,
    /* [out] */ IDiaEnumSectionContribs **ppenum);


void __RPC_STUB IDiaEnumSectionContribs_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaEnumSectionContribs_INTERFACE_DEFINED__ */


#ifndef __IDiaEnumFrameData_INTERFACE_DEFINED__
#define __IDiaEnumFrameData_INTERFACE_DEFINED__

/* interface IDiaEnumFrameData */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaEnumFrameData;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9FC77A4B-3C1C-44ed-A798-6C1DEEA53E1F")
    IDiaEnumFrameData : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ LONG *pRetVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ DWORD index,
            /* [retval][out] */ IDiaFrameData **frame) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [out] */ IDiaFrameData **rgelt,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IDiaEnumFrameData **ppenum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE frameByRVA( 
            /* [in] */ DWORD relativeVirtualAddress,
            /* [retval][out] */ IDiaFrameData **frame) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE frameByVA( 
            /* [in] */ ULONGLONG virtualAddress,
            /* [retval][out] */ IDiaFrameData **frame) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaEnumFrameDataVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaEnumFrameData * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaEnumFrameData * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaEnumFrameData * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IDiaEnumFrameData * This,
            /* [retval][out] */ IUnknown **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IDiaEnumFrameData * This,
            /* [retval][out] */ LONG *pRetVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Item )( 
            IDiaEnumFrameData * This,
            /* [in] */ DWORD index,
            /* [retval][out] */ IDiaFrameData **frame);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IDiaEnumFrameData * This,
            /* [in] */ ULONG celt,
            /* [out] */ IDiaFrameData **rgelt,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IDiaEnumFrameData * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IDiaEnumFrameData * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IDiaEnumFrameData * This,
            /* [out] */ IDiaEnumFrameData **ppenum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *frameByRVA )( 
            IDiaEnumFrameData * This,
            /* [in] */ DWORD relativeVirtualAddress,
            /* [retval][out] */ IDiaFrameData **frame);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *frameByVA )( 
            IDiaEnumFrameData * This,
            /* [in] */ ULONGLONG virtualAddress,
            /* [retval][out] */ IDiaFrameData **frame);
        
        END_INTERFACE
    } IDiaEnumFrameDataVtbl;

    interface IDiaEnumFrameData
    {
        CONST_VTBL struct IDiaEnumFrameDataVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaEnumFrameData_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaEnumFrameData_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaEnumFrameData_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaEnumFrameData_get__NewEnum(This,pRetVal)	\
    (This)->lpVtbl -> get__NewEnum(This,pRetVal)

#define IDiaEnumFrameData_get_Count(This,pRetVal)	\
    (This)->lpVtbl -> get_Count(This,pRetVal)

#define IDiaEnumFrameData_Item(This,index,frame)	\
    (This)->lpVtbl -> Item(This,index,frame)

#define IDiaEnumFrameData_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IDiaEnumFrameData_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IDiaEnumFrameData_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IDiaEnumFrameData_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#define IDiaEnumFrameData_frameByRVA(This,relativeVirtualAddress,frame)	\
    (This)->lpVtbl -> frameByRVA(This,relativeVirtualAddress,frame)

#define IDiaEnumFrameData_frameByVA(This,virtualAddress,frame)	\
    (This)->lpVtbl -> frameByVA(This,virtualAddress,frame)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumFrameData_get__NewEnum_Proxy( 
    IDiaEnumFrameData * This,
    /* [retval][out] */ IUnknown **pRetVal);


void __RPC_STUB IDiaEnumFrameData_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumFrameData_get_Count_Proxy( 
    IDiaEnumFrameData * This,
    /* [retval][out] */ LONG *pRetVal);


void __RPC_STUB IDiaEnumFrameData_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDiaEnumFrameData_Item_Proxy( 
    IDiaEnumFrameData * This,
    /* [in] */ DWORD index,
    /* [retval][out] */ IDiaFrameData **frame);


void __RPC_STUB IDiaEnumFrameData_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumFrameData_Next_Proxy( 
    IDiaEnumFrameData * This,
    /* [in] */ ULONG celt,
    /* [out] */ IDiaFrameData **rgelt,
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB IDiaEnumFrameData_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumFrameData_Skip_Proxy( 
    IDiaEnumFrameData * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IDiaEnumFrameData_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumFrameData_Reset_Proxy( 
    IDiaEnumFrameData * This);


void __RPC_STUB IDiaEnumFrameData_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumFrameData_Clone_Proxy( 
    IDiaEnumFrameData * This,
    /* [out] */ IDiaEnumFrameData **ppenum);


void __RPC_STUB IDiaEnumFrameData_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDiaEnumFrameData_frameByRVA_Proxy( 
    IDiaEnumFrameData * This,
    /* [in] */ DWORD relativeVirtualAddress,
    /* [retval][out] */ IDiaFrameData **frame);


void __RPC_STUB IDiaEnumFrameData_frameByRVA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDiaEnumFrameData_frameByVA_Proxy( 
    IDiaEnumFrameData * This,
    /* [in] */ ULONGLONG virtualAddress,
    /* [retval][out] */ IDiaFrameData **frame);


void __RPC_STUB IDiaEnumFrameData_frameByVA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaEnumFrameData_INTERFACE_DEFINED__ */


#ifndef __IDiaEnumDebugStreamData_INTERFACE_DEFINED__
#define __IDiaEnumDebugStreamData_INTERFACE_DEFINED__

/* interface IDiaEnumDebugStreamData */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaEnumDebugStreamData;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("486943E8-D187-4a6b-A3C4-291259FFF60D")
    IDiaEnumDebugStreamData : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ LONG *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_name( 
            /* [retval][out] */ BSTR *pRetVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ DWORD index,
            /* [in] */ DWORD cbData,
            /* [out] */ DWORD *pcbData,
            /* [length_is][size_is][out] */ BYTE data[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [in] */ DWORD cbData,
            /* [out] */ DWORD *pcbData,
            /* [length_is][size_is][out] */ BYTE data[  ],
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IDiaEnumDebugStreamData **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaEnumDebugStreamDataVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaEnumDebugStreamData * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaEnumDebugStreamData * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaEnumDebugStreamData * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IDiaEnumDebugStreamData * This,
            /* [retval][out] */ IUnknown **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IDiaEnumDebugStreamData * This,
            /* [retval][out] */ LONG *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_name )( 
            IDiaEnumDebugStreamData * This,
            /* [retval][out] */ BSTR *pRetVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Item )( 
            IDiaEnumDebugStreamData * This,
            /* [in] */ DWORD index,
            /* [in] */ DWORD cbData,
            /* [out] */ DWORD *pcbData,
            /* [length_is][size_is][out] */ BYTE data[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IDiaEnumDebugStreamData * This,
            /* [in] */ ULONG celt,
            /* [in] */ DWORD cbData,
            /* [out] */ DWORD *pcbData,
            /* [length_is][size_is][out] */ BYTE data[  ],
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IDiaEnumDebugStreamData * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IDiaEnumDebugStreamData * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IDiaEnumDebugStreamData * This,
            /* [out] */ IDiaEnumDebugStreamData **ppenum);
        
        END_INTERFACE
    } IDiaEnumDebugStreamDataVtbl;

    interface IDiaEnumDebugStreamData
    {
        CONST_VTBL struct IDiaEnumDebugStreamDataVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaEnumDebugStreamData_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaEnumDebugStreamData_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaEnumDebugStreamData_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaEnumDebugStreamData_get__NewEnum(This,pRetVal)	\
    (This)->lpVtbl -> get__NewEnum(This,pRetVal)

#define IDiaEnumDebugStreamData_get_Count(This,pRetVal)	\
    (This)->lpVtbl -> get_Count(This,pRetVal)

#define IDiaEnumDebugStreamData_get_name(This,pRetVal)	\
    (This)->lpVtbl -> get_name(This,pRetVal)

#define IDiaEnumDebugStreamData_Item(This,index,cbData,pcbData,data)	\
    (This)->lpVtbl -> Item(This,index,cbData,pcbData,data)

#define IDiaEnumDebugStreamData_Next(This,celt,cbData,pcbData,data,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,cbData,pcbData,data,pceltFetched)

#define IDiaEnumDebugStreamData_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IDiaEnumDebugStreamData_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IDiaEnumDebugStreamData_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumDebugStreamData_get__NewEnum_Proxy( 
    IDiaEnumDebugStreamData * This,
    /* [retval][out] */ IUnknown **pRetVal);


void __RPC_STUB IDiaEnumDebugStreamData_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumDebugStreamData_get_Count_Proxy( 
    IDiaEnumDebugStreamData * This,
    /* [retval][out] */ LONG *pRetVal);


void __RPC_STUB IDiaEnumDebugStreamData_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumDebugStreamData_get_name_Proxy( 
    IDiaEnumDebugStreamData * This,
    /* [retval][out] */ BSTR *pRetVal);


void __RPC_STUB IDiaEnumDebugStreamData_get_name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDiaEnumDebugStreamData_Item_Proxy( 
    IDiaEnumDebugStreamData * This,
    /* [in] */ DWORD index,
    /* [in] */ DWORD cbData,
    /* [out] */ DWORD *pcbData,
    /* [length_is][size_is][out] */ BYTE data[  ]);


void __RPC_STUB IDiaEnumDebugStreamData_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumDebugStreamData_Next_Proxy( 
    IDiaEnumDebugStreamData * This,
    /* [in] */ ULONG celt,
    /* [in] */ DWORD cbData,
    /* [out] */ DWORD *pcbData,
    /* [length_is][size_is][out] */ BYTE data[  ],
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB IDiaEnumDebugStreamData_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumDebugStreamData_Skip_Proxy( 
    IDiaEnumDebugStreamData * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IDiaEnumDebugStreamData_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumDebugStreamData_Reset_Proxy( 
    IDiaEnumDebugStreamData * This);


void __RPC_STUB IDiaEnumDebugStreamData_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumDebugStreamData_Clone_Proxy( 
    IDiaEnumDebugStreamData * This,
    /* [out] */ IDiaEnumDebugStreamData **ppenum);


void __RPC_STUB IDiaEnumDebugStreamData_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaEnumDebugStreamData_INTERFACE_DEFINED__ */


#ifndef __IDiaEnumDebugStreams_INTERFACE_DEFINED__
#define __IDiaEnumDebugStreams_INTERFACE_DEFINED__

/* interface IDiaEnumDebugStreams */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaEnumDebugStreams;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("08CBB41E-47A6-4f87-92F1-1C9C87CED044")
    IDiaEnumDebugStreams : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ LONG *pRetVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ VARIANT index,
            /* [retval][out] */ IDiaEnumDebugStreamData **stream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [out] */ IDiaEnumDebugStreamData **rgelt,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IDiaEnumDebugStreams **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaEnumDebugStreamsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaEnumDebugStreams * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaEnumDebugStreams * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaEnumDebugStreams * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IDiaEnumDebugStreams * This,
            /* [retval][out] */ IUnknown **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IDiaEnumDebugStreams * This,
            /* [retval][out] */ LONG *pRetVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Item )( 
            IDiaEnumDebugStreams * This,
            /* [in] */ VARIANT index,
            /* [retval][out] */ IDiaEnumDebugStreamData **stream);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IDiaEnumDebugStreams * This,
            /* [in] */ ULONG celt,
            /* [out] */ IDiaEnumDebugStreamData **rgelt,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IDiaEnumDebugStreams * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IDiaEnumDebugStreams * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IDiaEnumDebugStreams * This,
            /* [out] */ IDiaEnumDebugStreams **ppenum);
        
        END_INTERFACE
    } IDiaEnumDebugStreamsVtbl;

    interface IDiaEnumDebugStreams
    {
        CONST_VTBL struct IDiaEnumDebugStreamsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaEnumDebugStreams_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaEnumDebugStreams_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaEnumDebugStreams_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaEnumDebugStreams_get__NewEnum(This,pRetVal)	\
    (This)->lpVtbl -> get__NewEnum(This,pRetVal)

#define IDiaEnumDebugStreams_get_Count(This,pRetVal)	\
    (This)->lpVtbl -> get_Count(This,pRetVal)

#define IDiaEnumDebugStreams_Item(This,index,stream)	\
    (This)->lpVtbl -> Item(This,index,stream)

#define IDiaEnumDebugStreams_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IDiaEnumDebugStreams_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IDiaEnumDebugStreams_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IDiaEnumDebugStreams_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumDebugStreams_get__NewEnum_Proxy( 
    IDiaEnumDebugStreams * This,
    /* [retval][out] */ IUnknown **pRetVal);


void __RPC_STUB IDiaEnumDebugStreams_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumDebugStreams_get_Count_Proxy( 
    IDiaEnumDebugStreams * This,
    /* [retval][out] */ LONG *pRetVal);


void __RPC_STUB IDiaEnumDebugStreams_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDiaEnumDebugStreams_Item_Proxy( 
    IDiaEnumDebugStreams * This,
    /* [in] */ VARIANT index,
    /* [retval][out] */ IDiaEnumDebugStreamData **stream);


void __RPC_STUB IDiaEnumDebugStreams_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumDebugStreams_Next_Proxy( 
    IDiaEnumDebugStreams * This,
    /* [in] */ ULONG celt,
    /* [out] */ IDiaEnumDebugStreamData **rgelt,
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB IDiaEnumDebugStreams_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumDebugStreams_Skip_Proxy( 
    IDiaEnumDebugStreams * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IDiaEnumDebugStreams_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumDebugStreams_Reset_Proxy( 
    IDiaEnumDebugStreams * This);


void __RPC_STUB IDiaEnumDebugStreams_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumDebugStreams_Clone_Proxy( 
    IDiaEnumDebugStreams * This,
    /* [out] */ IDiaEnumDebugStreams **ppenum);


void __RPC_STUB IDiaEnumDebugStreams_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaEnumDebugStreams_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dia2_internal_0138 */
/* [local] */ 

struct DiaAddressMapEntry
    {
    DWORD rva;
    DWORD rvaTo;
    } ;


extern RPC_IF_HANDLE __MIDL_itf_dia2_internal_0138_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dia2_internal_0138_v0_0_s_ifspec;

#ifndef __IDiaAddressMap_INTERFACE_DEFINED__
#define __IDiaAddressMap_INTERFACE_DEFINED__

/* interface IDiaAddressMap */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaAddressMap;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B62A2E7A-067A-4ea3-B598-04C09717502C")
    IDiaAddressMap : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_addressMapEnabled( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_addressMapEnabled( 
            /* [in] */ BOOL NewVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_relativeVirtualAddressEnabled( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_relativeVirtualAddressEnabled( 
            /* [in] */ BOOL NewVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_imageAlign( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_imageAlign( 
            /* [in] */ DWORD NewVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE set_imageHeaders( 
            /* [in] */ DWORD cbData,
            /* [size_is][in] */ BYTE data[  ],
            /* [in] */ BOOL originalHeaders) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE set_addressMap( 
            /* [in] */ DWORD cData,
            /* [size_is][in] */ struct DiaAddressMapEntry data[  ],
            /* [in] */ BOOL imageToSymbols) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaAddressMapVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaAddressMap * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaAddressMap * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaAddressMap * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_addressMapEnabled )( 
            IDiaAddressMap * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_addressMapEnabled )( 
            IDiaAddressMap * This,
            /* [in] */ BOOL NewVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_relativeVirtualAddressEnabled )( 
            IDiaAddressMap * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_relativeVirtualAddressEnabled )( 
            IDiaAddressMap * This,
            /* [in] */ BOOL NewVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_imageAlign )( 
            IDiaAddressMap * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_imageAlign )( 
            IDiaAddressMap * This,
            /* [in] */ DWORD NewVal);
        
        HRESULT ( STDMETHODCALLTYPE *set_imageHeaders )( 
            IDiaAddressMap * This,
            /* [in] */ DWORD cbData,
            /* [size_is][in] */ BYTE data[  ],
            /* [in] */ BOOL originalHeaders);
        
        HRESULT ( STDMETHODCALLTYPE *set_addressMap )( 
            IDiaAddressMap * This,
            /* [in] */ DWORD cData,
            /* [size_is][in] */ struct DiaAddressMapEntry data[  ],
            /* [in] */ BOOL imageToSymbols);
        
        END_INTERFACE
    } IDiaAddressMapVtbl;

    interface IDiaAddressMap
    {
        CONST_VTBL struct IDiaAddressMapVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaAddressMap_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaAddressMap_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaAddressMap_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaAddressMap_get_addressMapEnabled(This,pRetVal)	\
    (This)->lpVtbl -> get_addressMapEnabled(This,pRetVal)

#define IDiaAddressMap_put_addressMapEnabled(This,NewVal)	\
    (This)->lpVtbl -> put_addressMapEnabled(This,NewVal)

#define IDiaAddressMap_get_relativeVirtualAddressEnabled(This,pRetVal)	\
    (This)->lpVtbl -> get_relativeVirtualAddressEnabled(This,pRetVal)

#define IDiaAddressMap_put_relativeVirtualAddressEnabled(This,NewVal)	\
    (This)->lpVtbl -> put_relativeVirtualAddressEnabled(This,NewVal)

#define IDiaAddressMap_get_imageAlign(This,pRetVal)	\
    (This)->lpVtbl -> get_imageAlign(This,pRetVal)

#define IDiaAddressMap_put_imageAlign(This,NewVal)	\
    (This)->lpVtbl -> put_imageAlign(This,NewVal)

#define IDiaAddressMap_set_imageHeaders(This,cbData,data,originalHeaders)	\
    (This)->lpVtbl -> set_imageHeaders(This,cbData,data,originalHeaders)

#define IDiaAddressMap_set_addressMap(This,cData,data,imageToSymbols)	\
    (This)->lpVtbl -> set_addressMap(This,cData,data,imageToSymbols)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaAddressMap_get_addressMapEnabled_Proxy( 
    IDiaAddressMap * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaAddressMap_get_addressMapEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE IDiaAddressMap_put_addressMapEnabled_Proxy( 
    IDiaAddressMap * This,
    /* [in] */ BOOL NewVal);


void __RPC_STUB IDiaAddressMap_put_addressMapEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaAddressMap_get_relativeVirtualAddressEnabled_Proxy( 
    IDiaAddressMap * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaAddressMap_get_relativeVirtualAddressEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE IDiaAddressMap_put_relativeVirtualAddressEnabled_Proxy( 
    IDiaAddressMap * This,
    /* [in] */ BOOL NewVal);


void __RPC_STUB IDiaAddressMap_put_relativeVirtualAddressEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaAddressMap_get_imageAlign_Proxy( 
    IDiaAddressMap * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaAddressMap_get_imageAlign_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE IDiaAddressMap_put_imageAlign_Proxy( 
    IDiaAddressMap * This,
    /* [in] */ DWORD NewVal);


void __RPC_STUB IDiaAddressMap_put_imageAlign_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaAddressMap_set_imageHeaders_Proxy( 
    IDiaAddressMap * This,
    /* [in] */ DWORD cbData,
    /* [size_is][in] */ BYTE data[  ],
    /* [in] */ BOOL originalHeaders);


void __RPC_STUB IDiaAddressMap_set_imageHeaders_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaAddressMap_set_addressMap_Proxy( 
    IDiaAddressMap * This,
    /* [in] */ DWORD cData,
    /* [size_is][in] */ struct DiaAddressMapEntry data[  ],
    /* [in] */ BOOL imageToSymbols);


void __RPC_STUB IDiaAddressMap_set_addressMap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaAddressMap_INTERFACE_DEFINED__ */


#ifndef __IDiaSession_INTERFACE_DEFINED__
#define __IDiaSession_INTERFACE_DEFINED__

/* interface IDiaSession */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaSession;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("67138B34-79CD-4b42-B74A-A18ADBB799DF")
    IDiaSession : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_loadAddress( 
            /* [retval][out] */ ULONGLONG *pRetVal) = 0;
        
        virtual /* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_loadAddress( 
            /* [in] */ ULONGLONG NewVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_globalScope( 
            /* [retval][out] */ IDiaSymbol **pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getEnumTables( 
            /* [out] */ IDiaEnumTables **ppEnumTables) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getSymbolsByAddr( 
            /* [out] */ IDiaEnumSymbolsByAddr **ppEnumbyAddr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE findChildren( 
            /* [in] */ IDiaSymbol *parent,
            /* [in] */ enum SymTagEnum symtag,
            /* [in] */ LPCOLESTR name,
            /* [in] */ DWORD compareFlags,
            /* [out] */ IDiaEnumSymbols **ppResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE findSymbolByAddr( 
            /* [in] */ DWORD isect,
            /* [in] */ DWORD offset,
            /* [in] */ enum SymTagEnum symtag,
            /* [out] */ IDiaSymbol **ppSymbol) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE findSymbolByRVA( 
            /* [in] */ DWORD rva,
            /* [in] */ enum SymTagEnum symtag,
            /* [out] */ IDiaSymbol **ppSymbol) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE findSymbolByVA( 
            /* [in] */ ULONGLONG va,
            /* [in] */ enum SymTagEnum symtag,
            /* [out] */ IDiaSymbol **ppSymbol) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE findSymbolByToken( 
            /* [in] */ ULONG token,
            /* [in] */ enum SymTagEnum symtag,
            /* [out] */ IDiaSymbol **ppSymbol) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE symsAreEquiv( 
            /* [in] */ IDiaSymbol *symbolA,
            /* [in] */ IDiaSymbol *symbolB) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE symbolById( 
            /* [in] */ DWORD id,
            /* [out] */ IDiaSymbol **ppSymbol) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE findSymbolByRVAEx( 
            /* [in] */ DWORD rva,
            /* [in] */ enum SymTagEnum symtag,
            /* [out] */ IDiaSymbol **ppSymbol,
            /* [out] */ long *displacement) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE findSymbolByVAEx( 
            /* [in] */ ULONGLONG va,
            /* [in] */ enum SymTagEnum symtag,
            /* [out] */ IDiaSymbol **ppSymbol,
            /* [out] */ long *displacement) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE findFile( 
            /* [in] */ IDiaSymbol *pCompiland,
            /* [in] */ LPCOLESTR name,
            /* [in] */ DWORD compareFlags,
            /* [out] */ IDiaEnumSourceFiles **ppResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE findFileById( 
            /* [in] */ DWORD uniqueId,
            /* [out] */ IDiaSourceFile **ppResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE findLines( 
            /* [in] */ IDiaSymbol *compiland,
            /* [in] */ IDiaSourceFile *file,
            /* [out] */ IDiaEnumLineNumbers **ppResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE findLinesByAddr( 
            /* [in] */ DWORD seg,
            /* [in] */ DWORD offset,
            /* [in] */ DWORD length,
            /* [out] */ IDiaEnumLineNumbers **ppResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE findLinesByRVA( 
            /* [in] */ DWORD rva,
            /* [in] */ DWORD length,
            /* [out] */ IDiaEnumLineNumbers **ppResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE findLinesByVA( 
            /* [in] */ ULONGLONG va,
            /* [in] */ DWORD length,
            /* [out] */ IDiaEnumLineNumbers **ppResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE findLinesByLinenum( 
            /* [in] */ IDiaSymbol *compiland,
            /* [in] */ IDiaSourceFile *file,
            /* [in] */ DWORD linenum,
            /* [in] */ DWORD column,
            /* [out] */ IDiaEnumLineNumbers **ppResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE findInjectedSource( 
            /* [in] */ LPCOLESTR srcFile,
            /* [out] */ IDiaEnumInjectedSources **ppResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getEnumDebugStreams( 
            /* [out] */ IDiaEnumDebugStreams **ppEnumDebugStreams) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaSessionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaSession * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaSession * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaSession * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_loadAddress )( 
            IDiaSession * This,
            /* [retval][out] */ ULONGLONG *pRetVal);
        
        /* [id][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_loadAddress )( 
            IDiaSession * This,
            /* [in] */ ULONGLONG NewVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_globalScope )( 
            IDiaSession * This,
            /* [retval][out] */ IDiaSymbol **pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *getEnumTables )( 
            IDiaSession * This,
            /* [out] */ IDiaEnumTables **ppEnumTables);
        
        HRESULT ( STDMETHODCALLTYPE *getSymbolsByAddr )( 
            IDiaSession * This,
            /* [out] */ IDiaEnumSymbolsByAddr **ppEnumbyAddr);
        
        HRESULT ( STDMETHODCALLTYPE *findChildren )( 
            IDiaSession * This,
            /* [in] */ IDiaSymbol *parent,
            /* [in] */ enum SymTagEnum symtag,
            /* [in] */ LPCOLESTR name,
            /* [in] */ DWORD compareFlags,
            /* [out] */ IDiaEnumSymbols **ppResult);
        
        HRESULT ( STDMETHODCALLTYPE *findSymbolByAddr )( 
            IDiaSession * This,
            /* [in] */ DWORD isect,
            /* [in] */ DWORD offset,
            /* [in] */ enum SymTagEnum symtag,
            /* [out] */ IDiaSymbol **ppSymbol);
        
        HRESULT ( STDMETHODCALLTYPE *findSymbolByRVA )( 
            IDiaSession * This,
            /* [in] */ DWORD rva,
            /* [in] */ enum SymTagEnum symtag,
            /* [out] */ IDiaSymbol **ppSymbol);
        
        HRESULT ( STDMETHODCALLTYPE *findSymbolByVA )( 
            IDiaSession * This,
            /* [in] */ ULONGLONG va,
            /* [in] */ enum SymTagEnum symtag,
            /* [out] */ IDiaSymbol **ppSymbol);
        
        HRESULT ( STDMETHODCALLTYPE *findSymbolByToken )( 
            IDiaSession * This,
            /* [in] */ ULONG token,
            /* [in] */ enum SymTagEnum symtag,
            /* [out] */ IDiaSymbol **ppSymbol);
        
        HRESULT ( STDMETHODCALLTYPE *symsAreEquiv )( 
            IDiaSession * This,
            /* [in] */ IDiaSymbol *symbolA,
            /* [in] */ IDiaSymbol *symbolB);
        
        HRESULT ( STDMETHODCALLTYPE *symbolById )( 
            IDiaSession * This,
            /* [in] */ DWORD id,
            /* [out] */ IDiaSymbol **ppSymbol);
        
        HRESULT ( STDMETHODCALLTYPE *findSymbolByRVAEx )( 
            IDiaSession * This,
            /* [in] */ DWORD rva,
            /* [in] */ enum SymTagEnum symtag,
            /* [out] */ IDiaSymbol **ppSymbol,
            /* [out] */ long *displacement);
        
        HRESULT ( STDMETHODCALLTYPE *findSymbolByVAEx )( 
            IDiaSession * This,
            /* [in] */ ULONGLONG va,
            /* [in] */ enum SymTagEnum symtag,
            /* [out] */ IDiaSymbol **ppSymbol,
            /* [out] */ long *displacement);
        
        HRESULT ( STDMETHODCALLTYPE *findFile )( 
            IDiaSession * This,
            /* [in] */ IDiaSymbol *pCompiland,
            /* [in] */ LPCOLESTR name,
            /* [in] */ DWORD compareFlags,
            /* [out] */ IDiaEnumSourceFiles **ppResult);
        
        HRESULT ( STDMETHODCALLTYPE *findFileById )( 
            IDiaSession * This,
            /* [in] */ DWORD uniqueId,
            /* [out] */ IDiaSourceFile **ppResult);
        
        HRESULT ( STDMETHODCALLTYPE *findLines )( 
            IDiaSession * This,
            /* [in] */ IDiaSymbol *compiland,
            /* [in] */ IDiaSourceFile *file,
            /* [out] */ IDiaEnumLineNumbers **ppResult);
        
        HRESULT ( STDMETHODCALLTYPE *findLinesByAddr )( 
            IDiaSession * This,
            /* [in] */ DWORD seg,
            /* [in] */ DWORD offset,
            /* [in] */ DWORD length,
            /* [out] */ IDiaEnumLineNumbers **ppResult);
        
        HRESULT ( STDMETHODCALLTYPE *findLinesByRVA )( 
            IDiaSession * This,
            /* [in] */ DWORD rva,
            /* [in] */ DWORD length,
            /* [out] */ IDiaEnumLineNumbers **ppResult);
        
        HRESULT ( STDMETHODCALLTYPE *findLinesByVA )( 
            IDiaSession * This,
            /* [in] */ ULONGLONG va,
            /* [in] */ DWORD length,
            /* [out] */ IDiaEnumLineNumbers **ppResult);
        
        HRESULT ( STDMETHODCALLTYPE *findLinesByLinenum )( 
            IDiaSession * This,
            /* [in] */ IDiaSymbol *compiland,
            /* [in] */ IDiaSourceFile *file,
            /* [in] */ DWORD linenum,
            /* [in] */ DWORD column,
            /* [out] */ IDiaEnumLineNumbers **ppResult);
        
        HRESULT ( STDMETHODCALLTYPE *findInjectedSource )( 
            IDiaSession * This,
            /* [in] */ LPCOLESTR srcFile,
            /* [out] */ IDiaEnumInjectedSources **ppResult);
        
        HRESULT ( STDMETHODCALLTYPE *getEnumDebugStreams )( 
            IDiaSession * This,
            /* [out] */ IDiaEnumDebugStreams **ppEnumDebugStreams);
        
        END_INTERFACE
    } IDiaSessionVtbl;

    interface IDiaSession
    {
        CONST_VTBL struct IDiaSessionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaSession_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaSession_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaSession_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaSession_get_loadAddress(This,pRetVal)	\
    (This)->lpVtbl -> get_loadAddress(This,pRetVal)

#define IDiaSession_put_loadAddress(This,NewVal)	\
    (This)->lpVtbl -> put_loadAddress(This,NewVal)

#define IDiaSession_get_globalScope(This,pRetVal)	\
    (This)->lpVtbl -> get_globalScope(This,pRetVal)

#define IDiaSession_getEnumTables(This,ppEnumTables)	\
    (This)->lpVtbl -> getEnumTables(This,ppEnumTables)

#define IDiaSession_getSymbolsByAddr(This,ppEnumbyAddr)	\
    (This)->lpVtbl -> getSymbolsByAddr(This,ppEnumbyAddr)

#define IDiaSession_findChildren(This,parent,symtag,name,compareFlags,ppResult)	\
    (This)->lpVtbl -> findChildren(This,parent,symtag,name,compareFlags,ppResult)

#define IDiaSession_findSymbolByAddr(This,isect,offset,symtag,ppSymbol)	\
    (This)->lpVtbl -> findSymbolByAddr(This,isect,offset,symtag,ppSymbol)

#define IDiaSession_findSymbolByRVA(This,rva,symtag,ppSymbol)	\
    (This)->lpVtbl -> findSymbolByRVA(This,rva,symtag,ppSymbol)

#define IDiaSession_findSymbolByVA(This,va,symtag,ppSymbol)	\
    (This)->lpVtbl -> findSymbolByVA(This,va,symtag,ppSymbol)

#define IDiaSession_findSymbolByToken(This,token,symtag,ppSymbol)	\
    (This)->lpVtbl -> findSymbolByToken(This,token,symtag,ppSymbol)

#define IDiaSession_symsAreEquiv(This,symbolA,symbolB)	\
    (This)->lpVtbl -> symsAreEquiv(This,symbolA,symbolB)

#define IDiaSession_symbolById(This,id,ppSymbol)	\
    (This)->lpVtbl -> symbolById(This,id,ppSymbol)

#define IDiaSession_findSymbolByRVAEx(This,rva,symtag,ppSymbol,displacement)	\
    (This)->lpVtbl -> findSymbolByRVAEx(This,rva,symtag,ppSymbol,displacement)

#define IDiaSession_findSymbolByVAEx(This,va,symtag,ppSymbol,displacement)	\
    (This)->lpVtbl -> findSymbolByVAEx(This,va,symtag,ppSymbol,displacement)

#define IDiaSession_findFile(This,pCompiland,name,compareFlags,ppResult)	\
    (This)->lpVtbl -> findFile(This,pCompiland,name,compareFlags,ppResult)

#define IDiaSession_findFileById(This,uniqueId,ppResult)	\
    (This)->lpVtbl -> findFileById(This,uniqueId,ppResult)

#define IDiaSession_findLines(This,compiland,file,ppResult)	\
    (This)->lpVtbl -> findLines(This,compiland,file,ppResult)

#define IDiaSession_findLinesByAddr(This,seg,offset,length,ppResult)	\
    (This)->lpVtbl -> findLinesByAddr(This,seg,offset,length,ppResult)

#define IDiaSession_findLinesByRVA(This,rva,length,ppResult)	\
    (This)->lpVtbl -> findLinesByRVA(This,rva,length,ppResult)

#define IDiaSession_findLinesByVA(This,va,length,ppResult)	\
    (This)->lpVtbl -> findLinesByVA(This,va,length,ppResult)

#define IDiaSession_findLinesByLinenum(This,compiland,file,linenum,column,ppResult)	\
    (This)->lpVtbl -> findLinesByLinenum(This,compiland,file,linenum,column,ppResult)

#define IDiaSession_findInjectedSource(This,srcFile,ppResult)	\
    (This)->lpVtbl -> findInjectedSource(This,srcFile,ppResult)

#define IDiaSession_getEnumDebugStreams(This,ppEnumDebugStreams)	\
    (This)->lpVtbl -> getEnumDebugStreams(This,ppEnumDebugStreams)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSession_get_loadAddress_Proxy( 
    IDiaSession * This,
    /* [retval][out] */ ULONGLONG *pRetVal);


void __RPC_STUB IDiaSession_get_loadAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE IDiaSession_put_loadAddress_Proxy( 
    IDiaSession * This,
    /* [in] */ ULONGLONG NewVal);


void __RPC_STUB IDiaSession_put_loadAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSession_get_globalScope_Proxy( 
    IDiaSession * This,
    /* [retval][out] */ IDiaSymbol **pRetVal);


void __RPC_STUB IDiaSession_get_globalScope_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSession_getEnumTables_Proxy( 
    IDiaSession * This,
    /* [out] */ IDiaEnumTables **ppEnumTables);


void __RPC_STUB IDiaSession_getEnumTables_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSession_getSymbolsByAddr_Proxy( 
    IDiaSession * This,
    /* [out] */ IDiaEnumSymbolsByAddr **ppEnumbyAddr);


void __RPC_STUB IDiaSession_getSymbolsByAddr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSession_findChildren_Proxy( 
    IDiaSession * This,
    /* [in] */ IDiaSymbol *parent,
    /* [in] */ enum SymTagEnum symtag,
    /* [in] */ LPCOLESTR name,
    /* [in] */ DWORD compareFlags,
    /* [out] */ IDiaEnumSymbols **ppResult);


void __RPC_STUB IDiaSession_findChildren_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSession_findSymbolByAddr_Proxy( 
    IDiaSession * This,
    /* [in] */ DWORD isect,
    /* [in] */ DWORD offset,
    /* [in] */ enum SymTagEnum symtag,
    /* [out] */ IDiaSymbol **ppSymbol);


void __RPC_STUB IDiaSession_findSymbolByAddr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSession_findSymbolByRVA_Proxy( 
    IDiaSession * This,
    /* [in] */ DWORD rva,
    /* [in] */ enum SymTagEnum symtag,
    /* [out] */ IDiaSymbol **ppSymbol);


void __RPC_STUB IDiaSession_findSymbolByRVA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSession_findSymbolByVA_Proxy( 
    IDiaSession * This,
    /* [in] */ ULONGLONG va,
    /* [in] */ enum SymTagEnum symtag,
    /* [out] */ IDiaSymbol **ppSymbol);


void __RPC_STUB IDiaSession_findSymbolByVA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSession_findSymbolByToken_Proxy( 
    IDiaSession * This,
    /* [in] */ ULONG token,
    /* [in] */ enum SymTagEnum symtag,
    /* [out] */ IDiaSymbol **ppSymbol);


void __RPC_STUB IDiaSession_findSymbolByToken_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSession_symsAreEquiv_Proxy( 
    IDiaSession * This,
    /* [in] */ IDiaSymbol *symbolA,
    /* [in] */ IDiaSymbol *symbolB);


void __RPC_STUB IDiaSession_symsAreEquiv_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSession_symbolById_Proxy( 
    IDiaSession * This,
    /* [in] */ DWORD id,
    /* [out] */ IDiaSymbol **ppSymbol);


void __RPC_STUB IDiaSession_symbolById_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSession_findSymbolByRVAEx_Proxy( 
    IDiaSession * This,
    /* [in] */ DWORD rva,
    /* [in] */ enum SymTagEnum symtag,
    /* [out] */ IDiaSymbol **ppSymbol,
    /* [out] */ long *displacement);


void __RPC_STUB IDiaSession_findSymbolByRVAEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSession_findSymbolByVAEx_Proxy( 
    IDiaSession * This,
    /* [in] */ ULONGLONG va,
    /* [in] */ enum SymTagEnum symtag,
    /* [out] */ IDiaSymbol **ppSymbol,
    /* [out] */ long *displacement);


void __RPC_STUB IDiaSession_findSymbolByVAEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSession_findFile_Proxy( 
    IDiaSession * This,
    /* [in] */ IDiaSymbol *pCompiland,
    /* [in] */ LPCOLESTR name,
    /* [in] */ DWORD compareFlags,
    /* [out] */ IDiaEnumSourceFiles **ppResult);


void __RPC_STUB IDiaSession_findFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSession_findFileById_Proxy( 
    IDiaSession * This,
    /* [in] */ DWORD uniqueId,
    /* [out] */ IDiaSourceFile **ppResult);


void __RPC_STUB IDiaSession_findFileById_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSession_findLines_Proxy( 
    IDiaSession * This,
    /* [in] */ IDiaSymbol *compiland,
    /* [in] */ IDiaSourceFile *file,
    /* [out] */ IDiaEnumLineNumbers **ppResult);


void __RPC_STUB IDiaSession_findLines_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSession_findLinesByAddr_Proxy( 
    IDiaSession * This,
    /* [in] */ DWORD seg,
    /* [in] */ DWORD offset,
    /* [in] */ DWORD length,
    /* [out] */ IDiaEnumLineNumbers **ppResult);


void __RPC_STUB IDiaSession_findLinesByAddr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSession_findLinesByRVA_Proxy( 
    IDiaSession * This,
    /* [in] */ DWORD rva,
    /* [in] */ DWORD length,
    /* [out] */ IDiaEnumLineNumbers **ppResult);


void __RPC_STUB IDiaSession_findLinesByRVA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSession_findLinesByVA_Proxy( 
    IDiaSession * This,
    /* [in] */ ULONGLONG va,
    /* [in] */ DWORD length,
    /* [out] */ IDiaEnumLineNumbers **ppResult);


void __RPC_STUB IDiaSession_findLinesByVA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSession_findLinesByLinenum_Proxy( 
    IDiaSession * This,
    /* [in] */ IDiaSymbol *compiland,
    /* [in] */ IDiaSourceFile *file,
    /* [in] */ DWORD linenum,
    /* [in] */ DWORD column,
    /* [out] */ IDiaEnumLineNumbers **ppResult);


void __RPC_STUB IDiaSession_findLinesByLinenum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSession_findInjectedSource_Proxy( 
    IDiaSession * This,
    /* [in] */ LPCOLESTR srcFile,
    /* [out] */ IDiaEnumInjectedSources **ppResult);


void __RPC_STUB IDiaSession_findInjectedSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSession_getEnumDebugStreams_Proxy( 
    IDiaSession * This,
    /* [out] */ IDiaEnumDebugStreams **ppEnumDebugStreams);


void __RPC_STUB IDiaSession_getEnumDebugStreams_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaSession_INTERFACE_DEFINED__ */


#ifndef __IDiaSymbol_INTERFACE_DEFINED__
#define __IDiaSymbol_INTERFACE_DEFINED__

/* interface IDiaSymbol */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaSymbol;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("72827A48-D320-4eaf-8436-548ADE47D5E5")
    IDiaSymbol : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_symIndexId( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_symTag( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_name( 
            /* [retval][out] */ BSTR *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_lexicalParent( 
            /* [retval][out] */ IDiaSymbol **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_classParent( 
            /* [retval][out] */ IDiaSymbol **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_type( 
            /* [retval][out] */ IDiaSymbol **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_dataKind( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_locationType( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_addressSection( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_addressOffset( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_relativeVirtualAddress( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_virtualAddress( 
            /* [retval][out] */ ULONGLONG *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_registerId( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_offset( 
            /* [retval][out] */ LONG *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_length( 
            /* [retval][out] */ ULONGLONG *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_slot( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_volatileType( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_constType( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_unalignedType( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_access( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_libraryName( 
            /* [retval][out] */ BSTR *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_platform( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_language( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_editAndContinueEnabled( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_frontEndMajor( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_frontEndMinor( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_frontEndBuild( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_backEndMajor( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_backEndMinor( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_backEndBuild( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_sourceFileName( 
            /* [retval][out] */ BSTR *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_unused( 
            /* [retval][out] */ BSTR *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_thunkOrdinal( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_thisAdjust( 
            /* [retval][out] */ LONG *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_virtualBaseOffset( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_virtual( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_intro( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_pure( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_callingConvention( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_value( 
            /* [retval][out] */ VARIANT *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_baseType( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_token( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_timeStamp( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_guid( 
            /* [retval][out] */ GUID *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_symbolsFileName( 
            /* [retval][out] */ BSTR *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_reference( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_count( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_bitPosition( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_arrayIndexType( 
            /* [retval][out] */ IDiaSymbol **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_packed( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_constructor( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_overloadedOperator( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_nested( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_hasNestedTypes( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_hasAssignmentOperator( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_hasCastOperator( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_scoped( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_virtualBaseClass( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_indirectVirtualBaseClass( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_virtualBasePointerOffset( 
            /* [retval][out] */ LONG *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_virtualTableShape( 
            /* [retval][out] */ IDiaSymbol **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_lexicalParentId( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_classParentId( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_typeId( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_arrayIndexTypeId( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_virtualTableShapeId( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_code( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_function( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_managed( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_msil( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_virtualBaseDispIndex( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_undecoratedName( 
            /* [retval][out] */ BSTR *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_age( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_signature( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_compilerGenerated( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_addressTaken( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_rank( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_lowerBound( 
            /* [retval][out] */ IDiaSymbol **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_upperBound( 
            /* [retval][out] */ IDiaSymbol **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_lowerBoundId( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_upperBoundId( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_dataBytes( 
            /* [in] */ DWORD cbData,
            /* [out] */ DWORD *pcbData,
            /* [length_is][size_is][out] */ BYTE data[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE findChildren( 
            /* [in] */ enum SymTagEnum symtag,
            /* [in] */ LPCOLESTR name,
            /* [in] */ DWORD compareFlags,
            /* [out] */ IDiaEnumSymbols **ppResult) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_targetSection( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_targetOffset( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_targetRelativeVirtualAddress( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_targetVirtualAddress( 
            /* [retval][out] */ ULONGLONG *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_machineType( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_oemId( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_oemSymbolId( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_types( 
            /* [in] */ DWORD cTypes,
            /* [out] */ DWORD *pcTypes,
            /* [length_is][size_is][out] */ IDiaSymbol *types[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_typeIds( 
            /* [in] */ DWORD cTypeIds,
            /* [out] */ DWORD *pcTypeIds,
            /* [length_is][size_is][out] */ DWORD typeIds[  ]) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_objectPointerType( 
            /* [retval][out] */ IDiaSymbol **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_udtKind( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_undecoratedNameEx( 
            /* [in] */ DWORD undecorateOptions,
            /* [out] */ BSTR *name) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaSymbolVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaSymbol * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaSymbol * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaSymbol * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_symIndexId )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_symTag )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_name )( 
            IDiaSymbol * This,
            /* [retval][out] */ BSTR *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lexicalParent )( 
            IDiaSymbol * This,
            /* [retval][out] */ IDiaSymbol **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_classParent )( 
            IDiaSymbol * This,
            /* [retval][out] */ IDiaSymbol **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_type )( 
            IDiaSymbol * This,
            /* [retval][out] */ IDiaSymbol **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_dataKind )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_locationType )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_addressSection )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_addressOffset )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_relativeVirtualAddress )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_virtualAddress )( 
            IDiaSymbol * This,
            /* [retval][out] */ ULONGLONG *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_registerId )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_offset )( 
            IDiaSymbol * This,
            /* [retval][out] */ LONG *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_length )( 
            IDiaSymbol * This,
            /* [retval][out] */ ULONGLONG *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_slot )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_volatileType )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_constType )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_unalignedType )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_access )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_libraryName )( 
            IDiaSymbol * This,
            /* [retval][out] */ BSTR *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_platform )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_language )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_editAndContinueEnabled )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_frontEndMajor )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_frontEndMinor )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_frontEndBuild )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_backEndMajor )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_backEndMinor )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_backEndBuild )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_sourceFileName )( 
            IDiaSymbol * This,
            /* [retval][out] */ BSTR *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_unused )( 
            IDiaSymbol * This,
            /* [retval][out] */ BSTR *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_thunkOrdinal )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_thisAdjust )( 
            IDiaSymbol * This,
            /* [retval][out] */ LONG *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_virtualBaseOffset )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_virtual )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_intro )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_pure )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_callingConvention )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_value )( 
            IDiaSymbol * This,
            /* [retval][out] */ VARIANT *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_baseType )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_token )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_timeStamp )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_guid )( 
            IDiaSymbol * This,
            /* [retval][out] */ GUID *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_symbolsFileName )( 
            IDiaSymbol * This,
            /* [retval][out] */ BSTR *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_reference )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_count )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_bitPosition )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_arrayIndexType )( 
            IDiaSymbol * This,
            /* [retval][out] */ IDiaSymbol **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_packed )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_constructor )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_overloadedOperator )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nested )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_hasNestedTypes )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_hasAssignmentOperator )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_hasCastOperator )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_scoped )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_virtualBaseClass )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_indirectVirtualBaseClass )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_virtualBasePointerOffset )( 
            IDiaSymbol * This,
            /* [retval][out] */ LONG *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_virtualTableShape )( 
            IDiaSymbol * This,
            /* [retval][out] */ IDiaSymbol **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lexicalParentId )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_classParentId )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_typeId )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_arrayIndexTypeId )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_virtualTableShapeId )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_code )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_function )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_managed )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_msil )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_virtualBaseDispIndex )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_undecoratedName )( 
            IDiaSymbol * This,
            /* [retval][out] */ BSTR *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_age )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_signature )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_compilerGenerated )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_addressTaken )( 
            IDiaSymbol * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_rank )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lowerBound )( 
            IDiaSymbol * This,
            /* [retval][out] */ IDiaSymbol **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_upperBound )( 
            IDiaSymbol * This,
            /* [retval][out] */ IDiaSymbol **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lowerBoundId )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_upperBoundId )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *get_dataBytes )( 
            IDiaSymbol * This,
            /* [in] */ DWORD cbData,
            /* [out] */ DWORD *pcbData,
            /* [length_is][size_is][out] */ BYTE data[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *findChildren )( 
            IDiaSymbol * This,
            /* [in] */ enum SymTagEnum symtag,
            /* [in] */ LPCOLESTR name,
            /* [in] */ DWORD compareFlags,
            /* [out] */ IDiaEnumSymbols **ppResult);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_targetSection )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_targetOffset )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_targetRelativeVirtualAddress )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_targetVirtualAddress )( 
            IDiaSymbol * This,
            /* [retval][out] */ ULONGLONG *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_machineType )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_oemId )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_oemSymbolId )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *get_types )( 
            IDiaSymbol * This,
            /* [in] */ DWORD cTypes,
            /* [out] */ DWORD *pcTypes,
            /* [length_is][size_is][out] */ IDiaSymbol *types[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *get_typeIds )( 
            IDiaSymbol * This,
            /* [in] */ DWORD cTypeIds,
            /* [out] */ DWORD *pcTypeIds,
            /* [length_is][size_is][out] */ DWORD typeIds[  ]);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_objectPointerType )( 
            IDiaSymbol * This,
            /* [retval][out] */ IDiaSymbol **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_udtKind )( 
            IDiaSymbol * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *get_undecoratedNameEx )( 
            IDiaSymbol * This,
            /* [in] */ DWORD undecorateOptions,
            /* [out] */ BSTR *name);
        
        END_INTERFACE
    } IDiaSymbolVtbl;

    interface IDiaSymbol
    {
        CONST_VTBL struct IDiaSymbolVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaSymbol_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaSymbol_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaSymbol_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaSymbol_get_symIndexId(This,pRetVal)	\
    (This)->lpVtbl -> get_symIndexId(This,pRetVal)

#define IDiaSymbol_get_symTag(This,pRetVal)	\
    (This)->lpVtbl -> get_symTag(This,pRetVal)

#define IDiaSymbol_get_name(This,pRetVal)	\
    (This)->lpVtbl -> get_name(This,pRetVal)

#define IDiaSymbol_get_lexicalParent(This,pRetVal)	\
    (This)->lpVtbl -> get_lexicalParent(This,pRetVal)

#define IDiaSymbol_get_classParent(This,pRetVal)	\
    (This)->lpVtbl -> get_classParent(This,pRetVal)

#define IDiaSymbol_get_type(This,pRetVal)	\
    (This)->lpVtbl -> get_type(This,pRetVal)

#define IDiaSymbol_get_dataKind(This,pRetVal)	\
    (This)->lpVtbl -> get_dataKind(This,pRetVal)

#define IDiaSymbol_get_locationType(This,pRetVal)	\
    (This)->lpVtbl -> get_locationType(This,pRetVal)

#define IDiaSymbol_get_addressSection(This,pRetVal)	\
    (This)->lpVtbl -> get_addressSection(This,pRetVal)

#define IDiaSymbol_get_addressOffset(This,pRetVal)	\
    (This)->lpVtbl -> get_addressOffset(This,pRetVal)

#define IDiaSymbol_get_relativeVirtualAddress(This,pRetVal)	\
    (This)->lpVtbl -> get_relativeVirtualAddress(This,pRetVal)

#define IDiaSymbol_get_virtualAddress(This,pRetVal)	\
    (This)->lpVtbl -> get_virtualAddress(This,pRetVal)

#define IDiaSymbol_get_registerId(This,pRetVal)	\
    (This)->lpVtbl -> get_registerId(This,pRetVal)

#define IDiaSymbol_get_offset(This,pRetVal)	\
    (This)->lpVtbl -> get_offset(This,pRetVal)

#define IDiaSymbol_get_length(This,pRetVal)	\
    (This)->lpVtbl -> get_length(This,pRetVal)

#define IDiaSymbol_get_slot(This,pRetVal)	\
    (This)->lpVtbl -> get_slot(This,pRetVal)

#define IDiaSymbol_get_volatileType(This,pRetVal)	\
    (This)->lpVtbl -> get_volatileType(This,pRetVal)

#define IDiaSymbol_get_constType(This,pRetVal)	\
    (This)->lpVtbl -> get_constType(This,pRetVal)

#define IDiaSymbol_get_unalignedType(This,pRetVal)	\
    (This)->lpVtbl -> get_unalignedType(This,pRetVal)

#define IDiaSymbol_get_access(This,pRetVal)	\
    (This)->lpVtbl -> get_access(This,pRetVal)

#define IDiaSymbol_get_libraryName(This,pRetVal)	\
    (This)->lpVtbl -> get_libraryName(This,pRetVal)

#define IDiaSymbol_get_platform(This,pRetVal)	\
    (This)->lpVtbl -> get_platform(This,pRetVal)

#define IDiaSymbol_get_language(This,pRetVal)	\
    (This)->lpVtbl -> get_language(This,pRetVal)

#define IDiaSymbol_get_editAndContinueEnabled(This,pRetVal)	\
    (This)->lpVtbl -> get_editAndContinueEnabled(This,pRetVal)

#define IDiaSymbol_get_frontEndMajor(This,pRetVal)	\
    (This)->lpVtbl -> get_frontEndMajor(This,pRetVal)

#define IDiaSymbol_get_frontEndMinor(This,pRetVal)	\
    (This)->lpVtbl -> get_frontEndMinor(This,pRetVal)

#define IDiaSymbol_get_frontEndBuild(This,pRetVal)	\
    (This)->lpVtbl -> get_frontEndBuild(This,pRetVal)

#define IDiaSymbol_get_backEndMajor(This,pRetVal)	\
    (This)->lpVtbl -> get_backEndMajor(This,pRetVal)

#define IDiaSymbol_get_backEndMinor(This,pRetVal)	\
    (This)->lpVtbl -> get_backEndMinor(This,pRetVal)

#define IDiaSymbol_get_backEndBuild(This,pRetVal)	\
    (This)->lpVtbl -> get_backEndBuild(This,pRetVal)

#define IDiaSymbol_get_sourceFileName(This,pRetVal)	\
    (This)->lpVtbl -> get_sourceFileName(This,pRetVal)

#define IDiaSymbol_get_unused(This,pRetVal)	\
    (This)->lpVtbl -> get_unused(This,pRetVal)

#define IDiaSymbol_get_thunkOrdinal(This,pRetVal)	\
    (This)->lpVtbl -> get_thunkOrdinal(This,pRetVal)

#define IDiaSymbol_get_thisAdjust(This,pRetVal)	\
    (This)->lpVtbl -> get_thisAdjust(This,pRetVal)

#define IDiaSymbol_get_virtualBaseOffset(This,pRetVal)	\
    (This)->lpVtbl -> get_virtualBaseOffset(This,pRetVal)

#define IDiaSymbol_get_virtual(This,pRetVal)	\
    (This)->lpVtbl -> get_virtual(This,pRetVal)

#define IDiaSymbol_get_intro(This,pRetVal)	\
    (This)->lpVtbl -> get_intro(This,pRetVal)

#define IDiaSymbol_get_pure(This,pRetVal)	\
    (This)->lpVtbl -> get_pure(This,pRetVal)

#define IDiaSymbol_get_callingConvention(This,pRetVal)	\
    (This)->lpVtbl -> get_callingConvention(This,pRetVal)

#define IDiaSymbol_get_value(This,pRetVal)	\
    (This)->lpVtbl -> get_value(This,pRetVal)

#define IDiaSymbol_get_baseType(This,pRetVal)	\
    (This)->lpVtbl -> get_baseType(This,pRetVal)

#define IDiaSymbol_get_token(This,pRetVal)	\
    (This)->lpVtbl -> get_token(This,pRetVal)

#define IDiaSymbol_get_timeStamp(This,pRetVal)	\
    (This)->lpVtbl -> get_timeStamp(This,pRetVal)

#define IDiaSymbol_get_guid(This,pRetVal)	\
    (This)->lpVtbl -> get_guid(This,pRetVal)

#define IDiaSymbol_get_symbolsFileName(This,pRetVal)	\
    (This)->lpVtbl -> get_symbolsFileName(This,pRetVal)

#define IDiaSymbol_get_reference(This,pRetVal)	\
    (This)->lpVtbl -> get_reference(This,pRetVal)

#define IDiaSymbol_get_count(This,pRetVal)	\
    (This)->lpVtbl -> get_count(This,pRetVal)

#define IDiaSymbol_get_bitPosition(This,pRetVal)	\
    (This)->lpVtbl -> get_bitPosition(This,pRetVal)

#define IDiaSymbol_get_arrayIndexType(This,pRetVal)	\
    (This)->lpVtbl -> get_arrayIndexType(This,pRetVal)

#define IDiaSymbol_get_packed(This,pRetVal)	\
    (This)->lpVtbl -> get_packed(This,pRetVal)

#define IDiaSymbol_get_constructor(This,pRetVal)	\
    (This)->lpVtbl -> get_constructor(This,pRetVal)

#define IDiaSymbol_get_overloadedOperator(This,pRetVal)	\
    (This)->lpVtbl -> get_overloadedOperator(This,pRetVal)

#define IDiaSymbol_get_nested(This,pRetVal)	\
    (This)->lpVtbl -> get_nested(This,pRetVal)

#define IDiaSymbol_get_hasNestedTypes(This,pRetVal)	\
    (This)->lpVtbl -> get_hasNestedTypes(This,pRetVal)

#define IDiaSymbol_get_hasAssignmentOperator(This,pRetVal)	\
    (This)->lpVtbl -> get_hasAssignmentOperator(This,pRetVal)

#define IDiaSymbol_get_hasCastOperator(This,pRetVal)	\
    (This)->lpVtbl -> get_hasCastOperator(This,pRetVal)

#define IDiaSymbol_get_scoped(This,pRetVal)	\
    (This)->lpVtbl -> get_scoped(This,pRetVal)

#define IDiaSymbol_get_virtualBaseClass(This,pRetVal)	\
    (This)->lpVtbl -> get_virtualBaseClass(This,pRetVal)

#define IDiaSymbol_get_indirectVirtualBaseClass(This,pRetVal)	\
    (This)->lpVtbl -> get_indirectVirtualBaseClass(This,pRetVal)

#define IDiaSymbol_get_virtualBasePointerOffset(This,pRetVal)	\
    (This)->lpVtbl -> get_virtualBasePointerOffset(This,pRetVal)

#define IDiaSymbol_get_virtualTableShape(This,pRetVal)	\
    (This)->lpVtbl -> get_virtualTableShape(This,pRetVal)

#define IDiaSymbol_get_lexicalParentId(This,pRetVal)	\
    (This)->lpVtbl -> get_lexicalParentId(This,pRetVal)

#define IDiaSymbol_get_classParentId(This,pRetVal)	\
    (This)->lpVtbl -> get_classParentId(This,pRetVal)

#define IDiaSymbol_get_typeId(This,pRetVal)	\
    (This)->lpVtbl -> get_typeId(This,pRetVal)

#define IDiaSymbol_get_arrayIndexTypeId(This,pRetVal)	\
    (This)->lpVtbl -> get_arrayIndexTypeId(This,pRetVal)

#define IDiaSymbol_get_virtualTableShapeId(This,pRetVal)	\
    (This)->lpVtbl -> get_virtualTableShapeId(This,pRetVal)

#define IDiaSymbol_get_code(This,pRetVal)	\
    (This)->lpVtbl -> get_code(This,pRetVal)

#define IDiaSymbol_get_function(This,pRetVal)	\
    (This)->lpVtbl -> get_function(This,pRetVal)

#define IDiaSymbol_get_managed(This,pRetVal)	\
    (This)->lpVtbl -> get_managed(This,pRetVal)

#define IDiaSymbol_get_msil(This,pRetVal)	\
    (This)->lpVtbl -> get_msil(This,pRetVal)

#define IDiaSymbol_get_virtualBaseDispIndex(This,pRetVal)	\
    (This)->lpVtbl -> get_virtualBaseDispIndex(This,pRetVal)

#define IDiaSymbol_get_undecoratedName(This,pRetVal)	\
    (This)->lpVtbl -> get_undecoratedName(This,pRetVal)

#define IDiaSymbol_get_age(This,pRetVal)	\
    (This)->lpVtbl -> get_age(This,pRetVal)

#define IDiaSymbol_get_signature(This,pRetVal)	\
    (This)->lpVtbl -> get_signature(This,pRetVal)

#define IDiaSymbol_get_compilerGenerated(This,pRetVal)	\
    (This)->lpVtbl -> get_compilerGenerated(This,pRetVal)

#define IDiaSymbol_get_addressTaken(This,pRetVal)	\
    (This)->lpVtbl -> get_addressTaken(This,pRetVal)

#define IDiaSymbol_get_rank(This,pRetVal)	\
    (This)->lpVtbl -> get_rank(This,pRetVal)

#define IDiaSymbol_get_lowerBound(This,pRetVal)	\
    (This)->lpVtbl -> get_lowerBound(This,pRetVal)

#define IDiaSymbol_get_upperBound(This,pRetVal)	\
    (This)->lpVtbl -> get_upperBound(This,pRetVal)

#define IDiaSymbol_get_lowerBoundId(This,pRetVal)	\
    (This)->lpVtbl -> get_lowerBoundId(This,pRetVal)

#define IDiaSymbol_get_upperBoundId(This,pRetVal)	\
    (This)->lpVtbl -> get_upperBoundId(This,pRetVal)

#define IDiaSymbol_get_dataBytes(This,cbData,pcbData,data)	\
    (This)->lpVtbl -> get_dataBytes(This,cbData,pcbData,data)

#define IDiaSymbol_findChildren(This,symtag,name,compareFlags,ppResult)	\
    (This)->lpVtbl -> findChildren(This,symtag,name,compareFlags,ppResult)

#define IDiaSymbol_get_targetSection(This,pRetVal)	\
    (This)->lpVtbl -> get_targetSection(This,pRetVal)

#define IDiaSymbol_get_targetOffset(This,pRetVal)	\
    (This)->lpVtbl -> get_targetOffset(This,pRetVal)

#define IDiaSymbol_get_targetRelativeVirtualAddress(This,pRetVal)	\
    (This)->lpVtbl -> get_targetRelativeVirtualAddress(This,pRetVal)

#define IDiaSymbol_get_targetVirtualAddress(This,pRetVal)	\
    (This)->lpVtbl -> get_targetVirtualAddress(This,pRetVal)

#define IDiaSymbol_get_machineType(This,pRetVal)	\
    (This)->lpVtbl -> get_machineType(This,pRetVal)

#define IDiaSymbol_get_oemId(This,pRetVal)	\
    (This)->lpVtbl -> get_oemId(This,pRetVal)

#define IDiaSymbol_get_oemSymbolId(This,pRetVal)	\
    (This)->lpVtbl -> get_oemSymbolId(This,pRetVal)

#define IDiaSymbol_get_types(This,cTypes,pcTypes,types)	\
    (This)->lpVtbl -> get_types(This,cTypes,pcTypes,types)

#define IDiaSymbol_get_typeIds(This,cTypeIds,pcTypeIds,typeIds)	\
    (This)->lpVtbl -> get_typeIds(This,cTypeIds,pcTypeIds,typeIds)

#define IDiaSymbol_get_objectPointerType(This,pRetVal)	\
    (This)->lpVtbl -> get_objectPointerType(This,pRetVal)

#define IDiaSymbol_get_udtKind(This,pRetVal)	\
    (This)->lpVtbl -> get_udtKind(This,pRetVal)

#define IDiaSymbol_get_undecoratedNameEx(This,undecorateOptions,name)	\
    (This)->lpVtbl -> get_undecoratedNameEx(This,undecorateOptions,name)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_symIndexId_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_symIndexId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_symTag_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_symTag_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_name_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BSTR *pRetVal);


void __RPC_STUB IDiaSymbol_get_name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_lexicalParent_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ IDiaSymbol **pRetVal);


void __RPC_STUB IDiaSymbol_get_lexicalParent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_classParent_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ IDiaSymbol **pRetVal);


void __RPC_STUB IDiaSymbol_get_classParent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_type_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ IDiaSymbol **pRetVal);


void __RPC_STUB IDiaSymbol_get_type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_dataKind_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_dataKind_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_locationType_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_locationType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_addressSection_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_addressSection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_addressOffset_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_addressOffset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_relativeVirtualAddress_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_relativeVirtualAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_virtualAddress_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ ULONGLONG *pRetVal);


void __RPC_STUB IDiaSymbol_get_virtualAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_registerId_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_registerId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_offset_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ LONG *pRetVal);


void __RPC_STUB IDiaSymbol_get_offset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_length_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ ULONGLONG *pRetVal);


void __RPC_STUB IDiaSymbol_get_length_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_slot_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_slot_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_volatileType_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_volatileType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_constType_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_constType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_unalignedType_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_unalignedType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_access_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_access_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_libraryName_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BSTR *pRetVal);


void __RPC_STUB IDiaSymbol_get_libraryName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_platform_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_platform_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_language_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_language_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_editAndContinueEnabled_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_editAndContinueEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_frontEndMajor_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_frontEndMajor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_frontEndMinor_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_frontEndMinor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_frontEndBuild_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_frontEndBuild_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_backEndMajor_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_backEndMajor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_backEndMinor_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_backEndMinor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_backEndBuild_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_backEndBuild_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_sourceFileName_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BSTR *pRetVal);


void __RPC_STUB IDiaSymbol_get_sourceFileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_unused_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BSTR *pRetVal);


void __RPC_STUB IDiaSymbol_get_unused_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_thunkOrdinal_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_thunkOrdinal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_thisAdjust_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ LONG *pRetVal);


void __RPC_STUB IDiaSymbol_get_thisAdjust_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_virtualBaseOffset_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_virtualBaseOffset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_virtual_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_virtual_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_intro_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_intro_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_pure_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_pure_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_callingConvention_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_callingConvention_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_value_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ VARIANT *pRetVal);


void __RPC_STUB IDiaSymbol_get_value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_baseType_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_baseType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_token_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_token_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_timeStamp_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_timeStamp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_guid_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ GUID *pRetVal);


void __RPC_STUB IDiaSymbol_get_guid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_symbolsFileName_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BSTR *pRetVal);


void __RPC_STUB IDiaSymbol_get_symbolsFileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_reference_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_reference_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_count_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_bitPosition_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_bitPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_arrayIndexType_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ IDiaSymbol **pRetVal);


void __RPC_STUB IDiaSymbol_get_arrayIndexType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_packed_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_packed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_constructor_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_constructor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_overloadedOperator_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_overloadedOperator_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_nested_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_nested_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_hasNestedTypes_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_hasNestedTypes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_hasAssignmentOperator_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_hasAssignmentOperator_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_hasCastOperator_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_hasCastOperator_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_scoped_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_scoped_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_virtualBaseClass_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_virtualBaseClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_indirectVirtualBaseClass_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_indirectVirtualBaseClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_virtualBasePointerOffset_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ LONG *pRetVal);


void __RPC_STUB IDiaSymbol_get_virtualBasePointerOffset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_virtualTableShape_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ IDiaSymbol **pRetVal);


void __RPC_STUB IDiaSymbol_get_virtualTableShape_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_lexicalParentId_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_lexicalParentId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_classParentId_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_classParentId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_typeId_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_typeId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_arrayIndexTypeId_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_arrayIndexTypeId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_virtualTableShapeId_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_virtualTableShapeId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_code_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_code_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_function_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_function_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_managed_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_managed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_msil_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_msil_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_virtualBaseDispIndex_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_virtualBaseDispIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_undecoratedName_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BSTR *pRetVal);


void __RPC_STUB IDiaSymbol_get_undecoratedName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_age_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_age_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_signature_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_signature_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_compilerGenerated_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_compilerGenerated_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_addressTaken_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSymbol_get_addressTaken_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_rank_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_rank_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_lowerBound_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ IDiaSymbol **pRetVal);


void __RPC_STUB IDiaSymbol_get_lowerBound_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_upperBound_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ IDiaSymbol **pRetVal);


void __RPC_STUB IDiaSymbol_get_upperBound_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_lowerBoundId_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_lowerBoundId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_upperBoundId_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_upperBoundId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSymbol_get_dataBytes_Proxy( 
    IDiaSymbol * This,
    /* [in] */ DWORD cbData,
    /* [out] */ DWORD *pcbData,
    /* [length_is][size_is][out] */ BYTE data[  ]);


void __RPC_STUB IDiaSymbol_get_dataBytes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSymbol_findChildren_Proxy( 
    IDiaSymbol * This,
    /* [in] */ enum SymTagEnum symtag,
    /* [in] */ LPCOLESTR name,
    /* [in] */ DWORD compareFlags,
    /* [out] */ IDiaEnumSymbols **ppResult);


void __RPC_STUB IDiaSymbol_findChildren_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_targetSection_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_targetSection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_targetOffset_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_targetOffset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_targetRelativeVirtualAddress_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_targetRelativeVirtualAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_targetVirtualAddress_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ ULONGLONG *pRetVal);


void __RPC_STUB IDiaSymbol_get_targetVirtualAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_machineType_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_machineType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_oemId_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_oemId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_oemSymbolId_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_oemSymbolId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSymbol_get_types_Proxy( 
    IDiaSymbol * This,
    /* [in] */ DWORD cTypes,
    /* [out] */ DWORD *pcTypes,
    /* [length_is][size_is][out] */ IDiaSymbol *types[  ]);


void __RPC_STUB IDiaSymbol_get_types_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSymbol_get_typeIds_Proxy( 
    IDiaSymbol * This,
    /* [in] */ DWORD cTypeIds,
    /* [out] */ DWORD *pcTypeIds,
    /* [length_is][size_is][out] */ DWORD typeIds[  ]);


void __RPC_STUB IDiaSymbol_get_typeIds_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_objectPointerType_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ IDiaSymbol **pRetVal);


void __RPC_STUB IDiaSymbol_get_objectPointerType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSymbol_get_udtKind_Proxy( 
    IDiaSymbol * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSymbol_get_udtKind_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSymbol_get_undecoratedNameEx_Proxy( 
    IDiaSymbol * This,
    /* [in] */ DWORD undecorateOptions,
    /* [out] */ BSTR *name);


void __RPC_STUB IDiaSymbol_get_undecoratedNameEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaSymbol_INTERFACE_DEFINED__ */


#ifndef __IDiaSourceFile_INTERFACE_DEFINED__
#define __IDiaSourceFile_INTERFACE_DEFINED__

/* interface IDiaSourceFile */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaSourceFile;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A2EF5353-F5A8-4eb3-90D2-CB526ACB3CDD")
    IDiaSourceFile : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_uniqueId( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_fileName( 
            /* [retval][out] */ BSTR *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_checksumType( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_compilands( 
            /* [retval][out] */ IDiaEnumSymbols **pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_checksum( 
            /* [in] */ DWORD cbData,
            /* [out] */ DWORD *pcbData,
            /* [length_is][size_is][out] */ BYTE data[  ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaSourceFileVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaSourceFile * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaSourceFile * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaSourceFile * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_uniqueId )( 
            IDiaSourceFile * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_fileName )( 
            IDiaSourceFile * This,
            /* [retval][out] */ BSTR *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_checksumType )( 
            IDiaSourceFile * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_compilands )( 
            IDiaSourceFile * This,
            /* [retval][out] */ IDiaEnumSymbols **pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *get_checksum )( 
            IDiaSourceFile * This,
            /* [in] */ DWORD cbData,
            /* [out] */ DWORD *pcbData,
            /* [length_is][size_is][out] */ BYTE data[  ]);
        
        END_INTERFACE
    } IDiaSourceFileVtbl;

    interface IDiaSourceFile
    {
        CONST_VTBL struct IDiaSourceFileVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaSourceFile_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaSourceFile_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaSourceFile_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaSourceFile_get_uniqueId(This,pRetVal)	\
    (This)->lpVtbl -> get_uniqueId(This,pRetVal)

#define IDiaSourceFile_get_fileName(This,pRetVal)	\
    (This)->lpVtbl -> get_fileName(This,pRetVal)

#define IDiaSourceFile_get_checksumType(This,pRetVal)	\
    (This)->lpVtbl -> get_checksumType(This,pRetVal)

#define IDiaSourceFile_get_compilands(This,pRetVal)	\
    (This)->lpVtbl -> get_compilands(This,pRetVal)

#define IDiaSourceFile_get_checksum(This,cbData,pcbData,data)	\
    (This)->lpVtbl -> get_checksum(This,cbData,pcbData,data)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSourceFile_get_uniqueId_Proxy( 
    IDiaSourceFile * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSourceFile_get_uniqueId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSourceFile_get_fileName_Proxy( 
    IDiaSourceFile * This,
    /* [retval][out] */ BSTR *pRetVal);


void __RPC_STUB IDiaSourceFile_get_fileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSourceFile_get_checksumType_Proxy( 
    IDiaSourceFile * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSourceFile_get_checksumType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSourceFile_get_compilands_Proxy( 
    IDiaSourceFile * This,
    /* [retval][out] */ IDiaEnumSymbols **pRetVal);


void __RPC_STUB IDiaSourceFile_get_compilands_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaSourceFile_get_checksum_Proxy( 
    IDiaSourceFile * This,
    /* [in] */ DWORD cbData,
    /* [out] */ DWORD *pcbData,
    /* [length_is][size_is][out] */ BYTE data[  ]);


void __RPC_STUB IDiaSourceFile_get_checksum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaSourceFile_INTERFACE_DEFINED__ */


#ifndef __IDiaLineNumber_INTERFACE_DEFINED__
#define __IDiaLineNumber_INTERFACE_DEFINED__

/* interface IDiaLineNumber */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaLineNumber;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B388EB14-BE4D-421d-A8A1-6CF7AB057086")
    IDiaLineNumber : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_compiland( 
            /* [retval][out] */ IDiaSymbol **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_sourceFile( 
            /* [retval][out] */ IDiaSourceFile **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_lineNumber( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_lineNumberEnd( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_columnNumber( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_columnNumberEnd( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_addressSection( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_addressOffset( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_relativeVirtualAddress( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_virtualAddress( 
            /* [retval][out] */ ULONGLONG *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_length( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_sourceFileId( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_statement( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_compilandId( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaLineNumberVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaLineNumber * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaLineNumber * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaLineNumber * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_compiland )( 
            IDiaLineNumber * This,
            /* [retval][out] */ IDiaSymbol **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_sourceFile )( 
            IDiaLineNumber * This,
            /* [retval][out] */ IDiaSourceFile **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lineNumber )( 
            IDiaLineNumber * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lineNumberEnd )( 
            IDiaLineNumber * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_columnNumber )( 
            IDiaLineNumber * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_columnNumberEnd )( 
            IDiaLineNumber * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_addressSection )( 
            IDiaLineNumber * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_addressOffset )( 
            IDiaLineNumber * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_relativeVirtualAddress )( 
            IDiaLineNumber * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_virtualAddress )( 
            IDiaLineNumber * This,
            /* [retval][out] */ ULONGLONG *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_length )( 
            IDiaLineNumber * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_sourceFileId )( 
            IDiaLineNumber * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_statement )( 
            IDiaLineNumber * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_compilandId )( 
            IDiaLineNumber * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        END_INTERFACE
    } IDiaLineNumberVtbl;

    interface IDiaLineNumber
    {
        CONST_VTBL struct IDiaLineNumberVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaLineNumber_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaLineNumber_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaLineNumber_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaLineNumber_get_compiland(This,pRetVal)	\
    (This)->lpVtbl -> get_compiland(This,pRetVal)

#define IDiaLineNumber_get_sourceFile(This,pRetVal)	\
    (This)->lpVtbl -> get_sourceFile(This,pRetVal)

#define IDiaLineNumber_get_lineNumber(This,pRetVal)	\
    (This)->lpVtbl -> get_lineNumber(This,pRetVal)

#define IDiaLineNumber_get_lineNumberEnd(This,pRetVal)	\
    (This)->lpVtbl -> get_lineNumberEnd(This,pRetVal)

#define IDiaLineNumber_get_columnNumber(This,pRetVal)	\
    (This)->lpVtbl -> get_columnNumber(This,pRetVal)

#define IDiaLineNumber_get_columnNumberEnd(This,pRetVal)	\
    (This)->lpVtbl -> get_columnNumberEnd(This,pRetVal)

#define IDiaLineNumber_get_addressSection(This,pRetVal)	\
    (This)->lpVtbl -> get_addressSection(This,pRetVal)

#define IDiaLineNumber_get_addressOffset(This,pRetVal)	\
    (This)->lpVtbl -> get_addressOffset(This,pRetVal)

#define IDiaLineNumber_get_relativeVirtualAddress(This,pRetVal)	\
    (This)->lpVtbl -> get_relativeVirtualAddress(This,pRetVal)

#define IDiaLineNumber_get_virtualAddress(This,pRetVal)	\
    (This)->lpVtbl -> get_virtualAddress(This,pRetVal)

#define IDiaLineNumber_get_length(This,pRetVal)	\
    (This)->lpVtbl -> get_length(This,pRetVal)

#define IDiaLineNumber_get_sourceFileId(This,pRetVal)	\
    (This)->lpVtbl -> get_sourceFileId(This,pRetVal)

#define IDiaLineNumber_get_statement(This,pRetVal)	\
    (This)->lpVtbl -> get_statement(This,pRetVal)

#define IDiaLineNumber_get_compilandId(This,pRetVal)	\
    (This)->lpVtbl -> get_compilandId(This,pRetVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaLineNumber_get_compiland_Proxy( 
    IDiaLineNumber * This,
    /* [retval][out] */ IDiaSymbol **pRetVal);


void __RPC_STUB IDiaLineNumber_get_compiland_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaLineNumber_get_sourceFile_Proxy( 
    IDiaLineNumber * This,
    /* [retval][out] */ IDiaSourceFile **pRetVal);


void __RPC_STUB IDiaLineNumber_get_sourceFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaLineNumber_get_lineNumber_Proxy( 
    IDiaLineNumber * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaLineNumber_get_lineNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaLineNumber_get_lineNumberEnd_Proxy( 
    IDiaLineNumber * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaLineNumber_get_lineNumberEnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaLineNumber_get_columnNumber_Proxy( 
    IDiaLineNumber * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaLineNumber_get_columnNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaLineNumber_get_columnNumberEnd_Proxy( 
    IDiaLineNumber * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaLineNumber_get_columnNumberEnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaLineNumber_get_addressSection_Proxy( 
    IDiaLineNumber * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaLineNumber_get_addressSection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaLineNumber_get_addressOffset_Proxy( 
    IDiaLineNumber * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaLineNumber_get_addressOffset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaLineNumber_get_relativeVirtualAddress_Proxy( 
    IDiaLineNumber * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaLineNumber_get_relativeVirtualAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaLineNumber_get_virtualAddress_Proxy( 
    IDiaLineNumber * This,
    /* [retval][out] */ ULONGLONG *pRetVal);


void __RPC_STUB IDiaLineNumber_get_virtualAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaLineNumber_get_length_Proxy( 
    IDiaLineNumber * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaLineNumber_get_length_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaLineNumber_get_sourceFileId_Proxy( 
    IDiaLineNumber * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaLineNumber_get_sourceFileId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaLineNumber_get_statement_Proxy( 
    IDiaLineNumber * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaLineNumber_get_statement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaLineNumber_get_compilandId_Proxy( 
    IDiaLineNumber * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaLineNumber_get_compilandId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaLineNumber_INTERFACE_DEFINED__ */


#ifndef __IDiaSectionContrib_INTERFACE_DEFINED__
#define __IDiaSectionContrib_INTERFACE_DEFINED__

/* interface IDiaSectionContrib */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaSectionContrib;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0CF4B60E-35B1-4c6c-BDD8-854B9C8E3857")
    IDiaSectionContrib : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_compiland( 
            /* [retval][out] */ IDiaSymbol **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_addressSection( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_addressOffset( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_relativeVirtualAddress( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_virtualAddress( 
            /* [retval][out] */ ULONGLONG *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_length( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_notPaged( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_code( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_initializedData( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_uninitializedData( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_remove( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_comdat( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_discardable( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_notCached( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_share( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_execute( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_read( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_write( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_dataCrc( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_relocationsCrc( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_compilandId( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaSectionContribVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaSectionContrib * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaSectionContrib * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaSectionContrib * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_compiland )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ IDiaSymbol **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_addressSection )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_addressOffset )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_relativeVirtualAddress )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_virtualAddress )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ ULONGLONG *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_length )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_notPaged )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_code )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_initializedData )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_uninitializedData )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_remove )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_comdat )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_discardable )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_notCached )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_share )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_execute )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_read )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_write )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_dataCrc )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_relocationsCrc )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_compilandId )( 
            IDiaSectionContrib * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        END_INTERFACE
    } IDiaSectionContribVtbl;

    interface IDiaSectionContrib
    {
        CONST_VTBL struct IDiaSectionContribVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaSectionContrib_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaSectionContrib_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaSectionContrib_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaSectionContrib_get_compiland(This,pRetVal)	\
    (This)->lpVtbl -> get_compiland(This,pRetVal)

#define IDiaSectionContrib_get_addressSection(This,pRetVal)	\
    (This)->lpVtbl -> get_addressSection(This,pRetVal)

#define IDiaSectionContrib_get_addressOffset(This,pRetVal)	\
    (This)->lpVtbl -> get_addressOffset(This,pRetVal)

#define IDiaSectionContrib_get_relativeVirtualAddress(This,pRetVal)	\
    (This)->lpVtbl -> get_relativeVirtualAddress(This,pRetVal)

#define IDiaSectionContrib_get_virtualAddress(This,pRetVal)	\
    (This)->lpVtbl -> get_virtualAddress(This,pRetVal)

#define IDiaSectionContrib_get_length(This,pRetVal)	\
    (This)->lpVtbl -> get_length(This,pRetVal)

#define IDiaSectionContrib_get_notPaged(This,pRetVal)	\
    (This)->lpVtbl -> get_notPaged(This,pRetVal)

#define IDiaSectionContrib_get_code(This,pRetVal)	\
    (This)->lpVtbl -> get_code(This,pRetVal)

#define IDiaSectionContrib_get_initializedData(This,pRetVal)	\
    (This)->lpVtbl -> get_initializedData(This,pRetVal)

#define IDiaSectionContrib_get_uninitializedData(This,pRetVal)	\
    (This)->lpVtbl -> get_uninitializedData(This,pRetVal)

#define IDiaSectionContrib_get_remove(This,pRetVal)	\
    (This)->lpVtbl -> get_remove(This,pRetVal)

#define IDiaSectionContrib_get_comdat(This,pRetVal)	\
    (This)->lpVtbl -> get_comdat(This,pRetVal)

#define IDiaSectionContrib_get_discardable(This,pRetVal)	\
    (This)->lpVtbl -> get_discardable(This,pRetVal)

#define IDiaSectionContrib_get_notCached(This,pRetVal)	\
    (This)->lpVtbl -> get_notCached(This,pRetVal)

#define IDiaSectionContrib_get_share(This,pRetVal)	\
    (This)->lpVtbl -> get_share(This,pRetVal)

#define IDiaSectionContrib_get_execute(This,pRetVal)	\
    (This)->lpVtbl -> get_execute(This,pRetVal)

#define IDiaSectionContrib_get_read(This,pRetVal)	\
    (This)->lpVtbl -> get_read(This,pRetVal)

#define IDiaSectionContrib_get_write(This,pRetVal)	\
    (This)->lpVtbl -> get_write(This,pRetVal)

#define IDiaSectionContrib_get_dataCrc(This,pRetVal)	\
    (This)->lpVtbl -> get_dataCrc(This,pRetVal)

#define IDiaSectionContrib_get_relocationsCrc(This,pRetVal)	\
    (This)->lpVtbl -> get_relocationsCrc(This,pRetVal)

#define IDiaSectionContrib_get_compilandId(This,pRetVal)	\
    (This)->lpVtbl -> get_compilandId(This,pRetVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_compiland_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ IDiaSymbol **pRetVal);


void __RPC_STUB IDiaSectionContrib_get_compiland_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_addressSection_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSectionContrib_get_addressSection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_addressOffset_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSectionContrib_get_addressOffset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_relativeVirtualAddress_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSectionContrib_get_relativeVirtualAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_virtualAddress_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ ULONGLONG *pRetVal);


void __RPC_STUB IDiaSectionContrib_get_virtualAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_length_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSectionContrib_get_length_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_notPaged_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSectionContrib_get_notPaged_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_code_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSectionContrib_get_code_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_initializedData_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSectionContrib_get_initializedData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_uninitializedData_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSectionContrib_get_uninitializedData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_remove_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSectionContrib_get_remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_comdat_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSectionContrib_get_comdat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_discardable_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSectionContrib_get_discardable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_notCached_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSectionContrib_get_notCached_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_share_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSectionContrib_get_share_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_execute_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSectionContrib_get_execute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_read_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSectionContrib_get_read_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_write_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSectionContrib_get_write_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_dataCrc_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSectionContrib_get_dataCrc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_relocationsCrc_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSectionContrib_get_relocationsCrc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSectionContrib_get_compilandId_Proxy( 
    IDiaSectionContrib * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSectionContrib_get_compilandId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaSectionContrib_INTERFACE_DEFINED__ */


#ifndef __IDiaSegment_INTERFACE_DEFINED__
#define __IDiaSegment_INTERFACE_DEFINED__

/* interface IDiaSegment */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaSegment;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0775B784-C75B-4449-848B-B7BD3159545B")
    IDiaSegment : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_frame( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_offset( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_length( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_read( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_write( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_execute( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_addressSection( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_relativeVirtualAddress( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_virtualAddress( 
            /* [retval][out] */ ULONGLONG *pRetVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaSegmentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaSegment * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaSegment * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaSegment * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_frame )( 
            IDiaSegment * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_offset )( 
            IDiaSegment * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_length )( 
            IDiaSegment * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_read )( 
            IDiaSegment * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_write )( 
            IDiaSegment * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_execute )( 
            IDiaSegment * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_addressSection )( 
            IDiaSegment * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_relativeVirtualAddress )( 
            IDiaSegment * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_virtualAddress )( 
            IDiaSegment * This,
            /* [retval][out] */ ULONGLONG *pRetVal);
        
        END_INTERFACE
    } IDiaSegmentVtbl;

    interface IDiaSegment
    {
        CONST_VTBL struct IDiaSegmentVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaSegment_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaSegment_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaSegment_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaSegment_get_frame(This,pRetVal)	\
    (This)->lpVtbl -> get_frame(This,pRetVal)

#define IDiaSegment_get_offset(This,pRetVal)	\
    (This)->lpVtbl -> get_offset(This,pRetVal)

#define IDiaSegment_get_length(This,pRetVal)	\
    (This)->lpVtbl -> get_length(This,pRetVal)

#define IDiaSegment_get_read(This,pRetVal)	\
    (This)->lpVtbl -> get_read(This,pRetVal)

#define IDiaSegment_get_write(This,pRetVal)	\
    (This)->lpVtbl -> get_write(This,pRetVal)

#define IDiaSegment_get_execute(This,pRetVal)	\
    (This)->lpVtbl -> get_execute(This,pRetVal)

#define IDiaSegment_get_addressSection(This,pRetVal)	\
    (This)->lpVtbl -> get_addressSection(This,pRetVal)

#define IDiaSegment_get_relativeVirtualAddress(This,pRetVal)	\
    (This)->lpVtbl -> get_relativeVirtualAddress(This,pRetVal)

#define IDiaSegment_get_virtualAddress(This,pRetVal)	\
    (This)->lpVtbl -> get_virtualAddress(This,pRetVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSegment_get_frame_Proxy( 
    IDiaSegment * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSegment_get_frame_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSegment_get_offset_Proxy( 
    IDiaSegment * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSegment_get_offset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSegment_get_length_Proxy( 
    IDiaSegment * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSegment_get_length_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSegment_get_read_Proxy( 
    IDiaSegment * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSegment_get_read_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSegment_get_write_Proxy( 
    IDiaSegment * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSegment_get_write_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSegment_get_execute_Proxy( 
    IDiaSegment * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaSegment_get_execute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSegment_get_addressSection_Proxy( 
    IDiaSegment * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSegment_get_addressSection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSegment_get_relativeVirtualAddress_Proxy( 
    IDiaSegment * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaSegment_get_relativeVirtualAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaSegment_get_virtualAddress_Proxy( 
    IDiaSegment * This,
    /* [retval][out] */ ULONGLONG *pRetVal);


void __RPC_STUB IDiaSegment_get_virtualAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaSegment_INTERFACE_DEFINED__ */


#ifndef __IDiaInjectedSource_INTERFACE_DEFINED__
#define __IDiaInjectedSource_INTERFACE_DEFINED__

/* interface IDiaInjectedSource */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaInjectedSource;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AE605CDC-8105-4a23-B710-3259F1E26112")
    IDiaInjectedSource : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_crc( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_length( 
            /* [retval][out] */ ULONGLONG *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_filename( 
            /* [retval][out] */ BSTR *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_objectFilename( 
            /* [retval][out] */ BSTR *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_virtualFilename( 
            /* [retval][out] */ BSTR *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_sourceCompression( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_source( 
            /* [in] */ DWORD cbData,
            /* [out] */ DWORD *pcbData,
            /* [length_is][size_is][out] */ BYTE data[  ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaInjectedSourceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaInjectedSource * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaInjectedSource * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaInjectedSource * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_crc )( 
            IDiaInjectedSource * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_length )( 
            IDiaInjectedSource * This,
            /* [retval][out] */ ULONGLONG *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_filename )( 
            IDiaInjectedSource * This,
            /* [retval][out] */ BSTR *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_objectFilename )( 
            IDiaInjectedSource * This,
            /* [retval][out] */ BSTR *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_virtualFilename )( 
            IDiaInjectedSource * This,
            /* [retval][out] */ BSTR *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_sourceCompression )( 
            IDiaInjectedSource * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *get_source )( 
            IDiaInjectedSource * This,
            /* [in] */ DWORD cbData,
            /* [out] */ DWORD *pcbData,
            /* [length_is][size_is][out] */ BYTE data[  ]);
        
        END_INTERFACE
    } IDiaInjectedSourceVtbl;

    interface IDiaInjectedSource
    {
        CONST_VTBL struct IDiaInjectedSourceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaInjectedSource_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaInjectedSource_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaInjectedSource_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaInjectedSource_get_crc(This,pRetVal)	\
    (This)->lpVtbl -> get_crc(This,pRetVal)

#define IDiaInjectedSource_get_length(This,pRetVal)	\
    (This)->lpVtbl -> get_length(This,pRetVal)

#define IDiaInjectedSource_get_filename(This,pRetVal)	\
    (This)->lpVtbl -> get_filename(This,pRetVal)

#define IDiaInjectedSource_get_objectFilename(This,pRetVal)	\
    (This)->lpVtbl -> get_objectFilename(This,pRetVal)

#define IDiaInjectedSource_get_virtualFilename(This,pRetVal)	\
    (This)->lpVtbl -> get_virtualFilename(This,pRetVal)

#define IDiaInjectedSource_get_sourceCompression(This,pRetVal)	\
    (This)->lpVtbl -> get_sourceCompression(This,pRetVal)

#define IDiaInjectedSource_get_source(This,cbData,pcbData,data)	\
    (This)->lpVtbl -> get_source(This,cbData,pcbData,data)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaInjectedSource_get_crc_Proxy( 
    IDiaInjectedSource * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaInjectedSource_get_crc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaInjectedSource_get_length_Proxy( 
    IDiaInjectedSource * This,
    /* [retval][out] */ ULONGLONG *pRetVal);


void __RPC_STUB IDiaInjectedSource_get_length_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaInjectedSource_get_filename_Proxy( 
    IDiaInjectedSource * This,
    /* [retval][out] */ BSTR *pRetVal);


void __RPC_STUB IDiaInjectedSource_get_filename_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaInjectedSource_get_objectFilename_Proxy( 
    IDiaInjectedSource * This,
    /* [retval][out] */ BSTR *pRetVal);


void __RPC_STUB IDiaInjectedSource_get_objectFilename_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaInjectedSource_get_virtualFilename_Proxy( 
    IDiaInjectedSource * This,
    /* [retval][out] */ BSTR *pRetVal);


void __RPC_STUB IDiaInjectedSource_get_virtualFilename_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaInjectedSource_get_sourceCompression_Proxy( 
    IDiaInjectedSource * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaInjectedSource_get_sourceCompression_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaInjectedSource_get_source_Proxy( 
    IDiaInjectedSource * This,
    /* [in] */ DWORD cbData,
    /* [out] */ DWORD *pcbData,
    /* [length_is][size_is][out] */ BYTE data[  ]);


void __RPC_STUB IDiaInjectedSource_get_source_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaInjectedSource_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dia2_internal_0146 */
/* [local] */ 


enum __MIDL___MIDL_itf_dia2_internal_0146_0001
    {	E_DIA_INPROLOG	= ( HRESULT  )(( unsigned long  )1 << 31 | ( unsigned long  )( LONG  )0x6d << 16 | ( unsigned long  )100),
	E_DIA_SYNTAX	= E_DIA_INPROLOG + 1,
	E_DIA_FRAME_ACCESS	= E_DIA_SYNTAX + 1,
	E_DIA_VALUE	= E_DIA_FRAME_ACCESS + 1
    } ;


extern RPC_IF_HANDLE __MIDL_itf_dia2_internal_0146_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dia2_internal_0146_v0_0_s_ifspec;

#ifndef __IDiaStackWalkFrame_INTERFACE_DEFINED__
#define __IDiaStackWalkFrame_INTERFACE_DEFINED__

/* interface IDiaStackWalkFrame */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaStackWalkFrame;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("97F0F1A6-E04E-4ea4-B4F9-B0D0E8D90F5D")
    IDiaStackWalkFrame : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_registerValue( 
            /* [in] */ DWORD index,
            /* [retval][out] */ ULONGLONG *pRetVal) = 0;
        
        virtual /* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_registerValue( 
            /* [in] */ DWORD index,
            /* [in] */ ULONGLONG NewVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE readMemory( 
            /* [in] */ ULONGLONG va,
            /* [in] */ DWORD cbData,
            /* [out] */ DWORD *pcbData,
            /* [length_is][size_is][out] */ BYTE data[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE searchForReturnAddress( 
            /* [in] */ IDiaFrameData *frame,
            /* [out] */ ULONGLONG *returnAddress) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE searchForReturnAddressStart( 
            /* [in] */ IDiaFrameData *frame,
            /* [in] */ ULONGLONG startAddress,
            /* [out] */ ULONGLONG *returnAddress) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaStackWalkFrameVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaStackWalkFrame * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaStackWalkFrame * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaStackWalkFrame * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_registerValue )( 
            IDiaStackWalkFrame * This,
            /* [in] */ DWORD index,
            /* [retval][out] */ ULONGLONG *pRetVal);
        
        /* [id][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_registerValue )( 
            IDiaStackWalkFrame * This,
            /* [in] */ DWORD index,
            /* [in] */ ULONGLONG NewVal);
        
        HRESULT ( STDMETHODCALLTYPE *readMemory )( 
            IDiaStackWalkFrame * This,
            /* [in] */ ULONGLONG va,
            /* [in] */ DWORD cbData,
            /* [out] */ DWORD *pcbData,
            /* [length_is][size_is][out] */ BYTE data[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *searchForReturnAddress )( 
            IDiaStackWalkFrame * This,
            /* [in] */ IDiaFrameData *frame,
            /* [out] */ ULONGLONG *returnAddress);
        
        HRESULT ( STDMETHODCALLTYPE *searchForReturnAddressStart )( 
            IDiaStackWalkFrame * This,
            /* [in] */ IDiaFrameData *frame,
            /* [in] */ ULONGLONG startAddress,
            /* [out] */ ULONGLONG *returnAddress);
        
        END_INTERFACE
    } IDiaStackWalkFrameVtbl;

    interface IDiaStackWalkFrame
    {
        CONST_VTBL struct IDiaStackWalkFrameVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaStackWalkFrame_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaStackWalkFrame_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaStackWalkFrame_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaStackWalkFrame_get_registerValue(This,index,pRetVal)	\
    (This)->lpVtbl -> get_registerValue(This,index,pRetVal)

#define IDiaStackWalkFrame_put_registerValue(This,index,NewVal)	\
    (This)->lpVtbl -> put_registerValue(This,index,NewVal)

#define IDiaStackWalkFrame_readMemory(This,va,cbData,pcbData,data)	\
    (This)->lpVtbl -> readMemory(This,va,cbData,pcbData,data)

#define IDiaStackWalkFrame_searchForReturnAddress(This,frame,returnAddress)	\
    (This)->lpVtbl -> searchForReturnAddress(This,frame,returnAddress)

#define IDiaStackWalkFrame_searchForReturnAddressStart(This,frame,startAddress,returnAddress)	\
    (This)->lpVtbl -> searchForReturnAddressStart(This,frame,startAddress,returnAddress)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaStackWalkFrame_get_registerValue_Proxy( 
    IDiaStackWalkFrame * This,
    /* [in] */ DWORD index,
    /* [retval][out] */ ULONGLONG *pRetVal);


void __RPC_STUB IDiaStackWalkFrame_get_registerValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE IDiaStackWalkFrame_put_registerValue_Proxy( 
    IDiaStackWalkFrame * This,
    /* [in] */ DWORD index,
    /* [in] */ ULONGLONG NewVal);


void __RPC_STUB IDiaStackWalkFrame_put_registerValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaStackWalkFrame_readMemory_Proxy( 
    IDiaStackWalkFrame * This,
    /* [in] */ ULONGLONG va,
    /* [in] */ DWORD cbData,
    /* [out] */ DWORD *pcbData,
    /* [length_is][size_is][out] */ BYTE data[  ]);


void __RPC_STUB IDiaStackWalkFrame_readMemory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaStackWalkFrame_searchForReturnAddress_Proxy( 
    IDiaStackWalkFrame * This,
    /* [in] */ IDiaFrameData *frame,
    /* [out] */ ULONGLONG *returnAddress);


void __RPC_STUB IDiaStackWalkFrame_searchForReturnAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaStackWalkFrame_searchForReturnAddressStart_Proxy( 
    IDiaStackWalkFrame * This,
    /* [in] */ IDiaFrameData *frame,
    /* [in] */ ULONGLONG startAddress,
    /* [out] */ ULONGLONG *returnAddress);


void __RPC_STUB IDiaStackWalkFrame_searchForReturnAddressStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaStackWalkFrame_INTERFACE_DEFINED__ */


#ifndef __IDiaFrameData_INTERFACE_DEFINED__
#define __IDiaFrameData_INTERFACE_DEFINED__

/* interface IDiaFrameData */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaFrameData;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A39184B7-6A36-42de-8EEC-7DF9F3F59F33")
    IDiaFrameData : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_addressSection( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_addressOffset( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_relativeVirtualAddress( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_virtualAddress( 
            /* [retval][out] */ ULONGLONG *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_lengthBlock( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_lengthLocals( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_lengthParams( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_maxStack( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_lengthProlog( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_lengthSavedRegisters( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_program( 
            /* [retval][out] */ BSTR *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_systemExceptionHandling( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_cplusplusExceptionHandling( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_functionStart( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_allocatesBasePointer( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_type( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_functionParent( 
            /* [retval][out] */ IDiaFrameData **pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE execute( 
            IDiaStackWalkFrame *frame) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaFrameDataVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaFrameData * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaFrameData * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaFrameData * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_addressSection )( 
            IDiaFrameData * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_addressOffset )( 
            IDiaFrameData * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_relativeVirtualAddress )( 
            IDiaFrameData * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_virtualAddress )( 
            IDiaFrameData * This,
            /* [retval][out] */ ULONGLONG *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lengthBlock )( 
            IDiaFrameData * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lengthLocals )( 
            IDiaFrameData * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lengthParams )( 
            IDiaFrameData * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_maxStack )( 
            IDiaFrameData * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lengthProlog )( 
            IDiaFrameData * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lengthSavedRegisters )( 
            IDiaFrameData * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_program )( 
            IDiaFrameData * This,
            /* [retval][out] */ BSTR *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_systemExceptionHandling )( 
            IDiaFrameData * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_cplusplusExceptionHandling )( 
            IDiaFrameData * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_functionStart )( 
            IDiaFrameData * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_allocatesBasePointer )( 
            IDiaFrameData * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_type )( 
            IDiaFrameData * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_functionParent )( 
            IDiaFrameData * This,
            /* [retval][out] */ IDiaFrameData **pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *execute )( 
            IDiaFrameData * This,
            IDiaStackWalkFrame *frame);
        
        END_INTERFACE
    } IDiaFrameDataVtbl;

    interface IDiaFrameData
    {
        CONST_VTBL struct IDiaFrameDataVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaFrameData_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaFrameData_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaFrameData_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaFrameData_get_addressSection(This,pRetVal)	\
    (This)->lpVtbl -> get_addressSection(This,pRetVal)

#define IDiaFrameData_get_addressOffset(This,pRetVal)	\
    (This)->lpVtbl -> get_addressOffset(This,pRetVal)

#define IDiaFrameData_get_relativeVirtualAddress(This,pRetVal)	\
    (This)->lpVtbl -> get_relativeVirtualAddress(This,pRetVal)

#define IDiaFrameData_get_virtualAddress(This,pRetVal)	\
    (This)->lpVtbl -> get_virtualAddress(This,pRetVal)

#define IDiaFrameData_get_lengthBlock(This,pRetVal)	\
    (This)->lpVtbl -> get_lengthBlock(This,pRetVal)

#define IDiaFrameData_get_lengthLocals(This,pRetVal)	\
    (This)->lpVtbl -> get_lengthLocals(This,pRetVal)

#define IDiaFrameData_get_lengthParams(This,pRetVal)	\
    (This)->lpVtbl -> get_lengthParams(This,pRetVal)

#define IDiaFrameData_get_maxStack(This,pRetVal)	\
    (This)->lpVtbl -> get_maxStack(This,pRetVal)

#define IDiaFrameData_get_lengthProlog(This,pRetVal)	\
    (This)->lpVtbl -> get_lengthProlog(This,pRetVal)

#define IDiaFrameData_get_lengthSavedRegisters(This,pRetVal)	\
    (This)->lpVtbl -> get_lengthSavedRegisters(This,pRetVal)

#define IDiaFrameData_get_program(This,pRetVal)	\
    (This)->lpVtbl -> get_program(This,pRetVal)

#define IDiaFrameData_get_systemExceptionHandling(This,pRetVal)	\
    (This)->lpVtbl -> get_systemExceptionHandling(This,pRetVal)

#define IDiaFrameData_get_cplusplusExceptionHandling(This,pRetVal)	\
    (This)->lpVtbl -> get_cplusplusExceptionHandling(This,pRetVal)

#define IDiaFrameData_get_functionStart(This,pRetVal)	\
    (This)->lpVtbl -> get_functionStart(This,pRetVal)

#define IDiaFrameData_get_allocatesBasePointer(This,pRetVal)	\
    (This)->lpVtbl -> get_allocatesBasePointer(This,pRetVal)

#define IDiaFrameData_get_type(This,pRetVal)	\
    (This)->lpVtbl -> get_type(This,pRetVal)

#define IDiaFrameData_get_functionParent(This,pRetVal)	\
    (This)->lpVtbl -> get_functionParent(This,pRetVal)

#define IDiaFrameData_execute(This,frame)	\
    (This)->lpVtbl -> execute(This,frame)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaFrameData_get_addressSection_Proxy( 
    IDiaFrameData * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaFrameData_get_addressSection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaFrameData_get_addressOffset_Proxy( 
    IDiaFrameData * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaFrameData_get_addressOffset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaFrameData_get_relativeVirtualAddress_Proxy( 
    IDiaFrameData * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaFrameData_get_relativeVirtualAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaFrameData_get_virtualAddress_Proxy( 
    IDiaFrameData * This,
    /* [retval][out] */ ULONGLONG *pRetVal);


void __RPC_STUB IDiaFrameData_get_virtualAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaFrameData_get_lengthBlock_Proxy( 
    IDiaFrameData * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaFrameData_get_lengthBlock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaFrameData_get_lengthLocals_Proxy( 
    IDiaFrameData * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaFrameData_get_lengthLocals_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaFrameData_get_lengthParams_Proxy( 
    IDiaFrameData * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaFrameData_get_lengthParams_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaFrameData_get_maxStack_Proxy( 
    IDiaFrameData * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaFrameData_get_maxStack_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaFrameData_get_lengthProlog_Proxy( 
    IDiaFrameData * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaFrameData_get_lengthProlog_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaFrameData_get_lengthSavedRegisters_Proxy( 
    IDiaFrameData * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaFrameData_get_lengthSavedRegisters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaFrameData_get_program_Proxy( 
    IDiaFrameData * This,
    /* [retval][out] */ BSTR *pRetVal);


void __RPC_STUB IDiaFrameData_get_program_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaFrameData_get_systemExceptionHandling_Proxy( 
    IDiaFrameData * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaFrameData_get_systemExceptionHandling_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaFrameData_get_cplusplusExceptionHandling_Proxy( 
    IDiaFrameData * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaFrameData_get_cplusplusExceptionHandling_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaFrameData_get_functionStart_Proxy( 
    IDiaFrameData * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaFrameData_get_functionStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaFrameData_get_allocatesBasePointer_Proxy( 
    IDiaFrameData * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaFrameData_get_allocatesBasePointer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaFrameData_get_type_Proxy( 
    IDiaFrameData * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaFrameData_get_type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaFrameData_get_functionParent_Proxy( 
    IDiaFrameData * This,
    /* [retval][out] */ IDiaFrameData **pRetVal);


void __RPC_STUB IDiaFrameData_get_functionParent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaFrameData_execute_Proxy( 
    IDiaFrameData * This,
    IDiaStackWalkFrame *frame);


void __RPC_STUB IDiaFrameData_execute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaFrameData_INTERFACE_DEFINED__ */


#ifndef __IDiaImageData_INTERFACE_DEFINED__
#define __IDiaImageData_INTERFACE_DEFINED__

/* interface IDiaImageData */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaImageData;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C8E40ED2-A1D9-4221-8692-3CE661184B44")
    IDiaImageData : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_relativeVirtualAddress( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_virtualAddress( 
            /* [retval][out] */ ULONGLONG *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_imageBase( 
            /* [retval][out] */ ULONGLONG *pRetVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaImageDataVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaImageData * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaImageData * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaImageData * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_relativeVirtualAddress )( 
            IDiaImageData * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_virtualAddress )( 
            IDiaImageData * This,
            /* [retval][out] */ ULONGLONG *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_imageBase )( 
            IDiaImageData * This,
            /* [retval][out] */ ULONGLONG *pRetVal);
        
        END_INTERFACE
    } IDiaImageDataVtbl;

    interface IDiaImageData
    {
        CONST_VTBL struct IDiaImageDataVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaImageData_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaImageData_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaImageData_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaImageData_get_relativeVirtualAddress(This,pRetVal)	\
    (This)->lpVtbl -> get_relativeVirtualAddress(This,pRetVal)

#define IDiaImageData_get_virtualAddress(This,pRetVal)	\
    (This)->lpVtbl -> get_virtualAddress(This,pRetVal)

#define IDiaImageData_get_imageBase(This,pRetVal)	\
    (This)->lpVtbl -> get_imageBase(This,pRetVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaImageData_get_relativeVirtualAddress_Proxy( 
    IDiaImageData * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaImageData_get_relativeVirtualAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaImageData_get_virtualAddress_Proxy( 
    IDiaImageData * This,
    /* [retval][out] */ ULONGLONG *pRetVal);


void __RPC_STUB IDiaImageData_get_virtualAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaImageData_get_imageBase_Proxy( 
    IDiaImageData * This,
    /* [retval][out] */ ULONGLONG *pRetVal);


void __RPC_STUB IDiaImageData_get_imageBase_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaImageData_INTERFACE_DEFINED__ */


#ifndef __IDiaTable_INTERFACE_DEFINED__
#define __IDiaTable_INTERFACE_DEFINED__

/* interface IDiaTable */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaTable;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4A59FB77-ABAC-469b-A30B-9ECC85BFEF14")
    IDiaTable : public IEnumUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_name( 
            /* [retval][out] */ BSTR *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ LONG *pRetVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ DWORD index,
            /* [retval][out] */ IUnknown **element) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaTableVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaTable * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaTable * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaTable * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Next )( 
            IDiaTable * This,
            /* [in] */ ULONG celt,
            /* [out] */ IUnknown **rgelt,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IDiaTable * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IDiaTable * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IDiaTable * This,
            /* [out] */ IEnumUnknown **ppenum);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IDiaTable * This,
            /* [retval][out] */ IUnknown **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_name )( 
            IDiaTable * This,
            /* [retval][out] */ BSTR *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IDiaTable * This,
            /* [retval][out] */ LONG *pRetVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Item )( 
            IDiaTable * This,
            /* [in] */ DWORD index,
            /* [retval][out] */ IUnknown **element);
        
        END_INTERFACE
    } IDiaTableVtbl;

    interface IDiaTable
    {
        CONST_VTBL struct IDiaTableVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaTable_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaTable_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaTable_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaTable_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IDiaTable_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IDiaTable_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IDiaTable_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)


#define IDiaTable_get__NewEnum(This,pRetVal)	\
    (This)->lpVtbl -> get__NewEnum(This,pRetVal)

#define IDiaTable_get_name(This,pRetVal)	\
    (This)->lpVtbl -> get_name(This,pRetVal)

#define IDiaTable_get_Count(This,pRetVal)	\
    (This)->lpVtbl -> get_Count(This,pRetVal)

#define IDiaTable_Item(This,index,element)	\
    (This)->lpVtbl -> Item(This,index,element)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaTable_get__NewEnum_Proxy( 
    IDiaTable * This,
    /* [retval][out] */ IUnknown **pRetVal);


void __RPC_STUB IDiaTable_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaTable_get_name_Proxy( 
    IDiaTable * This,
    /* [retval][out] */ BSTR *pRetVal);


void __RPC_STUB IDiaTable_get_name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaTable_get_Count_Proxy( 
    IDiaTable * This,
    /* [retval][out] */ LONG *pRetVal);


void __RPC_STUB IDiaTable_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDiaTable_Item_Proxy( 
    IDiaTable * This,
    /* [in] */ DWORD index,
    /* [retval][out] */ IUnknown **element);


void __RPC_STUB IDiaTable_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaTable_INTERFACE_DEFINED__ */


#ifndef __IDiaEnumTables_INTERFACE_DEFINED__
#define __IDiaEnumTables_INTERFACE_DEFINED__

/* interface IDiaEnumTables */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaEnumTables;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C65C2B0A-1150-4d7a-AFCC-E05BF3DEE81E")
    IDiaEnumTables : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ LONG *pRetVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ VARIANT index,
            /* [retval][out] */ IDiaTable **table) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            ULONG celt,
            IDiaTable **rgelt,
            ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IDiaEnumTables **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaEnumTablesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaEnumTables * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaEnumTables * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaEnumTables * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IDiaEnumTables * This,
            /* [retval][out] */ IUnknown **pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IDiaEnumTables * This,
            /* [retval][out] */ LONG *pRetVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Item )( 
            IDiaEnumTables * This,
            /* [in] */ VARIANT index,
            /* [retval][out] */ IDiaTable **table);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IDiaEnumTables * This,
            ULONG celt,
            IDiaTable **rgelt,
            ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IDiaEnumTables * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IDiaEnumTables * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IDiaEnumTables * This,
            /* [out] */ IDiaEnumTables **ppenum);
        
        END_INTERFACE
    } IDiaEnumTablesVtbl;

    interface IDiaEnumTables
    {
        CONST_VTBL struct IDiaEnumTablesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaEnumTables_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaEnumTables_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaEnumTables_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaEnumTables_get__NewEnum(This,pRetVal)	\
    (This)->lpVtbl -> get__NewEnum(This,pRetVal)

#define IDiaEnumTables_get_Count(This,pRetVal)	\
    (This)->lpVtbl -> get_Count(This,pRetVal)

#define IDiaEnumTables_Item(This,index,table)	\
    (This)->lpVtbl -> Item(This,index,table)

#define IDiaEnumTables_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IDiaEnumTables_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IDiaEnumTables_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IDiaEnumTables_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumTables_get__NewEnum_Proxy( 
    IDiaEnumTables * This,
    /* [retval][out] */ IUnknown **pRetVal);


void __RPC_STUB IDiaEnumTables_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaEnumTables_get_Count_Proxy( 
    IDiaEnumTables * This,
    /* [retval][out] */ LONG *pRetVal);


void __RPC_STUB IDiaEnumTables_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDiaEnumTables_Item_Proxy( 
    IDiaEnumTables * This,
    /* [in] */ VARIANT index,
    /* [retval][out] */ IDiaTable **table);


void __RPC_STUB IDiaEnumTables_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumTables_Next_Proxy( 
    IDiaEnumTables * This,
    ULONG celt,
    IDiaTable **rgelt,
    ULONG *pceltFetched);


void __RPC_STUB IDiaEnumTables_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumTables_Skip_Proxy( 
    IDiaEnumTables * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IDiaEnumTables_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumTables_Reset_Proxy( 
    IDiaEnumTables * This);


void __RPC_STUB IDiaEnumTables_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumTables_Clone_Proxy( 
    IDiaEnumTables * This,
    /* [out] */ IDiaEnumTables **ppenum);


void __RPC_STUB IDiaEnumTables_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaEnumTables_INTERFACE_DEFINED__ */



#ifndef __Dia2Lib_LIBRARY_DEFINED__
#define __Dia2Lib_LIBRARY_DEFINED__

/* library Dia2Lib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_Dia2Lib;

EXTERN_C const CLSID CLSID_DiaSource;

#ifdef __cplusplus

class DECLSPEC_UUID("e60afbee-502d-46ae-858f-8272a09bd707")
DiaSource;
#endif

EXTERN_C const CLSID CLSID_DiaSourceAlt;

#ifdef __cplusplus

class DECLSPEC_UUID("9c1c335f-d27d-4857-bda0-2c7364544706")
DiaSourceAlt;
#endif

EXTERN_C const CLSID CLSID_DiaStackWalker;

#ifdef __cplusplus

class DECLSPEC_UUID("31495af6-0897-4f1e-8dac-1447f10174a1")
DiaStackWalker;
#endif
#endif /* __Dia2Lib_LIBRARY_DEFINED__ */

/* interface __MIDL_itf_dia2_internal_0151 */
/* [local] */ 

#define	DiaTable_Symbols	( L"Symbols" )

#define	DiaTable_Sections	( L"Sections" )

#define	DiaTable_SrcFiles	( L"SourceFiles" )

#define	DiaTable_LineNums	( L"LineNumbers" )

#define	DiaTable_SegMap	( L"SegmentMap" )

#define	DiaTable_Dbg	( L"Dbg" )

#define	DiaTable_InjSrc	( L"InjectedSource" )

#define	DiaTable_FrameData	( L"FrameData" )



extern RPC_IF_HANDLE __MIDL_itf_dia2_internal_0151_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dia2_internal_0151_v0_0_s_ifspec;

#ifndef __IDiaPropertyStorage_INTERFACE_DEFINED__
#define __IDiaPropertyStorage_INTERFACE_DEFINED__

/* interface IDiaPropertyStorage */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaPropertyStorage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9d416f9c-e184-45b2-a4f0-ce517f719e9b")
    IDiaPropertyStorage : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ReadMultiple( 
            /* [in] */ ULONG cpspec,
            /* [size_is][in] */ const PROPSPEC rgpspec[  ],
            /* [length_is][size_is][out][in] */ PROPVARIANT rgvar[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReadPropertyNames( 
            /* [in] */ ULONG cpropid,
            /* [size_is][length_is][in] */ const PROPID rgpropid[  ],
            /* [size_is][length_is][out][in] */ BSTR rglpwstrName[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Enum( 
            /* [out] */ IEnumSTATPROPSTG **ppenum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReadDWORD( 
            /* [in] */ PROPID id,
            /* [out] */ DWORD *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReadLONG( 
            /* [in] */ PROPID id,
            /* [out] */ LONG *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReadBOOL( 
            /* [in] */ PROPID id,
            /* [out] */ BOOL *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReadULONGLONG( 
            /* [in] */ PROPID id,
            /* [out] */ ULONGLONG *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReadBSTR( 
            /* [in] */ PROPID id,
            /* [out] */ BSTR *pValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaPropertyStorageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaPropertyStorage * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaPropertyStorage * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaPropertyStorage * This);
        
        HRESULT ( STDMETHODCALLTYPE *ReadMultiple )( 
            IDiaPropertyStorage * This,
            /* [in] */ ULONG cpspec,
            /* [size_is][in] */ const PROPSPEC rgpspec[  ],
            /* [length_is][size_is][out][in] */ PROPVARIANT rgvar[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *ReadPropertyNames )( 
            IDiaPropertyStorage * This,
            /* [in] */ ULONG cpropid,
            /* [size_is][length_is][in] */ const PROPID rgpropid[  ],
            /* [size_is][length_is][out][in] */ BSTR rglpwstrName[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *Enum )( 
            IDiaPropertyStorage * This,
            /* [out] */ IEnumSTATPROPSTG **ppenum);
        
        HRESULT ( STDMETHODCALLTYPE *ReadDWORD )( 
            IDiaPropertyStorage * This,
            /* [in] */ PROPID id,
            /* [out] */ DWORD *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *ReadLONG )( 
            IDiaPropertyStorage * This,
            /* [in] */ PROPID id,
            /* [out] */ LONG *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *ReadBOOL )( 
            IDiaPropertyStorage * This,
            /* [in] */ PROPID id,
            /* [out] */ BOOL *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *ReadULONGLONG )( 
            IDiaPropertyStorage * This,
            /* [in] */ PROPID id,
            /* [out] */ ULONGLONG *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *ReadBSTR )( 
            IDiaPropertyStorage * This,
            /* [in] */ PROPID id,
            /* [out] */ BSTR *pValue);
        
        END_INTERFACE
    } IDiaPropertyStorageVtbl;

    interface IDiaPropertyStorage
    {
        CONST_VTBL struct IDiaPropertyStorageVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaPropertyStorage_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaPropertyStorage_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaPropertyStorage_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaPropertyStorage_ReadMultiple(This,cpspec,rgpspec,rgvar)	\
    (This)->lpVtbl -> ReadMultiple(This,cpspec,rgpspec,rgvar)

#define IDiaPropertyStorage_ReadPropertyNames(This,cpropid,rgpropid,rglpwstrName)	\
    (This)->lpVtbl -> ReadPropertyNames(This,cpropid,rgpropid,rglpwstrName)

#define IDiaPropertyStorage_Enum(This,ppenum)	\
    (This)->lpVtbl -> Enum(This,ppenum)

#define IDiaPropertyStorage_ReadDWORD(This,id,pValue)	\
    (This)->lpVtbl -> ReadDWORD(This,id,pValue)

#define IDiaPropertyStorage_ReadLONG(This,id,pValue)	\
    (This)->lpVtbl -> ReadLONG(This,id,pValue)

#define IDiaPropertyStorage_ReadBOOL(This,id,pValue)	\
    (This)->lpVtbl -> ReadBOOL(This,id,pValue)

#define IDiaPropertyStorage_ReadULONGLONG(This,id,pValue)	\
    (This)->lpVtbl -> ReadULONGLONG(This,id,pValue)

#define IDiaPropertyStorage_ReadBSTR(This,id,pValue)	\
    (This)->lpVtbl -> ReadBSTR(This,id,pValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDiaPropertyStorage_ReadMultiple_Proxy( 
    IDiaPropertyStorage * This,
    /* [in] */ ULONG cpspec,
    /* [size_is][in] */ const PROPSPEC rgpspec[  ],
    /* [length_is][size_is][out][in] */ PROPVARIANT rgvar[  ]);


void __RPC_STUB IDiaPropertyStorage_ReadMultiple_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaPropertyStorage_ReadPropertyNames_Proxy( 
    IDiaPropertyStorage * This,
    /* [in] */ ULONG cpropid,
    /* [size_is][length_is][in] */ const PROPID rgpropid[  ],
    /* [size_is][length_is][out][in] */ BSTR rglpwstrName[  ]);


void __RPC_STUB IDiaPropertyStorage_ReadPropertyNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaPropertyStorage_Enum_Proxy( 
    IDiaPropertyStorage * This,
    /* [out] */ IEnumSTATPROPSTG **ppenum);


void __RPC_STUB IDiaPropertyStorage_Enum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaPropertyStorage_ReadDWORD_Proxy( 
    IDiaPropertyStorage * This,
    /* [in] */ PROPID id,
    /* [out] */ DWORD *pValue);


void __RPC_STUB IDiaPropertyStorage_ReadDWORD_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaPropertyStorage_ReadLONG_Proxy( 
    IDiaPropertyStorage * This,
    /* [in] */ PROPID id,
    /* [out] */ LONG *pValue);


void __RPC_STUB IDiaPropertyStorage_ReadLONG_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaPropertyStorage_ReadBOOL_Proxy( 
    IDiaPropertyStorage * This,
    /* [in] */ PROPID id,
    /* [out] */ BOOL *pValue);


void __RPC_STUB IDiaPropertyStorage_ReadBOOL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaPropertyStorage_ReadULONGLONG_Proxy( 
    IDiaPropertyStorage * This,
    /* [in] */ PROPID id,
    /* [out] */ ULONGLONG *pValue);


void __RPC_STUB IDiaPropertyStorage_ReadULONGLONG_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaPropertyStorage_ReadBSTR_Proxy( 
    IDiaPropertyStorage * This,
    /* [in] */ PROPID id,
    /* [out] */ BSTR *pValue);


void __RPC_STUB IDiaPropertyStorage_ReadBSTR_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaPropertyStorage_INTERFACE_DEFINED__ */


#ifndef __IDiaStackFrame_INTERFACE_DEFINED__
#define __IDiaStackFrame_INTERFACE_DEFINED__

/* interface IDiaStackFrame */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaStackFrame;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("fcea0205-66eb-4794-b38f-13852095c785")
    IDiaStackFrame : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_type( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_base( 
            /* [retval][out] */ ULONGLONG *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_size( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_returnAddress( 
            /* [retval][out] */ ULONGLONG *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_localsBase( 
            /* [retval][out] */ ULONGLONG *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_lengthLocals( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_lengthParams( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_lengthProlog( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_lengthSavedRegisters( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_systemExceptionHandling( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_cplusplusExceptionHandling( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_functionStart( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_allocatesBasePointer( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_maxStack( 
            /* [retval][out] */ DWORD *pRetVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaStackFrameVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaStackFrame * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaStackFrame * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaStackFrame * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_type )( 
            IDiaStackFrame * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_base )( 
            IDiaStackFrame * This,
            /* [retval][out] */ ULONGLONG *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_size )( 
            IDiaStackFrame * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_returnAddress )( 
            IDiaStackFrame * This,
            /* [retval][out] */ ULONGLONG *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_localsBase )( 
            IDiaStackFrame * This,
            /* [retval][out] */ ULONGLONG *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lengthLocals )( 
            IDiaStackFrame * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lengthParams )( 
            IDiaStackFrame * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lengthProlog )( 
            IDiaStackFrame * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lengthSavedRegisters )( 
            IDiaStackFrame * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_systemExceptionHandling )( 
            IDiaStackFrame * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_cplusplusExceptionHandling )( 
            IDiaStackFrame * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_functionStart )( 
            IDiaStackFrame * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_allocatesBasePointer )( 
            IDiaStackFrame * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_maxStack )( 
            IDiaStackFrame * This,
            /* [retval][out] */ DWORD *pRetVal);
        
        END_INTERFACE
    } IDiaStackFrameVtbl;

    interface IDiaStackFrame
    {
        CONST_VTBL struct IDiaStackFrameVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaStackFrame_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaStackFrame_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaStackFrame_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaStackFrame_get_type(This,pRetVal)	\
    (This)->lpVtbl -> get_type(This,pRetVal)

#define IDiaStackFrame_get_base(This,pRetVal)	\
    (This)->lpVtbl -> get_base(This,pRetVal)

#define IDiaStackFrame_get_size(This,pRetVal)	\
    (This)->lpVtbl -> get_size(This,pRetVal)

#define IDiaStackFrame_get_returnAddress(This,pRetVal)	\
    (This)->lpVtbl -> get_returnAddress(This,pRetVal)

#define IDiaStackFrame_get_localsBase(This,pRetVal)	\
    (This)->lpVtbl -> get_localsBase(This,pRetVal)

#define IDiaStackFrame_get_lengthLocals(This,pRetVal)	\
    (This)->lpVtbl -> get_lengthLocals(This,pRetVal)

#define IDiaStackFrame_get_lengthParams(This,pRetVal)	\
    (This)->lpVtbl -> get_lengthParams(This,pRetVal)

#define IDiaStackFrame_get_lengthProlog(This,pRetVal)	\
    (This)->lpVtbl -> get_lengthProlog(This,pRetVal)

#define IDiaStackFrame_get_lengthSavedRegisters(This,pRetVal)	\
    (This)->lpVtbl -> get_lengthSavedRegisters(This,pRetVal)

#define IDiaStackFrame_get_systemExceptionHandling(This,pRetVal)	\
    (This)->lpVtbl -> get_systemExceptionHandling(This,pRetVal)

#define IDiaStackFrame_get_cplusplusExceptionHandling(This,pRetVal)	\
    (This)->lpVtbl -> get_cplusplusExceptionHandling(This,pRetVal)

#define IDiaStackFrame_get_functionStart(This,pRetVal)	\
    (This)->lpVtbl -> get_functionStart(This,pRetVal)

#define IDiaStackFrame_get_allocatesBasePointer(This,pRetVal)	\
    (This)->lpVtbl -> get_allocatesBasePointer(This,pRetVal)

#define IDiaStackFrame_get_maxStack(This,pRetVal)	\
    (This)->lpVtbl -> get_maxStack(This,pRetVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaStackFrame_get_type_Proxy( 
    IDiaStackFrame * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaStackFrame_get_type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaStackFrame_get_base_Proxy( 
    IDiaStackFrame * This,
    /* [retval][out] */ ULONGLONG *pRetVal);


void __RPC_STUB IDiaStackFrame_get_base_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaStackFrame_get_size_Proxy( 
    IDiaStackFrame * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaStackFrame_get_size_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaStackFrame_get_returnAddress_Proxy( 
    IDiaStackFrame * This,
    /* [retval][out] */ ULONGLONG *pRetVal);


void __RPC_STUB IDiaStackFrame_get_returnAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaStackFrame_get_localsBase_Proxy( 
    IDiaStackFrame * This,
    /* [retval][out] */ ULONGLONG *pRetVal);


void __RPC_STUB IDiaStackFrame_get_localsBase_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaStackFrame_get_lengthLocals_Proxy( 
    IDiaStackFrame * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaStackFrame_get_lengthLocals_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaStackFrame_get_lengthParams_Proxy( 
    IDiaStackFrame * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaStackFrame_get_lengthParams_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaStackFrame_get_lengthProlog_Proxy( 
    IDiaStackFrame * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaStackFrame_get_lengthProlog_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaStackFrame_get_lengthSavedRegisters_Proxy( 
    IDiaStackFrame * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaStackFrame_get_lengthSavedRegisters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaStackFrame_get_systemExceptionHandling_Proxy( 
    IDiaStackFrame * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaStackFrame_get_systemExceptionHandling_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaStackFrame_get_cplusplusExceptionHandling_Proxy( 
    IDiaStackFrame * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaStackFrame_get_cplusplusExceptionHandling_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaStackFrame_get_functionStart_Proxy( 
    IDiaStackFrame * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaStackFrame_get_functionStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaStackFrame_get_allocatesBasePointer_Proxy( 
    IDiaStackFrame * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB IDiaStackFrame_get_allocatesBasePointer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaStackFrame_get_maxStack_Proxy( 
    IDiaStackFrame * This,
    /* [retval][out] */ DWORD *pRetVal);


void __RPC_STUB IDiaStackFrame_get_maxStack_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaStackFrame_INTERFACE_DEFINED__ */


#ifndef __IDiaEnumStackFrames_INTERFACE_DEFINED__
#define __IDiaEnumStackFrames_INTERFACE_DEFINED__

/* interface IDiaEnumStackFrames */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaEnumStackFrames;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ec9d461d-ce74-4711-a020-7d8f9a1dd255")
    IDiaEnumStackFrames : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [out] */ IDiaStackFrame **rgelt,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaEnumStackFramesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaEnumStackFrames * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaEnumStackFrames * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaEnumStackFrames * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IDiaEnumStackFrames * This,
            /* [in] */ ULONG celt,
            /* [out] */ IDiaStackFrame **rgelt,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IDiaEnumStackFrames * This);
        
        END_INTERFACE
    } IDiaEnumStackFramesVtbl;

    interface IDiaEnumStackFrames
    {
        CONST_VTBL struct IDiaEnumStackFramesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaEnumStackFrames_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaEnumStackFrames_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaEnumStackFrames_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaEnumStackFrames_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IDiaEnumStackFrames_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDiaEnumStackFrames_Next_Proxy( 
    IDiaEnumStackFrames * This,
    /* [in] */ ULONG celt,
    /* [out] */ IDiaStackFrame **rgelt,
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB IDiaEnumStackFrames_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaEnumStackFrames_Reset_Proxy( 
    IDiaEnumStackFrames * This);


void __RPC_STUB IDiaEnumStackFrames_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaEnumStackFrames_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dia2_internal_0155 */
/* [local] */ 

typedef /* [public] */ struct __MIDL___MIDL_itf_dia2_internal_0155_0001
    {
    DWORD ulOffStart;
    DWORD cbProcSize;
    DWORD cdwLocals;
    WORD cdwParams;
    WORD cdwFlags;
    } 	FPODATA;



extern RPC_IF_HANDLE __MIDL_itf_dia2_internal_0155_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dia2_internal_0155_v0_0_s_ifspec;

#ifndef __IDiaStackWalkHelper_INTERFACE_DEFINED__
#define __IDiaStackWalkHelper_INTERFACE_DEFINED__

/* interface IDiaStackWalkHelper */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaStackWalkHelper;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("43dbf56f-7f7f-4a09-9c83-5bab344f1c12")
    IDiaStackWalkHelper : public IUnknown
    {
    public:
        virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_registerValue( 
            /* [in] */ DWORD index,
            /* [retval][out] */ ULONGLONG *pRetVal) = 0;
        
        virtual /* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_registerValue( 
            /* [in] */ DWORD index,
            /* [in] */ ULONGLONG NewVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE readMemory( 
            /* [in] */ enum MemoryTypeEnum type,
            /* [in] */ ULONGLONG va,
            /* [in] */ DWORD cbData,
            /* [out] */ DWORD *pcbData,
            /* [length_is][size_is][out] */ BYTE data[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE searchForReturnAddress( 
            /* [in] */ IDiaFrameData *frame,
            /* [out] */ ULONGLONG *returnAddress) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE searchForReturnAddressStart( 
            /* [in] */ IDiaFrameData *frame,
            /* [in] */ ULONGLONG startAddress,
            /* [out] */ ULONGLONG *returnAddress) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE frameForVA( 
            /* [in] */ ULONGLONG va,
            /* [out] */ IDiaFrameData **ppFrame) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE symbolForVA( 
            /* [in] */ ULONGLONG va,
            /* [out] */ IDiaSymbol **ppSymbol) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaStackWalkHelperVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaStackWalkHelper * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaStackWalkHelper * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaStackWalkHelper * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_registerValue )( 
            IDiaStackWalkHelper * This,
            /* [in] */ DWORD index,
            /* [retval][out] */ ULONGLONG *pRetVal);
        
        /* [id][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_registerValue )( 
            IDiaStackWalkHelper * This,
            /* [in] */ DWORD index,
            /* [in] */ ULONGLONG NewVal);
        
        HRESULT ( STDMETHODCALLTYPE *readMemory )( 
            IDiaStackWalkHelper * This,
            /* [in] */ enum MemoryTypeEnum type,
            /* [in] */ ULONGLONG va,
            /* [in] */ DWORD cbData,
            /* [out] */ DWORD *pcbData,
            /* [length_is][size_is][out] */ BYTE data[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *searchForReturnAddress )( 
            IDiaStackWalkHelper * This,
            /* [in] */ IDiaFrameData *frame,
            /* [out] */ ULONGLONG *returnAddress);
        
        HRESULT ( STDMETHODCALLTYPE *searchForReturnAddressStart )( 
            IDiaStackWalkHelper * This,
            /* [in] */ IDiaFrameData *frame,
            /* [in] */ ULONGLONG startAddress,
            /* [out] */ ULONGLONG *returnAddress);
        
        HRESULT ( STDMETHODCALLTYPE *frameForVA )( 
            IDiaStackWalkHelper * This,
            /* [in] */ ULONGLONG va,
            /* [out] */ IDiaFrameData **ppFrame);
        
        HRESULT ( STDMETHODCALLTYPE *symbolForVA )( 
            IDiaStackWalkHelper * This,
            /* [in] */ ULONGLONG va,
            /* [out] */ IDiaSymbol **ppSymbol);
        
        END_INTERFACE
    } IDiaStackWalkHelperVtbl;

    interface IDiaStackWalkHelper
    {
        CONST_VTBL struct IDiaStackWalkHelperVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaStackWalkHelper_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaStackWalkHelper_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaStackWalkHelper_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaStackWalkHelper_get_registerValue(This,index,pRetVal)	\
    (This)->lpVtbl -> get_registerValue(This,index,pRetVal)

#define IDiaStackWalkHelper_put_registerValue(This,index,NewVal)	\
    (This)->lpVtbl -> put_registerValue(This,index,NewVal)

#define IDiaStackWalkHelper_readMemory(This,type,va,cbData,pcbData,data)	\
    (This)->lpVtbl -> readMemory(This,type,va,cbData,pcbData,data)

#define IDiaStackWalkHelper_searchForReturnAddress(This,frame,returnAddress)	\
    (This)->lpVtbl -> searchForReturnAddress(This,frame,returnAddress)

#define IDiaStackWalkHelper_searchForReturnAddressStart(This,frame,startAddress,returnAddress)	\
    (This)->lpVtbl -> searchForReturnAddressStart(This,frame,startAddress,returnAddress)

#define IDiaStackWalkHelper_frameForVA(This,va,ppFrame)	\
    (This)->lpVtbl -> frameForVA(This,va,ppFrame)

#define IDiaStackWalkHelper_symbolForVA(This,va,ppSymbol)	\
    (This)->lpVtbl -> symbolForVA(This,va,ppSymbol)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDiaStackWalkHelper_get_registerValue_Proxy( 
    IDiaStackWalkHelper * This,
    /* [in] */ DWORD index,
    /* [retval][out] */ ULONGLONG *pRetVal);


void __RPC_STUB IDiaStackWalkHelper_get_registerValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE IDiaStackWalkHelper_put_registerValue_Proxy( 
    IDiaStackWalkHelper * This,
    /* [in] */ DWORD index,
    /* [in] */ ULONGLONG NewVal);


void __RPC_STUB IDiaStackWalkHelper_put_registerValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaStackWalkHelper_readMemory_Proxy( 
    IDiaStackWalkHelper * This,
    /* [in] */ enum MemoryTypeEnum type,
    /* [in] */ ULONGLONG va,
    /* [in] */ DWORD cbData,
    /* [out] */ DWORD *pcbData,
    /* [length_is][size_is][out] */ BYTE data[  ]);


void __RPC_STUB IDiaStackWalkHelper_readMemory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaStackWalkHelper_searchForReturnAddress_Proxy( 
    IDiaStackWalkHelper * This,
    /* [in] */ IDiaFrameData *frame,
    /* [out] */ ULONGLONG *returnAddress);


void __RPC_STUB IDiaStackWalkHelper_searchForReturnAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaStackWalkHelper_searchForReturnAddressStart_Proxy( 
    IDiaStackWalkHelper * This,
    /* [in] */ IDiaFrameData *frame,
    /* [in] */ ULONGLONG startAddress,
    /* [out] */ ULONGLONG *returnAddress);


void __RPC_STUB IDiaStackWalkHelper_searchForReturnAddressStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaStackWalkHelper_frameForVA_Proxy( 
    IDiaStackWalkHelper * This,
    /* [in] */ ULONGLONG va,
    /* [out] */ IDiaFrameData **ppFrame);


void __RPC_STUB IDiaStackWalkHelper_frameForVA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaStackWalkHelper_symbolForVA_Proxy( 
    IDiaStackWalkHelper * This,
    /* [in] */ ULONGLONG va,
    /* [out] */ IDiaSymbol **ppSymbol);


void __RPC_STUB IDiaStackWalkHelper_symbolForVA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaStackWalkHelper_INTERFACE_DEFINED__ */


#ifndef __IDiaStackWalker_INTERFACE_DEFINED__
#define __IDiaStackWalker_INTERFACE_DEFINED__

/* interface IDiaStackWalker */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaStackWalker;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("14341190-eff2-46af-9290-14fa980277b0")
    IDiaStackWalker : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE getEnumFrames( 
            /* [in] */ IDiaStackWalkHelper *pHelper,
            /* [out] */ IDiaEnumStackFrames **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaStackWalkerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaStackWalker * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaStackWalker * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaStackWalker * This);
        
        HRESULT ( STDMETHODCALLTYPE *getEnumFrames )( 
            IDiaStackWalker * This,
            /* [in] */ IDiaStackWalkHelper *pHelper,
            /* [out] */ IDiaEnumStackFrames **ppEnum);
        
        END_INTERFACE
    } IDiaStackWalkerVtbl;

    interface IDiaStackWalker
    {
        CONST_VTBL struct IDiaStackWalkerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaStackWalker_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaStackWalker_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaStackWalker_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaStackWalker_getEnumFrames(This,pHelper,ppEnum)	\
    (This)->lpVtbl -> getEnumFrames(This,pHelper,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDiaStackWalker_getEnumFrames_Proxy( 
    IDiaStackWalker * This,
    /* [in] */ IDiaStackWalkHelper *pHelper,
    /* [out] */ IDiaEnumStackFrames **ppEnum);


void __RPC_STUB IDiaStackWalker_getEnumFrames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaStackWalker_INTERFACE_DEFINED__ */


#ifndef __IDiaDataSource2_INTERFACE_DEFINED__
#define __IDiaDataSource2_INTERFACE_DEFINED__

/* interface IDiaDataSource2 */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IDiaDataSource2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6d31cb3b-edd4-4c3e-ab44-12b9f7a3828e")
    IDiaDataSource2 : public IDiaDataSource
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE getRawPDBPtr( 
            /* [out] */ void **pppdb) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE loadDataFromRawPDBPtr( 
            /* [in] */ void *ppdb) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiaDataSource2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDiaDataSource2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDiaDataSource2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDiaDataSource2 * This);
        
        /* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lastError )( 
            IDiaDataSource2 * This,
            /* [retval][out] */ BSTR *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *loadDataFromPdb )( 
            IDiaDataSource2 * This,
            /* [in] */ LPCOLESTR pdbPath);
        
        HRESULT ( STDMETHODCALLTYPE *loadAndValidateDataFromPdb )( 
            IDiaDataSource2 * This,
            /* [in] */ LPCOLESTR pdbPath,
            /* [in] */ GUID *pcsig70,
            /* [in] */ DWORD sig,
            /* [in] */ DWORD age);
        
        HRESULT ( STDMETHODCALLTYPE *loadDataForExe )( 
            IDiaDataSource2 * This,
            /* [in] */ LPCOLESTR executable,
            /* [in] */ LPCOLESTR searchPath,
            /* [in] */ IUnknown *pCallback);
        
        HRESULT ( STDMETHODCALLTYPE *loadDataFromIStream )( 
            IDiaDataSource2 * This,
            /* [in] */ IStream *pIStream);
        
        HRESULT ( STDMETHODCALLTYPE *openSession )( 
            IDiaDataSource2 * This,
            /* [out] */ IDiaSession **ppSession);
        
        HRESULT ( STDMETHODCALLTYPE *getRawPDBPtr )( 
            IDiaDataSource2 * This,
            /* [out] */ void **pppdb);
        
        HRESULT ( STDMETHODCALLTYPE *loadDataFromRawPDBPtr )( 
            IDiaDataSource2 * This,
            /* [in] */ void *ppdb);
        
        END_INTERFACE
    } IDiaDataSource2Vtbl;

    interface IDiaDataSource2
    {
        CONST_VTBL struct IDiaDataSource2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiaDataSource2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDiaDataSource2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDiaDataSource2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDiaDataSource2_get_lastError(This,pRetVal)	\
    (This)->lpVtbl -> get_lastError(This,pRetVal)

#define IDiaDataSource2_loadDataFromPdb(This,pdbPath)	\
    (This)->lpVtbl -> loadDataFromPdb(This,pdbPath)

#define IDiaDataSource2_loadAndValidateDataFromPdb(This,pdbPath,pcsig70,sig,age)	\
    (This)->lpVtbl -> loadAndValidateDataFromPdb(This,pdbPath,pcsig70,sig,age)

#define IDiaDataSource2_loadDataForExe(This,executable,searchPath,pCallback)	\
    (This)->lpVtbl -> loadDataForExe(This,executable,searchPath,pCallback)

#define IDiaDataSource2_loadDataFromIStream(This,pIStream)	\
    (This)->lpVtbl -> loadDataFromIStream(This,pIStream)

#define IDiaDataSource2_openSession(This,ppSession)	\
    (This)->lpVtbl -> openSession(This,ppSession)


#define IDiaDataSource2_getRawPDBPtr(This,pppdb)	\
    (This)->lpVtbl -> getRawPDBPtr(This,pppdb)

#define IDiaDataSource2_loadDataFromRawPDBPtr(This,ppdb)	\
    (This)->lpVtbl -> loadDataFromRawPDBPtr(This,ppdb)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDiaDataSource2_getRawPDBPtr_Proxy( 
    IDiaDataSource2 * This,
    /* [out] */ void **pppdb);


void __RPC_STUB IDiaDataSource2_getRawPDBPtr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDiaDataSource2_loadDataFromRawPDBPtr_Proxy( 
    IDiaDataSource2 * This,
    /* [in] */ void *ppdb);


void __RPC_STUB IDiaDataSource2_loadDataFromRawPDBPtr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDiaDataSource2_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\vs\diacreate_int.h ===
// diacreate_int.h - creation helper functions for DIA initialization - Microsoft internal version
//-----------------------------------------------------------------
// Microsoft Confidential
// Copyright 2000 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------
#ifndef _DIACREATE_INT_H_
#define _DIACREATE_INT_H_

//
// Create a dia data source object from a static dia library
//
HRESULT STDMETHODCALLTYPE DiaCoCreate(
                        REFCLSID   rclsid,
                        REFIID     riid,
                        void     **ppv);


//
// Get PDB pointer for IDiaDataSource/IDiaSession
//
// Note - Fragile, use _VERY_ sparingly. Exists only for pat's request
//

HRESULT STDMETHODCALLTYPE GetRawPdbPtrForDataSource( const IDiaDataSource* pSource, PDB **pppdb );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\vs\pdb.h ===
// Debug Information API
// Copyright (C) 1993-1996, Microsoft Corp.  All Rights Reserved.

#pragma once

#ifndef _VC_VER_INC
#include "..\include\vcver.h"
#endif

#ifndef __PDB_INCLUDED__
#define __PDB_INCLUDED__

typedef int BOOL;
typedef unsigned UINT;
typedef unsigned char BYTE;
typedef unsigned short WORD;
typedef unsigned long DWORD;
typedef unsigned __int64 DWORDLONG;
typedef unsigned short USHORT;
typedef unsigned long ULONG;
typedef ULONG   INTV;       // interface version number
typedef ULONG   IMPV;       // implementation version number
typedef ULONG   SIG;        // unique (across PDB instances) signature
typedef ULONG   AGE;        // no. of times this instance has been updated
typedef const char*     SZ_CONST;   // const string
typedef void *          PV;
typedef const void *    PCV;

#ifdef  LNGNM
#define LNGNM_CONST const
#else   // LNGNM
#define LNGNM_CONST
#endif  // LNGNM

#ifndef GUID_DEFINED
#define GUID_DEFINED

typedef struct _GUID {          // size is 16
    DWORD   Data1;
    WORD    Data2;
    WORD    Data3;
    BYTE    Data4[8];
} GUID;

#endif // !GUID_DEFINED

#ifndef _HRESULT_DEFINED
#define _HRESULT_DEFINED
typedef long HRESULT;

#endif // !_HRESULT_DEFINED


typedef GUID            SIG70;      // new to 7.0 are 16-byte guid-like signatures
typedef SIG70 *         PSIG70;
typedef const SIG70 *   PCSIG70;

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

enum {
#ifdef LNGNM
    PDBIntv70   = 20001102,
    PDBIntv70Dep = 20000406,
#else
    PDBIntv70   = 20000301,
#endif
    PDBIntv69   = 19990511,
    PDBIntv61   = 19980914,
    PDBIntv50a  = 19970116,
    PDBIntv60   = PDBIntv50a,
    PDBIntv50   = 19960502,
    PDBIntv41   = 920924,
#ifdef LNGNM
    PDBIntv     = PDBIntv70,   // Now we support both 50 & 60, 69 is only an intermediate version
    PDBIntvAlt  = PDBIntv50,   
    PDBIntvAlt2 = PDBIntv60,   
    PDBIntvAlt3 = PDBIntv69,
#else
    PDBIntvAlt  = PDBIntv50,   // Alternate (backward compatible) supported interface
    PDBIntvAlt2 = PDBIntv60,   // Alternate (backward compatible) supported interface
    PDBIntvAlt3 = PDBIntv61,
    PDBIntv     = PDBIntv69,
#endif  
};

enum {
    PDBImpvVC2  = 19941610,
    PDBImpvVC4  = 19950623,
    PDBImpvVC41 = 19950814,
    PDBImpvVC50 = 19960307,
    PDBImpvVC98 = 19970604,
    PDBImpvVC70 = 20000404,
    PDBImpvVC70Dep = 19990604,  // deprecated vc70 implementation version
#ifdef LNGNM
    PDBImpv     = PDBImpvVC70,
#else
    PDBImpv     = PDBImpvVC98,
#endif
};


enum {
    niNil        = 0,
    PDB_MAX_PATH = 260,
    cbErrMax     = 1024,
};

// cvinfo.h type index, intentionally typedef'ed here to check equivalence.
typedef unsigned short  CV_typ16_t;
typedef unsigned long   CV_typ_t;
typedef unsigned long   CV_pubsymflag_t;    // must be same as CV_typ_t.

typedef CV_typ_t        TI;     // PDB name for type index
typedef CV_typ16_t      TI16;   // 16-bit version
typedef unsigned long   NI;     // name index
typedef TI *            PTi;
typedef TI16 *          PTi16;

typedef BYTE            ITSM;   // type server map index
typedef ITSM*           PITSM;

typedef BOOL    (__stdcall *PFNVALIDATEDEBUGINFOFILE) (const char * szFile, ULONG * errcode );

typedef struct _tagSEARCHDEBUGINFO {
    DWORD   cb;                         // doubles as version detection
    BOOL    fMainDebugFile;             // indicates "core" or "ancilliary" file
                                        // eg: main.exe has main.pdb and foo.lib->foo.pdb
    char *  szMod;                      // exe/dll
    char *  szLib;                      // lib if appropriate
    char *  szObj;                      // object file
    char * *rgszTriedThese;             // list of ones that were tried,
                                        // NULL terminated list of LSZ's
    char  szValidatedFile[PDB_MAX_PATH];// output of validated filename,
    PFNVALIDATEDEBUGINFOFILE
            pfnValidateDebugInfoFile;   // validation function
    char *  szExe;                      // exe/dll
} SEARCHDEBUGINFO, *PSEARCHDEBUGINFO;

typedef BOOL ( __stdcall * PfnFindDebugInfoFile) ( PSEARCHDEBUGINFO );

#define PdbInterface struct

PdbInterface PDB;                   // program database
PdbInterface DBI;                   // debug information within the PDB
PdbInterface Mod;                   // a module within the DBI
PdbInterface TPI;                   // type info within the DBI
PdbInterface GSI;                   // global symbol info
PdbInterface SO;                    
PdbInterface Stream;                // some named bytestream in the PDB
PdbInterface StreamImage;           // some memory mapped stream
PdbInterface NameMap;              // name mapping
PdbInterface Enum;                 // generic enumerator
PdbInterface EnumNameMap;          // enumerate names within a NameMap
PdbInterface EnumContrib;          // enumerate contributions
PdbInterface Dbg;                   // misc debug data (FPO, OMAP, etc)
PdbInterface Src;                   // Src file data
PdbInterface EnumSrc;               // Src file enumerator
PdbInterface SrcHash;               // Src file hasher
PdbInterface EnumLines;

typedef PdbInterface PDB PDB;
typedef PdbInterface DBI DBI;
typedef PdbInterface Mod Mod;
typedef PdbInterface TPI TPI;
typedef PdbInterface GSI GSI;
typedef PdbInterface SO SO;
typedef PdbInterface Stream Stream;
typedef PdbInterface StreamImage StreamImage;
typedef PdbInterface NameMap NameMap;
typedef PdbInterface Enum Enum;
typedef PdbInterface EnumStreamNames EnumStreamNames;
typedef PdbInterface EnumNameMap EnumNameMap;
typedef PdbInterface EnumContrib EnumContrib;
typedef PdbInterface EnumSyms EnumSyms;
typedef PdbInterface WidenTi WidenTi;
typedef PdbInterface Dbg Dbg;
typedef PdbInterface EnumThunk EnumThunk;
typedef PdbInterface Src Src;
typedef PdbInterface EnumSrc EnumSrc;
typedef PdbInterface SrcHash SrcHash;

typedef SrcHash *   PSrcHash;

typedef long EC;            // error code
enum PDBErrors {
    EC_OK,                  // -, no problemo
    EC_USAGE,               // -, invalid parameter or call order
    EC_OUT_OF_MEMORY,       // -, out of RAM
    EC_FILE_SYSTEM,         // "pdb name", can't write file, out of disk, etc.
    EC_NOT_FOUND,           // "pdb name", PDB file not found
    EC_INVALID_SIG,         // "pdb name", PDB::OpenValidate() and its clients only
    EC_INVALID_AGE,         // "pdb name", PDB::OpenValidate() and its clients only
    EC_PRECOMP_REQUIRED,    // "obj name", Mod::AddTypes() only
    EC_OUT_OF_TI,           // "pdb name", TPI::QueryTiForCVRecord() only
    EC_NOT_IMPLEMENTED,     // -
    EC_V1_PDB,              // "pdb name", PDB::Open* only
    EC_FORMAT,              // accessing pdb with obsolete format
    EC_LIMIT,
    EC_CORRUPT,             // cv info corrupt, recompile mod
    EC_TI16,                // no 16-bit type interface present
    EC_ACCESS_DENIED,       // "pdb name", PDB file read-only
    EC_ILLEGAL_TYPE_EDIT,   // trying to edit types in read-only mode
    EC_INVALID_EXECUTABLE,  // not recogized as a valid executable
    EC_DBG_NOT_FOUND,       // A required .DBG file was not found
    EC_NO_DEBUG_INFO,       // No recognized debug info found
    EC_INVALID_EXE_TIMESTAMP, // Invalid timestamp on Openvalidate of exe
    EC_CORRUPT_TYPEPOOL,    // A corrupted type record was found in a PDB
    EC_DEBUG_INFO_NOT_IN_PDB, // returned by OpenValidateX
    EC_MAX
};

#if !defined(pure)
#define  pure = 0
#endif

#ifndef PDBCALL
#define PDBCALL  __cdecl
#endif

#ifdef PDB_SERVER
#define PDB_IMPORT_EXPORT(RTYPE)    __declspec(dllexport) RTYPE PDBCALL
#elif   defined(PDB_LIBRARY)
#define PDB_IMPORT_EXPORT(RTYPE)    RTYPE PDBCALL
#else
#define PDB_IMPORT_EXPORT(RTYPE)    __declspec(dllimport) RTYPE PDBCALL
#endif

#define PDBAPI PDB_IMPORT_EXPORT

#ifndef IN
#define IN                  /* in parameter, parameters are IN by default */
#endif
#ifndef OUT
#define OUT                 /* out parameter */
#endif

// Type of callback arg to PDB::OpenValidate5

enum POVC
{
    povcNotifyDebugDir,
    povcNotifyOpenDBG,
    povcNotifyOpenPDB,
    povcReserved,
    povcReadExecutableAt,
    povcReadExecutableAtRVA,
    povcRestrictRegistry,
    povcRestrictSymsrv,
    povcRestrictSystemRoot,
    povcNotifyMiscPath,
    povcReadMiscDebugData,
    povcReadCodeViewDebugData,
    povcRestrictOriginalPath,
    povcRestrictReferencePath,
    povcRestrictDBG
};

typedef int (PDBCALL *PDBCALLBACK)();

typedef PDBCALLBACK (PDBCALL *PfnPDBQueryCallback)(void *pvClient, enum POVC povc);

typedef void (PDBCALL *PfnPDBNotifyDebugDir)(void *pvClient, BOOL fExecutable, const struct _IMAGE_DEBUG_DIRECTORY *pdbgdir);
typedef void (PDBCALL *PfnPDBNotifyOpenDBG)(void *pvClient, const wchar_t *wszDbgPath, enum PDBErrors ec, const wchar_t *wszError);
typedef void (PDBCALL *PfnPDBNotifyOpenPDB)(void *pvClient, const wchar_t *wszPdbPath, enum PDBErrors ec, const wchar_t *wszError);
typedef HRESULT (PDBCALL *PfnPDBReadExecutableAt)(void *pvClient, DWORDLONG fo, DWORD cb, void *pv);
typedef HRESULT (PDBCALL *PfnPDBReadExecutableAtRVA)(void *pvClient, DWORD rva, DWORD cb, void *pv);
typedef HRESULT (PDBCALL *PfnPDBRestrictRegistry)(void *pvClient);
typedef HRESULT (PDBCALL *PfnPDBRestrictSymsrv)(void *pvClient);
typedef HRESULT (PDBCALL *PfnPDBRestrictSystemRoot)(void *pvClient);
typedef void (PDBCALL *PfnPDBNotifyMiscPath)(void *pvClient, const wchar_t *wszMiscPath);
typedef HRESULT (PDBCALL *PfnPDBReadCodeViewDebugData)(void *pvClient, DWORD *pcb, void *pv);
typedef HRESULT (PDBCALL *PfnPDBReadMiscDebugData)(void *pvClient, DWORD *pdwTimeStampExe, DWORD *pdwTimeStampDbg, DWORD *pdwSizeOfImage, DWORD *pcb, void *pv);
typedef HRESULT (PDBCALL *PfnPdbRestrictOriginalPath)(void *pvClient);
typedef HRESULT (PDBCALL *PfnPdbRestrictReferencePath)(void *pvClient);
typedef HRESULT (PDBCALL *PfnPdbRestrictDBG) (void *pvClient);

// type of callback arg to PDB::GetRawBytes
typedef BOOL (PDBCALL *PFNfReadPDBRawBytes)(const void *, long);

// WidenTi interface needs a couple of structures to communicate info back
// and forth.
struct OffMap {
    ULONG       offOld;
    ULONG       offNew;
};
typedef struct OffMap   OffMap;
typedef OffMap *        POffMap;

struct SymConvertInfo {
    ULONG       cbSyms;             // size necessary for converting a block
    ULONG       cSyms;              // count of symbols, necessary to allocate
                                    // mpoffOldoffNew array.
    BYTE *      pbSyms;             // block of symbols (output side)
    OffMap *    rgOffMap;           // OffMap rgOffMap[cSyms]
};
typedef struct SymConvertInfo   SymConvertInfo;
enum { wtiSymsNB09 = 0, wtiSymsNB10 = 1 };

// Filter values for PDBCopyTo
enum { 
    copyRemovePrivate       = 0x00000001,   // remove private debug information
    copyCreateNewSig        = 0x00000002,   // create new signature for target pdb
};

// PDBCopy callback signatures and function pointer types for PDB::CopyTo2 and CopyToW2
//
enum PCC {
    pccFilterPublics,
};

#if !defined(__cplusplus)
typedef enum PCC    PCC;
#endif  // __cplusplus

typedef BOOL (PDBCALL *PDBCOPYCALLBACK)();
typedef PDBCOPYCALLBACK (PDBCALL *PfnPDBCopyQueryCallback)(void *pvClientContext, PCC pcc);

// Return (true, pszNewPublic==NULL) to keep the name as is,
// (true, pszNewPublic!=NULL) changes name to pszNewPublic,
// false to discard public entirely.
//
typedef BOOL (PDBCALL *PfnPDBCopyFilterPublics)(
    void *          pvClientContext,
    DWORD           dwFilterFlags,
    unsigned int    offPublic,
    unsigned int    sectPublic,
    unsigned int    grfPublic,      // see cvinfo.h, definition of CV_PUBSYMFLAGS_e and
                                    // CV_PUBSYMFLAGS give the format of this bitfield.
    const wchar_t * szPublic,
    wchar_t **      pszNewPublic
    );

enum DBGTYPE {
    dbgtypeFPO,
    dbgtypeException,   // deprecated
    dbgtypeFixup,
    dbgtypeOmapToSrc,
    dbgtypeOmapFromSrc,
    dbgtypeSectionHdr,
#if !defined(VER60)
    dbgtypeTokenRidMap,
    dbgtypeXdata,
    dbgtypePdata,
    dbgtypeNewFPO,
    dbgtypeSectionHdrOrig,
#endif
    dbgtypeMax          // must be last!
};

typedef enum DBGTYPE DBGTYPE;

// We add a slight bit of structure to dbg blobs so we can record extra
// relevant information there.  Generally, the blobs are lifted right out
// of an image, and need some extra info anyway.  In the case of Xdata, we
// store RVA base of the Xdata there.  This is used to interpret the
// UnwindInfoAddress RVA in the IA64 Pdata entries.
//
enum VerDataBlob {
    vdbOne = 1,
    vdbXdataCur = vdbOne,
    vdbPdataCur = vdbOne,
};

// default blob header
//
typedef struct DbgBlob {
    ULONG   ver;
    ULONG   cbHdr;
    ULONG   cbData;
    //BYTE    rgbDataBlob[];    // Data follows, but to enable simple embedding,
                                // don't use a zero-sized array here.
} DbgBlob;

// "store rva of the base and va of image base" blob header
//
typedef struct DbgRvaVaBlob {
    ULONG       ver;
    ULONG       cbHdr;
    ULONG       cbData;
    ULONG       rvaDataBase;
    DWORDLONG   vaImageBase;
    ULONG       ulReserved1;    // reserved, must be 0
    ULONG       ulReserved2;    // reserved, must be 0
    //BYTE      rgbDataBlob[];  // Data follows, but to enable simple embedding,
                                // don't use a zero-sized array here.
} DbgRvaVaBlob;

// Linker data necessary for relinking an image.  Record contains two SZ strings
// off of the end of the record with two offsets from the base 
//
enum VerLinkInfo {
    vliOne = 1,
    vliTwo = 2,
    vliCur = vliTwo,
};

struct LinkInfo {
    ULONG           cb;             // size of the whole record.  computed as
                                    //  sizeof(LinkInfo) + strlen(szCwd) + 1 +
                                    //  strlen(szCommand) + 1
    ULONG           ver;            // version of this record (VerLinkInfo)
    ULONG           offszCwd;       // offset from base of this record to szCwd
    ULONG           offszCommand;   // offset from base of this record
    ULONG           ichOutfile;     // index of start of output file in szCommand
    ULONG           offszLibs;      // offset from base of this record to szLibs

    // The command includes the full path to the linker, the -re and -out:...
    // swithches.
    // A sample might look like the following:
    // "c:\program files\msdev\bin\link.exe -re -out:debug\foo.exe"
    // with ichOutfile being 48.
    // the -out switch is guaranteed to be the last item in the command line.
#ifdef __cplusplus
    VerLinkInfo Ver() const {
        return VerLinkInfo(ver);
    }
    long Cb() const {
        return cb;
    }
    char *     SzCwd() const {
        return (char *)((char *)(this) + offszCwd);
    }
    char *    SzCommand() const {
        return (char *)((char *)(this) + offszCommand);
    }
    char *    SzOutFile() const {
        return SzCommand() + ichOutfile;
    }
    LinkInfo() :
        cb(0), ver(vliCur), offszCwd(0), offszCommand(0), ichOutfile(0)
    {
    }
    char *    SzLibs() const {
        return (char *)((char *)(this) + offszLibs);
    }

#endif
};

#ifdef LNGNM
#ifdef __cplusplus
struct LinkInfoW : public LinkInfo
{
    wchar_t* SzCwdW() const {
        return (wchar_t *)((wchar_t *)(this) + offszCwd);
    }
    wchar_t* SzCommandW() const {
        return (wchar_t *)((wchar_t *)(this) + offszCommand);
    }
    wchar_t* SzOutFileW() const {
        return SzCommandW() + ichOutfile;
    }
    wchar_t* SzLibsW() const {
        return (wchar_t *)((wchar_t *)(this) + offszLibs);
    }
};
#else
typedef struct LinkInfo LinkInfoW;
#endif  // __cplusplus

typedef LinkInfoW * PLinkInfoW;

#endif  // LNGNM

typedef struct LinkInfo LinkInfo;
typedef LinkInfo *      PLinkInfo;


//
// Source (Src) info
//
// This is the source file server for virtual and real source code.
// It is structured as an index on the object file name concatenated
// with 
enum SrcVer {
    srcverOne = 19980827,
};

enum SrcCompress {
    srccompressNone,
    srccompressRLE,
    srccompressHuffman,
    srccompressLZ,
};

#ifdef LNGNM
struct tagSrcHeader {
#else
struct SrcHeader {
#endif
    unsigned long   cb;         // record length
    unsigned long   ver;        // header version
    unsigned long   sig;        // CRC of the data for uniqueness w/o full compare
    unsigned long   cbSource;   // count of bytes of the resulting source
    unsigned char   srccompress;// compression algorithm used
    union {
        unsigned char       grFlags;
        struct {
            unsigned char   fVirtual : 1;   // file is a virtual file (injected)
            unsigned char   pad : 7;        // must be zero
        };
    };
#ifndef LNGNM
    unsigned char   szNames[1]; // file names (szFile "\0" szObj "\0" szVirtual,
                                //  as in: "f.cpp" "\0" "f.obj" "\0" "*inj:1:f.obj")
                                // in the case of non-virtual files, szVirtual is
                                // the same as szFile.
#endif
};

#ifdef LNGNM
struct SrcHeader : public tagSrcHeader
{
    unsigned char szNames[1];   // see comment above
};

struct SrcHeaderW : public tagSrcHeader
{
    wchar_t szNames[1];   // see comment above
};

typedef struct SrcHeaderW    SrcHeaderW;
typedef SrcHeaderW *         PSrcHeaderW;
typedef const SrcHeaderW *   PCSrcHeaderW;

//cassert(offsetof(SrcHeader,szNames) == sizeof(tagSrcHeader));
//cassert(offsetof(SrcHeaderW,szNames) == sizeof(tagSrcHeader));

#endif      // LNGNM

typedef struct SrcHeader    SrcHeader;
typedef SrcHeader *         PSrcHeader;
typedef const SrcHeader *   PCSrcHeader;

// header used for storing the info and for output to clients who are reading
//
struct SrcHeaderOut {
    unsigned long   cb;         // record length
    unsigned long   ver;        // header version
    unsigned long   sig;        // CRC of the data for uniqueness w/o full compare
    unsigned long   cbSource;   // count of bytes of the resulting source
    unsigned long   niFile;
    unsigned long   niObj;
    unsigned long   niVirt;
    unsigned char   srccompress;// compression algorithm used
    union {
        unsigned char       grFlags;
        struct {
            unsigned char   fVirtual : 1;   // file is a virtual file (injected)
            unsigned char   pad : 7;        // must be zero
        };
    };
    short           sPad;
    union {
        void *      pvReserved1;
        __int64     pv64Reserved2;
    };
};

typedef struct SrcHeaderOut SrcHeaderOut;
typedef SrcHeaderOut *      PSrcHeaderOut;
typedef const SrcHeaderOut *PCSrcHeaderOut;

struct SrcHeaderBlock {
    __int32     ver;
    __int32     cb;
    struct {
        DWORD   dwLowDateTime;
        DWORD   dwHighDateTime;
    } ft;
    __int32     age;
    BYTE        rgbPad[44];
};

typedef struct SrcHeaderBlock   SrcHeaderBlock;


#ifdef __cplusplus

struct IStream;

// C++ Binding

PdbInterface PDB {                 // program database
    enum {
        intv  = PDBIntv,
#if defined(LNGNM)
        intvVC70Dep = PDBIntv70Dep,     // deprecated
#endif
        intvAlt = PDBIntvAlt,
        intvAlt2 = PDBIntvAlt2,
        intvAlt3 = PDBIntvAlt3,
    };

    static PDBAPI(BOOL)
           OpenValidate(
               LNGNM_CONST char *szPDB,
               LNGNM_CONST char *szPath,
               LNGNM_CONST char *szMode,
               SIG sig,
               AGE age,
               OUT EC* pec,
               OUT char szError[cbErrMax],
               OUT PDB **pppdb);

    static PDBAPI(BOOL)
           OpenValidateEx(
               LNGNM_CONST char *szPDB,
               LNGNM_CONST char *szPathOrig,
               LNGNM_CONST char *szSearchPath,
               LNGNM_CONST char *szMode,
               SIG sig,
               AGE age,
               OUT EC *pec,
               OUT char szError[cbErrMax],
               OUT PDB **pppdb);

    static PDBAPI(BOOL)
           Open(
               LNGNM_CONST char *szPDB,
               LNGNM_CONST char *szMode,
               SIG sigInitial,
               OUT EC *pec,
               OUT char szError[cbErrMax],
               OUT PDB **pppdb);

    static PDBAPI(BOOL)
           OpenValidate2(
               LNGNM_CONST char *szPDB,
               LNGNM_CONST char *szPath,
               LNGNM_CONST char *szMode,
               SIG sig,
               AGE age,
               long cbPage,
               OUT EC *pec,
               OUT char szError[cbErrMax],
               OUT PDB **pppdb);

    static PDBAPI(BOOL)
           OpenValidateEx2(
               LNGNM_CONST char *szPDB,
               LNGNM_CONST char *szPathOrig,
               LNGNM_CONST char *szSearchPath,
               LNGNM_CONST char *szMode,
               SIG sig,
               AGE age,
               long cbPage,
               OUT EC* pec,
               OUT char szError[cbErrMax],
               OUT PDB **pppdb);

    static PDBAPI(BOOL)
           OpenEx(
               LNGNM_CONST char *szPDB,
               LNGNM_CONST char *szMode,
               SIG sigInitial,
               long cbPage,
               OUT EC *pec,
               OUT char szError[cbErrMax],
               OUT PDB **pppdb);

    static PDBAPI(BOOL)
           OpenValidate3(
               const char *szExecutable,
               const char *szSearchPath,
               OUT EC *pec,
               OUT char szError[cbErrMax],
               OUT char szDbgPath[PDB_MAX_PATH],
               OUT DWORD *pfo,
               OUT DWORD *pcb,
               OUT PDB **pppdb);

    static PDBAPI(BOOL)
           OpenValidate4(
               const wchar_t *wszPDB,
               const char *szMode,
               PCSIG70 pcsig70,
               SIG sig,
               AGE age,
               OUT EC *pec,
               OUT wchar_t *wszError,
               size_t cchErrMax,
               OUT PDB **pppdb);

    static PDBAPI(BOOL) OpenInStream(
               IStream *pIStream,
               const char *szMode,
               OUT EC *pec,
               OUT wchar_t *wszError,
               size_t cchErrMax,
               OUT PDB **pppdb);

    static PDBAPI(BOOL) ExportValidateInterface(INTV intv);
    static PDBAPI(BOOL) ExportValidateImplementation(IMPV impv);

    static PDBAPI(IMPV) QueryImplementationVersionStatic();
    static PDBAPI(INTV) QueryInterfaceVersionStatic();

    virtual INTV QueryInterfaceVersion() pure;
    virtual IMPV QueryImplementationVersion() pure;
    virtual EC   QueryLastError(OUT char szError[cbErrMax]) pure;
    virtual char*QueryPDBName(OUT char szPDB[PDB_MAX_PATH]) pure;
    virtual SIG  QuerySignature() pure;
    virtual AGE  QueryAge() pure;
    virtual BOOL CreateDBI(const char* szTarget, OUT DBI** ppdbi) pure;
    virtual BOOL OpenDBI(const char* szTarget, const char* szMode, OUT DBI** ppdbi ) pure;
    virtual BOOL OpenTpi(const char* szMode, OUT TPI** pptpi) pure;

    virtual BOOL Commit() pure;
    virtual BOOL Close() pure;
    virtual BOOL OpenStream(const char* szStream, OUT Stream** ppstream) pure;
    virtual BOOL GetEnumStreamNameMap(OUT Enum** ppenum) pure;
    virtual BOOL GetRawBytes(PFNfReadPDBRawBytes pfnfSnarfRawBytes) pure;
    virtual IMPV QueryPdbImplementationVersion() pure;

    virtual BOOL OpenDBIEx(const char* szTarget, const char* szMode, OUT DBI** ppdbi, PfnFindDebugInfoFile pfn=0) pure;

    virtual BOOL CopyTo(const char *szDst, DWORD dwCopyFilter, DWORD dwReserved) pure;

    //
    // support for source file data
    //
    virtual BOOL OpenSrc(OUT Src** ppsrc) pure;

    virtual EC   QueryLastErrorExW(OUT wchar_t *wszError, size_t cchMax) pure;
    virtual wchar_t *QueryPDBNameExW(OUT wchar_t *wszPDB, size_t cchMax) pure;
    virtual BOOL QuerySignature2(PSIG70 psig70) pure;
    virtual BOOL CopyToW(const wchar_t *szDst, DWORD dwCopyFilter, DWORD dwReserved) pure;
    virtual BOOL fIsSZPDB() const pure;

    // Implemented only on 7.0 and above versions.
    //
    virtual BOOL OpenStreamW(const wchar_t * szStream, OUT Stream** ppstream) pure;

    // Implemented in both 6.0 and 7.0 builds

    virtual BOOL CopyToW2(
        const wchar_t *         szDst,
        DWORD                   dwCopyFilter,
        PfnPDBCopyQueryCallback pfnCallBack,
        void *                  pvClientContext
        ) pure;


    inline BOOL ValidateInterface()
    {
        return ExportValidateInterface(intv);
    }

    static PDBAPI(BOOL)
           Open2W(
               const wchar_t *wszPDB,
               const char *szMode,
               OUT EC *pec,
               OUT wchar_t *wszError,
               size_t cchErrMax,
               OUT PDB **pppdb);

    static PDBAPI(BOOL)
           OpenEx2W(
               const wchar_t *wszPDB,
               const char *szMode,
               long cbPage,
               OUT EC *pec,
               OUT wchar_t *wszError,
               size_t cchErrMax,
               OUT PDB **pppdb);

    static PDBAPI(BOOL)
           OpenValidate5(
               const wchar_t *wszExecutable,
               const wchar_t *wszSearchPath,
               void *pvClient,
               PfnPDBQueryCallback pfnQueryCallback,
               OUT EC *pec,
               OUT wchar_t *wszError,
               size_t cchErrMax,
               OUT PDB **pppdb);


};


// Review: a stream directory service would be more appropriate
// than Stream::Delete, ...

PdbInterface Stream {
    virtual long QueryCb() pure;
    virtual BOOL Read(long off, void* pvBuf, long* pcbBuf) pure;
    virtual BOOL Write(long off, void* pvBuf, long cbBuf) pure;
    virtual BOOL Replace(void* pvBuf, long cbBuf) pure;
    virtual BOOL Append(void* pvBuf, long cbBuf) pure;
    virtual BOOL Delete() pure;
    virtual BOOL Release() pure;
    virtual BOOL Read2(long off, void* pvBuf, long cbBuf) pure;
    virtual BOOL Truncate(long cb) pure;
};

PdbInterface StreamImage {
    static PDBAPI(BOOL) open(Stream* pstream, long cb, OUT StreamImage** ppsi);
    virtual long size() pure;
    virtual void* base() pure;
    virtual BOOL noteRead(long off, long cb, OUT void** ppv) pure;
    virtual BOOL noteWrite(long off, long cb, OUT void** ppv) pure;
    virtual BOOL writeBack() pure;
    virtual BOOL release() pure;
};

PdbInterface DBI {             // debug information
    enum { intv = PDBIntv };
    virtual IMPV QueryImplementationVersion() pure;
    virtual INTV QueryInterfaceVersion() pure;
    virtual BOOL OpenMod(const char* szModule, const char* szFile, OUT Mod** ppmod) pure;
    virtual BOOL DeleteMod(const char* szModule) pure;
    virtual BOOL QueryNextMod(Mod* pmod, Mod** ppmodNext) pure;
    virtual BOOL OpenGlobals(OUT GSI **ppgsi) pure;
    virtual BOOL OpenPublics(OUT GSI **ppgsi) pure;
    virtual BOOL AddSec(USHORT isect, USHORT flags, long off, long cb) pure;
#if defined(LNGNM) && (_MSC_VER >= 1300)
    //__declspec(deprecated)
#endif
    virtual BOOL QueryModFromAddr(USHORT isect, long off, OUT Mod** ppmod,
                    OUT USHORT* pisect, OUT long* poff, OUT long* pcb) pure;
    virtual BOOL QuerySecMap(OUT BYTE* pb, long* pcb) pure;
    virtual BOOL QueryFileInfo(OUT BYTE* pb, long* pcb) pure;
    virtual void DumpMods() pure;
    virtual void DumpSecContribs() pure;
    virtual void DumpSecMap() pure;

    virtual BOOL Close() pure;
    virtual BOOL AddThunkMap(long* poffThunkMap, unsigned nThunks, long cbSizeOfThunk,
                    struct SO* psoSectMap, unsigned nSects,
                    USHORT isectThunkTable, long offThunkTable) pure;
    virtual BOOL AddPublic(const char* szPublic, USHORT isect, long off) pure;
    virtual BOOL getEnumContrib(OUT Enum** ppenum) pure;
    virtual BOOL QueryTypeServer( ITSM itsm, OUT TPI** pptpi ) pure;
    virtual BOOL QueryItsmForTi( TI ti, OUT ITSM* pitsm ) pure;
    virtual BOOL QueryNextItsm( ITSM itsm, OUT ITSM *inext ) pure;
    virtual BOOL QueryLazyTypes() pure;
    virtual BOOL SetLazyTypes( BOOL fLazy ) pure;   // lazy is default and can only be turned off
    virtual BOOL FindTypeServers( OUT EC* pec, OUT char szError[cbErrMax] ) pure;
    virtual void DumpTypeServers() pure;
    virtual BOOL OpenDbg(DBGTYPE dbgtype, OUT Dbg **ppdbg) pure;
    virtual BOOL QueryDbgTypes(OUT DBGTYPE *pdbgtype, OUT long* pcDbgtype) pure;
    // apis to support EnC work
    virtual BOOL QueryAddrForSec(OUT USHORT* pisect, OUT long* poff, 
            USHORT imod, long cb, DWORD dwDataCrc, DWORD dwRelocCrc) pure;
    virtual BOOL QuerySupportsEC() pure;
    virtual BOOL QueryPdb( OUT PDB** pppdb ) pure;
    virtual BOOL AddLinkInfo(IN PLinkInfo ) pure;
    virtual BOOL QueryLinkInfo(PLinkInfo, OUT long * pcb) pure;
    // new to vc6
    virtual AGE  QueryAge() const pure;
    virtual void * QueryHeader() const pure;
    virtual void FlushTypeServers() pure;
    virtual BOOL QueryTypeServerByPdb(const char* szPdb, OUT ITSM* pitsm) pure;

#ifdef LNGNM        // Long filename support
    virtual BOOL OpenModW(const wchar_t* szModule, const wchar_t* szFile, OUT Mod** ppmod) pure;
    virtual BOOL DeleteModW(const wchar_t* szModule) pure;
    virtual BOOL AddPublicW(const wchar_t* szPublic, USHORT isect, long off, CV_pubsymflag_t cvpsf =0) pure;
    virtual BOOL QueryTypeServerByPdbW( const wchar_t* szPdb, OUT ITSM* pitsm ) pure;
    virtual BOOL AddLinkInfoW(IN PLinkInfoW ) pure;
    virtual BOOL AddPublic2(const char* szPublic, USHORT isect, long off, CV_pubsymflag_t cvpsf =0) pure;
    virtual USHORT QueryMachineType() const pure;
    virtual void SetMachineType(USHORT wMachine) pure;
    virtual void RemoveDataForRva( ULONG rva, ULONG cb ) pure;
    virtual bool FStripped() const pure;
    virtual BOOL QueryModFromAddr2(USHORT isect, long off, OUT Mod** ppmod,
                    OUT USHORT* pisect, OUT long* poff, OUT long* pcb,
                    OUT ULONG * pdwCharacteristics) pure;
#else
    virtual bool FStripped() const pure;
#endif
};

PdbInterface Mod {             // info for one module within DBI
    enum { intv = PDBIntv };
    virtual INTV QueryInterfaceVersion() pure;
    virtual IMPV QueryImplementationVersion() pure;
    virtual BOOL AddTypes(BYTE* pbTypes, long cb) pure;
    virtual BOOL AddSymbols(BYTE* pbSym, long cb) pure;
    virtual BOOL AddPublic(const char* szPublic, USHORT isect, long off) pure;
    virtual BOOL AddLines(const char* szSrc, USHORT isect, long offCon, long cbCon, long doff,
                          USHORT lineStart, BYTE* pbCoff, long cbCoff) pure;
    virtual BOOL AddSecContrib(USHORT isect, long off, long cb, ULONG dwCharacteristics) pure;
    virtual BOOL QueryCBName(OUT long* pcb) pure;
    virtual BOOL QueryName(OUT char szName[PDB_MAX_PATH], OUT long* pcb) pure;
    virtual BOOL QuerySymbols(BYTE* pbSym, long* pcb) pure;
    virtual BOOL QueryLines(BYTE* pbLines, long* pcb) pure;

    virtual BOOL SetPvClient(void *pvClient) pure;
    virtual BOOL GetPvClient(OUT void** ppvClient) pure;
    virtual BOOL QueryFirstCodeSecContrib(OUT USHORT* pisect, OUT long* poff, OUT long* pcb, OUT ULONG* pdwCharacteristics) pure;
//
// Make all users of this api use the real one, as this is exactly what it was
// supposed to query in the first place
//
#define QuerySecContrib QueryFirstCodeSecContrib

    virtual BOOL QueryImod(OUT USHORT* pimod) pure;
    virtual BOOL QueryDBI(OUT DBI** ppdbi) pure;
    virtual BOOL Close() pure;
    virtual BOOL QueryCBFile(OUT long* pcb) pure;
    virtual BOOL QueryFile(OUT char szFile[PDB_MAX_PATH], OUT long* pcb) pure;
    virtual BOOL QueryTpi(OUT TPI** pptpi) pure; // return this Mod's Tpi
    // apis to support EnC work
    virtual BOOL AddSecContribEx(USHORT isect, long off, long cb, ULONG dwCharacteristics, DWORD dwDataCrc, DWORD dwRelocCrc) pure;
    virtual BOOL QueryItsm(OUT USHORT* pitsm) pure;
    virtual BOOL QuerySrcFile(OUT char szFile[PDB_MAX_PATH], OUT long* pcb) pure;
    virtual BOOL QuerySupportsEC() pure;
    virtual BOOL QueryPdbFile(OUT char szFile[PDB_MAX_PATH], OUT long* pcb) pure;
    virtual BOOL ReplaceLines(BYTE* pbLines, long cb) pure;
#ifdef LNGNM
    // V7 line number support
    virtual bool GetEnumLines( EnumLines** ppenum ) pure;
    virtual bool QueryLineFlags( OUT DWORD* pdwFlags ) pure;    // what data is present?
    virtual bool QueryFileNameInfo( 
                    IN DWORD        fileId,                 // source file identifier
                    OUT wchar_t*    szFilename,             // file name string 
                    IN OUT DWORD*   pccFilename,            // length of string
                    OUT DWORD*      pChksumType,            // type of chksum
                    OUT BYTE*       pbChksum,               // pointer to buffer for chksum data
                    IN OUT DWORD*   pcbChksum               // number of bytes of chksum (in/out)
                    ) pure;         
    // Long filenames support
    virtual BOOL AddPublicW(const wchar_t* szPublic, USHORT isect, long off, CV_pubsymflag_t cvpsf =0) pure;
    virtual BOOL AddLinesW(const wchar_t* szSrc, USHORT isect, long offCon, long cbCon, long doff,
                          ULONG lineStart, BYTE* pbCoff, long cbCoff) pure;
    virtual BOOL QueryNameW(OUT wchar_t szName[PDB_MAX_PATH], OUT long* pcb) pure;
    virtual BOOL QueryFileW(OUT wchar_t szFile[PDB_MAX_PATH], OUT long* pcb) pure;
    virtual BOOL QuerySrcFileW(OUT wchar_t szFile[PDB_MAX_PATH], OUT long* pcb) pure;
    virtual BOOL QueryPdbFileW(OUT wchar_t szFile[PDB_MAX_PATH], OUT long* pcb) pure;
    virtual BOOL AddPublic2(const char* szPublic, USHORT isect, long off, CV_pubsymflag_t cvpsf =0) pure;
    virtual BOOL InsertLines(BYTE* pbLines, long cb) pure;
#endif
};

PdbInterface TPI {             // type info

    enum { intv = PDBIntv };

    virtual INTV QueryInterfaceVersion() pure;
    virtual IMPV QueryImplementationVersion() pure;

    virtual BOOL QueryTi16ForCVRecord(BYTE* pb, OUT TI16* pti) pure;
    virtual BOOL QueryCVRecordForTi16(TI16 ti, OUT BYTE* pb, IN OUT long* pcb) pure;
    virtual BOOL QueryPbCVRecordForTi16(TI16 ti, OUT BYTE** ppb) pure;
    virtual TI16 QueryTi16Min() pure;
    virtual TI16 QueryTi16Mac() pure;

    virtual long QueryCb() pure;
    virtual BOOL Close() pure;
    virtual BOOL Commit() pure;

    virtual BOOL QueryTi16ForUDT(LNGNM_CONST char *sz, BOOL fCase, OUT TI16* pti) pure;
    virtual BOOL SupportQueryTiForUDT() pure;

    // the new versions that truly take 32-bit types
    virtual BOOL fIs16bitTypePool() pure;
    virtual BOOL QueryTiForUDT(LNGNM_CONST char *sz, BOOL fCase, OUT TI* pti) pure;
    virtual BOOL QueryTiForCVRecord(BYTE* pb, OUT TI* pti) pure;
    virtual BOOL QueryCVRecordForTi(TI ti, OUT BYTE* pb, IN OUT long* pcb) pure;
    virtual BOOL QueryPbCVRecordForTi(TI ti, OUT BYTE** ppb) pure;
    virtual TI   QueryTiMin() pure;
    virtual TI   QueryTiMac() pure;
    virtual BOOL AreTypesEqual( TI ti1, TI ti2 ) pure;
    virtual BOOL IsTypeServed( TI ti ) pure;
#ifdef LNGNM
    virtual BOOL QueryTiForUDTW(const wchar_t *wcs, BOOL fCase, OUT TI* pti) pure;
#endif
};

PdbInterface GSI {
    enum { intv = PDBIntv };
    virtual INTV QueryInterfaceVersion() pure;
    virtual IMPV QueryImplementationVersion() pure;
    virtual BYTE* NextSym(BYTE* pbSym) pure;
    virtual BYTE* HashSym(const char* szName, BYTE* pbSym) pure;
    virtual BYTE* NearestSym(USHORT isect, long off, OUT long* pdisp) pure;      //currently only supported for publics
    virtual BOOL Close() pure;
    virtual BOOL getEnumThunk(USHORT isect, long off, OUT EnumThunk** ppenum) pure;
    virtual unsigned long OffForSym(BYTE *pbSym) pure;
    virtual BYTE* SymForOff(unsigned long off) pure;
#ifdef LNGNM
    virtual BYTE* HashSymW(const wchar_t *wcsName, BYTE* pbSym) pure;
#endif
    virtual BOOL getEnumByAddr(EnumSyms **ppEnum) pure;
};


PdbInterface NameMap {
    static PDBAPI(BOOL) open(PDB* ppdb, BOOL fWrite, OUT NameMap** ppnm);
    virtual BOOL close() pure;
    virtual BOOL reinitialize() pure;
    virtual BOOL getNi(const char* sz, OUT NI* pni) pure;
    virtual BOOL getName(NI ni, OUT const char** psz) pure;
    virtual BOOL getEnumNameMap(OUT Enum** ppenum) pure;
    virtual BOOL contains(const char* sz, OUT NI* pni) pure;
    virtual BOOL commit() pure;
    virtual BOOL isValidNi(NI ni) pure;
#ifdef LNGNM
    virtual BOOL getNiW(const wchar_t* sz, OUT NI* pni) pure;
    virtual BOOL getNameW(NI ni, OUT wchar_t* szName, IN OUT size_t * pcch) pure;
    virtual BOOL containsW(const wchar_t *sz, OUT NI* pni) pure;
    virtual BOOL containsUTF8(const char* sz, OUT NI* pni) pure;
    virtual BOOL getNiUTF8(const char *sz, OUT NI* pni) pure;
    virtual BOOL getNameA(NI ni, OUT const char ** psz) pure;
    virtual BOOL getNameW2(NI ni, OUT const wchar_t ** pwsz) pure;
#endif
};

#define __ENUM_INCLUDED__
PdbInterface Enum {
    virtual void release() pure;
    virtual void reset() pure;
    virtual BOOL next() pure;
};

PdbInterface EnumNameMap : Enum {
    virtual void get(OUT const char** psz, OUT NI* pni) pure;
};

PdbInterface EnumContrib : Enum {
    virtual void get(OUT USHORT* pimod, OUT USHORT* pisect, OUT long* poff, OUT long* pcb, OUT ULONG* pdwCharacteristics) pure;
    virtual void getCrcs(OUT DWORD* pcrcData, OUT DWORD* pcrcReloc ) pure;
    virtual bool fUpdate(IN long off, IN long cb) pure;
    virtual BOOL prev() pure;
    virtual BOOL clone( OUT EnumContrib **ppEnum ) pure;
    virtual BOOL locate( IN long isect, IN long off ) pure;
};

PdbInterface EnumThunk: Enum {
    virtual void get( OUT USHORT* pisect, OUT long* poff, OUT long* pcb ) pure;
};

PdbInterface EnumSyms : Enum {
    virtual void get( BYTE** ppbSym ) pure;
    virtual BOOL prev() pure;
    virtual BOOL clone( OUT EnumSyms **ppEnum ) pure;
    virtual BOOL locate( IN long isect, IN long off ) pure;
};
struct CV_Line_t;
struct CV_Column_t;
PdbInterface EnumLines: public Enum
{
    // 
    // Blocks of lines are always in offset order, lines within blocks are also ordered by offset
    //
    virtual bool getLines(  
        OUT DWORD*      fileId,     // id for the filename
        OUT DWORD*      poffset,    // offset part of address
        OUT WORD*       pseg,       // segment part of address
        OUT DWORD*      pcb,        // count of bytes of code described by this block
        IN OUT DWORD*   pcLines,    // number of lines (in/out)
        OUT CV_Line_t*  pLines      // pointer to buffer for line info
        ) = 0;
    virtual bool getLinesColumns(   
        OUT DWORD*      fileId,     // id for the filename      
        OUT DWORD*      poffset,    // offset part of address
        OUT WORD*       pseg,       // segment part of address
        OUT DWORD*      pcb,        // count of bytes of code described by this block
        IN OUT DWORD*   pcLines,    // number of lines (in/out)
        OUT CV_Line_t*  pLines,     // pointer to buffer for line info
        OUT CV_Column_t*pColumns    // pointer to buffer for column info
        ) = 0;
    virtual bool clone( 
        OUT EnumLines **ppEnum      // return pointer to the clone
        ) = 0;
};

//
// interface to use to widen type indices from 16 to 32 bits
// and store the results in a new location.
//
PdbInterface WidenTi {
public:
    static PDBAPI(BOOL)
    fCreate (
        WidenTi *&,
        unsigned cTypeInitialCache =256,
        BOOL fNB10Syms =wtiSymsNB09
        );

    virtual void
    release() pure;

    virtual BYTE /* TYPTYPE */ *
    pTypeWidenTi ( TI ti16, BYTE /* TYPTYPE */ * ) pure;

    virtual BYTE /* SYMTYPE */ *
    pSymWidenTi ( BYTE /* SYMTYPE */ * ) pure;

    virtual BOOL
    fTypeWidenTiNoCache ( BYTE * pbTypeDst, BYTE * pbTypeSrc, long & cbDst ) pure;

    virtual BOOL
    fSymWidenTiNoCache ( BYTE * pbSymDst, BYTE * pbSymSrc, long & cbDst ) pure;

    virtual BOOL
    fTypeNeedsWidening ( BYTE * pbType ) pure;

    virtual BOOL
    fSymNeedsWidening ( BYTE * pbSym ) pure;

    virtual BOOL
    freeRecord ( void * ) pure;

    // symbol block converters/query.  symbols start at doff from pbSymIn,
    // converted symbols will go at sci.pbSyms + doff, cbSyms are all including
    // doff.
    virtual BOOL
        fQuerySymConvertInfo (
        SymConvertInfo &    sciOut,
        BYTE *              pbSym,
        long                cbSym,
        int                 doff =0
        ) pure;

    virtual BOOL
    fConvertSymbolBlock (
        SymConvertInfo &    sciOut,
        BYTE *              pbSymIn,
        long                cbSymIn,
        int                 doff =0
        ) pure;
};

// interface for managing Dbg data
PdbInterface Dbg {
   // close Dbg Interface
   virtual BOOL Close() pure;
   // return number of elements (NOT bytes)
   virtual long QuerySize() pure;
   // reset enumeration index
   virtual void Reset() pure;
   // skip next celt elements (move enumeration index)
   virtual BOOL Skip(ULONG celt) pure;
   // query next celt elements into user-supplied buffer
   virtual BOOL QueryNext(ULONG celt, OUT void *rgelt) pure;
   // search for an element and fill in the entire struct given a field.
   // Only supported for the following debug types and fields:
   // DBG_FPO              'ulOffStart' field of FPO_DATA
   // DBG_FUNC             'StartingAddress' field of IMAGE_FUNCTION_ENTRY
   // DBG_OMAP             'rva' field of OMAP
   virtual BOOL Find(IN OUT void *pelt) pure;
   // remove debug data
   virtual BOOL Clear() pure;
   // append celt elements
   virtual BOOL Append(ULONG celt, const void *rgelt) pure;
   // replace next celt elements
   virtual BOOL ReplaceNext(ULONG celt, const void *rgelt) pure;
   // create a clone of this interface
   virtual BOOL Clone( Dbg** ppDbg ) pure;
};

PdbInterface Src {
    // close and commit the changes (when open for write)
    virtual bool
    Close() pure;

    // add a source file or file-ette
    virtual bool
    Add(IN PCSrcHeader psrcheader, IN const void * pvData) pure;

    // remove a file or file-ette or all of the injected code for
    // one particular compiland (using the object file name)
    virtual bool
    Remove(IN SZ_CONST szFile) pure;

    // query and copy the header/control data to the output buffer
    virtual bool
    QueryByName(IN SZ_CONST szFile, OUT PSrcHeaderOut psrcheaderOut) const pure;

    // copy the file data (the size of the buffer is in the SrcHeaderOut
    // structure) to the output buffer.
    virtual bool
    GetData(IN PCSrcHeaderOut pcsrcheader, OUT void * pvData) const pure;

    // create an enumerator to traverse all of the files included
    // in the mapping.
    virtual bool
    GetEnum(OUT EnumSrc ** ppenum) const pure;

    // Get the header block (master header) of the Src data.
    // Includes age, time stamp, version, and size of the master stream
    virtual bool
    GetHeaderBlock(SrcHeaderBlock & shb) const pure;
#ifdef LNGNM
    virtual bool RemoveW(IN wchar_t *wcsFile) pure;
    virtual bool QueryByNameW(IN wchar_t *wcsFile, OUT PSrcHeaderOut psrcheaderOut) const pure;
    virtual bool AddW(IN PCSrcHeaderW psrcheader, IN const void * pvData) pure;
#endif
};

PdbInterface EnumSrc : Enum {
    virtual void get(OUT PCSrcHeaderOut * ppcsrcheader) pure;
};


PdbInterface SrcHash {

    // Various types we need
    //
    
    // Tri-state return type
    //
    enum TriState {
        tsYes,
        tsNo,
        tsMaybe,
    };

    // Hash identifier
    //
    enum HID {
        hidNone,
        hidMD5,
        hidMax,
    };

    // Define machine independent types for storage of HashID and size_t
    //
    typedef __int32 HashID_t;
    typedef unsigned __int32 CbHash_t;

    // Create a SrcHash object with the usual two-stage construction technique
    //
    static PDBAPI(bool)
    FCreateSrcHash(OUT PSrcHash &);

    // Accumulate more bytes into the hash
    //
    virtual bool
    FHashBuffer(IN PCV pvBuf, IN size_t cbBuf) pure;

    // Query the hash id
    //
    virtual HashID_t
    HashID() const pure;

    // Query the size of the hash 
    //
    virtual CbHash_t
    CbHash() const pure;

    // Copy the hash bytes to the client buffer
    //
    virtual void
    GetHash(OUT PV pvHash, IN CbHash_t cbHash) const pure;

    // Verify the incoming hash against a target buffer of bytes
    // returning a yes it matches, no it doesn't, or indeterminate.
    //
    virtual TriState
    TsVerifyHash(
        IN HID,
        IN CbHash_t cbHash,
        IN PCV pvHash,
        IN size_t cbBuf,
        IN PCV pvBuf
        ) pure;

    // Reset this object to pristine condition
    //
    virtual bool
    FReset() pure;

    // Close off and release this object
    //
    virtual void
    Close() pure;
};

#endif  // __cplusplus

// ANSI C Binding

#if __cplusplus
extern "C" {
#endif

typedef BOOL (PDBCALL *PfnPDBOpen)(
    LNGNM_CONST char *,
    LNGNM_CONST char *,
    SIG,
    EC *,
    char [cbErrMax],
    PDB **);

PDBAPI(BOOL)
PDBOpen(
    LNGNM_CONST char *szPDB,
    LNGNM_CONST char *szMode,
    SIG sigInitial,
    OUT EC *pec,
    OUT char szError[cbErrMax],
    OUT PDB **pppdb);

PDBAPI(BOOL)
PDBOpenEx(
    LNGNM_CONST char *szPDB,
    LNGNM_CONST char *szMode,
    SIG sigInitial,
    long cbPage,
    OUT EC *pec,
    OUT char szError[cbErrMax],
    OUT PDB **pppdb);

PDBAPI(BOOL)
PDBOpen2W(
    const wchar_t *wszPDB,
    const char *szMode,
    OUT EC *pec,
    OUT wchar_t *wszError,
    size_t cchErrMax,
    OUT PDB **pppdb);

PDBAPI(BOOL)
PDBOpenEx2W(
    const wchar_t *wszPDB,
    const char *szMode,
    long cbPage,
    OUT EC *pec,
    OUT wchar_t *wszError,
    size_t cchErrMax,
    OUT PDB **pppdb);

PDBAPI(BOOL)
PDBOpenValidate(
    LNGNM_CONST char *szPDB,
    LNGNM_CONST char *szPath,
    LNGNM_CONST char *szMode,
    SIG sig,
    AGE age,
    OUT EC* pec,
    OUT char szError[cbErrMax],
    OUT PDB **pppdb);

PDBAPI(BOOL)
PDBOpenValidateEx(
    LNGNM_CONST char *szPDB,
    LNGNM_CONST char *szPathOrig,
    LNGNM_CONST char *szSearchPath,
    LNGNM_CONST char *szMode,
    SIG sig,
    AGE age,
    OUT EC *pec,
    OUT char szError[cbErrMax],
    OUT PDB **pppdb);

PDBAPI(BOOL)
PDBOpenValidate2(
    LNGNM_CONST char *szPDB,
    LNGNM_CONST char *szPath,
    LNGNM_CONST char *szMode,
    SIG sig,
    AGE age,
    long cbPage,
    OUT EC *pec,
    OUT char szError[cbErrMax],
    OUT PDB **pppdb);

PDBAPI(BOOL)
PDBOpenValidateEx2(
    LNGNM_CONST char *szPDB,
    LNGNM_CONST char *szPathOrig,
    LNGNM_CONST char *szSearchPath,
    LNGNM_CONST char *szMode,
    SIG sig,
    AGE age,
    long cbPage,
    OUT EC* pec,
    OUT char szError[cbErrMax],
    OUT PDB **pppdb);

PDBAPI(BOOL)
PDBOpenValidate3(
    const char *szExecutable,
    const char *szSearchPath,
    OUT EC *pec,
    OUT char szError[cbErrMax],
    OUT char szDbgPath[PDB_MAX_PATH],
    OUT DWORD *pfo,
    OUT DWORD *pcb,
    OUT PDB **pppdb);

PDBAPI(BOOL)
PDBOpenValidate4(
    const wchar_t *wszPDB,
    const char *szMode,
    PCSIG70 pcsig70,
    SIG sig,
    AGE age,
    OUT EC *pec,
    OUT wchar_t *wszError,
    size_t cchErrMax,
    OUT PDB **pppdb);

PDBAPI(BOOL)
PDBOpenValidate5(
    const wchar_t *wszExecutable,
    const wchar_t *wszSearchPath,
    void *pvClient,
    PfnPDBQueryCallback pfnQueryCallback,
    OUT EC *pec,
    OUT wchar_t *wszError,
    size_t cchErrMax,
    OUT PDB **pppdb);

// a dbi client should never call PDBExportValidateInterface directly - use PDBValidateInterface
PDBAPI(BOOL)
PDBExportValidateInterface(
    INTV intv);

__inline BOOL PDBValidateInterface(void)
{
    return PDBExportValidateInterface(PDBIntv);
}

typedef BOOL (PDBCALL *PfnPDBExportValidateInterface)(INTV);

__inline BOOL PDBValidateInterfacePfn(PfnPDBExportValidateInterface pfn)
{
    return (*pfn)(PDBIntv);
}

PDBAPI(EC)     PDBQueryLastError(PDB *ppdb, OUT char szError[cbErrMax]);
PDBAPI(INTV)   PDBQueryInterfaceVersion(PDB* ppdb);
PDBAPI(IMPV)   PDBQueryImplementationVersion(PDB* ppdb);
PDBAPI(char*)  PDBQueryPDBName(PDB* ppdb, OUT char szPDB[PDB_MAX_PATH]);
PDBAPI(SIG)    PDBQuerySignature(PDB* ppdb);
PDBAPI(BOOL)   PDBQuerySignature2(PDB* ppdb, PSIG70 psig70);
PDBAPI(AGE)    PDBQueryAge(PDB* ppdb);
PDBAPI(BOOL)   PDBCreateDBI(PDB* ppdb, const char* szTarget, OUT DBI** ppdbi);
PDBAPI(BOOL)   PDBOpenDBIEx(PDB* ppdb, const char* szMode, const char* szTarget, OUT DBI** ppdbi, PfnFindDebugInfoFile pfn);
PDBAPI(BOOL)   PDBOpenDBI(PDB* ppdb, const char* szMode, const char* szTarget, OUT DBI** ppdbi);
PDBAPI(BOOL)   PDBOpenTpi(PDB* ppdb, const char* szMode, OUT TPI** pptpi);
PDBAPI(BOOL)   PDBCommit(PDB* ppdb);
PDBAPI(BOOL)   PDBClose(PDB* ppdb);
PDBAPI(BOOL)   PDBOpenStream(PDB* ppdb, const char* szStream, OUT Stream** ppstream);
PDBAPI(BOOL)   PDBCopyTo(PDB *ppdb, const char *szTargetPdb, DWORD dwCopyFilter, DWORD dwReserved);
PDBAPI(BOOL)   PDBCopyToW(PDB *ppdb, const wchar_t *szTargetPdb, DWORD dwCopyFilter, DWORD dwReserved);
PDBAPI(BOOL)   PDBfIsSZPDB(PDB *ppdb);
PDBAPI(BOOL)   PDBCopyToW2(PDB *ppdb, const wchar_t *szTargetPdb, DWORD dwCopyFilter, PfnPDBCopyQueryCallback pfnCallBack, void * pvClientContext);

PDBAPI(INTV)   DBIQueryInterfaceVersion(DBI* pdbi);
PDBAPI(IMPV)   DBIQueryImplementationVersion(DBI* pdbi);
PDBAPI(BOOL)   DBIOpenMod(DBI* pdbi, const char* szModule, const char* szFile, OUT Mod** ppmod);
PDBAPI(BOOL)   DBIDeleteMod(DBI* pdbi, const char* szModule);
PDBAPI(BOOL)   DBIQueryNextMod(DBI* pdbi, Mod* pmod, Mod** ppmodNext);
PDBAPI(BOOL)   DBIOpenGlobals(DBI* pdbi, OUT GSI **ppgsi);
PDBAPI(BOOL)   DBIOpenPublics(DBI* pdbi, OUT GSI **ppgsi);
PDBAPI(BOOL)   DBIAddSec(DBI* pdbi, USHORT isect, USHORT flags, long off, long cb);
PDBAPI(BOOL)   DBIAddPublic(DBI* pdbi, const char* szPublic, USHORT isect, long off);
PDBAPI(BOOL)   DBIQueryModFromAddr(DBI* pdbi, USHORT isect, long off, OUT Mod** ppmod, OUT USHORT* pisect, OUT long* poff, OUT long* pcb);
#ifdef LNGNM
PDBAPI(BOOL)   DBIQueryModFromAddr2(DBI* pdbi, USHORT isect, long off, OUT Mod** ppmod, OUT USHORT* pisect, OUT long* poff, OUT long* pcb, OUT ULONG *pdwCharacteristics);
#endif
PDBAPI(BOOL)   DBIQuerySecMap(DBI* pdbi, OUT BYTE* pb, long* pcb);
PDBAPI(BOOL)   DBIQueryFileInfo(DBI* pdbi, OUT BYTE* pb, long* pcb);
PDBAPI(BOOL)   DBIQuerySupportsEC(DBI* pdbi);
PDBAPI(void)   DBIDumpMods(DBI* pdbi);
PDBAPI(void)   DBIDumpSecContribs(DBI* pdbi);
PDBAPI(void)   DBIDumpSecMap(DBI* pdbi);
PDBAPI(BOOL)   DBIClose(DBI* pdbi);
PDBAPI(BOOL)   DBIAddThunkMap(DBI* pdbi, long* poffThunkMap, unsigned nThunks, long cbSizeOfThunk,
                              struct SO* psoSectMap, unsigned nSects, USHORT isectThunkTable, long offThunkTable);
PDBAPI(BOOL)   DBIGetEnumContrib(DBI* pdbi, OUT Enum** ppenum);
PDBAPI(BOOL)   DBIQueryTypeServer(DBI* pdbi, ITSM itsm, OUT TPI** pptpi );
PDBAPI(BOOL)   DBIQueryItsmForTi(DBI* pdbi, TI ti, OUT ITSM* pitsm );
PDBAPI(BOOL)   DBIQueryNextItsm(DBI* pdbi, ITSM itsm, OUT ITSM *inext );
PDBAPI(BOOL)   DBIQueryLazyTypes(DBI* pdbi);
PDBAPI(BOOL)   DBIFindTypeServers( DBI* pdbi, OUT EC* pec, OUT char szError[cbErrMax] );
PDBAPI(BOOL)   DBIOpenDbg(DBI* pdbi, DBGTYPE dbgtype, OUT Dbg **ppdbg);
PDBAPI(BOOL)   DBIQueryDbgTypes(DBI* pdbi, OUT DBGTYPE *pdbgtype, OUT long* pcDbgtype);
PDBAPI(BOOL)   DBIAddLinkInfo(DBI* pdbi, IN PLinkInfo);
PDBAPI(BOOL)   DBIQueryLinkInfo(DBI* pdbi, PLinkInfo, IN OUT long * pcb);
PDBAPI(BOOL)   DBIFStripped(DBI* pdbi);

PDBAPI(INTV)   ModQueryInterfaceVersion(Mod* pmod);
PDBAPI(IMPV)   ModQueryImplementationVersion(Mod* pmod);
PDBAPI(BOOL)   ModAddTypes(Mod* pmod, BYTE* pbTypes, long cb);
PDBAPI(BOOL)   ModAddSymbols(Mod* pmod, BYTE* pbSym, long cb);
PDBAPI(BOOL)   ModAddPublic(Mod* pmod, const char* szPublic, USHORT isect, long off);
PDBAPI(BOOL)   ModAddLines(Mod* pmod, const char* szSrc, USHORT isect, long offCon, long cbCon, long doff,
                           USHORT lineStart, BYTE* pbCoff, long cbCoff);
PDBAPI(BOOL)   ModAddSecContrib(Mod * pmod, USHORT isect, long off, long cb, ULONG dwCharacteristics);
PDBAPI(BOOL)   ModQueryCBName(Mod* pmod, OUT long* pcb);
PDBAPI(BOOL)   ModQueryName(Mod* pmod, OUT char szName[PDB_MAX_PATH], OUT long* pcb);
PDBAPI(BOOL)   ModQuerySymbols(Mod* pmod, BYTE* pbSym, long* pcb);
PDBAPI(BOOL)   ModQueryLines(Mod* pmod, BYTE* pbLines, long* pcb);
PDBAPI(BOOL)   ModSetPvClient(Mod* pmod, void *pvClient);
PDBAPI(BOOL)   ModGetPvClient(Mod* pmod, OUT void** ppvClient);
PDBAPI(BOOL)   ModQuerySecContrib(Mod* pmod, OUT USHORT* pisect, OUT long* poff, OUT long* pcb, OUT ULONG* pdwCharacteristics);
PDBAPI(BOOL)   ModQueryFirstCodeSecContrib(Mod* pmod, OUT USHORT* pisect, OUT long* poff, OUT long* pcb, OUT ULONG* pdwCharacteristics);
PDBAPI(BOOL)   ModQueryImod(Mod* pmod, OUT USHORT* pimod);
PDBAPI(BOOL)   ModQueryDBI(Mod* pmod, OUT DBI** ppdbi);
PDBAPI(BOOL)   ModClose(Mod* pmod);
PDBAPI(BOOL)   ModQueryCBFile(Mod* pmod, OUT long* pcb);
PDBAPI(BOOL)   ModQueryFile(Mod* pmod, OUT char szFile[PDB_MAX_PATH], OUT long* pcb);
PDBAPI(BOOL)   ModQuerySrcFile(Mod* pmod, OUT char szFile[PDB_MAX_PATH], OUT long* pcb);
PDBAPI(BOOL)   ModQueryPdbFile(Mod* pmod, OUT char szFile[PDB_MAX_PATH], OUT long* pcb);
PDBAPI(BOOL)   ModQuerySupportsEC(Mod* pmod);
PDBAPI(BOOL)   ModQueryTpi(Mod* pmod, OUT TPI** pptpi);
PDBAPI(BOOL)   ModReplaceLines(Mod* pmod, BYTE* pbLines, long cb);

PDBAPI(INTV)   TypesQueryInterfaceVersion(TPI* ptpi);
PDBAPI(IMPV)   TypesQueryImplementationVersion(TPI* ptpi);
// can't use the same api's for 32-bit TIs.
PDBAPI(BOOL)   TypesQueryTiForCVRecordEx(TPI* ptpi, BYTE* pb, OUT TI* pti);
PDBAPI(BOOL)   TypesQueryCVRecordForTiEx(TPI* ptpi, TI ti, OUT BYTE* pb, IN OUT long* pcb);
PDBAPI(BOOL)   TypesQueryPbCVRecordForTiEx(TPI* ptpi, TI ti, OUT BYTE** ppb);
PDBAPI(TI)     TypesQueryTiMinEx(TPI* ptpi);
PDBAPI(TI)     TypesQueryTiMacEx(TPI* ptpi);
PDBAPI(long)   TypesQueryCb(TPI* ptpi);
PDBAPI(BOOL)   TypesClose(TPI* ptpi);
PDBAPI(BOOL)   TypesCommit(TPI* ptpi);
PDBAPI(BOOL)   TypesQueryTiForUDTEx(TPI* ptpi, LNGNM_CONST char *sz, BOOL fCase, OUT TI* pti);
PDBAPI(BOOL)   TypesSupportQueryTiForUDT(TPI*);
PDBAPI(BOOL)   TypesfIs16bitTypePool(TPI*);
// Map all old ones to new ones for new compilands.
#define TypesQueryTiForCVRecord     TypesQueryTiForCVRecordEx
#define TypesQueryCVRecordForTi     TypesQueryCVRecordForTiEx
#define TypesQueryPbCVRecordForTi   TypesQueryPbCVRecordForTiEx
#define TypesQueryTiMin             TypesQueryTiMinEx
#define TypesQueryTiMac             TypesQueryTiMacEx
#define TypesQueryTiForUDT          TypesQueryTiForUDTEx
PDBAPI(BOOL)    TypesAreTypesEqual( TPI* ptpi, TI ti1, TI ti2 );
PDBAPI(BOOL)    TypesIsTypeServed( TPI* ptpi, TI ti );

PDBAPI(BYTE*)  GSINextSym (GSI* pgsi, BYTE* pbSym);
PDBAPI(BYTE*)  GSIHashSym (GSI* pgsi, const char* szName, BYTE* pbSym);
PDBAPI(BYTE*)  GSINearestSym (GSI* pgsi, USHORT isect, long off,OUT long* pdisp);//currently only supported for publics
PDBAPI(BOOL)   GSIClose(GSI* pgsi);
PDBAPI(unsigned long)   GSIOffForSym( GSI* pgsi, BYTE* pbSym );
PDBAPI(BYTE*)   GSISymForOff( GSI* pgsi, unsigned long off );

PDBAPI(long)   StreamQueryCb(Stream* pstream);
PDBAPI(BOOL)   StreamRead(Stream* pstream, long off, void* pvBuf, long* pcbBuf);
PDBAPI(BOOL)   StreamWrite(Stream* pstream, long off, void* pvBuf, long cbBuf);
PDBAPI(BOOL)   StreamReplace(Stream* pstream, void* pvBuf, long cbBuf);
PDBAPI(BOOL)   StreamAppend(Stream* pstream, void* pvBuf, long cbBuf);
PDBAPI(BOOL)   StreamDelete(Stream* pstream);
PDBAPI(BOOL)   StreamTruncate(Stream* pstream, long cb);
PDBAPI(BOOL)   StreamRelease(Stream* pstream);

PDBAPI(BOOL)   StreamImageOpen(Stream* pstream, long cb, OUT StreamImage** ppsi);
PDBAPI(void*)  StreamImageBase(StreamImage* psi);
PDBAPI(long)   StreamImageSize(StreamImage* psi);
PDBAPI(BOOL)   StreamImageNoteRead(StreamImage* psi, long off, long cb, OUT void** ppv);
PDBAPI(BOOL)   StreamImageNoteWrite(StreamImage* psi, long off, long cb, OUT void** ppv);
PDBAPI(BOOL)   StreamImageWriteBack(StreamImage* psi);
PDBAPI(BOOL)   StreamImageRelease(StreamImage* psi);

PDBAPI(BOOL)   NameMapOpen(PDB* ppdb, BOOL fWrite, OUT NameMap** ppnm);
PDBAPI(BOOL)   NameMapClose(NameMap* pnm);
PDBAPI(BOOL)   NameMapReinitialize(NameMap* pnm);
PDBAPI(BOOL)   NameMapGetNi(NameMap* pnm, const char* sz, OUT NI* pni);
PDBAPI(BOOL)   NameMapGetName(NameMap* pnm, NI ni, OUT const char** psz);
PDBAPI(BOOL)   NameMapGetEnumNameMap(NameMap* pnm, OUT Enum** ppenum);
PDBAPI(BOOL)   NameMapCommit(NameMap* pnm);

PDBAPI(void)   EnumNameMapRelease(EnumNameMap* penum);
PDBAPI(void)   EnumNameMapReset(EnumNameMap* penum);
PDBAPI(BOOL)   EnumNameMapNext(EnumNameMap* penum);
PDBAPI(void)   EnumNameMapGet(EnumNameMap* penum, OUT const char** psz, OUT NI* pni);

PDBAPI(void)   EnumContribRelease(EnumContrib* penum);
PDBAPI(void)   EnumContribReset(EnumContrib* penum);
PDBAPI(BOOL)   EnumContribNext(EnumContrib* penum);
PDBAPI(void)   EnumContribGet(EnumContrib* penum, OUT USHORT* pimod, OUT USHORT* pisect, OUT long* poff, OUT long* pcb, OUT ULONG* pdwCharacteristics);
PDBAPI(void)   EnumContribGetCrcs(EnumContrib* penum, OUT DWORD* pcrcData, OUT DWORD* pcrcReloc);
PDBAPI(BOOL)   EnumContribfUpdate(EnumContrib* penum, IN long off, IN long cb);

PDBAPI(SIG)    SigForPbCb(BYTE* pb, size_t cb, SIG sig);
PDBAPI(void)   TruncStFromSz(char *stDst, const char *szSrc, size_t cbSrc);

PDBAPI(BOOL)   DbgClose(Dbg *pdbg);
PDBAPI(long)   DbgQuerySize(Dbg *pdbg);
PDBAPI(void)   DbgReset(Dbg *pdbg);
PDBAPI(BOOL)   DbgSkip(Dbg *pdbg, ULONG celt);
PDBAPI(BOOL)   DbgQueryNext(Dbg *pdbg, ULONG celt, OUT void *rgelt);
PDBAPI(BOOL)   DbgFind(Dbg *pdbg, IN OUT void *pelt);
PDBAPI(BOOL)   DbgClear(Dbg *pdbg);
PDBAPI(BOOL)   DbgAppend(Dbg *pdbg, ULONG celt, const void *rgelt);
PDBAPI(BOOL)   DbgReplaceNext(Dbg *pdbg, ULONG celt, const void *rgelt);

#if __cplusplus
};
#endif

struct SO {
    long off;
    USHORT isect;
    unsigned short pad;
};

#ifndef cbNil
#define cbNil   ((long)-1)
#endif
#define tsNil   ((TPI*)0)
#define tiNil   ((TI)0)
#define imodNil ((USHORT)(-1))

#define pdbWrite                "w"
#define pdbRead                 "r"
#define pdbGetTiOnly            "i"
#define pdbGetRecordsOnly       "c"
#define pdbFullBuild            "f"
#define pdbTypeAppend           "a"
#define pdbRepro                "z"
#define pdbFSCompress           "C"

#endif // __PDB_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\windbg\callswin.h ===
/*++

Copyright (c) 1992-2002  Microsoft Corporation

Module Name:

    callswin.h

Abstract:

    This module contains the main line code for display of calls window.

Environment:

    Win32, User Mode

--*/

#ifndef __CALLSWIN_H__
#define __CALLSWIN_H__

#define MAX_FRAMES  1000

class CALLSWIN_DATA : public SINGLE_CHILDWIN_DATA
{
public:
    ULONG m_Flags;
    ULONG m_Frames;

    // Set in ReadState.
    ULONG m_FramesFound;
    ULONG m_TextOffset;
    ULONG m_WarningLine;

    static HMENU s_ContextMenu;
    
    CALLSWIN_DATA();

    virtual void Validate();

    virtual HRESULT ReadState(void);
    
    virtual void Copy();

    virtual BOOL CanWriteTextToFile(void);
    virtual HRESULT WriteTextToFile(HANDLE File);
    
    virtual HMENU GetContextMenu(void);
    virtual void  OnContextMenuSelection(UINT Item);
    
    virtual HRESULT CodeExprAtCaret(PSTR Expr, PULONG64 Offset);
    virtual HRESULT StackFrameAtCaret(PDEBUG_STACK_FRAME pFrame);
    
    virtual BOOL OnCreate(void);
    virtual LRESULT OnCommand(WPARAM wParam, LPARAM lParam);
    virtual LRESULT OnVKeyToItem(WPARAM wParam, LPARAM lParam);
    virtual void OnUpdate(UpdateType Type);

    virtual ULONG GetWorkspaceSize(void);
    virtual PUCHAR SetWorkspace(PUCHAR Data);
    virtual PUCHAR ApplyWorkspace1(PUCHAR Data, PUCHAR End);

    void SyncUiWithFlags(ULONG Changed);
    ULONG SelectionToFrame(void);
};
typedef CALLSWIN_DATA *PCALLSWIN_DATA;

#endif // #ifndef __CALLSWIN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\windbg\cmdwin.h ===
/*++

Copyright (c) 1992-2002  Microsoft Corporation

Module Name:

    ncmdwin.h

Abstract:

    Command Window data structure and definition
    
Environment:

    Win32, User Mode

--*/

extern BOOL g_AutoCmdScroll;

class CMDWIN_DATA : public COMMONWIN_DATA
{
public:
    //
    // Internal class
    //
    class HISTORY_LIST : public LIST_ENTRY
    {
    public:
        PTSTR           m_psz;

        HISTORY_LIST()
        {
            InitializeListHead( (PLIST_ENTRY) this );
            m_psz = NULL;
        }

        virtual ~HISTORY_LIST()
        {
            RemoveEntryList( (PLIST_ENTRY) this );

            if (m_psz) {
                free(m_psz);
            }
        }
    };

public:
    //
    // Used to resize the divided windows.
    //
    BOOL                m_bTrackingMouse;
    int                 m_nDividerPosition;
    int                 m_EditHeight;

    //
    // Handle to the two main cmd windows.
    //
    HWND                m_hwndHistory;
    HWND                m_hwndEdit;
    BOOL                m_bHistoryActive;

    // Prompt display static text control.
    HWND                m_Prompt;
    ULONG               m_PromptWidth;
    
    HISTORY_LIST        m_listHistory;

    // Character index to place output at.
    LONG                m_OutputIndex;
    BOOL                m_OutputIndexAtEnd;

    CHARRANGE           m_FindSel;
    ULONG               m_FindFlags;

    BOOL                m_Wrap;
    BOOL                m_TabDown;
    
    static HMENU s_ContextMenu;

    CMDWIN_DATA();

    virtual void Validate();

    virtual void SetFont(ULONG FontIndex);

    virtual BOOL CanCopy();
    virtual BOOL CanCut();
    virtual BOOL CanPaste();
    virtual void Copy();
    virtual void Cut();
    virtual void Paste();
    virtual BOOL CanSelectAll();
    virtual void SelectAll();
    
    virtual BOOL CanWriteTextToFile(void);
    virtual HRESULT WriteTextToFile(HANDLE File);
    
    virtual HMENU GetContextMenu(void);
    virtual void  OnContextMenuSelection(UINT Item);
    
    virtual void Find(PTSTR Text, ULONG Flags, BOOL FromDlg);
    
    // Functions called in response to WM messages
    virtual BOOL OnCreate(void);
    virtual LRESULT OnCommand(WPARAM wParam, LPARAM lParam);
    virtual void OnSetFocus(void);
    virtual void OnSize(void);
    virtual void OnButtonDown(ULONG Button);
    virtual void OnButtonUp(ULONG Button);
    virtual void OnMouseMove(ULONG Modifiers, ULONG X, ULONG Y);
    virtual LRESULT OnNotify(WPARAM wParam, LPARAM lParam);
    virtual void OnUpdate(UpdateType Type);

    virtual ULONG GetWorkspaceSize(void);
    virtual PUCHAR SetWorkspace(PUCHAR Data);
    virtual PUCHAR ApplyWorkspace1(PUCHAR Data, PUCHAR End);

    virtual void UpdateColors(void);
    
    void MoveDivider(int Pos);
    void AddCmdToHistory(PCSTR);
    void AddText(PTSTR Text, COLORREF Fg, COLORREF Bg);
    void Clear(void);
    void SetWordWrap(BOOL Wrap);
    void ResizeChildren(BOOL PromptChange);
};
typedef CMDWIN_DATA *PCMDWIN_DATA;

void ClearCmdWindow(void);
BOOL CmdOutput(PTSTR pszStr, COLORREF Fg, COLORREF Bg);
void CmdLogFmt(PCTSTR buf, ...);
int  CmdExecuteCmd(PCTSTR, UiCommand);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\windbg\cmdwin.cpp ===
/*++

Copyright (c) 1997-2002  Microsoft Corporation

Module Name:

    cmdwin.cpp

Abstract:

    New command window UI.

--*/

#include "precomp.hxx"
#pragma hdrstop

#define MAX_CMDWIN_LINES 30000

// Minimum window pane size.
#define MIN_PANE_SIZE 20

BOOL g_AutoCmdScroll = TRUE;

HMENU CMDWIN_DATA::s_ContextMenu;

#define CMDWIN_CONTEXT_ID_BASE 0x100
#define ID_WORD_WRAP 0

TBBUTTON g_CmdWinTbButtons[] =
{
    TEXT_TB_BTN(IDM_EDIT_ADD_TO_COMMAND_HISTORY, "Add to Command Output", 0),
    TEXT_TB_BTN(IDM_EDIT_CLEAR_COMMAND_HISTORY, "Clear Command Output", 0),
    SEP_TB_BTN(),
    TEXT_TB_BTN(ID_WORD_WRAP, "Word wrap", 0),
};

#define NUM_CMDWIN_MENU_BUTTONS \
    (sizeof(g_CmdWinTbButtons) / sizeof(g_CmdWinTbButtons[0]))

//
//
//
CMDWIN_DATA::CMDWIN_DATA()
    // State buffer isn't currently used.
    : COMMONWIN_DATA(256)
{
    m_enumType = CMD_WINDOW;
    m_bTrackingMouse = FALSE;
    m_nDividerPosition = 0;
    m_EditHeight = 0;
    m_hwndHistory = NULL;
    m_hwndEdit = NULL;
    m_bHistoryActive = FALSE;
    m_Prompt = NULL;
    m_PromptWidth = 0;
    m_OutputIndex = 0;
    m_OutputIndexAtEnd = TRUE;
    m_FindSel.cpMin = 1;
    m_FindSel.cpMax = 0;
    m_FindFlags = 0;
    m_TabDown = FALSE;
}

void
CMDWIN_DATA::Validate()
{
    COMMONWIN_DATA::Validate();

    Assert(CMD_WINDOW == m_enumType);

    Assert(m_hwndHistory);
    Assert(m_hwndEdit);
}

BOOL 
CMDWIN_DATA::CanWriteTextToFile()
{
    return TRUE;
}

HRESULT
CMDWIN_DATA::WriteTextToFile(HANDLE File)
{
    return RicheditWriteToFile(m_hwndHistory, File);
}

HMENU
CMDWIN_DATA::GetContextMenu(void)
{
    // Disable the context menu for now because it interferes
    // with right-click copy and paste.
#ifdef CMD_CONTEXT_MENU
    CheckMenuItem(s_ContextMenu, ID_WORD_WRAP + CMDWIN_CONTEXT_ID_BASE,
                  MF_BYCOMMAND | (m_Wrap ? MF_CHECKED : 0));
    
    return s_ContextMenu;
#else
    return NULL;
#endif
}

void
CMDWIN_DATA::OnContextMenuSelection(UINT Item)
{
    // Disable the context menu for now because it interferes
    // with right-click copy and paste.
#ifdef CMD_CONTEXT_MENU
    Item -= CMDWIN_CONTEXT_ID_BASE;
    
    switch(Item)
    {
    case ID_WORD_WRAP:
        SetWordWrap(!m_Wrap);
        break;
    default:
        SendMessage(g_hwndFrame, WM_COMMAND, MAKELONG(Item, 1), 0);
        break;
    }
#endif
}
    
void
CMDWIN_DATA::Find(PTSTR Text, ULONG Flags, BOOL FromDlg)
{
    RicheditFind(m_hwndHistory, Text, Flags,
                 &m_FindSel, &m_FindFlags, FALSE);
}

BOOL
CMDWIN_DATA::OnCreate(void)
{
    if (s_ContextMenu == NULL)
    {
        s_ContextMenu = CreateContextMenuFromToolbarButtons
            (NUM_CMDWIN_MENU_BUTTONS, g_CmdWinTbButtons,
             CMDWIN_CONTEXT_ID_BASE);
        if (s_ContextMenu == NULL)
        {
            return FALSE;
        }
    }
    
    m_EditHeight = 3 * m_Font->Metrics.tmHeight / 2;
    m_nDividerPosition = m_Size.cy - m_EditHeight;

    m_hwndHistory = CreateWindowEx(
        WS_EX_CLIENTEDGE,                           // Extended style
        RICHEDIT_CLASS,                             // class name
        NULL,                                       // title
        WS_CLIPSIBLINGS
        | WS_CHILD | WS_VISIBLE
        | WS_HSCROLL | WS_VSCROLL
        | ES_AUTOHSCROLL | ES_AUTOVSCROLL
        | ES_NOHIDESEL
        | ES_MULTILINE | ES_READONLY,               // style
        0,                                          // x
        0,                                          // y
        100,                                        // width
        100,                                        // height
        m_Win,                                      // parent
        (HMENU) IDC_RICHEDIT_CMD_HISTORY,           // control id
        g_hInst,                                    // hInstance
        NULL);                                      // user defined data
    if ( !m_hwndHistory )
    {
        return FALSE;
    }

    m_PromptWidth = 4 * m_Font->Metrics.tmAveCharWidth;
    
    m_Prompt = CreateWindowEx(
        WS_EX_CLIENTEDGE,                           // Extended style
        "STATIC",                                   // class name
        "",                                         // title
        WS_CLIPSIBLINGS
        | WS_CHILD | WS_VISIBLE,                    // style
        0,                                          // x
        100,                                        // y
        m_PromptWidth,                              // width
        100,                                        // height
        m_Win,                                      // parent
        (HMENU) IDC_STATIC,                         // control id
        g_hInst,                                    // hInstance
        NULL);                                      // user defined data
    if ( m_Prompt == NULL )
    {
        return FALSE;
    }

    m_hwndEdit = CreateWindowEx(
        WS_EX_CLIENTEDGE,                           // Extended style
        RICHEDIT_CLASS,                             // class name
        NULL,                                       // title
        WS_CLIPSIBLINGS
        | WS_CHILD | WS_VISIBLE
        | WS_VSCROLL | ES_AUTOVSCROLL
        | ES_NOHIDESEL
        | ES_MULTILINE,                             // style
        m_PromptWidth,                              // x
        100,                                        // y
        100,                                        // width
        100,                                        // height
        m_Win,                                      // parent
        (HMENU) IDC_RICHEDIT_CMD_EDIT,              // control id
        g_hInst,                                    // hInstance
        NULL);                                      // user defined data
    if ( !m_hwndEdit )
    {
        return FALSE;
    }

    SetFont( FONT_FIXED );

    // Tell the edit control we want notification of keyboard input
    // so that we can automatically set focus to the edit window.
    SendMessage(m_hwndHistory, EM_SETEVENTMASK, 0, ENM_KEYEVENTS |
                ENM_MOUSEEVENTS);

    // Tell the edit controls, that we want notification of keyboard input
    // This is so we can process the enter key, and then send that text into
    // the History window.
    SendMessage(m_hwndEdit, EM_SETEVENTMASK, 0, ENM_KEYEVENTS |
                ENM_MOUSEEVENTS);

    m_Wrap = FALSE;
    
    return TRUE;
}

void
CMDWIN_DATA::SetFont(ULONG FontIndex)
{
    COMMONWIN_DATA::SetFont(FontIndex);

    SendMessage(m_hwndHistory, WM_SETFONT, (WPARAM)m_Font->Font, TRUE);
    SendMessage(m_hwndEdit, WM_SETFONT, (WPARAM)m_Font->Font, TRUE);
    SendMessage(m_Prompt, WM_SETFONT, (WPARAM)m_Font->Font, TRUE);
}

BOOL
CMDWIN_DATA::CanCopy()
{
    HWND hwnd = m_bHistoryActive ? m_hwndHistory : m_hwndEdit;
    CHARRANGE chrg;

    SendMessage(hwnd, EM_EXGETSEL, 0, (LPARAM)&chrg);
    return chrg.cpMin != chrg.cpMax;
}

BOOL
CMDWIN_DATA::CanCut()
{
    return !m_bHistoryActive && CanCopy() &&
        (GetWindowLong(m_hwndEdit, GWL_STYLE) & ES_READONLY) == 0;
}

BOOL
CMDWIN_DATA::CanPaste()
{
    return !m_bHistoryActive 
        && SendMessage(m_hwndEdit, EM_CANPASTE, CF_TEXT, 0);
}

void
CMDWIN_DATA::Copy()
{
    HWND hwnd = m_bHistoryActive ? m_hwndHistory : m_hwndEdit;

    SendMessage(hwnd, WM_COPY, 0, 0);
}

void
CMDWIN_DATA::Cut()
{
    SendMessage(m_hwndEdit, WM_CUT, 0, 0);
}

void
CMDWIN_DATA::Paste()
{
    SendMessage(m_hwndEdit, EM_PASTESPECIAL, CF_TEXT, 0);
}

BOOL
CMDWIN_DATA::CanSelectAll()
{
    return m_bHistoryActive;
}

void
CMDWIN_DATA::SelectAll()
{
    CHARRANGE Sel;

    Sel.cpMin = 0;
    Sel.cpMax = INT_MAX;
    SendMessage(m_hwndHistory, EM_EXSETSEL, 0, (LPARAM)&Sel);
}

LRESULT
CMDWIN_DATA::OnCommand(WPARAM wParam, LPARAM lParam)
{
    int  idEditCtrl = (int) LOWORD(wParam); // identifier of edit control 
    WORD wNotifyCode = HIWORD(wParam);      // notification code 
    HWND hwndEditCtrl = (HWND) lParam;      // handle of edit control 

    switch (wNotifyCode)
    {
    case EN_SETFOCUS:
        m_bHistoryActive = IDC_RICHEDIT_CMD_HISTORY == idEditCtrl;
        return 0;

    }

    return 1;
}
    
void 
CMDWIN_DATA::OnSetFocus()
{
    if (m_bHistoryActive)
    {
        ::SetFocus(m_hwndHistory);
    }
    else
    {
        ::SetFocus(m_hwndEdit);
    }
}

void 
CMDWIN_DATA::OnSize(void)
{
    ResizeChildren(FALSE);
}

void
CMDWIN_DATA::OnButtonDown(ULONG Button)
{
    if (Button & MK_LBUTTON)
    {
        m_bTrackingMouse = TRUE;
        SetCapture(m_Win);
    }
}

void
CMDWIN_DATA::OnButtonUp(ULONG Button)
{
    if (Button & MK_LBUTTON)
    {
        if (m_bTrackingMouse)
        {
            m_bTrackingMouse = FALSE;
            ReleaseCapture();
        }
    }
}

void
CMDWIN_DATA::OnMouseMove(ULONG Modifiers, ULONG X, ULONG Y)
{
    if (MK_LBUTTON & Modifiers && m_bTrackingMouse)
    {
        // We are resizing the History & Edit Windows
        // Y position centered vertically around the cursor
        ULONG EdgeHeight = GetSystemMetrics(SM_CYEDGE);
        MoveDivider(Y - EdgeHeight / 2);
    }
}

LRESULT
CMDWIN_DATA::OnNotify(WPARAM wParam, LPARAM lParam)
{
    MSGFILTER * lpMsgFilter = (MSGFILTER *) lParam;
    
    if (EN_MSGFILTER != lpMsgFilter->nmhdr.code)
    {
        return 0;
    }

    if (WM_RBUTTONDOWN == lpMsgFilter->msg ||
        WM_RBUTTONDBLCLK == lpMsgFilter->msg)
    {
        // If there's a selection copy it to the clipboard
        // and clear it.  Otherwise try to paste.
        if (CanCopy())
        {
            Copy();
            
            CHARRANGE Sel;
            HWND hwnd = m_bHistoryActive ? m_hwndHistory : m_hwndEdit;
            SendMessage(hwnd, EM_EXGETSEL, 0, (LPARAM)&Sel);
            Sel.cpMax = Sel.cpMin;
            SendMessage(hwnd, EM_EXSETSEL, 0, (LPARAM)&Sel);
        }
        else if (SendMessage(m_hwndEdit, EM_CANPASTE, CF_TEXT, 0))
        {
            SetFocus(m_hwndEdit);
            Paste();
        }
        
        // Ignore right-button events.
        return 1;
    }
    else if (lpMsgFilter->msg < WM_KEYFIRST || lpMsgFilter->msg > WM_KEYLAST)
    {
        // Process all non-key events.
        return 0;
    }
    else if (WM_SYSKEYDOWN == lpMsgFilter->msg ||
             WM_SYSKEYUP == lpMsgFilter->msg ||
             WM_SYSCHAR == lpMsgFilter->msg)
    {
        // Process menu operations though the default so
        // that the Alt-minus menu works.
        return 1;
    }

    // Allow tab to toggle between the windows.
    // Make sure that it isn't a Ctrl-Tab or Alt-Tab or
    // a keyup when we didn't see a keydown.
    if (WM_KEYUP == lpMsgFilter->msg && VK_TAB == lpMsgFilter->wParam &&
        GetKeyState(VK_CONTROL) >= 0 && GetKeyState(VK_MENU) >= 0 &&
        m_TabDown)
    {
        m_TabDown = FALSE;
        HWND hwnd = m_bHistoryActive ? m_hwndEdit : m_hwndHistory;
        SetFocus(hwnd);
        return 1;
    }
    else if (((WM_KEYDOWN == lpMsgFilter->msg ||
               WM_KEYUP == lpMsgFilter->msg) &&
              VK_TAB == lpMsgFilter->wParam) ||
             (WM_CHAR == lpMsgFilter->msg &&
              '\t' == lpMsgFilter->wParam))
    {
        if (WM_KEYDOWN == lpMsgFilter->msg)
        {
            // Remember that we saw a tab keydown so
            // that we can match it with keyup.
            m_TabDown = TRUE;
        }
        return 1;
    }

    switch (wParam)
    {
    case IDC_RICHEDIT_CMD_HISTORY:
        // Ignore key-ups to ignore the tail end of
        // menu operations.  The switch below will occur on
        // key-down anyway so key-up doesn't need to do it.
        if (WM_KEYUP == lpMsgFilter->msg)
        {
            return 0;
        }
        
        // Allow keyboard navigation in the history text.
        if (WM_KEYDOWN == lpMsgFilter->msg)
        {
            switch(lpMsgFilter->wParam)
            {
            case VK_LEFT:
            case VK_RIGHT:
            case VK_UP:
            case VK_DOWN:
            case VK_PRIOR:
            case VK_NEXT:
            case VK_HOME:
            case VK_END:
            case VK_SHIFT:
            case VK_CONTROL:
                return 0;
            }
        }

        // Forward key events to the edit window.
        SetFocus(m_hwndEdit);
        SendMessage(m_hwndEdit, lpMsgFilter->msg, lpMsgFilter->wParam,
                    lpMsgFilter->lParam);
        return 1; // ignore

    case IDC_RICHEDIT_CMD_EDIT:
        // If the window isn't accepting input don't do history.
        if (GetWindowLong(m_hwndEdit, GWL_STYLE) & ES_READONLY)
        {
            return 1;
        }
        
        static HISTORY_LIST *pHistoryList = NULL;

        switch (lpMsgFilter->msg)
        {
        case WM_KEYDOWN:
            switch (lpMsgFilter->wParam)
            {
            default:
                return 0;

            case VK_RETURN:

                // Reset the history list
                pHistoryList = NULL;
                    
                int nLen;
                TEXTRANGE TextRange;
                
                // Get length.
                // +1 we have to take into account the null terminator.
                nLen = GetWindowTextLength(lpMsgFilter->nmhdr.hwndFrom) +1;

                // Get everything
                TextRange.chrg.cpMin = 0;
                TextRange.chrg.cpMax = -1;
                TextRange.lpstrText = (PTSTR) calloc(nLen, sizeof(TCHAR));

                if (TextRange.lpstrText)
                {
                    // Okay got the text
                    GetWindowText(m_hwndEdit, 
                                  TextRange.lpstrText,
                                  nLen
                                  );
                    SetWindowText(m_hwndEdit, 
                                  _T("") 
                                  );

                    CmdExecuteCmd(TextRange.lpstrText, UIC_CMD_INPUT);

                    free(TextRange.lpstrText);
                }

                // ignore the event
                return 1;

            case VK_UP:
            case VK_DOWN:
                CHARRANGE End;
                LRESULT LineCount;

                End.cpMin = INT_MAX;
                End.cpMax = INT_MAX;

                if (IsListEmpty( (PLIST_ENTRY) &m_listHistory ))
                {
                    return 0; // process
                }
                    
                LineCount = SendMessage(m_hwndEdit, EM_GETLINECOUNT, 0, 0);
                if (LineCount != 1)
                {
                    // If more than 1 line, then scroll through the text
                    // unless at the top or bottom line.
                    if (VK_UP == lpMsgFilter->wParam)
                    {
                        if (SendMessage(m_hwndEdit, EM_LINEINDEX, -1, 0) != 0)
                        {
                            return 0;
                        }
                    }
                    else
                    {
                        if (SendMessage(m_hwndEdit, EM_LINEFROMCHAR, -1, 0) <
                            LineCount - 1)
                        {
                            return 0;
                        }
                    }
                } 

                if (NULL == pHistoryList)
                {
                    // first time scrolling thru the list,
                    // start at the beginning
                    pHistoryList = (HISTORY_LIST *) m_listHistory.Flink;
                    SetWindowText(m_hwndEdit, pHistoryList->m_psz);
                    // Put the cursor at the end.
                    SendMessage(m_hwndEdit, EM_EXSETSEL, 0, (LPARAM)&End);
                    SendMessage(m_hwndEdit, EM_SCROLLCARET, 0, 0);
                    return 1; // ignore
                }
                        
                if (VK_UP == lpMsgFilter->wParam)
                {
                    // up
                    if (pHistoryList->Flink != (PLIST_ENTRY) &m_listHistory)
                    {
                        pHistoryList = (HISTORY_LIST *) pHistoryList->Flink;
                    }
                    else
                    {
                        return 0; // process
                    }
                    SetWindowText(m_hwndEdit, pHistoryList->m_psz);
                    // Put the cursor at the end.
                    SendMessage(m_hwndEdit, EM_EXSETSEL, 0, (LPARAM)&End);
                    SendMessage(m_hwndEdit, EM_SCROLLCARET, 0, 0);
                    return 1; // ignore
                }
                else
                {
                    // down
                    if (pHistoryList->Blink != (PLIST_ENTRY) &m_listHistory)
                    {
                        pHistoryList = (HISTORY_LIST *) pHistoryList->Blink;
                    }
                    else
                    {
                        return 0; // process
                    }
                    SetWindowText(m_hwndEdit, pHistoryList->m_psz);
                    // Put the cursor at the end.
                    SendMessage(m_hwndEdit, EM_EXSETSEL, 0, (LPARAM)&End);
                    SendMessage(m_hwndEdit, EM_SCROLLCARET, 0, 0);
                    return 1; // ignore
                }
                    
            case VK_ESCAPE:
                // Clear the current command.
                SetWindowText(m_hwndEdit, "");
                // Reset the history list
                pHistoryList = NULL;
                return 1;
            }
        }

        // process the event
        return 0;
    }

    return 0;
}

void
CMDWIN_DATA::OnUpdate(UpdateType Type)
{
    PSTR Prompt = NULL;
    
    if (Type == UPDATE_EXEC ||
        Type == UPDATE_INPUT_REQUIRED)
    {
        if (Type == UPDATE_INPUT_REQUIRED ||
            g_ExecStatus == DEBUG_STATUS_BREAK)
        {
            SendMessage(m_hwndEdit, EM_SETBKGNDCOLOR, TRUE, 0);
            SendMessage(m_hwndEdit, EM_SETREADONLY, FALSE, 0);
            SetWindowText(m_hwndEdit, _T(""));

            //
            // If WinDBG is minized and we breakin, flash the window
            //

            if (IsIconic(g_hwndFrame) && g_FlashWindowEx != NULL)
            {
                FLASHWINFO FlashInfo = {sizeof(FLASHWINFO), g_hwndFrame,
                                        FLASHW_ALL | FLASHW_TIMERNOFG,
                                        0, 0};

                g_FlashWindowEx(&FlashInfo);
            }
        }
        else
        {
            PSTR Message;

            if (!g_SessionActive ||
                g_ExecStatus == DEBUG_STATUS_NO_DEBUGGEE)
            {
                Message = "Debuggee not connected";
            }
            else
            {
                Message = "Debuggee is running...";
            }
            SetWindowText(m_hwndEdit, Message);
            SendMessage(m_hwndEdit, EM_SETBKGNDCOLOR,
                        0, g_Colors[COL_DISABLED_WINDOW].Color);
            SendMessage(m_hwndEdit, EM_SETREADONLY, TRUE, 0);
        }

        if (Type == UPDATE_INPUT_REQUIRED)
        {
            // Indicate this is an input string and not debugger
            // commands.
            Prompt = "Input>";
        }
        else
        {
            // Put the existing prompt back.
            Prompt = g_PromptText;
        }
    }
    else if (Type == UPDATE_PROMPT_TEXT)
    {
        Prompt = g_PromptText;
    }

    if (Prompt != NULL)
    {
        if (Prompt[0] != 0)
        {
            ULONG Width = (strlen(Prompt) + 1) *
                m_Font->Metrics.tmAveCharWidth;
            if (Width != m_PromptWidth)
            {
                m_PromptWidth = Width;
                ResizeChildren(TRUE);
            }
        }
        
        SetWindowText(m_Prompt, Prompt);
    }
}

ULONG
CMDWIN_DATA::GetWorkspaceSize(void)
{
    return COMMONWIN_DATA::GetWorkspaceSize() + sizeof(int) + sizeof(BOOL);
}

PUCHAR
CMDWIN_DATA::SetWorkspace(PUCHAR Data)
{
    Data = COMMONWIN_DATA::SetWorkspace(Data);
    // The divider position is relative to the top of
    // the window.  This means that if the window
    // grows suddenly the edit area will grow to
    // fill the space rather than keeping it the same
    // size.  To avoid this we save the position
    // relative to the bottom of the window so that
    // the edit window stays the same size even when
    // the overall window changes size.
    // Previous versions didn't do this inversion, so
    // we mark the new style with a negative value.
    *(int*)Data = -(int)(m_Size.cy - m_nDividerPosition);
    Data += sizeof(int);
    *(PBOOL)Data = m_Wrap;
    Data += sizeof(BOOL);
    return Data;
}

PUCHAR
CMDWIN_DATA::ApplyWorkspace1(PUCHAR Data, PUCHAR End)
{
    Data = COMMONWIN_DATA::ApplyWorkspace1(Data, End);

    if (End - Data >= sizeof(int))
    {
        int Pos = *(int*)Data;
        // Handle old-style top-relative positive values and
        // new-style bottom-relative negative values.
        MoveDivider(Pos >= 0 ? Pos : m_Size.cy + Pos);
        Data += sizeof(int);
    }

    if (End - Data >= sizeof(BOOL))
    {
        SetWordWrap(*(PBOOL)Data);
        Data += sizeof(BOOL);
    }

    return Data;
}
    
void
CMDWIN_DATA::UpdateColors(void)
{
    COLORREF Fg, Bg;

    // Don't update the text in the history window
    // as it is already colored due to masks and
    // we don't want to interfere with that.
    RicheditUpdateColors(m_hwndHistory,
                         0, FALSE,
                         g_Colors[COL_PLAIN].Color, TRUE);
    GetOutMaskColors(DEBUG_OUTPUT_PROMPT, &Fg, &Bg);
    RicheditUpdateColors(m_hwndEdit, Fg, TRUE, Bg, TRUE);
}
    
void
CMDWIN_DATA::MoveDivider(int Pos)
{
    if (Pos == m_nDividerPosition)
    {
        return;
    }
    
    m_nDividerPosition = Pos;
    m_EditHeight = m_Size.cy - m_nDividerPosition;

    if (g_Workspace != NULL)
    {
        g_Workspace->AddDirty(WSPF_DIRTY_WINDOWS);
    }
    
    SendMessage(m_Win, WM_SIZE, SIZE_RESTORED, 
                MAKELPARAM(m_Size.cx, m_Size.cy));
}

void 
CMDWIN_DATA::AddCmdToHistory(PCSTR pszCmd)
/*++
Description:
    Add a command to the command history.

    If the command already exists, just move it to 
    the beginning of the list. This way we don't 
    repeat commands.
--*/
{
    Assert(pszCmd);

    HISTORY_LIST *p = NULL;
    BOOL fWhiteSpace;
    BOOL fFoundDuplicate;

    //
    // Does the command contain whitespace? If it does, it may be a command
    // that requires arguments. If it does have arguments, then string
    // comparisons must be case sensitive.
    //
    fWhiteSpace = _tcscspn(pszCmd, _T(" \t") ) != _tcslen(pszCmd);

    p = (HISTORY_LIST *) m_listHistory.Flink;
    while (p != &m_listHistory)
    {
        fFoundDuplicate = FALSE;

        if (fWhiteSpace)
        {
            if ( !_tcscmp(p->m_psz, pszCmd) )
            {
                fFoundDuplicate = TRUE;
            }
        }
        else
        {
            if ( !_tcsicmp(p->m_psz, pszCmd) )
            {
                fFoundDuplicate = TRUE;
            }
        }

        if (fFoundDuplicate)
        {
            RemoveEntryList( (PLIST_ENTRY) p );
            InsertHeadList( (PLIST_ENTRY) &m_listHistory, (PLIST_ENTRY) p);
            return;
        }

        p = (HISTORY_LIST *) p->Flink;
    }

    // This cmd is new to the list, add it
    p = new HISTORY_LIST;
    if (p != NULL)
    {
        p->m_psz = _tcsdup(pszCmd);
        if (p->m_psz != NULL)
        {
            InsertHeadList( (PLIST_ENTRY) &m_listHistory, (PLIST_ENTRY) p);
        }
        else
        {
            delete p;
        }
    }
}

void
CMDWIN_DATA::AddText(PTSTR Text, COLORREF Fg, COLORREF Bg)
{
    CHARRANGE OrigSel;
    POINT OrigScroll;
    CHARRANGE TextRange;

#if 0
    DebugPrint("Add %d chars, %p - %p\n",
               strlen(Text), Text, Text + strlen(Text));
#endif
    
    SendMessage(m_hwndHistory, WM_SETREDRAW, FALSE, 0);
    SendMessage(m_hwndHistory, EM_EXGETSEL, 0, (LPARAM)&OrigSel);
    SendMessage(m_hwndHistory, EM_GETSCROLLPOS, 0, (LPARAM)&OrigScroll);
    
    // The selection is lost when adding text so discard
    // any previous find results.
    if (g_AutoCmdScroll && m_FindSel.cpMax >= m_FindSel.cpMin)
    {
        m_FindSel.cpMin = 1;
        m_FindSel.cpMax = 0;
    }

    //
    // are there too many lines in the buffer?
    //
    
    INT Overflow;
    
    Overflow = (INT)SendMessage(m_hwndHistory, EM_GETLINECOUNT, 0, 0) -
        MAX_CMDWIN_LINES;
    if (Overflow > 0)
    {
        //
        // delete more than we need to so it doesn't happen
        // every time a line is printed.
        //
        TextRange.cpMin = 0;
        // Get the character index of the 50th line past the overflow.
        TextRange.cpMax = (LONG)
            SendMessage(m_hwndHistory, 
                        EM_LINEINDEX, 
                        Overflow + 50,
                        0
                        );

        SendMessage(m_hwndHistory, 
                    EM_EXSETSEL, 
                    0,
                    (LPARAM) &TextRange
                    );
        
        SendMessage(m_hwndHistory, 
                    EM_REPLACESEL, 
                    FALSE,
                    (LPARAM) _T("")
                    );

        m_OutputIndex -= TextRange.cpMax;
        if (!g_AutoCmdScroll)
        {
            if (m_FindSel.cpMax >= m_FindSel.cpMin)
            {
                m_FindSel.cpMin -= TextRange.cpMax;
                m_FindSel.cpMax -= TextRange.cpMax;
                if (m_FindSel.cpMin < 0)
                {
                    // Find is at least partially gone so
                    // throw it away.
                    m_FindSel.cpMin = 1;
                    m_FindSel.cpMax = 0;
                }
            }
            OrigSel.cpMin -= TextRange.cpMax;
            OrigSel.cpMax -= TextRange.cpMax;
            if (OrigSel.cpMin < 0)
            {
                OrigSel.cpMin = 0;
            }
            if (OrigSel.cpMax < 0)
            {
                OrigSel.cpMax = 0;
            }
        }
    }

    //
    // Output the text to the cmd window.  The command
    // window is emulating a console window so we need
    // to emulate the effects of backspaces and carriage returns.
    //

    for (;;)
    {
        PSTR Stop, Scan;
        char Save;

        // Find the first occurrence of an emulated char.
        // If the output index is at the end of the text
        // there's no need to specially emulate newline.
        // This is a very common case and not splitting
        // up output for it greatly enhances append performance.
        Stop = strchr(Text, '\r');
        Scan = strchr(Text, '\b');
        if (Stop == NULL || (Scan != NULL && Scan < Stop))
        {
            Stop = Scan;
        }
        if (!m_OutputIndexAtEnd)
        {
            Scan = strchr(Text, '\n');
            if (Stop == NULL || (Scan != NULL && Scan < Stop))
            {
                Stop = Scan;
            }
        }

        // Add all text up to the emulated char.
        if (Stop != NULL)
        {
            Save = *Stop;
            *Stop = 0;
        }

        if (*Text)
        {
            LONG Len = strlen(Text);

            // Replace any text that might already be there.
            TextRange.cpMin = m_OutputIndex;
            TextRange.cpMax = m_OutputIndex + Len;
            SendMessage(m_hwndHistory, EM_EXSETSEL, 
                        0, (LPARAM)&TextRange);
            SendMessage(m_hwndHistory, EM_REPLACESEL, 
                        FALSE, (LPARAM)Text);

            m_OutputIndex = TextRange.cpMax;
            
            CHARFORMAT2 Fmt;

            ZeroMemory(&Fmt, sizeof(Fmt));
            Fmt.cbSize = sizeof(Fmt);
            Fmt.dwMask = CFM_COLOR | CFM_BACKCOLOR;
            Fmt.crTextColor = Fg;
            Fmt.crBackColor = Bg;
            SendMessage(m_hwndHistory, EM_EXSETSEL, 
                        0, (LPARAM)&TextRange);
            SendMessage(m_hwndHistory, EM_SETCHARFORMAT,
                        SCF_SELECTION, (LPARAM)&Fmt);
            
            TextRange.cpMin = TextRange.cpMax;
            SendMessage(m_hwndHistory, EM_EXSETSEL, 
                        0, (LPARAM)&TextRange);
        }

        // If there weren't any emulated chars all the remaining text
        // was just added so we're done.
        if (Stop == NULL)
        {
            break;
        }

        Text = Stop;
        *Stop = Save;

        // Emulate the character.
        if (Save == '\b')
        {
            TextRange.cpMax = m_OutputIndex;
            do
            {
                if (m_OutputIndex > 0)
                {
                    m_OutputIndex--;
                }
            } while (*(++Text) == '\b');
            TextRange.cpMin = m_OutputIndex;

            SendMessage(m_hwndHistory, EM_EXSETSEL, 
                        0, (LPARAM)&TextRange);
            SendMessage(m_hwndHistory, EM_REPLACESEL,
                        FALSE, (LPARAM)"");
        }
        else if (Save == '\n')
        {
            // Move the output position to the next line.
            // This routine always appends text to the very
            // end of the control so that's always the last
            // position in the control.
            TextRange.cpMin = INT_MAX;
            TextRange.cpMax = INT_MAX;
            SendMessage(m_hwndHistory, EM_EXSETSEL, 
                        0, (LPARAM)&TextRange);
            
            do
            {
                SendMessage(m_hwndHistory, EM_REPLACESEL,
                            FALSE, (LPARAM)"\n");
            } while (*(++Text) == '\n');
            
            SendMessage(m_hwndHistory, EM_EXGETSEL, 
                        0, (LPARAM)&TextRange);
            m_OutputIndex = TextRange.cpMax;
            m_OutputIndexAtEnd = TRUE;
        }
        else if (Save == '\r')
        {
            // Return the output position to the beginning of
            // the current line.
            TextRange.cpMin = m_OutputIndex;
            TextRange.cpMax = m_OutputIndex;
            SendMessage(m_hwndHistory, EM_EXSETSEL, 
                        0, (LPARAM)&TextRange);
            m_OutputIndex = (LONG)
                SendMessage(m_hwndHistory, EM_LINEINDEX, -1, 0);
            m_OutputIndexAtEnd = FALSE;
            
            while (*(++Text) == '\r')
            {
                // Advance.
            }
        }
        else
        {
            Assert(FALSE);
        }
    }

    if (g_AutoCmdScroll)
    {
        // Force the window to scroll to the bottom of the text.
        SendMessage(m_hwndHistory, EM_SCROLLCARET, 0, 0);
    }
    else
    {
        // Restore original selection.
        SendMessage(m_hwndHistory, EM_EXSETSEL, 0, (LPARAM)&OrigSel);
        SendMessage(m_hwndHistory, EM_SETSCROLLPOS, 0, (LPARAM)&OrigScroll);
    }

    SendMessage(m_hwndHistory, WM_SETREDRAW, TRUE, 0);
    InvalidateRect(m_hwndHistory, NULL, TRUE);
}

void
CMDWIN_DATA::Clear(void)
{
    SetWindowText(m_hwndHistory, "");
    m_OutputIndex = 0;
    m_OutputIndexAtEnd = TRUE;
}

void
CMDWIN_DATA::SetWordWrap(BOOL Wrap)
{
    if (Wrap == m_Wrap)
    {
        return;
    }
    
    m_Wrap = Wrap;
    if (m_Wrap)
    {
        SendMessage(m_hwndHistory, EM_SETTARGETDEVICE, 0, 0);
    }
    else
    {
        SendMessage(m_hwndHistory, EM_SETTARGETDEVICE, 0, 1);
        SendMessage(m_hwndHistory, EM_SHOWSCROLLBAR, SB_HORZ, TRUE);
    }

    if (g_Workspace != NULL)
    {
        g_Workspace->AddDirty(WSPF_DIRTY_WINDOWS);
    }
}

void
CMDWIN_DATA::ResizeChildren(BOOL PromptChange)
{
    const int DividerHeight = GetSystemMetrics(SM_CYEDGE);
    int HistoryHeight;

    // Attempt to keep the input area the same size as it was
    // and modify the output area.  If the input area would
    // take up more than half the window shrink it also.
    if (m_EditHeight > (int)m_Size.cy / 2)
    {
        m_EditHeight = m_Size.cy / 2;
    }
    else if (m_EditHeight < MIN_PANE_SIZE)
    {
        m_EditHeight = MIN_PANE_SIZE;
    }
    HistoryHeight = m_Size.cy - m_EditHeight - DividerHeight / 2;
    m_nDividerPosition = m_Size.cy - m_EditHeight;

    if ((int)m_PromptWidth > m_Size.cx / 2)
    {
        m_PromptWidth = m_Size.cx / 2;
    }

    if (!PromptChange)
    {
        MoveWindow(m_hwndHistory,
                   0, 
                   0, 
                   m_Size.cx, 
                   HistoryHeight, 
                   TRUE);
    }

    MoveWindow(m_Prompt,
               0,
               HistoryHeight + DividerHeight,
               m_PromptWidth,
               m_Size.cy - HistoryHeight - DividerHeight, 
               TRUE);
    
    MoveWindow(m_hwndEdit, 
               m_PromptWidth,
               HistoryHeight + DividerHeight,
               m_Size.cx - m_PromptWidth, 
               m_Size.cy - HistoryHeight - DividerHeight, 
               TRUE);

    if (g_AutoCmdScroll)
    {
        if (!PromptChange)
        {
            // Keep the caret visible in both windows.  The richedit
            // control likes to leave the history window scrolled
            // up off the top of the window so force a scroll down
            // so that the history comes to the bottom of the history
            // window.
            SendMessage(m_hwndHistory, EM_LINESCROLL, 0, -(LONG)m_LineHeight);
            SendMessage(m_hwndHistory, EM_SCROLLCARET, 0, 0);
        }

        // The edit window usually has the caret and doesn't
        // need any extra scrolling.
        SendMessage(m_hwndEdit, EM_SCROLLCARET, 0, 0);
    }
}

//----------------------------------------------------------------------------
//
// Functions.
//
//----------------------------------------------------------------------------

void
ClearCmdWindow(void)
{
    HWND CmdWin = GetCmdHwnd();
    if (CmdWin == NULL)
    {
        return;
    }
    
    PCMDWIN_DATA CmdWinData = GetCmdWinData(CmdWin);
    if (CmdWinData == NULL)
    {
        return;
    }

    CmdWinData->Clear();
}

BOOL
CmdOutput(PTSTR pszStr, COLORREF Fg, COLORREF Bg)
{
    PCMDWIN_DATA pCmdWinData;
    BOOL fRet = TRUE;

    //
    //  Ensure that the command window exists
    //

    if ( !GetCmdHwnd() )
    {
        if ( !NewCmd_CreateWindow(g_hwndMDIClient) )
        {
            return FALSE;
        }
    }

    pCmdWinData = GetCmdWinData(GetCmdHwnd());
    if (!pCmdWinData)
    {
        return FALSE;
    }

    pCmdWinData->AddText(pszStr, Fg, Bg);
    
    return TRUE;
}

void
CmdLogFmt(
    PCTSTR  lpFmt,
    ...
    )
{
    TCHAR szText[MAX_VAR_MSG_TXT];
    va_list vargs;

    va_start(vargs, lpFmt);
    _vsntprintf(szText, MAX_VAR_MSG_TXT - 1, lpFmt, vargs);
    szText[MAX_VAR_MSG_TXT - 1] = 0;
    va_end(vargs);

    COLORREF Fg, Bg;

    GetOutMaskColors(DEBUG_OUTPUT_NORMAL, &Fg, &Bg);
    CmdOutput(szText, Fg, Bg);
}

void
CmdOpenSourceFile(PSTR File)
{
    char Found[MAX_SOURCE_PATH];

    if (File == NULL)
    {
        CmdLogFmt("Usage: .open filename\n");
        return;
    }
    
    // Look up the reported file along the source path.
    // XXX drewb - Use first-match and then element walk to
    // determine ambiguities and display resolution UI.
    if (g_pUiLocSymbols->
        FindSourceFile(0, File,
                       DEBUG_FIND_SOURCE_BEST_MATCH |
                       DEBUG_FIND_SOURCE_FULL_PATH,
                       NULL, Found, sizeof(Found), NULL) != S_OK)
    {
        CmdLogFmt("Unable to find '%s'\n", File);
    }
    else
    {
        OpenOrActivateFile(Found, NULL, NULL, -1, TRUE, TRUE);
    }
}

BOOL
DirectCommand(PSTR Command)
{
    char Term, TermText;
    PSTR Scan, Arg, ArgText;

    //
    // Check and see if this is a UI command
    // vs. a command that should go to the engine.
    //
    
    while (isspace(*Command))
    {
        Command++;
    }
    Scan = Command;
    while (*Scan && !isspace(*Scan))
    {
        Scan++;
    }
    Term = *Scan;
    *Scan = 0;

    // Advance to next nonspace char for arguments.
    if (Term != 0)
    {
        Arg = Scan + 1;
        while (isspace(*Arg))
        {
            Arg++;
        }
        if (*Arg == 0)
        {
            Arg = NULL;
            ArgText = "";
        }
        else
        {
            ArgText = Arg;
        }
        TermText = Term;
    }
    else
    {
        Arg = NULL;
        ArgText = "";
        TermText = ' ';
    }

    if (!_strcmpi(Command, ".cls"))
    {
        CmdLogFmt("windbg> %s%c%s\n", Command, TermText, ArgText);
        ClearCmdWindow();
    }
    else if (!_strcmpi(Command, ".hh"))
    {
        CmdLogFmt("windbg> %s%c%s\n", Command, TermText, ArgText);
        if (Arg == NULL)
        {
            OpenHelpTopic(HELP_TOPIC_TABLE_OF_CONTENTS);
        }
        else if (!_strnicmp(Arg, "dbgerr", 6))
        {
            OpenHelpKeyword(Arg, TRUE);
        }
        else
        {
            OpenHelpKeyword(Arg, FALSE);
        }
    }
    else if (!_strcmpi(Command, ".hold_output"))
    {
        CmdLogFmt("windbg> %s%c%s\n", Command, TermText, ArgText);

        if (Arg)
        {
            g_HoldWaitOutput = _strcmpi(Arg, "on") == 0;
        }

        CmdLogFmt("Hold output until event: %s\n",
                  g_HoldWaitOutput ? "on" : "off");
    }
    else if (!_strcmpi(Command, ".lsrcpath") ||
             !_strcmpi(Command, ".lsrcpath+"))
    {
        CmdLogFmt("windbg> %s%c%s\n", Command, TermText, ArgText);

        *Scan = Term;
        
        // Apply source path changes to the local symbol
        // object to update its source path.
        if (g_RemoteClient)
        {
            char Path[MAX_ENGINE_PATH];
            
            // Convert .lsrcpath to .srcpath.
            Command[1] = '.';
            g_pUiLocControl->Execute(DEBUG_OUTCTL_IGNORE, Command + 1,
                                     DEBUG_EXECUTE_NOT_LOGGED |
                                     DEBUG_EXECUTE_NO_REPEAT);
            if (g_pUiLocSymbols->GetSourcePath(Path, sizeof(Path),
                                               NULL) == S_OK)
            {
                CmdLogFmt("Local source search path is: %s\n", Path);
                if (g_Workspace != NULL)
                {
                    g_Workspace->SetString(WSP_GLOBAL_LOCAL_SOURCE_PATH, Path);
                }
            }
            
            // Refresh windows affected by the source path.
            InvalidateStateBuffers(1 << EVENT_BIT);
            UpdateEngine();
        }
        else
        {
            CmdLogFmt("lsrcpath is only enabled for remote clients\n");
        }
    }
    else if (!_strcmpi(Command, ".open"))
    {
        CmdLogFmt("windbg> %s%c%s\n", Command, TermText, ArgText);
        CmdOpenSourceFile(Arg);
    }
    else if (!_strcmpi(Command, ".restart"))
    {
        CmdLogFmt("windbg> %s%c%s\n", Command, TermText, ArgText);
        AddEnumCommand(UIC_RESTART);
    }
    else if (!_strcmpi(Command, ".server"))
    {
        // We don't interpret this but we need to update
        // the title.
        if (Arg)
        {
            SetTitleServerText("Server '%s'", Arg);
        }
        *Scan = Term;
        return FALSE;
    }
    else if (!_strcmpi(Command, ".wtitle"))
    {
        CmdLogFmt("windbg> %s%c%s\n", Command, TermText, ArgText);
        if (!Arg)
        {
            CmdLogFmt("Usage: .wtitle title_string\n");
        }
        else
        {
            SetTitleExplicitText(Arg);
        }
    }
    else
    {
        *Scan = Term;
        return FALSE;
    }

    // Handled so no need to patch up the command.
    return TRUE;
}

int
CmdExecuteCmd(
    PCTSTR pszCmd,
    UiCommand UiCmd
    )
{
    PCMDWIN_DATA    pCmdWinData = NULL;
    PTSTR           pszDupe = NULL;
    PTSTR           pszToken = NULL;

    if ( !GetCmdHwnd() )
    {
        NewCmd_CreateWindow(g_hwndMDIClient);
    }
    pCmdWinData = GetCmdWinData(GetCmdHwnd());

    pszDupe = _tcsdup(pszCmd);
    pszToken = _tcstok(pszDupe, _T("\r\n") );

    if (pszToken == NULL)
    {
        // Blank command, important for repeats in
        // the engine but not for the history window.
        AddStringCommand(UiCmd, pszCmd);
    }
    else
    {
        for (; pszToken; pszToken = _tcstok(NULL, _T("\r\n") ) )
        {
            if (pCmdWinData)
            {
                pCmdWinData->AddCmdToHistory(pszToken);
            }

            if (!DirectCommand(pszToken))
            {
                AddStringCommand(UiCmd, pszToken);
            }
        }
    }

    free(pszDupe);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\windbg\arrange.cpp ===
/*++

Copyright (c) 1992-2002  Microsoft Corporation

Module Name:

    arrange.cpp

Abstract:

    This module contains the default MDI tiling (arrange) code for
    windowing arrangement.

--*/


#include "precomp.hxx"
#pragma hdrstop

#define AUTO_ARRANGE_WARNING_LIMIT 3
// Multiple events closely together don't each get their own
// count in order to prevent warnings on full-drag message
// series.  This delay should be relatively large to
// avoid problems with people pausing during a full-drag move.
#define AUTO_ARRANGE_WARNING_DELAY 2500

// DeferWindowPos flags to restrict change to position only.
#define POS_ONLY (SWP_NOACTIVATE | SWP_NOZORDER)

ULONG g_AutoArrangeWarningCount;
ULONG g_AutoArrangeWarningTime;

BOOL
IsAutoArranged(WIN_TYPES Type)
{
    if (g_WinOptions & WOPT_AUTO_ARRANGE)
    {
        if (g_WinOptions & WOPT_ARRANGE_ALL)
        {
            return TRUE;
        }

        return Type != DOC_WINDOW && Type != DISASM_WINDOW;
    }

    return FALSE;
}

void
DisplayAutoArrangeWarning(PCOMMONWIN_DATA CmnWin)
{
    //
    // If this window is under automatic arrangement
    // control and has been rearranged a few times,
    // let the user know that auto-arrange may override
    // what the user has done.
    //
    // In order to prevent false positives we avoid
    // giving any warnings if the window is being
    // moved automatically or if we're getting a series
    // of changes in a short period of time, such as
    // if the user has full-drag enabled so that many
    // move or size events can occur rapidly.
    //
    // Display the warning only once per execution.
    //
    
    if (g_AutoArrangeWarningCount == 0xffffffff ||
        CmnWin == NULL ||
        CmnWin->m_InAutoOp > 0 ||
        !IsAutoArranged(CmnWin->m_enumType) ||
        g_AutoArrangeWarningTime >
        GetTickCount() - AUTO_ARRANGE_WARNING_DELAY ||
        getenv("WINDBG_NO_ARRANGE_WARNING"))
    {
        return;
    }

    if (++g_AutoArrangeWarningCount >= AUTO_ARRANGE_WARNING_LIMIT)
    {
        InformationBox(STR_Auto_Arrange_Is_Enabled);
        g_AutoArrangeWarningCount = 0xffffffff;
    }
    else
    {
        g_AutoArrangeWarningTime = GetTickCount();
    }
}

void
ArrangeInRect(HDWP Defer, int X, int Y, int Width, int Height,
              BOOL Vertical, ULONG Types, int Count, BOOL Overlay)
{
    PLIST_ENTRY Entry;
    PCOMMONWIN_DATA Data;
    int PerWin, Remain;

    if (Overlay)
    {
        Remain = 0;
    }
    else if (Vertical)
    {
        PerWin = Height / Count;
        Remain = Height - PerWin * Count;
        Height = PerWin + (Remain ? 1 : 0);
    }
    else
    {
        PerWin = Width / Count;
        Remain = Width - PerWin * Count;
        Width = PerWin + (Remain ? 1 : 0);
    }
        
    for (Entry = g_ActiveWin.Flink;
         Entry != &g_ActiveWin;
         Entry = Entry->Flink)
    {
        Data = ACTIVE_WIN_ENTRY(Entry);
        if ((Types & (1 << Data->m_enumType)) == 0 ||
            IsIconic(Data->m_Win))
        {
            continue;
        }

        DeferWindowPos(Defer, Data->m_Win, NULL, X, Y,
                       Width, Height, POS_ONLY);

        if (Overlay)
        {
            // All windows are stacked on top of each other.
        }
        else if (Vertical)
        {
            Y += Height;
            if (--Remain == 0)
            {
                Height--;
            }
        }
        else
        {
            X += Width;
            if (--Remain == 0)
            {
                Width--;
            }
        }
    }
}

void 
Arrange(void)
{
    PLIST_ENTRY Entry;
    PCOMMONWIN_DATA pWinData;
    int         NumDoc, NumMem, NumWatchLocals, NumWin;
    int         NumLeft, NumRight;
    BOOL        AnyIcon = FALSE;
    HWND        hwndChild;
    HWND        hwndCpu;
    HWND        hwndWatch;
    HWND        hwndLocals;
    HWND        hwndCalls;
    HWND        hwndCmd;
    HWND        hwndDisasm;
    HWND        hwndScratch;
    HWND        hwndProcThread;

    // initialize to non-existent
    NumLeft = NumRight = 0;
    NumDoc = NumMem = NumWatchLocals = NumWin = 0;
    hwndWatch = hwndLocals = hwndCpu = hwndCalls = NULL;
    hwndCmd = hwndDisasm = hwndScratch = hwndProcThread = NULL;

    hwndChild = MDIGetActive(g_hwndMDIClient, NULL);
    if (hwndChild && IsZoomed(hwndChild))
    {
        // If there's a maximized window it covers the MDI
        // client area and arranging will have no visual effect.
        // Don't even bother to rearrange underlying windows
        // as this causes problems when switching between child
        // windows while a child is maximized.
        return;
    }

    //
    // Windows are either left-side windows or right-side windows.
    // Left-side windows are wider and can be relatively short,
    // while right-side windows are narrow but want height.
    // Left-side windows want to be 80 columns wide while
    // right side windows have both a minimum width and a desired
    // width.
    //
    // Right-side windows fill whatever space is left over to
    // the right of the left-side windows.  If that space is
    // less than the minimum the left-side windows have to give up space.
    //
    // Vertically each side is split up according to the specific
    // windows present.  On the right side the windows are
    // space equally top-to-bottom.
    // On the left side watch and locals windows are packed together
    // in one vertical area, as are memory windows.  Calls,
    // disassembly, document and command windows each get their own band.
    //

    for (Entry = g_ActiveWin.Flink;
         Entry != &g_ActiveWin;
         Entry = Entry->Flink)
    {
        pWinData = ACTIVE_WIN_ENTRY(Entry);
        // This window is participating in an operation
        // which may cause window messages.
        pWinData->m_InAutoOp++;
        
        hwndChild = pWinData->m_Win;
        if (hwndChild == NULL)
        {
            continue;
        }
        
        if (IsIconic(hwndChild))
        {
            AnyIcon = TRUE;
            continue;
        }

        NumWin++;
            
        switch (pWinData->m_enumType)
        {
        default:
            Assert(!_T("Unknown window type"));
            break;

        case WATCH_WINDOW:
            hwndWatch = hwndChild;
            if (++NumWatchLocals == 1)
            {
                NumLeft++;
            }
            break;
            
        case LOCALS_WINDOW:
            hwndLocals = hwndChild;
            if (++NumWatchLocals == 1)
            {
                NumLeft++;
            }
            break;
            
        case CPU_WINDOW:
            hwndCpu = hwndChild;
            NumRight++;
            break;
            
        case CALLS_WINDOW:
            hwndCalls = hwndChild;
            NumLeft++;
            break;
            
        case DOC_WINDOW:
            if ((g_WinOptions & WOPT_ARRANGE_ALL) == 0)
            {
                break;
            }
            
            if (++NumDoc == 1)
            {
                NumLeft++;
            }
            break;
            
        case DISASM_WINDOW:
            if ((g_WinOptions & WOPT_ARRANGE_ALL) == 0)
            {
                break;
            }
            
            hwndDisasm = hwndChild;
            NumLeft++;
            break;
            
        case CMD_WINDOW:
            hwndCmd = hwndChild;
            NumLeft++;
            break;

        case SCRATCH_PAD_WINDOW:
            hwndScratch = hwndChild;
            NumRight++;
            break;
            
        case MEM_WINDOW:
            if (++NumMem == 1)
            {
                NumLeft++;
            }
            break;

        case PROCESS_THREAD_WINDOW:
            hwndProcThread = hwndChild;
            NumLeft++;
            break;
        }
    }

    HDWP Defer = BeginDeferWindowPos(NumWin);
    if (Defer == NULL)
    {
        goto EndAutoOp;
    }

    // Now we have a count of all multiple wins and existence of special cases
    
    int AvailWidth = (int)g_MdiWidth;
    int AvailHeight = (int)g_MdiHeight;

    int X, Y, Width, MaxWidth, Height, RemainY;
        
    //
    // If icons present, don't cover them
    //
    if (AnyIcon)
    {
        AvailHeight -= GetSystemMetrics(SM_CYCAPTION) +
            GetSystemMetrics(SM_CYFRAME);
    }

    int LeftWidth = NumLeft > 0 ? LEFT_SIDE_WIDTH : 0;

    if (NumRight > 0)
    {
        switch(g_ActualProcType)
        {
        default:
            Width = RIGHT_SIDE_MIN_WIDTH_32;
            MaxWidth = RIGHT_SIDE_DESIRED_WIDTH_32;
            break;

        case IMAGE_FILE_MACHINE_IA64:
        case IMAGE_FILE_MACHINE_AXP64:
        case IMAGE_FILE_MACHINE_AMD64:
            Width = RIGHT_SIDE_MIN_WIDTH_64;
            MaxWidth = RIGHT_SIDE_DESIRED_WIDTH_64;
            break;
        }

        if (AvailWidth < LeftWidth + Width)
        {
            // Not enough space for left side to be at
            // its desired width.
            if (NumLeft == 0)
            {
                // No left-side windows to take space from.
                Width = AvailWidth;
            }
            else
            {
                LeftWidth = AvailWidth - Width;
                if (LeftWidth < LEFT_SIDE_MIN_WIDTH)
                {
                    // We stole too much space so neither
                    // side can meet their minimum widths.  Just
                    // split the available space up.
                    Width = AvailWidth / 2;
                    LeftWidth = AvailWidth - Width;
                }
            }
        }
        else
        {
            // Take up space on the right side up to the
            // desired width but no more.  This gives
            // any extra space to the left side as the right
            // side doesn't really need any more than its desired
            // width.
            Width = AvailWidth - LeftWidth;
            if (Width > MaxWidth)
            {
                Width = MaxWidth;
                LeftWidth = AvailWidth - Width;
            }
        }

        X = LeftWidth;
        Y = 0;
        Height = AvailHeight / NumRight;
        
        if (hwndCpu != NULL)
        {
            DeferWindowPos(Defer, hwndCpu, NULL, X, Y,
                           Width, Height, POS_ONLY);
            Y += Height;
            Height = AvailHeight - Height;
        }

        if (hwndScratch != NULL)
        {
            DeferWindowPos(Defer, hwndScratch, NULL, X, Y,
                           Width, Height, POS_ONLY);
        }
    }
    else
    {
        LeftWidth = AvailWidth;
    }

    if (NumLeft == 0)
    {
        goto EndDefer;
    }

    int CmdHeight;
    int BiasedNumLeft;
    
    // Compute the size of each vertical band within the left side.
    // When doing so bias things so the command window gets
    // a 2.0 share to account for the fact that it has both
    // output and input areas.  Also give it any remainder
    // space left when dividing.
    BiasedNumLeft = NumLeft * 2 + (hwndCmd != NULL ? 2 : 0);
    Height = (AvailHeight * 2) / BiasedNumLeft;
    if (hwndCmd != NULL)
    {
        CmdHeight = AvailHeight - Height * (NumLeft - 1);
        RemainY = 0;
    }
    else
    {
        RemainY = Height * (NumLeft + 1) - AvailHeight;
    }
    Y = 0;

    // Place the watch and locals windows at the top.
    if (NumWatchLocals > 0)
    {
        if (RemainY-- == 1)
        {
            Height++;
        }

        X = 0;
        Width = LeftWidth / NumWatchLocals;

        if (hwndWatch != NULL)
        {
            DeferWindowPos(Defer, hwndWatch, NULL, X, Y,
                           Width, Height, POS_ONLY);
            X += Width;
            Width = LeftWidth - X;
        }
        if (hwndLocals != NULL)
        {
            DeferWindowPos(Defer, hwndLocals, NULL, X, Y,
                           Width, Height, POS_ONLY);
            X += Width;
            Width = LeftWidth - X;
        }

        Y += Height;
    }

    // Place all the memory windows next.
    if (NumMem > 0)
    {
        if (RemainY-- == 1)
        {
            Height++;
        }

        ArrangeInRect(Defer, 0, Y, LeftWidth, Height,
                      FALSE, 1 << MEM_WINDOW, NumMem, FALSE);
        
        Y += Height;
    }

    // Disasm window.
    if (hwndDisasm != NULL)
    {
        if (RemainY-- == 1)
        {
            Height++;
        }

        DeferWindowPos(Defer, hwndDisasm, NULL, 0, Y,
                       LeftWidth, Height, POS_ONLY);
        
        Y += Height;
    }
    
    // Doc windows.
    if (NumDoc > 0)
    {
        if (RemainY-- == 1)
        {
            Height++;
        }

        ArrangeInRect(Defer, 0, Y, LeftWidth, Height,
                      FALSE, 1 << DOC_WINDOW, NumDoc,
                      (g_WinOptions & WOPT_OVERLAY_SOURCE) != 0);
        
        Y += Height;
    }

    // Command window.
    if (hwndCmd != NULL)
    {
        if (RemainY-- == 1)
        {
            Height++;
        }

        DeferWindowPos(Defer, hwndCmd, NULL, 0, Y,
                       LeftWidth, CmdHeight, POS_ONLY);
        
        Y += CmdHeight;
    }

    // Calls window.
    if (hwndCalls != NULL)
    {
        if (RemainY-- == 1)
        {
            Height++;
        }

        DeferWindowPos(Defer, hwndCalls, NULL, 0, Y,
                       LeftWidth, Height, POS_ONLY);
        
        Y += Height;
    }

    // Processes and threads window.
    if (hwndProcThread != NULL)
    {
        if (RemainY-- == 1)
        {
            Height++;
        }

        DeferWindowPos(Defer, hwndProcThread, NULL, 0, Y,
                       LeftWidth, Height, POS_ONLY);
        
        Y += Height;
    }

 EndDefer:
    EndDeferWindowPos(Defer);

 EndAutoOp:
    // The auto-op is finished.
    for (Entry = g_ActiveWin.Flink;
         Entry != &g_ActiveWin;
         Entry = Entry->Flink)
    {
        pWinData = ACTIVE_WIN_ENTRY(Entry);
        pWinData->m_InAutoOp--;
    }
}

void
UpdateSourceOverlay(void)
{
    // If we're turning off overlay just leave the windows
    // the way they are.
    if ((g_WinOptions & WOPT_OVERLAY_SOURCE) == 0)
    {
        return;
    }

    // If doc windows are auto-arranged just handle it
    // that way.
    if (IsAutoArranged(DOC_WINDOW))
    {
        Arrange();
        return;
    }
    
    // Source overlay was just turned on.  Pile all source
    // windows on top of the first one.
    
    PLIST_ENTRY Entry;
    PCOMMONWIN_DATA WinData;
    int X, Y;

    X = -INT_MAX;
    for (Entry = g_ActiveWin.Flink;
         Entry != &g_ActiveWin;
         Entry = Entry->Flink)
    {
        WinData = ACTIVE_WIN_ENTRY(Entry);
        if (WinData->m_enumType == DOC_WINDOW &&
            !IsIconic(WinData->m_Win))
        {
            if (X == -INT_MAX)
            {
                RECT Rect;
                
                // First window, remember its position.
                GetWindowRect(WinData->m_Win, &Rect);
                MapWindowPoints(GetDesktopWindow(), g_hwndMDIClient,
                                (LPPOINT)&Rect, 1);
                X = Rect.left;
                Y = Rect.top;
            }
            else
            {
                // Line up with the first window.
                SetWindowPos(WinData->m_Win, NULL, X, Y, 0, 0,
                         SWP_NOZORDER | SWP_NOSIZE | SWP_NOACTIVATE);
            }
        }
    }
}

void
SetAllFonts(ULONG FontIndex)
{
    PLIST_ENTRY Entry;
    PCOMMONWIN_DATA WinData;

    for (Entry = g_ActiveWin.Flink;
         Entry != &g_ActiveWin;
         Entry = Entry->Flink)
    {
        WinData = ACTIVE_WIN_ENTRY(Entry);
        if (WinData != NULL)
        {
            WinData->SetFont(FontIndex);
            // Treat this like a resize as the line height
            // may change.
            WinData->OnSize();
        }
    }

    if (g_WinOptions & WOPT_AUTO_ARRANGE)
    {
        Arrange();
    }
}

void
CloseAllWindows(ULONG TypeMask)
{
    HWND Win, Next;
    
    Win = MDIGetActive(g_hwndMDIClient, NULL);
    while (Win != NULL)
    {
        PCOMMONWIN_DATA WinData;
        
        Next = GetNextWindow(Win, GW_HWNDNEXT);
        WinData = GetCommonWinData(Win);
        if (TypeMask == ALL_WINDOWS ||
            (WinData && (TypeMask & (1 << WinData->m_enumType))))
        {
            SendMessage(g_hwndMDIClient, WM_MDIDESTROY, (WPARAM)Win, 0);
        }
        Win = Next;
    }
}

void
UpdateAllColors(void)
{
    PLIST_ENTRY Entry;
    PCOMMONWIN_DATA WinData;

    for (Entry = g_ActiveWin.Flink;
         Entry != &g_ActiveWin;
         Entry = Entry->Flink)
    {
        WinData = ACTIVE_WIN_ENTRY(Entry);
        if (WinData != NULL)
        {
            WinData->UpdateColors();
        }
    }
}

PCOMMONWIN_DATA
FindNthWindow(ULONG Nth, ULONG Types)
{
    PLIST_ENTRY Entry;
    PCOMMONWIN_DATA WinData;

    for (Entry = g_ActiveWin.Flink;
         Entry != &g_ActiveWin;
         Entry = Entry->Flink)
    {
        WinData = ACTIVE_WIN_ENTRY(Entry);
        if (WinData != NULL &&
            ((1 << WinData->m_enumType) & Types) &&
            Nth-- == 0)
        {
            return WinData;
        }
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\windbg\callswin.cpp ===
/*++

Copyright (c) 1992-2002  Microsoft Corporation

Module Name:

    callswin.cpp

Abstract:

    This module contains the main line code for display of calls window.

Environment:

    Win32, User Mode

--*/


#include "precomp.hxx"
#pragma hdrstop

#define MIN_FRAMES 10
#define MORE_LESS 10

#define CALLS_CONTEXT_ID_BASE 0x100

#define TBB_MORE     9
#define TBB_LESS     10
#define TBB_COPY_ALL 13

// The IDs of the buttons are the bit shift of the
// corresponding flag.
TBBUTTON g_CallsTbButtons[] =
{
    TEXT_TB_BTN(0, "Args", BTNS_CHECK),
    TEXT_TB_BTN(1, "Func info", BTNS_CHECK),
    TEXT_TB_BTN(2, "Source", BTNS_CHECK),
    TEXT_TB_BTN(3, "Addrs", BTNS_CHECK),
    TEXT_TB_BTN(4, "Headings", BTNS_CHECK),
    TEXT_TB_BTN(5, "Nonvolatile regs", BTNS_CHECK),
    TEXT_TB_BTN(6, "Frame nums", BTNS_CHECK),
    TEXT_TB_BTN(7, "Arg types", BTNS_CHECK),
    SEP_TB_BTN(),
    TEXT_TB_BTN(TBB_MORE, "More", 0),
    TEXT_TB_BTN(TBB_LESS, "Less", 0),
    SEP_TB_BTN(),
    TEXT_TB_BTN(ID_SHOW_TOOLBAR, "Toolbar", 0),
    SEP_TB_BTN(),
    TEXT_TB_BTN(TBB_COPY_ALL, "Copy stack to clipboard", 0),
};

#define NUM_CALLS_MENU_BUTTONS \
    (sizeof(g_CallsTbButtons) / sizeof(g_CallsTbButtons[0]))
#define NUM_CALLS_TB_BUTTONS \
    (NUM_CALLS_MENU_BUTTONS - 4)

HMENU CALLSWIN_DATA::s_ContextMenu;

//
//
//
CALLSWIN_DATA::CALLSWIN_DATA()
    : SINGLE_CHILDWIN_DATA(1024)
{
    m_enumType = CALLS_WINDOW;
    m_Flags = 0;
    m_Frames = 20;
    m_FramesFound = 0;
    m_TextOffset = 0;
    m_WarningLine = 0xffffffff;
}

void
CALLSWIN_DATA::Validate()
{
    SINGLE_CHILDWIN_DATA::Validate();

    Assert(CALLS_WINDOW == m_enumType);
}

HRESULT
CALLSWIN_DATA::ReadState(void)
{
    HRESULT Status;
    ULONG FramesFound;
    ULONG TextOffset;

    Empty();
    
    //
    // Record the raw frame data first.
    //

    // Preallocate space to record the raw frames.
    if (AddData(sizeof(DEBUG_STACK_FRAME) * m_Frames) == NULL)
    {
        return E_OUTOFMEMORY;
    }

    // Allocate a separate buffer to hold the frames while
    // calling OutputStackTrace on them.  We can't just pass
    // in the state buffer pointer as resizing of the state
    // buffer may cause the data pointer to change.
    PDEBUG_STACK_FRAME RawFrames = (PDEBUG_STACK_FRAME)malloc(m_DataUsed);
    if (RawFrames == NULL)
    {
        return E_OUTOFMEMORY;
    }

    Status = g_pDbgControl->GetStackTrace(0, 0, 0, RawFrames, m_Frames,
                                          &FramesFound);
    if (Status != S_OK)
    {
        free(RawFrames);
        m_FramesFound = 0;
        m_TextOffset = 0;
        return Status;
    }
    
    TextOffset = m_DataUsed;
    
    g_OutStateBuf.SetBuffer(this);
    if ((Status = g_OutStateBuf.Start(FALSE)) != S_OK)
    {
        free(RawFrames);
        m_FramesFound = 0;
        m_TextOffset = 0;
        return Status;
    }

    // If nonvolatile registers were requested we can't use just
    // our saved frames as they require full context information.
    Status = g_pOutCapControl->
        OutputStackTrace(DEBUG_OUTCTL_THIS_CLIENT |
                         DEBUG_OUTCTL_OVERRIDE_MASK |
                         DEBUG_OUTCTL_NOT_LOGGED,
                         (m_Flags & DEBUG_STACK_NONVOLATILE_REGISTERS) ?
                         NULL : RawFrames, FramesFound, m_Flags);
    if (Status == S_OK)
    {
        Status = g_OutStateBuf.End(FALSE);
    }
    else
    {
        g_OutStateBuf.End(FALSE);
    }

    // Now that the state buffer is stable put the raw frame
    // data in.
    memcpy(m_Data, RawFrames, TextOffset);
    m_FramesFound = FramesFound;
    m_TextOffset = TextOffset;
    free(RawFrames);

    // Check and see if there's a stack trace warning and remember
    // it so we can ignore it.  We still want it in the text
    // as a reminder so we can't just remove it.
    ULONG Line = 0;
    PSTR Scan = (PSTR)m_Data + m_TextOffset;

    m_WarningLine = 0xffffffff;
    while (Scan < (PSTR)m_Data + m_DataUsed)
    {
        if (!memcmp(Scan, "WARNING:", 8))
        {
            m_WarningLine = Line;
            break;
        }

        Scan = strchr(Scan, '\n');
        if (!Scan)
        {
            break;
        }
        else
        {
            Scan++;
        }

        Line++;
    }
    
    return Status;
}

void
CALLSWIN_DATA::Copy()
{
    LRESULT Line = SendMessage(m_hwndChild, LB_GETCURSEL, 0, 0);
    Assert(Line != LB_ERR);

    LRESULT Len = SendMessage(m_hwndChild, LB_GETTEXTLEN, Line, 0);
    if (Len <= 0)
    {
        return;
    }

    Len++;
    
    PSTR Text = (PSTR)malloc(Len);

    if (!Text) 
    {
        return;
    }
    SendMessage(m_hwndChild, LB_GETTEXT, Line, (LPARAM)Text);
    Text[Len - 1] = 0;

    CopyToClipboard(Text, FALSE);

    free (Text);
    return;

}

BOOL 
CALLSWIN_DATA::CanWriteTextToFile()
{
    return TRUE;
}

HRESULT
CALLSWIN_DATA::WriteTextToFile(HANDLE File)
{
    HRESULT Status;
    BOOL Write;
    ULONG Done;
    
    if ((Status = UiLockForRead()) != S_OK)
    {
        return Status;
    }

    Write = WriteFile(File, (PSTR)m_Data + m_TextOffset,
                      m_DataUsed - m_TextOffset, &Done, NULL);

    UnlockStateBuffer(this);

    if (!Write)
    {
        return WIN32_LAST_STATUS();
    }
    if (Done < m_DataUsed - m_TextOffset)
    {
        return HRESULT_FROM_WIN32(ERROR_WRITE_FAULT);
    }

    return S_OK;
}

HMENU
CALLSWIN_DATA::GetContextMenu(void)
{
    ULONG i;
    
    //
    // We only keep one menu around for all call windows
    // so apply the menu check state for this particular
    // window.
    // In reality there's only one calls window anyway,
    // but this is a good example of how to handle
    // multi-instance windows.
    //

    for (i = 0; i < NUM_CALLS_TB_BUTTONS; i++)
    {
        CheckMenuItem(s_ContextMenu, i + CALLS_CONTEXT_ID_BASE,
                      MF_BYCOMMAND | ((m_Flags & (1 << i)) ? MF_CHECKED : 0));
    }
    CheckMenuItem(s_ContextMenu, ID_SHOW_TOOLBAR + CALLS_CONTEXT_ID_BASE,
                  MF_BYCOMMAND | (m_ShowToolbar ? MF_CHECKED : 0));
    
    return s_ContextMenu;
}

void
CALLSWIN_DATA::OnContextMenuSelection(UINT Item)
{
    Item -= CALLS_CONTEXT_ID_BASE;

    switch(Item)
    {
    case TBB_MORE:
        m_Frames += MORE_LESS;
        break;
    case TBB_LESS:
        if (m_Frames >= MIN_FRAMES + MORE_LESS)
        {
            m_Frames -= MORE_LESS;
        }
        break;
    case TBB_COPY_ALL:
        if (UiLockForRead() == S_OK)
        {
            CopyToClipboard((PSTR)m_Data + m_TextOffset, TRUE);
            UnlockStateBuffer(this);
        }
        break;
    case ID_SHOW_TOOLBAR:
        SetShowToolbar(!m_ShowToolbar);
        break;
    default:
        m_Flags ^= 1 << Item;
        SyncUiWithFlags(1 << Item);
        break;
    }
    if (g_Workspace != NULL)
    {
        g_Workspace->AddDirty(WSPF_DIRTY_WINDOWS);
    }
    UiRequestRead();
}

HRESULT
CALLSWIN_DATA::CodeExprAtCaret(PSTR Expr, PULONG64 Offset)
{
    HRESULT Status;
    
    ULONG Line = SelectionToFrame();
    if (Line >= m_FramesFound)
    {
        return E_INVALIDARG;
    }
    
    if ((Status = UiLockForRead()) != S_OK)
    {
        // Don't want to return any success codes here.
        return FAILED(Status) ? Status : E_FAIL;
    }
    
    PDEBUG_STACK_FRAME RawFrames = (PDEBUG_STACK_FRAME)m_Data;
    if (Expr != NULL)
    {
        sprintf(Expr, "0x%I64x", RawFrames[Line].InstructionOffset);
    }
    if (Offset != NULL)
    {
        *Offset = RawFrames[Line].InstructionOffset;
    }
    UnlockStateBuffer(this);
    return S_OK;
}

HRESULT
CALLSWIN_DATA::StackFrameAtCaret(PDEBUG_STACK_FRAME Frame)
{
    HRESULT Status;
    
    ULONG Line = SelectionToFrame();
    if (Line >= m_FramesFound)
    {
        return E_INVALIDARG;
    }
    
    if ((Status = UiLockForRead()) != S_OK)
    {
        // Don't want to return any success codes here.
        return FAILED(Status) ? Status : E_FAIL;
    }
    
    PDEBUG_STACK_FRAME RawFrames = (PDEBUG_STACK_FRAME)m_Data;
    *Frame = RawFrames[Line];
    UnlockStateBuffer(this);
    return S_OK;
}

BOOL
CALLSWIN_DATA::OnCreate(void)
{
    if (s_ContextMenu == NULL)
    {
        s_ContextMenu = CreateContextMenuFromToolbarButtons
            (NUM_CALLS_MENU_BUTTONS, g_CallsTbButtons, CALLS_CONTEXT_ID_BASE);
        if (s_ContextMenu == NULL)
        {
            return FALSE;
        }
    }
    
    m_Toolbar = CreateWindowEx(0, TOOLBARCLASSNAME, NULL,
                               WS_CHILD | WS_VISIBLE |
                               TBSTYLE_WRAPABLE | TBSTYLE_LIST | CCS_TOP,
                               0, 0, m_Size.cx, 0, m_Win, (HMENU)ID_TOOLBAR,
                               g_hInst, NULL);
    if (m_Toolbar == NULL)
    {
        return FALSE;
    }
    SendMessage(m_Toolbar, TB_BUTTONSTRUCTSIZE, sizeof(TBBUTTON), 0);
    SendMessage(m_Toolbar, TB_ADDBUTTONS, NUM_CALLS_TB_BUTTONS,
                (LPARAM)&g_CallsTbButtons);
    SendMessage(m_Toolbar, TB_AUTOSIZE, 0, 0);
    
    RECT Rect;
    GetClientRect(m_Toolbar, &Rect);
    m_ToolbarHeight = Rect.bottom - Rect.top;
    m_ShowToolbar = TRUE;

    m_hwndChild = CreateWindowEx(
        WS_EX_CLIENTEDGE,                           // Extended style
        _T("LISTBOX"),                              // class name
        NULL,                                       // title
        WS_CHILD | WS_VISIBLE
        | WS_MAXIMIZE
        | WS_HSCROLL | WS_VSCROLL
        | LBS_NOTIFY | LBS_WANTKEYBOARDINPUT
        | LBS_NOINTEGRALHEIGHT,                     // style
        0,                                          // x
        m_ToolbarHeight,                            // y
        m_Size.cx,                                  // width
        m_Size.cy - m_ToolbarHeight,                // height
        m_Win,                                      // parent
        0,                                          // control id
        g_hInst,                                    // hInstance
        NULL                                        // user defined data
        );

    if (m_hwndChild != NULL)
    {
        SetFont( FONT_FIXED );
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

LRESULT
CALLSWIN_DATA::OnCommand(
    WPARAM wParam,
    LPARAM lParam
    )
{
    if (HIWORD(wParam) == LBN_DBLCLK)
    {
        ULONG64 Offset;
        if (CodeExprAtCaret(NULL, &Offset) == S_OK)
        {
            UIC_DISPLAY_CODE_DATA* DispCode =
                StartStructCommand(UIC_DISPLAY_CODE);
            if (DispCode != NULL)
            {
                DispCode->Offset = Offset;
                FinishCommand();
            }
        }

        DEBUG_STACK_FRAME StkFrame;
        if (StackFrameAtCaret(&StkFrame) == S_OK)
        {
            UIC_SET_SCOPE_DATA* SetScope =
                StartStructCommand(UIC_SET_SCOPE);
            if (SetScope != NULL)
            {
                SetScope->StackFrame = StkFrame;
                FinishCommand();
            }
        }
        return 0;
    }

    if ((HWND)lParam == m_Toolbar)
    {
        OnContextMenuSelection(LOWORD(wParam) + CALLS_CONTEXT_ID_BASE);
        return 0;
    }
    
    return 0;
}

LRESULT
CALLSWIN_DATA::OnVKeyToItem(
    WPARAM wParam,
    LPARAM lParam
    )
{
    if (LOWORD(wParam) == VK_RETURN)
    {
        ULONG64 Offset;
        if (CodeExprAtCaret(NULL, &Offset) == S_OK)
        {
            UIC_DISPLAY_CODE_DATA* DispCode =
                StartStructCommand(UIC_DISPLAY_CODE);
            if (DispCode != NULL)
            {
                DispCode->Offset = Offset;
                FinishCommand();
            }
        }
        DEBUG_STACK_FRAME StkFrame;
        if (StackFrameAtCaret(&StkFrame) == S_OK)
        {
            UIC_SET_SCOPE_DATA* SetScope =
                StartStructCommand(UIC_SET_SCOPE);
            if (SetScope != NULL)
            {
                SetScope->StackFrame = StkFrame;
                FinishCommand();
            }
        }

    }
    else if (_T('G') == LOWORD(wParam))
    {
        ULONG64 Offset;
        if (CodeExprAtCaret(NULL, &Offset) == S_OK)
        {
            PrintStringCommand(UIC_EXECUTE, "g 0x%I64x", Offset);
        }
    }
    else if (_T('R') == LOWORD(wParam))
    {
        OnUpdate(UPDATE_BUFFER);
    }
    else
    {
        // Default behavior.
        return -1;
    }

    // Keystroke processed.
    return -2;
}

void
CALLSWIN_DATA::OnUpdate(
    UpdateType Type
    )
{
    if (Type != UPDATE_BUFFER)
    {
        return;
    }
    
    LRESULT lbItem;
    int     nFrameCount;
    HRESULT Status;

    lbItem = SendMessage( m_hwndChild, LB_GETCURSEL, 0, 0 );
    
    SendMessage( m_hwndChild, WM_SETREDRAW, FALSE, 0L );
    SendMessage( m_hwndChild, LB_RESETCONTENT, 0, 0 );

    Status = UiLockForRead();
    if (Status == S_OK)
    {
        PSTR Buf = (PSTR)m_Data + m_TextOffset;
        // Ignore final terminator.
        PSTR End = (PSTR)m_Data + m_DataUsed - 1;
        ULONG Width = 0;

        nFrameCount = 0;

        while (Buf < End)
        {
            PSTR Sep = strchr(Buf, '\n');
            if (!Sep)
            {
                // Shouldn't happen, but just in case.
                break;
            }
            
            ULONG Len = (ULONG)(Sep - Buf);
            ULONG StrWidth = Len * m_Font->Metrics.tmAveCharWidth;
            *Sep = 0;
            SendMessage(m_hwndChild, LB_ADDSTRING, 0, (LPARAM)Buf);
            Buf = Sep;
            *Buf++ = '\n';
            if (StrWidth > Width)
            {
                Width = StrWidth;
            }
            nFrameCount++;
        }

        SendMessage(m_hwndChild, LB_SETHORIZONTALEXTENT, Width, 0);
        UnlockStateBuffer(this);
    }
    else
    {
        SendLockStatusMessage(m_hwndChild, LB_ADDSTRING, Status);
        nFrameCount = 1;
    }

    SendMessage( m_hwndChild, LB_SETCURSEL,
                 (lbItem > nFrameCount) ? 0 : lbItem, 0 );
    SendMessage( m_hwndChild, WM_SETREDRAW, TRUE, 0L );
}

ULONG
CALLSWIN_DATA::GetWorkspaceSize(void)
{
    return SINGLE_CHILDWIN_DATA::GetWorkspaceSize() + 2 * sizeof(ULONG);
}

PUCHAR
CALLSWIN_DATA::SetWorkspace(PUCHAR Data)
{
    Data = SINGLE_CHILDWIN_DATA::SetWorkspace(Data);
    *(PULONG)Data = m_Flags;
    Data += sizeof(ULONG);
    *(PULONG)Data = m_Frames;
    Data += sizeof(ULONG);
    return Data;
}

PUCHAR
CALLSWIN_DATA::ApplyWorkspace1(PUCHAR Data, PUCHAR End)
{
    Data = SINGLE_CHILDWIN_DATA::ApplyWorkspace1(Data, End);

    if (End - Data >= 2 * sizeof(ULONG))
    {
        m_Flags = *(PULONG)Data;
        Data += sizeof(ULONG);
        m_Frames = *(PULONG)Data;
        Data += sizeof(ULONG);

        SyncUiWithFlags(0xffffffff);
        UiRequestRead();
    }

    return Data;
}

void
CALLSWIN_DATA::SyncUiWithFlags(ULONG Changed)
{
    ULONG i;

    //
    // Set toolbar button state from flags.
    //

    for (i = 0; i < NUM_CALLS_TB_BUTTONS; i++)
    {
        if (Changed & (1 << i))
        {
            SendMessage(m_Toolbar, TB_SETSTATE, g_CallsTbButtons[i].idCommand,
                        TBSTATE_ENABLED |
                        ((m_Flags & (1 << i)) ? TBSTATE_CHECKED : 0));
        }
    }
}

ULONG
CALLSWIN_DATA::SelectionToFrame(void)
{
    LRESULT CurSel = SendMessage(m_hwndChild, LB_GETCURSEL, 0, 0);
    // Check for no-selection.
    if (CurSel < 0)
    {
        return 0xffffffff;
    }
    
    ULONG Line = (ULONG)CurSel;
    
    // If there's a WARNING line ignore it.
    if (Line == m_WarningLine)
    {
        return 0xffffffff;
    }
    else if (Line > m_WarningLine)
    {
        Line--;
    }

    // If the column headers are on ignore the header line.
    if (m_Flags & DEBUG_STACK_COLUMN_NAMES)
    {
        if (Line == 0)
        {
            return 0xffffffff;
        }
        else
        {
            Line--;
        }
    }
    
    return Line;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\windbg\cmnwin.h ===
/*++

Copyright (c) 1992-2002  Microsoft Corporation

Module Name:

    cmnwin.h

Abstract:

    Header for common window architecture functions.    

Environment:

    Win32, User Mode

--*/

// Millisecond delay value before evaluating input in
// edit boxes.  Required because there's only a per-character
// change notification and we don't want to reevaluate on
// every character.
#define EDIT_DELAY 500

// Several windows have edit boxes for entering offset
// expressions.
#define MAX_OFFSET_EXPR (MAX_PATH + 64)

//
// Window-related options.
//

#define WOPT_AUTO_ARRANGE       0x00000001
#define WOPT_ARRANGE_ALL        0x00000002
#define WOPT_AUTO_DISASM        0x00000004
#define WOPT_OVERLAY_SOURCE     0x00000008

extern ULONG g_WinOptions;
extern ULONG g_AutoArrangeWarningCount;

enum
{
    FONT_FIXED,
    FONT_VARIABLE,
    FONT_COUNT
};

struct INDEXED_FONT
{
    HFONT Font;
    TEXTMETRIC Metrics;
    LOGFONT LogFont;
    BOOL LogFontSet;
};

extern INDEXED_FONT g_Fonts[];

#define LINE_MARKERS 2

extern BOOL g_LineMarkers;

//----------------------------------------------------------------------------
//
// COMMONWIN_DATA and family.
//
//----------------------------------------------------------------------------

// List of all commonwin's still associated with an HWND.
// This list entry is a member of the commonwin and is
// different from the derivation list entry.  Use
// the ACTIVE_WIN_ENTRY macro to get from an entry to
// the actual commonwin.
extern LIST_ENTRY g_ActiveWin;

#define ACTIVE_WIN_ENTRY(Entry) \
    ((PCOMMONWIN_DATA) \
     ((PUCHAR)(Entry) - FIELD_OFFSET(COMMONWIN_DATA, m_ActiveWin)))

struct COMMONWIN_CREATE_DATA
{
    WIN_TYPES Type;
};

//
// Data common to all window structures
//
class COMMONWIN_DATA : public StateBuffer
{
public:
    LIST_ENTRY          m_ActiveWin;
    SIZEL               m_Size;
    ULONG               m_CausedArrange;
    ULONG               m_InAutoOp;
    INDEXED_FONT*       m_Font;
    // Height of current font.
    ULONG               m_FontHeight;
    // Height of window in lines of the current font, rounded down.
    ULONG               m_LineHeight;

    // Toolbar if this window has one.
    HWND                m_Toolbar;
    BOOL                m_ShowToolbar;
    int                 m_ToolbarHeight;
    int                 m_MinToolbarWidth;
    HWND                m_ToolbarEdit;
    
    COMMONWIN_DATA(ULONG ChangeBy);

    virtual void Validate();

    virtual void SetFont(ULONG FontIndex);

    virtual BOOL CanCopy();
    virtual BOOL CanCut();
    virtual BOOL CanPaste();
    virtual void Copy();
    virtual void Cut();
    virtual void Paste();
    virtual BOOL CanSelectAll();
    virtual void SelectAll();
    virtual BOOL SelectedText(PTSTR Buffer, ULONG BufferChars);

    virtual BOOL CanWriteTextToFile(void);
    virtual HRESULT WriteTextToFile(HANDLE File);
    
    virtual BOOL HasEditableProperties();
    virtual BOOL EditProperties();

    virtual HMENU GetContextMenu(void);
    virtual void  OnContextMenuSelection(UINT Item);
    
    virtual BOOL CanGotoLine(void);
    virtual void GotoLine(ULONG Line);

    virtual void Find(PTSTR Text, ULONG Flags, BOOL FromDlg);
    
    virtual HRESULT CodeExprAtCaret(PSTR Expr, ULONG ExprSize,
                                    PULONG64 Offset);
    virtual void ToggleBpAtCaret(void);
    
    // Functions called in response to WM messages
    virtual BOOL OnCreate(void);
    virtual LRESULT OnCommand(WPARAM wParam, LPARAM lParam);
    virtual void OnSetFocus(void);
    virtual void OnSize(void);
    virtual void OnButtonDown(ULONG Button);
    virtual void OnButtonUp(ULONG Button);
    virtual void OnMouseMove(ULONG Modifiers, ULONG X, ULONG Y);
    virtual void OnTimer(WPARAM TimerId);
    virtual LRESULT OnGetMinMaxInfo(LPMINMAXINFO Info);
    virtual LRESULT OnVKeyToItem(WPARAM wParam, LPARAM lParam);
    virtual LRESULT OnNotify(WPARAM wParam, LPARAM lParam);
    virtual void OnUpdate(UpdateType Type);
    virtual void OnDestroy(void);
    virtual LRESULT OnOwnerDraw(UINT uMsg, WPARAM wParam, LPARAM lParam);

    virtual ULONG GetWorkspaceSize(void);
    virtual PUCHAR SetWorkspace(PUCHAR Data);
    virtual PUCHAR ApplyWorkspace1(PUCHAR Data, PUCHAR End);

    virtual void UpdateColors(void);
    
    void UpdateSize(ULONG Width, ULONG Height);
    void SetShowToolbar(BOOL Show);

    static LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg,
                                       WPARAM wParam, LPARAM lParam);
};
typedef COMMONWIN_DATA *PCOMMONWIN_DATA;


//
// Data common to all window structures
// that only have one child
//
class SINGLE_CHILDWIN_DATA : public COMMONWIN_DATA
{
public:
    HWND    m_hwndChild;


    SINGLE_CHILDWIN_DATA(ULONG ChangeBy);

    virtual void Validate();

    virtual void SetFont(ULONG FontIndex);

    virtual BOOL CanCopy();
    virtual BOOL CanCut();
    virtual BOOL CanPaste();
    virtual void Copy();
    virtual void Cut();
    virtual void Paste();

    // Functions called in response to WM messages
    virtual void OnSetFocus(void);
    virtual void OnSize(void);
    
    virtual void UpdateColors(void);
};
typedef SINGLE_CHILDWIN_DATA *PSINGLE_CHILDWIN_DATA;

#define IDC_PROCESS_TREE 1234

class PROCESS_THREAD_DATA : public SINGLE_CHILDWIN_DATA
{
public:
    // Set in ReadState.
    ULONG m_TotalSystems, m_NamesOffset;

    PROCESS_THREAD_DATA();

    virtual void Validate();

    HRESULT ReadProcess(ULONG ProcId, PULONG Offset);
    HRESULT ReadSystem(ULONG SysId, PULONG Offset);
    virtual HRESULT ReadState(void);
    
    virtual BOOL OnCreate(void);
    virtual LRESULT OnNotify(WPARAM wParam, LPARAM lParam);
    virtual void OnUpdate(UpdateType Type);

    virtual void UpdateColors(void);

    void SetCurThreadFromProcessTreeItem(HWND Tree, HTREEITEM Sel);
};
typedef PROCESS_THREAD_DATA *PPROCESS_THREAD_DATA;


#define EHL_CURRENT_LINE 0x00000001
#define EHL_ENABLED_BP   0x00000002
#define EHL_DISABLED_BP  0x00000004

#define EHL_ANY_BP (EHL_ENABLED_BP | EHL_DISABLED_BP)

struct EDIT_HIGHLIGHT
{
    EDIT_HIGHLIGHT* Next;
    ULONG64 Data;
    ULONG Line;
    ULONG Flags;
};

class EDITWIN_DATA : public SINGLE_CHILDWIN_DATA
{
public:
    // Total number of lines in the edit window.
    ULONG m_TextLines;

    EDIT_HIGHLIGHT* m_Highlights;

    EDITWIN_DATA(ULONG ChangeBy);

    virtual void Validate();

    virtual void SetFont(ULONG FontIndex);
    
    virtual BOOL CanSelectAll();
    virtual void SelectAll();
    
    virtual BOOL OnCreate(void);
    virtual LRESULT OnNotify(WPARAM wParam, LPARAM lParam);
    virtual void OnDestroy(void);

    virtual void UpdateColors(void);

    void SetCurrentLineHighlight(ULONG Line);
    void RemoveCurrentLineHighlight(void)
    {
        SetCurrentLineHighlight(ULONG_MAX);
    }
    void UpdateCurrentLineHighlight(void);
    EDIT_HIGHLIGHT* GetLineHighlighting(ULONG Line);
    
    void ApplyHighlight(EDIT_HIGHLIGHT* Hl);
    EDIT_HIGHLIGHT* AddHighlight(ULONG Line, ULONG Flags);
    void RemoveHighlight(ULONG Line, ULONG Flags);
    void RemoveAllHighlights(ULONG Flags);
    static void RemoveActiveWinHighlights(ULONG Types, ULONG Flags);

    // Base implementation does nothing.
    virtual void UpdateBpMarks(void);

    int CheckForFileChanges(PCSTR File, FILETIME* LastWrite);
};
typedef EDITWIN_DATA *PEDITWIN_DATA;


class SCRATCH_PAD_DATA : public EDITWIN_DATA
{
public:
    SCRATCH_PAD_DATA();

    virtual void Validate();

    virtual void Cut();
    virtual void Paste();

    virtual BOOL CanWriteTextToFile(void);
    virtual HRESULT WriteTextToFile(HANDLE File);
    
    virtual BOOL OnCreate(void);
    virtual LRESULT OnNotify(WPARAM wParam, LPARAM lParam);
};
typedef SCRATCH_PAD_DATA *PSCRATCH_PAD_DATA;


#define IDC_DISASM_PREVIOUS 1234
#define IDC_DISASM_NEXT     1235

class DISASMWIN_DATA : public EDITWIN_DATA
{
public:
    char m_OffsetExpr[MAX_OFFSET_EXPR];
    BOOL m_UpdateExpr;
    HWND m_PreviousButton;
    HWND m_NextButton;

    // Set in ReadState.
    ULONG64 m_FirstInstr;
    ULONG64 m_PrimaryInstr;
    ULONG64 m_LastInstr;
    ULONG m_PrimaryLine;
    ULONG m_TextOffset;

    DISASMWIN_DATA();

    virtual void Validate();

    virtual HRESULT ReadState(void);
    
    virtual HRESULT CodeExprAtCaret(PSTR Expr, ULONG ExprSize,
                                    PULONG64 Offset);
    
    virtual BOOL OnCreate(void);
    virtual LRESULT OnCommand(WPARAM wParam, LPARAM lParam);
    virtual void OnSize(void);
    virtual void OnTimer(WPARAM TimerId);
    virtual LRESULT OnNotify(WPARAM wParam, LPARAM lParam);
    virtual void OnUpdate(UpdateType Type);
    virtual void UpdateBpMarks(void);

    void SetCurInstr(ULONG64 Offset);

    void ScrollLower(void)
    {
        if (m_FirstInstr != 0)
        {
            SetCurInstr(m_FirstInstr);
        }
    }
    void ScrollHigher(void)
    {
        if (m_LastInstr != 0)
        {
            SetCurInstr(m_LastInstr);
        }
    }
};
typedef DISASMWIN_DATA *PDISASMWIN_DATA;



// Array of active commonwin's indexed by WIN_TYPES.
extern PCOMMONWIN_DATA g_IndexedWin[];
extern HWND g_IndexedHwnd[];

#define GetWatchHwnd()          g_IndexedHwnd[WATCH_WINDOW]
#define GetLocalsHwnd()         g_IndexedHwnd[LOCALS_WINDOW]
#define GetCpuHwnd()            g_IndexedHwnd[CPU_WINDOW]
#define GetDisasmHwnd()         g_IndexedHwnd[DISASM_WINDOW]
#define GetCmdHwnd()            g_IndexedHwnd[CMD_WINDOW]
#define GetScratchHwnd()        g_IndexedHwnd[SCRATCH_PAD_WINDOW]
#define GetCallsHwnd()          g_IndexedHwnd[CALLS_WINDOW]
#define GetQuickWatchHwnd()     g_IndexedHwnd[QUICKW_WINDOW]
#define GetProcessThreadHwnd()  g_IndexedHwnd[PROCESS_THREAD_WINDOW]


// Size of caption bar plus window frame.
#define WIN_EXTRA_HEIGHT \
    (2 * GetSystemMetrics(SM_CYBORDER) + 3 * GetSystemMetrics(SM_CYFRAME) + \
     GetSystemMetrics(SM_CYCAPTION))

// Attempt to make most text windows 80 chars wide by default.
// Most windows end up with a scroll bar so add that in on top.
#define WIDTH_80 \
    (g_Fonts[FONT_FIXED].Metrics.tmAveCharWidth * 80 + GetSystemMetrics(SM_CXVSCROLL))

// Make all the left-side windows (command, stack, ...) 80 columns.
#define LEFT_SIDE_WIDTH WIDTH_80
// Require some space for left-side windows.
#define LEFT_SIDE_MIN_WIDTH \
    (g_Fonts[FONT_FIXED].Metrics.tmAveCharWidth * 15 + GetSystemMetrics(SM_CXVSCROLL))
#define LEFT_SIDE_MIN_HEIGHT \
    (g_Fonts[FONT_FIXED].Metrics.tmHeight * 5 + WIN_EXTRA_HEIGHT)

// Make all the right-side windows (cpu, ...) narrow.
#define RIGHT_SIDE_MIN_WIDTH_32 \
    (g_Fonts[FONT_FIXED].Metrics.tmAveCharWidth * 15 + GetSystemMetrics(SM_CXVSCROLL))
#define RIGHT_SIDE_DESIRED_WIDTH_32 \
    (g_Fonts[FONT_FIXED].Metrics.tmAveCharWidth * 25 + GetSystemMetrics(SM_CXVSCROLL))
#define RIGHT_SIDE_MIN_WIDTH_64 \
    (g_Fonts[FONT_FIXED].Metrics.tmAveCharWidth * 20 + GetSystemMetrics(SM_CXVSCROLL))
#define RIGHT_SIDE_DESIRED_WIDTH_64 \
    (g_Fonts[FONT_FIXED].Metrics.tmAveCharWidth * 30 + GetSystemMetrics(SM_CXVSCROLL))

#define DOC_WIDTH       WIDTH_80
#define DISASM_WIDTH    WIDTH_80
#define CMD_WIDTH       WIDTH_80
#define CALLS_WIDTH     WIDTH_80

// Give plenty of room for the command window.
#define CMD_HEIGHT \
    (g_Fonts[FONT_FIXED].Metrics.tmHeight * 38)
#define CMD_MIN_HEIGHT \
    (g_Fonts[FONT_FIXED].Metrics.tmHeight * 25)

#define CPU_WIDTH_32 RIGHT_SIDE_DESIRED_WIDTH_32
#define CPU_WIDTH_64 RIGHT_SIDE_DESIRED_WIDTH_64
#define CPU_HEIGHT g_MdiHeight

// Keep the calls window short but with enough lines to be useful.
#define CALLS_MIN_HEIGHT LEFT_SIDE_MIN_HEIGHT
#define CALLS_HEIGHT \
    (g_Fonts[FONT_FIXED].Metrics.tmHeight * 10 + WIN_EXTRA_HEIGHT)

// Give the code windows enough lines to provide useful context.
#define DISASM_HEIGHT \
    (g_Fonts[FONT_FIXED].Metrics.tmHeight * 30 + WIN_EXTRA_HEIGHT)
#define DOC_HEIGHT DISASM_HEIGHT

void Arrange(void);
BOOL IsAutoArranged(WIN_TYPES Type);
void DisplayAutoArrangeWarning(PCOMMONWIN_DATA CmnWin);
void UpdateSourceOverlay(void);
void SetAllFonts(ULONG FontIndex);
void CloseAllWindows(ULONG TypeMask);
void UpdateAllColors(void);
PCOMMONWIN_DATA FindNthWindow(ULONG Nth, ULONG Types);

void RicheditFind(HWND Edit,
                  PTSTR Text, ULONG Flags,
                  CHARRANGE* SaveSel, PULONG SaveFlags,
                  BOOL HideSel);
HRESULT RicheditWriteToFile(HWND Edit, HANDLE File);
void RicheditUpdateColors(HWND Edit,
                          COLORREF Fg, BOOL UpdateFg,
                          COLORREF Bg, BOOL UpdateBg);
void RicheditScrollToLine(HWND Edit, ULONG Line, ULONG VisLines);
ULONG RicheditGetSelectionText(HWND Edit, PTSTR Buffer, ULONG BufferChars);
ULONG RicheditGetSourceToken(HWND Edit, PTSTR Buffer, ULONG BufferChars,
                             CHARRANGE* Range);

#define NTH_OPEN_ALWAYS 0xffffffff

HWND
New_OpenDebugWindow(
    WIN_TYPES   winType,
    BOOL        bUserActivated,
    ULONG       Nth
    );

HWND
New_CreateWindow(
    HWND      hwndParent,
    WIN_TYPES Type,
    UINT      uClassId,
    UINT      uWinTitle,
    PRECT     pRect
    );

HWND 
NewCmd_CreateWindow(
    HWND
    );

HWND
NewWatch_CreateWindow(
    HWND
    );

HWND
NewLocals_CreateWindow(
    HWND
    );

HWND
NewCpu_CreateWindow(
    HWND
    );

HWND
NewDisasm_CreateWindow(
    HWND
    );

HWND
NewQuickWatch_CreateWindow(
    HWND
    );

HWND
NewCalls_CreateWindow(
    HWND
    );

HWND
NewDoc_CreateWindow(
    HWND
    );

HWND
NewMemory_CreateWindow(
    HWND
    );

HWND
NewScratch_CreateWindow(
    HWND
    );

HWND
NewProcessThread_CreateWindow(
    HWND
    );

#undef DEFINE_GET_WINDATA

#define DEFINE_GET_WINDATA(ClassType, FuncName)   \
    class ClassType * Get##FuncName##WinData(HWND);

#include "fncdefs.h"

#undef DEFINE_GET_WINDATA
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\windbg\cmnwin.cpp ===
/*++

Copyright (c) 1999-2002  Microsoft Corporation

Module Name:

    cmnwin.cpp

Abstract:

    This module contains the code for the common window architecture.

--*/

#include "precomp.hxx"
#pragma hdrstop

ULONG g_WinOptions = WOPT_AUTO_ARRANGE | WOPT_AUTO_DISASM;

LIST_ENTRY g_ActiveWin;

PCOMMONWIN_DATA g_IndexedWin[MAXVAL_WINDOW];
HWND g_IndexedHwnd[MAXVAL_WINDOW];

INDEXED_FONT g_Fonts[FONT_COUNT];

BOOL g_LineMarkers = FALSE;

#define CW_WSP_SIG3 '3WCW'

//
//
//
COMMONWIN_DATA::COMMONWIN_DATA(ULONG ChangeBy)
    : StateBuffer(ChangeBy)
{
    m_Size.cx = 0;
    m_Size.cy = 0;
    m_CausedArrange = FALSE;
    // Creation is an automatic operation so
    // InAutoOp is initialized to a non-zero value.
    // After CreateWindow returns it is decremented.
    m_InAutoOp = 1;
    m_enumType = MINVAL_WINDOW;
    m_Font = &g_Fonts[FONT_FIXED];
    m_FontHeight = 0;
    m_LineHeight = 0;
    m_Toolbar = NULL;
    m_ShowToolbar = FALSE;
    m_ToolbarHeight = 0;
    m_MinToolbarWidth = 0;
    m_ToolbarEdit = NULL;
}

void
COMMONWIN_DATA::Validate()
{
    Assert(MINVAL_WINDOW < m_enumType);
    Assert(m_enumType < MAXVAL_WINDOW);
}

void 
COMMONWIN_DATA::SetFont(ULONG FontIndex)
{
    m_Font = &g_Fonts[FontIndex];
    m_FontHeight = m_Font->Metrics.tmHeight;
    m_LineHeight = m_Size.cy / m_FontHeight;
}

BOOL
COMMONWIN_DATA::CanCopy()
{
    if (GetFocus() == m_ToolbarEdit)
    {
        DWORD Start, End;
        SendMessage(m_ToolbarEdit, EM_GETSEL,
                    (WPARAM)&Start, (WPARAM)&End);
        return Start != End;
    }
    else
    {
        return FALSE;
    }
}

BOOL
COMMONWIN_DATA::CanCut()
{
    if (GetFocus() == m_ToolbarEdit)
    {
        DWORD Start, End;
        SendMessage(m_ToolbarEdit, EM_GETSEL,
                    (WPARAM)&Start, (WPARAM)&End);
        return Start != End;
    }
    else
    {
        return FALSE;
    }
}

BOOL
COMMONWIN_DATA::CanPaste()
{
    if (GetFocus() == m_ToolbarEdit)
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

void
COMMONWIN_DATA::Copy()
{
    if (GetFocus() == m_ToolbarEdit)
    {
        SendMessage(m_ToolbarEdit, WM_COPY, 0, 0);
    }
}

void
COMMONWIN_DATA::Cut()
{
    if (GetFocus() == m_ToolbarEdit)
    {
        SendMessage(m_ToolbarEdit, WM_CUT, 0, 0);
    }
}

void
COMMONWIN_DATA::Paste()
{
    if (GetFocus() == m_ToolbarEdit)
    {
        SendMessage(m_ToolbarEdit, WM_PASTE, 0, 0);
    }
}

BOOL
COMMONWIN_DATA::CanSelectAll()
{
    return FALSE;
}

void
COMMONWIN_DATA::SelectAll()
{
}

BOOL
COMMONWIN_DATA::SelectedText(PTSTR Buffer, ULONG BufferChars)
{
    return FALSE;
}

BOOL 
COMMONWIN_DATA::CanWriteTextToFile()
{
    return FALSE;
}

HRESULT
COMMONWIN_DATA::WriteTextToFile(HANDLE File)
{
    return E_NOTIMPL;
}

BOOL 
COMMONWIN_DATA::HasEditableProperties()
{
    return FALSE;
}

BOOL 
COMMONWIN_DATA::EditProperties()
/*++
Returns
    TRUE - If properties were edited
    FALSE - If nothing was changed
--*/
{
    return FALSE;
}

HMENU
COMMONWIN_DATA::GetContextMenu(void)
{
    return NULL;
}

void
COMMONWIN_DATA::OnContextMenuSelection(UINT Item)
{
    // Nothing to do.
}

BOOL
COMMONWIN_DATA::CanGotoLine(void)
{
    return FALSE;
}

void
COMMONWIN_DATA::GotoLine(ULONG Line)
{
    // Do nothing.
}

void
COMMONWIN_DATA::Find(PTSTR Text, ULONG Flags, BOOL FromDlg)
{
    // Do nothing.
}

HRESULT
COMMONWIN_DATA::CodeExprAtCaret(PSTR Expr, ULONG ExprSize, PULONG64 Offset)
{
    return E_NOINTERFACE;
}

void
COMMONWIN_DATA::ToggleBpAtCaret(void)
{
    char CodeExpr[MAX_OFFSET_EXPR];
    ULONG64 Offset;
    
    if (CodeExprAtCaret(CodeExpr, DIMA(CodeExpr), &Offset) != S_OK)
    {
        MessageBeep(0);
        ErrorBox(NULL, 0, ERR_No_Code_For_File_Line);
        return;
    }

    ULONG CurBpId = DEBUG_ANY_ID;

    // This doesn't work too well with duplicate
    // breakpoints, but that should be a minor problem.
    if (IsBpAtOffset(NULL, Offset, &CurBpId) != BP_NONE)
    {
        PrintStringCommand(UIC_SILENT_EXECUTE, "bc %d", CurBpId);
    }
    else
    {
        PrintStringCommand(UIC_SILENT_EXECUTE, "bp %s", CodeExpr);
    }
}

BOOL
COMMONWIN_DATA::OnCreate(void)
{
    return TRUE;
}

LRESULT
COMMONWIN_DATA::OnCommand(WPARAM wParam, LPARAM lParam)
{
    return 1;
}

void
COMMONWIN_DATA::OnSetFocus(void)
{
}

void
COMMONWIN_DATA::OnSize(void)
{
    RECT Rect;
    
    // Resize the toolbar.
    if (m_Toolbar != NULL && m_ShowToolbar)
    {
        // If the toolbar gets too small sometimes it's better
        // to just let it get clipped rather than have it
        // try to fit into a narrow column.
        if (m_Size.cx >= m_MinToolbarWidth)
        {
            MoveWindow(m_Toolbar, 0, 0, m_Size.cx, m_ToolbarHeight, TRUE);
        }

        // Record what size it ended up.
        GetClientRect(m_Toolbar, &Rect);
        m_ToolbarHeight = Rect.bottom - Rect.top;

        if (m_FontHeight != 0)
        {
            if (m_ToolbarHeight >= m_Size.cy)
            {
                m_LineHeight = 0;
            }
            else
            {
                m_LineHeight = (m_Size.cy - m_ToolbarHeight) / m_FontHeight;
            }
        }
    }
    else
    {
        Assert(m_ToolbarHeight == 0);
    }
}

void
COMMONWIN_DATA::OnButtonDown(ULONG Button)
{
}

void
COMMONWIN_DATA::OnButtonUp(ULONG Button)
{
}

void
COMMONWIN_DATA::OnMouseMove(ULONG Modifiers, ULONG X, ULONG Y)
{
}

void
COMMONWIN_DATA::OnTimer(WPARAM TimerId)
{
}

LRESULT
COMMONWIN_DATA::OnGetMinMaxInfo(LPMINMAXINFO Info)
{
    return 1;
}

LRESULT
COMMONWIN_DATA::OnVKeyToItem(WPARAM wParam, LPARAM lParam)
{
    return -1;
}

LRESULT
COMMONWIN_DATA::OnNotify(WPARAM wParam, LPARAM lParam)
{
    return 0;
}

void
COMMONWIN_DATA::OnUpdate(UpdateType Type)
{
}

void
COMMONWIN_DATA::OnDestroy(void)
{
}

LRESULT
COMMONWIN_DATA::OnOwnerDraw(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    return 0;
}

ULONG
COMMONWIN_DATA::GetWorkspaceSize(void)
{
    return 3 * sizeof(ULONG) + sizeof(WINDOWPLACEMENT);
}

PUCHAR
COMMONWIN_DATA::SetWorkspace(PUCHAR Data)
{
    // First store the special signature that marks
    // this version of the workspace data.
    *(PULONG)Data = CW_WSP_SIG3;
    Data += sizeof(ULONG);

    // Store the size saved by this layer.
    *(PULONG)Data = COMMONWIN_DATA::GetWorkspaceSize();
    Data += sizeof(ULONG);

    //
    // Store the actual data.
    //

    *(PULONG)Data = m_ShowToolbar;
    Data += sizeof(ULONG);
    
    LPWINDOWPLACEMENT Place = (LPWINDOWPLACEMENT)Data;
    Place->length = sizeof(WINDOWPLACEMENT);
    GetWindowPlacement(m_Win, Place);
    Data += sizeof(WINDOWPLACEMENT);

    return Data;
}

PUCHAR
COMMONWIN_DATA::ApplyWorkspace1(PUCHAR Data, PUCHAR End)
{
    ULONG_PTR Size = End - Data;
    
    // There are three versions of the base COMMONWIN data.
    // 1. RECT.
    // 2. WINDOWPLACEMENT.
    // 3. CW_WSP_SIG3 sized block.
    // All three cases can be easily distinguished.

    if (Size > 2 * sizeof(ULONG) &&
        *(PULONG)Data == CW_WSP_SIG3 &&
        Size >= *(PULONG)(Data + sizeof(ULONG)))
    {
        Size = *(PULONG)(Data + sizeof(ULONG)) - 2 * sizeof(ULONG);
        Data += 2 * sizeof(ULONG);
        
        if (Size >= sizeof(ULONG))
        {
            SetShowToolbar(*(PULONG)Data);
            Size -= sizeof(ULONG);
            Data += sizeof(ULONG);
        }
    }

    if (Size >= sizeof(WINDOWPLACEMENT) &&
        ((LPWINDOWPLACEMENT)Data)->length == sizeof(WINDOWPLACEMENT))
    {
        LPWINDOWPLACEMENT Place = (LPWINDOWPLACEMENT)Data;

        if (!IsAutoArranged(m_enumType))
        {
            SetWindowPlacement(m_Win, Place);
        }
        
        return (PUCHAR)(Place + 1);
    }
    else
    {
        LPRECT Rect = (LPRECT)Data;
        Assert((PUCHAR)(Rect + 1) <= End);
    
        if (!IsAutoArranged(m_enumType))
        {
            MoveWindow(m_Win, Rect->left, Rect->top,
                       (Rect->right - Rect->left), (Rect->bottom - Rect->top),
                       TRUE);
        }
    
        return (PUCHAR)(Rect + 1);
    }
}

void
COMMONWIN_DATA::UpdateColors(void)
{
    // Nothing to do.
}

void
COMMONWIN_DATA::UpdateSize(ULONG Width, ULONG Height)
{
    m_Size.cx = Width;
    m_Size.cy = Height;
    if (m_FontHeight != 0)
    {
        m_LineHeight = m_Size.cy / m_FontHeight;
    }
}

void
COMMONWIN_DATA::SetShowToolbar(BOOL Show)
{
    if (!m_Toolbar)
    {
        return;
    }
    
    m_ShowToolbar = Show;
    if (m_ShowToolbar)
    {
        ShowWindow(m_Toolbar, SW_SHOW);
    }
    else
    {
        ShowWindow(m_Toolbar, SW_HIDE);
        m_ToolbarHeight = 0;
    }

    OnSize();
    if (g_Workspace != NULL)
    {
        g_Workspace->AddDirty(WSPF_DIRTY_WINDOWS);
    }
}

PCOMMONWIN_DATA
NewWinData(WIN_TYPES Type)
{
    switch(Type)
    {
    case DOC_WINDOW:
        return new DOCWIN_DATA;
    case WATCH_WINDOW:
        return new WATCHWIN_DATA;
    case LOCALS_WINDOW:
        return new LOCALSWIN_DATA;
    case CPU_WINDOW:
        return new CPUWIN_DATA;
    case DISASM_WINDOW:
        return new DISASMWIN_DATA;
    case CMD_WINDOW:
        return new CMDWIN_DATA;
    case SCRATCH_PAD_WINDOW:
        return new SCRATCH_PAD_DATA;
    case MEM_WINDOW:
        return new MEMWIN_DATA;
#if 0
    case QUICKW_WINDOW:
        // XXX drewb - Unimplemented.
        return new QUICKWWIN_DATA;
#endif
    case CALLS_WINDOW:
        return new CALLSWIN_DATA;
    case PROCESS_THREAD_WINDOW:
        return new PROCESS_THREAD_DATA;
    default:
        Assert(FALSE);
        return NULL;
    }
}

LRESULT
CALLBACK
COMMONWIN_DATA::WindowProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    PCOMMONWIN_DATA pWinData = GetCommonWinData(hwnd);

#if 0
    {
        DebugPrint("CommonWin msg %X for %p, args %X %X\n",
                   uMsg, pWinData, wParam, lParam);
    }
#endif

    if (uMsg != WM_CREATE && pWinData == NULL)
    {
        return DefMDIChildProc(hwnd, uMsg, wParam, lParam);
    }
    
    switch (uMsg)
    {
    case WM_CREATE:
        RECT rc;
        COMMONWIN_CREATE_DATA* Data;

        Assert(NULL == pWinData);

        Data = (COMMONWIN_CREATE_DATA*)
            ((LPMDICREATESTRUCT)
             (((CREATESTRUCT *)lParam)->lpCreateParams))->lParam;

        pWinData = NewWinData(Data->Type);
        if (!pWinData)
        {
            return -1; // Fail window creation
        }
        Assert(pWinData->m_enumType == Data->Type);

        pWinData->m_Win = hwnd;
        
        GetClientRect(hwnd, &rc);
        pWinData->m_Size.cx = rc.right;
        pWinData->m_Size.cy = rc.bottom;
            
        if ( !pWinData->OnCreate() )
        {
            delete pWinData;
            return -1; // Fail window creation
        }

        // store this in the window
        SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)pWinData);

#if DBG
        pWinData->Validate();
#endif
            
        g_IndexedWin[Data->Type] = pWinData;
        g_IndexedHwnd[Data->Type] = hwnd;
        InsertHeadList(&g_ActiveWin, &pWinData->m_ActiveWin);

        if (g_Workspace != NULL)
        {
            g_Workspace->AddDirty(WSPF_DIRTY_WINDOWS);
        }

        SendMessage(hwnd, WM_SETICON, 0, (LPARAM)
                    LoadIcon(g_hInst,
                             MAKEINTRESOURCE(pWinData->m_enumType +
                                             MINVAL_WINDOW_ICON)));

        // A new buffer has been created so put it in the list
        // then wake up the engine to fill it.
        Dbg_EnterCriticalSection(&g_QuickLock);
        InsertHeadList(&g_StateList, pWinData);
        Dbg_LeaveCriticalSection(&g_QuickLock);
        UpdateEngine();

        // Force initial updates so that the window starts
        // out with a state which matches the current debug
        // session's state.
        PostMessage(hwnd, WU_UPDATE, UPDATE_BUFFER, 0);
        PostMessage(hwnd, WU_UPDATE, UPDATE_EXEC, 0);

        if (g_WinOptions & WOPT_AUTO_ARRANGE)
        {
            Arrange();
        }
        return 0;

    case WM_COMMAND:
        if (pWinData->OnCommand(wParam, lParam) == 0)
        {
            return 0;
        }
        break;
        
    case WM_SETFOCUS:
        pWinData->OnSetFocus();
        break;

    case WM_MOVE:
        // When the frame window is minimized or restored
        // a move to 0,0 comes through.  Ignore this so
        // as to not trigger the warning.
        if (!IsIconic(g_hwndFrame) && lParam != 0 &&
            !IsIconic(hwnd) && !pWinData->m_CausedArrange)
        {
            DisplayAutoArrangeWarning(pWinData);
        }
        if (g_Workspace != NULL)
        {
            g_Workspace->AddDirty(WSPF_DIRTY_WINDOWS);
        }
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
        
    case WM_SIZE:
        if (wParam == SIZE_MAXHIDE || wParam == SIZE_MAXSHOW)
        {
            // We don't care about cover/uncover events.
            break;
        }
        // We don't care about size events while the frame is
        // minimized as the children can't be seen.  When
        // the frame is restored a new size event will come through
        // and things will get updated when they're actually visible.
        if (IsIconic(g_hwndFrame))
        {
            break;
        }

        if (wParam == SIZE_RESTORED && !pWinData->m_CausedArrange)
        {
            DisplayAutoArrangeWarning(pWinData);
        }
        if (g_Workspace != NULL)
        {
            g_Workspace->AddDirty(WSPF_DIRTY_WINDOWS);
        }

        pWinData->UpdateSize(LOWORD(lParam), HIWORD(lParam));

        // No need to run sizing code for minimize.
        if (wParam == SIZE_MINIMIZED)
        {
            // The minimized window will leave a hole so
            // arrange to fill it and leave space for the
            // minimized window.
            if (g_WinOptions & WOPT_AUTO_ARRANGE)
            {
                pWinData->m_CausedArrange = TRUE;
                Arrange();
            }
            break;
        }

        if (wParam == SIZE_RESTORED && pWinData->m_CausedArrange)
        {
            // If we're restoring a window that caused
            // a rearrange when it was minimized we
            // need to update things to account for it.
            pWinData->m_CausedArrange = FALSE;
            
            if (g_WinOptions & WOPT_AUTO_ARRANGE)
            {
                Arrange();
            }
        }
        else if (wParam == SIZE_MAXIMIZED)
        {
            // Ask for a rearrange on restore just
            // for consistency with minimize.
            pWinData->m_CausedArrange = TRUE;
        }

        pWinData->OnSize();
        break;

    case WM_LBUTTONDOWN:
        pWinData->OnButtonDown(MK_LBUTTON);
        return 0;
    case WM_LBUTTONUP:
        pWinData->OnButtonUp(MK_LBUTTON);
        return 0;
    case WM_MBUTTONDOWN:
        pWinData->OnButtonDown(MK_MBUTTON);
        return 0;
    case WM_MBUTTONUP:
        pWinData->OnButtonUp(MK_MBUTTON);
        return 0;
    case WM_RBUTTONDOWN:
        pWinData->OnButtonDown(MK_RBUTTON);
        return 0;
    case WM_RBUTTONUP:
        pWinData->OnButtonUp(MK_RBUTTON);
        return 0;

    case WM_MOUSEMOVE:
        pWinData->OnMouseMove((ULONG)wParam, LOWORD(lParam), HIWORD(lParam));
        return 0;

    case WM_TIMER:
        pWinData->OnTimer(wParam);
        return 0;

    case WM_GETMINMAXINFO:
        if (pWinData->OnGetMinMaxInfo((LPMINMAXINFO)lParam) == 0)
        {
            return 0;
        }
        break;
        
    case WM_VKEYTOITEM:
        return pWinData->OnVKeyToItem(wParam, lParam);
        
    case WM_NOTIFY:
        return pWinData->OnNotify(wParam, lParam);
        
    case WU_UPDATE:
        pWinData->OnUpdate((UpdateType)wParam);
        return 0;

    case WU_RECONFIGURE:
        pWinData->OnSize();
        break;

    case WM_DESTROY:
        pWinData->OnDestroy();
        
        SetWindowLongPtr(hwnd, GWLP_USERDATA, NULL);
        g_IndexedWin[pWinData->m_enumType] = NULL;
        g_IndexedHwnd[pWinData->m_enumType] = NULL;
        RemoveEntryList(&pWinData->m_ActiveWin);
        
        if (g_Workspace != NULL)
        {
            g_Workspace->AddDirty(WSPF_DIRTY_WINDOWS);
        }
        
        // Mark this buffer as ready for cleanup by the
        // engine when it gets around to it.
        pWinData->m_Win = NULL;
        if (pWinData == g_FindLast)
        {
            g_FindLast = NULL;
        }
        UpdateEngine();
        
        if (g_WinOptions & WOPT_AUTO_ARRANGE)
        {
            Arrange();
        }
        break;
        
    case WM_MEASUREITEM:
    case WM_DRAWITEM:
        // 
        // Both these messages must be handled by owner drawn windows
        // 
        return pWinData->OnOwnerDraw(uMsg, wParam, lParam);

    case WM_CTLCOLORLISTBOX:
        // Substitute windbg's default window colors.
        SetTextColor((HDC)wParam, g_Colors[COL_PLAIN_TEXT].Color);
        SetBkColor((HDC)wParam, g_Colors[COL_PLAIN].Color);
        return (LRESULT)g_Colors[COL_PLAIN].Brush;
    }
    
    return DefMDIChildProc(hwnd, uMsg, wParam, lParam);
}


//
//
//
SINGLE_CHILDWIN_DATA::SINGLE_CHILDWIN_DATA(ULONG ChangeBy)
    : COMMONWIN_DATA(ChangeBy)
{
    m_hwndChild = NULL;
}

void 
SINGLE_CHILDWIN_DATA::Validate()
{
    COMMONWIN_DATA::Validate();

    Assert(m_hwndChild);
}

void 
SINGLE_CHILDWIN_DATA::SetFont(ULONG FontIndex)
{
    COMMONWIN_DATA::SetFont(FontIndex);

    SendMessage(m_hwndChild, 
                WM_SETFONT, 
                (WPARAM) m_Font->Font,
                (LPARAM) TRUE
                );
}

BOOL
SINGLE_CHILDWIN_DATA::CanCopy()
{
    if (GetFocus() != m_hwndChild)
    {
        return COMMONWIN_DATA::CanCopy();
    }
    
    switch (m_enumType)
    {
    default:
        Assert(!"Unknown type");
        return FALSE;

    case CMD_WINDOW:
        Assert(!"Should not be handled here since this is only for windows"
            " with only one child window.");
        return FALSE;

    case WATCH_WINDOW:
    case LOCALS_WINDOW:
    case CPU_WINDOW:
    case QUICKW_WINDOW:
        return -1 != ListView_GetNextItem(m_hwndChild,
                                          -1, // Find the first match
                                          LVNI_FOCUSED
                                          );

    case CALLS_WINDOW:
        return LB_ERR != SendMessage(m_hwndChild, LB_GETCURSEL, 0, 0);

    case DOC_WINDOW:
    case DISASM_WINDOW:
    case MEM_WINDOW:
    case SCRATCH_PAD_WINDOW:
        CHARRANGE chrg;
        SendMessage(m_hwndChild, EM_EXGETSEL, 0, (LPARAM)&chrg);
        return chrg.cpMin != chrg.cpMax;

    case PROCESS_THREAD_WINDOW:
        return NULL != TreeView_GetSelection(m_hwndChild);
    }
}

BOOL
SINGLE_CHILDWIN_DATA::CanCut()
{
    if (GetFocus() != m_hwndChild)
    {
        return COMMONWIN_DATA::CanCut();
    }
    
    switch (m_enumType)
    {
    default:
        Assert(!"Unknown type");
        return FALSE;

    case CMD_WINDOW:
        Assert(!"Should not be handled here since this is only for windows"
            " with only one child window.");
        return FALSE;

    case WATCH_WINDOW:
    case LOCALS_WINDOW:
    case CPU_WINDOW:
    case QUICKW_WINDOW:
    case CALLS_WINDOW:
    case DOC_WINDOW:
    case DISASM_WINDOW:
    case MEM_WINDOW:
    case PROCESS_THREAD_WINDOW:
        return FALSE;
        
    case SCRATCH_PAD_WINDOW:
        CHARRANGE chrg;
        SendMessage(m_hwndChild, EM_EXGETSEL, 0, (LPARAM)&chrg);
        return chrg.cpMin != chrg.cpMax;
    }
}

BOOL
SINGLE_CHILDWIN_DATA::CanPaste()
{
    if (GetFocus() != m_hwndChild)
    {
        return COMMONWIN_DATA::CanPaste();
    }
    
    switch (m_enumType)
    {
    default:
        Assert(!"Unknown type");
        return FALSE;

    case CMD_WINDOW:
        Assert(!"Should not be handled here since this is only for windows"
            " with only one child window.");
        return FALSE;

    case WATCH_WINDOW:
    case LOCALS_WINDOW:
    case CPU_WINDOW:
    case QUICKW_WINDOW:
    case CALLS_WINDOW:
    case DOC_WINDOW:
    case DISASM_WINDOW:
    case MEM_WINDOW:
    case PROCESS_THREAD_WINDOW:
        return FALSE;
        
    case SCRATCH_PAD_WINDOW:
        return TRUE;
    }
}

void
SINGLE_CHILDWIN_DATA::Copy()
{
    if (GetFocus() != m_hwndChild)
    {
        COMMONWIN_DATA::Copy();
    }
    else
    {
        SendMessage(m_hwndChild, WM_COPY, 0, 0);
    }
}

void
SINGLE_CHILDWIN_DATA::Cut()
{
    if (GetFocus() != m_hwndChild)
    {
        COMMONWIN_DATA::Paste();
    }
}

void
SINGLE_CHILDWIN_DATA::Paste()
{
    if (GetFocus() != m_hwndChild)
    {
        COMMONWIN_DATA::Paste();
    }
}

void
SINGLE_CHILDWIN_DATA::OnSetFocus()
{
    ::SetFocus(m_hwndChild);
}

void
SINGLE_CHILDWIN_DATA::OnSize(void)
{
    COMMONWIN_DATA::OnSize();
    MoveWindow(m_hwndChild, 0, m_ToolbarHeight,
               m_Size.cx, m_Size.cy - m_ToolbarHeight, TRUE);
}

void
SINGLE_CHILDWIN_DATA::UpdateColors(void)
{
    // Force a repaint of the child.
    InvalidateRect(m_hwndChild, NULL, TRUE);
}

//
//
//
PROCESS_THREAD_DATA::PROCESS_THREAD_DATA()
    : SINGLE_CHILDWIN_DATA(512)
{
    m_enumType = PROCESS_THREAD_WINDOW;
    m_TotalSystems = 0;
    m_NamesOffset = 0;
}

void
PROCESS_THREAD_DATA::Validate()
{
    SINGLE_CHILDWIN_DATA::Validate();

    Assert(PROCESS_THREAD_WINDOW == m_enumType);
}

HRESULT
PROCESS_THREAD_DATA::ReadProcess(ULONG ProcId, PULONG Offset)
{
    HRESULT Status;
    PULONG ThreadIds, ThreadSysIds;
    ULONG NumThread;
    char Name[MAX_PATH];
    ULONG NameLen;
    PULONG Data;

    if ((Status = g_pDbgSystem->
         SetCurrentProcessId(ProcId)) != S_OK ||
        (Status = g_pDbgSystem->GetNumberThreads(&NumThread)) != S_OK)
    {
        return Status;
    }
    if (FAILED(Status = g_pDbgSystem->
               GetCurrentProcessExecutableName(Name, sizeof(Name),
                                               NULL)))
    {
        PrintString(Name, DIMA(Name), "<%s>", FormatStatusCode(Status));
    }
    
    NameLen = strlen(Name) + 1;
    if (NameLen > 1)
    {
        PSTR NameStore = (PSTR)AddData(NameLen);
        if (NameStore == NULL)
        {
            return E_OUTOFMEMORY;
        }

        strcpy(NameStore, Name);
    }
    
    // Refresh pointers in case a resize
    // caused buffer movement.
    Data = (PULONG)GetDataBuffer() + *Offset;
    *Data++ = NumThread;
    *Data++ = NameLen;
    *Offset += 2;
    
    ThreadIds = Data;
    ThreadSysIds = ThreadIds + NumThread;
        
    if ((Status = g_pDbgSystem->
         GetThreadIdsByIndex(0, NumThread,
                             ThreadIds, ThreadSysIds)) != S_OK)
    {
        return Status;
    }

    *Offset += 2 * NumThread;

    return S_OK;
}

HRESULT
PROCESS_THREAD_DATA::ReadSystem(ULONG SysId,
                                PULONG Offset)
{
    HRESULT Status;
    ULONG ProcIdsOffset;
    PULONG ProcIds, ProcSysIds;
    ULONG NumProc;
    ULONG i;
    char Name[MAX_PATH + 32];
    ULONG NameLen;
    PULONG Data;

    if (g_pDbgSystem3)
    {
        if ((Status = g_pDbgSystem3->
             SetCurrentSystemId(SysId)) != S_OK ||
            FAILED(Status = g_pDbgSystem3->
                   GetCurrentSystemServerName(Name, sizeof(Name), NULL)))
        {
            return Status;
        }
    }
    else
    {
        Name[0] = 0;
    }

    NameLen = strlen(Name) + 1;
    if (NameLen > 1)
    {
        PSTR NameStore = (PSTR)AddData(NameLen);
        if (NameStore == NULL)
        {
            return E_OUTOFMEMORY;
        }

        strcpy(NameStore, Name);
    }
    
    if ((Status = g_pDbgSystem->
         GetNumberProcesses(&NumProc)) != S_OK)
    {
        return Status;
    }
    
    // Refresh pointers in case a resize
    // caused buffer movement.
    Data = (PULONG)GetDataBuffer() + *Offset;
    *Data++ = NumProc;
    *Data++ = NameLen;
    *Offset += 2;

    if (NumProc == 0)
    {
        return S_OK;
    }
    
    ProcIds = Data;
    ProcIdsOffset = *Offset;
    ProcSysIds = ProcIds + NumProc;
    
    if ((Status = g_pDbgSystem->
         GetProcessIdsByIndex(0, NumProc, ProcIds, ProcSysIds)) != S_OK)
    {
        return Status;
    }

    *Offset += 2 * NumProc;
    for (i = 0; i < NumProc; i++)
    {
        ProcIds = (PULONG)GetDataBuffer() + ProcIdsOffset;
        
        if ((Status = ReadProcess(ProcIds[i], Offset)) != S_OK)
        {
            return Status;
        }
    }

    return S_OK;
}

HRESULT
PROCESS_THREAD_DATA::ReadState(void)
{
    HRESULT Status;
    ULONG CurProc;
    ULONG TotalSys, TotalThread, TotalProc;
    ULONG MaxProcThread, MaxSysThread, MaxSysProc;
    PULONG SysIds;
    ULONG i;
    ULONG Offset;
    ULONG NamesOffset;

    if ((Status = g_pDbgSystem->GetCurrentProcessId(&CurProc)) != S_OK)
    {
        return Status;
    }
    if (g_pDbgSystem3)
    {
        if ((Status = g_pDbgSystem3->GetNumberSystems(&TotalSys)) != S_OK ||
            (Status = g_pDbgSystem3->
             GetTotalNumberThreadsAndProcesses(&TotalThread, &TotalProc,
                                               &MaxProcThread, &MaxSysThread,
                                               &MaxSysProc)) != S_OK)
        {
            return Status;
        }
    }
    else
    {
        if ((Status = g_pDbgSystem->GetNumberProcesses(&TotalProc)) != S_OK ||
            (Status = g_pDbgSystem->
             GetTotalNumberThreads(&TotalThread, &MaxProcThread)) != S_OK)
        {
            return Status;
        }
        
        TotalSys = 1;
        MaxSysThread = MaxProcThread;
        MaxSysProc = TotalProc;
    }

    Empty();

    NamesOffset = (TotalSys * 3 + TotalProc * 4 + TotalThread * 2) *
        sizeof(ULONG);
    SysIds = (PULONG)AddData(NamesOffset);
    if (SysIds == NULL)
    {
        return E_OUTOFMEMORY;
    }

    if (g_pDbgSystem3)
    {
        if ((Status = g_pDbgSystem3->
             GetSystemIdsByIndex(0, TotalSys, SysIds)) != S_OK)
        {
            return Status;
        }
    }
    else
    {
        *SysIds = 0;
    }

    ULONG OutMask, LogMask;
    
    // Ignore thread notifications as we're changing the thread.
    g_IgnoreThreadChange = TRUE;
    // Switching threads causes output which we don't want so
    // ignore all output.
    g_pDbgClient->GetOutputMask(&OutMask);
    g_pDbgControl->GetLogMask(&LogMask);
    g_pDbgClient->SetOutputMask(0);
    g_pDbgControl->SetLogMask(0);
    
    Offset = TotalSys;
    for (i = 0; i < TotalSys; i++)
    {
        SysIds = (PULONG)GetDataBuffer();
        
        if ((Status = ReadSystem(SysIds[i], &Offset)) != S_OK)
        {
            break;
        }
    }

    // This will also set the current system and thread
    // from the process information.
    g_pDbgSystem->SetCurrentProcessId(CurProc);

    g_IgnoreThreadChange = FALSE;
    
    g_pDbgClient->SetOutputMask(OutMask);
    g_pDbgControl->SetLogMask(LogMask);

    if (Status == S_OK)
    {
        m_TotalSystems = TotalSys;
        m_NamesOffset = NamesOffset;
    }
    
    return Status;
}

BOOL
PROCESS_THREAD_DATA::OnCreate(void)
{
    if (!SINGLE_CHILDWIN_DATA::OnCreate())
    {
        return FALSE;
    }

    m_hwndChild = CreateWindow(
        WC_TREEVIEW,                                // class name
        NULL,                                       // title
        WS_CLIPSIBLINGS |
        WS_CHILD | WS_VISIBLE |
        WS_HSCROLL | WS_VSCROLL |
        TVS_HASBUTTONS | TVS_LINESATROOT |
        TVS_HASLINES,                               // style
        0,                                          // x
        0,                                          // y
        m_Size.cx,                                  // width
        m_Size.cy,                                  // height
        m_Win,                                      // parent
        (HMENU) IDC_PROCESS_TREE,                   // control id
        g_hInst,                                    // hInstance
        NULL);                                      // user defined data
    if (!m_hwndChild)
    {
        return FALSE;
    }
    
    SetFont(FONT_FIXED);
    SendMessage(m_hwndChild, TVM_SETTEXTCOLOR,
                0, g_Colors[COL_PLAIN_TEXT].Color);
    SendMessage(m_hwndChild, TVM_SETBKCOLOR,
                0, g_Colors[COL_PLAIN].Color);
    
    return TRUE;
}

LRESULT
PROCESS_THREAD_DATA::OnNotify(WPARAM Wpm, LPARAM Lpm)
{
    LPNMTREEVIEW Tvn;
    HTREEITEM Sel;

    Tvn = (LPNMTREEVIEW)Lpm;
    if (Tvn->hdr.idFrom != IDC_PROCESS_TREE)
    {
        return FALSE;
    }
    
    switch(Tvn->hdr.code)
    {
    case TVN_SELCHANGED:
        if (Tvn->action == TVC_BYMOUSE)
        {
            SetCurThreadFromProcessTreeItem(m_hwndChild, Tvn->itemNew.hItem);
        }
        break;

    case NM_DBLCLK:
    case NM_RETURN:
        Sel = TreeView_GetSelection(m_hwndChild);
        if (Sel)
        {
            SetCurThreadFromProcessTreeItem(m_hwndChild, Sel);
        }
        return TRUE;
    }

    return FALSE;
}

void
PROCESS_THREAD_DATA::OnUpdate(UpdateType Type)
{
    if (Type != UPDATE_BUFFER &&
        Type != UPDATE_EXEC)
    {
        return;
    }
    
    HRESULT Status;
    
    Status = UiLockForRead();
    if (Status != S_OK)
    {
        return;
    }
    
    ULONG Sys;
    ULONG NameLen;
    PULONG SysIds, Data;
    char Text[MAX_PATH + 64];
    PSTR Names;
    TVINSERTSTRUCT Insert;
    HTREEITEM CurThreadItem = NULL;

    SysIds = (PULONG)GetDataBuffer();
    Data = SysIds + m_TotalSystems;
    Names = (PSTR)GetDataBuffer() + m_NamesOffset;
    
    TreeView_DeleteAllItems(m_hwndChild);

    for (Sys = 0; Sys < m_TotalSystems; Sys++)
    {
        HTREEITEM SysItem;
        ULONG NumProc, Proc;
        PULONG ProcIds, ProcSysIds;

        NumProc = *Data++;
        NameLen = *Data++;
        ProcIds = Data;
        ProcSysIds = ProcIds + NumProc;
        Data = ProcSysIds + NumProc;

        sprintf(Text, "%d ", SysIds[Sys]);
        if (NameLen > 1)
        {
            CatString(Text, Names, DIMA(Text));
            Names += strlen(Names) + 1;
        }
        
        if (m_TotalSystems > 1)
        {
            Insert.hParent = TVI_ROOT;
            Insert.hInsertAfter = TVI_LAST;
            Insert.item.mask = TVIF_TEXT | TVIF_STATE | TVIF_PARAM;
            Insert.item.pszText = Text;
            Insert.item.state =
                SysIds[Sys] == g_CurSystemId ? TVIS_EXPANDED | TVIS_BOLD: 0;
            Insert.item.stateMask = TVIS_EXPANDED | TVIS_BOLD;
            // Parameter is the thread ID to set to select the given system.
            Insert.item.lParam = NumProc > 0 ? (LPARAM)Data[2] : (LPARAM)-1;
            SysItem = TreeView_InsertItem(m_hwndChild, &Insert);
        }
        else
        {
            SysItem = TVI_ROOT;
        }

        for (Proc = 0; Proc < NumProc; Proc++)
        {
            HTREEITEM ProcItem;
            ULONG NumThread, Thread;
            PULONG ThreadIds, ThreadSysIds;

            NumThread = *Data++;
            NameLen = *Data++;
            ThreadIds = Data;
            ThreadSysIds = Data + NumThread;
            Data = ThreadSysIds + NumThread;
            
            sprintf(Text, "%03d:%x ", ProcIds[Proc], ProcSysIds[Proc]);
            if (NameLen > 1)
            {
                CatString(Text, Names, DIMA(Text));
                Names += strlen(Names) + 1;
            }
        
            Insert.hParent = SysItem;
            Insert.hInsertAfter = TVI_LAST;
            Insert.item.mask = TVIF_TEXT | TVIF_STATE | TVIF_PARAM;
            Insert.item.pszText = Text;
            Insert.item.state =
                SysIds[Sys] == g_CurSystemId &&
                ProcIds[Proc] == g_CurProcessId ?
                TVIS_EXPANDED | TVIS_BOLD: 0;
            Insert.item.stateMask = TVIS_EXPANDED | TVIS_BOLD;
            // Parameter is the thread ID to set to select the given thread.
            Insert.item.lParam = (LPARAM)ThreadIds[0];
            ProcItem = TreeView_InsertItem(m_hwndChild, &Insert);

            for (Thread = 0; Thread < NumThread; Thread++)
            {
                HTREEITEM ThreadItem;
            
                sprintf(Text, "%03d:%x",
                        ThreadIds[Thread], ThreadSysIds[Thread]);
                Insert.hParent = ProcItem;
                Insert.hInsertAfter = TVI_LAST;
                Insert.item.mask = TVIF_TEXT | TVIF_STATE | TVIF_PARAM;
                Insert.item.pszText = Text;
                Insert.item.state =
                    SysIds[Sys] == g_CurSystemId &&
                    ProcIds[Proc] == g_CurProcessId &&
                    ThreadIds[Thread] == g_CurThreadId ?
                    TVIS_BOLD : 0;
                Insert.item.stateMask = TVIS_BOLD;
                Insert.item.lParam = (LPARAM)ThreadIds[Thread];
                ThreadItem = TreeView_InsertItem(m_hwndChild, &Insert);
                if (Insert.item.state & TVIS_BOLD)
                {
                    CurThreadItem = ThreadItem;
                }
            }
        }
    }

    if (CurThreadItem)
    {
        TreeView_Select(m_hwndChild, CurThreadItem, TVGN_CARET);
    }
    
    UnlockStateBuffer(this);
}

void
PROCESS_THREAD_DATA::UpdateColors(void)
{
    SendMessage(m_hwndChild, TVM_SETTEXTCOLOR,
                0, g_Colors[COL_PLAIN_TEXT].Color);
    SendMessage(m_hwndChild, TVM_SETBKCOLOR,
                0, g_Colors[COL_PLAIN].Color);
    InvalidateRect(m_hwndChild, NULL, TRUE);
}

void
PROCESS_THREAD_DATA::SetCurThreadFromProcessTreeItem(HWND Tree, HTREEITEM Sel)
{
    TVITEM Item;
                
    Item.hItem = Sel;
    Item.mask = TVIF_CHILDREN | TVIF_PARAM;
    TreeView_GetItem(Tree, &Item);
    if (Item.lParam != (LPARAM)-1)
    {
        g_pUiSystem->SetCurrentThreadId((ULONG)Item.lParam);
    }
}


//
//
//
EDITWIN_DATA::EDITWIN_DATA(ULONG ChangeBy)
    : SINGLE_CHILDWIN_DATA(ChangeBy)
{
    m_TextLines = 0;
    m_Highlights = NULL;
}

void
EDITWIN_DATA::Validate()
{
    SINGLE_CHILDWIN_DATA::Validate();
}

void 
EDITWIN_DATA::SetFont(ULONG FontIndex)
{
    SINGLE_CHILDWIN_DATA::SetFont(FontIndex);

    // Force the tabstop size to be recomputed
    // with the new font.
    SendMessage(m_hwndChild, EM_SETTABSTOPS, 1, (LPARAM)&g_TabWidth);
}

BOOL
EDITWIN_DATA::CanSelectAll()
{
    return TRUE;
}

void
EDITWIN_DATA::SelectAll()
{
    CHARRANGE Sel;

    Sel.cpMin = 0;
    Sel.cpMax = INT_MAX;
    SendMessage(m_hwndChild, EM_EXSETSEL, 0, (LPARAM)&Sel);
}

BOOL
EDITWIN_DATA::OnCreate(void)
{
    m_hwndChild = CreateWindowEx(
        WS_EX_CLIENTEDGE,                           // Extended style
        RICHEDIT_CLASS,                             // class name
        NULL,                                       // title
        WS_CLIPSIBLINGS
        | WS_CHILD | WS_VISIBLE
        | WS_VSCROLL | ES_AUTOVSCROLL
        | WS_HSCROLL | ES_AUTOHSCROLL
        | ES_READONLY
        | ES_MULTILINE,                             // style
        0,                                          // x
        m_ToolbarHeight,                            // y
        m_Size.cx,                                  // width
        m_Size.cy - m_ToolbarHeight,                // height
        m_Win,                                      // parent
        (HMENU) 0,                                  // control id
        g_hInst,                                    // hInstance
        NULL);                                      // user defined data

    if (m_hwndChild)
    {
        CHARFORMAT2 Fmt;

        SetFont(FONT_FIXED);

        SendMessage(m_hwndChild, EM_SETBKGNDCOLOR, FALSE,
                    g_Colors[COL_PLAIN].Color);

        ZeroMemory(&Fmt, sizeof(Fmt));
        Fmt.cbSize = sizeof(Fmt);
        Fmt.dwMask = CFM_COLOR;
        Fmt.crTextColor = g_Colors[COL_PLAIN_TEXT].Color;
        SendMessage(m_hwndChild, EM_SETCHARFORMAT,
                    SCF_SELECTION, (LPARAM)&Fmt);
    }

    return m_hwndChild != NULL;
}

LRESULT
EDITWIN_DATA::OnNotify(WPARAM Wpm, LPARAM Lpm)
{
    NMHDR* Hdr = (NMHDR*)Lpm;
    if (Hdr->code == EN_SAVECLIPBOARD)
    {
        // Indicate that the clipboard contents should
        // be kept alive.
        return 0;
    }
    else if (Hdr->code == EN_MSGFILTER)
    {
        MSGFILTER* Filter = (MSGFILTER*)Lpm;
        
        if (WM_SYSKEYDOWN == Filter->msg ||
            WM_SYSKEYUP == Filter->msg ||
            WM_SYSCHAR == Filter->msg)
        {
            // Force default processing for menu operations
            // so that the Alt-minus menu comes up.
            return 1;
        }
    }

    return 0;
}

void
EDITWIN_DATA::OnDestroy(void)
{
    EDIT_HIGHLIGHT* Next;
    
    while (m_Highlights != NULL)
    {
        Next = m_Highlights->Next;
        delete m_Highlights;
        m_Highlights = Next;
    }

    SINGLE_CHILDWIN_DATA::OnDestroy();
}

void
EDITWIN_DATA::UpdateColors(void)
{
    RicheditUpdateColors(m_hwndChild,
                         g_Colors[COL_PLAIN_TEXT].Color, TRUE,
                         g_Colors[COL_PLAIN].Color, TRUE);
    UpdateCurrentLineHighlight();
    UpdateBpMarks();
}

void
EDITWIN_DATA::SetCurrentLineHighlight(ULONG Line)
{
    //
    // Clear any other current line highlight in this window.
    // Also, only one doc window can have a current IP highlight so if
    // this is a doc window getting a current IP highlight make
    // sure no other doc windows have a current IP highlight.
    //
    if (m_enumType == DOC_WINDOW && ULONG_MAX != Line)
    {
        RemoveActiveWinHighlights(1 << DOC_WINDOW, EHL_CURRENT_LINE);
    }
    else
    {
        RemoveAllHighlights(EHL_CURRENT_LINE);
    }
    
    if (ULONG_MAX != Line)
    {
        AddHighlight(Line, EHL_CURRENT_LINE);
        RicheditScrollToLine(m_hwndChild, Line, m_LineHeight);
    }
}
    
void
EDITWIN_DATA::UpdateCurrentLineHighlight(void)
{
    EDIT_HIGHLIGHT* Hl;

    for (Hl = m_Highlights; Hl != NULL; Hl = Hl->Next)
    {
        if (Hl->Flags & EHL_CURRENT_LINE)
        {
            break;
        }
    }

    if (Hl)
    {
        ApplyHighlight(Hl);
    }
}

EDIT_HIGHLIGHT*
EDITWIN_DATA::GetLineHighlighting(ULONG Line)
{
    EDIT_HIGHLIGHT* Hl;
    
    for (Hl = m_Highlights; Hl != NULL; Hl = Hl->Next)
    {
        if (Hl->Line == Line)
        {
            return Hl;
        }
    }

    return NULL;
}

void
EDITWIN_DATA::ApplyHighlight(EDIT_HIGHLIGHT* Hl)
{
    CHARRANGE OldSel;
    BOOL HasFocus = ::GetFocus() == m_hwndChild;

    // Get the old selection and scroll position.
    SendMessage(m_hwndChild, EM_EXGETSEL, 0, (LPARAM)&OldSel);

    // Disable the window to prevent auto-scrolling
    // when the selection is set.
    EnableWindow(m_hwndChild, FALSE);
    
    //
    // Compute the highlight information.
    //

    char Markers[LINE_MARKERS + 1];
    CHARFORMAT2 Fmt;
    ULONG TextCol, BgCol;

    Markers[2] = 0;
    ZeroMemory(&Fmt, sizeof(Fmt));
    Fmt.cbSize = sizeof(Fmt);
    Fmt.dwMask = CFM_COLOR | CFM_BACKCOLOR;
    
    if (Hl->Flags & EHL_CURRENT_LINE)
    {
        Markers[1] = '>';
        switch(Hl->Flags & EHL_ANY_BP)
        {
        case EHL_ENABLED_BP:
            Markers[0] = 'B';
            TextCol = COL_BP_CURRENT_LINE_TEXT;
            BgCol = COL_BP_CURRENT_LINE;
            break;
        case EHL_DISABLED_BP:
            Markers[0] = 'D';
            TextCol = COL_BP_CURRENT_LINE_TEXT;
            BgCol = COL_BP_CURRENT_LINE;
            break;
        default:
            Markers[0] = ' ';
            TextCol = COL_CURRENT_LINE_TEXT;
            BgCol = COL_CURRENT_LINE;
            break;
        }
    }
    else
    {
        Markers[1] = ' ';
        switch(Hl->Flags & EHL_ANY_BP)
        {
        case EHL_ENABLED_BP:
            Markers[0] = 'B';
            TextCol = COL_ENABLED_BP_TEXT;
            BgCol = COL_ENABLED_BP;
            break;
        case EHL_DISABLED_BP:
            Markers[0] = 'D';
            TextCol = COL_DISABLED_BP_TEXT;
            BgCol = COL_DISABLED_BP;
            break;
        default:
            Markers[0] = ' ';
            TextCol = COL_PLAIN_TEXT;
            BgCol = COL_PLAIN;
            break;
        }
    }

    Fmt.crTextColor = g_Colors[TextCol].Color;
    Fmt.crBackColor = g_Colors[BgCol].Color;
    
    //
    // Select the line to be highlighted
    //
    
    CHARRANGE FmtSel;
    
    FmtSel.cpMin = (LONG)SendMessage(m_hwndChild, EM_LINEINDEX, Hl->Line, 0);

    if (g_LineMarkers)
    {
        // Replace the markers at the beginning of the line.
        FmtSel.cpMax = FmtSel.cpMin + 2;
        SendMessage(m_hwndChild, EM_EXSETSEL, 0, (LPARAM)&FmtSel);
        SendMessage(m_hwndChild, EM_REPLACESEL, FALSE, (LPARAM)Markers);
    }

    // Color the line.
    FmtSel.cpMax = FmtSel.cpMin + (LONG)
        SendMessage(m_hwndChild, EM_LINELENGTH, FmtSel.cpMin, 0) + 1;
    if (g_LineMarkers)
    {
        FmtSel.cpMin += 2;
    }
    SendMessage(m_hwndChild, EM_EXSETSEL, 0, (LPARAM)&FmtSel);
    SendMessage(m_hwndChild, EM_SETCHARFORMAT, SCF_SELECTION, (LPARAM)&Fmt);

    // Restore the old selection
    SendMessage(m_hwndChild, EM_EXSETSEL, 0, (LPARAM)&OldSel);
    
    EnableWindow(m_hwndChild, TRUE);

    // The disabling of the window caused the richedit
    // to forget its focus status so force the focus
    // back if it had it.
    if (HasFocus)
    {
        ::SetFocus(m_hwndChild);
    }
}

EDIT_HIGHLIGHT*
EDITWIN_DATA::AddHighlight(ULONG Line, ULONG Flags)
{
    EDIT_HIGHLIGHT* Hl;

    // Search for an existing highlight record for the line.
    Hl = GetLineHighlighting(Line);

    if (Hl == NULL)
    {
        Hl = new EDIT_HIGHLIGHT;
        if (Hl == NULL)
        {
            return NULL;
        }

        Hl->Data = 0;
        Hl->Line = Line;
        Hl->Flags = 0;
        Hl->Next = m_Highlights;
        m_Highlights = Hl;
    }

    Hl->Flags |= Flags;
    ApplyHighlight(Hl);

    return Hl;
}

void
EDITWIN_DATA::RemoveHighlight(ULONG Line, ULONG Flags)
{
    EDIT_HIGHLIGHT* Hl;
    EDIT_HIGHLIGHT* Prev;
    
    // Search for an existing highlight record for the line.
    Prev = NULL;
    for (Hl = m_Highlights; Hl != NULL; Hl = Hl->Next)
    {
        if (Hl->Line == Line)
        {
            break;
        }

        Prev = Hl;
    }

    if (Hl == NULL)
    {
        return;
    }

    Hl->Flags &= ~Flags;
    ApplyHighlight(Hl);

    if (Hl->Flags == 0)
    {
        if (Prev == NULL)
        {
            m_Highlights = Hl->Next;
        }
        else
        {
            Prev->Next = Hl->Next;
        }

        delete Hl;
    }
}

void
EDITWIN_DATA::RemoveAllHighlights(ULONG Flags)
{
    EDIT_HIGHLIGHT* Hl;
    EDIT_HIGHLIGHT* Next;
    EDIT_HIGHLIGHT* Prev;

    Prev = NULL;
    for (Hl = m_Highlights; Hl != NULL; Hl = Next)
    {
        Next = Hl->Next;

        if (Hl->Flags & Flags)
        {
            Hl->Flags &= ~Flags;
            ApplyHighlight(Hl);

            if (Hl->Flags == 0)
            {
                if (Prev == NULL)
                {
                    m_Highlights = Hl->Next;
                }
                else
                {
                    Prev->Next = Hl->Next;
                }

                delete Hl;
            }
            else
            {
                Prev = Hl;
            }
        }
        else
        {
            Prev = Hl;
        }
    }
}

void
EDITWIN_DATA::RemoveActiveWinHighlights(ULONG Types, ULONG Flags)
{
    PLIST_ENTRY Entry = g_ActiveWin.Flink;

    while (Entry != &g_ActiveWin)
    {
        PEDITWIN_DATA WinData = (PEDITWIN_DATA)
            ACTIVE_WIN_ENTRY(Entry);
            
        if (Types & (1 << WinData->m_enumType))
        {
            WinData->RemoveAllHighlights(Flags);
        }

        Entry = Entry->Flink;
    }
}

void
EDITWIN_DATA::UpdateBpMarks(void)
{
    // Empty implementation for derived classes
    // that do not show BP marks.
}

int
EDITWIN_DATA::CheckForFileChanges(PCSTR File, FILETIME* LastWrite)
{
    HANDLE Handle;
    
    Handle = CreateFile(File, GENERIC_READ, FILE_SHARE_READ,
                        NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 
                        NULL);
    if (Handle == INVALID_HANDLE_VALUE)
    {
        goto Changed;
    }

    FILETIME NewWrite;
    
    if (!GetFileTime(Handle, NULL, NULL, &NewWrite))
    {
        if (!GetFileTime(Handle, &NewWrite, NULL, NULL))
        {
            ZeroMemory(&NewWrite, sizeof(NewWrite));
        }
    }

    CloseHandle(Handle);

    if (CompareFileTime(LastWrite, &NewWrite) == 0)
    {
        // No change.
        return IDCANCEL;
    }

 Changed:
    return
        g_QuietSourceMode == QMODE_ALWAYS_YES ? IDYES :
        (g_QuietSourceMode == QMODE_ALWAYS_NO ? IDCANCEL :
         QuestionBox(ERR_File_Has_Changed, MB_YESNO, File));
}

//
//
//

SCRATCH_PAD_DATA::SCRATCH_PAD_DATA()
    : EDITWIN_DATA(16)
{
    m_enumType = SCRATCH_PAD_WINDOW;
}

void
SCRATCH_PAD_DATA::Validate()
{
    EDITWIN_DATA::Validate();

    Assert(SCRATCH_PAD_WINDOW == m_enumType);
}

void
SCRATCH_PAD_DATA::Cut()
{
    SendMessage(m_hwndChild, WM_CUT, 0, 0);
}

void
SCRATCH_PAD_DATA::Paste()
{
    SendMessage(m_hwndChild, EM_PASTESPECIAL, CF_TEXT, 0);
}

BOOL 
SCRATCH_PAD_DATA::CanWriteTextToFile()
{
    return TRUE;
}

HRESULT
SCRATCH_PAD_DATA::WriteTextToFile(HANDLE File)
{
    return RicheditWriteToFile(m_hwndChild, File);
}

BOOL
SCRATCH_PAD_DATA::OnCreate(void)
{
    if (!EDITWIN_DATA::OnCreate())
    {
        return FALSE;
    }

    SendMessage(m_hwndChild, EM_SETOPTIONS, ECOOP_AND, ~ECO_READONLY);
    SendMessage(m_hwndChild, EM_SETEVENTMASK, 0, ENM_MOUSEEVENTS);

    return TRUE;
}

LRESULT
SCRATCH_PAD_DATA::OnNotify(WPARAM Wpm, LPARAM Lpm)
{
    MSGFILTER* Filter = (MSGFILTER *)Lpm;
    
    if (EN_MSGFILTER != Filter->nmhdr.code)
    {
        return 0;
    }

    if (WM_RBUTTONDOWN == Filter->msg ||
        WM_RBUTTONDBLCLK == Filter->msg)
    {
        // If there's a selection copy it to the clipboard
        // and clear it.  Otherwise try to paste.
        if (CanCopy())
        {
            Copy();
            
            CHARRANGE Sel;
            SendMessage(m_hwndChild, EM_EXGETSEL, 0, (LPARAM)&Sel);
            Sel.cpMax = Sel.cpMin;
            SendMessage(m_hwndChild, EM_EXSETSEL, 0, (LPARAM)&Sel);
        }
        else if (SendMessage(m_hwndChild, EM_CANPASTE, CF_TEXT, 0))
        {
            Paste();
        }
        
        // Ignore right-button events.
        return 1;
    }

    return 0;
}

//
//
//
DISASMWIN_DATA::DISASMWIN_DATA()
    : EDITWIN_DATA(2048)
{
    m_enumType = DISASM_WINDOW;
    sprintf(m_OffsetExpr, "0x%I64x", g_EventIp);
    m_UpdateExpr = FALSE;
    m_FirstInstr = 0;
    m_LastInstr = 0;
}

void
DISASMWIN_DATA::Validate()
{
    EDITWIN_DATA::Validate();

    Assert(DISASM_WINDOW == m_enumType);
}

HRESULT
DISASMWIN_DATA::ReadState(void)
{
    HRESULT Status;
    // Sample these values right away in case the UI changes them.
    ULONG LinesTotal = m_LineHeight;
    ULONG LinesBefore = LinesTotal / 2;
    DEBUG_VALUE Value;

    if ((Status = g_pDbgControl->Evaluate(m_OffsetExpr, DEBUG_VALUE_INT64,
                                          &Value, NULL)) != S_OK)
    {
        return Status;
    }

    m_PrimaryInstr = Value.I64;
    
    // Reserve space at the beginning of the buffer to
    // store the line to offset mapping table.
    PULONG64 LineMap;
    
    Empty();
    LineMap = (PULONG64)AddData(sizeof(ULONG64) * LinesTotal);
    if (LineMap == NULL)
    {
        return E_OUTOFMEMORY;
    }

    // We also need to allocate a temporary line map to
    // pass to the engine for filling.  This can't be
    // the state buffer data since that may move as
    // output is generated.
    LineMap = new ULONG64[LinesTotal];
    if (LineMap == NULL)
    {
        return E_OUTOFMEMORY;
    }
    
    g_OutStateBuf.SetBuffer(this);
    if ((Status = g_OutStateBuf.Start(FALSE)) != S_OK)
    {
        delete [] LineMap;
        return Status;
    }

    Status = g_pOutCapControl->
        OutputDisassemblyLines(DEBUG_OUTCTL_THIS_CLIENT |
                               DEBUG_OUTCTL_OVERRIDE_MASK |
                               DEBUG_OUTCTL_NOT_LOGGED,
                               LinesBefore, LinesTotal, m_PrimaryInstr,
                               DEBUG_DISASM_EFFECTIVE_ADDRESS |
                               DEBUG_DISASM_MATCHING_SYMBOLS,
                               &m_PrimaryLine, &m_FirstInstr, &m_LastInstr,
                               LineMap);

    memcpy(m_Data, LineMap, sizeof(ULONG64) * LinesTotal);
    delete [] LineMap;

    if (Status != S_OK)
    {
        g_OutStateBuf.End(FALSE);
        return Status;
    }

    m_TextLines = LinesTotal;
    m_TextOffset = LinesTotal * sizeof(ULONG64);
    
    // The line map is generated with offsets followed by
    // invalid offsets for continuation lines.  We want
    // the offsets to be on the last line of the disassembly
    // for a continuation set so move them down.
    // We don't want to move the offsets down to blank lines,
    // though, such as the blank lines that separate bundles
    // in IA64 disassembly.
    LineMap = (PULONG64)m_Data;
    PULONG64 LineMapEnd = LineMap + m_TextLines;
    PULONG64 SetStart;
    PSTR Text = (PSTR)m_Data + m_TextOffset;
    PSTR PrevText;
        
    while (LineMap < LineMapEnd)
    {
        if (*LineMap != DEBUG_INVALID_OFFSET)
        {
            SetStart = LineMap;
            for (;;)
            {
                PrevText = Text;
                Text = strchr(Text, '\n') + 1;
                LineMap++;
                if (LineMap >= LineMapEnd ||
                    *LineMap != DEBUG_INVALID_OFFSET ||
                    *Text == '\n')
                {
                    break;
                }
            }
            LineMap--;
            Text = PrevText;
            
            if (LineMap > SetStart)
            {
                *LineMap = *SetStart;
                *SetStart = DEBUG_INVALID_OFFSET;
            }
        }
            
        LineMap++;
        Text = strchr(Text, '\n') + 1;
    }
    
#ifdef DEBUG_DISASM
    LineMap = (PULONG64)m_Data;
    for (Line = 0; Line < m_TextLines; Line++)
    {
        DebugPrint("%d: %I64x\n", Line, LineMap[Line]);
    }
#endif

    return g_OutStateBuf.End(TRUE);
}

HRESULT
DISASMWIN_DATA::CodeExprAtCaret(PSTR Expr, ULONG ExprSize, PULONG64 Offset)
{
    HRESULT Status;
    LRESULT LineChar;
    LONG Line;
    PULONG64 LineMap;
    
    if ((Status = UiLockForRead()) != S_OK)
    {
        // Don't want to return any success codes here.
        return FAILED(Status) ? Status : E_FAIL;
    }

    LineChar = SendMessage(m_hwndChild, EM_LINEINDEX, -1, 0);
    Line = (LONG)SendMessage(m_hwndChild, EM_EXLINEFROMCHAR, 0, LineChar);
    if (Line < 0 || (ULONG)Line >= m_TextLines)
    {
        Status = E_INVALIDARG;
        goto Unlock;
    }

    ULONG64 LineOff;
    
    // Look up the offset in the line map.  If it's part of
    // a multiline group move forward to the offset.
    LineMap = (PULONG64)m_Data;
    LineOff = LineMap[Line];
    while ((ULONG)(Line + 1) < m_TextLines && LineOff == DEBUG_INVALID_OFFSET)
    {
        Line++;
        LineOff = LineMap[Line];
    }

    if (Expr != NULL)
    {
        if (!PrintString(Expr, ExprSize, "0x%I64x", LineOff))
        {
            Status = E_INVALIDARG;
            goto Unlock;
        }
    }
    if (Offset != NULL)
    {
        *Offset = LineOff;
    }
    Status = S_OK;
    
 Unlock:
    UnlockStateBuffer(this);
    return Status;
}

BOOL
DISASMWIN_DATA::OnCreate(void)
{
    RECT Rect;
    ULONG Height;

    Height = GetSystemMetrics(SM_CYVSCROLL) + 4 * GetSystemMetrics(SM_CYEDGE);
    
    m_Toolbar = CreateWindowEx(0, REBARCLASSNAME, NULL,
                               WS_VISIBLE | WS_CHILD |
                               WS_CLIPCHILDREN | WS_CLIPSIBLINGS |
                               CCS_NODIVIDER | CCS_NOPARENTALIGN |
                               RBS_VARHEIGHT | RBS_BANDBORDERS,
                               0, 0, m_Size.cx, Height, m_Win,
                               (HMENU)ID_TOOLBAR,
                               g_hInst, NULL);
    if (m_Toolbar == NULL)
    {
        return FALSE;
    }

    REBARINFO BarInfo;
    BarInfo.cbSize = sizeof(BarInfo);
    BarInfo.fMask = 0;
    BarInfo.himl = NULL;
    SendMessage(m_Toolbar, RB_SETBARINFO, 0, (LPARAM)&BarInfo);

    m_ToolbarEdit = CreateWindowEx(WS_EX_CLIENTEDGE, "EDIT", NULL,
                                   WS_VISIBLE | WS_CHILD | ES_AUTOHSCROLL,
                                   0, 0, 18 * m_Font->Metrics.tmAveCharWidth,
                                   Height, m_Toolbar, (HMENU)IDC_EDIT_OFFSET,
                                   g_hInst, NULL);
    if (m_ToolbarEdit == NULL)
    {
        return FALSE;
    }

    SendMessage(m_ToolbarEdit, WM_SETFONT, (WPARAM)m_Font->Font, 0);
    SendMessage(m_ToolbarEdit, EM_LIMITTEXT, sizeof(m_OffsetExpr) - 1, 0);
    
    GetClientRect(m_ToolbarEdit, &Rect);

    REBARBANDINFO BandInfo;
    BandInfo.cbSize = sizeof(BandInfo);
    BandInfo.fMask = RBBIM_STYLE | RBBIM_TEXT | RBBIM_CHILD | RBBIM_CHILDSIZE;
    BandInfo.fStyle = RBBS_FIXEDSIZE;
    BandInfo.lpText = "Offset:";
    BandInfo.hwndChild = m_ToolbarEdit;
    BandInfo.cxMinChild = Rect.right - Rect.left;
    BandInfo.cyMinChild = Rect.bottom - Rect.top;
    SendMessage(m_Toolbar, RB_INSERTBAND, -1, (LPARAM)&BandInfo);

    // If the toolbar is allowed to shrink too small it hangs
    // while resizing.  Just let it clip off below a certain width.
    m_MinToolbarWidth = BandInfo.cxMinChild * 2;
    
    PSTR PrevText = "Previous";
    m_PreviousButton =
        AddButtonBand(m_Toolbar, PrevText, PrevText, IDC_DISASM_PREVIOUS);
    m_NextButton =
        AddButtonBand(m_Toolbar, "Next", PrevText, IDC_DISASM_NEXT);
    if (m_PreviousButton == NULL || m_NextButton == NULL)
    {
        return FALSE;
    }

    // Maximize the space for the offset expression.
    SendMessage(m_Toolbar, RB_MAXIMIZEBAND, 0, FALSE);
    
    GetClientRect(m_Toolbar, &Rect);
    m_ToolbarHeight = Rect.bottom - Rect.top;
    m_ShowToolbar = TRUE;
    
    if (!EDITWIN_DATA::OnCreate())
    {
        return FALSE;
    }

    // Suppress the scroll bar as the text is always
    // fitted to the window size.
    SendMessage(m_hwndChild, EM_SHOWSCROLLBAR, SB_VERT, FALSE);

    SendMessage(m_hwndChild, EM_SETEVENTMASK, 0, ENM_KEYEVENTS);

    return TRUE;
}

LRESULT
DISASMWIN_DATA::OnCommand(WPARAM Wpm, LPARAM Lpm)
{
    switch(LOWORD(Wpm))
    {
    case IDC_EDIT_OFFSET:
        if (HIWORD(Wpm) == EN_CHANGE)
        {
            // This message is sent on every keystroke
            // which causes a bit too much updating.
            // Set up a timer to trigger the actual
            // update in half a second.
            SetTimer(m_Win, IDC_EDIT_OFFSET, EDIT_DELAY, NULL);
            m_UpdateExpr = TRUE;
        }
        break;
    case IDC_DISASM_PREVIOUS:
        ScrollLower();
        break;
    case IDC_DISASM_NEXT:
        ScrollHigher();
        break;
    }
    
    return 0;
}

void
DISASMWIN_DATA::OnSize(void)
{
    EDITWIN_DATA::OnSize();

    // Force buffer to refill for new line count.
    UiRequestRead();
}

void
DISASMWIN_DATA::OnTimer(WPARAM TimerId)
{
    if (TimerId == IDC_EDIT_OFFSET && m_UpdateExpr)
    {
        m_UpdateExpr = FALSE;
        GetWindowText(m_ToolbarEdit, m_OffsetExpr, sizeof(m_OffsetExpr));
        UiRequestRead();
    }
}

LRESULT
DISASMWIN_DATA::OnNotify(WPARAM Wpm, LPARAM Lpm)
{
    MSGFILTER* Filter = (MSGFILTER*)Lpm;

    if (Filter->nmhdr.code != EN_MSGFILTER)
    {
        return EDITWIN_DATA::OnNotify(Wpm, Lpm);
    }
    
    if (Filter->msg == WM_KEYDOWN)
    {
        switch(Filter->wParam)
        {
        case VK_UP:
        {
            CHARRANGE range;

            SendMessage(m_hwndChild, EM_EXGETSEL, 0, (LPARAM) &range);
            if (!SendMessage(m_hwndChild, EM_LINEFROMCHAR, range.cpMin, 0)) 
            {
                // up arrow on top line, scroll
                ScrollLower();
                return 1;
            }
            break;
        }
        case VK_DOWN:
        {
            CHARRANGE range;
            int MaxLine;

            SendMessage(m_hwndChild, EM_EXGETSEL, 0, (LPARAM) &range);
            MaxLine = (int) SendMessage(m_hwndChild, EM_GETLINECOUNT, 0, 0);

            if (MaxLine == (1+SendMessage(m_hwndChild, EM_LINEFROMCHAR, range.cpMin, 0)))
            {
                // down arrow on bottom line, scroll
                ScrollHigher();
                return 1;
            }
            break;
        }
        
        case VK_PRIOR:
            ScrollLower();
            return 1;
        case VK_NEXT:
            ScrollHigher();
            return 1;
        }
    }
    else if (WM_SYSKEYDOWN == Filter->msg ||
             WM_SYSKEYUP == Filter->msg ||
             WM_SYSCHAR == Filter->msg)
    {
        // Force default processing for menu operations
        // so that the Alt-minus menu comes up.
        return 1;
    }

    return 0;
}

void
DISASMWIN_DATA::OnUpdate(UpdateType Type)
{
    if (Type == UPDATE_BP ||
        Type == UPDATE_END_SESSION)
    {
        UpdateBpMarks();
        return;
    }
    else if (Type != UPDATE_BUFFER)
    {
        return;
    }
    
    HRESULT Status;
    
    Status = UiLockForRead();
    if (Status == S_OK)
    {
        PULONG64 LineMap;
        ULONG Line;

        if (!g_LineMarkers)
        {
            SendMessage(m_hwndChild, WM_SETTEXT,
                        0, (LPARAM)m_Data + m_TextOffset);
        }
        else
        {
            SendMessage(m_hwndChild, WM_SETTEXT, 0, (LPARAM)"");
            PSTR Text = (PSTR)m_Data + m_TextOffset;
            for (;;)
            {
                SendMessage(m_hwndChild, EM_REPLACESEL, FALSE, (LPARAM)"  ");
                PSTR NewLine = strchr(Text, '\n');
                if (NewLine != NULL)
                {
                    *NewLine = 0;
                }
                SendMessage(m_hwndChild, EM_REPLACESEL, FALSE, (LPARAM)Text);
                if (NewLine == NULL)
                {
                    break;
                }
                SendMessage(m_hwndChild, EM_REPLACESEL, FALSE, (LPARAM)"\n");
                *NewLine = '\n';
                Text = NewLine + 1;
            }
        }

        // Highlight the last line of multiline disassembly.
        LineMap = (PULONG64)m_Data;
        Line = m_PrimaryLine;
        while (Line + 1 < m_TextLines &&
               LineMap[Line] == DEBUG_INVALID_OFFSET)
        {
            Line++;
        }
        
        SetCurrentLineHighlight(Line);

        UnlockStateBuffer(this);

        RicheditUpdateColors(m_hwndChild,
                             g_Colors[COL_PLAIN_TEXT].Color, TRUE,
                             0, FALSE);
        UpdateCurrentLineHighlight();
        UpdateBpMarks();
        
        EnableWindow(m_PreviousButton, m_FirstInstr != m_PrimaryInstr);
        EnableWindow(m_NextButton, m_LastInstr != m_PrimaryInstr);
    }
    else
    {
        SendLockStatusMessage(m_hwndChild, WM_SETTEXT, Status);
        RemoveCurrentLineHighlight();
    }
}

void
DISASMWIN_DATA::UpdateBpMarks(void)
{
    if (m_TextLines == 0 ||
        UiLockForRead() != S_OK)
    {
        return;
    }

    if (g_BpBuffer->UiLockForRead() != S_OK)
    {
        UnlockStateBuffer(this);
        return;
    }

    SendMessage(m_hwndChild, WM_SETREDRAW, FALSE, 0);

    // Remove existing BP highlights.
    RemoveAllHighlights(EHL_ANY_BP);
    
    //
    // Highlight every line that matches a breakpoint.
    //
    
    PULONG64 LineMap = (PULONG64)m_Data;
    BpBufferData* BpData = (BpBufferData*)g_BpBuffer->GetDataBuffer();
    ULONG Line;
    BpStateType State;

    for (Line = 0; Line < m_TextLines; Line++)
    {
        if (*LineMap != DEBUG_INVALID_OFFSET)
        {
            State = IsBpAtOffset(BpData, *LineMap, NULL);
            if (State != BP_NONE)
            {
                AddHighlight(Line, State == BP_ENABLED ?
                             EHL_ENABLED_BP : EHL_DISABLED_BP);
            }
        }

        LineMap++;
    }

    SendMessage(m_hwndChild, WM_SETREDRAW, TRUE, 0);
    InvalidateRect(m_hwndChild, NULL, TRUE);
    
    UnlockStateBuffer(g_BpBuffer);
    UnlockStateBuffer(this);
}

void
DISASMWIN_DATA::SetCurInstr(ULONG64 Offset)
{
    // Any pending user update is now irrelevant.
    m_UpdateExpr = FALSE;
    sprintf(m_OffsetExpr, "0x%I64x", Offset);
    // Force engine to update buffer.
    UiRequestRead();
}


void
RicheditFind(HWND Edit,
             PTSTR Text, ULONG Flags,
             CHARRANGE* SaveSel, PULONG SaveFlags,
             BOOL HideSel)
{
    if (Text == NULL)
    {
        // Clear last find.
        if (SaveSel->cpMax >= SaveSel->cpMin)
        {
            if (*SaveFlags & FR_DOWN)
            {
                SaveSel->cpMin = SaveSel->cpMax;
            }
            else
            {
                SaveSel->cpMax = SaveSel->cpMin;
            }
            if (HideSel)
            {
                SendMessage(Edit, EM_SETOPTIONS, ECOOP_AND, ~ECO_NOHIDESEL);
            }
            SendMessage(Edit, EM_EXSETSEL, 0, (LPARAM)SaveSel);
            SendMessage(Edit, EM_SCROLLCARET, 0, 0);
            SaveSel->cpMin = 1;
            SaveSel->cpMax = 0;
        }
    }
    else
    {
        LRESULT Match;
        FINDTEXTEX Find;

        SendMessage(Edit, EM_EXGETSEL, 0, (LPARAM)&Find.chrg);
        if (Flags & FR_DOWN)
        {
            if (Find.chrg.cpMax > Find.chrg.cpMin)
            {
                Find.chrg.cpMin++;
            }
            Find.chrg.cpMax = LONG_MAX;
        }
        else
        {
            Find.chrg.cpMax = 0;
        }
        Find.lpstrText = Text;
        Match = SendMessage(Edit, EM_FINDTEXTEX, Flags, (LPARAM)&Find);
        if (Match != -1)
        {
            *SaveSel = Find.chrgText;
            *SaveFlags = Flags;
            if (HideSel)
            {
                SendMessage(Edit, EM_SETOPTIONS, ECOOP_OR, ECO_NOHIDESEL);
            }
            SendMessage(Edit, EM_EXSETSEL, 0, (LPARAM)SaveSel);
            SendMessage(Edit, EM_SCROLLCARET, 0, 0);
        }
        else
        {
            if (g_FindDialog)
            {
                EnableWindow(g_FindDialog, FALSE);
            }
            
            InformationBox(ERR_No_More_Matches, Text);
            
            if (g_FindDialog)
            {
                EnableWindow(g_FindDialog, TRUE);
                SetFocus(g_FindDialog);
            }
        }
    }
}

DWORD CALLBACK 
StreamOutCb(DWORD_PTR File, LPBYTE Buffer, LONG Request, PLONG Done)
{
    return WriteFile((HANDLE)File, Buffer, Request, (LPDWORD)Done, NULL) ?
        0 : GetLastError();
}

HRESULT
RicheditWriteToFile(HWND Edit, HANDLE File)
{
    EDITSTREAM Stream;

    Stream.dwCookie = (DWORD_PTR)File;
    Stream.dwError = 0;
    Stream.pfnCallback = StreamOutCb;
    SendMessage(Edit, EM_STREAMOUT, SF_TEXT, (LPARAM)&Stream);
    if (Stream.dwError)
    {
        return HRESULT_FROM_WIN32(Stream.dwError);
    }
    return S_OK;
}

void
RicheditUpdateColors(HWND Edit,
                     COLORREF Fg, BOOL UpdateFg,
                     COLORREF Bg, BOOL UpdateBg)
{
    if (UpdateBg)
    {
        if (UpdateFg)
        {
            SendMessage(Edit, WM_SETREDRAW, FALSE, 0);
        }

        SendMessage(Edit, EM_SETBKGNDCOLOR, FALSE, Bg);

        if (UpdateFg)
        {
            SendMessage(Edit, WM_SETREDRAW, TRUE, 0);
        }
    }

    if (UpdateFg)
    {
        CHARFORMAT2 Fmt;

        ZeroMemory(&Fmt, sizeof(Fmt));
        Fmt.cbSize = sizeof(Fmt);
        Fmt.dwMask = CFM_COLOR;
        Fmt.crTextColor = Fg;
        SendMessage(Edit, EM_SETCHARFORMAT, SCF_ALL, (LPARAM)&Fmt);
    }
}

#define EXTRA_VIS 3

void
RicheditScrollToLine(HWND Edit, ULONG Line, ULONG VisLines)
{
    CHARRANGE Sel;
    ULONG CurLine;
    ULONG VisAround;
    ULONG TotalLines;
    LONG Scroll;

    //
    // Scroll the given line into view.  Try to keep
    // the line from being the first or last line
    // in view.
    //
    // Disable the window during this to prevent
    // the default richedit scrolling from occurring.
    //

    VisAround = VisLines / 2;
    if (VisAround > EXTRA_VIS)
    {
        VisAround = EXTRA_VIS;
    }
    
    TotalLines = (ULONG)SendMessage(Edit, EM_GETLINECOUNT, 0, 0);
    CurLine = (ULONG)SendMessage(Edit, EM_GETFIRSTVISIBLELINE, 0, 0);

    if (Line < CurLine + VisAround)
    {
        Scroll = (LONG)Line - (LONG)(CurLine + VisAround);
        if ((ULONG)-Scroll > CurLine)
        {
            Scroll = -(LONG)CurLine;
        }
    }
    else if (Line >= CurLine + VisLines - VisAround &&
             CurLine + VisLines < TotalLines)
    {
        Scroll = (LONG)Line - (LONG)(CurLine + VisLines - VisAround) + 1;
    }
    else
    {
        Scroll = 0;
    }

    if (Scroll)
    {
        SendMessage(Edit, EM_LINESCROLL, 0, Scroll);
    }

    Sel.cpMax = Sel.cpMin = (LONG)
        SendMessage(Edit, EM_LINEINDEX, Line, 0);
    SendMessage(Edit, EM_EXSETSEL, 0, (LPARAM)&Sel);
}

ULONG
RicheditGetSelectionText(HWND Edit, PTSTR Buffer, ULONG BufferChars)
{
    CHARRANGE Sel;

    SendMessage(Edit, EM_EXGETSEL, 0, (LPARAM)&Sel);
    if (Sel.cpMin >= Sel.cpMax)
    {
        return 0;
    }

    Sel.cpMax -= Sel.cpMin;
    if ((ULONG)Sel.cpMax + 1 > BufferChars)
    {
        return 0;
    }

    SendMessage(Edit, EM_GETSELTEXT, 0, (LPARAM)Buffer);
    return Sel.cpMax;
}

ULONG
RicheditGetSourceToken(HWND Edit, PTSTR Buffer, ULONG BufferChars,
                       CHARRANGE* Range)
{
    LRESULT Idx;
    TEXTRANGE GetRange;
    CHARRANGE Sel;

    //
    // Get the text for the line containing the selection.
    //
    
    SendMessage(Edit, EM_EXGETSEL, 0, (LPARAM)&Sel);
    if (Sel.cpMin > Sel.cpMax)
    {
        return 0;
    }

    if ((Idx = SendMessage(Edit, EM_LINEINDEX, -1, 0)) < 0)
    {
        return 0;
    }
    GetRange.chrg.cpMin = (LONG)Idx;

    if (!(Idx = SendMessage(Edit, EM_LINELENGTH, GetRange.chrg.cpMin, 0)))
    {
        return 0;
    }
    if (BufferChars <= (ULONG)Idx)
    {
        Idx = (LONG)BufferChars - 1;
    }
    GetRange.chrg.cpMax = GetRange.chrg.cpMin + (LONG)Idx;
    GetRange.lpstrText = Buffer;
    if (!SendMessage(Edit, EM_GETTEXTRANGE, 0, (LPARAM)&GetRange))
    {
        return 0;
    }

    //
    // Check and see if the selection is within a source token.
    //
    
    PTSTR Scan = Buffer + (Sel.cpMin - GetRange.chrg.cpMin);
    if (!iscsym(*Scan))
    {
        return 0;
    }

    //
    // Find the start of the token and validate it.
    //
    
    PTSTR Start = Scan;
    if (Start > Buffer)
    {
        while (--Start >= Buffer && iscsym(*Start))
        {
            // Back up.
        }
        Start++;
    }
    if (!iscsymf(*Start))
    {
        return 0;
    }

    //
    // Find the end of the token.
    //

    Scan++;
    while (iscsym(*Scan))
    {
        Scan++;
    }

    ULONG Len;
    
    // Chop the buffer down to just the token and return.
    Len = (ULONG)(Scan - Start);
    memmove(Buffer, Start, Len);
    Buffer[Len] = 0;
    Range->cpMin = GetRange.chrg.cpMin + (LONG)(Start - Buffer);
    Range->cpMax = Range->cpMin + Len;
    return Len;
}

#undef DEFINE_GET_WINDATA
#undef ASSERT_CLASS_TYPE


#ifndef DBG

#define ASSERT_CLASS_TYPE(p, ct)        ((VOID)0)

#else

#define ASSERT_CLASS_TYPE(p, ct)        if (p) { AssertType(*p, ct); }

#endif



#define DEFINE_GET_WINDATA(ClassType, FuncName)         \
ClassType *                                             \
Get##FuncName##WinData(                                 \
    HWND hwnd                                           \
    )                                                   \
{                                                       \
    ClassType *p = (ClassType *)                        \
        GetWindowLongPtr(hwnd, GWLP_USERDATA);          \
                                                        \
    ASSERT_CLASS_TYPE(p, ClassType);                    \
                                                        \
    return p;                                           \
}


#include "fncdefs.h"


#undef DEFINE_GET_WINDATA
#undef ASSERT_CLASS_TYPE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\windbg\cwcreate.cpp ===
/*++

Copyright (c) 1999-2002  Microsoft Corporation

Module Name:

    cwcreate.cpp

Abstract:

    This module contains the code for the new window architecture.

--*/

#include "precomp.hxx"
#pragma hdrstop

HWND
New_CreateWindow(
    HWND      hwndParent,
    WIN_TYPES Type,
    UINT      uClassId,
    UINT      uWinTitle,
    PRECT     pRect
    )
/*++
Description
    Generic rotuine to create a child window.

Arguments
    hwndParent  - handle to parent window
    uClassId    - resource string ID containing class name
    uWinTitle   - resource string ID containing window title
    pRect       - Rect describing the position of the window.
                  If NULL, CW_USEDEFAULT is used to specify the
                  location of the window.

--*/
{
    TCHAR   szClassName[MAX_MSG_TXT];
    TCHAR   szWinTitle[MAX_MSG_TXT];
    int     nX = CW_USEDEFAULT;
    int     nY = CW_USEDEFAULT;
    int     nWidth = CW_USEDEFAULT;
    int     nHeight = CW_USEDEFAULT;
    COMMONWIN_CREATE_DATA Data;

    if (pRect)
    {
        nX = pRect->left;
        nY = pRect->top;
        nWidth = pRect->right;
        nHeight = pRect->bottom;
    }

    // get class name and tile
    Dbg(LoadString(g_hInst, uClassId, szClassName, _tsizeof(szClassName)));
    Dbg(LoadString(g_hInst, uWinTitle, szWinTitle, _tsizeof(szWinTitle)));

    Data.Type = Type;

    BOOL TopMax;
    MDIGetActive(g_hwndMDIClient, &TopMax);
    
    HWND Win = CreateWindowEx(
        WS_EX_MDICHILD | WS_EX_CONTROLPARENT,       // Extended style
        szClassName,                                // class name
        szWinTitle,                                 // title
        WS_CLIPCHILDREN | WS_CLIPSIBLINGS
        | WS_OVERLAPPEDWINDOW | WS_VISIBLE |
        (TopMax ? WS_MAXIMIZE : 0),                 // style
        nX,                                         // x
        nY,                                         // y
        nWidth,                                     // width
        nHeight,                                    // height
        hwndParent,                                 // parent
        NULL,                                       // menu
        g_hInst,                                    // hInstance
        &Data                                       // user defined data
        );

    // Creation is considered an automatic operation in
    // order to distinguish things occuring during creation
    // from normal user operations.  Now that create is
    // finished, decrement to indicate the create op is over.
    if (Win != NULL)
    {
        COMMONWIN_DATA* CmnWin = GetCommonWinData(Win);
        if (CmnWin != NULL)
        {
            CmnWin->m_InAutoOp--;
        }
    }

    return Win;
}



HWND
NewWatch_CreateWindow(
    HWND hwndParent
    )
{
    return New_CreateWindow(hwndParent,
                            WATCH_WINDOW,
                            SYS_CommonWin_wClass,
                            SYS_WatchWin_Title,
                            NULL
                            );
}

HWND
NewLocals_CreateWindow(
    HWND hwndParent
    )
{
    return New_CreateWindow(hwndParent,
                            LOCALS_WINDOW,
                            SYS_CommonWin_wClass,
                            SYS_LocalsWin_Title,
                            NULL
                            );
}

HWND
NewDisasm_CreateWindow(
    HWND hwndParent
    )
{
    RECT Rect;

    SetRect(&Rect, CW_USEDEFAULT, CW_USEDEFAULT,
            DISASM_WIDTH, DISASM_HEIGHT);
    return New_CreateWindow(hwndParent,
                            DISASM_WINDOW,
                            SYS_CommonWin_wClass,
                            SYS_DisasmWin_Title,
                            &Rect
                            );
}

HWND
NewQuickWatch_CreateWindow(
    HWND hwndParent
    )
{
    return New_CreateWindow(hwndParent,
                            QUICKW_WINDOW,
                            SYS_CommonWin_wClass,
                            SYS_QuickWatchWin_Title,
                            NULL
                            );
}

HWND
NewMemory_CreateWindow(
    HWND hwndParent
    )
{
    return New_CreateWindow(hwndParent,
                            MEM_WINDOW,
                            SYS_CommonWin_wClass,
                            SYS_MemoryWin_Title,
                            NULL
                            );
}

HWND
NewCalls_CreateWindow(
    HWND hwndParent
    )
{
    RECT Rect;
    
    SetRect(&Rect, CW_USEDEFAULT, CW_USEDEFAULT,
            CALLS_WIDTH, CALLS_HEIGHT);
    return New_CreateWindow(hwndParent,
                            CALLS_WINDOW,
                            SYS_CommonWin_wClass,
                            SYS_CallsWin_Title, 
                            &Rect
                            );
}

HWND
NewCmd_CreateWindow(
    HWND hwndParent
    )
{
    RECT Rect;

    SetRect(&Rect, CW_USEDEFAULT, CW_USEDEFAULT, CMD_WIDTH, CMD_HEIGHT);
    return New_CreateWindow(hwndParent,
                            CMD_WINDOW,
                            SYS_CommonWin_wClass,
                            SYS_CmdWin_Title,
                            &Rect
                            );
}

HWND
NewCpu_CreateWindow(
    HWND hwndParent
    )
{
    RECT Rect;

    SetRect(&Rect, CW_USEDEFAULT, CW_USEDEFAULT,
            g_Ptr64 ? CPU_WIDTH_64 : CPU_WIDTH_32, CPU_HEIGHT);
    return New_CreateWindow(hwndParent,
                            CPU_WINDOW,
                            SYS_CommonWin_wClass,
                            SYS_CpuWin_Title,
                            &Rect
                            );
}

HWND
NewDoc_CreateWindow(
    HWND hwndParent
    )
/*++
Routine Description:

  Create the command window.

Arguments:

    hwndParent - The parent window to the command window. In an MDI document,
        this is usually the handle to the MDI client window: g_hwndMDIClient

Return Value:

    If successful, creates a valid window handle to the new command window.

    NULL if the window was not created.

--*/
{
    RECT Rect;

    // Set default geometry.
    SetRect(&Rect, CW_USEDEFAULT, CW_USEDEFAULT,
            DOC_WIDTH, DOC_HEIGHT);
    
    if (g_WinOptions & WOPT_OVERLAY_SOURCE)
    {
        PLIST_ENTRY Entry;
        PCOMMONWIN_DATA WinData;
        
        // If we're stacking up document windows go
        // find the first one and use it as a template.
        for (Entry = g_ActiveWin.Flink;
             Entry != &g_ActiveWin;
             Entry = Entry->Flink)
        {
            WinData = ACTIVE_WIN_ENTRY(Entry);
            if (WinData->m_enumType == DOC_WINDOW &&
                !IsIconic(WinData->m_Win))
            {
                GetWindowRect(WinData->m_Win, &Rect);
                MapWindowPoints(GetDesktopWindow(), g_hwndMDIClient,
                                (LPPOINT)&Rect, 2);
                Rect.right -= Rect.left;
                Rect.bottom -= Rect.top;
            }
        }
    }

    return New_CreateWindow(hwndParent,
                            DOC_WINDOW,
                            SYS_CommonWin_wClass,
                            SYS_DocWin_Title,
                            &Rect
                            );
}

HWND
NewScratch_CreateWindow(
    HWND hwndParent
    )
{
    return New_CreateWindow(hwndParent,
                            SCRATCH_PAD_WINDOW,
                            SYS_CommonWin_wClass,
                            SYS_Scratch_Pad_Title, 
                            NULL
                            );
}

HWND
NewProcessThread_CreateWindow(
    HWND hwndParent
    )
{
    return New_CreateWindow(hwndParent,
                            PROCESS_THREAD_WINDOW,
                            SYS_CommonWin_wClass,
                            SYS_Process_Thread_Title, 
                            NULL
                            );
}


HWND
New_OpenDebugWindow(
    WIN_TYPES   winType,
    BOOL        bUserActivated,
    ULONG       Nth
    )
/*++

Routine Description:

    Opens Cpu, Watch, Locals, Calls, or Memory Window under MDI
    Handles special case for memory win's

Arguments:

    winType - Supplies Type of debug window to be openned
    
    bUserActivated - Indicates whether this action was initiated by the
                user or by windbg. The value is to determine the Z order of
                any windows that are opened.

Return Value:

    Window handle.

    NULL if an error occurs.

--*/
{
    HWND hwndActivate = NULL;
    PCOMMONWIN_DATA CmnWin;

    switch (winType)
    {
    default:
        Assert(!_T("Invalid window type. Ignorable error."));
        break;

    case CMD_WINDOW:
        if (GetCmdHwnd())
        {
            hwndActivate = GetCmdHwnd();
        }
        else
        {
            return NewCmd_CreateWindow(g_hwndMDIClient);
        }
        break;

    case WATCH_WINDOW:
        if (GetWatchHwnd())
        {
            hwndActivate = GetWatchHwnd();
        }
        else
        {
            return NewWatch_CreateWindow(g_hwndMDIClient);
        }
        break;

    case LOCALS_WINDOW:
        if (GetLocalsHwnd())
        {
            hwndActivate = GetLocalsHwnd();
        }
        else
        {
            return NewLocals_CreateWindow(g_hwndMDIClient);
        }
        break;

    case CPU_WINDOW:
        if (GetCpuHwnd())
        {
            hwndActivate = GetCpuHwnd();
        }
        else
        {
            return NewCpu_CreateWindow(g_hwndMDIClient);
        }
        break;

    case SCRATCH_PAD_WINDOW:
        if (GetScratchHwnd())
        {
            hwndActivate = GetScratchHwnd();
        }
        else
        {
            return NewScratch_CreateWindow(g_hwndMDIClient);
        }
        break;

    case DISASM_WINDOW:
        if (!bUserActivated && GetSrcMode_StatusBar() &&
            NULL == GetDisasmHwnd() &&
            (g_WinOptions & WOPT_AUTO_DISASM) == 0)
        {
            return NULL;
        }

        if (GetDisasmHwnd())
        {
            hwndActivate = GetDisasmHwnd();
        }
        else
        {
            return NewDisasm_CreateWindow(g_hwndMDIClient);
        }
        break;

    case MEM_WINDOW:
        // Memory windows normally open a fresh window
        // whenever an open request occurs, but when applying
        // workspaces we don't want to continually add
        // new memory windows.  In the workspace case we
        // reuse existing memory windows as much as possible.
        if (Nth != NTH_OPEN_ALWAYS &&
            (CmnWin = FindNthWindow(Nth, 1 << winType)) != NULL)
        {
            hwndActivate = CmnWin->m_Win;
            break;
        }
        
        hwndActivate = NewMemory_CreateWindow(g_hwndMDIClient);
        if (hwndActivate)
        {
            MEMWIN_DATA * pMemWinData = GetMemWinData(hwndActivate);
            Assert(pMemWinData);

            // If this window is being created from a workspace
            // don't pop up the properties dialog.
            if ( Nth == NTH_OPEN_ALWAYS &&
                 pMemWinData->HasEditableProperties() )
            {
                pMemWinData->EditProperties();
                pMemWinData->UiRequestRead();
            }
        }
        break;

    case DOC_WINDOW:
        return NewDoc_CreateWindow(g_hwndMDIClient);

    case QUICKW_WINDOW:
        if (GetQuickWatchHwnd())
        {
            hwndActivate = GetQuickWatchHwnd();
        }
        else
        {
            return NewQuickWatch_CreateWindow(g_hwndMDIClient);
        }
        break;

    case CALLS_WINDOW:
        if (GetCallsHwnd())
        {
            hwndActivate = GetCallsHwnd();
        }
        else
        {
            return NewCalls_CreateWindow(g_hwndMDIClient);
        }
        break;
        
    case PROCESS_THREAD_WINDOW:
        if (GetProcessThreadHwnd())
        {
            hwndActivate = GetProcessThreadHwnd();
        }
        else
        {
            return NewProcessThread_CreateWindow(g_hwndMDIClient);
        }
        break;
    }

    if (hwndActivate)
    {
        if (GetKeyState(VK_SHIFT) < 0 &&
            GetKeyState(VK_CONTROL) >= 0)
        {
            SendMessage(g_hwndMDIClient, WM_MDIDESTROY,
                        (WPARAM)hwndActivate, 0);
        }
        else
        {
            if (IsIconic(hwndActivate))
            {
                OpenIcon(hwndActivate);
            }
            
            ActivateMDIChild(hwndActivate, bUserActivated);
        }
    }    

    return hwndActivate;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\windbg\docwin.h ===
/*++

Copyright (c) 1992-2002  Microsoft Corporation

Module Name:

    docwin.h

Environment:

    Win32, User Mode

--*/

#define MAX_SOURCE_PATH 1024

extern ULONG g_TabWidth;
extern BOOL g_DisasmActivateSource;
extern char g_EditorInvokeCommand[MAX_PATH + MAX_SOURCE_PATH];
extern char g_EditorUpdateCommand[MAX_PATH + MAX_SOURCE_PATH];

class DOCWIN_DATA : public EDITWIN_DATA
{
public:
    // Two filenames are kept for source files, the filename
    // by which the file was opened on the local file system
    // and the original filename from symbolic information (or NULL
    // if the file was not opened as a result of symbol lookup).
    // The found filename is the one presented to the user while
    // the symbol filename is for line symbol queries.
    TCHAR       m_FoundFile[MAX_SOURCE_PATH];
    TCHAR       m_SymFileBuffer[MAX_SOURCE_PATH];
    PCTSTR      m_SymFile;
    TCHAR       m_PathComponent[MAX_SOURCE_PATH];
    FILETIME    m_LastWriteTime;
    CHARRANGE   m_FindSel;
    ULONG       m_FindFlags;

    static HMENU s_ContextMenu;

    DOCWIN_DATA();

    virtual void Validate();

    virtual BOOL SelectedText(PTSTR Buffer, ULONG BufferChars);

    virtual BOOL CanGotoLine(void);
    virtual void GotoLine(ULONG Line);

    virtual void Find(PTSTR Text, ULONG Flags, BOOL FromDlg);

    virtual HRESULT CodeExprAtCaret(PSTR Expr, ULONG ExprSize,
                                    PULONG64 Offset);
    virtual void ToggleBpAtCaret(void);
    virtual void UpdateBpMarks(void);
    
    virtual HMENU GetContextMenu(void);
    virtual void  OnContextMenuSelection(UINT Item);
    
    virtual BOOL OnCreate(void);
    virtual LRESULT OnNotify(WPARAM wParam, LPARAM lParam);
    virtual void OnUpdate(UpdateType Type);
    
    virtual ULONG GetWorkspaceSize(void);
    virtual PUCHAR SetWorkspace(PUCHAR Data);
    virtual PUCHAR ApplyWorkspace1(PUCHAR Data, PUCHAR End);
    
    virtual BOOL LoadFile(PCTSTR FoundFile, PCTSTR SymFile,
                          PCTSTR PathComponent);
};
typedef DOCWIN_DATA *PDOCWIN_DATA;

BOOL
FindDocWindowByFileName(
    IN          PCTSTR          pszFile,
    OPTIONAL    HWND           *phwnd,
    OPTIONAL    PDOCWIN_DATA   *ppDocWinData
    );

BOOL OpenOrActivateFile(PCSTR FoundFile, PCSTR SymFile,
                        PCSTR PathComponent, ULONG Line,
                        BOOL Activate, BOOL UserActivated);
void UpdateCodeDisplay(ULONG64 Ip, PCSTR FoundFile, PCSTR SymFile,
                       PCSTR PathComponent, ULONG Line,
                       BOOL UserActivated);

VOID AddDocHwnd(HWND);
VOID RemoveDocHwnd(HWND);

void SetTabWidth(ULONG TabWidth);

void GetEditorCommandDefaults(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\windbg\dualwin.h ===
/*++

Copyright (c) 1992-2002  Microsoft Corporation

Module Name:

    dualwin.h

Abstract:

    Header for new window architecture functions.    

Environment:

    Win32, User Mode

--*/

//
// Allow editing of right & left panes
//
#define DL_EDIT_LEFTPANE    0x0001
#define DL_EDIT_SECONDPANE  0x0002
#define DL_EDIT_THIRDPANE   0x0004
#define DL_CUSTOM_ITEMS     0x0008

// Item flags for Get/SetItemFlags.
#define ITEM_CHANGED        0x00000001
#define ITEM_FLOATING_POINT 0x00000002
#define ITEM_USER_FLAGS     0xffff0000

#define ITEM_VALUE_CHANGED   0x10000000

class DUALLISTWIN_DATA : public SINGLE_CHILDWIN_DATA
{
public:
    DWORD   m_wFlags;
    // Handle to the list view control.
    HWND    m_hwndEditControl;
    int     m_nItem_LastSelected;
    int     m_nSubItem_LastSelected;
    // Item and subitem currently being edited
    int     m_nItem_CurrentlyEditing;
    int     m_nSubItem_CurrentlyEditing;

    DUALLISTWIN_DATA(ULONG ChangeBy);

    virtual void Validate();

    virtual void SetFont(ULONG FontIndex);
    
    virtual BOOL OnCreate(void);
    virtual LRESULT OnCommand(WPARAM wParam, LPARAM lParam);
    virtual LRESULT OnNotify(WPARAM wParam, LPARAM lParam);

    virtual BOOL ClearList(ULONG ClearFrom);
    virtual void EditText();
    virtual void InvalidateItem(int);

    virtual void ItemChanged(int Item, PCSTR Text);
    
    virtual LRESULT OnCustomDraw(LPNMLVCUSTOMDRAW Custom);
    virtual LRESULT OnCustomItem(ULONG SubItem, LPNMLVCUSTOMDRAW Custom);
    virtual void OnClick(LPNMLISTVIEW);

    virtual BOOL CanCopy();
    virtual BOOL CanCut();
    virtual BOOL CanPaste();
    virtual void Copy();
    virtual void Cut();
    virtual void Paste();

    virtual void UpdateColors(void);
    
    ULONG GetItemFlags(ULONG Item);
    void SetItemFlags(ULONG Item, ULONG Flags);
    BOOL SetItemFromEdit(ULONG Item, ULONG SubItem);
};
typedef DUALLISTWIN_DATA *PDUALLISTWIN_DATA;



class CPUWIN_DATA : public DUALLISTWIN_DATA
{
public:
    ULONG m_ProcType;
    ULONG m_NamesProcType;
    ULONG m_NumRegisters;
    BOOL m_CheckChanged;
    
    static HMENU s_ContextMenu;

    CPUWIN_DATA();

    virtual void Validate();

    virtual HRESULT ReadState(void);
    
    virtual HMENU GetContextMenu(void);
    virtual void  OnContextMenuSelection(UINT Item);
    
    virtual BOOL OnCreate(void);
    virtual LRESULT OnCommand(WPARAM wParam, LPARAM lParam);
    virtual void OnSize(void);
    virtual void OnUpdate(UpdateType Type);

    virtual void ItemChanged(int Item, PCSTR Text);
    
    virtual LRESULT OnCustomItem(ULONG SubItem, LPNMLVCUSTOMDRAW Custom);
    
    ULONG SetRegVals(HRESULT LockStatus,
                     PDEBUG_VALUE Vals,
                     PBOOL Changed,
                     RegisterNamesStateBuffer* NameBuf,
                     PULONG RegTypes,
                     PTSTR RegNames,
                     ULONG EntryIdx,
                     BOOL MatchChanged,
                     BOOL MatchChangedVal);
    void UpdateNames(BOOL FullUpdate);

    // Keep engine register index in the
    // user item flags.
    ULONG RegToFlags(USHORT Reg)
    {
        return (ULONG)Reg << 16;
    }
    USHORT FlagsToReg(ULONG Flags)
    {
        return (USHORT)(Flags >> 16);
    }
};
typedef CPUWIN_DATA * PCPUWIN_DATA;



class SYMWIN_DATA : public DUALLISTWIN_DATA
{
public:
    SYMWIN_DATA(IDebugSymbolGroup **pDbgSymbolGroup);
    ~SYMWIN_DATA();

    static HMENU s_ContextMenu;

    virtual void Validate();
    
    virtual HRESULT ReadState(void);

    virtual HMENU GetContextMenu(void);
    virtual void  OnContextMenuSelection(UINT Item);
    
    virtual BOOL OnCreate(void);
    virtual void OnSize(void);
    virtual LRESULT OnCommand(WPARAM wParam, LPARAM lParam);
    virtual LRESULT OnNotify(WPARAM  wParam, LPARAM lParam);
    virtual void OnUpdate(UpdateType Type);

    virtual ULONG GetWorkspaceSize(void);
    virtual PUCHAR SetWorkspace(PUCHAR Data);
    virtual PUCHAR ApplyWorkspace1(PUCHAR Data, PUCHAR End);

    virtual void ItemChanged(int Item, PCSTR Text);
    virtual void OnClick(LPNMLISTVIEW);
    virtual LRESULT OnOwnerDraw(UINT uMsg, WPARAM wParam, LPARAM lParam);
    
    void UpdateNames();
    BOOL AddListItem(ULONG iItem, PSTR ItemText, 
                     ULONG Level, BOOL HasChildren, BOOL Expanded);
    HRESULT      SetMaxSyms(ULONG nSyms);
    ULONG        GetMaxSyms() { return m_nWinSyms;}
    PDEBUG_SYMBOL_PARAMETERS GetSymParam() { return m_pWinSyms;}
    void SetDisplayTypes(LONG Id, BOOL Set);
    void DrawTreeItem(HDC hDC, ULONG itemID, RECT ItemRect, PULONG pIndentOffset);
    void ExpandSymbol(ULONG Index, BOOL Expand);

    void SyncUiWithFlags(ULONG Changed);

private:
    ULONG                    m_LastIndex;
    PDEBUG_SYMBOL_PARAMETERS m_pWinSyms;
    ULONG                    m_nWinSyms;
    BOOL                     m_DisplayTypes;
    BOOL                     m_DisplayOffsets;
    ULONG                    m_SplitWindowAtItem;
    LONG                     m_IndentWidth;
    ULONG                    m_NumCols;
    UCHAR                    m_ListItemLines[2048];

protected:    
    BOOL                     m_RefreshValues;
    ULONG                    m_MaxNameWidth;
    CHAR                     m_ChangedName[1024];
    ULONG                    m_RefreshItem;
    ULONG                    m_UpdateItem;
    ULONG                    m_NumSymsDisplayed;
    IDebugSymbolGroup      **m_pDbgSymbolGroup;
};

class WATCHWIN_DATA : public SYMWIN_DATA
{
public:
    WATCHWIN_DATA();

    virtual void Validate();
    HRESULT ReadState(void);
    
    virtual ULONG GetWorkspaceSize(void);
    virtual PUCHAR SetWorkspace(PUCHAR Data);
    virtual PUCHAR ApplyWorkspace1(PUCHAR Data, PUCHAR End);

private:
};
typedef WATCHWIN_DATA *PWATCHWIN_DATA;

extern BOOL g_ScopeChanged;


class LOCALSWIN_DATA : public SYMWIN_DATA
{
public:
    LOCALSWIN_DATA();
    ~LOCALSWIN_DATA();

    virtual BOOL OnCreate(void);
    virtual void Validate();
    HRESULT ReadState(void);
};
typedef LOCALSWIN_DATA *PLOCALSWIN_DATA;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\windbg\engine.cpp ===
//----------------------------------------------------------------------------
//
// Engine interface code.
//
// Copyright (C) Microsoft Corporation, 1999-2002.
//
//----------------------------------------------------------------------------

#include "precomp.hxx"
#pragma hdrstop

#include <dbghelp.h>

#define DBG_CALLBACK 0
#define DBG_INPUT 0

// Windows that change behavior depending on the execution status.
#define UPDATE_EXEC_WINDOWS     \
    ((1 << CPU_WINDOW) |        \
     (1 << DISASM_WINDOW) |     \
     (1 << CMD_WINDOW) |        \
     (1 << LOCALS_WINDOW) |     \
     (1 << WATCH_WINDOW) |      \
     (1 << MEM_WINDOW))

// Windows that use symbol information.
#define UPDATE_SYM_WINDOWS      \
    ((1 << DOC_WINDOW) |        \
     (1 << WATCH_WINDOW) |      \
     (1 << LOCALS_WINDOW) |     \
     (1 << DISASM_WINDOW) |     \
     (1 << QUICKW_WINDOW) |     \
     (1 << CALLS_WINDOW) |      \
     (1 << EVENT_BIT) |         \
     (1 << BP_BIT))

// Symbol options that cause visible changes and
// therefore require a refresh.  Note that this
// doesn't include options that would cause a visible
// change only after symbol reload as things will
// get refreshed when the load notifications come in.
#define REFRESH_SYMOPT          \
    (~(SYMOPT_CASE_INSENSITIVE | SYMOPT_DEFERRED_LOADS | SYMOPT_LOAD_LINES | \
       SYMOPT_LOAD_ANYTHING | SYMOPT_IGNORE_CVREC | \
       SYMOPT_NO_UNQUALIFIED_LOADS | SYMOPT_EXACT_SYMBOLS))

//
// Session initialization parameters.
//

// Turn on verbose output or not.
BOOL g_Verbose;
// Dump files to open.
PTSTR g_DumpFiles[MAX_DUMP_FILES];
ULONG g_NumDumpFiles;
PTSTR g_DumpInfoFiles[MAX_DUMP_FILES];
ULONG g_DumpInfoTypes[MAX_DUMP_FILES];
ULONG g_NumDumpInfoFiles;
// Process server to use.
PSTR g_ProcessServer;
// Full command line with exe name.
PSTR g_DebugCommandLine;
PSTR g_ProcessStartDir;
// Process creation flags.
ULONG g_DebugCreateFlags = DEBUG_ONLY_THIS_PROCESS;
// Process ID to attach to or zero.
ULONG g_PidToDebug;
// Process name to attach to or NULL.
PSTR g_ProcNameToDebug;
BOOL g_DetachOnExit;
ULONG g_AttachProcessFlags = DEBUG_ATTACH_DEFAULT;
// Kernel connection options.
ULONG g_AttachKernelFlags = DEBUG_ATTACH_KERNEL_CONNECTION;
PSTR g_KernelConnectOptions;

// Remoting options.
BOOL g_RemoteClient;
ULONG g_HistoryLines = 10000;

//
// Debug engine interfaces for the engine thread.
//
IDebugClient         *g_pDbgClient;
IDebugClient2        *g_pDbgClient2;
IDebugControl        *g_pDbgControl;
IDebugSymbols        *g_pDbgSymbols;
IDebugSymbolGroup    *g_pDbgWatchSymbolGroup;
IDebugSymbolGroup    *g_pDbgLocalSymbolGroup = NULL;
IDebugRegisters      *g_pDbgRegisters;
IDebugDataSpaces     *g_pDbgData;
IDebugSystemObjects  *g_pDbgSystem;
IDebugSystemObjects3 *g_pDbgSystem3;

//
// Debug engine interfaces for the UI thread.
//
IDebugClient        *g_pUiClient;
IDebugControl       *g_pUiControl;
IDebugControl3      *g_pUiControl3;
IDebugSymbols       *g_pUiSymbols;
IDebugSymbols2      *g_pUiSymbols2;
IDebugSystemObjects *g_pUiSystem;

//
// Debug engine interfaces for private output capture.
//
IDebugClient        *g_pOutCapClient;
IDebugControl       *g_pOutCapControl;
IDebugSymbols       *g_pOutCapSymbols;
//
// Debug engine interfaces for local source file lookup.
//
IDebugClient        *g_pLocClient;
IDebugControl       *g_pLocControl;
IDebugSymbols       *g_pLocSymbols;
IDebugClient        *g_pUiLocClient;
IDebugControl       *g_pUiLocControl;
IDebugSymbols       *g_pUiLocSymbols;

ULONG g_ActualProcType = IMAGE_FILE_MACHINE_UNKNOWN;
char g_ActualProcAbbrevName[32];
ULONG g_CommandSequence;
ULONG g_TargetClass = DEBUG_CLASS_UNINITIALIZED;
ULONG g_TargetClassQual;
BOOL g_Ptr64;
ULONG g_ExecStatus = DEBUG_STATUS_NO_DEBUGGEE;
ULONG g_EngOptModified;
ULONG g_EngineThreadId;
HANDLE g_EngineThread;
PSTR g_InitialCommand;
char g_PromptText[32];
BOOL g_WaitingForEvent;
ULONG g_NumberRadix;
BOOL g_CodeLevelLocked;
BOOL g_IgnoreFilterChange;
BOOL g_IgnoreCodeLevelChange;
BOOL g_IgnoreThreadChange;
ULONG g_LastProcessExitCode;
ULONG g_SymOptions;
ULONG g_TypeOptions;

BOOL g_InputStarted;
BOOL g_Invisible;
BOOL g_HoldWaitOutput;
BOOL g_ScopeChanged;

enum
{
    ENDING_NONE,
    ENDING_RESTART,
    ENDING_STOP,
    ENDING_EXIT
};

ULONG g_EndingSession = ENDING_NONE;

void SetLocalScope(PDEBUG_STACK_FRAME);

BOOL g_SessionActive;
void SessionActive(void);
void SessionInactive(void);

StateBuffer g_UiCommandBuffer(MAX_COMMAND_LEN);
StateBuffer g_UiOutputBuffer(128 * 1024);

//----------------------------------------------------------------------------
//
// Default output callbacks implementation, provides IUnknown for
// static classes.
//
//----------------------------------------------------------------------------

STDMETHODIMP
DefOutputCallbacks::QueryInterface(
    THIS_
    IN REFIID InterfaceId,
    OUT PVOID* Interface
    )
{
    *Interface = NULL;

    if (IsEqualIID(InterfaceId, IID_IUnknown) ||
        IsEqualIID(InterfaceId, IID_IDebugOutputCallbacks))
    {
        *Interface = (IDebugOutputCallbacks *)this;
        AddRef();
        return S_OK;
    }
    else
    {
        return E_NOINTERFACE;
    }
}

STDMETHODIMP_(ULONG)
DefOutputCallbacks::AddRef(
    THIS
    )
{
    // This class is designed to be static so
    // there's no true refcount.
    return 1;
}

STDMETHODIMP_(ULONG)
DefOutputCallbacks::Release(
    THIS
    )
{
    // This class is designed to be static so
    // there's no true refcount.
    return 0;
}

//----------------------------------------------------------------------------
//
// Command window output callbacks.
//
//----------------------------------------------------------------------------

class OutputCallbacks : public DefOutputCallbacks
{
public:
    // IDebugOutputCallbacks.
    STDMETHOD(Output)(
        THIS_
        IN ULONG Mask,
        IN PCSTR Text
        );
};

STDMETHODIMP
OutputCallbacks::Output(
    THIS_
    IN ULONG Mask,
    IN PCSTR Text
    )
{
    LockUiBuffer(&g_UiOutputBuffer);

    HRESULT Status;
    ULONG Len;
    PSTR DataStart;

    Len = sizeof(Mask) + strlen(Text) + 1;
    if ((DataStart = (PSTR)g_UiOutputBuffer.AddData(Len)) != NULL)
    {
        *(ULONG UNALIGNED *)DataStart = Mask;
        DataStart += sizeof(Mask);
        strcpy(DataStart, Text);

        if (!g_HoldWaitOutput || !g_WaitingForEvent)
        {
            UpdateUi();
        }
        Status = S_OK;
    }
    else
    {
        Status = E_OUTOFMEMORY;
    }

    UnlockUiBuffer(&g_UiOutputBuffer);
    return Status;
}

OutputCallbacks g_OutputCb;

//----------------------------------------------------------------------------
//
// Input callbacks.
//
//----------------------------------------------------------------------------

class InputCallbacks :
    public IDebugInputCallbacks
{
public:
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        );
    STDMETHOD_(ULONG, AddRef)(
        THIS
        );
    STDMETHOD_(ULONG, Release)(
        THIS
        );

    // IDebugInputCallbacks.
    STDMETHOD(StartInput)(
        THIS_
        IN ULONG BufferSize
        );
    STDMETHOD(EndInput)(
        THIS
        );
};

STDMETHODIMP
InputCallbacks::QueryInterface(
    THIS_
    IN REFIID InterfaceId,
    OUT PVOID* Interface
    )
{
    *Interface = NULL;

    if (IsEqualIID(InterfaceId, IID_IUnknown) ||
        IsEqualIID(InterfaceId, IID_IDebugInputCallbacks))
    {
        *Interface = (IDebugInputCallbacks *)this;
        AddRef();
        return S_OK;
    }
    else
    {
        return E_NOINTERFACE;
    }
}

STDMETHODIMP_(ULONG)
InputCallbacks::AddRef(
    THIS
    )
{
    // This class is designed to be static so
    // there's no true refcount.
    return 1;
}

STDMETHODIMP_(ULONG)
InputCallbacks::Release(
    THIS
    )
{
    // This class is designed to be static so
    // there's no true refcount.
    return 0;
}

STDMETHODIMP
InputCallbacks::StartInput(
    THIS_
    IN ULONG BufferSize
    )
{
    HRESULT Status;

    //
    // Pull the first command input command out
    // of the UI's command buffer and use it as input.
    //

    LockUiBuffer(&g_UiCommandBuffer);

    UiCommandData* CmdData =
        (UiCommandData*)g_UiCommandBuffer.GetDataBuffer();
    UiCommandData* CmdEnd = (UiCommandData*)
        ((PBYTE)g_UiCommandBuffer.GetDataBuffer() +
         g_UiCommandBuffer.GetDataLen());

    while (CmdData < CmdEnd)
    {
        if (CmdData->Cmd == UIC_CMD_INPUT)
        {
            break;
        }

        CmdData = (UiCommandData*)((PBYTE)CmdData + CmdData->Len);
    }

#if DBG_INPUT
    DebugPrint("StartInput available %d\n", CmdData < CmdEnd);
#endif

    if (CmdData < CmdEnd)
    {
        g_OutputCb.Output(DEBUG_OUTPUT_NORMAL, (PSTR)(CmdData + 1));
        g_OutputCb.Output(DEBUG_OUTPUT_NORMAL, "\n");

        Status = g_pUiControl->ReturnInput((PSTR)(CmdData + 1));

#if DBG_INPUT
        DebugPrint("  ReturnInput status %X\n", Status);
#endif

        g_UiCommandBuffer.
            RemoveMiddle((ULONG)((PBYTE)CmdData -
                                 (PBYTE)g_UiCommandBuffer.GetDataBuffer()),
                         CmdData->Len);
    }
    else
    {
        g_InputStarted = TRUE;
        // Didn't find any input waiting.
        // Let the command window know that input is needed.
        UpdateBufferWindows(1 << CMD_WINDOW, UPDATE_INPUT_REQUIRED);
    }

    UnlockUiBuffer(&g_UiCommandBuffer);
    return S_OK;
}

STDMETHODIMP
InputCallbacks::EndInput(
    THIS
    )
{
    LockUiBuffer(&g_UiCommandBuffer);

#if DBG_INPUT
    DebugPrint("EndInput started %d\n", g_InputStarted);
#endif

    g_InputStarted = FALSE;
    // Reset the command window's state to what it was.
    UpdateBufferWindows(1 << CMD_WINDOW, UPDATE_EXEC);

    UnlockUiBuffer(&g_UiCommandBuffer);
    return S_OK;
}

InputCallbacks g_InputCb;

//----------------------------------------------------------------------------
//
// Event callbacks.
//
//----------------------------------------------------------------------------

// This is safe to do from the engine thread as
// it just sets a flag.
#define DIRTY_WORKSPACE(Flags)                                                \
if (!g_RemoteClient &&                                                        \
    g_EndingSession == ENDING_NONE && !g_Invisible && g_Workspace != NULL)    \
{                                                                             \
    g_Workspace->AddDirty(Flags);                                             \
}

STDMETHODIMP_(ULONG)
EventCallbacks::AddRef(
    THIS
    )
{
    // This class is designed to be static so
    // there's no true refcount.
    return 1;
}

STDMETHODIMP_(ULONG)
EventCallbacks::Release(
    THIS
    )
{
    // This class is designed to be static so
    // there's no true refcount.
    return 0;
}

STDMETHODIMP
EventCallbacks::GetInterestMask(
    THIS_
    OUT PULONG Mask
    )
{
    *Mask =
        DEBUG_EVENT_CREATE_THREAD |
        DEBUG_EVENT_EXIT_THREAD |
        DEBUG_EVENT_CREATE_PROCESS |
        DEBUG_EVENT_EXIT_PROCESS |
        DEBUG_EVENT_SESSION_STATUS |
        DEBUG_EVENT_CHANGE_DEBUGGEE_STATE |
        DEBUG_EVENT_CHANGE_ENGINE_STATE |
        DEBUG_EVENT_CHANGE_SYMBOL_STATE;
    return S_OK;
}

STDMETHODIMP
EventCallbacks::CreateThread(
    THIS_
    IN ULONG64 Handle,
    IN ULONG64 DataOffset,
    IN ULONG64 StartOffset
    )
{
    ULONG InvFlags =
        (1 << PROCESS_THREAD_WINDOW);

#if DBG_CALLBACK
    DebugPrint(" CT\n");
#endif

    // There's no need to update buffers when we're throwing
    // everything away while shutting down a session.
    if (g_EndingSession == ENDING_NONE && InvFlags)
    {
        InvalidateStateBuffers(InvFlags);
        UpdateEngine();
    }

    return DEBUG_STATUS_NO_CHANGE;
}

STDMETHODIMP
EventCallbacks::ExitThread(
    THIS_
    IN ULONG ExitCode
    )
{
    ULONG InvFlags =
        (1 << PROCESS_THREAD_WINDOW);

#if DBG_CALLBACK
    DebugPrint(" ET\n");
#endif

    // There's no need to update buffers when we're throwing
    // everything away while shutting down a session.
    if (g_EndingSession == ENDING_NONE && InvFlags)
    {
        InvalidateStateBuffers(InvFlags);
        UpdateEngine();
    }

    return DEBUG_STATUS_NO_CHANGE;
}

STDMETHODIMP
EventCallbacks::CreateProcess(
    THIS_
    IN ULONG64 ImageFileHandle,
    IN ULONG64 Handle,
    IN ULONG64 BaseOffset,
    IN ULONG ModuleSize,
    IN PCSTR ModuleName,
    IN PCSTR ImageName,
    IN ULONG CheckSum,
    IN ULONG TimeDateStamp,
    IN ULONG64 InitialThreadHandle,
    IN ULONG64 ThreadDataOffset,
    IN ULONG64 StartOffset
    )
{
    ULONG InvFlags =
        (1 << PROCESS_THREAD_WINDOW);

#if DBG_CALLBACK
    DebugPrint("CPR\n");
#endif

    // Use this opportunity to get initial insertion
    // of any workspace breakpoints and process other workspace
    // commands which may be queued.
    ProcessEngineCommands(TRUE);

    // There's no need to update buffers when we're throwing
    // everything away while shutting down a session.
    if (g_EndingSession == ENDING_NONE && InvFlags)
    {
        InvalidateStateBuffers(InvFlags);
        UpdateEngine();
    }

    return DEBUG_STATUS_NO_CHANGE;
}

STDMETHODIMP
EventCallbacks::ExitProcess(
    THIS_
    IN ULONG ExitCode
    )
{
    ULONG InvFlags =
        (1 << PROCESS_THREAD_WINDOW);

#if DBG_CALLBACK
    DebugPrint("EPR\n");
#endif

    // There's no need to update buffers when we're throwing
    // everything away while shutting down a session.
    if (g_EndingSession == ENDING_NONE && InvFlags)
    {
        InvalidateStateBuffers(InvFlags);
        UpdateEngine();
    }

    g_LastProcessExitCode = ExitCode;
    return DEBUG_STATUS_NO_CHANGE;
}

STDMETHODIMP
EventCallbacks::SessionStatus(
    THIS_
    IN ULONG Status
    )
{
#if DBG_CALLBACK
    DebugPrint(" SS %X\n", Status);
#endif

    switch(Status)
    {
    case DEBUG_SESSION_ACTIVE:
        SessionActive();
        break;
    case DEBUG_SESSION_END_SESSION_ACTIVE_TERMINATE:
    case DEBUG_SESSION_END_SESSION_ACTIVE_DETACH:
    case DEBUG_SESSION_END:
    case DEBUG_SESSION_REBOOT:
    case DEBUG_SESSION_HIBERNATE:
        SessionInactive();
        break;
    }
    return DEBUG_STATUS_NO_CHANGE;
}

STDMETHODIMP
EventCallbacks::ChangeDebuggeeState(
    THIS_
    IN ULONG Flags,
    IN ULONG64 Argument
    )
{
    ULONG InvFlags =
        (1 << WATCH_WINDOW) |
        (1 << LOCALS_WINDOW) |
        (1 << DISASM_WINDOW) |
        (1 << QUICKW_WINDOW) |
        (1 << CALLS_WINDOW);

    // Invalidate everything that changed.
    if (Flags & DEBUG_CDS_REGISTERS)
    {
        InvFlags |= (1 << EVENT_BIT) | (1 << CPU_WINDOW);
    }
    if (Flags & DEBUG_CDS_DATA)
    {
        InvFlags |=
            (1 << MEM_WINDOW);
    }

#if DBG_CALLBACK
    DebugPrint("CDS %X, arg %I64X, inv %X\n", Flags, Argument, InvFlags);
#endif

    // There's no need to update buffers when we're throwing
    // everything away while shutting down a session.
    if (g_EndingSession == ENDING_NONE)
    {
        InvalidateStateBuffers(InvFlags);
    }
    if (InvFlags != 0)
    {
        UpdateEngine();
    }
    return S_OK;
}

STDMETHODIMP
EventCallbacks::ChangeEngineState(
    THIS_
    IN ULONG Flags,
    IN ULONG64 Argument
    )
{
    ULONG InvFlags = 0;

    // If the current thread changed we need to get
    // new context information for the thread.
    if ((Flags & DEBUG_CES_CURRENT_THREAD) &&
        !g_IgnoreThreadChange)
    {
        InvFlags |=
            (1 << LOCALS_WINDOW) |
            (1 << CPU_WINDOW) |
            (1 << DISASM_WINDOW) |
            (1 << CALLS_WINDOW) |
            (1 << PROCESS_THREAD_WINDOW) |
            (1 << EVENT_BIT) |
            (1 << BP_BIT);
    }

    // If the effective processor changed we need to update
    // anything related to processor information.
    if (Flags & DEBUG_CES_EFFECTIVE_PROCESSOR)
    {
        InvFlags |=
            (1 << CPU_WINDOW) |
            (1 << DISASM_WINDOW) |
            (1 << CALLS_WINDOW) |
            (1 << BP_BIT);
    }

    // If breakpoints changed we need to update the breakpoint cache.
    if (Flags & DEBUG_CES_BREAKPOINTS)
    {
        InvFlags |= (1 << BP_BIT);

        // If it's a bulk edit it's coming from a thread or process exit
        // or from a session shutdown rather than a user operation.
        // We only want to remember user-driven changes in the workspace.
        if (Argument != DEBUG_ANY_ID)
        {
            InvFlags |= (1 << BP_CMDS_BIT);
            DIRTY_WORKSPACE(WSPF_DIRTY_BREAKPOINTS);
        }
    }

    // If the code level changed we need to update the toolbar.
    if (Flags & DEBUG_CES_CODE_LEVEL)
    {
        InvFlags |= (1 << BP_BIT);

        // If this isn't a notification due to a change
        // from windbg itself the user must have changed
        // things via a command.  If the user does
        // change things from the command window lock
        // the code level so that it isn't overridden
        // automatically.
        if (!g_Invisible && !g_IgnoreCodeLevelChange)
        {
            g_CodeLevelLocked = TRUE;
            PostMessage(g_hwndFrame, WU_UPDATE,
                        UPDATE_BUFFER, (ULONG)Argument);
        }
        else
        {
            // Setting the source mode from the GUI enables
            // the source setting to float along with whether
            // the GUI can display source code or not.
            g_CodeLevelLocked = FALSE;
        }
    }

    if (Flags & DEBUG_CES_EXECUTION_STATUS)
    {
        // If this notification came from a wait completing
        // we want to wake up things thread so that new
        // commands can be processed.  If it came from inside
        // a wait we don't want to wake up as the engine
        // may go back to running at any time.
        if ((Argument & DEBUG_STATUS_INSIDE_WAIT) == 0 &&
            (ULONG)Argument != g_ExecStatus)
        {
            g_ExecStatus = (ULONG)Argument;

            UpdateBufferWindows(UPDATE_EXEC_WINDOWS, UPDATE_EXEC);

            if (InvFlags == 0)
            {
                // Force the loop waiting in DispatchCallbacks to go around.
                UpdateEngine();
            }
        }
    }

    // If the log file changed we need to update the workspace.
    if (Flags & DEBUG_CES_LOG_FILE)
    {
        DIRTY_WORKSPACE(WSPF_DIRTY_LOG_FILE);
    }

    // If event filters changed we need to update the filter cache.
    if ((Flags & DEBUG_CES_EVENT_FILTERS) &&
        !g_IgnoreFilterChange)
    {
        InvFlags |= (1 << FILTER_BIT);
        DIRTY_WORKSPACE(WSPF_DIRTY_FILTERS);
    }

    if (Flags & DEBUG_CES_RADIX)
    {
        g_NumberRadix = (ULONG)Argument;
        InvFlags |=
            (1 << WATCH_WINDOW) |
            (1 << LOCALS_WINDOW) |
            (1 << CPU_WINDOW);
    }

    if (Flags & DEBUG_CES_SYSTEMS)
    {
        InvFlags |=
            (1 << PROCESS_THREAD_WINDOW);
    }

    if (Flags & DEBUG_CES_ASSEMBLY_OPTIONS)
    {
        InvFlags |=
            (1 << DISASM_WINDOW);

        if (g_Workspace != NULL)
        {
            g_Workspace->SetUlong(WSP_GLOBAL_ASSEMBLY_OPTIONS,
                                  (ULONG)Argument);
        }
    }

    if (Flags & DEBUG_CES_EXPRESSION_SYNTAX)
    {
        InvFlags |=
            (1 << LOCALS_WINDOW) |
            (1 << WATCH_WINDOW);

        if (g_Workspace != NULL)
        {
            g_Workspace->SetUlong(WSP_GLOBAL_EXPRESSION_SYNTAX,
                                  (ULONG)Argument);
        }
    }

    if (Flags & DEBUG_CES_TEXT_REPLACEMENTS)
    {
        InvFlags |= (1 << ALIAS_BIT);
        DIRTY_WORKSPACE(WSPF_DIRTY_ALIASES);
    }

#if DBG_CALLBACK
    DebugPrint("CES %X, arg %I64X, inv %X\n", Flags, Argument, InvFlags);
#endif

    // There's no need to update buffers when we're throwing
    // everything away while shutting down a session.
    if (g_EndingSession == ENDING_NONE)
    {
        InvalidateStateBuffers(InvFlags);
    }
    if (InvFlags != 0)
    {
        UpdateEngine();
    }
    if (InvFlags & (1 << LOCALS_WINDOW))
    {
        g_ScopeChanged = TRUE;
    }
    return S_OK;
}

STDMETHODIMP
EventCallbacks::ChangeSymbolState(
    THIS_
    IN ULONG Flags,
    IN ULONG64 Argument
    )
{
    ULONG InvFlags = 0;

    // If module information changed we need to update
    // everything that might display or depend on symbols.
    if (Flags & (DEBUG_CSS_LOADS |
                 DEBUG_CSS_UNLOADS))
    {

        InvFlags |= UPDATE_SYM_WINDOWS | (1 << MODULE_BIT);

        // On any generic module load/unload refresh
        // windbg's module state.  This helps catch stale
        // source after explicit .reload commands and
        // other global refresh changes.
        if (!Argument)
        {
            UpdateBufferWindows((1 << DOC_WINDOW),
                                UPDATE_REFRESH_MODULES);
        }
    }

    // If the scope changed we need to update scope-related windows.
    if (Flags & DEBUG_CSS_SCOPE)
    {
        InvFlags |=
            (1 << WATCH_WINDOW) |
            (1 << LOCALS_WINDOW) |
            (1 << CALLS_WINDOW);
    }

    // If paths changed we need to update
    // the event state in case we can suddenly load source.
    if (Flags & DEBUG_CSS_PATHS)
    {
        InvFlags |= (1 << EVENT_BIT);
        DIRTY_WORKSPACE(WSPF_DIRTY_PATHS);
    }

    // If certain options changed we need to update
    // everything that might display or depend on symbols.
    if (Flags & DEBUG_CSS_SYMBOL_OPTIONS)
    {
        if ((g_SymOptions ^ (ULONG)Argument) & REFRESH_SYMOPT)
        {
            InvFlags |= UPDATE_SYM_WINDOWS;
        }

        g_SymOptions = (ULONG)Argument;
    }

    // If certain options changed we need to update
    // everything that might display or depend on symbols.
    if (Flags & DEBUG_CSS_TYPE_OPTIONS)
    {
        InvFlags |=
            (1 << WATCH_WINDOW) |
            (1 << LOCALS_WINDOW) |
            (1 << CALLS_WINDOW);

        if (g_pUiSymbols2 != NULL)
        {
            g_pUiSymbols2->GetTypeOptions( &g_TypeOptions );

            if (g_Workspace != NULL)
            {
                g_Workspace->SetUlong(WSP_GLOBAL_TYPE_OPTIONS,
                                      g_TypeOptions);
            }
        }
    }

#if DBG_CALLBACK
    DebugPrint("CSS %X, arg %I64X, inv %X\n", Flags, Argument, InvFlags);
#endif

    // There's no need to update buffers when we're throwing
    // everything away while shutting down a session.
    if (g_EndingSession == ENDING_NONE)
    {
        InvalidateStateBuffers(InvFlags);
    }
    if (InvFlags != 0)
    {
        UpdateEngine();
    }
    if (InvFlags & (1 << LOCALS_WINDOW))
    {
        g_ScopeChanged = TRUE;
    }
    return S_OK;
}

EventCallbacks g_EventCb;

//----------------------------------------------------------------------------
//
// Inter-thread communication.
//
//----------------------------------------------------------------------------

#define COMMAND_OVERHEAD (sizeof(ULONG64) + sizeof(UiCommandData))

PVOID
StartCommand(UiCommand Cmd, ULONG Len)
{
    UiCommandData* Data;

    // Round length up to a multiple of ULONG64s for
    // alignment.
    Len = ((Len + sizeof(ULONG64) - 1) & ~(sizeof(ULONG64) - 1)) +
        sizeof(UiCommandData);

    if (Len > MAX_COMMAND_LEN)
    {
        return NULL;
    }

    LockUiBuffer(&g_UiCommandBuffer);

    Data = (UiCommandData *)g_UiCommandBuffer.AddData(Len);
    if (Data == NULL)
    {
        return Data;
    }

    Data->Cmd = Cmd;
    Data->Len = Len;

    return Data + 1;
}

void
FinishCommand(void)
{
    UnlockUiBuffer(&g_UiCommandBuffer);

    // Wake up the engine to process the command.
    UpdateEngine();
}

BOOL
AddStringCommand(UiCommand Cmd, PCSTR Str)
{
    ULONG StrLen = strlen(Str) + 1;
    PSTR Data;

    // If we're adding command input we may need
    // to send it directly to the engine in response
    // to an input request.
    if (Cmd == UIC_CMD_INPUT)
    {
        LockUiBuffer(&g_UiCommandBuffer);

#if DBG_INPUT
        DebugPrint("InputStarted started %d\n", g_InputStarted);
#endif

        if (g_InputStarted)
        {
            HRESULT Status;

            g_OutputCb.Output(DEBUG_OUTPUT_NORMAL, Str);
            g_OutputCb.Output(DEBUG_OUTPUT_NORMAL, "\n");
            Status = g_pUiControl->ReturnInput(Str);
#if DBG_INPUT
            DebugPrint("  ReturnInput status %X\n", Status);
#endif
            g_InputStarted = FALSE;
            UnlockUiBuffer(&g_UiCommandBuffer);
            return TRUE;
        }
    }

    Data = (PSTR)StartCommand(Cmd, StrLen);

    if (Cmd == UIC_CMD_INPUT)
    {
        UnlockUiBuffer(&g_UiCommandBuffer);
    }

    if (Data == NULL)
    {
        return FALSE;
    }

    memcpy(Data, Str, StrLen);

    FinishCommand();
    return TRUE;
}

BOOL
AddStringMultiCommand(UiCommand Cmd, PSTR Str, BOOL ForceSplit)
{
    //
    // Given a string with multiple commands separated
    // by newlines, break the string into multiple
    // commands, one per line.  This allows arbitrarily
    // large command strings without running into
    // the MAX_COMMAND_LEN limit as long as each individual
    // line fits within that limit.
    //
    while (*Str)
    {
        PSTR Scan, LastNl;
        ULONG Len;
        BOOL Status;

        Scan = Str + 1;
        Len = 1;
        LastNl = NULL;
        while (*Scan && Len < (MAX_COMMAND_LEN - COMMAND_OVERHEAD))
        {
            if (*Scan == '\n')
            {
                LastNl = Scan;
                if (ForceSplit)
                {
                    Scan++;
                    break;
                }
            }

            Scan++;
            Len++;
        }

        // If the rest of the command string doesn't fit
        // within the limit it needs to be split.
        // If there's no newline to break it at
        // the command is too large to be processed.
        if (*Scan && !LastNl)
        {
            return FALSE;
        }

        // Split if necessary.
        if (*Scan)
        {
            *LastNl = 0;
        }

        // Add the head (which may be the whole remainder).
        Status = AddStringCommand(Cmd, Str);

        if (*Scan)
        {
            *LastNl = '\n';

            if (!Status)
            {
                return FALSE;
            }

            Str = LastNl + 1;
        }
        else
        {
            return Status;
        }
    }

    return TRUE;
}

BOOL __cdecl
PrintStringCommand(UiCommand Cmd, PCSTR Format, ...)
{
    char Buf[MAX_COMMAND_LEN - COMMAND_OVERHEAD];
    va_list Args;

    va_start(Args, Format);
    _vsnprintf(Buf, DIMA(Buf), Format, Args);
    Buf[DIMA(Buf) - 1] = 0;
    va_end(Args);
    return AddStringCommand(Cmd, Buf);
}

void
WriteData(UIC_WRITE_DATA_DATA* WriteData)
{
    ULONG Written;

    switch(WriteData->Type)
    {
    default:
        Assert(!"Unhandled condition");
        break;

    case PHYSICAL_MEM_TYPE:
        g_pDbgData->WritePhysical(WriteData->Offset,
                                  WriteData->Data,
                                  WriteData->Length,
                                  &Written
                                  );
        break;

    case VIRTUAL_MEM_TYPE:
        g_pDbgData->WriteVirtual(WriteData->Offset,
                                 WriteData->Data,
                                 WriteData->Length,
                                 &Written
                                 );
        break;

    case CONTROL_MEM_TYPE:
        g_pDbgData->WriteControl(WriteData->Any.control.Processor,
                                 WriteData->Offset,
                                 WriteData->Data,
                                 WriteData->Length,
                                 &Written
                                 );
        break;

    case IO_MEM_TYPE:
        g_pDbgData->WriteIo(WriteData->Any.io.interface_type,
                            WriteData->Any.io.BusNumber,
                            WriteData->Any.io.AddressSpace,
                            WriteData->Offset,
                            WriteData->Data,
                            WriteData->Length,
                            &Written
                            );
        break;

    case MSR_MEM_TYPE:
        Assert(WriteData->Length == sizeof(ULONG64));
        g_pDbgData->WriteMsr((ULONG)WriteData->Offset,
                             *(PULONG64)WriteData->Data
                             );
        break;

    case BUS_MEM_TYPE:
        g_pDbgData->WriteBusData(WriteData->Any.bus.bus_type,
                                 WriteData->Any.bus.BusNumber,
                                 WriteData->Any.bus.SlotNumber,
                                 (ULONG)WriteData->Offset,
                                 WriteData->Data,
                                 WriteData->Length,
                                 &Written
                                 );
        break;
    }
}

void
ProcessWatchCommand(
    UIC_SYMBOL_WIN_DATA *SymWinData
    )
{
    PDEBUG_SYMBOL_GROUP pSymbolGroup;
    if (!SymWinData->pSymbolGroup ||
        !(pSymbolGroup = *SymWinData->pSymbolGroup))
    {
        return;
    }
    switch (SymWinData->Type)
    {
    case ADD_SYMBOL_WIN:
        if (strlen(SymWinData->u.Add.Name))
        {
            // add only non-empty symbols
            pSymbolGroup->AddSymbol(SymWinData->u.Add.Name,
                                    &SymWinData->u.Add.Index);
        }
        break;

    case DEL_SYMBOL_WIN_INDEX:
        pSymbolGroup->RemoveSymbolByIndex(SymWinData->u.DelIndex);
        break;

    case DEL_SYMBOL_WIN_NAME:
        pSymbolGroup->RemoveSymbolByName(SymWinData->u.DelName);
        break;

    case QUERY_NUM_SYMBOL_WIN:
        pSymbolGroup->GetNumberSymbols(SymWinData->u.NumWatch);
        break;

    case GET_NAME:
        pSymbolGroup->GetSymbolName(SymWinData->u.GetName.Index,
                                    SymWinData->u.GetName.Buffer,
                                    SymWinData->u.GetName.BufferSize,
                                    SymWinData->u.GetName.NameSize);
        break;

    case GET_PARAMS:
        pSymbolGroup->
            GetSymbolParameters(SymWinData->u.GetParams.Start,
                                SymWinData->u.GetParams.Count,
                                SymWinData->u.GetParams.SymbolParams);
        break;

    case EXPAND_SYMBOL:
        pSymbolGroup->ExpandSymbol(SymWinData->u.ExpandSymbol.Index,
                                   SymWinData->u.ExpandSymbol.Expand);
        break;
    case EDIT_SYMBOL:
        pSymbolGroup->WriteSymbol(SymWinData->u.WriteSymbol.Index,
                                  SymWinData->u.WriteSymbol.Value);
        break;
    case EDIT_TYPE:
        pSymbolGroup->OutputAsType(SymWinData->u.OutputAsType.Index,
                                  SymWinData->u.OutputAsType.Type);
        break;
    case DEL_SYMBOL_WIN_ALL:
    {
        ULONG nSyms = 0;

        pSymbolGroup->GetNumberSymbols(&nSyms);

        while (nSyms)
        {
            pSymbolGroup->RemoveSymbolByIndex(0);
            pSymbolGroup->GetNumberSymbols(&nSyms);
        }

        }
    }
}

void
ProcessCommand(UiCommandData* CmdData)
{
    DEBUG_VALUE Val;
    HRESULT Status;

    switch(CmdData->Cmd)
    {
    case UIC_CMD_INPUT:
    case UIC_EXECUTE:
        PSTR Str;
        ULONG StrLen;

        // Make sure the command has a newline at the end.
        Str = (PSTR)(CmdData + 1);
        StrLen = strlen(Str);
        if (StrLen > 0 && Str[StrLen - 1] == '\n')
        {
            // Trim existing newline as we're adding one.
            Str[StrLen - 1] = 0;
        }

        if (g_RemoteClient)
        {
            // Identify self before command.
            g_pDbgClient->OutputIdentity(DEBUG_OUTCTL_ALL_OTHER_CLIENTS,
                                         DEBUG_OUTPUT_IDENTITY_DEFAULT,
                                         "[%s] ");
        }

        g_pDbgControl->OutputPrompt(DEBUG_OUTCTL_ALL_CLIENTS, " %s\n", Str);
        g_pDbgControl->Execute(DEBUG_OUTCTL_ALL_CLIENTS,
                               Str, DEBUG_EXECUTE_NOT_LOGGED);
        break;

    case UIC_SILENT_EXECUTE:
        // Execute the command without displaying it.
        g_pDbgControl->Execute(DEBUG_OUTCTL_IGNORE,
                               (PCSTR)(CmdData + 1),
                               DEBUG_EXECUTE_NOT_LOGGED |
                               DEBUG_EXECUTE_NO_REPEAT);
        break;

    case UIC_INVISIBLE_EXECUTE:
        // Execute the command without displaying it and
        // ignore any notifications.
        g_Invisible = TRUE;
        g_pDbgControl->Execute(DEBUG_OUTCTL_IGNORE,
                               (PCSTR)(CmdData + 1),
                               DEBUG_EXECUTE_NOT_LOGGED |
                               DEBUG_EXECUTE_NO_REPEAT);
        g_Invisible = FALSE;
        break;

    case UIC_SET_REG:
        UIC_SET_REG_DATA* SetRegData;
        SetRegData = (UIC_SET_REG_DATA*)(CmdData + 1);
        g_pDbgRegisters->SetValue(SetRegData->Reg, &SetRegData->Val);
        break;

    case UIC_RESTART:
        if (g_RemoteClient)
        {
            g_pDbgControl->
                Output(DEBUG_OUTPUT_ERROR,
                       "Only user-mode created processes may be restarted\n");
        }
        else
        {
            if ((Status = g_pDbgClient->
                 EndSession(DEBUG_END_ACTIVE_TERMINATE)) != S_OK)
            {
                InternalError(Status, "EndSession");
            }
            else
            {
                g_EndingSession = ENDING_RESTART;
            }
        }
        break;

    case UIC_END_SESSION:
        ULONG OldEnding;
        ULONG OldExec;

        // Mark the session as ending to avoid workspace
        // deadlock problems.
        OldEnding = g_EndingSession;
        OldExec = g_ExecStatus;
        g_EndingSession = ENDING_STOP;
        g_ExecStatus = DEBUG_STATUS_NO_DEBUGGEE;

        if (!g_RemoteClient)
        {
            if ((Status = g_pDbgClient->
                 EndSession(DEBUG_END_ACTIVE_TERMINATE)) != S_OK)
            {
                InternalError(Status, "EndSession");
                g_EndingSession = OldEnding;
                g_ExecStatus = OldExec;
            }
        }
        break;

    case UIC_WRITE_DATA:
        WriteData((UIC_WRITE_DATA_DATA*)(CmdData + 1));
        break;

    case UIC_SYMBOL_WIN:
        ProcessWatchCommand((UIC_SYMBOL_WIN_DATA*) (CmdData + 1));
        break;

    case UIC_DISPLAY_CODE:
        FillCodeBuffer(((UIC_DISPLAY_CODE_DATA*)(CmdData + 1))->Offset,
                       TRUE);
        break;

    case UIC_DISPLAY_CODE_EXPR:
        if (g_pDbgControl->Evaluate((PSTR)(CmdData + 1), DEBUG_VALUE_INT64,
                                    &Val, NULL) != S_OK)
        {
            Val.I64 = 0;
        }
        FillCodeBuffer(Val.I64, TRUE);
        break;

    case UIC_SET_SCOPE:
        SetLocalScope(&(((UIC_SET_SCOPE_DATA *)(CmdData + 1))->StackFrame));
        InvalidateStateBuffers(1 << LOCALS_WINDOW);
        break;

    case UIC_SET_FILTER:
        UIC_SET_FILTER_DATA* SetFilter;
        SetFilter = (UIC_SET_FILTER_DATA*)(CmdData + 1);
        if (SetFilter->Index != 0xffffffff)
        {
            DEBUG_SPECIFIC_FILTER_PARAMETERS Params;

            Params.ExecutionOption = SetFilter->Execution;
            Params.ContinueOption = SetFilter->Continue;
            g_pDbgControl->SetSpecificFilterParameters(SetFilter->Index, 1,
                                                       &Params);
        }
        else
        {
            DEBUG_EXCEPTION_FILTER_PARAMETERS Params;

            Params.ExecutionOption = SetFilter->Execution;
            Params.ContinueOption = SetFilter->Continue;
            Params.ExceptionCode = SetFilter->Code;
            g_pDbgControl->SetExceptionFilterParameters(1, &Params);
        }
        break;

    case UIC_SET_FILTER_ARGUMENT:
        UIC_SET_FILTER_ARGUMENT_DATA* SetFilterArg;
        SetFilterArg = (UIC_SET_FILTER_ARGUMENT_DATA*)(CmdData + 1);
        g_pDbgControl->SetSpecificFilterArgument(SetFilterArg->Index,
                                                 SetFilterArg->Argument);
        break;

    case UIC_SET_FILTER_COMMAND:
        UIC_SET_FILTER_COMMAND_DATA* SetFilterCmd;
        SetFilterCmd = (UIC_SET_FILTER_COMMAND_DATA*)(CmdData + 1);
        if (SetFilterCmd->Which == 0)
        {
            g_pDbgControl->SetEventFilterCommand(SetFilterCmd->Index,
                                                 SetFilterCmd->Command);
        }
        else
        {
            g_pDbgControl->SetExceptionFilterSecondCommand
                (SetFilterCmd->Index, SetFilterCmd->Command);
        }
        break;

    case UIC_SET_IP:
        // First, execute the corresponding command to set the
        // register value.
        g_pDbgControl->Execute(DEBUG_OUTCTL_IGNORE,
                               (PCSTR)(CmdData + 1),
                               DEBUG_EXECUTE_NOT_LOGGED |
                               DEBUG_EXECUTE_NO_REPEAT);
        // Now, since we know that IP changed we need
        // to force an update to the current scope.
        g_pDbgSymbols->ResetScope();
        break;
    }
}

void
ProcessEngineCommands(BOOL Internal)
{
#if DBG_CALLBACK
    DebugPrint("ProcessEngineCommands\n");
#endif

    // Check for commands to execute.  We do not
    // want to hold the lock while doing so because
    // the commands may include things that cause waits
    // and we don't want to lock out the GUI.

    LockUiBuffer(&g_UiCommandBuffer);

    while (g_UiCommandBuffer.GetDataLen() > 0)
    {
        //
        // Remove the first command from the buffer.
        //

        // Extra char is for forcing a newline on executes.
        char CmdBuf[MAX_COMMAND_LEN + 1];
        UiCommandData* CmdData;

        // Copy command to local buffer.
        CmdData = (UiCommandData*)g_UiCommandBuffer.GetDataBuffer();
        memcpy(CmdBuf, CmdData, CmdData->Len);
        CmdData = (UiCommandData*)CmdBuf;

        // Remove command from queue and release the queue for
        // the UI thread to use again.
        g_UiCommandBuffer.RemoveHead(CmdData->Len);
        UnlockUiBuffer(&g_UiCommandBuffer);

        ProcessCommand(CmdData);

        InterlockedIncrement((PLONG)&g_CommandSequence);

        // Lock the buffer again for the next command retrieval.
        LockUiBuffer(&g_UiCommandBuffer);

        if (g_EndingSession != ENDING_NONE)
        {
            // If we're ending a session just throw away the rest
            // of the commands.
            g_UiCommandBuffer.Empty();
        }
    }

    UnlockUiBuffer(&g_UiCommandBuffer);

    if (!Internal && g_EndingSession == ENDING_NONE)
    {
        ReadStateBuffers();
    }
}

//----------------------------------------------------------------------------
//
// Engine processing.
//
//----------------------------------------------------------------------------

HRESULT
InitializeEngineInterfaces(void)
{
    HRESULT Hr;

    if ((Hr = g_pUiClient->CreateClient(&g_pDbgClient)) != S_OK)
    {
        InternalError(Hr, "Engine CreateClient");
        return Hr;
    }

    if ((Hr = g_pDbgClient->
         QueryInterface(IID_IDebugControl,
                        (void **)&g_pDbgControl)) != S_OK ||
        (Hr = g_pDbgClient->
         QueryInterface(IID_IDebugSymbols,
                        (void **)&g_pDbgSymbols)) != S_OK ||
        (Hr = g_pDbgClient->
         QueryInterface(IID_IDebugRegisters,
                        (void **)&g_pDbgRegisters)) != S_OK ||
        (Hr = g_pDbgClient->
         QueryInterface(IID_IDebugDataSpaces,
                        (void **)&g_pDbgData)) != S_OK ||
        (Hr = g_pDbgClient->
         QueryInterface(IID_IDebugSystemObjects,
                        (void **)&g_pDbgSystem)) != S_OK)
    {
        if (Hr == RPC_E_VERSION_MISMATCH)
        {
            InformationBox(ERR_Remoting_Version_Mismatch);
        }
        else
        {
            InternalError(Hr, "Engine QueryInterface");
        }
        return Hr;
    }

    //
    // Try and get higher version interfaces.
    //

    if (g_pDbgClient->
        QueryInterface(IID_IDebugClient2,
                       (void **)&g_pDbgClient2) != S_OK)
    {
        g_pDbgClient2 = NULL;
    }

    if (g_pDbgClient->
        QueryInterface(IID_IDebugSystemObjects3,
                       (void **)&g_pDbgSystem3) != S_OK)
    {
        g_pDbgSystem3 = NULL;
    }

    if (g_RemoteClient)
    {
        // Create a local client to do local source file lookups.
        if ((Hr = g_pUiLocClient->CreateClient(&g_pLocClient)) != S_OK ||
            (Hr = g_pLocClient->
             QueryInterface(IID_IDebugControl,
                            (void **)&g_pLocControl)) != S_OK ||
            (Hr = g_pLocClient->
             QueryInterface(IID_IDebugSymbols,
                            (void **)&g_pLocSymbols)) != S_OK)
        {
            InternalError(Hr, "Engine local client");
            return Hr;
        }
    }
    else
    {
        g_pLocClient = g_pDbgClient;
        g_pLocClient->AddRef();
        g_pLocControl = g_pDbgControl;
        g_pLocControl->AddRef();
        g_pLocSymbols = g_pDbgSymbols;
        g_pLocSymbols->AddRef();
    }

    // Create separate client for private output capture
    // during state buffer filling.  The output capture client
    // sets its output mask to nothing so that it doesn't
    // receive any normal input.  During private output capture
    // the output control is set to THIS_CLIENT | OVERRIDE_MASK to force
    // output to just the output capture client.
    if ((Hr = g_pDbgClient->CreateClient(&g_pOutCapClient)) != S_OK ||
        (Hr = g_pOutCapClient->
         QueryInterface(IID_IDebugControl,
                        (void **)&g_pOutCapControl)) != S_OK)
    {
        InternalError(Hr, "Engine output capture client");
        return Hr;
    }

    // Set callbacks.
    if ((Hr = g_pDbgClient->SetOutputCallbacks(&g_OutputCb)) != S_OK ||
        (Hr = g_pDbgClient->SetInputCallbacks(&g_InputCb)) != S_OK ||
        (Hr = g_pDbgClient->SetEventCallbacks(&g_EventCb)) != S_OK ||
        (g_RemoteClient &&
         (Hr = g_pLocClient->SetOutputCallbacks(&g_OutputCb))) != S_OK ||
        (Hr = g_pOutCapClient->SetOutputMask(0)) != S_OK ||
        (Hr = g_pOutCapClient->SetOutputCallbacks(&g_OutStateBuf)) != S_OK ||
        (Hr = g_pOutCapClient->
         QueryInterface(IID_IDebugSymbols,
                        (void **)&g_pOutCapSymbols)) != S_OK)
    {
        InternalError(Hr, "Engine callbacks");
        return Hr;
    }

    // Create a watch window client
    if ((Hr = g_pOutCapSymbols->
         CreateSymbolGroup(&g_pDbgWatchSymbolGroup)) != S_OK)
    {
        InternalError(Hr, "Engine CreateSymbolGroup");
        return Hr;
    }

    // Create a local window client
    if ((Hr = g_pOutCapSymbols->
         GetScopeSymbolGroup(DEBUG_SCOPE_GROUP_LOCALS,
                             NULL, &g_pDbgLocalSymbolGroup)) == E_NOTIMPL)
    {
        // Older version
        Hr = g_pOutCapSymbols->
            GetScopeSymbolGroup(DEBUG_SCOPE_GROUP_ALL,
                                NULL, &g_pDbgLocalSymbolGroup);
    }
    if (Hr != S_OK ||
        (Hr = g_FilterTextBuffer->Update()) != S_OK)
    {
        InternalError(Hr, "Engine GetScopeSymbolGroup");
        return Hr;
    }

    if ((Hr = g_pDbgControl->GetRadix(&g_NumberRadix)) != S_OK)
    {
        InternalError(Hr, "Engine GetRadix");
        return Hr;
    }

    if (g_RemoteClient)
    {
        return S_OK;
    }

    //
    // Set up initial state for things that are important
    // when starting the debug session.
    //

    if (g_Verbose)
    {
        DWORD OutMask;

        g_pDbgClient->GetOutputMask(&OutMask);
        OutMask |= DEBUG_OUTPUT_VERBOSE;
        g_pDbgClient->SetOutputMask(OutMask);
        g_pDbgControl->SetLogMask(OutMask);
    }

    // Always load line numbers for source support.
    g_pDbgSymbols->AddSymbolOptions(SYMOPT_LOAD_LINES);

    // Set the source stepping mode
    g_IgnoreCodeLevelChange = TRUE;
    if (GetSrcMode_StatusBar())
    {
        g_pDbgControl->SetCodeLevel(DEBUG_LEVEL_SOURCE);
    }
    else
    {
        g_pDbgControl->SetCodeLevel(DEBUG_LEVEL_ASSEMBLY);
    }
    g_IgnoreCodeLevelChange = FALSE;

    // If this is a user-mode debug session default to
    // initial and final breaks.  Don't override settings
    // that were given on the command line, though.

    g_IgnoreFilterChange = TRUE;
    if (g_DebugCommandLine != NULL ||
        g_PidToDebug != 0 ||
        g_ProcNameToDebug != NULL)
    {
        g_pDbgControl->AddEngineOptions((DEBUG_ENGOPT_INITIAL_BREAK |
                                         DEBUG_ENGOPT_FINAL_BREAK) &
                                        ~g_EngOptModified);
    }
    else
    {
        g_pDbgControl->RemoveEngineOptions((DEBUG_ENGOPT_INITIAL_BREAK |
                                            DEBUG_ENGOPT_FINAL_BREAK) &
                                           ~g_EngOptModified);
    }
    g_IgnoreFilterChange = FALSE;

    return S_OK;
}

void
DiscardEngineState(void)
{
    LockUiBuffer(&g_UiOutputBuffer);
    g_UiOutputBuffer.Empty();
    UnlockUiBuffer(&g_UiOutputBuffer);

    g_TargetClass = DEBUG_CLASS_UNINITIALIZED;
    g_ExecStatus = DEBUG_STATUS_NO_DEBUGGEE;
}

void
ReleaseEngineInterfaces(void)
{
    DiscardEngineState();

    RELEASE(g_pLocControl);
    RELEASE(g_pLocSymbols);
    RELEASE(g_pLocClient);

    RELEASE(g_pDbgWatchSymbolGroup);
    RELEASE(g_pDbgLocalSymbolGroup);

    RELEASE(g_pOutCapControl);
    RELEASE(g_pOutCapSymbols);
    RELEASE(g_pOutCapClient);

    RELEASE(g_pDbgControl);
    RELEASE(g_pDbgSymbols);
    RELEASE(g_pDbgRegisters);
    RELEASE(g_pDbgData);
    RELEASE(g_pDbgSystem3);
    RELEASE(g_pDbgSystem);
    RELEASE(g_pDbgClient2);
    RELEASE(g_pDbgClient);
}

BOOL
ExtractWspName(PSTR CommandLine, PSTR Buf, ULONG BufLen)
{
    PSTR Scan = CommandLine;
    PSTR Start;

    while (isspace(*Scan))
    {
        Scan++;
    }

    if (!*Scan)
    {
        return FALSE;
    }
    else if (*Scan == '"')
    {
        Start = ++Scan;

        // Look for closing quote.
        while (*Scan && *Scan != '"')
        {
            Scan++;
        }
    }
    else
    {
        // Look for whitespace.
        Start = Scan++;

        while (*Scan && !isspace(*Scan))
        {
            Scan++;
        }
    }

    ULONG Len = (ULONG) (ULONG64) (Scan - Start);
    if (Len == 0)
    {
        return FALSE;
    }

    if (Len >= BufLen)
    {
        Len = BufLen - 1;
    }
    memcpy(Buf, Start, Len);
    Buf[Len] = 0;

    return TRUE;
}

HRESULT
StartSession(void)
{
    TCHAR WspName[MAX_PATH];
    ULONG WspKey;
    PTSTR WspValue;
    HRESULT Hr;
    ULONG i;

    // Reset things to the default priority first.
    // If necessary, priority will be increased in certain code
    // paths later.
    SetPriorityClass(GetCurrentProcess(), g_DefPriority);

    if (!g_RemoteClient)
    {
        if (g_NumDumpFiles)
        {
            WspKey = WSP_NAME_DUMP;
            WspValue = g_DumpFiles[0];
            EngSwitchWorkspace(WspKey, WspValue);

            if (g_NumDumpInfoFiles)
            {
                if (g_pDbgClient2 == NULL)
                {
                    ErrorBox(NULL, 0, ERR_Cant_Add_Dump_Info_File);
                    Hr = E_NOINTERFACE;
                    goto ResetWorkspace;
                }

                for (i = 0; i < g_NumDumpInfoFiles; i++)
                {
                    if ((Hr = g_pDbgClient2->AddDumpInformationFile
                         (g_DumpInfoFiles[i], g_DumpInfoTypes[i])) != S_OK)
                    {
                        ErrorBox(NULL, 0, ERR_Add_Dump_Info_File_Failed,
                                 g_DumpInfoFiles[i], FormatStatusCode(Hr),
                                 FormatStatus(Hr));
                        goto ResetWorkspace;
                    }
                }
            }

            for (i = 0; i < g_NumDumpFiles; i++)
            {
                Hr = g_pDbgClient->OpenDumpFile(g_DumpFiles[i]);
                if (Hr != S_OK)
                {
                    if ((HRESULT_FACILITY(Hr)) == FACILITY_WIN32)
                    {
                        // Win32 errors on open generally mean some
                        // kind of file error.
                        ErrorBox(NULL, 0, ERR_Invalid_Dump_File_Name,
                                 g_DumpFiles[i], FormatStatusCode(Hr),
                                 FormatStatus(Hr));
                    }
                    else
                    {
                        ErrorBox(NULL, 0, ERR_Unable_To_Open_Dump,
                                 g_DumpFiles[i], FormatStatusCode(Hr),
                                 FormatStatus(Hr));
                    }

                    goto ResetWorkspace;
                }
            }
        }
        else if (g_DebugCommandLine != NULL ||
                 g_PidToDebug != 0 ||
                 g_ProcNameToDebug != NULL)
        {
            ULONG64 Server = 0;
            ULONG Pid;

            WspKey = WSP_NAME_USER;
            WspValue = g_ProcessServer != NULL ?
                g_ProcessServer : g_WorkspaceDefaultName;
            if (g_DebugCommandLine != NULL)
            {
                if (ExtractWspName(g_DebugCommandLine,
                                   WspName, sizeof(WspName)))
                {
                    WspValue = WspName;
                }
            }
            EngSwitchWorkspace(WspKey, WspValue);

            if (g_ProcessServer != NULL)
            {
                Hr = g_pDbgClient->ConnectProcessServer(g_ProcessServer,
                                                        &Server);
                if (Hr != S_OK)
                {
                    ErrorBox(NULL, 0, ERR_Connect_Process_Server,
                             g_ProcessServer, FormatStatusCode(Hr),
                             FormatStatus(Hr));
                    goto ResetWorkspace;
                }

                // Default to not automatically bringing up a disassembly
                // window as it is very expensive to remote all
                // the virtual reads done for it.
                g_WinOptions &= ~WOPT_AUTO_DISASM;
            }

            if (g_ProcNameToDebug != NULL)
            {
                Hr = g_pDbgClient->GetRunningProcessSystemIdByExecutableName
                    (Server, g_ProcNameToDebug, DEBUG_GET_PROC_ONLY_MATCH,
                     &Pid);
                if (Hr != S_OK)
                {
                    if (Hr == S_FALSE)
                    {
                        ErrorBox(NULL, 0, ERR_Ambiguous_Named_Process,
                                 g_ProcNameToDebug);
                    }
                    else
                    {
                        ErrorBox(NULL, 0, ERR_Get_Named_Process,
                                 g_ProcNameToDebug, FormatStatusCode(Hr),
                                 FormatStatus(Hr));
                    }
                    goto ResetWorkspace;
                }
            }
            else
            {
                Pid = g_PidToDebug;
            }

            if (g_DebugCommandLine != NULL &&
                g_ProcessStartDir != NULL &&
                g_ProcessStartDir[0] != 0)
            {
                sprintf(WspName, ".createdir \"%s\"", g_ProcessStartDir);
                g_pDbgControl->Execute(DEBUG_OUTCTL_IGNORE,
                                       WspName,
                                       DEBUG_EXECUTE_NOT_LOGGED);
            }

            Hr = g_pDbgClient->CreateProcessAndAttach(Server,
                                                      g_DebugCommandLine,
                                                      g_DebugCreateFlags,
                                                      Pid,
                                                      g_AttachProcessFlags);

            if (g_DebugCommandLine != NULL &&
                g_ProcessStartDir != NULL &&
                g_ProcessStartDir[0] != 0)
            {
                g_pDbgControl->Execute(DEBUG_OUTCTL_IGNORE,
                                       ".createdir \"\"",
                                       DEBUG_EXECUTE_NOT_LOGGED);
            }

            if (Hr != S_OK)
            {
                if (g_DebugCommandLine != NULL)
                {
                    ErrorBox(NULL, 0, ERR_Invalid_Process_Create,
                             g_DebugCommandLine, FormatStatusCode(Hr),
                             FormatStatus(Hr));
                }
                else
                {
                    ErrorBox(NULL, 0, ERR_Invalid_Process_Attach,
                             Pid, FormatStatusCode(Hr), FormatStatus(Hr));
                }
                goto ResetWorkspace;
            }

            if (g_DetachOnExit &&
                (Hr = g_pDbgClient->
                 AddProcessOptions(DEBUG_PROCESS_DETACH_ON_EXIT)) != S_OK)
            {
                ErrorBox(NULL, 0, ERR_No_Detach_On_Exit);
            }

            if (Server != 0)
            {
                g_pDbgClient->DisconnectProcessServer(Server);
            }

            // Bump up our priority so that the debugger stays responsive
            // even when the debuggee is running.
            SetPriorityClass(GetCurrentProcess(), HIGH_PRIORITY_CLASS);
        }
        else
        {
            // Default to not automatically bringing up a disassembly
            // window as it is very expensive in kernel debugging.
            g_WinOptions &= ~WOPT_AUTO_DISASM;

            WspKey = WSP_NAME_KERNEL;
            WspValue = g_WorkspaceDefaultName;
            EngSwitchWorkspace(WspKey, WspValue);

            Hr = g_pDbgClient->AttachKernel(g_AttachKernelFlags,
                                            g_KernelConnectOptions);
            if (Hr != S_OK)
            {
                if (g_AttachKernelFlags == DEBUG_ATTACH_LOCAL_KERNEL)
                {
                    if (Hr == E_NOTIMPL)
                    {
                        ErrorBox(NULL, 0, ERR_No_Local_Kernel_Debugging);
                    }
                    else
                    {
                        ErrorBox(NULL, 0, ERR_Failed_Local_Kernel_Debugging,
                                 FormatStatusCode(Hr), FormatStatus(Hr));
                    }
                }
                else
                {
                    ErrorBox(NULL, 0, ERR_Invalid_Kernel_Attach,
                             g_KernelConnectOptions, FormatStatusCode(Hr),
                             FormatStatus(Hr));
                }

                goto ResetWorkspace;
            }
        }
    }
    else
    {
        WspKey = WSP_NAME_REMOTE;
        WspValue = g_WorkspaceDefaultName;
        EngSwitchWorkspace(WspKey, WspValue);

        // Use a heuristic of 45 characters per line.
        g_pDbgClient->ConnectSession(DEBUG_CONNECT_SESSION_DEFAULT,
                                     g_HistoryLines * 45);
    }

    PostMessage(g_hwndFrame, WU_ENGINE_STARTED, 0, S_OK);
    return S_OK;

 ResetWorkspace:
    // We just switched to this workspace but
    // we're failing and we want to abandon it.
    if (g_Workspace != NULL && !g_ExplicitWorkspace)
    {
        // Make sure this doesn't cause a popup.
        g_Workspace->ClearDirty();

        EngSwitchWorkspace(WSP_NAME_BASE,
                           g_WorkspaceDefaultName);
    }
    return Hr;
}

void
SetLocalScope(PDEBUG_STACK_FRAME pStackFrame)
{
    DEBUG_STACK_FRAME LocalFrame;

    if (!pStackFrame)
    {
        // Get and use the default scope
        if (g_pDbgSymbols->ResetScope() != S_OK ||
            g_pDbgSymbols->GetScope(NULL, &LocalFrame, NULL, 0) != S_OK)
        {
            return;
        }

        pStackFrame = &LocalFrame;
    }
    else if (FAILED(g_pDbgSymbols->SetScope(0, pStackFrame, NULL, 0)))
    {
        return;
    }

}

void
SessionActive(void)
{
    HRESULT Hr;

    // This can get called twice if a remote client connects
    // just as a session is becoming active.
    if (g_SessionActive)
    {
        return;
    }
    g_SessionActive = TRUE;

    if ((Hr = g_pDbgControl->
         GetActualProcessorType(&g_ActualProcType)) != S_OK ||
        FAILED(Hr = g_pDbgControl->
               GetProcessorTypeNames(g_ActualProcType, NULL, 0, NULL,
                                     g_ActualProcAbbrevName,
                                     sizeof(g_ActualProcAbbrevName),
                                     NULL)))
    {
        ErrorExit(g_pDbgClient,
                  "Debug target initialization failed, 0x%X\n", Hr);
    }

    // Put in a request for the actual processor register
    // names right now.
    GetRegisterNames(g_ActualProcType);

    if (FAILED(Hr = g_pDbgControl->IsPointer64Bit()))
    {
        ErrorExit(g_pDbgClient,
                  "Unable to get debuggee pointer size, 0x%X\n", Hr);
    }
    g_Ptr64 = Hr == S_OK;

    if (!g_RemoteClient &&
        (g_ExplicitWorkspace || g_TargetClass == DEBUG_CLASS_KERNEL) &&
        g_NumDumpFiles == 0)
    {
        if (g_ExplicitWorkspace)
        {
            // Reapply the workspace after a reboot/restart to get
            // breakpoints and other engine state back.
            // Don't restart the session when doing so.
            if (g_Workspace != NULL)
            {
                Workspace* Wsp = g_Workspace;
                g_Workspace = NULL;
                Wsp->Apply(WSP_APPLY_AGAIN);
                g_Workspace = Wsp;
            }
        }
        else
        {
            // The same machine could theoretically debug many different
            // processor types over kernel connections or via different
            // processor dumps.  Workspaces contain processor-related
            // information, such as register maps, so allow for different
            // workspaces based on the processor type.  This is only
            // done when a default workspace would otherwise be used,
            // though to reduce workspace explosion.
            EngSwitchWorkspace(WSP_NAME_KERNEL, g_ActualProcAbbrevName);
        }
    }

    InvalidateStateBuffers(BUFFERS_ALL);
    UpdateBufferWindows((1 << CPU_WINDOW) | (1 << DOC_WINDOW),
                        UPDATE_START_SESSION);
    UpdateEngine();
}

void
SessionInactive(void)
{
    if (!g_RemoteClient && g_EndingSession != ENDING_STOP)
    {
        EngSwitchWorkspace(WSP_NAME_BASE,
                           g_WorkspaceDefaultName);
    }

    g_SessionActive = FALSE;
    g_ActualProcType = IMAGE_FILE_MACHINE_UNKNOWN;

    InvalidateStateBuffers(BUFFERS_ALL);
    UpdateBufferWindows((1 << CPU_WINDOW) | (1 << DOC_WINDOW) |
                        (1 << DISASM_WINDOW), UPDATE_END_SESSION);
    UpdateEngine();
    SetPriorityClass(GetCurrentProcess(), g_DefPriority);
}

void
StopOrEndDebugging(void)
{
    //
    // If the session was started from the command line
    // assume that debugging is done and exit.
    // If the session was started from the UI treat it
    // like a stop debugging request.
    //

    if (g_CommandLineStart)
    {
        EngSwitchWorkspace(WSP_NAME_BASE,
                           g_WorkspaceDefaultName);
        g_Exit = TRUE;
        PostMessage(g_hwndFrame, WU_UPDATE, UPDATE_EXIT, 0);
    }
    else
    {
        PostMessage(g_hwndFrame, WM_COMMAND,
                    0xffff0000 | IDM_DEBUG_STOPDEBUGGING, 0);
        g_EndingSession = ENDING_STOP;
    }
}

DWORD
WINAPI
EngineLoop(LPVOID Param)
{
    HRESULT Hr;

    if ((Hr = InitializeEngineInterfaces()) != S_OK ||
        (Hr = StartSession()) != S_OK)
    {
        ReleaseEngineInterfaces();
        PostMessage(g_hwndFrame, WU_ENGINE_STARTED, 0, Hr);
        return 0;
    }

    g_EngineThreadId = GetCurrentThreadId();

    Hr = g_pDbgControl->GetDebuggeeType(&g_TargetClass, &g_TargetClassQual);
    if (Hr != S_OK)
    {
        ErrorExit(g_pDbgClient, "Unable to get debuggee type, 0x%X\n", Hr);
    }

    // Set initial execution state.
    if ((Hr = g_pDbgControl->GetExecutionStatus(&g_ExecStatus)) != S_OK)
    {
        ErrorExit(g_pDbgClient, "Unable to get execution status, 0x%X\n", Hr);
    }

    if (g_ExecStatus != DEBUG_STATUS_NO_DEBUGGEE)
    {
        // Session is already active.
        SessionActive();
    }

    UpdateBufferWindows(UPDATE_EXEC_WINDOWS, UPDATE_EXEC);

    if (g_RemoteClient)
    {
        // Request an initial read of everything.
        InvalidateStateBuffers(BUFFERS_ALL);
        ReadStateBuffers();

        // The server may be in an input request, which
        // we would have been notified of back during
        // ConnectSession.  If we're still in an input
        // request switch to input mode.
        if (g_InputStarted)
        {
            UpdateBufferWindows(1 << CMD_WINDOW, UPDATE_INPUT_REQUIRED);
        }
    }

    for (;;)
    {
        if (!g_RemoteClient)
        {
            g_WaitingForEvent = TRUE;

            Hr = g_pDbgControl->WaitForEvent(DEBUG_WAIT_DEFAULT, INFINITE);

            g_WaitingForEvent = FALSE;

            if (g_HoldWaitOutput)
            {
                UpdateUi();
            }

            if (FAILED(Hr))
            {
                // The debug session may have ended.  If so,
                // stop or end things based on how the session
                // was started.
                if (g_pDbgControl->GetExecutionStatus(&g_ExecStatus) == S_OK &&
                    g_ExecStatus == DEBUG_STATUS_NO_DEBUGGEE)
                {
                    g_pDbgClient->EndSession(DEBUG_END_PASSIVE);
                    StopOrEndDebugging();
                    break;
                }

                // Inform the user of the failure and force
                // command processing.
                g_OutputCb.Output(DEBUG_OUTPUT_ERROR, "WaitForEvent failed\n");
                g_ExecStatus = DEBUG_STATUS_BREAK;
            }

            if (g_TargetClass != DEBUG_CLASS_KERNEL ||
                (g_TargetClassQual != DEBUG_DUMP_SMALL &&
                 g_TargetClassQual != DEBUG_DUMP_DEFAULT &&
                 g_TargetClassQual != DEBUG_DUMP_FULL))
            {
                g_pDbgControl->OutputCurrentState(DEBUG_OUTCTL_ALL_CLIENTS,
                                                  DEBUG_CURRENT_DEFAULT);
            }


            ReadStateBuffers();
        }

        while (!g_Exit &&
               g_EndingSession == ENDING_NONE &&
               (g_RemoteClient || g_ExecStatus == DEBUG_STATUS_BREAK))
        {
            if (!g_InputStarted)
            {
                // Tell the command window to display a prompt to
                // indicate the engine is ready to process commands.
                if (g_pDbgControl->GetPromptText(g_PromptText,
                                                 sizeof(g_PromptText),
                                                 NULL) != S_OK)
                {
                    strcpy(g_PromptText, "?Err");
                }
                UpdateBufferWindows(1 << CMD_WINDOW, UPDATE_PROMPT_TEXT);

                PostMessage(g_hwndFrame, WU_ENGINE_IDLE, 0, 0);
            }

            // Wait until engine processing is needed.
            Hr = g_pDbgClient->DispatchCallbacks(INFINITE);
            if (FAILED(Hr))
            {
                if (g_RemoteClient && HRESULT_FACILITY(Hr) == FACILITY_RPC)
                {
                    // A remote client was unable to communicate
                    // with the server so shut down the session.
                    InformationBox(ERR_Client_Disconnect);
                    StopOrEndDebugging();
                    break;
                }
                else
                {
                    // A failure here is a critical problem as
                    // something is seriously wrong with the engine
                    // if it can't do a normal DispatchCallbacks.
                    ErrorExit(g_pDbgClient,
                              "Engine thread wait failed, 0x%X\n", Hr);
                }
            }

            if (!g_InputStarted)
            {
                // Take away the prompt while the engine is working.
                g_PromptText[0] = 0;
                UpdateBufferWindows(1 << CMD_WINDOW, UPDATE_PROMPT_TEXT);
            }

            ProcessEngineCommands(FALSE);
        }

        if (g_Exit)
        {
            g_EndingSession = ENDING_EXIT;
            break;
        }

        if (g_EndingSession != ENDING_NONE)
        {
            // Force windows to display empty state.
            InvalidateStateBuffers(BUFFERS_ALL);
            UpdateBufferWindows(BUFFERS_ALL, UPDATE_BUFFER);

            if (g_EndingSession == ENDING_RESTART)
            {
                if (StartSession() != S_OK)
                {
                    // If we couldn't restart go into
                    // the stop-debugging state.
                    g_EndingSession = ENDING_STOP;
                    break;
                }

                g_EndingSession = ENDING_NONE;
            }
            else
            {
                break;
            }
        }
    }

    if (g_EndingSession == ENDING_NONE)
    {
        // Wake up the message pump for exit.
        PostMessage(g_hwndFrame, WM_CLOSE, 0, 0);
    }

    ULONG Code;

    if (!g_RemoteClient && g_DebugCommandLine != NULL)
    {
        // Return exit code of last process to exit.
        Code = g_LastProcessExitCode;
    }
    else
    {
        Code = S_OK;
    }

    if (g_pDbgClient)
    {
        if (g_RemoteClient)
        {
            g_pDbgClient->EndSession(DEBUG_END_DISCONNECT);
        }
        else if (g_EndingSession != ENDING_STOP)
        {
            g_pDbgClient->EndSession(DEBUG_END_REENTRANT);
        }
    }

    ReleaseEngineInterfaces();

    g_EngineThreadId = 0;

    if (g_EndingSession != ENDING_STOP)
    {
        //
        // Wait for UI to finish up.
        //

        while (!g_Exit)
        {
            Sleep(50);
        }

        ExitDebugger(g_pDbgClient, Code);
    }
    else
    {
        g_EndingSession = ENDING_NONE;
    }

    return 0;
}

void
UpdateEngine(void)
{
    if (g_pUiClient != NULL && g_pDbgClient != NULL)
    {
        g_pUiClient->ExitDispatch(g_pDbgClient);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\windbg\dualwin.cpp ===
/*++

Copyright (c) 1992-2002  Microsoft Corporation

Module Name:

    dualwin.cpp

Abstract:

    Header for new window architecture functions.

--*/


#include "precomp.hxx"
#pragma hdrstop

#define NAME_BUFFER 1024

BOOL g_UseTextMode = FALSE;

//
// DUALLISTWIN_DATA methods
//
DUALLISTWIN_DATA::DUALLISTWIN_DATA(ULONG ChangeBy)
    : SINGLE_CHILDWIN_DATA(ChangeBy)
{
    m_wFlags = DL_EDIT_SECONDPANE;
    m_hwndEditControl = NULL;
    m_nItem_LastSelected = -1;
    m_nSubItem_LastSelected = 0;
    m_nItem_CurrentlyEditing = -1;
    m_nSubItem_CurrentlyEditing = -1;
}

void
DUALLISTWIN_DATA::Validate()
{
    SINGLE_CHILDWIN_DATA::Validate();
}

void
DUALLISTWIN_DATA::SetFont(ULONG FontIndex)
{
    SINGLE_CHILDWIN_DATA::SetFont(FontIndex);

    SendMessage(m_hwndEditControl, WM_SETFONT,
                (WPARAM)m_Font->Font, TRUE);
}

BOOL
DUALLISTWIN_DATA::OnCreate(void)
{
    m_hwndChild = CreateWindowEx(
                      WS_EX_CLIENTEDGE,                           // Extended style
                      WC_LISTVIEW,                                // class name
                      NULL,                                       // title
                      WS_CHILD | WS_VISIBLE
                      | WS_MAXIMIZE
                      | WS_HSCROLL | WS_VSCROLL
                      | LVS_SHOWSELALWAYS
                      | LVS_REPORT | LVS_SINGLESEL
                      | ((m_enumType != CPU_WINDOW)
                         ? LVS_OWNERDRAWFIXED : 0),            // style
                      0,                                          // x
                      0,                                          // y
                      CW_USEDEFAULT,                              // width
                      CW_USEDEFAULT,                              // height
                      m_Win,                                      // parent
                      0,                                          // control id
                      g_hInst,                                    // hInstance
                      NULL                                        // user defined data
                      );

    if (m_hwndChild == NULL)
    {
        return FALSE;
    }

    m_hwndEditControl = CreateWindowEx(
                            0,                                          // Extended style
                            RICHEDIT_CLASS,                             // class name
                            NULL,                                       // title
                            WS_CHILD,
                            0,                                          // x
                            0,                                          // y
                            CW_USEDEFAULT,                              // width
                            CW_USEDEFAULT,                              // height
                            m_Win,                                      // parent
                            0,                                          // control id
                            g_hInst,                                    // hInstance
                            NULL                                        // user defined data
                            );

    if (m_hwndEditControl == NULL)
    {
        DestroyWindow(m_hwndChild);
        return FALSE;
    }

    SetFont(FONT_FIXED);

    SendMessage(m_hwndEditControl,
        EM_SETEVENTMASK,
        0,
        (LPARAM) ENM_KEYEVENTS | ENM_MOUSEEVENTS
        );

    ListView_SetBkColor(m_hwndChild, g_Colors[COL_PLAIN].Color);
    ListView_SetTextBkColor(m_hwndChild, g_Colors[COL_PLAIN].Color);
    ListView_SetTextColor(m_hwndChild, g_Colors[COL_PLAIN_TEXT].Color);

    return TRUE;
}

LRESULT
DUALLISTWIN_DATA::OnCommand(
    WPARAM wParam,
    LPARAM lParam
    )
{
    WORD wCode = HIWORD(wParam);
    WORD wId = LOWORD(wParam);
    HWND hwnd = (HWND) lParam;

    if (hwnd != m_hwndEditControl)
    {
        return 1; // Not handled
    }

    switch (wCode)
    {
    default:
        return 1; // not handled

    case EN_KILLFOCUS:
        //
        // Duplicate code in OnNotify : EN_MSGFILTER
        //
        if (-1 != m_nItem_CurrentlyEditing)
        {
            if (!SetItemFromEdit(m_nItem_CurrentlyEditing,
                                 m_nSubItem_CurrentlyEditing))
            {
                break;
            }

            ShowWindow(hwnd, SW_HIDE);
            SetFocus(m_hwndChild);

            InvalidateItem(m_nItem_CurrentlyEditing);

            m_nItem_CurrentlyEditing = -1;
            m_nSubItem_CurrentlyEditing = -1;
        }
        break;
    }

    return 0;
}

LRESULT
DUALLISTWIN_DATA::OnNotify(
    WPARAM wParam,
    LPARAM lParam
    )
{
    // Branch depending on the specific notification message.
    switch (((LPNMHDR) lParam)->code)
    {
    case LVN_ITEMCHANGED:
        InvalidateItem( ((LPNMLISTVIEW) lParam)->iItem);
        break;

    case NM_CLICK:
    case NM_DBLCLK:
        // Figure out whether an item or a sub-item was clicked
        OnClick((LPNMLISTVIEW) lParam);
        break;
    case NM_CUSTOMDRAW:
        return OnCustomDraw((LPNMLVCUSTOMDRAW)lParam);

    case EN_MSGFILTER:
        //
        // Duplicate code in OnCommand : EN_KILLFOCUS
        //
        if (WM_KEYDOWN == ((MSGFILTER *)lParam)->msg)
        {
            MSGFILTER * pMsgFilter = (MSGFILTER *) lParam;

            switch (pMsgFilter->wParam)
            {
            case VK_RETURN:
                // Ignore this message so the richedit
                // doesn't beep.
                return 1;
            }
        }
        else if (WM_CHAR == ((MSGFILTER *)lParam)->msg)
        {
            MSGFILTER * pMsgFilter = (MSGFILTER *) lParam;

            switch (pMsgFilter->wParam)
            {
            case VK_RETURN:
                if (!SetItemFromEdit(m_nItem_CurrentlyEditing,
                                     m_nSubItem_CurrentlyEditing))
                {
                    break;
                }
                // fall through...

            case VK_ESCAPE:
                InvalidateItem(m_nItem_CurrentlyEditing);

                //
                // Invalidate these before changing focus, so that Itemchanged
                // doesn't get called again on same item
                //
                m_nItem_CurrentlyEditing = -1;
                m_nSubItem_CurrentlyEditing = -1;

                //
                // Hide the edit box and set focus to the list view
                //
                ShowWindow(m_hwndEditControl, SW_HIDE);
                SetFocus(m_hwndChild);

                break;
            }
        }
        else if (WM_RBUTTONDOWN == ((MSGFILTER *)lParam)->msg ||
                 WM_RBUTTONDBLCLK == ((MSGFILTER *)lParam)->msg)
        {
            // process cpoy/passte selection
            if (CanCopy())
            {
                Copy();

                CHARRANGE Sel;
                SendMessage(m_hwndEditControl, EM_EXGETSEL, 0, (LPARAM)&Sel);
                Sel.cpMax = Sel.cpMin;
                SendMessage(m_hwndEditControl, EM_EXSETSEL, 0, (LPARAM)&Sel);
            }
            else if (SendMessage(m_hwndEditControl, EM_CANPASTE, CF_TEXT, 0))
            {
                SetFocus(m_hwndEditControl);
                Paste();
            }

            // Ignore right-button events.
            return 1;

        }
        return 0; // process this message
    case LVN_COLUMNCLICK:
//      LVN_COLUMNCLICK pnmv = (LPNMLISTVIEW) lParam;

        break;

    }

    return DefMDIChildProc(m_Win, WM_NOTIFY, wParam, lParam);
}


BOOL
DUALLISTWIN_DATA::ClearList(ULONG ClearFrom)
{
    if (!ClearFrom)
    {
        return ListView_DeleteAllItems(m_hwndChild);
    }
    else
    {
        ULONG nItems = ListView_GetItemCount(m_hwndChild);
        BOOL  res = TRUE;

        while (res && (ClearFrom < nItems))
        {
            res = ListView_DeleteItem(m_hwndChild, --nItems);
        }

        return res;
    }
}

void
DUALLISTWIN_DATA::InvalidateItem(
    int nItem
    )
{
    RECT rc = {0};

    if (-1 == nItem)
    {
        // Invalidate the entire window
        GetClientRect(m_hwndChild, &rc);
    }
    else
    {
        // Invalidate the item row
        if (!ListView_GetItemRect(m_hwndChild,nItem,&rc,LVIR_BOUNDS))
        {
            // Invalidate the entire window
            GetClientRect(m_hwndChild, &rc);
        }
    }
    InvalidateRect(m_hwndChild, &rc, TRUE);
}

void
DUALLISTWIN_DATA::ItemChanged(
    int Item,
    PCSTR Text
    )
{
    // Do-nothing placeholder.
}

LRESULT
DUALLISTWIN_DATA::OnCustomDraw(LPNMLVCUSTOMDRAW Custom)
{
    static int s_SelectedItem = -1;
    static ULONG s_SubItem;

    if (Custom->nmcd.hdr.hwndFrom != m_hwndChild)
    {
        return CDRF_DODEFAULT;
    }

    switch (Custom->nmcd.dwDrawStage)
    {
    case CDDS_PREPAINT:
        s_SelectedItem = ListView_GetNextItem(m_hwndChild, -1, LVNI_SELECTED);
        if (m_wFlags & DL_CUSTOM_ITEMS)
        {
            return CDRF_NOTIFYITEMDRAW | CDRF_NOTIFYPOSTPAINT;
        }
        else
        {
            return CDRF_NOTIFYPOSTPAINT;
        }

    case CDDS_ITEMPREPAINT:
        s_SubItem = 0;
        return CDRF_NOTIFYSUBITEMDRAW;
    case CDDS_ITEMPREPAINT | CDDS_SUBITEM:
        return OnCustomItem(s_SubItem++, Custom);

    case CDDS_POSTPAINT:
        if (-1 != s_SelectedItem)
        {
            RECT rc;

            // If we ask for subitem 0, then we get the rectangle for the
            // entire item, so we ask for item 1, and do the math

            Dbg( ListView_GetSubItemRect(m_hwndChild,
                                         s_SelectedItem,
                                         1,
                                         LVIR_BOUNDS,
                                         &rc));

            if (0 == m_nSubItem_LastSelected)
            {
                rc.right = rc.left - 1;
                rc.left = 0;
            }

            InvertRect(Custom->nmcd.hdc, &rc);
        }

        return CDRF_NOTIFYPOSTPAINT;

    default:
        return 0;
    }
}

LRESULT
DUALLISTWIN_DATA::OnCustomItem(ULONG SubItem, LPNMLVCUSTOMDRAW Custom)
{
    return CDRF_DODEFAULT;
}

void
DUALLISTWIN_DATA::OnClick(
    LPNMLISTVIEW Notify
    )
{
    LVHITTESTINFO lvHTInfo = {0};

    lvHTInfo.pt = Notify->ptAction;

    if (-1 != ListView_SubItemHitTest(m_hwndChild, &lvHTInfo) )
    {
        // success

        //
        // If the user click on a different item than the one currently selected
        // then the LVN_ITEMCHANGED message will take care of updating the screen.
        //
        // If the user clicked on the currently slected item then we need to
        // check whether he wants to edit the contents or select a different subitem.
        //
        if (m_nItem_CurrentlyEditing == lvHTInfo.iItem
            && m_nSubItem_CurrentlyEditing == lvHTInfo.iSubItem)
        {
            ShowWindow(m_hwndEditControl, SW_SHOW);

            SetFocus(m_hwndEditControl);
        } else if (m_nItem_LastSelected == lvHTInfo.iItem
            && m_nSubItem_LastSelected == lvHTInfo.iSubItem)
        {
            // If we clicked on the currently selected item & subitem
            // then the user wants to edit the text.
            //
            // Is editing allowed
            if ( ( (0 == m_nSubItem_LastSelected) &&
                (m_wFlags & DL_EDIT_LEFTPANE) )       ||
                ( (1 == m_nSubItem_LastSelected) &&
                (m_wFlags & DL_EDIT_SECONDPANE) )      ||
                ( (2 == m_nSubItem_LastSelected) &&
                (m_wFlags & DL_EDIT_THIRDPANE) ) )
            {
                m_nItem_CurrentlyEditing = m_nItem_LastSelected;
                m_nSubItem_CurrentlyEditing = m_nSubItem_LastSelected;

                EditText();
            }
        }
        else
        {
            // User wants to select a different subitem
            m_nItem_LastSelected = lvHTInfo.iItem;
            m_nSubItem_LastSelected = lvHTInfo.iSubItem;
            InvalidateItem(lvHTInfo.iItem);
        }
    }
}

void
DUALLISTWIN_DATA::EditText()
{
    RECT rc;
    TCHAR sz[NAME_BUFFER * 10], *psz;

    // Get the item's text
    ListView_GetItemText(m_hwndChild,
        m_nItem_CurrentlyEditing,
        m_nSubItem_CurrentlyEditing,
        sz,
        _tsizeof(sz)
        );

    // If we ask for subitem 0, then we get the rectangle for the
    // entire item, so we ask for item m_nItem_CurrentlyEditing, and do the math
    // if we need subitem 0
    Dbg( ListView_GetSubItemRect(m_hwndChild,
        m_nItem_CurrentlyEditing,
        (m_nSubItem_CurrentlyEditing ? m_nSubItem_CurrentlyEditing : 1),
        LVIR_BOUNDS,
        &rc));

    psz = &sz[0];
    if (0 == m_nSubItem_CurrentlyEditing)
    {
        rc.right = rc.left - 1;
        rc.left = 0;

        while (*psz && (*psz == ' ')) {
            ++psz;
        }
    }

    SetWindowText(m_hwndEditControl, psz);

    CHARRANGE charRange={0};

    charRange.cpMax = strlen(psz);
    charRange.cpMin = 0;
    SendMessage(m_hwndEditControl, EM_EXSETSEL, (WPARAM) 0, (LPARAM) &charRange);
    SendMessage(m_hwndEditControl, EM_SETSEL, (WPARAM) 0, (LPARAM) -1);


    POINT ChildBase = {0, 0};
    MapWindowPoints(m_hwndChild, m_Win, &ChildBase, 1);

    MoveWindow(m_hwndEditControl,
        rc.left + ChildBase.x,
        rc.top + ChildBase.y,
        rc.right - rc.left,
        rc.bottom - rc.top,
        FALSE);

    ShowWindow(m_hwndEditControl, SW_SHOW);

    SetFocus(m_hwndEditControl);
}


BOOL
DUALLISTWIN_DATA::CanCopy()
{
    HWND hwnd = (m_nItem_CurrentlyEditing == -1) ? m_hwndChild : m_hwndEditControl;
    CHARRANGE chrg;

    SendMessage(hwnd, EM_EXGETSEL, 0, (LPARAM) (CHARRANGE *) &chrg);

    return chrg.cpMin != chrg.cpMax;
}

BOOL
DUALLISTWIN_DATA::CanCut()
{
    return(m_nItem_CurrentlyEditing != -1)  && CanCopy();
}

BOOL
DUALLISTWIN_DATA::CanPaste()
{
    return(m_nItem_CurrentlyEditing != -1)
        && SendMessage(m_hwndEditControl,
                       EM_CANPASTE,
                       CF_TEXT,
                       0
                       );
}

CHAR ListCopy[500];

void
DUALLISTWIN_DATA::Copy()
{
    if ((m_nItem_CurrentlyEditing == -1) &&
        (m_nItem_LastSelected != -1))
    {
        PCHAR sz = &ListCopy[0];

        ZeroMemory(sz, sizeof(ListCopy));
        if (!GlobalLock( (HGLOBAL) sz))
        {
            return;
        }
        ListView_GetItemText(m_hwndChild, m_nItem_LastSelected, m_nSubItem_LastSelected,
                             sz, sizeof(ListCopy));

        CopyToClipboard(sz, FALSE);
    }
    else
    {
        SendMessage(m_hwndEditControl, WM_COPY, 0, 0);
    }

}

void
DUALLISTWIN_DATA::Cut()
{
    SendMessage(m_hwndEditControl, WM_CUT, 0, 0);
}

void
DUALLISTWIN_DATA::Paste()
{
    SendMessage(m_hwndEditControl, WM_PASTE, 0, 0);
}

void
DUALLISTWIN_DATA::UpdateColors(void)
{
    // Update the general colors and force a repaint to
    // get the text updated.  Specific colors will be
    // applied by custom drawing.
    ListView_SetBkColor(m_hwndChild, g_Colors[COL_PLAIN].Color);
    ListView_SetTextBkColor(m_hwndChild, g_Colors[COL_PLAIN].Color);
    ListView_SetTextColor(m_hwndChild, g_Colors[COL_PLAIN_TEXT].Color);
    InvalidateRect(m_hwndChild, NULL, FALSE);
}

ULONG
DUALLISTWIN_DATA::GetItemFlags(ULONG Item)
{
    LVITEM LvItem;

    LvItem.mask = LVIF_PARAM;
    LvItem.iItem = Item;
    LvItem.iSubItem = 0;
    if (ListView_GetItem(m_hwndChild, &LvItem))
    {
        return (ULONG)LvItem.lParam;
    }
    else
    {
        return 0;
    }
}

void
DUALLISTWIN_DATA::SetItemFlags(ULONG Item, ULONG Flags)
{
    LVITEM LvItem;

    LvItem.mask = LVIF_PARAM;
    LvItem.iItem = Item;
    LvItem.iSubItem = 0;
    LvItem.lParam = (LPARAM)Flags;
    ListView_SetItem(m_hwndChild, &LvItem);
}

BOOL
DUALLISTWIN_DATA::SetItemFromEdit(ULONG Item, ULONG SubItem)
{
    //
    // Save the text from the edit box to list item.
    //
    int nLen = GetWindowTextLength(m_hwndEditControl) + 1;
    PTSTR psz = (PTSTR)calloc( nLen, sizeof(TCHAR) );
    if (psz == NULL)
    {
        return FALSE;
    }

    GetWindowText(m_hwndEditControl, psz, nLen);

    ListView_SetItemText(m_hwndChild, Item, SubItem, psz);
    SetItemFlags(Item, GetItemFlags(Item) | ITEM_CHANGED);

    ItemChanged(Item, psz);

    free(psz);
    return TRUE;
}

//
// SYMWIN_DATA methods
//

HMENU SYMWIN_DATA::s_ContextMenu;

SYMWIN_DATA::SYMWIN_DATA(IDebugSymbolGroup **pDbgSymbolGroup)
    : DUALLISTWIN_DATA(2048)
{
    m_pWinSyms = NULL;
    m_nWinSyms = 0;
    m_pDbgSymbolGroup = pDbgSymbolGroup;
    m_NumSymsDisplayed = 0;
    m_DisplayTypes = FALSE;
    m_DisplayOffsets = FALSE;
    m_RefreshItem = 0;
    m_UpdateItem = -1;
    m_SplitWindowAtItem = 0;
    m_MaxNameWidth = 0;
    m_NumCols = 0;
    m_RefreshValues = TRUE;
    SetMaxSyms(1);
    // Use text for Accessibility readers
    SystemParametersInfo(SPI_GETSCREENREADER, 0, &g_UseTextMode, 0);

}

#define VALUE_COLM  1
#define TYPE_COLM   2
#define OFFSET_COLM (m_DisplayTypes ? 3 : 2)

SYMWIN_DATA::~SYMWIN_DATA()
{
    if (m_pWinSyms)
    {
        free (m_pWinSyms);
    }
    return;
}


void
SYMWIN_DATA::Validate()
{
    DUALLISTWIN_DATA::Validate();
}

#define SYMWIN_CONTEXT_ID_BASE 0x100

#define SYMWIN_TBB_TYPECAST 0
#define SYMWIN_TBB_OFFSETS  1

TBBUTTON g_SymWinTbButtons[] =
{
    TEXT_TB_BTN(SYMWIN_TBB_TYPECAST, "Typecast", BTNS_CHECK),
    TEXT_TB_BTN(SYMWIN_TBB_OFFSETS, "Offsets", BTNS_CHECK),
    SEP_TB_BTN(),
    TEXT_TB_BTN(ID_SHOW_TOOLBAR, "Toolbar", 0),
};

#define NUM_SYMWIN_MENU_BUTTONS \
    (sizeof(g_SymWinTbButtons) / sizeof(g_SymWinTbButtons[0]))
#define NUM_SYMWIN_TB_BUTTONS \
    (NUM_SYMWIN_MENU_BUTTONS - 2)

#define IsAParent(Sym) ((Sym)->SubElements)
#define SYM_LEVEL(sym) ((sym)->Flags & DEBUG_SYMBOL_EXPANSION_LEVEL_MASK)
#define IsRootSym(Sym) !SYM_LEVEL(Sym)

HMENU
SYMWIN_DATA::GetContextMenu(void)
{
    //
    // We only keep one menu around for all call windows
    // so apply the menu check state for this particular
    // window.
    //

    CheckMenuItem(s_ContextMenu, SYMWIN_TBB_TYPECAST + SYMWIN_CONTEXT_ID_BASE,
                  MF_BYCOMMAND | (m_DisplayTypes ? MF_CHECKED : 0));
    CheckMenuItem(s_ContextMenu, SYMWIN_TBB_OFFSETS + SYMWIN_CONTEXT_ID_BASE,
                  MF_BYCOMMAND | (m_DisplayOffsets ? MF_CHECKED : 0));
    CheckMenuItem(s_ContextMenu, ID_SHOW_TOOLBAR + SYMWIN_CONTEXT_ID_BASE,
                  MF_BYCOMMAND | (m_ShowToolbar ? MF_CHECKED : 0));

    return s_ContextMenu;
}

void
SYMWIN_DATA::OnContextMenuSelection(UINT Item)
{
    ULONG Changed = 0;

    Item -= SYMWIN_CONTEXT_ID_BASE;

    switch(Item)
    {
    case SYMWIN_TBB_TYPECAST:
        SetDisplayTypes(Item, !m_DisplayTypes);
        Changed = 1 << SYMWIN_TBB_TYPECAST;
        break;
    case SYMWIN_TBB_OFFSETS:
        SetDisplayTypes(Item, !m_DisplayOffsets);
        Changed = 1 << SYMWIN_TBB_OFFSETS;
        break;
    case ID_SHOW_TOOLBAR:
        SetShowToolbar(!m_ShowToolbar);
        break;
    }
    SyncUiWithFlags(Changed);
}

BOOL
SYMWIN_DATA::OnCreate(void)
{
    if (s_ContextMenu == NULL)
    {
        s_ContextMenu = CreateContextMenuFromToolbarButtons
            (NUM_SYMWIN_MENU_BUTTONS, g_SymWinTbButtons,
             SYMWIN_CONTEXT_ID_BASE);
        if (s_ContextMenu == NULL)
        {
            return FALSE;
        }
    }

    if (!DUALLISTWIN_DATA::OnCreate())
    {
        return FALSE;
    }

    m_Toolbar = CreateWindowEx(0, TOOLBARCLASSNAME, NULL,
                    WS_CHILD | WS_VISIBLE |
                    TBSTYLE_WRAPABLE | TBSTYLE_LIST | CCS_TOP,
                    0, 0, m_Size.cx, 0, m_Win, (HMENU)ID_TOOLBAR,
                    g_hInst, NULL);
    if (m_Toolbar == NULL)
    {
        return FALSE;
    }
    SendMessage(m_Toolbar, TB_BUTTONSTRUCTSIZE, sizeof(TBBUTTON), 0);
    SendMessage(m_Toolbar, TB_ADDBUTTONS, NUM_SYMWIN_TB_BUTTONS,
        (LPARAM)&g_SymWinTbButtons);
    SendMessage(m_Toolbar, TB_AUTOSIZE, 0, 0);

    RECT Rect;
    GetClientRect(m_Toolbar, &Rect);
    m_ToolbarHeight = Rect.bottom - Rect.top + GetSystemMetrics(SM_CYEDGE);
    m_ShowToolbar = TRUE;

    SendMessage(m_hwndChild, WM_SETREDRAW, FALSE, 0);

    RECT        rc;
    LV_COLUMN   lvc = {0};

    GetClientRect(m_hwndChild, &rc);
    rc.right -= rc.left + GetSystemMetrics(SM_CXVSCROLL);

    //initialize the columns
    lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_SUBITEM | LVCF_TEXT;
    lvc.fmt = LVCFMT_LEFT;
    lvc.iSubItem = 0;

    lvc.cx = m_Font->Metrics.tmAveCharWidth * 20;
    if (lvc.cx > rc.right / 2)
    {
        lvc.cx = rc.right / 2;
    }
    lvc.pszText = _T("Name");
    Dbg( (0 == ListView_InsertColumn(m_hwndChild, 0, &lvc)) );

    // Give the rest of the space to the value.
    lvc.cx = rc.right - lvc.cx;
    lvc.pszText = _T("Value");
    Dbg( (1 == ListView_InsertColumn(m_hwndChild, 1, &lvc)) );
    m_NumCols = 2;

    ListView_SetExtendedListViewStyle(m_hwndChild,
        LVS_EX_GRIDLINES | LVS_EX_FULLROWSELECT
        );
    SendMessage(m_hwndChild, WM_SETREDRAW, TRUE, 0);
    InvalidateRect(m_hwndChild, NULL, TRUE);


    return TRUE;
}

void
SYMWIN_DATA::OnSize(void)
{
    DUALLISTWIN_DATA::OnSize();

//    ListView_SetColumnWidth(m_hwndChild, 0 , m_MaxNameWidth);
}


LRESULT
SYMWIN_DATA::OnNotify(
    WPARAM              wParam,
    LPARAM              lParam
    )
{
    if (((LPNMHDR) lParam)->code == LVN_KEYDOWN)
    {
        if (m_nItem_LastSelected != -1 &&
            m_nItem_CurrentlyEditing == -1 &&
            g_ExecStatus == DEBUG_STATUS_BREAK)
        {
            NMLVKEYDOWN * pNmKeyDown = (NMLVKEYDOWN *) lParam;

            switch (pNmKeyDown->wVKey)
            {
            case VK_LEFT:
                if (m_nSubItem_LastSelected == 0)
                {
                    ExpandSymbol(m_nItem_LastSelected, FALSE);
                    return TRUE;
                }
                break;
            case VK_RIGHT:
                if (m_nSubItem_LastSelected == 0)
                {
                    ExpandSymbol(m_nItem_LastSelected, TRUE);
                    return TRUE;
                }
                break;
            case VK_RETURN:
                switch (m_nSubItem_LastSelected) {
                case 0:
                    if (IsRootSym(&m_pWinSyms[m_nItem_LastSelected]) && (m_enumType == WATCH_WINDOW))
                    {
                        m_nItem_CurrentlyEditing   = m_nItem_LastSelected;
                        m_nSubItem_CurrentlyEditing=0;
                        EditText();
                    }
                    break;
                case 1:
                    if (!(m_pWinSyms[m_nItem_LastSelected].Flags & DEBUG_SYMBOL_READ_ONLY))
                    {
                        m_nItem_CurrentlyEditing   = m_nItem_LastSelected;
                        m_nSubItem_CurrentlyEditing=1;
                        EditText();
                    }
                    break;
                case 2:
                    m_nItem_CurrentlyEditing   = m_nItem_LastSelected;
                    m_nSubItem_CurrentlyEditing=2;
                    EditText();
                    break;
                default:
                    break;
                }
                break;
            default:
                break;
            }

        }
    }
    else if (((LPNMHDR) lParam)->code == LVN_ITEMCHANGED)
    {
        LPNMLISTVIEW pnmv = (LPNMLISTVIEW) lParam;

        if (pnmv->uNewState & LVIS_SELECTED)
        {
            m_nItem_LastSelected = pnmv->iItem;
            m_nSubItem_LastSelected = pnmv->iSubItem;
        }
    }
    return DUALLISTWIN_DATA::OnNotify(wParam, lParam);
}

void
SYMWIN_DATA::OnUpdate(
    UpdateType Type
    )
{
    if (Type == UPDATE_EXEC)
    {
        // Disallow editing when the debuggee is running.
        if (g_ExecStatus == DEBUG_STATUS_BREAK)
        {
            if (m_enumType != LOCALS_WINDOW)
            {
                m_wFlags |= DL_EDIT_LEFTPANE;
            }
            else
            {
                m_wFlags &= ~DL_EDIT_LEFTPANE;
            }
            ListView_SetTextBkColor(m_hwndChild, g_Colors[COL_PLAIN].Color);
        }
        else
        {
            m_wFlags = 0;
            ListView_SetTextBkColor(m_hwndChild,
                                    g_Colors[COL_DISABLED_WINDOW].Color);
        }
        InvalidateRect(m_hwndChild, NULL, FALSE);
        return;
    }
    else if (Type != UPDATE_BUFFER)
    {
        return;
    }
    SendMessage(m_hwndChild, WM_SETREDRAW, FALSE, 0);

    UpdateNames();

    SendMessage(m_hwndChild, WM_SETREDRAW, TRUE, 0);
    InvalidateRect(m_hwndChild, NULL, TRUE);
}

void
SYMWIN_DATA::ExpandSymbol(
    ULONG Index,
    BOOL Expand
    )
{
    //
    // Expand the Item
    //
    UIC_SYMBOL_WIN_DATA* WatchItem;

    WatchItem = StartStructCommand(UIC_SYMBOL_WIN);
    if (WatchItem != NULL)
    {

        WatchItem->Type = EXPAND_SYMBOL;
        WatchItem->pSymbolGroup = m_pDbgSymbolGroup;
        WatchItem->u.ExpandSymbol.Index = Index;
        WatchItem->u.ExpandSymbol.Expand = Expand;
        FinishCommand();
        UiRequestRead();
    }

}

ULONG
SYMWIN_DATA::GetWorkspaceSize(void)
{
    return DUALLISTWIN_DATA::GetWorkspaceSize() + 2*sizeof(BOOL);
}

PUCHAR
SYMWIN_DATA::SetWorkspace(PUCHAR Data)
{
    Data = DUALLISTWIN_DATA::SetWorkspace(Data);
    *(PBOOL)Data = m_DisplayTypes;
    Data += sizeof(BOOL);
    *(PBOOL)Data = m_DisplayOffsets;
    Data += sizeof(BOOL);

    return Data;
}

PUCHAR
SYMWIN_DATA::ApplyWorkspace1(PUCHAR Data, PUCHAR End)
{
    UIC_SYMBOL_WIN_DATA* WatchItem;

    Data = DUALLISTWIN_DATA::ApplyWorkspace1(Data, End);

    // Clear the window
    WatchItem = StartStructCommand(UIC_SYMBOL_WIN);
    if (WatchItem != NULL)
    {
        WatchItem->Type = DEL_SYMBOL_WIN_ALL;
        WatchItem->pSymbolGroup = m_pDbgSymbolGroup;
        FinishCommand();
    }

    ULONG Changed = 0;

    if (End - Data >= sizeof(BOOL))
    {
        SetDisplayTypes(SYMWIN_TBB_TYPECAST, *(PBOOL)Data);
        Changed |= 1 << SYMWIN_TBB_TYPECAST;
        Data += sizeof(BOOL);
    }
    if (End - Data >= sizeof(BOOL))
    {
        SetDisplayTypes(SYMWIN_TBB_OFFSETS, *(PBOOL)Data);
        Changed |= 1 << SYMWIN_TBB_OFFSETS;
        Data += sizeof(BOOL);
    }
    SyncUiWithFlags(Changed);

    return Data;
}

BOOL
SYMWIN_DATA::AddListItem(
    ULONG iItem,
    PSTR ItemText,
    ULONG Level,
    BOOL  HasChildren,
    BOOL  Expanded)
{
    LVITEM LvItem = {0};
    CHAR Name[NAME_BUFFER], OldName[NAME_BUFFER];
    ULONG i;

    LvItem.mask = LVIF_TEXT | LVIF_INDENT;
    Name[0] = 0;

    ULONG NameUsed = strlen(Name);

    // HACK - Column autosize doesn't take indent into account
    // while autosizing the column, so padd with spaces in front to make it work
    i = 0;
    while (i <= (Level + 2) && i < sizeof(Name) - 1)
    {
        Name[i++] = ' ';
    }
    Name[i] = 0;

    CatString(Name, ItemText, DIMA(Name));

    LvItem.pszText = Name;
    LvItem.iItem = iItem;
    LvItem.iIndent = Level + 1;
    if ((ULONG)ListView_GetItemCount(m_hwndChild) <= iItem)
    {
        ListView_InsertItem(m_hwndChild, &LvItem);
        return TRUE;
    }
    else
    {
        ListView_GetItemText(m_hwndChild, iItem, 0, OldName, sizeof(OldName));
        ListView_SetItem(m_hwndChild, &LvItem);
        return (strcmp(Name, OldName) != 0);
    }
}

void
SYMWIN_DATA::UpdateNames()
{
    ULONG   Sym, Items;
    PSTR    Buf;
    PDEBUG_SYMBOL_PARAMETERS SymParams = GetSymParam();
    BOOL    NameChanged;
    HDC     hDC = GetDC(m_hwndChild);
    TEXTMETRIC tm = {0};

    Items = ListView_GetItemCount(m_hwndChild);
    GetTextMetrics(hDC, &tm);
    ReleaseDC(m_hwndChild, hDC);

    if (UiLockForRead() == S_OK)
    {
        Buf = (PSTR)GetDataBuffer();

        ULONG Len;
        CHAR  Name[NAME_BUFFER], Value[NAME_BUFFER], Type[NAME_BUFFER], Offset[20];
        ULONG LastArgSym=-1, LastParent=0;

        Items = 0;

        if (m_UpdateItem < m_SplitWindowAtItem)
        {
            LastArgSym = m_UpdateItem;
            m_SplitWindowAtItem = 0;
        }

        for (Sym = m_UpdateItem; Sym < m_NumSymsDisplayed; Sym++)
        {
            PSTR EndTag;
            PSTR NameSt, NameEn;

            if (Buf == NULL)
            {
                strcpy(Name, _T("Unknown"));
                strcpy(Value, _T(""));
            }
            else
            {
#if DBG_SYM_WIN
                DebugPrint("SYM_WIN: Buffer left %s\n", Buf);
#endif

                Name[0] = 0;
                EndTag = strstr(Buf, DEBUG_OUTPUT_NAME_END);
                if (!EndTag)
                {
                    break;
                }

                NameSt = Buf;
                NameEn = EndTag;

                Buf = EndTag + strlen(DEBUG_OUTPUT_NAME_END);
                EndTag = strstr(Buf, DEBUG_OUTPUT_VALUE_END);
                if (!EndTag)
                {
                    break;
                }

                Len = (ULONG) (EndTag - Buf);
                if (Len >= sizeof(Value))
                {
                    Len = sizeof(Value) - 1;
                }
                memcpy(Value, Buf, Len);
                Value[Len] = 0;

                Buf = EndTag + strlen(DEBUG_OUTPUT_VALUE_END);

                if (m_DisplayOffsets)
                {
                    EndTag = strstr(Buf, DEBUG_OUTPUT_OFFSET_END);
                    if (!EndTag)
                    {
                        EndTag = Buf;
                    }

                    Len = (ULONG) (EndTag - Buf);
                    if (Len >= sizeof(Offset))
                    {
                        Len = sizeof(Offset) - 1;
                    }
                    memcpy(Offset, Buf, Len);
                    Offset[Len] = 0;

                    Buf = EndTag + strlen(DEBUG_OUTPUT_OFFSET_END);
                }

                Len = (ULONG) (NameEn - NameSt);
                if (Len >= sizeof(Name) - 10)
                {
                    Len = sizeof(Name) - 11;
                }
                strncat(Name, NameSt, Len);
                Name[DIMA(Name) - 1] = 0;

                if (m_DisplayTypes)
                {
                    EndTag = strstr(Buf, DEBUG_OUTPUT_TYPE_END);
                    if (!EndTag)
                    {
                        EndTag = Buf;
                    }

                    Len = (ULONG) (EndTag - Buf);
                    if (Len >= sizeof(Type))
                    {
                        Len = sizeof(Type) - 1;
                    }
                    memcpy(Type, Buf, Len);
                    Type[Len] = 0;

                    Buf = EndTag + strlen(DEBUG_OUTPUT_TYPE_END);
                }
            }

            if (GetMaxSyms() > Sym)
            {
                NameChanged =
                    AddListItem(Sym, Name, SYM_LEVEL((SymParams + Sym)),
                                SymParams[Sym].SubElements,
                                SymParams[Sym].Flags & DEBUG_SYMBOL_EXPANDED);
            }
            else
            {
                break;
            }

            if (!(SymParams[Sym].Flags & DEBUG_SYMBOL_EXPANSION_LEVEL_MASK))
            {
                LastParent = Sym;

                if ((SymParams[Sym].Flags & DEBUG_SYMBOL_IS_ARGUMENT) &&
                    (m_enumType == LOCALS_WINDOW))
                {
                    LastArgSym = Sym;
                }

                if ((LastParent > LastArgSym) && !m_SplitWindowAtItem)
                {
                    m_SplitWindowAtItem = Sym;
                }
            }

            if (!NameChanged)
            {
                // Check if the value changed
                PCHAR OldValue = &Name[0];
                ListView_GetItemText(m_hwndChild, Sym, VALUE_COLM,
                                     OldValue, sizeof(Name));

                if (strcmp(OldValue, Value))
                {
                    // Value changed
                    SymParams[Sym].Flags |= ITEM_VALUE_CHANGED;
                }
                else
                {
                    SymParams[Sym].Flags &= ~ITEM_VALUE_CHANGED;
                }
            }

            ListView_SetItemText(m_hwndChild, Sym, VALUE_COLM, Value);

            if (m_DisplayOffsets)
            {
                ListView_SetItemText(m_hwndChild, Sym, OFFSET_COLM, Offset);
            }
            if (m_DisplayTypes)
            {
                ListView_SetItemText(m_hwndChild, Sym, TYPE_COLM, Type);
            }

            if (Sym < sizeof(m_ListItemLines))
            {
                m_ListItemLines[Sym] = 2;
            }
        }

        UnlockStateBuffer(this);
    }

    ClearList(m_NumSymsDisplayed);

    if (Items == 0 && (m_enumType == WATCH_WINDOW))
    {
        //
        // add a dummy to enable adding new items
        //
        LVITEM LvItem = {0};
        LvItem.mask = LVIF_TEXT | LVIF_INDENT;
        LvItem.pszText = "";
        LvItem.iItem = m_NumSymsDisplayed;
        ListView_InsertItem(m_hwndChild, &LvItem);
        // ListView_SetItemText(m_hwndChild, m_NumSymsDisplayed, 1, "Dummy");
    }

    m_MaxNameWidth = 0;
    m_UpdateItem = -1;
}

#define ALLOCATE_CHUNK 0x100
HRESULT
SYMWIN_DATA::SetMaxSyms(
    ULONG nSyms
    )
{
    if (m_nWinSyms < nSyms)
    {
        DEBUG_SYMBOL_PARAMETERS *TempSyms = m_pWinSyms;

        m_nWinSyms = ALLOCATE_CHUNK * ((nSyms + ALLOCATE_CHUNK - 1 )/ ALLOCATE_CHUNK);
        TempSyms = (DEBUG_SYMBOL_PARAMETERS *) realloc(m_pWinSyms, m_nWinSyms*sizeof(DEBUG_SYMBOL_PARAMETERS));

        if (!TempSyms)
        {
            // malloc failed, free old allocations and bail with error below
            if (m_pWinSyms)
            {
                free ( m_pWinSyms );
                m_pWinSyms = NULL;
            }
            m_nWinSyms = 0;
            return E_OUTOFMEMORY;
        }
        // move ptr to new memory address
        m_pWinSyms = TempSyms;
    }

    return S_OK;
}

LRESULT
SYMWIN_DATA::OnCommand(
    WPARAM wParam,
    LPARAM lParam
    )
{
    if ((HWND) lParam == m_Toolbar)
    {
        OnContextMenuSelection(LOWORD(wParam) + SYMWIN_CONTEXT_ID_BASE);
        return 0;
    }

    return DUALLISTWIN_DATA::OnCommand(wParam, lParam);
}


void
SYMWIN_DATA::OnClick(
    LPNMLISTVIEW Notify
    )
{

    LVHITTESTINFO lvHTInfo = {0};
    RECT          itemRect;
    ULONG         item;

    lvHTInfo.pt = Notify->ptAction;

    if (-1 != ListView_SubItemHitTest(m_hwndChild, &lvHTInfo) &&
        (m_NumSymsDisplayed > (ULONG) lvHTInfo.iItem) &&
        (g_ExecStatus == DEBUG_STATUS_BREAK))
    {
        PDEBUG_SYMBOL_PARAMETERS SymParams = GetSymParam();

            item = lvHTInfo.iItem;
            if (ListView_GetItemRect(m_hwndChild, lvHTInfo.iItem, &itemRect, LVIR_BOUNDS))
            {
                if (((int) SYM_LEVEL(&SymParams[item]) * m_IndentWidth < Notify->ptAction.x)  &&
                     (Notify->ptAction.x < (int) (itemRect.left + m_IndentWidth * (2+SYM_LEVEL(&SymParams[item])))) &&
                    (lvHTInfo.iSubItem == 0) &&
                    (SymParams[item].SubElements))
                {
                    BOOL Expand = TRUE;
                    if (SymParams[item].SubElements)
                    {
                        if ((m_NumSymsDisplayed > item + 1)  &&
                            (SymParams[item+1].ParentSymbol == item) &&
                            ((SymParams[item+1].Flags & DEBUG_SYMBOL_EXPANSION_LEVEL_MASK) ==
                             (SymParams[item].Flags & DEBUG_SYMBOL_EXPANSION_LEVEL_MASK) + 1))
                         {
                            //
                            // Already expanded
                            //
                            Expand = FALSE;
                        }

                        ExpandSymbol(item, Expand);
                    }
                    m_RefreshItem = item;

                    m_nItem_LastSelected = lvHTInfo.iItem;
                    m_nSubItem_LastSelected = lvHTInfo.iSubItem;

                    return;
                }
            }

            //
            // Check if ok to edit right pane
            //
            if (SymParams[lvHTInfo.iItem].Flags & DEBUG_SYMBOL_READ_ONLY)
            {
                m_wFlags &= ~DL_EDIT_SECONDPANE;
            }
            else
            {
                m_wFlags |= DL_EDIT_SECONDPANE;
            }
            //
            // Check if ok to edit left pane
            //
            if ((SymParams[lvHTInfo.iItem].Flags & DEBUG_SYMBOL_EXPANSION_LEVEL_MASK) ||
                (m_enumType != WATCH_WINDOW))
            {
                m_wFlags &= ~DL_EDIT_LEFTPANE;
            }
            else
            {
                m_wFlags |= DL_EDIT_LEFTPANE;
            }

            if (m_DisplayTypes)
            {
                m_wFlags |= DL_EDIT_THIRDPANE;
            }
            else
            {
                m_wFlags &= ~DL_EDIT_THIRDPANE;
            }
    }
    else if ((m_enumType == WATCH_WINDOW) &&
             (g_ExecStatus == DEBUG_STATUS_BREAK) &&
             (m_NumSymsDisplayed == (ULONG) lvHTInfo.iItem))
    {
        m_wFlags |= DL_EDIT_LEFTPANE;
    }

    //
    // Default processing
    //
    DUALLISTWIN_DATA::OnClick(Notify);
}

HRESULT
SYMWIN_DATA::ReadState(void)
{
    HRESULT Status;
    ULONG   getSyms;

    if (m_pDbgSymbolGroup == NULL ||
        *m_pDbgSymbolGroup == NULL)
    {
        return E_UNEXPECTED;
    }

    (*m_pDbgSymbolGroup)->GetNumberSymbols(&m_NumSymsDisplayed);
    if (m_NumSymsDisplayed < m_RefreshItem)
    {
        // numsyms changed since last click - might happen for locals

        m_RefreshItem = 0;
    }
    getSyms = m_NumSymsDisplayed - m_RefreshItem;
    if (m_NumSymsDisplayed > GetMaxSyms())
    {
        if ((Status = SetMaxSyms(m_NumSymsDisplayed)) != S_OK)
        {
            m_NumSymsDisplayed = 0;
            return Status;
        }
    }

    (*m_pDbgSymbolGroup)->GetSymbolParameters(m_RefreshItem, getSyms, GetSymParam() + m_RefreshItem);
    Empty();

    g_OutStateBuf.SetBuffer(this);
    if ((Status = g_OutStateBuf.Start(TRUE)) != S_OK)
    {
        return Status;
    }
    (*m_pDbgSymbolGroup)->OutputSymbols(DEBUG_OUTCTL_THIS_CLIENT |
        DEBUG_OUTCTL_OVERRIDE_MASK |
        DEBUG_OUTCTL_NOT_LOGGED,
        (m_DisplayOffsets ? 0 : DEBUG_OUTPUT_SYMBOLS_NO_OFFSETS) |
        (m_DisplayTypes ? 0 : DEBUG_OUTPUT_SYMBOLS_NO_TYPES),
        m_RefreshItem,
        m_NumSymsDisplayed - m_RefreshItem);

    Status = g_OutStateBuf.End(FALSE);
    m_UpdateItem = m_RefreshItem;
    m_RefreshItem = 0;
    return Status;
}

void
SYMWIN_DATA::ItemChanged(int Item, PCSTR Text)
{
    UIC_SYMBOL_WIN_DATA* WatchItem;

    if (m_nItem_CurrentlyEditing == -1)
    {
        return;
    }

    if (m_nSubItem_CurrentlyEditing == 0)
    {
        //
        // First delete, then add the item
        //

        if (Item < (int) GetMaxSyms() && Item < (int) m_NumSymsDisplayed)
        {
            //
            // See if this item can be changed or not - only root and dummy can be chnged
            //
            if ((GetSymParam())[Item].Flags & DEBUG_SYMBOL_EXPANSION_LEVEL_MASK)
            {
                UiRequestRead();
                return;
            }
        }

        WatchItem = StartStructCommand(UIC_SYMBOL_WIN);
        if (WatchItem != NULL)
        {

            WatchItem->Type = DEL_SYMBOL_WIN_INDEX;

            WatchItem->pSymbolGroup = m_pDbgSymbolGroup;
            WatchItem->u.DelIndex = Item;
            FinishCommand();
        }
        else
        {
            // XXX drewb - Failure?
        }

        WatchItem = StartStructCommand(UIC_SYMBOL_WIN);
        if (WatchItem != NULL)
        {
            WatchItem->Type = ADD_SYMBOL_WIN;
            WatchItem->pSymbolGroup = m_pDbgSymbolGroup;
            CopyString(m_ChangedName, Text, DIMA(m_ChangedName));
            WatchItem->u.Add.Name = m_ChangedName;
            WatchItem->u.Add.Index = Item;
            FinishCommand();
        }

        if (g_Workspace != NULL)
        {
            g_Workspace->AddDirty(WSPF_DIRTY_WINDOWS);
        }
    }
    else if (m_nSubItem_CurrentlyEditing == 1)
    {
        WatchItem = StartStructCommand(UIC_SYMBOL_WIN);

        if (WatchItem != NULL)
        {
            CopyString(m_ChangedName, Text, DIMA(m_ChangedName));
            WatchItem->Type = EDIT_SYMBOL;
            WatchItem->pSymbolGroup = m_pDbgSymbolGroup;
            WatchItem->u.WriteSymbol.Index = m_nItem_CurrentlyEditing;
            WatchItem->u.WriteSymbol.Value = m_ChangedName;
            FinishCommand();
        }
    }
    else if (m_nSubItem_CurrentlyEditing == 2)
    {
        WatchItem = StartStructCommand(UIC_SYMBOL_WIN);

        if (WatchItem != NULL)
        {
            CopyString(m_ChangedName, Text, DIMA(m_ChangedName));
            WatchItem->Type = EDIT_TYPE;
            WatchItem->pSymbolGroup = m_pDbgSymbolGroup;
            WatchItem->u.OutputAsType.Index = m_nItem_CurrentlyEditing;
            WatchItem->u.OutputAsType.Type = m_ChangedName;
            FinishCommand();
        }
    }
    UiRequestRead();
}

void
SYMWIN_DATA::SetDisplayTypes(LONG Id, BOOL Set)
{
    if (Id == g_SymWinTbButtons[0].idCommand ||
        Id == g_SymWinTbButtons[1].idCommand)
    {
        //
        // Add / remove a column
        //
        if (Id == g_SymWinTbButtons[0].idCommand)
        {
            m_wFlags |= DL_EDIT_THIRDPANE;

            if (Set == m_DisplayTypes)
            {
                return;
            }

            m_DisplayTypes = Set;
        }
        else
        {
            if (Set == m_DisplayOffsets)
            {
                return;
            }

            m_DisplayOffsets = Set;
        }

        if (g_Workspace != NULL)
        {
            g_Workspace->AddDirty(WSPF_DIRTY_WINDOWS);
        }
        if (Id == g_SymWinTbButtons[1].idCommand)
        {
            //UiRequestRead();
            //return;
        }

        if (Set)
        {
            LV_COLUMN   lvc = {0};
            int         Col1Width;

            Col1Width = ListView_GetColumnWidth(m_hwndChild, VALUE_COLM);

            lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_SUBITEM | LVCF_TEXT;
            lvc.fmt = LVCFMT_LEFT;
            lvc.iSubItem = 0;

            if (Col1Width >= (m_Font->Metrics.tmAveCharWidth * 20))
            {
                lvc.cx = max(Col1Width / 4,
                             m_Font->Metrics.tmAveCharWidth * 10);
                Col1Width -= lvc.cx;
            } else
            {
                lvc.cx = Col1Width >> 1;
                Col1Width -= lvc.cx;
            }
            ListView_SetColumnWidth(m_hwndChild, VALUE_COLM, Col1Width);


            lvc.pszText = _T((Id == g_SymWinTbButtons[0].idCommand) ? "Type" : "Offset");
            ListView_InsertColumn(
                m_hwndChild,
                ((Id == g_SymWinTbButtons[0].idCommand) ? TYPE_COLM : OFFSET_COLM),
                &lvc);
            m_NumCols++;
        }
        else
        {
            if (Id == g_SymWinTbButtons[0].idCommand)
            {
                m_wFlags &= ~DL_EDIT_THIRDPANE;
            }

            int         Col2Width;
            int         Col1Width;
            int         ColToDel = ((Id == g_SymWinTbButtons[0].idCommand) ? TYPE_COLM : OFFSET_COLM);


            Col1Width = ListView_GetColumnWidth(m_hwndChild, VALUE_COLM);
            Col2Width = ListView_GetColumnWidth(m_hwndChild, ColToDel);

            ListView_DeleteColumn(m_hwndChild, ColToDel);
            ListView_SetColumnWidth(m_hwndChild, VALUE_COLM, Col1Width + Col2Width);
            m_NumCols--;
        }
        UiRequestRead();
    }
}


//the basic rutine making the ... thing
LPTSTR MakeShortString(HDC hDC, LPTSTR lpszLong, LONG nColumnLen,
                       LONG nOffset, PULONG pActualLen )
{
    static const _TCHAR szThreeDots[]=_T("...");
    SIZE strSz;

    int nStringLen = lstrlen(lpszLong);

    if (nStringLen==0 ||
        (GetTextExtentPoint(hDC, lpszLong,nStringLen,
                            &strSz), strSz.cx + nOffset < nColumnLen))
    {
        *pActualLen = nStringLen ? strSz.cx : 0;
        return(lpszLong);
    }
    *pActualLen = strSz.cx;

    static _TCHAR szShort[1024];

    if (nStringLen < sizeof(szShort) - 4)
    {
        lstrcpy(szShort, lpszLong);
    }
    else
    {
        nStringLen = sizeof(szShort) - 4;
        strncpy(szShort, lpszLong, nStringLen);
        szShort[nStringLen] = 0;
    }
    GetTextExtentPoint(hDC, szThreeDots, sizeof(szThreeDots), &strSz);
    int nAddLen = strSz.cx;

    for (int i = nStringLen - 1; i > 0; i--)
    {
        szShort[i] = 0;
        GetTextExtentPoint(hDC, szShort, i, &strSz);

        if(strSz.cx + nOffset + nAddLen < nColumnLen)
        {
            break;
        }
    }
    lstrcat(szShort, szThreeDots);
    return szShort;
}

void DrawRectangle(HDC hDc, POINT pt, ULONG width)
{
    POINT corners[5];

    corners[0] = pt;
    corners[1].x = pt.x; corners[1].y = pt.y + width;
    corners[2].x = pt.x + width; corners[2].y = pt.y + width;
    corners[3].x = pt.x + width; corners[3].y = pt.y;
    corners[4] = pt;

    Polyline(hDc, &corners[0], 5);
}

void DrawHorizLine(HDC hDc, POINT start, ULONG length, ULONG thick)
{
    POINT curr, pt = start;

    while (thick)
    {
        MoveToEx(hDc, pt.x, pt.y, &curr);
        LineTo(hDc, pt.x + length, pt.y);

        --thick;
        ++pt.y;
    }
}

void DrawPlus(HDC hDc, POINT topLeft, ULONG width)
{
    if (g_UseTextMode)
    {
        TextOut(hDc, topLeft.x, topLeft.y - width/2, "+", 1);
        return;
    }
    POINT curr, pt = topLeft;
        DrawRectangle(hDc, pt, width);

    MoveToEx(hDc, pt.x, pt.y + width/2, &curr);
        LineTo(hDc, pt.x + width, pt.y + width/2);

    MoveToEx(hDc, pt.x + width/2, pt.y, &curr);
        LineTo(hDc, pt.x + width/2, pt.y + width);
}


void DrawMinus(HDC hDc, POINT topLeft, ULONG width)
{
    if (g_UseTextMode)
    {
        TextOut(hDc, topLeft.x, topLeft.y - width/2, "-", 1);
        return;
    }

    POINT curr, pt = topLeft;
        DrawRectangle(hDc, pt, width);

    MoveToEx(hDc, pt.x, pt.y + width/2, &curr);
        LineTo(hDc, pt.x + width, pt.y + width/2);
}



void DrawIndentLevel(HDC hDc, ULONG Indent, RECT leftRect)
{
    POINT curr, pt;
    ULONG i;
    INT   width, height;

    pt.x = leftRect.left;
    pt.y = leftRect.top;

    width = leftRect.right - leftRect.left;
    height = leftRect.bottom - leftRect.top;

    for (i=0;i<Indent; i++,pt.x+=width)
    {
        if (g_UseTextMode)
        {
            TextOut(hDc, pt.x, pt.y, "|",1);
            continue;
        }
        MoveToEx(hDc, pt.x + width/2, pt.y, &curr);
        LineTo(hDc, pt.x + width/2, pt.y + height);
        if (i+1==Indent)
        {
            MoveToEx(hDc, pt.x + width/2, pt.y + height/2, &curr);
            LineTo(hDc, pt.x + width - 1, pt.y + height/2);
        }
    }
}

#define NAME_LEFT_PAD 6

void
SYMWIN_DATA::DrawTreeItem(HDC hDC, ULONG itemID, RECT ItemRect, PULONG pIndentOffset)
{
    ULONG RectWidth;
    ULONG level;
    TEXTMETRIC tm;

    if (itemID >= m_NumSymsDisplayed)
    {
        return;
    }

    // derive the Width of +/- from tm
    GetTextMetrics(hDC, &tm);
    RectWidth = (tm.tmHeight * 2) / 3;

    level = m_pWinSyms[itemID].Flags & DEBUG_SYMBOL_EXPANSION_LEVEL_MASK;

    // Rectangle for One indent level
    RECT IndentRc;
    IndentRc = ItemRect;
    IndentRc.left  = ItemRect.left + 2;
    IndentRc.right = IndentRc.left + RectWidth + 1;
    DrawIndentLevel(hDC, level, IndentRc);

    *pIndentOffset = level * (RectWidth+1) + NAME_LEFT_PAD;
    POINT pt;
    pt.x = ItemRect.left + *pIndentOffset - 4;
    pt.y = (ItemRect.top + ItemRect.bottom - RectWidth) / 2;

    if (m_pWinSyms[itemID].Flags & DEBUG_SYMBOL_EXPANDED)
    {
        DrawMinus(hDC, pt, RectWidth);
    } else if (m_pWinSyms[itemID].SubElements)
    {
        DrawPlus(hDC, pt, RectWidth);
    }

    m_IndentWidth   = RectWidth+1;
    *pIndentOffset += RectWidth+1;
}

LRESULT
SYMWIN_DATA::OnOwnerDraw(UINT uMsg, WPARAM wParam, LPARAM lParam)
{

    LPDRAWITEMSTRUCT lpdis;
    TEXTMETRIC tm;
    ULONG IndentOffset = 0, ActualWidth;


    if (uMsg == WM_MEASUREITEM)
    {
        MEASUREITEMSTRUCT *lpmis = (MEASUREITEMSTRUCT * ) lParam;
        HDC hDC = GetDC(m_hwndChild);
        GetTextMetrics(hDC, &tm);
        lpmis->CtlType = ODT_LISTVIEW;
        lpmis->itemHeight = tm.tmHeight;
        lpmis->itemWidth  = m_MaxNameWidth;
        ReleaseDC(m_hwndChild, hDC);

        return TRUE;
    }
    else
    {
        // Assert (uMsg == WM_DRAWITEM);
    }

    lpdis = (LPDRAWITEMSTRUCT) lParam;

    int y;
    TCHAR Buffer[NAME_BUFFER];
    int Col;
    LPTSTR pszText=&Buffer[0];


    // If there are no list box items, skip this message.
    if (lpdis->itemID == -1)
    {
        return FALSE;
    }

    switch (lpdis->itemAction)
    {
    case ODA_SELECT:
    case ODA_DRAWENTIRE:
    {
        HBRUSH hBrush;
        DWORD  dwOldTextColor, dwOldBkColor, TextColor;

        if (g_ExecStatus != DEBUG_STATUS_BREAK)
        {
            dwOldTextColor = ListView_GetTextColor(m_hwndChild);
            dwOldBkColor =   ListView_GetBkColor(m_hwndChild);

            hBrush = g_Colors[COL_DISABLED_WINDOW].Brush;

            TextColor = dwOldTextColor =
                SetTextColor(lpdis->hDC, dwOldTextColor);
            dwOldBkColor = SetBkColor(lpdis->hDC,
                                      g_Colors[COL_DISABLED_WINDOW].Color);
        }
        else if (lpdis->itemState & ODS_SELECTED)
        {
            hBrush = g_Colors[COL_CURRENT_LINE].Brush;
            TextColor = g_Colors[COL_CURRENT_LINE_TEXT].Color;

            dwOldTextColor = SetTextColor(lpdis->hDC, TextColor);
            dwOldBkColor = SetBkColor(lpdis->hDC,
                                      g_Colors[COL_CURRENT_LINE].Color);
        }
        else // item not selected
        {
            hBrush = g_Colors[COL_PLAIN].Brush;
            TextColor = g_Colors[COL_PLAIN_TEXT].Color;

            dwOldTextColor = SetTextColor(lpdis->hDC, TextColor);
            dwOldBkColor = SetBkColor(lpdis->hDC,
                                      g_Colors[COL_PLAIN].Color);
        }

        if (hBrush != NULL)
        {
            FillRect(lpdis->hDC, (LPRECT)&lpdis->rcItem, hBrush);
        }

        // Display the text associated with the item.

        ListView_GetItemText(m_hwndChild, lpdis->itemID,
                             0, Buffer, sizeof(Buffer));

        GetTextMetrics(lpdis->hDC, &tm);

        y = (lpdis->rcItem.bottom + lpdis->rcItem.top -
             tm.tmHeight) / 2;

        RECT rc = lpdis->rcItem;

        if (m_SplitWindowAtItem && (lpdis->itemID == m_SplitWindowAtItem))
        {
            POINT pt = {rc.left, rc.top-1};

            DrawHorizLine(lpdis->hDC, pt, rc.right - rc.left, 2);

            rc.top++;
        }

        LV_COLUMN lvc;
        lvc.mask = LVCF_FMT | LVCF_WIDTH;

        RECT rc2;
        ListView_GetSubItemRect(m_hwndChild, lpdis->itemID,
                                1, LVIR_BOUNDS,
                                &rc2);

        rc.right = rc2.left;

        DrawTreeItem(lpdis->hDC, lpdis->itemID, rc, &IndentOffset);

        while (*pszText && *pszText == ' ')
        {
            ++pszText;
        }
        pszText = MakeShortString(lpdis->hDC, pszText, rc.right-rc.left,
                                  2 + IndentOffset, &ActualWidth);
        TextOut(lpdis->hDC, rc.left + IndentOffset, y,
                pszText, strlen(pszText));

        if (m_MaxNameWidth < (2 + IndentOffset*3/2 + ActualWidth))
        {
            m_MaxNameWidth = 2 + IndentOffset*3/2 + ActualWidth;
        }

        for (Col = 1;
             //ListView_GetColumn(m_hwndChild, Col, &lvc);
             Col < (int) m_NumCols;
             Col++)
        {
            if (!ListView_GetSubItemRect(m_hwndChild,
                                         lpdis->itemID,
                                         Col,
                                         LVIR_BOUNDS,
                                         &rc))
            {
                // invalid coulmn
                break;
            }

            ListView_GetItemText(m_hwndChild, lpdis->itemID,
                                 Col, Buffer, sizeof(Buffer));
            int nRetLen = strlen(Buffer);

            if (nRetLen == 0)
            {
                pszText = "";
            }
            else
            {
                pszText = MakeShortString(lpdis->hDC, Buffer,
                                          rc.right - rc.left, 2, &ActualWidth);
            }

            if ((Col == 1) &&
                (m_NumSymsDisplayed > lpdis->itemID))
            {
                if (m_pWinSyms[lpdis->itemID].Flags & ITEM_VALUE_CHANGED)
                {
                    SetTextColor(lpdis->hDC,
                                 g_Colors[COL_CHANGED_DATA_TEXT].Color);
                }
            }

            TextOut(lpdis->hDC, rc.left + 2, y, pszText, strlen(pszText));

            if (m_pWinSyms[lpdis->itemID].Flags & ITEM_VALUE_CHANGED)
            {
                SetTextColor(lpdis->hDC, TextColor);
            }
        }

        // restore text and back ground color of list box's selection
        SetTextColor(lpdis->hDC, dwOldTextColor);
        SetBkColor(lpdis->hDC, dwOldBkColor);

        return TRUE;
    }

    case ODA_FOCUS:
        // Do not process focus changes. The focus caret
        // (outline rectangle) indicates the selection.
        break;
    }

    return DefMDIChildProc(m_Win, WM_DRAWITEM, wParam, lParam);
}

void
SYMWIN_DATA::SyncUiWithFlags(ULONG Changed)
{
    if (Changed & (1 << SYMWIN_TBB_TYPECAST))
    {
        SendMessage(m_Toolbar, TB_SETSTATE, SYMWIN_TBB_TYPECAST,
                    TBSTATE_ENABLED |
                    (m_DisplayTypes ? TBSTATE_CHECKED : 0));
    }
    if (Changed & (1 << SYMWIN_TBB_OFFSETS))
    {
        SendMessage(m_Toolbar, TB_SETSTATE, SYMWIN_TBB_OFFSETS,
                    TBSTATE_ENABLED |
                    (m_DisplayOffsets ? TBSTATE_CHECKED : 0));
    }
}

//
// WATCHWIN_DATA methods
//

extern IDebugSymbolGroup * g_pDbgWatchSymbolGroup;
WATCHWIN_DATA::WATCHWIN_DATA()
    : SYMWIN_DATA(&g_pDbgWatchSymbolGroup)
{
    m_wFlags   = DL_EDIT_LEFTPANE;
    m_enumType = WATCH_WINDOW;
}

void
WATCHWIN_DATA::Validate()
{
    SYMWIN_DATA::Validate();

    Assert(WATCH_WINDOW == m_enumType);
}

HRESULT
WATCHWIN_DATA::ReadState(void)
{
    m_pDbgSymbolGroup = &g_pDbgWatchSymbolGroup;
    return SYMWIN_DATA::ReadState();
}

#define WATCH_WRKSPC_TAG          0x40404040
//
// Workspace
//     0                4        8
//     WATCH_WRKSPC_TAG NUM syms [Null terminated names]
//
ULONG
WATCHWIN_DATA::GetWorkspaceSize(void)
{
    ULONG i;
    ULONG Size = 2*sizeof(ULONG);
    PDEBUG_SYMBOL_PARAMETERS SymParam;

    for (SymParam = GetSymParam(), i = 0;
         i < m_NumSymsDisplayed;
         SymParam++, i++)
    {
        if (IsRootSym(SymParam))
        {
            CHAR Text[500] = {0};

            ListView_GetItemText(m_hwndChild, i, 0, Text, sizeof(Text));

            Size += strlen(Text) + 1;
        }
    }
    return SYMWIN_DATA::GetWorkspaceSize() + Size;
}

PUCHAR
WATCHWIN_DATA::SetWorkspace(PUCHAR Data)
{
    Data = SYMWIN_DATA::SetWorkspace(Data);
    PULONG pNumSyms, watchWrkspc = (PULONG) Data;

    *watchWrkspc  = WATCH_WRKSPC_TAG;
    pNumSyms = (PULONG) (Data + sizeof(ULONG));
    *pNumSyms = 0;
    Data += 2 * sizeof(ULONG);

    ULONG i;
    PDEBUG_SYMBOL_PARAMETERS SymParam;

    for (SymParam = GetSymParam(), i = 0;
         i < m_NumSymsDisplayed;
         SymParam++, i++)
    {
        if (IsRootSym(SymParam))
        {
            CHAR Text[500] = {0}, *pName = &Text[0];

            ListView_GetItemText(m_hwndChild, i, 0, Text, sizeof(Text));
            strcpy((PCHAR) Data, pName);
            Data += strlen(pName) + 1;
            *pNumSyms = *pNumSyms + 1;
        }
    }

    return Data;
}

PUCHAR
WATCHWIN_DATA::ApplyWorkspace1(PUCHAR Data, PUCHAR End)
{
    Data = SYMWIN_DATA::ApplyWorkspace1(Data, End);

    if (*((PULONG) Data) == WATCH_WRKSPC_TAG &&
        End >= Data + 2 * sizeof(ULONG))
    {
        Data += sizeof(ULONG);

        ULONG NumSyms = *((PULONG) Data);
        ULONG i = 0;
        Data += sizeof(ULONG);

        PCHAR Name = (PCHAR) Data, pCopyName = &m_ChangedName[0];

        while ((Data < End) && (i<NumSyms))
        {
            UIC_SYMBOL_WIN_DATA* WatchItem;

            while (*Name == ' ')
            {
                // eat out space in begining
                ++Name;
            }
            if (pCopyName + strlen(Name) >=
                &m_ChangedName[sizeof(m_ChangedName) - 1])
            {
                Data = End;
                break;
            }
            strcpy(pCopyName, Name);
            WatchItem = StartStructCommand(UIC_SYMBOL_WIN);
            if (WatchItem != NULL)
            {
                WatchItem->Type = ADD_SYMBOL_WIN;
                WatchItem->pSymbolGroup = m_pDbgSymbolGroup;
                WatchItem->u.Add.Name = pCopyName;
                WatchItem->u.Add.Index = i;
                FinishCommand();
            }
            ++i;
            pCopyName += strlen(pCopyName) + 1;
            while (*Data != 0)
            {
                ++Data;
            }
            ++Data;
            Name = (PCHAR) Data;
        }
    }
    return Data;
}

//
// LOCALSWIN_DATA methods
//
extern IDebugSymbolGroup * g_pDbgLocalSymbolGroup;
LOCALSWIN_DATA::LOCALSWIN_DATA()
    : SYMWIN_DATA(&g_pDbgLocalSymbolGroup)
{
    m_enumType = LOCALS_WINDOW;
}

void
LOCALSWIN_DATA::Validate()
{
    DUALLISTWIN_DATA::Validate();

    Assert(LOCALS_WINDOW == m_enumType);
}

LOCALSWIN_DATA::~LOCALSWIN_DATA()
{
}

BOOL
LOCALSWIN_DATA::OnCreate(void)
{

    if (!SYMWIN_DATA::OnCreate())
    {
        return FALSE;
    }

    return TRUE;

}

HRESULT
LOCALSWIN_DATA::ReadState(void)
{
    HRESULT Hr;
    IDebugSymbolGroup *pLocalSymbolGroup;

    if (g_ScopeChanged)
    {
        //
        // Get the new locals
        //
        if ((Hr = g_pDbgSymbols->GetScopeSymbolGroup(DEBUG_SCOPE_GROUP_LOCALS,
                                                    g_pDbgLocalSymbolGroup,
                                                    &pLocalSymbolGroup)) == E_NOTIMPL)
        {
            // Older engine version
            Hr = g_pDbgSymbols->GetScopeSymbolGroup(DEBUG_SCOPE_GROUP_ALL,
                                                    g_pDbgLocalSymbolGroup,
                                                    &pLocalSymbolGroup);
        }
        if (Hr == S_OK)
        {
            g_pDbgLocalSymbolGroup = pLocalSymbolGroup;
            m_pDbgSymbolGroup = &g_pDbgLocalSymbolGroup;
            g_ScopeChanged = FALSE;
        }
        else
        {
            //
            // Keep the old values
            //
            return E_PENDING;
        }
    }

    return SYMWIN_DATA::ReadState();
}

//
// CPUWIN_DATA methods
//

HMENU CPUWIN_DATA::s_ContextMenu;

CPUWIN_DATA::CPUWIN_DATA()
    : DUALLISTWIN_DATA(1024)
{
    m_wFlags |= DL_CUSTOM_ITEMS;
    m_enumType = CPU_WINDOW;
    m_ProcType = IMAGE_FILE_MACHINE_UNKNOWN;
    m_NamesProcType = IMAGE_FILE_MACHINE_UNKNOWN;
    m_NumRegisters = 0;
    m_CheckChanged = FALSE;
}

void
CPUWIN_DATA::Validate()
{
    DUALLISTWIN_DATA::Validate();

    Assert(CPU_WINDOW == m_enumType);
}

HRESULT
CPUWIN_DATA::ReadState(void)
{
    HRESULT Status;
    PDEBUG_VALUE OldVals;
    ULONG NumOld, NumReg;
    PDEBUG_VALUE Vals;
    PDEBUG_VALUE Coerced;
    PULONG Types;
    PBOOL Changed;
    ULONG ProcType;
    BOOL ProcChanged;

    NumOld = m_NumRegisters;

    if ((Status = g_pDbgRegisters->
         GetNumberRegisters(&NumReg)) != S_OK ||
        (Status = g_pDbgControl->
         GetEffectiveProcessorType(&ProcType)) != S_OK)
    {
        return Status;
    }

    ProcChanged = ProcType != m_ProcType;

    Empty();

    //
    // Retrieve all register values and diff them.
    // Also keep space for a coercion type map and
    // temporary coerced values.
    //

    OldVals = (PDEBUG_VALUE)
        AddData(NumReg * (3 * sizeof(DEBUG_VALUE) + sizeof(ULONG) +
                          sizeof(BOOL)));
    if (OldVals == NULL)
    {
        return E_OUTOFMEMORY;
    }
    Changed = (PBOOL)(OldVals + NumReg);
    Coerced = (PDEBUG_VALUE)(Changed + NumReg);
    Vals = Coerced + NumReg;
    Types = (PULONG)(Vals + NumReg);

    Status = g_pDbgRegisters->GetValues(NumReg, NULL, 0, Vals);
    if (Status != S_OK)
    {
        return Status;
    }

    ULONG i;

    // Coerce values into known types.
    // If it's an integer value coerce it to 64-bit.
    // If it's a float value coerce to 64-bit also,
    // which loses precision but has CRT support for
    // formatting.
    for (i = 0; i < NumReg; i++)
    {
        if (Vals[i].Type >= DEBUG_VALUE_INT8 &&
            Vals[i].Type <= DEBUG_VALUE_INT64)
        {
            Types[i] = DEBUG_VALUE_INT64;
        }
        else if (Vals[i].Type >= DEBUG_VALUE_FLOAT32 &&
                 Vals[i].Type <= DEBUG_VALUE_FLOAT128)
        {
            Types[i] = DEBUG_VALUE_FLOAT64;
        }
        else if (Vals[i].Type == DEBUG_VALUE_VECTOR64 ||
                 Vals[i].Type == DEBUG_VALUE_VECTOR128)
        {
            Types[i] = Vals[i].Type;
        }
        else
        {
            // Unknown type.
            return E_INVALIDARG;
        }
    }

    if ((Status = g_pDbgControl->
        CoerceValues(NumReg, Vals, Types, Coerced)) != S_OK)
    {
        return Status;
    }

    // Diff new values against the old.
    for (i = 0; i < NumReg; i++)
    {
        // Ignore differences if the processor has changed.
        if (!ProcChanged && i < NumOld)
        {
            switch(Types[i])
            {
            case DEBUG_VALUE_INT64:
                Changed[i] = Coerced[i].I64 != OldVals[i].I64;
                break;
            case DEBUG_VALUE_FLOAT64:
                Changed[i] = Coerced[i].F64 != OldVals[i].F64;
                break;
            case DEBUG_VALUE_VECTOR64:
                Changed[i] = memcmp(Coerced[i].RawBytes, OldVals[i].RawBytes,
                                    8);
                break;
            case DEBUG_VALUE_VECTOR128:
                Changed[i] = memcmp(Coerced[i].RawBytes, OldVals[i].RawBytes,
                                    16);
                break;
            }
        }
        else
        {
            Changed[i] = FALSE;
        }
    }

    // Copy new values into permanent storage area.
    memmove(OldVals, Coerced, NumReg * sizeof(*Vals));

    // Trim off temporary information.
    RemoveTail(NumReg * (2 * sizeof(DEBUG_VALUE) + sizeof(ULONG)));

    m_NumRegisters = NumReg;
    m_ProcType = ProcType;
    if (ProcChanged)
    {
        UpdateBufferWindows(1 << CPU_WINDOW, UPDATE_REG_NAMES);
    }

    return Status;
}

#define CPU_CONTEXT_ID_BASE 0x100

TBBUTTON g_CpuTbButtons[] =
{
    TEXT_TB_BTN(ID_CUSTOMIZE, "Customize...", 0),
    SEP_TB_BTN(),
    TEXT_TB_BTN(ID_SHOW_TOOLBAR, "Toolbar", 0),
};

#define NUM_CPU_MENU_BUTTONS \
    (sizeof(g_CpuTbButtons) / sizeof(g_CpuTbButtons[0]))
#define NUM_CPU_TB_BUTTONS \
    (NUM_CPU_MENU_BUTTONS - 2)

HMENU
CPUWIN_DATA::GetContextMenu(void)
{
    //
    // We only keep one menu around for all CPU windows
    // so apply the menu check state for this particular
    // window.
    // In reality there's only one CPU window anyway,
    // but this is a good example of how to handle
    // multi-instance windows.
    //

    CheckMenuItem(s_ContextMenu, ID_SHOW_TOOLBAR + CPU_CONTEXT_ID_BASE,
                  MF_BYCOMMAND | (m_ShowToolbar ? MF_CHECKED : 0));

    return s_ContextMenu;
}

void
CPUWIN_DATA::OnContextMenuSelection(UINT Item)
{
    StateBuffer* NameBuf;

    Item -= CPU_CONTEXT_ID_BASE;

    switch(Item)
    {
    case ID_CUSTOMIZE:
        NameBuf = GetRegisterNames(m_ProcType);
        if (!NameBuf ||
            (NameBuf->UiLockForRead() != S_OK))
        {
            ErrorBox(NULL, 0, ERR_No_Register_Names);
        }
        else
        {
            int Res =
                StartDialog(IDD_DLG_REG_CUSTOMIZE, DlgProc_RegCustomize,
                            (LPARAM)NameBuf);
            UnlockStateBuffer(NameBuf);
            if (Res == IDOK)
            {
                UpdateNames(TRUE);
                OnUpdate(UPDATE_BUFFER);
            }
        }
        break;
    case ID_SHOW_TOOLBAR:
        SetShowToolbar(!m_ShowToolbar);
        break;
    }
}

BOOL
CPUWIN_DATA::OnCreate(void)
{
    if (s_ContextMenu == NULL)
    {
        s_ContextMenu = CreateContextMenuFromToolbarButtons
            (NUM_CPU_MENU_BUTTONS, g_CpuTbButtons, CPU_CONTEXT_ID_BASE);
        if (s_ContextMenu == NULL)
        {
            return FALSE;
        }
    }

    if (!DUALLISTWIN_DATA::OnCreate())
    {
        return FALSE;
    }

    m_Toolbar = CreateWindowEx(0, TOOLBARCLASSNAME, NULL,
                    WS_CHILD | WS_VISIBLE |
                    TBSTYLE_WRAPABLE | TBSTYLE_LIST | CCS_TOP,
                    0, 0, m_Size.cx, 0, m_Win, (HMENU)ID_TOOLBAR,
                    g_hInst, NULL);
    if (m_Toolbar == NULL)
    {
        return FALSE;
    }
    SendMessage(m_Toolbar, TB_BUTTONSTRUCTSIZE, sizeof(TBBUTTON), 0);
    SendMessage(m_Toolbar, TB_ADDBUTTONS, NUM_CPU_TB_BUTTONS,
        (LPARAM)&g_CpuTbButtons);
    SendMessage(m_Toolbar, TB_AUTOSIZE, 0, 0);

    RECT Rect;
    GetClientRect(m_Toolbar, &Rect);
    m_ToolbarHeight = Rect.bottom - Rect.top + GetSystemMetrics(SM_CYEDGE);
    m_ShowToolbar = TRUE;

    SendMessage(m_hwndChild, WM_SETREDRAW, FALSE, 0);

    RECT        rc;
    LV_COLUMN   lvc = {0};

    GetClientRect(m_hwndChild, &rc);
    rc.right -= rc.left + GetSystemMetrics(SM_CXVSCROLL);

    //initialize the columns
    lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_SUBITEM | LVCF_TEXT;
    lvc.fmt = LVCFMT_LEFT;
    lvc.iSubItem = 0;

    // Keep the register name column narrow since most names are short.
    lvc.cx = m_Font->Metrics.tmAveCharWidth * 7;
    if (lvc.cx > rc.right / 2)
    {
        lvc.cx = rc.right / 2;
    }
    lvc.pszText = _T("Reg");
    Dbg( (0 == ListView_InsertColumn(m_hwndChild, 0, &lvc)) );

    // Give the rest of the space to the value.
    lvc.cx = rc.right - lvc.cx;
    lvc.pszText = _T("Value");
    Dbg( (1 == ListView_InsertColumn(m_hwndChild, 1, &lvc)) );

    ListView_SetExtendedListViewStyle(m_hwndChild,
        LVS_EX_GRIDLINES | LVS_EX_FULLROWSELECT
        );

    UpdateNames(FALSE);

    SendMessage(m_hwndChild, WM_SETREDRAW, TRUE, 0);
    InvalidateRect(m_hwndChild, NULL, TRUE);

    return TRUE;
}

LRESULT
CPUWIN_DATA::OnCommand(
    WPARAM wParam,
    LPARAM lParam
    )
{
    if ((HWND)lParam == m_Toolbar)
    {
        OnContextMenuSelection(LOWORD(wParam) + CPU_CONTEXT_ID_BASE);
        return 0;
    }

    return DUALLISTWIN_DATA::OnCommand(wParam, lParam);
}

void
CPUWIN_DATA::OnSize(void)
{
    DUALLISTWIN_DATA::OnSize();

    // The register label column stays fixed in size so
    // resize the value column to fit the remaining space.
    ListView_SetColumnWidth(m_hwndChild, 1, LVSCW_AUTOSIZE_USEHEADER);
}

void
CPUWIN_DATA::OnUpdate(UpdateType Type)
{
    if (Type == UPDATE_EXEC)
    {
        // Disallow editing when the debuggee is running.
        if (g_ExecStatus == DEBUG_STATUS_BREAK)
        {
            m_wFlags |= DL_EDIT_SECONDPANE;
            ListView_SetTextBkColor(m_hwndChild, g_Colors[COL_PLAIN].Color);
        }
        else
        {
            m_wFlags &= ~DL_EDIT_SECONDPANE;
            ListView_SetTextBkColor(m_hwndChild,
                                    g_Colors[COL_DISABLED_WINDOW].Color);
        }
        InvalidateRect(m_hwndChild, NULL, FALSE);
        return;
    }
    else if (Type == UPDATE_START_SESSION ||
             Type == UPDATE_END_SESSION)
    {
        m_ProcType = IMAGE_FILE_MACHINE_UNKNOWN;
        m_NumRegisters = 0;
        m_CheckChanged = Type != UPDATE_START_SESSION;
        return;
    }
    else if (Type == UPDATE_REG_NAMES)
    {
        UpdateNames(FALSE);
        return;
    }
    else if (Type != UPDATE_BUFFER)
    {
        return;
    }

    PDEBUG_VALUE Vals = NULL;
    PBOOL Changed = NULL;
    HRESULT Status;
    RegisterNamesStateBuffer* NameBuf = GetRegisterNames(m_ProcType);
    PTSTR RegNames = NULL;
    PULONG RegTypes = NULL;

    SendMessage(m_hwndChild, WM_SETREDRAW, FALSE, 0);

    Status = UiLockForRead();
    if (Status == S_OK)
    {
        Vals = (PDEBUG_VALUE)m_Data;
        Changed = (PBOOL)(Vals + m_NumRegisters);
    }

    if (NameBuf &&
        NameBuf->UiLockForRead() == S_OK)
    {
        RegTypes = (PULONG)NameBuf->GetDataBuffer();
        RegNames = (PTSTR)NameBuf->GetDataBuffer() +
            NameBuf->m_NamesOffset;
    }
    
    if (NameBuf &&
        (NameBuf->m_Flags & REGCUST_CHANGED_FIRST))
    {
        ULONG Idx = 0;

        // Set the changed values first.
        Idx = SetRegVals(Status, Vals, Changed, NameBuf, RegTypes,
                         RegNames, Idx, TRUE, TRUE);
        // Set the remainder.
        Idx = SetRegVals(Status, Vals, Changed, NameBuf, RegTypes,
                         RegNames, Idx, TRUE, FALSE);
    }
    else
    {
        SetRegVals(Status, Vals, Changed, NameBuf, RegTypes,
                   NULL, 0, FALSE, FALSE);
    }

    if (RegTypes)
    {
        UnlockStateBuffer(NameBuf);
    }

    if (Status == S_OK)
    {
        UnlockStateBuffer(this);
    }

    SendMessage(m_hwndChild, WM_SETREDRAW, TRUE, 0);
    InvalidateRect(m_hwndChild, NULL, TRUE);
    m_CheckChanged = TRUE;
}

ULONG
CPUWIN_DATA::SetRegVals(HRESULT LockStatus,
                        PDEBUG_VALUE Vals,
                        PBOOL Changed,
                        RegisterNamesStateBuffer* NameBuf,
                        PULONG RegTypes,
                        PTSTR RegNames,
                        ULONG EntryIdx,
                        BOOL MatchChanged,
                        BOOL MatchChangedVal)
{
    ULONG i;
    PDEBUG_VALUE Val;
    TCHAR TextBuf[256];
    PTSTR Str;
    BOOL ChangeFlag;
    USHORT EngReg;
    ULONG RegType;
    
    for (i = 0; i < m_NumRegisters; i++)
    {
        ChangeFlag = FALSE;
        EngReg = 0xffff;
        RegType = DEBUG_VALUE_INT64;

        if (LockStatus == S_FALSE)
        {
            _tcscpy(TextBuf, _T("Retrieving"));
        }
        else if (FAILED(LockStatus) || !Vals || !NameBuf)
        {
            _tcscpy(TextBuf, _T("Error"));
        }
        else
        {
            EngReg = NameBuf->MapUserToEngine(i);

            RegType = RegTypes[EngReg * 2];
            if ((NameBuf->m_Flags & REGCUST_NO_SUBREG) &&
                (RegTypes[EngReg * 2 + 1] & DEBUG_REGISTER_SUB_REGISTER))
            {
                continue;
            }
            
            Val = Vals + EngReg;
            // If this is a new session consider everything
            // unchanged since comparisons may be against
            // values from the previous session.
            if (m_CheckChanged)
            {
                ChangeFlag = Changed[EngReg];
            }

            if (MatchChanged && ChangeFlag != MatchChangedVal)
            {
                continue;
            }
            
            // Buffer values are coerced into known types.
            switch(Val->Type)
            {
            case DEBUG_VALUE_INT64:
                CPFormatMemory(TextBuf, _tsizeof(TextBuf),
                               (LPBYTE)&Val->I64, 64, fmtUInt, g_NumberRadix);
                break;
            case DEBUG_VALUE_FLOAT64:
                CPFormatMemory(TextBuf, _tsizeof(TextBuf),
                               (LPBYTE)&Val->F64, 64, fmtFloat, 10);
                break;
            case DEBUG_VALUE_VECTOR64:
                // Assume they want it as v4i16.
                Str = TextBuf;
                CPFormatMemory(Str, _tsizeof(TextBuf) - (ULONG)(Str - TextBuf),
                               (LPBYTE)&Val->VI16[3], 16, fmtUInt,
                               g_NumberRadix);
                Str += strlen(Str);
                *Str++ = ':';
                CPFormatMemory(Str, _tsizeof(TextBuf) - (ULONG)(Str - TextBuf),
                               (LPBYTE)&Val->VI16[2], 16, fmtUInt,
                               g_NumberRadix);
                Str += strlen(Str);
                *Str++ = ':';
                CPFormatMemory(Str, _tsizeof(TextBuf) - (ULONG)(Str - TextBuf),
                               (LPBYTE)&Val->VI16[1], 16, fmtUInt,
                               g_NumberRadix);
                Str += strlen(Str);
                *Str++ = ':';
                CPFormatMemory(Str, _tsizeof(TextBuf) - (ULONG)(Str - TextBuf),
                               (LPBYTE)&Val->VI16[0], 16, fmtUInt,
                               g_NumberRadix);
                break;
            case DEBUG_VALUE_VECTOR128:
                // Assume they want it as v4f32.
                Str = TextBuf;
                CPFormatMemory(Str, _tsizeof(TextBuf) - (ULONG)(Str - TextBuf),
                               (LPBYTE)&Val->VF32[3], 32, fmtFloat, 10);
                Str += strlen(Str);
                *Str++ = ':';
                CPFormatMemory(Str, _tsizeof(TextBuf) - (ULONG)(Str - TextBuf),
                               (LPBYTE)&Val->VF32[2], 32, fmtFloat, 10);
                Str += strlen(Str);
                *Str++ = ':';
                CPFormatMemory(Str, _tsizeof(TextBuf) - (ULONG)(Str - TextBuf),
                               (LPBYTE)&Val->VF32[1], 32, fmtFloat, 10);
                Str += strlen(Str);
                *Str++ = ':';
                CPFormatMemory(Str, _tsizeof(TextBuf) - (ULONG)(Str - TextBuf),
                               (LPBYTE)&Val->VF32[0], 32, fmtFloat, 10);
                break;
            default:
                Assert(FALSE);
                break;
            }
        }

        ULONG ItemFlags = GetItemFlags(EntryIdx);

        ItemFlags &= ~ITEM_USER_FLAGS;
        ItemFlags |= RegToFlags(EngReg);
        
        if (RegType >= DEBUG_VALUE_FLOAT32 &&
            RegType <= DEBUG_VALUE_FLOAT128)
        {
            ItemFlags |= ITEM_FLOATING_POINT;
        }
        else
        {
            ItemFlags &= ~ITEM_FLOATING_POINT;
        }

        if (ChangeFlag)
        {
            ItemFlags |= ITEM_CHANGED;
        }
        else
        {
            ItemFlags &= ~ITEM_CHANGED;
        }

        SetItemFlags(EntryIdx, ItemFlags);

        if (RegNames)
        {
            PTSTR Name = RegNames;
            while (EngReg-- > 0)
            {
                Name += strlen(Name) + 1;
            }

            ListView_SetItemText(m_hwndChild, EntryIdx, 0, Name);
        }
        
        ListView_SetItemText(m_hwndChild, EntryIdx, 1, TextBuf);

        EntryIdx++;
    }

    return EntryIdx;
}

void
CPUWIN_DATA::ItemChanged(int Item, PCSTR Text)
{
    UIC_SET_REG_DATA* SetRegData;
    ULONG ItemFlags = GetItemFlags(Item);
    
    USHORT Reg = FlagsToReg(ItemFlags);
    if (Reg == 0xffff)
    {
        // Invalid register.
        return;
    }

    SetRegData = StartStructCommand(UIC_SET_REG);
    if (SetRegData != NULL)
    {
        SetRegData->Reg = Reg;

        // Default the guess about the value type based
        // on whether the value includes a decimal point
        // or not.  If we can access the stored register
        // description information we'll use that to
        // override.
        BOOL IsFloat = strchr(Text, '.') != NULL;

        if (ItemFlags & ITEM_FLOATING_POINT)
        {
            IsFloat = TRUE;
        }

        if (IsFloat)
        {
            SetRegData->Val.Type = DEBUG_VALUE_FLOAT64;
            if (sscanf(Text, "%lf", &SetRegData->Val.F64) != 1)
            {
                SetRegData->Val.F64 = 0.0;
            }
        }
        else
        {
            SetRegData->Val.Type = DEBUG_VALUE_INT64;
            switch(g_NumberRadix)
            {
            case 10:
                if (sscanf(Text, "%I64d", &SetRegData->Val.I64) != 1)
                {
                    SetRegData->Val.I64 = 0;
                }
                break;
            default:
                if (sscanf(Text, "%I64x", &SetRegData->Val.I64) != 1)
                {
                    SetRegData->Val.I64 = 0;
                }
                break;
            }
            // XXX drewb - What about IA64 NAT bits?
            SetRegData->Val.Nat = FALSE;
        }

        FinishCommand();
    }
}

LRESULT
CPUWIN_DATA::OnCustomItem(ULONG SubItem, LPNMLVCUSTOMDRAW Custom)
{
    if (SubItem == 1)
    {
        // Check changed flag stored in lParam.
        if (Custom->nmcd.lItemlParam & ITEM_CHANGED)
        {
            Custom->clrText = g_Colors[COL_CHANGED_DATA_TEXT].Color;
        }
    }
    return CDRF_NOTIFYSUBITEMDRAW;
}

void
CPUWIN_DATA::UpdateNames(BOOL FullUpdate)
{
    ULONG i;
    ULONG EntryIdx = 0;
    PSTR Name;
    LVITEM LvItem = {0};
    RegisterNamesStateBuffer* NameBuf;
    PULONG RegTypes = NULL;
    PSTR RegNames = NULL;
    ULONG ProcType = m_ProcType;
    BOOL NameChange = FullUpdate || ProcType != m_NamesProcType;

    //
    // This routine has two primary functions: to set
    // up the register window properly for a register set
    // and also to set the register names properly.
    // In the first case the register window must be cleared
    // and all items recreated for the given processor type.
    // During this operation the register names for the given
    // processor type may not have been retrieved yet, so
    // all of the register names will be set as unknown.  The
    // important part of the operation is then just creating
    // the proper number of items.  A later update will come
    // through when the names are retrieved and at that point
    // a simple name-label-only update will occur.
    //

    NameBuf = GetRegisterNames(ProcType);
    if (NameBuf)
    {
        // If the entries are being sorted by change the
        // names will get updated there and we do not
        // want to do it here.
        if (!NameChange && (NameBuf->m_Flags & REGCUST_CHANGED_FIRST))
        {
            return;
        }

        if (NameBuf->UiLockForRead() == S_OK)
        {
            RegTypes = (PULONG)NameBuf->GetDataBuffer();
            RegNames = (PSTR)NameBuf->GetDataBuffer() +
                NameBuf->m_NamesOffset;
        }
    }

    SendMessage(m_hwndChild, WM_SETREDRAW, FALSE, 0);

    if (NameChange)
    {
        ListView_DeleteAllItems(m_hwndChild);
    }

    LvItem.mask = LVIF_TEXT;

    for (i = 0; i < m_NumRegisters; i++)
    {
        if (RegNames == NULL)
        {
            Name = _T("Unknown");
        }
        else
        {
            ULONG NameIdx = NameBuf->MapUserToEngine(i);

            if ((NameBuf->m_Flags & REGCUST_NO_SUBREG) &&
                (RegTypes[NameIdx * 2 + 1] & DEBUG_REGISTER_SUB_REGISTER))
            {
                continue;
            }
            
            Name = RegNames;
            while (NameIdx-- > 0)
            {
                Name += strlen(Name) + 1;
            }
        }

        LvItem.pszText = Name;
        LvItem.iItem = EntryIdx;
        if (NameChange)
        {
            ListView_InsertItem(m_hwndChild, &LvItem);
            SetItemFlags(EntryIdx, RegToFlags(0xffff));
        }
        else
        {
            ListView_SetItemText(m_hwndChild, EntryIdx, 0, Name);
        }

        EntryIdx++;
    }

    if (NameBuf && RegNames)
    {
        UnlockStateBuffer(NameBuf);
    }

    SendMessage(m_hwndChild, WM_SETREDRAW, TRUE, 0);
    m_NamesProcType = ProcType;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\windbg\dialogs.h ===
#ifdef IDC_STATIC
#undef IDC_STATIC
#endif
#define IDC_STATIC      (-1)





#define ID_SETBREAK_COMMAND                2200
#define ID_SETBREAK_THREAD                 2202
#define ID_SETBREAK_BREAKPOINT             2203
#define ID_SETBREAK_REMOVE                 2204
#define ID_SETBREAK_REMOVEALL              2205
#define ID_SETBREAK_DISABLE                2206
#define ID_SETBREAK_ENABLE                 2207
#define ID_SETBREAK_CONDITION              2208

#define IDD_DLG_FILEOPEN_EXPLORER_EXTENSION_EXE_ARGS  2250
#define IDC_EDIT_ARGS                                 2251
#define IDC_EXEOPEN_CHILD_PROCESSES                   2252
#define IDC_EXEOPEN_START_DIR                         2253

#define IDD_DLG_KERNEL_COM                 2300
#define IDC_KD_BAUDRATE                    2301
#define IDC_KD_PORT                        2302

#define IDD_DLG_KERNEL_1394                2310
#define IDC_KD_1394_CHANNEL                2311

#define IDD_DLG_KERNEL_LOCAL               2320

#define IDD_DLG_CONNECTTOREMOTE            2400
#define IDC_REM_CONNECT_LABEL              2401
#define IDC_REM_CONNECT                    2402
#define IDC_REM_BROWSE                     2403

#define IDD_DLG_BROWSE_SERVERS             2450
#define IDC_BROWSE_MACHINE                 2451
#define IDC_BROWSE_REFRESH                 2452
#define IDC_BROWSE_SERVERS_LIST            2453

#define IDD_DLG_SYMBOLS                    2500
#define IDC_SYMPATH_LABEL                  2501
#define IDC_SYMPATH                        2502
#define IDC_PATH_BROWSE                    2503
#define IDC_PATH_RELOAD                    2504

#define IDD_DLG_REG_CUSTOMIZE              2600
#define IDC_REGCUST_ENTRY                  2601
#define IDC_REGCUST_CHANGED_FIRST          2602
#define IDC_REGCUST_NO_SUBREG              2603



#define IDD_DLG_MEMORY                     3012
#define IDD_DLG_BREAKPOINTS                3013
#define IDD_DLG_MEM_PHYSICAL               3014
#define IDD_DLG_MEM_VIRTUAL                3015
#define IDD_DLG_MEM_BUS_DATA               3016
#define IDD_DLG_MEM_CONTROL                3017
#define IDD_DLG_MEM_IO                     3018
#define IDD_DLG_MEM_MSR                    3019


#define IDC_LIST_CALLS                     3255


#define IDC_STATUS_BAR                     4000
#define IDC_TOOLBAR                        4001
#define IDC_RICHEDIT_CMD_HISTORY           4002
#define IDC_RICHEDIT_CMD_EDIT              4003
#define IDC_RICHEDIT_DOC_EDIT              4004
#define IDC_LISTVIEW                       4005

#define IDC_COMBO_MEM_TYPE                 4007
#define IDC_EDIT_MEM_ADDRESS               4008

#define IDC_COMBO_INTERFACE_TYPE           4009
#define IDC_EDIT_ADDRESS_SPACE             4010
#define IDC_EDIT_OFFSET                    4011
#define IDC_COMBO_BUS_DATA_TYPE            4012
#define IDC_EDIT_BUS_NUMBER                4013
#define IDC_EDIT_SLOT_NUMBER               4014
#define IDC_COMBO_DISPLAY_FORMAT           4015
#define IDC_EDIT_PROCESSOR                 4016

#define IDD_DLG_GOTO_LINE                  4100
#define IDC_LINE_ENTRY                     4101

#define IDD_DLG_GOTO_ADDRESS               4200
#define IDC_ADDRESS_ENTRY                  4201

#define IDD_DLG_LOG_FILE                   4300
#define IDC_LOG_FILE_NAME                  4301
#define IDC_LOG_CLOSE                      4302
#define IDC_LOG_APPEND                     4303

#define IDD_DLG_IMAGE_PATH                 4350
#define IDC_IMAGE_PATH                     4351

#define IDD_DLG_SOURCE_PATH                4400
#define IDC_SOURCE_PATH                    4401
#define IDC_LOCAL_SOURCE                   4402

#define IDD_DLG_ATTACH_PROCESS             4450
#define IDC_ATTACH_PID                     4451
#define IDC_ATTACH_PROC_LIST               4452
#define IDC_ATTACH_NONINVASIVE             4453

#define IDD_DLG_EVENT_FILTERS              4499
#define IDD_DLG_EXCEPTION_FILTER           4500
#define IDC_FILTER_ADD                     4501
#define IDC_FILTER_REMOVE                  4502
#define IDC_FILTER_ENABLED                 4503
#define IDC_FILTER_DISABLED                4504
#define IDC_FILTER_OUTPUT                  4505
#define IDC_FILTER_IGNORE                  4506
#define IDC_FILTERS                        4507
#define IDC_FILTER_CODE                    4508
#define IDC_FILTER_HANDLED                 4509
#define IDC_FILTER_NOT_HANDLED             4510
#define IDC_FILTER_ARGUMENT                4511
#define IDD_DLG_FILTER_ARGUMENT            4512
#define IDD_DLG_FILTER_COMMAND             4513
#define IDC_FILTER_COMMAND                 4514
#define IDC_FILTER_COMMAND2                4515

#define IDD_DLG_OPTIONS                    4550
#define IDC_OPTION_TAB_WIDTH               4551
#define IDC_OPTION_REPEAT_COMMANDS         4552
#define IDC_OPTION_COLOR_LIST              4553
#define IDC_OPTION_COLOR_DISPLAY           4554
#define IDC_OPTION_COLOR_CHANGE            4555
#define IDC_OPTION_DISASM_ACTIVATE_SOURCE  4556
#define IDC_OPTION_AUTO_CMD_SCROLL         4557

#define IDD_DLG_CLEAR_WORKSPACE            4600
#define IDC_CLW_SAVE_LIST                  4601
#define IDC_CLW_CLEAR                      4602
#define IDC_CLW_CLEAR_ALL                  4603
#define IDC_CLW_SAVE                       4604
#define IDC_CLW_SAVE_ALL                   4605
#define IDC_CLW_CLEAR_LIST                 4606

#define IDD_DLG_MODULES                    4625
#define IDC_MODULE_LIST                    4626

#define IDD_DLG_WORKSPACE_IO               4650
#define IDC_WORKSPACE_LIST                 4651
#define IDC_WORKSPACE_NAME                 4652

#define IDD_DLG_ADD_TO_COMMAND_HISTORY     4675
#define IDC_ATCH_TEXT                      4676

#define IDD_DLG_DELETE_WORKSPACES          4700
#define IDC_DELETE_WORKSPACE               4701
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\windbg\docwin.cpp ===
/*++

Copyright (c) 1999-2002  Microsoft Corporation

Module Name:

    docwin.cpp

Abstract:

    This module contains the code for the new doc windows.

--*/

#include "precomp.hxx"
#pragma hdrstop

#include <dbghelp.h>

#define INVOKE_DEFAULT "notepad %f"

ULONG g_TabWidth = 32;
BOOL g_DisasmActivateSource;
char g_EditorInvokeCommand[MAX_PATH + MAX_SOURCE_PATH] = INVOKE_DEFAULT;
char g_EditorUpdateCommand[MAX_PATH + MAX_SOURCE_PATH];

#define DOCWIN_CONTEXT_ID_BASE 0x100

#define DOCWIN_TBB_SET_IP        0
#define DOCWIN_TBB_INVOKE_EDITOR 1
#define DOCWIN_TBB_COPY          2
#define DOCWIN_TBB_EVAL          3
#define DOCWIN_TBB_DT            4
#define DOCWIN_TBB_VIEW_IP       5

TBBUTTON g_DocWinTbButtons[] =
{
    TEXT_TB_BTN(DOCWIN_TBB_SET_IP,
                "Set instruction pointer to current line", 0),
    TEXT_TB_BTN(DOCWIN_TBB_INVOKE_EDITOR, "Edit this file...", 0),
    TEXT_TB_BTN(DOCWIN_TBB_COPY, "Copy", 0),
    TEXT_TB_BTN(DOCWIN_TBB_EVAL, "Evalute selection", 0),
    TEXT_TB_BTN(DOCWIN_TBB_DT, "Display selected type", 0),
    TEXT_TB_BTN(DOCWIN_TBB_VIEW_IP, "Disassemble at current line", 0),
};

#define NUM_DOCWIN_MENU_BUTTONS \
    (sizeof(g_DocWinTbButtons) / sizeof(g_DocWinTbButtons[0]))

HMENU DOCWIN_DATA::s_ContextMenu;

void
RunEditorCommand(PCSTR Command, PCSTR FoundFile, ULONG Line)
{
    char RepCommand[MAX_PATH + MAX_SOURCE_PATH];
    PCSTR Src;
    PSTR Dst;
    
    if (!Command[0])
    {
        return;
    }

    Src = Command;
    Dst = RepCommand;
    while (*Src)
    {
        if (*Src == '%')
        {
            if (*(Src + 1) == 'l' ||
                *(Src + 1) == 'L')
            {
                // Line number.
                Src += 2;
                if ((Dst - RepCommand) + 20 >= sizeof(RepCommand))
                {
                    return;
                }
                sprintf(Dst, "%d", (*(Src + 1) == 'L' ? Line : (Line + 1)));
                Dst += strlen(Dst);
            }
            else if (*(Src + 1) == 'f' ||
                     *(Src + 1) == 'p')
            {
                // File name.
                Src += 2;
                if ((Dst - RepCommand) + strlen(FoundFile) >=
                    sizeof(RepCommand))
                {
                    return;
                }
                strcpy(Dst, FoundFile);
                Dst += strlen(Dst);
            }
            else
            {
                *Dst++ = *Src++;
            }
        }
        else
        {
            *Dst++ = *Src++;
        }
    }
    *Dst = 0;

    STARTUPINFOA Start;
    PROCESS_INFORMATION Info;

    ZeroMemory(&Start, sizeof(Start));
    Start.cb = sizeof(Start);
    
    if (CreateProcessA(NULL, RepCommand, NULL, NULL, FALSE,
                       0, NULL, NULL, &Start, &Info))
    {
        CloseHandle(Info.hProcess);
        CloseHandle(Info.hThread);
    }
}

//
//
//
DOCWIN_DATA::DOCWIN_DATA()
    // State buffer isn't currently used.
    : EDITWIN_DATA(256)
{
    m_enumType = DOC_WINDOW;

    ZeroMemory(m_FoundFile, _tsizeof(m_FoundFile));
    ZeroMemory(m_SymFileBuffer, _tsizeof(m_SymFileBuffer));
    ZeroMemory(m_PathComponent, _tsizeof(m_PathComponent));
    ZeroMemory(&m_LastWriteTime, sizeof(m_LastWriteTime));

    m_FindSel.cpMin = 1;
    m_FindSel.cpMax = 0;
    m_FindFlags = 0;
}

void
DOCWIN_DATA::Validate()
{
    EDITWIN_DATA::Validate();

    Assert(DOC_WINDOW == m_enumType);
}

BOOL
DOCWIN_DATA::SelectedText(PTSTR Buffer, ULONG BufferChars)
{
    return RicheditGetSelectionText(m_hwndChild, Buffer, BufferChars) > 0;
}

BOOL
DOCWIN_DATA::CanGotoLine(void)
{
    return m_TextLines > 0;
}

void
DOCWIN_DATA::GotoLine(ULONG Line)
{
    CHARRANGE Sel;
                
    Sel.cpMin = (LONG)SendMessage(m_hwndChild, EM_LINEINDEX, Line - 1, 0);
    Sel.cpMax = Sel.cpMin;
    SendMessage(m_hwndChild, EM_EXSETSEL, 0, (LPARAM)&Sel);
}

void
DOCWIN_DATA::Find(PTSTR Text, ULONG Flags, BOOL FromDlg)
{
    RicheditFind(m_hwndChild, Text, Flags,
                 &m_FindSel, &m_FindFlags, FromDlg);
}

HRESULT
DOCWIN_DATA::CodeExprAtCaret(PSTR Expr, ULONG ExprSize, PULONG64 Offset)
{
    LRESULT LineChar;
    LONG Line;
    
    LineChar = SendMessage(m_hwndChild, EM_LINEINDEX, -1, 0);
    Line = (LONG)SendMessage(m_hwndChild, EM_EXLINEFROMCHAR, 0, LineChar);
    if (Line < 0)
    {
        return E_INVALIDARG;
    }

    // Convert to one-based.
    Line++;
    
    if (Expr == NULL)
    {
        // Caller is just checking whether it's possible
        // to get an expression or not, such as the
        // menu enable code.  This code always considers
        // it possible since it can't know for sure without
        // a full symbol check.
        return S_OK;
    }
    
    //
    // First attempt to resolve the source line using currently
    // loaded symbols.  This is done directly from the UI
    // thread for synchronous behavior.  The assumption is
    // that turning off symbol loads will limit the execution
    // time to something reasonably quick.
    //

    DEBUG_VALUE Val;
    HRESULT Status;
    
    if (!PrintString(Expr, ExprSize, "@@masm(`<U>%s:%d+`)", m_SymFile, Line))
    {
        return E_INVALIDARG;
    }
    Status = g_pUiControl->Evaluate(Expr, DEBUG_VALUE_INT64, &Val, NULL);

    // Don't preserve the <U>nqualified option in the actual
    // expression returned as it's just a temporary override.
    sprintf(Expr, "@@masm(`%s:%d+`)", m_SymFile, Line);

    if (Status == S_OK)
    {
        if (Offset != NULL)
        {
            *Offset = Val.I64;
        }
        return S_OK;
    }

    ULONG SymOpts;

    if (g_pUiSymbols->GetSymbolOptions(&SymOpts) == S_OK &&
        (SymOpts & SYMOPT_NO_UNQUALIFIED_LOADS))
    {
        // The user isn't allowing unqualified loads so
        // further searches won't help.
        return E_NOINTERFACE;
    }

    // We weren't able to resolve the expression with the
    // existing symbols so we'll need to do a full search.
    // This can be very expensive, so allow the user to cancel.
    if (g_QuietMode == QMODE_DISABLED)
    {
        int Mode = QuestionBox(STR_Unresolved_Source_Expr, MB_YESNOCANCEL);
        if (Mode == IDCANCEL)
        {
            return E_NOINTERFACE;
        }
        else if (Mode == IDYES)
        {
            if (g_pUiControl->Evaluate(Expr, DEBUG_VALUE_INT64,
                                       &Val, NULL) == S_OK)
            {
                if (Offset != NULL)
                {
                    *Offset = Val.I64;
                }
                return S_OK;
            }
            else
            {
                return E_NOINTERFACE;
            }
        }
    }

    // Let the expression go without trying to further resolve it.
    if (Offset != NULL)
    {
        *Offset = DEBUG_INVALID_OFFSET;
    }
    return S_FALSE;
}

void
DOCWIN_DATA::ToggleBpAtCaret(void)
{
    HRESULT Status;
    LRESULT LineChar;
    LONG Line;
    
    LineChar = SendMessage(m_hwndChild, EM_LINEINDEX, -1, 0);
    Line = (LONG)SendMessage(m_hwndChild, EM_EXLINEFROMCHAR, 0, LineChar);
    if (Line < 0)
    {
        return;
    }

    // If we have a breakpoint on this line remove it.
    EDIT_HIGHLIGHT* Hl = GetLineHighlighting(Line);
    if (Hl != NULL && (Hl->Flags & EHL_ANY_BP))
    {
        PrintStringCommand(UIC_SILENT_EXECUTE, "bc %d", (ULONG)Hl->Data);
        return;
    }

    //
    // No breakpoint exists so add a new one.
    //
    
    char CodeExpr[MAX_OFFSET_EXPR];
    ULONG64 Offset;

    Status = CodeExprAtCaret(CodeExpr, DIMA(CodeExpr), &Offset);
    if (FAILED(Status))
    {
        MessageBeep(0);
        ErrorBox(NULL, 0, ERR_No_Code_For_File_Line);
    }
    else
    {
        if (Status == S_OK)
        {
            char SymName[MAX_OFFSET_EXPR];
            ULONG64 Disp;
            
            // Check and see whether this offset maps
            // exactly to a symbol.  If it does, use
            // the symbol name to be more robust in the
            // face of source changes.
            // Symbols should be loaded at this point since
            // we just used them to resolve the source
            // expression that produced Offset, so we
            // can safely do this on the UI thread.
            if (g_pUiSymbols->GetNameByOffset(Offset, SymName, sizeof(SymName),
                                              NULL, &Disp) == S_OK &&
                Disp == 0)
            {
                strcpy(CodeExpr, SymName);
            }
        }
        
        PrintStringCommand(UIC_SILENT_EXECUTE, "bu %s", CodeExpr);
    }
}

HMENU
DOCWIN_DATA::GetContextMenu(void)
{
    return s_ContextMenu;
}

void
DOCWIN_DATA::OnContextMenuSelection(UINT Item)
{
    CHARRANGE Sel;
    int Line;
    TCHAR SelText[256];

    Item -= DOCWIN_CONTEXT_ID_BASE;
    
    switch(Item)
    {
    case DOCWIN_TBB_SET_IP:
        SendMessage(m_hwndChild, EM_EXGETSEL, 0, (LPARAM)&Sel);
        Line = (int)
            SendMessage(m_hwndChild, EM_EXLINEFROMCHAR, 0, Sel.cpMin);
        PrintStringCommand(UIC_SET_IP, "r$ip = @@masm(`%s:%d+`)",
                           m_SymFile, Line + 1);
        break;
    case DOCWIN_TBB_INVOKE_EDITOR:
        SendMessage(m_hwndChild, EM_EXGETSEL, 0, (LPARAM)&Sel);
        Line = (int)
            SendMessage(m_hwndChild, EM_EXLINEFROMCHAR, 0, Sel.cpMin);
        RunEditorCommand(g_EditorInvokeCommand, m_FoundFile, Line);
        break;
    case DOCWIN_TBB_COPY:
        SendMessage(m_hwndChild, WM_COPY, 0, 0);
        break;
    case DOCWIN_TBB_EVAL:
        SendMessage(m_hwndChild, EM_EXGETSEL, 0, (LPARAM)&Sel);
        if (Sel.cpMax > Sel.cpMin)
        {
            if (!RicheditGetSelectionText(m_hwndChild, SelText, DIMA(SelText)))
            {
                break;
            }
        }
        else if (!RicheditGetSourceToken(m_hwndChild, SelText, DIMA(SelText),
                                         &Sel))
        {
            break;
        }
        PrintStringCommand(UIC_EXECUTE, "?? %s", SelText);
        break;
    case DOCWIN_TBB_DT:
        SendMessage(m_hwndChild, EM_EXGETSEL, 0, (LPARAM)&Sel);
        if (Sel.cpMax > Sel.cpMin)
        {
            if (!RicheditGetSelectionText(m_hwndChild, SelText, DIMA(SelText)))
            {
                break;
            }
        }
        else if (!RicheditGetSourceToken(m_hwndChild, SelText, DIMA(SelText),
                                         &Sel))
        {
            break;
        }
        PrintStringCommand(UIC_EXECUTE, "dt %s", SelText);
        break;
    case DOCWIN_TBB_VIEW_IP:
        SendMessage(m_hwndChild, EM_EXGETSEL, 0, (LPARAM)&Sel);
        Line = (int)
            SendMessage(m_hwndChild, EM_EXLINEFROMCHAR, 0, Sel.cpMin);
        PrintStringCommand(UIC_DISPLAY_CODE_EXPR, "@@masm(`%s:%d+`)",
                           m_SymFile, Line + 1);
        break;
    }
}
    
BOOL
DOCWIN_DATA::OnCreate(void)
{
    if (s_ContextMenu == NULL &&
        g_EditorInvokeCommand)
    {
        s_ContextMenu = CreateContextMenuFromToolbarButtons
            (NUM_DOCWIN_MENU_BUTTONS, g_DocWinTbButtons,
             DOCWIN_CONTEXT_ID_BASE);
        if (s_ContextMenu == NULL)
        {
            return FALSE;
        }
    }
    
    if (!EDITWIN_DATA::OnCreate())
    {
        return FALSE;
    }

    SendMessage(m_hwndChild, EM_SETEDITSTYLE,
                SES_XLTCRCRLFTOCR, SES_XLTCRCRLFTOCR);
    SendMessage(m_hwndChild, EM_SETEVENTMASK,
                0, ENM_SELCHANGE | ENM_KEYEVENTS | ENM_MOUSEEVENTS);
    SendMessage(m_hwndChild, EM_SETTABSTOPS, 1, (LPARAM)&g_TabWidth);
    
    return TRUE;
}

LRESULT
DOCWIN_DATA::OnNotify(WPARAM Wpm, LPARAM Lpm)
{
    NMHDR* Hdr = (NMHDR*)Lpm;

    if (Hdr->code == EN_SELCHANGE)
    {
        SELCHANGE* SelChange = (SELCHANGE*)Lpm;
        int Line = (int)
            SendMessage(m_hwndChild, EM_EXLINEFROMCHAR, 0,
                        SelChange->chrg.cpMin);
        LRESULT LineFirst =
            SendMessage(m_hwndChild, EM_LINEINDEX, Line, 0);
        SetLineColumn_StatusBar(Line + 1,
                                (int)(SelChange->chrg.cpMin - LineFirst) + 1);
        return 0;
    }
    else if (Hdr->code == EN_MSGFILTER)
    {
        MSGFILTER* Filter = (MSGFILTER*)Lpm;
        char Token[256];
        CHARRANGE TokenRange;

        if (Filter->msg == WM_LBUTTONDBLCLK &&
            RicheditGetSourceToken(m_hwndChild, Token, DIMA(Token),
                                   &TokenRange))
        {
            SendMessage(m_hwndChild, EM_EXSETSEL, 0, (LPARAM)&TokenRange);
            return 1;
        }
    }
 
    return EDITWIN_DATA::OnNotify(Wpm, Lpm);
}

void
DOCWIN_DATA::OnUpdate(
    UpdateType Type
    )
{
    if (Type == UPDATE_BP ||
        Type == UPDATE_BUFFER ||
        Type == UPDATE_END_SESSION)
    {
        UpdateBpMarks();
    }
    else if (Type == UPDATE_START_SESSION ||
             Type == UPDATE_REFRESH_MODULES)
    {
        // If there's already a message box open we don't
        // want to put up a new one.  This may mean we
        // miss a source file change but it should be relatively
        // uncommon.  If it's a problem we could start up a timer
        // to repost the update later.
        if (g_nBoxCount == 0 &&
            m_FoundFile[0] &&
            CheckForFileChanges(m_FoundFile, &m_LastWriteTime) == IDYES)
        {
            char Found[MAX_SOURCE_PATH], Sym[MAX_SOURCE_PATH];
            char PathComp[MAX_SOURCE_PATH];

            // Save away filenames since they're copied over
            // on a successful load.
            strcpy(Found, m_FoundFile);
            strcpy(Sym, m_SymFileBuffer);
            strcpy(PathComp, m_PathComponent);
            
            if (!LoadFile(Found, Sym, PathComp))
            {
                PostMessage(g_hwndMDIClient, WM_MDIDESTROY, (WPARAM)m_Win, 0);
            }
        }
    }
}

ULONG
DOCWIN_DATA::GetWorkspaceSize(void)
{
    ULONG Len = EDITWIN_DATA::GetWorkspaceSize();
    Len += _tcslen(m_FoundFile) + 1;
    Len += _tcslen(m_SymFileBuffer) + 1;
    Len += _tcslen(m_PathComponent) + 1;
    Len += sizeof(LONG);
    return Len;
}

PUCHAR
DOCWIN_DATA::SetWorkspace(PUCHAR Data)
{
    PTSTR Str = (PTSTR)EDITWIN_DATA::SetWorkspace(Data);
    _tcscpy(Str, m_FoundFile);
    Str += _tcslen(m_FoundFile) + 1;
    _tcscpy(Str, m_SymFileBuffer);
    Str += _tcslen(m_SymFileBuffer) + 1;
    _tcscpy(Str, m_PathComponent);
    Str += _tcslen(m_PathComponent) + 1;

    CHARRANGE Sel;

    SendMessage(m_hwndChild, EM_EXGETSEL, 0, (LPARAM)&Sel);
    *(LONG UNALIGNED *)Str = Sel.cpMin;
    Str += sizeof(Sel.cpMin);
    
    return (PUCHAR)Str;
}

PUCHAR
DOCWIN_DATA::ApplyWorkspace1(PUCHAR Data, PUCHAR End)
{
    PTSTR Found = (PTSTR)EDITWIN_DATA::ApplyWorkspace1(Data, End);
    PTSTR Sym = Found + _tcslen(Found) + 1;
    PTSTR SymEnd = Sym + _tcslen(Sym) + 1;
    PTSTR PathComp = SymEnd;
    
    if ((PUCHAR)PathComp >= End || !PathComp[0])
    {
        PathComp = NULL;
    }

    if ((PUCHAR)SymEnd >= End)
    {
        Data = (PUCHAR)SymEnd;
    }
    else
    {
        Data = (PUCHAR)(SymEnd + _tcslen(SymEnd) + 1);
    }
    
    if (Found[0])
    {
        if (FindDocWindowByFileName(Found, NULL, NULL) ||
            !LoadFile(Found, Sym[0] ? Sym : NULL, PathComp))
        {
            PostMessage(g_hwndMDIClient, WM_MDIDESTROY, (WPARAM)m_Win, 0);
        }
    }

    if (Data < End)
    {
        CHARRANGE Sel;

        Sel.cpMin = *(LONG UNALIGNED *)Data;
        Sel.cpMax = Sel.cpMin;
        SendMessage(m_hwndChild, EM_EXSETSEL, 0, (LPARAM)&Sel);
        SendMessage(m_hwndChild, EM_SCROLLCARET, 0, 0);

        Data += sizeof(Sel.cpMin);
    }
    
    return Data;
}
    
void
DOCWIN_DATA::UpdateBpMarks(void)
{
    if (m_TextLines == 0 ||
        g_BpBuffer->UiLockForRead() != S_OK)
    {
        return;
    }

    SendMessage(m_hwndChild, WM_SETREDRAW, FALSE, 0);

    // Remove existing BP highlights.
    RemoveAllHighlights(EHL_ANY_BP);
    
    //
    // Highlight every line that matches a breakpoint.
    //
    
    BpBufferData* BpData = (BpBufferData*)g_BpBuffer->GetDataBuffer();
    ULONG i;

    for (i = 0; i < g_BpCount; i++)
    {
        if (BpData[i].FileOffset)
        {
            PSTR FileSpace;
            ULONG Line;
            PSTR FileStop, MatchStop;
            ULONG HlFlags;

            FileSpace = (PSTR)g_BpBuffer->GetDataBuffer() +
                BpData[i].FileOffset;
            // Adjust to zero-based.
            Line = *(ULONG UNALIGNED *)FileSpace - 1;
            FileSpace += sizeof(Line);
            
            // If this document's file matches some suffix
            // of the breakpoint's file at the path component
            // level then do the highlight.  This can result in
            // extra highlights for multiple files with the same
            // name but in different directories.  That's a rare
            // enough problem to wait for somebody to complain
            // before trying to hack some better check up.
            if (SymMatchFileName(FileSpace, (PSTR)m_SymFile,
                                 &FileStop, &MatchStop) ||
                *MatchStop == '\\' ||
                *MatchStop == '/' ||
                *MatchStop == ':')
            {
                if (BpData[i].Flags & DEBUG_BREAKPOINT_ENABLED)
                {
                    HlFlags = EHL_ENABLED_BP;
                }
                else
                {
                    HlFlags = EHL_DISABLED_BP;
                }

                EDIT_HIGHLIGHT* Hl = AddHighlight(Line, HlFlags);
                if (Hl != NULL)
                {
                    Hl->Data = BpData[i].Id;
                }
            }
        }
    }

    UnlockStateBuffer(g_BpBuffer);

    SendMessage(m_hwndChild, WM_SETREDRAW, TRUE, 0);
    InvalidateRect(m_hwndChild, NULL, TRUE);
}

DWORD 
CALLBACK 
EditStreamCallback(
    DWORD_PTR     dwFileHandle,   // application-defined value
    LPBYTE        pbBuff,     // data buffer
    LONG          cb,         // number of bytes to read or write
    LONG          *pcb        // number of bytes transferred
    )
{
    HRESULT Status;
    PathFile* File = (PathFile*)dwFileHandle;
    
    if ((Status = File->Read(pbBuff, cb, (PDWORD)pcb)) != S_OK)
    {
        return Status;
    }

    // Edit out page-break characters (^L's) as richedit
    // gives them their own line which throws off line numbers.
    while (cb-- > 0)
    {
        if (*pbBuff == '\f')
        {
            *pbBuff = ' ';
        }

        pbBuff++;
    }
    
    return 0; // No error
}

BOOL 
DOCWIN_DATA::LoadFile(
    PCTSTR pszFoundFile,
    PCTSTR pszSymFile,
    PCTSTR pszPathComponent
    )
/*++
Returns
    TRUE - Success, file opened and loaded
    FALSE - Failure, file not loaded
--*/
{
    Assert(pszFoundFile);

    BOOL        bRet = TRUE;
    HCURSOR     hcursor = NULL;
    EDITSTREAM  editstr = {0};
    PathFile   *File = NULL;

    if ((OpenPathFile(pszPathComponent, pszFoundFile, 0, &File)) != S_OK)
    {
        ErrorBox(NULL, 0, ERR_File_Open, pszFoundFile);
        bRet = FALSE;
        goto exit;
    }

    // Store last write time to check for file changes.
    if (File->GetLastWriteTime(&m_LastWriteTime) != S_OK)
    {
        ZeroMemory(&m_LastWriteTime, sizeof(m_LastWriteTime));
    }

    // Set the Hour glass cursor
    hcursor = SetCursor( LoadCursor(NULL, IDC_WAIT) );

    // Select all of the text so that it will be replaced
    SendMessage(m_hwndChild, EM_SETSEL, 0, -1);

    // Put the text into the window
    editstr.dwCookie = (DWORD_PTR)File;
    editstr.pfnCallback = EditStreamCallback;

    SendMessage(m_hwndChild,
                EM_STREAMIN,
                SF_TEXT,
                (LPARAM) &editstr
                );

    RicheditUpdateColors(m_hwndChild,
                         g_Colors[COL_PLAIN_TEXT].Color, TRUE,
                         g_Colors[COL_PLAIN].Color, TRUE);

    // Restore cursor
    SetCursor(hcursor);

    _tcsncpy(m_FoundFile, pszFoundFile, _tsizeof(m_FoundFile) - 1 );
    m_FoundFile[ _tsizeof(m_FoundFile) - 1 ] = 0;
    if (pszSymFile != NULL && pszSymFile[0])
    {
        _tcsncpy(m_SymFileBuffer, pszSymFile, _tsizeof(m_SymFileBuffer) - 1 );
        m_SymFileBuffer[ _tsizeof(m_SymFileBuffer) - 1 ] = 0;
        m_SymFile = m_SymFileBuffer;
    }
    else
    {
        // No symbol file information so just use the found filename.
        m_SymFileBuffer[0] = 0;
        m_SymFile = strrchr(m_FoundFile, '\\');
        if (m_SymFile == NULL)
        {
            m_SymFile = strrchr(m_FoundFile, '/');
            if (m_SymFile == NULL)
            {
                m_SymFile = strrchr(m_FoundFile, ':');
                if (m_SymFile == NULL)
                {
                    m_SymFile = m_FoundFile - 1;
                }
            }
        }
        m_SymFile++;
    }
    if (pszPathComponent)
    {
        _tcsncpy(m_PathComponent, pszPathComponent,
                 _tsizeof(m_PathComponent) - 1);
        m_PathComponent[_tsizeof(m_PathComponent) - 1] = 0;
    }
    else
    {
        m_PathComponent[0] = 0;
    }

    SetWindowText(m_Win, m_FoundFile);

    if (SendMessage(m_hwndChild, WM_GETTEXTLENGTH, 0, 0) == 0)
    {
        m_TextLines = 0;
    }
    else
    {
        m_TextLines = (ULONG)SendMessage(m_hwndChild, EM_GETLINECOUNT, 0, 0);
    }

    if (g_LineMarkers)
    {
        // Insert marker space before every line.
        for (ULONG i = 0; i < m_TextLines; i++)
        {
            CHARRANGE Ins;

            Ins.cpMin = (LONG)SendMessage(m_hwndChild, EM_LINEINDEX, i, 0);
            Ins.cpMax = Ins.cpMin;
            SendMessage(m_hwndChild, EM_EXSETSEL, 0, (LPARAM)&Ins);
            SendMessage(m_hwndChild, EM_REPLACESEL, FALSE, (LPARAM)"  ");
        }
    }
    
    // Request that the engine update the line map for the file.
    UiRequestRead();
    
exit:
    delete File;
    return bRet;
}

BOOL
SameFileName(PCSTR Name1, PCSTR Name2)
{
    while (*Name1)
    {
        if (!(((*Name1 == '\\' || *Name1 == '/') &&
               (*Name2 == '\\' || *Name2 == '/')) ||
              toupper(*Name1) == toupper(*Name2)))
        {
            return FALSE;
        }

        Name1++;
        Name2++;
    }

    return *Name2 == 0;
}

BOOL
FindDocWindowByFileName(
    IN          PCTSTR          pszFile,
    OPTIONAL    HWND           *phwnd,
    OPTIONAL    PDOCWIN_DATA   *ppDocWinData
    )
/*++
Returns
    TRUE - If the window is currently open.
    FALSE - Not currently open.
--*/
{
    Assert(pszFile);

    PLIST_ENTRY Entry;
    PDOCWIN_DATA pTmp;

    Entry = g_ActiveWin.Flink;

    while (Entry != &g_ActiveWin)
    {
        pTmp = (PDOCWIN_DATA)ACTIVE_WIN_ENTRY(Entry);
        if ( pTmp->m_enumType == DOC_WINDOW &&
             SameFileName(pTmp->m_FoundFile, pszFile) )
        {
            if (ppDocWinData)
            {
                *ppDocWinData = pTmp;
            }
            if (phwnd)
            {
                *phwnd = pTmp->m_Win;
            }
            return TRUE;
        }

        Entry = Entry->Flink;
    }

    return FALSE;
}

BOOL
OpenOrActivateFile(PCSTR FoundFile, PCSTR SymFile, PCSTR PathComponent,
                   ULONG Line, BOOL Activate, BOOL UserActivated)
{
    HWND hwndDoc = NULL;
    PDOCWIN_DATA pDoc;
    BOOL Activated = FALSE;

    if ( FindDocWindowByFileName( FoundFile, &hwndDoc, &pDoc) )
    {
        if (Activate)
        {
            // Found it. Now activate it.
            if (IsIconic(hwndDoc))
            {
                ShowWindow(hwndDoc, SW_RESTORE);
            }
            ActivateMDIChild(hwndDoc, UserActivated);
            Activated = TRUE;
        }
    }
    else
    {
        HWND WinTop, WinUnder;

        WinTop = MDIGetActive(g_hwndMDIClient, NULL);
        if (WinTop)
        {
            WinUnder = GetNextWindow(WinTop, GW_HWNDNEXT);
        }
        else
        {
            WinUnder = NULL;
        }
        
        hwndDoc = NewDoc_CreateWindow(g_hwndMDIClient);
        if (hwndDoc == NULL)
        {
            return FALSE;
        }
        pDoc = GetDocWinData(hwndDoc);
        Assert(pDoc);

        if (!pDoc->LoadFile(FoundFile, SymFile, PathComponent))
        {
            DestroyWindow(pDoc->m_Win);
            return FALSE;
        }

        if (!UserActivated && WinTop)
        {
            // If this isn't a user-provoked activation we don't
            // want the window to obscure the user's current window.
            // Reorder the current windows appropriately.
            ReorderChildren(WinUnder, WinTop, pDoc->m_Win,
                            UserActivated);
        }

        Activated = TRUE;
    }
    
    // Success. Now highlight the line.
    pDoc->SetCurrentLineHighlight(Line);
        
    return Activated;
}

void
UpdateCodeDisplay(
    ULONG64 Ip,
    PCSTR   FoundFile,
    PCSTR   SymFile,
    PCSTR   PathComponent,
    ULONG   Line,
    BOOL    UserActivated
    )
{
    // Update the disassembly window if there's one
    // active or there's no source information.

    BOOL Activated = FALSE;
    HWND hwndDisasm = GetDisasmHwnd();
        
    if (hwndDisasm == NULL && FoundFile == NULL &&
        (g_WinOptions & WOPT_AUTO_DISASM))
    {
        // No disassembly window around and no source so create one.
        hwndDisasm = NewDisasm_CreateWindow(g_hwndMDIClient);
    }

    if (hwndDisasm != NULL)
    {
        PDISASMWIN_DATA pDis = GetDisasmWinData(hwndDisasm);
        Assert(pDis);

        pDis->SetCurInstr(Ip);
    }
        
    if (FoundFile != NULL)
    {
        //
        // We now know the file name and line number. Either
        // it's open or we open it.
        //

        Activated = OpenOrActivateFile(FoundFile, SymFile, PathComponent, Line,
                                       GetSrcMode_StatusBar() ||
                                       g_DisasmActivateSource,
                                       UserActivated);

        RunEditorCommand(g_EditorUpdateCommand, FoundFile, Line);
    }
    else
    {
        // No source file was found so make sure no
        // doc windows have a highlight.
        EDITWIN_DATA::RemoveActiveWinHighlights(1 << DOC_WINDOW,
                                                EHL_CURRENT_LINE);
    }

    if ((!Activated || !GetSrcMode_StatusBar()) && hwndDisasm != NULL)
    {
        // No window has been activated yet so fall back
        // on activating the disassembly window.
        ActivateMDIChild(hwndDisasm, UserActivated);
    }
}

void
SetTabWidth(ULONG TabWidth)
{
    PLIST_ENTRY Entry;
    PDOCWIN_DATA DocData;

    g_TabWidth = TabWidth;
    if (g_Workspace != NULL)
    {
        g_Workspace->SetUlong(WSP_GLOBAL_TAB_WIDTH, TabWidth);
    }
    
    Entry = g_ActiveWin.Flink;
    while (Entry != &g_ActiveWin)
    {
        DocData = (PDOCWIN_DATA)ACTIVE_WIN_ENTRY(Entry);
        if (DocData->m_enumType == DOC_WINDOW)
        {
            SendMessage(DocData->m_hwndChild, EM_SETTABSTOPS,
                        1, (LPARAM)&g_TabWidth);
        }

        Entry = Entry->Flink;
    }
}

void
GetEditorCommandDefaults(void)
{
    PSTR Env;
    HKEY Key;

    // As a convenience for windiff users pick up the
    // windiff editor registry setting.
    if (RegOpenKeyExA(HKEY_CURRENT_USER, "Software\\Microsoft\\Windiff",
                      0, KEY_READ, &Key) == ERROR_SUCCESS)
    {
        DWORD Type;
        DWORD Size;
        
        Size = sizeof(g_EditorInvokeCommand);
        if (RegQueryValueExA(Key, "Editor", NULL, &Type,
                             (LPBYTE)g_EditorInvokeCommand,
                             &Size) != ERROR_SUCCESS ||
            Type != REG_SZ)
        {
            strcpy(g_EditorInvokeCommand, INVOKE_DEFAULT);
        }
                             
        RegCloseKey(Key);
    }
    
    Env = getenv("WINDBG_INVOKE_EDITOR");
    if (Env)
    {
        CopyString(g_EditorInvokeCommand, Env, DIMA(g_EditorInvokeCommand));
    }
    
    Env = getenv("WINDBG_UPDATE_EDITOR");
    if (Env)
    {
        CopyString(g_EditorUpdateCommand, Env, DIMA(g_EditorInvokeCommand));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\windbg\engine.h ===
//----------------------------------------------------------------------------
//
// Engine interface code.
//
// Copyright (C) Microsoft Corporation, 1999-2002.
//
//----------------------------------------------------------------------------

#ifndef __ENGINE_H__
#define __ENGINE_H__

#define RELEASE(Unk) \
    ((Unk) != NULL ? ((Unk)->Release(), (Unk) = NULL) : NULL)

#define MAX_ENGINE_PATH 4096

#define MAX_DUMP_FILES 64
//
// Session initialization parameters.
//

// Turn on verbose output or not.
extern BOOL g_Verbose;
// Dump file to open or NULL.
extern PTSTR g_DumpFiles[MAX_DUMP_FILES];
extern ULONG g_NumDumpFiles;
extern PTSTR g_DumpInfoFiles[MAX_DUMP_FILES];
extern ULONG g_DumpInfoTypes[MAX_DUMP_FILES];
extern ULONG g_NumDumpInfoFiles;
// Process server to use.
extern PSTR g_ProcessServer;
// Full command line with exe name.
extern PSTR g_DebugCommandLine;
extern PSTR g_ProcessStartDir;
// Process creation flags.
extern ULONG g_DebugCreateFlags;
// Process ID to attach to or zero.
extern ULONG g_PidToDebug;
// Process name to attach to or NULL.
extern PSTR g_ProcNameToDebug;
extern BOOL g_DetachOnExit;
extern ULONG g_AttachProcessFlags;
// Kernel connection options.
extern ULONG g_AttachKernelFlags;
extern PSTR g_KernelConnectOptions;

// Remoting options.
extern BOOL g_RemoteClient;
extern ULONG g_HistoryLines;

// Type options.
extern ULONG g_TypeOptions;

//
// Debug engine interfaces for the engine thread.
//
extern IDebugClient         *g_pDbgClient;
extern IDebugClient2        *g_pDbgClient2;
extern IDebugControl        *g_pDbgControl;
extern IDebugSymbols        *g_pDbgSymbols;
extern IDebugRegisters      *g_pDbgRegisters;
extern IDebugDataSpaces     *g_pDbgData;
extern IDebugSystemObjects  *g_pDbgSystem;
extern IDebugSystemObjects3 *g_pDbgSystem3;

//
// Debug engine interfaces for the UI thread.
//
extern IDebugClient        *g_pUiClient;
extern IDebugControl       *g_pUiControl;
extern IDebugControl3      *g_pUiControl3;
extern IDebugSymbols       *g_pUiSymbols;
extern IDebugSymbols2      *g_pUiSymbols2;
extern IDebugSystemObjects *g_pUiSystem;

//
// Debug engine interfaces for private output capture.
//
extern IDebugClient        *g_pOutCapClient;
extern IDebugControl       *g_pOutCapControl;

//
// Debug engine interfaces for local source file lookup.
//
extern IDebugClient        *g_pLocClient;
extern IDebugControl       *g_pLocControl;
extern IDebugSymbols       *g_pLocSymbols;
extern IDebugClient        *g_pUiLocClient;
extern IDebugControl       *g_pUiLocControl;
extern IDebugSymbols       *g_pUiLocSymbols;

extern ULONG g_ActualProcType;
extern char g_ActualProcAbbrevName[32];
extern ULONG g_CommandSequence;
extern ULONG g_TargetClass;
extern ULONG g_TargetClassQual;
extern BOOL g_Ptr64;
extern ULONG g_ExecStatus;
extern ULONG g_EngOptModified;
extern ULONG g_EngineThreadId;
extern HANDLE g_EngineThread;
extern PSTR g_InitialCommand;
extern char g_PromptText[];
extern BOOL g_WaitingForEvent;
extern BOOL g_SessionActive;
extern ULONG g_NumberRadix;
extern BOOL g_IgnoreCodeLevelChange;
extern BOOL g_IgnoreThreadChange;
extern ULONG g_LastProcessExitCode;
extern BOOL g_CodeLevelLocked;
extern BOOL g_HoldWaitOutput;

// Target exists and is not running.
#define IS_TARGET_HALTED() \
    (g_ExecStatus == DEBUG_STATUS_BREAK)

//----------------------------------------------------------------------------
//
// Default output callbacks implementation, provides IUnknown for
// static classes.
//
//----------------------------------------------------------------------------

class DefOutputCallbacks :
    public IDebugOutputCallbacks
{
public:
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        );
    STDMETHOD_(ULONG, AddRef)(
        THIS
        );
    STDMETHOD_(ULONG, Release)(
        THIS
        );
};

//----------------------------------------------------------------------------
//
// EventCallbacks.
//
//----------------------------------------------------------------------------

class EventCallbacks : public DebugBaseEventCallbacks
{
public:
    // IUnknown.
    STDMETHOD_(ULONG, AddRef)(
        THIS
        );
    STDMETHOD_(ULONG, Release)(
        THIS
        );

    // IDebugEventCallbacks.
    STDMETHOD(GetInterestMask)(
        THIS_
        OUT PULONG Mask
        );

    STDMETHOD(CreateThread)(
        THIS_
        IN ULONG64 Handle,
        IN ULONG64 DataOffset,
        IN ULONG64 StartOffset
        );
    STDMETHOD(ExitThread)(
        THIS_
        IN ULONG ExitCode
        );
    STDMETHOD(CreateProcess)(
        THIS_
        IN ULONG64 ImageFileHandle,
        IN ULONG64 Handle,
        IN ULONG64 BaseOffset,
        IN ULONG ModuleSize,
        IN PCSTR ModuleName,
        IN PCSTR ImageName,
        IN ULONG CheckSum,
        IN ULONG TimeDateStamp,
        IN ULONG64 InitialThreadHandle,
        IN ULONG64 ThreadDataOffset,
        IN ULONG64 StartOffset
        );
    STDMETHOD(ExitProcess)(
        THIS_
        IN ULONG ExitCode
        );
    STDMETHOD(SessionStatus)(
        THIS_
        IN ULONG Status
        );
    STDMETHOD(ChangeDebuggeeState)(
        THIS_
        IN ULONG Flags,
        IN ULONG64 Argument
        );
    STDMETHOD(ChangeEngineState)(
        THIS_
        IN ULONG Flags,
        IN ULONG64 Argument
        );
    STDMETHOD(ChangeSymbolState)(
        THIS_
        IN ULONG Flags,
        IN ULONG64 Argument
        );
};

extern EventCallbacks g_EventCb;

//----------------------------------------------------------------------------
//
// Data space read/write support.
//
//----------------------------------------------------------------------------

//
// Begin types originally defined in NTIOAPI.H
//


//
// Define the I/O bus interface types.
//
typedef enum _INTERFACE_TYPE
{
    InterfaceTypeUndefined = -1,
    Internal,
    Isa,
    Eisa,
    MicroChannel,
    TurboChannel,
    PCIBus,
    VMEBus,
    NuBus,
    PCMCIABus,
    CBus,
    MPIBus,
    MPSABus,
    ProcessorInternal,
    InternalPowerBus,
    PNPISABus,
    PNPBus,
    MaximumInterfaceType
} INTERFACE_TYPE, *PINTERFACE_TYPE;


//
// Define types of bus information.
//
typedef enum _BUS_DATA_TYPE
{
    ConfigurationSpaceUndefined = -1,
    Cmos,
    EisaConfiguration,
    Pos,
    CbusConfiguration,
    PCIConfiguration,
    VMEConfiguration,
    NuBusConfiguration,
    PCMCIAConfiguration,
    MPIConfiguration,
    MPSAConfiguration,
    PNPISAConfiguration,
    SgiInternalConfiguration,
    MaximumBusDataType
} BUS_DATA_TYPE, *PBUS_DATA_TYPE;

//
// End types originally defined in NTIOAPI.H
//

enum MEMORY_TYPE
{
    VIRTUAL_MEM_TYPE = 0,
    MIN_MEMORY_TYPE = 0, // Placed here so that symbol lookup finds this first
    PHYSICAL_MEM_TYPE,
    CONTROL_MEM_TYPE,
    IO_MEM_TYPE,
    MSR_MEM_TYPE,
    BUS_MEM_TYPE,
    MAX_MEMORY_TYPE
};


struct IO_MEMORY_DATA
{
    ULONG           BusNumber;
    ULONG           AddressSpace;
    INTERFACE_TYPE  interface_type;
};

struct BUS_MEMORY_DATA
{
    ULONG           BusNumber;
    ULONG           SlotNumber;
    BUS_DATA_TYPE   bus_type;
};

struct MSR_MEMORY_DATA
{
    // Placeholder in case data is needed later.
};

struct PHYSICAL_MEMORY_DATA
{
    // Placeholder in case data is needed later.
};

struct VIRTUAL_MEMORY_DATA
{
    // Placeholder in case data is needed later.
};

struct CONTROL_MEMORY_DATA
{
    ULONG           Processor;
};

struct ANY_MEMORY_DATA
{
    union
    {
        IO_MEMORY_DATA          io;
        BUS_MEMORY_DATA         bus;
        MSR_MEMORY_DATA         msr;
        CONTROL_MEMORY_DATA     control;
        PHYSICAL_MEMORY_DATA    physical;
        VIRTUAL_MEMORY_DATA     virt;
    };
};

//----------------------------------------------------------------------------
//
// Inter-thread communication.
//
// UI buffers are used for transferring information between the
// UI thread and the engine thread, such as commands and output.
// They have a separate lock to avoid contention with state filling.
// If state buffers had individual locks this would be unnecessary.
//
// The UI reads text output from the output buffer for display
// in the command window.
//
// The UI queues commands to the command buffer for execution
// by the engine.
//
//----------------------------------------------------------------------------

// This must be at least MAX_PATH, and also must
// be large enough for the largest single command window
// command expected.
#define MAX_COMMAND_LEN 4096

#define LockUiBuffer(Buffer) Dbg_EnterCriticalSection(&(Buffer)->m_Lock)
#define UnlockUiBuffer(Buffer) Dbg_LeaveCriticalSection(&(Buffer)->m_Lock)

extern class StateBuffer g_UiOutputBuffer;

// Commands from the UI to the engine.
enum UiCommand
{
    // Distinguish command input from other commands so
    // that the input callbacks have a specific token to
    // look for user input.
    UIC_CMD_INPUT,
    UIC_EXECUTE,
    UIC_SILENT_EXECUTE,
    UIC_INVISIBLE_EXECUTE,
    UIC_SET_REG,
    UIC_RESTART,
    UIC_END_SESSION,
    UIC_WRITE_DATA,
    UIC_SYMBOL_WIN,
    UIC_DISPLAY_CODE,
    UIC_DISPLAY_CODE_EXPR,
    UIC_SET_SCOPE,
    UIC_GET_SYM_PATH,
    UIC_SET_SYM_PATH,
    UIC_SET_FILTER,
    UIC_SET_FILTER_ARGUMENT,
    UIC_SET_FILTER_COMMAND,
    UIC_SET_IP,
};

struct UiCommandData
{
    UiCommand Cmd;
    ULONG Len;
};

struct UIC_SET_REG_DATA
{
    ULONG Reg;
    DEBUG_VALUE Val;
};

struct UIC_WRITE_DATA_DATA
{
    MEMORY_TYPE Type;
    ANY_MEMORY_DATA Any;
    ULONG64 Offset;
    ULONG Length;
    UCHAR Data[16];
};

enum SYMBOL_WIN_CALL_TYPE
{
    ADD_SYMBOL_WIN,
    DEL_SYMBOL_WIN_INDEX,
    DEL_SYMBOL_WIN_NAME,
    QUERY_NUM_SYMBOL_WIN,
    GET_NAME,
    GET_PARAMS,
    EXPAND_SYMBOL,
    EDIT_SYMBOL,
    EDIT_TYPE,
    DEL_SYMBOL_WIN_ALL
};

typedef struct UIC_SYMBOL_WIN_DATA
{
    SYMBOL_WIN_CALL_TYPE Type;
    PDEBUG_SYMBOL_GROUP *pSymbolGroup;
    union
    {
        struct
        {
            PCSTR Name;
            ULONG Index;
        } Add;
        PCSTR DelName;
        ULONG DelIndex;
        PULONG NumWatch;
        struct
        {
            ULONG Index;
            PSTR Buffer;
            ULONG BufferSize;
            PULONG NameSize;
        } GetName;
        struct
        {
            ULONG Start;
            ULONG Count;
            PDEBUG_SYMBOL_PARAMETERS SymbolParams;
        } GetParams;
        struct
        {
            ULONG Index;
            BOOL  Expand;
        } ExpandSymbol;
        struct
        {
            ULONG Index;
            PSTR  Value;
        } WriteSymbol;
        struct
        {
            ULONG Index;
            PSTR  Type;
        } OutputAsType;
    } u;
} UIC_SYMBOL_WIN_DATA;

struct UIC_DISPLAY_CODE_DATA
{
    ULONG64 Offset;
};

struct UIC_SET_SCOPE_DATA
{
    DEBUG_STACK_FRAME StackFrame;
};

struct UIC_SET_FILTER_DATA
{
    ULONG Index;
    ULONG Code;
    ULONG Execution;
    ULONG Continue;
};

struct UIC_SET_FILTER_ARGUMENT_DATA
{
    ULONG Index;
    char Argument[1];
};

struct UIC_SET_FILTER_COMMAND_DATA
{
    ULONG Which;
    ULONG Index;
    char Command[1];
};

PVOID StartCommand(UiCommand Cmd, ULONG Len);
void FinishCommand(void);

BOOL AddStringCommand(UiCommand Cmd, PCSTR Str);
BOOL AddStringMultiCommand(UiCommand Cmd, PSTR Str, BOOL FOrceSplit);
BOOL __cdecl PrintStringCommand(UiCommand Cmd, PCSTR Format, ...);

#define StartStructCommand(Struct) \
    ((Struct ## _DATA*)StartCommand(Struct, sizeof(Struct ## _DATA)))

#define AddEnumCommand(Cmd) \
    (StartCommand(Cmd, 0) != NULL ? (FinishCommand(), TRUE) : FALSE)

// Wake up the UI thread to do UI processing.
#define UpdateUi() \
    PostMessage(g_hwndFrame, WM_NOTIFY, 0, 0)

// Wake up the engine thread to do engine processing.
void UpdateEngine(void);

void ProcessEngineCommands(BOOL Internal);
void DiscardEngineState(void);
DWORD WINAPI EngineLoop(LPVOID Param);

#endif // #ifndef __ENGINE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\windbg\makefile.inc ===
$(O)\res_str.i: res_str.h
    $(TARGET_CPP) -EP -DRESOURCES -Tc res_str.h > $@

$(O)\windbg.res: $(O)\res_str.i dialogs.dlg
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\windbg\fncdefs.h ===
#if defined(DEFINE_GET_WINDATA)

DEFINE_GET_WINDATA(COMMONWIN_DATA, Common)
DEFINE_GET_WINDATA(CMDWIN_DATA, Cmd)
DEFINE_GET_WINDATA(SCRATCH_PAD_DATA, Scratch)
DEFINE_GET_WINDATA(CPUWIN_DATA, Cpu)
DEFINE_GET_WINDATA(CALLSWIN_DATA, Calls)
DEFINE_GET_WINDATA(MEMWIN_DATA, Mem)
DEFINE_GET_WINDATA(DISASMWIN_DATA, Disasm)
DEFINE_GET_WINDATA(LOCALSWIN_DATA, Locals)
DEFINE_GET_WINDATA(WATCHWIN_DATA, Watch)
DEFINE_GET_WINDATA(DOCWIN_DATA, Doc)
DEFINE_GET_WINDATA(PROCESS_THREAD_DATA, ProcessThread)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\windbg\format.h ===
/*++

Copyright (c) 1992-2002  Microsoft Corporation

Module Name:

    format.h

Abstract:

    Formatting functions.

Environment:

    Win32, User Mode

--*/

typedef UINT FMTTYPE;

#define fmtAscii    0
#define fmtInt      1
#define fmtUInt     2
#define fmtFloat    3
#define fmtAddress  4
#define fmtUnicode  5
#define fmtBit      6
#define fmtBasis    0x0f

// override logic to force radix
#define fmtSpacePad 0x1000
#define fmtOverRide 0x2000
#define fmtZeroPad  0x4000
#define fmtNat      0x8000


int
CPCopyString(
    PTSTR *lplps,
    PTSTR lpT,
    TCHAR chEscape,
    BOOL fQuote
    );

BOOL
CPFormatMemory(
    LPCH    lpchTarget,
    DWORD    cchTarget,
    LPBYTE  lpbSource,
    DWORD    cBits,
    FMTTYPE fmtType,
    DWORD    radix
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\windbg\memopts.cpp ===
/*++

Copyright (c) 1992-2002  Microsoft Corporation

Module Name:

    Memory.c

Abstract:

    This module contains the memory options dialog callback and supporting
    routines to choose options for memory display.

--*/

#include "precomp.hxx"
#pragma hdrstop



_FORMATS_MEM_WIN g_FormatsMemWin[] = {
    {8,  fmtAscii,               0, FALSE,  1,  _T("ASCII")},
    {16, fmtUnicode,             0, FALSE,  1,  _T("Unicode")},
    {8,  fmtBit,                 2, FALSE,  8,  _T("Bit")},
    {8,  fmtInt  | fmtZeroPad,  16, TRUE,   2,  _T("Byte")},
    {16, fmtInt  | fmtSpacePad, 10, FALSE,  6,  _T("Short")},
    {16, fmtUInt | fmtZeroPad,  16, FALSE,  4,  _T("Short Hex")},
    {16, fmtUInt | fmtSpacePad, 10, FALSE,  5,  _T("Short Unsigned")},
    {32, fmtInt  | fmtSpacePad, 10, FALSE,  11, _T("Long")},
    {32, fmtUInt | fmtZeroPad,  16, FALSE,  8,  _T("Long Hex")},
    {32, fmtUInt | fmtSpacePad, 10, FALSE,  10, _T("Long Unsigned")},
    {64, fmtInt  | fmtSpacePad, 10, FALSE,  21, _T("Quad")},
    {64, fmtUInt | fmtZeroPad,  16, FALSE,  16, _T("Quad Hex")},
    {64, fmtUInt | fmtSpacePad, 10, FALSE,  20, _T("Quad Unsigned")},
    {32, fmtFloat,              10, FALSE,  14, _T("Real (32-bit)")},
    {64, fmtFloat,              10, FALSE,  23, _T("Real (64-bit)")},
    {80, fmtFloat,              10, FALSE,  25, _T("Real (10-byte)")},
    {128,fmtFloat,              10, FALSE,  42, _T("Real (16-byte)")}
};

const int g_nMaxNumFormatsMemWin = sizeof(g_FormatsMemWin) / sizeof(g_FormatsMemWin[0]);




HWND hwndMemOptsParent = NULL;


void
Init(HWND,
    HINSTANCE,
    LPPROPSHEETHEADER,
    PROPSHEETPAGE [],
    const int
    );


INT_PTR CALLBACK DlgProc_Physical_Mem(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK DlgProc_Virtual_Mem(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK DlgProc_IO_Mem(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK DlgProc_Bus_Mem(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK DlgProc_Control_Mem(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK DlgProc_MSR_Mem(HWND, UINT, WPARAM, LPARAM);

INT_PTR
CALLBACK
DlgProc_MemoryProperties(MEMORY_TYPE, HWND, UINT, WPARAM, LPARAM);


int
MemType_To_DlgId(
    MEMORY_TYPE memtype
    )
{
    int i;
    struct {
        MEMORY_TYPE memtype;
        int         nId;
    } rgMap[] = {
        { PHYSICAL_MEM_TYPE,    IDD_DLG_MEM_PHYSICAL },
        { VIRTUAL_MEM_TYPE,     IDD_DLG_MEM_VIRTUAL },
        { BUS_MEM_TYPE,         IDD_DLG_MEM_BUS_DATA },
        { CONTROL_MEM_TYPE,     IDD_DLG_MEM_CONTROL },
        { IO_MEM_TYPE,          IDD_DLG_MEM_IO },
        { MSR_MEM_TYPE,         IDD_DLG_MEM_MSR }
    };

    for (i=0; i<sizeof(rgMap)/sizeof(rgMap[0]); i++) {
        if (memtype == rgMap[i].memtype) {
            return rgMap[i].nId;
        }
    }

    Assert(!"This should not happen");
    return 0;
}


INT_PTR
DisplayOptionsPropSheet(
    HWND                hwndOwner,
    HINSTANCE           hinst,
    MEMORY_TYPE         memtypeStartPage
    )
/*++
Routine Description:
    Will Initialize and display the Options property sheet. Handle the return codes,
    and the commitment of changes to the debugger.

Arguments:
    hwndOwner
    hinst
        Are both used initialize the property sheet dialog.
    nStart - Is used to specify the page that is to be initially
        displayed when the prop sheet first appears. The default
        value is 0. The values specified correspond to array index
        of the PROPSHEETPAGE array.

Returns
    Button pushed IDOK, etc...
--*/
{
    INT_PTR nRes = 0;
    PROPSHEETHEADER psh = {0};
    PROPSHEETPAGE apsp[MAX_MEMORY_TYPE] = {0};
    int nNumPropPages = sizeof(apsp) / sizeof(PROPSHEETPAGE);

    Init(hwndOwner, hinst, &psh, apsp, nNumPropPages);

    {
        //
        // Figure out the initial page to be displayed
        //

        int i;
        int nStartPage = 0;
        int nId = MemType_To_DlgId(memtypeStartPage);

        for (i=0; i<MAX_MEMORY_TYPE; i++) {
            if ( (PVOID)(MAKEINTRESOURCE(nId)) == (PVOID)(apsp[i].pszTemplate) ) {
                nStartPage = i;
                break;
            }
        }

        psh.nStartPage = nStartPage;
    }


    hwndMemOptsParent = hwndOwner;

    nRes = PropertySheet(&psh);

    hwndMemOptsParent = NULL;

    if (IDOK == nRes) {
        // Save workspace changes here
    }

    return nRes;
}


void
Init(
    HWND                hwndOwner,
    HINSTANCE           hinst,
    LPPROPSHEETHEADER   lppsh,
    PROPSHEETPAGE       apsp[],
    const int           nMaxPropPages
    )
/*++
Routine Description:
    Initializes the property sheet header and pages.

Arguments:
    hwndOwner
    hinst
        Are both used by the PROPSHEETHEADER & PROPSHEETPAGE structure.
        Please see the docs for the these structures for more info.

    lppsh
        Standard prop sheet structure.

    apsp[]
        An array of prop pages
        Standard prop sheet structure.

    nNumPropPages
        Number of prop pages in the "apsp" array.
--*/
{
    int nPropIdx;

    memset(lppsh, 0, sizeof(PROPSHEETHEADER));

    lppsh->dwSize = sizeof(PROPSHEETHEADER);
    lppsh->dwFlags = PSH_PROPSHEETPAGE | PSH_NOAPPLYNOW;
    lppsh->hwndParent = hwndOwner;
    lppsh->hInstance = hinst;
    lppsh->pszCaption = "Memory Options";
    lppsh->nPages = 0;
    lppsh->ppsp = apsp;

    // Init the first one, then copy its contents to all the others
    memset(apsp, 0, sizeof(PROPSHEETPAGE));
    apsp[0].dwSize = sizeof(PROPSHEETPAGE);
//    apsp[0].dwFlags = PSP_HASHELP;
    apsp[0].hInstance = hinst;

    for (nPropIdx = 1; nPropIdx < nMaxPropPages; nPropIdx++) {
        memcpy(&(apsp[nPropIdx]), &apsp[0], sizeof(PROPSHEETPAGE));
    }



    // Only init the distinct values
    nPropIdx = 0;
    apsp[nPropIdx].pszTemplate = MAKEINTRESOURCE(IDD_DLG_MEM_VIRTUAL);
    apsp[nPropIdx].pfnDlgProc  = DlgProc_Virtual_Mem;

    if (g_TargetClass == DEBUG_CLASS_KERNEL)
    {
        nPropIdx = 1;
        apsp[nPropIdx].pszTemplate = MAKEINTRESOURCE(IDD_DLG_MEM_PHYSICAL);
        apsp[nPropIdx].pfnDlgProc  = DlgProc_Physical_Mem;

        nPropIdx = 2;
        apsp[nPropIdx].pszTemplate = MAKEINTRESOURCE(IDD_DLG_MEM_BUS_DATA);
        apsp[nPropIdx].pfnDlgProc  = DlgProc_Bus_Mem;

        nPropIdx = 3;
        apsp[nPropIdx].pszTemplate = MAKEINTRESOURCE(IDD_DLG_MEM_CONTROL);
        apsp[nPropIdx].pfnDlgProc  = DlgProc_Control_Mem;

        nPropIdx = 4;
        apsp[nPropIdx].pszTemplate = MAKEINTRESOURCE(IDD_DLG_MEM_IO);
        apsp[nPropIdx].pfnDlgProc  = DlgProc_IO_Mem;

        nPropIdx = 5;
        apsp[nPropIdx].pszTemplate = MAKEINTRESOURCE(IDD_DLG_MEM_MSR);
        apsp[nPropIdx].pfnDlgProc  = DlgProc_MSR_Mem;
    }

    Assert(nPropIdx < nMaxPropPages);
    lppsh->nPages = nPropIdx + 1;
}


INT_PTR
CALLBACK
DlgProc_MemoryProperties(
    MEMORY_TYPE memtype,
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    LRESULT nPos;
    MEMWIN_DATA *pMemWinData = GetMemWinData( hwndMemOptsParent );

    switch (uMsg) {

/*
    case WM_HELP:
        WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, "windbg.hlp", HELP_WM_HELP,
            (DWORD_PTR)(LPVOID) HelpArray );
        return TRUE;

    case WM_CONTEXTMENU:
        WinHelp ((HWND) wParam, "windbg.hlp", HELP_CONTEXTMENU,
            (DWORD_PTR)(LPVOID) HelpArray );
        return TRUE;
*/

    case WM_COMMAND:
        /*{
            WORD wNotifyCode = HIWORD(wParam);  // notification code
            WORD wID = LOWORD(wParam);          // item, control, or accelerator identifier
            HWND hwndCtl = (HWND) lParam;       // handle of control
            BOOL bEnabled;

            switch(wID) {
            case ID_ENV_SRCHPATH:
                if (BN_CLICKED == wNotifyCode) {
                    BOOL b = IsDlgButtonChecked(hDlg, ID_ENV_SRCHPATH);

                    EnableWindow(GetDlgItem(hDlg, IDC_EDIT_EXECUTABLE_SEARCH_PATH), b);
                    EnableWindow(GetDlgItem(hDlg, IDC_BUT_BROWSE), b);

                    return TRUE;
                }
                break;
            }
        }*/
        break;

    case WM_INITDIALOG:
        { // begin Prog & Arguments code block

            int         nIdx;
            TCHAR       szTmp[MAX_MSG_TXT];


            //
            // Enter the display formats
            //
            for (nIdx=0; nIdx < g_nMaxNumFormatsMemWin; nIdx++) {

                nPos = SendDlgItemMessage(hDlg,
                                          IDC_COMBO_DISPLAY_FORMAT,
                                          CB_ADDSTRING,
                                          0,
                                          (LPARAM) g_FormatsMemWin[nIdx].lpszDescription
                                          );

                SendDlgItemMessage(hDlg,
                                   IDC_COMBO_DISPLAY_FORMAT,
                                   CB_SETITEMDATA,
                                   (WPARAM) nPos,
                                   (LPARAM) (UINT) nIdx
                                   );
            }

            SendDlgItemMessage(hDlg,
                               IDC_COMBO_DISPLAY_FORMAT,
                               CB_SELECTSTRING,
                               (WPARAM) -1,
                               (LPARAM) g_FormatsMemWin[pMemWinData->m_GenMemData.nDisplayFormat].lpszDescription
                               );

            //
            // Update the offset. Offset is common to all dialogs
            //
            SendDlgItemMessage(hDlg, IDC_EDIT_OFFSET, EM_LIMITTEXT,
                               sizeof(pMemWinData->m_OffsetExpr) - 1, 0);
            SetDlgItemText(hDlg, IDC_EDIT_OFFSET, pMemWinData->m_OffsetExpr);

            switch (memtype) {
            default:
                Assert(!"Unhandled value");
                break;

            case VIRTUAL_MEM_TYPE:
                // Nothing to do
                break;

            case PHYSICAL_MEM_TYPE:
                // Nothing to do
                break;

            case CONTROL_MEM_TYPE:
                SendDlgItemMessage(hDlg, IDC_EDIT_PROCESSOR, EM_LIMITTEXT,
                                   32, 0);

                sprintf(szTmp, "%d",
                        pMemWinData->m_GenMemData.any.control.Processor);
                SetDlgItemText(hDlg, IDC_EDIT_PROCESSOR, szTmp);
                break;

            case IO_MEM_TYPE:
                SendDlgItemMessage(hDlg, IDC_EDIT_BUS_NUMBER, EM_LIMITTEXT,
                                   32, 0);
                SendDlgItemMessage(hDlg, IDC_EDIT_ADDRESS_SPACE, EM_LIMITTEXT,
                                   32, 0);

                sprintf(szTmp, "%d",
                        pMemWinData->m_GenMemData.any.io.BusNumber);
                SetDlgItemText(hDlg, IDC_EDIT_BUS_NUMBER, szTmp);

                sprintf(szTmp, "%d",
                        pMemWinData->m_GenMemData.any.io.AddressSpace);
                SetDlgItemText(hDlg, IDC_EDIT_ADDRESS_SPACE, szTmp);


                //
                // Enter the interface types
                //
                for (nIdx = 0; nIdx < sizeof(rgInterfaceTypeNames) /
                         sizeof(rgInterfaceTypeNames[0]); nIdx++) {

                    nPos = SendDlgItemMessage(hDlg,
                                              IDC_COMBO_INTERFACE_TYPE,
                                              CB_ADDSTRING,
                                              0,
                                              (LPARAM) rgInterfaceTypeNames[nIdx].psz
                                              );

                    SendDlgItemMessage(hDlg,
                                       IDC_COMBO_INTERFACE_TYPE,
                                       CB_SETITEMDATA,
                                       (WPARAM) nPos,
                                       (LPARAM) (UINT) nIdx
                                       );
                }

                if (memtype == pMemWinData->m_GenMemData.memtype) {
                    nIdx = pMemWinData->m_GenMemData.any.io.interface_type;
                } else {
                    nIdx = 0;
                }
                SendDlgItemMessage(hDlg,
                                   IDC_COMBO_INTERFACE_TYPE,
                                   CB_SELECTSTRING,
                                   (WPARAM) -1,
                                   (LPARAM) rgInterfaceTypeNames[nIdx].psz
                                   );
                break;

            case MSR_MEM_TYPE:
                // Nothing to do
                break;

            case BUS_MEM_TYPE:
                SendDlgItemMessage(hDlg, IDC_EDIT_BUS_NUMBER, EM_LIMITTEXT,
                                   32, 0);
                SendDlgItemMessage(hDlg, IDC_EDIT_SLOT_NUMBER, EM_LIMITTEXT,
                                   32, 0);

                sprintf(szTmp, "%d",
                        pMemWinData->m_GenMemData.any.bus.BusNumber);
                SetDlgItemText(hDlg, IDC_EDIT_BUS_NUMBER, szTmp);

                sprintf(szTmp, "%d",
                        pMemWinData->m_GenMemData.any.bus.SlotNumber);
                SetDlgItemText(hDlg, IDC_EDIT_SLOT_NUMBER, szTmp);

                //
                // Enter the bus types
                //
                for (nIdx = 0; nIdx < sizeof(rgBusTypeNames) /
                         sizeof(rgBusTypeNames[0]); nIdx++) {

                    nPos = SendDlgItemMessage(hDlg,
                                              IDC_COMBO_BUS_DATA_TYPE,
                                              CB_ADDSTRING,
                                              0,
                                              (LPARAM) rgBusTypeNames[nIdx].psz
                                              );

                    SendDlgItemMessage(hDlg,
                                       IDC_COMBO_BUS_DATA_TYPE,
                                       CB_SETITEMDATA,
                                       (WPARAM) nPos,
                                       (LPARAM) (UINT) nIdx
                                       );
                }

                if (memtype == pMemWinData->m_GenMemData.memtype) {
                    nIdx = pMemWinData->m_GenMemData.any.bus.bus_type;
                } else {
                    nIdx = 0;
                }
                SendDlgItemMessage(hDlg,
                                   IDC_COMBO_BUS_DATA_TYPE,
                                   CB_SELECTSTRING,
                                   (WPARAM) -1,
                                   (LPARAM) rgBusTypeNames[nIdx].psz
                                   );
                break;
            }

            return FALSE;
        } // end Prog & Arguments code block
        break;

    case WM_NOTIFY:
        switch (((NMHDR FAR *) lParam)->code) {
        case PSN_SETACTIVE:
            pMemWinData->m_GenMemData.memtype = memtype;
            return 0;

        case PSN_KILLACTIVE:
            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, FALSE);
            return 1;

        case PSN_APPLY:
            if (memtype != pMemWinData->m_GenMemData.memtype) {
                // This isn't the current page so ignore.
                break;
            }

            int         nIdx;
            TCHAR       szTmp[MAX_MSG_TXT];

            //
            // Get the display formats
            //
            nPos = SendDlgItemMessage(hDlg,
                                      IDC_COMBO_DISPLAY_FORMAT,
                                      CB_GETCURSEL,
                                      0,
                                      0
                                      );

            if (CB_ERR == nPos) {
                pMemWinData->m_GenMemData.nDisplayFormat = 0;
            } else {
                nIdx = (int)SendDlgItemMessage(hDlg,
                                               IDC_COMBO_DISPLAY_FORMAT,
                                               CB_GETITEMDATA,
                                               (WPARAM) nPos,
                                               0
                                               );
                if (CB_ERR == nIdx) {
                    pMemWinData->m_GenMemData.nDisplayFormat = 0;
                } else {
                    pMemWinData->m_GenMemData.nDisplayFormat = nIdx;
                }
            }

            //
            // Update the offset. Offset is common to all dialogs
            //
            GetDlgItemText(hDlg, IDC_EDIT_OFFSET,
                           pMemWinData->m_OffsetExpr,
                           sizeof(pMemWinData->m_OffsetExpr));

            switch (memtype) {
            default:
                Assert(!"Unhandled value");
                break;

            case VIRTUAL_MEM_TYPE:
                // Nothing to do
                break;

            case PHYSICAL_MEM_TYPE:
                // Nothing to do
                break;

            case CONTROL_MEM_TYPE:
                GetDlgItemText(hDlg, IDC_EDIT_PROCESSOR,
                               szTmp, _tsizeof(szTmp));
                if (sscanf(szTmp, "%d", &pMemWinData->
                           m_GenMemData.any.control.Processor) != 1)
                {
                    pMemWinData->m_GenMemData.any.control.Processor = 0;
                }
                break;

            case IO_MEM_TYPE:
                GetDlgItemText(hDlg, IDC_EDIT_BUS_NUMBER,
                               szTmp, _tsizeof(szTmp));
                if (sscanf(szTmp, "%d", &pMemWinData->
                           m_GenMemData.any.io.BusNumber) != 1)
                {
                    pMemWinData->m_GenMemData.any.io.BusNumber = 0;
                }

                GetDlgItemText(hDlg, IDC_EDIT_ADDRESS_SPACE,
                               szTmp, _tsizeof(szTmp));
                if (sscanf(szTmp, "%d", &pMemWinData->
                           m_GenMemData.any.io.AddressSpace) != 1)
                {
                    pMemWinData->m_GenMemData.any.io.AddressSpace = 0;
                }

                //
                // Get the interface types
                //
                nPos = SendDlgItemMessage(hDlg,
                                          IDC_COMBO_INTERFACE_TYPE,
                                          CB_GETCURSEL,
                                          0,
                                          0
                                          );

                if (CB_ERR == nPos) {
                    pMemWinData->m_GenMemData.any.io.interface_type =
                        _INTERFACE_TYPE(0);
                } else {
                    nIdx = (int)SendDlgItemMessage(hDlg,
                                                   IDC_COMBO_INTERFACE_TYPE,
                                                   CB_GETITEMDATA,
                                                   (WPARAM) nPos,
                                                   0
                                                   );
                    if (CB_ERR == nIdx) {
                        pMemWinData->m_GenMemData.any.io.interface_type =
                            _INTERFACE_TYPE(0);
                    } else {
                        pMemWinData->m_GenMemData.any.io.interface_type =
                            _INTERFACE_TYPE(nIdx);
                    }
                }
                break;

            case MSR_MEM_TYPE:
                // Nothing to do
                break;

            case BUS_MEM_TYPE:
                GetDlgItemText(hDlg, IDC_EDIT_BUS_NUMBER,
                               szTmp, _tsizeof(szTmp));
                if (sscanf(szTmp, "%d", &pMemWinData->
                           m_GenMemData.any.bus.BusNumber) != 1)
                {
                    pMemWinData->m_GenMemData.any.bus.BusNumber = 0;
                }

                GetDlgItemText(hDlg, IDC_EDIT_SLOT_NUMBER,
                               szTmp, _tsizeof(szTmp));
                if (sscanf(szTmp, "%d", &pMemWinData->
                           m_GenMemData.any.bus.SlotNumber) != 1)
                {
                    pMemWinData->m_GenMemData.any.bus.SlotNumber = 0;
                }

                //
                // Get the bus type
                //
                nPos = SendDlgItemMessage(hDlg,
                                          IDC_COMBO_BUS_DATA_TYPE,
                                          CB_GETCURSEL,
                                          0,
                                          0
                                          );

                if (CB_ERR == nPos) {
                    pMemWinData->m_GenMemData.any.bus.bus_type =
                        _BUS_DATA_TYPE(0);
                } else {
                    nIdx = (int)SendDlgItemMessage(hDlg,
                                                   IDC_COMBO_BUS_DATA_TYPE,
                                                   CB_GETITEMDATA,
                                                   (WPARAM) nPos,
                                                   0
                                                   );
                    if (CB_ERR == nIdx) {
                        pMemWinData->m_GenMemData.any.bus.bus_type =
                            _BUS_DATA_TYPE(0);
                    } else {
                        pMemWinData->m_GenMemData.any.bus.bus_type =
                            _BUS_DATA_TYPE(nIdx);
                    }
                }
                break;
            }

            return FALSE;
        }
        break;
    }

    return FALSE;
}

INT_PTR
CALLBACK
DlgProc_Physical_Mem(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    return DlgProc_MemoryProperties(PHYSICAL_MEM_TYPE, hDlg, uMsg, wParam, lParam);
}

INT_PTR
CALLBACK
DlgProc_Virtual_Mem(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    return DlgProc_MemoryProperties(VIRTUAL_MEM_TYPE, hDlg, uMsg, wParam, lParam);
}

INT_PTR
CALLBACK
DlgProc_IO_Mem(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    return DlgProc_MemoryProperties(IO_MEM_TYPE, hDlg, uMsg, wParam, lParam);
}

INT_PTR
CALLBACK
DlgProc_Bus_Mem(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    return DlgProc_MemoryProperties(BUS_MEM_TYPE, hDlg, uMsg, wParam, lParam);
}

INT_PTR
CALLBACK
DlgProc_Control_Mem(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    return DlgProc_MemoryProperties(CONTROL_MEM_TYPE, hDlg, uMsg, wParam, lParam);
}

INT_PTR
CALLBACK
DlgProc_MSR_Mem(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    return DlgProc_MemoryProperties(MSR_MEM_TYPE, hDlg, uMsg, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\windbg\format.cpp ===
/*++

Copyright (c) 1992-2002  Microsoft Corporation

Purpose:

    Formatting functions.

--*/


#include "precomp.hxx"
#pragma hdrstop



#define MAXNESTING      (50)

static TCHAR rgchOpenQuote[] = { _T('\"'), _T('\''), _T('('), _T('{'), _T('[') };
static TCHAR rgchCloseQuote[] = { _T('\"'), _T('\''), _T(')'), _T('}'), _T(']') };
#define MAXQUOTE        (_tsizeof(rgchOpenQuote) / _tsizeof(rgchOpenQuote[0]))

static TCHAR rgchDelim[] = { _T(' '), _T('\t'), _T(',') };
#define MAXDELIM        (_tsizeof(rgchDelim) / _tsizeof(rgchDelim[0]))

//extern  LPSHF   Lpshf;





int
CPCopyString(
    PTSTR * lplps,
    PTSTR lpT,
    TCHAR  chEscape,
    BOOL  fQuote
    )
/*++

Routine Description:

    Scan and copy an optionally quoted C-style string.  If the first character is
    a quote, a matching quote will terminate the string, otherwise the scanning will
    stop at the first whitespace encountered.  The target string will be null
    terminated if any characters are copied.

Arguments:

    lplps    - Supplies a pointer to a pointer to the source string

    lpt      - Supplies a pointer to the target string

    chEscape - Supplies the escape character (typically '\\')

    fQuote   - Supplies a flag indicating whether the first character is a quote

Return Value:

    The number of characters copied into lpt[].  If an error occurs, -1 is returned.

--*/
{
    PTSTR lps = *lplps;
    PTSTR lpt = lpT;
    int   i;
    int   n;
    int   err = 0;
    TCHAR  cQuote = _T('\0');

    if (fQuote) {
        if (*lps) {
            cQuote = *lps++;
        }
    }

    while (!err) {

        if (*lps == 0)
        {
            if (fQuote) {
                err = 1;
            } else {
                *lpt = _T('\0');
            }
            break;
        }
        else if (fQuote && *lps == cQuote)
        {
            *lpt = _T('\0');
            // eat the quote
            lps++;
            break;
        }
        else if (!fQuote &&  (!*lps || *lps == _T(' ') || *lps == _T('\t') || *lps == _T('\r') || *lps == _T('\n')))
        {
            *lpt = _T('\0');
            break;
        }

        else if (*lps != chEscape)
        {
            *lpt++ = *lps++;
        }
        else
        {
            switch (*++lps) {
              case 0:
                err = 1;
                --lps;
                break;

              default:     // any char - usually escape or quote
                *lpt++ = *lps;
                break;

              case _T('b'):    // backspace
                *lpt++ = _T('\b');
                break;

              case _T('f'):    // formfeed
                *lpt++ = _T('\f');
                break;

              case _T('n'):    // newline
                *lpt++ = _T('\n');
                break;

              case _T('r'):    // return
                *lpt++ = _T('\r');
                break;

              case _T('s'):    // space
                *lpt++ = _T(' ');
                break;

              case _T('t'):    // tab
                *lpt++ = _T('\t');
                break;

              case _T('0'):    // octal escape
                for (n = 0, i = 0; i < 3; i++) {
                    ++lps;
                    if (*lps < _T('0') || *lps > _T('7')) {
                        --lps;
                        break;
                    }
                    n = (n<<3) + *lps - _T('0');
                }
                *lpt++ = (UCHAR)(n & 0xff);
                break;
            }
            lps++;    // skip char from switch
        }

    }  // while

    if (err) {
        return -1;
    } else {
        *lplps = lps;
        return (int) (lpt - lpT);
    }
}



BOOL
CPFormatMemory(
    LPCH    lpchTarget,
    DWORD    cchTarget,
    LPBYTE  lpbSource,
    DWORD    cBits,
    FMTTYPE fmtType,
    DWORD    radix
    )

/*++

Routine Description:

    CPFormatMemory.

    formats a value by template

Arguments:

    lpchTarget - Destination buffer.

    cchTarget - Size of destination buffer.

    lpbSource - Data to be formatted.

    cBits - Number of bits in the data.

    fmtType - Determines how the data will be treated?? UINT, float, real, ...

    radix - Radix to use when formatting.

Return Value:

    TRUE - Success

    FALSE - Bad things happened

--*/
{
    LONG64      l;
    long        cb;
    ULONG64     ul = 0;
    TCHAR        rgch[512] = {0};


    Assert (radix == 2 || radix == 8 || radix == 10 || radix == 16 ||
            (fmtType & fmtBasis) == fmtAscii ||
            (fmtType & fmtBasis) == fmtUnicode);
    Assert (cBits != 0);
    Assert (cchTarget <= _tsizeof(rgch));

    switch (fmtType & fmtBasis) {
    //
    //  Format from memory bytes into an integer format number
    //
    case fmtInt:

        if (radix == 10) {

            switch( (cBits + 7)/8 ) {
            case 1:
                l = *(signed char *)lpbSource;
                if (fmtType & fmtZeroPad) {
                    _stprintf(rgch, _T("%0*I64d"), cchTarget-1, l);
                } else if (fmtType & fmtSpacePad) {
                    _stprintf(rgch, _T("% *I64d"), cchTarget-1, l);
                } else {
                    _stprintf(rgch, _T("% I64d"), l);
                }
                break;

            case 2:
                l = *(short *)lpbSource;
                if (fmtType & fmtZeroPad) {
                    _stprintf(rgch, _T("%0*I64d"), cchTarget-1, l);
                } else if (fmtType & fmtSpacePad) {
                    _stprintf(rgch, _T("% *I64d"), cchTarget-1, l);
                } else {
                    _stprintf(rgch, _T("% I64d"), l);
                }
                break;

            case 4:
                l = *(long *)lpbSource;
                if (fmtType & fmtZeroPad) {
                    _stprintf(rgch, _T("%0*I64d"), cchTarget-1, l);
                } else if (fmtType & fmtSpacePad) {
                    _stprintf(rgch, _T("% *I64d"), cchTarget-1, l);
                } else {
                    _stprintf(rgch, _T("% I64d"), l);
                }
                break;

            case 8:
                l = *(LONG64 *)lpbSource;
                if (fmtType & fmtZeroPad) {
                    _stprintf(rgch, _T("%0*I64d"), cchTarget-1, l);
                } else if (fmtType & fmtSpacePad) {
                    _stprintf(rgch, _T("% *I64d"), cchTarget-1, l);
                } else {
                    _stprintf(rgch, _T("% I64d"), l);
                }
                break;

            default:
                return FALSE; // Bad format
            }


            if (_tcslen(rgch) >= cchTarget) {
                return FALSE; // Overrun
            }

            _tcscpy(lpchTarget, rgch);

            break;
        }
        //
        // then we should handle this as UInt
        //

    case fmtUInt:

        cb = (cBits + 7)/8;
        switch( cb ) {
        case 1:
            ul = *(BYTE *) lpbSource;
            break;

        case 2:
            ul = *(USHORT *) lpbSource;
            break;

        case 4:
            ul = *(ULONG *) lpbSource;
            break;

//
// MBH - bugbug - CENTAUR bug;
// putting contents of instead of address of structure
// for return value in a0.
//

        case 8:
            ul = *(ULONG64 *) lpbSource;
            break;


        default:
            if (radix != 16 || (fmtType & fmtZeroPad) == 0) {
                return FALSE; // Bad format
            }
        }

        if (fmtType & fmtZeroPad) {
            switch (radix) {
            case 8:
                _stprintf(rgch, _T("%0*.*I64o"), cchTarget-1, cchTarget-1, ul);
                break;
            case 10:
                _stprintf(rgch, _T("%0*.*I64u"), cchTarget-1, cchTarget-1, ul);
                break;
            case 16:
                if (cb <= 8) {
                    _stprintf(rgch, _T("%0*.*I64x"), cchTarget-1, cchTarget-1, ul);
                } else {
                    // handle any size:
                    // NOTENOTE a-kentf this is dependent on byte order
                    for (l = 0; l < cb; l++) {
                        _stprintf(rgch+l+l, _T("%02.2x"), lpbSource[cb - l - 1]);
                    }
                    //_stprintf(rgch, _T("%0*.*x"), cchTarget-1, cchTarget-1, ul);
                }
                break;
            }
        } else if (fmtType & fmtSpacePad) {
            switch (radix) {
            case 8:
                _stprintf(rgch, _T("% *.*I64o"), cchTarget-1, cchTarget-1, ul);
                break;
            case 10:
                _stprintf(rgch, _T("% *.*I64u"), cchTarget-1, cchTarget-1, ul);
                break;
            case 16:
                if (cb <= 8) {
                    _stprintf(rgch, _T("% *.*I64x"), cchTarget-1, cchTarget-1, ul);
                } else {
                    // handle any size:
                    // NOTENOTE a-kentf this is dependent on byte order
                    /*for (l = 0; l < cb; l++) {
                        _stprintf(rgch+l+l, _T("% 2.2x"), lpbSource[cb - l - 1]);
                    }*/
                    _stprintf(rgch, _T("% *.*I64x"), cchTarget-1, cchTarget-1, ul);
                }
                break;
            }
        } else {
            switch (radix) {
            case 8:
                _stprintf(rgch, _T("%I64o"), ul);
                break;
            case 10:
                _stprintf(rgch, _T("%I64u"), ul);
                break;
            case 16:
                _stprintf(rgch, _T("%I64x"), ul);
                break;
            }
        }


        if (_tcslen(rgch) >= cchTarget) {
            return FALSE; // Overrun
        }

        _tcscpy(lpchTarget, rgch);

        break;


    case fmtAscii:
        if ( cBits != 8 ) {
            return FALSE; // Bad format
        }
        lpchTarget[0] = *(BYTE *) lpbSource;
        if ((lpchTarget[0] < _T(' ')) || (lpchTarget[0] > 0x7e)) {
            lpchTarget[0] = _T('.');
        }
        lpchTarget[1] = 0;
        return TRUE; // success

    case fmtUnicode:
        if (cBits != 16) {
            return FALSE; // Bad format
        }
    // This 2 should really be MB_CUR_MAX but that caused
    // a compatibility problem with Win2K as its definition
    // changed to a function.
        Assert(2 <= cchTarget);
        if ((wctomb(lpchTarget, *(LPWCH)lpbSource) == -1) ||
            (lpchTarget[0] < _T(' ')) ||
            (lpchTarget[0] > 0x7e)) {
            lpchTarget[0] = _T('.');
        }
        lpchTarget[1] = 0;
        return TRUE; // success

    case fmtFloat:
        switch ( cBits ) {
        case 4*8:
            _stprintf(rgch, _T("% 12.6e"),*((float *) lpbSource));
            break;

        case 8*8:
            //            _stprintf(rgch, _T("% 17.11le"), *((double *) lpbSource));
            _stprintf(rgch, _T("% 21.14le"), *((double *) lpbSource));
            break;

        case 10*8:
            if (_uldtoa((_ULDOUBLE *)lpbSource, 25, rgch) == NULL) {
                return FALSE; // Bad format
            }
            break;

        case 16*8:
            // v-vadimp this is an IA64 float - may have to rethink the format here
            // what we are getting here is really FLOAT128
            if (_uldtoa((_ULDOUBLE *)(lpbSource), 30, rgch) == NULL) {
                return FALSE; // Bad format
            }
            break;

        default:
            return FALSE; // Bad format

        }

        if (_tcslen(rgch) >= cchTarget) {
            return FALSE; // Overrun
        }

        _tcsncpy(lpchTarget, rgch, cchTarget-1);
        lpchTarget[cchTarget-1] = 0;
        return TRUE; // success

    case fmtBit:
        {
            WORD i,j,shift=0; //shift will allow for a blank after each 8 bits
            for (i=0;i<(cBits+7)/8;i++)  {
                for(j=0;j<8;j++) {
                    if((lpbSource[i]>> (7-j)) & 0x1) {
                        rgch[i*8+j+shift]=_T('1');
                    } else {
                        rgch[i*8+j+shift]=_T('0');
                    }
                }
                rgch[(i+1)*8+shift]=_T(' ');
                shift++;
            }
            rgch[cBits+shift-1]=_T('\0');
            if (_tcslen(rgch) >= cchTarget) {
                return FALSE; // Overrun
            }
            _tcscpy(lpchTarget,rgch);
        }
        return TRUE; // success

    default:

        return FALSE; // Bad format

    }

    return TRUE; // success
}                   /* CPFormatMemory() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\windbg\memlist.h ===
//
//  Doubly-linked list manipulation routines.  Implemented as macros
//  but logically these are procedures.
//

//
//  VOID
//  InitializeListHead(
//      PLIST_ENTRY ListHead
//      );
//

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

//
//  BOOLEAN
//  IsListEmpty(
//      PLIST_ENTRY ListHead
//      );
//

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))

//
//  PLIST_ENTRY
//  RemoveHeadList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}

//
//  PLIST_ENTRY
//  RemoveTailList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveTailList(ListHead) \
    (ListHead)->Blink;\
    {RemoveEntryList((ListHead)->Blink)}

//
//  VOID
//  RemoveEntryList(
//      PLIST_ENTRY Entry
//      );
//

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }

//
//  VOID
//  InsertTailList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }

//
//  VOID
//  InsertHeadList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    }

//
//
//  PSINGLE_LIST_ENTRY
//  PopEntryList(
//      PSINGLE_LIST_ENTRY ListHead
//      );
//

#define PopEntryList(ListHead) \
    (ListHead)->Next;\
    {\
        PSINGLE_LIST_ENTRY FirstEntry;\
        FirstEntry = (ListHead)->Next;\
        if (FirstEntry != NULL) {     \
            (ListHead)->Next = FirstEntry->Next;\
        }                             \
    }


//
//  VOID
//  PushEntryList(
//      PSINGLE_LIST_ENTRY ListHead,
//      PSINGLE_LIST_ENTRY Entry
//      );
//

#define PushEntryList(ListHead,Entry) \
    (Entry)->Next = (ListHead)->Next; \
    (ListHead)->Next = (Entry)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\windbg\memwin.cpp ===
/*++

Copyright (c) 1992-2002  Microsoft Corporation

Module Name:

    Memwin.cpp

Abstract:

    This module contains the main line code for display of multiple memory
    windows and the subclassed win proc to handle editing, display, etc.

--*/


#include "precomp.hxx"
#pragma hdrstop

_INTERFACE_TYPE_NAMES rgInterfaceTypeNames[MaximumInterfaceType] =
{
    { Internal,             "Internal" },
    { Isa,                  "Isa" },
    { Eisa,                 "Eisa" },
    { MicroChannel,         "MicroChannel" },
    { TurboChannel,         "TurboChannel" },
    { PCIBus,               "PCIBus" },
    { VMEBus,               "VMEBus" },
    { NuBus,                "NuBus" },
    { PCMCIABus,            "PCMCIABus" },
    { CBus,                 "CBus" },
    { MPIBus,               "MPIBus" },
    { MPSABus,              "MPSABus" },
    { ProcessorInternal,    "ProcessorInternal" },
    { InternalPowerBus,     "InternalPowerBus" },
    { PNPISABus,            "PNPISABus" },
    { PNPBus,               "PNPBus" }
};

_BUS_TYPE_NAMES rgBusTypeNames[MaximumBusDataType] =
{
    { Cmos,                     "Cmos" },
    { EisaConfiguration,        "EisaConfiguration" },
    { Pos,                      "Pos" },
    { CbusConfiguration,        "CbusConfiguration" },
    { PCIConfiguration,         "PCIConfiguration" },
    { VMEConfiguration,         "VMEConfiguration" },
    { NuBusConfiguration,       "NuBusConfiguration" },
    { PCMCIAConfiguration,      "PCMCIAConfiguration" },
    { MPIConfiguration,         "MPIConfiguration" },
    { MPSAConfiguration,        "MPSAConfiguration" },
    { PNPISAConfiguration,      "PNPISAConfiguration" },
    { SgiInternalConfiguration, "SgiInternalConfiguration" }
};

PSTR g_MemTypeNames[] =
{
    "Virtual:", "Physical:", "Control:", "I/O:", "MSR:", "Bus data:"
};


//
//
//
MEMWIN_DATA::MEMWIN_DATA()
    : EDITWIN_DATA(512)
{
    m_enumType = MEM_WINDOW;

    ZeroMemory(&m_GenMemData, sizeof(m_GenMemData));

    strcpy(m_OffsetExpr, FormatAddr64(g_EventIp));
    m_GenMemData.memtype = VIRTUAL_MEM_TYPE;
    m_GenMemData.nDisplayFormat = 3;
    m_Columns = 4;
    m_WindowDataSize = 0;
}

void
MEMWIN_DATA::Validate()
{
    EDITWIN_DATA::Validate();

    Assert(MEM_WINDOW == m_enumType);
}

HRESULT
MEMWIN_DATA::ReadState(void)
{
    HRESULT Status;
    ULONG DataNeeded;
    PVOID Data;
    ULONG64 Offset;
    DEBUG_VALUE Value;
    ULONG i;

    // Evaluate offset expression.
    if ((Status = g_pDbgControl->Evaluate(m_OffsetExpr, DEBUG_VALUE_INT64,
                                          &Value, NULL)) != S_OK)
    {
        return Status;
    }

    Offset = Value.I64;

    // Compute how much data to retrieve.  We don't want to
    // create a big matrix of memtype/display format so just
    // ask for a chunk of data big enough for any display format.
    DataNeeded = m_LineHeight * m_Columns * 2 * sizeof(ULONG64);

    Empty();
    Data = AddData(DataNeeded);
    if (Data == NULL)
    {
        return E_OUTOFMEMORY;
    }

    ULONG Read;

    switch(m_GenMemData.memtype)
    {
    default:
        Assert(!"Unhandled condition");
        Status = E_FAIL;
        break;

    case PHYSICAL_MEM_TYPE:
        Status = g_pDbgData->ReadPhysical(Offset,
                                          Data,
                                          DataNeeded,
                                          &Read
                                          );
        break;

    case VIRTUAL_MEM_TYPE:
        Status = g_pDbgData->ReadVirtual(Offset,
                                         Data,
                                         DataNeeded,
                                         &Read
                                         );
        break;

    case CONTROL_MEM_TYPE:
        Status = g_pDbgData->ReadControl(m_GenMemData.any.control.Processor,
                                         Offset,
                                         Data,
                                         DataNeeded,
                                         &Read
                                         );
        break;

    case IO_MEM_TYPE:
        Status = g_pDbgData->ReadIo(m_GenMemData.any.io.interface_type,
                                    m_GenMemData.any.io.BusNumber,
                                    m_GenMemData.any.io.AddressSpace,
                                    Offset,
                                    Data,
                                    DataNeeded,
                                    &Read
                                    );
        break;

    case MSR_MEM_TYPE:
        Read = 0;
        for (i = 0; i < DataNeeded / sizeof(ULONG64); i++)
        {
            if ((Status = g_pDbgData->ReadMsr((ULONG)Offset + i,
                                              (PULONG64)Data + i
                                              )) != S_OK)
            {
                // Assume an error means we've run out of MSRs to
                // read.  If some were read, don't consider it an error.
                if (Read > 0)
                {
                    Status = S_OK;
                }
                break;
            }

            Read += sizeof(ULONG64);
        }
        break;

    case BUS_MEM_TYPE:
        Status = g_pDbgData->ReadBusData(m_GenMemData.any.bus.bus_type,
                                         m_GenMemData.any.bus.BusNumber,
                                         m_GenMemData.any.bus.SlotNumber,
                                         (ULONG)Offset,
                                         Data,
                                         DataNeeded,
                                         &Read
                                         );
        break;
    }

    if (Status == S_OK)
    {
        // Trim data back if read didn't get everything.
        RemoveTail(DataNeeded - Read);
        m_OffsetRead = Offset;
    }

    return Status;
}

BOOL
MEMWIN_DATA::HasEditableProperties()
{
    return TRUE;
}

BOOL
MEMWIN_DATA::EditProperties()
/*++
Returns
    TRUE - If properties were edited
    FALSE - If nothing was changed
--*/
{
    if (g_TargetClass != DEBUG_CLASS_UNINITIALIZED)
    {
        INT_PTR Res = DisplayOptionsPropSheet(GetParent(m_hwndChild),
                                              g_hInst,
                                              m_GenMemData.memtype
                                              );
        if (IDOK == Res)
        {
            UpdateOptions();
            return TRUE; // Properties have been changed
        }
    }

    MessageBeep(0);
    return FALSE;         // No Debuggee or User Cancel out.
}

BOOL
MEMWIN_DATA::OnCreate(void)
{
    RECT Rect;
    int i;
    ULONG Height;

    Height = GetSystemMetrics(SM_CYVSCROLL) + 4 * GetSystemMetrics(SM_CYEDGE);

    m_Toolbar = CreateWindowEx(0, REBARCLASSNAME, NULL,
                               WS_VISIBLE | WS_CHILD |
                               WS_CLIPCHILDREN | WS_CLIPSIBLINGS |
                               CCS_NODIVIDER | CCS_NOPARENTALIGN |
                               RBS_VARHEIGHT | RBS_BANDBORDERS,
                               0, 0, m_Size.cx, Height, m_Win,
                               (HMENU)ID_TOOLBAR,
                               g_hInst, NULL);
    if (m_Toolbar == NULL)
    {
        return FALSE;
    }

    REBARINFO BarInfo;
    BarInfo.cbSize = sizeof(BarInfo);
    BarInfo.fMask = 0;
    BarInfo.himl = NULL;
    SendMessage(m_Toolbar, RB_SETBARINFO, 0, (LPARAM)&BarInfo);

    REBARBANDINFO BandInfo;
    BandInfo.cbSize = sizeof(BandInfo);
    BandInfo.fMask = RBBIM_TEXT | RBBIM_CHILD | RBBIM_CHILDSIZE;

    m_ToolbarEdit = CreateWindowEx(WS_EX_CLIENTEDGE, "EDIT", NULL,
                                   WS_VISIBLE | WS_CHILD | ES_AUTOHSCROLL,
                                   0, 0, 18 *
                                   m_Font->Metrics.tmAveCharWidth,
                                   Height, m_Toolbar, (HMENU)IDC_EDIT_OFFSET,
                                   g_hInst, NULL);
    if (m_ToolbarEdit == NULL)
    {
        return FALSE;
    }

    SendMessage(m_ToolbarEdit, WM_SETFONT, (WPARAM)m_Font->Font, 0);
    SendMessage(m_ToolbarEdit, EM_LIMITTEXT, sizeof(m_OffsetExpr) - 1, 0);

    GetClientRect(m_ToolbarEdit, &Rect);

    BandInfo.lpText = "Offset:";
    BandInfo.hwndChild = m_ToolbarEdit;
    BandInfo.cxMinChild = Rect.right - Rect.left;
    BandInfo.cyMinChild = Rect.bottom - Rect.top;
    SendMessage(m_Toolbar, RB_INSERTBAND, -1, (LPARAM)&BandInfo);

    m_FormatCombo = CreateWindowEx(0, "COMBOBOX", NULL,
                                   WS_VISIBLE | WS_CHILD | WS_VSCROLL |
                                   CBS_SORT | CBS_DROPDOWNLIST, 0, 0,
                                   15 * m_Font->Metrics.tmAveCharWidth,
                                   (g_nMaxNumFormatsMemWin *
                                    m_Font->Metrics.tmHeight / 2),
                                   m_Toolbar, (HMENU)IDC_COMBO_DISPLAY_FORMAT,
                                   g_hInst, NULL);
    if (m_FormatCombo == NULL)
    {
        return FALSE;
    }

    SendMessage(m_FormatCombo, WM_SETFONT, (WPARAM)m_Font->Font, 0);

    for (i = 0; i < g_nMaxNumFormatsMemWin; i++)
    {
        LRESULT Idx;

        // The format strings will be sorted so mark them with
        // their true index for retrieval when selected.
        Idx = SendMessage(m_FormatCombo, CB_ADDSTRING,
                          0, (LPARAM)g_FormatsMemWin[i].lpszDescription);
        SendMessage(m_FormatCombo, CB_SETITEMDATA, (WPARAM)Idx, i);
    }

    GetClientRect(m_FormatCombo, &Rect);

    BandInfo.lpText = "Display format:";
    BandInfo.hwndChild = m_FormatCombo;
    BandInfo.cxMinChild = Rect.right - Rect.left;
    BandInfo.cyMinChild = Rect.bottom - Rect.top;
    SendMessage(m_Toolbar, RB_INSERTBAND, -1, (LPARAM)&BandInfo);

    PSTR PrevText = "Previous";
    m_PreviousButton =
        AddButtonBand(m_Toolbar, PrevText, PrevText, IDC_MEM_PREVIOUS);
    m_NextButton =
        AddButtonBand(m_Toolbar, "Next", PrevText, IDC_MEM_NEXT);
    if (m_PreviousButton == NULL || m_NextButton == NULL)
    {
        return FALSE;
    }

    // Maximize the space for the offset expression.
    SendMessage(m_Toolbar, RB_MAXIMIZEBAND, 0, FALSE);

    GetClientRect(m_Toolbar, &Rect);
    m_ToolbarHeight = Rect.bottom - Rect.top + GetSystemMetrics(SM_CYEDGE);
    m_ShowToolbar = TRUE;

    if (!EDITWIN_DATA::OnCreate())
    {
        return FALSE;
    }

    SendMessage(m_hwndChild, EM_SETBKGNDCOLOR, FALSE,
                g_Colors[COL_PLAIN].Color);

    SendMessage(m_hwndChild, EM_SETEVENTMASK, 0, ENM_KEYEVENTS);
    UpdateOptions();
    return TRUE;
}

LRESULT
MEMWIN_DATA::OnCommand(
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch(LOWORD(wParam))
    {
    case IDC_EDIT_OFFSET:
        if (HIWORD(wParam) == EN_CHANGE)
        {
            // This message is sent on every keystroke
            // which causes a bit too much updating.
            // Set up a timer to trigger the actual
            // update in half a second.
            SetTimer(m_Win, IDC_EDIT_OFFSET, EDIT_DELAY, NULL);
            m_UpdateExpr = TRUE;
        }
        break;

    case IDC_COMBO_DISPLAY_FORMAT:
        if (HIWORD(wParam) == CBN_SELCHANGE)
        {
            LRESULT Sel = SendMessage((HWND)lParam, CB_GETCURSEL, 0, 0);
            if (Sel != CB_ERR)
            {
                m_GenMemData.nDisplayFormat = (int)
                    SendMessage((HWND)lParam, CB_GETITEMDATA, (WPARAM)Sel, 0);
                UpdateOptions();
                UiRequestRead();
            }
        }
        break;

    case IDC_MEM_PREVIOUS:
        ScrollLower();
        break;
    case IDC_MEM_NEXT:
        ScrollHigher();
        break;
    }

    return 0;
}

void
MEMWIN_DATA::OnSize(void)
{
    EDITWIN_DATA::OnSize();

    // Force buffer to refill for new line count.
    UiRequestRead();
}

void
MEMWIN_DATA::OnTimer(WPARAM TimerId)
{
    if (TimerId == IDC_EDIT_OFFSET && m_UpdateExpr)
    {
        m_UpdateExpr = FALSE;
        if (SendMessage(m_ToolbarEdit, EM_GETMODIFY, 0,0))
        {
            GetWindowText(m_ToolbarEdit, m_OffsetExpr, sizeof(m_OffsetExpr));
            SendMessage(m_ToolbarEdit, EM_SETMODIFY, 0,0);
            UiRequestRead();
        }
//      KillTimer(m_Win, IDC_EDIT_OFFSET);
    }
}

LRESULT
MEMWIN_DATA::OnNotify(WPARAM Wpm, LPARAM Lpm)
{
    LPNMHDR Hdr = (LPNMHDR)Lpm;

    switch(Hdr->code)
    {
    case RBN_HEIGHTCHANGE:
        PostMessage(m_Win, WU_RECONFIGURE, 0, 0);
        break;
    case EN_MSGFILTER:
        MSGFILTER* Filter = (MSGFILTER*)Lpm;

        if (Filter->msg == WM_KEYDOWN)
        {
            switch(Filter->wParam)
            {
            case VK_UP:
            {
                CHARRANGE range;

                SendMessage(m_hwndChild, EM_EXGETSEL, 0, (LPARAM) &range);
                if (!SendMessage(m_hwndChild, EM_LINEFROMCHAR,
                                 range.cpMin, 0))
                {
                    // up arrow on top line, scroll
                    ScrollLower();
                    return TRUE;
                }
                break;
            }
            case VK_DOWN:
            {
                CHARRANGE range;
                int MaxLine;

                SendMessage(m_hwndChild, EM_EXGETSEL, 0, (LPARAM) &range);
                MaxLine = (int)SendMessage(m_hwndChild, EM_GETLINECOUNT, 0, 0);

                if (MaxLine == (1 + SendMessage(m_hwndChild, EM_LINEFROMCHAR,
                                                range.cpMin, 0)))
                {
                    // down arrow on bottom line, scroll
                    ScrollHigher();
                    return TRUE;
                }
                break;
            }

            case VK_PRIOR:
                ScrollLower();
                return TRUE;
            case VK_NEXT:
                ScrollHigher();
                return TRUE;

            case VK_LEFT: case VK_RIGHT:
                break;
            case VK_DELETE:
                MessageBeep(0);
                return TRUE;
            default:
                // Allow default processing of everything else
                return TRUE;
            }
        }
        else if (Filter->msg == WM_KEYUP)
        {
            return TRUE;
        }

        if (ES_READONLY & GetWindowLongPtr(m_hwndChild, GWL_STYLE))
        {
            break;
        }
        if (Filter->msg == WM_CHAR)
        {
            switch(Filter->wParam)
            {
            case '0': case '1': case '2': case '3': case '4':
            case '5': case '6': case '7': case '8': case '9':
            case 'a': case 'A': case 'b': case 'B': case 'c':
            case 'C': case 'd': case 'D': case 'e': case 'E':
            case 'f': case 'F':
            {
                CHARRANGE value;
                ULONG charIndex;
                ULONG64 Address;
                CHAR writeval[2] = {0};

                writeval[0] = (CHAR) tolower((CHAR) Filter->wParam);
                Address = GetAddressOfCurValue(&charIndex, &value);
                if (Address)
                {
                    TEXTRANGE textRange;

                    SendMessage(m_hwndChild, EM_SETSEL,
                                charIndex, charIndex+1);
                    SendMessage(m_hwndChild, EM_REPLACESEL,
                                FALSE, (LPARAM) writeval);

                    textRange.chrg = value;
                    textRange.lpstrText = &m_ValueExpr[0];
                    if (SendMessage(m_hwndChild, EM_GETTEXTRANGE,
                                    0, (LPARAM) &textRange))
                    {
                        m_ValueExpr[charIndex - value.cpMin] = writeval[0];
                        WriteValue(Address);
                        SendMessage(m_hwndChild, EM_SETSEL,
                                    charIndex+1, charIndex+1);
                        return TRUE;
                    }
                }
            }

            default:
                MessageBeep(0);
                return TRUE;
            }
        }
        break;
    }

    return EDITWIN_DATA::OnNotify(Wpm, Lpm);
}

void
MEMWIN_DATA::OnUpdate(
    UpdateType Type
    )
{
    if (Type != UPDATE_BUFFER)
    {
        return;
    }

    HRESULT Status;

    Status = UiLockForRead();
    if (Status == S_OK)
    {
        ULONG charIndex;
        SendMessage(m_hwndChild, EM_GETSEL, (WPARAM) &charIndex, NULL);

        SendMessage(m_hwndChild, WM_SETREDRAW, FALSE, 0);

        CHARRANGE Sel;

        // Select everything so it's all replaced.
        Sel.cpMin = 0;
        Sel.cpMax = -1;
        SendMessage(m_hwndChild, EM_EXSETSEL, 0, (LPARAM)&Sel);

        TCHAR Buf[64];
        TCHAR CharBuf[64];
        TCHAR* ColChar;
        ULONG Row, Col;
        ULONG64 Offset;
        ULONG64 DataEnd;
        PUCHAR Data;
        ULONG Bytes;
        _FORMATS_MEM_WIN* Fmt = g_FormatsMemWin + m_GenMemData.nDisplayFormat;

        Offset = m_OffsetRead;
        Data = (PUCHAR)m_Data;
        DataEnd = Offset + m_DataUsed;
        Bytes = (Fmt->cBits + 7) / 8;

        for (Row = 0; Row < m_LineHeight; Row++)
        {
            SendMessage(m_hwndChild, EM_REPLACESEL, FALSE,
                        (LPARAM)FormatAddr64(Offset));

            ColChar = CharBuf;
            *ColChar++ = ' ';
            *ColChar++ = ' ';

            for (Col = 0; Col < m_Columns; Col++)
            {
                if (Offset < DataEnd)
                {
                    _tcscpy(Buf, _T(" "));

                    // If the formatting succeeds,
                    // Buf contains the formatted data.
                    if (!CPFormatMemory(Buf + 1,
                                        (DWORD)min(_tsizeof(Buf) - 1,
                                                   Fmt->cchMax + 1),
                                        Data,
                                        Fmt->cBits,
                                        Fmt->fmtType,
                                        Fmt->radix))
                    {
                        // Else we don't know what to format
                        for (UINT uTmp = 0; uTmp < Bytes; uTmp++)
                        {
                            m_AllowWrite = FALSE;
                            _tcscat(Buf + 1, _T("??"));
                        }
                    }

                    if (Fmt->fTwoFields)
                    {
                        if (!CPFormatMemory(ColChar, 1, Data, 8,
                                            fmtAscii, 0))
                        {
                            *ColChar = '?';
                        }

                        ColChar++;
                    }
                }
                else
                {
                    m_AllowWrite = FALSE;
                    _tcscpy(Buf, _T(" ????????"));
                    *ColChar++ = '?';
                }
                SendMessage(m_hwndChild, EM_REPLACESEL, FALSE, (LPARAM)Buf);

                Data += Bytes;
                Offset += Bytes;
            }

            if (Fmt->fTwoFields)
            {
                *ColChar = 0;
                SendMessage(m_hwndChild, EM_REPLACESEL,
                            FALSE, (LPARAM)CharBuf);
            }

            // Don't complete the last line to avoid leaving
            // a blank line at the bottom.
            if (Row < m_LineHeight - 1)
            {
                SendMessage(m_hwndChild, EM_REPLACESEL, FALSE, (LPARAM)"\n");
            }
        }

        m_WindowDataSize = (ULONG)(Offset - m_OffsetRead);

        UnlockStateBuffer(this);

        SendMessage(m_hwndChild, WM_SETREDRAW, TRUE, 0);
        InvalidateRect(m_hwndChild, NULL, TRUE);

        SendMessage(m_hwndChild, EM_SETSEL, charIndex, charIndex);
    }
    else
    {
        SendLockStatusMessage(m_hwndChild, WM_SETTEXT, Status);
    }
}

void
MEMWIN_DATA::ScrollLower(void)
{
    ULONG64 Offs = m_OffsetRead;

    if (Offs >= m_WindowDataSize)
    {
        Offs -= m_WindowDataSize;
    }
    else
    {
        Offs = 0;
    }
    sprintf(m_OffsetExpr, "0x%I64x", Offs);
    UiRequestRead();
}

void
MEMWIN_DATA::ScrollHigher(void)
{
    ULONG64 Offs = m_OffsetRead;

    if (Offs + m_WindowDataSize > Offs)
    {
        Offs += m_WindowDataSize;
    }
    else
    {
        Offs = (ULONG64)-1 - m_WindowDataSize;
    }
    sprintf(m_OffsetExpr, "0x%I64x", Offs);
    UiRequestRead();
}

void
MEMWIN_DATA::UpdateOptions(void)
{
    REBARBANDINFO BandInfo;

    BandInfo.cbSize = sizeof(BandInfo);
    BandInfo.fMask = RBBIM_TEXT;
    BandInfo.lpText = g_MemTypeNames[m_GenMemData.memtype];
    SendMessage(m_Toolbar, RB_SETBANDINFO, 0, (LPARAM)&BandInfo);
    SetWindowText(m_ToolbarEdit, m_OffsetExpr);

    m_AllowWrite = (m_GenMemData.memtype == PHYSICAL_MEM_TYPE ||
        m_GenMemData.memtype == VIRTUAL_MEM_TYPE) &&
        ((g_FormatsMemWin[m_GenMemData.nDisplayFormat].fmtType & fmtBasis) == fmtUInt ||
         (g_FormatsMemWin[m_GenMemData.nDisplayFormat].fmtType & fmtBasis) == fmtInt ||
         (g_FormatsMemWin[m_GenMemData.nDisplayFormat].fmtType & fmtBasis) == fmtAddress
         ) &&
        g_FormatsMemWin[m_GenMemData.nDisplayFormat].radix == 16;

    SendMessage(m_hwndChild, EM_SETREADONLY, !m_AllowWrite, 0);

    for (LONG Idx = 0; Idx < g_nMaxNumFormatsMemWin; Idx++)
    {
        if ((LONG)SendMessage(m_FormatCombo, CB_GETITEMDATA, Idx, 0) ==
            m_GenMemData.nDisplayFormat)
        {
            SendMessage(m_FormatCombo, CB_SETCURSEL, Idx, 0);
            break;
        }
    }

    switch(m_GenMemData.memtype)
    {
    case MSR_MEM_TYPE:
        m_Columns = 1;
        break;
    default:
        if ((g_FormatsMemWin[m_GenMemData.nDisplayFormat].fmtType &
             fmtBasis) == fmtBit)
        {
            m_Columns = 8;
        }
        else if ((g_FormatsMemWin[m_GenMemData.nDisplayFormat].fmtType &
             fmtBasis) == fmtAscii ||
            (g_FormatsMemWin[m_GenMemData.nDisplayFormat].fmtType &
             fmtBasis) == fmtUnicode ||
            g_FormatsMemWin[m_GenMemData.nDisplayFormat].cBits == 8)
        {
            m_Columns = 16;
        }
        else if (g_FormatsMemWin[m_GenMemData.nDisplayFormat].cBits == 16)
        {
            m_Columns = 8;
        }
        else if (g_FormatsMemWin[m_GenMemData.nDisplayFormat].cBits > 64)
        {
            m_Columns = 2;
        }
        else
        {
            m_Columns = 4;
        }
        break;
    }
}

void
MEMWIN_DATA::WriteValue(
    ULONG64 Offset
    )
{
    if (!m_AllowWrite)
    {
        return;
    }
    ULONG64 Data;
    ULONG Size;
    DEBUG_VALUE Value;

    // Evaluate value expression.
    if (g_pDbgControl->Evaluate(m_ValueExpr, DEBUG_VALUE_INT64,
                                &Value, NULL) != S_OK)
    {
        return;
    }
    Data = Value.I64;
    Size = g_FormatsMemWin[m_GenMemData.nDisplayFormat].cBits / 8;
    UIC_WRITE_DATA_DATA* WriteData;

    WriteData = StartStructCommand(UIC_WRITE_DATA);
    if (WriteData == NULL)
    {
        return;
    }

    // Fill in WriteData members.
    memcpy(WriteData->Data, &Data, Size);
    WriteData->Length = Size;
    WriteData->Offset = Offset;
    WriteData->Type = m_GenMemData.memtype;
    WriteData->Any  = m_GenMemData.any;
    FinishCommand();
}

ULONG64
MEMWIN_DATA::GetAddressOfCurValue(
    PULONG pCharIndex,
    CHARRANGE *pCRange
    )
{
    CHARRANGE range;
    ULONG CurLine, FirstLineChar, CurCol;

    SendMessage(m_hwndChild, EM_EXGETSEL, NULL, (LPARAM) &range);
    CurLine = (ULONG)SendMessage(m_hwndChild, EM_LINEFROMCHAR, range.cpMin, 0);
    FirstLineChar = (ULONG)SendMessage(m_hwndChild, EM_LINEINDEX, CurLine, 0);
    CurCol = range.cpMin - FirstLineChar;

    ULONG Length;
    PCHAR pLineTxt = (PCHAR)
        malloc(Length = ((ULONG)SendMessage(m_hwndChild, EM_LINELENGTH,
                                            FirstLineChar, 0) + 2));

    if (!pLineTxt)
    {
        return 0;
    }

    Assert(Length >= CurCol);

    ZeroMemory(pLineTxt, Length);
 //   Assert (Length = (ULONG) SendMessage(m_hwndChild, EM_GETLINE, (WPARAM) CurLine, (LPARAM) pLineTxt));
    TEXTRANGE textrange;
    textrange.chrg.cpMin = FirstLineChar;
    textrange.chrg.cpMax = FirstLineChar + Length-2;
    textrange.lpstrText = (LPSTR) pLineTxt;
    SendMessage(m_hwndChild, EM_GETTEXTRANGE, 0, (LPARAM) &textrange);

    ULONG ValueCol=0, Index=0, ValueIndex=0;
    while (pLineTxt[CurCol] == ' ')
    {
        CurCol++;
    }
    while (Index < CurCol)
    {
        if (pLineTxt[Index] == ' ')
        {
            