placing irps in the list under the protection of the
    cancel spin lock.

Arguments:

    Extension - A pointer to the serial device extension.

Return Value:

    Will return pending for everything put the first
    request that we actually process.  Even in that
    case it will return pending unless it can complete
    it right away.


--*/

{

    //
    // The current stack location.  This contains much of the
    // information we need to process this particular request.
    //
    PIO_STACK_LOCATION IrpSp;

    PIRP NewIrp;

    BOOLEAN SetFirstStatus = FALSE;
    NTSTATUS FirstStatus;

    SERIAL_LOCKED_PAGED_CODE();

    SerialDbgPrintEx(SERDIAG3, "In SerialStartMask\n");

    ASSERT(Extension->CurrentMaskIrp);

    do {

        SerialDbgPrintEx(SERDIAG4, "STARTMASK - CurrentMaskIrp: %x\n",
                         Extension->CurrentMaskIrp);
        IrpSp = IoGetCurrentIrpStackLocation(Extension->CurrentMaskIrp);

        ASSERT((IrpSp->Parameters.DeviceIoControl.IoControlCode ==
                IOCTL_SERIAL_WAIT_ON_MASK) ||
               (IrpSp->Parameters.DeviceIoControl.IoControlCode ==
                IOCTL_SERIAL_SET_WAIT_MASK));

        if (IrpSp->Parameters.DeviceIoControl.IoControlCode ==
            IOCTL_SERIAL_SET_WAIT_MASK) {

            SerialDbgPrintEx(SERDIAG4, "SERIAL - %x is a SETMASK irp\n",
                             Extension->CurrentMaskIrp);

            //
            // Complete the old wait if there is one.
            //

            KeSynchronizeExecution(
                Extension->Interrupt,
                SerialFinishOldWait,
                Extension
                );

            //
            // Any current waits should be on its way to completion
            // at this point.  There certainly shouldn't be any
            // irp mask location.
            //

            ASSERT(!Extension->IrpMaskLocation);

            Extension->CurrentMaskIrp->IoStatus.Status = STATUS_SUCCESS;

            if (!SetFirstStatus) {

                SerialDbgPrintEx(SERDIAG4, "%x was the first irp processed by "
                                 "this\n"
                                 "------- invocation of startmask\n",
                                 Extension->CurrentMaskIrp);

                FirstStatus = STATUS_SUCCESS;
                SetFirstStatus = TRUE;

            }

            //
            // The following call will also cause the current
            // call to be completed.
            //

            SerialGetNextIrp(
                &Extension->CurrentMaskIrp,
                &Extension->MaskQueue,
                &NewIrp,
                TRUE,
                Extension
                );
            SerialDbgPrintEx(SERDIAG4, "Perhaps another mask irp was found in "
                             "the queue\n"
                             "------- %x/%x <- values should be the same\n",
                             Extension->CurrentMaskIrp,NewIrp);


        } else {

            //
            // First make sure that we have a non-zero mask.
            // If the app queues a wait on a zero mask it can't
            // be statisfied so it makes no sense to start it.
            //

            if ((!Extension->IsrWaitMask) || (Extension->CurrentWaitIrp)) {

                SerialDbgPrintEx(SERDIAG4, "WaitIrp is invalid\n"
                                 "------- IsrWaitMask: %x\n"
                                 "------- CurrentWaitIrp: %x\n",
                                 Extension->IsrWaitMask,
                                 Extension->CurrentWaitIrp);

                Extension->CurrentMaskIrp->IoStatus.Status
                   = STATUS_INVALID_PARAMETER;

                if (!SetFirstStatus) {

                    SerialDbgPrintEx(SERDIAG4, "%x was the first irp processed "
                                     "by this\n"
                                     "------- invocation of startmask\n",
                                     Extension->CurrentMaskIrp);

                    FirstStatus = STATUS_INVALID_PARAMETER;
                    SetFirstStatus = TRUE;

                }

                SerialGetNextIrp(&Extension->CurrentMaskIrp,
                                 &Extension->MaskQueue, &NewIrp, TRUE,
                                 Extension);

                SerialDbgPrintEx(SERDIAG4, "Perhaps another mask irp was found "
                                 "in the queue\n"
                                 "------- %x/%x <- values should be the same\n",
                                 Extension->CurrentMaskIrp,NewIrp);

            } else {

                KIRQL OldIrql;

                //
                // Make the current mask irp the current wait irp and
                // get a new current mask irp.  Note that when we get
                // the new current mask irp we DO NOT complete the
                // old current mask irp (which is now the current wait
                // irp.
                //
                // Then under the protection of the cancel spin lock
                // we check to see if the current wait irp needs to
                // be canceled
                //

                IoAcquireCancelSpinLock(&OldIrql);

                if (Extension->CurrentMaskIrp->Cancel) {

                    SerialDbgPrintEx(SERDIAG4, "%x irp was already marked as "
                                     "cancelled\n", Extension->CurrentMaskIrp);

                    IoReleaseCancelSpinLock(OldIrql);
                    Extension->CurrentMaskIrp->IoStatus.Status = STATUS_CANCELLED;

                    if (!SetFirstStatus) {

                        SerialDbgPrintEx(SERDIAG4, "%x was the first irp "
                                         "processed by this\n"
                                         "------- invocation of startmask\n",
                                         Extension->CurrentMaskIrp);

                        FirstStatus = STATUS_CANCELLED;
                        SetFirstStatus = TRUE;

                    }

                    SerialGetNextIrp(&Extension->CurrentMaskIrp,
                                     &Extension->MaskQueue, &NewIrp, TRUE,
                                     Extension);

                    SerialDbgPrintEx(SERDIAG4, "Perhaps another mask irp was "
                                     "found in the queue\n"
                                     "------- %x/%x <- values should be the "
                                     "same\n", Extension->CurrentMaskIrp,
                                     NewIrp);

                } else {

                    SerialDbgPrintEx(SERDIAG4, "%x will become the current "
                                     "wait irp\n", Extension->CurrentMaskIrp);
                    if (!SetFirstStatus) {

                        SerialDbgPrintEx(SERDIAG4, "%x was the first irp "
                                         "processed by this\n"
                                         "------- invocation of startmask\n",
                                         Extension->CurrentMaskIrp);

                        FirstStatus = STATUS_PENDING;
                        SetFirstStatus = TRUE;

                        //
                        // If we haven't already set a first status
                        // then there is a chance that this packet
                        // was never on the queue.  We should mark
                        // it as pending.
                        //

                        IoMarkIrpPending(Extension->CurrentMaskIrp);

                    }

                    //
                    // There should never be a mask location when
                    // there isn't a current wait irp.  At this point
                    // there shouldn't be a current wait irp also.
                    //

                    ASSERT(!Extension->IrpMaskLocation);
                    ASSERT(!Extension->CurrentWaitIrp);

                    Extension->CurrentWaitIrp = Extension->CurrentMaskIrp;
                    SERIAL_INIT_REFERENCE(Extension->CurrentWaitIrp);
                    IoSetCancelRoutine(
                        Extension->CurrentWaitIrp,
                        SerialCancelWait
                        );

                    //
                    // Since the cancel routine has a reference to
                    // the irp we need to update the reference
                    // count.
                    //

                    SERIAL_SET_REFERENCE(
                        Extension->CurrentWaitIrp,
                        SERIAL_REF_CANCEL
                        );

                    KeSynchronizeExecution(
                        Extension->Interrupt,
                        SerialGiveWaitToIsr,
                        Extension
                        );

                    //
                    // Since it isn't really the mask irp anymore,
                    // null out that pointer.
                    //

                    Extension->CurrentMaskIrp = NULL;

                    //
                    // This will release the cancel spinlock for us
                    //

                    SerialGetNextIrpLocked(&Extension->CurrentMaskIrp,
                                           &Extension->MaskQueue, &NewIrp,
                                           FALSE, Extension, OldIrql);

                    SerialDbgPrintEx(SERDIAG4, "Perhaps another mask irp was "
                                     "found in the queue\n"
                                     "------- %x/%x <- values should be the "
                                     "same\n", Extension->CurrentMaskIrp,
                                     NewIrp);

                }

            }

        }

    } while (NewIrp);

    return FirstStatus;

}

BOOLEAN
SerialGrabWaitFromIsr(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine will check to see if the ISR still knows about
    a wait irp by checking to see if the IrpMaskLocation is non-null.
    If it is then it will zero the Irpmasklocation (which in effect
    grabs the irp away from the isr).  This routine is only called
    buy the cancel code for the wait.

    NOTE: This is called by KeSynchronizeExecution.

Arguments:

    Context - A pointer to the device extension

Return Value:

    Always FALSE.

--*/

{

    PSERIAL_DEVICE_EXTENSION Extension = Context;
    SERIAL_LOCKED_PAGED_CODE();

    SerialDbgPrintEx(SERDIAG3, "In SerialGrabWaitFromIsr\n");

    if (Extension->IrpMaskLocation) {

        SerialDbgPrintEx(SERDIAG4, "The isr still owns the irp %x, mask "
                         "location is %x\n"
                         "------- and system buffer is %x\n",
                         Extension->CurrentWaitIrp,Extension->IrpMaskLocation,
                         Extension->CurrentWaitIrp->AssociatedIrp.SystemBuffer);

        //
        // The isr still "owns" the irp.
        //

        *Extension->IrpMaskLocation = 0;
        Extension->IrpMaskLocation = NULL;

        Extension->CurrentWaitIrp->IoStatus.Information = sizeof(ULONG);

        //
        // Since the isr no longer references the irp we need to
        // decrement the reference count.
        //

        SERIAL_CLEAR_REFERENCE(
            Extension->CurrentWaitIrp,
            SERIAL_REF_ISR
            );

    }

    return FALSE;
}

BOOLEAN
SerialGiveWaitToIsr(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine simply sets a variable in the device extension
    so that the isr knows that we have a wait irp.

    NOTE: This is called by KeSynchronizeExecution.

    NOTE: This routine assumes that it is called with the
          cancel spinlock held.

Arguments:

    Context - Simply a pointer to the device extension.

Return Value:

    Always FALSE.

--*/

{

    PSERIAL_DEVICE_EXTENSION Extension = Context;
    SERIAL_LOCKED_PAGED_CODE();

    SerialDbgPrintEx(SERDIAG3, "In SerialGiveWaitToIsr\n");
    //
    // There certainly shouldn't be a current mask location at
    // this point since we have a new current wait irp.
    //

    ASSERT(!Extension->IrpMaskLocation);

    //
    // The isr may or may not actually reference this irp.  It
    // won't if the wait can be satisfied immediately.  However,
    // since it will then go through the normal completion sequence,
    // we need to have an incremented reference count anyway.
    //

    SERIAL_SET_REFERENCE(
        Extension->CurrentWaitIrp,
        SERIAL_REF_ISR
        );

    if (!Extension->HistoryMask) {

        SerialDbgPrintEx(SERDIAG4, "No events occured prior to the wait call"
                         "\n");

        //
        // Although this wait might not be for empty transmit
        // queue, it doesn't hurt anything to set it to false.
        //

        Extension->EmptiedTransmit = FALSE;

        //
        // Record where the "completion mask" should be set.
        //

        Extension->IrpMaskLocation =
            Extension->CurrentWaitIrp->AssociatedIrp.SystemBuffer;
        SerialDbgPrintEx( SERDIAG4, "The isr owns the irp %x, mask location is "
                          "%x\n"
                          "------- and system buffer is %x\n",
                          Extension->CurrentWaitIrp,Extension->IrpMaskLocation,
                          Extension->CurrentWaitIrp->AssociatedIrp
                          .SystemBuffer);

    } else {

        SerialDbgPrintEx(SERDIAG4, "%x occurred prior to the wait - starting "
                         "the\n"
                         "------- completion code for %x\n",
                         Extension->HistoryMask,Extension->CurrentWaitIrp);

        *((ULONG *)Extension->CurrentWaitIrp->AssociatedIrp.SystemBuffer) =
            Extension->HistoryMask;
        Extension->HistoryMask = 0;
        Extension->CurrentWaitIrp->IoStatus.Information = sizeof(ULONG);
        Extension->CurrentWaitIrp->IoStatus.Status = STATUS_SUCCESS;

        SerialInsertQueueDpc(&Extension->CommWaitDpc, NULL, NULL, Extension);

    }

    return FALSE;
}

BOOLEAN
SerialFinishOldWait(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine will check to see if the ISR still knows about
    a wait irp by checking to see if the Irpmasklocation is non-null.
    If it is then it will zero the Irpmasklocation (which in effect
    grabs the irp away from the isr).  This routine is only called
    buy the cancel code for the wait.

    NOTE: This is called by KeSynchronizeExecution.

Arguments:

    Context - A pointer to the device extension

Return Value:

    Always FALSE.

--*/

{

    PSERIAL_DEVICE_EXTENSION Extension = Context;
    SERIAL_LOCKED_PAGED_CODE();

    SerialDbgPrintEx(SERDIAG3, "In SerialFinishOldWait\n");

    if (Extension->IrpMaskLocation) {

        SerialDbgPrintEx(SERDIAG4, "The isr still owns the irp %x, mask "
                         "location is %x\n"
                         "------- and system buffer is %x\n",
                         Extension->CurrentWaitIrp,Extension->IrpMaskLocation,
                         Extension->CurrentWaitIrp->AssociatedIrp.SystemBuffer);
        //
        // The isr still "owns" the irp.
        //

        *Extension->IrpMaskLocation = 0;
        Extension->IrpMaskLocation = NULL;

        Extension->CurrentWaitIrp->IoStatus.Information = sizeof(ULONG);

        //
        // We don't decrement the reference since the completion routine
        // will do that.
        //

        SerialInsertQueueDpc(&Extension->CommWaitDpc, NULL, NULL, Extension);

    }

    //
    // Don't wipe out any historical data we are still interested in.
    //

    Extension->HistoryMask &= *((ULONG *)Extension->CurrentMaskIrp->
                                            AssociatedIrp.SystemBuffer);

    Extension->IsrWaitMask = *((ULONG *)Extension->CurrentMaskIrp->
                                            AssociatedIrp.SystemBuffer);
    SerialDbgPrintEx( SERDIAG4, "Set mask location of %x, in irp %x, with "
                      "system buffer of %x\n",
                      Extension->IrpMaskLocation, Extension->CurrentMaskIrp,
                      Extension->CurrentMaskIrp->AssociatedIrp.SystemBuffer);
    return FALSE;
}

VOID
SerialCancelWait(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is used to cancel a irp that is waiting on
    a comm event.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    None.

--*/

{

    PSERIAL_DEVICE_EXTENSION Extension = DeviceObject->DeviceExtension;
    SERIAL_LOCKED_PAGED_CODE();

    SerialDbgPrintEx(SERDIAG3, "In SerialCancelWait\n");

    SerialDbgPrintEx(SERDIAG4, "Canceling wait for irp %x\n",
                     Extension->CurrentWaitIrp);

    SerialTryToCompleteCurrent(Extension, SerialGrabWaitFromIsr,
                               Irp->CancelIrql, STATUS_CANCELLED,
                               &Extension->CurrentWaitIrp, NULL, NULL, NULL,
                               NULL, NULL, SERIAL_REF_CANCEL);

}

VOID
SerialCompleteWait(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )

{
    PSERIAL_DEVICE_EXTENSION Extension = DeferredContext;
    KIRQL OldIrql;


    SerialDbgPrintEx(DPFLTR_TRACE_LEVEL, ">SerialCompleteWait(%X)\n",
                     Extension);

    SerialDbgPrintEx(SERDIAG3, "In SerialCompleteWait\n");

    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    IoAcquireCancelSpinLock(&OldIrql);

    SerialDbgPrintEx(SERDIAG4, "Completing wait for irp %x\n",
                     Extension->CurrentWaitIrp);

    SerialTryToCompleteCurrent(Extension, NULL, OldIrql, STATUS_SUCCESS,
                               &Extension->CurrentWaitIrp, NULL, NULL, NULL,
                               NULL, NULL, SERIAL_REF_ISR);

    SerialDpcEpilogue(Extension, Dpc);


    SerialDbgPrintEx(DPFLTR_TRACE_LEVEL, "<SerialCompleteWait\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\serial\test\tinsertw.c ===
//
// This test the line status and modem status insertion.
//

#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include "windows.h"

#define SIZEOFBUF 1000000
UCHAR writeBuff[SIZEOFBUF];

int __cdecl main(int argc,char *argv[]) {

    HANDLE hFile;
    DCB myDcb;
    char *myPort = "COM1";
    unsigned char escapeChar = 0xff;
    DWORD numberToWrite;
    DWORD numberActuallyWrote;
    DWORD useBaud = 1200;
    COMMTIMEOUTS to = {0};
    int totalCount;
    int j;

    if (argc > 1) {

        sscanf(argv[1],"%d",&numberToWrite);

        if (argc > 2) {

            sscanf(argv[2],"%d",&useBaud);

            if (argc > 3) {

                myPort = argv[3];

            }

        }

    }

    //
    // Fill up the write buff with a known data stream.
    //

    for (
        totalCount = 0;
        totalCount < numberToWrite;
        ) {

        for (
            j = 0;
            j <= 9;
            j++
            ) {

            writeBuff[totalCount] = j;
            totalCount++;
            if (totalCount >= numberToWrite) {

                break;

            }

        }

    }


    if ((hFile = CreateFile(
                     myPort,
                     GENERIC_READ | GENERIC_WRITE,
                     0,
                     NULL,
                     CREATE_ALWAYS,
                     FILE_ATTRIBUTE_NORMAL,
                     NULL
                     )) == ((HANDLE)-1)) {

        printf("Couldn't open the comm port\n");
        exit(1);

    }

    if (!SetCommTimeouts(
            hFile,
            &to
            )) {

        printf("Couldn't set the timeouts\n");
        exit(1);

    }

    //
    // We've successfully opened the file.  Set the state of
    // the comm device.  First we get the old values and
    // adjust to our own.
    //

    if (!GetCommState(
             hFile,
             &myDcb
             )) {

        printf("Couldn't get the comm state: %d\n",GetLastError());
        exit(1);

    }

    myDcb.BaudRate = useBaud;
    myDcb.ByteSize = 8;
    myDcb.Parity = NOPARITY;
    myDcb.StopBits = ONESTOPBIT;

    //
    // Make sure that no flow control is turned on.
    //

    myDcb.fOutxDsrFlow = FALSE;
    myDcb.fOutxCtsFlow = FALSE;
    myDcb.fDsrSensitivity = FALSE;
    myDcb.fOutX = FALSE;
    myDcb.fInX = FALSE;
    myDcb.fDtrControl = DTR_CONTROL_DISABLE;
    myDcb.fRtsControl = RTS_CONTROL_DISABLE;

    if (!SetCommState(
            hFile,
            &myDcb
            )) {

        printf("Couldn't set the comm state.\n");
        exit(1);

    }

    //
    // Write the number of chars asked to write.
    // But for each char we do:
    //
    // 1) One plain write of the char.
    // 2) Cut the baud in half and write the same char.
    // 3) Reset the baud.
    // 4) Set Break.
    // 5) Clear break.
    // 6) Enable the DTR Line.
    // 7) Enable the RTS Line.
    // 8) Clear the RTS Line.
    // 9) Clear the DTR Line.
    // 10) Set the parity to even.
    // 11) Send the char.
    // 12) Set the parity to none.
    // 13) Send the original char.
    //

    for (
        j = 0;
        j < numberToWrite;
        j++
        ) {

        if (!WriteFile(
                 hFile,
                 &writeBuff[j],
                 1,
                 &numberActuallyWrote,
                 NULL
                 )) {

            printf("bad status on write: %d\n",GetLastError());
            exit(1);

        }

        if (numberActuallyWrote != 1) {

            printf("Couldn't write plain character number: %d\n",j);
            exit(1);

        }

        myDcb.BaudRate = useBaud / 2;

        if (!SetCommState(
                hFile,
                &myDcb
                )) {

            printf("Couldn't half the baud rate during write.\n");
            exit(1);

        }

        if (!WriteFile(
                 hFile,
                 &writeBuff[j],
                 1,
                 &numberActuallyWrote,
                 NULL
                 )) {

            printf("bad status on half baud write: %d\n",GetLastError());
            exit(1);

        }

        if (numberActuallyWrote != 1) {

            printf("Couldn't write half baud character number: %d\n",j);
            exit(1);

        }

        //
        // Give the serial time to do work.
        //

        Sleep(20);

        //
        // Reset the baud.
        //

        myDcb.BaudRate = useBaud;

        if (!SetCommState(
                hFile,
                &myDcb
                )) {

            printf("Couldn't reset the baud during write.\n");
            exit(1);

        }

        if (!EscapeCommFunction(
                 hFile,
                 SETBREAK
                 )) {

            printf("Couldn't set the break during write.\n");
            exit(1);

        }

        Sleep(20);

        if (!EscapeCommFunction(
                 hFile,
                 CLRBREAK
                 )) {

            printf("Couldn't clr the break during write.\n");
            exit(1);

        }

        Sleep(20);

        if (!EscapeCommFunction(
                 hFile,
                 SETDTR
                 )) {

            printf("Couldn't set the dtr during write.\n");
            exit(1);

        }

        Sleep(100);

        if (!EscapeCommFunction(
                 hFile,
                 SETRTS
                 )) {

            printf("Couldn't set the rts during write.\n");
            exit(1);

        }

        Sleep(20);

        if (!EscapeCommFunction(
                 hFile,
                 CLRRTS
                 )) {

            printf("Couldn't clr the rts during write.\n");
            exit(1);

        }

        Sleep(20);

        if (!EscapeCommFunction(
                 hFile,
                 CLRDTR
                 )) {

            printf("Couldn't clr the dtr during write.\n");
            exit(1);

        }

        Sleep(20);

        myDcb.Parity = EVENPARITY;

        if (!SetCommState(
                hFile,
                &myDcb
                )) {

            printf("Couldn't adjust the parity during write.\n");
            exit(1);

        }

        if (!WriteFile(
                 hFile,
                 &writeBuff[j],
                 1,
                 &numberActuallyWrote,
                 NULL
                 )) {

            printf("bad status on even parity write: %d\n",GetLastError());
            exit(1);

        }

        Sleep(20);

        //
        // Reset the parity.
        //

        myDcb.Parity = NOPARITY;

        if (!SetCommState(
                hFile,
                &myDcb
                )) {

            printf("Couldn't reset the parity during write.\n");
            exit(1);

        }

        if (!WriteFile(
                 hFile,
                 &escapeChar,
                 1,
                 &numberActuallyWrote,
                 NULL
                 )) {

            printf("bad status escape char write: %d\n",GetLastError());
            exit(1);

        }

        if (numberActuallyWrote != 1) {

            printf("Couldn't write escape char number: %d\n",j);
            exit(1);

        }

        if (!WriteFile(
                 hFile,
                 &writeBuff[j],
                 1,
                 &numberActuallyWrote,
                 NULL
                 )) {

            printf("bad status on terminating write: %d\n",GetLastError());
            exit(1);

        }

        if (numberActuallyWrote != 1) {

            printf("Couldn't write terminating plain character number: %d\n",j);
            exit(1);

        }

        Sleep(20);

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\serial\write.c ===
/*++

Copyright (c) 1991, 1992, 1993 - 1997 Microsoft Corporation

Module Name:

    write.c

Abstract:

    This module contains the code that is very specific to write
    operations in the serial driver

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

--*/

#include "precomp.h"


BOOLEAN
SerialGiveWriteToIsr(
    IN PVOID Context
    );

VOID
SerialCancelCurrentWrite(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

BOOLEAN
SerialGrabWriteFromIsr(
    IN PVOID Context
    );

BOOLEAN
SerialGrabXoffFromIsr(
    IN PVOID Context
    );

VOID
SerialCancelCurrentXoff(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

BOOLEAN
SerialGiveXoffToIsr(
    IN PVOID Context
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGESER,SerialProcessEmptyTransmit)
#pragma alloc_text(PAGESER,SerialWrite)
#pragma alloc_text(PAGESER,SerialStartWrite)
#pragma alloc_text(PAGESER,SerialGetNextWrite)
#pragma alloc_text(PAGESER,SerialGiveWriteToIsr)
#pragma alloc_text(PAGESER,SerialCancelCurrentWrite)
#pragma alloc_text(PAGESER,SerialGrabWriteFromIsr)
#pragma alloc_text(PAGESER,SerialGrabXoffFromIsr)
#pragma alloc_text(PAGESER,SerialCancelCurrentXoff)
#pragma alloc_text(PAGESER,SerialGiveXoffToIsr)
#endif


NTSTATUS
SerialWrite(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the dispatch routine for write.  It validates the parameters
    for the write request and if all is ok then it places the request
    on the work queue.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    If the io is zero length then it will return STATUS_SUCCESS,
    otherwise this routine will return STATUS_PENDING.

--*/

{

    PSERIAL_DEVICE_EXTENSION Extension = DeviceObject->DeviceExtension;
    NTSTATUS status;

    SERIAL_LOCKED_PAGED_CODE();

    SerialDbgPrintEx(DPFLTR_TRACE_LEVEL, ">SerialWrite(%X, %X)\n", DeviceObject,
                     Irp);

    if ((status = SerialIRPPrologue(Irp, Extension)) != STATUS_SUCCESS) {
      if (status != STATUS_PENDING) {
         SerialCompleteRequest(Extension, Irp, IO_NO_INCREMENT);
      }
      SerialDbgPrintEx(DPFLTR_TRACE_LEVEL, "<SerialWrite (1) %X\n", status);
      return status;
   }

    SerialDbgPrintEx(SERIRPPATH, "Dispatch entry for: %x\n", Irp);

    if (SerialCompleteIfError(DeviceObject, Irp) != STATUS_SUCCESS) {
       SerialDbgPrintEx(DPFLTR_TRACE_LEVEL, "<SerialWrite (2) %X\n",
                        STATUS_CANCELLED);
       return STATUS_CANCELLED;
    }

    Irp->IoStatus.Information = 0L;

    //
    // Quick check for a zero length write.  If it is zero length
    // then we are already done!
    //

    if (IoGetCurrentIrpStackLocation(Irp)->Parameters.Write.Length) {

        //
        // Well it looks like we actually have to do some
        // work.  Put the write on the queue so that we can
        // process it when our previous writes are done.
        //


       status = SerialStartOrQueue(Extension, Irp, &Extension->WriteQueue,
                                   &Extension->CurrentWriteIrp,
                                   SerialStartWrite);

       SerialDbgPrintEx(DPFLTR_TRACE_LEVEL, "<SerialWrite (3) %X\n", status);

       return status;

    } else {

        Irp->IoStatus.Status = STATUS_SUCCESS;

        SerialCompleteRequest(Extension, Irp, 0);

        SerialDbgPrintEx(DPFLTR_TRACE_LEVEL, "<SerialWrite (4) %X\n",
                         STATUS_SUCCESS);

        return STATUS_SUCCESS;

    }

}

NTSTATUS
SerialStartWrite(
    IN PSERIAL_DEVICE_EXTENSION Extension
    )

/*++

Routine Description:

    This routine is used to start off any write.  It initializes
    the Iostatus fields of the irp.  It will set up any timers
    that are used to control the write.

Arguments:

    Extension - Points to the serial device extension

Return Value:

    This routine will return STATUS_PENDING for all writes
    other than those that we find are cancelled.

--*/

{

    PIRP NewIrp;
    KIRQL OldIrql;
    LARGE_INTEGER TotalTime;
    BOOLEAN UseATimer;
    SERIAL_TIMEOUTS Timeouts;
    BOOLEAN SetFirstStatus = FALSE;
    NTSTATUS FirstStatus;

    SERIAL_LOCKED_PAGED_CODE();

    SerialDbgPrintEx(DPFLTR_TRACE_LEVEL, ">SerialStartWrite(%X)\n", Extension);

    do {

        //
        // If there is an xoff counter then complete it.
        //

        IoAcquireCancelSpinLock(&OldIrql);

        //
        // We see if there is a actually an Xoff counter irp.
        //
        // If there is, we put the write irp back on the head
        // of the write list.  We then kill the xoff counter.
        // The xoff counter killing code will actually make the
        // xoff counter back into the current write irp, and
        // in the course of completing the xoff (which is now
        // the current write) we will restart this irp.
        //

        if (Extension->CurrentXoffIrp) {

            if (SERIAL_REFERENCE_COUNT(Extension->CurrentXoffIrp)) {

                //
                // The reference count is non-zero.  This implies that
                // the xoff irp has not made it through the completion
                // path yet.  We will increment the reference count
                // and attempt to complete it ourseleves.
                //

                SERIAL_SET_REFERENCE(
                    Extension->CurrentXoffIrp,
                    SERIAL_REF_XOFF_REF
                    );

                Extension->CurrentXoffIrp->IoStatus.Information = 0;

                //
                // The following call will actually release the
                // cancel spin lock.
                //

                SerialTryToCompleteCurrent(
                    Extension,
                    SerialGrabXoffFromIsr,
                    OldIrql,
                    STATUS_SERIAL_MORE_WRITES,
                    &Extension->CurrentXoffIrp,
                    NULL,
                    NULL,
                    &Extension->XoffCountTimer,
                    NULL,
                    NULL,
                    SERIAL_REF_XOFF_REF
                    );

            } else {

                //
                // The irp is well on its way to being finished.
                // We can let the regular completion code do the
                // work.  Just release the spin lock.
                //

                IoReleaseCancelSpinLock(OldIrql);

            }

        } else {

            IoReleaseCancelSpinLock(OldIrql);

        }

        UseATimer = FALSE;

        //
        // Calculate the timeout value needed for the
        // request.  Note that the values stored in the
        // timeout record are in milliseconds.  Note that
        // if the timeout values are zero then we won't start
        // the timer.
        //

        KeAcquireSpinLock(
            &Extension->ControlLock,
            &OldIrql
            );

        Timeouts = Extension->Timeouts;

        KeReleaseSpinLock(
            &Extension->ControlLock,
            OldIrql
            );

        if (Timeouts.WriteTotalTimeoutConstant ||
            Timeouts.WriteTotalTimeoutMultiplier) {

            PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(
                                           Extension->CurrentWriteIrp
                                           );
            UseATimer = TRUE;

            //
            // We have some timer values to calculate.
            //
            // Take care, we might have an xoff counter masquerading
            // as a write.
            //

            TotalTime.QuadPart =
                ((LONGLONG)((UInt32x32To64(
                                 (IrpSp->MajorFunction == IRP_MJ_WRITE)?
                                     (IrpSp->Parameters.Write.Length):
                                     (1),
                                 Timeouts.WriteTotalTimeoutMultiplier
                                 )
                                 + Timeouts.WriteTotalTimeoutConstant)))
                * -10000;

        }

        //
        // The irp may be going to the isr shortly.  Now
        // is a good time to initialize its reference counts.
        //

        SERIAL_INIT_REFERENCE(Extension->CurrentWriteIrp);

        //
        // We need to see if this irp should be canceled.
        //

        IoAcquireCancelSpinLock(&OldIrql);
        if (Extension->CurrentWriteIrp->Cancel) {

            IoReleaseCancelSpinLock(OldIrql);
            Extension->CurrentWriteIrp->IoStatus.Status = STATUS_CANCELLED;

            if (!SetFirstStatus) {

                FirstStatus = STATUS_CANCELLED;
                SetFirstStatus = TRUE;

            }

        } else {

            if (!SetFirstStatus) {

                //
                // If we haven't set our first status, then
                // this is the only irp that could have possibly
                // not been on the queue.  (It could have been
                // on the queue if this routine is being invoked
                // from the completion routine.)  Since this
                // irp might never have been on the queue we
                // should mark it as pending.
                //

                IoMarkIrpPending(Extension->CurrentWriteIrp);
                SetFirstStatus = TRUE;
                FirstStatus = STATUS_PENDING;

            }

            //
            // We give the irp to to the isr to write out.
            // We set a cancel routine that knows how to
            // grab the current write away from the isr.
            //
            // Since the cancel routine has an implicit reference
            // to this irp up the reference count.
            //

            IoSetCancelRoutine(
                Extension->CurrentWriteIrp,
                SerialCancelCurrentWrite
                );

            SERIAL_SET_REFERENCE(
                Extension->CurrentWriteIrp,
                SERIAL_REF_CANCEL
                );

            if (UseATimer) {

                SerialSetTimer(
                    &Extension->WriteRequestTotalTimer,
                    TotalTime,
                    &Extension->TotalWriteTimeoutDpc,
                    Extension
                    );

                //
                // This timer now has a reference to the irp.
                //

                SERIAL_SET_REFERENCE(
                    Extension->CurrentWriteIrp,
                    SERIAL_REF_TOTAL_TIMER
                    );
            }

            KeSynchronizeExecution(
                Extension->Interrupt,
                SerialGiveWriteToIsr,
                Extension
                );

            IoReleaseCancelSpinLock(OldIrql);
            break;

        }

        //
        // Well the write was canceled before we could start it up.
        // Try to get another.
        //

        SerialGetNextWrite(&Extension->CurrentWriteIrp, &Extension->WriteQueue,
                           &NewIrp, TRUE, Extension);

    } while (NewIrp);

    SerialDbgPrintEx(DPFLTR_TRACE_LEVEL, "<SerialStartWrite %X\n", FirstStatus);

    return FirstStatus;
}

VOID
SerialGetNextWrite(
    IN PIRP *CurrentOpIrp,
    IN PLIST_ENTRY QueueToProcess,
    IN PIRP *NewIrp,
    IN BOOLEAN CompleteCurrent,
    PSERIAL_DEVICE_EXTENSION Extension
    )

/*++

Routine Description:

    This routine completes the old write as well as getting
    a pointer to the next write.

    The reason that we have have pointers to the current write
    queue as well as the current write irp is so that this
    routine may be used in the common completion code for
    read and write.

Arguments:

    CurrentOpIrp - Pointer to the pointer that points to the
                   current write irp.

    QueueToProcess - Pointer to the write queue.

    NewIrp - A pointer to a pointer to the irp that will be the
             current irp.  Note that this could end up pointing
             to a null pointer.  This does NOT necessaryly mean
             that there is no current write.  What could occur
             is that while the cancel lock is held the write
             queue ended up being empty, but as soon as we release
             the cancel spin lock a new irp came in from
             SerialStartWrite.

    CompleteCurrent - Flag indicates whether the CurrentOpIrp should
                      be completed.

Return Value:

    None.

--*/

{
   SERIAL_LOCKED_PAGED_CODE();

   SerialDbgPrintEx(DPFLTR_TRACE_LEVEL, ">SerialGetNextWrite(XXX)\n");


    do {


        //
        // We could be completing a flush.
        //

        if (IoGetCurrentIrpStackLocation(*CurrentOpIrp)->MajorFunction
            == IRP_MJ_WRITE) {

            KIRQL OldIrql;

            ASSERT(Extension->TotalCharsQueued >=
                   (IoGetCurrentIrpStackLocation(*CurrentOpIrp)
                    ->Parameters.Write.Length));

            IoAcquireCancelSpinLock(&OldIrql);
            Extension->TotalCharsQueued -=
                IoGetCurrentIrpStackLocation(*CurrentOpIrp)
                ->Parameters.Write.Length;
            IoReleaseCancelSpinLock(OldIrql);

        } else if (IoGetCurrentIrpStackLocation(*CurrentOpIrp)->MajorFunction
                   == IRP_MJ_DEVICE_CONTROL) {

            KIRQL OldIrql;
            PIRP Irp;
            PSERIAL_XOFF_COUNTER Xc;

            IoAcquireCancelSpinLock(&OldIrql);

            Irp = *CurrentOpIrp;
            Xc = Irp->AssociatedIrp.SystemBuffer;

            //
            // We should never have a xoff counter when we
            // get to this point.
            //

            ASSERT(!Extension->CurrentXoffIrp);

            //
            // We absolutely shouldn't have a cancel routine
            // at this point.
            //

            ASSERT(!Irp->CancelRoutine);

            //
            // This could only be a xoff counter masquerading as
            // a write irp.
            //

            Extension->TotalCharsQueued--;

            //
            // Check to see of the xoff irp has been set with success.
            // This means that the write completed normally.  If that
            // is the case, and it hasn't been set to cancel in the
            // meanwhile, then go on and make it the CurrentXoffIrp.
            //

            if (Irp->IoStatus.Status != STATUS_SUCCESS) {

                //
                // Oh well, we can just finish it off.
                //
                NOTHING;

            } else if (Irp->Cancel) {

                Irp->IoStatus.Status = STATUS_CANCELLED;

            } else {

                //
                // Give it a new cancel routine, and increment the
                // reference count because the cancel routine has
                // a reference to it.
                //

                IoSetCancelRoutine(
                    Irp,
                    SerialCancelCurrentXoff
                    );

                SERIAL_SET_REFERENCE(
                    Irp,
                    SERIAL_REF_CANCEL
                    );

                //
                // We don't want to complete the current irp now.  This
                // will now get completed by the Xoff counter code.
                //

                CompleteCurrent = FALSE;

                //
                // Give the counter to the isr.
                //

                Extension->CurrentXoffIrp = Irp;
                KeSynchronizeExecution(
                    Extension->Interrupt,
                    SerialGiveXoffToIsr,
                    Extension
                    );

                //
                // Start the timer for the counter and increment
                // the reference count since the timer has a
                // reference to the irp.
                //

                if (Xc->Timeout) {

                    LARGE_INTEGER delta;

                    delta.QuadPart = -((LONGLONG)UInt32x32To64(
                                                     1000,
                                                     Xc->Timeout
                                                     ));

                    SerialSetTimer(
                        &Extension->XoffCountTimer,
                        delta,
                        &Extension->XoffCountTimeoutDpc,
                        Extension

                        );

                    SERIAL_SET_REFERENCE(
                        Irp,
                        SERIAL_REF_TOTAL_TIMER
                        );

                }

            }

            IoReleaseCancelSpinLock(OldIrql);

        }

        //
        // Note that the following call will (probably) also cause
        // the current irp to be completed.
        //

        SerialGetNextIrp(
            CurrentOpIrp,
            QueueToProcess,
            NewIrp,
            CompleteCurrent,
            Extension
            );

        if (!*NewIrp) {

            KIRQL OldIrql;

            IoAcquireCancelSpinLock(&OldIrql);
            KeSynchronizeExecution(
                Extension->Interrupt,
                SerialProcessEmptyTransmit,
                Extension
                );
            IoReleaseCancelSpinLock(OldIrql);

            break;

        } else if (IoGetCurrentIrpStackLocation(*NewIrp)->MajorFunction
                   == IRP_MJ_FLUSH_BUFFERS) {

            //
            // If we encounter a flush request we just want to get
            // the next irp and complete the flush.
            //
            // Note that if NewIrp is non-null then it is also
            // equal to CurrentWriteIrp.
            //


            ASSERT((*NewIrp) == (*CurrentOpIrp));
            (*NewIrp)->IoStatus.Status = STATUS_SUCCESS;

        } else {

            break;

        }

    } while (TRUE);

    SerialDbgPrintEx(DPFLTR_TRACE_LEVEL, "<SerialGetNextWrite\n");

}

VOID
SerialCompleteWrite(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )

/*++

Routine Description:

    This routine is merely used to complete any write.  It
    assumes that the status and the information fields of
    the irp are already correctly filled in.

Arguments:

    Dpc - Not Used.

    DeferredContext - Really points to the device extension.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

--*/

{

    PSERIAL_DEVICE_EXTENSION Extension = DeferredContext;
    KIRQL OldIrql;

    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    SerialDbgPrintEx(DPFLTR_TRACE_LEVEL, ">SerialCompleteWrite(%X)\n",
                     Extension);

    IoAcquireCancelSpinLock(&OldIrql);

    SerialTryToCompleteCurrent(Extension, NULL, OldIrql, STATUS_SUCCESS,
                               &Extension->CurrentWriteIrp,
                               &Extension->WriteQueue, NULL,
                               &Extension->WriteRequestTotalTimer,
                               SerialStartWrite, SerialGetNextWrite,
                               SERIAL_REF_ISR);

    SerialDpcEpilogue(Extension, Dpc);

    SerialDbgPrintEx(DPFLTR_TRACE_LEVEL, "<SerialCompleteWrite\n");

}

BOOLEAN
SerialProcessEmptyTransmit(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is used to determine if conditions are appropriate
    to satisfy a wait for transmit empty event, and if so to complete
    the irp that is waiting for that event.  It also call the code
    that checks to see if we should lower the RTS line if we are
    doing transmit toggling.

    NOTE: This routine is called by KeSynchronizeExecution.

    NOTE: This routine assumes that it is called with the cancel
          spinlock held.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

--*/

{

    PSERIAL_DEVICE_EXTENSION Extension = Context;
    SERIAL_LOCKED_PAGED_CODE();

    if (Extension->IsrWaitMask && (Extension->IsrWaitMask & SERIAL_EV_TXEMPTY) &&
        Extension->EmptiedTransmit && (!Extension->TransmitImmediate) &&
        (!Extension->CurrentWriteIrp) && IsListEmpty(&Extension->WriteQueue)) {

        Extension->HistoryMask |= SERIAL_EV_TXEMPTY;
        if (Extension->IrpMaskLocation) {

            *Extension->IrpMaskLocation = Extension->HistoryMask;
            Extension->IrpMaskLocation = NULL;
            Extension->HistoryMask = 0;

            Extension->CurrentWaitIrp->IoStatus.Information = sizeof(ULONG);
            SerialInsertQueueDpc(
                &Extension->CommWaitDpc,
                NULL,
                NULL,
                Extension
                );

        }

        Extension->CountOfTryingToLowerRTS++;
        SerialPerhapsLowerRTS(Extension);

    }

    return FALSE;

}

BOOLEAN
SerialGiveWriteToIsr(
    IN PVOID Context
    )

/*++

Routine Description:

    Try to start off the write by slipping it in behind
    a transmit immediate char, or if that isn't available
    and the transmit holding register is empty, "tickle"
    the UART into interrupting with a transmit buffer
    empty.

    NOTE: This routine is called by KeSynchronizeExecution.

    NOTE: This routine assumes that it is called with the
          cancel spin lock held.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

--*/

{

    PSERIAL_DEVICE_EXTENSION Extension = Context;

    //
    // The current stack location.  This contains all of the
    // information we need to process this particular request.
    //
    PIO_STACK_LOCATION IrpSp;

    SERIAL_LOCKED_PAGED_CODE();

    IrpSp = IoGetCurrentIrpStackLocation(Extension->CurrentWriteIrp);

    //
    // We might have a xoff counter request masquerading as a
    // write.  The length of these requests will always be one
    // and we can get a pointer to the actual character from
    // the data supplied by the user.
    //

    if (IrpSp->MajorFunction == IRP_MJ_WRITE) {

        Extension->WriteLength = IrpSp->Parameters.Write.Length;
        Extension->WriteCurrentChar =
            Extension->CurrentWriteIrp->AssociatedIrp.SystemBuffer;

    } else {

        Extension->WriteLength = 1;
        Extension->WriteCurrentChar =
            ((PUCHAR)Extension->CurrentWriteIrp->AssociatedIrp.SystemBuffer) +
            FIELD_OFFSET(
                SERIAL_XOFF_COUNTER,
                XoffChar
                );

    }

    //
    // The isr now has a reference to the irp.
    //

    SERIAL_SET_REFERENCE(
        Extension->CurrentWriteIrp,
        SERIAL_REF_ISR
        );

    //
    // Check first to see if an immediate char is transmitting.
    // If it is then we'll just slip in behind it when its
    // done.
    //

    if (!Extension->TransmitImmediate) {

        //
        // If there is no immediate char transmitting then we
        // will "re-enable" the transmit holding register empty
        // interrupt.  The 8250 family of devices will always
        // signal a transmit holding register empty interrupt
        // *ANY* time this bit is set to one.  By doing things
        // this way we can simply use the normal interrupt code
        // to start off this write.
        //
        // We've been keeping track of whether the transmit holding
        // register is empty so it we only need to do this
        // if the register is empty.
        //

        if (Extension->HoldingEmpty) {

#ifdef _WIN64
            DISABLE_ALL_INTERRUPTS(Extension->Controller, Extension->AddressSpace);
            ENABLE_ALL_INTERRUPTS(Extension->Controller, Extension->AddressSpace);
#else
            DISABLE_ALL_INTERRUPTS(Extension->Controller);
            ENABLE_ALL_INTERRUPTS(Extension->Controller);
#endif

        }

    }

    //
    // The rts line may already be up from previous writes,
    // however, it won't take much additional time to turn
    // on the RTS line if we are doing transmit toggling.
    //

    if ((Extension->HandFlow.FlowReplace & SERIAL_RTS_MASK) ==
        SERIAL_TRANSMIT_TOGGLE) {

        SerialSetRTS(Extension);

    }

    return FALSE;

}

VOID
SerialCancelCurrentWrite(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )

/*++

Routine Description:

    This routine is used to cancel the current write.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP to be canceled.

Return Value:

    None.

--*/

{

    PSERIAL_DEVICE_EXTENSION Extension = DeviceObject->DeviceExtension;
    SERIAL_LOCKED_PAGED_CODE();

    SerialTryToCompleteCurrent(
        Extension,
        SerialGrabWriteFromIsr,
        Irp->CancelIrql,
        STATUS_CANCELLED,
        &Extension->CurrentWriteIrp,
        &Extension->WriteQueue,
        NULL,
        &Extension->WriteRequestTotalTimer,
        SerialStartWrite,
        SerialGetNextWrite,
        SERIAL_REF_CANCEL
        );

}

VOID
SerialWriteTimeout(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )

/*++

Routine Description:

    This routine will try to timeout the current write.

Arguments:

    Dpc - Not Used.

    DeferredContext - Really points to the device extension.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

--*/

{

    PSERIAL_DEVICE_EXTENSION Extension = DeferredContext;
    KIRQL OldIrql;

    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    SerialDbgPrintEx(DPFLTR_TRACE_LEVEL, ">SerialWriteTimeout(%X)\n",
                     Extension);

    IoAcquireCancelSpinLock(&OldIrql);

    SerialTryToCompleteCurrent(Extension, SerialGrabWriteFromIsr, OldIrql,
                               STATUS_TIMEOUT, &Extension->CurrentWriteIrp,
                               &Extension->WriteQueue, NULL,
                               &Extension->WriteRequestTotalTimer,
                               SerialStartWrite, SerialGetNextWrite,
                               SERIAL_REF_TOTAL_TIMER);

    SerialDpcEpilogue(Extension, Dpc);


    SerialDbgPrintEx(DPFLTR_TRACE_LEVEL, "<SerialWriteTimeout\n");
}

BOOLEAN
SerialGrabWriteFromIsr(
    IN PVOID Context
    )

/*++

Routine Description:


    This routine is used to grab the current irp, which could be timing
    out or canceling, from the ISR

    NOTE: This routine is being called from KeSynchronizeExecution.

    NOTE: This routine assumes that the cancel spin lock is held
          when this routine is called.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    Always false.

--*/

{

    PSERIAL_DEVICE_EXTENSION Extension = Context;
    SERIAL_LOCKED_PAGED_CODE();

    //
    // Check if the write length is non-zero.  If it is non-zero
    // then the ISR still owns the irp. We calculate the the number
    // of characters written and update the information field of the
    // irp with the characters written.  We then clear the write length
    // the isr sees.
    //

    if (Extension->WriteLength) {

        //
        // We could have an xoff counter masquerading as a
        // write irp.  If so, don't update the write length.
        //

        if (IoGetCurrentIrpStackLocation(Extension->CurrentWriteIrp)
            ->MajorFunction == IRP_MJ_WRITE) {

            Extension->CurrentWriteIrp->IoStatus.Information =
                IoGetCurrentIrpStackLocation(
                    Extension->CurrentWriteIrp
                    )->Parameters.Write.Length -
                Extension->WriteLength;

        } else {

            Extension->CurrentWriteIrp->IoStatus.Information = 0;

        }

        //
        // Since the isr no longer references this irp, we can
        // decrement it's reference count.
        //

        SERIAL_CLEAR_REFERENCE(
            Extension->CurrentWriteIrp,
            SERIAL_REF_ISR
            );

        Extension->WriteLength = 0;

    }

    return FALSE;

}

BOOLEAN
SerialGrabXoffFromIsr(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is used to grab an xoff counter irp from the
    isr when it is no longer masquerading as a write irp.  This
    routine is called by the cancel and timeout code for the
    xoff counter ioctl.


    NOTE: This routine is being called from KeSynchronizeExecution.

    NOTE: This routine assumes that the cancel spin lock is held
          when this routine is called.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    Always false.

--*/

{

    PSERIAL_DEVICE_EXTENSION Extension = Context;
    SERIAL_LOCKED_PAGED_CODE();

    if (Extension->CountSinceXoff) {

        //
        // This is only non-zero when there actually is a Xoff ioctl
        // counting down.
        //

        Extension->CountSinceXoff = 0;

        //
        // We decrement the count since the isr no longer owns
        // the irp.
        //

        SERIAL_CLEAR_REFERENCE(
            Extension->CurrentXoffIrp,
            SERIAL_REF_ISR
            );

    }

    return FALSE;

}

VOID
SerialCompleteXoff(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )

/*++

Routine Description:

    This routine is merely used to truely complete an xoff counter irp.  It
    assumes that the status and the information fields of the irp are
    already correctly filled in.

Arguments:

    Dpc - Not Used.

    DeferredContext - Really points to the device extension.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

--*/

{

    PSERIAL_DEVICE_EXTENSION Extension = DeferredContext;
    KIRQL OldIrql;

    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    SerialDbgPrintEx(DPFLTR_TRACE_LEVEL, ">SerialCompleteXoff(%X)\n",
                     Extension);

    IoAcquireCancelSpinLock(&OldIrql);

    SerialTryToCompleteCurrent(Extension, NULL, OldIrql, STATUS_SUCCESS,
                               &Extension->CurrentXoffIrp, NULL, NULL,
                               &Extension->XoffCountTimer, NULL, NULL,
                               SERIAL_REF_ISR);

    SerialDpcEpilogue(Extension, Dpc);


    SerialDbgPrintEx(DPFLTR_TRACE_LEVEL, "<SerialCompleteXoff\n");

}

VOID
SerialTimeoutXoff(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )

/*++

Routine Description:

    This routine is merely used to truely complete an xoff counter irp,
    if its timer has run out.

Arguments:

    Dpc - Not Used.

    DeferredContext - Really points to the device extension.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

--*/

{

    PSERIAL_DEVICE_EXTENSION Extension = DeferredContext;
    KIRQL OldIrql;

    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    SerialDbgPrintEx(DPFLTR_TRACE_LEVEL, ">SerialTimeoutXoff(%X)\n", Extension);

    IoAcquireCancelSpinLock(&OldIrql);

    SerialTryToCompleteCurrent(Extension, SerialGrabXoffFromIsr, OldIrql,
                               STATUS_SERIAL_COUNTER_TIMEOUT,
                               &Extension->CurrentXoffIrp, NULL, NULL, NULL,
                               NULL, NULL, SERIAL_REF_TOTAL_TIMER);

    SerialDpcEpilogue(Extension, Dpc);

    SerialDbgPrintEx(DPFLTR_TRACE_LEVEL, "<SerialTimeoutXoff\n");
}

VOID
SerialCancelCurrentXoff(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )

/*++

Routine Description:

    This routine is used to cancel the current write.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP to be canceled.

Return Value:

    None.

--*/

{

    PSERIAL_DEVICE_EXTENSION Extension = DeviceObject->DeviceExtension;
    SERIAL_LOCKED_PAGED_CODE();

    SerialTryToCompleteCurrent(
        Extension,
        SerialGrabXoffFromIsr,
        Irp->CancelIrql,
        STATUS_CANCELLED,
        &Extension->CurrentXoffIrp,
        NULL,
        NULL,
        &Extension->XoffCountTimer,
        NULL,
        NULL,
        SERIAL_REF_CANCEL
        );

}

BOOLEAN
SerialGiveXoffToIsr(
    IN PVOID Context
    )

/*++

Routine Description:


    This routine starts off the xoff counter.  It merely
    has to set the xoff count and increment the reference
    count to denote that the isr has a reference to the irp.

    NOTE: This routine is called by KeSynchronizeExecution.

    NOTE: This routine assumes that it is called with the
          cancel spin lock held.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

--*/

{

    PSERIAL_DEVICE_EXTENSION Extension = Context;

    //
    // The current stack location.  This contains all of the
    // information we need to process this particular request.
    //

    PSERIAL_XOFF_COUNTER Xc =
        Extension->CurrentXoffIrp->AssociatedIrp.SystemBuffer;

    SERIAL_LOCKED_PAGED_CODE();

    ASSERT(Extension->CurrentXoffIrp);
    Extension->CountSinceXoff = Xc->Counter;

    //
    // The isr now has a reference to the irp.
    //

    SERIAL_SET_REFERENCE(
        Extension->CurrentXoffIrp,
        SERIAL_REF_ISR
        );

    return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\serial\test\tinttime.c ===
#include <stdio.h>
#include <conio.h>
#include <process.h>
#include <string.h>
#include <windows.h>

#define PERR(bSuccess, api) {if (!(bSuccess)) printf("%s: Error %d from %s \
    on line %d\n", __FILE__, GetLastError(), api, __LINE__);}

char cr = '\r';
char lf = '\n';
char ctrlC = 3;
int addLf = 0;
HANDLE hfSerialPort;

void readPort()
{
  DWORD cbBytesRead;
  char inBuf[256];
  int i;
  BOOL bSuccess;
  SYSTEMTIME sysTimeStart;
  SYSTEMTIME sysTimeEnd;

  while (1)
    {
    GetSystemTime(&sysTimeStart);
    bSuccess = ReadFile(hfSerialPort, inBuf, sizeof(inBuf), &cbBytesRead,
        NULL);
    GetSystemTime(&sysTimeEnd);
    printf("StartingTime: Yr: %d Mn: %d DayofWeek: %d Day: %d Hr: %d Min: %d Sec: %d Milli: %d\n",
            sysTimeStart.wYear,
            sysTimeStart.wMonth,
            sysTimeStart.wDayOfWeek,
            sysTimeStart.wDay,
            sysTimeStart.wHour,
            sysTimeStart.wMinute,
            sysTimeStart.wSecond,
            sysTimeStart.wMilliseconds
            );
    printf("EndingTime: Yr: %d Mn: %d DayofWeek: %d Day: %d Hr: %d Min: %d Sec: %d Milli: %d\n",
            sysTimeEnd.wYear,
            sysTimeEnd.wMonth,
            sysTimeEnd.wDayOfWeek,
            sysTimeEnd.wDay,
            sysTimeEnd.wHour,
            sysTimeEnd.wMinute,
            sysTimeEnd.wSecond,
            sysTimeEnd.wMilliseconds
            );
    PERR(bSuccess, "ReadFile");
    if (bSuccess && (cbBytesRead == 0))
      puts("total timeout");
    else
      if (cbBytesRead < sizeof(inBuf))
        printf("\ainterval timeout, ");
      else
        printf("buffer full, ");
      printf("bytes read: %d\n", cbBytesRead);
    for (i = 0; i < (int) cbBytesRead; i++)
      {
      switch(inBuf[i])
        {
        case '\r':
          if (addLf)
            putchar(lf);
          putchar(inBuf[i]);
          break;
        default:
          putchar(inBuf[i]);
          break;
        }
      }
    }
  return;
}

int __cdecl main(int argc,char *argv[])
{
  char szTemp[512];
  BOOL bSuccess;
  COMMTIMEOUTS ctmo;
  DCB dcb;

  hfSerialPort = CreateFile("COM2", GENERIC_READ | GENERIC_WRITE, 0,
      NULL, OPEN_EXISTING, 0, NULL );
  PERR(hfSerialPort != INVALID_HANDLE_VALUE, "CreateFile");
  bSuccess = GetCommState(hfSerialPort, &dcb);
  PERR(bSuccess, "GetCommState");
  dcb.BaudRate = 9600;
  dcb.fBinary = 1;
  dcb.fParity = 0;
  dcb.fOutxCtsFlow = 0;
  dcb.fOutxDsrFlow = 0;
  dcb.fDtrControl = DTR_CONTROL_DISABLE;
  dcb.fDsrSensitivity = 0;
  dcb.fTXContinueOnXoff = 0;
  dcb.fOutX = 1;
  dcb.fInX = 1;
  dcb.fErrorChar = 0;
  dcb.fNull = 1;
  dcb.fRtsControl = RTS_CONTROL_DISABLE;
  dcb.fAbortOnError = 0;
  dcb.Parity = NOPARITY;
  dcb.StopBits = ONESTOPBIT;
  bSuccess = SetCommState(hfSerialPort, &dcb);
  PERR(bSuccess, "SetCommState");

  ctmo.ReadIntervalTimeout = 1000;
  ctmo.ReadTotalTimeoutMultiplier = 0;
  ctmo.ReadTotalTimeoutConstant = 30000;
  ctmo.WriteTotalTimeoutMultiplier = 0;
  ctmo.WriteTotalTimeoutConstant = 0;
  bSuccess = SetCommTimeouts(hfSerialPort, &ctmo);
  PERR(bSuccess, "SetCommTimeouts");

  readPort();
  return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\serial\test\tmskstr.c ===
#include <stddef.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include "windows.h"

HANDLE WaitEvent;
HANDLE ReadEvent;
HANDLE hFile;
HANDLE IoSemaphore;


DWORD
WaitCommThread(
    LPVOID Trash
    )
{

    DWORD ReasonSatisfied;
    DWORD Trash2;
    OVERLAPPED Ol;
    UNREFERENCED_PARAMETER(Trash);

    Ol.hEvent = WaitEvent;
    do {

        if (!WaitCommEvent(
                 hFile,
                 &ReasonSatisfied,
                 &Ol
                 )) {

            DWORD LastError = GetLastError();

            if (LastError == ERROR_IO_PENDING) {

                if (!GetOverlappedResult(
                         hFile,
                         &Ol,
                         &Trash2,
                         TRUE
                         )) {

                    WaitForSingleObject(IoSemaphore,-1);
                    printf("Could not do the getoverlapped on the wait: %d\n",GetLastError());
                    ReleaseSemaphore(IoSemaphore,1,NULL);

                }

            } else {

                WaitForSingleObject(IoSemaphore,-1);
                printf("Could not start the wait: %d\n",LastError);
                ReleaseSemaphore(IoSemaphore,1,NULL);

            }

        }

    } while (TRUE);

    return 1;

}

DWORD
SetMaskThread(
    LPVOID Trash
    )
{


    UNREFERENCED_PARAMETER(Trash);

    do {

        //
        // Now clear.
        //

        Sleep(1000);
        if (!SetCommMask(
                 hFile,
                 0
                 )) {

            DWORD LastError = GetLastError();

            WaitForSingleObject(IoSemaphore,-1);
            printf("Could not initiate the 0 set mask: %d\n",LastError);
            ReleaseSemaphore(IoSemaphore,1,NULL);

        }

        //
        // Now set.
        //

        Sleep(1000);
        if (!SetCommMask(
                 hFile,
                 EV_RXCHAR
                 )) {

            DWORD LastError = GetLastError();

            WaitForSingleObject(IoSemaphore,-1);
            printf("Could not initiate the EV_RXCHAR set mask: %d\n",LastError);
            ReleaseSemaphore(IoSemaphore,1,NULL);


        }

    } while (TRUE);

    return 1;

}
DWORD
ReadThread(
    LPVOID Trash
    )
{

    DWORD Trash2;
    OVERLAPPED Ol;
    char readbuff[100];
    DWORD NumberActuallyRead;
    DWORD NumberToRead = 100;

    UNREFERENCED_PARAMETER(Trash);
    Ol.hEvent = ReadEvent;
    do {

        Sleep(200);
        if (!ReadFile(
                 hFile,
                 readbuff,
                 NumberToRead,
                 &NumberActuallyRead,
                 &Ol
                 )) {

            DWORD LastError = GetLastError();

            if (LastError == ERROR_IO_PENDING) {

                if (!GetOverlappedResult(
                         hFile,
                         &Ol,
                         &Trash2,
                         TRUE
                         )) {

                    WaitForSingleObject(IoSemaphore,-1);
                    printf("Could not do the getoverlapped on the read: %d\n",GetLastError());
                    ReleaseSemaphore(IoSemaphore,1,NULL);

                }

            } else {

                WaitForSingleObject(IoSemaphore,-1);
                printf("Could not start the wait: %d\n",LastError);
                ReleaseSemaphore(IoSemaphore,1,NULL);

            }

        }

    } while (TRUE);

    return 1;

}

int __cdecl main(int argc,char *argv[]) {

    char *MyPort = "COM1";
    DWORD ValueFromEscape = 0;
    DWORD CharFunc;
    DWORD ThreadId;
    DWORD ReadThreadId;
    HANDLE ReadHandle;
    int scanfval;

    if (argc > 1) {

        MyPort = argv[1];

    }

    WaitEvent = CreateEvent(
                    NULL,
                    TRUE,
                    FALSE,
                    NULL
                    );

    if (!WaitEvent) {

        printf("Wait Event could not be created\n");
        exit(1);

    }

    ReadEvent = CreateEvent(
                    NULL,
                    TRUE,
                    FALSE,
                    NULL
                    );

    if (!ReadEvent) {

        printf("Read Event could not be created\n");
        exit(1);

    }

    IoSemaphore = CreateSemaphore(
                      NULL,
                      1,
                      1,
                      NULL
                      );

    if (!IoSemaphore) {

        printf("IoSemaphore could not be created\n");
        exit(1);

    }

    if ((hFile = CreateFile(
                     MyPort,
                     GENERIC_READ | GENERIC_WRITE,
                     0,
                     NULL,
                     CREATE_ALWAYS,
                     FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
                     NULL
                     )) != ((HANDLE)-1)) {

        DCB MyDcb;
        COMMTIMEOUTS NewTimeouts;

        printf("We successfully opened the %s port.\n",MyPort);


        //
        // We've successfully opened the file.  Set the state of
        // the comm device.  First we get the old values and
        // adjust to our own.
        //

        if (!GetCommState(
                 hFile,
                 &MyDcb
                 )) {

            printf("Couldn't get the comm state: %d\n",GetLastError());
            exit(1);

        }

        MyDcb.BaudRate = 19200;
        MyDcb.ByteSize = 8;
        MyDcb.Parity = NOPARITY;
        MyDcb.StopBits = ONESTOPBIT;
        MyDcb.EvtChar = 'a';

        if (!SetCommState(
                hFile,
                &MyDcb
                )) {

            printf("Couldn't set the comm state: %d\n",GetLastError());
            exit(1);

        }

        if (!SetCommTimeouts(
                 hFile,
                 &NewTimeouts
                 )) {

            printf("Couldn't set the comm timeouts: %d\n",GetLastError());
            exit(1);

        }

    } else {

        printf("Could not open the comm port: %d\n",GetLastError());

    }

    //
    // Create the thread that will wait for the
    // comm events.
    //

    if (!CreateThread(
              NULL,
              0,
              WaitCommThread,
              NULL,
              0,
              &ThreadId
              )) {

        printf("Could not create the wait thread.\n");
        exit(1);

    }

    if (!CreateThread(
              NULL,
              0,
              SetMaskThread,
              NULL,
              0,
              &ThreadId
              )) {

        printf("Could not create the set mask thread.\n");
        exit(1);

    }

    if ((ReadHandle = CreateThread(
                          NULL,
                          0,
                          ReadThread,
                          NULL,
                          0,
                          &ThreadId
                          )) == 0) {

        printf("Could not create the read thread.\n");
        exit(1);

    }

    WaitForSingleObject(ReadHandle,-1);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\serial\test\tpurge.c ===
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include "windows.h"

#define BIGREAD 256000
unsigned char readbuff[BIGREAD];

void main(int argc,char *argv[]) {

    HANDLE hFile;
    DCB MyDcb;
    char *MyPort = "COM1";
    DWORD NumberToRead = 0;
    DWORD UseBaud = 19200;
    COMMTIMEOUTS To;

    if (argc > 1) {

        sscanf(argv[1],"%d",&NumberToRead);

        if (argc > 2) {

            sscanf(argv[2],"%d",&UseBaud);

            if (argc > 3) {

                MyPort = argv[3];

            }

        }

    }

    printf("Will try to read %d characters.\n",NumberToRead);
    printf("Will try to read a %d baud.\n",UseBaud);
    printf("Using port %s\n",MyPort);

    if ((hFile = CreateFile(
                     MyPort,
                     GENERIC_READ | GENERIC_WRITE,
                     0,
                     NULL,
                     CREATE_ALWAYS,
                     FILE_ATTRIBUTE_NORMAL,
                     NULL
                     )) != ((HANDLE)-1)) {

        printf("We successfully opened the %s port.\n",MyPort);

        To.ReadIntervalTimeout = 0;
        To.ReadTotalTimeoutMultiplier = ((1000+(((UseBaud+9)/10)-1))/((UseBaud+9)/10));
        if (!To.ReadTotalTimeoutMultiplier) {
            To.ReadTotalTimeoutMultiplier = 1;
        }
        printf("Multiplier is: %d\n",To.ReadTotalTimeoutMultiplier);
        To.ReadTotalTimeoutConstant = 5000;
        To.WriteTotalTimeoutMultiplier = 0;
        To.WriteTotalTimeoutConstant = 5000;

        if (SetCommTimeouts(
                hFile,
                &To
                )) {


            //
            // We've successfully opened the file.  Set the state of
            // the comm device.  First we get the old values and
            // adjust to our own.
            //

            if (!GetCommState(
                     hFile,
                     &MyDcb
                     )) {

                printf("Couldn't get the comm state: %d\n",GetLastError());
                exit(1);

            }

            MyDcb.BaudRate = 19200;
            MyDcb.ByteSize = 8;
            MyDcb.Parity = NOPARITY;
            MyDcb.StopBits = ONESTOPBIT;

            if (SetCommState(
                    hFile,
                    &MyDcb
                    )) {

                printf("We successfully set the state of the %s port.\n",MyPort);

                if (PurgeComm(
                        hFile,
                        PURGE_TXABORT
                        )) {

                    printf("We succesfully purged\n");

                } else {

                    DWORD LastError;
                    LastError = GetLastError();
                    printf("Couldn't purge the %s device.\n",MyPort);
                    printf("Status of failed purge is: %x\n",LastError);

                }

                if (!PurgeComm(
                        hFile,
                        0
                        )) {

                    printf("Purge correctly detects bad parameter: %d\n",GetLastError());

                } else {

                    printf("Purge should have rejected!!!!!\n");

                }

                if (FlushFileBuffers(hFile)) {

                    printf("We succesfully flushed\n");

                } else {

                    DWORD LastError;
                    LastError = GetLastError();
                    printf("Couldn't flush the %s device.\n",MyPort);
                    printf("Status of failed flush is: %x\n",LastError);

                }

            } else {

                DWORD LastError;
                LastError = GetLastError();
                printf("Couldn't set the %s device.\n",MyPort);
                printf("Status of failed set is: %x\n",LastError);

            }

        } else {

            DWORD LastError;
            LastError = GetLastError();
            printf("Couldn't set the %s device timeouts.\n",MyPort);
            printf("Status of failed timeouts is: %x\n",LastError);

        }

        CloseHandle(hFile);

    } else {

        DWORD LastError;
        LastError = GetLastError();
        printf("Couldn't open the %s device.\n",MyPort);
        printf("Status of failed open is: %x\n",LastError);

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\serial\test\tpurge2.c ===
//
// Test the quick return timeouts
//
// Assume that we are using a loopback connector.
//
// Assume that it isn't running on a stressed machine.
//

#include "windows.h"
#include "stdio.h"

#define FAILURE printf("FAIL: %d\n",__LINE__);exit(1)

int __cdecl main(int argc, char *argv[]) {
    CHAR *myPort = "COM1";
    DCB myDcb;
    DWORD junk;
    COMMTIMEOUTS myTimeOuts;
    DWORD numberActuallyRead;
    DWORD numberActuallyWritten;
    UCHAR readBuff[1000];
    HANDLE comHandle;
    DWORD startingTicks;
    OVERLAPPED readOl;
    OVERLAPPED writeOl;
    UCHAR writeBuff[5] = {0,1,2,3,4};

    if (argc > 1) {

        myPort = argv[1];

    }

    if ((comHandle = CreateFile(
                     myPort,
                     GENERIC_READ | GENERIC_WRITE,
                     0,
                     NULL,
                     CREATE_ALWAYS,
                     FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
                     NULL
                     )) == ((HANDLE)-1)) {

        FAILURE;

    }

    if (!(readOl.hEvent = CreateEvent(
                             NULL,
                             TRUE,
                             FALSE,
                             NULL
                             ))) {

        FAILURE;

    }

    if (!GetCommState(
             comHandle,
             &myDcb
             )) {

        FAILURE;

    }

    myDcb.BaudRate = 19200;
    myDcb.ByteSize = 8;
    myDcb.StopBits = ONESTOPBIT;
    myDcb.Parity = NOPARITY;
    myDcb.fOutxCtsFlow = FALSE;
    myDcb.fOutxDsrFlow = FALSE;
    myDcb.fDsrSensitivity = FALSE;
    myDcb.fOutX = FALSE;
    myDcb.fInX = FALSE;
    myDcb.fRtsControl = RTS_CONTROL_ENABLE;
    myDcb.fDtrControl = DTR_CONTROL_ENABLE;
    if (!SetCommState(
            comHandle,
            &myDcb
            )) {

        FAILURE;

    }

    //
    // Make sure that the IO doesn't time out.
    //

    myTimeOuts.ReadIntervalTimeout = 0;
    myTimeOuts.ReadTotalTimeoutMultiplier = 0;
    myTimeOuts.ReadTotalTimeoutConstant = 0;
    myTimeOuts.WriteTotalTimeoutMultiplier = 0;
    myTimeOuts.WriteTotalTimeoutConstant = 0;

    if (!SetCommTimeouts(
             comHandle,
             &myTimeOuts
             )) {

        FAILURE;

    }

    //
    // Start off a read.  It shouldn't complete
    //

    if (!ReadFile(
             comHandle,
             &readBuff[0],
             1000,
             &numberActuallyRead,
             &readOl
             )) {

        if (GetLastError() != ERROR_IO_PENDING) {

            FAILURE;

        }

        if (GetOverlappedResult(
                 comHandle,
                 &readOl,
                 &numberActuallyRead,
                 FALSE
                 )) {

            FAILURE;

        }

    } else {

        FAILURE;

    }

    //
    // The read should still be there.  Now do a purge comm.  We
    // should then do a sleep for 2 seconds to give the read time
    // to complete.  Then we should first make sure that the
    // read has completed (via a get overlapped).  Then we should
    // do a SetupComm (with a "large" value so that we will actually
    // allocate a new typeahead buffer).  If there is still a "dangling"
    // read, then we should never return from SetupComm.
    //

    if (!PurgeComm(
             comHandle,
             PURGE_TXABORT | PURGE_RXABORT
             )) {

        FAILURE;

    }

    if (WaitForSingleObject(
             readOl.hEvent,
             2000
             ) != WAIT_OBJECT_0) {

        FAILURE;

    }

    if (!SetupComm(
             comHandle,
             20000,
             20000
             )) {

        FAILURE;

    }

    return 1;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\serial\test\tpurge3.c ===
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include "windows.h"

#define FAILURE(e) printf("FAIL: %d/%d\n",e,__LINE__);exit(1)

int __cdecl main(int argc,char *argv[]) {

    HANDLE hFile;
    DWORD junk;
    char *myPort = "COM1";

    if (argc > 1) {

        myPort = argv[1];

    }

    if ((hFile = CreateFile(
                     myPort,
                     GENERIC_READ | GENERIC_WRITE,
                     0,
                     NULL,
                     CREATE_ALWAYS,
                     FILE_ATTRIBUTE_NORMAL,
                     NULL
                     )) != ((HANDLE)-1)) {

        if (!DeviceIoControl(
                 hFile,
                 0x001b004c,
                 NULL,
                 0,
                 NULL,
                 0,
                 &junk,
                 NULL
                 )) {

            FAILURE(GetLastError());

        }

    } else {

        FAILURE(GetLastError());

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\serial\test\trtshndr.c ===
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include "windows.h"

#define BIGREAD 256000
unsigned char readbuff[BIGREAD];

int __cdecl main(int argc,char *argv[]) {

    HANDLE hFile;
    DCB MyDcb;
    char *MyPort = "COM1";
    DWORD NumberActuallyRead;
    DWORD NumberToRead = 0;
    DWORD UseBaud = 19200;
    COMMTIMEOUTS To;
    COMMPROP MyCommProp;
    DWORD numberReadSoFar;
    DWORD TotalCount;
    DWORD j;

    if (argc > 1) {

        sscanf(argv[1],"%d",&NumberToRead);

        if (argc > 2) {

            sscanf(argv[2],"%d",&UseBaud);

            if (argc > 3) {

                MyPort = argv[3];

            }

        }

    }

    printf("Will try to read %d characters.\n",NumberToRead);
    printf("Will try to read a %d baud.\n",UseBaud);
    printf("Using port %s\n",MyPort);

    if ((hFile = CreateFile(
                     MyPort,
                     GENERIC_READ | GENERIC_WRITE,
                     0,
                     NULL,
                     CREATE_ALWAYS,
                     FILE_ATTRIBUTE_NORMAL,
                     NULL
                     )) == ((HANDLE)-1)) {

        printf("Couldn't open the port - last error is: %d\n",GetLastError());
        exit(1);

    }


    printf("We successfully opened the %s port.\n",MyPort);

    To.ReadIntervalTimeout = 0;
    To.ReadTotalTimeoutMultiplier = ((1000+(((UseBaud+9)/10)-1))/((UseBaud+9)/10));
    if (!To.ReadTotalTimeoutMultiplier) {
        To.ReadTotalTimeoutMultiplier = 1;
    }
    printf("Multiplier is: %d\n",To.ReadTotalTimeoutMultiplier);
    To.ReadTotalTimeoutConstant = 5000;
    To.WriteTotalTimeoutMultiplier = 0;
    To.WriteTotalTimeoutConstant = 5000;

    if (!SetCommTimeouts(
            hFile,
            &To
            )) {

        printf("Couldn't set the timeouts - last error: %d\n",GetLastError());
        exit(1);

    }

    //
    // We've successfully opened the file.  Set the state of
    // the comm device.  First we get the old values and
    // adjust to our own.
    //

    if (!GetCommState(
             hFile,
             &MyDcb
             )) {

        printf("Couldn't get the comm state: %d\n",GetLastError());
        exit(1);

    }

    if (!GetCommProperties(
             hFile,
             &MyCommProp
             )) {

        printf("Couldn't get the comm prop: %d\n",GetLastError());
        exit(1);

    }

    //
    // Set the Xoff/xon limit so that it lowers the handshake
    // whenever we have more than 50 chars in our buffer,
    // and raises when we drop below 20.
    //

    MyDcb.XoffLim = MyCommProp.dwCurrentRxQueue - 50;
    MyDcb.XonLim = 20;

    MyDcb.BaudRate = UseBaud;
    MyDcb.ByteSize = 8;
    MyDcb.Parity = NOPARITY;
    MyDcb.StopBits = ONESTOPBIT;

    //
    // Make sure that the only flow control is input RTS.
    //

    MyDcb.fOutxDsrFlow = FALSE;
    MyDcb.fOutxCtsFlow = FALSE;
    MyDcb.fDsrSensitivity = FALSE;
    MyDcb.fOutX = FALSE;
    MyDcb.fInX = FALSE;
    MyDcb.fDtrControl = DTR_CONTROL_DISABLE;
    MyDcb.fRtsControl = RTS_CONTROL_HANDSHAKE;

    if (!SetCommState(
            hFile,
            &MyDcb
            )) {

        printf("Couldn't set the comm state - last error: %d\n",GetLastError());
        exit(1);

    }

    //
    // Read ten chars at a time until we get all the
    // chars or we get some kind of error.
    // We delay 100ms after each read to let the buffer
    // have a chance to fill up some.
    //

    for (
        numberReadSoFar = 0;
        numberReadSoFar < NumberToRead;

        ) {

        if (ReadFile(
                hFile,
                &readbuff[numberReadSoFar],
                10,
                &NumberActuallyRead,
                NULL
                )) {

            //
            // If there was no characters (timed out), then
            // we probably won't see anything.
            //

            if (!NumberActuallyRead) {

                printf("No chars - Timeout!\n");
                break;

            }
            numberReadSoFar += NumberActuallyRead;
            Sleep(100);

            continue;

        } else {

            //
            // Some kind of read error.
            //

            DWORD LastError;
            LastError = GetLastError();
            printf("Couldn't read the %s device.\n",MyPort);
            printf("Status of failed read is: %d\n",LastError);

            //
            // Get the error word from clear comm error.
            //

            if (!ClearCommError(
                     hFile,
                     &LastError,
                     NULL
                     )) {

                printf("Couldn't call clear comm error: %d\n",GetLastError());
                exit(1);

            } else {

                if (!LastError) {

                    printf("No LastError\n");

                } else {

                    if (LastError & CE_RXOVER) {

                        printf("Error: CE_RXOVER\n");

                    }

                    if (LastError & CE_OVERRUN) {

                        printf("Error: CE_OVERRUN\n");

                    }

                    if (LastError & CE_RXPARITY) {

                        printf("Error: CE_RXPARITY\n");

                    }

                    if (LastError & CE_FRAME) {

                        printf("Error: CE_FRAME\n");

                    }

                    if (LastError & CE_BREAK) {

                        printf("Error: CE_BREAK\n");

                    }
                    if (LastError & ~(CE_RXOVER |
                                   CE_OVERRUN |
                                   CE_RXPARITY |
                                   CE_FRAME |
                                   CE_BREAK)) {

                        printf("Unknown errors: %x\n",LastError);

                    }

                }

            }
            exit(1);

        }

    }

    for (
        TotalCount = 0;
        TotalCount < numberReadSoFar;
        ) {

        for (
            j = 0;
            j <= 9;
            j++
            ) {

            if (readbuff[TotalCount] != j) {

                printf("Bad data starting at: %d\n",TotalCount);
                goto donewithcheck;

            }

            TotalCount++;
            if (TotalCount >= numberReadSoFar) {

                break;

            }

        }

    }

donewithcheck:;

    exit(1);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\serial\test\tseria1r.c ===
//
// Read from the comm 1 char at a time.
//

#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include "windows.h"

#define BIGREAD 256000
unsigned char readbuff[BIGREAD];

void main(int argc,char *argv[]) {

    HANDLE hFile;
    DCB MyDcb;
    char *MyPort = "COM1";
    DWORD NumberActuallyRead;
    DWORD NumberToRead = 0;
    DWORD UseBaud = 19200;
    COMMTIMEOUTS To;

    if (argc > 1) {

        sscanf(argv[1],"%d",&NumberToRead);

        if (argc > 2) {

            sscanf(argv[2],"%d",&UseBaud);

            if (argc > 3) {

                MyPort = argv[3];

            }

        }

    }

    printf("Will try to read %d characters.\n",NumberToRead);
    printf("Will try to read a %d baud.\n",UseBaud);
    printf("Using port %s\n",MyPort);

    if ((hFile = CreateFile(
                     MyPort,
                     GENERIC_READ | GENERIC_WRITE,
                     0,
                     NULL,
                     CREATE_ALWAYS,
                     FILE_ATTRIBUTE_NORMAL,
                     NULL
                     )) != ((HANDLE)-1)) {

        printf("We successfully opened the %s port.\n",MyPort);

        To.ReadIntervalTimeout = 0;
        To.ReadTotalTimeoutMultiplier = ((1000+(((UseBaud+9)/10)-1))/((UseBaud+9)/10));
        if (!To.ReadTotalTimeoutMultiplier) {
            To.ReadTotalTimeoutMultiplier = 1;
        }
        printf("Multiplier is: %d\n",To.ReadTotalTimeoutMultiplier);
        To.ReadTotalTimeoutConstant = 5000;
        To.WriteTotalTimeoutMultiplier = 0;
        To.WriteTotalTimeoutConstant = 5000;

        if (SetCommTimeouts(
                hFile,
                &To
                )) {

            //
            // We've successfully opened the file.  Set the state of
            // the comm device.  First we get the old values and
            // adjust to our own.
            //

            if (!GetCommState(
                     hFile,
                     &MyDcb
                     )) {

                printf("Couldn't get the comm state: %d\n",GetLastError());
                exit(1);

            }

            MyDcb.BaudRate = UseBaud;
            MyDcb.ByteSize = 8;
            MyDcb.Parity = NOPARITY;
            MyDcb.StopBits = ONESTOPBIT;

            if (SetCommState(
                    hFile,
                    &MyDcb
                    )) {

                DWORD CurrentReadIt = 0;
                DWORD CurrentActualRead = 0;
                unsigned char j;
                DWORD TotalCount;

                NumberActuallyRead = 0;
                printf("We successfully set the state of the %s port.\n",MyPort);

                printf("Hit any 1 <cr> to start reading: ");
                scanf("%d",&CurrentReadIt);
                for (
                    CurrentReadIt = 0;
                    CurrentReadIt < NumberToRead;
                    CurrentReadIt++
                    ) {

                    if (ReadFile(
                            hFile,
                            &readbuff[CurrentReadIt],
                            1,
                            &CurrentActualRead,
                            NULL
                            )) {

                        if (CurrentActualRead != 1) {

                            printf("Iteration %d read %d\n",CurrentReadIt,CurrentActualRead);
                            break;

                        } else {

                            NumberActuallyRead++;

                        }

                    } else {

                        DWORD LastError;
                        LastError = GetLastError();
                        printf("Status of failed %d read is: %x\n",CurrentReadIt,LastError);
                        break;

                    }

                }

                printf("Number actually read %d.\n",NumberActuallyRead);
                printf("Now we check the data\n");

                for (
                    TotalCount = 0;
                    TotalCount < NumberActuallyRead;
                    ) {

                    for (
                        j = 0;
                        j <= 9;
                        j++
                        ) {

                        if (readbuff[TotalCount] != j) {

                            printf("Bad data starting at: %d\n",TotalCount);
                            goto donewithcheck;

                        }

                        TotalCount++;
                        if (TotalCount >= NumberActuallyRead) {

                            break;

                        }

                    }

                }
donewithcheck:;

            } else {

                DWORD LastError;
                LastError = GetLastError();
                printf("Couldn't set the %s device.\n",MyPort);
                printf("Status of failed set is: %x\n",LastError);

            }

        } else {

            DWORD LastError;
            LastError = GetLastError();
            printf("Couldn't set the %s device timeouts.\n",MyPort);
            printf("Status of failed timeouts is: %x\n",LastError);

        }

        CloseHandle(hFile);

    } else {

        DWORD LastError;
        LastError = GetLastError();
        printf("Couldn't open the %s device.\n",MyPort);
        printf("Status of failed open is: %x\n",LastError);

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\serial\test\tseria1w.c ===
//
// Write to the comm one character at a time.
//

#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include "windows.h"

#define BIGWRITE 256000
unsigned char writebuff[BIGWRITE];

void main(int argc,char *argv[]) {

    HANDLE hFile;
    DCB MyDcb;
    char *MyPort = "COM1";
    DWORD NumberActuallyWritten;
    DWORD NumberToWrite = 0;
    DWORD UseBaud = 19200;

    if (argc > 1) {

        sscanf(argv[1],"%d",&NumberToWrite);

        if (argc > 2) {

            sscanf(argv[2],"%d",&UseBaud);

            if (argc > 3) {

                MyPort = argv[3];

            }

        }

    }

    printf("Will try to write %d characters.\n",NumberToWrite);
    printf("Will try to write at %d baud.\n",UseBaud);
    printf("Using port: %s\n",MyPort);

    if ((hFile = CreateFile(
                     MyPort,
                     GENERIC_READ | GENERIC_WRITE,
                     0,
                     NULL,
                     CREATE_ALWAYS,
                     FILE_ATTRIBUTE_NORMAL,
                     NULL
                     )) != ((HANDLE)-1)) {

        printf("We successfully opened the %s port.\n",MyPort);

        //
        // We've successfully opened the file.  Set the state of
        // the comm device.  First we get the old values and
        // adjust to our own.
        //

        if (!GetCommState(
                 hFile,
                 &MyDcb
                 )) {

            printf("Couldn't get the comm state: %d\n",GetLastError());
            exit(1);

        }

        MyDcb.BaudRate = UseBaud;
        MyDcb.ByteSize = 8;
        MyDcb.Parity = NOPARITY;
        MyDcb.StopBits = ONESTOPBIT;

        if (SetCommState(
                hFile,
                &MyDcb
                )) {

            unsigned char j;
            DWORD TotalCount;

            printf("We successfully set the state of the %s port.\n",MyPort);

            for (
                TotalCount = 0;
                TotalCount < NumberToWrite;
                ) {

                for (
                    j = 0;
                    j <= 9;
                    j++
                    ) {

                    writebuff[TotalCount] = j;
                    TotalCount++;
                    if (TotalCount >= NumberToWrite) {

                        break;

                    }

                }

            }

            for (
                TotalCount = 0;
                TotalCount < NumberToWrite;
                ) {

                if (WriteFile(
                        hFile,
                        &writebuff[TotalCount],
                        1,
                        &NumberActuallyWritten,
                        NULL
                        )) {

                    if (NumberActuallyWritten != 1) {

                        printf("Write iteration %d only wrote %d\n",NumberActuallyWritten);
                        break;

                    } else {

                        TotalCount++;

                    }

                } else {

                    DWORD LastError;
                    LastError = GetLastError();
                    printf("Status of %d write is: %x\n",TotalCount,LastError);

                }

            }

        } else {

            DWORD LastError;
            LastError = GetLastError();
            printf("Couldn't set the %s device.\n",MyPort);
            printf("Status of failed set is: %x\n",LastError);

        }

        CloseHandle(hFile);

    } else {

        DWORD LastError;
        LastError = GetLastError();
        printf("Couldn't open the %s device.\n",MyPort);
        printf("Status of failed open is: %x\n",LastError);

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\serial\test\tinterva.c ===
#include "windows.h"
#include "stdio.h"

//
// Set by the master when it isn't going to do the tests anymore.
// Manual Reset
//
HANDLE AllDoneEvent;

//
// Set by the thread to tell the master to go ahead and write.
// Auto reset.
//
HANDLE WriteWaitEvent;

//
// Set by the master to indicate that the timeouts have been
// set to the proper value and it's ok to proceed with the reads.
// Auto reset.
//
HANDLE ProceedWithReads;

//
// Set by the thread to indicate that it is ok for the master
// to proceed with the next write loop.
// Auto reset.
//
HANDLE ProceedWithNextWriteLoop;


//
// Handle to the comm port.
//

HANDLE ComHandle;
OVERLAPPED ReadOverLap = {0};
OVERLAPPED WriteOverLap = {0};

DWORD
ReadThread(
    LPVOID ThreadCount
    ) {

    UCHAR buff[10];
    DWORD i;
    DWORD startOfWait;
    float waitTimeSoFar;
    DWORD numberActuallyRead;

    //
    // Keep doing these tests until the master sets the all done signal.
    //

    while (WaitForSingleObject(
               AllDoneEvent,
               0
               ) == WAIT_TIMEOUT) {

        WaitForSingleObject(
            ProceedWithReads,
            INFINITE
            );

        waitTimeSoFar = 0.0;

        //
        // Execute the read 10 times.  Do the wait for
        // overlapped.  We only go into the GetOverlapped code
        // when the overlapped write code completes
        // we capture the time just before the overlapped and
        // just after the overlapped.  We add up all the
        // milliseconds it took for the getoverlapped to complete
        // and we average them and print out the result.
        //

        for (
            i = 0;
            i <= 9;
            i++
            ) {

            if (ReadFile(
                        ComHandle,
                        &buff[0],
                        10,
                        &numberActuallyRead,
                        &ReadOverLap
                        )) {

                printf("Didn't get the read error\n");
                exit(1);

            }

            if (GetLastError() != ERROR_IO_PENDING) {

                printf("Didn't get pending\n");
                exit(1);

            }

            //
            // Tell the write to go ahead.
            //

            SetEvent(WriteWaitEvent);

            //
            // Wait for the event that is set by the write.
            //

            WaitForSingleObject(
                WriteOverLap.hEvent,
                INFINITE
                );

            startOfWait = GetTickCount();

            if (!GetOverlappedResult(
                     ComHandle,
                     &ReadOverLap,
                     &numberActuallyRead,
                     TRUE
                     )) {

                printf("getover returned false\n");
                exit(1);

            }
            waitTimeSoFar += GetTickCount() - startOfWait;
            if (numberActuallyRead != 5) {

                printf("Wrong amount in IO\n");
                exit(1);

            }


        }
        printf("Total Time: %f - average time: %f\n",
               waitTimeSoFar,waitTimeSoFar/10.0);

        SetEvent(ProceedWithNextWriteLoop);

    }

    return 1;

}

int __cdecl main(int argc, char *argv[]) {


    DWORD startingMilli = 100;
    DWORD endingMilli = 20000;
    DWORD currentMilli;
    HANDLE threadHandle;
    CHAR *myPort = "COM1";
    DCB myDcb;
    DWORD junk;
    COMMTIMEOUTS myTimeOuts;
    DWORD numberActuallyWritten;
    UCHAR buff[5] = {0,1,2,3,4};

    if (argc > 1) {

        sscanf(argv[1],"%d",&startingMilli);

        if (argc > 2) {

            sscanf(argv[2],"%d",&endingMilli);

            if (argc > 3) {

                myPort = argv[3];

            }

        }

    }


    if ((ComHandle = CreateFile(
                     myPort,
                     GENERIC_READ | GENERIC_WRITE,
                     0,
                     NULL,
                     CREATE_ALWAYS,
                     FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
                     NULL
                     )) == ((HANDLE)-1)) {

        printf("Couldn't open the port\n");
        exit(1);

    }

    if (!GetCommState(
             ComHandle,
             &myDcb
             )) {

        printf("Cound't get the comm state\n");
        exit(1);

    }

    myDcb.BaudRate = 19200;
    myDcb.ByteSize = 8;
    myDcb.StopBits = ONESTOPBIT;
    myDcb.Parity = NOPARITY;
    myDcb.fOutxCtsFlow = FALSE;
    myDcb.fOutxDsrFlow = FALSE;
    myDcb.fDsrSensitivity = FALSE;
    myDcb.fOutX = FALSE;
    myDcb.fInX = FALSE;
    myDcb.fRtsControl = RTS_CONTROL_ENABLE;
    myDcb.fDtrControl = DTR_CONTROL_ENABLE;
    if (!SetCommState(
            ComHandle,
            &myDcb
            )) {

        printf("Can't set the state\n");
        exit(1);

    }

    myTimeOuts.ReadIntervalTimeout = startingMilli;
    myTimeOuts.ReadTotalTimeoutMultiplier = 0;
    myTimeOuts.ReadTotalTimeoutConstant = 0;
    myTimeOuts.WriteTotalTimeoutMultiplier = 0;
    myTimeOuts.WriteTotalTimeoutConstant = 0;

    if (!SetCommTimeouts(
             ComHandle,
             &myTimeOuts
             )) {

        printf("Couldn't set the initial timeouts\n");
        exit(1);

    }

    if (!(AllDoneEvent = CreateEvent(
                             NULL,
                             TRUE,
                             FALSE,
                             NULL
                             ))) {

        printf("Could not create the all done event\n");
        exit(1);

    }

    if (!(WriteWaitEvent = CreateEvent(
                             NULL,
                             FALSE,
                             FALSE,
                             NULL
                             ))) {

        printf("Could not create the write wait event\n");
        exit(1);

    }

    if (!(ProceedWithReads = CreateEvent(
                             NULL,
                             TRUE,
                             TRUE,
                             NULL
                             ))) {

        printf("Could not create the proceed with reads event\n");
        exit(1);

    }

    if (!(ProceedWithNextWriteLoop = CreateEvent(
                             NULL,
                             TRUE,
                             FALSE,
                             NULL
                             ))) {

        printf("Could not create the proceed with writes event\n");
        exit(1);

    }

    if (!(ReadOverLap.hEvent = CreateEvent(
                             NULL,
                             TRUE,
                             FALSE,
                             NULL
                             ))) {

        printf("Could not create the read event\n");
        exit(1);

    }

    if (!(WriteOverLap.hEvent = CreateEvent(
                             NULL,
                             TRUE,
                             FALSE,
                             NULL
                             ))) {

        printf("Could not create the write event\n");
        exit(1);

    }

    threadHandle = CreateThread(
                       NULL,
                       0,
                       ReadThread,
                       0,
                       0,
                       &junk
                       );

    if (!threadHandle) {

        printf("Couldn't create the thread\n");
        exit(1);

    }


    currentMilli = startingMilli;
    while (currentMilli <= endingMilli) {

        printf("Interval timeout test for %d milliseconds\n",currentMilli);
        for (
            junk = 0;
            junk <= 9;
            junk++
            ) {

            //
            // Wait for the read thread to say that it's ok to write.
            //

            WaitForSingleObject(
                WriteWaitEvent,
                INFINITE
                );

            if (!WriteFile(
                     ComHandle,
                     &buff[0],
                     5,
                     &numberActuallyWritten,
                     &WriteOverLap
                     )) {

                if (GetLastError() != ERROR_IO_PENDING) {

                    printf("Write went bad\n");
                    exit(1);

                }

                GetOverlappedResult(
                    ComHandle,
                    &WriteOverLap,
                    &numberActuallyWritten,
                    TRUE
                    );

            }

        }

        currentMilli += 100;
        myTimeOuts.ReadIntervalTimeout = currentMilli;
        if (!SetCommTimeouts(
                 ComHandle,
                 &myTimeOuts
                 )) {

            printf("Couldn't set the new timeouts\n");
            exit(1);

        }

        SetEvent(ProceedWithReads);
        WaitForSingleObject(ProceedWithNextWriteLoop,INFINITE);

    }

    SetEvent(AllDoneEvent);
    WaitForSingleObject(threadHandle,INFINITE);

    return 1;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\serial\test\timeout.c ===
#include <stdio.h>
#include <windows.h>


BOOL DoComIo(LPSTR lpCom,DWORD Baud,BYTE Size,BYTE Parity,BYTE Stop);

//#define COM_DEB     1

#define   NUM         128
#define   print       printf
#define   SETTINGS1       "COM1",9600,8,NOPARITY,ONESTOPBIT
#define   SETTINGS2       "COM1",4800,8,NOPARITY,ONESTOPBIT
#define   SETTINGS3       "COM1",2400,8,NOPARITY,ONESTOPBIT
#define   SETTINGS4       "COM1",1200,8,NOPARITY,ONESTOPBIT


DWORD    dwSize;
DWORD dwRIT,dwRTTM,dwRTTC;


DWORD main(int argc, char *argv[], char *envp[])
{
BOOL bRc;
CHAR chDummy;
BOOL  bSize,bRIT,bRTTM,bRTTC;

UNREFERENCED_PARAMETER(envp);

bRIT = bRTTM = bSize =  bRTTC = FALSE;

while(argc--)
{



switch(argv[argc][1])
  {
//  case 'f' :
//  case 'F' :    {
//                if (argv[argc][0] != '-') break;
//                printf("filename option=%s\n\n",argv[argc]);
//                sscanf(argv[argc],"%c %c %s",&chDummy,&chDummy,lpFilename);
//                printf("filename to be displayed=%s\n\n",lpFilename);
//                bFile = TRUE;
//                break;
//                }

  case 'I' :
  case 'i' :    {
                if (argv[argc][0] != '-') break;
                printf("RIT option=%s\n\n",argv[argc]);
                sscanf(argv[argc],"%c %c %lx",&chDummy,&chDummy,&dwRIT);
                printf("RIT =%lx\n\n",dwRIT);
                bRIT = TRUE;
                break;
                }
  case 'M' :
  case 'm' :    {
                if (argv[argc][0] != '-') break;
                printf("RTTM option=%s\n\n",argv[argc]);
                sscanf(argv[argc],"%c %c %lx",&chDummy,&chDummy,&dwRTTM);
                printf("RTTM =%lx\n\n",dwRTTM);
                bRTTM = TRUE;
                break;
                }



  case 'C' :
  case 'c' :    {
                if (argv[argc][0] != '-') break;
                printf("RTTC option=%s\n\n",argv[argc]);
                sscanf(argv[argc],"%c %c %lx",&chDummy,&chDummy,&dwRTTC);
                printf("RTTC =%lx\n\n",dwRTTC);
                bRTTC = TRUE;
                break;
                }



  case 'S' :
  case 's' :    {
                if (argv[argc][0] != '-') break;
                printf("size option=%s\n\n",argv[argc]);
                sscanf(argv[argc],"%c %c %lx",&chDummy,&chDummy,&dwSize);
                printf("Size to be xfered =%lx bytes\n\n",dwSize);
                if (dwSize > NUM)
                    {
                     printf("dwSize[%lx] should be < %lx\n",dwSize,NUM);
                     return -1;
                    }
                bSize = TRUE;
                break;
                }
  default:      {
                break;
                }

  }

}

if (!bRIT || !bRTTM || !bRTTC ||!bSize)
     {
     printf("\n\nOptions are required!!\n\n");
     printf("timeout <required options>\n\n");
     printf("options:\n");
     printf("         -i<read interval timeout > eg: -i0x0000>\n\n");
     printf("         -m<read total timeout multiplier> eg: -m0x0000>\n\n");
     printf("         -c<read total timeout constant> eg: -c0x0000>\n\n");
     printf("         -s<size in bytes to be xfred eg: -s0x10>\n\n");
     return (-1);
     }








print("\n\n *** Doing COM TEST with [port=%s Baud=%d,Size=%d,Parity=%d,Stop=%d]***\n\n",
        SETTINGS1);
bRc = DoComIo(SETTINGS1);
if (!bRc) {
            print("\n\nCOM TEST FAILED********************************\n\n");
          }

return 0;
}


BOOL DoComIo(LPSTR lpCom,DWORD Baud,BYTE Size,BYTE Parity,BYTE Stop)
{

CHAR WrBuffer[NUM];
CHAR RdBuffer[NUM];
DWORD i;
HANDLE hCommPort;
DCB    dcb;
BOOL   bRc;
DWORD  dwNumWritten,dwNumRead,dwErrors;
COMMTIMEOUTS CommTimeOuts;

print("\n\n *** COMM TEST START [port=%s,Baud=%d,Size=%d,Parity=%d,Stop=%d]***\n\n",
         lpCom,Baud,Size,Parity,Stop);

print("Opening the comm port for read write\n");

hCommPort = CreateFile(
                       lpCom,
                       GENERIC_READ|GENERIC_WRITE,
                       0, // exclusive
                       NULL, // sec attr
                       OPEN_EXISTING,
                       0,             // no attributes
                       NULL);         // no template

if (hCommPort == (HANDLE)-1)
    {
    print("FAIL: OpenComm failed rc: %lx\n",hCommPort);
    return FALSE;
    }


print("Opening the comm port for read write: SUCCESS hCommPort=%lx\n",hCommPort);

print("Setting the line characteristics on comm \n");

if (!GetCommState(hCommPort,&dcb))
    {
    printf("FAIL: Couldn't get the dcb: %d\n",GetLastError());
    return FALSE;
    }
dcb.DCBlength   = sizeof(DCB);
// dcb.DCBversion  = 0x0002; in spec not in header

dcb.BaudRate = Baud;
dcb.ByteSize = Size;
dcb.Parity   = Parity;
dcb.StopBits = Stop;



bRc = SetupComm(hCommPort,1024,1024);

printf("bRc from CommSetup = %lx\n",bRc);

if (!bRc)
    {
    printf("FAIL: comsetup\n");
    }

bRc = SetCommState(hCommPort,&dcb);

if (!bRc)
    {
    print("FAIL: cannot set the comm state rc:%lx\n",bRc);
    bRc = CloseHandle(hCommPort);
          if (!bRc)
          {
           print("FAIL: cannot close the comm port:%lx\n",bRc);
          }
    return FALSE;
    }

print("Setting the line characteristics on comm: SUCCESS\n");




CommTimeOuts.ReadIntervalTimeout =         dwRIT;
CommTimeOuts.ReadTotalTimeoutMultiplier =  dwRTTM;
CommTimeOuts.ReadTotalTimeoutConstant   =  dwRTTC;
CommTimeOuts.WriteTotalTimeoutMultiplier = 0;
CommTimeOuts.WriteTotalTimeoutConstant   = 0;


printf("setting timeouts: RIT=%lx RTTM = %lx RTTC = %lx\n",
        dwRIT, dwRTTM, dwRTTC);

bRc = SetCommTimeouts(hCommPort, &CommTimeOuts);

printf("bRc from setcommtimeouts = %lx\n",bRc);

if (!bRc)
    {
    printf("FAIL: setcommtimeouts\n");
    }

printf("Filling the buffer with the known chars \n");

for (i=0; i<dwSize; i++)
    {
    //WrBuffer[i] = 'a';
    WrBuffer[i] = (CHAR)i;

    }

print("Filling the buffer with the known chars : SUCCESS\n");


#ifdef COM_DEB
print("Dumping the buffer before sending it to comm\n");

for (i=0; i< dwSize; i++)
    {
    //print("%c",RdBuffer[i]);
    print(" %d ",WrBuffer[i]);

    }

print("\nDumping the buffer before sending it to comm SUCCESS\n");
#endif

print("Filling the Rdbuffer with the known chars (0xFF) to makeit dirty\n");

for (i=0; i< dwSize; i++)
    {
    RdBuffer[i] = (CHAR)'0xFF';
    }

print("Filling the Rdbuffer with the known chars (0xFF): SUCCESS\n");

print("Writting this buffer to the comm port\n");

bRc = WriteFile( hCommPort,
                 WrBuffer,
                 dwSize,
                &dwNumWritten,
                 NULL);

if (!bRc)
        {
        print("FAIL: cannot Write To the comm port:%lx\n",bRc);
        bRc = CloseHandle(hCommPort);
          if (!bRc)
          {
           print("FAIL: cannot close the comm port:%lx\n",bRc);
          }
        return FALSE;
        }

print("Writting this buffer to the comm port: SUCCESS rc:%lx, byteswritten:%lx\n",
                                                     bRc,dwNumWritten);


print("Reading this buffer from the comm port\n");

bRc = ReadFile( hCommPort,
                RdBuffer,
                dwSize,
               &dwNumRead,
                NULL);

if (!bRc)
        {
        print("FAIL: cannot Read From the comm port:%lx\n",bRc);
        bRc = CloseHandle(hCommPort);
          if (!bRc)
          {
           print("FAIL: cannot close the comm port:%lx\n",bRc);
          }
        return FALSE;
        }

print("Reading this buffer from the comm port: SUCCESS rc:%lx, bytesread:%lx\n",
                                                     bRc,dwNumRead);


//#ifdef COM_DEB
print("Dumping the Rdbuffer with the comm data\n");

for (i=0; i< dwSize; i++)
    {
    //print("%c",RdBuffer[i]);
    print(" %d ",RdBuffer[i]);

    }

print("\nDumping the Rdbuffer with the comm data: SUCCESS\n");
//#endif

print("Comparing the rd and wr buffers\n");

for (i=0; i< dwSize; i++)
    {
    if (RdBuffer[i] != WrBuffer[i])
        {
        print("FAIL: BufferMisMatch: RdBuffer[%d]=%lx,WrBuffer[%d]=%lx\n",
                      i,RdBuffer[i],i,WrBuffer[i]);
        bRc = CloseHandle(hCommPort);
          if (!bRc)
          {
           print("FAIL: cannot close the comm port:%lx\n",bRc);
          }
        return FALSE;
        }
    }

print("Comparing the rd and wr buffers: SUCCESS\n");


bRc = ClearCommError(hCommPort,&dwErrors,NULL);
print("ClearCommError: rc= %lx and dwErrors=%lx\n",bRc,dwErrors);

bRc = PurgeComm(hCommPort,0);
print("PurgeComm (%lx,0) rc = %lx\n",hCommPort,bRc);


//bRc = FlushFileBuffers(hCommPort);
//print("flushfilebuffers(%lx) rc = %lx\n",hCommPort,bRc);


print("Closing the comm port\n");
bRc = CloseHandle(hCommPort);

if (!bRc)
    {
        print("FAIL: cannot close the comm port:%lx\n",bRc);
        return FALSE;
    }


print("\n\n*** COMM TEST OVER*** \n\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\serial\test\tmask.c ===
#include <stddef.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include "windows.h"

HANDLE WaitEvent;
HANDLE StartWaitEvent;
HANDLE StartTransmitEvent;
HANDLE SetBreakEvent;
HANDLE ClrBreakEvent;
HANDLE hFile;
HANDLE IoSemaphore;


DWORD
WaitCommThread(
    LPVOID Trash
    )
{

    DWORD ReasonSatisfied;
    DWORD Trash2;
    OVERLAPPED Ol;
    UNREFERENCED_PARAMETER(Trash);

    Ol.hEvent = WaitEvent;
    do {

        //
        // StartWait Event will get pulsed whenever the user
        // asks for a wait.
        //

        WaitForSingleObject(StartWaitEvent,-1);

        //
        // Now we wait on the comm event.
        //

        WaitForSingleObject(IoSemaphore,-1);
        printf("Waiting for comm event\n");
        ReleaseSemaphore(IoSemaphore,1,NULL);
        if (!WaitCommEvent(
                 hFile,
                 &ReasonSatisfied,
                 &Ol
                 )) {

            DWORD LastError = GetLastError();

            if (LastError == ERROR_IO_PENDING) {

                if (!GetOverlappedResult(
                         hFile,
                         &Ol,
                         &Trash2,
                         TRUE
                         )) {

                    WaitForSingleObject(IoSemaphore,-1);
                    printf("Could not do the getoverlapped on the wait: %d\n",GetLastError());
                    ReleaseSemaphore(IoSemaphore,1,NULL);

                } else {

                    WaitForSingleObject(IoSemaphore,-1);
                    printf("Wait satisfied with mask: %x\n",ReasonSatisfied);
                    printf("Event was%sset\n",((!WaitForSingleObject(WaitEvent,0))?(" "):(" not ")));
                    ReleaseSemaphore(IoSemaphore,1,NULL);

                }

            } else {

                WaitForSingleObject(IoSemaphore,-1);
                printf("Could not start the wait: %d\n",LastError);
                ReleaseSemaphore(IoSemaphore,1,NULL);

            }

        } else {

            WaitForSingleObject(IoSemaphore,-1);
            printf("Wait satisfied with mask: %x\n",ReasonSatisfied);
            printf("Event was%sset\n",((!WaitForSingleObject(WaitEvent,0))?(" "):(" not ")));
            ReleaseSemaphore(IoSemaphore,1,NULL);

        }

    } while (TRUE);

    return 1;

}


DWORD
TransmitCommThread(
    LPVOID Trash
    )
{


    UNREFERENCED_PARAMETER(Trash);

    do {

        //
        // StartWait Event will get pulsed whenever the user
        // asks for a wait.
        //

        WaitForSingleObject(StartTransmitEvent,-1);

        //
        // Now we wait on the comm event.
        //

        WaitForSingleObject(IoSemaphore,-1);
        printf("Starting transmit\n");
        ReleaseSemaphore(IoSemaphore,1,NULL);
        if (!TransmitCommChar(
                 hFile,
                 'a'
                 )) {

            DWORD LastError = GetLastError();

            WaitForSingleObject(IoSemaphore,-1);
            printf("Could not initiate the transmit: %d\n",LastError);
            ReleaseSemaphore(IoSemaphore,1,NULL);

        } else {

            COMSTAT LocalStat;

            if (!ClearCommError(
                     hFile,
                     NULL,
                     &LocalStat
                     )) {

                WaitForSingleObject(IoSemaphore,-1);
                printf("Could not initiate the clear comm error: %d\n",GetLastError());
                ReleaseSemaphore(IoSemaphore,1,NULL);

            } else {

                WaitForSingleObject(IoSemaphore,-1);
                printf("Successful transmit - InQueue,OutQueue: %d,%d\n",LocalStat.cbInQue,LocalStat.cbOutQue);
                ReleaseSemaphore(IoSemaphore,1,NULL);

            }

        }

    } while (TRUE);

    return 1;

}

DWORD
SetBreakThread(
    LPVOID Trash
    )
{


    UNREFERENCED_PARAMETER(Trash);

    do {

        //
        // StartBreakEvent will get pulsed whenever the user
        // asks for a Set break.
        //

        WaitForSingleObject(SetBreakEvent,-1);

        //
        // Now we wait on the comm event.
        //

        WaitForSingleObject(IoSemaphore,-1);
        printf("Starting Set Break\n");
        ReleaseSemaphore(IoSemaphore,1,NULL);
        if (!EscapeCommFunction(
                 hFile,
                 SETBREAK
                 )) {

            DWORD LastError = GetLastError();

            WaitForSingleObject(IoSemaphore,-1);
            printf("Set break failed: %d\n",LastError);
            ReleaseSemaphore(IoSemaphore,1,NULL);

        } else {

            WaitForSingleObject(IoSemaphore,-1);
            printf("Set escape done\n");
            ReleaseSemaphore(IoSemaphore,1,NULL);

        }

    } while (TRUE);

    return 1;

}

DWORD
ClrBreakThread(
    LPVOID Trash
    )
{


    UNREFERENCED_PARAMETER(Trash);

    do {

        //
        // StartWait Event will get pulsed whenever the user
        // asks for a clr break.
        //

        WaitForSingleObject(ClrBreakEvent,-1);

        //
        // Now we wait on the comm event.
        //

        WaitForSingleObject(IoSemaphore,-1);
        printf("Starting clr break\n");
        ReleaseSemaphore(IoSemaphore,1,NULL);
        if (!EscapeCommFunction(
                 hFile,
                 CLRBREAK
                 )) {

            DWORD LastError = GetLastError();

            WaitForSingleObject(IoSemaphore,-1);
            printf("Could not initiate the clr break: %d\n",LastError);
            ReleaseSemaphore(IoSemaphore,1,NULL);

        } else {

            WaitForSingleObject(IoSemaphore,-1);
            printf("clr break done\n");
            ReleaseSemaphore(IoSemaphore,1,NULL);

        }

    } while (TRUE);

    return 1;

}


void main(int argc,char *argv[]) {

    char *MyPort = "COM1";
    DWORD ValueFromEscape = 0;
    DWORD CharFunc;
    DWORD ThreadId;
    int scanfval;

    if (argc > 1) {

        MyPort = argv[1];

    }

    WaitEvent = CreateEvent(
                    NULL,
                    TRUE,
                    FALSE,
                    NULL
                    );

    if (!WaitEvent) {

        printf("Wait Event could not be created\n");
        exit(1);

    }

    StartWaitEvent = CreateEvent(
                         NULL,
                         FALSE,
                         FALSE,
                         NULL
                         );

    if (!StartWaitEvent) {

        printf("StartWait Event could not be created\n");
        exit(1);

    }

    StartTransmitEvent = CreateEvent(
                             NULL,
                             FALSE,
                             FALSE,
                             NULL
                             );

    if (!StartTransmitEvent) {

        printf("StartTransmit Event could not be created\n");
        exit(1);

    }

    SetBreakEvent = CreateEvent(
                             NULL,
                             FALSE,
                             FALSE,
                             NULL
                             );

    if (!SetBreakEvent) {

        printf("SetBreakEvent could not be created\n");
        exit(1);

    }

    ClrBreakEvent = CreateEvent(
                             NULL,
                             FALSE,
                             FALSE,
                             NULL
                             );

    if (!ClrBreakEvent) {

        printf("ClrBreakEvent could not be created\n");
        exit(1);

    }


    IoSemaphore = CreateSemaphore(
                      NULL,
                      1,
                      1,
                      NULL
                      );

    if (!IoSemaphore) {

        printf("IoSemaphore could not be created\n");
        exit(1);

    }

    if ((hFile = CreateFile(
                     MyPort,
                     GENERIC_READ | GENERIC_WRITE,
                     0,
                     NULL,
                     CREATE_ALWAYS,
                     FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
                     NULL
                     )) != ((HANDLE)-1)) {

        DCB MyDcb;
        COMMTIMEOUTS NewTimeouts;

        printf("We successfully opened the %s port.\n",MyPort);


        //
        // We've successfully opened the file.  Set the state of
        // the comm device.  First we get the old values and
        // adjust to our own.
        //

        if (!GetCommState(
                 hFile,
                 &MyDcb
                 )) {

            printf("Couldn't get the comm state: %d\n",GetLastError());
            exit(1);

        }

        MyDcb.BaudRate = 19200;
        MyDcb.ByteSize = 8;
        MyDcb.Parity = NOPARITY;
        MyDcb.StopBits = ONESTOPBIT;
        MyDcb.EvtChar = 'a';

        NewTimeouts.ReadIntervalTimeout = 0;
        NewTimeouts.ReadTotalTimeoutMultiplier = 0;
        NewTimeouts.ReadTotalTimeoutConstant = 0;
        NewTimeouts.WriteTotalTimeoutMultiplier = 0;
        NewTimeouts.WriteTotalTimeoutConstant = 30000; // 30 seconds for immediate char;

        if (!SetCommState(
                hFile,
                &MyDcb
                )) {

            printf("Couldn't set the comm state: %d\n",GetLastError());
            exit(1);

        }

        if (!SetCommTimeouts(
                 hFile,
                 &NewTimeouts
                 )) {

            printf("Couldn't set the comm timeouts: %d\n",GetLastError());
            exit(1);

        }

    } else {

        printf("Could not open the comm port: %d\n",GetLastError());

    }

    //
    // Create the thread that will wait for the
    // comm events.
    //

    if (!CreateThread(
              NULL,
              0,
              WaitCommThread,
              NULL,
              0,
              &ThreadId
              )) {

        printf("Could not create the wait thread.\n");
        exit(1);

    }


    //
    // Create the thread that will wait for the
    // comm events.
    //

    if (!CreateThread(
              NULL,
              0,
              TransmitCommThread,
              NULL,
              0,
              &ThreadId
              )) {

        printf("Could not create the transmit thread.\n");
        exit(1);

    }

    if (!CreateThread(
              NULL,
              0,
              SetBreakThread,
              NULL,
              0,
              &ThreadId
              )) {

        printf("Could not create the transmit thread.\n");
        exit(1);

    }

    if (!CreateThread(
              NULL,
              0,
              ClrBreakThread,
              NULL,
              0,
              &ThreadId
              )) {

        printf("Could not create the transmit thread.\n");
        exit(1);

    }

    do {

        WaitForSingleObject(IoSemaphore,-1);
        printf("^z=END 1=GETCOMMMASK  2=WAITCOMMEVENT\n"
               "       3=SETCOMMMASK (Will prompt for mask)\n"
               "       4=TRANSMITIMMEDIATE\n"
               "       5=SETBREAK     6=CLRBREAK:");

        if ((scanfval = scanf("%d",&CharFunc)) != EOF) {

            if (scanfval != 1) {

                printf("Invalid input\n");
                ReleaseSemaphore(IoSemaphore,1,NULL);
                continue;

            }

            ReleaseSemaphore(IoSemaphore,1,NULL);

            if ((CharFunc >= 1) && (CharFunc <= 6)) {

                switch (CharFunc) {
                    case 1: {

                        DWORD OldMask = 0;

                        if (GetCommMask(
                                hFile,
                                &OldMask
                                )) {

                            WaitForSingleObject(IoSemaphore,-1);
                            printf("CurrentMask = %x\n",OldMask);
                            ReleaseSemaphore(IoSemaphore,1,NULL);

                        } else {

                            DWORD LastError = GetLastError();
                            DWORD ErrorWord = 0;

                            if (ClearCommError(
                                    hFile,
                                    &ErrorWord,
                                    NULL
                                    )) {

                                if (ErrorWord) {

                                    printf("We had an error word of: %x\n",ErrorWord);

                                } else {

                                    printf("No error word value on bad getmask call\n");

                                }

                            } else {

                                printf("Could not call clear comm error: %d\n",GetLastError());

                            }

                            WaitForSingleObject(IoSemaphore,-1);
                            printf("Error from GetMask: %d\n",LastError);
                            ReleaseSemaphore(IoSemaphore,1,NULL);

                        }

                        break;

                    }
                    case 2: {

                        if (!SetEvent(StartWaitEvent)) {

                            DWORD LastError = GetLastError();

                            WaitForSingleObject(IoSemaphore,-1);
                            printf("Could not set StartWaitEvent: %d\n",LastError);
                            ReleaseSemaphore(IoSemaphore,1,NULL);

                        }
                        break;

                    }
                    case 3: {

                        DWORD NewMask = 0;

                        WaitForSingleObject(IoSemaphore,-1);
                        printf("%.8x EV_RXCHAR   %.8x EV_RXFLAG\n"
                               "%.8x EV_TXEMPTY  %.8x EV_CTS   \n"
                               "%.8x EV_DSR      %.8x EV_RLSD  \n"
                               "%.8x EV_BREAK    %.8x EV_ERR   \n"
                               "%.8x EV_RING     %.8x EV_PERR  \n"
                               "%.8x EV_RX80FULL %.8x EV_EVENT1\n"
                               "%.8x EV_EVENT2                 \n",
                               EV_RXCHAR    ,EV_RXFLAG,
                               EV_TXEMPTY   ,EV_CTS,
                               EV_DSR       ,EV_RLSD,
                               EV_BREAK     ,EV_ERR,
                               EV_RING      ,EV_PERR,
                               EV_RX80FULL  ,EV_EVENT1,
                               EV_EVENT2);

                        if ((scanfval = scanf("%x",&NewMask)) != EOF) {

                            if (scanfval != 1) {

                                printf("Invalid input\n");
                                ReleaseSemaphore(IoSemaphore,1,NULL);
                                continue;

                            }

                            printf("Using New mask of: %x\n",NewMask);
                            ReleaseSemaphore(IoSemaphore,1,NULL);


                            if (!SetCommMask(
                                     hFile,
                                     NewMask
                                     )) {

                                DWORD LastError = GetLastError();

                                WaitForSingleObject(IoSemaphore,-1);
                                printf("SetCommMask unsuccessful: %d\n",LastError);
                                ReleaseSemaphore(IoSemaphore,1,NULL);

                            }


                        } else {

                            printf("All done\n");
                            ReleaseSemaphore(IoSemaphore,1,NULL);
                            exit(1);

                        }

                        break;

                    }

                    case 4: {

                        if (!SetEvent(StartTransmitEvent)) {

                            DWORD LastError = GetLastError();

                            WaitForSingleObject(IoSemaphore,-1);
                            printf("Could not set StartTransmitEvent: %d\n",LastError);
                            ReleaseSemaphore(IoSemaphore,1,NULL);

                        }
                        break;

                    }

                    case 5: {

                        if (!SetEvent(SetBreakEvent)) {

                            DWORD LastError = GetLastError();

                            WaitForSingleObject(IoSemaphore,-1);
                            printf("Could not set SetBreakEvent: %d\n",LastError);
                            ReleaseSemaphore(IoSemaphore,1,NULL);

                        }
                        break;

                    }

                    case 6: {

                        if (!SetEvent(ClrBreakEvent)) {

                            DWORD LastError = GetLastError();

                            WaitForSingleObject(IoSemaphore,-1);
                            printf("Could not set ClrBreakEvt: %d\n",LastError);
                            ReleaseSemaphore(IoSemaphore,1,NULL);

                        }
                        break;

                    }

                }

            }

        } else {

            printf("All done\n");
            ReleaseSemaphore(IoSemaphore,1,NULL);
            break;

        }

    } while (TRUE);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\serial\test\tserialr.c ===
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include "windows.h"

#define BIGREAD 256000
unsigned char readbuff[BIGREAD];

int __cdecl main(int argc,char *argv[]) {

    HANDLE hFile;
    DCB MyDcb;
    char *MyPort = "COM1";
    DWORD NumberActuallyRead;
    DWORD NumberToRead = 0;
    DWORD UseBaud = 19200;
    COMMTIMEOUTS To;
    clock_t Start;
    clock_t Finish;

    if (argc > 1) {

        sscanf(argv[1],"%d",&NumberToRead);

        if (argc > 2) {

            sscanf(argv[2],"%d",&UseBaud);

            if (argc > 3) {

                MyPort = argv[3];

            }

        }

    }

    printf("Will try to read %d characters.\n",NumberToRead);
    printf("Will try to read a %d baud.\n",UseBaud);
    printf("Using port %s\n",MyPort);

    if ((hFile = CreateFile(
                     MyPort,
                     GENERIC_READ | GENERIC_WRITE,
                     0,
                     NULL,
                     CREATE_ALWAYS,
                     FILE_ATTRIBUTE_NORMAL,
                     NULL
                     )) != ((HANDLE)-1)) {

        printf("We successfully opened the %s port.\n",MyPort);

        To.ReadIntervalTimeout = 0;
        To.ReadTotalTimeoutMultiplier = ((1000+(((UseBaud+9)/10)-1))/((UseBaud+9)/10));
        if (!To.ReadTotalTimeoutMultiplier) {
            To.ReadTotalTimeoutMultiplier = 1;
        }
        printf("Multiplier is: %d\n",To.ReadTotalTimeoutMultiplier);
        To.ReadTotalTimeoutConstant = 5000;
        To.WriteTotalTimeoutMultiplier = 0;
        To.WriteTotalTimeoutConstant = 5000;

        if (SetCommTimeouts(
                hFile,
                &To
                )) {

            //
            // We've successfully opened the file.  Set the state of
            // the comm device.  First we get the old values and
            // adjust to our own.
            //

            if (!GetCommState(
                     hFile,
                     &MyDcb
                     )) {

                printf("Couldn't get the comm state: %d\n",GetLastError());
                exit(1);

            }

            MyDcb.BaudRate = UseBaud;
            MyDcb.ByteSize = 8;
            MyDcb.Parity = NOPARITY;
            MyDcb.StopBits = ONESTOPBIT;
            MyDcb.fOutxCtsFlow = TRUE;
            MyDcb.fOutxDsrFlow = TRUE;
            MyDcb.fDtrControl = DTR_CONTROL_ENABLE;
            MyDcb.fRtsControl = RTS_CONTROL_ENABLE;

            if (SetCommState(
                    hFile,
                    &MyDcb
                    )) {

                printf("We successfully set the state of the %s port.\n",MyPort);

                Start = clock();
                if (ReadFile(
                        hFile,
                        readbuff,
                        NumberToRead,
                        &NumberActuallyRead,
                        NULL
                        )) {

                    unsigned char j;
                    DWORD TotalCount;

                    Finish = clock();
                    printf("Well we thought the read went ok.\n");
                    printf("Number actually read %d.\n",NumberActuallyRead);
                    printf("Now we check the data\n");
//                    printf("Time to read %f\n",(((double)(Finish-Start))/CLOCKS_PER_SEC));
//                    printf("Chars per second %f\n",((double)NumberActuallyRead)/(((double)(Finish-Start))/CLOCKS_PER_SEC));

                    for (
                        TotalCount = 0;
                        TotalCount < NumberActuallyRead;
                        ) {

                        for (
                            j = 0;
                            j <= 9;
                            j++
                            ) {

                            if (readbuff[TotalCount] != j) {

                                printf("Bad data starting at: %d\n",TotalCount);
                                goto donewithcheck;

                            }

                            TotalCount++;
                            if (TotalCount >= NumberActuallyRead) {

                                break;

                            }

                        }

                    }
donewithcheck:;


                } else {

                    DWORD LastError;
                    LastError = GetLastError();
                    printf("Couldn't read the %s device.\n",MyPort);
                    printf("Status of failed read is: %d\n",LastError);

                    //
                    // Get the error word from clear comm error.
                    //

                    if (!ClearCommError(
                             hFile,
                             &LastError,
                             NULL
                             )) {

                        printf("Couldn't call clear comm error: %d\n",GetLastError());
                        exit(1);

                    } else {

                        if (!LastError) {

                            printf("No LastError\n");

                        } else {

                            if (LastError & CE_RXOVER) {

                                printf("Error: CE_RXOVER\n");

                            }

                            if (LastError & CE_OVERRUN) {

                                printf("Error: CE_OVERRUN\n");

                            }

                            if (LastError & CE_RXPARITY) {

                                printf("Error: CE_RXPARITY\n");

                            }

                            if (LastError & CE_FRAME) {

                                printf("Error: CE_FRAME\n");

                            }

                            if (LastError & CE_BREAK) {

                                printf("Error: CE_BREAK\n");

                            }
                            if (LastError & ~(CE_RXOVER |
                                           CE_OVERRUN |
                                           CE_RXPARITY |
                                           CE_FRAME |
                                           CE_BREAK)) {

                                printf("Unknown errors: %x\n",LastError);

                            }

                        }

                    }

                }

            } else {

                DWORD LastError;
                LastError = GetLastError();
                printf("Couldn't set the %s device.\n",MyPort);
                printf("Status of failed set is: %x\n",LastError);

            }

        } else {

            DWORD LastError;
            LastError = GetLastError();
            printf("Couldn't set the %s device timeouts.\n",MyPort);
            printf("Status of failed timeouts is: %x\n",LastError);

        }

        CloseHandle(hFile);

    } else {

        DWORD LastError;
        LastError = GetLastError();
        printf("Couldn't open the %s device.\n",MyPort);
        printf("Status of failed open is: %x\n",LastError);

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\serial\test\tserialw.c ===
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include "windows.h"

#define BIGWRITE 256000
unsigned char writebuff[BIGWRITE];

int __cdecl main(int argc,char *argv[]) {

    HANDLE hFile;
    DCB MyDcb;
    char *MyPort = "COM1";
    DWORD NumberActuallyWritten;
    DWORD NumberToWrite = 0;
    DWORD UseBaud = 19200;

    COMMTIMEOUTS To;
    clock_t Start;
    clock_t Finish;

    if (argc > 1) {

        sscanf(argv[1],"%d",&NumberToWrite);

        if (argc > 2) {

            sscanf(argv[2],"%d",&UseBaud);

            if (argc > 3) {

                MyPort = argv[3];

            }

        }

    }

    printf("Will try to write %d characters.\n",NumberToWrite);
    printf("Will try to write at %d baud.\n",UseBaud);
    printf("Using port: %s\n",MyPort);

    if ((hFile = CreateFile(
                     MyPort,
                     GENERIC_READ | GENERIC_WRITE,
                     0,
                     NULL,
                     CREATE_ALWAYS,
                     FILE_ATTRIBUTE_NORMAL,
                     NULL
                     )) != ((HANDLE)-1)) {

        printf("We successfully opened the %s port.\n",MyPort);

        //
        // We've successfully opened the file.  Set the state of
        // the comm device.  First we get the old values and
        // adjust to our own.
        //

        if (!GetCommState(
                 hFile,
                 &MyDcb
                 )) {

            printf("Couldn't get the comm state: %d\n",GetLastError());
            exit(1);

        }

        MyDcb.BaudRate = UseBaud;
        MyDcb.ByteSize = 8;
        MyDcb.Parity = NOPARITY;
        MyDcb.StopBits = ONESTOPBIT;
        MyDcb.fOutxCtsFlow = TRUE;
        MyDcb.fOutxDsrFlow = TRUE;
        MyDcb.fDtrControl = DTR_CONTROL_ENABLE;
        MyDcb.fRtsControl = RTS_CONTROL_ENABLE;


        To.ReadIntervalTimeout = 0;
        To.ReadTotalTimeoutMultiplier = 0;
        To.ReadTotalTimeoutConstant = 0;
        To.WriteTotalTimeoutMultiplier = 0;
        To.WriteTotalTimeoutConstant = 0;

        SetCommTimeouts(
            hFile,
            &To
            );

        if (SetCommState(
                hFile,
                &MyDcb
                )) {

            unsigned char j;
            DWORD TotalCount;

            printf("We successfully set the state of the %s port.\n",MyPort);

            for (
                TotalCount = 0;
                TotalCount < NumberToWrite;
                ) {

                for (
                    j = 0;
                    j <= 9;
                    j++
                    ) {

                    writebuff[TotalCount] = j;
                    TotalCount++;
                    if (TotalCount >= NumberToWrite) {

                        break;

                    }

                }

            }

            Start = clock();
            if (WriteFile(
                    hFile,
                    writebuff,
                    NumberToWrite,
                    &NumberActuallyWritten,
                    NULL
                    )) {

                Finish = clock();
                printf("Time to write %f\n",(((double)(Finish-Start))/CLOCKS_PER_SEC));
                printf("Chars per second %f\n",((double)NumberActuallyWritten)/(((double)(Finish-Start))/CLOCKS_PER_SEC));

                printf("Well we thought the write went ok.\n");
                printf("Number actually written %d.\n",NumberActuallyWritten);

            } else {

                DWORD LastError;
                LastError = GetLastError();
                printf("Couldn't write the %s device.\n",MyPort);
                printf("Status of failed write is: %x\n",LastError);

            }

        } else {

            DWORD LastError;
            LastError = GetLastError();
            printf("Couldn't set the %s device.\n",MyPort);
            printf("Status of failed set is: %x\n",LastError);

        }

        CloseHandle(hFile);

    } else {

        DWORD LastError;
        LastError = GetLastError();
        printf("Couldn't open the %s device.\n",MyPort);
        printf("Status of failed open is: %x\n",LastError);

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\serial\test\tescape.c ===
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include "windows.h"

VOID
DumpCommState(
    IN DCB MyDcb
    ) {

    printf("Current comm state: \n");
    printf("Size of DCB:     %d\n",MyDcb.DCBlength);
    printf("Baud rate:       %d\n",MyDcb.BaudRate);
    printf("Binary mode:     %s\n",MyDcb.fBinary?"TRUE":"FALSE");
    printf("Parity checking: %s\n",MyDcb.fParity?"TRUE":"FALSE");
    printf("Out CTS Flow:    %s\n",MyDcb.fOutxCtsFlow?"TRUE":"FALSE");
    printf("Out DSR Flow:    %s\n",MyDcb.fOutxDsrFlow?"TRUE":"FALSE");
    printf("DTR control:     %s\n",MyDcb.fDtrControl==DTR_CONTROL_DISABLE?"DISABLE":
                                   MyDcb.fDtrControl==DTR_CONTROL_ENABLE?"ENABLE":
                                   MyDcb.fDtrControl==DTR_CONTROL_HANDSHAKE?"HANDSHAKE":"INVALID!");
    printf("Dsr sensitive:   %s\n",MyDcb.fDsrSensitivity?"TRUE":"FALSE");
    printf("Tx Contin xoff:  %s\n",MyDcb.fTXContinueOnXoff?"TRUE":"FALSE");
    printf("Output X on/off: %s\n",MyDcb.fOutX?"ON":"OFF");
    printf("Input X on/off:  %s\n",MyDcb.fInX?"ON":"OFF");
    printf("Error replace:   %s\n",MyDcb.fErrorChar?"ON":"OFF");
    printf("Null stripping:  %s\n",MyDcb.fNull?"ON":"OFF");
    printf("RTS control:     %s\n",MyDcb.fRtsControl==RTS_CONTROL_DISABLE?"DISABLE":
                                   MyDcb.fRtsControl==RTS_CONTROL_ENABLE?"ENABLE":
                                   MyDcb.fRtsControl==RTS_CONTROL_HANDSHAKE?"HANDSHAKE":"TOGGLE");
    printf("Abort on error:  %s\n",MyDcb.fAbortOnError?"ON":"OFF");
    printf("Xon Limit:       %d\n",MyDcb.XonLim);
    printf("Xoff Limit:      %d\n",MyDcb.XoffLim);
    printf("Valid bits/byte: %d\n",MyDcb.ByteSize);
    printf("Parity:          %s\n",MyDcb.Parity==EVENPARITY?"EVEN":
                                   MyDcb.Parity==ODDPARITY?"ODD":
                                   MyDcb.Parity==MARKPARITY?"MARK":
                                   MyDcb.Parity==NOPARITY?"NO":"INVALID");
    printf("Stop bits:       %s\n",MyDcb.StopBits==ONESTOPBIT?"1":
                                   MyDcb.StopBits==TWOSTOPBITS?"2":
                                   MyDcb.StopBits==ONE5STOPBITS?"1.5":"INVALID");
    printf("Xoff char:       %x\n",MyDcb.XoffChar);
    printf("Xon char:        %x\n",MyDcb.XonChar);
    printf("Error char:      %x\n",MyDcb.ErrorChar);
    printf("EOF char:        %x\n",MyDcb.EofChar);
    printf("Evt char:        %x\n",MyDcb.EvtChar);

}
int __cdecl main(int argc,char *argv[]) {

    HANDLE hFile;
    char *MyPort = "COM1";
    DWORD ValueFromEscape = 0;
    DWORD Func;
    DCB MyDcb;
    COMMPROP MyCommProp;
    DWORD NewXon;
    DWORD NewXoff;
    int scanfval;

    if (argc > 1) {

        MyPort = argv[1];

    }

    if ((hFile = CreateFile(
                     MyPort,
                     GENERIC_READ | GENERIC_WRITE,
                     0,
                     NULL,
                     CREATE_ALWAYS,
                     FILE_ATTRIBUTE_NORMAL,
                     NULL
                     )) != ((HANDLE)-1)) {

        printf("We successfully opened the %s port.\n",MyPort);

        do {

            printf("^z=END  1=SETXOFF   2=SETXON    3=SETRTS\n"
                   "        4=CLRRTS    5=SETDTR    6=CLRDTR\n"
                   "        7=RESETDEV  8=SETBREAK  9=CLRBREAK\n"
                   " SET   10=DSR HAND 11=CTS HAND 12=DCD HAND\n"
                   " CLEAR 13=DSR HAND 14=CTS HAND 15=DCD HAND\n"
                   "       16=DTR CONTROL ENABLE\n"
                   "       17=DTR CONTROL DISABLE\n"
                   "       18=DTR INPUT HANDSHAKE ENABLE\n"
                   "       19=DTR INPUT HANDSHARE DISABLE (implies 17)\n"
                   "       20=RTS CONTROL ENABLE\n"
                   "       21=RTS CONTROL DISABLE\n"
                   "       22=RTS INPUT HANDSHAKE ENABLE\n"
                   "       23=RTS INPUT HANDSHAKE DISABLE (implies 21)\n"
                   "       24=ClearCommError       25=GetCommModemStatus\n"
                   " SET   26=AUTO RECEIVE Xxxx    27=AUTO TRANSMIT Xxxx\n"
                   " CLEAR 28=AUTO RECEIVE Xxxx    29=AUTO TRANSMIT Xxxx: \n"
                   "       30=Get Queue Sizes\n"
                   "       31=Get XonLimit         32=Get XoffLimit\n"
                   "       33=Set XonLimit         34=Set XoffLimit\n"
                   "       35=Dump Comm State: ");

            if ((scanfval = scanf("%d",&Func)) == EOF) {

                printf("All done\n");
                break;

            } else if (scanfval != 1) {

                printf("Invalid input\n");

            } else {

                if ((Func >= 1) && (Func <= 35)) {

                    switch (Func) {
                        case 1:
                            if (!EscapeCommFunction(
                                     hFile,
                                     SETXON
                                     )) {

                                printf("Bad status from escape: %d\n",GetLastError());

                            }
                            break;
                        case 2:
                            if (!EscapeCommFunction(
                                     hFile,
                                     SETXOFF
                                     )) {

                                printf("Bad status from escape: %d\n",GetLastError());

                            }
                            break;
                        case 3:
                            if (!EscapeCommFunction(
                                     hFile,
                                     SETRTS
                                     )) {

                                printf("Bad status from escape: %d\n",GetLastError());

                            }
                            break;
                        case 4:
                            if (!EscapeCommFunction(
                                     hFile,
                                     CLRRTS
                                     )) {

                                printf("Bad status from escape: %d\n",GetLastError());

                            }
                            break;
                        case 5:
                            if (!EscapeCommFunction(
                                     hFile,
                                     SETDTR
                                     )) {

                                printf("Bad status from escape: %d\n",GetLastError());

                            }
                            break;
                        case 6:
                            if (!EscapeCommFunction(
                                     hFile,
                                     CLRDTR
                                     )) {

                                printf("Bad status from escape: %d\n",GetLastError());

                            }
                            break;
                        case 7:
                            if (!EscapeCommFunction(
                                     hFile,
                                     RESETDEV
                                     )) {

                                printf("Bad status from escape: %d\n",GetLastError());

                            }
                            break;
                        case 8:
                            if (!EscapeCommFunction(
                                     hFile,
                                     SETBREAK
                                     )) {

                                printf("Bad status from escape: %d\n",GetLastError());

                            }
                            break;
                        case 9:
                            if (!EscapeCommFunction(
                                     hFile,
                                     CLRBREAK
                                     )) {

                                printf("Bad status from escape: %d\n",GetLastError());

                            }
                            break;
                        case 10:
                            if (!GetCommState(
                                     hFile,
                                     &MyDcb
                                     )) {

                                printf("Couldn't get comm state: %d\n",GetLastError());
                            } else {

                                MyDcb.fOutxDsrFlow = TRUE;
                                if (!SetCommState(
                                         hFile,
                                         &MyDcb
                                         )) {

                                    printf("Couldn't set comm state: %d\n",GetLastError());

                                }
                            }
                            break;
                        case 11:
                            if (!GetCommState(
                                     hFile,
                                     &MyDcb
                                     )) {

                                printf("Couldn't get comm state: %d\n",GetLastError());
                            } else {

                                MyDcb.fOutxCtsFlow = TRUE;
                                if (!SetCommState(
                                         hFile,
                                         &MyDcb
                                         )) {

                                    printf("Couldn't set comm state: %d\n",GetLastError());

                                }
                            }
                            break;
                        case 12:
                            printf("Setting DCD HandShaking not implemented\n");
                            break;
                        case 13:
                            if (!GetCommState(
                                     hFile,
                                     &MyDcb
                                     )) {

                                printf("Couldn't get comm state: %d\n",GetLastError());
                            } else {

                                MyDcb.fOutxDsrFlow = FALSE;
                                if (!SetCommState(
                                         hFile,
                                         &MyDcb
                                         )) {

                                    printf("Couldn't set comm state: %d\n",GetLastError());

                                }
                            }
                            break;
                        case 14:
                            if (!GetCommState(
                                     hFile,
                                     &MyDcb
                                     )) {

                                printf("Couldn't get comm state: %d\n",GetLastError());
                            } else {

                                MyDcb.fOutxCtsFlow = FALSE;
                                if (!SetCommState(
                                         hFile,
                                         &MyDcb
                                         )) {

                                    printf("Couldn't set comm state: %d\n",GetLastError());

                                }
                            }
                            break;
                        case 15:
                            printf("Clearing DCD HandShaking is not implemented.\n");
                            break;

                        case 16:
                            if (!GetCommState(
                                     hFile,
                                     &MyDcb
                                     )) {

                                printf("Couldn't get comm state: %d\n",GetLastError());
                            } else {

                                MyDcb.fDtrControl = DTR_CONTROL_ENABLE;
                                if (!SetCommState(
                                         hFile,
                                         &MyDcb
                                         )) {

                                    printf("Couldn't set comm state: %d\n",GetLastError());

                                }
                            }
                            break;
                        case 17:
                            if (!GetCommState(
                                     hFile,
                                     &MyDcb
                                     )) {

                                printf("Couldn't get comm state: %d\n",GetLastError());
                            } else {

                                MyDcb.fDtrControl = DTR_CONTROL_DISABLE;
                                if (!SetCommState(
                                         hFile,
                                         &MyDcb
                                         )) {

                                    printf("Couldn't set comm state: %d\n",GetLastError());

                                }
                            }
                            break;
                        case 18:
                            if (!GetCommState(
                                     hFile,
                                     &MyDcb
                                     )) {

                                printf("Couldn't get comm state: %d\n",GetLastError());
                            } else {

                                MyDcb.fDtrControl = DTR_CONTROL_HANDSHAKE;
                                if (!SetCommState(
                                         hFile,
                                         &MyDcb
                                         )) {

                                    printf("Couldn't set comm state: %d\n",GetLastError());

                                }
                            }
                            break;
                        case 19:
                            if (!GetCommState(
                                     hFile,
                                     &MyDcb
                                     )) {

                                printf("Couldn't get comm state: %d\n",GetLastError());
                            } else {

                                MyDcb.fDtrControl = DTR_CONTROL_DISABLE;
                                if (!SetCommState(
                                         hFile,
                                         &MyDcb
                                         )) {

                                    printf("Couldn't set comm state: %d\n",GetLastError());

                                }
                            }
                            break;
                        case 20:
                            if (!GetCommState(
                                     hFile,
                                     &MyDcb
                                     )) {

                                printf("Couldn't get comm state: %d\n",GetLastError());
                            } else {

                                MyDcb.fRtsControl = RTS_CONTROL_ENABLE;
                                if (!SetCommState(
                                         hFile,
                                         &MyDcb
                                         )) {

                                    printf("Couldn't set comm state: %d\n",GetLastError());

                                }
                            }
                            break;
                        case 21:
                            if (!GetCommState(
                                     hFile,
                                     &MyDcb
                                     )) {

                                printf("Couldn't get comm state: %d\n",GetLastError());
                            } else {

                                MyDcb.fRtsControl = RTS_CONTROL_DISABLE;
                                if (!SetCommState(
                                         hFile,
                                         &MyDcb
                                         )) {

                                    printf("Couldn't set comm state: %d\n",GetLastError());

                                }
                            }
                            break;
                        case 22:
                            if (!GetCommState(
                                     hFile,
                                     &MyDcb
                                     )) {

                                printf("Couldn't get comm state: %d\n",GetLastError());
                            } else {

                                MyDcb.fRtsControl = DTR_CONTROL_HANDSHAKE;
                                if (!SetCommState(
                                         hFile,
                                         &MyDcb
                                         )) {

                                    printf("Couldn't set comm state: %d\n",GetLastError());

                                }
                            }
                            break;
                        case 23:
                            if (!GetCommState(
                                     hFile,
                                     &MyDcb
                                     )) {

                                printf("Couldn't get comm state: %d\n",GetLastError());
                            } else {

                                MyDcb.fRtsControl = DTR_CONTROL_DISABLE;
                                if (!SetCommState(
                                         hFile,
                                         &MyDcb
                                         )) {

                                    printf("Couldn't set comm state: %d\n",GetLastError());

                                }
                            }
                            break;
                        case 24: {

                            DWORD Errors;
                            COMSTAT LocalComStat = {0};

                            if (!ClearCommError(
                                     hFile,
                                     &Errors,
                                     &LocalComStat
                                     )) {

                                printf("Couldn't clear errors: %d\n",GetLastError());

                            } else {

                                if (!Errors) {

                                    printf("No errors\n");

                                } else {

                                    if (Errors & CE_RXOVER) {

                                        printf("Error: CE_RXOVER\n");

                                    }

                                    if (Errors & CE_OVERRUN) {

                                        printf("Error: CE_OVERRUN\n");

                                    }

                                    if (Errors & CE_RXPARITY) {

                                        printf("Error: CE_RXPARITY\n");

                                    }

                                    if (Errors & CE_FRAME) {

                                        printf("Error: CE_FRAME\n");

                                    }

                                    if (Errors & CE_BREAK) {

                                        printf("Error: CE_BREAK\n");

                                    }
                                    if (Errors & ~(CE_RXOVER |
                                                   CE_OVERRUN |
                                                   CE_RXPARITY |
                                                   CE_FRAME |
                                                   CE_BREAK)) {

                                        printf("Unknown errors: %x\n",Errors);

                                    }

                                }

                                printf("Comstat values------------\n");
                                if (LocalComStat.fCtsHold) {

                                    printf("Holding due to Cts\n");

                                }
                                if (LocalComStat.fDsrHold) {

                                    printf("Holding due to Dsr\n");

                                }
                                if (LocalComStat.fRlsdHold) {

                                    printf("Holding due to Xoff received\n");

                                }
                                if (LocalComStat.fXoffSent) {

                                    printf("Holding due to Xoff sent\n");

                                }
                                if (LocalComStat.fEof) {

                                    printf("Eof Seen\n");

                                }
                                if (LocalComStat.fTxim) {

                                    printf("Immediate character being sent\n");

                                }
                                printf("Chars in typeahead: %d\n",LocalComStat.cbInQue);
                                printf("Chars to be sent: %d\n",LocalComStat.cbOutQue);

                            }

                            break;

                        }
                        case 25: {
                            DWORD ModemStat;

                            if (!GetCommModemStatus(
                                     hFile,
                                     &ModemStat
                                     )) {

                                printf("Couldn't get the modem stat: %d\n",GetLastError());

                            } else {

                                printf("Modem bits set---------\n");
                                if (ModemStat & MS_CTS_ON) {

                                    printf("CTS is ON\n");

                                }
                                if (ModemStat & MS_DSR_ON) {

                                    printf("DSR is ON\n");

                                }
                                if (ModemStat & MS_RING_ON) {

                                    printf("RING is ON\n");

                                }
                                if (ModemStat & MS_RLSD_ON) {

                                    printf("RLSD is ON\n");

                                }
                                if (ModemStat & ~(MS_CTS_ON |
                                                  MS_DSR_ON |
                                                  MS_RING_ON |
                                                  MS_RLSD_ON)) {

                                    printf("Unknown Modem Stat: %x\n",ModemStat);

                                }

                            }

                            break;
                        }
                        case 26:
                            if (!GetCommState(
                                     hFile,
                                     &MyDcb
                                     )) {

                                printf("Couldn't get comm state: %d\n",GetLastError());
                            } else {

                                MyDcb.fInX = TRUE;
                                if (!SetCommState(
                                         hFile,
                                         &MyDcb
                                         )) {

                                    printf("Couldn't set comm state: %d\n",GetLastError());

                                }
                            }
                            break;
                        case 27:
                            if (!GetCommState(
                                     hFile,
                                     &MyDcb
                                     )) {

                                printf("Couldn't get comm state: %d\n",GetLastError());
                            } else {

                                MyDcb.fOutX = TRUE;
                                if (!SetCommState(
                                         hFile,
                                         &MyDcb
                                         )) {

                                    printf("Couldn't set comm state: %d\n",GetLastError());

                                }
                            }
                            break;
                        case 28:
                            if (!GetCommState(
                                     hFile,
                                     &MyDcb
                                     )) {

                                printf("Couldn't get comm state: %d\n",GetLastError());
                            } else {

                                MyDcb.fInX = FALSE;
                                if (!SetCommState(
                                         hFile,
                                         &MyDcb
                                         )) {

                                    printf("Couldn't set comm state: %d\n",GetLastError());

                                }
                            }
                            break;
                        case 29:
                            if (!GetCommState(
                                     hFile,
                                     &MyDcb
                                     )) {

                                printf("Couldn't get comm state: %d\n",GetLastError());
                            } else {

                                MyDcb.fOutX = FALSE;
                                if (!SetCommState(
                                         hFile,
                                         &MyDcb
                                         )) {

                                    printf("Couldn't set comm state: %d\n",GetLastError());

                                }
                            }
                            break;
                        case 30:

                            if (!GetCommProperties(
                                     hFile,
                                     &MyCommProp
                                     )) {

                                printf("Couldn't get comm state: %d\n",GetLastError());
                            } else {

                                printf("Rx Queue Size: %d Tx Queue Size: %d\n",
                                       MyCommProp.dwCurrentRxQueue,
                                       MyCommProp.dwCurrentTxQueue
                                       );
                            }
                            break;
                        case 31:
                            if (!GetCommState(
                                     hFile,
                                     &MyDcb
                                     )) {

                                printf("Couldn't get comm state: %d\n",GetLastError());
                            } else {

                                printf("XonLimit is %d\n",MyDcb.XonLim);

                            }

                            break;
                        case 32:
                            if (!GetCommState(
                                     hFile,
                                     &MyDcb
                                     )) {

                                printf("Couldn't get comm state: %d\n",GetLastError());
                            } else {

                                printf("XoffLimit is %d\n",MyDcb.XoffLim);

                            }

                            break;
                        case 33:
                            printf("The New Xon limit Value: ");
                            scanf("%d",&NewXon);
                            printf("Setting Xon limit to %d\n",NewXon);
                            if (!GetCommState(
                                     hFile,
                                     &MyDcb
                                     )) {

                                printf("Couldn't get comm state: %d\n",GetLastError());
                            } else {

                                MyDcb.XonLim = (WORD)NewXon;
                                if (!SetCommState(
                                         hFile,
                                         &MyDcb
                                         )) {

                                    printf("Couldn't set comm state: %d\n",GetLastError());

                                }
                            }
                            break;
                        case 34:

                            printf("The New Xoff limit Value: ");
                            scanf("%d",&NewXoff);
                            printf("Setting Xoff limit to %d\n",NewXoff);
                            if (!GetCommState(
                                     hFile,
                                     &MyDcb
                                     )) {

                                printf("Couldn't get comm state: %d\n",GetLastError());
                            } else {

                                MyDcb.XoffLim = (WORD)NewXoff;
                                if (!SetCommState(
                                         hFile,
                                         &MyDcb
                                         )) {

                                    printf("Couldn't set comm state: %d\n",GetLastError());

                                }
                            }
                            break;

                        case 35:

                            if (!GetCommState(
                                     hFile,
                                     &MyDcb
                                     )) {

                                printf("Couldn't get comm state: %d\n",GetLastError());
                            } else {

                                DumpCommState(MyDcb);

                            }
                            break;


                    }

                } else {

                    printf("Invalid Input\n");

                }

            }


        } while (TRUE);


        CloseHandle(hFile);

    } else {

        DWORD LastError;
        LastError = GetLastError();
        printf("Couldn't open the %s device.\n",MyPort);
        printf("Status of failed open is: %x\n",LastError);

    }

    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\serial\test\tseriatr.c ===
//
// This is special in that it attempts to test the interval timeout.
//

#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include "windows.h"

#define BIGREAD 256000
unsigned char readbuff[BIGREAD];

void main(int argc,char *argv[]) {

    HANDLE hFile;
    DCB MyDcb;
    char *MyPort = "COM1";
    DWORD NumberActuallyRead;
    DWORD NumberToRead = 0;
    DWORD UseBaud = 19200;
    COMMTIMEOUTS To;
    clock_t Start;
    clock_t Finish;

    if (argc > 1) {

        sscanf(argv[1],"%d",&NumberToRead);

        if (argc > 2) {

            sscanf(argv[2],"%d",&UseBaud);

            if (argc > 3) {

                MyPort = argv[3];

            }

        }

    }

    if (((NumberToRead / 2)*2) != NumberToRead) {

        printf("Number to read must be even!\n");
        exit(1);

    }

    printf("Will try to read %d characters.\n",NumberToRead);
    printf("Will try to read a %d baud.\n",UseBaud);
    printf("Using port %s\n",MyPort);

    if ((hFile = CreateFile(
                     MyPort,
                     GENERIC_READ | GENERIC_WRITE,
                     0,
                     NULL,
                     CREATE_ALWAYS,
                     FILE_ATTRIBUTE_NORMAL,
                     NULL
                     )) != ((HANDLE)-1)) {

        printf("We successfully opened the %s port.\n",MyPort);

        To.ReadIntervalTimeout = 3000; // Three seconds between chars max.
        To.ReadTotalTimeoutMultiplier = ((1000+(((UseBaud+9)/10)-1))/((UseBaud+9)/10));
        if (!To.ReadTotalTimeoutMultiplier) {
            To.ReadTotalTimeoutMultiplier = 1;
        }
        printf("Multiplier is: %d\n",To.ReadTotalTimeoutMultiplier);
        To.ReadTotalTimeoutConstant = NumberToRead * 10000; // Allow ten seconds for each character.
        To.WriteTotalTimeoutMultiplier = 0;
        To.WriteTotalTimeoutConstant = 5000;

        if (SetCommTimeouts(
                hFile,
                &To
                )) {

            //
            // We've successfully opened the file.  Set the state of
            // the comm device.  First we get the old values and
            // adjust to our own.
            //

            if (!GetCommState(
                     hFile,
                     &MyDcb
                     )) {

                printf("Couldn't get the comm state: %d\n",GetLastError());
                exit(1);

            }

            MyDcb.BaudRate = UseBaud;
            MyDcb.ByteSize = 8;
            MyDcb.Parity = NOPARITY;
            MyDcb.StopBits = ONESTOPBIT;

            if (SetCommState(
                    hFile,
                    &MyDcb
                    )) {

                printf("We successfully set the state of the %s port.\n",MyPort);

                Start = clock();
                if (ReadFile(
                        hFile,
                        readbuff,
                        NumberToRead,
                        &NumberActuallyRead,
                        NULL
                        )) {

                    unsigned char j;
                    DWORD TotalCount;

                    Finish = clock();
                    printf("Well we thought the read went ok.\n");
                    printf("Number actually read %d.\n",NumberActuallyRead);
                    printf("Now we check the data\n");
//                    printf("Time to read %f\n",(((double)(Finish-Start))/CLOCKS_PER_SEC));
//                    printf("Chars per second %f\n",((double)NumberActuallyRead)/(((double)(Finish-Start))/CLOCKS_PER_SEC));

                    for (
                        TotalCount = 0;
                        TotalCount < NumberActuallyRead;
                        ) {

                        for (
                            j = 0;
                            j <= 9;
                            j++
                            ) {

                            if (readbuff[TotalCount] != j) {

                                printf("Bad data starting at: %d\n",TotalCount);
                                goto donewithcheck;

                            }

                            TotalCount++;
                            if (TotalCount >= NumberActuallyRead) {

                                break;

                            }

                        }

                    }
donewithcheck:;


                } else {

                    DWORD LastError;
                    LastError = GetLastError();
                    printf("Couldn't read the %s device.\n",MyPort);
                    printf("Status of failed read is: %x\n",LastError);

                }

            } else {

                DWORD LastError;
                LastError = GetLastError();
                printf("Couldn't set the %s device.\n",MyPort);
                printf("Status of failed set is: %x\n",LastError);

            }

        } else {

            DWORD LastError;
            LastError = GetLastError();
            printf("Couldn't set the %s device timeouts.\n",MyPort);
            printf("Status of failed timeouts is: %x\n",LastError);

        }

        CloseHandle(hFile);

    } else {

        DWORD LastError;
        LastError = GetLastError();
        printf("Couldn't open the %s device.\n",MyPort);
        printf("Status of failed open is: %x\n",LastError);

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\serial\test\tsetup.c ===
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include "windows.h"

DWORD SV[][2] = {
                -1,-1,
                -1,0,
                -1,1,
                -1,100,
                -1,1024,
                -1,4096,
                -1,10000,
                0,-1,
                0,0,
                0,1,
                0,100,
                0,1024,
                0,4096,
                0,10000,
                1,-1,
                1,0,
                1,1,
                1,100,
                1,1024,
                1,4096,
                1,10000,
                100,0,
                100,1,
                100,100,
                100,1024,
                100,4096,
                100,10000,
                1024,-1,
                1024,0,
                1024,1,
                1024,100,
                1024,1024,
                1024,4096,
                1024,10000,
                4096,-1,
                4096,0,
                4096,1,
                4096,100,
                4096,1024,
                4096,4096,
                4096,10000,
                10000,-1,
                10000,0,
                10000,1,
                10000,100,
                10000,1024,
                10000,4096,
                10000,10000
                };


void main(int argc,char *argv[]) {

    char *MyPort = "COM1";
    HANDLE hFile;
    int j;


    if (argc > 1) {

        MyPort = argv[1];

    }

    if ((hFile = CreateFile(
                     MyPort,
                     GENERIC_READ | GENERIC_WRITE,
                     0,
                     NULL,
                     CREATE_ALWAYS,
                     FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
                     NULL
                     )) != ((HANDLE)-1)) {

        printf("We successfully opened the %s port.\n",MyPort);

        for (
            j = 0;
            j < sizeof(SV)/(sizeof(DWORD)*2);
            j++
            ) {
            printf("SetupComm(hFile,%d,%d)\n",SV[j][1],SV[j][2]);
            if (!SetupComm(hFile,SV[j][1],SV[j][2])) {

                printf("Couldn't do CommSetup(hFile,%d,%d) %d\n",SV[j][1],SV[j][2],GetLastError());

            }

        }


    } else {

        printf("Couldn't open the comm port\n");

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\serial\test\tseriatw.c ===
// This is special in that it trys to cause an interval timeout.

#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include "windows.h"

#define BIGWRITE 256000
unsigned char writebuff[BIGWRITE];

void main(int argc,char *argv[]) {

    HANDLE hFile;
    DCB MyDcb;
    char *MyPort = "COM1";
    DWORD NumberActuallyWritten;
    DWORD NumberToWrite = 0;
    DWORD UseBaud = 19200;
    COMMTIMEOUTS To;

    if (argc > 1) {

        sscanf(argv[1],"%d",&NumberToWrite);

        if (argc > 2) {

            sscanf(argv[2],"%d",&UseBaud);

            if (argc > 3) {

                MyPort = argv[3];

            }

        }

    }

    if (((NumberToWrite / 2)*2) != NumberToWrite) {

        printf("Number to write must be even!\n");
        exit(1);

    }

    printf("Will try to write %d characters.\n",NumberToWrite);
    printf("Will try to write at %d baud.\n",UseBaud);
    printf("Using port: %s\n",MyPort);

    if ((hFile = CreateFile(
                     MyPort,
                     GENERIC_READ | GENERIC_WRITE,
                     0,
                     NULL,
                     CREATE_ALWAYS,
                     FILE_ATTRIBUTE_NORMAL,
                     NULL
                     )) != ((HANDLE)-1)) {

        printf("We successfully opened the %s port.\n",MyPort);

        //
        // We've successfully opened the file.  Set the state of
        // the comm device.  First we get the old values and
        // adjust to our own.
        //

        if (!GetCommState(
                 hFile,
                 &MyDcb
                 )) {

            printf("Couldn't get the comm state: %d\n",GetLastError());
            exit(1);

        }

        if (!GetCommTimeouts(
                 hFile,
                 &To
                 )) {

            printf("Couldn't get the timeouts: %d\n",GetLastError());
            exit(1);

        }

        To.ReadIntervalTimeout = 0;
        To.ReadTotalTimeoutMultiplier = 0;
        To.ReadTotalTimeoutConstant = 0;
        To.WriteTotalTimeoutMultiplier = 0;
        To.WriteTotalTimeoutConstant = 0;

        if (!SetCommTimeouts(
                 hFile,
                 &To
                 )) {

            printf("Couldn't set the timeouts: %d\n",GetLastError());
            exit(1);

        }

        MyDcb.BaudRate = UseBaud;
        MyDcb.ByteSize = 8;
        MyDcb.Parity = NOPARITY;
        MyDcb.StopBits = ONESTOPBIT;

        if (SetCommState(
                hFile,
                &MyDcb
                )) {

            unsigned char j;
            DWORD TotalCount;

            printf("We successfully set the state of the %s port.\n",MyPort);

            for (
                TotalCount = 0;
                TotalCount < NumberToWrite;
                ) {

                for (
                    j = 0;
                    j <= 9;
                    j++
                    ) {

                    writebuff[TotalCount] = j;
                    TotalCount++;
                    if (TotalCount >= NumberToWrite) {

                        break;

                    }

                }

            }

            if (!WriteFile(
                     hFile,
                     writebuff,
                     NumberToWrite/2,
                     &NumberActuallyWritten,
                     NULL
                     )) {

                DWORD LastError;
                LastError = GetLastError();
                printf("Couldn't write the %s device.\n",MyPort);
                printf("Status of failed write is: %x\n",LastError);

            } else if (NumberActuallyWritten != (NumberToWrite/2)) {

                printf("Didn't write out the correct number: %d\n",NumberActuallyWritten);

            }

            //
            // 15 seconds till the next write.
            //

            Sleep(15000);

            if (!WriteFile(
                     hFile,
                     &writebuff[(NumberToWrite/2)],
                     NumberToWrite/2,
                     &NumberActuallyWritten,
                     NULL
                     )) {

                DWORD LastError;
                LastError = GetLastError();
                printf("Couldn't write the %s device.\n",MyPort);
                printf("Status of failed write is: %x\n",LastError);

            } else if (NumberActuallyWritten != (NumberToWrite/2)) {

                printf("Didn't write out the correct number: %d\n",NumberActuallyWritten);

            }


        } else {

            DWORD LastError;
            LastError = GetLastError();
            printf("Couldn't set the %s device.\n",MyPort);
            printf("Status of failed set is: %x\n",LastError);

        }

        CloseHandle(hFile);

    } else {

        DWORD LastError;
        LastError = GetLastError();
        printf("Couldn't open the %s device.\n",MyPort);
        printf("Status of failed open is: %x\n",LastError);

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\serial\test\tstbaud.c ===
#include "windows.h"
#include <stdio.h>

BOOL
SerialGetDivisorFromBaud(
    IN ULONG ClockRate,
    IN LONG DesiredBaud,
    OUT PSHORT AppropriateDivisor
    )

/*++

Routine Description:

    This routine will determine a divisor based on an unvalidated
    baud rate.

Arguments:

    ClockRate - The clock input to the controller.

    DesiredBaud - The baud rate for whose divisor we seek.

    AppropriateDivisor - Given that the DesiredBaud is valid, the
    LONG pointed to by this parameter will be set to the appropriate
    value.  NOTE: The long is undefined if the DesiredBaud is not
    supported.

Return Value:

    This function will return STATUS_SUCCESS if the baud is supported.
    If the value is not supported it will return a status such that
    NT_ERROR(Status) == FALSE.

--*/

{

    signed short calculatedDivisor;
    unsigned long denominator;
    unsigned long remainder;

    //
    // Allow up to a 1 percent error
    //

    unsigned long maxRemain18 = 18432;
    unsigned long maxRemain30 = 30720;
    unsigned long maxRemain42 = 42336;
    unsigned long maxRemain80 = 80000;
    unsigned long maxRemain;

    //
    // Reject any non-positive bauds.
    //

    denominator = DesiredBaud*(unsigned long)16;

    if (DesiredBaud <= 0) {

        *AppropriateDivisor = -1;

    } else if ((signed long)denominator < DesiredBaud) {

        //
        // If the desired baud was so huge that it cause the denominator
        // calculation to wrap, don't support it.
        //

        *AppropriateDivisor = -1;
        printf("baud to big\n");

    } else {

        if (ClockRate == 1843200) {
            maxRemain = maxRemain18;
        } else if (ClockRate == 3072000) {
            maxRemain = maxRemain30;
        } else if (ClockRate == 4233600) {
            maxRemain = maxRemain42;
        } else {
            maxRemain = maxRemain80;
        }

        calculatedDivisor = (signed short)(ClockRate / denominator);
        remainder = ClockRate % denominator;

        //
        // Round up.
        //

        if (((remainder*2) > ClockRate) && (DesiredBaud != 110)) {

            calculatedDivisor++;
        }


        //
        // Only let the remainder calculations effect us if
        // the baud rate is > 9600.
        //

        if (DesiredBaud >= 9600) {

            //
            // If the remainder is less than the maximum remainder (wrt
            // the ClockRate) or the remainder + the maximum remainder is
            // greater than or equal to the ClockRate then assume that the
            // baud is ok.
            //

            if ((remainder >= maxRemain) && ((remainder+maxRemain) < ClockRate)) {
                printf("remainder: %d\n",remainder);
                printf("error is: %f\n",((double)remainder)/((double)ClockRate));
                calculatedDivisor = -1;
            }

        }

        //
        // Don't support a baud that causes the denominator to
        // be larger than the clock.
        //

        if (denominator > ClockRate) {

            calculatedDivisor = -1;

        }

        //
        // Ok, Now do some special casing so that things can actually continue
        // working on all platforms.
        //

        if (ClockRate == 1843200) {

            if (DesiredBaud == 56000) {
                calculatedDivisor = 2;
            }

        } else if (ClockRate == 3072000) {

            if (DesiredBaud == 14400) {
                calculatedDivisor = 13;
            }

        } else if (ClockRate == 4233600) {

            if (DesiredBaud == 9600) {
                calculatedDivisor = 28;
            } else if (DesiredBaud == 14400) {
                calculatedDivisor = 18;
            } else if (DesiredBaud == 19200) {
                calculatedDivisor = 14;
            } else if (DesiredBaud == 38400) {
                calculatedDivisor = 7;
            } else if (DesiredBaud == 56000) {
                calculatedDivisor = 5;
            }

        } else if (ClockRate == 8000000) {

            if (DesiredBaud == 14400) {
                calculatedDivisor = 35;
            } else if (DesiredBaud == 56000) {
                calculatedDivisor = 9;
            }

        }

        *AppropriateDivisor = calculatedDivisor;

    }


    if (*AppropriateDivisor == -1) {

        return FALSE;

    }

    return TRUE;

}

void main(int argc,char *argv[]){


    unsigned long baudrate;
    signed short divisor = -1;

    if (argc > 1) {

        sscanf(argv[1],"%d",&baudrate);

    }

    if (!SerialGetDivisorFromBaud(
             1843200,
             baudrate,
             &divisor
             )) {

        printf("Couldn't get a divisor\n");

    } else {

        printf("Divisor is: %d\n",divisor);

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\serial\test\ttimeout.c ===
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include "windows.h"

void main(int argc,char *argv[]) {

    HANDLE hFile;
    char *MyPort = "COM1";
    DWORD ValueFromEscape = 0;
    DWORD Func;
    int scanfval;

    if (argc > 1) {

        MyPort = argv[1];

    }

    if ((hFile = CreateFile(
                     MyPort,
                     GENERIC_READ | GENERIC_WRITE,
                     0,
                     NULL,
                     CREATE_ALWAYS,
                     FILE_ATTRIBUTE_NORMAL,
                     NULL
                     )) != ((HANDLE)-1)) {

        printf("We successfully opened the %s port.\n",MyPort);

        do {

            printf("^z=END 1=GETTIMEOUTS  2=SETTIMEOUTS:");

            if ((scanfval = scanf("%d",&Func)) == EOF) {

                printf("All done\n");
                break;

            } else if (scanfval != 1) {

                printf("Invalid input\n");

            } else {

                if ((Func >= 1) && (Func <= 2)) {

                    switch (Func) {
                        case 1: {

                            COMMTIMEOUTS OldTimeouts;
                            if (!GetCommTimeouts(
                                     hFile,
                                     &OldTimeouts
                                     )) {

                                printf("Error getting timeouts: %d\n",GetLastError());

                            } else {

                                printf("ReadIntervalTimeout: %d\n",OldTimeouts.ReadIntervalTimeout);
                                printf("ReadTotalTimeoutMultiplier: %d\n",OldTimeouts.ReadTotalTimeoutMultiplier);
                                printf("ReadTotalTimeoutConstant: %d\n",OldTimeouts.ReadTotalTimeoutConstant);
                                printf("WriteTotalTimeoutMultipler: %d\n",OldTimeouts.WriteTotalTimeoutMultiplier);
                                printf("WriteTotalTimeoutConstant: %d\n",OldTimeouts.WriteTotalTimeoutConstant);


                            }

                            break;

                        }
                        case 2: {

                            COMMTIMEOUTS NewTimeout;

                            printf("ReadIntervalTimeout[CR Implies use old value]: ");

                            if ((scanfval = scanf("%d",&NewTimeout.ReadIntervalTimeout)) == EOF) {

                                printf("All done\n");
                                exit(1);

                            } else if (!scanfval) {

                                NewTimeout.ReadIntervalTimeout = ~0;

                            } else if (scanfval != 1) {

                                printf("Bad input\n");
                                break;

                            }

                            printf("ReadTotalTimeoutMultiplier[CR Implies use old value]: ");

                            if ((scanfval = scanf("%d",&NewTimeout.ReadTotalTimeoutMultiplier)) == EOF) {

                                printf("All done\n");
                                exit(1);

                            } else if (!scanfval) {

                                NewTimeout.ReadTotalTimeoutMultiplier = ~0;

                            } else if (scanfval != 1) {

                                printf("Bad input\n");
                                break;

                            }

                            printf("ReadTotalTimeoutConstant[CR Implies use old value]: ");

                            if ((scanfval = scanf("%d",&NewTimeout.ReadTotalTimeoutConstant)) == EOF) {

                                printf("All done\n");
                                exit(1);

                            } else if (!scanfval) {

                                NewTimeout.ReadTotalTimeoutConstant = ~0;

                            } else if (scanfval != 1) {

                                printf("Bad input\n");
                                break;

                            }

                            printf("WriteTotalTimeoutMultipler[CR Implies use old value]: ");

                            if ((scanfval = scanf("%d",&NewTimeout.WriteTotalTimeoutMultiplier)) == EOF) {

                                printf("All done\n");
                                exit(1);

                            } else if (!scanfval) {

                                NewTimeout.WriteTotalTimeoutMultiplier = ~0;

                            } else if (scanfval != 1) {

                                printf("Bad input\n");
                                break;

                            }

                            printf("WriteTotalTimeoutConstant[CR Implies use old value]: ");

                            if ((scanfval = scanf("%d",&NewTimeout.WriteTotalTimeoutConstant)) == EOF) {

                                printf("All done\n");
                                exit(1);

                            } else if (!scanfval) {

                                NewTimeout.WriteTotalTimeoutConstant = ~0;

                            } else if (scanfval != 1) {

                                printf("Bad input\n");
                                break;

                            }

                            printf("ReadIntervalTimeout: %d\n",NewTimeout.ReadIntervalTimeout);
                            printf("ReadTotalTimeoutMultiplier: %d\n",NewTimeout.ReadTotalTimeoutMultiplier);
                            printf("ReadTotalTimeoutConstant: %d\n",NewTimeout.ReadTotalTimeoutConstant);
                            printf("WriteTotalTimeoutMultipler: %d\n",NewTimeout.WriteTotalTimeoutMultiplier);
                            printf("WriteTotalTimeoutConstant: %d\n",NewTimeout.WriteTotalTimeoutConstant);
                            if (!SetCommTimeouts(
                                     hFile,
                                     &NewTimeout
                                     )) {

                                printf("Error setting timeouts: %d\n",GetLastError());

                            }

                            break;


                        }

                    }

                } else {

                    printf("Invalid Input\n");

                }

            }


        } while (TRUE);


        CloseHandle(hFile);

    } else {

        DWORD LastError;
        LastError = GetLastError();
        printf("Couldn't open the %s device.\n",MyPort);
        printf("Status of failed open is: %x\n",LastError);

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\serial\test\tserialb.c ===
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include "windows.h"

#define BIGREAD 256000
unsigned char readbuff[BIGREAD];
unsigned char writebuff[BIGREAD];

unsigned char DataMask[9] = {0,0,0,0,0x0f,0x1f,0x3f,0x7f,0xff};

void main(int argc,char *argv[]) {

    HANDLE hFile;
    DCB MyDcb;
    char *MyPort = "COM1";
    DWORD NumberActuallyRead;
    DWORD NumberToRead = 0;
    DWORD NumberActuallyWritten;
    DWORD NumberToWrite = 0;
    DWORD UseBaud = 19200;
    DWORD NumberOfDataBits = 8;
    COMMTIMEOUTS To;
    OVERLAPPED ReadOl = {0};
    OVERLAPPED WriteOl = {0};
    unsigned char j;
    DWORD TotalCount;
    BOOL ReadDone;
    BOOL WriteDone;

    if (argc > 1) {

        sscanf(argv[1],"%d",&NumberToRead);
        NumberToWrite = NumberToRead;

        if (argc > 2) {

            sscanf(argv[2],"%d",&UseBaud);

            if (argc > 3) {

                MyPort = argv[3];

                if (argc > 4) {

                    sscanf(argv[4],"%d",&NumberOfDataBits);

                }

            }

        }

    }

    printf("Will try to read/write %d characters.\n",NumberToRead);
    printf("Will try to read/write at %d baud.\n",UseBaud);
    printf("Using port %s\n",MyPort);

    for (
        TotalCount = 0;
        TotalCount < NumberToWrite;
        ) {

        for (
            j = (0xff - 10);
            j != 0; // When it wraps around
            j++
            ) {

            writebuff[TotalCount] = j;
            TotalCount++;
            if (TotalCount >= NumberToWrite) {

                break;

            }

        }

    }

    if (!(ReadOl.hEvent = CreateEvent(
                              NULL,
                              FALSE,
                              FALSE,
                              NULL
                              ))) {

        printf("Could not create the read event.\n");
        goto cleanup;

    } else {

        ReadOl.Internal = 0;
        ReadOl.InternalHigh = 0;
        ReadOl.Offset = 0;
        ReadOl.OffsetHigh = 0;

    }

    if (!(WriteOl.hEvent = CreateEvent(
                               NULL,
                               FALSE,
                               FALSE,
                               NULL
                               ))) {

        printf("Could not create the write event.\n");
        goto cleanup;

    } else {

        WriteOl.Internal = 0;
        WriteOl.InternalHigh = 0;
        WriteOl.Offset = 0;
        WriteOl.OffsetHigh = 0;

    }

    if ((hFile = CreateFile(
                     MyPort,
                     GENERIC_READ | GENERIC_WRITE,
                     0,
                     NULL,
                     CREATE_ALWAYS,
                     FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
                     NULL
                     )) != ((HANDLE)-1)) {

        printf("We successfully opened the %s port.\n",MyPort);

        To.ReadIntervalTimeout = 0;
        To.ReadTotalTimeoutMultiplier = ((1000+(((UseBaud+9)/10)-1))/((UseBaud+9)/10));
        if (!To.ReadTotalTimeoutMultiplier) {
            To.ReadTotalTimeoutMultiplier = 1;
        }
        To.WriteTotalTimeoutMultiplier = ((1000+(((UseBaud+9)/10)-1))/((UseBaud+9)/10));
        if (!To.WriteTotalTimeoutMultiplier) {
            To.WriteTotalTimeoutMultiplier = 1;
        }
        printf("Multiplier is: %d\n",To.ReadTotalTimeoutMultiplier);
        To.ReadTotalTimeoutConstant = 5000;
        To.WriteTotalTimeoutConstant = 5000;

        if (SetCommTimeouts(
                hFile,
                &To
                )) {

            //
            // We've successfully opened the file.  Set the state of
            // the comm device.  First we get the old values and
            // adjust to our own.
            //

            if (!GetCommState(
                     hFile,
                     &MyDcb
                     )) {

                printf("Couldn't get the comm state: %d\n",GetLastError());
                exit(1);

            }

            MyDcb.BaudRate = UseBaud;
            MyDcb.ByteSize = (BYTE)NumberOfDataBits;
            MyDcb.Parity = NOPARITY;
            MyDcb.StopBits = ONESTOPBIT;

            if (SetCommState(
                    hFile,
                    &MyDcb
                    )) {

                printf("We successfully set the state of the %s port.\n",MyPort);

                //
                // Sleep for 5 seconds so both sides can "synchronize".
                //

                Sleep(5000);

                ReadDone = ReadFile(
                               hFile,
                               readbuff,
                               NumberToRead,
                               &NumberActuallyRead,
                               &ReadOl
                               );

                if (!ReadDone) {

                    DWORD LastError;
                    LastError = GetLastError();

                    if (LastError != ERROR_IO_PENDING) {

                        printf("Couldn't read the %s device.\n",MyPort);
                        printf("Status of failed read is: %x\n",LastError);
                        goto cleanup;

                    }

                }


                WriteDone = WriteFile(
                                hFile,
                                writebuff,
                                NumberToWrite,
                                &NumberActuallyWritten,
                                &WriteOl
                                );

                if (!WriteDone) {

                    DWORD LastError;
                    LastError = GetLastError();

                    if (LastError != ERROR_IO_PENDING) {

                        printf("Couldn't write the %s device.\n",MyPort);
                        printf("Status of failed write is: %x\n",LastError);
                        goto cleanup;

                    }

                }

                //
                // We'll wait for the read to complete.
                //

                if (!GetOverlappedResult(
                         hFile,
                         &ReadOl,
                         &NumberActuallyRead,
                         TRUE
                         )) {

                    DWORD LastError;
                    LastError = GetLastError();

                    printf("Couldn't read the %s device.\n",MyPort);
                    printf("Status of failed read is: %x\n",LastError);

                } else {

                    printf("Well we thought the read went ok.\n");
                    printf("Number actually read %d.\n",NumberActuallyRead);
                    printf("Now we check the data\n");

                    for (
                        TotalCount = 0;
                        TotalCount < NumberActuallyRead;
                        ) {

                        for (
                            j = (0xff - 10);
                            j != 0;  // When it wraps around.
                            j++
                            ) {

                            if (readbuff[TotalCount] != (j & DataMask[NumberOfDataBits])) {

                                printf("Bad data starting at: %d\n",TotalCount);
                                printf("readbuff[TotalCount]: %x\n",readbuff[TotalCount]);
                                printf("(j & DataMask[NumberOfDataBits]): %x\n",(j & DataMask[NumberOfDataBits]));
                                goto donewithcheck;

                            }

                            TotalCount++;
                            if (TotalCount >= NumberActuallyRead) {

                                break;

                            }

                        }

                    }

                }

donewithcheck: ;

                //
                // We'll wait for the write to complete.
                //

                if (!GetOverlappedResult(
                         hFile,
                         &WriteOl,
                         &NumberActuallyWritten,
                         TRUE
                         )) {

                    DWORD LastError;
                    LastError = GetLastError();

                    printf("Couldn't write the %s device.\n",MyPort);
                    printf("Status of failed write is: %x\n",LastError);
                    goto cleanup;

                } else {

                    printf("Well we thought the write went ok.\n");
                    printf("Number actually written %d.\n",NumberActuallyWritten);

                }

            } else {

                DWORD LastError;
                LastError = GetLastError();
                printf("Couldn't set the %s device.\n",MyPort);
                printf("Status of failed set is: %x\n",LastError);

            }

        } else {

            DWORD LastError;
            LastError = GetLastError();
            printf("Couldn't set the %s device timeouts.\n",MyPort);
            printf("Status of failed timeouts is: %x\n",LastError);

        }

        CloseHandle(hFile);

    } else {

        DWORD LastError;
        LastError = GetLastError();
        printf("Couldn't open the %s device.\n",MyPort);
        printf("Status of failed open is: %x\n",LastError);

    }

cleanup:;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\serial\test\tserialm.c ===
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include "windows.h"


HANDLE PrintfAvailable;
HANDLE ReadyToWork;
HANDLE ReadyToReport;
HANDLE DoneReporting;
HANDLE StartOperationsEvent;
HANDLE BeginReporting;

typedef struct _THREAD_WORK {
    char *NameOfPort;
    HANDLE FileToUse;
    DWORD NumberOfChars;
    BOOL DoWrite;
    OVERLAPPED Ol;
    UCHAR BufferForOp[1];
    } THREAD_WORK,*PTHREAD_WORK;

char NameOfWrite[] = "Write";
char NameOfRead[] = "Read";
DWORD
WorkThread(
    LPVOID ThreadContext
    )
{

    PTHREAD_WORK ToDo = ThreadContext;
    DWORD FinalCountOfOp;
    DWORD LastError;
    clock_t Start;
    clock_t Finish;
    BOOL OpDone;
    char *OperationName;

    OperationName = (ToDo->DoWrite)?(&NameOfWrite[0]):(&NameOfRead[0]);

    if (!ReleaseSemaphore(ReadyToWork,1,NULL)) {

        WaitForSingleObject(PrintfAvailable,-1);
        printf(
            "Couldn't release the ready to start semaphore for port %s\n",
            ToDo->NameOfPort
            );
        ReleaseSemaphore(PrintfAvailable,1,NULL);
        ReleaseSemaphore(ReadyToReport,1,NULL);
        ReleaseSemaphore(DoneReporting,1,NULL);
        return 1;

    }

    WaitForSingleObject(StartOperationsEvent,-1);

    if (ToDo->DoWrite) {

        Start = clock();
        OpDone = WriteFile(
                     ToDo->FileToUse,
                     &ToDo->BufferForOp[0],
                     ToDo->NumberOfChars,
                     &FinalCountOfOp,
                     &ToDo->Ol
                     );

    } else {

        Start = clock();
        OpDone = ReadFile(
                     ToDo->FileToUse,
                     &ToDo->BufferForOp[0],
                     ToDo->NumberOfChars,
                     &FinalCountOfOp,
                     &ToDo->Ol
                     );

    }

    if (!OpDone) {

        LastError = GetLastError();
        if (LastError != ERROR_IO_PENDING) {


            WaitForSingleObject(PrintfAvailable,-1);
            printf(
                "Could not start the %s for %s - error: %d\n",
                OperationName,
                ToDo->NameOfPort,
                LastError
                );
            ReleaseSemaphore(PrintfAvailable,1,NULL);
            ReleaseSemaphore(ReadyToReport,1,NULL);
            ReleaseSemaphore(DoneReporting,1,NULL);
            return 1;

        }

        if (!GetOverlappedResult(
                 ToDo->FileToUse,
                 &ToDo->Ol,
                 &FinalCountOfOp,
                 TRUE
                 )) {


            LastError = GetLastError();
            WaitForSingleObject(PrintfAvailable,-1);
            printf(
                "Wait on %s for port %s failed - error: %d\n",
                OperationName,
                ToDo->NameOfPort,
                LastError
                );
            ReleaseSemaphore(PrintfAvailable,1,NULL);
            ReleaseSemaphore(ReadyToReport,1,NULL);
            ReleaseSemaphore(DoneReporting,1,NULL);
            return 1;

        }

    }

    Finish = clock();

    if (!ReleaseSemaphore(ReadyToReport,1,NULL)) {

        WaitForSingleObject(PrintfAvailable,-1);
        printf(
            "Couldn't release the ready to report semaphore for port %s\n",
            ToDo->NameOfPort
            );
        ReleaseSemaphore(PrintfAvailable,1,NULL);
        return 1;

    }

    WaitForSingleObject(BeginReporting,-1);

    WaitForSingleObject(PrintfAvailable,-1);
    printf("%s for %s\n",OperationName,ToDo->NameOfPort);
    printf("-------Time to write %f\n",(((double)(Finish-Start))/CLOCKS_PER_SEC));
    printf("-------Chars per second %f\n",((double)FinalCountOfOp)/(((double)(Finish-Start))/CLOCKS_PER_SEC));
    printf("-------Number actually done by %s: %d.\n",OperationName,FinalCountOfOp);

    //
    // if this is the write code then check the data.
    //

    if (ToDo->DoWrite) {

        DWORD TotalCount;
        DWORD j;

        for (
            TotalCount = 0;
            TotalCount < FinalCountOfOp;
            ) {

            for (
                j = (0xff - 10);
                j != 0;  // When it wraps around.
                j++
                ) {

                if (ToDo->BufferForOp[TotalCount] != ((UCHAR)j)) {

                    WaitForSingleObject(PrintfAvailable,-1);
                    printf("Bad data starting at: %d\n",TotalCount);
                    printf("BufferForOp[TotalCount]: %x\n",ToDo->BufferForOp[TotalCount]);
                    printf("j: %x\n",j);
                    ReleaseSemaphore(PrintfAvailable,1,NULL);
                    goto DoneWithCheck;

                }

                TotalCount++;
                if (TotalCount >= FinalCountOfOp) {

                    goto DoneWithCheck;

                }

            }

        }
DoneWithCheck:;

    }
    ReleaseSemaphore(PrintfAvailable,1,NULL);

    if (!ReleaseSemaphore(DoneReporting,1,NULL)) {

        WaitForSingleObject(PrintfAvailable,-1);
        printf(
            "Couldn't release the done reporting semaphore for port %s\n",
            ToDo->NameOfPort
            );
        ReleaseSemaphore(PrintfAvailable,1,NULL);

    }
    return 1;

}


void main(int argc,char *argv[]) {

    HANDLE hFile;
    DCB MyDcb;
    DWORD NumberOfChars;
    DWORD UseBaud;
    DWORD NumberOfDataBits = 8;
    COMMTIMEOUTS To;
    DWORD i;

    DWORD NumberOfPorts;

    if (argc < 4) {

        printf("Ivalid number of args - tserialm #chars Baud COMx [COMX...]\n");

    }

    NumberOfPorts = argc - 3;

    sscanf(argv[1],"%d",&NumberOfChars);
    sscanf(argv[2],"%d",&UseBaud);

    //
    // Create a global event that each thread will wait on
    // to start it's work.
    //

    StartOperationsEvent = CreateEvent(
                               NULL,
                               TRUE,
                               FALSE,
                               NULL
                               );

    if (!StartOperationsEvent) {

        printf("StartOperationsEvent could not be created\n");
        exit(1);

    }

    //
    // Create a global event that each thread will wait on
    // to start reporting its results.
    //

    BeginReporting = CreateEvent(
                               NULL,
                               TRUE,
                               FALSE,
                               NULL
                               );

    if (!BeginReporting) {

        printf("Begin reporting could not be created\n");
        exit(1);

    }

    //
    // Create a semaphore that is used to make sure that
    // only one thread is doing printf at a time.
    //

    PrintfAvailable = CreateSemaphore(
                      NULL,
                      1,
                      1,
                      NULL
                      );

    if (!PrintfAvailable) {

        printf("PrintfAvailable could not be created\n");
        exit(1);

    }

    //
    // Create a semaphore that is used to indicate that all threads
    // are waiting to work.
    //

    ReadyToWork = CreateSemaphore(
                     NULL,
                     0,
                     NumberOfPorts*2,
                     NULL
                     );

    if (!ReadyToWork) {

        printf("Ready to work could not be created\n");
        exit(1);

    }

    //
    // Create a semaphore that is used to indicate that all threads
    // are ready to report their results.
    //

    ReadyToReport = CreateSemaphore(
                     NULL,
                     0,
                     NumberOfPorts*2,
                     NULL
                     );

    if (!ReadyToReport) {

        printf("Ready to report could not be created\n");
        exit(1);

    }

    //
    // Create a semaphore that is used to indicate that all threads
    // are done reporting.
    //

    DoneReporting = CreateSemaphore(
                     NULL,
                     0,
                     NumberOfPorts*2,
                     NULL
                     );

    if (!DoneReporting) {

        printf("Done reporting could not be created\n");
        exit(1);

    }

    for (
        i = 1;
        i <= NumberOfPorts;
        i++
        ) {

        PTHREAD_WORK ReadContext;
        PTHREAD_WORK WriteContext;
        DWORD TotalCount;
        DWORD j;
        DWORD ThreadId;

        if ((hFile = CreateFile(
                         argv[i+2],
                         GENERIC_READ | GENERIC_WRITE,
                         0,
                         NULL,
                         CREATE_ALWAYS,
                         FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
                         NULL
                         )) == ((HANDLE)-1)) {

            WaitForSingleObject(PrintfAvailable,-1);
            printf(
                "Couldn't open %s\n",
                argv[i+2]
                );
            ReleaseSemaphore(PrintfAvailable,1,NULL);
            exit(1);

        }

        To.ReadIntervalTimeout = 0;
        To.ReadTotalTimeoutMultiplier = ((1000+(((UseBaud+9)/10)-1))/((UseBaud+9)/10));
        if (!To.ReadTotalTimeoutMultiplier) {
            To.ReadTotalTimeoutMultiplier = 1;
        }
        To.WriteTotalTimeoutMultiplier = ((1000+(((UseBaud+9)/10)-1))/((UseBaud+9)/10));
        if (!To.WriteTotalTimeoutMultiplier) {
            To.WriteTotalTimeoutMultiplier = 1;
        }
        To.ReadTotalTimeoutConstant = 5000;
        To.WriteTotalTimeoutConstant = 5000;

        if (!SetCommTimeouts(
                 hFile,
                 &To
                 )) {


            WaitForSingleObject(PrintfAvailable,-1);
            printf(
                "Couldn't set the timeouts for port %s error %d\n",
                argv[i+2],
                GetLastError()
                );
            ReleaseSemaphore(PrintfAvailable,1,NULL);
            exit(1);
        }

        if (!GetCommState(
                 hFile,
                 &MyDcb
                 )) {

            WaitForSingleObject(PrintfAvailable,-1);
            printf(
                "Couldn't get the comm state for port %s error %d\n",
                argv[i+2],
                GetLastError()
                );
            ReleaseSemaphore(PrintfAvailable,1,NULL);
            exit(1);

        }

        MyDcb.BaudRate = UseBaud;
        MyDcb.ByteSize = 8;
        MyDcb.Parity = NOPARITY;
        MyDcb.StopBits = ONESTOPBIT;
        MyDcb.fOutxDsrFlow = TRUE;
        MyDcb.fDtrControl = DTR_CONTROL_HANDSHAKE;

        if (!SetCommState(
                 hFile,
                 &MyDcb
                 )) {

            WaitForSingleObject(PrintfAvailable,-1);
            printf(
                "Couldn't set the comm state for port %s error %d\n",
                argv[i+2],
                GetLastError()
                );
            ReleaseSemaphore(PrintfAvailable,1,NULL);
            exit(1);

        }

        //
        // Alloc two thread contexts for the read and the
        // write thread.
        //

        ReadContext = malloc(sizeof(THREAD_WORK)+(NumberOfChars-1));

        if (!ReadContext) {

            WaitForSingleObject(PrintfAvailable,-1);
            printf(
                "Couldn't create the read thread context for %s\n",
                argv[i+2]
                );
            ReleaseSemaphore(PrintfAvailable,1,NULL);
            exit(1);

        }

        WriteContext = malloc(sizeof(THREAD_WORK)+(NumberOfChars-1));

        if (!WriteContext) {

            WaitForSingleObject(PrintfAvailable,-1);
            printf(
                "Couldn't create the write thread context for %s\n",
                argv[i+2]
                );
            ReleaseSemaphore(PrintfAvailable,1,NULL);
            exit(1);

        }

        ReadContext->NameOfPort = argv[i+2];
        ReadContext->FileToUse = hFile;
        ReadContext->NumberOfChars = NumberOfChars;
        ReadContext->DoWrite = FALSE;
        if (!(ReadContext->Ol.hEvent = CreateEvent(
                                           NULL,
                                           FALSE,
                                           FALSE,
                                           NULL
                                           ))) {


            WaitForSingleObject(PrintfAvailable,-1);
            printf(
                "Couldn't create read overlapped event for %s\n",
                argv[i+2]
                );
            ReleaseSemaphore(PrintfAvailable,1,NULL);
            exit(1);

        } else {

            ReadContext->Ol.Internal = 0;
            ReadContext->Ol.InternalHigh = 0;
            ReadContext->Ol.Offset = 0;
            ReadContext->Ol.OffsetHigh = 0;

        }

        WriteContext->NameOfPort = argv[i+2];
        WriteContext->FileToUse = hFile;
        WriteContext->NumberOfChars = NumberOfChars;
        WriteContext->DoWrite = TRUE;
        if (!(WriteContext->Ol.hEvent = CreateEvent(
                                           NULL,
                                           FALSE,
                                           FALSE,
                                           NULL
                                           ))) {

            WaitForSingleObject(PrintfAvailable,-1);
            printf(
                "Couldn't create write overlapped event for %s\n",
                argv[i+2]
                );
            ReleaseSemaphore(PrintfAvailable,1,NULL);
            exit(1);

        } else {

            WriteContext->Ol.Internal = 0;
            WriteContext->Ol.InternalHigh = 0;
            WriteContext->Ol.Offset = 0;
            WriteContext->Ol.OffsetHigh = 0;

        }


        for (
            TotalCount = 0;
            TotalCount < NumberOfChars;
            ) {

            for (
                j = (0xff - 10);
                j != 0; // When it wraps around
                j++
                ) {

                WriteContext->BufferForOp[TotalCount] = (UCHAR)j;
                TotalCount++;
                if (TotalCount >= NumberOfChars) {

                    break;

                }

            }

        }

        if (!CreateThread(
                 NULL,
                 0,
                 WorkThread,
                 ReadContext,
                 0,
                 &ThreadId
                 )) {

            WaitForSingleObject(PrintfAvailable,-1);
            printf(
                "Couldn't create the read thread for %s\n",
                argv[i+2]
                );
            ReleaseSemaphore(PrintfAvailable,1,NULL);
            exit(1);
        }

        if (!CreateThread(
                 NULL,
                 0,
                 WorkThread,
                 WriteContext,
                 0,
                 &ThreadId
                 )) {

            WaitForSingleObject(PrintfAvailable,-1);
            printf(
                "Couldn't create the write thread for %s\n",
                argv[i+2]
                );
            ReleaseSemaphore(PrintfAvailable,1,NULL);
            exit(1);
        }

    }

    //
    // Wait for all the threads to signal that they
    // are ready to work
    //

    for (
        i = 0;
        i < NumberOfPorts*2;
        i++
        ) {

        if (WaitForSingleObject(ReadyToWork,-1)) {

            WaitForSingleObject(PrintfAvailable,-1);
            printf(
                "Got an error waiting for threads to be ready to work: %d\n",i
                );
            ReleaseSemaphore(PrintfAvailable,1,NULL);
            exit(1);

        }

    }

    //
    // Tell them to start working.
    //

    SetEvent(StartOperationsEvent);

    //
    // Wait for all the threads to report that they
    // are done with their io an that they are ready to report.
    //

    for (
        i = 0;
        i < NumberOfPorts*2;
        i++
        ) {

        if (WaitForSingleObject(ReadyToReport,-1)) {

            WaitForSingleObject(PrintfAvailable,-1);
            printf(
                "Got an error waiting for threads to be ready to report.\n"
                );
            ReleaseSemaphore(PrintfAvailable,1,NULL);
            exit(1);

        }

    }

    //
    // Tell all the threads that its ok for them to report.
    //

    SetEvent(BeginReporting);

    //
    // Wait for all the thread to complete reporting.  Then
    // we can finish.
    //

    for (
        i = 0;
        i < NumberOfPorts*2;
        i++
        ) {

        if (WaitForSingleObject(DoneReporting,-1)) {

            WaitForSingleObject(PrintfAvailable,-1);
            printf(
                "Got an error waiting for threads to be done reporting.\n"
                );
            ReleaseSemaphore(PrintfAvailable,1,NULL);
            exit(1);

        }

    }
    //
    // All gone.
    //

    exit(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\serial\test\tqictime.c ===
//
// Test the quick return timeouts
//
// Assume that we are using a loopback connector.
//
// Assume that it isn't running on a stressed machine.
//

#include "windows.h"
#include "stdio.h"

#define FAILURE printf("FAIL: %d\n",__LINE__);exit(1)

int __cdecl main(int argc, char *argv[]) {
    CHAR *myPort = "COM1";
    DCB myDcb;
    DWORD junk;
    COMMTIMEOUTS myTimeOuts;
    DWORD numberActuallyRead;
    DWORD numberActuallyWritten;
    UCHAR readBuff[1000];
    HANDLE comHandle;
    DWORD startingTicks;
    OVERLAPPED readOl;
    OVERLAPPED writeOl;
    UCHAR writeBuff[5] = {0,1,2,3,4};

    if (argc > 1) {

        myPort = argv[1];

    }

    if ((comHandle = CreateFile(
                     myPort,
                     GENERIC_READ | GENERIC_WRITE,
                     0,
                     NULL,
                     CREATE_ALWAYS,
                     FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
                     NULL
                     )) == ((HANDLE)-1)) {

        FAILURE;

    }

    if (!(readOl.hEvent = CreateEvent(
                             NULL,
                             TRUE,
                             FALSE,
                             NULL
                             ))) {

        FAILURE;

    }

    if (!(writeOl.hEvent = CreateEvent(
                             NULL,
                             TRUE,
                             FALSE,
                             NULL
                             ))) {

        FAILURE;

    }

    if (!GetCommState(
             comHandle,
             &myDcb
             )) {

        FAILURE;

    }

    myDcb.BaudRate = 19200;
    myDcb.ByteSize = 8;
    myDcb.StopBits = ONESTOPBIT;
    myDcb.Parity = NOPARITY;
    myDcb.fOutxCtsFlow = FALSE;
    myDcb.fOutxDsrFlow = FALSE;
    myDcb.fDsrSensitivity = FALSE;
    myDcb.fOutX = FALSE;
    myDcb.fInX = FALSE;
    myDcb.fRtsControl = RTS_CONTROL_ENABLE;
    myDcb.fDtrControl = DTR_CONTROL_ENABLE;
    if (!SetCommState(
            comHandle,
            &myDcb
            )) {

        FAILURE;

    }

    //
    // Test to make sure that all maxdword on read is illegal.
    //

    myTimeOuts.ReadIntervalTimeout = MAXDWORD;
    myTimeOuts.ReadTotalTimeoutMultiplier = MAXDWORD;
    myTimeOuts.ReadTotalTimeoutConstant = MAXDWORD;
    myTimeOuts.WriteTotalTimeoutMultiplier = MAXDWORD;
    myTimeOuts.WriteTotalTimeoutConstant = MAXDWORD;

    if (SetCommTimeouts(
             comHandle,
             &myTimeOuts
             )) {

        FAILURE;

    }

    //
    // Test that MAXDWORD,0,0 will return immediately with whatever
    // is there
    //

    myTimeOuts.ReadIntervalTimeout = MAXDWORD;
    myTimeOuts.ReadTotalTimeoutMultiplier = 0;
    myTimeOuts.ReadTotalTimeoutConstant = 0;
    myTimeOuts.WriteTotalTimeoutMultiplier = MAXDWORD;
    myTimeOuts.WriteTotalTimeoutConstant = MAXDWORD;

    if (!SetCommTimeouts(
             comHandle,
             &myTimeOuts
             )) {

        FAILURE;

    }

    startingTicks = GetTickCount();
    if (!ReadFile(
             comHandle,
             &readBuff[0],
             1000,
             &numberActuallyRead,
             &readOl
             )) {

        if (GetLastError() != ERROR_IO_PENDING) {

            FAILURE;

        }

        if (!GetOverlappedResult(
                 comHandle,
                 &readOl,
                 &numberActuallyRead,
                 TRUE
                 )) {

            FAILURE;

        }

    }

    //
    // We certainly should have gotten back in less than a
    // a half a second.
    //

    if ((GetTickCount() - startingTicks) > 500) {

        FAILURE;

    }

    if (numberActuallyRead) {

        FAILURE;

    }

    //
    // Write out five bytes and make sure that is what we get back
    //

    if (!WriteFile(
             comHandle,
             &writeBuff[0],
             5,
             &numberActuallyWritten,
             &writeOl
             )) {

        if (GetLastError() != ERROR_IO_PENDING) {

            FAILURE;

        }

        if (!GetOverlappedResult(
                 comHandle,
                 &writeOl,
                 &numberActuallyWritten,
                 TRUE
                 )) {

            FAILURE;

        }

        if (numberActuallyWritten != 5) {

            FAILURE;

        }

    }

    //
    // Give some time for the chars to get there.
    //

    Sleep (100);

    startingTicks = GetTickCount();
    if (!ReadFile(
             comHandle,
             &readBuff[0],
             1000,
             &numberActuallyRead,
             &readOl
             )) {

        if (GetLastError() != ERROR_IO_PENDING) {

            FAILURE;

        }

        if (!GetOverlappedResult(
                 comHandle,
                 &readOl,
                 &numberActuallyRead,
                 TRUE
                 )) {

            FAILURE;

        }

    }

    //
    // We certainly should have gotten back in less than a
    // a half a second.
    //

    if ((GetTickCount() - startingTicks) > 500) {

        FAILURE;

    }

    if (numberActuallyRead != 5) {

        FAILURE;

    }

    //
    // Test that the os2 wait for something works.
    //
    // First test that if there is something in the buffer
    // it returns right away.
    //
    // Then test that if there isn't something, then if we
    // put in the amount expected before the timeout expires
    // that it returns.
    //
    // The test that if there isn't something and nothing
    // happens before the timeout it returns after the timeout
    // with nothing.
    //
    myTimeOuts.ReadIntervalTimeout = MAXDWORD;
    myTimeOuts.ReadTotalTimeoutMultiplier = 0;
    myTimeOuts.ReadTotalTimeoutConstant = 5000;
    myTimeOuts.WriteTotalTimeoutMultiplier = MAXDWORD;
    myTimeOuts.WriteTotalTimeoutConstant = MAXDWORD;

    if (!SetCommTimeouts(
             comHandle,
             &myTimeOuts
             )) {

        FAILURE;

    }

    if (!WriteFile(
             comHandle,
             &writeBuff[0],
             5,
             &numberActuallyWritten,
             &writeOl
             )) {

        if (GetLastError() != ERROR_IO_PENDING) {

            FAILURE;

        }

        if (!GetOverlappedResult(
                 comHandle,
                 &writeOl,
                 &numberActuallyWritten,
                 TRUE
                 )) {

            FAILURE;

        }

        if (numberActuallyWritten != 5) {

            FAILURE;

        }

    }

    //
    // Give some time for the chars to get there.
    //

    Sleep (100);
    startingTicks = GetTickCount();
    if (!ReadFile(
             comHandle,
             &readBuff[0],
             1000,
             &numberActuallyRead,
             &readOl
             )) {

        if (GetLastError() != ERROR_IO_PENDING) {

            FAILURE;

        }

        //
        // Give it at most a 1/2 second to finish for
        // the irp to complete immediately.
        //

        Sleep(500);
        if (!GetOverlappedResult(
                 comHandle,
                 &readOl,
                 &numberActuallyRead,
                 FALSE
                 )) {

            FAILURE;

        }

    }

    if ((GetTickCount() - startingTicks) > 1000) {

        FAILURE;

    }

    if (numberActuallyRead != 5) {

        FAILURE;

    }

    //
    // Do the second os2 test
    //

    if (ReadFile(
             comHandle,
             &readBuff[0],
             1000,
             &numberActuallyRead,
             &readOl
             )) {

        FAILURE;

    }

    if (GetLastError() != ERROR_IO_PENDING) {

        FAILURE;

    }

    //
    // Give it a second for the the read to complete
    //
    //

    Sleep(1000);

    //
    // Call the GetOverlapped and make sure that it returns
    // ERROR_IO_INCOMPLETE.
    //

    if (GetOverlappedResult(
            comHandle,
            &readOl,
            &numberActuallyRead,
            FALSE
            )) {

            FAILURE;

    }

    if (GetLastError() != ERROR_IO_INCOMPLETE) {

        FAILURE;

    }

    //
    // Do the write file and make sure that there is enough
    // time for the chars to make it.
    //

    if (!WriteFile(
             comHandle,
             &writeBuff[0],
             5,
             &numberActuallyWritten,
             &writeOl
             )) {

        if (GetLastError() != ERROR_IO_PENDING) {

            FAILURE;

        }

        if (!GetOverlappedResult(
                 comHandle,
                 &writeOl,
                 &numberActuallyWritten,
                 TRUE
                 )) {

            FAILURE;

        }

        if (numberActuallyWritten != 5) {

            FAILURE;

        }

    }

    //
    // Give some time for the chars to get there.
    //

    Sleep(100);

    //
    // Wait for no more than 6 seconds for the IO to complete
    //

    if (WaitForSingleObject(
            readOl.hEvent,
            6000
            ) != WAIT_OBJECT_0) {

        FAILURE;

    }

    //
    // Make sure we got everything we wrote
    //

    if (!GetOverlappedResult(
            comHandle,
            &readOl,
            &numberActuallyRead,
            FALSE
            )) {

        FAILURE;

    }

    if (numberActuallyRead != 5) {

        FAILURE;

    }

    //
    // Do the third os2 wait for something test.
    //

    startingTicks = GetTickCount();
    if (ReadFile(
             comHandle,
             &readBuff[0],
             1000,
             &numberActuallyRead,
             &readOl
             )) {

        FAILURE;

    }

    if (GetLastError() != ERROR_IO_PENDING) {

        FAILURE;

    }

    //
    // Give it a second for the the read to complete
    //
    //

    Sleep(1000);

    //
    // Call the GetOverlapped and make sure that it returns
    // ERROR_IO_INCOMPLETE.
    //

    if (GetOverlappedResult(
            comHandle,
            &readOl,
            &numberActuallyRead,
            FALSE
            )) {

            FAILURE;

    }

    if (GetLastError() != ERROR_IO_INCOMPLETE) {

        FAILURE;

    }

    //
    // Wait for no more than 10 seconds for the IO to complete
    //

    if (WaitForSingleObject(
            readOl.hEvent,
            10000
            ) != WAIT_OBJECT_0) {

        FAILURE;

    }

    //
    // It shouldn't be more than 6 seconds for the Io to be done.
    //

    if ((GetTickCount() - startingTicks) > 6000) {

        FAILURE;

    }

    //
    // Make sure we got everything we wrote, which in this case is zero.
    //

    if (!GetOverlappedResult(
            comHandle,
            &readOl,
            &numberActuallyRead,
            FALSE
            )) {

        FAILURE;

    }

    if (numberActuallyRead) {

        FAILURE;

    }

    //
    // Test the graphics mode quick return.
    //
    // First test that if there is something in the buffer
    // it returns right away.
    //
    // Then test that if there isn't something, then if we
    // put in 2 characters it returns right away with one
    // and then the other read will return right away with
    // 1.
    //
    // Then test that if there isn't something and nothing
    // happens before the timeout it returns after the timeout
    // with nothing.
    //
    myTimeOuts.ReadIntervalTimeout = MAXDWORD;
    myTimeOuts.ReadTotalTimeoutMultiplier = MAXDWORD;
    myTimeOuts.ReadTotalTimeoutConstant = 5000;
    myTimeOuts.WriteTotalTimeoutMultiplier = MAXDWORD;
    myTimeOuts.WriteTotalTimeoutConstant = MAXDWORD;

    if (!SetCommTimeouts(
             comHandle,
             &myTimeOuts
             )) {

        FAILURE;

    }

    if (!WriteFile(
             comHandle,
             &writeBuff[0],
             5,
             &numberActuallyWritten,
             &writeOl
             )) {

        if (GetLastError() != ERROR_IO_PENDING) {

            FAILURE;

        }

        if (!GetOverlappedResult(
                 comHandle,
                 &writeOl,
                 &numberActuallyWritten,
                 TRUE
                 )) {

            FAILURE;

        }

        if (numberActuallyWritten != 5) {

            FAILURE;

        }

    }

    //
    // Give some time for the chars to get there.
    //

    Sleep (100);
    startingTicks = GetTickCount();
    if (!ReadFile(
             comHandle,
             &readBuff[0],
             1000,
             &numberActuallyRead,
             &readOl
             )) {

        if (GetLastError() != ERROR_IO_PENDING) {

            FAILURE;

        }

        //
        // Give it at most a 1/2 second to finish for
        // the irp to complete immediately.
        //

        Sleep(500);
        if (!GetOverlappedResult(
                 comHandle,
                 &readOl,
                 &numberActuallyRead,
                 FALSE
                 )) {

            FAILURE;

        }

    }

    if ((GetTickCount() - startingTicks) > 1000) {

        FAILURE;

    }

    if (numberActuallyRead != 5) {

        FAILURE;

    }

    //
    // Do the second graphics wait test.
    //
    if (ReadFile(
             comHandle,
             &readBuff[0],
             1000,
             &numberActuallyRead,
             &readOl
             )) {

        FAILURE;

    }

    if (GetLastError() != ERROR_IO_PENDING) {

        FAILURE;

    }

    //
    // Give it a second for the the read to complete
    //
    //

    Sleep(1000);

    //
    // Call the GetOverlapped and make sure that it returns
    // ERROR_IO_INCOMPLETE.
    //

    if (GetOverlappedResult(
            comHandle,
            &readOl,
            &numberActuallyRead,
            FALSE
            )) {

            FAILURE;

    }

    if (GetLastError() != ERROR_IO_INCOMPLETE) {

        FAILURE;

    }

    //
    // Do the write file and make sure that there is enough
    // time for the chars to make it.
    //

    if (!WriteFile(
             comHandle,
             &writeBuff[0],
             5,
             &numberActuallyWritten,
             &writeOl
             )) {

        if (GetLastError() != ERROR_IO_PENDING) {

            FAILURE;

        }

        if (!GetOverlappedResult(
                 comHandle,
                 &writeOl,
                 &numberActuallyWritten,
                 TRUE
                 )) {

            FAILURE;

        }

        if (numberActuallyWritten != 5) {

            FAILURE;

        }

    }

    //
    // Give some time for the chars to get there.
    //

    Sleep(100);

    //
    // Wait for no more than 1 second for the IO to complete
    //

    if (WaitForSingleObject(
            readOl.hEvent,
            1000
            ) != WAIT_OBJECT_0) {

        FAILURE;

    }

    //
    // Make sure we got everything we wrote
    //

    if (!GetOverlappedResult(
            comHandle,
            &readOl,
            &numberActuallyRead,
            FALSE
            )) {

        FAILURE;

    }

    if (numberActuallyRead != 1) {

        FAILURE;

    }
    startingTicks = GetTickCount();
    if (!ReadFile(
             comHandle,
             &readBuff[0],
             1000,
             &numberActuallyRead,
             &readOl
             )) {

        if (GetLastError() != ERROR_IO_PENDING) {

            FAILURE;

        }

        //
        // Give it at most a 1/2 second to finish for
        // the irp to complete immediately.
        //

        Sleep(500);
        if (!GetOverlappedResult(
                 comHandle,
                 &readOl,
                 &numberActuallyRead,
                 FALSE
                 )) {

            FAILURE;

        }

    }

    if ((GetTickCount() - startingTicks) > 1000) {

        FAILURE;

    }

    if (numberActuallyRead != 4) {

        FAILURE;

    }

    //
    // Do the third graphics wait test.
    //

    startingTicks = GetTickCount();
    if (ReadFile(
             comHandle,
             &readBuff[0],
             1000,
             &numberActuallyRead,
             &readOl
             )) {

        FAILURE;

    }

    if (GetLastError() != ERROR_IO_PENDING) {

        FAILURE;

    }

    //
    // Give it a second for the the read to complete
    //
    //

    Sleep(1000);

    //
    // Call the GetOverlapped and make sure that it returns
    // ERROR_IO_INCOMPLETE.
    //

    if (GetOverlappedResult(
            comHandle,
            &readOl,
            &numberActuallyRead,
            FALSE
            )) {

            FAILURE;

    }

    if (GetLastError() != ERROR_IO_INCOMPLETE) {

        FAILURE;

    }

    //
    // Wait for no more than 10 seconds for the IO to complete
    //

    if (WaitForSingleObject(
            readOl.hEvent,
            10000
            ) != WAIT_OBJECT_0) {

        FAILURE;

    }

    //
    // It shouldn't be more than 6 seconds for the Io to be done.
    //

    if ((GetTickCount() - startingTicks) > 6000) {

        FAILURE;

    }

    //
    // Make sure we got everything we wrote, which in this case is zero.
    //

    if (!GetOverlappedResult(
            comHandle,
            &readOl,
            &numberActuallyRead,
            FALSE
            )) {

        FAILURE;

    }

    if (numberActuallyRead) {

        FAILURE;

    }


    return 1;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\serial\test\tresize.c ===
//
// Tests resize of buffer.
//

#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include "windows.h"

//
// This program assumes that it is using a loopback connector.
//

#define MAX_CHECK 100000

ULONG CheckValues[MAX_CHECK];
ULONG ReadValues[MAX_CHECK];

void main(int argc,char *argv[]) {

    HANDLE hFile;
    COMMPROP mp;
    DCB MyDcb;
    ULONG i;
    ULONG actuallyIoed;
    ULONG firstReadSize;
    ULONG secondReadSize;
    ULONG secondWriteSize;
    COMMTIMEOUTS cto;
    char *MyPort = "COM1";
    COMSTAT stat;
    DWORD errors;
    DWORD increment = 1066;
    DWORD baudRate = 19200;

    cto.ReadIntervalTimeout = (DWORD)~0;
    cto.ReadTotalTimeoutMultiplier = (DWORD)0;
    cto.ReadTotalTimeoutConstant = (DWORD)0;
    cto.WriteTotalTimeoutMultiplier = (DWORD)1;
    cto.WriteTotalTimeoutConstant = (DWORD)1000;


    if (argc > 1) {

        MyPort = argv[1];

        if (argc > 2) {

            sscanf(argv[2],"%d",&increment);

            if (argc > 3) {

                sscanf(argv[3],"%d",&baudRate);

            }

        }

    }

    //
    // Put a sequence number in each long.  As an extra check
    // turn the high bit on.
    //

    for (
        i = 0;
        i < MAX_CHECK;
        i++
        ) {

        CheckValues[i] = i;
        CheckValues[i] |= 0x80000000;

    }

    if ((hFile = CreateFile(
                     MyPort,
                     GENERIC_READ | GENERIC_WRITE,
                     0,
                     NULL,
                     CREATE_ALWAYS,
                     FILE_ATTRIBUTE_NORMAL,
                     NULL
                     )) == ((HANDLE)-1)) {

        printf("Couldn't open the port %s\n",MyPort);
        exit(1);

    }

    if (!GetCommState(
             hFile,
             &MyDcb
             )) {

        printf("We couldn't get the comm state\n");
        exit(1);

    }

    //
    // Set the baud to 19200 and the data bits to 8
    // (We want 8 so that we don't lose any of our data.)
    //

    MyDcb.BaudRate = baudRate;
    MyDcb.ByteSize = 8;

    if (!SetCommState(
             hFile,
             &MyDcb
             )) {

        printf("Couldn't set the baud/data for port %s\n");
        exit(1);

    }

    //
    // All the data should be in memory,  we just set a timeout
    // so that if we do get hung up, the reads will return.
    //

    if (!SetCommTimeouts(
             hFile,
             &cto
             )) {

        printf("Couldn't set the timeouts.\n");
        exit(1);

    }

    //
    // Find out how many bytes are available in the RX buffer.
    //

    if (!GetCommProperties(
             hFile,
             &mp
             )) {

        printf("Couldn't get the properties for port %s\n",MyPort);
        exit(1);

    }

    while (mp.dwCurrentRxQueue <= (MAX_CHECK*sizeof(ULONG))) {

        printf("RX buffer size: %d\r",mp.dwCurrentRxQueue);

        //
        // Write out the number of bytes that the RX buffer can
        // hold.
        //
        // The we read in half (approximately) of those bytes.  After
        // we read the half, we resize the buffer.  We then read in
        // the rest of those bytes.  We then check the values against
        // what they "should" be.
        //

        if (!WriteFile(
                 hFile,
                 &CheckValues[0],
                 mp.dwCurrentRxQueue,
                 &actuallyIoed,
                 NULL
                 )) {

            printf("\nDidn't get all of the characters written %d\n",actuallyIoed);
            exit(1);

        }

        if (actuallyIoed != mp.dwCurrentRxQueue) {

            printf("\nfirst write Timed out with IO of %d\n",actuallyIoed);
            exit(1);

        }

        Sleep(2);

        //
        // Call clear comm error so that we can see how many characters
        // are in the typeahead buffer.
        //

        if (!ClearCommError(
                 hFile,
                 &errors,
                 &stat
                 )) {

            printf("\nCouldn't call clear comm status after first write.\n");
            exit(1);

        }

        if (stat.cbInQue != mp.dwCurrentRxQueue) {

            printf("\nAfter first write the typeahead buffer is incorrect %d - %x\n",
                   stat.cbInQue,errors);
            exit(1);

        }

        firstReadSize = mp.dwCurrentRxQueue / 2;
        secondReadSize = mp.dwCurrentRxQueue - firstReadSize;

        if (!ReadFile(
                 hFile,
                 &ReadValues[0],
                 firstReadSize,
                 &actuallyIoed,
                 NULL
                 )) {

            printf("\nDidn't get all of the characters read %d\n",actuallyIoed);
            exit(1);

        }

        if (actuallyIoed != firstReadSize) {

            printf("\nfirst read Timed out with IO of %d\n",actuallyIoed);
            exit(1);

        }

        Sleep(2);

        //
        // Call clear comm error so that we can see how many characters
        // are in the typeahead buffer.
        //

        if (!ClearCommError(
                 hFile,
                 &errors,
                 &stat
                 )) {

            printf("\nCouldn't call clear comm status after first read.\n");
            exit(1);

        }

        if (stat.cbInQue != secondReadSize) {

            printf("\nAfter first read the typeahead buffer is incorrect %d\n",
                   stat.cbInQue);
            exit(1);

        }

        Sleep(100);
        mp.dwCurrentRxQueue += increment;

        if (!SetupComm(
                 hFile,
                 mp.dwCurrentRxQueue,
                 mp.dwCurrentTxQueue
                 )) {

            printf("\nCouldn't resize the buffer to %d\n",mp.dwCurrentRxQueue);
            exit(1);

        }

        Sleep(2);

        //
        // Call clear comm error so that we can see how many characters
        // are in the typeahead buffer.
        //

        if (!ClearCommError(
                 hFile,
                 &errors,
                 &stat
                 )) {

            printf("\nCouldn't call clear comm status after resize.\n");
            exit(1);

        }

        if (stat.cbInQue != secondReadSize) {

            printf("\nAfter resize the typeahead buffer is incorrect %d\n",
                   stat.cbInQue);
            exit(1);

        }

        //
        // It's been resized.  Fill up the remaining.
        //

        secondWriteSize = mp.dwCurrentRxQueue - secondReadSize;

        if (!WriteFile(
                 hFile,
                 &CheckValues[0],
                 secondWriteSize,
                 &actuallyIoed,
                 NULL
                 )) {

            printf("\nDidn't write all of the chars second time %d\n",actuallyIoed);
            exit(1);

        }

        if (actuallyIoed != secondWriteSize) {

            printf("\nsecond write Timed out with IO of %d\n",actuallyIoed);
            exit(1);

        }

        Sleep(2);

        //
        // Call clear comm error so that we can see how many characters
        // are in the typeahead buffer.
        //

        if (!ClearCommError(
                 hFile,
                 &errors,
                 &stat
                 )) {

            printf("\nCouldn't call clear comm status after resize.\n");
            exit(1);

        }

        if (stat.cbInQue != mp.dwCurrentRxQueue) {

            printf("\nAfter second write the typeahead buffer is incorrect %d\n",
                   stat.cbInQue);
            exit(1);

        }


        //
        // We resized the buffer, see if we can get the rest of the
        // characters from the first write.
        //

        if (!ReadFile(
                 hFile,
                 ((PUCHAR)&ReadValues[0])+firstReadSize,
                 secondReadSize,
                 &actuallyIoed,
                 NULL
                 )) {

            printf("\nDidn't get all of the characters read(2) %d\n",actuallyIoed);
            exit(1);

        }

        if (actuallyIoed != secondReadSize) {

            printf("\nsecond read Timed out with IO of %d\n",actuallyIoed);
            exit(1);

        }

        Sleep(2);

        //
        // Call clear comm error so that we can see how many characters
        // are in the typeahead buffer.
        //

        if (!ClearCommError(
                 hFile,
                 &errors,
                 &stat
                 )) {

            printf("\nCouldn't call clear comm status after resize.\n");
            exit(1);

        }

        if (stat.cbInQue != secondWriteSize) {

            printf("\nAfter second read the typeahead buffer is incorrect %d\n",
                   stat.cbInQue);
            exit(1);

        }

        //
        // Now check that what we read was what we sent.
        //

        for (
            i = 0;
            i < (((firstReadSize+secondReadSize)+(sizeof(DWORD)-1)) / sizeof(DWORD)) - 1;
            i++
            ) {

            if (ReadValues[i] != CheckValues[i]) {

                printf("\nAt index %d - values are read %x - check %x\n",
                       i,ReadValues[i],CheckValues[i]);
                exit(1);

            }

        }

        //
        // Get the chars we wrote on the second write and make
        // sure that they are good also.
        //

        if (!ReadFile(
                 hFile,
                 &ReadValues[0],
                 secondWriteSize,
                 &actuallyIoed,
                 NULL
                 )) {

            printf("\nDidn't get all of the characters read(3) %d\n",actuallyIoed);
            exit(1);

        }

        if (actuallyIoed != secondWriteSize) {

            printf("\nthird read Timed out with IO of %d\n",actuallyIoed);
            exit(1);

        }

        Sleep(2);

        //
        // Call clear comm error so that we can see how many characters
        // are in the typeahead buffer.
        //

        if (!ClearCommError(
                 hFile,
                 &errors,
                 &stat
                 )) {

            printf("\nCouldn't call clear comm status after resize.\n");
            exit(1);

        }

        if (stat.cbInQue) {

            printf("\nAfter second read the typeahead buffer is incorrect %d\n",
                   stat.cbInQue);
            exit(1);

        }

        //
        // Now check that what we read was what we sent.
        //

        for (
            i = 0;
            i < ((secondWriteSize+(sizeof(DWORD)-1)) / sizeof(DWORD)) - 1;
            i++
            ) {

            if (ReadValues[i] != CheckValues[i]) {

                printf("\nAt on read(3) index %d - values are read %x - check %x\n",
                       i,ReadValues[i],CheckValues[i]);
                exit(1);

            }

        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\serial\test\tvdm.c ===
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "ntddser.h"
#include "windows.h"

void main(int argc,char *argv[]) {

    HANDLE hFile;
    DCB MyDcb;
    char *MyPort = "COM1";
    DWORD NumberActuallyWritten;
    DWORD NumberToWrite = 1000;
    DWORD UseBaud = 1200;
    DWORD NumberOfDataBits = 8;
    COMMTIMEOUTS To;
    OVERLAPPED WriteOl = {0};
    BOOL WriteDone;
    char Char = 'z';
    int j;

    HANDLE Evt1;
    HANDLE Evt2;
    HANDLE Evt3;
    HANDLE Evt4;
    HANDLE Evt5;

    SERIAL_XOFF_COUNTER Xc1 = {10000,10,'a'};
    SERIAL_XOFF_COUNTER Xc2 = {10000,10,'b'};
    SERIAL_XOFF_COUNTER Xc3 = {10000,10,'c'};
    SERIAL_XOFF_COUNTER Xc4 = {10000,10,'d'};
    SERIAL_XOFF_COUNTER Xc5 = {10000,10,'e'};

    IO_STATUS_BLOCK Iosb1;
    IO_STATUS_BLOCK Iosb2;
    IO_STATUS_BLOCK Iosb3;
    IO_STATUS_BLOCK Iosb4;
    IO_STATUS_BLOCK Iosb5;

    NTSTATUS Status1;
    NTSTATUS Status2;
    NTSTATUS Status3;
    NTSTATUS Status4;
    NTSTATUS Status5;

    UNREFERENCED_PARAMETER(argc);
    UNREFERENCED_PARAMETER(argv);

    if (!(WriteOl.hEvent = CreateEvent(
                               NULL,
                               FALSE,
                               FALSE,
                               NULL
                               ))) {

        printf("Could not create the write event.\n");
        exit(1);

    } else {

        WriteOl.Internal = 0;
        WriteOl.InternalHigh = 0;
        WriteOl.Offset = 0;
        WriteOl.OffsetHigh = 0;

    }

    if ((hFile = CreateFile(
                     MyPort,
                     GENERIC_READ | GENERIC_WRITE,
                     0,
                     NULL,
                     CREATE_ALWAYS,
                     FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
                     NULL
                     )) == ((HANDLE)-1)) {

        printf("Couldn't open the comm port\n");
        exit(1);

    }

    To.ReadIntervalTimeout = 0;
    To.ReadTotalTimeoutMultiplier = ((1000+(((UseBaud+9)/10)-1))/((UseBaud+9)/10));
    if (!To.ReadTotalTimeoutMultiplier) {
        To.ReadTotalTimeoutMultiplier = 1;
    }
    To.WriteTotalTimeoutMultiplier = ((1000+(((UseBaud+9)/10)-1))/((UseBaud+9)/10));
    if (!To.WriteTotalTimeoutMultiplier) {
        To.WriteTotalTimeoutMultiplier = 1;
    }
    To.ReadTotalTimeoutConstant = 5000;
    To.WriteTotalTimeoutConstant = 5000;

    if (!SetCommTimeouts(
            hFile,
            &To
            )) {

        printf("Couldn't set the timeouts\n");
        exit(1);

    }

    //
    // We've successfully opened the file.  Set the state of
    // the comm device.  First we get the old values and
    // adjust to our own.
    //

    if (!GetCommState(
             hFile,
             &MyDcb
             )) {

        printf("Couldn't get the comm state: %d\n",GetLastError());
        exit(1);

    }

    MyDcb.BaudRate = UseBaud;
    MyDcb.ByteSize = (BYTE)NumberOfDataBits;
    MyDcb.Parity = NOPARITY;
    MyDcb.StopBits = ONESTOPBIT;

    if (!SetCommState(
            hFile,
            &MyDcb
            )) {

        printf("Couldn't set the comm state.\n");
        exit(1);

    }

    //
    // Create 5 event handles to use to process the
    // vdm ioctls.
    //

    if (!(Evt1 = CreateEvent(NULL,
                     FALSE,
                     FALSE,
                     NULL))) {

        printf("Couldn't create event 1\n");
        exit(1);

    }

    if (!(Evt2 = CreateEvent(NULL,
                     FALSE,
                     FALSE,
                     NULL))) {

        printf("Couldn't create event 2\n");
        exit(1);

    }

    if (!(Evt3 = CreateEvent(NULL,
                     FALSE,
                     FALSE,
                     NULL))) {

        printf("Couldn't create event 3\n");
        exit(1);

    }

    if (!(Evt4 = CreateEvent(NULL,
                     FALSE,
                     FALSE,
                     NULL))) {

        printf("Couldn't create event 4\n");
        exit(1);

    }

    if (!(Evt5 = CreateEvent(NULL,
                     FALSE,
                     FALSE,
                     NULL))) {

        printf("Couldn't create event 5\n");
        exit(1);

    }

    //
    // Start up the vdm ioctl and give it a second to get well
    // established as a counter.
    //

    Status1 = NtDeviceIoControlFile(
                  hFile,
                  Evt1,
                  NULL,
                  NULL,
                  &Iosb1,
                  IOCTL_SERIAL_XOFF_COUNTER,
                  &Xc1,
                  sizeof(SERIAL_XOFF_COUNTER),
                  NULL,
                  0
                  );

    if ( Status1 != STATUS_PENDING) {

        printf("1: Non pending status: %x\n",Status1);
        exit(1);

    }

    Sleep(1000);

    //
    // Do the second vdm ioctl.  Wait one second then test to
    // make sure that the first one is finished by checking
    // its event handle. Then make sure that it was killed
    // because of writes
    //

    Status2 = NtDeviceIoControlFile(
                  hFile,
                  Evt2,
                  NULL,
                  NULL,
                  &Iosb2,
                  IOCTL_SERIAL_XOFF_COUNTER,
                  &Xc2,
                  sizeof(SERIAL_XOFF_COUNTER),
                  NULL,
                  0
                  );

    if ( Status2 != STATUS_PENDING) {

        printf("2: Non pending status: %x\n",Status1);
        exit(1);

    }

    //
    // Wait up to a second for the first one to be killed.
    //

    if (WaitForSingleObject(Evt1,1000)) {

        printf("Evt1 has not attained a signalled state.\n");
        exit(1);

    }

    if (Iosb1.Status != STATUS_SERIAL_MORE_WRITES) {

        printf("Iosb1 not more writes: %x\n",Iosb1.Status);
        exit(1);

    }

    //
    // Start up an 1 character asynchronous write and wait for a second and
    // the make sure that the previous vdm ioctl is done.
    //

    WriteDone = WriteFile(
                    hFile,
                    &Char,
                    1,
                    &NumberActuallyWritten,
                    &WriteOl
                    );

    if (!WriteDone) {

        DWORD LastError;
        LastError = GetLastError();

        if (LastError != ERROR_IO_PENDING) {

            printf("Couldn't write the %s device.\n",MyPort);
            printf("Status of failed write is: %x\n",LastError);
            exit(1);

        }

    }

    if (WaitForSingleObject(Evt2,1000)) {

        printf("Evt2 has not attained a signalled state.\n");
        exit(1);

    }

    if (Iosb2.Status != STATUS_SERIAL_MORE_WRITES) {

        printf("Iosb2 not more writes: %x\n",Iosb2.Status);
        exit(1);

    }

    //
    // Wait up to 10 seconds for the write to finish.
    //

    if (WaitForSingleObject(WriteOl.hEvent,10000)) {

        printf("The write never finished\n");
        exit(1);

    }

    //
    // Set up a third vdm ioctl as before.
    //

    Status3 = NtDeviceIoControlFile(
                  hFile,
                  Evt3,
                  NULL,
                  NULL,
                  &Iosb3,
                  IOCTL_SERIAL_XOFF_COUNTER,
                  &Xc3,
                  sizeof(SERIAL_XOFF_COUNTER),
                  NULL,
                  0
                  );

    if ( Status3 != STATUS_PENDING) {

        printf("3: Non pending status: %x\n",Status3);
        exit(1);

    }

    //
    // Set up a fourth vdm ioctl, make sure that the previous ioctl
    // has been killed.  Then wait for 15 seconds and then make sure
    // that the fourth vdm ioctl is finished and that it finished
    // due to the timer expiring before the the counter expired
    //

    Status4 = NtDeviceIoControlFile(
                  hFile,
                  Evt4,
                  NULL,
                  NULL,
                  &Iosb4,
                  IOCTL_SERIAL_XOFF_COUNTER,
                  &Xc4,
                  sizeof(SERIAL_XOFF_COUNTER),
                  NULL,
                  0
                  );

    if ( Status4 != STATUS_PENDING) {

        printf("4: Non pending status: %x\n",Status4);
        exit(1);

    }

    if (WaitForSingleObject(Evt3,1000)) {

        printf("Evt3 has not attained a signalled state.\n");
        exit(1);

    }

    if (Iosb3.Status != STATUS_SERIAL_MORE_WRITES) {

        printf("Iosb3 not more writes: %x\n",Iosb3.Status);
        exit(1);

    }

    //
    // Wait up to one second beyond the countdown timeout.
    //
    printf("Waiting %d seconds for the timer to time out.\n",(Xc4.Timeout+1000)/1000);
    if (WaitForSingleObject(Evt4,Xc4.Timeout+1000)) {

        printf("Evt4 has not attained a signalled state.\n");
        exit(1);

    }
    printf("Done with the timeout.\n");

    if (Iosb4.Status != STATUS_SERIAL_COUNTER_TIMEOUT) {

        printf("Iosb4 not counter timeout: %x\n",Iosb4.Status);
        exit(1);

    }

    //
    // Set up a fifth vdm ioctl, with a counter of ten,
    // then do 15 transmit immediate writes.  If a loopback
    // connector is connected to the port then the characters
    // will then be received.  This should cause the counter to
    // count down and cause the vdm ioctl to complete with
    // status success.
    //
    // NOTE NOTE: Transmit immediates DO NOT cause vdm ioctls
    // to complete with a status of MORE_WRITES.
    //

    Status5 = NtDeviceIoControlFile(
                  hFile,
                  Evt5,
                  NULL,
                  NULL,
                  &Iosb5,
                  IOCTL_SERIAL_XOFF_COUNTER,
                  &Xc5,
                  sizeof(SERIAL_XOFF_COUNTER),
                  NULL,
                  0
                  );

    if ( Status5 != STATUS_PENDING) {

        printf("5: Non pending status: %x\n",Status5);
        exit(1);

    }

    for (
        j = 0;
        j < Xc5.Counter+5;
        j++
        ) {

        if (!TransmitCommChar(hFile,'u')) {

            printf("A transmit comm char failed: %d\n",j);
            exit(1);

        }

    }

    //
    // Well we'll give it at least a second.
    //

    if (WaitForSingleObject(Evt5,1000)) {

        printf("Evt5 has not attained a signalled state.\n");
        exit(1);

    }

    if (Iosb5.Status != STATUS_SUCCESS) {

        printf("Iosb5 not SUCCEESS: %x\n",Iosb5.Status);
        exit(1);

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serveravailability\ddk\display\msdisp.cpp ===
/*++

Copyright (c) 1991 - 2002 Microsoft Corporation

Module Name:

    ##    ##  ###  #####   ####  ###  #####      ####  #####  #####
    ###  ### ##  # ##  ##   ##  ##  # ##  ##    ##   # ##  ## ##  ##
    ######## ###   ##   ##  ##  ###   ##  ##    ##     ##  ## ##  ##
    # ### ##  ###  ##   ##  ##   ###  ##  ##    ##     ##  ## ##  ##
    #  #  ##   ### ##   ##  ##    ### #####     ##     #####  #####
    #     ## #  ## ##  ##   ##  #  ## ##     ## ##   # ##     ##
    #     ##  ###  #####   ####  ###  ##     ##  ####  ##     ##

Abstract:

    This module contains the entire implementation of
    the Microsoft virtual display miniport driver.

@@BEGIN_DDKSPLIT
Author:

    Wesley Witt (wesw) 1-Oct-2001

@@END_DDKSPLIT
Environment:

    Kernel mode only.

Notes:

--*/

#include "msdisp.h"


#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,DriverEntry)
#endif



NTSTATUS
MsDispHwInitialize(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID DeviceExtensionIn,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR PartialResources,
    IN ULONG PartialResourceCount
    )

/*++

Routine Description:

    This routine is the driver's entry point, called by the I/O system
    to load the driver.  The driver's entry points are initialized and
    a mutex to control paging is initialized.

    In DBG mode, this routine also examines the registry for special
    debug parameters.

Arguments:
    DeviceObject            - Miniport's device object
    Irp                     - Current IRP in progress
    DeviceExtensionIn       - Miniport's device extension
    PartialResources        - List of resources that are assigned to the miniport
    PartialResourceCount    - Number of assigned resources

Return Value:

    NT status code

--*/

{
    PDEVICE_EXTENSION DeviceExtension;
    UNICODE_STRING EventName;


    DeviceExtension = (PDEVICE_EXTENSION) DeviceExtensionIn;
    DeviceExtension->DeviceObject = DeviceObject;

    KeInitializeMutex( &DeviceExtension->DeviceLock, 0 );
    DeviceExtension->DisplayBufferLength = SA_DISPLAY_MAX_BITMAP_SIZE;
    DeviceExtension->DisplayBuffer = (PUCHAR) SaPortAllocatePool( DeviceExtension, DeviceExtension->DisplayBufferLength+128 );
    if (DeviceExtension->DisplayBuffer == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory( DeviceExtension->DisplayBuffer, DeviceExtension->DisplayBufferLength+128 );

    return STATUS_SUCCESS;
}


NTSTATUS
MsDispCreate(
    IN PVOID DeviceExtensionIn,
    IN PIRP Irp,
    IN PVOID FsContextIn
    )
{
    PDEVICE_EXTENSION DeviceExtension = (PDEVICE_EXTENSION) DeviceExtensionIn;
    PMSDISP_FSCONTEXT FsContext = (PMSDISP_FSCONTEXT) FsContextIn;

    FsContext->HasLockedPages = 0;

    return STATUS_SUCCESS;
}


NTSTATUS
MsDispClose(
    IN PVOID DeviceExtensionIn,
    IN PIRP Irp,
    IN PVOID FsContextIn
    )
{
    PDEVICE_EXTENSION DeviceExtension = (PDEVICE_EXTENSION) DeviceExtensionIn;
    PMSDISP_FSCONTEXT FsContext = (PMSDISP_FSCONTEXT) FsContextIn;


    if (FsContext->HasLockedPages) {
        KeAcquireMutex( &DeviceExtension->DeviceLock );
        IoFreeMdl( FsContext->Mdl );
        KeReleaseMutex( &DeviceExtension->DeviceLock, FALSE );
    }

    return STATUS_SUCCESS;
}


VOID
MsDispCreateEventsWorker(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    )

/*++

Routine Description:

   This delayed work routine creates the necessary events used
   to communicate with the user mode application.

Arguments:

   DeviceObject         - Display device object
   Context              - Context pointer

Return Value:

   None.

--*/

{
    PMSDISP_WORK_ITEM WorkItem = (PMSDISP_WORK_ITEM)Context;
    PDEVICE_EXTENSION DeviceExtension = WorkItem->DeviceExtension;
    NTSTATUS Status;


    WorkItem->Status = STATUS_SUCCESS;
    DeviceExtension->EventHandle = NULL;
    DeviceExtension->Event = NULL;

    KeAcquireMutex( &DeviceExtension->DeviceLock );

    Status = SaPortCreateBasenamedEvent(
        DeviceExtension,
        MSDISP_EVENT_NAME,
        &DeviceExtension->Event,
        &DeviceExtension->EventHandle
        );
    if (!NT_SUCCESS(Status)) {
        REPORT_ERROR( SA_DEVICE_DISPLAY, "SaPortCreateBasenamedEvent failed", Status );
    }

    WorkItem->Status = Status;

    KeReleaseMutex( &DeviceExtension->DeviceLock, FALSE );

    IoFreeWorkItem( WorkItem->WorkItem );
    KeSetEvent( &WorkItem->Event, IO_NO_INCREMENT, FALSE );
}


NTSTATUS
MsDispDeviceIoctl(
    IN PVOID DeviceExtensionIn,
    IN PIRP Irp,
    IN PVOID FsContextIn,
    IN ULONG FunctionCode,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength,
    IN PVOID OutputBuffer,
    IN ULONG OutputBufferLength
    )

/*++

Routine Description:

   This routine processes the device control requests for the
   local display miniport.

Arguments:

   DeviceExtension      - Miniport's device extension
   FunctionCode         - Device control function code
   InputBuffer          - Pointer to the user's input buffer
   InputBufferLength    - Length in bytes of the input buffer
   OutputBuffer         - Pointer to the user's output buffer
   OutputBufferLength   - Length in bytes of the output buffer

Return Value:

   NT status code.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PDEVICE_EXTENSION DeviceExtension = (PDEVICE_EXTENSION) DeviceExtensionIn;
    PSA_DISPLAY_CAPS DeviceCaps;
    PMSDISP_BUFFER_DATA BufferData;
    PMSDISP_FSCONTEXT FsContext;
    MSDISP_WORK_ITEM WorkItem;



    switch (FunctionCode) {
        case FUNC_SA_GET_VERSION:
            *((PULONG)OutputBuffer) = SA_INTERFACE_VERSION;
            break;

        case FUNC_SA_GET_CAPABILITIES:
            DeviceCaps = (PSA_DISPLAY_CAPS)OutputBuffer;
            DeviceCaps->SizeOfStruct = sizeof(SA_DISPLAY_CAPS);
            DeviceCaps->DisplayType = SA_DISPLAY_TYPE_BIT_MAPPED_LCD;
            DeviceCaps->CharacterSet = SA_DISPLAY_CHAR_ASCII;
            DeviceCaps->DisplayHeight = DISPLAY_HEIGHT;
            DeviceCaps->DisplayWidth = DISPLAY_WIDTH;
            break;

    case FUNC_VDRIVER_INIT:
            if (DeviceExtension->Event == NULL) {
                WorkItem.DeviceExtension = DeviceExtension;
                WorkItem.Status = 0;
                WorkItem.WorkItem = IoAllocateWorkItem( DeviceExtension->DeviceObject );
                if (WorkItem.WorkItem) {
                    KeInitializeEvent( &WorkItem.Event, NotificationEvent, FALSE );
                    IoQueueWorkItem( WorkItem.WorkItem, MsDispCreateEventsWorker, DelayedWorkQueue, &WorkItem );
                    KeWaitForSingleObject( &WorkItem.Event, Executive, KernelMode, FALSE, NULL );
                } else {
                    WorkItem.Status = STATUS_INSUFFICIENT_RESOURCES;
                }
            } else {
                WorkItem.Status = STATUS_SUCCESS;
            }
            if (WorkItem.Status == STATUS_SUCCESS) {
                BufferData = (PMSDISP_BUFFER_DATA) OutputBuffer;
                FsContext = (PMSDISP_FSCONTEXT) FsContextIn;
                FsContext->Mdl = IoAllocateMdl( DeviceExtension->DisplayBuffer, DeviceExtension->DisplayBufferLength, FALSE, TRUE, NULL );
                if (FsContext->Mdl) {
                    MmBuildMdlForNonPagedPool( FsContext->Mdl );
                    BufferData->DisplayBuffer = MmMapLockedPagesSpecifyCache(
                        FsContext->Mdl,
                        UserMode,
                        MmCached,
                        NULL,
                        FALSE,
                        NormalPagePriority
                        );
                    if (BufferData->DisplayBuffer == NULL) {
                        IoFreeMdl( FsContext->Mdl );
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                        REPORT_ERROR( SA_DEVICE_DISPLAY, "MmMapLockedPagesSpecifyCache failed", Status );
                    } else {
                        FsContext->HasLockedPages = 1;
                    }
                } else {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    REPORT_ERROR( SA_DEVICE_DISPLAY, "IoAllocateMdl failed", Status );
                }
            } else {
                Status = WorkItem.Status;
            }
            break;

        default:
            Status = STATUS_NOT_SUPPORTED;
            REPORT_ERROR( SA_DEVICE_DISPLAY, "Unsupported device control", Status );
            break;
    }

    return Status;
}


VOID
MsDispWriteWorker(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    )

/*++

Routine Description:

   This delayed work routine completes a write operation.

Arguments:

   DeviceObject         - Display device object
   Context              - Context pointer

Return Value:

   None.

--*/

{
    PMSDISP_WORK_ITEM WorkItem = (PMSDISP_WORK_ITEM)Context;
    PDEVICE_EXTENSION DeviceExtension = WorkItem->DeviceExtension;
    NTSTATUS Status;


    KeAcquireMutex( &DeviceExtension->DeviceLock );
    RtlZeroMemory( DeviceExtension->DisplayBuffer, DeviceExtension->DisplayBufferLength );
    RtlCopyMemory( DeviceExtension->DisplayBuffer, WorkItem->SaDisplay->Bits, (WorkItem->SaDisplay->Width/8)*WorkItem->SaDisplay->Height );
    KeReleaseMutex( &DeviceExtension->DeviceLock, FALSE );

    if (DeviceExtension->Event) {
        KeSetEvent( DeviceExtension->Event, 0, FALSE );
    }

    IoFreeWorkItem( WorkItem->WorkItem );
    SaPortFreePool( DeviceExtension, WorkItem );

    SaPortCompleteRequest( DeviceExtension, NULL, 0, STATUS_SUCCESS, FALSE );
}


NTSTATUS
MsDispWrite(
    IN PVOID DeviceExtensionIn,
    IN PIRP Irp,
    IN PVOID FsContextIn,
    IN LONGLONG StartingOffset,
    IN PVOID DataBuffer,
    IN ULONG DataBufferLength
    )

/*++

Routine Description:

   This routine processes the write request for the local display miniport.

Arguments:

   DeviceExtensionIn    - Miniport's device extension
   StartingOffset       - Starting offset for the I/O
   DataBuffer           - Pointer to the data buffer
   DataBufferLength     - Length of the data buffer in bytes

Return Value:

   NT status code.

--*/

{
    PDEVICE_EXTENSION DeviceExtension = (PDEVICE_EXTENSION) DeviceExtensionIn;
    PSA_DISPLAY_SHOW_MESSAGE SaDisplay = (PSA_DISPLAY_SHOW_MESSAGE) DataBuffer;
    NTSTATUS Status = STATUS_SUCCESS;
    PMSDISP_WORK_ITEM WorkItem;


    if ((ULONG)((SaDisplay->Width/8)*SaDisplay->Height) > DeviceExtension->DisplayBufferLength) {
        return STATUS_INVALID_PARAMETER;
    }

    WorkItem = (PMSDISP_WORK_ITEM) SaPortAllocatePool( DeviceExtension, sizeof(MSDISP_WORK_ITEM) );
    if (WorkItem == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    WorkItem->DeviceExtension = DeviceExtension;
    WorkItem->SaDisplay = (PSA_DISPLAY_SHOW_MESSAGE) DataBuffer;
    WorkItem->WorkItem = IoAllocateWorkItem( DeviceExtension->DeviceObject );
    if (WorkItem->WorkItem) {
        IoQueueWorkItem( WorkItem->WorkItem, MsDispWriteWorker, DelayedWorkQueue, WorkItem );
        Status = STATUS_PENDING;
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return Status;
}


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This routine is the driver's entry point, called by the I/O system
    to load the driver.  The driver's entry points are initialized and
    a mutex to control paging is initialized.

    In DBG mode, this routine also examines the registry for special
    debug parameters.

Arguments:

    DriverObject - a pointer to the object that represents this device
                   driver.

    RegistryPath - a pointer to this driver's key in the Services tree.

Return Value:

    STATUS_SUCCESS

--*/

{
    NTSTATUS Status;
    SAPORT_INITIALIZATION_DATA SaPortInitData;


    RtlZeroMemory( &SaPortInitData, sizeof(SAPORT_INITIALIZATION_DATA) );

    SaPortInitData.StructSize = sizeof(SAPORT_INITIALIZATION_DATA);
    SaPortInitData.DeviceType = SA_DEVICE_DISPLAY;
    SaPortInitData.HwInitialize = MsDispHwInitialize;
    SaPortInitData.Write = MsDispWrite;
    SaPortInitData.DeviceIoctl = MsDispDeviceIoctl;
    SaPortInitData.CloseRoutine = MsDispClose;
    SaPortInitData.CreateRoutine = MsDispCreate;

    SaPortInitData.DeviceExtensionSize = sizeof(DEVICE_EXTENSION);
    SaPortInitData.FileContextSize = sizeof(MSDISP_FSCONTEXT);

    Status = SaPortInitialize( DriverObject, RegistryPath, &SaPortInitData );
    if (!NT_SUCCESS(Status)) {
        REPORT_ERROR( SA_DEVICE_DISPLAY, "SaPortInitialize failed\n", Status );
        return Status;
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serveravailability\ddk\gui\resource.h ===
#define APPICON                         100
#define IDD_DIALOG                      101
#define IDC_BITMAP                      102
#define IDC_ESCAPE                      103
#define IDC_ENTER                       104
#define IDC_LEFT                        105
#define IDC_RIGHT                       106
#define IDC_UP                          107
#define IDC_DOWN                        108
#define IDC_STATIC                      -1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serveravailability\ddk\display\msdisp.h ===
/*++

Copyright (c) 1991 - 2002 Microsoft Corporation

Module Name:

    ##    ##  ###  #####   ####  ###  #####     ##   ##
    ###  ### ##  # ##  ##   ##  ##  # ##  ##    ##   ##
    ######## ###   ##   ##  ##  ###   ##  ##    ##   ##
    # ### ##  ###  ##   ##  ##   ###  ##  ##    #######
    #  #  ##   ### ##   ##  ##    ### #####     ##   ##
    #     ## #  ## ##  ##   ##  #  ## ##     ## ##   ##
    #     ##  ###  #####   ####  ###  ##     ## ##   ##

Abstract:

    This header file contains the definitions for the
    Microsoft virtual display miniport driver.

@@BEGIN_DDKSPLIT
Author:

    Wesley Witt (wesw) 1-Oct-2001

@@END_DDKSPLIT
Environment:

    Kernel mode only.

Notes:

--*/

extern "C" {
#include <ntddk.h>
#include <stdio.h>
}

#define MINIPORT_DEVICE_TYPE    SA_DEVICE_DISPLAY

#include "saport.h"
#include "..\inc\virtual.h"

#define SecToNano(_sec) (LONGLONG)((_sec) * 1000 * 1000 * 10)

//
// Global Defines
//

#define DISPLAY_WIDTH               (128)
#define DISPLAY_HEIGHT              (64)
#define MAX_BITMAP_SIZE             ((DISPLAY_WIDTH/8)*DISPLAY_HEIGHT)

typedef struct _DEVICE_EXTENSION {
    PDEVICE_OBJECT      DeviceObject;
    PUCHAR              DisplayBuffer;
    ULONG               DisplayBufferLength;
    KMUTEX              DeviceLock;
    PKEVENT             Event;
    HANDLE              EventHandle;
} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

typedef struct _MSDISP_WORK_ITEM {
    PDEVICE_EXTENSION           DeviceExtension;
    PIO_WORKITEM                WorkItem;
    NTSTATUS                    Status;
    KEVENT                      Event;
    PSA_DISPLAY_SHOW_MESSAGE    SaDisplay;
} MSDISP_WORK_ITEM, *PMSDISP_WORK_ITEM;

typedef struct _MSDISP_FSCONTEXT {
    ULONG               HasLockedPages;
    PMDL                Mdl;
} MSDISP_FSCONTEXT, *PMSDISP_FSCONTEXT;


//
// prototypes
//

extern "C" {

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

} // extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\serial\test\twrcntl.c ===
#include <windows.h>
#include <stdio.h>
//#define COM_DEB     1

#define   NUM         20
#define   SETTINGS1       "COM3",9600,8,NOPARITY,ONESTOPBIT
#define   SETTINGS15       "COM3",9600,5,NOPARITY,ONE5STOPBITS
#define   SETTINGS2       "COM3",4800,8,NOPARITY,ONESTOPBIT
#define   SETTINGS3       "COM3",2400,8,NOPARITY,ONESTOPBIT
#define   SETTINGS4       "COM3",300,8,NOPARITY,ONESTOPBIT

BOOL DoComIo(LPSTR lpCom,DWORD Baud,BYTE Size,BYTE Parity,BYTE Stop);
DWORD main(int argc, char *argv[], char *envp[])
{
BOOL bRc;

UNREFERENCED_PARAMETER(argc);
UNREFERENCED_PARAMETER(argv);
UNREFERENCED_PARAMETER(envp);

printf("\n\n *** Doing COM TEST with [port=%s Baud=%d,Size=%d,Parity=%d,Stop=%d]***\n\n",
        SETTINGS1);
bRc = DoComIo(SETTINGS1);
if (!bRc) {
            printf("\n\nCOM TEST FAILED********************************\n\n");
          }


return 0;
}


BOOL DoComIo(LPSTR lpCom,DWORD Baud,BYTE Size,BYTE Parity,BYTE Stop)
{

CHAR WrBuffer[NUM];
CHAR RdBuffer[NUM+5];
DWORD i;
HANDLE hCommPort;
DCB    dcb;
BOOL   bRc;
DWORD  dwNumWritten,dwNumRead,dwErrors;
COMSTAT ComStat;

printf("\n\n *** COMM TEST START [port=%s,Baud=%d,Size=%d,Parity=%d,Stop=%d]***\n\n",
         lpCom,Baud,Size,Parity,Stop);

printf("Opening the comm port for read write\n");

hCommPort = CreateFile(
                       lpCom,
                       GENERIC_READ|GENERIC_WRITE,
                       0, // exclusive
                       NULL, // sec attr
                       OPEN_EXISTING,
                       0,             // no attributes
                       NULL);         // no template

if (hCommPort == (HANDLE)-1)
    {
    printf("FAIL: OpenComm failed rc: %lx\n",hCommPort);
    return FALSE;
    }


printf("Opening the comm port for read write: SUCCESS hCommPort=%lx\n",hCommPort);

printf("Setting the line characteristics on comm \n");


//printf("doing getcommstate for priming the dcb with defaults\n");

//bRc = GetCommState(hCommPort,&dcb);

if (!bRc)
    {
    printf("FAIL: getcommstate failed\n");
    return FALSE;
    }



// toggle rts dtr when xonlim xofflim reached
// fdtrcontrol frtscontrol
// send xoff when xofflim reached and send xon when xonlim reached
// fInX
// xonlim xonlim xonchar xoffchar


dcb.DCBlength   = sizeof(DCB);
// dcb.DCBversion  = 0x0002; in spec not in header

dcb.BaudRate = Baud;
dcb.ByteSize = Size;
dcb.Parity   = Parity;
dcb.StopBits = Stop;


dcb.fBinary = 1;         // binary data xmit
dcb.fParity = 0;         // dont bother about parity
dcb.fOutxCtsFlow= 0;     // no cts flow control
dcb.fOutxDsrFlow= 0;     // no dsr flow control
dcb.fDtrControl = DTR_CONTROL_HANDSHAKE;      // dont bother about dtr
dcb.fRtsControl = RTS_CONTROL_HANDSHAKE;      // dont bother about dtr
dcb.fOutX =1;            //  disable xoff handling
dcb.fInX  =1;            //  disable xon handling
dcb.fErrorChar = 0;         // forget about parity char
dcb.fNull =  0;          // forget about the null striping

dcb.XonChar = '#';
dcb.XonLim =   1;
dcb.XoffChar = '*';
dcb.XoffLim = 4090;


dcb.ErrorChar = '*';
dcb.EofChar = 0x00;
dcb.EvtChar = 'x';

//dcb.TxDelay = 100000;  // 100sec


bRc = SetCommState(hCommPort,&dcb);

if (!bRc)
    {
    printf("FAIL: cannot set the comm state rc:%lx\n",bRc);
    bRc = CloseHandle(hCommPort);
          if (!bRc)
          {
           printf("FAIL: cannot close the comm port:%lx\n",bRc);
          }
    return FALSE;
    }

printf("Setting the line characteristics on comm: SUCCESS\n");


printf("Filling the buffer with the known chars \n");

for (i=0; i< NUM; i++)
    {
    WrBuffer[i] = 'a';
    //WrBuffer[i] = (CHAR)i;

    }

printf("Filling the buffer with the known chars : SUCCESS\n");


printf("Dumping the buffer before sending it to comm\n");

for (i=0; i< 6; i++)
    {
    printf("%c",WrBuffer[i]);
    //printf(" %d ",WrBuffer[i]);

    }

printf("\nDumping the buffer before sending it to comm SUCCESS\n");

printf("Filling the Rdbuffer with the known chars (0xFF) to makeit dirty\n");

for (i=0; i< NUM+2; i++)
    {
    RdBuffer[i] = 'z';
    }

printf("Filling the Rdbuffer with the known chars (0xFF/z): SUCCESS\n");

printf("Writting this buffer to the comm port\n");

bRc = WriteFile( hCommPort,
                 WrBuffer,
                 6,
                &dwNumWritten,
                 NULL);

if (!bRc)
        {
        printf("FAIL: cannot Write To the comm port:%lx\n",bRc);
        bRc = CloseHandle(hCommPort);
          if (!bRc)
          {
           printf("FAIL: cannot close the comm port:%lx\n",bRc);
          }
        return FALSE;
        }

printf("Writting this buffer to the comm port: SUCCESS rc:%lx, byteswritten:%lx\n",
                                                     bRc,dwNumWritten);


printf("Reading this buffer from the comm port\n");

bRc = FlushFileBuffers(hCommPort);
printf("flush file buffers (%lx) rc = %lx\n",hCommPort,bRc);

bRc = ClearCommError(hCommPort,&dwErrors,&ComStat);
printf("ClearCommError: rc= %lx and dwErrors=%lx\n",bRc,dwErrors);

printf("Comstat.fXoffSent = %lx\n",(DWORD)(ComStat.fXoffSent));
printf("Comstat.fXoffHold = %lx\n",(DWORD)(ComStat.fXoffHold));


printf("reading the first num chars\n");

bRc = ReadFile( hCommPort,
                RdBuffer,
                6,
               &dwNumRead,
                NULL);

if (!bRc)
        {
        printf("FAIL: cannot Read From the comm port:%lx\n",bRc);
        bRc = CloseHandle(hCommPort);
          if (!bRc)
          {
           printf("FAIL: cannot close the comm port:%lx\n",bRc);
          }
        return FALSE;
        }

printf("Reading this buffer from the comm port: SUCCESS rc:%lx, bytesread:%lx\n",
                                                     bRc,dwNumRead);


printf("Dumping the Rdbuffer with the comm data\n");

for (i=0; i< 6; i++)
    {
    printf("%c ",RdBuffer[i]);
    //printf(" %d ",RdBuffer[i]);

    }

printf("\nDumping the Rdbuffer with the comm data: SUCCESS\n");





for (i=0; i< 6; i++)
    {
    if (RdBuffer[i] != WrBuffer[i])
        {
        printf("FAIL: BufferMisMatch: RdBuffer[%d]=%lx,WrBuffer[%d]=%lx\n",
                      i,RdBuffer[i],i,WrBuffer[i]);
        bRc = CloseHandle(hCommPort);
          if (!bRc)
          {
           printf("FAIL: cannot close the comm port:%lx\n",bRc);
          }
        return FALSE;
        }
    }

printf("Comparing the rd and wr buffers: SUCCESS\n");


bRc = FlushFileBuffers(hCommPort);
printf("flush file buffers (%lx,0) rc = %lx\n",hCommPort,bRc);

bRc = ClearCommError(hCommPort,&dwErrors,&ComStat);
printf("ClearCommError: rc= %lx and dwErrors=%lx\n",bRc,dwErrors);


printf("Comstat.fXoffSent = %lx\n",(DWORD)(ComStat.fXoffSent));
printf("Comstat.fXoffHold = %lx\n",(DWORD)(ComStat.fXoffHold));




bRc = PurgeComm(hCommPort,0);
printf("PurgeComm BUG (%lx,0) rc = %lx\n",hCommPort,bRc);

bRc = PurgeComm(hCommPort,PURGE_TXCLEAR);
printf("PurgeComm txclear (%lx) rc = %lx\n",hCommPort,bRc);

bRc = PurgeComm(hCommPort,PURGE_RXCLEAR);
printf("PurgeComm rxclear (%lx) rc = %lx\n",hCommPort,bRc);

bRc = PurgeComm(hCommPort,PURGE_RXABORT);
printf("PurgeComm rxabort (%lx) rc = %lx\n",hCommPort,bRc);


bRc = PurgeComm(hCommPort,PURGE_TXABORT);
printf("PurgeComm txabort (%lx) rc = %lx\n",hCommPort,bRc);



printf("Closing the comm port\n");
bRc = CloseHandle(hCommPort);

if (!bRc)
    {
        printf("FAIL: cannot close the comm port:%lx\n",bRc);
        return FALSE;
    }


printf("\n\n*** COMM TEST OVER*** \n\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serveravailability\ddk\gui\gui.cpp ===
/*++

Copyright (c) 1991 - 2002 Microsoft Corporation

Module Name:

     ####  ##  ## ####     ####  #####  #####
    ##   # ##  ##  ##     ##   # ##  ## ##  ##
    ##     ##  ##  ##     ##     ##  ## ##  ##
    ## ### ##  ##  ##     ##     ##  ## ##  ##
    ##  ## ##  ##  ##     ##     #####  #####
    ##  ## ##  ##  ##  ## ##   # ##     ##
     #####  ####  #### ##  ####  ##     ##

Abstract:

    This module contains the implementation for
    the GUI interface for the local display and
    keypad drivers.

@@BEGIN_DDKSPLIT
Author:

    Wesley Witt (wesw) 1-Oct-2001

@@END_DDKSPLIT
Environment:

    Kernel mode only.

Notes:

--*/

#include <windows.h>
#include <winioctl.h>
#include <stdio.h>
#include "resource.h"
#include "saio.h"
#include "..\inc\virtual.h"

#define WIDTH(rect)             (rect.right - rect.left)
#define HEIGHT(rect)            (rect.bottom - rect.top)
#define WINDOW_SIZE_FACTOR      3
#define Align(p, x)             (((x) & ((p)-1)) ? (((x) & ~((p)-1)) + p) : (x))

CRITICAL_SECTION WindowLock;
HANDLE ReadyEvent;
SA_DISPLAY_CAPS DisplayCaps;
HWND hwndMain;
HBITMAP hBitmap;
PUCHAR DisplayBufferTmp;
UCHAR DisplayBuffer[8192];
ULONG DisplayBufferWidth;
ULONG DisplayBufferHeight;
HANDLE hFileKeypad;



void
dprintf(
    PSTR Format,
    ...
    )
{
    char buf[512];
    va_list arg_ptr;
    PSTR s = buf;


    va_start(arg_ptr, Format);

    _vsnprintf( s, sizeof(buf), Format, arg_ptr );
    s += strlen(s);

    OutputDebugStringA( buf );
}


HANDLE
OpenSaDevice(
    ULONG DeviceType
    )
{
    HANDLE hDevice;
    WCHAR buf[128];


    wcscpy( buf, L"\\\\?\\GLOBALROOT" );

    switch (DeviceType) {
        case SA_DEVICE_DISPLAY:
            wcscat( buf, SA_DEVICE_DISPLAY_NAME_STRING );
            break;

        case SA_DEVICE_KEYPAD:
            wcscat( buf, SA_DEVICE_KEYPAD_NAME_STRING );
            break;

        case SA_DEVICE_NVRAM:
            wcscat( buf, SA_DEVICE_NVRAM_NAME_STRING );
            break;

    }

    hDevice = CreateFileW(
        buf,
        GENERIC_READ | GENERIC_WRITE,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        0,
        NULL
        );

    if (hDevice == INVALID_HANDLE_VALUE) {
        dprintf( "CreateFile failed [%ws], ec=%d\n", buf, GetLastError() );
    }

    return hDevice;
}


void
CenterWindow (
    IN  HWND hwnd,
    IN  HWND Parent
    )
{
    RECT WndRect, ParentRect;
    int x, y;

    if (!Parent) {
        ParentRect.left = 0;
        ParentRect.top  = 0;
        ParentRect.right = GetSystemMetrics (SM_CXFULLSCREEN);
        ParentRect.bottom = GetSystemMetrics (SM_CYFULLSCREEN);
    } else {
        GetWindowRect (Parent, &ParentRect);
    }

    GetWindowRect (hwnd, &WndRect);

    x = ParentRect.left + (WIDTH(ParentRect) - WIDTH(WndRect)) / 2;
    y = ParentRect.top + (HEIGHT(ParentRect) - HEIGHT(WndRect)) / 2;

    SetWindowPos (hwnd, NULL, x, y, 0, 0, SWP_NOZORDER|SWP_NOSIZE);
}


void
ConvertBottomLeft2TopLeft(
    PUCHAR Bits,
    ULONG Width,
    ULONG Height
    )
{
    ULONG Row;
    ULONG Col;
    ULONG Size;
    ULONG i;
    UCHAR Temp;

    Size = (Width * Height) >> 3;

    for (i = 0; i < Size; i++) {
        Bits[i] = ~Bits[i];
    }

    Width = Width >> 3;

    for (Row = 0; Row < (Height / 2); Row++) {
        for (Col = 0; Col < Width; Col++) {
            Temp = Bits[Row * Width + Col];
            Bits[Row * Width + Col] = Bits[(Height - Row - 1) * Width + Col];
            Bits[(Height - Row - 1) * Width + Col] = Temp;
        }
    }
}


DWORD
UpdateBitmap(
    HWND hwnd
    )
{
    DWORD ec;
    HDC hdc;
    HDC hdcTemp;
    UCHAR BmiBuf[sizeof(BITMAPINFO)+sizeof(RGBQUAD)];
    PBITMAPINFO Bmi = (PBITMAPINFO)BmiBuf;
    PUCHAR Bits;
    int lines;


    if (hBitmap) {
        DeleteObject( hBitmap );
    }

    hdc = GetDC( hwnd );
    hdcTemp = CreateCompatibleDC( hdc );

    SetMapMode( hdcTemp, MM_TEXT );

    memset( BmiBuf, 0, sizeof(BmiBuf) );

    Bmi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
    Bmi->bmiHeader.biWidth = DisplayCaps.DisplayWidth*3;
    Bmi->bmiHeader.biHeight = DisplayCaps.DisplayHeight*3;
    Bmi->bmiHeader.biPlanes = 1;
    Bmi->bmiHeader.biBitCount = 1;
    Bmi->bmiHeader.biCompression = BI_RGB;

    Bmi->bmiColors[0].rgbBlue = 0;
    Bmi->bmiColors[0].rgbGreen = 0;
    Bmi->bmiColors[0].rgbRed = 0;

    Bmi->bmiColors[1].rgbBlue = 0xff;
    Bmi->bmiColors[1].rgbGreen = 0xff;
    Bmi->bmiColors[1].rgbRed = 0xff;

    hBitmap = CreateDIBSection(
        hdcTemp,
        Bmi,
        DIB_RGB_COLORS,
        (void**)&Bits,
        NULL,
        0
        );
    if (hBitmap == NULL) {
        ec = GetLastError();
        return ec;
    }

    SelectObject( hdcTemp, hBitmap );

    Bmi->bmiHeader.biWidth = DisplayCaps.DisplayWidth;
    Bmi->bmiHeader.biHeight = DisplayCaps.DisplayHeight;

    ConvertBottomLeft2TopLeft( DisplayBuffer, DisplayCaps.DisplayWidth, DisplayCaps.DisplayHeight );

    lines = StretchDIBits(
        hdcTemp,
        0,
        0,
        DisplayCaps.DisplayWidth*WINDOW_SIZE_FACTOR,
        DisplayCaps.DisplayHeight*WINDOW_SIZE_FACTOR,
        0,
        0,
        DisplayCaps.DisplayWidth,
        DisplayCaps.DisplayHeight,
        DisplayBuffer,
        Bmi,
        DIB_RGB_COLORS,
        SRCCOPY
        );
    if (lines == GDI_ERROR) {
        ec = GetLastError();
        return ec;
    }

    GdiFlush();

    DeleteDC( hdcTemp );
    ReleaseDC( hwnd, hdc );

    PostMessage( GetDlgItem(hwnd,IDC_BITMAP), STM_SETIMAGE, IMAGE_BITMAP, (LPARAM)hBitmap );

    return 0;
}


INT_PTR CALLBACK
MsGuiWndProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    PAINTSTRUCT ps;
    BOOL b;
    HDC hdc;
    BITMAP BitMap;
    HBITMAP hBitMap;
    HBITMAP hBitMapBig;
    BITMAPINFO Bmi;
    HDC hdcTemp;
    HDC hdcBig;
    RECT Rect;
    int lines;
    DWORD ec;
    UCHAR Keypress;
    ULONG Bytes;


    switch (message) {
        case WM_CREATE:
            return 0;

        case WM_INITDIALOG:
            CenterWindow( hwnd, NULL );
            return 1;

        case WM_USER:
            UpdateBitmap( hwnd );
            return 0;

        case WM_COMMAND:
            switch (wParam) {
                case IDC_ESCAPE:
                    Keypress = SA_KEYPAD_CANCEL;
                    break;

                case IDC_ENTER:
                    Keypress = SA_KEYPAD_SELECT;
                    break;

                case IDC_LEFT:
                    Keypress = SA_KEYPAD_LEFT;
                    break;

                case IDC_RIGHT:
                    Keypress = SA_KEYPAD_RIGHT;
                    break;

                case IDC_UP:
                    Keypress = SA_KEYPAD_UP;
                    break;

                case IDC_DOWN:
                    Keypress = SA_KEYPAD_DOWN;
                    break;

                default:
                    Keypress = 0;
                    break;
            }

            if (Keypress) {
                b = DeviceIoControl(
                    hFileKeypad,
                    IOCTL_VDRIVER_INIT,
                    &Keypress,
                    sizeof(UCHAR),
                    NULL,
                    0,
                    &Bytes,
                    NULL
                    );
                if (!b) {
                    OutputDebugString( L"IOCTL_VDRIVER_INIT failed\n" );
                    ExitProcess( 0 );
                }
            }
            return 0;

        case WM_DESTROY:
            PostQuitMessage( 0 );
            return 0;
    }

    return DefWindowProc( hwnd, message, wParam, lParam );
}


DWORD
DisplayBufferThread(
    PVOID pv
    )
{
    HANDLE hFile;
    MSDISP_BUFFER_DATA BufferData;
    BOOL b;
    ULONG Bytes;
    HANDLE hEvent;



    hFile = OpenSaDevice(
        SA_DEVICE_DISPLAY
        );
    if (hFile == INVALID_HANDLE_VALUE) {
        OutputDebugString( L"OpenSaDevice failed\n" );
        ExitProcess( 0 );
    }

    DisplayCaps.SizeOfStruct = sizeof(SA_DISPLAY_CAPS);
    b = DeviceIoControl(
        hFile,
        IOCTL_SA_GET_CAPABILITIES,
        NULL,
        0,
        &DisplayCaps,
        sizeof(SA_DISPLAY_CAPS),
        &Bytes,
        NULL
        );
    if (!b) {
        OutputDebugString( L"IOCTL_SA_GET_CAPABILITIES failed\n" );
        ExitProcess( 0 );
    }

    BufferData.DisplayBuffer = NULL;
    BufferData.DisplayBufferLength = 0;

    b = DeviceIoControl(
        hFile,
        IOCTL_VDRIVER_INIT,
        NULL,
        0,
        &BufferData,
        sizeof(BufferData),
        &Bytes,
        NULL
        );
    if (!b) {
        OutputDebugString( L"IOCTL_MSDISP_INIT failed\n" );
        ExitProcess( 0 );
    }

    DisplayBufferTmp = (PUCHAR)BufferData.DisplayBuffer;

    hEvent = CreateEvent( NULL, FALSE, FALSE, MSDISP_EVENT_NAME );
    if (hEvent == NULL) {
        OutputDebugString( L"OpenEvent failed\n" );
        ExitProcess( 0 );
    }

    SetEvent( ReadyEvent );

    while (TRUE) {
        WaitForSingleObject( hEvent, INFINITE );
        EnterCriticalSection( &WindowLock );
        memcpy( DisplayBuffer, DisplayBufferTmp, (DisplayCaps.DisplayWidth/8)*DisplayCaps.DisplayHeight );
        LeaveCriticalSection( &WindowLock );
        PostMessage( hwndMain, WM_USER, 0, 0 );
    }

    return 0;
}


int
__cdecl
wmain(
    int argc,
    WCHAR *argv[]
    )
{
    HWND           hwnd;
    MSG            msg;
    WNDCLASS       wndclass;
    HINSTANCE      hInst;
    HANDLE         hThread;


    hInst = GetModuleHandle( NULL );
    InitializeCriticalSection( &WindowLock );
    ReadyEvent = CreateEvent( NULL, FALSE, FALSE, NULL );
    if (ReadyEvent == NULL) {
        OutputDebugString( L"CreateEvent failed\n" );
        return -1;
    }

    hFileKeypad = OpenSaDevice(
        SA_DEVICE_KEYPAD
        );
    if (hFileKeypad == INVALID_HANDLE_VALUE) {
        OutputDebugString( L"OpenSaDevice failed\n" );
        return -1;
    }

    hThread = CreateThread(
        NULL,
        0,
        DisplayBufferThread,
        NULL,
        0,
        NULL
        );
    if (hThread == NULL) {
        OutputDebugString( L"CreateThread failed\n" );
        return -1;
    }

    WaitForSingleObject( ReadyEvent, INFINITE );

    hInst                   = GetModuleHandle( NULL );
    wndclass.style          = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc    = (WNDPROC)MsGuiWndProc;
    wndclass.cbClsExtra     = 0;
    wndclass.cbWndExtra     = DLGWINDOWEXTRA;
    wndclass.hInstance      = hInst;
    wndclass.hIcon          = LoadIcon( hInst, MAKEINTRESOURCE(APPICON) );
    wndclass.hCursor        = LoadCursor( NULL, IDC_ARROW );
    wndclass.hbrBackground  = (HBRUSH) (COLOR_3DFACE + 1);
    wndclass.lpszMenuName   = NULL;
    wndclass.lpszClassName  = L"SaDialog";
    RegisterClass( &wndclass );

    hwnd = CreateDialog(
        hInst,
        MAKEINTRESOURCE(IDD_DIALOG),
        0,
        MsGuiWndProc
        );

    hwndMain = hwnd;

    ShowWindow( hwnd, SW_SHOWNORMAL );

    while (GetMessage (&msg, NULL, 0, 0)) {
        if (!IsDialogMessage( hwnd, &msg )) {
            TranslateMessage (&msg) ;
            DispatchMessage (&msg) ;
        }
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serveravailability\ddk\inc\virtual.h ===
/*++

Copyright (c) 1991 - 2002 Microsoft Corporation

Module Name:

    ##  ## #### #####  ###### ##  ##   ###   ##       ##   ##
    ##  ##  ##  ##  ##   ##   ##  ##   ###   ##       ##   ##
    ##  ##  ##  ##  ##   ##   ##  ##  ## ##  ##       ##   ##
     ####   ##  #####    ##   ##  ##  ## ##  ##       #######
     ####   ##  ####     ##   ##  ## ####### ##       ##   ##
      ##    ##  ## ##    ##   ##  ## ##   ## ##    ## ##   ##
      ##   #### ##  ##   ##    ####  ##   ## ##### ## ##   ##

Abstract:

    This header file contains the definitions for the
    user mode to kernel mode interface for the
    Microsoft virtual display driver.

@@BEGIN_DDKSPLIT
Author:

    Wesley Witt (wesw) 1-Oct-2001

@@END_DDKSPLIT
Environment:

    Kernel mode only.

Notes:

--*/

#define FUNC_VDRIVER_INIT                   (FUNC_SA_LAST)
#define IOCTL_VDRIVER_INIT                  SA_IOCTL(FUNC_VDRIVER_INIT)

#define MSDISP_EVENT_NAME                   L"MsDispEvent"
#define MSKEYPAD_EVENT_NAME                 L"MsKeypadEvent"

typedef struct _MSDISP_BUFFER_DATA {
    PVOID       DisplayBuffer;
    ULONG       DisplayBufferLength;
} MSDISP_BUFFER_DATA, *PMSDISP_BUFFER_DATA;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serveravailability\ddk\keypad\mskeypad.cpp ===
/*++

Copyright (c) 1991 - 2002 Microsoft Corporation

Module Name:

    ##    ##  ###  ##  ## ##### ##  ## #####    ###   #####       ####  #####  #####
    ###  ### ##  # ## ##  ##    ##  ## ##  ##   ###   ##  ##     ##   # ##  ## ##  ##
    ######## ###   ####   ##     ####  ##  ##  ## ##  ##   ##    ##     ##  ## ##  ##
    # ### ##  ###  ###    #####  ####  ##  ##  ## ##  ##   ##    ##     ##  ## ##  ##
    #  #  ##   ### ####   ##      ##   #####  ####### ##   ##    ##     #####  #####
    #     ## #  ## ## ##  ##      ##   ##     ##   ## ##  ##  ## ##   # ##     ##
    #     ##  ###  ##  ## #####   ##   ##     ##   ## #####   ##  ####  ##     ##

Abstract:

    This module contains the entire implementation of
    the virtual keypad miniport driver.

@@BEGIN_DDKSPLIT
Author:

    Wesley Witt (wesw) 1-Oct-2001

@@END_DDKSPLIT
Environment:

    Kernel mode only.

Notes:


--*/

#include "mskeypad.h"


#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,DriverEntry)
#endif





VOID
MsKeypadCancelRoutine(
    IN PVOID DeviceExtensionIn,
    IN PIRP Irp,
    IN BOOLEAN CurrentIo
    )

/*++

Routine Description:

    This function is the miniport's IRP cancel routine.

Arguments:

    DeviceExtension - Pointer to the mini-port's device extension.
    CurrentIo       - TRUE if this is called for the current I/O

Return Value:

    None.

--*/

{
    PDEVICE_EXTENSION DeviceExtension = (PDEVICE_EXTENSION)DeviceExtensionIn;
    KIRQL OldIrql;
    if (CurrentIo) {
        KeAcquireSpinLock( &DeviceExtension->DeviceLock, &OldIrql );
        DeviceExtension->Keypress = 0;
        DeviceExtension->DataBuffer = NULL;
        KeReleaseSpinLock( &DeviceExtension->DeviceLock, OldIrql );
    }
}


NTSTATUS
MsKeypadRead(
    IN PVOID DeviceExtensionIn,
    IN PIRP Irp,
    IN PVOID FsContext,
    IN LONGLONG StartingOffset,
    IN PVOID DataBuffer,
    IN ULONG DataBufferLength
    )

/*++

Routine Description:

   This routine processes the read requests for the local display miniport.

Arguments:

   DeviceExtensionIn    - Miniport's device extension
   StartingOffset       - Starting offset for the I/O
   DataBuffer           - Pointer to the data buffer
   DataBufferLength     - Length of the data buffer in bytes

Return Value:

   NT status code.

--*/

{
    PDEVICE_EXTENSION DeviceExtension = (PDEVICE_EXTENSION)DeviceExtensionIn;
    KIRQL OldIrql;
    KeAcquireSpinLock( &DeviceExtension->DeviceLock, &OldIrql );
    if (DeviceExtension->Keypress) {
        *((PUCHAR)DataBuffer) = DeviceExtension->Keypress;
        KeReleaseSpinLock( &DeviceExtension->DeviceLock, OldIrql );
        return STATUS_SUCCESS;
    }
    DeviceExtension->DataBuffer = (PUCHAR) DataBuffer;
    KeReleaseSpinLock( &DeviceExtension->DeviceLock, OldIrql );
    return STATUS_PENDING;
}


NTSTATUS
MsKeypadDeviceIoctl(
    IN PVOID DeviceExtensionIn,
    IN PIRP Irp,
    IN PVOID FsContext,
    IN ULONG FunctionCode,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength,
    IN PVOID OutputBuffer,
    IN ULONG OutputBufferLength
    )

/*++

Routine Description:

    This function is called by the SAPORT driver so that
    the mini-port driver can service an IOCTL call.

Arguments:

    DeviceExtension     - A pointer to the mini-port's device extension
    FunctionCode        - The IOCTL function code
    InputBuffer         - Pointer to the input buffer, contains the data sent down by the I/O
    InputBufferLength   - Length in bytes of the InputBuffer
    OutputBuffer        - Pointer to the output buffer, contains the data generated by this call
    OutputBufferLength  - Length in bytes of the OutputBuffer

Context:

    IRQL: IRQL PASSIVE_LEVEL, arbitrary thread context

Return Value:

    If the function succeeds, it must return STATUS_SUCCESS.
    Otherwise, it must return one of the error status values defined in ntstatus.h.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PDEVICE_EXTENSION DeviceExtension = (PDEVICE_EXTENSION)DeviceExtensionIn;
    KIRQL OldIrql;


    switch (FunctionCode) {
        case FUNC_SA_GET_VERSION:
            *((PULONG)OutputBuffer) = SA_INTERFACE_VERSION;
            break;

        case FUNC_VDRIVER_INIT:
            if (InputBufferLength != sizeof(UCHAR) || InputBuffer == NULL) {
                return STATUS_BUFFER_TOO_SMALL;
            }
            KeAcquireSpinLock( &DeviceExtension->DeviceLock, &OldIrql );
            if (DeviceExtension->DataBuffer) {
                DeviceExtension->Keypress = *((PUCHAR)InputBuffer);
                DeviceExtension->DataBuffer[0] = DeviceExtension->Keypress;
                DeviceExtension->DataBuffer = NULL;
                KeReleaseSpinLock( &DeviceExtension->DeviceLock, OldIrql );
                SaPortCompleteRequest( DeviceExtension, NULL, sizeof(UCHAR), STATUS_SUCCESS, TRUE );
                KeAcquireSpinLock( &DeviceExtension->DeviceLock, &OldIrql );
                DeviceExtension->Keypress = 0;
            }
            KeReleaseSpinLock( &DeviceExtension->DeviceLock, OldIrql );
            break;

        default:
            Status = STATUS_NOT_SUPPORTED;
            REPORT_ERROR( SA_DEVICE_KEYPAD, "Unsupported device control", Status );
            break;
    }

    return Status;
}


NTSTATUS
MsKeypadHwInitialize(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID DeviceExtensionIn,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR PartialResources,
    IN ULONG PartialResourceCount
    )

/*++

Routine Description:

    This function is called by the SAPORT driver so that
    the mini-port driver can initialize it's hardware
    resources.

Arguments:

    DeviceObject            - Pointer to the target device object.
    Irp                     - Pointer to an IRP structure that describes the requested I/O operation.
    DeviceExtension         - A pointer to the mini-port's device extension.
    PartialResources        - Pointer to the translated resources alloacted by the system.
    PartialResourceCount    - The number of resources in the PartialResources array.

Context:

    IRQL: IRQL PASSIVE_LEVEL, system thread context

Return Value:

    If the function succeeds, it must return STATUS_SUCCESS.
    Otherwise, it must return one of the error status values defined in ntstatus.h.

--*/

{
    PDEVICE_EXTENSION DeviceExtension = (PDEVICE_EXTENSION) DeviceExtensionIn;
    KeInitializeSpinLock( &DeviceExtension->DeviceLock );
    return STATUS_SUCCESS;
}


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This routine is the driver's entry point, called by the I/O system
    to load the driver.  The driver's entry points are initialized and
    a spin lock to control paging is initialized.

    In DBG mode, this routine also examines the registry for special
    debug parameters.

Arguments:

    DriverObject - a pointer to the object that represents this device driver.
    RegistryPath - a pointer to this driver's key in the Services tree.

Return Value:

    STATUS_SUCCESS

--*/

{
    NTSTATUS Status;
    SAPORT_INITIALIZATION_DATA SaPortInitData;


    RtlZeroMemory( &SaPortInitData, sizeof(SAPORT_INITIALIZATION_DATA) );

    SaPortInitData.StructSize = sizeof(SAPORT_INITIALIZATION_DATA);
    SaPortInitData.DeviceType = SA_DEVICE_KEYPAD;
    SaPortInitData.HwInitialize = MsKeypadHwInitialize;
    SaPortInitData.DeviceIoctl = MsKeypadDeviceIoctl;
    SaPortInitData.Read = MsKeypadRead;
    SaPortInitData.CancelRoutine = MsKeypadCancelRoutine;

    SaPortInitData.DeviceExtensionSize = sizeof(DEVICE_EXTENSION);

    Status = SaPortInitialize( DriverObject, RegistryPath, &SaPortInitData );
    if (!NT_SUCCESS(Status)) {
        REPORT_ERROR( SA_DEVICE_KEYPAD, "SaPortInitialize failed\n", Status );
        return Status;
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serveravailability\ddk\nvram\msnvram.h ===
/*++

Copyright (c) 1991 - 2002 Microsoft Corporation

Module Name:

    ##    ##  ###  ##   # ##  ## #####    ###   ##    ##    ##   ##
    ###  ### ##  # ###  # ##  ## ##  ##   ###   ###  ###    ##   ##
    ######## ###   #### # ##  ## ##  ##  ## ##  ########    ##   ##
    # ### ##  ###  # ####  ####  #####   ## ##  # ### ##    #######
    #  #  ##   ### #  ###  ####  ####   ####### #  #  ##    ##   ##
    #     ## #  ## #   ##   ##   ## ##  ##   ## #     ## ## ##   ##
    #     ##  ###  #    #   ##   ##  ## ##   ## #     ## ## ##   ##

Abstract:

    This header file contains the definitions for the
    virtual NVRAM miniport driver.

@@BEGIN_DDKSPLIT
Author:

    Wesley Witt (wesw) 1-Oct-2001

@@END_DDKSPLIT
Environment:

    Kernel mode only.

Notes:


--*/

extern "C" {
#include <ntddk.h>
#include <stdio.h>
}


#define MINIPORT_DEVICE_TYPE    SA_DEVICE_NVRAM

#include "saport.h"



#define MAX_NVRAM_SIZE          32
#define MAX_NVRAM_SIZE_BYTES    (MAX_NVRAM_SIZE*sizeof(ULONG))


typedef struct _DEVICE_EXTENSION {
    PDEVICE_OBJECT      DeviceObject;
} DEVICE_EXTENSION, *PDEVICE_EXTENSION;


typedef struct _MSNVRAM_WORK_ITEM {
    PDEVICE_EXTENSION   DeviceExtension;
    PIO_WORKITEM        WorkItem;
    ULONG               IoFunction;
    PVOID               DataBuffer;
    ULONG               DataBufferLength;
    LONGLONG            StartingOffset;
} MSNVRAM_WORK_ITEM, *PMSNVRAM_WORK_ITEM;





//
// prototypes
//

extern "C" {

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

} // extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serveravailability\ddk\watchdog\mswd.h ===
/*++

Copyright (c) 1991 - 2002 Microsoft Corporation

Module Name:

    ##    ##  ###  ##  #  ## #####      ##   ##
    ###  ### ##  # ## ### ## ##  ##     ##   ##
    ######## ###   ## ### ## ##   ##    ##   ##
    # ### ##  ###  ## # # ## ##   ##    #######
    #  #  ##   ###  ### ###  ##   ##    ##   ##
    #     ## #  ##  ### ###  ##  ##  ## ##   ##
    #     ##  ###   ##   ##  #####   ## ##   ##

@@BEGIN_DDKSPLIT
Abstract:

    This header file contains the definitions for the
    virtual watchdog miniport driver.

@@END_DDKSPLIT
Author:

    Wesley Witt (wesw) 1-Oct-2001

Environment:

    Kernel mode only.

Notes:


--*/

extern "C" {
#include <ntddk.h>
#include <stdio.h>
}

#define DEFAULT_WD_TIMEOUT_SECS (2*60)

#define SecToNano(_sec)         ((_sec) * 1000 * 1000 * 10)
#define NanoToSec(_nano)        ((_nano) / (1000 * 1000 * 10))


#define MINIPORT_DEVICE_TYPE    SA_DEVICE_WATCHDOG

#include "saport.h"

typedef struct _DEVICE_EXTENSION {
    PDEVICE_OBJECT  DeviceObject;
    FAST_MUTEX      WdIoLock;
    ULONG           Enabled;
    ULONG           ExpireBehavior;
    KTIMER          Timer;
    KDPC            TimerDpc;
    LARGE_INTEGER   StartTime;
    LARGE_INTEGER   TimeoutValue;
} DEVICE_EXTENSION, *PDEVICE_EXTENSION;


//
// prototypes
//

extern "C" {

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

} // extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serveravailability\ddk\nvram\msnvram.cpp ===
/*++

Copyright (c) 1991 - 2002 Microsoft Corporation

Module Name:

    ##    ##  ###  ##   # ##  ## #####    ###   ##    ##     ####  #####  #####
    ###  ### ##  # ###  # ##  ## ##  ##   ###   ###  ###    ##   # ##  ## ##  ##
    ######## ###   #### # ##  ## ##  ##  ## ##  ########    ##     ##  ## ##  ##
    # ### ##  ###  # ####  ####  #####   ## ##  # ### ##    ##     ##  ## ##  ##
    #  #  ##   ### #  ###  ####  ####   ####### #  #  ##    ##     #####  #####
    #     ## #  ## #   ##   ##   ## ##  ##   ## #     ## ## ##   # ##     ##
    #     ##  ###  #    #   ##   ##  ## ##   ## #     ## ##  ####  ##     ##

Abstract:

    This module contains the entire implementation of
    the virtual NVRAM miniport.

@@BEGIN_DDKSPLIT
Author:

    Wesley Witt (wesw) 1-Oct-2001

@@END_DDKSPLIT
Environment:

    Kernel mode only.

Notes:

--*/

#include "msnvram.h"


#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,DriverEntry)
#endif


NTSTATUS
ReadNvramData(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN OUT PUCHAR *NvramDataBuffer,
    IN OUT PULONG NvramDataBufferLength
    )
{
    NTSTATUS Status;


    *NvramDataBuffer = NULL;
    *NvramDataBufferLength = 0;

    Status = SaPortReadBinaryRegistryValue(
        DeviceExtension,
        L"NvramData",
        NULL,
        NvramDataBufferLength
        );
    if (Status != STATUS_BUFFER_TOO_SMALL) {
        REPORT_ERROR( SA_DEVICE_NVRAM, "SaPortReadBinaryRegistryValue failed", Status );
        goto exit;
    }

    *NvramDataBuffer = (PUCHAR) SaPortAllocatePool( DeviceExtension, *NvramDataBufferLength );
    if (*NvramDataBuffer == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        REPORT_ERROR( SA_DEVICE_NVRAM, "Could not allocate pool for registry read", Status );
        goto exit;
    }

    Status = SaPortReadBinaryRegistryValue(
        DeviceExtension,
        L"NvramData",
        *NvramDataBuffer,
        NvramDataBufferLength
        );
    if (!NT_SUCCESS(Status)) {
        REPORT_ERROR( SA_DEVICE_NVRAM, "SaPortReadBinaryRegistryValue failed", Status );
        goto exit;
    }

    Status = STATUS_SUCCESS;

exit:

    return Status;
}


VOID
MsNvramIoWorker(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    )
{
    NTSTATUS Status;
    PMSNVRAM_WORK_ITEM WorkItem = (PMSNVRAM_WORK_ITEM) Context;
    PDEVICE_EXTENSION DeviceExtension = WorkItem->DeviceExtension;
    PUCHAR RegistryValue = NULL;
    ULONG RegistryValueLength = 0;
    PUCHAR DataPtr;


    if (WorkItem->IoFunction == IRP_MJ_READ) {

        Status = ReadNvramData(
            DeviceExtension,
            &RegistryValue,
            &RegistryValueLength
            );
        if (!NT_SUCCESS(Status)) {
            REPORT_ERROR( SA_DEVICE_NVRAM, "ReadNvramData failed", Status );
            goto exit;
        }

        if (WorkItem->StartingOffset > RegistryValueLength) {
            Status = STATUS_INVALID_PARAMETER_1;
            REPORT_ERROR( SA_DEVICE_NVRAM, "Starting offset is greater than the registry value data length", Status );
            goto exit;
        }

        if (WorkItem->DataBufferLength + WorkItem->StartingOffset > RegistryValueLength) {
            Status = STATUS_INVALID_PARAMETER_2;
            REPORT_ERROR( SA_DEVICE_NVRAM, "I/O request is past the valid data length", Status );
            goto exit;
        }

        DataPtr = RegistryValue + WorkItem->StartingOffset;
        RegistryValueLength = WorkItem->DataBufferLength;

        RtlCopyMemory( WorkItem->DataBuffer, DataPtr, RegistryValueLength  );

        Status = STATUS_SUCCESS;

    } else if (WorkItem->IoFunction == IRP_MJ_WRITE) {

        Status = ReadNvramData(
            DeviceExtension,
            &RegistryValue,
            &RegistryValueLength
            );
        if (!NT_SUCCESS(Status)) {
            if (RegistryValue != NULL) {
                SaPortFreePool( DeviceExtension, RegistryValue );
            }
            RegistryValueLength = MAX_NVRAM_SIZE_BYTES;
            RegistryValue = (PUCHAR) SaPortAllocatePool( DeviceExtension, RegistryValueLength );
            if (RegistryValue == NULL) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                REPORT_ERROR( SA_DEVICE_NVRAM, "Could not allocate pool for registry read", Status );
                goto exit;
            }
            RtlZeroMemory( RegistryValue, RegistryValueLength );
        }

        RtlCopyMemory( RegistryValue + WorkItem->StartingOffset, WorkItem->DataBuffer, WorkItem->DataBufferLength );

        Status = SaPortWriteBinaryRegistryValue(
            DeviceExtension,
            L"NvramData",
            RegistryValue,
            RegistryValueLength
            );

    }

exit:
    if (!NT_SUCCESS(Status)) {
        RegistryValueLength = 0;
    }
    if (RegistryValue != NULL) {
        SaPortFreePool( DeviceExtension, RegistryValue );
    }
    SaPortCompleteRequest( DeviceExtension, NULL, RegistryValueLength, Status, FALSE );
    IoFreeWorkItem( WorkItem->WorkItem );
    SaPortFreePool( DeviceExtension, WorkItem );
}


NTSTATUS
MsNvramRead(
    IN PVOID DeviceExtensionIn,
    IN PIRP Irp,
    IN PVOID FsContext,
    IN LONGLONG StartingOffset,
    IN PVOID DataBuffer,
    IN ULONG DataBufferLength
    )

/*++

Routine Description:

   This routine processes the read requests for the local display miniport.

Arguments:

   DeviceExtensionIn    - Miniport's device extension
   StartingOffset       - Starting offset for the I/O
   DataBuffer           - Pointer to the data buffer
   DataBufferLength     - Length of the data buffer in bytes

Return Value:

   NT status code.

--*/

{
    PDEVICE_EXTENSION DeviceExtension = (PDEVICE_EXTENSION) DeviceExtensionIn;
    PMSNVRAM_WORK_ITEM WorkItem;


    WorkItem = (PMSNVRAM_WORK_ITEM) SaPortAllocatePool( DeviceExtension, sizeof(MSNVRAM_WORK_ITEM) );
    if (WorkItem == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    WorkItem->WorkItem = IoAllocateWorkItem( DeviceExtension->DeviceObject );
    if (WorkItem->WorkItem == NULL) {
        SaPortFreePool( DeviceExtension, WorkItem );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    WorkItem->IoFunction = IRP_MJ_READ;
    WorkItem->DataBuffer = DataBuffer;
    WorkItem->DataBufferLength = DataBufferLength;
    WorkItem->StartingOffset = StartingOffset;
    WorkItem->DeviceExtension = DeviceExtension;

    IoQueueWorkItem( WorkItem->WorkItem, MsNvramIoWorker, DelayedWorkQueue, WorkItem );

    return STATUS_PENDING;
}


NTSTATUS
MsNvramWrite(
    IN PVOID DeviceExtensionIn,
    IN PIRP Irp,
    IN PVOID FsContext,
    IN LONGLONG StartingOffset,
    IN PVOID DataBuffer,
    IN ULONG DataBufferLength
    )

/*++

Routine Description:

   This routine processes the write requests for the local display miniport.

Arguments:

   DeviceExtensionIn    - Miniport's device extension
   StartingOffset       - Starting offset for the I/O
   DataBuffer           - Pointer to the data buffer
   DataBufferLength     - Length of the data buffer in bytes

Return Value:

   NT status code.

--*/

{
    PDEVICE_EXTENSION DeviceExtension = (PDEVICE_EXTENSION) DeviceExtensionIn;
    PMSNVRAM_WORK_ITEM WorkItem;


    WorkItem = (PMSNVRAM_WORK_ITEM) SaPortAllocatePool( DeviceExtension, sizeof(MSNVRAM_WORK_ITEM) );
    if (WorkItem == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    WorkItem->WorkItem = IoAllocateWorkItem( DeviceExtension->DeviceObject );
    if (WorkItem->WorkItem == NULL) {
        SaPortFreePool( DeviceExtension, WorkItem );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    WorkItem->IoFunction = IRP_MJ_WRITE;
    WorkItem->DataBuffer = DataBuffer;
    WorkItem->DataBufferLength = DataBufferLength;
    WorkItem->StartingOffset = StartingOffset;
    WorkItem->DeviceExtension = DeviceExtension;

    IoQueueWorkItem( WorkItem->WorkItem, MsNvramIoWorker, DelayedWorkQueue, WorkItem );

    return STATUS_PENDING;
}


NTSTATUS
MsNvramDeviceIoctl(
    IN PVOID DeviceExtensionIn,
    IN PIRP Irp,
    IN PVOID FsContext,
    IN ULONG FunctionCode,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength,
    IN PVOID OutputBuffer,
    IN ULONG OutputBufferLength
    )

/*++

Routine Description:

    This function is called by the SAPORT driver so that
    the mini-port driver can service an IOCTL call.

Arguments:

    DeviceExtension     - A pointer to the mini-port's device extension
    FunctionCode        - The IOCTL function code
    InputBuffer         - Pointer to the input buffer, contains the data sent down by the I/O
    InputBufferLength   - Length in bytes of the InputBuffer
    OutputBuffer        - Pointer to the output buffer, contains the data generated by this call
    OutputBufferLength  - Length in bytes of the OutputBuffer

Context:

    IRQL: IRQL PASSIVE_LEVEL, arbitrary thread context

Return Value:

    If the function succeeds, it must return STATUS_SUCCESS.
    Otherwise, it must return one of the error status values defined in ntstatus.h.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PDEVICE_EXTENSION DeviceExtension = (PDEVICE_EXTENSION) DeviceExtensionIn;
    PSA_NVRAM_CAPS NvramCaps = NULL;


    switch (FunctionCode) {
        case FUNC_SA_GET_VERSION:
            *((PULONG)OutputBuffer) = SA_INTERFACE_VERSION;
            break;

        case FUNC_SA_GET_CAPABILITIES:
            NvramCaps = (PSA_NVRAM_CAPS)OutputBuffer;
            NvramCaps->SizeOfStruct = sizeof(SA_NVRAM_CAPS);
            NvramCaps->NvramSize = MAX_NVRAM_SIZE;
            break;

        default:
            Status = STATUS_NOT_SUPPORTED;
            REPORT_ERROR( SA_DEVICE_NVRAM, "Unsupported device control", Status );
            break;
    }

    return Status;
}


NTSTATUS
MsNvramHwInitialize(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID DeviceExtensionIn,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR PartialResources,
    IN ULONG PartialResourceCount
    )

/*++

Routine Description:

    This function is called by the SAPORT driver so that
    the mini-port driver can initialize it's hardware
    resources.

Arguments:

    DeviceObject            - Pointer to the target device object.
    Irp                     - Pointer to an IRP structure that describes the requested I/O operation.
    DeviceExtension         - A pointer to the mini-port's device extension.
    PartialResources        - Pointer to the translated resources alloacted by the system.
    PartialResourceCount    - The number of resources in the PartialResources array.

Context:

    IRQL: IRQL PASSIVE_LEVEL, system thread context

Return Value:

    If the function succeeds, it must return STATUS_SUCCESS.
    Otherwise, it must return one of the error status values defined in ntstatus.h.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PDEVICE_EXTENSION DeviceExtension = (PDEVICE_EXTENSION) DeviceExtensionIn;
    ULONG RegistryType;
    ULONG RegistryDataLength;
    PULONG NvramData = NULL;


    DeviceExtension->DeviceObject = DeviceObject;

    //
    // Ensure that the NVRAM store in the registry is actually good
    //

    Status = SaPortGetRegistryValueInformation(
        DeviceExtension,
        L"NvramData",
        &RegistryType,
        &RegistryDataLength
        );
    if ((!NT_SUCCESS(Status)) || RegistryType != REG_BINARY || RegistryDataLength != MAX_NVRAM_SIZE_BYTES) {

        Status = SaPortDeleteRegistryValue(
            DeviceExtension,
            L"NvramData"
            );
        if ((!NT_SUCCESS(Status)) && Status != STATUS_OBJECT_NAME_NOT_FOUND) {
            REPORT_ERROR( SA_DEVICE_NVRAM, "SaPortDeleteRegistryValue failed", Status );
            goto exit;
        }

        NvramData = (PULONG) SaPortAllocatePool( DeviceExtension, MAX_NVRAM_SIZE_BYTES );
        if (NvramData == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            REPORT_ERROR( SA_DEVICE_NVRAM, "Could not allocate pool for registry read", Status );
            goto exit;
        }

        RtlZeroMemory( NvramData, MAX_NVRAM_SIZE_BYTES );

        Status = SaPortWriteBinaryRegistryValue(
            DeviceExtension,
            L"NvramData",
            NvramData,
            MAX_NVRAM_SIZE_BYTES
            );
        if (!NT_SUCCESS(Status)) {
            REPORT_ERROR( SA_DEVICE_NVRAM, "SaPortWriteBinaryRegistryValue failed", Status );
            goto exit;
        }

    }

exit:

    if (NvramData != NULL) {
        SaPortFreePool( DeviceExtension, NvramData );
    }

    return Status;
}


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This routine is the driver's entry point, called by the I/O system
    to load the driver.  The driver's entry points are initialized and
    a mutex to control paging is initialized.

    In DBG mode, this routine also examines the registry for special
    debug parameters.

Arguments:

    DriverObject - a pointer to the object that represents this device driver.
    RegistryPath - a pointer to this driver's key in the Services tree.

Return Value:

    STATUS_SUCCESS

--*/

{
    NTSTATUS Status;
    SAPORT_INITIALIZATION_DATA SaPortInitData;


    RtlZeroMemory( &SaPortInitData, sizeof(SAPORT_INITIALIZATION_DATA) );

    SaPortInitData.StructSize = sizeof(SAPORT_INITIALIZATION_DATA);
    SaPortInitData.DeviceType = SA_DEVICE_NVRAM;
    SaPortInitData.HwInitialize = MsNvramHwInitialize;
    SaPortInitData.DeviceIoctl = MsNvramDeviceIoctl;
    SaPortInitData.Read = MsNvramRead;
    SaPortInitData.Write = MsNvramWrite;

    SaPortInitData.DeviceExtensionSize = sizeof(DEVICE_EXTENSION);

    Status = SaPortInitialize( DriverObject, RegistryPath, &SaPortInitData );
    if (!NT_SUCCESS(Status)) {
        REPORT_ERROR( SA_DEVICE_NVRAM, "SaPortInitialize failed\n", Status );
        return Status;
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serveravailability\ddk\watchdog\mswd.cpp ===
/*++

Copyright (c) 1991 - 2002 Microsoft Corporation

Module Name:

    ##    ##  ###  ##  #  ## #####       ####  #####  #####
    ###  ### ##  # ## ### ## ##  ##     ##   # ##  ## ##  ##
    ######## ###   ## ### ## ##   ##    ##     ##  ## ##  ##
    # ### ##  ###  ## # # ## ##   ##    ##     ##  ## ##  ##
    #  #  ##   ###  ### ###  ##   ##    ##     #####  #####
    #     ## #  ##  ### ###  ##  ##  ## ##   # ##     ##
    #     ##  ###   ##   ##  #####   ##  ####  ##     ##

Abstract:

    This module contains the entire implementation of
    the virtual watchdog miniport driver.

@@BEGIN_DDKSPLIT
Author:

    Wesley Witt (wesw) 1-Oct-2001

@@END_DDKSPLIT
Environment:

    Kernel mode only.

Notes:


--*/

#include "mswd.h"


#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,DriverEntry)
#endif



VOID
MsWdTimerReset(
    IN PDEVICE_EXTENSION DeviceExtension
    )
{
    LARGE_INTEGER DueTime;
    KeQuerySystemTime( &DeviceExtension->StartTime );
    DueTime.QuadPart = DeviceExtension->TimeoutValue.QuadPart;
    KeSetTimer( &DeviceExtension->Timer, DueTime, &DeviceExtension->TimerDpc );
}


VOID
MsWdShutdownWorker(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    )
{
    PDEVICE_EXTENSION DeviceExtension = (PDEVICE_EXTENSION) Context;
    ULONG ExpireBehavior;


    ExAcquireFastMutex( &DeviceExtension->WdIoLock );
    ExpireBehavior = DeviceExtension->ExpireBehavior;
    ExReleaseFastMutex( &DeviceExtension->WdIoLock );

    SaPortShutdownSystem( ExpireBehavior == 1 );
}


VOID
MsWdTimerDpc(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
{
    PDEVICE_EXTENSION DeviceExtension = (PDEVICE_EXTENSION)DeferredContext;
    PIO_WORKITEM WorkItem;


    WorkItem = IoAllocateWorkItem( DeviceExtension->DeviceObject );
    if (WorkItem) {
        IoQueueWorkItem( WorkItem, MsWdShutdownWorker, DelayedWorkQueue, DeviceExtension );
    }
}


NTSTATUS
MsWdDeviceIoctl(
    IN PVOID DeviceExtensionIn,
    IN PIRP Irp,
    IN PVOID FsContext,
    IN ULONG FunctionCode,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength,
    IN PVOID OutputBuffer,
    IN ULONG OutputBufferLength
    )

/*++

Routine Description:

    This function is called by the SAPORT driver so that
    the mini-port driver can service an IOCTL call.

Arguments:

    DeviceExtension     - A pointer to the mini-port's device extension
    FunctionCode        - The IOCTL function code
    InputBuffer         - Pointer to the input buffer, contains the data sent down by the I/O
    InputBufferLength   - Length in bytes of the InputBuffer
    OutputBuffer        - Pointer to the output buffer, contains the data generated by this call
    OutputBufferLength  - Length in bytes of the OutputBuffer

Context:

    IRQL: IRQL PASSIVE_LEVEL, arbitrary thread context

Return Value:

    If the function succeeds, it must return STATUS_SUCCESS.
    Otherwise, it must return one of the error status values defined in ntstatus.h.

--*/

{
    PDEVICE_EXTENSION DeviceExtension = (PDEVICE_EXTENSION)DeviceExtensionIn;
    NTSTATUS Status = STATUS_SUCCESS;
    PSA_WD_CAPS WdCaps = NULL;
    LARGE_INTEGER CurrentTime;


    switch (FunctionCode) {
        case FUNC_SA_GET_VERSION:
            *((PULONG)OutputBuffer) = SA_INTERFACE_VERSION;
            break;

        case FUNC_SA_GET_CAPABILITIES:
            WdCaps = (PSA_WD_CAPS)OutputBuffer;
            WdCaps->SizeOfStruct = sizeof(SA_WD_CAPS);
            WdCaps->Minimum = 1;
            WdCaps->Maximum = 512;
            break;

        case FUNC_SAWD_DISABLE:
            ExAcquireFastMutex( &DeviceExtension->WdIoLock );
            if (*((PULONG)InputBuffer) == 1) {
                DeviceExtension->Enabled = 1;
                MsWdTimerReset( DeviceExtension );
            } else if (*((PULONG)InputBuffer) == 0) {
                DeviceExtension->Enabled = 0;
                KeCancelTimer( &DeviceExtension->Timer );
            } else {
                Status = STATUS_INVALID_PARAMETER_1;
            }
            ExReleaseFastMutex( &DeviceExtension->WdIoLock );
            break;

        case FUNC_SAWD_QUERY_EXPIRE_BEHAVIOR:
            ExAcquireFastMutex( &DeviceExtension->WdIoLock );
            *((PULONG)OutputBuffer) = DeviceExtension->ExpireBehavior;
            ExReleaseFastMutex( &DeviceExtension->WdIoLock );
            break;

        case FUNC_SAWD_SET_EXPIRE_BEHAVIOR:
            ExAcquireFastMutex( &DeviceExtension->WdIoLock );
            if (*((PULONG)InputBuffer) == 1) {
                DeviceExtension->ExpireBehavior = 1;
            } else {
                DeviceExtension->ExpireBehavior = 0;
            }
            ExReleaseFastMutex( &DeviceExtension->WdIoLock );
            break;

        case FUNC_SAWD_PING:
            ExAcquireFastMutex( &DeviceExtension->WdIoLock );
            MsWdTimerReset( DeviceExtension );
            ExReleaseFastMutex( &DeviceExtension->WdIoLock );
            break;

        case FUNC_SAWD_QUERY_TIMER:
            ExAcquireFastMutex( &DeviceExtension->WdIoLock );
            KeQuerySystemTime( &CurrentTime );
            CurrentTime.QuadPart = DeviceExtension->TimeoutValue.QuadPart - (CurrentTime.QuadPart - DeviceExtension->StartTime.QuadPart);
            *((PULONG)OutputBuffer) = (ULONG)NanoToSec( CurrentTime.QuadPart );
            ExReleaseFastMutex( &DeviceExtension->WdIoLock );
            break;

        case FUNC_SAWD_SET_TIMER:
            ExAcquireFastMutex( &DeviceExtension->WdIoLock );
            DeviceExtension->TimeoutValue.QuadPart = (ULONGLONG)-SecToNano( *((PLONG)InputBuffer) );
            MsWdTimerReset( DeviceExtension );
            ExReleaseFastMutex( &DeviceExtension->WdIoLock );
            break;

        default:
            Status = STATUS_NOT_SUPPORTED;
            REPORT_ERROR( SA_DEVICE_WATCHDOG, "Unsupported device control", Status );
            break;
    }

    return Status;
}


NTSTATUS
MsWdHwInitialize(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID DeviceExtensionIn,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR PartialResources,
    IN ULONG PartialResourceCount
    )

/*++

Routine Description:

    This function is called by the SAPORT driver so that
    the mini-port driver can initialize it's hardware
    resources.

Arguments:

    DeviceObject            - Pointer to the target device object.
    Irp                     - Pointer to an IRP structure that describes the requested I/O operation.
    DeviceExtension         - A pointer to the mini-port's device extension.
    PartialResources        - Pointer to the translated resources alloacted by the system.
    PartialResourceCount    - The number of resources in the PartialResources array.

Context:

    IRQL: IRQL PASSIVE_LEVEL, system thread context

Return Value:

    If the function succeeds, it must return STATUS_SUCCESS.
    Otherwise, it must return one of the error status values defined in ntstatus.h.

--*/

{
    PDEVICE_EXTENSION DeviceExtension = (PDEVICE_EXTENSION) DeviceExtensionIn;


    DeviceExtension->DeviceObject = DeviceObject;
    ExInitializeFastMutex( &DeviceExtension->WdIoLock );
    KeInitializeTimer( &DeviceExtension->Timer );
    KeInitializeDpc( &DeviceExtension->TimerDpc, MsWdTimerDpc, DeviceExtension );
    DeviceExtension->TimeoutValue.QuadPart = -SecToNano(DEFAULT_WD_TIMEOUT_SECS);
    DeviceExtension->Enabled = 1;
    DeviceExtension->ExpireBehavior = 0;
    MsWdTimerReset( DeviceExtension );
    return STATUS_SUCCESS;
}


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This routine is the driver's entry point, called by the I/O system
    to load the driver.  The driver's entry points are initialized and
    a mutex to control paging is initialized.

    In DBG mode, this routine also examines the registry for special
    debug parameters.

Arguments:

    DriverObject - a pointer to the object that represents this device driver.
    RegistryPath - a pointer to this driver's key in the Services tree.

Return Value:

    STATUS_SUCCESS

--*/

{
    NTSTATUS Status;
    SAPORT_INITIALIZATION_DATA SaPortInitData;


    RtlZeroMemory( &SaPortInitData, sizeof(SAPORT_INITIALIZATION_DATA) );

    SaPortInitData.StructSize = sizeof(SAPORT_INITIALIZATION_DATA);
    SaPortInitData.DeviceType = SA_DEVICE_WATCHDOG;
    SaPortInitData.HwInitialize = MsWdHwInitialize;
    SaPortInitData.DeviceIoctl = MsWdDeviceIoctl;

    SaPortInitData.DeviceExtensionSize = sizeof(DEVICE_EXTENSION);

    Status = SaPortInitialize( DriverObject, RegistryPath, &SaPortInitData );
    if (!NT_SUCCESS(Status)) {
        REPORT_ERROR( SA_DEVICE_WATCHDOG, "SaPortInitialize failed\n", Status );
        return Status;
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serveravailability\ddk\keypad\mskeypad.h ===
/*++

Copyright (c) 1991 - 2002 Microsoft Corporation

Module Name:

    ##    ##  ###  ##  ## ##### ##  ## #####    ###   #####      ##   ##
    ###  ### ##  # ## ##  ##    ##  ## ##  ##   ###   ##  ##     ##   ##
    ######## ###   ####   ##     ####  ##  ##  ## ##  ##   ##    ##   ##
    # ### ##  ###  ###    #####  ####  ##  ##  ## ##  ##   ##    #######
    #  #  ##   ### ####   ##      ##   #####  ####### ##   ##    ##   ##
    #     ## #  ## ## ##  ##      ##   ##     ##   ## ##  ##  ## ##   ##
    #     ##  ###  ##  ## #####   ##   ##     ##   ## #####   ## ##   ##

Abstract:

    The module is the header file for the virtual
    keypad miniport device driver.

@@BEGIN_DDKSPLIT
Author:

    Wesley Witt (wesw) 1-Oct-2001

@@END_DDKSPLIT
Environment:

    Kernel mode only.

Notes:


--*/

extern "C" {
#include <ntddk.h>
#include <stdio.h>
}

#define MINIPORT_DEVICE_TYPE    SA_DEVICE_KEYPAD

#include "saport.h"
#include "..\inc\virtual.h"


typedef struct _DEVICE_EXTENSION {
    KSPIN_LOCK          DeviceLock;
    PUCHAR              DataBuffer;
    UCHAR               Keypress;
} DEVICE_EXTENSION, *PDEVICE_EXTENSION;


//
// prototypes
//

extern "C" {

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

} // extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serveravailability\saport\display.cpp ===
/*++

Copyright (c) 1991 - 2001 Microsoft Corporation

Module Name:

    #####   ####  ###  #####  ##      ###   ##  ##     ####  #####  #####
    ##  ##   ##  ##  # ##  ## ##      ###   ##  ##    ##   # ##  ## ##  ##
    ##   ##  ##  ###   ##  ## ##     ## ##   ####     ##     ##  ## ##  ##
    ##   ##  ##   ###  ##  ## ##     ## ##   ####     ##     ##  ## ##  ##
    ##   ##  ##    ### #####  ##    #######   ##      ##     #####  #####
    ##  ##   ##  #  ## ##     ##    ##   ##   ##   ## ##   # ##     ##
    #####   ####  ###  ##     ##### ##   ##   ##   ##  ####  ##     ##

Abstract:

    This module contains functions specfic to the
    display device.  The logic in this module is not
    hardware specific, but is logic that is common
    to all hardware implementations.

Author:

    Wesley Witt (wesw) 1-Oct-2001

Environment:

    Kernel mode only.

Notes:


--*/

#include "internal.h"

PDISPLAY_DEVICE_EXTENSION g_DeviceExtension = NULL;

NTSTATUS
DoBitmapDisplay(
    IN PDISPLAY_DEVICE_EXTENSION DeviceExtension,
    IN PVOID BitmapBits,
    IN ULONG MsgCode
    );

VOID
SaDisplayProcessNotifyRoutine(
    IN HANDLE ParentId,
    IN HANDLE ProcessId,
    IN BOOLEAN Create
    );


NTSTATUS
SaDisplayLoadBitmapFromRegistry(
    IN PDISPLAY_DEVICE_EXTENSION DeviceExtension,
    IN PUNICODE_STRING RegistryPath,
    IN PWSTR ValueName,
    IN OUT PVOID *DataBuffer
    )

/*++

Routine Description:

   This routine loads a bitmap resource from the registry.
   The bitmaps are loaded from the driver's parameters key.

Arguments:

   RegistryPath         - Full path to the driver's registry key
   ValueName            - Name of the value in the registry (also the bitmap name)
   DataBuffer           - Pointer to a pointer that is allocated by this function.
                          The allocated memory holds the bitmap's bits.

Return Value:

    NT status code.

--*/

{
    NTSTATUS status;
    PKEY_VALUE_FULL_INFORMATION KeyInformation = NULL;


    __try {

        status = ReadRegistryValue(
            DeviceExtension->DriverExtension,
            RegistryPath,
            ValueName,
            &KeyInformation
            );
        if (!NT_SUCCESS(status)) {
            ERROR_RETURN( DeviceExtension->DeviceType, "SaDisplayLoadBitmapFromRegistry could not read bitmap", status );
        }

        if (KeyInformation->Type != REG_BINARY) {
            status = STATUS_OBJECT_TYPE_MISMATCH;
            __leave;
        }

        *DataBuffer = ExAllocatePool( NonPagedPool, KeyInformation->DataLength );
        if (*DataBuffer == NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            ERROR_RETURN( DeviceExtension->DeviceType, "Could not allocate pool", status );
        }

        RtlCopyMemory( *DataBuffer, (PUCHAR)KeyInformation + KeyInformation->DataOffset, KeyInformation->DataLength );

        status = STATUS_SUCCESS;

    } __finally {

        if (KeyInformation) {
            ExFreePool( KeyInformation );
        }

        if (!NT_SUCCESS(status)) {
            if (*DataBuffer) {
                ExFreePool( *DataBuffer );
            }
        }

    }

    return status;
}


NTSTATUS
SaDisplayLoadAllBitmaps(
    IN PDISPLAY_DEVICE_EXTENSION DeviceExtension,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

   This routine loads all bitmap resources from the registry.

Arguments:

   DeviceExtension      - Display device extension
   RegistryPath         - Full path to the driver's registry key

Return Value:

    NT status code.

--*/

{
    NTSTATUS Status;
    PVOID StartingBitmap = NULL;
    PVOID CheckDiskBitmap = NULL;
    PVOID ReadyBitmap = NULL;
    PVOID ShutdownBitmap = NULL;
    PVOID UpdateBitmap = NULL;


    __try {

        ExAcquireFastMutex( &DeviceExtension->DisplayMutex );

        Status = SaDisplayLoadBitmapFromRegistry( DeviceExtension, RegistryPath, DISPLAY_STARTING_PARAM, &StartingBitmap );
        if (!NT_SUCCESS(Status)) {
            REPORT_ERROR( DeviceExtension->DeviceType, "Could not load starting bitmap", Status );
        }

        Status = SaDisplayLoadBitmapFromRegistry( DeviceExtension, RegistryPath, DISPLAY_CHECKDISK_PARAM, &CheckDiskBitmap );
        if (!NT_SUCCESS(Status)) {
            REPORT_ERROR( DeviceExtension->DeviceType, "Could not load check disk bitmap", Status );
        }

        Status = SaDisplayLoadBitmapFromRegistry( DeviceExtension, RegistryPath, DISPLAY_READY_PARAM, &ReadyBitmap );
        if (!NT_SUCCESS(Status)) {
            REPORT_ERROR( DeviceExtension->DeviceType, "Could not load ready bitmap", Status );
        }

        Status = SaDisplayLoadBitmapFromRegistry( DeviceExtension, RegistryPath, DISPLAY_SHUTDOWN_PARAM, &ShutdownBitmap );
        if (!NT_SUCCESS(Status)) {
            REPORT_ERROR( DeviceExtension->DeviceType, "Could not load shutdown bitmap", Status );
        }

        Status = SaDisplayLoadBitmapFromRegistry( DeviceExtension, RegistryPath, DISPLAY_UPDATE_PARAM, &UpdateBitmap );
        if (!NT_SUCCESS(Status)) {
            REPORT_ERROR( DeviceExtension->DeviceType, "Could not load update bitmap", Status );
        }

        Status = STATUS_SUCCESS;

        DeviceExtension->StartingBitmap = StartingBitmap;
        DeviceExtension->CheckDiskBitmap = CheckDiskBitmap;
        DeviceExtension->ReadyBitmap = ReadyBitmap;
        DeviceExtension->ShutdownBitmap = ShutdownBitmap;
        DeviceExtension->UpdateBitmap = UpdateBitmap;

    } __finally {

        if (!NT_SUCCESS(Status)) {
            if (StartingBitmap) {
                ExFreePool( StartingBitmap );
            }

            if (CheckDiskBitmap) {
                ExFreePool( CheckDiskBitmap );
            }

            if (ReadyBitmap) {
                ExFreePool( ReadyBitmap );
            }

            if (ShutdownBitmap) {
                ExFreePool( ShutdownBitmap );
            }

            if (UpdateBitmap) {
                ExFreePool( UpdateBitmap );
            }
        }

        ExReleaseFastMutex( &DeviceExtension->DisplayMutex );

    }

    return Status;
}

NTSTATUS
SaDisplayDisplayBitmap(
    IN PDISPLAY_DEVICE_EXTENSION DeviceExtension,
    IN PSA_DISPLAY_SHOW_MESSAGE Bitmap
    )

/*++

Routine Description:

   This routine calls the local display miniport to display a bitmap.

Arguments:

   DeviceExtension      - Display device extension
   Bitmap               - Pointer to a SA_DISPLAY_SHOW_MESSAGE structure

Return Value:

    NT status code.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;


    __try {

        if (DeviceExtension->DisplayType != SA_DISPLAY_TYPE_BIT_MAPPED_LCD) {
            Status = STATUS_INVALID_DEVICE_REQUEST;
            ERROR_RETURN( DeviceExtension->DeviceType, "The display does not support bitmapped LCD", Status );
        }

        Status = CallMiniPortDriverReadWrite(
            DeviceExtension,
            DeviceExtension->DeviceObject,
            TRUE,
            Bitmap,
            sizeof(SA_DISPLAY_SHOW_MESSAGE),
            0
            );
        if (!NT_SUCCESS(Status)) {
            ERROR_RETURN( DeviceExtension->DeviceType, "Could not display the bitmap", Status );
        }

    } __finally {

    }

    return Status;
}


NTSTATUS
SaDisplayClearDisplay(
    PDISPLAY_DEVICE_EXTENSION DeviceExtension
    )

/*++

Routine Description:

   This routine causes the local display to be cleared of any bitmap image.

Arguments:

   DeviceExtension   - Display device extension

Return Value:

    NT status code.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PSA_DISPLAY_SHOW_MESSAGE Bitmap = NULL;


    __try {

        if (DeviceExtension->DisplayType != SA_DISPLAY_TYPE_BIT_MAPPED_LCD) {
            Status = STATUS_INVALID_DEVICE_REQUEST;
            ERROR_RETURN( DeviceExtension->DeviceType, "The display does not support bitmapped LCD", Status );
        }

        Bitmap = (PSA_DISPLAY_SHOW_MESSAGE) ExAllocatePool( PagedPool, sizeof(SA_DISPLAY_SHOW_MESSAGE) );
        if (Bitmap == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            ERROR_RETURN( DeviceExtension->DeviceType, "Could not allocate pool", Status );
        }

        Bitmap->SizeOfStruct = sizeof(SA_DISPLAY_SHOW_MESSAGE);
        Bitmap->Width = DeviceExtension->DisplayWidth;
        Bitmap->Height = DeviceExtension->DisplayHeight;
        Bitmap->MsgCode = SA_DISPLAY_STARTING;

        RtlZeroMemory( Bitmap->Bits, SA_DISPLAY_MAX_BITMAP_SIZE );

        Status = SaDisplayDisplayBitmap( DeviceExtension, Bitmap );
        if (!NT_SUCCESS(Status)) {
            ERROR_RETURN( DeviceExtension->DeviceType, "Could not display bitmap", Status );
        }

    } __finally {

        if (Bitmap) {
            ExFreePool( Bitmap );
        }

    }

    return Status;
}


NTSTATUS
SaDisplayStartDevice(
    IN PDISPLAY_DEVICE_EXTENSION DeviceExtension
    )

/*++

Routine Description:

   This is the local display specific code for processing
   the PNP start device request.  The local display's
   capabilities are queried and then all the bitmap
   resources are loaded.

Arguments:

   DeviceExtension   - Display device extension

Return Value:

    NT status code.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    SA_DISPLAY_CAPS DisplayCaps;


    Status = CallMiniPortDriverDeviceControl(
        DeviceExtension,
        DeviceExtension->DeviceObject,
        IOCTL_SA_GET_CAPABILITIES,
        NULL,
        0,
        &DisplayCaps,
        sizeof(SA_DISPLAY_CAPS)
        );
    if (!NT_SUCCESS(Status)) {
        REPORT_ERROR( DeviceExtension->DeviceType, "Could not query miniport's capabilities", Status );
        return Status;
    }

    if (DisplayCaps.SizeOfStruct != sizeof(SA_DISPLAY_CAPS)) {
        REPORT_ERROR( DeviceExtension->DeviceType, "SA_DISPLAY_CAPS is the wrong size", STATUS_INVALID_BUFFER_SIZE );
        return STATUS_INVALID_BUFFER_SIZE;
    }

    DeviceExtension->DisplayType = DisplayCaps.DisplayType;
    DeviceExtension->DisplayHeight = DisplayCaps.DisplayHeight;
    DeviceExtension->DisplayWidth = DisplayCaps.DisplayWidth;


    Status = SaDisplayLoadAllBitmaps( DeviceExtension, &DeviceExtension->DriverExtension->RegistryPath );
    if (!NT_SUCCESS(Status)) {
        REPORT_ERROR( DeviceExtension->DeviceType, "Could not load all the bitmaps", Status );
        return Status;
    }

    Status = DoBitmapDisplay(
        (PDISPLAY_DEVICE_EXTENSION)DeviceExtension,
        ((PDISPLAY_DEVICE_EXTENSION)DeviceExtension)->StartingBitmap,
        SA_DISPLAY_STARTING
        );

    if (!NT_SUCCESS(Status)) {
        REPORT_ERROR( DeviceExtension->DeviceType, "Could not display starting bitmap", Status );
    }

    g_DeviceExtension = DeviceExtension;

    Status = PsSetCreateProcessNotifyRoutine(SaDisplayProcessNotifyRoutine,0);
    if (!NT_SUCCESS(Status)) {
        REPORT_ERROR( DeviceExtension->DeviceType, "Could not display starting bitmap", Status );
    }

    return STATUS_SUCCESS;
}

/*++

Routine Description:

   This is the local display specific code for processing
   notification of process creation and termination.
   Process name is retrieved and checkdisk bitmap is
   displayed if "autochk.exe" is running.

Arguments:

   HANDLE   - Handle to parent process
   HANDLE   - Handle to process
   BOOLEAN  - Flag(Creation or Termination)

Return Value:

    None.

--*/
VOID
SaDisplayProcessNotifyRoutine(
    IN HANDLE ParentId,
    IN HANDLE ProcessId,
    IN BOOLEAN Create
    )
{

    NTSTATUS Status;
    PSTR ImageName;
    PEPROCESS Process;

    if (!g_DeviceExtension)
    	return;

    Status = PsLookupProcessByProcessId(
        ProcessId,
        &Process
        );
    if (!NT_SUCCESS(Status)) {
        return;
    }

    ImageName = (PSTR)PsGetProcessImageFileName(Process);

    _strlwr(ImageName);

    if (strcmp(ImageName,"autochk.exe") == 0) {

        if (Create) {
            if (g_DeviceExtension->CheckDiskBitmap) {
                Status = DoBitmapDisplay(
                    g_DeviceExtension,
                    g_DeviceExtension->CheckDiskBitmap,
                    SA_DISPLAY_ADD_START_TASKS
                    );
            }
        } else {
            if (g_DeviceExtension->StartingBitmap) {
                Status = DoBitmapDisplay(
                    g_DeviceExtension,
                    g_DeviceExtension->StartingBitmap,
                    SA_DISPLAY_ADD_START_TASKS
                    );
            }
        }
    }

    return;
}


NTSTATUS
SaDisplayDeviceInitialization(
    IN PSAPORT_DRIVER_EXTENSION DriverExtension
    )

/*++

Routine Description:

   This is the local display specific code for driver initialization.
   This function is called by SaPortInitialize, which is called by
   the local display's DriverEntry function.

Arguments:

   DriverExtension      - Driver extension structure

Return Value:

    NT status code.

--*/

{
    UNREFERENCED_PARAMETER(DriverExtension);
    return STATUS_SUCCESS;
}


NTSTATUS
SaDisplayIoValidation(
    IN PDISPLAY_DEVICE_EXTENSION DeviceExtension,
    IN PIRP Irp,
    PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

   This is the local display specific code for processing
   all I/O validation for reads and writes.

Arguments:

   DeviceExtension      - Display device extension
   Irp                  - Pointer to an IRP structure that describes the requested I/O operation.
   IrpSp                - Irp stack pointer

Return Value:

    NT status code.

--*/

{
    ULONG Length;


    if (IrpSp->MajorFunction == IRP_MJ_READ) {
        Length = (ULONG)IrpSp->Parameters.Read.Length;
    } else if (IrpSp->MajorFunction == IRP_MJ_WRITE) {
        Length = (ULONG)IrpSp->Parameters.Write.Length;
    } else {
        REPORT_ERROR( DeviceExtension->DeviceType, "Invalid I/O request", STATUS_INVALID_PARAMETER_1 );
        return STATUS_INVALID_PARAMETER_1;
    }

    if (Length < sizeof(SA_DISPLAY_SHOW_MESSAGE)) {
        REPORT_ERROR( DeviceExtension->DeviceType, "I/O length != sizeof(SA_DISPLAY_SHOW_MESSAGE)", STATUS_INVALID_PARAMETER_2 );
        return STATUS_INVALID_PARAMETER_2;
    }

    //
    // For the display device we support the concept of
    // the user mode layer obtaining exclusive access
    // to the device.
    //

    ExAcquireFastMutex( &DeviceExtension->DisplayMutex );
    if (!DeviceExtension->AllowWrites) {
        ExReleaseFastMutex( &DeviceExtension->DisplayMutex );
        REPORT_ERROR( DeviceExtension->DeviceType, "Cannot write bitmap because the display is locked", STATUS_MEDIA_WRITE_PROTECTED );
        return STATUS_MEDIA_WRITE_PROTECTED;
    }
    ExReleaseFastMutex( &DeviceExtension->DisplayMutex );

    return STATUS_SUCCESS;
}


NTSTATUS
SaDisplayShutdownNotification(
    IN PDISPLAY_DEVICE_EXTENSION DeviceExtension,
    IN PIRP Irp,
    PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

   This is the local display specific code for processing
   the system shutdown notification.

Arguments:

   DeviceExtension      - Display device extension
   Irp                  - Pointer to an IRP structure that describes the requested I/O operation.
   IrpSp                - Irp stack pointer

Return Value:

    NT status code.

--*/

{
    UNREFERENCED_PARAMETER(DeviceExtension);
    UNREFERENCED_PARAMETER(Irp);
    UNREFERENCED_PARAMETER(IrpSp);
    return STATUS_SUCCESS;
}


DECLARE_IOCTL_HANDLER( HandleDisplayLock )

/*++

Routine Description:

   This routine processes the private IOCTL_SADISPLAY_LOCK request.  This
   IOCTL allows an applicatgion to lock out display writes for a period
   of time.

Arguments:

   DeviceObject         - The device object for the target device.
   Irp                  - Pointer to an IRP structure that describes the requested I/O operation.
   DeviceExtension      - Pointer to the main port driver device extension.
   InputBuffer          - Pointer to the user's input buffer
   InputBufferLength    - Length in bytes of the input buffer
   OutputBuffer         - Pointer to the user's output buffer
   OutputBufferLength   - Length in bytes of the output buffer

Return Value:

   NT status code.

--*/

{
    ExAcquireFastMutex( &((PDISPLAY_DEVICE_EXTENSION)DeviceExtension)->DisplayMutex );
    ((PDISPLAY_DEVICE_EXTENSION)DeviceExtension)->AllowWrites = FALSE;
    ExReleaseFastMutex( &((PDISPLAY_DEVICE_EXTENSION)DeviceExtension)->DisplayMutex );

    return CompleteRequest( Irp, STATUS_SUCCESS, 0 );
}


DECLARE_IOCTL_HANDLER( HandleDisplayUnlock )

/*++

Routine Description:

   This routine processes the private IOCTL_SADISPLAY_UNLOCK request.  This
   IOCTL allows an applicatgion to unlock a previous lock.

Arguments:

   DeviceObject         - The device object for the target device.
   Irp                  - Pointer to an IRP structure that describes the requested I/O operation.
   DeviceExtension      - Pointer to the main port driver device extension.
   InputBuffer          - Pointer to the user's input buffer
   InputBufferLength    - Length in bytes of the input buffer
   OutputBuffer         - Pointer to the user's output buffer
   OutputBufferLength   - Length in bytes of the output buffer

Return Value:

   NT status code.

--*/

{
    ExAcquireFastMutex( &((PDISPLAY_DEVICE_EXTENSION)DeviceExtension)->DisplayMutex );
    ((PDISPLAY_DEVICE_EXTENSION)DeviceExtension)->AllowWrites = TRUE;
    ExReleaseFastMutex( &((PDISPLAY_DEVICE_EXTENSION)DeviceExtension)->DisplayMutex );

    return CompleteRequest( Irp, STATUS_SUCCESS, 0 );
}


NTSTATUS
DoBitmapDisplay(
    IN PDISPLAY_DEVICE_EXTENSION DeviceExtension,
    IN PVOID BitmapBits,
    IN ULONG MsgCode
    )

/*++

Routine Description:

   This is an internal support function that displays a bitmap on the local display.

Arguments:

   DeviceExtension       - Pointer to the display specific device extension
   BitmapBits                   - Pointer to the bitmap bits to display
   MsgCode                      - Server appliance message code

Return Value:

   NT status code.

--*/

{
    NTSTATUS Status;
    PSA_DISPLAY_SHOW_MESSAGE Bitmap = NULL;


    Status = SaDisplayClearDisplay( DeviceExtension );
    if (!NT_SUCCESS(Status)) {
        REPORT_ERROR( DeviceExtension->DeviceType, "Could not clear the local display", Status );
        return Status;
    }

    __try {


        if (BitmapBits == NULL) {
            Status = STATUS_DATA_ERROR;
            ERROR_RETURN( DeviceExtension->DeviceType, "Bitmap bits cannot be NULL", Status );
        }

        Bitmap = (PSA_DISPLAY_SHOW_MESSAGE) ExAllocatePool( PagedPool, sizeof(SA_DISPLAY_SHOW_MESSAGE) );
        if (Bitmap == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            ERROR_RETURN( DeviceExtension->DeviceType, "Could not allocate pool", Status );
        }

        Bitmap->SizeOfStruct = sizeof(SA_DISPLAY_SHOW_MESSAGE);
        Bitmap->Width = DeviceExtension->DisplayWidth;
        Bitmap->Height = DeviceExtension->DisplayHeight;
        Bitmap->MsgCode = MsgCode;

        RtlCopyMemory( Bitmap->Bits, BitmapBits, Bitmap->Height * (Bitmap->Width >> 3) );

        Status = SaDisplayDisplayBitmap( DeviceExtension, Bitmap );
        if (!NT_SUCCESS(Status)) {
            ERROR_RETURN( DeviceExtension->DeviceType, "Could not display bitmap", Status );
        }

    } __finally {

        if (Bitmap) {
            ExFreePool( Bitmap );
        }


    }

    return Status;
}


DECLARE_IOCTL_HANDLER( HandleDisplayBusyMessage )

/*++

Routine Description:

   This routine displays the busy message bitmap on the local display.

Arguments:

   DeviceObject         - The device object for the target device.
   Irp                  - Pointer to an IRP structure that describes the requested I/O operation.
   DeviceExtension      - Pointer to the main port driver device extension.
   InputBuffer          - Pointer to the user's input buffer
   InputBufferLength    - Length in bytes of the input buffer
   OutputBuffer         - Pointer to the user's output buffer
   OutputBufferLength   - Length in bytes of the output buffer

Return Value:

   NT status code.

--*/

{
    NTSTATUS Status;


    Status = DoBitmapDisplay(
        (PDISPLAY_DEVICE_EXTENSION)DeviceExtension,
        ((PDISPLAY_DEVICE_EXTENSION)DeviceExtension)->CheckDiskBitmap,
        SA_DISPLAY_ADD_START_TASKS
        );
    if (!NT_SUCCESS(Status)) {
        REPORT_ERROR( DeviceExtension->DeviceType, "Could not display busy bitmap", Status );
        return CompleteRequest( Irp, Status, 0 );
    }

    return CompleteRequest( Irp, STATUS_SUCCESS, 0 );
}


DECLARE_IOCTL_HANDLER( HandleDisplayShutdownMessage )

/*++

Routine Description:

   This routine displays the shutdown message bitmap on the local display.

Arguments:

   DeviceObject         - The device object for the target device.
   Irp                  - Pointer to an IRP structure that describes the requested I/O operation.
   DeviceExtension      - Pointer to the main port driver device extension.
   InputBuffer          - Pointer to the user's input buffer
   InputBufferLength    - Length in bytes of the input buffer
   OutputBuffer         - Pointer to the user's output buffer
   OutputBufferLength   - Length in bytes of the output buffer

Return Value:

   NT status code.

--*/

{
    NTSTATUS Status;


    Status = DoBitmapDisplay(
        (PDISPLAY_DEVICE_EXTENSION)DeviceExtension,
        ((PDISPLAY_DEVICE_EXTENSION)DeviceExtension)->ShutdownBitmap,
        SA_DISPLAY_SHUTTING_DOWN
        );
    if (!NT_SUCCESS(Status)) {
        REPORT_ERROR( DeviceExtension->DeviceType, "Could not display shutdown bitmap", Status );
        return CompleteRequest( Irp, Status, 0 );
    }

    return CompleteRequest( Irp, STATUS_SUCCESS, 0 );
}


DECLARE_IOCTL_HANDLER( HandleDisplayChangeLanguage  )

/*++

Routine Description:

   This routine causes all internal butmaps to be reloaded from the registry.

Arguments:

   DeviceObject         - The device object for the target device.
   Irp                  - Pointer to an IRP structure that describes the requested I/O operation.
   DeviceExtension      - Pointer to the main port driver device extension.
   InputBuffer          - Pointer to the user's input buffer
   InputBufferLength    - Length in bytes of the input buffer
   OutputBuffer         - Pointer to the user's output buffer
   OutputBufferLength   - Length in bytes of the output buffer

Return Value:

   NT status code.

--*/

{
    NTSTATUS Status;

    Status = SaDisplayLoadAllBitmaps( (PDISPLAY_DEVICE_EXTENSION)DeviceExtension, &DeviceExtension->DriverExtension->RegistryPath );
    if (!NT_SUCCESS(Status)) {
        REPORT_ERROR( DeviceExtension->DeviceType, "Could not load all bitmaps", Status );
    }

    return CompleteRequest( Irp, Status, 0 );
}


NTSTATUS
SaDisplayStoreBitmapInRegistry(
    IN PDISPLAY_DEVICE_EXTENSION DeviceExtension,
    IN PWSTR ValueName,
    IN PSA_DISPLAY_SHOW_MESSAGE SaDisplay
    )

/*++

Routine Description:

   This routine stores a bitmap in the registry.

Arguments:

   RegistryPath         - Full path to the driver's registry key
   ValueName            - Name of the value in the registry (also the bitmap name)
   SaDisplay            - Pointer to the bitmap to be stored

Return Value:

    NT status code.

--*/

{
    NTSTATUS Status;


    Status = WriteRegistryValue(
        DeviceExtension->DriverExtension,
        &DeviceExtension->DriverExtension->RegistryPath,
        ValueName,
        REG_BINARY,
        SaDisplay->Bits,
        SaDisplay->Height * (SaDisplay->Width >> 3)
        );
    if (!NT_SUCCESS(Status)) {
        REPORT_ERROR( DeviceExtension->DeviceType, "WriteRegistryValue failed", Status );
    }

    return Status;
}


DECLARE_IOCTL_HANDLER( HandleDisplayStoreBitmap )
{

/*++

Routine Description:

   This routine stores a bitmap in the registry for the display driver.

Arguments:

   DeviceObject         - The device object for the target device.
   Irp                  - Pointer to an IRP structure that describes the requested I/O operation.
   DeviceExtension      - Pointer to the main port driver device extension.
   InputBuffer          - Pointer to the user's input buffer
   InputBufferLength    - Length in bytes of the input buffer
   OutputBuffer         - Pointer to the user's output buffer
   OutputBufferLength   - Length in bytes of the output buffer

Return Value:

   NT status code.

--*/

    NTSTATUS Status;
    PSA_DISPLAY_SHOW_MESSAGE SaDisplay = (PSA_DISPLAY_SHOW_MESSAGE) InputBuffer;


    __try {

        if (InputBuffer == NULL || InputBufferLength != sizeof(SA_DISPLAY_SHOW_MESSAGE)) {
            Status = STATUS_INVALID_PARAMETER_1;
            ERROR_RETURN( DeviceExtension->DeviceType, "Input buffer is invalid", Status );
        }

        if (SaDisplay->SizeOfStruct != sizeof(SA_DISPLAY_SHOW_MESSAGE)) {
            Status = STATUS_INVALID_PARAMETER_2;
            ERROR_RETURN( DeviceExtension->DeviceType, "SaDisplay->SizeOfStruct != sizeof(SA_DISPLAY_SHOW_MESSAGE)", Status );
        }

        if (SaDisplay->Width > ((PDISPLAY_DEVICE_EXTENSION)DeviceExtension)->DisplayWidth || SaDisplay->Height > ((PDISPLAY_DEVICE_EXTENSION)DeviceExtension)->DisplayHeight) {
            Status = STATUS_INVALID_PARAMETER_3;
            ERROR_RETURN( DeviceExtension->DeviceType, "SaDisplay->SizeOfStruct != sizeof(SA_DISPLAY_SHOW_MESSAGE)", Status );
        }

        switch (SaDisplay->MsgCode) {
            case SA_DISPLAY_STARTING:
                Status = SaDisplayStoreBitmapInRegistry( (PDISPLAY_DEVICE_EXTENSION)DeviceExtension, DISPLAY_STARTING_PARAM, SaDisplay );
                break;

            case SA_DISPLAY_ADD_START_TASKS:
                Status = SaDisplayStoreBitmapInRegistry( (PDISPLAY_DEVICE_EXTENSION)DeviceExtension, DISPLAY_UPDATE_PARAM, SaDisplay );
                break;

            case SA_DISPLAY_READY:
                Status = SaDisplayStoreBitmapInRegistry( (PDISPLAY_DEVICE_EXTENSION)DeviceExtension, DISPLAY_READY_PARAM, SaDisplay );
                break;

            case SA_DISPLAY_SHUTTING_DOWN:
                Status = SaDisplayStoreBitmapInRegistry( (PDISPLAY_DEVICE_EXTENSION)DeviceExtension, DISPLAY_SHUTDOWN_PARAM, SaDisplay );
                break;

            case SA_DISPLAY_CHECK_DISK:
                Status = SaDisplayStoreBitmapInRegistry( (PDISPLAY_DEVICE_EXTENSION)DeviceExtension, DISPLAY_CHECKDISK_PARAM, SaDisplay );
                break;

            default:
                Status = STATUS_INVALID_PARAMETER_4;
                ERROR_RETURN( DeviceExtension->DeviceType, "Invalid display message id", Status );
                break;
        }

    } __finally {


    }

    return CompleteRequest( Irp, Status, 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serveravailability\saport\exports.cpp ===
/*++

Copyright (c) 1991 - 2001 Microsoft Corporation

Module Name:

    ##### ##  ## #####   #####  #####  ######  ###      ####  #####  #####
    ##    ##  ## ##  ## ##   ## ##  ##   ##   ##  #    ##   # ##  ## ##  ##
    ##     ####  ##  ## ##   ## ##  ##   ##   ###      ##     ##  ## ##  ##
    #####   ##   ##  ## ##   ## #####    ##    ###     ##     ##  ## ##  ##
    ##     ####  #####  ##   ## ####     ##     ###    ##     #####  #####
    ##    ##  ## ##     ##   ## ## ##    ##   #  ## ## ##   # ##     ##
    ##### ##  ## ##      #####  ##  ##   ##    ###  ##  ####  ##     ##

Abstract:

    This module contains the code for all fundtions that
    are exported by the Server Appliance port driver for
    use by the mini-port drivers.

Author:

    Wesley Witt (wesw) 1-Oct-2001

Environment:

    Kernel mode only.

Notes:


--*/

#include "internal.h"
#include <ntimage.h>



PVOID
SaPortAllocatePool(
    IN PVOID MiniPortDeviceExtension,
    IN SIZE_T NumberOfBytes
    )

/*++

Routine Description:

   This routine is a wrapper for ExAllocatePool, but enforces
   pool tagging by using the associated miniport's driver name
   for the pool tag.

Arguments:

   MiniPortDeviceExtension      - Pointer to the miniport's device extension
   NumberOfBytes                - Number of bytes to allocate

Return Value:

   Pointer to the allocated pool or NULL for failure.

--*/

{
    PDEVICE_EXTENSION DeviceExtension;
    ULONG DeviceType;
    ULONG PoolTag;


    if (MiniPortDeviceExtension) {
        DeviceExtension = DeviceExtentionFromMiniPort( MiniPortDeviceExtension );
        DeviceType = DeviceExtension->InitData->DeviceType;
    } else {
        DeviceType = 0;
    }

    switch (DeviceType) {
        case SA_DEVICE_DISPLAY:
            PoolTag = 'sDaS';
            break;

        case SA_DEVICE_KEYPAD:
            PoolTag = 'pKaS';
            break;

        case SA_DEVICE_NVRAM:
            PoolTag = 'vNaS';
            break;

        case SA_DEVICE_WATCHDOG:
            PoolTag = 'dWaS';
            break;

        default:
            PoolTag = 'tPaS';
            break;
    }

    return ExAllocatePoolWithTag( NonPagedPool, NumberOfBytes, PoolTag );
}


VOID
SaPortFreePool(
    IN PVOID MiniPortDeviceExtension,
    IN PVOID PoolMemory
    )

/*++

Routine Description:

   This routine is a wrapper for ExFreePool, but enforces
   pool tagging by using the associated miniport's driver name
   for the pool tag.

Arguments:

   MiniPortDeviceExtension      - Pointer to the miniport's device extension
   PoolMemory                   - Pointer to the previously allocated pool

Return Value:

   None.

--*/

{
    PDEVICE_EXTENSION DeviceExtension = DeviceExtentionFromMiniPort( MiniPortDeviceExtension );
    ULONG PoolTag;


    switch (DeviceExtension->InitData->DeviceType) {
        case SA_DEVICE_DISPLAY:
            PoolTag = 'sDaS';
            break;

        case SA_DEVICE_KEYPAD:
            PoolTag = 'pKaS';
            break;

        case SA_DEVICE_NVRAM:
            PoolTag = 'vNaS';
            break;

        case SA_DEVICE_WATCHDOG:
            PoolTag = 'dWaS';
            break;
    }

    ExFreePoolWithTag( PoolMemory, PoolTag );
}


PVOID
SaPortGetVirtualAddress(
    IN PVOID MiniPortDeviceExtension,
    IN PHYSICAL_ADDRESS PhysicalAddress,
    IN ULONG Length
    )

/*++

Routine Description:

   This routine is a wrapper for MmMapIoSpace and simply provides a
   virtual memory address to access a physical resource.

Arguments:

   MiniPortDeviceExtension      - Pointer to the miniport's device extension
   PhysicalAddress              - Physical memory address
   Length                       - Length of the memory space

Return Value:

   None.

--*/

{
    return MmMapIoSpace( PhysicalAddress, Length, MmNonCached );
}


VOID
SaPortRequestDpc(
    IN PVOID MiniPortDeviceExtension,
    IN PVOID Context
    )

/*++

Routine Description:

   This routine is a wrapper for IoRequestDpc.

Arguments:

   MiniPortDeviceExtension      - Pointer to the miniport's device extension
   Context                      - Miniport supplied context pointer

Return Value:

   None.

--*/

{
    PDEVICE_EXTENSION DeviceExtension = DeviceExtentionFromMiniPort( MiniPortDeviceExtension );
    IoRequestDpc( DeviceExtension->DeviceObject, MiniPortDeviceExtension, Context );
}


VOID
SaPortCompleteRequest(
    IN PVOID MiniPortDeviceExtension,
    IN PIRP Irp,
    IN ULONG Information,
    IN NTSTATUS Status,
    IN BOOLEAN CompleteAll
    )

/*++

Routine Description:

   This routine is use by all miniports to complete the currently processed IRP.
   The caller can optionally request that all oustanding I/Os be completed.  This is
   accomplished by removing all IRPs from the device queue and processing the I/O.

Arguments:

   MiniPortDeviceExtension      - Pointer to the miniport's device extension
   Information                  - Informational, request specific data
   Status                       - NT status value
   CompleteAll                  - TRUE for completion of all outstanding I/O requests, otherwise FALSE

Return Value:

   None.

--*/

{
    PDEVICE_EXTENSION DeviceExtension = DeviceExtentionFromMiniPort( MiniPortDeviceExtension );
    PKDEVICE_QUEUE_ENTRY Packet;
    KIRQL CancelIrql;
    PIRP ThisIrp;



    if (Irp) {
        CompleteRequest( Irp, Status, Information );
        return;
    }

    if (DeviceExtension->DeviceObject->CurrentIrp == NULL) {
        return;
    }

    CompleteRequest( DeviceExtension->DeviceObject->CurrentIrp, Status, Information );

    if (CompleteAll) {
        while (1) {
            IoAcquireCancelSpinLock( &CancelIrql );
            Packet = KeRemoveDeviceQueue( &DeviceExtension->DeviceObject->DeviceQueue );
            if (Packet == NULL) {
                IoReleaseCancelSpinLock( CancelIrql );
                break;
            }
            ThisIrp = CONTAINING_RECORD( Packet, IRP, Tail.Overlay.DeviceQueueEntry );
            IoReleaseCancelSpinLock( CancelIrql );
            SaPortStartIo( DeviceExtension->DeviceObject, ThisIrp );
        }
    } else {
        IoStartNextPacket( DeviceExtension->DeviceObject, TRUE );
    }

    IoReleaseRemoveLock( &DeviceExtension->RemoveLock, DeviceExtension->DeviceObject->CurrentIrp );
}


BOOLEAN
SaPortSynchronizeExecution (
    IN PVOID MiniPortDeviceExtension,
    IN PKSYNCHRONIZE_ROUTINE SynchronizeRoutine,
    IN PVOID SynchronizeContext
    )

/*++

Routine Description:

   This routine is a wrapper for KeSynchronizeExecution.

Arguments:

   MiniPortDeviceExtension      - Pointer to the miniport's device extension
   SynchronizeRoutine           - Is the entry point for a caller-supplied SynchCritSection routine whose execution is to be
                                  synchronized with the execution of the ISR associated with the interrupt objects.
   SynchronizeContext           - Pointer to a caller-supplied context area to be passed to the SynchronizeRoutine when it is called.

Return Value:

   None.

--*/

{
    PDEVICE_EXTENSION DeviceExtension = DeviceExtentionFromMiniPort( MiniPortDeviceExtension );


    if (DeviceExtension->InterruptObject == NULL) {
        return FALSE;
    }

    return KeSynchronizeExecution(
        DeviceExtension->InterruptObject,
        SynchronizeRoutine,
        SynchronizeContext
        );
}


ULONG
SaPortGetOsVersion(
    VOID
    )

/*++

Routine Description:

   This routine provides access to the OS version on which the minport is running.
   The OS version value is obtained at DriverEntry time.

Arguments:

   None.

Return Value:

   OS Version data.

--*/

{
    return (ULONG)((OsMajorVersion << 16) | (OsMinorVersion & 0xffff));
}


NTSTATUS
SaPortGetRegistryValueInformation(
    IN PVOID MiniPortDeviceExtension,
    IN PWSTR ValueName,
    IN OUT PULONG RegistryType,
    IN OUT PULONG RegistryDataLength
    )
{
    NTSTATUS status;
    PDEVICE_EXTENSION DeviceExtension = DeviceExtentionFromMiniPort( MiniPortDeviceExtension );
    PKEY_VALUE_FULL_INFORMATION KeyInformation = NULL;


    __try {

        status = ReadRegistryValue(
            DeviceExtension->DriverExtension,
            &DeviceExtension->DriverExtension->RegistryPath,
            ValueName,
            &KeyInformation
            );
        if (!NT_SUCCESS(status)) {
            __leave;
        }

        *RegistryType = KeyInformation->Type;
        *RegistryDataLength = KeyInformation->DataLength;

        status = STATUS_SUCCESS;

    } __finally {

        if (KeyInformation) {
            ExFreePool( KeyInformation );
        }

    }

    return status;
}


NTSTATUS
SaPortDeleteRegistryValue(
    IN PVOID MiniPortDeviceExtension,
    IN PWSTR ValueName
    )
{
    NTSTATUS status;
    PDEVICE_EXTENSION DeviceExtension = DeviceExtentionFromMiniPort( MiniPortDeviceExtension );
    UNICODE_STRING unicodeString;
    HANDLE parametersKey = NULL;


    __try {

        status = OpenParametersRegistryKey(
            DeviceExtension->DriverExtension,
            &DeviceExtension->DriverExtension->RegistryPath,
            KEY_ALL_ACCESS,
            &parametersKey
            );
        if (!NT_SUCCESS(status)) {
            ERROR_RETURN( DeviceExtension->DeviceType, "OpenParametersRegistryKey failed", status );
        }

        RtlInitUnicodeString( &unicodeString, ValueName );

        status = ZwDeleteValueKey(
            parametersKey,
            &unicodeString
            );
        if (!NT_SUCCESS(status)) {
            ERROR_RETURN( DeviceExtension->DeviceType, "ZwDeleteValueKey failed", status );
        }

        status = STATUS_SUCCESS;

    } __finally {

        if (parametersKey) {
            ZwClose( parametersKey );
        }

    }

    return status;
}


NTSTATUS
SaPortReadNumericRegistryValue(
    IN PVOID MiniPortDeviceExtension,
    IN PWSTR ValueName,
    OUT PULONG RegistryValue
    )

/*++

Routine Description:

   This routine provides access to the miniport driver's registry parameters.
   This function returns a numeric (REG_DWORD) data value.

Arguments:

   MiniPortDeviceExtension      - Pointer to the miniport's device extension
   ValueName                    - Name of the registry value to read
   RegistryValue                - Pointer to a ULONG that holds the registry data

Return Value:

   NT status code.

--*/

{
    NTSTATUS status;
    PDEVICE_EXTENSION DeviceExtension = DeviceExtentionFromMiniPort( MiniPortDeviceExtension );
    PKEY_VALUE_FULL_INFORMATION KeyInformation = NULL;


    __try {

        status = ReadRegistryValue(
            DeviceExtension->DriverExtension,
            &DeviceExtension->DriverExtension->RegistryPath,
            ValueName,
            &KeyInformation
            );
        if (!NT_SUCCESS(status)) {
            __leave;
        }

        if (KeyInformation->Type != REG_DWORD) {
            status = STATUS_OBJECT_TYPE_MISMATCH;
            __leave;
        }

        RtlCopyMemory( RegistryValue, (PUCHAR)KeyInformation + KeyInformation->DataOffset, sizeof(ULONG) );

        status = STATUS_SUCCESS;

    } __finally {

        if (KeyInformation) {
            ExFreePool( KeyInformation );
        }

    }

    return status;
}


NTSTATUS
SaPortWriteNumericRegistryValue(
    IN PVOID MiniPortDeviceExtension,
    IN PWSTR ValueName,
    IN ULONG RegistryValue
    )

/*++

Routine Description:

   This routine provides access to the miniport driver's registry parameters.
   This function returns a numeric (REG_DWORD) data value.

Arguments:

   MiniPortDeviceExtension      - Pointer to the miniport's device extension
   ValueName                    - Name of the registry value to read
   RegistryValue                - Pointer to a ULONG that holds the registry data

Return Value:

   NT status code.

--*/

{
    NTSTATUS Status;
    PDEVICE_EXTENSION DeviceExtension = DeviceExtentionFromMiniPort( MiniPortDeviceExtension );


    __try {

        Status = WriteRegistryValue(
            DeviceExtension->DriverExtension,
            &DeviceExtension->DriverExtension->RegistryPath,
            ValueName,
            REG_DWORD,
            &RegistryValue,
            sizeof(ULONG)
            );
        if (!NT_SUCCESS(Status)) {
            __leave;
        }

        Status = STATUS_SUCCESS;

    } __finally {

    }

    return Status;
}


NTSTATUS
SaPortReadBinaryRegistryValue(
    IN PVOID MiniPortDeviceExtension,
    IN PWSTR ValueName,
    OUT PVOID RegistryValue,
    IN OUT PULONG RegistryValueLength
    )

/*++

Routine Description:

   This routine provides access to the miniport driver's registry parameters.
   This function returns a numeric (REG_DWORD) data value.

Arguments:

   MiniPortDeviceExtension      - Pointer to the miniport's device extension
   ValueName                    - Name of the registry value to read
   RegistryValue                - Pointer to a ULONG that holds the registry data

Return Value:

   NT status code.

--*/

{
    NTSTATUS status;
    PDEVICE_EXTENSION DeviceExtension = DeviceExtentionFromMiniPort( MiniPortDeviceExtension );
    PKEY_VALUE_FULL_INFORMATION KeyInformation = NULL;


    __try {

        status = ReadRegistryValue(
            DeviceExtension->DriverExtension,
            &DeviceExtension->DriverExtension->RegistryPath,
            ValueName,
            &KeyInformation
            );
        if (!NT_SUCCESS(status)) {
            __leave;
        }

        if (KeyInformation->Type != REG_BINARY) {
            status = STATUS_OBJECT_TYPE_MISMATCH;
            __leave;
        }

        if (*RegistryValueLength < KeyInformation->DataLength) {
            *RegistryValueLength = KeyInformation->DataLength;
            status = STATUS_BUFFER_TOO_SMALL;
            __leave;
        }

        RtlCopyMemory( RegistryValue, (PUCHAR)KeyInformation + KeyInformation->DataOffset, KeyInformation->DataLength );

        status = STATUS_SUCCESS;

    } __finally {

        if (KeyInformation) {
            ExFreePool( KeyInformation );
        }

    }

    return status;
}


NTSTATUS
SaPortWriteBinaryRegistryValue(
    IN PVOID MiniPortDeviceExtension,
    IN PWSTR ValueName,
    IN PVOID RegistryValue,
    IN ULONG RegistryValueLength
    )

/*++

Routine Description:

   This routine provides access to the miniport driver's registry parameters.
   This function returns a numeric (REG_DWORD) data value.

Arguments:

   MiniPortDeviceExtension      - Pointer to the miniport's device extension
   ValueName                    - Name of the registry value to read
   RegistryValue                - Pointer to a ULONG that holds the registry data

Return Value:

   NT status code.

--*/

{
    NTSTATUS Status;
    PDEVICE_EXTENSION DeviceExtension = DeviceExtentionFromMiniPort( MiniPortDeviceExtension );


    __try {

        Status = WriteRegistryValue(
            DeviceExtension->DriverExtension,
            &DeviceExtension->DriverExtension->RegistryPath,
            ValueName,
            REG_BINARY,
            RegistryValue,
            RegistryValueLength
            );
        if (!NT_SUCCESS(Status)) {
            __leave;
        }

        Status = STATUS_SUCCESS;

    } __finally {

    }

    return Status;
}


NTSTATUS
SaPortReadUnicodeStringRegistryValue(
    IN PVOID MiniPortDeviceExtension,
    IN PWSTR ValueName,
    OUT PUNICODE_STRING RegistryValue
    )

/*++

Routine Description:

   This routine provides access to the miniport driver's registry parameters.
   This function returns a UNICODE_STRING representation of REG_SZ registry data.

Arguments:

   MiniPortDeviceExtension      - Pointer to the miniport's device extension
   ValueName                    - Name of the registry value to read
   RegistryValue                - Pointer to a UNICODE_STRING that holds the registry data

Return Value:

   NT status code.

--*/

{
    NTSTATUS status;
    PDEVICE_EXTENSION DeviceExtension = DeviceExtentionFromMiniPort( MiniPortDeviceExtension );
    PKEY_VALUE_FULL_INFORMATION KeyInformation = NULL;


    __try {

        status = ReadRegistryValue(
            DeviceExtension->DriverExtension,
            &DeviceExtension->DriverExtension->RegistryPath,
            ValueName,
            &KeyInformation
            );
        if (!NT_SUCCESS(status)) {
            __leave;
        }

        if (KeyInformation->Type != REG_SZ) {
            status = STATUS_OBJECT_TYPE_MISMATCH;
            __leave;
        }

        RegistryValue->Buffer = (PWSTR) ExAllocatePool( NonPagedPool, KeyInformation->DataLength );
        if (RegistryValue->Buffer == NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            __leave;
        }

        RtlCopyMemory( RegistryValue->Buffer, (PUCHAR)KeyInformation + KeyInformation->DataOffset, KeyInformation->DataLength );

        RegistryValue->Length = (USHORT) KeyInformation->DataLength;
        RegistryValue->MaximumLength = RegistryValue->Length;

        status = STATUS_SUCCESS;

    } __finally {

        if (KeyInformation) {
            ExFreePool( KeyInformation );
        }

        if (!NT_SUCCESS(status)) {
            if (RegistryValue->Buffer) {
                ExFreePool( RegistryValue->Buffer );
            }
        }

    }

    return status;
}


NTSTATUS
SaPortWriteUnicodeStringRegistryValue(
    IN PVOID MiniPortDeviceExtension,
    IN PWSTR ValueName,
    IN PUNICODE_STRING RegistryValue
    )

/*++

Routine Description:

   This routine provides access to the miniport driver's registry parameters.
   This function returns a UNICODE_STRING representation of REG_SZ registry data.

Arguments:

   MiniPortDeviceExtension      - Pointer to the miniport's device extension
   ValueName                    - Name of the registry value to read
   RegistryValue                - Pointer to a UNICODE_STRING that holds the registry data

Return Value:

   NT status code.

--*/

{
    NTSTATUS Status;
    PDEVICE_EXTENSION DeviceExtension = DeviceExtentionFromMiniPort( MiniPortDeviceExtension );


    __try {

        Status = WriteRegistryValue(
            DeviceExtension->DriverExtension,
            &DeviceExtension->DriverExtension->RegistryPath,
            ValueName,
            REG_SZ,
            RegistryValue->Buffer,
            RegistryValue->Length
            );
        if (!NT_SUCCESS(Status)) {
            __leave;
        }

        Status = STATUS_SUCCESS;

    } __finally {

    }

    return Status;
}


PVOID
SaPortLockPagesForSystem(
    IN PVOID MiniPortDeviceExtension,
    IN PVOID UserBuffer,
    IN ULONG UserBufferLength,
    IN OUT PMDL *Mdl
    )

/*++

Routine Description:

   This routine obtains a virtual address that is locked down
   and usable by the miniport driver at all times.

Arguments:

   MiniPortDeviceExtension      - Pointer to the miniport's device extension
   UserBuffer                   - User buffer that is passed to the miniport
   UserBufferLength             - Length in bytes of the UserBuffer
   Mdl                          - MDL that is created by this routine

Return Value:

   Virtual system address for the UserBuffer

--*/

{
    PDEVICE_EXTENSION DeviceExtension = DeviceExtentionFromMiniPort( MiniPortDeviceExtension );


    if (Mdl == NULL) {
        return NULL;
    }

    *Mdl = NULL;

    __try {
        *Mdl = IoAllocateMdl( UserBuffer, UserBufferLength, FALSE, TRUE, NULL );
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        *Mdl = NULL;
    }

    if (*Mdl == NULL) {
        return NULL;
    }

    __try {
        MmProbeAndLockPages( *Mdl, KernelMode , IoWriteAccess );
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        IoFreeMdl( *Mdl );
    }

    return MmGetSystemAddressForMdlSafe( *Mdl, NormalPagePriority );
}


VOID
SaPortReleaseLockedPagesForSystem(
    IN PVOID MiniPortDeviceExtension,
    IN PMDL Mdl
    )

/*++

Routine Description:

   This routine releases the resources with a previously allocated MDL.

Arguments:

   MiniPortDeviceExtension      - Pointer to the miniport's device extension
   Mdl                          - MDL that is created by SaPortLockPagesForSystem

Return Value:

   None.

--*/

{
    PDEVICE_EXTENSION DeviceExtension = DeviceExtentionFromMiniPort( MiniPortDeviceExtension );


    MmUnlockPages( Mdl );
    IoFreeMdl( Mdl );
}


NTSTATUS
SaPortCopyUnicodeString(
    IN PVOID MiniPortDeviceExtension,
    IN PUNICODE_STRING DestinationString,
    IN OUT PUNICODE_STRING SourceString
    )

/*++

Routine Description:

   This routine copies a UNICODE_STRING from a source to a
   destination, but allocates a new buffer from pool first.

Arguments:

   DestinationString    - Pointer to an empty UNICODE_STRING structure to be filled out
   SourceString         - Source UNICODE_STRING for the copy

Return Value:

   NT status code

--*/

{
    PDEVICE_EXTENSION DeviceExtension = DeviceExtentionFromMiniPort( MiniPortDeviceExtension );


    DestinationString->Buffer = (PWSTR) SaPortAllocatePool( MiniPortDeviceExtension, SourceString->MaximumLength );
    if (DestinationString->Buffer == NULL) {
        REPORT_ERROR( DeviceExtension->DeviceType, "Failed to allocate pool for string", STATUS_INSUFFICIENT_RESOURCES );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory( DestinationString->Buffer, SourceString->Buffer, SourceString->Length );

    DestinationString->Length = SourceString->Length;
    DestinationString->MaximumLength = SourceString->MaximumLength;

    return STATUS_SUCCESS;
}


NTSTATUS
SaPortCreateUnicodeString(
    IN PVOID MiniPortDeviceExtension,
    IN PUNICODE_STRING DestinationString,
    IN PWSTR SourceString
    )

/*++

Routine Description:

   This routine creates a new UNICODE_STRING from pool
   and initializes it with the source string.

Arguments:

   DestinationString    - Pointer to an empty UNICODE_STRING structure to be filled out
   SourceString         - Source character string

Return Value:

   NT status code

--*/

{
    PDEVICE_EXTENSION DeviceExtension = DeviceExtentionFromMiniPort( MiniPortDeviceExtension );

    DestinationString->Length = wcslen(SourceString) * sizeof(WCHAR);
    DestinationString->MaximumLength = DestinationString->Length;

    DestinationString->Buffer = (PWSTR) SaPortAllocatePool( MiniPortDeviceExtension, DestinationString->Length+2 );
    if (DestinationString->Buffer == NULL) {
        REPORT_ERROR( DeviceExtension->DeviceType, "Failed to allocate pool for string", STATUS_INSUFFICIENT_RESOURCES );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory( DestinationString->Buffer, DestinationString->Length+2 );
    RtlCopyMemory( DestinationString->Buffer, SourceString, DestinationString->Length );

    return STATUS_SUCCESS;
}


NTSTATUS
SaPortCreateUnicodeStringCat(
    IN PVOID MiniPortDeviceExtension,
    IN PUNICODE_STRING DestinationString,
    IN PWSTR SourceString1,
    IN PWSTR SourceString2
    )

/*++

Routine Description:

   This routine creates a new UNICODE_STRING from pool
   and initializes it with the two source strings by
   concatinating them together.

Arguments:

   DestinationString    - Pointer to an empty UNICODE_STRING structure to be filled out
   SourceString1        - Source character string
   SourceString2        - Source character string

Return Value:

   NT status code

--*/

{
    PDEVICE_EXTENSION DeviceExtension = DeviceExtentionFromMiniPort( MiniPortDeviceExtension );

    DestinationString->Length = STRING_SZ(SourceString1) + STRING_SZ(SourceString2);
    DestinationString->MaximumLength = DestinationString->Length;

    DestinationString->Buffer = (PWSTR) SaPortAllocatePool( MiniPortDeviceExtension, DestinationString->Length+2 );
    if (DestinationString->Buffer == NULL) {
        REPORT_ERROR( DeviceExtension->DeviceType, "Failed to allocate pool for string", STATUS_INSUFFICIENT_RESOURCES );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory( DestinationString->Buffer, DestinationString->Length+2 );
    RtlCopyMemory( DestinationString->Buffer, SourceString1, STRING_SZ(SourceString1) );
    RtlCopyMemory( ((PUCHAR)DestinationString->Buffer)+STRING_SZ(SourceString1), SourceString2, STRING_SZ(SourceString2) );

    return STATUS_SUCCESS;
}


VOID
SaPortFreeUnicodeString(
    IN PVOID MiniPortDeviceExtension,
    IN PUNICODE_STRING SourceString
    )

/*++

Routine Description:

   This routine creates a new UNICODE_STRING from pool
   and initializes it with the two source strings by
   concatinating them together.

Arguments:

   DestinationString    - Pointer to an empty UNICODE_STRING structure to be filled out
   SourceString1        - Source character string
   SourceString2        - Source character string

Return Value:

   NT status code

--*/

{
    SaPortFreePool( MiniPortDeviceExtension, SourceString->Buffer );
    SourceString->Buffer = NULL;
    SourceString->MaximumLength = 0;
    SourceString->MaximumLength = 0;
}


extern "C" PACL SePublicDefaultDacl;

NTSTATUS
SaPortCreateBasenamedEvent(
    IN PVOID MiniPortDeviceExtension,
    IN PWSTR EventNameString,
    IN OUT PKEVENT *Event,
    IN OUT PHANDLE EventHandle
    )
{
    NTSTATUS Status;
    PDEVICE_EXTENSION DeviceExtension = DeviceExtentionFromMiniPort( MiniPortDeviceExtension );
    UNICODE_STRING EventName;
    PSECURITY_DESCRIPTOR SecurityDescriptor = NULL;
    OBJECT_ATTRIBUTES objectAttributes;


    __try {

        SecurityDescriptor = (PSECURITY_DESCRIPTOR) SaPortAllocatePool( DeviceExtension, 4096 );
        if (SecurityDescriptor == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            ERROR_RETURN( DeviceExtension->DeviceType, "Could not allocate pool for security descriptor", Status );
        }

        Status = RtlCreateSecurityDescriptor( SecurityDescriptor, SECURITY_DESCRIPTOR_REVISION );
        if (!NT_SUCCESS(Status)) {
            ERROR_RETURN( DeviceExtension->DeviceType, "RtlCreateSecurityDescriptor failed", Status );
        }

        Status = RtlSetDaclSecurityDescriptor( SecurityDescriptor, TRUE, *(PACL*)SePublicDefaultDacl, FALSE );
        if (!NT_SUCCESS(Status)) {
            ERROR_RETURN( DeviceExtension->DeviceType, "RtlSetDaclSecurityDescriptor failed", Status );
        }

        Status = SaPortCreateUnicodeStringCat( MiniPortDeviceExtension, &EventName, L"\\BaseNamedObjects\\", EventNameString );
        if (!NT_SUCCESS(Status)) {
            ERROR_RETURN( DeviceExtension->DeviceType, "SaPortCreateUnicodeStringCat failed", Status );
        }

        InitializeObjectAttributes( &objectAttributes, &EventName, OBJ_OPENIF, NULL, SecurityDescriptor );

        Status = ZwCreateEvent( EventHandle, EVENT_ALL_ACCESS, &objectAttributes, SynchronizationEvent, TRUE );
        if (!NT_SUCCESS(Status)) {
            ERROR_RETURN( DeviceExtension->DeviceType, "ZwCreateEvent failed", Status );
        }

        Status = ObReferenceObjectByHandle( *EventHandle, 0, NULL, KernelMode, (PVOID*)Event, NULL );
        if (!NT_SUCCESS(Status)) {
            ERROR_RETURN( DeviceExtension->DeviceType, "ObReferenceObjectByHandle failed", Status );
        }

        ObDereferenceObject( *Event );

    } __finally {

        if (EventName.Buffer) {
            SaPortFreeUnicodeString( MiniPortDeviceExtension, &EventName );
        }

        if (!NT_SUCCESS(Status)) {
            if (SecurityDescriptor) {
                SaPortFreePool( MiniPortDeviceExtension, SecurityDescriptor );
            }
            if (EventHandle) {
                ZwClose( *EventHandle );
            }
        }
    }

    return Status;
}

NTSTATUS
SaPortShutdownSystem(
    IN BOOLEAN PowerOff
    )
{
    return NtShutdownSystem( PowerOff ? ShutdownPowerOff : ShutdownReboot );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serveravailability\saport\display.h ===
/*++

Copyright (c) 1991 - 2001 Microsoft Corporation

Module Name:

    #####   ####  ###  #####  ##      ###   ##  ##    ##   ##
    ##  ##   ##  ##  # ##  ## ##      ###   ##  ##    ##   ##
    ##   ##  ##  ###   ##  ## ##     ## ##   ####     ##   ##
    ##   ##  ##   ###  ##  ## ##     ## ##   ####     #######
    ##   ##  ##    ### #####  ##    #######   ##      ##   ##
    ##  ##   ##  #  ## ##     ##    ##   ##   ##   ## ##   ##
    #####   ####  ###  ##     ##### ##   ##   ##   ## ##   ##

Abstract:

    This header file contains all the global
    definitions for the display device.

Author:

    Wesley Witt (wesw) 1-Oct-2001

Environment:

    Kernel mode only.

Notes:


--*/


//
// Global defines
//

#define DEFAULT_DISPLAY_WIDTH               (128)
#define DEFAULT_DISPLAY_HEIGHT              (64)

#define DISPLAY_STARTING_PARAM              L"Startup BitMap"
#define DISPLAY_CHECKDISK_PARAM             L"CheckDisk BitMap"
#define DISPLAY_READY_PARAM                 L"Ready BitMap"
#define DISPLAY_SHUTDOWN_PARAM              L"Shutdown BitMap"
#define DISPLAY_UPDATE_PARAM                L"Update BitMap"

//
// Device extension
//

typedef struct _DISPLAY_DEVICE_EXTENSION : _DEVICE_EXTENSION {
    FAST_MUTEX                      DisplayMutex;
    BOOLEAN                         AllowWrites;
    PVOID                           StartingBitmap;
    PVOID                           CheckDiskBitmap;
    PVOID                           ReadyBitmap;
    PVOID                           ShutdownBitmap;
    PVOID                           UpdateBitmap;
    USHORT                          DisplayType;
    USHORT                          DisplayHeight;
    USHORT                          DisplayWidth;
} DISPLAY_DEVICE_EXTENSION, *PDISPLAY_DEVICE_EXTENSION;


//
// Display specific functions
//

NTSTATUS
SaDisplayLoadAllBitmaps(
    IN PDISPLAY_DEVICE_EXTENSION DeviceExtension,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
SaDisplayClearDisplay(
    IN PDISPLAY_DEVICE_EXTENSION DisplayDeviceExtension
    );

NTSTATUS
SaDisplayDisplayBitmap(
    IN PDISPLAY_DEVICE_EXTENSION DisplayDeviceExtension,
    IN PSA_DISPLAY_SHOW_MESSAGE Bitmap
    );

NTSTATUS
SaDisplayStartDevice(
    IN PDISPLAY_DEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
SaDisplayIoValidation(
    IN PDISPLAY_DEVICE_EXTENSION DeviceExtension,
    IN PIRP Irp,
    PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
SaDisplayDeviceInitialization(
    IN PSAPORT_DRIVER_EXTENSION DriverExtension
    );

NTSTATUS
SaDisplayShutdownNotification(
    IN PDISPLAY_DEVICE_EXTENSION DeviceExtension,
    IN PIRP Irp,
    PIO_STACK_LOCATION IrpSp
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serveravailability\saport\io.cpp ===
/*++

Copyright (c) 1991 - 2001 Microsoft Corporation

Module Name:

    ####  #####      ####  #####  #####
     ##  ##   ##    ##   # ##  ## ##  ##
     ##  ##   ##    ##     ##  ## ##  ##
     ##  ##   ##    ##     ##  ## ##  ##
     ##  ##   ##    ##     #####  #####
     ##  ##   ## ## ##   # ##     ##
    ####  #####  ##  ####  ##     ##

Abstract:

    This module contains the code to process basic I/O
    requests for read and write IRPs.

Author:

    Wesley Witt (wesw) 1-Oct-2001

Environment:

    Kernel mode only.

Notes:


--*/

#include "internal.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,SaPortRead)
#pragma alloc_text(PAGE,SaPortWrite)
#endif


NTSTATUS
SaPortWrite(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

   This routine is the dispatch point for all writes.  The function
   calls the miniport specific I/O validation function to verify that
   the input parameters are correct.  The IRP is then marked as pending
   and placed in the device queue for processing.

Arguments:

   DeviceObject         - The device object for the target device.
   Irp                  - Pointer to an IRP structure that describes the requested I/O operation.

Return Value:

    NT status code.

--*/

{
    NTSTATUS status;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);
    PDEVICE_EXTENSION DeviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;


    DebugPrint(( DeviceExtension->DeviceType, SAPORT_DEBUG_INFO_LEVEL, "SaPortWrite\n" ));

    if (!DeviceExtension->IsStarted) {
        return CompleteRequest( Irp, STATUS_NO_SUCH_DEVICE, 0 );
    }

    __try {

        //
        // Do any device specific verification
        //

        if (!IS_IRP_INTERNAL( Irp )) {
            switch (DeviceExtension->DriverExtension->InitData.DeviceType) {
                case SA_DEVICE_DISPLAY:
                    status = SaDisplayIoValidation( (PDISPLAY_DEVICE_EXTENSION)DeviceExtension, Irp, IrpSp );
                    break;

                case SA_DEVICE_KEYPAD:
                    status = SaKeypadIoValidation( (PKEYPAD_DEVICE_EXTENSION)DeviceExtension, Irp, IrpSp );
                    break;

                case SA_DEVICE_NVRAM:
                    status = SaNvramIoValidation( (PNVRAM_DEVICE_EXTENSION)DeviceExtension, Irp, IrpSp );
                    break;

                case SA_DEVICE_WATCHDOG:
                    status = SaWatchdogIoValidation( (PWATCHDOG_DEVICE_EXTENSION)DeviceExtension, Irp, IrpSp );
                    break;
            }

            if (!NT_SUCCESS(status)) {
                ERROR_RETURN( DeviceExtension->DeviceType, "I/O validation failed", status );
            }
        }

        IoMarkIrpPending( Irp );
        IoStartPacket( DeviceObject, Irp, NULL, SaPortCancelRoutine );
        status = STATUS_PENDING;

    } __finally {

    }

    if (status != STATUS_PENDING) {
        status = CompleteRequest( Irp, status, Irp->IoStatus.Information );
    }

    return status;
}


NTSTATUS
SaPortRead(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

   This routine is the dispatch point for all reads.  The function
   calls the miniport specific I/O validation function to verify that
   the input parameters are correct.  The IRP is then marked as pending
   and placed in the device queue for processing.

Arguments:

   DeviceObject         - The device object for the target device.
   Irp                  - Pointer to an IRP structure that describes the requested I/O operation.

Return Value:

    NT status code.

--*/

{
    NTSTATUS status;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);
    PDEVICE_EXTENSION DeviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;


    DebugPrint(( DeviceExtension->DeviceType, SAPORT_DEBUG_INFO_LEVEL, "SaPortRead\n" ));

    if (!DeviceExtension->IsStarted) {
        return CompleteRequest( Irp, STATUS_NO_SUCH_DEVICE, 0 );
    }

    __try {

        if (!IS_IRP_INTERNAL( Irp )) {

            //
            // Do any device specific verification, but
            // only if the request is NOT internal
            //

            switch (DeviceExtension->DriverExtension->InitData.DeviceType) {
                case SA_DEVICE_DISPLAY:
                    status = SaDisplayIoValidation( (PDISPLAY_DEVICE_EXTENSION)DeviceExtension, Irp, IrpSp );
                    break;

                case SA_DEVICE_KEYPAD:
                    status = SaKeypadIoValidation( (PKEYPAD_DEVICE_EXTENSION)DeviceExtension, Irp, IrpSp );
                    break;

                case SA_DEVICE_NVRAM:
                    status = SaNvramIoValidation( (PNVRAM_DEVICE_EXTENSION)DeviceExtension, Irp, IrpSp );
                    break;

                case SA_DEVICE_WATCHDOG:
                    status = SaWatchdogIoValidation( (PWATCHDOG_DEVICE_EXTENSION)DeviceExtension, Irp, IrpSp );
                    break;
            }

            if (!NT_SUCCESS(status)) {
                ERROR_RETURN( DeviceExtension->DeviceType, "I/O validation failed", status );
            }
        }

        IoMarkIrpPending( Irp );
        IoStartPacket( DeviceObject, Irp, NULL, SaPortCancelRoutine );
        status = STATUS_PENDING;

    } __finally {

    }

    if (status != STATUS_PENDING) {
        status = CompleteRequest( Irp, status, Irp->IoStatus.Information );
    }

    return status;
}


VOID
SaPortCancelRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

   This routine is the dispatch point for all IRP cancellation.  Every IRP
   that is pending has this function specified as the global cancel routine.
   The associated miniport can specify a cancel routine that it uses for I/O
   specific processing, specifically for stopping I/O on it's hardware device.

Arguments:

   DeviceObject         - The device object for the target device.
   Irp                  - Pointer to an IRP structure that describes the requested I/O operation.

Return Value:

    None.

--*/

{
    PDEVICE_EXTENSION DeviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;


    if (DeviceObject->CurrentIrp == Irp) {
        IoReleaseCancelSpinLock( Irp->CancelIrql );
        if (DeviceExtension->InitData->CancelRoutine) {
            DeviceExtension->InitData->CancelRoutine( DeviceExtension->MiniPortDeviceExtension, Irp, TRUE );
        }
        CompleteRequest( Irp, STATUS_CANCELLED, 0 );
        IoReleaseRemoveLock( &DeviceExtension->RemoveLock, DeviceExtension->DeviceObject->CurrentIrp );
        IoStartNextPacket( DeviceExtension->DeviceObject, TRUE );
    } else {
        if (KeRemoveEntryDeviceQueue( &DeviceObject->DeviceQueue, &Irp->Tail.Overlay.DeviceQueueEntry )) {
            IoReleaseCancelSpinLock( Irp->CancelIrql );
            if (DeviceExtension->InitData->CancelRoutine) {
                DeviceExtension->InitData->CancelRoutine( DeviceExtension->MiniPortDeviceExtension, Irp, FALSE );
            }
            CompleteRequest( Irp, STATUS_CANCELLED, 0 );
            IoReleaseRemoveLock( &DeviceExtension->RemoveLock, DeviceExtension->DeviceObject->CurrentIrp );
            IoStartNextPacket( DeviceExtension->DeviceObject, TRUE );
        } else {
            IoReleaseCancelSpinLock( Irp->CancelIrql );
        }
    }
}


BOOLEAN
SaPortStartIoSynchRoutine(
    IN PVOID SynchronizeContext
    )

/*++

Routine Description:

   This routine is called through a call to KeSynchronizeExecution and is used
   to synchronize the StartIO calls for a miniport with it's ISR access to any
   hardware.  This function is currently used for read and write IRPS only and
   passes the calls through to the miniport, returning any status code to the
   caller of KeSynchronizeExecution.

Arguments:

   SynchronizeContext   - Void pointer that is really a SAPORT_IOCONTEXT packet.

Return Value:

    Always TRUE, the status code is found in IoContext->Status.

--*/

{
    PSAPORT_IOCONTEXT IoContext = (PSAPORT_IOCONTEXT)SynchronizeContext;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(IoContext->Irp);


    IoContext->Status = IoContext->IoRoutine(
        IoContext->MiniPortDeviceExtension,
        IoContext->Irp,
        IrpSp->FileObject ? IrpSp->FileObject->FsContext : NULL,
        IoContext->StartingOffset,
        IoContext->IoBuffer,
        IoContext->IoLength
        );

    return TRUE;
}


VOID
SaPortStartIo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

   This routine is the dispatch point for the StartIo call by the I/O manager.
   The function simply calls the associated miniport's I/O handler and completes
   the IRP if the miniport returns STATUS_PENDING.

Arguments:

   DeviceObject         - The device object for the target device.
   Irp                  - Pointer to an IRP structure that describes the requested I/O operation.

Return Value:

    NT status code.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PDEVICE_EXTENSION DeviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);
    SAPORT_IOCONTEXT IoContext;


    __try {

        Status = IoAcquireRemoveLock( &DeviceExtension->RemoveLock, Irp );
        if (!NT_SUCCESS(Status)) {
            ERROR_RETURN( DeviceExtension->DeviceType, "IoAcquireRemoveLock failed", Status );
        }

        IoContext.IoBuffer = (PUCHAR) MmGetSystemAddressForMdlSafe( Irp->MdlAddress, NormalPagePriority );
        if (IoContext.IoBuffer == NULL) {
            ERROR_RETURN( DeviceExtension->DeviceType, "MmGetSystemAddressForMdlSafe failed", Status );
        }

        switch (IrpSp->MajorFunction) {
            case IRP_MJ_READ:
                IoContext.IoRoutine = DeviceExtension->InitData->Read;
                IoContext.IoLength = IrpSp->Parameters.Read.Length;
                IoContext.StartingOffset = IrpSp->Parameters.Read.ByteOffset.QuadPart;
                break;

            case IRP_MJ_WRITE:
                IoContext.IoRoutine = DeviceExtension->InitData->Write;
                IoContext.IoLength = IrpSp->Parameters.Write.Length;
                IoContext.StartingOffset = IrpSp->Parameters.Write.ByteOffset.QuadPart;
                break;

            default:
                IoContext.IoRoutine = NULL;
                break;
        }

        if (IoContext.IoRoutine) {
            if (DeviceExtension->InterruptObject) {
                IoContext.MiniPortDeviceExtension = DeviceExtension->MiniPortDeviceExtension;
                IoContext.Irp = Irp;
                KeSynchronizeExecution(
                    DeviceExtension->InterruptObject,
                    SaPortStartIoSynchRoutine,
                    &IoContext
                    );
                Status = IoContext.Status;
            } else {
                Status = IoContext.IoRoutine(
                    DeviceExtension->MiniPortDeviceExtension,
                    Irp,
                    IrpSp->FileObject ? IrpSp->FileObject->FsContext : NULL,
                    IoContext.StartingOffset,
                    IoContext.IoBuffer,
                    IoContext.IoLength
                    );
            }
        } else {
            Status = STATUS_NOT_SUPPORTED;
        }


    } __finally {

    }

    if (Status != STATUS_SUCCESS && Status != STATUS_PENDING) {
        REPORT_ERROR( DeviceExtension->DeviceType, "Miniport I/O routine failed", Status );
    }

    if (Status == STATUS_SUCCESS || Status != STATUS_PENDING) {
        IoReleaseRemoveLock( &DeviceExtension->RemoveLock, Irp );
        CompleteRequest( Irp, Status, 0 );
        IoStartNextPacket( DeviceExtension->DeviceObject, TRUE );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serveravailability\saport\keypad.cpp ===
/*++

Copyright (c) 1991 - 2001 Microsoft Corporation

Module Name:

    ##  ## ##### ##  ## #####    ###   #####       ####  #####  #####
    ## ##  ##    ##  ## ##  ##   ###   ##  ##     ##   # ##  ## ##  ##
    ####   ##     ####  ##  ##  ## ##  ##   ##    ##     ##  ## ##  ##
    ###    #####  ####  ##  ##  ## ##  ##   ##    ##     ##  ## ##  ##
    ####   ##      ##   #####  ####### ##   ##    ##     #####  #####
    ## ##  ##      ##   ##     ##   ## ##  ##  ## ##   # ##     ##
    ##  ## #####   ##   ##     ##   ## #####   ##  ####  ##     ##

Abstract:

    This module contains functions specfic to the
    keypad device.  The logic in this module is not
    hardware specific, but is logic that is common
    to all hardware implementations.

Author:

    Wesley Witt (wesw) 1-Oct-2001

Environment:

    Kernel mode only.

Notes:


--*/

#include "internal.h"


NTSTATUS
SaKeypadDeviceInitialization(
    IN PSAPORT_DRIVER_EXTENSION DriverExtension
    )

/*++

Routine Description:

   This is the keypad specific code for driver initialization.
   This function is called by SaPortInitialize, which is called by
   the keypad driver's DriverEntry function.

Arguments:

   DriverExtension      - Driver extension structure

Return Value:

    NT status code.

--*/

{
    UNREFERENCED_PARAMETER(DriverExtension);
    return STATUS_SUCCESS;
}


NTSTATUS
SaKeypadIoValidation(
    IN PKEYPAD_DEVICE_EXTENSION DeviceExtension,
    IN PIRP Irp,
    PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

   This is the keypad specific code for processing all I/O validation for reads and writes.

Arguments:

   DeviceExtension      - Display device extension
   Irp                  - Pointer to an IRP structure that describes the requested I/O operation.
   IrpSp                - Irp stack pointer

Return Value:

    NT status code.

--*/

{
    ULONG Length;


    UNREFERENCED_PARAMETER(DeviceExtension);
    UNREFERENCED_PARAMETER(Irp);

    if (IrpSp->MajorFunction == IRP_MJ_READ) {
        Length = (ULONG)IrpSp->Parameters.Read.Length;
    } else if (IrpSp->MajorFunction == IRP_MJ_WRITE) {
        Length = (ULONG)IrpSp->Parameters.Write.Length;
    } else {
        REPORT_ERROR( DeviceExtension->DeviceType, "Invalid I/O request", STATUS_INVALID_PARAMETER_1 );
        return STATUS_INVALID_PARAMETER_1;
    }

    if (Length < sizeof(UCHAR)) {
        REPORT_ERROR( DeviceExtension->DeviceType, "I/O length != sizeof(UCHAR)", STATUS_INVALID_PARAMETER_2 );
        return STATUS_INVALID_PARAMETER_2;
    }

    return STATUS_SUCCESS;
}


NTSTATUS
SaKeypadShutdownNotification(
    IN PKEYPAD_DEVICE_EXTENSION DeviceExtension,
    IN PIRP Irp,
    PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

   This is the keypad specific code for processing the system shutdown notification.

Arguments:

   DeviceExtension      - Display device extension
   Irp                  - Pointer to an IRP structure that describes the requested I/O operation.
   IrpSp                - Irp stack pointer

Return Value:

    NT status code.

--*/

{
    UNREFERENCED_PARAMETER(DeviceExtension);
    UNREFERENCED_PARAMETER(Irp);
    UNREFERENCED_PARAMETER(IrpSp);
    return STATUS_SUCCESS;
}


NTSTATUS
SaKeypadStartDevice(
    IN PKEYPAD_DEVICE_EXTENSION DeviceExtension
    )

/*++

Routine Description:

   This is the keypad specific code for processing the PNP start device request.

Arguments:

   DeviceExtension      - Keypad device extension

Return Value:

    NT status code.

--*/

{
    UNREFERENCED_PARAMETER(DeviceExtension);
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serveravailability\saport\internal.h ===
/*++

Copyright (c) 1991 - 2001 Microsoft Corporation

Module Name:

    #### ##   # ###### ##### #####  ##   #   ###   ##       ##   ##
     ##  ###  #   ##   ##    ##  ## ###  #   ###   ##       ##   ##
     ##  #### #   ##   ##    ##  ## #### #  ## ##  ##       ##   ##
     ##  # ####   ##   ##### #####  # ####  ## ##  ##       #######
     ##  #  ###   ##   ##    ####   #  ### ####### ##       ##   ##
     ##  #   ##   ##   ##    ## ##  #   ## ##   ## ##    ## ##   ##
    #### #    #   ##   ##### ##  ## #    # ##   ## ##### ## ##   ##

Abstract:

    This header contains all definitions that are internal
    to the port driver.

Author:

    Wesley Witt (wesw) 1-Oct-2001

Environment:

    Kernel mode only.

Notes:

--*/

extern "C" {
#include <ntosp.h>
#include <zwapi.h>
#include <mountmgr.h>
#include <mountdev.h>
#include <ntddstor.h>
#include <ntdddisk.h>
#include <wdmsec.h>
#include <stdio.h>
}

#define MINIPORT_DEVICE_TYPE 0

#include "saport.h"

#pragma warning(error:4101)   // Unreferenced local variable

#ifdef POOL_TAGGING
#ifdef ExAllocatePool
#undef ExAllocatePool
#endif
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'tpaS')
#endif


#define STRING_SZ(_str)     (wcslen((PWSTR)_str)*sizeof(WCHAR))
#define ARRAY_SZ(_ary)      (sizeof(_ary)/sizeof(_ary[0]))

#define SecToNano(_sec)     (LONGLONG)((_sec) * 1000 * 1000 * 10)
#define NanoToSec(_nano)    (ULONG)((_nano) / (1000 * 1000 * 10))

#define MARK_IRP_INTERNAL(_irp)     (_irp)->Flags |= 0x80
#define IS_IRP_INTERNAL(_irp)       (((_irp)->Flags & 0x80) > 0)


typedef struct _SAPORT_DRIVER_EXTENSION {
    SAPORT_INITIALIZATION_DATA      InitData;
    PDRIVER_OBJECT                  DriverObject;
    UNICODE_STRING                  RegistryPath;
} SAPORT_DRIVER_EXTENSION, *PSAPORT_DRIVER_EXTENSION;


//
// Device extension structures
//


#define DEVICE_EXTENSION_UNKNOWN       (0)
#define DEVICE_EXTENSION_DISPLAY       (1)
#define DEVICE_EXTENSION_KEYPAD        (2)
#define DEVICE_EXTENSION_NVRAM         (3)
#define DEVICE_EXTENSION_WATCHDOG      (4)

typedef struct _DEVICE_EXTENSION {
    ULONG                           DeviceExtensionType;
    ULONG                           DeviceType;
    PDEVICE_OBJECT                  DeviceObject;
    PDRIVER_OBJECT                  DriverObject;
    PDEVICE_OBJECT                  TargetObject;
    PDEVICE_OBJECT                  Pdo;
    LONG                            IsStarted;
    LONG                            IsRemoved;
    PVOID                           MiniPortDeviceExtension;
    PSAPORT_INITIALIZATION_DATA     InitData;
    IO_REMOVE_LOCK                  RemoveLock;
    PSAPORT_DRIVER_EXTENSION        DriverExtension;
    PKINTERRUPT                     InterruptObject;
} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

typedef struct _SAPORT_IOCONTEXT {
    NTSTATUS                        Status;
    PSA_IO_ROUTINE                  IoRoutine;
    PUCHAR                          IoBuffer;
    ULONG                           IoLength;
    LONGLONG                        StartingOffset;
    PVOID                           MiniPortDeviceExtension;
    PIRP                            Irp;
} SAPORT_IOCONTEXT, *PSAPORT_IOCONTEXT;

typedef struct _SAPORT_FSCONTEXT {
    ULONGLONG                       CurrentPosition;
} SAPORT_FSCONTEXT, *PSAPORT_FSCONTEXT;



PDEVICE_EXTENSION
FORCEINLINE
DeviceExtentionFromMiniPort(
    IN PVOID MiniPortDeviceExtension
    )
{
    return (PDEVICE_EXTENSION)((PUCHAR)MiniPortDeviceExtension - *(PULONG)((PUCHAR)MiniPortDeviceExtension - sizeof(ULONG)));
}

//
// IOCTL processing
//

#define DECLARE_IOCTL_HANDLER(_NAME) \
    NTSTATUS \
    _NAME( \
        IN PDEVICE_OBJECT DeviceObject, \
        IN PIRP Irp, \
        IN PDEVICE_EXTENSION DeviceExtension, \
        IN PVOID InputBuffer, \
        IN ULONG InputBufferLength, \
        IN PVOID OutputBuffer, \
        IN ULONG OutputBufferLength \
        )

#define DO_DEFAULT() DefaultIoctlHandler( DeviceObject, Irp, DeviceExtension, InputBuffer, InputBufferLength, OutputBuffer, OutputBufferLength )

//
// IOCTL handler prototypes
//

DECLARE_IOCTL_HANDLER( DefaultIoctlHandler );
DECLARE_IOCTL_HANDLER( UnsupportedIoctlHandler );
DECLARE_IOCTL_HANDLER( HandleGetVersion );
DECLARE_IOCTL_HANDLER( HandleGetCaps );
DECLARE_IOCTL_HANDLER( HandleDisplayLock );
DECLARE_IOCTL_HANDLER( HandleDisplayUnlock );
DECLARE_IOCTL_HANDLER( HandleDisplayBusyMessage );
DECLARE_IOCTL_HANDLER( HandleDisplayShutdownMessage );
DECLARE_IOCTL_HANDLER( HandleDisplayChangeLanguage  );
DECLARE_IOCTL_HANDLER( HandleWdDisable );
DECLARE_IOCTL_HANDLER( HandleWdQueryExpireBehavior );
DECLARE_IOCTL_HANDLER( HandleWdSetExpireBehavior );
DECLARE_IOCTL_HANDLER( HandleWdPing );
DECLARE_IOCTL_HANDLER( HandleWdQueryTimer );
DECLARE_IOCTL_HANDLER( HandleWdSetTimer );
DECLARE_IOCTL_HANDLER( HandleWdDelayBoot );
DECLARE_IOCTL_HANDLER( HandleNvramWriteBootCounter );
DECLARE_IOCTL_HANDLER( HandleNvramReadBootCounter );
DECLARE_IOCTL_HANDLER( HandleDisplayStoreBitmap );

//
// Miniport specific header files
//

#include "display.h"
#include "keypad.h"
#include "nvram.h"
#include "watchdog.h"

//
// OS Versioning Stuff
//

extern ULONG OsMajorVersion;
extern ULONG OsMinorVersion;

#define RunningOnWin2k  (OsMajorVersion == 5 && OsMinorVersion == 0)
#define RunningOnWinXp  (OsMajorVersion == 5 && OsMinorVersion == 1)

//
// Debug Stuff
//

#define ERROR_RETURN(_dt_,_msg_,_status_) \
    { \
        REPORT_ERROR(_dt_,_msg_,_status_); \
        __leave; \
    }

#if DBG
PCHAR
PnPMinorFunctionString(
    UCHAR MinorFunction
    );

PCHAR
IoctlString(
    ULONG IoControlCode
    );

PCHAR
PowerMinorFunctionString(
    UCHAR MinorFunction
    );

PCHAR
PowerSystemStateString(
    SYSTEM_POWER_STATE State
    );

PCHAR
PowerDeviceStateString(
    DEVICE_POWER_STATE State
    );

PCHAR
PnPMinorFunctionString(
    UCHAR MinorFunction
    );
#endif

//
// prototypes
//

extern "C" {

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
SaPortStartIo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SaPortCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SaPortCleanup(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SaPortClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SaPortPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SaPortAddDevice(
    IN      PDRIVER_OBJECT DriverObject,
    IN OUT  PDEVICE_OBJECT PhysicalDeviceObject
    );

NTSTATUS
SaPortPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SaPortWrite(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   );

NTSTATUS
SaPortRead(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   );

NTSTATUS
SaPortDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SaPortShutdown(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SaPortSystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
SaPortCancelRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

} // extern "C"


//
// util.cpp
//

VOID
PrintDriverVersion(
    IN ULONG DeviceType,
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
CallLowerDriverAndWait(
    IN PIRP Irp,
    IN PDEVICE_OBJECT TargetObject
    );

NTSTATUS
GetBootPartitionNumber(
    OUT PULONG DiskNumber,
    OUT PULONG PartitionNumber,
    OUT PULONG AbsolutePartNumber
    );

NTSTATUS
CompleteRequest(
    PIRP Irp,
    NTSTATUS Status,
    ULONG_PTR OutputLength
    );

NTSTATUS
ForwardRequest(
    IN PIRP Irp,
    IN PDEVICE_OBJECT TargetObject
    );

NTSTATUS
CallMiniPortDriverReadWrite(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN WriteIo,
    IN PVOID Buffer,
    IN ULONG Length,
    IN ULONG Offset
    );

NTSTATUS
CallMiniPortDriverDeviceControl(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG IoControlCode,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer,
    IN ULONG OutputBufferLength
    );

NTSTATUS
OpenParametersRegistryKey(
    IN PSAPORT_DRIVER_EXTENSION DriverExtension,
    IN PUNICODE_STRING RegistryPath,
    IN ULONG AccessMode,
    OUT PHANDLE RegistryHandle
    );

NTSTATUS
CreateParametersRegistryKey(
    IN PSAPORT_DRIVER_EXTENSION DriverExtension,
    IN PUNICODE_STRING RegistryPath,
    OUT PHANDLE parametersKey
    );

NTSTATUS
ReadRegistryValue(
    IN PSAPORT_DRIVER_EXTENSION DriverExtension,
    IN PUNICODE_STRING RegistryPath,
    IN PWSTR ValueName,
    OUT PKEY_VALUE_FULL_INFORMATION *KeyInformation
    );

NTSTATUS
WriteRegistryValue(
    IN PSAPORT_DRIVER_EXTENSION DriverExtension,
    IN PUNICODE_STRING RegistryPath,
    IN PWSTR ValueName,
    IN ULONG RegistryType,
    IN PVOID RegistryValue,
    IN ULONG RegistryValueLength
    );

VOID
GetOsVersion(
    VOID
    );

//
// ******************************************
//
// From NTDDK.H
//
// ******************************************
//
extern "C" {

typedef
VOID
(*PCREATE_PROCESS_NOTIFY_ROUTINE)(
    IN HANDLE ParentId,
    IN HANDLE ProcessId,
    IN BOOLEAN Create
    );

NTSTATUS
PsSetCreateProcessNotifyRoutine(
    IN PCREATE_PROCESS_NOTIFY_ROUTINE NotifyRoutine,
    IN BOOLEAN Remove
    );

BOOLEAN
PsGetVersion(
    PULONG MajorVersion OPTIONAL,
    PULONG MinorVersion OPTIONAL,
    PULONG BuildNumber OPTIONAL,
    PUNICODE_STRING CSDVersion OPTIONAL
    );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serveravailability\saport\keypad.h ===
/*++

Copyright (c) 1991 - 2001 Microsoft Corporation

Module Name:

    ##  ## ##### ##  ## #####    ###   #####      ##   ##
    ## ##  ##    ##  ## ##  ##   ###   ##  ##     ##   ##
    ####   ##     ####  ##  ##  ## ##  ##   ##    ##   ##
    ###    #####  ####  ##  ##  ## ##  ##   ##    #######
    ####   ##      ##   #####  ####### ##   ##    ##   ##
    ## ##  ##      ##   ##     ##   ## ##  ##  ## ##   ##
    ##  ## #####   ##   ##     ##   ## #####   ## ##   ##

Abstract:

    This header file contains all the global
    definitions for the keypad device.

Author:

    Wesley Witt (wesw) 1-Oct-2001

Environment:

    Kernel mode only.

Notes:


--*/



typedef struct _KEYPAD_DEVICE_EXTENSION : _DEVICE_EXTENSION {
    // Empty
} KEYPAD_DEVICE_EXTENSION, *PKEYPAD_DEVICE_EXTENSION;


NTSTATUS
SaKeypadIoValidation(
    IN PKEYPAD_DEVICE_EXTENSION DeviceExtension,
    IN PIRP Irp,
    PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
SaKeypadDeviceInitialization(
    IN PSAPORT_DRIVER_EXTENSION DriverExtension
    );

NTSTATUS
SaKeypadShutdownNotification(
    IN PKEYPAD_DEVICE_EXTENSION DeviceExtension,
    IN PIRP Irp,
    PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
SaKeypadStartDevice(
    IN PKEYPAD_DEVICE_EXTENSION DeviceExtension
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serveravailability\saport\ioctl.cpp ===
/*++

Copyright (c) 1991 - 2001 Microsoft Corporation

Module Name:

    ####  #####   ####  ###### ##        ####  #####  #####
     ##  ##   ## ##   #   ##   ##       ##   # ##  ## ##  ##
     ##  ##   ## ##       ##   ##       ##     ##  ## ##  ##
     ##  ##   ## ##       ##   ##       ##     ##  ## ##  ##
     ##  ##   ## ##       ##   ##       ##     #####  #####
     ##  ##   ## ##   #   ##   ##    ## ##   # ##     ##
    ####  #####   ####    ##   ##### ##  ####  ##     ##

Abstract:

    This module contains the dispatcher for processing all
    IOCTL requests.  This module also contains all code for
    device controls that are global to all miniport drivers.

Author:

    Wesley Witt (wesw) 1-Oct-2001

Environment:

    Kernel mode only.

Notes:


--*/

#include "internal.h"


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,SaPortDeviceControl)
#endif



//
// IOCTL dispatch table
//

typedef NTSTATUS (*PIOCTL_DISPATCH_FUNC)(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength,
    IN PVOID OutputBuffer,
    IN ULONG OutputBufferLength
    );

//
// All IOCTLs are dispatched through this table.  There are 16 dispatch
// entry points for the public miniports, all private IOCTLs must
// follow these dispatch entry points.
//

PIOCTL_DISPATCH_FUNC IoctlDispatchTable[] =
{
    HandleGetVersion,                      //   0  FUNC_SA_GET_VERSION,
    HandleGetCaps,                         //   1  FUNC_SA_GET_CAPABILITIES,
    HandleWdDisable,                       //   2  FUNC_SAWD_DISABLE,
    HandleWdQueryExpireBehavior,           //   3  FUNC_SAWD_QUERY_EXPIRE_BEHAVIOR,
    HandleWdSetExpireBehavior,             //   4  FUNC_SAWD_SET_EXPIRE_BEHAVIOR,
    HandleWdPing,                          //   5  FUNC_SAWD_PING,
    HandleWdQueryTimer,                    //   6  FUNC_SAWD_QUERY_TIMER,
    HandleWdSetTimer,                      //   7  FUNC_SAWD_SET_TIMER,
    HandleWdDelayBoot,                     //   8  FUNC_SAWD_DELAY_BOOT
    HandleNvramWriteBootCounter,           //   9  FUNC_NVRAM_WRITE_BOOT_COUNTER,
    HandleNvramReadBootCounter,            //   A  FUNC_NVRAM_READ_BOOT_COUNTER,
    DefaultIoctlHandler,                   //   B
    HandleDisplayLock,                     //   C  FUNC_SADISPLAY_LOCK,
    HandleDisplayUnlock,                   //   D  FUNC_SADISPLAY_UNLOCK,
    HandleDisplayBusyMessage,              //   E  FUNC_SADISPLAY_BUSY_MESSAGE,
    HandleDisplayShutdownMessage,          //   F  FUNC_SADISPLAY_SHUTDOWN_MESSAGE,
    HandleDisplayChangeLanguage,           //  10  FUNC_SADISPLAY_CHANGE_LANGUAGE,
    HandleDisplayStoreBitmap,              //  11  FUNC_DISPLAY_STORE_BITMAP
    DefaultIoctlHandler,                   //  12
    DefaultIoctlHandler,                   //  13
    DefaultIoctlHandler,                   //  14
    DefaultIoctlHandler,                   //  15
    DefaultIoctlHandler,                   //  16
    DefaultIoctlHandler,                   //  17
    DefaultIoctlHandler,                   //  18
    DefaultIoctlHandler,                   //  19
    DefaultIoctlHandler,                   //  1A
    DefaultIoctlHandler,                   //  1B
    DefaultIoctlHandler,                   //  1C
    DefaultIoctlHandler,                   //  1D
    DefaultIoctlHandler,                   //  1E
    DefaultIoctlHandler,                   //  1F
    DefaultIoctlHandler                    //  20
};



DECLARE_IOCTL_HANDLER( UnsupportedIoctlHandler )

/*++

Routine Description:

   This routine handles all unsupported IOCTLs.  It's job is to simply complete
   the IRP with the status code set to STATUS_INVALID_DEVICE_REQUEST.

Arguments:

   DeviceObject         - The device object for the target device.
   Irp                  - Pointer to an IRP structure that describes the requested I/O operation.
   DeviceExtension      - Pointer to the main port driver device extension.
   InputBuffer          - Pointer to the user's input buffer
   InputBufferLength    - Length in bytes of the input buffer
   OutputBuffer         - Pointer to the user's output buffer
   OutputBufferLength   - Length in bytes of the output buffer

Return Value:

   Always STATUS_INVALID_DEVICE_REQUEST.

--*/

{
    return CompleteRequest( Irp, STATUS_INVALID_DEVICE_REQUEST, 0 );
}


DECLARE_IOCTL_HANDLER( DefaultIoctlHandler )

/*++

Routine Description:

   This routine is called by all of the subsequent IOCTL handlers.  It's job
   is to call the IOCTL handler in the associated miniport driver and then
   complete the IRP.

Arguments:

   DeviceObject         - The device object for the target device.
   Irp                  - Pointer to an IRP structure that describes the requested I/O operation.
   DeviceExtension      - Pointer to the main port driver device extension.
   InputBuffer          - Pointer to the user's input buffer
   InputBufferLength    - Length in bytes of the input buffer
   OutputBuffer         - Pointer to the user's output buffer
   OutputBufferLength   - Length in bytes of the output buffer

Return Value:

   NT status code.

--*/

{
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);

    NTSTATUS Status = DeviceExtension->InitData->DeviceIoctl(
        DeviceExtension->MiniPortDeviceExtension,
        Irp,
        IrpSp->FileObject ? IrpSp->FileObject->FsContext : NULL,
        IoGetFunctionCodeFromCtlCode( IrpSp->Parameters.DeviceIoControl.IoControlCode ),
        InputBuffer,
        InputBufferLength,
        OutputBuffer,
        OutputBufferLength
        );

    if (Status != STATUS_PENDING) {
        if (!NT_SUCCESS(Status)) {
            REPORT_ERROR( DeviceExtension->DeviceType, "Miniport device control routine failed", Status );
        }
        Status = CompleteRequest( Irp, Status, OutputBufferLength );
    }

    return Status;
}


DECLARE_IOCTL_HANDLER( HandleGetVersion )

/*++

Routine Description:

   This routine processes the IOCTL_SA_GET_VERSION request for all
   miniport drivers.  It is required that all miniports support
   this IOCTL.

Arguments:

   DeviceObject         - The device object for the target device.
   Irp                  - Pointer to an IRP structure that describes the requested I/O operation.
   DeviceExtension      - Pointer to the main port driver device extension.
   InputBuffer          - Pointer to the user's input buffer
   InputBufferLength    - Length in bytes of the input buffer
   OutputBuffer         - Pointer to the user's output buffer
   OutputBufferLength   - Length in bytes of the output buffer

Return Value:

   NT status code.

--*/

{
    if (OutputBufferLength != sizeof(ULONG)) {
        REPORT_ERROR( DeviceExtension->DeviceType, "Output buffer length != sizeof(ULONG)", STATUS_INVALID_BUFFER_SIZE );
        return CompleteRequest( Irp, STATUS_INVALID_BUFFER_SIZE, 0 );
    }

    return DO_DEFAULT();
}


DECLARE_IOCTL_HANDLER( HandleGetCaps )

/*++

Routine Description:

   This routine processes the IOCTL_SA_GET_CAPABILITIES request for all
   miniport drivers.  It is required that all miniports support
   this IOCTL.  Eventhough this function process the IOCTL for all miniports
   the specifics of any given miniport driver is cased in various switch
   statements.

Arguments:

   DeviceObject         - The device object for the target device.
   Irp                  - Pointer to an IRP structure that describes the requested I/O operation.
   DeviceExtension      - Pointer to the main port driver device extension.
   InputBuffer          - Pointer to the user's input buffer
   InputBufferLength    - Length in bytes of the input buffer
   OutputBuffer         - Pointer to the user's output buffer
   OutputBufferLength   - Length in bytes of the output buffer

Return Value:

   NT status code.

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);
    ULONG DeviceCapsSize = 0;


    switch (DeviceExtension->InitData->DeviceType) {
        case SA_DEVICE_DISPLAY:
            DeviceCapsSize = sizeof(SA_DISPLAY_CAPS);
            break;

        case SA_DEVICE_KEYPAD:
            DeviceCapsSize = 0;
            break;

        case SA_DEVICE_NVRAM:
            DeviceCapsSize = sizeof(SA_NVRAM_CAPS);
            break;

        case SA_DEVICE_WATCHDOG:
            DeviceCapsSize = sizeof(SA_WD_CAPS);
            break;

        default:
            DeviceCapsSize = 0;
            break;
    }

    if (OutputBufferLength != DeviceCapsSize) {
        REPORT_ERROR( DeviceExtension->DeviceType, "Output buffer wrong length", STATUS_INVALID_BUFFER_SIZE );
        return CompleteRequest( Irp, STATUS_INVALID_BUFFER_SIZE, DeviceCapsSize );
    }

    Status = DeviceExtension->InitData->DeviceIoctl(
        DeviceExtension->MiniPortDeviceExtension,
        Irp,
        NULL,
        IoGetFunctionCodeFromCtlCode( IrpSp->Parameters.DeviceIoControl.IoControlCode ),
        InputBuffer,
        InputBufferLength,
        OutputBuffer,
        OutputBufferLength
        );
    if (NT_SUCCESS(Status)) {
        switch (DeviceExtension->InitData->DeviceType) {
            case SA_DEVICE_DISPLAY:
                break;

            case SA_DEVICE_KEYPAD:
                break;

            case SA_DEVICE_NVRAM:
                {
                    PSA_NVRAM_CAPS NvramCaps = (PSA_NVRAM_CAPS)OutputBuffer;
                    if (NvramCaps->NvramSize < SA_NVRAM_MINIMUM_SIZE) {
                        Status = STATUS_INVALID_BUFFER_SIZE;
                    } else {
                        NvramCaps->NvramSize -= NVRAM_RESERVED_BOOTCOUNTER_SLOTS;
                        NvramCaps->NvramSize -= NVRAM_RESERVED_DRIVER_SLOTS;
                    }
                }
                break;

            case SA_DEVICE_WATCHDOG:
                break;

            default:
                break;
        }
    } else {
        REPORT_ERROR( DeviceExtension->DeviceType, "Miniport device control routine failed", Status );
    }

    return CompleteRequest( Irp, Status, OutputBufferLength );
}


NTSTATUS
SaPortDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

   This routine is called by the I/O system to perform a device I/O
   control function.

Arguments:

   DeviceObject - a pointer to the object that represents the device
   that I/O is to be done on.

   Irp - a pointer to the I/O Request Packet for this request.

Return Value:

   STATUS_SUCCESS or STATUS_PENDING if recognized I/O control code,
   STATUS_INVALID_DEVICE_REQUEST otherwise.

--*/

{
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);
    PDEVICE_EXTENSION DeviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    NTSTATUS Status;
    ULONG FuncCode;
    ULONG Idx;
    PVOID OutputBuffer;
    ULONG OutputBufferLength;
    PIOCTL_DISPATCH_FUNC DispatchFunc;


    if (DeviceExtension->IsRemoved) {
        return CompleteRequest( Irp, STATUS_DELETE_PENDING, 0 );
    }

    if (!DeviceExtension->IsStarted) {
        return CompleteRequest( Irp, STATUS_NO_SUCH_DEVICE, 0 );
    }

    DebugPrint(( DeviceExtension->DeviceType, SAPORT_DEBUG_INFO_LEVEL, "IOCTL - [0x%08x] %s\n",
        IrpSp->Parameters.DeviceIoControl.IoControlCode,
        IoctlString(IrpSp->Parameters.DeviceIoControl.IoControlCode)
        ));

    if (DEVICE_TYPE_FROM_CTL_CODE(IrpSp->Parameters.DeviceIoControl.IoControlCode) != FILE_DEVICE_SERVER_AVAILABILITY) {
        return CompleteRequest( Irp, STATUS_INVALID_PARAMETER_1, 0 );
    }

    FuncCode = IoGetFunctionCodeFromCtlCode( IrpSp->Parameters.DeviceIoControl.IoControlCode );
    Idx = FuncCode - IOCTL_SERVERAVAILABILITY_BASE;

    if (Irp->MdlAddress) {
        OutputBuffer = (PVOID) MmGetSystemAddressForMdlSafe( Irp->MdlAddress, NormalPagePriority );
        if (OutputBuffer == NULL) {
            REPORT_ERROR( DeviceExtension->DeviceType, "MmGetSystemAddressForMdlSafe failed", STATUS_INSUFFICIENT_RESOURCES );
            return CompleteRequest( Irp, STATUS_INSUFFICIENT_RESOURCES, 0 );
        }
        OutputBufferLength = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;
    } else {
        OutputBuffer = NULL;
        OutputBufferLength = 0;
    }

    if ((Idx > sizeof(IoctlDispatchTable)/sizeof(PIOCTL_DISPATCH_FUNC)) || (DeviceExtension->InitData->DeviceIoctl == NULL)) {
        DispatchFunc = UnsupportedIoctlHandler;
    } else {
        DispatchFunc = IoctlDispatchTable[Idx];
    }

    Status = DispatchFunc(
        DeviceObject,
        Irp,
        DeviceExtension,
        Irp->AssociatedIrp.SystemBuffer,
        IrpSp->Parameters.DeviceIoControl.InputBufferLength,
        OutputBuffer,
        OutputBufferLength
        );
    if (!NT_SUCCESS(Status)) {
        REPORT_ERROR( DeviceExtension->DeviceType, "Device control dispatch routine failed", Status );
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serveravailability\saport\main.cpp ===
/*++

Copyright (c) 1991 - 2001 Microsoft Corporation

Module Name:

    ##    ##   ###   #### ##   #     ####  #####  #####
    ###  ###   ###    ##  ###  #    ##   # ##  ## ##  ##
    ########  ## ##   ##  #### #    ##     ##  ## ##  ##
    # ### ##  ## ##   ##  # ####    ##     ##  ## ##  ##
    #  #  ## #######  ##  #  ###    ##     #####  #####
    #     ## ##   ##  ##  #   ## ## ##   # ##     ##
    #     ## ##   ## #### #    # ##  ####  ##     ##

Abstract:

    This module contains the code for all driver initializtion
    and create/close IRP processing.

Author:

    Wesley Witt (wesw) 1-Oct-2001

Environment:

    Kernel mode only.

Notes:


--*/

#include "internal.h"


#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,DriverEntry)
#pragma alloc_text(PAGE,SaPortCreate)
#pragma alloc_text(PAGE,SaPortClose)
#pragma alloc_text(PAGE,SaPortSystemControl)
#pragma alloc_text(PAGE,SaPortCleanup)
#endif



#if DBG
extern ULONG SaPortDebugLevel[5];
#endif

ULONG OsMajorVersion;
ULONG OsMinorVersion;



NTSTATUS
DllInitialize(
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    DLL initialization funtion.

Arguments:

    RegistryPath    - String containing the path to the driver's registry data

Return Value:

   STATUS_SUCCESS

--*/

{
    UNREFERENCED_PARAMETER(RegistryPath);
    return STATUS_SUCCESS;
}


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    Temporary entry point needed to initialize the scsi port driver.

Arguments:

    DriverObject    - Pointer to the driver object created by the system.
    RegistryPath    - String containing the path to the driver's registry data

Return Value:

   STATUS_SUCCESS

--*/

{
    //
    // NOTE: This routine should not be needed ! DriverEntry is defined
    // in the miniport driver.
    //

    UNREFERENCED_PARAMETER(DriverObject);
    UNREFERENCED_PARAMETER(RegistryPath);
    return STATUS_SUCCESS;

}


NTSTATUS
SaPortDefaultDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the default dispatch which passes down to the next layer.

Arguments:

    DeviceObject    - Supplies the device object.
    Irp             - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    UNREFERENCED_PARAMETER(DeviceObject);
    return CompleteRequest( Irp, STATUS_INVALID_DEVICE_REQUEST, 0 );
}


NTSTATUS
SaPortInitialize(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath,
    IN PSAPORT_INITIALIZATION_DATA SaPortInitData
    )

/*++

Routine Description:

    This function is the port driver's substitute for the miniport's DriverEntry
    routine.  The miniport driver MUST call this function from it's DriverEntry
    to initialize the driver stack.

Arguments:

    DriverObject    - Pointer to the driver object created by the system.
    RegistryPath    - String containing the path to the driver's registry data
    SaPortInitData  - Pointer to the miniport's SAPORT_INITIALIZATION_DATA data structure

Return Value:

   NT status code

--*/

{
    NTSTATUS Status;
    PSAPORT_DRIVER_EXTENSION DriverExtension;
    PKEY_VALUE_FULL_INFORMATION KeyInformation = NULL;


    //
    // Create and initialize the driver extension
    //

    DriverExtension = (PSAPORT_DRIVER_EXTENSION)IoGetDriverObjectExtension( DriverObject, SaPortInitialize );
    if (DriverExtension == NULL) {
        Status = IoAllocateDriverObjectExtension(
            DriverObject,
            SaPortInitialize,
            sizeof(SAPORT_DRIVER_EXTENSION),
            (PVOID*)&DriverExtension
            );
        if (!NT_SUCCESS(Status)) {
            DebugPrint(( SaPortInitData->DeviceType, SAPORT_DEBUG_ERROR_LEVEL, "IoAllocateDriverObjectExtension failed [0x%08x]\n", Status ));
            return Status;
        }
    }

    RtlCopyMemory( &DriverExtension->InitData, SaPortInitData, sizeof(SAPORT_INITIALIZATION_DATA) );

    DriverExtension->RegistryPath.Buffer = (PWSTR) ExAllocatePool( NonPagedPool, RegistryPath->MaximumLength );
    if (DriverExtension->RegistryPath.Buffer == NULL) {
        REPORT_ERROR( SaPortInitData->DeviceType, "Failed to allocate pool for string", STATUS_INSUFFICIENT_RESOURCES );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory( DriverExtension->RegistryPath.Buffer, RegistryPath->Buffer, RegistryPath->Length );

    DriverExtension->RegistryPath.Length = RegistryPath->Length;
    DriverExtension->RegistryPath.MaximumLength = RegistryPath->MaximumLength;

    DriverExtension->DriverObject = DriverObject;

    //
    // Get the OS version; this is used by the
    // port driver and the mini-ports to have
    // OS dependent code that is dynamic at runtime
    //

    GetOsVersion();

    //
    // Get the debug level value from the registry
    //

#if DBG
    SaPortDebugLevel[SaPortInitData->DeviceType] = 0;

    Status = ReadRegistryValue( DriverExtension, RegistryPath, L"DebugLevel", &KeyInformation );
    if (NT_SUCCESS(Status) && KeyInformation->Type == REG_DWORD) {
        SaPortDebugLevel[SaPortInitData->DeviceType] = *(PULONG)((PUCHAR)KeyInformation + KeyInformation->DataOffset);
    }
    if (KeyInformation) {
        ExFreePool( KeyInformation );
    }
#endif

    //
    // Print a banner that includes the
    // OS version and the version/build date
    // of the driver
    //

#if DBG
    PrintDriverVersion( SaPortInitData->DeviceType, DriverObject );
#endif

    //
    // Parameter validation
    //

    if (SaPortInitData == NULL || SaPortInitData->StructSize != sizeof(SAPORT_INITIALIZATION_DATA) ||
        SaPortInitData->HwInitialize == NULL || SaPortInitData->DeviceIoctl == NULL) {

        DebugPrint(( SaPortInitData->DeviceType, SAPORT_DEBUG_ERROR_LEVEL, "SAPORT_INITIALIZATION_DATA fields are invalid [0x%08x]\n", STATUS_INVALID_PARAMETER ));
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Now check the device specific callbacks
    //

    switch (SaPortInitData->DeviceType) {
        case SA_DEVICE_DISPLAY:
            if (SaPortInitData->Write == NULL) {
                return STATUS_INVALID_PARAMETER;
            }
            Status = STATUS_SUCCESS;
            break;

        case SA_DEVICE_KEYPAD:
            if (SaPortInitData->Read == NULL) {
                return STATUS_INVALID_PARAMETER;
            }
            Status = STATUS_SUCCESS;
            break;

        case SA_DEVICE_NVRAM:
            Status = STATUS_SUCCESS;
            break;

        case SA_DEVICE_WATCHDOG:
            Status = STATUS_SUCCESS;
            break;
    }

    if (!NT_SUCCESS(Status)) {
        DebugPrint(( SaPortInitData->DeviceType, SAPORT_DEBUG_ERROR_LEVEL, "SAPORT_INITIALIZATION_DATA fields are invalid [0x%08x]\n", Status ));
        return Status;
    }

    //
    // Do any device specific initialization
    //

    switch (SaPortInitData->DeviceType) {
        case SA_DEVICE_DISPLAY:
            Status = SaDisplayDeviceInitialization( DriverExtension );
            break;

        case SA_DEVICE_KEYPAD:
            Status = SaKeypadDeviceInitialization( DriverExtension );
            break;

        case SA_DEVICE_NVRAM:
            Status = SaNvramDeviceInitialization( DriverExtension );
            break;

        case SA_DEVICE_WATCHDOG:
            Status = SaWatchdogDeviceInitialization( DriverExtension );
            break;
    }

    if (!NT_SUCCESS(Status)) {
        DebugPrint(( SaPortInitData->DeviceType, SAPORT_DEBUG_ERROR_LEVEL, "Device specific initialization failed [0x%08x]\n", Status ));
        return Status;
    }

    //
    // Set up the device driver entry points.
    //

    for (ULONG i=0; i<=IRP_MJ_MAXIMUM_FUNCTION; i++) {
        DriverObject->MajorFunction[i] = SaPortDefaultDispatch;
    }

    DriverObject->MajorFunction[IRP_MJ_CREATE] = SaPortCreate;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] = SaPortClose;
    DriverObject->MajorFunction[IRP_MJ_READ] = SaPortRead;
    DriverObject->MajorFunction[IRP_MJ_WRITE] = SaPortWrite;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = SaPortDeviceControl;
    DriverObject->MajorFunction[IRP_MJ_PNP] = SaPortPnp;
    DriverObject->MajorFunction[IRP_MJ_POWER] = SaPortPower;
    DriverObject->MajorFunction[IRP_MJ_SHUTDOWN] = SaPortShutdown;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = SaPortSystemControl;
    DriverObject->MajorFunction[IRP_MJ_CLEANUP] = SaPortCleanup;

    //
    // Set up the device driver's pnp-power routine & add routine
    //

    DriverObject->DriverExtension->AddDevice = SaPortAddDevice;
    DriverObject->DriverStartIo = SaPortStartIo;

    return STATUS_SUCCESS;
}


NTSTATUS
SaPortCleanup(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the dispatch routine for IRP cleanup.

Arguments:

    DeviceObject - a pointer to the object that represents the device that I/O is to be done on.
    Irp          - a pointer to the I/O Request Packet for this request.

Return Value:

    Always returns STATUS_SUCCESS, since this is a null operation.

--*/

{
    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    return STATUS_SUCCESS;
}


NTSTATUS
SaPortCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called only rarely by the I/O system; it's mainly
    for layered drivers to call.  All it does is complete the IRP
    successfully.

Arguments:

    DeviceObject - a pointer to the object that represents the device that I/O is to be done on.
    Irp          - a pointer to the I/O Request Packet for this request.

Return Value:

    Always returns STATUS_SUCCESS, since this is a null operation.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PDEVICE_EXTENSION DeviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);
    PVOID FsContext = NULL;


    UNREFERENCED_PARAMETER( DeviceObject );
    DebugPrint(( DeviceExtension->DeviceType, SAPORT_DEBUG_INFO_LEVEL, "SaPortCreate [fo=%08x]\n", IrpSp->FileObject ));

    if (DeviceExtension->InitData->CreateRoutine) {
        if (DeviceExtension->InitData->FileContextSize) {
            FsContext = ExAllocatePool( PagedPool, DeviceExtension->InitData->FileContextSize );
            if (FsContext == NULL) {
                return CompleteRequest( Irp, STATUS_INSUFFICIENT_RESOURCES, 0 );
            }
            RtlZeroMemory( FsContext, DeviceExtension->InitData->FileContextSize );
        }
        Status = DeviceExtension->InitData->CreateRoutine(
            DeviceExtension->MiniPortDeviceExtension,
            Irp,
            FsContext
            );
        if (!NT_SUCCESS(Status)) {
            REPORT_ERROR( DeviceExtension->DeviceType, "Miniport create routine failed", Status );
            if (FsContext) {
                ExFreePool( FsContext );
            }
        } else {
            IrpSp->FileObject->FsContext = FsContext;
        }
    }

    return CompleteRequest( Irp, STATUS_SUCCESS, 0 );
}


NTSTATUS
SaPortClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called only rarely by the I/O system; it's mainly
    for layered drivers to call.  All it does is complete the IRP
    successfully.

Arguments:

    DeviceObject - a pointer to the object that represents the device that I/O is to be done on.
    Irp          - a pointer to the I/O Request Packet for this request.

Return Value:

    Always returns STATUS_SUCCESS, since this is a null operation.

--*/

{
    NTSTATUS Status;
    PDEVICE_EXTENSION DeviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);
    PVOID FsContext;


    UNREFERENCED_PARAMETER( DeviceObject );
    DebugPrint(( DeviceExtension->DeviceType, SAPORT_DEBUG_INFO_LEVEL, "SaPortClose [fo=%08x]\n", IrpSp->FileObject ));

    FsContext = (PVOID) IrpSp->FileObject->FsContext;

    if (DeviceExtension->InitData->CloseRoutine) {
        Status = DeviceExtension->InitData->CloseRoutine(
            DeviceExtension->MiniPortDeviceExtension,
            Irp,
            FsContext
            );
        if (!NT_SUCCESS(Status)) {
            REPORT_ERROR( DeviceExtension->DeviceType, "Miniport close routine failed", Status );
        }
    } else {
        Status = STATUS_SUCCESS;
    }

    if (FsContext) {
        IrpSp->FileObject->FsContext = NULL;
        ExFreePool( FsContext );
    }

    return CompleteRequest( Irp, STATUS_SUCCESS, 0 );
}


NTSTATUS
SaPortShutdown(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called only rarely by the I/O system; it's mainly
    for layered drivers to call.  All it does is complete the IRP
    successfully.

Arguments:

    DeviceObject - a pointer to the object that represents the device that I/O is to be done on.
    Irp          - a pointer to the I/O Request Packet for this request.

Return Value:

    Always returns STATUS_SUCCESS, since this is a null operation.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PDEVICE_EXTENSION DeviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);

    switch (DeviceExtension->DriverExtension->InitData.DeviceType) {
        case SA_DEVICE_DISPLAY:
            Status = SaDisplayShutdownNotification( (PDISPLAY_DEVICE_EXTENSION)DeviceExtension, Irp, IrpSp );
            break;

        case SA_DEVICE_KEYPAD:
            Status = SaKeypadShutdownNotification( (PKEYPAD_DEVICE_EXTENSION)DeviceExtension, Irp, IrpSp );
            break;

        case SA_DEVICE_NVRAM:
            Status = SaNvramShutdownNotification( (PNVRAM_DEVICE_EXTENSION)DeviceExtension, Irp, IrpSp );
            break;

        case SA_DEVICE_WATCHDOG:
            Status = SaWatchdogShutdownNotification( (PWATCHDOG_DEVICE_EXTENSION)DeviceExtension, Irp, IrpSp );
            break;
    }

    if (!NT_SUCCESS(Status)) {
        REPORT_ERROR( DeviceExtension->DeviceType, "Device specific shutdown notification failed", Status );
    }

    return ForwardRequest( Irp, DeviceExtension->TargetObject );
}


NTSTATUS
SaPortSystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    IRP_MJ_SYSTEM_CONTROL dispatch routine. Currently, we don't handle
    this. So, if this is FDO just pass it to the lower driver. If this
    is PDO complete the irp with changing the irp status.

Arguments:

    DeviceObject - a pointer to the object that represents the device that I/O is to be done on.
    Irp          - a pointer to the I/O Request Packet for this request.

Return Value:

--*/
{
    PDEVICE_EXTENSION DeviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;


    IoSkipCurrentIrpStackLocation( Irp );
    return IoCallDriver( DeviceExtension->TargetObject, Irp );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serveravailability\saport\nvram.cpp ===
/*++

Copyright (c) 1991 - 2001 Microsoft Corporation

Module Name:

    ##   # ##  ## #####    ###   ##    ##     ####  #####  #####
    ###  # ##  ## ##  ##   ###   ###  ###    ##   # ##  ## ##  ##
    #### # ##  ## ##  ##  ## ##  ########    ##     ##  ## ##  ##
    # ####  ####  #####   ## ##  # ### ##    ##     ##  ## ##  ##
    #  ###  ####  ####   ####### #  #  ##    ##     #####  #####
    #   ##   ##   ## ##  ##   ## #     ## ## ##   # ##     ##
    #    #   ##   ##  ## ##   ## #     ## ##  ####  ##     ##

Abstract:

    This module contains functions specfic to the
    NVRAM device.  The logic in this module is not
    hardware specific, but is logic that is common
    to all hardware implementations.

Author:

    Wesley Witt (wesw) 1-Oct-2001

Environment:

    Kernel mode only.

Notes:

    This is a map that shows how the NVRAM is used by the
    server appliance driver and application layers.  This
    diagram shows and NVRAM configuration of 32 DWORDs of
    NVRAM, but less is acceptable.  Regardless of the NVRAM
    size, the boot counters and boot times are always
    stored at the end of the NVRAM array.  The upper layers
    are then free to be used by the application layers.


    |------------------------------|
    |  [00-00]                     |
    |------------------------------|
    |  [01-04]                     |
    |------------------------------|
    |  [02-08]                     |
    |------------------------------|
    |  [03-0c]                     |
    |------------------------------|
    |  [04-10]                     |
    |------------------------------|
    |  [05-14]                     |
    |------------------------------|
    |  [06-18]                     |
    |------------------------------|
    |  [07-1c]                     |
    |------------------------------|
    |  [08-20]                     |
    |------------------------------|
    |  [09-24]                     |
    |------------------------------|
    |  [0a-28]                     |
    |------------------------------|
    |  [0b-2c]                     |
    |------------------------------|
    |  [0c-30]                     |
    |------------------------------|
    |  [0d-34]                     |
    |------------------------------|
    |  [0e-38]                     |
    |------------------------------|
    |  [0f-3c]                     |
    |------------------------------|
    |  [10-40]                     |
    |------------------------------|
    |  [11-44]                     |
    |------------------------------|
    |  [12-48]                     |
    |------------------------------|
    |  [13-4c]                     |
    |------------------------------|
    |  [14-50]  Shutdown time #1   |
    |------------------------------|
    |  [16-58]  Shutdown time #2   |
    |------------------------------|
    |  [18-60]  Shutdown time #3   |
    |------------------------------|
    |  [1a-68]  Shutdown time #4   |
    |------------------------------|
    |  [1c-70]  Boot Counter #1    |
    |------------------------------|
    |  [1d-74]  Boot Counter #2    |
    |------------------------------|
    |  [1e-78]  Boot Counter #3    |
    |------------------------------|
    |  [1f-7c]  Boot Counter #4    |
    |------------------------------|

--*/

#include "internal.h"



NTSTATUS
SaNvramStartDevice(
    IN PNVRAM_DEVICE_EXTENSION DeviceExtension
    )

/*++

Routine Description:

   This is the NVRAM specific code for processing
   the PNP start device request.  The NVRAM driver's
   capabilities are queried, the primary OS is queried,
   all the NVRAM data is read, and the reboot status
   is determined.

Arguments:

   DeviceExtension   - NVRAM device extension

Return Value:

    NT status code.

--*/

{
    NTSTATUS Status;
    ULONG InterfaceVersion;
    ULONG FirstAvailableSlot;
    ULONG FirstBootCounterSlot;
    ULONG FullNvramSize;


    __try {

        //
        // Read our parameters from the registry
        //

        Status = SaPortReadNumericRegistryValue(
            DeviceExtension->MiniPortDeviceExtension,
            L"PrimaryOS",
            &DeviceExtension->PrimaryOS
            );
        if (!NT_SUCCESS(Status)) {
            REPORT_ERROR( DeviceExtension->DeviceType, "Missing the PrimaryOS registry parameter, assuming primary\n", Status );
            DeviceExtension->PrimaryOS = TRUE;
        }

        //
        // Get the mini-port's interface version
        //

        Status = CallMiniPortDriverDeviceControl(
            DeviceExtension,
            DeviceExtension->DeviceObject,
            IOCTL_SA_GET_VERSION,
            NULL,
            0,
            &InterfaceVersion,
            sizeof(ULONG)
            );
        if (!NT_SUCCESS(Status)) {
            ERROR_RETURN( DeviceExtension->DeviceType, "Failed to query the NVRAM driver interface version\n", Status );
        }

        if (InterfaceVersion > SA_INTERFACE_VERSION) {
            Status = STATUS_NOINTERFACE;
            ERROR_RETURN( DeviceExtension->DeviceType, "Incompatible NVRAM interface version\n", Status );
        }

        //
        // Get the mini-port's device capabilities
        //

        DeviceExtension->DeviceCaps.SizeOfStruct = sizeof(SA_NVRAM_CAPS);

        Status = CallMiniPortDriverDeviceControl(
            DeviceExtension,
            DeviceExtension->DeviceObject,
            IOCTL_SA_GET_CAPABILITIES,
            NULL,
            0,
            &DeviceExtension->DeviceCaps,
            sizeof(SA_NVRAM_CAPS)
            );
        if (!NT_SUCCESS(Status)) {
            ERROR_RETURN( DeviceExtension->DeviceType, "Failed to query the NVRAM driver capabilities\n", Status );
        }

        //
        // Compute the persistent slot numbers
        //

        FirstAvailableSlot = DeviceExtension->DeviceCaps.NvramSize;
        FirstBootCounterSlot = DeviceExtension->DeviceCaps.NvramSize + NVRAM_RESERVED_DRIVER_SLOTS;

        DeviceExtension->SlotPowerCycle = FirstAvailableSlot;
        DeviceExtension->SlotShutDownTime = FirstAvailableSlot - 2;

        DeviceExtension->SlotBootCounter = FirstBootCounterSlot;

        //
        // Read the NVRAM data
        //

        FullNvramSize = (DeviceExtension->DeviceCaps.NvramSize + NVRAM_RESERVED_DRIVER_SLOTS + NVRAM_RESERVED_BOOTCOUNTER_SLOTS) * sizeof(ULONG);

        DeviceExtension->NvramData = (PULONG) ExAllocatePool( PagedPool, FullNvramSize );
        if (DeviceExtension->NvramData == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            ERROR_RETURN( DeviceExtension->DeviceType, "Failed to allocate pool\n", Status );
        }

        Status = CallMiniPortDriverReadWrite(
            DeviceExtension,
            DeviceExtension->DeviceObject,
            FALSE,
            DeviceExtension->NvramData,
            FullNvramSize,
            0
            );
        if (!NT_SUCCESS(Status)) {
            ERROR_RETURN( DeviceExtension->DeviceType, "Failed to read the NVRAM boot counters\n", Status );
        }

        DebugPrint(( DeviceExtension->DeviceType, SAPORT_DEBUG_INFO_LEVEL, "Boot counters [%08x] [%08x] [%08x] [%08x]\n",
            DeviceExtension->NvramData[FirstBootCounterSlot+0],
            DeviceExtension->NvramData[FirstBootCounterSlot+1],
            DeviceExtension->NvramData[FirstBootCounterSlot+2],
            DeviceExtension->NvramData[FirstBootCounterSlot+3] ));

        Status = STATUS_SUCCESS;

    } __finally {

        if (!NT_SUCCESS(Status)) {
            if (DeviceExtension->NvramData) {
                ExFreePool( DeviceExtension->NvramData );
            }
        }

    }

    return STATUS_SUCCESS;
}


NTSTATUS
SaNvramDeviceInitialization(
    IN PSAPORT_DRIVER_EXTENSION DriverExtension
    )

/*++

Routine Description:

   This is the NVRAM specific code for driver initialization.
   This function is called by SaPortInitialize, which is called by
   the NVRAM driver's DriverEntry function.

Arguments:

   DriverExtension      - Driver extension structure

Return Value:

    NT status code.

--*/

{
    return STATUS_SUCCESS;
}


NTSTATUS
SaNvramIoValidation(
    IN PNVRAM_DEVICE_EXTENSION DeviceExtension,
    IN PIRP Irp,
    PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

   This is the NVRAM specific code for processing
   all I/O validation for reads and writes.

Arguments:

   DeviceExtension      - NVRAM device extension
   Irp                  - Pointer to an IRP structure that describes the requested I/O operation.
   IrpSp                - Irp stack pointer

Return Value:

    NT status code.

--*/

{
    ULONG ByteOffset;
    ULONG Length;


    if (IrpSp->MajorFunction == IRP_MJ_READ) {
        ByteOffset = (ULONG)IrpSp->Parameters.Read.ByteOffset.QuadPart;
        Length = (ULONG)IrpSp->Parameters.Read.Length;
    } else if (IrpSp->MajorFunction == IRP_MJ_WRITE) {
        ByteOffset = (ULONG)IrpSp->Parameters.Write.ByteOffset.QuadPart;
        Length = (ULONG)IrpSp->Parameters.Write.Length;
    } else {
        REPORT_ERROR( DeviceExtension->DeviceType, "Invalid I/O request", STATUS_INVALID_PARAMETER_1 );
        return STATUS_INVALID_PARAMETER_1;
    }

    if (((ByteOffset + Length) / sizeof(ULONG)) > DeviceExtension->DeviceCaps.NvramSize) {
        REPORT_ERROR( DeviceExtension->DeviceType, "I/O length too large", STATUS_INVALID_PARAMETER_2 );
        return STATUS_INVALID_PARAMETER_2;
    }

    return STATUS_SUCCESS;
}


NTSTATUS
SaNvramShutdownNotification(
    IN PNVRAM_DEVICE_EXTENSION DeviceExtension,
    IN PIRP Irp,
    PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

   This is the NVRAM specific code for processing
   the system shutdown notification.  Here we need to
   record the shutdown timestam to the appropriate
   NVRAM slot.

Arguments:

   DeviceExtension      - Display device extension
   Irp                  - Pointer to an IRP structure that describes the requested I/O operation.
   IrpSp                - Irp stack pointer

Return Value:

    NT status code.

--*/

{
    NTSTATUS Status;
    LARGE_INTEGER CurrentTime;


    KeQuerySystemTime( &CurrentTime );

    Status = CallMiniPortDriverReadWrite(
        DeviceExtension,
        DeviceExtension->DeviceObject,
        TRUE,
        &CurrentTime.QuadPart,
        sizeof(LONGLONG),
        DeviceExtension->SlotShutDownTime * sizeof(ULONG)
        );
    if (!NT_SUCCESS(Status)) {
        REPORT_ERROR( DeviceExtension->DeviceType, "Failed to write the shutdown timestamp to NVRAM", Status );
        return Status;
    }

    return STATUS_SUCCESS;
}


DECLARE_IOCTL_HANDLER( HandleNvramReadBootCounter )

/*++

Routine Description:

   This routine handles the read boot counter IOCTL for the
   NVRAM miniport driver.

Arguments:

   DeviceObject         - The device object for the target device.
   Irp                  - Pointer to an IRP structure that describes the requested I/O operation.
   DeviceExtension      - Pointer to the main port driver device extension.
   InputBuffer          - Pointer to the user's input buffer
   InputBufferLength    - Length in bytes of the input buffer
   OutputBuffer         - Pointer to the user's output buffer
   OutputBufferLength   - Length in bytes of the output buffer

Return Value:

   NT status code.

--*/

{
    NTSTATUS Status;
    PSA_NVRAM_BOOT_COUNTER NvramBootCounter = (PSA_NVRAM_BOOT_COUNTER) OutputBuffer;
    ULONG NvramValue;


    if (OutputBufferLength != sizeof(SA_NVRAM_BOOT_COUNTER)) {
        REPORT_ERROR( DeviceExtension->DeviceType, "Output buffer != sizeof(SA_NVRAM_BOOT_COUNTER)", STATUS_INVALID_BUFFER_SIZE );
        return CompleteRequest( Irp, STATUS_INVALID_BUFFER_SIZE, 0 );
    }

    if (NvramBootCounter->SizeOfStruct != sizeof(SA_NVRAM_BOOT_COUNTER)) {
        REPORT_ERROR( DeviceExtension->DeviceType, "SA_NVRAM_BOOT_COUNTER structure wrong size", STATUS_INVALID_PARAMETER_1 );
        return CompleteRequest( Irp, STATUS_INVALID_PARAMETER_1, 0 );
    }

    if (NvramBootCounter->Number == 0 || NvramBootCounter->Number > NVRAM_RESERVED_BOOTCOUNTER_SLOTS) {
        REPORT_ERROR( DeviceExtension->DeviceType, "Requested boot counter number is out of range (0>=4)", STATUS_INVALID_PARAMETER_2 );
        return CompleteRequest( Irp, STATUS_INVALID_PARAMETER_2, 0 );
    }

    Status = CallMiniPortDriverReadWrite(
        DeviceExtension,
        DeviceExtension->DeviceObject,
        FALSE,
        &NvramValue,
        sizeof(ULONG),
        (((PNVRAM_DEVICE_EXTENSION)DeviceExtension)->DeviceCaps.NvramSize + NVRAM_RESERVED_DRIVER_SLOTS + (NvramBootCounter->Number - 1)) * sizeof(ULONG)
        );
    if (NT_SUCCESS(Status)) {
        NvramBootCounter->Value = NvramValue & 0xf;
        NvramBootCounter->DeviceId = NvramValue >> 16;
    } else {
        REPORT_ERROR( DeviceExtension->DeviceType, "Failed to read boot counter from NVRAM", Status );
    }

    return CompleteRequest( Irp, Status, sizeof(ULONG) );
}


DECLARE_IOCTL_HANDLER( HandleNvramWriteBootCounter )

/*++

Routine Description:

   This routine handles the write boot counter IOCTL for the
   NVRAM miniport driver.

Arguments:

   DeviceObject         - The device object for the target device.
   Irp                  - Pointer to an IRP structure that describes the requested I/O operation.
   DeviceExtension      - Pointer to the main port driver device extension.
   InputBuffer          - Pointer to the user's input buffer
   InputBufferLength    - Length in bytes of the input buffer
   OutputBuffer         - Pointer to the user's output buffer
   OutputBufferLength   - Length in bytes of the output buffer

Return Value:

   NT status code.

--*/

{
    NTSTATUS Status;
    PSA_NVRAM_BOOT_COUNTER NvramBootCounter = (PSA_NVRAM_BOOT_COUNTER) InputBuffer;
    ULONG NewValue;


    if (InputBufferLength != sizeof(SA_NVRAM_BOOT_COUNTER)) {
        REPORT_ERROR( DeviceExtension->DeviceType, "Input buffer != sizeof(SA_NVRAM_BOOT_COUNTER)", STATUS_INVALID_BUFFER_SIZE );
        return CompleteRequest( Irp, STATUS_INVALID_BUFFER_SIZE, 0 );
    }

    if (NvramBootCounter->SizeOfStruct != sizeof(SA_NVRAM_BOOT_COUNTER)) {
        REPORT_ERROR( DeviceExtension->DeviceType, "SA_NVRAM_BOOT_COUNTER structure wrong size", STATUS_INVALID_PARAMETER_1 );
        return CompleteRequest( Irp, STATUS_INVALID_PARAMETER_1, 0 );
    }

    if (NvramBootCounter->Number == 0 || NvramBootCounter->Number > NVRAM_RESERVED_BOOTCOUNTER_SLOTS) {
        REPORT_ERROR( DeviceExtension->DeviceType, "Requested boot counter number is out of range (0>=4)", STATUS_INVALID_PARAMETER_2 );
        return CompleteRequest( Irp, STATUS_INVALID_PARAMETER_2, 0 );
    }

    NewValue = (NvramBootCounter->DeviceId << 16) | (NvramBootCounter->Value & 0xf);

    Status = CallMiniPortDriverReadWrite(
        DeviceExtension,
        DeviceExtension->DeviceObject,
        TRUE,
        &NewValue,
        sizeof(ULONG),
        (((PNVRAM_DEVICE_EXTENSION)DeviceExtension)->DeviceCaps.NvramSize + NVRAM_RESERVED_DRIVER_SLOTS + (NvramBootCounter->Number - 1)) * sizeof(ULONG)
        );
    if (!NT_SUCCESS(Status)) {
        REPORT_ERROR( DeviceExtension->DeviceType, "Failed to write boot counter from NVRAM", Status );
    }

    return CompleteRequest( Irp, Status, sizeof(ULONG) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serveravailability\saport\nvram.h ===
/*++

Copyright (c) 1991 - 2001 Microsoft Corporation

Module Name:

    ##   # ##  ## #####    ###   ##    ##    ##   ##
    ###  # ##  ## ##  ##   ###   ###  ###    ##   ##
    #### # ##  ## ##  ##  ## ##  ########    ##   ##
    # ####  ####  #####   ## ##  # ### ##    #######
    #  ###  ####  ####   ####### #  #  ##    ##   ##
    #   ##   ##   ## ##  ##   ## #     ## ## ##   ##
    #    #   ##   ##  ## ##   ## #     ## ## ##   ##

Abstract:

    This header file contains all the global
    definitions for the NVRAM device.

Author:

    Wesley Witt (wesw) 1-Oct-2001

Environment:

    Kernel mode only.

Notes:


--*/



/////////////////////////////////////////////////////////////////////
// By default we assume a power cycle has occurred if the driver
// has been down for more than DURATION_OF_POWERCYCLE milliseconds.
// In other words, the "initializing boot" is expected. This is
// determined if the driver shutdown timestamp is the latest
// timestamp. If the driver was never shut down (i.e., the last up
// timestamp is greater than the shutdown timestamp, then the duration
// is required to be more than two minutes to conclude that there
// was a power cycle. This is necessary to prevent falsly assuming
// a power cycle on repeated crashes, and hence potentially entering
// a cycle whereby an alternative OS is never switched over to.
//

// AAN: If we did get a shutdown IRP and we took a timestamp during shutdown
// (indicated by the fact that the shutdown timestamp is later than the last
// periodic timestamp) then we use DURATION_OF_POWERCYCLE interval to determine
// if power has cycled. If the shutdown timestamp wa snot taken (because we did
// not get a shutdown IRP) then we the DURATION_PWRCYCLE_NOSHUTDOWN interval.
// The periodic timestamps are taken at half the duration of DURATION_PWRCYCLE_NOSHUTDOWN
// interval.

#define DURATION_OF_POWERCYCLE (90*1000) // 90 seconds in milliseconds
#define DURATION_OF_POWERCYCLE_STRING (L"Duration Powercycle")

// four minutes in milliseconds
#define DURATION_PWRCYCLE_NOSHUTDOWN (4*60*1000)
#define DURATION_PWRCYCLE_NOSHUTDOWN_STRING (L"Duration PwrCycle NoShutDn")
//#define DURATION_PWRCYCLE_NOSHUTDOWN (10*1000) // test code, for fast testing

#define NVRAM_MAXIMUM_PARTITIONS                4

#define NVRAM_RESERVED_BOOTCOUNTER_SLOTS        4
#define NVRAM_RESERVED_DRIVER_SLOTS             8
#define NVRAM_MAX_RESERVED_SLOTS                (NVRAM_RESERVED_BOOTCOUNTER_SLOTS + NVRAM_RESERVED_DRIVER_SLOTS)

//
// Device Extension
//

typedef struct _NVRAM_DEVICE_EXTENSION : _DEVICE_EXTENSION {

    SA_NVRAM_CAPS                   DeviceCaps;
    ULONG                           PrimaryOS;
    LONGLONG                        LastStartupTime;
    LONGLONG                        StartupInterval;
    LONGLONG                        StartIntNoShutdown;
    LONGLONG                        ShutdownTime;
    LONGLONG                        LastUpTime;
    BOOLEAN                         PowerCycleBoot;

    ULONG                           SlotPowerCycle;         // 1 slot
    ULONG                           SlotShutDownTime;       // 2 slots
    ULONG                           SlotBootCounter;        // 1 slot

    PULONG                          NvramData;

} NVRAM_DEVICE_EXTENSION, *PNVRAM_DEVICE_EXTENSION;



NTSTATUS
SaNvramDetermineIfPowerCycled(
    IN PNVRAM_DEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
SaNvramStartDevice(
    IN PNVRAM_DEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
SaNvramDeviceInitialization(
    IN PSAPORT_DRIVER_EXTENSION DriverExtension
    );

NTSTATUS
SaNvramIoValidation(
    IN PNVRAM_DEVICE_EXTENSION DeviceExtension,
    IN PIRP Irp,
    PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
SaNvramShutdownNotification(
    IN PNVRAM_DEVICE_EXTENSION DeviceExtension,
    IN PIRP Irp,
    PIO_STACK_LOCATION IrpSp
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serveravailability\saport\pnp.cpp ===
/*++

Copyright (c) 1991 - 2001 Microsoft Corporation

Module Name:

    #####  ##   # #####      ####  #####  #####
    ##  ## ###  # ##  ##    ##   # ##  ## ##  ##
    ##  ## #### # ##  ##    ##     ##  ## ##  ##
    ##  ## # #### ##  ##    ##     ##  ## ##  ##
    #####  #  ### #####     ##     #####  #####
    ##     #   ## ##     ## ##   # ##     ##
    ##     #    # ##     ##  ####  ##     ##

Abstract:

    This module process all plug and play IRPs.

Author:

    Wesley Witt (wesw) 1-Oct-2001

Environment:

    Kernel mode only.

Notes:


--*/

#include "internal.h"


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,SaPortAddDevice)
#pragma alloc_text(PAGE,SaPortPnp)
#endif


//
// Device names
//

PWSTR SaDeviceName[] =
{
    { NULL                           },       //  Bogus
    { SA_DEVICE_DISPLAY_NAME_STRING  },       //  SA_DEVICE_DISPLAY
    { SA_DEVICE_KEYPAD_NAME_STRING   },       //  SA_DEVICE_KEYPAD
    { SA_DEVICE_NVRAM_NAME_STRING    },       //  SA_DEVICE_NVRAM
    { SA_DEVICE_WATCHDOG_NAME_STRING }        //  SA_DEVICE_WATCHDOG
};


//
// Prototypes
//

#define DECLARE_PNP_HANDLER(_NAME) \
    NTSTATUS \
    _NAME( \
        IN PDEVICE_OBJECT DeviceObject, \
        IN PIRP Irp, \
        IN PIO_STACK_LOCATION IrpSp, \
        IN PDEVICE_EXTENSION DeviceExtension \
        )

DECLARE_PNP_HANDLER( DefaultPnpHandler );
DECLARE_PNP_HANDLER( HandleStartDevice );
DECLARE_PNP_HANDLER( HandleQueryCapabilities );
DECLARE_PNP_HANDLER( HandleQueryDeviceState );


//
// PNP dispatch table
//

typedef NTSTATUS (*PPNP_DISPATCH_FUNC)(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN PDEVICE_EXTENSION DeviceExtension
    );


PPNP_DISPATCH_FUNC PnpDispatchTable[] =
{
    HandleStartDevice,                    // IRP_MN_START_DEVICE
    DefaultPnpHandler,                    // IRP_MN_QUERY_REMOVE_DEVICE
    DefaultPnpHandler,                    // IRP_MN_REMOVE_DEVICE
    DefaultPnpHandler,                    // IRP_MN_CANCEL_REMOVE_DEVICE
    DefaultPnpHandler,                    // IRP_MN_STOP_DEVICE
    DefaultPnpHandler,                    // IRP_MN_QUERY_STOP_DEVICE
    DefaultPnpHandler,                    // IRP_MN_CANCEL_STOP_DEVICE
    DefaultPnpHandler,                    // IRP_MN_QUERY_DEVICE_RELATIONS
    DefaultPnpHandler,                    // IRP_MN_QUERY_INTERFACE
    HandleQueryCapabilities,              // IRP_MN_QUERY_CAPABILITIES
    DefaultPnpHandler,                    // IRP_MN_QUERY_RESOURCES
    DefaultPnpHandler,                    // IRP_MN_QUERY_RESOURCE_REQUIREMENTS
    DefaultPnpHandler,                    // IRP_MN_QUERY_DEVICE_TEXT
    DefaultPnpHandler,                    // IRP_MN_FILTER_RESOURCE_REQUIREMENTS
    DefaultPnpHandler,                    // *unused*
    DefaultPnpHandler,                    // IRP_MN_READ_CONFIG
    DefaultPnpHandler,                    // IRP_MN_WRITE_CONFIG
    DefaultPnpHandler,                    // IRP_MN_EJECT
    DefaultPnpHandler,                    // IRP_MN_SET_LOCK
    DefaultPnpHandler,                    // IRP_MN_QUERY_ID
    HandleQueryDeviceState,               // IRP_MN_QUERY_PNP_DEVICE_STATE
    DefaultPnpHandler,                    // IRP_MN_QUERY_BUS_INFORMATION
    DefaultPnpHandler,                    // IRP_MN_DEVICE_USAGE_NOTIFICATION
    DefaultPnpHandler                     // IRP_MN_SURPRISE_REMOVAL
};



NTSTATUS
SaPortAddDevice(
    IN      PDRIVER_OBJECT DriverObject,
    IN OUT  PDEVICE_OBJECT PhysicalDeviceObject
    )

/*++

Routine Description:

   This routine is the driver's pnp add device entry point.  It is
   called by the pnp manager to initialize the driver.

   Add device creates and initializes a device object for this FDO and
   attaches to the underlying PDO.

Arguments:

   DriverObject - a pointer to the object that represents this device driver.
   PhysicalDeviceObject - a pointer to the underlying PDO to which this new device will attach.

Return Value:

   If we successfully create a device object, STATUS_SUCCESS is
   returned.  Otherwise, return the appropriate error code.

Notes:

    The device extension that is allocated for each server appliance
    miniport is really a concatination of several data structures.

    |------------------------------|
    |                              |
    |   Port driver extension      |   This is the DEVICE_EXTENSION data structure
    |                              |
    |------------------------------|
    |                              |
    |   Port driver device         |   This is the DISPLAY_DEVICE_EXTENSION, KEYPAD_DEVICE_EXTENSION,
    |     specific data structure  |       NVRAM_DEVICE_EXTENSION, or the WATCHDOG_DEVICE_EXTENSION data structure.
    |                              |
    |------------------------------|
    |                              |
    |   Size of the port driver    |   This is a single ULONG value and is used to back-compute the location of
    |     portion of the extension |       the port driver extension from the miniport device extension.
    |                              |
    |------------------------------|
    |                              |
    |   Miniport device extension  |   This is owned by the miniport driver and can be anything.  The size must be
    |                              |       specified in the DeviceExtensionSize field of the SAPORT_INITIALIZATION_DATA structure.
    |------------------------------|

--*/

{
    NTSTATUS status = STATUS_SUCCESS;
    PSAPORT_DRIVER_EXTENSION DriverExtension;
    PDEVICE_EXTENSION DeviceExtension = NULL;
    PDEVICE_OBJECT deviceObject = NULL;
    ULONG DeviceExtensionSize;
    WCHAR DeviceNameBuffer[64];
    UNICODE_STRING DeviceName;
    UNICODE_STRING VmLinkName = {0};
    UNICODE_STRING SaLinkName = {0};


    __try {

        DriverExtension = (PSAPORT_DRIVER_EXTENSION) IoGetDriverObjectExtension( DriverObject, SaPortInitialize );
        if (DriverExtension == NULL) {
            status = STATUS_NO_SUCH_DEVICE;
            ERROR_RETURN( 0, "IoGetDriverObjectExtension", status );
        }

        DebugPrint(( DriverExtension->InitData.DeviceType, SAPORT_DEBUG_INFO_LEVEL, "SaPortAddDevice\n" ));

        DeviceExtensionSize = DriverExtension->InitData.DeviceExtensionSize + sizeof(ULONG);

        switch (DriverExtension->InitData.DeviceType) {
            case SA_DEVICE_DISPLAY:
                DeviceExtensionSize += sizeof(DISPLAY_DEVICE_EXTENSION);
                break;

            case SA_DEVICE_KEYPAD:
                DeviceExtensionSize += sizeof(KEYPAD_DEVICE_EXTENSION);
                break;

            case SA_DEVICE_NVRAM:
                DeviceExtensionSize += sizeof(NVRAM_DEVICE_EXTENSION);
                break;

            case SA_DEVICE_WATCHDOG:
                DeviceExtensionSize += sizeof(WATCHDOG_DEVICE_EXTENSION);
                break;

            default:
                DeviceExtensionSize += sizeof(DEVICE_EXTENSION);
                break;
        }

        //
        // Establish the device name
        //

        DeviceName.MaximumLength = sizeof(DeviceNameBuffer);
        DeviceName.Buffer = DeviceNameBuffer;

        wcscpy( DeviceName.Buffer, SaDeviceName[DriverExtension->InitData.DeviceType] );

        DeviceName.Length = wcslen(DeviceName.Buffer) * sizeof(WCHAR);

        //
        // Create the device
        //

        status = IoCreateDeviceSecure(
            DriverObject,
            DeviceExtensionSize,
            &DeviceName,
            FILE_DEVICE_CONTROLLER,
            FILE_DEVICE_SECURE_OPEN,
            FALSE,
            &SDDL_DEVOBJ_SYS_ALL_ADM_ALL,
            NULL,
            &deviceObject
            );
        if (!NT_SUCCESS(status)) {
            ERROR_RETURN( DriverExtension->InitData.DeviceType, "IoCreateDevice", status );
        }

        DeviceExtension = (PDEVICE_EXTENSION) deviceObject->DeviceExtension;
        RtlZeroMemory( DeviceExtension, DeviceExtensionSize );

        DeviceExtension->DeviceObject = deviceObject;
        DeviceExtension->DriverObject = DriverObject;
        DeviceExtension->Pdo = PhysicalDeviceObject;
        DeviceExtension->InitData = &DriverExtension->InitData;
        DeviceExtension->DriverExtension = DriverExtension;
        DeviceExtension->DeviceType = DriverExtension->InitData.DeviceType;

        DeviceExtension->MiniPortDeviceExtension =
            (PUCHAR)DeviceExtension + (DeviceExtensionSize - DriverExtension->InitData.DeviceExtensionSize);

        *(PULONG)((PUCHAR)DeviceExtension->MiniPortDeviceExtension - sizeof(ULONG)) = DeviceExtensionSize - DriverExtension->InitData.DeviceExtensionSize;

        IoInitializeRemoveLock( &DeviceExtension->RemoveLock, 0, 0, 0 );

        switch (DriverExtension->InitData.DeviceType) {
            case SA_DEVICE_DISPLAY:
                ((PDISPLAY_DEVICE_EXTENSION)DeviceExtension)->AllowWrites = TRUE;
                ExInitializeFastMutex( &((PDISPLAY_DEVICE_EXTENSION)DeviceExtension)->DisplayMutex );
                DeviceExtension->DeviceExtensionType = DEVICE_EXTENSION_DISPLAY;
                break;

            case SA_DEVICE_KEYPAD:
                DeviceExtension->DeviceExtensionType = DEVICE_EXTENSION_KEYPAD;
                break;

            case SA_DEVICE_NVRAM:
                DeviceExtension->DeviceExtensionType = DEVICE_EXTENSION_NVRAM;
                break;

            case SA_DEVICE_WATCHDOG:
                DeviceExtension->DeviceExtensionType = DEVICE_EXTENSION_WATCHDOG;
                break;
        }

        DeviceExtension->TargetObject = IoAttachDeviceToDeviceStack( deviceObject, PhysicalDeviceObject );
        if (DeviceExtension->TargetObject == NULL) {
            status = STATUS_NO_SUCH_DEVICE;
            ERROR_RETURN( DeviceExtension->DeviceType, "IoAttachDeviceToDeviceStack", status );
        }

        //
        // Register with the I/O manager for shutdown notification
        //

        status = IoRegisterShutdownNotification( deviceObject );
        if (!NT_SUCCESS(status)) {
            ERROR_RETURN( DeviceExtension->DeviceType, "IoRegisterShutdownNotification", status );
        }

        //
        // Set the device object flags
        //

        deviceObject->Flags |= DO_DIRECT_IO;
        deviceObject->Flags |= DO_POWER_PAGABLE;
        deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    } __finally {

        //
        // In the failure case un-do everything
        //

        if (!NT_SUCCESS(status)) {
            if (deviceObject) {
                IoDeleteSymbolicLink( &VmLinkName );
                IoDeleteSymbolicLink( &SaLinkName );
                if (DeviceExtension && DeviceExtension->TargetObject) {
                    IoDetachDevice( DeviceExtension->TargetObject );
                }
                IoDeleteDevice( deviceObject );
            }
        }

    }

    return status;
}


DECLARE_PNP_HANDLER( DefaultPnpHandler )

/*++

Routine Description:

   This routine is the default PNP handler and simply calls the next lower device driver.

Arguments:

   DeviceObject     - Pointer to the object that represents the device that I/O is to be done on.
   Irp              - I/O Request Packet for this request.
   IrpSp            - IRP stack location for this request
   DeviceExtension  - Device extension

Return Value:

   NT status code.

--*/

{
    return ForwardRequest( Irp, DeviceExtension->TargetObject );
}


DECLARE_PNP_HANDLER( HandleStartDevice )

/*++

Routine Description:

   This routine is the PNP handler for the IRP_MN_START_DEVICE request.

Arguments:

   DeviceObject     - Pointer to the object that represents the device that I/O is to be done on.
   Irp              - I/O Request Packet for this request.
   IrpSp            - IRP stack location for this request
   DeviceExtension  - Device extension

Return Value:

   NT status code.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PCM_RESOURCE_LIST ResourceList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR PartialResources;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR ResourceInterrupt = NULL;
    ULONG PartialResourceCount;
    ULONG i;


    if (DeviceExtension->IsStarted) {
        return ForwardRequest( Irp, DeviceExtension->TargetObject );
    }

    __try {

        ResourceList = IrpSp->Parameters.StartDevice.AllocatedResourcesTranslated;
        if (ResourceList == NULL) {

            Status = DeviceExtension->DriverExtension->InitData.HwInitialize(
                DeviceObject,
                Irp,
                DeviceExtension->MiniPortDeviceExtension,
                NULL,
                0
                );
            if (!NT_SUCCESS(Status)) {
                ERROR_RETURN( DeviceExtension->DeviceType, "Miniport HwInitialize", Status );
            }

        } else {

            PartialResources = (PCM_PARTIAL_RESOURCE_DESCRIPTOR) &ResourceList->List[0].PartialResourceList.PartialDescriptors[0];
            PartialResourceCount = ResourceList->List[0].PartialResourceList.Count;

            if (ResourceList == NULL || ResourceList->Count != 1) {
                Status = STATUS_UNSUCCESSFUL ;
                ERROR_RETURN( DeviceExtension->DeviceType, "Resource list is empty", Status );
            }

            if (DeviceExtension->DriverExtension->InitData.InterruptServiceRoutine) {

                //
                // Find the IRQ resource
                //

                for (i=0; i<PartialResourceCount; i++) {
                    if (PartialResources[i].Type == CmResourceTypeInterrupt) {
                        ResourceInterrupt = &PartialResources[i];
                    }
                }

                if (ResourceInterrupt) {

                    //
                    // There is an IRQ resource so now use it
                    //

                    if (DeviceExtension->DriverExtension->InitData.IsrForDpcRoutine) {

                        //
                        // Initialize the DPC routine
                        //

                        IoInitializeDpcRequest(
                            DeviceExtension->DeviceObject,
                            DeviceExtension->DriverExtension->InitData.IsrForDpcRoutine
                            );
                    }

                    //
                    // Connect up the ISR
                    //

                    Status = IoConnectInterrupt(
                        &DeviceExtension->InterruptObject,
                        DeviceExtension->DriverExtension->InitData.InterruptServiceRoutine,
                        DeviceExtension->MiniPortDeviceExtension,
                        NULL,
                        ResourceInterrupt->u.Interrupt.Vector,
                        (KIRQL)ResourceInterrupt->u.Interrupt.Level,
                        (KIRQL)ResourceInterrupt->u.Interrupt.Level,
                        LevelSensitive,
                        TRUE,
                        ResourceInterrupt->u.Interrupt.Affinity,
                        FALSE
                        );
                    if (!NT_SUCCESS(Status)) {
                        ERROR_RETURN( DeviceExtension->DeviceType, "IoConnectInterrupt", Status );
                    }
                }
            }

            Status = DeviceExtension->DriverExtension->InitData.HwInitialize(
                DeviceObject,
                Irp,
                DeviceExtension->MiniPortDeviceExtension,
                (PCM_PARTIAL_RESOURCE_DESCRIPTOR) &ResourceList->List[0].PartialResourceList.PartialDescriptors[0],
                ResourceList->List[0].PartialResourceList.Count
                );
            if (!NT_SUCCESS(Status)) {
                ERROR_RETURN( DeviceExtension->DeviceType, "Miniport HwInitialize", Status );
            }

        }

        //
        // We must set this to TRUE temporarity here so that the
        // the device specific start device routine can be called.
        // If the call fails then IsStarted is set to FALSE
        //

        DeviceExtension->IsStarted = TRUE;

        switch (DeviceExtension->DriverExtension->InitData.DeviceType) {
            case SA_DEVICE_DISPLAY:
                Status = SaDisplayStartDevice( (PDISPLAY_DEVICE_EXTENSION)DeviceExtension );
                break;

            case SA_DEVICE_KEYPAD:
                Status = SaKeypadStartDevice( (PKEYPAD_DEVICE_EXTENSION)DeviceExtension );
                break;

            case SA_DEVICE_NVRAM:
                Status = SaNvramStartDevice( (PNVRAM_DEVICE_EXTENSION)DeviceExtension );
                break;

            case SA_DEVICE_WATCHDOG:
                Status = SaWatchdogStartDevice( (PWATCHDOG_DEVICE_EXTENSION)DeviceExtension );
                break;
        }

        if (!NT_SUCCESS(Status)) {
            DeviceExtension->IsStarted = FALSE;
            ERROR_RETURN( DeviceExtension->DeviceType, "Device specific start device", Status );
        }

    } __finally {

    }

    Irp->IoStatus.Status = Status;

    return ForwardRequest( Irp, DeviceExtension->TargetObject );
}


DECLARE_PNP_HANDLER( HandleQueryCapabilities )

/*++

Routine Description:

   This routine is the PNP handler for the IRP_MN_QUERY_CAPABILITIES request.

Arguments:

   DeviceObject     - Pointer to the object that represents the device that I/O is to be done on.
   Irp              - I/O Request Packet for this request.
   IrpSp            - IRP stack location for this request
   DeviceExtension  - Device extension

Return Value:

   NT status code.

--*/

{
    NTSTATUS Status;
    PDEVICE_CAPABILITIES Capabilities = IrpSp->Parameters.DeviceCapabilities.Capabilities;


    Status = CallLowerDriverAndWait( Irp, DeviceExtension->TargetObject );

    Capabilities->SilentInstall = 1;
    Capabilities->RawDeviceOK = 1;

    return CompleteRequest( Irp, Status, Irp->IoStatus.Information );
}


DECLARE_PNP_HANDLER( HandleQueryDeviceState )

/*++

Routine Description:

   This routine is the PNP handler for the IRP_MN_QUERY_PNP_DEVICE_STATE request.

Arguments:

   DeviceObject     - Pointer to the object that represents the device that I/O is to be done on.
   Irp              - I/O Request Packet for this request.
   IrpSp            - IRP stack location for this request
   DeviceExtension  - Device extension

Return Value:

   NT status code.

--*/

{
    NTSTATUS Status;


    Status = CallLowerDriverAndWait( Irp, DeviceExtension->TargetObject );
    if (!NT_SUCCESS(Status)) {
        REPORT_ERROR( DeviceExtension->DeviceType, "IRP_MN_QUERY_PNP_DEVICE_STATE", Status );
        Irp->IoStatus.Information = 0;
    }

    //Irp->IoStatus.Information |= PNP_DEVICE_NOT_DISABLEABLE;
#if MAKE_DEVICES_HIDDEN
    Irp->IoStatus.Information |= PNP_DEVICE_DONT_DISPLAY_IN_UI;
#endif

    return CompleteRequest( Irp, STATUS_SUCCESS, Irp->IoStatus.Information );
}


NTSTATUS
SaPortPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

   Main PNP irp dispatch routine

Arguments:

   DeviceObject - a pointer to the object that represents the device
   that I/O is to be done on.

   Irp - a pointer to the I/O Request Packet for this request.

Return Value:

   status

--*/
{
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);
    PDEVICE_EXTENSION DeviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;


    DebugPrint(( DeviceExtension->DeviceType, SAPORT_DEBUG_INFO_LEVEL, "PNP - Func [0x%02x %s]\n",
        irpSp->MinorFunction,
        PnPMinorFunctionString(irpSp->MinorFunction)
        ));

    if (DeviceExtension->IsRemoved) {
        return CompleteRequest( Irp, STATUS_DELETE_PENDING, 0 );
    }

    status = IoAcquireRemoveLock(&DeviceExtension->RemoveLock, Irp );
    if (!NT_SUCCESS(status)) {
        REPORT_ERROR( DeviceExtension->DeviceType, "SaPortPnp", status );
        return CompleteRequest( Irp, status, 0 );
    }

    if (irpSp->MinorFunction >= ARRAY_SZ(PnpDispatchTable)) {
        status = DefaultPnpHandler( DeviceObject, Irp, irpSp, DeviceExtension );
    } else {
        status = (*PnpDispatchTable[irpSp->MinorFunction])( DeviceObject, Irp, irpSp, DeviceExtension );
    }

    if (!NT_SUCCESS(status)) {
        REPORT_ERROR( DeviceExtension->DeviceType, "Pnp handler failed", status );
    }

    IoReleaseRemoveLock( &DeviceExtension->RemoveLock, Irp );

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serveravailability\saport\power.cpp ===
/*++

Copyright (c) 1991 - 2001 Microsoft Corporation

Module Name:

    #####   #####  ##  #  ## ##### #####      ####  #####  #####
    ##  ## ##   ## ## ### ## ##    ##  ##    ##   # ##  ## ##  ##
    ##  ## ##   ## ## ### ## ##    ##  ##    ##     ##  ## ##  ##
    ##  ## ##   ## ## # # ## ##### #####     ##     ##  ## ##  ##
    #####  ##   ##  ### ###  ##    ####      ##     #####  #####
    ##     ##   ##  ### ###  ##    ## ##  ## ##   # ##     ##
    ##      #####   ##   ##  ##### ##  ## ##  ####  ##     ##

Abstract:

    This module process all power management IRPs.

Author:

    Wesley Witt (wesw) 1-Oct-2001

Environment:

    Kernel mode only.

Notes:


--*/

#include "internal.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,SaPortPower)
#endif



NTSTATUS
SaPortPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

Arguments:

    DeviceObject - a pointer to the object that represents the device
    that I/O is to be done on.

    Irp - a pointer to the I/O Request Packet for this request.

Return Value:

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PDEVICE_EXTENSION DeviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);

    switch (IrpSp->MinorFunction) {
        case IRP_MN_WAIT_WAKE:
        case IRP_MN_POWER_SEQUENCE:
        case IRP_MN_SET_POWER:
        case IRP_MN_QUERY_POWER:
            Status = STATUS_SUCCESS;
            break;

        default:
            Status = Irp->IoStatus.Status;
            break;

    }

    Irp->IoStatus.Status = Status;
    PoStartNextPowerIrp(Irp);
    IoSkipCurrentIrpStackLocation( Irp );
    return PoCallDriver( DeviceExtension->TargetObject, Irp );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serveravailability\saport\util.cpp ===
/*++

Copyright (c) 1991 - 2001 Microsoft Corporation

Module Name:

    ##  ## ###### #### ##        ####  #####  #####
    ##  ##   ##    ##  ##       ##   # ##  ## ##  ##
    ##  ##   ##    ##  ##       ##     ##  ## ##  ##
    ##  ##   ##    ##  ##       ##     ##  ## ##  ##
    ##  ##   ##    ##  ##       ##     #####  #####
    ##  ##   ##    ##  ##    ## ##   # ##     ##
     ####    ##   #### ##### ##  ####  ##     ##

Abstract:

    Utility driver functions.

Author:

    Wesley Witt (wesw) 1-Oct-2001

Environment:

    Kernel mode only.

Notes:


--*/

#include "internal.h"
#include <ntimage.h>
#include <stdarg.h>

#if DBG
ULONG SaPortDebugLevel[5];
#endif



NTSTATUS
CompleteRequest(
    PIRP Irp,
    NTSTATUS Status,
    ULONG_PTR Information
    )

/*++

Routine Description:

   This routine completes as outstanding I/O request.

Arguments:

   Irp                  - Pointer to an IRP structure that describes the requested I/O operation.
   Status               - NT status value
   Information          - Informational, request specific data

Return Value:

   NT status code.

--*/

{
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);
    KIRQL CancelIrql;


    if (IrpSp && (IrpSp->MajorFunction == IRP_MJ_READ || IrpSp->MajorFunction == IRP_MJ_WRITE)) {
        IoAcquireCancelSpinLock( &CancelIrql );
        IoSetCancelRoutine( Irp, NULL );
        IoReleaseCancelSpinLock( CancelIrql );
    }

    Irp->IoStatus.Information = Information;
    Irp->IoStatus.Status = Status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    return Status;
}


NTSTATUS
ForwardRequest(
    IN PIRP Irp,
    IN PDEVICE_OBJECT TargetObject
    )

/*++

Routine Description:

   This routine forwards the IRP to another driver.

Arguments:

   Irp                  - Pointer to an IRP structure that describes the requested I/O operation.
   TargetObject         - Target device object to receive the request packet

Return Value:

   NT status code.

--*/

{
    IoSkipCurrentIrpStackLocation( Irp );
    return IoCallDriver( TargetObject, Irp );
}


NTSTATUS
CallMiniPortDriverReadWrite(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN WriteIo,
    IN PVOID Buffer,
    IN ULONG Length,
    IN ULONG Offset
    )

/*++

Routine Description:

   This routine creates an IRP for a read/write I/O and
   then passes the IRP to the driver.  This call is
   synchronous, control returns only when the driver has
   completed the IRP.

Arguments:

   DeviceExtension      - Port driver device extension pointer
   WriteIo              - TRUE for a write, FALSE for a read
   Buffer               - Pointer to the I/O buffer
   Length               - Length in bytes of the I/O buffer
   Offset               - Starting offset of the I/O

Return Value:

   NT status code.

--*/

{
    NTSTATUS Status;
    PIRP Irp;
    KEVENT Event;
    IO_STATUS_BLOCK IoStatus;
    LARGE_INTEGER StartingOffset;


    KeInitializeEvent( &Event, NotificationEvent, FALSE );

    StartingOffset.QuadPart = Offset;

    Irp = IoBuildSynchronousFsdRequest(
        WriteIo ? IRP_MJ_WRITE : IRP_MJ_READ,
        DeviceObject,
        Buffer,
        Length,
        &StartingOffset,
        &Event,
        &IoStatus
        );
    if (!Irp) {
        REPORT_ERROR( DeviceExtension->DeviceType, "IoBuildSynchronousFsdRequest failed", STATUS_INSUFFICIENT_RESOURCES );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    MARK_IRP_INTERNAL( Irp );

    Status = IoCallDriver( DeviceObject, Irp );
    if (Status == STATUS_PENDING) {
        KeWaitForSingleObject( &Event, Executive, KernelMode, FALSE, NULL );
        Status = IoStatus.Status;
    }

    if (!NT_SUCCESS(Status)) {
        REPORT_ERROR( DeviceExtension->DeviceType, "Miniport I/O request failed", Status );
    }

    return Status;
}


NTSTATUS
CallMiniPortDriverDeviceControl(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG IoControlCode,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer,
    IN ULONG OutputBufferLength
    )

/*++

Routine Description:

   This routine creates an IRP for a device control I/O and
   then passes the IRP to the driver.  This call is
   synchronous, control returns only when the driver has
   completed the IRP.

Arguments:

   DeviceExtension      - Port driver device extension pointer
   IoControlCode        - Device I/O control code
   InputBuffer          - Input buffer pointer
   InputBufferLength    - Length in bytes of the input buffer
   OutputBuffer         - Output buffer pointer
   OutputBufferLength   - Length in bytes of output buffer

Return Value:

   NT status code.

--*/

{
    NTSTATUS Status;
    PIRP Irp;
    KEVENT Event;
    IO_STATUS_BLOCK IoStatus;


    KeInitializeEvent( &Event, NotificationEvent, FALSE );

    Irp = IoBuildDeviceIoControlRequest(
        IoControlCode,
        DeviceObject,
        InputBuffer,
        InputBufferLength,
        OutputBuffer,
        OutputBufferLength,
        FALSE,
        &Event,
        &IoStatus
        );
    if (!Irp) {
        REPORT_ERROR( DeviceExtension->DeviceType, "IoBuildDeviceIoControlRequest failed", STATUS_INSUFFICIENT_RESOURCES );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    MARK_IRP_INTERNAL( Irp );

    Status = IoCallDriver( DeviceObject, Irp );
    if (Status == STATUS_PENDING) {
        KeWaitForSingleObject( &Event, Executive, KernelMode, FALSE, NULL );
        Status = IoStatus.Status;
    }

    if (!NT_SUCCESS(Status)) {
        REPORT_ERROR( DeviceExtension->DeviceType, "Miniport device control request failed", Status );
    }

    return Status;
}


VOID
SaPortDebugPrint(
    IN ULONG DeviceType,
    IN ULONG DebugLevel,
    IN PSTR DebugMessage,
    IN ...
    )

/*++

Routine Description:

   This routine prints a formatted string to the debugger.

Arguments:

   DebugLevel       - Debug level that controls when a message is printed
   DebugMessage     - String that is printed
   ...              - Arguments that are used by the DebugMessage

Return Value:

   None.

--*/

{
    static char *DeviceName[] = {"SAPORT", "DISPLAY","KEYPAD","NVRAM","WATCHDOG"};
    va_list arg_ptr;
    char buf[512];
    char *s = buf;



#if DBG
    if ((SaPortDebugLevel[DeviceType] == 0) || ((SaPortDebugLevel[DeviceType] & DebugLevel) == 0)) {
        return;
    }
#endif

    va_start( arg_ptr, DebugMessage );
    sprintf( s, "%s: ", DeviceName[DeviceType] );
    s += strlen(s);
    _vsnprintf( s, sizeof(buf)-strlen(s), DebugMessage, arg_ptr );
    DbgPrint( buf );
}


VOID
GetOsVersion(
    VOID
    )
{
#if (WINVER >= 0x0501)
    RTL_OSVERSIONINFOW VersionInformation;

    VersionInformation.dwOSVersionInfoSize = sizeof(RTL_OSVERSIONINFOW);
    RtlGetVersion( &VersionInformation );
    OsMajorVersion = VersionInformation.dwMajorVersion;
    OsMinorVersion = VersionInformation.dwMinorVersion;
#else
    OsMajorVersion = 0;
    OsMinorVersion = 0;
    //PsGetVersion( &OsMajorVersion, &OsMinorVersion, NULL, NULL );
#endif
}



#if DBG

VOID
FormatTime(
    ULONG TimeStamp,
    PSTR  TimeBuf
    )

/*++

Routine Description:

   This routine formats a timestamp word into a string.

Arguments:

   TimeStamp    - Timestamp word
   TimeBuf      - Buffer to place the resulting string

Return Value:

   None.

--*/

{
    static char    mnames[] = { "JanFebMarAprMayJunJulAugSepOctNovDec" };
    LARGE_INTEGER  MyTime;
    TIME_FIELDS    TimeFields;


    RtlSecondsSince1970ToTime( TimeStamp, &MyTime );
    ExSystemTimeToLocalTime( &MyTime, &MyTime );
    RtlTimeToTimeFields( &MyTime, &TimeFields );

    strncpy( TimeBuf, &mnames[(TimeFields.Month - 1) * 3], 3 );
    sprintf(
        &TimeBuf[3],
        " %02d, %04d @ %02d:%02d:%02d",
        TimeFields.Day,
        TimeFields.Year,
        TimeFields.Hour,
        TimeFields.Minute,
        TimeFields.Second
        );
}


VOID
PrintDriverVersion(
    IN ULONG DeviceType,
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

   This routine locates the NT image headers from the
   base of a loaded driver.

Arguments:

   DeviceType       - Miniport device type (see saio.h for the enumeration)
   DriverObject     - Pointer to the DRIVER_OBJECT structure

Return Value:

   None.

--*/

{
    PIMAGE_NT_HEADERS NtHeaders;
    ULONG TimeStamp;
    CHAR buf[32];
    PSTR DriverId;


    NtHeaders = RtlpImageNtHeader( DriverObject->DriverStart );
    if (NtHeaders) {
        TimeStamp = NtHeaders->FileHeader.TimeDateStamp;
        FormatTime( TimeStamp, buf );
        DebugPrint(( DeviceType, SAPORT_DEBUG_INFO_LEVEL, "***********************************************\n" ));
        switch (DeviceType) {
            case 0:
                DriverId = "Server Appliance Port";
                break;

            case SA_DEVICE_DISPLAY:
                DriverId = "Local Display";
                break;

            case SA_DEVICE_KEYPAD:
                DriverId = "Keypad";
                break;

            case SA_DEVICE_NVRAM:
                DriverId = "NVRAM";
                break;

            case SA_DEVICE_WATCHDOG:
                DriverId = "Watchdog Timer";
                break;

            default:
                DriverId = "Unknown";
                break;
        }
        DebugPrint(( DeviceType, SAPORT_DEBUG_INFO_LEVEL, "%s Driver Built: %s\n", DriverId, buf ));
        if (RunningOnWin2k) {
            DebugPrint(( DeviceType, SAPORT_DEBUG_INFO_LEVEL, "Running on Windows 2000\n" ));
        } else if (RunningOnWinXp) {
            DebugPrint(( DeviceType, SAPORT_DEBUG_INFO_LEVEL, "Running on Windows XP\n" ));
        } else {
            DebugPrint(( DeviceType, SAPORT_DEBUG_INFO_LEVEL, "Running on *UNKNOWN*\n" ));
        }
        DebugPrint(( DeviceType, SAPORT_DEBUG_INFO_LEVEL, "***********************************************\n" ));
    }
}

#endif


NTSTATUS
SaSignalCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Event
    )

/*++

Routine Description:

   This routine is used to signal the completion of an
   I/O request and is used ONLY by CallLowerDriverAndWait.

Arguments:

   DeviceObject         - Pointer to the miniport's device object
   Irp                  - I/O request packet
   Event                - Event to be signaled when the I/O is completed

Return Value:

   NT status code

--*/

{
    KeSetEvent( (PKEVENT)Event, IO_NO_INCREMENT, FALSE );
    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
CallLowerDriverAndWait(
    IN PIRP Irp,
    IN PDEVICE_OBJECT TargetObject
    )

/*++

Routine Description:

   This routine calls a lower driver and waits for the I/O to complete.

Arguments:

   Irp                  - I/O request packet
   TargetObject         - Pointer to the target device object

Return Value:

   NT status code

--*/

{
    KEVENT event;

    KeInitializeEvent( &event, NotificationEvent, FALSE );
    IoCopyCurrentIrpStackLocationToNext( Irp );
    IoSetCompletionRoutine( Irp, SaSignalCompletion, &event, TRUE, TRUE, TRUE );
    IoCallDriver( TargetObject, Irp );
    KeWaitForSingleObject( &event, Executive, KernelMode, FALSE, NULL );
    return Irp->IoStatus.Status;
}


NTSTATUS
OpenParametersRegistryKey(
    IN PSAPORT_DRIVER_EXTENSION DriverExtension,
    IN PUNICODE_STRING RegistryPath,
    IN ULONG AccessMode,
    OUT PHANDLE RegistryHandle
    )
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING unicodeString;
    HANDLE serviceKey = NULL;


    __try {

        InitializeObjectAttributes(
            &objectAttributes,
            RegistryPath,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );

        status = ZwOpenKey(
            &serviceKey,
            AccessMode,
            &objectAttributes
            );
        if (!NT_SUCCESS(status)) {
            ERROR_RETURN( DriverExtension->InitData.DeviceType, "ZwOpenKey failed", status );
        }

        RtlInitUnicodeString( &unicodeString, L"Parameters" );

        InitializeObjectAttributes(
            &objectAttributes,
            &unicodeString,
            OBJ_CASE_INSENSITIVE,
            serviceKey,
            NULL
            );

        status = ZwOpenKey(
            RegistryHandle,
            AccessMode,
            &objectAttributes
            );
        if (!NT_SUCCESS(status)) {
            ERROR_RETURN( DriverExtension->InitData.DeviceType, "ZwOpenKey failed", status );
        }

        status = STATUS_SUCCESS;

    } __finally {

        if (serviceKey) {
            ZwClose( serviceKey );
        }

        if (!NT_SUCCESS(status)) {
            if (*RegistryHandle) {
                ZwClose( *RegistryHandle );
            }
        }

    }

    return status;
}


NTSTATUS
CreateParametersRegistryKey(
    IN PSAPORT_DRIVER_EXTENSION DriverExtension,
    IN PUNICODE_STRING RegistryPath,
    OUT PHANDLE parametersKey
    )
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING unicodeString;
    HANDLE serviceKey = NULL;
    ULONG Disposition;


    __try {

        parametersKey = NULL;

        InitializeObjectAttributes(
            &objectAttributes,
            RegistryPath,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );

        status = ZwOpenKey(
            &serviceKey,
            KEY_READ | KEY_WRITE,
            &objectAttributes
            );
        if (!NT_SUCCESS(status)) {
            ERROR_RETURN( DriverExtension->InitData.DeviceType, "ZwOpenKey failed", status );
        }

        RtlInitUnicodeString( &unicodeString, L"Parameters" );

        InitializeObjectAttributes(
            &objectAttributes,
            &unicodeString,
            OBJ_CASE_INSENSITIVE,
            serviceKey,
            NULL
            );

        status = ZwCreateKey(
            parametersKey,
            KEY_READ | KEY_WRITE,
            &objectAttributes,
            0,
            NULL,
            REG_OPTION_NON_VOLATILE,
            &Disposition
            );
        if (!NT_SUCCESS(status)) {
            ERROR_RETURN( DriverExtension->InitData.DeviceType, "ZwCreateKey failed", status );
        }

        status = STATUS_SUCCESS;

    } __finally {

        if (serviceKey) {
            ZwClose( serviceKey );
        }

        if (!NT_SUCCESS(status)) {
            if (parametersKey) {
                ZwClose( parametersKey );
            }
        }

    }

    return status;
}


NTSTATUS
ReadRegistryValue(
    IN PSAPORT_DRIVER_EXTENSION DriverExtension,
    IN PUNICODE_STRING RegistryPath,
    IN PWSTR ValueName,
    OUT PKEY_VALUE_FULL_INFORMATION *KeyInformation
    )

/*++

Routine Description:

   This routine reads a registry arbitrary value from the
   device's parameter registry data.  The necessary memory
   is allocated by this function and must be freed by the caller.

Arguments:

   RegistryPath     - String containing the path to the driver's registry data
   ValueName        - Value name in the registry
   KeyInformation   - Pointer to a PKEY_VALUE_FULL_INFORMATION pointer that is allocated by this function

Return Value:

   NT status code

--*/

{
    NTSTATUS status;
    UNICODE_STRING unicodeString;
    HANDLE parametersKey = NULL;
    ULONG keyValueLength;


    __try {

        status = OpenParametersRegistryKey(
            DriverExtension,
            RegistryPath,
            KEY_READ,
            &parametersKey
            );
        if (!NT_SUCCESS(status)) {
            ERROR_RETURN( DriverExtension->InitData.DeviceType, "OpenParametersRegistryKey failed", status );
        }

        RtlInitUnicodeString( &unicodeString, ValueName );

        status = ZwQueryValueKey(
            parametersKey,
            &unicodeString,
            KeyValueFullInformation,
            NULL,
            0,
            &keyValueLength
            );
        if (status != STATUS_BUFFER_OVERFLOW && status != STATUS_BUFFER_TOO_SMALL) {
            ERROR_RETURN( DriverExtension->InitData.DeviceType, "ZwQueryValueKey failed", status );
        }

        *KeyInformation = (PKEY_VALUE_FULL_INFORMATION) ExAllocatePool( NonPagedPool, keyValueLength );
        if (*KeyInformation == NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            ERROR_RETURN( DriverExtension->InitData.DeviceType, "Failed to allocate pool for registry data", status );
        }

        status = ZwQueryValueKey(
            parametersKey,
            &unicodeString,
            KeyValueFullInformation,
            *KeyInformation,
            keyValueLength,
            &keyValueLength
            );
        if (!NT_SUCCESS(status)) {
            ERROR_RETURN( DriverExtension->InitData.DeviceType, "ZwQueryValueKey failed", status );
        }

        status = STATUS_SUCCESS;

    } __finally {

        if (parametersKey) {
            ZwClose( parametersKey );
        }

        if (!NT_SUCCESS(status)) {
            if (*KeyInformation) {
                ExFreePool( *KeyInformation );
            }
            *KeyInformation = NULL;
        }

    }

    return status;
}


NTSTATUS
WriteRegistryValue(
    IN PSAPORT_DRIVER_EXTENSION DriverExtension,
    IN PUNICODE_STRING RegistryPath,
    IN PWSTR ValueName,
    IN ULONG RegistryType,
    IN PVOID RegistryValue,
    IN ULONG RegistryValueLength
    )

/*++

Routine Description:

   This routine reads a registry arbitrary value from the
   device's parameter registry data.  The necessary memory
   is allocated by this function and must be freed by the caller.

Arguments:

   RegistryPath     - String containing the path to the driver's registry data
   ValueName        - Value name in the registry
   KeyInformation   - Pointer to a PKEY_VALUE_FULL_INFORMATION pointer that is allocated by this function

Return Value:

   NT status code

--*/

{
    NTSTATUS status;
    UNICODE_STRING unicodeString;
    HANDLE parametersKey = NULL;


    __try {

        status = OpenParametersRegistryKey(
            DriverExtension,
            RegistryPath,
            KEY_READ | KEY_WRITE,
            &parametersKey
            );
        if (!NT_SUCCESS(status)) {
            status = CreateParametersRegistryKey(
                DriverExtension,
                RegistryPath,
                &parametersKey
                );
            if (!NT_SUCCESS(status)) {
                ERROR_RETURN( DriverExtension->InitData.DeviceType, "CreateParametersRegistryKey failed", status );
            }
        }

        RtlInitUnicodeString( &unicodeString, ValueName );

        status = ZwSetValueKey(
            parametersKey,
            &unicodeString,
            0,
            RegistryType,
            RegistryValue,
            RegistryValueLength
            );
        if (!NT_SUCCESS(status)) {
            ERROR_RETURN( DriverExtension->InitData.DeviceType, "ZwQueryValueKey failed", status );
        }

        status = STATUS_SUCCESS;

    } __finally {

        if (parametersKey) {
            ZwClose( parametersKey );
        }

    }

    return status;
}


//------------------------------------------------------------------------
//  debugging stuff
//------------------------------------------------------------------------


#if DBG

PCHAR
PnPMinorFunctionString(
    UCHAR MinorFunction
    )

/*++

Routine Description:

   This routine translates a minor function code into a string.

Arguments:

   MinorFunction    - Minor function code

Return Value:

   Pointer to a string representation of the MinorFunction code.

--*/

{
    switch (MinorFunction) {
        case IRP_MN_START_DEVICE:
            return "IRP_MN_START_DEVICE";
        case IRP_MN_QUERY_REMOVE_DEVICE:
            return "IRP_MN_QUERY_REMOVE_DEVICE";
        case IRP_MN_REMOVE_DEVICE:
            return "IRP_MN_REMOVE_DEVICE";
        case IRP_MN_CANCEL_REMOVE_DEVICE:
            return "IRP_MN_CANCEL_REMOVE_DEVICE";
        case IRP_MN_STOP_DEVICE:
            return "IRP_MN_STOP_DEVICE";
        case IRP_MN_QUERY_STOP_DEVICE:
            return "IRP_MN_QUERY_STOP_DEVICE";
        case IRP_MN_CANCEL_STOP_DEVICE:
            return "IRP_MN_CANCEL_STOP_DEVICE";
        case IRP_MN_QUERY_DEVICE_RELATIONS:
            return "IRP_MN_QUERY_DEVICE_RELATIONS";
        case IRP_MN_QUERY_INTERFACE:
            return "IRP_MN_QUERY_INTERFACE";
        case IRP_MN_QUERY_CAPABILITIES:
            return "IRP_MN_QUERY_CAPABILITIES";
        case IRP_MN_QUERY_RESOURCES:
            return "IRP_MN_QUERY_RESOURCES";
        case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
            return "IRP_MN_QUERY_RESOURCE_REQUIREMENTS";
        case IRP_MN_QUERY_DEVICE_TEXT:
            return "IRP_MN_QUERY_DEVICE_TEXT";
        case IRP_MN_FILTER_RESOURCE_REQUIREMENTS:
            return "IRP_MN_FILTER_RESOURCE_REQUIREMENTS";
        case IRP_MN_READ_CONFIG:
            return "IRP_MN_READ_CONFIG";
        case IRP_MN_WRITE_CONFIG:
            return "IRP_MN_WRITE_CONFIG";
        case IRP_MN_EJECT:
            return "IRP_MN_EJECT";
        case IRP_MN_SET_LOCK:
            return "IRP_MN_SET_LOCK";
        case IRP_MN_QUERY_ID:
            return "IRP_MN_QUERY_ID";
        case IRP_MN_QUERY_PNP_DEVICE_STATE:
            return "IRP_MN_QUERY_PNP_DEVICE_STATE";
        case IRP_MN_QUERY_BUS_INFORMATION:
            return "IRP_MN_QUERY_BUS_INFORMATION";
        case IRP_MN_DEVICE_USAGE_NOTIFICATION:
            return "IRP_MN_DEVICE_USAGE_NOTIFICATION";
        case IRP_MN_SURPRISE_REMOVAL:
            return "IRP_MN_SURPRISE_REMOVAL";
        case IRP_MN_QUERY_LEGACY_BUS_INFORMATION:
            return "IRP_MN_QUERY_LEGACY_BUS_INFORMATION";
        default:
            return "IRP_MN_?????";
    }
}

PCHAR
PowerMinorFunctionString(
    UCHAR MinorFunction
    )

/*++

Routine Description:

   This routine translates a minor power function code into a string.

Arguments:

   MinorFunction    - Minor function code

Return Value:

   Pointer to a string representation of the MinorFunction code.

--*/

{
    switch (MinorFunction) {
        case IRP_MN_WAIT_WAKE:
            return "IRP_MN_WAIT_WAKE";
        case IRP_MN_POWER_SEQUENCE:
            return "IRP_MN_POWER_SEQUENCE";
        case IRP_MN_SET_POWER:
            return "IRP_MN_SET_POWER";
        case IRP_MN_QUERY_POWER:
            return "IRP_MN_QUERY_POWER";
        default:
            return "IRP_MN_?????";
    }
}

PCHAR
PowerDeviceStateString(
    DEVICE_POWER_STATE State
    )

/*++

Routine Description:

   This routine translates a power state code into a string.

Arguments:

   State    - State code

Return Value:

   Pointer to a string representation of the state code.

--*/

{
    switch (State) {
        case PowerDeviceUnspecified:
            return "PowerDeviceUnspecified";
        case PowerDeviceD0:
            return "PowerDeviceD0";
        case PowerDeviceD1:
            return "PowerDeviceD1";
        case PowerDeviceD2:
            return "PowerDeviceD2";
        case PowerDeviceD3:
            return "PowerDeviceD3";
        case PowerDeviceMaximum:
            return "PowerDeviceMaximum";
        default:
            return "PowerDevice?????";
    }
}

PCHAR
PowerSystemStateString(
    SYSTEM_POWER_STATE State
    )

/*++

Routine Description:

   This routine translates a power system state code into a string.

Arguments:

   State    - State code

Return Value:

   Pointer to a string representation of the state code.

--*/

{
    switch (State) {
        case PowerSystemUnspecified:
            return "PowerSystemUnspecified";
        case PowerSystemWorking:
            return "PowerSystemWorking";
        case PowerSystemSleeping1:
            return "PowerSystemSleeping1";
        case PowerSystemSleeping2:
            return "PowerSystemSleeping2";
        case PowerSystemSleeping3:
            return "PowerSystemSleeping3";
        case PowerSystemHibernate:
            return "PowerSystemHibernate";
        case PowerSystemShutdown:
            return "PowerSystemShutdown";
        case PowerSystemMaximum:
            return "PowerSystemMaximum";
        default:
            return "PowerSystem?????";
    }
}

PCHAR
IoctlString(
    ULONG IoControlCode
    )

/*++

Routine Description:

   This routine translates an IOCTL code into a string.

Arguments:

   IoControlCode    - I/O control code

Return Value:

   Pointer to a string representation of the I/O control code.

--*/

{
    switch (IoControlCode) {
        case IOCTL_MOUNTDEV_QUERY_DEVICE_NAME:
            return "IOCTL_MOUNTDEV_QUERY_DEVICE_NAME";
        case IOCTL_MOUNTDEV_QUERY_UNIQUE_ID:
            return "IOCTL_MOUNTDEV_QUERY_UNIQUE_ID";
        case IOCTL_MOUNTDEV_QUERY_SUGGESTED_LINK_NAME:
            return "IOCTL_MOUNTDEV_QUERY_SUGGESTED_LINK_NAME";
        case IOCTL_STORAGE_GET_MEDIA_TYPES:
            return "IOCTL_STORAGE_GET_MEDIA_TYPES";
        case IOCTL_DISK_GET_MEDIA_TYPES:
            return "IOCTL_DISK_GET_MEDIA_TYPES";
        case IOCTL_DISK_CHECK_VERIFY:
            return "IOCTL_DISK_CHECK_VERIFY";
        case IOCTL_DISK_GET_DRIVE_GEOMETRY:
            return "IOCTL_DISK_GET_DRIVE_GEOMETRY";
        case IOCTL_DISK_IS_WRITABLE:
            return "IOCTL_DISK_IS_WRITABLE";
        case IOCTL_DISK_VERIFY:
            return "IOCTL_DISK_VERIFY";
        case IOCTL_DISK_GET_DRIVE_LAYOUT:
            return "IOCTL_DISK_GET_DRIVE_LAYOUT";
        case IOCTL_DISK_GET_PARTITION_INFO:
            return "IOCTL_DISK_GET_PARTITION_INFO";
        case IOCTL_DISK_GET_PARTITION_INFO_EX:
            return "IOCTL_DISK_GET_PARTITION_INFO_EX";
        case IOCTL_DISK_GET_LENGTH_INFO:
            return "IOCTL_DISK_GET_LENGTH_INFO";
        case IOCTL_DISK_MEDIA_REMOVAL:
            return "IOCTL_DISK_MEDIA_REMOVAL";
        case IOCTL_SA_GET_VERSION:
            return "IOCTL_SA_GET_VERSION";
        case IOCTL_SA_GET_CAPABILITIES:
            return "IOCTL_SA_GET_CAPABILITIES";
        case IOCTL_SAWD_DISABLE:
            return "IOCTL_SAWD_DISABLE";
        case IOCTL_SAWD_QUERY_EXPIRE_BEHAVIOR:
            return "IOCTL_SAWD_QUERY_EXPIRE_BEHAVIOR";
        case IOCTL_SAWD_SET_EXPIRE_BEHAVIOR:
            return "IOCTL_SAWD_SET_EXPIRE_BEHAVIOR";
        case IOCTL_SAWD_PING:
            return "IOCTL_SAWD_PING";
        case IOCTL_SAWD_QUERY_TIMER:
            return "IOCTL_SAWD_QUERY_TIMER";
        case IOCTL_SAWD_SET_TIMER:
            return "IOCTL_SAWD_SET_TIMER";
        case IOCTL_NVRAM_WRITE_BOOT_COUNTER:
            return "IOCTL_NVRAM_WRITE_BOOT_COUNTER";
        case IOCTL_NVRAM_READ_BOOT_COUNTER:
            return "IOCTL_NVRAM_READ_BOOT_COUNTER";
        case IOCTL_SADISPLAY_LOCK:
            return "IOCTL_SADISPLAY_LOCK";
        case IOCTL_SADISPLAY_UNLOCK:
            return "IOCTL_SADISPLAY_UNLOCK";
        case IOCTL_SADISPLAY_BUSY_MESSAGE:
            return "IOCTL_SADISPLAY_BUSY_MESSAGE";
        case IOCTL_SADISPLAY_SHUTDOWN_MESSAGE:
            return "IOCTL_SADISPLAY_SHUTDOWN_MESSAGE";
        case IOCTL_SADISPLAY_CHANGE_LANGUAGE:
            return "IOCTL_SADISPLAY_CHANGE_LANGUAGE";
        default:
            return "IOCTL_?????";
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serveravailability\saport\watchdog.cpp ===
/*++

Copyright (c) 1991 - 2001 Microsoft Corporation

Module Name:

    ##  #  ##   ###   ######  ####  ##   ## #####    #####   ####      ####  #####  #####
    ## ### ##   ###     ##   ##   # ##   ## ##  ##  ##   ## ##   #    ##   # ##  ## ##  ##
    ## ### ##  ## ##    ##   ##     ##   ## ##   ## ##   ## ##        ##     ##  ## ##  ##
    ## # # ##  ## ##    ##   ##     ####### ##   ## ##   ## ## ###    ##     ##  ## ##  ##
     ### ###  #######   ##   ##     ##   ## ##   ## ##   ## ##  ##    ##     #####  #####
     ### ###  ##   ##   ##   ##   # ##   ## ##  ##  ##   ## ##  ## ## ##   # ##     ##
     ##   ##  ##   ##   ##    ####  ##   ## #####    #####   ##### ##  ####  ##     ##

Abstract:

    This module contains functions specfic to the
    watchdog device.  The logic in this module is not
    hardware specific, but is logic that is common
    to all hardware implementations.

Author:

    Wesley Witt (wesw) 1-Oct-2001

Environment:

    Kernel mode only.

Notes:


--*/

#include "internal.h"



NTSTATUS
SaWatchdogDeviceInitialization(
    IN PSAPORT_DRIVER_EXTENSION DriverExtension
    )

/*++

Routine Description:

   This is the NVRAM specific code for driver initialization.
   This function is called by SaPortInitialize, which is called by
   the NVRAM driver's DriverEntry function.

Arguments:

   DriverExtension      - Driver extension structure

Return Value:

    NT status code.

--*/

{
    UNREFERENCED_PARAMETER(DriverExtension);
    return STATUS_SUCCESS;
}


NTSTATUS
SaWatchdogIoValidation(
    IN PWATCHDOG_DEVICE_EXTENSION DeviceExtension,
    IN PIRP Irp,
    PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

   This is the NVRAM specific code for processing
   all I/O validation for reads and writes.

Arguments:

   DeviceExtension      - NVRAM device extension
   Irp                  - Pointer to an IRP structure that describes the requested I/O operation.
   IrpSp                - Irp stack pointer

Return Value:

    NT status code.

--*/

{
    UNREFERENCED_PARAMETER(DeviceExtension);
    UNREFERENCED_PARAMETER(Irp);
    UNREFERENCED_PARAMETER(IrpSp);
    return STATUS_NOT_SUPPORTED;
}


NTSTATUS
SaWatchdogShutdownNotification(
    IN PWATCHDOG_DEVICE_EXTENSION DeviceExtension,
    IN PIRP Irp,
    PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

   This is the NVRAM specific code for processing
   the system shutdown notification.

Arguments:

   DeviceExtension      - NVRAM device extension
   Irp                  - Pointer to an IRP structure that describes the requested I/O operation.
   IrpSp                - Irp stack pointer

Return Value:

    NT status code.

--*/

{
    UNREFERENCED_PARAMETER(DeviceExtension);
    UNREFERENCED_PARAMETER(Irp);
    UNREFERENCED_PARAMETER(IrpSp);
    return STATUS_SUCCESS;
}


VOID
WatchdogProcessPingThread(
    IN PVOID StartContext
    )

/*++

Routine Description:

   This function runs as a system thread and serves to
   ping the watchdog hardware while the system boots.

Arguments:

   StartContext     - Context pointer; device extension

Return Value:

    None.

--*/

{
    PWATCHDOG_DEVICE_EXTENSION DeviceExtension = (PWATCHDOG_DEVICE_EXTENSION) StartContext;
    NTSTATUS Status;
    LARGE_INTEGER DueTime;
    UNICODE_STRING UnicodeString;
    PFILE_OBJECT DisplayFileObject = NULL;
    PDEVICE_OBJECT DisplayDeviceObject = NULL;
    BOOLEAN BusyMessageDisplayed = FALSE;
    ULONG TimerValue = WATCHDOG_TIMER_VALUE;


    //
    // Set the timer resolution
    //

    Status = CallMiniPortDriverDeviceControl(
        DeviceExtension,
        DeviceExtension->DeviceObject,
        IOCTL_SAWD_SET_TIMER,
        &TimerValue,
        sizeof(ULONG),
        NULL,
        0
        );
    if (!NT_SUCCESS(Status)) {
        REPORT_ERROR( DeviceExtension->DeviceType, "Failed to ping the watchdog\n", Status );
    }

    //
    // Ping loop
    //

    while (1) {

        //
        // Get a pointer to the display device
        //

        if (DisplayDeviceObject == NULL) {

            RtlInitUnicodeString( &UnicodeString, SA_DEVICE_DISPLAY_NAME_STRING );

            Status = IoGetDeviceObjectPointer(
                &UnicodeString,
                FILE_ALL_ACCESS,
                &DisplayFileObject,
                &DisplayDeviceObject
                );
            if (!NT_SUCCESS(Status)) {
                REPORT_ERROR( DeviceExtension->DeviceType, "IoGetDeviceObjectPointer failed", Status );
            }

        }

        //
        // Display the busy message if necessary
        //

        if (DisplayDeviceObject && BusyMessageDisplayed == FALSE) {

            Status = CallMiniPortDriverDeviceControl(
                DeviceExtension,
                DisplayDeviceObject,
                IOCTL_SADISPLAY_BUSY_MESSAGE,
                NULL,
                0,
                NULL,
                0
                );
            if (!NT_SUCCESS(Status)) {
                REPORT_ERROR( DeviceExtension->DeviceType, "Failed to display the busy message", Status );
            } else {
                BusyMessageDisplayed = TRUE;
                ObDereferenceObject( DisplayFileObject );
            }

        }

        //
        // Call the watchdog driver so that the hardware is pinged
        // and prevent the system from rebooting
        //

        Status = CallMiniPortDriverDeviceControl(
            DeviceExtension,
            DeviceExtension->DeviceObject,
            IOCTL_SAWD_PING,
            NULL,
            0,
            NULL,
            0
            );
        if (!NT_SUCCESS(Status)) {
            REPORT_ERROR( DeviceExtension->DeviceType, "Failed to ping the watchdog\n", Status );
        }

        //
        // Wait...
        //

        DueTime.QuadPart = -SecToNano(WATCHDOG_PING_SECONDS);
        Status = KeWaitForSingleObject( &DeviceExtension->PingEvent, Executive, KernelMode, FALSE, &DueTime );
        if (Status != STATUS_TIMEOUT) {

            //
            // The ping event was triggered
            //

            //
            // Call the watchdog driver so that the hardware is pinged
            // and prevent the system from rebooting
            //

            Status = CallMiniPortDriverDeviceControl(
                DeviceExtension,
                DeviceExtension->DeviceObject,
                IOCTL_SAWD_PING,
                NULL,
                0,
                NULL,
                0
                );
            if (!NT_SUCCESS(Status)) {
                REPORT_ERROR( DeviceExtension->DeviceType, "Failed to ping the watchdog\n", Status );
            }

            return;

        } else {

            //
            // We timed out
            //

            ExAcquireFastMutex( &DeviceExtension->DeviceLock );
            if (DeviceExtension->ActiveProcessCount == 0) {
                KeQuerySystemTime( &DueTime );
                DueTime.QuadPart = NanoToSec( DueTime.QuadPart - DeviceExtension->LastProcessTime.QuadPart );
                if (DueTime.QuadPart > WATCHDOG_INIT_SECONDS) {
                    ExReleaseFastMutex( &DeviceExtension->DeviceLock );
                    return;
                }
            }
            ExReleaseFastMutex( &DeviceExtension->DeviceLock );
        }
    }
}


VOID
WatchdogProcessWatchThread(
    IN PVOID StartContext
    )

/*++

Routine Description:

   This function runs as a system thread and the sole
   purpose is to wait for a list of processes to terminate.

Arguments:

   StartContext     - Context pointer; device extension

Return Value:

    None.

--*/

{
    PWATCHDOG_PROCESS_WATCH ProcessWatch = (PWATCHDOG_PROCESS_WATCH) StartContext;
    PWATCHDOG_DEVICE_EXTENSION DeviceExtension = ProcessWatch->DeviceExtension;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    CLIENT_ID ClientId;
    HANDLE ProcessHandle = NULL;
    LARGE_INTEGER CurrentTime;


    __try {
        InitializeObjectAttributes( &Obja, NULL, 0, NULL, NULL );

        ClientId.UniqueThread = NULL;
        ClientId.UniqueProcess = ProcessWatch->ProcessId;

        Status = ZwOpenProcess(
            &ProcessHandle,
            PROCESS_ALL_ACCESS,
            &Obja,
            &ClientId
            );
        if (!NT_SUCCESS(Status)) {
            ERROR_RETURN( DeviceExtension->DeviceType, "ZwOpenProcess failed", Status );
        }

        //
        // Wait for the process to complete
        //

        Status = ZwWaitForSingleObject(
            ProcessHandle,
            FALSE,
            NULL
            );
        if (!NT_SUCCESS(Status)) {
            REPORT_ERROR( DeviceExtension->DeviceType, "KeWaitForSingleObject failed", Status );
        }

        //
        // The process terminated
        //

        ExAcquireFastMutex( &DeviceExtension->DeviceLock );
        DeviceExtension->ActiveProcessCount -= 1;
        if (DeviceExtension->ActiveProcessCount == 0) {
            KeQuerySystemTime( &CurrentTime );
            CurrentTime.QuadPart = CurrentTime.QuadPart - DeviceExtension->LastProcessTime.QuadPart;
            if (NanoToSec(CurrentTime.QuadPart) > WATCHDOG_INIT_SECONDS) {
                KeSetEvent( &DeviceExtension->PingEvent, 0, FALSE );
            }
        }
        ExReleaseFastMutex( &DeviceExtension->DeviceLock );


    } __finally {

        if (ProcessHandle != NULL) {
            ZwClose( ProcessHandle );
        }

        ExFreePool( ProcessWatch );

    }
}


VOID
WatchdogInitializeThread(
    IN PVOID StartContext
    )

/*++

Routine Description:

   This function runs as a system thread and serves to
   look for a list of processes running on the system.

Arguments:

   StartContext     - Context pointer; device extension

Return Value:

    None.

--*/

{
    PWATCHDOG_DEVICE_EXTENSION DeviceExtension = (PWATCHDOG_DEVICE_EXTENSION) StartContext;
    NTSTATUS Status;
    ULONG BufferSize;
    PUCHAR Buffer = NULL;
    PSYSTEM_PROCESS_INFORMATION ProcessInfo;
    ULONG TotalOffset;
    ULONG TaskBufferSize = 0;
    PKEY_VALUE_FULL_INFORMATION KeyInformation = NULL;
    PUCHAR p;
    ULONG TaskCount = 0;
    OBJECT_ATTRIBUTES Obja;
    HANDLE ThreadHandle;
    LARGE_INTEGER DueTime;
    UNICODE_STRING ProcessName;
    PWATCHDOG_PROCESS_WATCH ProcessWatch;
    PHANDLE Tasks = NULL;


    __try {

        //
        // Read the task names from the registry
        //

        Status = ReadRegistryValue(
            DeviceExtension->DriverExtension,
            &DeviceExtension->DriverExtension->RegistryPath,
            L"ExceptionTasks",
            &KeyInformation
            );
        if (!NT_SUCCESS(Status)) {
            ERROR_RETURN( DeviceExtension->DeviceType, "ReadRegistryValue failed", Status );
        }

        if (KeyInformation->Type != REG_MULTI_SZ) {
            Status = STATUS_OBJECT_TYPE_MISMATCH;
            ERROR_RETURN( DeviceExtension->DeviceType, "ExceptionTasks value is corrupt", Status );
        }

        //
        // Count the number of tasks
        //

        p = (PUCHAR)((PUCHAR)KeyInformation + KeyInformation->DataOffset);
        while (*p) {
            p += (STRING_SZ(p) + sizeof(WCHAR));
            TaskCount += 1;
        }

        if (TaskCount == 0) {
            Status = STATUS_NO_MORE_ENTRIES;
            ERROR_RETURN( DeviceExtension->DeviceType, "No tasks specified in the ExceptionTasks registry value", Status );
        }

        //
        // Allocate an array to hold the process handles
        //

        Tasks = (PHANDLE) ExAllocatePool( NonPagedPool, (TaskCount + 1) * sizeof(HANDLE) );
        if (Tasks == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            ERROR_RETURN( DeviceExtension->DeviceType, "Failed to allocate pool for task array buffer", Status );
        }

        while (1) {

            //
            // Query the system for the number of tasks that are running
            //

            Status = ZwQuerySystemInformation(
                SystemProcessInformation,
                NULL,
                0,
                &BufferSize
                );
            if (Status != STATUS_INFO_LENGTH_MISMATCH) {
                ERROR_RETURN( DeviceExtension->DeviceType, "ZwQuerySystemInformation failed", Status );
            }

            //
            // Allocate the pool to hold that process information
            //

            Buffer = (PUCHAR) ExAllocatePool( NonPagedPool, BufferSize + 2048 );
            if (Buffer == NULL) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                ERROR_RETURN( DeviceExtension->DeviceType, "Failed to allocate pool for system information buffer", Status );
            }

            //
            // Get the task list from the system
            //

            Status = ZwQuerySystemInformation(
                SystemProcessInformation,
                Buffer,
                BufferSize,
                NULL
                );
            if (!NT_SUCCESS(Status)) {
                ERROR_RETURN( DeviceExtension->DeviceType, "ZwQuerySystemInformation failed", Status );
            }

            //
            // Loop over each running process and check it
            // against the exception process list.  If the process
            // is specified as an exception process then open a handle
            // to the process.
            //

            TaskCount = 0;
            p = (PUCHAR)((PUCHAR)KeyInformation + KeyInformation->DataOffset);

            //
            // Walk the list of processes in the registry value
            //

            while (*p) {

                //
                // Loop initialization
                //

                ProcessInfo = (PSYSTEM_PROCESS_INFORMATION) Buffer;
                TotalOffset = 0;
                RtlInitUnicodeString( &ProcessName, (PWSTR)p );

                //
                // Walk the processes in the system process list
                // and try to match each with the selected process
                // from the registry.
                //

                while (1) {

                    //
                    // Only valid process names
                    //

                    if (ProcessInfo->ImageName.Buffer) {

                        //
                        // Compare the process names
                        //

                        if (RtlCompareUnicodeString( &ProcessInfo->ImageName, &ProcessName, TRUE ) == 0) {

                            //
                            // Check to see if we've already seen the process in
                            // a previous loop thru thr process list
                            //

                            if (Tasks[TaskCount] != ProcessInfo->UniqueProcessId) {

                                //
                                // The process matches and is new so set things up so
                                // that we start watching the process to end
                                //

                                Tasks[TaskCount] = ProcessInfo->UniqueProcessId;
                                ProcessWatch = (PWATCHDOG_PROCESS_WATCH) ExAllocatePool( NonPagedPool, sizeof(WATCHDOG_PROCESS_WATCH) );
                                if (ProcessWatch == NULL) {
                                    Status = STATUS_INSUFFICIENT_RESOURCES;
                                    ERROR_RETURN( DeviceExtension->DeviceType, "Failed to allocate pool for process watch structure", Status );
                                }

                                //
                                // Start the ping thread iff this is the first being watched
                                //

                                ExAcquireFastMutex( &DeviceExtension->DeviceLock );
                                if (DeviceExtension->ActiveProcessCount == 0) {
                                    InitializeObjectAttributes( &Obja, NULL, OBJ_KERNEL_HANDLE, NULL, NULL );
                                    Status = PsCreateSystemThread( &ThreadHandle, 0, &Obja, 0, NULL, WatchdogProcessPingThread, DeviceExtension );
                                    if (!NT_SUCCESS(Status)) {
                                        ExReleaseFastMutex( &DeviceExtension->DeviceLock );
                                        ERROR_RETURN( DeviceExtension->DeviceType, "PsCreateSystemThread failed", Status );
                                    }
                                    ZwClose( ThreadHandle );
                                }
                                KeQuerySystemTime( &DeviceExtension->LastProcessTime );
                                DeviceExtension->ActiveProcessCount += 1;
                                ExReleaseFastMutex( &DeviceExtension->DeviceLock );

                                //
                                // Start a thread to watch this process
                                //

                                ProcessWatch->DeviceExtension = DeviceExtension;
                                ProcessWatch->ProcessId = ProcessInfo->UniqueProcessId;
                                InitializeObjectAttributes( &Obja, NULL, OBJ_KERNEL_HANDLE, NULL, NULL );
                                Status = PsCreateSystemThread( &ThreadHandle, 0, &Obja, 0, NULL, WatchdogProcessWatchThread, ProcessWatch );
                                if (!NT_SUCCESS(Status)) {
                                    ERROR_RETURN( DeviceExtension->DeviceType, "PsCreateSystemThread failed", Status );
                                }
                                ZwClose( ThreadHandle );
                            }
                        }
                    }

                    //
                    // Loop to the next process in the system process list
                    //

                    if (ProcessInfo->NextEntryOffset == 0) {
                        break;
                    }
                    TotalOffset += ProcessInfo->NextEntryOffset;
                    ProcessInfo = (PSYSTEM_PROCESS_INFORMATION) &Buffer[TotalOffset];
                }

                //
                // Loop to the next process in the registry list
                //

                p += (STRING_SZ(p) + sizeof(WCHAR));
                TaskCount += 1;
            }

            //
            // Clean up all resources allocated in this loop
            //

            ExFreePool( Buffer );
            Buffer = NULL;

            //
            // Delay execution before looping again
            //

            DueTime.QuadPart = -SecToNano(WATCHDOG_INIT_SECONDS);
            Status = KeWaitForSingleObject( &DeviceExtension->StopEvent, Executive, KernelMode, FALSE, &DueTime );
            if (Status != STATUS_TIMEOUT) {
                __leave;
            }
        }

    } __finally {

        if (KeyInformation) {
            ExFreePool( KeyInformation );
        }

        if (Buffer) {
            ExFreePool( Buffer );
        }

        if (Tasks) {
            ExFreePool( Tasks );
        }
    }
}


ULONG
IsTextModeSetupRunning(
    IN PWATCHDOG_DEVICE_EXTENSION DeviceExtension
    )

/*++

Routine Description:

   This function checks to see if we are running in
   text mode setup.

Arguments:

   DeviceExtension   - NVRAM device extension

Return Value:

    NT status code.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;
    HANDLE SetupKey = NULL;
    ULONG TextModeSetupInProgress = 0;


    //
    // Check to see if we're running in GUI mode setup
    //

    __try {

        RtlInitUnicodeString( &UnicodeString, L"\\Registry\\Machine\\System\\ControlSet001\\Services\\setupdd" );

        InitializeObjectAttributes(
            &Obja,
            &UnicodeString,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );

        Status = ZwOpenKey(
            &SetupKey,
            KEY_READ,
            &Obja
            );
        if (NT_SUCCESS(Status)) {
            TextModeSetupInProgress = 1;
        } else {
            ERROR_RETURN( DeviceExtension->DeviceType, "ZwOpenKey failed", Status );
        }

    } __finally {

        if (SetupKey) {
            ZwClose( SetupKey );
        }

    }

    return TextModeSetupInProgress;
}


ULONG
IsGuiModeSetupRunning(
    IN PWATCHDOG_DEVICE_EXTENSION DeviceExtension
    )

/*++

Routine Description:

   This function checks to see if we are running in
   GUI mode setup.

Arguments:

   DeviceExtension   - NVRAM device extension

Return Value:

    NT status code.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;
    HANDLE SetupKey = NULL;
    UCHAR KeyInformationBuffer[sizeof(KEY_VALUE_FULL_INFORMATION)+64];
    PKEY_VALUE_FULL_INFORMATION KeyInformation = (PKEY_VALUE_FULL_INFORMATION) KeyInformationBuffer;
    ULONG KeyValueLength;
    ULONG SystemSetupInProgress = 0;


    //
    // Check to see if we're running in GUI mode setup
    //
    __try {

        RtlInitUnicodeString( &UnicodeString, L"\\Registry\\Machine\\System\\Setup" );

        InitializeObjectAttributes(
            &Obja,
            &UnicodeString,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );

        Status = ZwOpenKey(
            &SetupKey,
            KEY_READ,
            &Obja
            );
        if (!NT_SUCCESS(Status)) {
            ERROR_RETURN( DeviceExtension->DeviceType, "ZwOpenKey failed", Status );
        }

        RtlInitUnicodeString( &UnicodeString, L"SystemSetupInProgress" );

        Status = ZwQueryValueKey(
            SetupKey,
            &UnicodeString,
            KeyValueFullInformation,
            KeyInformation,
            sizeof(KeyInformationBuffer),
            &KeyValueLength
            );
        if (!NT_SUCCESS(Status)) {
            ERROR_RETURN( DeviceExtension->DeviceType, "ZwQueryValueKey failed", Status );
        }

        if (KeyInformation->Type != REG_DWORD) {
            Status = STATUS_OBJECT_TYPE_MISMATCH;
            ERROR_RETURN( DeviceExtension->DeviceType, "SystemSetupInProgress value is corrupt", Status );
        }

        SystemSetupInProgress = *(PULONG)((PUCHAR)KeyInformation + KeyInformation->DataOffset);

    } __finally {

        if (SetupKey) {
            ZwClose( SetupKey );
        }

    }

    return SystemSetupInProgress;
}


NTSTATUS
SaWatchdogStartDevice(
    IN PWATCHDOG_DEVICE_EXTENSION DeviceExtension
    )

/*++

Routine Description:

   This is the NVRAM specific code for processing
   the PNP start device request.

Arguments:

   DeviceExtension   - NVRAM device extension

Return Value:

    NT status code.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE ThreadHandle;
    ULONG SetupInProgress = 0;


    //
    // Setup the device extension fields
    //

    ExInitializeFastMutex( &DeviceExtension->DeviceLock );
    KeInitializeEvent( &DeviceExtension->PingEvent, SynchronizationEvent, FALSE );
    KeInitializeEvent( &DeviceExtension->StopEvent, SynchronizationEvent, FALSE );

    //
    // Check to see if we're running in setup
    //

    if (IsTextModeSetupRunning( DeviceExtension ) || IsGuiModeSetupRunning( DeviceExtension )) {
        SetupInProgress = 1;
    }

    if (SetupInProgress != 0) {

        //
        // Start the ping thread so that setup is not terminated
        //

        DeviceExtension->ActiveProcessCount += 1;

        InitializeObjectAttributes( &Obja, NULL, OBJ_KERNEL_HANDLE, NULL, NULL );
        Status = PsCreateSystemThread( &ThreadHandle, 0, &Obja, 0, NULL, WatchdogProcessPingThread, DeviceExtension );
        if (!NT_SUCCESS(Status)) {
            REPORT_ERROR( DeviceExtension->DeviceType, "PsCreateSystemThread failed", Status );
        } else {
            ZwClose( ThreadHandle );
        }

        return STATUS_SUCCESS;
    }

    //
    // Start the delay boot initialization thread
    //

    InitializeObjectAttributes( &Obja, NULL, OBJ_KERNEL_HANDLE, NULL, NULL );
    Status = PsCreateSystemThread( &ThreadHandle, 0, &Obja, 0, NULL, WatchdogInitializeThread, DeviceExtension );
    if (!NT_SUCCESS(Status)) {
        REPORT_ERROR( DeviceExtension->DeviceType, "PsCreateSystemThread failed", Status );
    } else {
        ZwClose( ThreadHandle );
    }

    return STATUS_SUCCESS;
}


DECLARE_IOCTL_HANDLER( HandleWdDisable )

/*++

Routine Description:

   This routine allows the watchdog timer to be started or stopped.

Arguments:

   DeviceObject         - The device object for the target device.
   Irp                  - Pointer to an IRP structure that describes the requested I/O operation.
   DeviceExtension      - Pointer to the main port driver device extension.
   InputBuffer          - Pointer to the user's input buffer
   InputBufferLength    - Length in bytes of the input buffer
   OutputBuffer         - Pointer to the user's output buffer
   OutputBufferLength   - Length in bytes of the output buffer

Return Value:

   NT status code.

--*/

{
    if (InputBufferLength != sizeof(ULONG)) {
        REPORT_ERROR( DeviceExtension->DeviceType, "Input buffer != sizeof(ULONG)", STATUS_INVALID_BUFFER_SIZE );
        return CompleteRequest( Irp, STATUS_INVALID_BUFFER_SIZE, 0 );
    }

    return DO_DEFAULT();
}


DECLARE_IOCTL_HANDLER( HandleWdQueryExpireBehavior )

/*++

Routine Description:

   This routine queries the watchdog expiry behavior

Arguments:

   DeviceObject         - The device object for the target device.
   Irp                  - Pointer to an IRP structure that describes the requested I/O operation.
   DeviceExtension      - Pointer to the main port driver device extension.
   InputBuffer          - Pointer to the user's input buffer
   InputBufferLength    - Length in bytes of the input buffer
   OutputBuffer         - Pointer to the user's output buffer
   OutputBufferLength   - Length in bytes of the output buffer

Return Value:

   NT status code.

--*/

{
    if (OutputBufferLength != sizeof(ULONG)) {
        REPORT_ERROR( DeviceExtension->DeviceType, "output buffer != sizeof(ULONG)", STATUS_INVALID_BUFFER_SIZE );
        return CompleteRequest( Irp, STATUS_INVALID_BUFFER_SIZE, 0 );
    }

    return DO_DEFAULT();
}


DECLARE_IOCTL_HANDLER( HandleWdSetExpireBehavior )

/*++

Routine Description:

   This routine set/changes the watchdog expiry behavior

Arguments:

   DeviceObject         - The device object for the target device.
   Irp                  - Pointer to an IRP structure that describes the requested I/O operation.
   DeviceExtension      - Pointer to the main port driver device extension.
   InputBuffer          - Pointer to the user's input buffer
   InputBufferLength    - Length in bytes of the input buffer
   OutputBuffer         - Pointer to the user's output buffer
   OutputBufferLength   - Length in bytes of the output buffer

Return Value:

   NT status code.

--*/

{
    if (InputBufferLength != sizeof(ULONG)) {
        REPORT_ERROR( DeviceExtension->DeviceType, "Input buffer != sizeof(ULONG)", STATUS_INVALID_BUFFER_SIZE );
        return CompleteRequest( Irp, STATUS_INVALID_BUFFER_SIZE, 0 );
    }

    return DO_DEFAULT();
}


DECLARE_IOCTL_HANDLER( HandleWdPing )

/*++

Routine Description:

   This routine pings the watchdog timer to prevent
   the timer from expiring and restarting the system.

Arguments:

   DeviceObject         - The device object for the target device.
   Irp                  - Pointer to an IRP structure that describes the requested I/O operation.
   DeviceExtension      - Pointer to the main port driver device extension.
   InputBuffer          - Pointer to the user's input buffer
   InputBufferLength    - Length in bytes of the input buffer
   OutputBuffer         - Pointer to the user's output buffer
   OutputBufferLength   - Length in bytes of the output buffer

Return Value:

   NT status code.

--*/

{
    if (!IS_IRP_INTERNAL( Irp )) {
        KeSetEvent( &((PWATCHDOG_DEVICE_EXTENSION)DeviceExtension)->StopEvent, 0, FALSE );
        KeSetEvent( &((PWATCHDOG_DEVICE_EXTENSION)DeviceExtension)->PingEvent, 0, FALSE );
    }

    return DO_DEFAULT();
}


DECLARE_IOCTL_HANDLER( HandleWdDelayBoot )

/*++

Routine Description:

   This routine pings the watchdog timer to prevent
   the timer from expiring and restarting the system.

Arguments:

   DeviceObject         - The device object for the target device.
   Irp                  - Pointer to an IRP structure that describes the requested I/O operation.
   DeviceExtension      - Pointer to the main port driver device extension.
   InputBuffer          - Pointer to the user's input buffer
   InputBufferLength    - Length in bytes of the input buffer
   OutputBuffer         - Pointer to the user's output buffer
   OutputBufferLength   - Length in bytes of the output buffer

Return Value:

   NT status code.

--*/

{
    NTSTATUS Status;
    LARGE_INTEGER CurrentTime;
    OBJECT_ATTRIBUTES Obja;
    HANDLE ThreadHandle;


    if (InputBufferLength != sizeof(ULONG)) {
        REPORT_ERROR( ((PWATCHDOG_DEVICE_EXTENSION)DeviceExtension)->DeviceType, "Input buffer length != sizeof(ULONG)", STATUS_INVALID_BUFFER_SIZE );
        return CompleteRequest( Irp, STATUS_INVALID_BUFFER_SIZE, 0 );
    }

    ExAcquireFastMutex( &((PWATCHDOG_DEVICE_EXTENSION)DeviceExtension)->DeviceLock );

    switch (*((PULONG)InputBuffer)) {
        case 0:
            //
            // Disable the delay boot, meaning that the system should continue booting
            //
            ((PWATCHDOG_DEVICE_EXTENSION)DeviceExtension)->ActiveProcessCount -= 1;
            if (((PWATCHDOG_DEVICE_EXTENSION)DeviceExtension)->ActiveProcessCount == 0) {
                KeQuerySystemTime( &CurrentTime );
                CurrentTime.QuadPart = CurrentTime.QuadPart - ((PWATCHDOG_DEVICE_EXTENSION)DeviceExtension)->LastProcessTime.QuadPart;
                if (NanoToSec(CurrentTime.QuadPart) > WATCHDOG_INIT_SECONDS) {
                    KeSetEvent( &((PWATCHDOG_DEVICE_EXTENSION)DeviceExtension)->PingEvent, 0, FALSE );
                }
            }
            break;

        case 1:
            //
            // Enable the delay boot, meaning that the system will delay until this driver is finished
            //
            if (((PWATCHDOG_DEVICE_EXTENSION)DeviceExtension)->ActiveProcessCount == 0) {
                InitializeObjectAttributes( &Obja, NULL, OBJ_KERNEL_HANDLE, NULL, NULL );
                Status = PsCreateSystemThread( &ThreadHandle, 0, &Obja, 0, NULL, WatchdogProcessPingThread, DeviceExtension );
                if (!NT_SUCCESS(Status)) {
                    REPORT_ERROR( ((PWATCHDOG_DEVICE_EXTENSION)DeviceExtension)->DeviceType, "PsCreateSystemThread failed", Status );
                } else {
                    ZwClose( ThreadHandle );
                }
            }
            ((PWATCHDOG_DEVICE_EXTENSION)DeviceExtension)->ActiveProcessCount += 1;
            break;

        default:
            break;
    }

    ExReleaseFastMutex( &((PWATCHDOG_DEVICE_EXTENSION)DeviceExtension)->DeviceLock );

    return DO_DEFAULT();
}


DECLARE_IOCTL_HANDLER( HandleWdQueryTimer )

/*++

Routine Description:

   This routine queries the watchdog timer value.  The timer counts
   down from a BIOS set value to zero.  When the timer reaches zero the
   BIOS assumes that the system is non-responsive and the system
   is either restarted or shutdown.

Arguments:

   DeviceObject         - The device object for the target device.
   Irp                  - Pointer to an IRP structure that describes the requested I/O operation.
   DeviceExtension      - Pointer to the main port driver device extension.
   InputBuffer          - Pointer to the user's input buffer
   InputBufferLength    - Length in bytes of the input buffer
   OutputBuffer         - Pointer to the user's output buffer
   OutputBufferLength   - Length in bytes of the output buffer

Return Value:

   NT status code.

--*/

{
    if (OutputBufferLength != sizeof(ULONG)) {
        REPORT_ERROR( DeviceExtension->DeviceType, "Output buffer != sizeof(ULONG)", STATUS_INVALID_BUFFER_SIZE );
        return CompleteRequest( Irp, STATUS_INVALID_BUFFER_SIZE, 0 );
    }

    return DO_DEFAULT();
}


DECLARE_IOCTL_HANDLER( HandleWdSetTimer )

/*++

Routine Description:

   This routine sets/changes the watchdog timer value.  The timer counts
   down from a BIOS set value to zero.  When the timer reaches zero the
   BIOS assumes that the system is non-responsive and the system
   is either restarted or shutdown.

Arguments:

   DeviceObject         - The device object for the target device.
   Irp                  - Pointer to an IRP structure that describes the requested I/O operation.
   DeviceExtension      - Pointer to the main port driver device extension.
   InputBuffer          - Pointer to the user's input buffer
   InputBufferLength    - Length in bytes of the input buffer
   OutputBuffer         - Pointer to the user's output buffer
   OutputBufferLength   - Length in bytes of the output buffer

Return Value:

   NT status code.

--*/

{
    if (InputBufferLength != sizeof(ULONG)) {
        REPORT_ERROR( DeviceExtension->DeviceType, "Input buffer != sizeof(ULONG)", STATUS_INVALID_BUFFER_SIZE );
        return CompleteRequest( Irp, STATUS_INVALID_BUFFER_SIZE, 0 );
    }

    return DO_DEFAULT();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serveravailability\serverworks\display\swdisp.h ===
/*++

Copyright (c) 1991 - 2001 Microsoft Corporation

Module Name:

     ###  ##  #  ## #####   ####  ###  #####     ##   ##
    ##  # ## ### ## ##  ##   ##  ##  # ##  ##    ##   ##
    ###   ## ### ## ##   ##  ##  ###   ##  ##    ##   ##
     ###  ## # # ## ##   ##  ##   ###  ##  ##    #######
      ###  ### ###  ##   ##  ##    ### #####     ##   ##
    #  ##  ### ###  ##  ##   ##  #  ## ##     ## ##   ##
     ###   ##   ##  #####   ####  ###  ##     ## ##   ##

Abstract:

    This header file contains the definitions for the
    ServerWorks local display miniport driver.

Author:

    Wesley Witt (wesw) 1-Oct-2001

Environment:

    Kernel mode only.

Notes:


--*/

extern "C" {
#include <ntddk.h>
#include <stdio.h>
}

#define MINIPORT_DEVICE_TYPE    SA_DEVICE_DISPLAY

#include "saport.h"

//
// Global Defines
//

#define DISPLAY_COLUMNS             (128)
#define DISPLAY_PAGES               (8)
#define DISPLAY_WIDTH               (128)
#define DISPLAY_HEIGHT              (64)
#define DISPLAY_LINES_PER_PAGE      (8)
#define MAX_BITMAP_SIZE             ((DISPLAY_COLUMNS * DISPLAY_PAGES * DISPLAY_LINES_PER_PAGE)/8)



typedef struct _DEVICE_EXTENSION {
    PUCHAR      VideoMemBase;
} DEVICE_EXTENSION, *PDEVICE_EXTENSION;


#define GetDisplayPage(_base) \
    READ_REGISTER_UCHAR( (*(PUCHAR)((PUCHAR)_base + 0) & 0xf) )

#define SetDisplayPage(_base,_pg) \
    WRITE_REGISTER_UCHAR( (PUCHAR)((PUCHAR)_base + 0), (_pg & 0xf) )

#define GetDisplayColumnAddressUpper(_base) \
    READ_REGISTER_UCHAR( (*(PUCHAR)((PUCHAR)_base + 2) & 0xf) )

#define GetDisplayColumnAddressLower(_base) \
    READ_REGISTER_UCHAR( (*(PUCHAR)((PUCHAR)_base + 3) & 0xf) )

#define GetDisplayColumnAddress(_base) \
    ((GetDisplayColumnAddressUpper(_base) << 4) | GetDisplayColumnAddressLower(_base))

#define SetDisplayColumnAddressUpper(_base,_colu) \
    WRITE_REGISTER_UCHAR( (PUCHAR)((PUCHAR)_base + 2), ((_colu) & 0xf) )

#define SetDisplayColumnAddressLower(_base,_coll) \
    WRITE_REGISTER_UCHAR( (PUCHAR)((PUCHAR)_base + 3), ((_coll) & 0xf) )

#define SetDisplayColumnAddress(_base,_col) \
    { \
        SetDisplayColumnAddressUpper(_base,(_col&0xf0)>>4); \
        SetDisplayColumnAddressLower(_base,(_col&0xf)); \
    }

#define GetDisplayStatus(_base) \
    READ_REGISTER_UCHAR( (*(PUCHAR)((PUCHAR)_base + 6)) )

#define GetDisplayData(_base) \
    READ_REGISTER_UCHAR( (*(PUCHAR)((PUCHAR)_base + 7)) )

#define SetDisplayData(_base,_data) \
    WRITE_REGISTER_UCHAR( (PUCHAR)((PUCHAR)_base + 7), (_data) )


//
// prototypes
//

extern "C" {

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

} // extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serveravailability\saport\watchdog.h ===
/*++

Copyright (c) 1991 - 2001 Microsoft Corporation

Module Name:

    ##  #  ##   ###   ######  ####  ##   ## #####    #####   ####     ##   ##
    ## ### ##   ###     ##   ##   # ##   ## ##  ##  ##   ## ##   #    ##   ##
    ## ### ##  ## ##    ##   ##     ##   ## ##   ## ##   ## ##        ##   ##
    ## # # ##  ## ##    ##   ##     ####### ##   ## ##   ## ## ###    #######
     ### ###  #######   ##   ##     ##   ## ##   ## ##   ## ##  ##    ##   ##
     ### ###  ##   ##   ##   ##   # ##   ## ##  ##  ##   ## ##  ## ## ##   ##
     ##   ##  ##   ##   ##    ####  ##   ## #####    #####   ##### ## ##   ##

Abstract:

    This header file contains all the global
    definitions for the watchdog timer device.

Author:

    Wesley Witt (wesw) 1-Oct-2001

Environment:

    Kernel mode only.

Notes:


--*/


#define WATCHDOG_PING_SECONDS   (30)
#define WATCHDOG_TIMER_VALUE    (120)
#define WATCHDOG_INIT_SECONDS   (10)

typedef struct _WATCHDOG_DEVICE_EXTENSION : _DEVICE_EXTENSION {
    FAST_MUTEX      DeviceLock;
    LONG            ActiveProcessCount;
    LARGE_INTEGER   LastProcessTime;
    KEVENT          PingEvent;
    KEVENT          StopEvent;
} WATCHDOG_DEVICE_EXTENSION, *PWATCHDOG_DEVICE_EXTENSION;

typedef struct _WATCHDOG_PROCESS_WATCH {
    PWATCHDOG_DEVICE_EXTENSION  DeviceExtension;
    HANDLE                      ProcessId;
} WATCHDOG_PROCESS_WATCH, *PWATCHDOG_PROCESS_WATCH;


NTSTATUS
SaWatchdogIoValidation(
    IN PWATCHDOG_DEVICE_EXTENSION DeviceExtension,
    IN PIRP Irp,
    PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
SaWatchdogDeviceInitialization(
    IN PSAPORT_DRIVER_EXTENSION DriverExtension
    );

NTSTATUS
SaWatchdogShutdownNotification(
    IN PWATCHDOG_DEVICE_EXTENSION DeviceExtension,
    IN PIRP Irp,
    PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
SaWatchdogStartDevice(
    IN PWATCHDOG_DEVICE_EXTENSION DeviceExtension
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serveravailability\serverworks\display\swdisp.cpp ===
/*++

Copyright (c) 1991 - 2001 Microsoft Corporation

Module Name:

     ###  ##  #  ## #####   ####  ###  #####      ####  #####  #####
    ##  # ## ### ## ##  ##   ##  ##  # ##  ##    ##   # ##  ## ##  ##
    ###   ## ### ## ##   ##  ##  ###   ##  ##    ##     ##  ## ##  ##
     ###  ## # # ## ##   ##  ##   ###  ##  ##    ##     ##  ## ##  ##
      ###  ### ###  ##   ##  ##    ### #####     ##     #####  #####
    #  ##  ### ###  ##  ##   ##  #  ## ##     ## ##   # ##     ##
     ###   ##   ##  #####   ####  ###  ##     ##  ####  ##     ##

Abstract:

    This module contains the entire implementation of
    the local display miniport for the ServerWorks
    CSB5 server chip set.

Author:

    Wesley Witt (wesw) 1-Oct-2001

Environment:

    Kernel mode only.

Notes:

--*/

#include "swdisp.h"


#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,DriverEntry)
#endif



NTSTATUS
SaDispHwInitialize(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID DeviceExtensionIn,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR PartialResources,
    IN ULONG PartialResourceCount
    )

/*++

Routine Description:

    This routine is the driver's entry point, called by the I/O system
    to load the driver.  The driver's entry points are initialized and
    a mutex to control paging is initialized.

    In DBG mode, this routine also examines the registry for special
    debug parameters.

Arguments:
    DeviceObject            - Miniport's device object
    Irp                     - Current IRP in progress
    DeviceExtensionIn       - Miniport's device extension
    PartialResources        - List of resources that are assigned to the miniport
    PartialResourceCount    - Number of assigned resources

Return Value:

    NT status code

--*/

{
    ULONG i;
    PDEVICE_EXTENSION DeviceExtension = (PDEVICE_EXTENSION) DeviceExtensionIn;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR Resource = NULL;


    for (i=0; i<PartialResourceCount; i++) {
        if (PartialResources[i].Type == CmResourceTypeMemory) {
            Resource = &PartialResources[i];
            break;
        }
    }

    if (Resource == NULL) {
        REPORT_ERROR( SA_DEVICE_DISPLAY, "Missing memory resource", STATUS_UNSUCCESSFUL );
        return STATUS_UNSUCCESSFUL;
    }

    DeviceExtension->VideoMemBase = (PUCHAR) SaPortGetVirtualAddress(
        DeviceExtension,
        Resource->u.Memory.Start,
        Resource->u.Memory.Length
        );
    if (DeviceExtension->VideoMemBase == NULL) {
        REPORT_ERROR( SA_DEVICE_DISPLAY, "SaPortGetVirtualAddress failed", STATUS_NO_MEMORY );
        return STATUS_NO_MEMORY;
    }

    return STATUS_SUCCESS;
}


NTSTATUS
SaDispDeviceIoctl(
    IN PVOID DeviceExtension,
    IN PIRP Irp,
    IN PVOID FsContext,
    IN ULONG FunctionCode,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength,
    IN PVOID OutputBuffer,
    IN ULONG OutputBufferLength
    )

/*++

Routine Description:

   This routine processes the device control requests for the
   local display miniport.

Arguments:

   DeviceExtension      - Miniport's device extension
   FunctionCode         - Device control function code
   InputBuffer          - Pointer to the user's input buffer
   InputBufferLength    - Length in bytes of the input buffer
   OutputBuffer         - Pointer to the user's output buffer
   OutputBufferLength   - Length in bytes of the output buffer

Return Value:

   NT status code.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PSA_DISPLAY_CAPS DeviceCaps;


    switch (FunctionCode) {
        case FUNC_SA_GET_VERSION:
            *((PULONG)OutputBuffer) = SA_INTERFACE_VERSION;
            break;

        case FUNC_SA_GET_CAPABILITIES:
            DeviceCaps = (PSA_DISPLAY_CAPS)OutputBuffer;
            DeviceCaps->SizeOfStruct = sizeof(SA_DISPLAY_CAPS);
            DeviceCaps->DisplayType = SA_DISPLAY_TYPE_BIT_MAPPED_LCD;
            DeviceCaps->CharacterSet = SA_DISPLAY_CHAR_ASCII;
            DeviceCaps->DisplayHeight = DISPLAY_HEIGHT;
            DeviceCaps->DisplayWidth = DISPLAY_WIDTH;
            break;

        default:
            Status = STATUS_NOT_SUPPORTED;
            REPORT_ERROR( SA_DEVICE_DISPLAY, "Unsupported device control", Status );
            break;
    }

    return Status;
}


UCHAR TestMask[128] =
{
    0x80,0x40,0x20,0x10,0x08,0x04,0x02,0x01,0x80,0x40,0x20,0x10,0x08,0x04,0x02,0x01,
    0x80,0x40,0x20,0x10,0x08,0x04,0x02,0x01,0x80,0x40,0x20,0x10,0x08,0x04,0x02,0x01,
    0x80,0x40,0x20,0x10,0x08,0x04,0x02,0x01,0x80,0x40,0x20,0x10,0x08,0x04,0x02,0x01,
    0x80,0x40,0x20,0x10,0x08,0x04,0x02,0x01,0x80,0x40,0x20,0x10,0x08,0x04,0x02,0x01,
    0x80,0x40,0x20,0x10,0x08,0x04,0x02,0x01,0x80,0x40,0x20,0x10,0x08,0x04,0x02,0x01,
    0x80,0x40,0x20,0x10,0x08,0x04,0x02,0x01,0x80,0x40,0x20,0x10,0x08,0x04,0x02,0x01,
    0x80,0x40,0x20,0x10,0x08,0x04,0x02,0x01,0x80,0x40,0x20,0x10,0x08,0x04,0x02,0x01,
    0x80,0x40,0x20,0x10,0x08,0x04,0x02,0x01,0x80,0x40,0x20,0x10,0x08,0x04,0x02,0x01
};


ULONG
TransformBitmap(
    PUCHAR Bits,
    ULONG Width,
    ULONG Height,
    PUCHAR NewBits
    )

/*++

Routine Description:

    The TransformBitmap() function morphs the input bitmap from a
    normal bitmap that has it's pixel bits organized as sequential
    bits starting from coord (0,0) through (n,n).  The bits are
    in a stream that proceed from column to column and row to row.
    The transformation accomplished by this function changes the bitmap
    into one that has it's bits organized in pages, lines, and columns.

    Each page is a unit of 8 lines and is organized as follows:

             ---------------------------------------------------------
             |Columns
             ---------------------------------------------------------
             | 1| 2| 3| 4| 5| 6| 7| 8| 9|10|11|12|13|14|15|16| ...128
             ---------------------------------------------------------
    Line #1  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  | ...
             |--------------------------------------------------------
    Line #2  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  | ...
             |--------------------------------------------------------
    Line #3  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  | ...
             |--------------------------------------------------------
    Line #4  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  | ...
             |--------------------------------------------------------
    Line #5  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  | ...
             |--------------------------------------------------------
    Line #6  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  | ...
             |--------------------------------------------------------
    Line #7  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  | ...
             |--------------------------------------------------------
    Line #8  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  | ...
             |--------------------------------------------------------

    The bytes that comprise the bitmap correspond to the columns in the
    page, so there are 128 bytes per page.  If the first byte of the
    transformed bitmap is 0x46 then the pixels in column 1 of lines 2,6,&7
    are illuminated by the display.

Arguments:

   Bits         - Input bits that are to be transformed
   Width        - Width of the bitmap in pixels
   Height       - Height of the bitmap in pixels
   NewBits      - Buffer to hold the newly transformed bitmap

Return Value:

   NT status code.

--*/

{
    ULONG i,j,k,line,idx,mask,coli;
    UCHAR byte;
    ULONG padBytes;
    ULONG byteWidth;
    ULONG NewSize = 0;


    //
    // Compute the pad bytes.  It is assumed
    // that the data width of the input bitmap
    // is dword aliged long.
    //

    if (((Width % 32) == 0) || ((Width % 32) > 24)) {
        padBytes = 0;
    } else if ((Width % 32) <= 8) {
        padBytes = 3;
    } else if ((Width % 32) <= 16) {
        padBytes = 2;
    } else {
        padBytes = 1;
    }

    //
    // Compute the realy byte width
    // based on the pad bytes.
    //

    byteWidth = (Width / 8) + padBytes;
    if (Width % 8) {
        byteWidth += 1;
    }

    //
    // Loop through the input bitmap and
    // create a new, morphed bitmap.
    //

    for (i=0; i<DISPLAY_PAGES; i++) {

        //
        // starting line number for this page
        //
        line = i * DISPLAY_LINES_PER_PAGE;

        //
        // This handles the case where the
        // input bitmap is not as tall as the display.
        //

        if (line >= Height) {
            break;
        }

        //
        // loop over the bits for this column
        //

        for (j=0; j<Width; j++) {

            //
            // Reset the new byte value to a zero state
            //

            byte = 0;

            //
            // Compute the column index as the
            // current column number divided by 8 (width of a byte)
            //

            coli = j >> 3;

            //
            // Compute the mask that is used to test the
            // bit in the input bitmap.
            //

            mask = TestMask[j];

            //
            // Process the bits in all this pages's lines
            // for the current column.
            //

            for (k=0; k<DISPLAY_LINES_PER_PAGE; k++) {

                if ((k + line) >= Height) {
                    break;
                }

                //
                // index the byte that contains this pixel
                //

                idx = (((k + line) * byteWidth)) + coli;

                //
                // set the bit
                //

                if (Bits[idx] & mask) {
                    byte = byte | (1 << k);
                }
            }

            //
            // Save the new byte in the bitmap
            //

            *NewBits = byte;
            NewBits += 1;
            NewSize += 1;
        }
    }

    return NewSize;
}


NTSTATUS
SaDispWrite(
    IN PVOID DeviceExtensionIn,
    IN PIRP Irp,
    IN PVOID FsContext,
    IN LONGLONG StartingOffset,
    IN PVOID DataBuffer,
    IN ULONG DataBufferLength
    )

/*++

Routine Description:

   This routine processes the write request for the local display miniport.

Arguments:

   DeviceExtensionIn    - Miniport's device extension
   StartingOffset       - Starting offset for the I/O
   DataBuffer           - Pointer to the data buffer
   DataBufferLength     - Length of the data buffer in bytes

Return Value:

   NT status code.

--*/

{
    NTSTATUS Status;
    PDEVICE_EXTENSION DeviceExtension = (PDEVICE_EXTENSION) DeviceExtensionIn;
    PSA_DISPLAY_SHOW_MESSAGE SaDisplay = (PSA_DISPLAY_SHOW_MESSAGE)DataBuffer;
    UCHAR i,j;
    PUCHAR NewBits = NULL;
    PUCHAR byte;
    ULONG Pages;
    ULONG NewSize;


    UNREFERENCED_PARAMETER(StartingOffset);

    if (SaDisplay->Width > DISPLAY_WIDTH || SaDisplay->Height > DISPLAY_HEIGHT) {
        REPORT_ERROR( SA_DEVICE_DISPLAY, "Bitmap size is too large\n", STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    NewBits = (PUCHAR) SaPortAllocatePool( DeviceExtension, MAX_BITMAP_SIZE );
    if (NewBits == NULL) {
        REPORT_ERROR( SA_DEVICE_DISPLAY, "Failed to allocate pool\n", MAX_BITMAP_SIZE );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory( NewBits, MAX_BITMAP_SIZE );

    NewSize = TransformBitmap(
        SaDisplay->Bits,
        SaDisplay->Width,
        SaDisplay->Height,
        NewBits
        );
    if (NewSize == 0) {
        SaPortFreePool( DeviceExtension, NewBits );
        REPORT_ERROR( SA_DEVICE_DISPLAY, "Failed to transform the bitmap\n", STATUS_UNSUCCESSFUL );
        return STATUS_UNSUCCESSFUL;
    }

    Pages = SaDisplay->Height / DISPLAY_LINES_PER_PAGE;
    if (SaDisplay->Height % DISPLAY_LINES_PER_PAGE) {
        Pages += 1;
    }

    for (i=0,byte=NewBits; i<Pages; i++) {
        SetDisplayPage( DeviceExtension->VideoMemBase, i );
        for (j=0; j<SaDisplay->Width; j++) {
            SetDisplayColumnAddress( DeviceExtension->VideoMemBase, j );
            SetDisplayData( DeviceExtension->VideoMemBase, *byte );
            byte += 1;
        }
    }

    SaPortFreePool( DeviceExtension, NewBits );

    return STATUS_SUCCESS;
}


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This routine is the driver's entry point, called by the I/O system
    to load the driver.  The driver's entry points are initialized and
    a mutex to control paging is initialized.

    In DBG mode, this routine also examines the registry for special
    debug parameters.

Arguments:

    DriverObject - a pointer to the object that represents this device
                   driver.

    RegistryPath - a pointer to this driver's key in the Services tree.

Return Value:

    STATUS_SUCCESS

--*/

{
    NTSTATUS Status;
    SAPORT_INITIALIZATION_DATA SaPortInitData;


    RtlZeroMemory( &SaPortInitData, sizeof(SAPORT_INITIALIZATION_DATA) );

    SaPortInitData.StructSize = sizeof(SAPORT_INITIALIZATION_DATA);
    SaPortInitData.DeviceType = SA_DEVICE_DISPLAY;
    SaPortInitData.HwInitialize = SaDispHwInitialize;
    SaPortInitData.Write = SaDispWrite;
    SaPortInitData.DeviceIoctl = SaDispDeviceIoctl;

    SaPortInitData.DeviceExtensionSize = sizeof(DEVICE_EXTENSION);

    Status = SaPortInitialize( DriverObject, RegistryPath, &SaPortInitData );
    if (!NT_SUCCESS(Status)) {
        REPORT_ERROR( SA_DEVICE_DISPLAY, "SaPortInitialize failed\n", Status );
        return Status;
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serveravailability\serverworks\keypad\swkeypad.h ===
/*++

Copyright (c) 1991 - 2001 Microsoft Corporation

Module Name:

     ###  ##  #  ## ##  ## ##### ##  ## #####    ###   #####      ##   ##
    ##  # ## ### ## ## ##  ##    ##  ## ##  ##   ###   ##  ##     ##   ##
    ###   ## ### ## ####   ##     ####  ##  ##  ## ##  ##   ##    ##   ##
     ###  ## # # ## ###    #####  ####  ##  ##  ## ##  ##   ##    #######
      ###  ### ###  ####   ##      ##   #####  ####### ##   ##    ##   ##
    #  ##  ### ###  ## ##  ##      ##   ##     ##   ## ##  ##  ## ##   ##
     ###   ##   ##  ##  ## #####   ##   ##     ##   ## #####   ## ##   ##

Abstract:

    The module is the header file for the ServerWorks
    keypad miniport device driver.

Author:

    Wesley Witt (wesw) 1-Oct-2001

Environment:

    Kernel mode only.

Notes:


--*/

extern "C" {
#include <ntddk.h>
#include <stdio.h>
}

#define MINIPORT_DEVICE_TYPE    SA_DEVICE_KEYPAD

#include "saport.h"



#define MAX_KEY_BUFF_SIZE               32

#define KEYPAD_DATA_PRESSED             0x80
#define KEYPAD_DATA_INTERRUPT_ENABLE    0x40

#define KEYPAD_DATA_ENTER               0x20
#define KEYPAD_DATA_ESCAPE              0x10
#define KEYPAD_DATA_RIGHT               0x08
#define KEYPAD_DATA_LEFT                0x04
#define KEYPAD_DATA_DOWN                0x02
#define KEYPAD_DATA_UP                  0x01

#define KEYPAD_ALL_KEYS                 (KEYPAD_DATA_ENTER|KEYPAD_DATA_ESCAPE|KEYPAD_DATA_RIGHT|KEYPAD_DATA_LEFT|KEYPAD_DATA_DOWN|KEYPAD_DATA_UP)


typedef struct _DEVICE_EXTENSION {
    PUCHAR              PortAddress;
    PUCHAR              DataBuffer;
    UCHAR               Keypress;
    KSPIN_LOCK          KeypadLock;
} DEVICE_EXTENSION, *PDEVICE_EXTENSION;


//
// prototypes
//

extern "C" {

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

} // extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serveravailability\serverworks\keypad\swkeypad.cpp ===
/*++

Copyright (c) 1991 - 2001 Microsoft Corporation

Module Name:

     ###  ##  #  ## ##  ## ##### ##  ## #####    ###   #####       ####  #####  #####
    ##  # ## ### ## ## ##  ##    ##  ## ##  ##   ###   ##  ##     ##   # ##  ## ##  ##
    ###   ## ### ## ####   ##     ####  ##  ##  ## ##  ##   ##    ##     ##  ## ##  ##
     ###  ## # # ## ###    #####  ####  ##  ##  ## ##  ##   ##    ##     ##  ## ##  ##
      ###  ### ###  ####   ##      ##   #####  ####### ##   ##    ##     #####  #####
    #  ##  ### ###  ## ##  ##      ##   ##     ##   ## ##  ##  ## ##   # ##     ##
     ###   ##   ##  ##  ## #####   ##   ##     ##   ## #####   ##  ####  ##     ##

Abstract:

    This module contains the entire implementation of
    the keypad miniport for the ServerWorks
    CSB5 server chip set.

Author:

    Wesley Witt (wesw) 1-Oct-2001

Environment:

    Kernel mode only.

Notes:


--*/

#include "swkeypad.h"

#define CLEARBITS(_val,_mask)  ((_val) &= ~(_mask))
#define SETBITS(_val,_mask)  ((_val) |= (_mask))


#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,DriverEntry)
#endif



BOOLEAN
SaKeypadInterruptService(
    IN PKINTERRUPT InterruptObject,
    IN PVOID ServiceContext
    )

/*++

Routine Description:

    This function is the device's interrupt service routine and
    is called by the OS to service the interrupt.  The interrupt
    spin lock is held so work here is kept to a minimum.

Arguments:

    InterruptObject - Pointer to an interrupt object.

    DeviceExtension - Pointer to the mini-port's device extension

Context:

    IRQL: DIRQL, arbitrary thread context

Return Value:

    A value of TRUE is returned if the interrupt is serviced by
    this function.  Otherwise a value of FALSE is returned.

--*/

{
    PDEVICE_EXTENSION DeviceExtension = (PDEVICE_EXTENSION) ServiceContext;
    UCHAR KeyChar;


    //
    // Fetch the character from the keypad device
    //

    KeyChar = READ_PORT_UCHAR( DeviceExtension->PortAddress );

    //
    // Check to see if this is our interrupt
    //

    if (((KeyChar & KEYPAD_DATA_PRESSED) == 0) || ((KeyChar & KEYPAD_ALL_KEYS) == 0)) {
        DebugPrint(( SA_DEVICE_KEYPAD, SAPORT_DEBUG_INFO_LEVEL, "Interrupt: passing on [%02x]\n", KeyChar ));
        return FALSE;
    }

    DebugPrint(( SA_DEVICE_KEYPAD, SAPORT_DEBUG_INFO_LEVEL, "Interrupt: processing [%02x]\n", KeyChar ));

    SETBITS( KeyChar, KEYPAD_DATA_PRESSED );
    WRITE_PORT_UCHAR( DeviceExtension->PortAddress, KeyChar );

    //
    // Queue a DPC to process the key press
    //

    SaPortRequestDpc( DeviceExtension, (PVOID)KeyChar );

    //
    // return success
    //

    return TRUE;
}


VOID
SaKeypadDpcRoutine(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    This function is the device's DPC-for-ISR function.  It is called
    only by the ISR function and it's only function is to start the
    next I/O.

Arguments:

    DeviceObject - Pointer to the target device object.
    DeviceExtension - Pointer to the mini-port's device extension.
    Context - Mini-port supplied context pointer.

Context:

    IRQL: DISPATCH_LEVEL, DPC context

Return Value:

    None.

--*/

{
    PDEVICE_EXTENSION DeviceExtension = (PDEVICE_EXTENSION) Irp;
    KIRQL  OldIrql;


    KeAcquireSpinLock( &DeviceExtension->KeypadLock, &OldIrql );
    if (DeviceExtension->DataBuffer) {
        DeviceExtension->Keypress = (UCHAR)Context;
        DeviceExtension->DataBuffer[0] = DeviceExtension->Keypress & KEYPAD_ALL_KEYS;
        DeviceExtension->DataBuffer = NULL;
        SaPortCompleteRequest( DeviceExtension, NULL, sizeof(UCHAR), STATUS_SUCCESS, TRUE );
        DeviceExtension->Keypress = 0;
    }
    KeReleaseSpinLock( &DeviceExtension->KeypadLock, OldIrql );
}


VOID
SaKeypadCancelRoutine(
    IN PVOID DeviceExtensionIn,
    IN PIRP Irp,
    IN BOOLEAN CurrentIo
    )

/*++

Routine Description:

    This function is the miniport's IRP cancel routine.

Arguments:

    DeviceExtension - Pointer to the mini-port's device extension.
    CurrentIo       - TRUE if this is called for the current I/O

Return Value:

    None.

--*/

{
    PDEVICE_EXTENSION DeviceExtension = (PDEVICE_EXTENSION)DeviceExtensionIn;
    KIRQL  OldIrql;


    if (CurrentIo) {
        KeAcquireSpinLock( &DeviceExtension->KeypadLock, &OldIrql );
        DeviceExtension->Keypress = 0;
        DeviceExtension->DataBuffer = NULL;
        KeReleaseSpinLock( &DeviceExtension->KeypadLock, OldIrql );
    }
}


NTSTATUS
SaKeypadRead(
    IN PVOID DeviceExtensionIn,
    IN PIRP Irp,
    IN PVOID FsContext,
    IN LONGLONG StartingOffset,
    IN PVOID DataBuffer,
    IN ULONG DataBufferLength
    )

/*++

Routine Description:

   This routine processes the read requests for the local display miniport.

Arguments:

   DeviceExtensionIn    - Miniport's device extension
   StartingOffset       - Starting offset for the I/O
   DataBuffer           - Pointer to the data buffer
   DataBufferLength     - Length of the data buffer in bytes

Return Value:

   NT status code.

--*/

{
    PDEVICE_EXTENSION DeviceExtension = (PDEVICE_EXTENSION)DeviceExtensionIn;
    KIRQL  OldIrql;


    if (DeviceExtension->Keypress) {
        *((PUCHAR)DataBuffer) = DeviceExtension->Keypress;
        return STATUS_SUCCESS;
    }
    DeviceExtension->DataBuffer = (PUCHAR) DataBuffer;
    return STATUS_PENDING;
}


NTSTATUS
SaKeypadDeviceIoctl(
    IN PVOID DeviceExtension,
    IN PIRP Irp,
    IN PVOID FsContext,
    IN ULONG FunctionCode,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength,
    IN PVOID OutputBuffer,
    IN ULONG OutputBufferLength
    )

/*++

Routine Description:

    This function is called by the SAPORT driver so that
    the mini-port driver can service an IOCTL call.

Arguments:

    DeviceExtension     - A pointer to the mini-port's device extension
    FunctionCode        - The IOCTL function code
    InputBuffer         - Pointer to the input buffer, contains the data sent down by the I/O
    InputBufferLength   - Length in bytes of the InputBuffer
    OutputBuffer        - Pointer to the output buffer, contains the data generated by this call
    OutputBufferLength  - Length in bytes of the OutputBuffer

Context:

    IRQL: IRQL PASSIVE_LEVEL, arbitrary thread context

Return Value:

    If the function succeeds, it must return STATUS_SUCCESS.
    Otherwise, it must return one of the error status values defined in ntstatus.h.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;


    switch (FunctionCode) {
        case FUNC_SA_GET_VERSION:
            *((PULONG)OutputBuffer) = SA_INTERFACE_VERSION;
            break;

        default:
            Status = STATUS_NOT_SUPPORTED;
            REPORT_ERROR( SA_DEVICE_KEYPAD, "Unsupported device control", Status );
            break;
    }

    return Status;
}


NTSTATUS
SaKeypadHwInitialize(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID DeviceExtensionIn,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR PartialResources,
    IN ULONG PartialResourceCount
    )

/*++

Routine Description:

    This function is called by the SAPORT driver so that
    the mini-port driver can initialize it's hardware
    resources.

Arguments:

    DeviceObject            - Pointer to the target device object.
    Irp                     - Pointer to an IRP structure that describes the requested I/O operation.
    DeviceExtension         - A pointer to the mini-port's device extension.
    PartialResources        - Pointer to the translated resources alloacted by the system.
    PartialResourceCount    - The number of resources in the PartialResources array.

Context:

    IRQL: IRQL PASSIVE_LEVEL, system thread context

Return Value:

    If the function succeeds, it must return STATUS_SUCCESS.
    Otherwise, it must return one of the error status values defined in ntstatus.h.

--*/

{
    PDEVICE_EXTENSION DeviceExtension = (PDEVICE_EXTENSION) DeviceExtensionIn;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR ResourcePort = NULL;
    NTSTATUS Status;
    ULONG i;


    for (i=0; i<PartialResourceCount; i++) {
        if (PartialResources[i].Type == CmResourceTypePort) {
            ResourcePort = &PartialResources[i];
        }
    }
    if (ResourcePort == NULL) {
        REPORT_ERROR( SA_DEVICE_KEYPAD, "Missing port resource", STATUS_UNSUCCESSFUL );
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Setup the I/O port address
    //

    DeviceExtension->PortAddress = (PUCHAR) ResourcePort->u.Port.Start.QuadPart;
    KeInitializeSpinLock( &DeviceExtension->KeypadLock );

    //
    // Enable interrupts on the hardware
    //

    WRITE_PORT_UCHAR( DeviceExtension->PortAddress, KEYPAD_DATA_INTERRUPT_ENABLE );

    return STATUS_SUCCESS;
}


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This routine is the driver's entry point, called by the I/O system
    to load the driver.  The driver's entry points are initialized and
    a mutex to control paging is initialized.

    In DBG mode, this routine also examines the registry for special
    debug parameters.

Arguments:

    DriverObject - a pointer to the object that represents this device driver.
    RegistryPath - a pointer to this driver's key in the Services tree.

Return Value:

    STATUS_SUCCESS

--*/

{
    NTSTATUS Status;
    SAPORT_INITIALIZATION_DATA SaPortInitData;


    RtlZeroMemory( &SaPortInitData, sizeof(SAPORT_INITIALIZATION_DATA) );

    SaPortInitData.StructSize = sizeof(SAPORT_INITIALIZATION_DATA);
    SaPortInitData.DeviceType = SA_DEVICE_KEYPAD;
    SaPortInitData.HwInitialize = SaKeypadHwInitialize;
    SaPortInitData.DeviceIoctl = SaKeypadDeviceIoctl;
    SaPortInitData.Read = SaKeypadRead;
    SaPortInitData.CancelRoutine = SaKeypadCancelRoutine;
    SaPortInitData.InterruptServiceRoutine = SaKeypadInterruptService;
    SaPortInitData.IsrForDpcRoutine = SaKeypadDpcRoutine;

    SaPortInitData.DeviceExtensionSize = sizeof(DEVICE_EXTENSION);

    Status = SaPortInitialize( DriverObject, RegistryPath, &SaPortInitData );
    if (!NT_SUCCESS(Status)) {
        REPORT_ERROR( SA_DEVICE_KEYPAD, "SaPortInitialize failed\n", Status );
        return Status;
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serveravailability\serverworks\nvram\swnvram.h ===
/*++

Copyright (c) 1991 - 2001 Microsoft Corporation

Module Name:

     ###  ##  #  ## ##   # ##  ## #####    ###   ##    ##    ##   ##
    ##  # ## ### ## ###  # ##  ## ##  ##   ###   ###  ###    ##   ##
    ###   ## ### ## #### # ##  ## ##  ##  ## ##  ########    ##   ##
     ###  ## # # ## # ####  ####  #####   ## ##  # ### ##    #######
      ###  ### ###  #  ###  ####  ####   ####### #  #  ##    ##   ##
    #  ##  ### ###  #   ##   ##   ## ##  ##   ## #     ## ## ##   ##
     ###   ##   ##  #    #   ##   ##  ## ##   ## #     ## ## ##   ##

Abstract:

    This header file contains the definitions for the
    ServerWorks NVRAM miniport driver.

Author:

    Wesley Witt (wesw) 1-Oct-2001

Environment:

    Kernel mode only.

Notes:


--*/

extern "C" {
#include <ntddk.h>
#include <stdio.h>
}


#define MINIPORT_DEVICE_TYPE    SA_DEVICE_NVRAM

#include "saport.h"


//
// Control Register Bits
//

#define NVRAM_CONTROL_INTERRUPT_ENABLE      0x0200
#define NVRAM_CONTROL_DONE                  0x0100
#define NVRAM_CONTROL_BUSY                  0x0080
#define NVRAM_CONTROL_FUNCTION_CODE         0x0060
#define NVRAM_CONTROL_ADDRESS               0x001F

#define NVRAM_CONTROL_FUNCTION_WRITE        0x0020
#define NVRAM_CONTROL_FUNCTION_READ         0x0040

#define MAX_NVRAM_SIZE  (32)


typedef struct _DEVICE_EXTENSION {
    PUCHAR          NvramMemBase;        // Memory mapped register base address
    PULONG          IoBuffer;            // Buffer passed in StartIo
    ULONG           IoLength;            // Length of IoBuffer in dwords
    ULONG           IoOffset;            // Starting offset for the I/O in dwords
    ULONG           IoFunction;          // Function code; IRP_MJ_WRITE, IRP_MJ_READ
    ULONG           IoIndex;             // Current index info IoBuffer
    ULONG           CompletedIoSize;     //
} DEVICE_EXTENSION, *PDEVICE_EXTENSION;


//
// prototypes
//

extern "C" {

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

} // extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serveravailability\serverworks\nvram\swnvram.cpp ===
/*++

Copyright (c) 1991 - 2001 Microsoft Corporation

Module Name:

     ###  ##  #  ## ##   # ##  ## #####    ###   ##    ##     ####  #####  #####
    ##  # ## ### ## ###  # ##  ## ##  ##   ###   ###  ###    ##   # ##  ## ##  ##
    ###   ## ### ## #### # ##  ## ##  ##  ## ##  ########    ##     ##  ## ##  ##
     ###  ## # # ## # ####  ####  #####   ## ##  # ### ##    ##     ##  ## ##  ##
      ###  ### ###  #  ###  ####  ####   ####### #  #  ##    ##     #####  #####
    #  ##  ### ###  #   ##   ##   ## ##  ##   ## #     ## ## ##   # ##     ##
     ###   ##   ##  #    #   ##   ##  ## ##   ## #     ## ##  ####  ##     ##

Abstract:

    This module contains the entire implementation of
    the NVRAM miniport for the ServerWorks
    CSB5 server chip set.

Author:

    Wesley Witt (wesw) 1-Oct-2001

Environment:

    Kernel mode only.

Notes:

--*/

#include "swnvram.h"


#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,DriverEntry)
#endif

#define CLEARBITS(_val,_mask)  ((_val) &= ~(_mask))
#define SETBITS(_val,_mask)  ((_val) |= (_mask))



BOOLEAN
SaNvramStartNextIo(
    IN PDEVICE_EXTENSION DeviceExtension
    )

/*++

Routine Description:

    This function is called by the ISR and the StartIo functions.
    The purpose is to modify the device's hardware registers
    such that the next I/O is started on the device.

Arguments:

    DeviceExtension - A pointer to the mini-port's device extension

Context:

    IRQL: DISPATCH_LEVEL or DIRQL, arbitrary thread context

Return Value:

    A value of TRUE is returned if the I/O is started successfully.
    Otherwise a value of FALSE is returned.

--*/

{
    USHORT Control;


    //
    // This function executes at DIRQL and it synchronized
    // with the ISR.
    //

    //
    // Read the current value of the NVRAM address register
    //

    Control = READ_REGISTER_USHORT( (PUSHORT)DeviceExtension->NvramMemBase );

    if (Control & NVRAM_CONTROL_BUSY) {
        //
        // This should never happen, but the device us telling
        // us that it is busy.
        //

        return FALSE;
    }

    //
    // Setup the device for the I/O
    //

    //
    // Clear the Function code
    //

    CLEARBITS( Control, NVRAM_CONTROL_FUNCTION_CODE );

    switch (DeviceExtension->IoFunction) {
        case IRP_MJ_WRITE:
            //
            // Stuff the next dword into the data register
            //
            WRITE_REGISTER_ULONG(
                (PULONG)(DeviceExtension->NvramMemBase+4),
                DeviceExtension->IoBuffer[DeviceExtension->IoIndex]
                );

            //
            // Set the bit to indicate a write
            //
            SETBITS( Control, NVRAM_CONTROL_FUNCTION_WRITE );
            break;

        case IRP_MJ_READ:
            //
            // Set the bit to indicate a read
            //
            SETBITS( Control, NVRAM_CONTROL_FUNCTION_READ );
            break;

        default:
            return FALSE;
    }

    //
    // Clear the I/O address
    //

    CLEARBITS( Control, NVRAM_CONTROL_ADDRESS );

    //
    // Set the requested I/O address
    //

    Control = Control | (USHORT) (DeviceExtension->IoOffset + DeviceExtension->IoIndex);

    //
    // Write the new control value to the address register
    //

    WRITE_REGISTER_USHORT( (PUSHORT)DeviceExtension->NvramMemBase, Control );

    return TRUE;
}


BOOLEAN
SaNvramInterruptService(
    IN PKINTERRUPT InterruptObject,
    IN PVOID ServiceContext
    )

/*++

Routine Description:

    This function is the device's interrupt service routine and
    is called by the OS to service the interrupt.  The interrupt
    spin lock is held so work here is kept to a minimum.

Arguments:

    InterruptObject - Pointer to an interrupt object.
    DeviceExtension - Pointer to the mini-port's device extension

Context:

    IRQL: DIRQL, arbitrary thread context

Return Value:

    A value of TRUE is returned if the interrupt is serviced by
    this function.  Otherwise a value of FALSE is returned.

--*/

{
    PDEVICE_EXTENSION DeviceExtension = (PDEVICE_EXTENSION) ServiceContext;
    USHORT Control;


    //
    // First thing is to check the DONE bit in the NVRAM address register.
    // This bit indicates that the device has completed a previous
    // command request.  This tells the ISR that the interrupt was
    // likely generated by the NVRAM device.
    //

    Control = READ_REGISTER_USHORT( (PUSHORT)DeviceExtension->NvramMemBase );
    if ((Control & NVRAM_CONTROL_DONE) == 0) {
        return FALSE;
    }

    //
    // Now the interrupt must be stopped.
    // This is accomplished by setting the done
    // bit and clearing the function code.
    //

    CLEARBITS( Control, NVRAM_CONTROL_FUNCTION_CODE );
    SETBITS( Control, NVRAM_CONTROL_DONE );

    WRITE_REGISTER_USHORT( (PUSHORT)DeviceExtension->NvramMemBase, Control );

    //
    // Check to see if this is a bogus interrupt
    //

    if (DeviceExtension->IoIndex >= DeviceExtension->IoLength) {
        return FALSE;
    }

    //
    // Process the I/O
    //

    if (DeviceExtension->IoFunction == IRP_MJ_READ) {

        //
        // Fetch the double word value from the NVRAM data register
        //

        DeviceExtension->IoBuffer[DeviceExtension->IoIndex] = READ_REGISTER_ULONG( (PULONG)(DeviceExtension->NvramMemBase+4) );
    }

    DeviceExtension->IoIndex += 1;
    DeviceExtension->CompletedIoSize += sizeof(ULONG);

    if (DeviceExtension->IoIndex >= DeviceExtension->IoLength) {

        //
        // We're done so we need to have the DPC start the next I/O
        //
        SaPortRequestDpc( DeviceExtension, NULL );

    } else {

        //
        // More I/O necessary so request the device start the next I/O
        //

        if (!SaNvramStartNextIo( DeviceExtension )) {
            //
            // Something failed so be sure that the next I/O is started
            //
            SaPortRequestDpc( DeviceExtension, NULL );
        }

    }

    return TRUE;
}


NTSTATUS
SaNvramRead(
    IN PVOID DeviceExtensionIn,
    IN PIRP Irp,
    IN PVOID FsContext,
    IN LONGLONG StartingOffset,
    IN PVOID DataBuffer,
    IN ULONG DataBufferLength
    )

/*++

Routine Description:

   This routine processes the read requests for the local display miniport.

Arguments:

   DeviceExtensionIn    - Miniport's device extension
   StartingOffset       - Starting offset for the I/O
   DataBuffer           - Pointer to the data buffer
   DataBufferLength     - Length of the data buffer in bytes

Return Value:

   NT status code.

--*/

{
    PDEVICE_EXTENSION DeviceExtension = (PDEVICE_EXTENSION) DeviceExtensionIn;


    //
    // Validate the I/O parameters
    //

    if (((StartingOffset + DataBufferLength) / sizeof(ULONG)) > MAX_NVRAM_SIZE) {
        REPORT_ERROR( SA_DEVICE_NVRAM, "Starting offset is too large\n", STATUS_INVALID_PARAMETER_1 );
        return STATUS_INVALID_PARAMETER_1;
    }

    //
    // Save the I/O parameters
    //

    DeviceExtension->IoBuffer = (PULONG)DataBuffer;
    DeviceExtension->IoLength = DataBufferLength / sizeof(ULONG);
    DeviceExtension->IoFunction = IRP_MJ_READ;
    DeviceExtension->IoOffset = (ULONG) (StartingOffset / sizeof(ULONG));
    DeviceExtension->IoIndex = 0;
    DeviceExtension->CompletedIoSize = 0;

    //
    // Start the I/O

    if (!SaNvramStartNextIo( DeviceExtension )) {
        REPORT_ERROR( SA_DEVICE_NVRAM, "SaNvramStartNextIo failed\n", STATUS_UNSUCCESSFUL );
        return STATUS_UNSUCCESSFUL;
    }

    return STATUS_PENDING;
}


NTSTATUS
SaNvramWrite(
    IN PVOID DeviceExtensionIn,
    IN PIRP Irp,
    IN PVOID FsContext,
    IN LONGLONG StartingOffset,
    IN PVOID DataBuffer,
    IN ULONG DataBufferLength
    )

/*++

Routine Description:

   This routine processes the write requests for the local display miniport.

Arguments:

   DeviceExtensionIn    - Miniport's device extension
   StartingOffset       - Starting offset for the I/O
   DataBuffer           - Pointer to the data buffer
   DataBufferLength     - Length of the data buffer in bytes

Return Value:

   NT status code.

--*/

{
    PDEVICE_EXTENSION DeviceExtension = (PDEVICE_EXTENSION) DeviceExtensionIn;


    //
    // Validate the I/O parameters
    //

    if (((StartingOffset + DataBufferLength) / sizeof(ULONG)) > MAX_NVRAM_SIZE) {
        REPORT_ERROR( SA_DEVICE_NVRAM, "Starting offset is too large\n", STATUS_INVALID_PARAMETER_1 );
        return STATUS_INVALID_PARAMETER_1;
    }

    //
    // Save the I/O parameters
    //

    DeviceExtension->IoBuffer = (PULONG)DataBuffer;
    DeviceExtension->IoLength = DataBufferLength / sizeof(ULONG);
    DeviceExtension->IoFunction = IRP_MJ_WRITE;
    DeviceExtension->IoOffset = (ULONG) (StartingOffset / sizeof(ULONG));
    DeviceExtension->IoIndex = 0;
    DeviceExtension->CompletedIoSize = 0;

    //
    // Start the I/O

    if (!SaNvramStartNextIo( DeviceExtension )) {
        REPORT_ERROR( SA_DEVICE_NVRAM, "SaNvramStartNextIo failed\n", STATUS_UNSUCCESSFUL );
        return STATUS_UNSUCCESSFUL;
    }

    return STATUS_PENDING;
}


VOID
SaNvramDpcRoutine(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    This function is the device's DPC-for-ISR function.  It is called
    only by the ISR function and it's only function is to start the
    next I/O.

Arguments:

    DeviceObject    - Pointer to the target device object.
    DeviceExtension - Pointer to the mini-port's device extension.
    Context         - Mini-port supplied context pointer.

Context:

    IRQL: DISPATCH_LEVEL, DPC context

Return Value:

    None.

--*/

{
    PDEVICE_EXTENSION DeviceExtension = (PDEVICE_EXTENSION) Irp;
    NTSTATUS Status;


    //
    // Set the status based on the data
    // that was transfered.
    //

    if (DeviceExtension->CompletedIoSize == (DeviceExtension->IoIndex * sizeof(ULONG))) {
        Status = STATUS_SUCCESS;
    } else {
        Status = STATUS_UNEXPECTED_IO_ERROR;
    }

    //
    // Reset the current I/O paramaters to
    // prevent the ISR from reacting to a
    // bogus interrupt.
    //

    DeviceExtension->IoBuffer = NULL;
    DeviceExtension->IoLength = 0;
    DeviceExtension->IoFunction = 0;
    DeviceExtension->IoOffset = 0;
    DeviceExtension->IoIndex = 0;

    //
    // Complete this IRP and start the next
    // IRP is there is one in the queue
    //

    SaPortCompleteRequest(
        DeviceExtension,
        NULL,
        DeviceExtension->CompletedIoSize,
        Status,
        FALSE
        );
}


NTSTATUS
SaNvramDeviceIoctl(
    IN PVOID DeviceExtension,
    IN PIRP Irp,
    IN PVOID FsContext,
    IN ULONG FunctionCode,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength,
    IN PVOID OutputBuffer,
    IN ULONG OutputBufferLength
    )

/*++

Routine Description:

    This function is called by the SAPORT driver so that
    the mini-port driver can service an IOCTL call.

Arguments:

    DeviceExtension     - A pointer to the mini-port's device extension
    FunctionCode        - The IOCTL function code
    InputBuffer         - Pointer to the input buffer, contains the data sent down by the I/O
    InputBufferLength   - Length in bytes of the InputBuffer
    OutputBuffer        - Pointer to the output buffer, contains the data generated by this call
    OutputBufferLength  - Length in bytes of the OutputBuffer

Context:

    IRQL: IRQL PASSIVE_LEVEL, arbitrary thread context

Return Value:

    If the function succeeds, it must return STATUS_SUCCESS.
    Otherwise, it must return one of the error status values defined in ntstatus.h.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PSA_NVRAM_CAPS NvramCaps = NULL;


    switch (FunctionCode) {
        case FUNC_SA_GET_VERSION:
            *((PULONG)OutputBuffer) = SA_INTERFACE_VERSION;
            break;

        case FUNC_SA_GET_CAPABILITIES:
            NvramCaps = (PSA_NVRAM_CAPS)OutputBuffer;
            NvramCaps->SizeOfStruct = sizeof(SA_NVRAM_CAPS);
            NvramCaps->NvramSize = MAX_NVRAM_SIZE;
            break;

        default:
            Status = STATUS_NOT_SUPPORTED;
            REPORT_ERROR( SA_DEVICE_NVRAM, "Unsupported device control", Status );
            break;
    }

    return Status;
}


NTSTATUS
SaNvramHwInitialize(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID DeviceExtensionIn,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR PartialResources,
    IN ULONG PartialResourceCount
    )

/*++

Routine Description:

    This function is called by the SAPORT driver so that
    the mini-port driver can initialize it's hardware
    resources.

Arguments:

    DeviceObject            - Pointer to the target device object.
    Irp                     - Pointer to an IRP structure that describes the requested I/O operation.
    DeviceExtension         - A pointer to the mini-port's device extension.
    PartialResources        - Pointer to the translated resources alloacted by the system.
    PartialResourceCount    - The number of resources in the PartialResources array.

Context:

    IRQL: IRQL PASSIVE_LEVEL, system thread context

Return Value:

    If the function succeeds, it must return STATUS_SUCCESS.
    Otherwise, it must return one of the error status values defined in ntstatus.h.

--*/

{
    PDEVICE_EXTENSION DeviceExtension = (PDEVICE_EXTENSION) DeviceExtensionIn;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR ResourceMemory = NULL;
    ULONG i;


    for (i=0; i<PartialResourceCount; i++) {
        if (PartialResources[i].Type == CmResourceTypeMemory) {
            ResourceMemory = &PartialResources[i];
        }
    }

    if (ResourceMemory == NULL) {
        REPORT_ERROR( SA_DEVICE_NVRAM, "Missing memory resource", STATUS_UNSUCCESSFUL );
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Setup the memory base address
    //

    DeviceExtension->NvramMemBase = (PUCHAR) SaPortGetVirtualAddress(
        DeviceExtension,
        ResourceMemory->u.Memory.Start,
        ResourceMemory->u.Memory.Length
        );
    if (DeviceExtension->NvramMemBase == NULL) {
        REPORT_ERROR( SA_DEVICE_NVRAM, "SaPortGetVirtualAddress failed", STATUS_NO_MEMORY );
        return STATUS_NO_MEMORY;
    }

    //
    // Enable interrupts on the hardware
    //

    WRITE_REGISTER_USHORT( (PUSHORT)DeviceExtension->NvramMemBase, NVRAM_CONTROL_INTERRUPT_ENABLE );

    return STATUS_SUCCESS;
}


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This routine is the driver's entry point, called by the I/O system
    to load the driver.  The driver's entry points are initialized and
    a mutex to control paging is initialized.

    In DBG mode, this routine also examines the registry for special
    debug parameters.

Arguments:

    DriverObject - a pointer to the object that represents this device driver.
    RegistryPath - a pointer to this driver's key in the Services tree.

Return Value:

    STATUS_SUCCESS

--*/

{
    NTSTATUS Status;
    SAPORT_INITIALIZATION_DATA SaPortInitData;


    RtlZeroMemory( &SaPortInitData, sizeof(SAPORT_INITIALIZATION_DATA) );

    SaPortInitData.StructSize = sizeof(SAPORT_INITIALIZATION_DATA);
    SaPortInitData.DeviceType = SA_DEVICE_NVRAM;
    SaPortInitData.HwInitialize = SaNvramHwInitialize;
    SaPortInitData.DeviceIoctl = SaNvramDeviceIoctl;
    SaPortInitData.Read = SaNvramRead;
    SaPortInitData.Write = SaNvramWrite;
    SaPortInitData.InterruptServiceRoutine = SaNvramInterruptService;
    SaPortInitData.IsrForDpcRoutine = SaNvramDpcRoutine;

    SaPortInitData.DeviceExtensionSize = sizeof(DEVICE_EXTENSION);

    Status = SaPortInitialize( DriverObject, RegistryPath, &SaPortInitData );
    if (!NT_SUCCESS(Status)) {
        REPORT_ERROR( SA_DEVICE_NVRAM, "SaPortInitialize failed\n", Status );
        return Status;
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serveravailability\serverworks\watchdog\swwd.h ===
/*++

Copyright (c) 1991 - 2001 Microsoft Corporation

Module Name:

     ###  ##  #  ## ##  #  ## #####      ##   ##
    ##  # ## ### ## ## ### ## ##  ##     ##   ##
    ###   ## ### ## ## ### ## ##   ##    ##   ##
     ###  ## # # ## ## # # ## ##   ##    #######
      ###  ### ###   ### ###  ##   ##    ##   ##
    #  ##  ### ###   ### ###  ##  ##  ## ##   ##
     ###   ##   ##   ##   ##  #####   ## ##   ##

Abstract:

    This header file contains the definitions for the
    ServerWorks watchdog miniport driver.

Author:

    Wesley Witt (wesw) 1-Oct-2001

Environment:

    Kernel mode only.

Notes:


--*/

extern "C" {
#include <ntddk.h>
#include <stdio.h>
}


#define MINIPORT_DEVICE_TYPE    SA_DEVICE_WATCHDOG

#include "saport.h"

#define CLEARBITS(_val,_mask)  ((_val) &= ~(_mask))
#define SETBITS(_val,_mask)  ((_val) |= (_mask))

//
// Control Register Bits
//

#define WATCHDOG_CONTROL_TRIGGER            0x80
#define WATCHDOG_CONTROL_BIOS_JUMPER        0x08
#define WATCHDOG_CONTROL_TIMER_MODE         0x04
#define WATCHDOG_CONTROL_FIRED              0x02
#define WATCHDOG_CONTROL_ENABLE             0x01


typedef struct _DEVICE_EXTENSION {
    PUCHAR          WdMemBase;           // Memory mapped register base address
    FAST_MUTEX      WdIoLock;
} DEVICE_EXTENSION, *PDEVICE_EXTENSION;


//
// prototypes
//

extern "C" {

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

} // extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serveravailability\serverworks\watchdog\swwd.cpp ===
/*++

Copyright (c) 1991 - 2001 Microsoft Corporation

Module Name:

     ###  ##  #  ## ##  #  ## #####       ####  #####  #####
    ##  # ## ### ## ## ### ## ##  ##     ##   # ##  ## ##  ##
    ###   ## ### ## ## ### ## ##   ##    ##     ##  ## ##  ##
     ###  ## # # ## ## # # ## ##   ##    ##     ##  ## ##  ##
      ###  ### ###   ### ###  ##   ##    ##     #####  #####
    #  ##  ### ###   ### ###  ##  ##  ## ##   # ##     ##
     ###   ##   ##   ##   ##  #####   ##  ####  ##     ##

Abstract:

    This module contains the entire implementation of
    the watchdog miniport for the ServerWorks
    CSB5 server chip set.

Author:

    Wesley Witt (wesw) 1-Oct-2001

Environment:

    Kernel mode only.

Notes:


--*/

#include "swwd.h"


#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,DriverEntry)
#endif



NTSTATUS
SaWdDeviceIoctl(
    IN PVOID DeviceExtensionIn,
    IN PIRP Irp,
    IN PVOID FsContext,
    IN ULONG FunctionCode,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength,
    IN PVOID OutputBuffer,
    IN ULONG OutputBufferLength
    )

/*++

Routine Description:

    This function is called by the SAPORT driver so that
    the mini-port driver can service an IOCTL call.

Arguments:

    DeviceExtensionIn   - A pointer to the mini-port's device extension
    Irp                 - IO request packet pointer
    FsContext           - Context pointer
    FunctionCode        - The IOCTL function code
    InputBuffer         - Pointer to the input buffer, contains the data sent down by the I/O
    InputBufferLength   - Length in bytes of the InputBuffer
    OutputBuffer        - Pointer to the output buffer, contains the data generated by this call
    OutputBufferLength  - Length in bytes of the OutputBuffer

Context:

    IRQL: IRQL PASSIVE_LEVEL, arbitrary thread context

Return Value:

    If the function succeeds, it must return STATUS_SUCCESS.
    Otherwise, it must return one of the error status values defined in ntstatus.h.

--*/

{
    PDEVICE_EXTENSION DeviceExtension = (PDEVICE_EXTENSION)DeviceExtensionIn;
    NTSTATUS Status = STATUS_SUCCESS;
    PSA_WD_CAPS WdCaps = NULL;
    UCHAR Control;
    ULONG TimerValue;


    switch (FunctionCode) {
        case FUNC_SA_GET_VERSION:
            *((PULONG)OutputBuffer) = SA_INTERFACE_VERSION;
            break;

        case FUNC_SA_GET_CAPABILITIES:
            WdCaps = (PSA_WD_CAPS)OutputBuffer;
            WdCaps->SizeOfStruct = sizeof(SA_WD_CAPS);
            WdCaps->Minimum = 1;
            WdCaps->Maximum = 512;
            break;

        case FUNC_SAWD_DISABLE:
            ExAcquireFastMutex( &DeviceExtension->WdIoLock );
            Control = READ_REGISTER_UCHAR( DeviceExtension->WdMemBase );
            if (*((PULONG)InputBuffer) == 1) {
                SETBITS( Control, WATCHDOG_CONTROL_ENABLE );
                SETBITS( Control, WATCHDOG_CONTROL_TRIGGER );
            } else {
                CLEARBITS( Control, WATCHDOG_CONTROL_ENABLE );
            }
            WRITE_REGISTER_UCHAR( DeviceExtension->WdMemBase, Control );
            ExReleaseFastMutex( &DeviceExtension->WdIoLock );
            break;

        case FUNC_SAWD_QUERY_EXPIRE_BEHAVIOR:
            ExAcquireFastMutex( &DeviceExtension->WdIoLock );
            Control = READ_REGISTER_UCHAR( DeviceExtension->WdMemBase );
            if (Control & WATCHDOG_CONTROL_TIMER_MODE) {
                *((PULONG)OutputBuffer) = 1;
            } else {
                *((PULONG)OutputBuffer) = 0;
            }
            ExReleaseFastMutex( &DeviceExtension->WdIoLock );
            break;

        case FUNC_SAWD_SET_EXPIRE_BEHAVIOR:
            ExAcquireFastMutex( &DeviceExtension->WdIoLock );
            Control = READ_REGISTER_UCHAR( DeviceExtension->WdMemBase );
            if (*((PULONG)InputBuffer) == 1) {
                SETBITS( Control, WATCHDOG_CONTROL_TIMER_MODE );
            } else {
                CLEARBITS( Control, WATCHDOG_CONTROL_TIMER_MODE );
            }
            WRITE_REGISTER_UCHAR( DeviceExtension->WdMemBase, Control );
            ExReleaseFastMutex( &DeviceExtension->WdIoLock );
            break;

        case FUNC_SAWD_PING:
            ExAcquireFastMutex( &DeviceExtension->WdIoLock );
            Control = READ_REGISTER_UCHAR( DeviceExtension->WdMemBase );
            SETBITS( Control, WATCHDOG_CONTROL_TRIGGER );
            WRITE_REGISTER_UCHAR( DeviceExtension->WdMemBase, Control );
            ExReleaseFastMutex( &DeviceExtension->WdIoLock );
            break;

        case FUNC_SAWD_QUERY_TIMER:
            ExAcquireFastMutex( &DeviceExtension->WdIoLock );
            TimerValue = READ_REGISTER_ULONG( (PULONG)(DeviceExtension->WdMemBase+4) );
            *((PULONG)OutputBuffer) = TimerValue & 0x1ff;
            ExReleaseFastMutex( &DeviceExtension->WdIoLock );
            break;

        case FUNC_SAWD_SET_TIMER:
            ExAcquireFastMutex( &DeviceExtension->WdIoLock );
            TimerValue = *((PULONG)InputBuffer) & 0x1ff;
            WRITE_REGISTER_ULONG( (PULONG)(DeviceExtension->WdMemBase+4), TimerValue );
            ExReleaseFastMutex( &DeviceExtension->WdIoLock );
            break;

        default:
            Status = STATUS_NOT_SUPPORTED;
            REPORT_ERROR( SA_DEVICE_WATCHDOG, "Unsupported device control", Status );
            break;
    }

    return Status;
}


NTSTATUS
SaWdHwInitialize(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID DeviceExtensionIn,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR PartialResources,
    IN ULONG PartialResourceCount
    )

/*++

Routine Description:

    This function is called by the SAPORT driver so that
    the mini-port driver can initialize it's hardware
    resources.

Arguments:

    DeviceObject            - Pointer to the target device object.
    Irp                     - Pointer to an IRP structure that describes the requested I/O operation.
    DeviceExtension         - A pointer to the mini-port's device extension.
    PartialResources        - Pointer to the translated resources alloacted by the system.
    PartialResourceCount    - The number of resources in the PartialResources array.

Context:

    IRQL: IRQL PASSIVE_LEVEL, system thread context

Return Value:

    If the function succeeds, it must return STATUS_SUCCESS.
    Otherwise, it must return one of the error status values defined in ntstatus.h.

--*/

{
    PDEVICE_EXTENSION DeviceExtension = (PDEVICE_EXTENSION)DeviceExtensionIn;
    NTSTATUS Status;
    ULONG i;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR ResourceMemory = NULL;


    for (i=0; i<PartialResourceCount; i++) {
        if (PartialResources[i].Type == CmResourceTypeMemory) {
            ResourceMemory = &PartialResources[i];
        }
    }

    if (ResourceMemory == NULL) {
        REPORT_ERROR( SA_DEVICE_WATCHDOG, "Missing memory resource", STATUS_UNSUCCESSFUL );
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Setup the memory base address
    //

    DeviceExtension->WdMemBase = (PUCHAR) SaPortGetVirtualAddress(
        DeviceExtension,
        ResourceMemory->u.Memory.Start,
        ResourceMemory->u.Memory.Length
        );
    if (DeviceExtension->WdMemBase == NULL) {
        REPORT_ERROR( SA_DEVICE_WATCHDOG, "SaPortGetVirtualAddress failed", STATUS_NO_MEMORY );
        return STATUS_NO_MEMORY;
    }

    ExInitializeFastMutex( &DeviceExtension->WdIoLock );

    return STATUS_SUCCESS;
}


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This routine is the driver's entry point, called by the I/O system
    to load the driver.  The driver's entry points are initialized and
    a mutex to control paging is initialized.

    In DBG mode, this routine also examines the registry for special
    debug parameters.

Arguments:

    DriverObject - a pointer to the object that represents this device driver.
    RegistryPath - a pointer to this driver's key in the Services tree.

Return Value:

    STATUS_SUCCESS

--*/

{
    NTSTATUS Status;
    SAPORT_INITIALIZATION_DATA SaPortInitData;


    RtlZeroMemory( &SaPortInitData, sizeof(SAPORT_INITIALIZATION_DATA) );

    SaPortInitData.StructSize = sizeof(SAPORT_INITIALIZATION_DATA);
    SaPortInitData.DeviceType = SA_DEVICE_WATCHDOG;
    SaPortInitData.HwInitialize = SaWdHwInitialize;
    SaPortInitData.DeviceIoctl = SaWdDeviceIoctl;

    SaPortInitData.DeviceExtensionSize = sizeof(DEVICE_EXTENSION);

    Status = SaPortInitialize( DriverObject, RegistryPath, &SaPortInitData );
    if (!NT_SUCCESS(Status)) {
        REPORT_ERROR( SA_DEVICE_WATCHDOG, "SaPortInitialize failed\n", Status );
        return Status;
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serveravailability\watchdog\acpi.cpp ===
/*++

Copyright (c) 1991 - 2001 Microsoft Corporation

Module Name:

      ###    ####  #####  ####     ####  #####  #####
      ###   ##   # ##  ##  ##     ##   # ##  ## ##  ##
     ## ##  ##     ##  ##  ##     ##     ##  ## ##  ##
     ## ##  ##     ##  ##  ##     ##     ##  ## ##  ##
    ####### ##     #####   ##     ##     #####  #####
    ##   ## ##   # ##      ##  ## ##   # ##     ##
    ##   ##  ####  ##     #### ##  ####  ##     ##

Abstract:

    ACPI functions for querying the fixed ACPI tables.

Author:

    Wesley Witt (wesw) 22-April-2002

Environment:

    Kernel mode only.

Notes:

    This code was taken from the HAL.

--*/

#include "internal.h"
#include <ntacpi.h>



#define rgzMultiFunctionAdapter L"\\Registry\\Machine\\Hardware\\Description\\System\\MultifunctionAdapter"
#define rgzAcpiConfigurationData L"Configuration Data"
#define rgzAcpiIdentifier L"Identifier"
#define rgzBIOSIdentifier L"ACPI BIOS"



NTSTATUS
WdAcpiGetRegistryValue(
    IN HANDLE KeyHandle,
    IN PWSTR  ValueName,
    OUT PKEY_VALUE_PARTIAL_INFORMATION *Information
    )

/*++

Routine Description:

    This routine is invoked to retrieve the data for a registry key's value.
    This is done by querying the value of the key with a zero-length buffer
    to determine the size of the value, and then allocating a buffer and
    actually querying the value into the buffer.

    It is the responsibility of the caller to free the buffer.

Arguments:

    KeyHandle - Supplies the key handle whose value is to be queried

    ValueName - Supplies the null-terminated Unicode name of the value.

    Information - Returns a pointer to the allocated data buffer.

Return Value:

    The function value is the final status of the query operation.

--*/

{
    UNICODE_STRING unicodeString;
    NTSTATUS status;
    PKEY_VALUE_PARTIAL_INFORMATION infoBuffer;
    ULONG keyValueLength;

    RtlInitUnicodeString( &unicodeString, ValueName );

    //
    // Figure out how big the data value is so that a buffer of the
    // appropriate size can be allocated.
    //

    status = ZwQueryValueKey( KeyHandle,
                              &unicodeString,
                              KeyValuePartialInformation,
                              (PVOID) NULL,
                              0,
                              &keyValueLength );
    if (status != STATUS_BUFFER_OVERFLOW &&
        status != STATUS_BUFFER_TOO_SMALL) {
        return status;
    }

    //
    // Allocate a buffer large enough to contain the entire key data value.
    //

    infoBuffer = (PKEY_VALUE_PARTIAL_INFORMATION) ExAllocatePoolWithTag(NonPagedPool,
                                       keyValueLength,
                                       'IPCA');
    if (!infoBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Query the data for the key value.
    //

    status = ZwQueryValueKey( KeyHandle,
                              &unicodeString,
                              KeyValuePartialInformation,
                              infoBuffer,
                              keyValueLength,
                              &keyValueLength );
    if (!NT_SUCCESS( status )) {
        ExFreePool( infoBuffer );
        return status;
    }

    //
    // Everything worked, so simply return the address of the allocated
    // buffer to the caller, who is now responsible for freeing it.
    //

    *Information = infoBuffer;
    return STATUS_SUCCESS;
}


NTSTATUS
WdAcpiFindRsdt (
    OUT PACPI_BIOS_MULTI_NODE   *AcpiMulti
    )
/*++

Routine Description:

    This function looks into the registry to find the ACPI RSDT,
    which was stored there by ntdetect.com.

Arguments:

    RsdtPtr - Pointer to a buffer that contains the ACPI
              Root System Description Pointer Structure.
              The caller is responsible for freeing this
              buffer.  Note:  This is returned in non-paged
              pool.

Return Value:

    A NTSTATUS code to indicate the result of the initialization.

--*/
{
    UNICODE_STRING unicodeString, unicodeValueName, biosId;
    OBJECT_ATTRIBUTES objectAttributes;
    HANDLE hMFunc, hBus;
    WCHAR wbuffer[10];
    ULONG i, length;
    PWSTR p;
    PKEY_VALUE_PARTIAL_INFORMATION valueInfo;
    NTSTATUS status;
    BOOLEAN same;
    PCM_PARTIAL_RESOURCE_LIST prl;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR prd;
    PACPI_BIOS_MULTI_NODE multiNode;
    ULONG multiNodeSize;


    //
    // Look in the registry for the "ACPI BIOS bus" data
    //

    RtlInitUnicodeString (&unicodeString, rgzMultiFunctionAdapter);
    InitializeObjectAttributes (&objectAttributes,
                                &unicodeString,
                                OBJ_CASE_INSENSITIVE,
                                NULL,       // handle
                                NULL);


    status = ZwOpenKey (&hMFunc, KEY_READ, &objectAttributes);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    unicodeString.Buffer = wbuffer;
    unicodeString.MaximumLength = sizeof(wbuffer);
    RtlInitUnicodeString(&biosId, rgzBIOSIdentifier);

    for (i = 0; TRUE; i++) {
        RtlIntegerToUnicodeString (i, 10, &unicodeString);
        InitializeObjectAttributes (
            &objectAttributes,
            &unicodeString,
            OBJ_CASE_INSENSITIVE,
            hMFunc,
            NULL);

        status = ZwOpenKey (&hBus, KEY_READ, &objectAttributes);
        if (!NT_SUCCESS(status)) {

            //
            // Out of Multifunction adapter entries...
            //

            ZwClose (hMFunc);
            return STATUS_UNSUCCESSFUL;
        }

        //
        // Check the Indentifier to see if this is an ACPI BIOS entry
        //

        status = WdAcpiGetRegistryValue (hBus, rgzAcpiIdentifier, &valueInfo);
        if (!NT_SUCCESS (status)) {
            ZwClose (hBus);
            continue;
        }

        p = (PWSTR) ((PUCHAR) valueInfo->Data);
        unicodeValueName.Buffer = p;
        unicodeValueName.MaximumLength = (USHORT)valueInfo->DataLength;
        length = valueInfo->DataLength;

        //
        // Determine the real length of the ID string
        //

        while (length) {
            if (p[length / sizeof(WCHAR) - 1] == UNICODE_NULL) {
                length -= 2;
            } else {
                break;
            }
        }

        unicodeValueName.Length = (USHORT)length;
        same = RtlEqualUnicodeString(&biosId, &unicodeValueName, TRUE);
        ExFreePool(valueInfo);
        if (!same) {
            ZwClose (hBus);
            continue;
        }

        status = WdAcpiGetRegistryValue(hBus, rgzAcpiConfigurationData, &valueInfo);
        ZwClose (hBus);
        if (!NT_SUCCESS(status)) {
            continue ;
        }

        prl = (PCM_PARTIAL_RESOURCE_LIST)(valueInfo->Data);
        prd = &prl->PartialDescriptors[0];
        multiNode = (PACPI_BIOS_MULTI_NODE)((PCHAR) prd + sizeof(CM_PARTIAL_RESOURCE_LIST));


        break;
    }

    multiNodeSize = sizeof(ACPI_BIOS_MULTI_NODE) +
                        ((ULONG)(multiNode->Count - 1) * sizeof(ACPI_E820_ENTRY));

    *AcpiMulti = (PACPI_BIOS_MULTI_NODE)
                   ExAllocatePoolWithTag(NonPagedPool,
                           multiNodeSize,
                           'IPCA');
    if (*AcpiMulti == NULL) {
        ExFreePool(valueInfo);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory(*AcpiMulti, multiNode, multiNodeSize);

    ExFreePool(valueInfo);
    return STATUS_SUCCESS;
}


PVOID
WdGetAcpiTable(
  IN  ULONG  Signature
  )
/*++

  Routine Description:

      This routine will retrieve any table referenced in the ACPI
      RSDT.

  Arguments:

      Signature - Target table signature

  Return Value:

      pointer to a copy of the table, or NULL if not found

--*/
{
  PACPI_BIOS_MULTI_NODE multiNode;
  NTSTATUS status;
  ULONG entry, rsdtEntries;
  PDESCRIPTION_HEADER header;
  PHYSICAL_ADDRESS physicalAddr;
  PRSDT rsdt;
  ULONG rsdtSize;
  PVOID table = NULL;


  //
  // Get the physical address of the RSDT from the Registry
  //

  status = WdAcpiFindRsdt(&multiNode);

  if (!NT_SUCCESS(status)) {
    return NULL;
  }


  //
  // Map down header to get total RSDT table size
  //

  header = (PDESCRIPTION_HEADER) MmMapIoSpace(multiNode->RsdtAddress, sizeof(DESCRIPTION_HEADER), MmNonCached);

  if (!header) {
    return NULL;
  }

  rsdtSize = header->Length;
  MmUnmapIoSpace(header, sizeof(DESCRIPTION_HEADER));


  //
  // Map down entire RSDT table
  //

  rsdt = (PRSDT) MmMapIoSpace(multiNode->RsdtAddress, rsdtSize, MmNonCached);

  ExFreePool(multiNode);

  if (!rsdt) {
    return NULL;
  }


  //
  // Do a sanity check on the RSDT.
  //

  if ((rsdt->Header.Signature != RSDT_SIGNATURE) &&
      (rsdt->Header.Signature != XSDT_SIGNATURE)) {

    goto GetAcpiTableEnd;
  }


  //
  // Calculate the number of entries in the RSDT.
  //

  rsdtEntries = rsdt->Header.Signature == XSDT_SIGNATURE ?
      NumTableEntriesFromXSDTPointer(rsdt) :
      NumTableEntriesFromRSDTPointer(rsdt);


  //
  // Look down the pointer in each entry to see if it points to
  // the table we are looking for.
  //

  for (entry = 0; entry < rsdtEntries; entry++) {

    if (rsdt->Header.Signature == XSDT_SIGNATURE) {
      physicalAddr = ((PXSDT)rsdt)->Tables[entry];
    } else {
      physicalAddr.HighPart = 0;
      physicalAddr.LowPart = (ULONG)rsdt->Tables[entry];
    }

    //
    // Map down the header, check the signature
    //

    header = (PDESCRIPTION_HEADER) MmMapIoSpace(physicalAddr, sizeof(DESCRIPTION_HEADER), MmNonCached);

    if (!header) {
      goto GetAcpiTableEnd;
    }

    if (header->Signature == Signature) {

      table = ExAllocatePoolWithTag(PagedPool, header->Length, 'IPCA');

      if (table) {
        RtlCopyMemory(table, header, header->Length);
      }

      MmUnmapIoSpace(header, sizeof(DESCRIPTION_HEADER));
      break;
    }

    MmUnmapIoSpace(header, sizeof(DESCRIPTION_HEADER));
  }


GetAcpiTableEnd:

  MmUnmapIoSpace(rsdt, rsdtSize);
  return table;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serveravailability\watchdog\handler.cpp ===
/*++

Copyright (c) 1991 - 2002 Microsoft Corporation

Module Name:

    ##   ##   ###   ##   # #####   ##    ##### #####      ####  #####  #####
    ##   ##   ###   ###  # ##  ##  ##    ##    ##  ##    ##   # ##  ## ##  ##
    ##   ##  ## ##  #### # ##   ## ##    ##    ##  ##    ##     ##  ## ##  ##
    #######  ## ##  # #### ##   ## ##    ##### #####     ##     ##  ## ##  ##
    ##   ## ####### #  ### ##   ## ##    ##    ####      ##     #####  #####
    ##   ## ##   ## #   ## ##  ##  ##    ##    ## ##  ## ##   # ##     ##
    ##   ## ##   ## #    # #####   ##### ##### ##  ## ##  ####  ##     ##

Abstract:

    This module process the callback from
    the OS executive.

Author:

    Wesley Witt (wesw) 1-Mar-2002

Environment:

    Kernel mode only.

Notes:

--*/

#include "internal.h"



void
WdHandlerSetTimeoutValue(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN ULONG Timeout,
    IN BOOLEAN PingTimer
    )

/*++

Routine Description:

    This function sets the timeout value for the hardware
    timer and the software timer.  The software timer runs
    as a frequency that is 25% of the hardware timer.  The
    hardware timer's frequency is set at StartDevice time to
    the device's reported maximum value, but it can be changed
    through the NtSetSystemInformation inmterface.

Arguments:

    DeviceExtension - Pointer to the watchdog device extension

    Timeout - The requested timeout value expressed in the device
        units.

    PingTimer - Specifies if the timer should be pinged after
        changing the timeout value.

Return Value:

    None.

Notes:

--*/

{
    DeviceExtension->HardwareTimeout = Timeout;
    DeviceExtension->DpcTimeout = ConvertTimeoutToMilliseconds(
        WdTable->Units, DeviceExtension->HardwareTimeout >> 2 ) * 10000;
    ULONG Control = READ_REGISTER_ULONG( DeviceExtension->ControlRegisterAddress );
    SETBITS( Control, WATCHDOG_CONTROL_TRIGGER );
    WRITE_REGISTER_ULONG( DeviceExtension->CountRegisterAddress, DeviceExtension->HardwareTimeout );
    WRITE_REGISTER_ULONG( DeviceExtension->ControlRegisterAddress, Control );
    if (PingTimer) {
        PingWatchdogTimer( DeviceExtension, FALSE );
    }
}


ULONG
WdHandlerQueryTimeoutValue(
    IN PDEVICE_EXTENSION DeviceExtension
    )

/*++

Routine Description:

    This function queries the hardware for the current
    value of the hardware timer.  This timer is counting down
    to zero and this query returns the real-time value of
    the timer.

Arguments:

    DeviceExtension - Pointer to the watchdog device extension

Return Value:

    The current timeout value.

Notes:

--*/

{
    return READ_REGISTER_ULONG( DeviceExtension->CountRegisterAddress );
}


void
WdHandlerResetTimer(
    IN PDEVICE_EXTENSION DeviceExtension
    )

/*++

Routine Description:

    This function resets the timer to it's previously
    set maximum value.

Arguments:

    DeviceExtension - Pointer to the watchdog device extension

Return Value:

    None.

Notes:

--*/

{
    ULONG Control = READ_REGISTER_ULONG( DeviceExtension->ControlRegisterAddress );
    SETBITS( Control, WATCHDOG_CONTROL_TRIGGER );
    WRITE_REGISTER_ULONG( DeviceExtension->ControlRegisterAddress, Control );
    PingWatchdogTimer( DeviceExtension, FALSE );
}


void
WdHandlerStopTimer(
    IN PDEVICE_EXTENSION DeviceExtension
    )

/*++

Routine Description:

    This function stops the hardware and software timer.

Arguments:

    DeviceExtension - Pointer to the watchdog device extension

Return Value:

    None.

Notes:

--*/

{
    ULONG Control = READ_REGISTER_ULONG( DeviceExtension->ControlRegisterAddress );
    CLEARBITS( Control, WATCHDOG_CONTROL_ENABLE );
    WRITE_REGISTER_ULONG( DeviceExtension->ControlRegisterAddress, Control );
    KeCancelTimer( &DeviceExtension->Timer );
}


void
WdHandlerStartTimer(
    IN PDEVICE_EXTENSION DeviceExtension
    )

/*++

Routine Description:

    This function starts the hardware and software timer.

Arguments:

    DeviceExtension - Pointer to the watchdog device extension

Return Value:

    None.

Notes:

--*/

{
    ULONG Control = READ_REGISTER_ULONG( DeviceExtension->ControlRegisterAddress );
    SETBITS( Control, WATCHDOG_CONTROL_ENABLE );
    WRITE_REGISTER_ULONG( DeviceExtension->ControlRegisterAddress, Control );
    SETBITS( Control, WATCHDOG_CONTROL_TRIGGER );
    WRITE_REGISTER_ULONG( DeviceExtension->ControlRegisterAddress, Control );
    PingWatchdogTimer( DeviceExtension, FALSE );
}


void
WdHandlerSetTriggerAction(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN ULONG TriggerAction
    )

/*++

Routine Description:

    This function sets the trigger action.  The trigger
    action specifies what action takes place when the
    hardware timer expires.  There are 2 possible actions,
    restart and reboot.

Arguments:

    DeviceExtension - Pointer to the watchdog device extension

    TriggerAction - Sets the trigger action
        0 = Restart system
        1 = Reboot system

Return Value:

    None.

Notes:

--*/

{
    ULONG Control = READ_REGISTER_ULONG( DeviceExtension->ControlRegisterAddress );
    if (TriggerAction == 1) {
        SETBITS( Control, WATCHDOG_CONTROL_TIMER_MODE );
    } else {
        CLEARBITS( Control, WATCHDOG_CONTROL_TIMER_MODE );
    }
    WRITE_REGISTER_ULONG( DeviceExtension->ControlRegisterAddress, Control );
}


ULONG
WdHandlerQueryTriggerAction(
    IN PDEVICE_EXTENSION DeviceExtension
    )

/*++

Routine Description:

    This function queries the current trigger action.

Arguments:

    DeviceExtension - Pointer to the watchdog device extension

Return Value:

    TriggerAction:
        0 = Restart system
        1 = Reboot system

Notes:

--*/

{
    ULONG Control = READ_REGISTER_ULONG( DeviceExtension->ControlRegisterAddress );
    if (Control & WATCHDOG_CONTROL_TIMER_MODE) {
        return 1;
    }
    return 0;
}


ULONG
WdHandlerQueryState(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN BOOLEAN QueryFiredFromDevice
    )

/*++

Routine Description:

    This function queries the device state from the
    hardware timer.

Arguments:

    DeviceExtension - Pointer to the watchdog device extension

    QueryFiredFromDevice - Specifies whether the fired state
        bit should come from the device or from the driver cache.

Return Value:

    Device state.

Notes:

--*/

{
    ULONG Control = READ_REGISTER_ULONG( DeviceExtension->ControlRegisterAddress );
    ULONG StateValue = 0;
    if (QueryFiredFromDevice) {
        if (Control & WATCHDOG_CONTROL_FIRED) {
            SETBITS( StateValue, WDSTATE_FIRED );
        }
    } else {
        if (DeviceExtension->WdState & WDSTATE_FIRED) {
            SETBITS( StateValue, WDSTATE_FIRED );
        }
    }
    if ((Control & WATCHDOG_CONTROL_BIOS_JUMPER) == 0) {
        SETBITS( StateValue, WDSTATE_HARDWARE_ENABLED );
    }
    if (Control & WATCHDOG_CONTROL_ENABLE) {
        SETBITS( StateValue, WDSTATE_STARTED );
    }
    SETBITS( StateValue, WDSTATE_HARDWARE_PRESENT );
    return StateValue;
}


void
WdHandlerResetFired(
    IN PDEVICE_EXTENSION DeviceExtension
    )

/*++

Routine Description:

    This function resets the hardware fired state bit.

Arguments:

    DeviceExtension - Pointer to the watchdog device extension

Return Value:

    None.

Notes:

--*/

{
    ULONG Control = READ_REGISTER_ULONG( DeviceExtension->ControlRegisterAddress );
    SETBITS( Control, WATCHDOG_CONTROL_FIRED );
    WRITE_REGISTER_ULONG( DeviceExtension->ControlRegisterAddress, Control );
}


NTSTATUS
WdHandlerFunction(
    IN WATCHDOG_HANDLER_ACTION HandlerAction,
    IN PVOID Context,
    IN OUT PULONG DataValue,
    IN BOOLEAN NoLocks
    )

/*++

Routine Description:

   This routine is the hardware specific interface to the watchdog device.
   All hardware interfaces are here are exposed thru the handler function
   for use by NtSet/QuerySystemInformation and the other part of the
   watchdog driver.

Arguments:

    HandlerAction - Enumeration specifying the requested action

    Context - Always a device extension pointer

    DataValue - Action specific data value

    NoLocks - Specifies that no lock are to be held during
      the handler function

Return Value:

   If we successfully create a device object, STATUS_SUCCESS is
   returned.  Otherwise, return the appropriate error code.

Notes:

--*/

{
    PDEVICE_EXTENSION DeviceExtension = (PDEVICE_EXTENSION) Context;
    NTSTATUS Status = STATUS_SUCCESS;
    KLOCK_QUEUE_HANDLE LockHandle;
    ULONG Timeout;


    if (!NoLocks) {
        KeAcquireInStackQueuedSpinLock( &DeviceExtension->DeviceLock, &LockHandle );
    }

    switch (HandlerAction) {
        case WdActionSetTimeoutValue:
            Timeout = ConvertTimeoutFromMilliseconds( WdTable->Units, *DataValue );
            if (Timeout > DeviceExtension->MaxCount || Timeout == 0) {
                Status = STATUS_INVALID_PARAMETER_1;
            } else {
                WdHandlerSetTimeoutValue( DeviceExtension, Timeout, TRUE );
            }
            break;

        case WdActionQueryTimeoutValue:
            *DataValue = WdHandlerQueryTimeoutValue( DeviceExtension );
            break;

        case WdActionResetTimer:
            WdHandlerResetTimer( DeviceExtension );
            break;

        case WdActionStopTimer:
            WdHandlerStopTimer( DeviceExtension );
            break;

        case WdActionStartTimer:
            WdHandlerStartTimer( DeviceExtension );
            break;

        case WdActionSetTriggerAction:
            if (*DataValue == 0xbadbadff) {
                KeCancelTimer( &DeviceExtension->Timer );
            } else {
                if (*DataValue > 1) {
                    Status = STATUS_INVALID_PARAMETER_2;
                } else {
                    WdHandlerSetTriggerAction( DeviceExtension, *DataValue );
                }
            }
            break;

        case WdActionQueryTriggerAction:
            *DataValue = WdHandlerQueryTriggerAction( DeviceExtension );
            break;

        case WdActionQueryState:
            *DataValue = WdHandlerQueryState( DeviceExtension, FALSE );
            break;

        default:
            Status = STATUS_INVALID_PARAMETER_3;
    }

    if (!NoLocks) {
        KeReleaseInStackQueuedSpinLock( &LockHandle );
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serveravailability\watchdog\internal.h ===
/*++

Copyright (c) 1991 - 2001 Microsoft Corporation

Module Name:

    #### ##   # ###### ##### #####  ##   #   ###   ##       ##   ##
     ##  ###  #   ##   ##    ##  ## ###  #   ###   ##       ##   ##
     ##  #### #   ##   ##    ##  ## #### #  ## ##  ##       ##   ##
     ##  # ####   ##   ##### #####  # ####  ## ##  ##       #######
     ##  #  ###   ##   ##    ####   #  ### ####### ##       ##   ##
     ##  #   ##   ##   ##    ## ##  #   ## ##   ## ##    ## ##   ##
    #### #    #   ##   ##### ##  ## #    # ##   ## ##### ## ##   ##

Abstract:

    This header contains all definitions that are internal
    to the watchdog driver.

Author:

    Wesley Witt (wesw) 23-Jan-2002

Environment:

    Kernel mode only.

Notes:

--*/

extern "C" {
#include <ntosp.h>
#include <zwapi.h>
#include <mountmgr.h>
#include <mountdev.h>
#include <ntddstor.h>
#include <ntdddisk.h>
#include <acpitabl.h>
#include <stdio.h>
#include <eventmsg.h>
}

#pragma warning(error:4101)   // Unreferenced local variable

//
// externs
//

extern ULONG ShutdownCountTime;
extern ULONG RunningCountTime;

extern ULONG WdDebugLevel;

extern ULONG OsMajorVersion;
extern ULONG OsMinorVersion;

extern PWATCHDOG_TIMER_RESOURCE_TABLE WdTable;


//
// Memory allocation
///

#define WD_POOL_TAG 'tpaS'

#ifdef POOL_TAGGING
#ifdef ExAllocatePool
#undef ExAllocatePool
#endif
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,WD_POOL_TAG)
#endif

//
// General purpose macros
//

#define STRING_SZ(_str)                 (wcslen((PWSTR)_str)*sizeof(WCHAR))
#define ARRAY_SZ(_ary)                  (sizeof(_ary)/sizeof(_ary[0]))

#define SecToNano(_sec)                 (LONGLONG)((_sec) * 1000 * 1000 * 10)
#define NanoToSec(_nano)                (ULONG)((_nano) / (1000 * 1000 * 10))

#define CLEARBITS(_val,_mask)           ((_val) &= ~(_mask))
#define SETBITS(_val,_mask)             ((_val) |= (_mask))

#define MIN_TIMEOUT_VALUE               (100)

//
// Control Register Bits
//

#define WATCHDOG_CONTROL_TRIGGER        0x80   // Setting this to 1 causes a new countdown to start
#define WATCHDOG_CONTROL_BIOS_JUMPER    0x08   // Is the timer disabled in the BIOS? (0=false,1=true)
#define WATCHDOG_CONTROL_TIMER_MODE     0x04   // Controls what happens when the timer fires (0=reset,1=shutdown)
#define WATCHDOG_CONTROL_FIRED          0x02   // The timer fired causing the last reboot
#define WATCHDOG_CONTROL_ENABLE         0x01   // Starts/stops the timer

typedef struct _SYSTEM_HEALTH_DATA {
    ULONG                                       CpuCount;
    LONG                                        HealthyCpuRatio;
    LONGLONG                                    TickCountPrevious;
    LONGLONG                                    ContextSwitchesPrevious;
    PSYSTEM_PROCESSOR_PERFORMANCE_INFORMATION   ProcInfo;
    PSYSTEM_PROCESSOR_PERFORMANCE_INFORMATION   ProcInfoPrev;
    ULONG                                       ProcInfoSize;
    LONG                                        ContextSwitchRate;
    LONG                                        CPUTime;
    LONG                                        ContextCpuRatio;
} SYSTEM_HEALTH_DATA, *PSYSTEM_HEALTH_DATA;

typedef struct _DEVICE_EXTENSION {
    PDEVICE_OBJECT                  DeviceObject;
    PDRIVER_OBJECT                  DriverObject;
    PDEVICE_OBJECT                  TargetObject;
    PDEVICE_OBJECT                  Pdo;
    LONG                            IsStarted;
    LONG                            IsRemoved;
    IO_REMOVE_LOCK                  RemoveLock;
    KSPIN_LOCK                      DeviceLock;
    KTIMER                          Timer;
    KDPC                            TimerDpc;
    PULONG                          ControlRegisterAddress;
    PULONG                          CountRegisterAddress;
    ULONG                           MaxCount;
    ULONG                           DpcTimeout;
    ULONG                           Units;
    ULONG                           HardwareTimeout;
    SYSTEM_HEALTH_DATA              Health;
    ULONG                           WdState;
} DEVICE_EXTENSION, *PDEVICE_EXTENSION;


//
// Debug Stuff
//

#define WD_DEBUG_ERROR_LEVEL        0x00000001
#define WD_WARNING_LEVEL            0x00000002
#define WD_DEBUG_TRACE_LEVEL        0x00000004
#define WD_DEBUG_INFO_LEVEL         0x00000008
#define WD_DEBUG_IGNORE_LEVEL       0xffffffff


#if DBG
#define DebugPrint(_X_)    WdDebugPrint _X_
#else
#define DebugPrint(_X_)
#endif

#define REPORT_ERROR(_msg_,_status_) \
    DebugPrint(( WD_DEBUG_ERROR_LEVEL, "%s [0x%08x]: %s @ %d\n", _msg_, _status_, __FILE__, __LINE__ ))

#define ERROR_RETURN(_msg_,_status_) \
    { \
        REPORT_ERROR(_msg_,_status_); \
        __leave; \
    }

#if DBG

VOID
WdDebugPrint(
    IN ULONG DebugLevel,
    IN PSTR DebugMessage,
    IN ...
    );

PCHAR
PnPMinorFunctionString(
    UCHAR MinorFunction
    );

PCHAR
IoctlString(
    ULONG IoControlCode
    );

PCHAR
PowerMinorFunctionString(
    UCHAR MinorFunction
    );

PCHAR
PowerSystemStateString(
    SYSTEM_POWER_STATE State
    );

PCHAR
PowerDeviceStateString(
    DEVICE_POWER_STATE State
    );

PCHAR
PnPMinorFunctionString(
    UCHAR MinorFunction
    );
#endif

//
// prototypes
//

extern "C" {

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
WdPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
WdAddDevice(
    IN      PDRIVER_OBJECT DriverObject,
    IN OUT  PDEVICE_OBJECT PhysicalDeviceObject
    );

NTSTATUS
WdPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
WdShutdown(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
WdSystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
WdDefaultDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
WdHandlerFunction(
    IN WATCHDOG_HANDLER_ACTION Action,
    IN PVOID Context,
    IN OUT PULONG DataValue,
    IN BOOLEAN NoLocks
    );

} // extern "C"

NTSTATUS
WdInitializeSoftwareTimer(
    PDEVICE_EXTENSION DeviceExtension
    );


//
// util.cpp
//

VOID
PrintDriverVersion(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
CallLowerDriverAndWait(
    IN PIRP Irp,
    IN PDEVICE_OBJECT TargetObject
    );

NTSTATUS
CompleteRequest(
    PIRP Irp,
    NTSTATUS Status,
    ULONG_PTR OutputLength
    );

NTSTATUS
ForwardRequest(
    IN PIRP Irp,
    IN PDEVICE_OBJECT TargetObject
    );

NTSTATUS
OpenParametersRegistryKey(
    IN PUNICODE_STRING RegistryPath,
    IN ULONG AccessMode,
    OUT PHANDLE RegistryHandle
    );

NTSTATUS
CreateParametersRegistryKey(
    IN PUNICODE_STRING RegistryPath,
    OUT PHANDLE parametersKey
    );

NTSTATUS
ReadRegistryValue(
    IN PUNICODE_STRING RegistryPath,
    IN PWSTR ValueName,
    OUT PKEY_VALUE_FULL_INFORMATION *KeyInformation
    );

NTSTATUS
WriteRegistryValue(
    IN PUNICODE_STRING RegistryPath,
    IN PWSTR ValueName,
    IN ULONG RegistryType,
    IN PVOID RegistryValue,
    IN ULONG RegistryValueLength
    );

VOID
GetOsVersion(
    VOID
    );

NTSTATUS
WdInitializeSystemHealth(
    PSYSTEM_HEALTH_DATA Health
    );

BOOLEAN
WdCheckSystemHealth(
    PSYSTEM_HEALTH_DATA Health
    );

NTSTATUS
WriteEventLogEntry (
    IN PDEVICE_EXTENSION DeviceExtension,
    IN ULONG ErrorCode,
    IN PVOID InsertionStrings, OPTIONAL
    IN ULONG StringCount,      OPTIONAL
    IN PVOID DumpData, OPTIONAL
    IN ULONG DataSize  OPTIONAL
    );

ULONG
ConvertTimeoutFromMilliseconds(
    IN ULONG Units,
    IN ULONG UserTimeout
    );

ULONG
ConvertTimeoutToMilliseconds(
    IN ULONG Units,
    IN ULONG NativeTimeout
    );

PVOID
WdGetAcpiTable(
    IN  ULONG  Signature
    );

VOID
PingWatchdogTimer(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN BOOLEAN LockResources
    );

void
WdHandlerSetTimeoutValue(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN ULONG Timeout,
    IN BOOLEAN PingTimer
    );

ULONG
WdHandlerQueryTimeoutValue(
    IN PDEVICE_EXTENSION DeviceExtension
    );

void
WdHandlerResetTimer(
    IN PDEVICE_EXTENSION DeviceExtension
    );

void
WdHandlerStopTimer(
    IN PDEVICE_EXTENSION DeviceExtension
    );

void
WdHandlerStartTimer(
    IN PDEVICE_EXTENSION DeviceExtension
    );

void
WdHandlerSetTriggerAction(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN ULONG TriggerAction
    );

ULONG
WdHandlerQueryTriggerAction(
    IN PDEVICE_EXTENSION DeviceExtension
    );

ULONG
WdHandlerQueryState(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN BOOLEAN QueryFiredFromDevice
    );

void
WdHandlerResetFired(
    IN PDEVICE_EXTENSION DeviceExtension
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serveravailability\watchdog\pnp.cpp ===
/*++

Copyright (c) 1991 - 2001 Microsoft Corporation

Module Name:

    #####  ##   # #####      ####  #####  #####
    ##  ## ###  # ##  ##    ##   # ##  ## ##  ##
    ##  ## #### # ##  ##    ##     ##  ## ##  ##
    ##  ## # #### ##  ##    ##     ##  ## ##  ##
    #####  #  ### #####     ##     #####  #####
    ##     #   ## ##     ## ##   # ##     ##
    ##     #    # ##     ##  ####  ##     ##

Abstract:

    This module process all plug and play IRPs.

Author:

    Wesley Witt (wesw) 1-Oct-2001

Environment:

    Kernel mode only.

Notes:


--*/

#include "internal.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,WdAddDevice)
#pragma alloc_text(PAGE,WdPnp)
#endif




NTSTATUS
WdAddDevice(
    IN      PDRIVER_OBJECT DriverObject,
    IN OUT  PDEVICE_OBJECT PhysicalDeviceObject
    )

/*++

Routine Description:

   This routine is the driver's pnp add device entry point.  It is
   called by the pnp manager to initialize the driver.

   Add device creates and initializes a device object for this FDO and
   attaches to the underlying PDO.

Arguments:

   DriverObject - a pointer to the object that represents this device driver.
   PhysicalDeviceObject - a pointer to the underlying PDO to which this new device will attach.

Return Value:

   If we successfully create a device object, STATUS_SUCCESS is
   returned.  Otherwise, return the appropriate error code.

Notes:

--*/

{
    NTSTATUS status = STATUS_SUCCESS;
    PDEVICE_EXTENSION DeviceExtension = NULL;
    PDEVICE_OBJECT deviceObject = NULL;
    WCHAR DeviceNameBuffer[64];
    UNICODE_STRING DeviceName;


    __try {

        //
        // Establish the device name
        //

        DeviceName.MaximumLength = sizeof(DeviceNameBuffer);
        DeviceName.Buffer = DeviceNameBuffer;

        wcscpy( DeviceName.Buffer, L"\\Device\\Watchdog" );

        DeviceName.Length = wcslen(DeviceName.Buffer) * sizeof(WCHAR);

        //
        // Create the device
        //

        status = IoCreateDevice(
            DriverObject,
            sizeof(DEVICE_EXTENSION),
            &DeviceName,
            FILE_DEVICE_CONTROLLER,
            FILE_DEVICE_SECURE_OPEN,
            FALSE,
            &deviceObject
            );
        if (!NT_SUCCESS(status)) {
            ERROR_RETURN( "IoCreateDevice", status );
        }

        DeviceExtension = (PDEVICE_EXTENSION) deviceObject->DeviceExtension;
        RtlZeroMemory( DeviceExtension, sizeof(DEVICE_EXTENSION) );

        DeviceExtension->DeviceObject = deviceObject;
        DeviceExtension->DriverObject = DriverObject;
        DeviceExtension->Pdo = PhysicalDeviceObject;

        DeviceExtension->TargetObject = IoAttachDeviceToDeviceStack( deviceObject, PhysicalDeviceObject );
        if (DeviceExtension->TargetObject == NULL) {
            status = STATUS_NO_SUCH_DEVICE;
            ERROR_RETURN( "IoAttachDeviceToDeviceStack", status );
        }

        //
        // Register with the I/O manager for shutdown notification
        //

        status = IoRegisterShutdownNotification( deviceObject );
        if (!NT_SUCCESS(status)) {
            ERROR_RETURN( "IoRegisterShutdownNotification", status );
        }

        IoInitializeRemoveLock( &DeviceExtension->RemoveLock, WD_POOL_TAG, 0, 0 );
        KeInitializeSpinLock( &DeviceExtension->DeviceLock );

        //
        // Set the device object flags
        //

        deviceObject->Flags |= DO_DIRECT_IO;
        deviceObject->Flags |= DO_POWER_PAGABLE;
        deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    } __finally {

        //
        // In the failure case un-do everything
        //

        if (!NT_SUCCESS(status)) {
            if (deviceObject) {
                if (DeviceExtension && DeviceExtension->TargetObject) {
                    IoDetachDevice( DeviceExtension->TargetObject );
                }
                IoDeleteDevice( deviceObject );
            }
        }

    }

    return status;
}


NTSTATUS
WdPnpStartDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

   This routine is the PNP handler for the IRP_MN_START_DEVICE request.

Arguments:

   DeviceObject     - Pointer to the object that represents the device that I/O is to be done on.
   Irp              - I/O Request Packet for this request.
   IrpSp            - IRP stack location for this request
   DeviceExtension  - Device extension

Return Value:

   NT status code.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PDEVICE_EXTENSION DeviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);
    SYSTEM_WATCHDOG_HANDLER_INFORMATION WdHandlerInfo;


    if (DeviceExtension->IsStarted) {
        return ForwardRequest( Irp, DeviceExtension->TargetObject );
    }

    __try {

        if (IrpSp->Parameters.StartDevice.AllocatedResourcesTranslated != NULL) {
            Status = STATUS_UNSUCCESSFUL;
            ERROR_RETURN( "Resource list is empty", Status );
        }

        DeviceExtension->ControlRegisterAddress = (PULONG) MmMapIoSpace(
            WdTable->ControlRegisterAddress.Address,
            WdTable->ControlRegisterAddress.BitWidth>>3,
            MmNonCached
            );
        if (DeviceExtension->ControlRegisterAddress == NULL) {
            Status = STATUS_UNSUCCESSFUL ;
            ERROR_RETURN( "MmMapIoSpace failed", Status );
        }

        DeviceExtension->CountRegisterAddress = (PULONG) MmMapIoSpace(
            WdTable->CountRegisterAddress.Address,
            WdTable->CountRegisterAddress.BitWidth>>3,
            MmNonCached
            );
        if (DeviceExtension->CountRegisterAddress == NULL) {
            Status = STATUS_UNSUCCESSFUL ;
            ERROR_RETURN( "MmMapIoSpace failed", Status );
        }

        //
        // Setup & start the hardware timer
        //

        //
        // First query the state of the hardware
        //

        DeviceExtension->WdState = WdHandlerQueryState( DeviceExtension, TRUE );

        DeviceExtension->Units = WdTable->Units;
        DeviceExtension->MaxCount = WdTable->MaxCount;

        if (RunningCountTime > 0) {
            DeviceExtension->HardwareTimeout = RunningCountTime;
        } else {
            DeviceExtension->HardwareTimeout = DeviceExtension->MaxCount;
        }

        WdHandlerSetTimeoutValue( DeviceExtension, DeviceExtension->HardwareTimeout, FALSE );

        //
        // Everything is good and the device is now started
        // The last thing to do is register with the executive
        // so that we can service watchdog requests.
        //

        WdHandlerInfo.WdHandler = WdHandlerFunction;
        WdHandlerInfo.Context = (PVOID) DeviceExtension;

        Status = ZwSetSystemInformation( SystemWatchdogTimerHandler, &WdHandlerInfo, sizeof(SYSTEM_WATCHDOG_HANDLER_INFORMATION) );
        if (!NT_SUCCESS(Status)) {
            REPORT_ERROR( "Failed to set the executive watchdog handler, ec=%08x", Status );
        }

        //
        // Check to see if the timer triggered previous to this boot
        //

        if (DeviceExtension->WdState & WDSTATE_FIRED) {
            Status = WriteEventLogEntry( DeviceExtension, WD_TIMER_WAS_TRIGGERED, NULL, 0, NULL, 0 );
            if (!NT_SUCCESS(Status)) {
                REPORT_ERROR( "WriteEventLogEntry failed, ec=%08x", Status );
            }
            WdHandlerResetFired( DeviceExtension );
        }

        //
        // Mark the device as started
        //

        DeviceExtension->IsStarted = TRUE;

        Status = WdInitializeSoftwareTimer( DeviceExtension );
        if (!NT_SUCCESS(Status)) {
            REPORT_ERROR( "Failed to start the software watchdog timer, ec=%08x", Status );
        }

        WdHandlerStartTimer( DeviceExtension );

    } __finally {

    }

    Irp->IoStatus.Status = Status;

    return ForwardRequest( Irp, DeviceExtension->TargetObject );
}


NTSTATUS
WdPnpQueryCapabilities(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

   This routine is the PNP handler for the IRP_MN_QUERY_CAPABILITIES request.

Arguments:

   DeviceObject     - Pointer to the object that represents the device that I/O is to be done on.
   Irp              - I/O Request Packet for this request.
   IrpSp            - IRP stack location for this request
   DeviceExtension  - Device extension

Return Value:

   NT status code.

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);
    PDEVICE_EXTENSION DeviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    PDEVICE_CAPABILITIES Capabilities = IrpSp->Parameters.DeviceCapabilities.Capabilities;


    Status = CallLowerDriverAndWait( Irp, DeviceExtension->TargetObject );

    Capabilities->SilentInstall = 1;
    Capabilities->RawDeviceOK = 1;

    return CompleteRequest( Irp, Status, Irp->IoStatus.Information );
}


NTSTATUS
WdPnpQueryDeviceState(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

   This routine is the PNP handler for the IRP_MN_QUERY_PNP_DEVICE_STATE request.

Arguments:

   DeviceObject     - Pointer to the object that represents the device that I/O is to be done on.
   Irp              - I/O Request Packet for this request.
   IrpSp            - IRP stack location for this request
   DeviceExtension  - Device extension

Return Value:

   NT status code.

--*/

{
    NTSTATUS Status;
    PDEVICE_EXTENSION DeviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;


    Status = CallLowerDriverAndWait( Irp, DeviceExtension->TargetObject );
    if (!NT_SUCCESS(Status)) {
        REPORT_ERROR( "IRP_MN_QUERY_PNP_DEVICE_STATE", Status );
        Irp->IoStatus.Information = 0;
    }

    return CompleteRequest( Irp, STATUS_SUCCESS, Irp->IoStatus.Information );
}


NTSTATUS
WdPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

   Main PNP irp dispatch routine

Arguments:

   DeviceObject - a pointer to the object that represents the device
   that I/O is to be done on.

   Irp - a pointer to the I/O Request Packet for this request.

Return Value:

   status

--*/
{
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);
    PDEVICE_EXTENSION DeviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;


    DebugPrint(( WD_DEBUG_INFO_LEVEL, "PNP - Func [0x%02x %s]\n",
        irpSp->MinorFunction,
        PnPMinorFunctionString(irpSp->MinorFunction)
        ));

    if (DeviceExtension->IsRemoved) {
        return CompleteRequest( Irp, STATUS_DELETE_PENDING, 0 );
    }

    status = IoAcquireRemoveLock(&DeviceExtension->RemoveLock, Irp );
    if (!NT_SUCCESS(status)) {
        REPORT_ERROR( "WdPnp could not acquire the remove lock", status );
        return CompleteRequest( Irp, status, 0 );
    }

    switch (irpSp->MinorFunction) {
        case IRP_MN_START_DEVICE:
            status = WdPnpStartDevice( DeviceObject, Irp );
            break;

        case IRP_MN_QUERY_CAPABILITIES:
            status = WdPnpQueryCapabilities( DeviceObject, Irp );
            break;

        case IRP_MN_QUERY_PNP_DEVICE_STATE:
            status = WdPnpQueryDeviceState( DeviceObject, Irp );
            break;

        default:
            status = ForwardRequest( Irp, DeviceExtension->TargetObject );
            break;
    }

    IoReleaseRemoveLock( &DeviceExtension->RemoveLock, Irp );

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serveravailability\watchdog\main.cpp ===
/*++

Copyright (c) 1991 - 2001 Microsoft Corporation

Module Name:

    ##    ##   ###   #### ##   #     ####  #####  #####
    ###  ###   ###    ##  ###  #    ##   # ##  ## ##  ##
    ########  ## ##   ##  #### #    ##     ##  ## ##  ##
    # ### ##  ## ##   ##  # ####    ##     ##  ## ##  ##
    #  #  ## #######  ##  #  ###    ##     #####  #####
    #     ## ##   ##  ##  #   ## ## ##   # ##     ##
    #     ## ##   ## #### #    # ##  ####  ##     ##

Abstract:

    This module contains the driver initializtion code.

Author:

    Wesley Witt (wesw) 23-Jan-2002

Environment:

    Kernel mode only.

Notes:


--*/

#include "internal.h"


#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,DriverEntry)
#pragma alloc_text(PAGE,WdSystemControl)
#pragma alloc_text(PAGE,WdDefaultDispatch)
#pragma alloc_text(PAGE,WdShutdown)
#endif



//
// Watchdog timer resource table
//
PWATCHDOG_TIMER_RESOURCE_TABLE WdTable;

//
// Control values
//

ULONG ShutdownCountTime;
ULONG RunningCountTime;



NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    Temporary entry point needed to initialize the scsi port driver.

Arguments:

    DriverObject    - Pointer to the driver object created by the system.
    RegistryPath    - String containing the path to the driver's registry data

Return Value:

   STATUS_SUCCESS

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PKEY_VALUE_FULL_INFORMATION KeyInformation = NULL;
    PVOID WdTableTmp;


#if DBG
    //
    // Get the debug level value from the registry
    //

    WdDebugLevel = 0;

    Status = ReadRegistryValue( RegistryPath, L"DebugLevel", &KeyInformation );
    if (NT_SUCCESS(Status) && KeyInformation->Type == REG_DWORD) {
        WdDebugLevel = *(PULONG)((PUCHAR)KeyInformation + KeyInformation->DataOffset);
    }
    if (KeyInformation) {
        ExFreePool( KeyInformation );
    }

    //
    // Get the OS version; this is used by the
    // port driver and the mini-ports to have
    // OS dependent code that is dynamic at runtime
    //

    GetOsVersion();

    //
    // Print a banner that includes the
    // OS version and the version/build date
    // of the driver
    //

    PrintDriverVersion( DriverObject );
#endif

    //
    // Read in the registry control values
    //

    Status = ReadRegistryValue( RegistryPath, L"RunningCountTime", &KeyInformation );
    if (NT_SUCCESS(Status) && KeyInformation->Type == REG_DWORD) {
        RunningCountTime = *(PULONG)((PUCHAR)KeyInformation + KeyInformation->DataOffset);
    }
    if (KeyInformation) {
        ExFreePool( KeyInformation );
    }

    Status = ReadRegistryValue( RegistryPath, L"ShutdownCountTime", &KeyInformation );
    if (NT_SUCCESS(Status) && KeyInformation->Type == REG_DWORD) {
        ShutdownCountTime = *(PULONG)((PUCHAR)KeyInformation + KeyInformation->DataOffset);
    }
    if (KeyInformation) {
        ExFreePool( KeyInformation );
    }

    //
    // Set up the device driver entry points.
    //

    for (ULONG i=0; i<=IRP_MJ_MAXIMUM_FUNCTION; i++) {
        DriverObject->MajorFunction[i] = WdDefaultDispatch;
    }


    //
    // Set up the device driver's pnp-power routine & add routine
    //

    DriverObject->DriverExtension->AddDevice = WdAddDevice;

    //
    // Get a copy of the watchdog ACPI fixed table
    //

    WdTableTmp = (PVOID) WdGetAcpiTable( WDTT_SIGNATURE );
    if (WdTableTmp) {

        DriverObject->MajorFunction[IRP_MJ_PNP] = WdPnp;
        DriverObject->MajorFunction[IRP_MJ_POWER] = WdPower;
        DriverObject->MajorFunction[IRP_MJ_SHUTDOWN] = WdShutdown;
        DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = WdSystemControl;

        WdTable = (PWATCHDOG_TIMER_RESOURCE_TABLE) ExAllocatePool( NonPagedPool, sizeof(WATCHDOG_TIMER_RESOURCE_TABLE) );
        if (WdTable == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlCopyMemory( WdTable, WdTableTmp, sizeof(WATCHDOG_TIMER_RESOURCE_TABLE) );

        //
        // Validate the registry settings
        //

        if (RunningCountTime) {
            RunningCountTime = ConvertTimeoutFromMilliseconds( WdTable->Units, RunningCountTime );
            if (RunningCountTime > WdTable->MaxCount) {
                RunningCountTime = WdTable->MaxCount;
            }
        }

        if (ShutdownCountTime) {
            ShutdownCountTime = ConvertTimeoutFromMilliseconds( WdTable->Units, ShutdownCountTime );
            if (ShutdownCountTime > WdTable->MaxCount) {
                ShutdownCountTime = WdTable->MaxCount;
            }
        }
    }
    return STATUS_SUCCESS;
}


NTSTATUS
WdDefaultDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the default dispatch which passes down to the next layer.

Arguments:

    DeviceObject    - Supplies the device object.
    Irp             - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    UNREFERENCED_PARAMETER(DeviceObject);
    return CompleteRequest( Irp, STATUS_INVALID_DEVICE_REQUEST, 0 );
}


NTSTATUS
WdSystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    IRP_MJ_SYSTEM_CONTROL dispatch routine. Currently, we don't handle
    this. So, if this is FDO just pass it to the lower driver. If this
    is PDO complete the irp with changing the irp status.

Arguments:

    DeviceObject - a pointer to the object that represents the device that I/O is to be done on.
    Irp          - a pointer to the I/O Request Packet for this request.

Return Value:

--*/
{
    PDEVICE_EXTENSION DeviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;


    IoSkipCurrentIrpStackLocation( Irp );
    return IoCallDriver( DeviceExtension->TargetObject, Irp );
}


NTSTATUS
WdShutdown(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called only rarely by the I/O system; it's mainly
    for layered drivers to call.  All it does is complete the IRP
    successfully.

Arguments:

    DeviceObject - a pointer to the object that represents the device that I/O is to be done on.
    Irp          - a pointer to the I/O Request Packet for this request.

Return Value:

    Always returns STATUS_SUCCESS, since this is a null operation.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PDEVICE_EXTENSION DeviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);

    return ForwardRequest( Irp, DeviceExtension->TargetObject );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serveravailability\watchdog\health.cpp ===
/*++

Copyright (c) 1991 - 2002 Microsoft Corporation

Module Name:

    ##   ## #####   ###   ##    ###### ##   ##     ####  #####  #####
    ##   ## ##      ###   ##      ##   ##   ##    ##   # ##  ## ##  ##
    ##   ## ##     ## ##  ##      ##   ##   ##    ##     ##  ## ##  ##
    ####### #####  ## ##  ##      ##   #######    ##     ##  ## ##  ##
    ##   ## ##    ####### ##      ##   ##   ##    ##     #####  #####
    ##   ## ##    ##   ## ##      ##   ##   ## ## ##   # ##     ##
    ##   ## ##### ##   ## #####   ##   ##   ## ##  ####  ##     ##

Abstract:

    This module implements the system health monitoring
    functions for the watchdog driver.

Author:

    Wesley Witt (wesw) 23-Jan-2002

Environment:

    Kernel mode only.

Notes:

--*/

#include "internal.h"



NTSTATUS
WdInitializeSystemHealth(
    PSYSTEM_HEALTH_DATA Health
    )

/*++

Routine Description:

    This function is called to initialize the system
    health monitoring functions in the watchdog driver.

Arguments:

    Health - Pointer to a health data structure that is used
      for input and output of data to the health monitoring.

Return Value:

    If we successfully create a device object, STATUS_SUCCESS is
    returned.  Otherwise, return the appropriate error code.

Notes:

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    SYSTEM_BASIC_INFORMATION si;


    RtlZeroMemory( Health, sizeof(SYSTEM_HEALTH_DATA) );

    Status = ZwQuerySystemInformation(
        SystemBasicInformation,
        &si,
        sizeof(SYSTEM_BASIC_INFORMATION),
        NULL
        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    Health->CpuCount = si.NumberOfProcessors;
    Health->ProcInfoSize = sizeof(SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION) * Health->CpuCount;

    Health->ProcInfoPrev = (PSYSTEM_PROCESSOR_PERFORMANCE_INFORMATION) ExAllocatePool( NonPagedPool, Health->ProcInfoSize );
    if (Health->ProcInfoPrev == NULL) {
        return STATUS_NO_MEMORY;
    }

    Health->ProcInfo = (PSYSTEM_PROCESSOR_PERFORMANCE_INFORMATION) ExAllocatePool( NonPagedPool, Health->ProcInfoSize );
    if (Health->ProcInfo == NULL) {
        return STATUS_NO_MEMORY;
    }

    RtlZeroMemory( Health->ProcInfo, Health->ProcInfoSize );
    RtlZeroMemory( Health->ProcInfoPrev, Health->ProcInfoSize );

    Health->HealthyCpuRatio = 10;

    return STATUS_SUCCESS;
}


LONG
GetPercentage(
    LARGE_INTEGER part,
    LARGE_INTEGER total
    )

/*++

Routine Description:

    This function computes a percentage number.

Arguments:

    Health - Pointer to a health data structure that is used
      for input and output of data to the health monitoring.

Return Value:

    If we successfully create a device object, STATUS_SUCCESS is
    returned.  Otherwise, return the appropriate error code.

Notes:

--*/

{

    if (total.HighPart == 0 && total.LowPart == 0) {
        return 100;
    }

    ULONG ul;
    LARGE_INTEGER t1, t2, t3;
    if (total.HighPart == 0) {
        t1 = RtlEnlargedIntegerMultiply(part.LowPart, 100);
        t2 = RtlExtendedLargeIntegerDivide(t1, total.LowPart, &ul);
    } else {
        t1 = RtlExtendedLargeIntegerDivide(total, 100, &ul);
        t2 = RtlLargeIntegerDivide(part, t1, &t3);
    }
    return t2.LowPart;
}


NTSTATUS
WdCollectContextSwitchData(
    PSYSTEM_HEALTH_DATA Health
    )

/*++

Routine Description:

    This function collects context switch data and
    computes an accumulation for use in determining
    system health.

Arguments:

    Health - Pointer to a health data structure that is used
      for input and output of data to the health monitoring.

Return Value:

    If we successfully create a device object, STATUS_SUCCESS is
    returned.  Otherwise, return the appropriate error code.

Notes:

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    SYSTEM_CONTEXT_SWITCH_INFORMATION ContextSwitch;
    LARGE_INTEGER TickCountCurrent;
    LONGLONG TickCountElapsed = 0;


    Status = ZwQuerySystemInformation(
        SystemContextSwitchInformation,
        &ContextSwitch,
        sizeof(SYSTEM_CONTEXT_SWITCH_INFORMATION),
        NULL
        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    KeQueryTickCount( &TickCountCurrent );

    TickCountElapsed = TickCountCurrent.QuadPart - Health->TickCountPrevious;

    if (TickCountElapsed){
        if ((ContextSwitch.ContextSwitches > Health->ContextSwitchesPrevious) &&
            (TickCountCurrent.QuadPart > Health->TickCountPrevious))
        {
            Health->ContextSwitchRate = (LONG)(((ContextSwitch.ContextSwitches - Health->ContextSwitchesPrevious) * 1000) / TickCountElapsed);
            Health->ContextSwitchRate = Health->ContextSwitchRate / Health->CpuCount;
        }
        Health->ContextSwitchesPrevious = ContextSwitch.ContextSwitches;
        Health->TickCountPrevious = TickCountCurrent.QuadPart;
    }

    return STATUS_SUCCESS;
}


NTSTATUS
WdCollectCpuData(
    PSYSTEM_HEALTH_DATA Health
    )

/*++

Routine Description:

    This function collects CPU data and
    computes an accumulation for use in determining
    system health.

Arguments:

    Health - Pointer to a health data structure that is used
      for input and output of data to the health monitoring.

Return Value:

    If we successfully create a device object, STATUS_SUCCESS is
    returned.  Otherwise, return the appropriate error code.

Notes:

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG i;
    LARGE_INTEGER cpuIdleTime   = {0};
    LARGE_INTEGER cpuUserTime   = {0};
    LARGE_INTEGER cpuKernelTime = {0};
    LARGE_INTEGER cpuBusyTime   = {0};
    LARGE_INTEGER cpuTotalTime  = {0};
    LARGE_INTEGER sumBusyTime   = {0};
    LARGE_INTEGER sumTotalTime  = {0};


    Status = ZwQuerySystemInformation(
        SystemProcessorPerformanceInformation,
        Health->ProcInfo,
        Health->ProcInfoSize,
        NULL
        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    for (i=0; i<Health->CpuCount; i++) {

        cpuIdleTime   = RtlLargeIntegerSubtract( Health->ProcInfo[i].IdleTime, Health->ProcInfoPrev[i].IdleTime );
        cpuUserTime   = RtlLargeIntegerSubtract( Health->ProcInfo[i].UserTime, Health->ProcInfoPrev[i].UserTime );
        cpuKernelTime = RtlLargeIntegerSubtract( Health->ProcInfo[i].KernelTime, Health->ProcInfoPrev[i].KernelTime );

        cpuTotalTime  = RtlLargeIntegerAdd( cpuUserTime, cpuKernelTime );
        cpuBusyTime   = RtlLargeIntegerSubtract( cpuTotalTime, cpuIdleTime );

        sumBusyTime = RtlLargeIntegerAdd( sumBusyTime, cpuBusyTime );
        sumTotalTime = RtlLargeIntegerAdd( sumTotalTime, cpuTotalTime );

    }

    Health->CPUTime = GetPercentage(sumBusyTime, sumTotalTime);

    RtlCopyMemory( Health->ProcInfoPrev, Health->ProcInfo, Health->ProcInfoSize );

    return STATUS_SUCCESS;
}


BOOLEAN
WdCheckSystemHealth(
    PSYSTEM_HEALTH_DATA Health
    )

/*++

Routine Description:

    This function determines if the system is in a healthy
    state.

Arguments:

    Health - Pointer to a health data structure that is used
      for input and output of data to the health monitoring.

Return Value:

    If we successfully create a device object, STATUS_SUCCESS is
    returned.  Otherwise, return the appropriate error code.

Notes:

--*/

{
    NTSTATUS Status;
    BOOLEAN rVal = FALSE;


    //
    // return TRUE always because we have not yet decided
    // how the system health is really supposed to be
    // computed.
    //

    return TRUE;

    __try {

        Status = WdCollectContextSwitchData( Health );
        if (!NT_SUCCESS(Status)) {
            DebugPrint(( 0xffffffff, "WdCollectContextSwitchData failed [0x%08x]\n", Status ));
            __leave;
        }

        Status = WdCollectCpuData( Health );
        if (!NT_SUCCESS(Status)) {
            DebugPrint(( 0xffffffff, "WdCollectCpuData failed [0x%08x]\n", Status ));
            __leave;
        }

        if (Health->CPUTime) {
            Health->ContextCpuRatio = Health->ContextSwitchRate / Health->CPUTime;
            if (Health->ContextCpuRatio < Health->HealthyCpuRatio) {
                __leave;
            }

            rVal = TRUE;
        }

    } __finally {

    }

    DebugPrint(( 0xffffffff, "context-switch=[%d] cpu=[%d] ratio=[%d%s\n",
        Health->ContextSwitchRate,
        Health->CPUTime,
        Health->ContextCpuRatio,
        rVal == TRUE ? "*]" : "]"
        ));

    return rVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serveravailability\watchdog\timer.cpp ===
/*++

Copyright (c) 1991 - 2002 Microsoft Corporation

Module Name:

    ###### #### ##    ## ##### #####      ####  #####  #####
      ##    ##  ###  ### ##    ##  ##    ##   # ##  ## ##  ##
      ##    ##  ######## ##    ##  ##    ##     ##  ## ##  ##
      ##    ##  # ### ## ##### #####     ##     ##  ## ##  ##
      ##    ##  #  #  ## ##    ####      ##     #####  #####
      ##    ##  #     ## ##    ## ##  ## ##   # ##     ##
      ##   #### #     ## ##### ##  ## ##  ####  ##     ##

Abstract:

    This module implements the software watchdog timer
    component.  The timer's responsibility is to simply
    ping the hardware timer if it is determined that the
    system is in a healthy state.

Author:

    Wesley Witt (wesw) 1-Mar-2002

Environment:

    Kernel mode only.

Notes:

--*/

#include "internal.h"



VOID
PingWatchdogTimer(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN BOOLEAN LockResources
    )

/*++

Routine Description:

    This function pings the hardware watchdog timer
    device.  The ping occurs only if the system
    health is determined to be good.

Arguments:

    DeviceExtension - Pointer to a device extension object

    LockResources - Specifies whether the hardware resources
      are to be locked for exclusive access.

Return Value:

    None.

Notes:

--*/

{
    BOOLEAN b;
    KLOCK_QUEUE_HANDLE LockHandle;
    LARGE_INTEGER DueTime;
    ULONG Control;


    b = WdCheckSystemHealth( &DeviceExtension->Health );
    if (b) {

        if (LockResources) {
            KeAcquireInStackQueuedSpinLockAtDpcLevel( &DeviceExtension->DeviceLock, &LockHandle );
        }

        Control = READ_REGISTER_ULONG( DeviceExtension->ControlRegisterAddress );
        SETBITS( Control, WATCHDOG_CONTROL_TRIGGER );
        WRITE_REGISTER_ULONG( DeviceExtension->ControlRegisterAddress, Control );

        if (LockResources) {
            KeReleaseInStackQueuedSpinLockFromDpcLevel( &LockHandle );
        }

        DueTime.QuadPart = -((LONGLONG)DeviceExtension->DpcTimeout);
        KeSetTimer( &DeviceExtension->Timer, DueTime, &DeviceExtension->TimerDpc );
    }
}


VOID
WdTimerDpc(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:

    This is the function is called when the DPC timer
    expires.  The hardware timer is simply pinged at
    this time.

Arguments:

    Dpc - Pointer to the kernel DPC object

    DeferredContext - Really a device extension

    SystemArgument1 - unused

    SystemArgument2 - unused

Return Value:

    None.

Notes:

--*/

{
    PDEVICE_EXTENSION DeviceExtension = (PDEVICE_EXTENSION)DeferredContext;
    PingWatchdogTimer( DeviceExtension, TRUE );
}


NTSTATUS
WdInitializeSoftwareTimer(
    PDEVICE_EXTENSION DeviceExtension
    )

/*++

Routine Description:

    This function initializes the software DPC timer.

Arguments:

    DeviceExtension - Pointer to a device extension object

Return Value:

    If we successfully create a device object, STATUS_SUCCESS is
    returned.  Otherwise, return the appropriate error code.

Notes:

--*/

{
    DeviceExtension->DpcTimeout = ConvertTimeoutToMilliseconds(
        WdTable->Units, DeviceExtension->HardwareTimeout >> 2 ) * 10000;

    WdInitializeSystemHealth( &DeviceExtension->Health );

    KeInitializeTimer( &DeviceExtension->Timer );
    KeInitializeDpc( &DeviceExtension->TimerDpc, WdTimerDpc, DeviceExtension );

    PingWatchdogTimer( DeviceExtension, FALSE );

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serveravailability\watchdog\power.cpp ===
/*++

Copyright (c) 1991 - 2001 Microsoft Corporation

Module Name:

    #####   #####  ##  #  ## ##### #####      ####  #####  #####
    ##  ## ##   ## ## ### ## ##    ##  ##    ##   # ##  ## ##  ##
    ##  ## ##   ## ## ### ## ##    ##  ##    ##     ##  ## ##  ##
    ##  ## ##   ## ## # # ## ##### #####     ##     ##  ## ##  ##
    #####  ##   ##  ### ###  ##    ####      ##     #####  #####
    ##     ##   ##  ### ###  ##    ## ##  ## ##   # ##     ##
    ##      #####   ##   ##  ##### ##  ## ##  ####  ##     ##

Abstract:

    This module process all power management IRPs.

Author:

    Wesley Witt (wesw) 1-Oct-2001

Environment:

    Kernel mode only.

Notes:


--*/

#include "internal.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,WdPower)
#endif



NTSTATUS
WdPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

Arguments:

    DeviceObject - a pointer to the object that represents the device
    that I/O is to be done on.

    Irp - a pointer to the I/O Request Packet for this request.

Return Value:

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PDEVICE_EXTENSION DeviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);
    ULONG TimeoutValue;


    switch (IrpSp->MinorFunction) {
        case IRP_MN_WAIT_WAKE:
        case IRP_MN_POWER_SEQUENCE:
        case IRP_MN_QUERY_POWER:
            Status = STATUS_SUCCESS;
            break;

        case IRP_MN_SET_POWER:
            switch (IrpSp->Parameters.Power.State.SystemState) {
                case PowerSystemSleeping1:
                    //
                    // The system is being suspended
                    //
                    WdHandlerStopTimer( DeviceExtension );
                    break;

                case PowerSystemHibernate:
                    //
                    // The system is hibernating
                    //
                    WdHandlerStopTimer( DeviceExtension );
                    break;

                case PowerSystemWorking:
                    //
                    // The system is waking up from suspend/hibernate
                    //
                    WdHandlerStartTimer( DeviceExtension );
                    break;

                case PowerSystemShutdown:
                    //
                    // The system is shutting down normally
                    //
                    if (ShutdownCountTime > MIN_TIMEOUT_VALUE) {
                        TimeoutValue = ShutdownCountTime;
                    } else {
                        TimeoutValue = (ULONG)DeviceExtension->MaxCount;
                    }
                    WdHandlerSetTimeoutValue( DeviceExtension, TimeoutValue, TRUE );
                    switch (IrpSp->Parameters.Power.ShutdownType) {
                        case PowerActionShutdownOff:
                            TimeoutValue = 1;
                            break;

                        case PowerActionShutdownReset:
                            TimeoutValue = 0;
                            break;
                    }
                    WdHandlerSetTriggerAction( DeviceExtension, TimeoutValue );
                    break;
            }
            Status = STATUS_SUCCESS;
            break;

        default:
            Status = Irp->IoStatus.Status;
            break;
    }

    Irp->IoStatus.Status = Status;
    PoStartNextPowerIrp(Irp);
    IoSkipCurrentIrpStackLocation( Irp );
    return PoCallDriver( DeviceExtension->TargetObject, Irp );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\bulltlp3\bulltlp3.h ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    scrcp8t.h

Abstract:

    smartcard TLP3 serial miniport defines and structures

Author:

    Klaus U. Schutz

Revision History:

--*/


#ifndef _BULLTLP3_
#define _BULLTLP3_

#define DRIVER_NAME "BULLTLP3"
#define SMARTCARD_POOL_TAG '3BCS'

#include <ntddk.h>
#include <ntddser.h>

#include "smclib.h"
#include "tlp3log.h"

#define MAXIMUM_SERIAL_READERS  4
#define SMARTCARD_READ          SCARD_CTL_CODE(1000)
#define SMARTCARD_WRITE         SCARD_CTL_CODE(1001)

#define READ_INTERVAL_TIMEOUT_DEFAULT       1000
#define READ_TOTAL_TIMEOUT_CONSTANT_DEFAULT 3000

#define READ_INTERVAL_TIMEOUT_ATR           0
#define READ_TOTAL_TIMEOUT_CONSTANT_ATR     50

#define READER_CMD_POWER_DOWN   'O'
#define READER_CMD_COLD_RESET   'C'
#define READER_CMD_WARM_RESET   'W'

#define SIM_IO_TIMEOUT          0x00000001
#define SIM_ATR_TRASH           0x00000002
#define SIM_WRONG_STATE         0x00000004
#define SIM_INVALID_STATE       0x00000008
#define SIM_LONG_RESET_TIMEOUT  0x00000010
#define SIM_LONG_IO_TIMEOUT     0x00000020

#define DEBUG_SIMULATION    DEBUG_ERROR


typedef enum _READER_POWER_STATE {
    PowerReaderUnspecified = 0,
    PowerReaderWorking,
    PowerReaderOff
} READER_POWER_STATE, *PREADER_POWER_STATE;

typedef struct _SERIAL_READER_CONFIG {

    // flow control
    SERIAL_HANDFLOW HandFlow;           

    // special characters
    SERIAL_CHARS SerialChars;

    // read/write timeouts
    SERIAL_TIMEOUTS Timeouts;           

    // Baudrate for reader
    SERIAL_BAUD_RATE BaudRate;          

    // Stop bits, parity configuration
    SERIAL_LINE_CONTROL LineControl;    

    // Event serial reader uses to signal insert/removal
    ULONG SerialWaitMask;

} SERIAL_READER_CONFIG, *PSERIAL_READER_CONFIG;

typedef struct _DEVICE_EXTENSION {

    // Our smart card extension
    SMARTCARD_EXTENSION SmartcardExtension;

    // The current number of io-requests
    LONG IoCount;
    
    // Used to signal that the reader is able to process reqeusts
    KEVENT ReaderStarted;
    
    // Used to signal the the reader has been closed
    LONG ReaderOpen;

    // The pnp device name of our smart card reader
    UNICODE_STRING PnPDeviceName;

    KSPIN_LOCK SpinLock;

    // A worker thread that closes the serial driver
    PIO_WORKITEM CloseSerial;

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

//
// Define the reader specific portion of the smart card extension
//
typedef struct _READER_EXTENSION {

    // DeviceObject pointer to serial port
    PDEVICE_OBJECT AttachedDeviceObject;

    // Used to signal that the connection to the serial driver has been closed
    KEVENT SerialCloseDone;

    // This is used for CardTracking
    PIRP    SerialStatusIrp;

    // IoRequest to be send to serial driver
    ULONG   SerialIoControlCode;

    // Flag that indicates we're getting the ModemStatus (used in a DPC)
    BOOLEAN GetModemStatus;

    // Variable used to receive the modem status
    ULONG   ModemStatus;

    // Flag that indicates that the caller requests a power-down or a reset
    BOOLEAN PowerRequest;

    SERIAL_READER_CONFIG SerialConfigData;

    // Saved card state for hibernation/sleeping modes.
    BOOLEAN CardPresent;

    // Current reader power state.
    READER_POWER_STATE ReaderPowerState;

#ifdef SIMULATION
    ULONG SimulationLevel;
#endif

} READER_EXTENSION, *PREADER_EXTENSION;

#define READER_EXTENSION(member) \
    (SmartcardExtension->ReaderExtension->member)
#define READER_EXTENSION_L(member) \
    (smartcardExtension->ReaderExtension->member)
#define ATTACHED_DEVICE_OBJECT \
    deviceExtension->SmartcardExtension.ReaderExtension->AttachedDeviceObject

//
// Prototypes
//
NTSTATUS
DriverEntry(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PUNICODE_STRING RegistryPath
    );

NTSTATUS
TLP3PnP(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP Irp
    );

NTSTATUS
TLP3AddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );

NTSTATUS
TLP3CreateClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
TLP3CreateDevice(
    IN  PDRIVER_OBJECT DriverObject,
    OUT PDEVICE_OBJECT *DeviceObject
    );

NTSTATUS
TLP3SystemControl(
    PDEVICE_OBJECT DeviceObject,
    PIRP        Irp
    );

NTSTATUS
TLP3DeviceControl(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

VOID
TLP3RemoveDevice( 
    PDEVICE_OBJECT DeviceObject
    );

VOID
TLP3DriverUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
TLP3ConfigureSerialPort(
    PSMARTCARD_EXTENSION SmartcardExtension
    );

NTSTATUS
TLP3SerialIo(
    PSMARTCARD_EXTENSION SmartcardExtension
    );

NTSTATUS 
TLP3StartSerialEventTracking(
    PSMARTCARD_EXTENSION SmartcardExtension
    );

NTSTATUS
TLP3SerialEvent(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PSMARTCARD_EXTENSION SmartcardExtension
    );

NTSTATUS
TLP3Cleanup(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
TLP3ReaderPower(
    PSMARTCARD_EXTENSION SmartcardExtension
    );

NTSTATUS
TLP3SetProtocol(
    PSMARTCARD_EXTENSION SmartcardExtension
    );

NTSTATUS
TLP3Transmit(
    PSMARTCARD_EXTENSION SmartcardExtension
    );

NTSTATUS
TLP3CardTracking(
    PSMARTCARD_EXTENSION SmartcardExtension
    );

NTSTATUS
TLP3VendorIoctl(
    PSMARTCARD_EXTENSION SmartcardExtension
    );

NTSTATUS
TLP3Cancel(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS 
TLP3CallSerialDriver(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP Irp
    );

NTSTATUS
TLP3TransmitT0(
    PSMARTCARD_EXTENSION SmartcardExtension
    );

NTSTATUS
TLP3Power (
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp
    );

VOID
TLP3CompleteCardTracking(
    IN PSMARTCARD_EXTENSION SmartcardExtension
    );

VOID 
TLP3CloseSerialPort(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    );

VOID
TLP3StopDevice(
    IN PDEVICE_OBJECT DeviceObject
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serveravailability\watchdog\util.cpp ===
/*++

Copyright (c) 1991 - 2001 Microsoft Corporation

Module Name:

    ##  ## ###### #### ##        ####  #####  #####
    ##  ##   ##    ##  ##       ##   # ##  ## ##  ##
    ##  ##   ##    ##  ##       ##     ##  ## ##  ##
    ##  ##   ##    ##  ##       ##     ##  ## ##  ##
    ##  ##   ##    ##  ##       ##     #####  #####
    ##  ##   ##    ##  ##    ## ##   # ##     ##
     ####    ##   #### ##### ##  ####  ##     ##

Abstract:

    Utility driver functions.

Author:

    Wesley Witt (wesw) 23-Jan-2002

Environment:

    Kernel mode only.

Notes:


--*/

#include "internal.h"
#include <ntimage.h>
#include <stdarg.h>

#if DBG
ULONG WdDebugLevel;
#endif

ULONG OsMajorVersion;
ULONG OsMinorVersion;


NTSTATUS
CompleteRequest(
    PIRP Irp,
    NTSTATUS Status,
    ULONG_PTR Information
    )

/*++

Routine Description:

   This routine completes as outstanding I/O request.

Arguments:

   Irp                  - Pointer to an IRP structure that describes the requested I/O operation.
   Status               - NT status value
   Information          - Informational, request specific data

Return Value:

   NT status code.

--*/

{
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);
    KIRQL CancelIrql;


    if (IrpSp->MajorFunction == IRP_MJ_READ || IrpSp->MajorFunction == IRP_MJ_WRITE) {
        IoAcquireCancelSpinLock( &CancelIrql );
        IoSetCancelRoutine( Irp, NULL );
        IoReleaseCancelSpinLock( CancelIrql );
    }

    Irp->IoStatus.Information = Information;
    Irp->IoStatus.Status = Status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    return Status;
}


NTSTATUS
ForwardRequest(
    IN PIRP Irp,
    IN PDEVICE_OBJECT TargetObject
    )

/*++

Routine Description:

   This routine forwards the IRP to another driver.

Arguments:

   Irp                  - Pointer to an IRP structure that describes the requested I/O operation.
   TargetObject         - Target device object to receive the request packet

Return Value:

   NT status code.

--*/

{
    IoSkipCurrentIrpStackLocation( Irp );
    return IoCallDriver( TargetObject, Irp );
}


VOID
WdDebugPrint(
    IN ULONG DebugLevel,
    IN PSTR DebugMessage,
    IN ...
    )

/*++

Routine Description:

   This routine prints a formatted string to the debugger.

Arguments:

   DebugLevel       - Debug level that controls when a message is printed
   DebugMessage     - String that is printed
   ...              - Arguments that are used by the DebugMessage

Return Value:

   None.

--*/

{
    va_list arg_ptr;
    char buf[512];
    char *s = buf;



#if DBG
    if ((DebugLevel != 0xffffffff) && ((WdDebugLevel == 0) || ((WdDebugLevel & DebugLevel) == 0))) {
        return;
    }
#endif

    va_start( arg_ptr, DebugMessage );
    strcpy( s, "WD: " );
    s += strlen(s);
    _vsnprintf( s, sizeof(buf)-1-strlen(s), DebugMessage, arg_ptr );
    DbgPrint( buf );
}


#if DBG

VOID
GetOsVersion(
    VOID
    )

/*++

Routine Description:

   This routine gets the current OS version information

Arguments:

    None.

Return Value:

    None.

--*/

{
    RTL_OSVERSIONINFOW VersionInformation;

    VersionInformation.dwOSVersionInfoSize = sizeof(RTL_OSVERSIONINFOW);
    RtlGetVersion( &VersionInformation );
    OsMajorVersion = VersionInformation.dwMajorVersion;
    OsMinorVersion = VersionInformation.dwMinorVersion;
}


VOID
FormatTime(
    ULONG TimeStamp,
    PSTR  TimeBuf
    )

/*++

Routine Description:

   This routine formats a timestamp word into a string.

Arguments:

   TimeStamp    - Timestamp word
   TimeBuf      - Buffer to place the resulting string

Return Value:

   None.

--*/

{
    static char    mnames[] = { "JanFebMarAprMayJunJulAugSepOctNovDec" };
    LARGE_INTEGER  MyTime;
    TIME_FIELDS    TimeFields;


    RtlSecondsSince1970ToTime( TimeStamp, &MyTime );
    ExSystemTimeToLocalTime( &MyTime, &MyTime );
    RtlTimeToTimeFields( &MyTime, &TimeFields );

    strncpy( TimeBuf, &mnames[(TimeFields.Month - 1) * 3], 3 );
    sprintf(
        &TimeBuf[3],
        " %02d, %04d @ %02d:%02d:%02d",
        TimeFields.Day,
        TimeFields.Year,
        TimeFields.Hour,
        TimeFields.Minute,
        TimeFields.Second
        );
}


VOID
PrintDriverVersion(
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

   This routine locates the NT image headers from the
   base of a loaded driver.

Arguments:

   DeviceType       - Miniport device type (see saio.h for the enumeration)
   DriverObject     - Pointer to the DRIVER_OBJECT structure

Return Value:

   None.

--*/

{
    PIMAGE_NT_HEADERS NtHeaders;
    ULONG TimeStamp;
    CHAR buf[32];


    NtHeaders = RtlpImageNtHeader( DriverObject->DriverStart );
    if (NtHeaders) {
        TimeStamp = NtHeaders->FileHeader.TimeDateStamp;
        FormatTime( TimeStamp, buf );
    }
}

#endif


NTSTATUS
WdSignalCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Event
    )

/*++

Routine Description:

   This routine is used to signal the completion of an
   I/O request and is used ONLY by CallLowerDriverAndWait.

Arguments:

   DeviceObject         - Pointer to the miniport's device object
   Irp                  - I/O request packet
   Event                - Event to be signaled when the I/O is completed

Return Value:

   NT status code

--*/

{
    KeSetEvent( (PKEVENT)Event, IO_NO_INCREMENT, FALSE );
    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
CallLowerDriverAndWait(
    IN PIRP Irp,
    IN PDEVICE_OBJECT TargetObject
    )

/*++

Routine Description:

   This routine calls a lower driver and waits for the I/O to complete.

Arguments:

   Irp                  - I/O request packet
   TargetObject         - Pointer to the target device object

Return Value:

   NT status code

--*/

{
    KEVENT event;

    KeInitializeEvent( &event, NotificationEvent, FALSE );
    IoCopyCurrentIrpStackLocationToNext( Irp );
    IoSetCompletionRoutine( Irp, WdSignalCompletion, &event, TRUE, TRUE, TRUE );
    IoCallDriver( TargetObject, Irp );
    KeWaitForSingleObject( &event, Executive, KernelMode, FALSE, NULL );
    return Irp->IoStatus.Status;
}


NTSTATUS
OpenParametersRegistryKey(
    IN PUNICODE_STRING RegistryPath,
    IN ULONG AccessMode,
    OUT PHANDLE RegistryHandle
    )

/*++

Routine Description:

    This routine opens the driver's paramaters
    registry key for I/O.

Arguments:

    RegistryPath - Full path to the root of the driver's
      registry tree.

    AccessMode - Specifies how the handle is to be opened (READ/WRITE/etc).

    RegistryHandle - Output parameter that receives the registry handle.

Return Value:

   NT status code

--*/

{
    NTSTATUS status;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING unicodeString;
    HANDLE serviceKey = NULL;


    __try {

        InitializeObjectAttributes(
            &objectAttributes,
            RegistryPath,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );

        status = ZwOpenKey(
            &serviceKey,
            AccessMode,
            &objectAttributes
            );
        if (!NT_SUCCESS(status)) {
            ERROR_RETURN( "ZwOpenKey failed", status );
        }

        RtlInitUnicodeString( &unicodeString, L"Parameters" );

        InitializeObjectAttributes(
            &objectAttributes,
            &unicodeString,
            OBJ_CASE_INSENSITIVE,
            serviceKey,
            NULL
            );

        status = ZwOpenKey(
            RegistryHandle,
            AccessMode,
            &objectAttributes
            );
        if (!NT_SUCCESS(status)) {
            ERROR_RETURN( "ZwOpenKey failed", status );
        }

        status = STATUS_SUCCESS;

    } __finally {

        if (serviceKey) {
            ZwClose( serviceKey );
        }

        if (!NT_SUCCESS(status)) {
            if (*RegistryHandle) {
                ZwClose( *RegistryHandle );
            }
        }

    }

    return status;
}


NTSTATUS
CreateParametersRegistryKey(
    IN PUNICODE_STRING RegistryPath,
    OUT PHANDLE parametersKey
    )

/*++

Routine Description:

    This routine creates the driver's paramaters
    registry key for I/O.

Arguments:

    RegistryPath - Full path to the root of the driver's
      registry tree.

    RegistryHandle - Output parameter that receives the registry handle.

Return Value:

   NT status code

--*/

{
    NTSTATUS status;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING unicodeString;
    HANDLE serviceKey = NULL;
    ULONG Disposition;


    __try {

        parametersKey = NULL;

        InitializeObjectAttributes(
            &objectAttributes,
            RegistryPath,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );

        status = ZwOpenKey(
            &serviceKey,
            KEY_READ | KEY_WRITE,
            &objectAttributes
            );
        if (!NT_SUCCESS(status)) {
            ERROR_RETURN( "ZwOpenKey failed", status );
        }

        RtlInitUnicodeString( &unicodeString, L"Parameters" );

        InitializeObjectAttributes(
            &objectAttributes,
            &unicodeString,
            OBJ_CASE_INSENSITIVE,
            serviceKey,
            NULL
            );

        status = ZwCreateKey(
            parametersKey,
            KEY_READ | KEY_WRITE,
            &objectAttributes,
            0,
            NULL,
            REG_OPTION_NON_VOLATILE,
            &Disposition
            );
        if (!NT_SUCCESS(status)) {
            ERROR_RETURN( "ZwCreateKey failed", status );
        }

        status = STATUS_SUCCESS;

    } __finally {

        if (serviceKey) {
            ZwClose( serviceKey );
        }

        if (!NT_SUCCESS(status)) {
            if (parametersKey) {
                ZwClose( parametersKey );
            }
        }

    }

    return status;
}


NTSTATUS
ReadRegistryValue(
    IN PUNICODE_STRING RegistryPath,
    IN PWSTR ValueName,
    OUT PKEY_VALUE_FULL_INFORMATION *KeyInformation
    )

/*++

Routine Description:

   This routine reads a registry arbitrary value from the
   device's parameter registry data.  The necessary memory
   is allocated by this function and must be freed by the caller.

Arguments:

   RegistryPath     - String containing the path to the driver's registry data
   ValueName        - Value name in the registry
   KeyInformation   - Pointer to a PKEY_VALUE_FULL_INFORMATION pointer that is allocated by this function

Return Value:

   NT status code

--*/

{
    NTSTATUS status;
    UNICODE_STRING unicodeString;
    HANDLE parametersKey = NULL;
    ULONG keyValueLength;


    __try {

        *KeyInformation = NULL;

        status = OpenParametersRegistryKey(
            RegistryPath,
            KEY_READ,
            &parametersKey
            );
        if (!NT_SUCCESS(status)) {
            ERROR_RETURN( "OpenParametersRegistryKey failed", status );
        }

        RtlInitUnicodeString( &unicodeString, ValueName );

        status = ZwQueryValueKey(
            parametersKey,
            &unicodeString,
            KeyValueFullInformation,
            NULL,
            0,
            &keyValueLength
            );
        if (status != STATUS_BUFFER_OVERFLOW && status != STATUS_BUFFER_TOO_SMALL) {
            ERROR_RETURN( "ZwQueryValueKey failed", status );
        }

        *KeyInformation = (PKEY_VALUE_FULL_INFORMATION) ExAllocatePool( NonPagedPool, keyValueLength );
        if (*KeyInformation == NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            ERROR_RETURN( "Failed to allocate pool for registry data", status );
        }

        status = ZwQueryValueKey(
            parametersKey,
            &unicodeString,
            KeyValueFullInformation,
            *KeyInformation,
            keyValueLength,
            &keyValueLength
            );
        if (!NT_SUCCESS(status)) {
            ERROR_RETURN( "ZwQueryValueKey failed", status );
        }

        status = STATUS_SUCCESS;

    } __finally {

        if (parametersKey) {
            ZwClose( parametersKey );
        }

        if (!NT_SUCCESS(status)) {
            if (*KeyInformation) {
                ExFreePool( *KeyInformation );
            }
            *KeyInformation = NULL;
        }

    }

    return status;
}


NTSTATUS
WriteRegistryValue(
    IN PUNICODE_STRING RegistryPath,
    IN PWSTR ValueName,
    IN ULONG RegistryType,
    IN PVOID RegistryValue,
    IN ULONG RegistryValueLength
    )

/*++

Routine Description:

   This routine reads a registry arbitrary value from the
   device's parameter registry data.  The necessary memory
   is allocated by this function and must be freed by the caller.

Arguments:

   RegistryPath     - String containing the path to the driver's registry data
   ValueName        - Value name in the registry
   KeyInformation   - Pointer to a PKEY_VALUE_FULL_INFORMATION pointer that is allocated by this function

Return Value:

   NT status code

--*/

{
    NTSTATUS status;
    UNICODE_STRING unicodeString;
    HANDLE parametersKey = NULL;


    __try {

        status = OpenParametersRegistryKey(
            RegistryPath,
            KEY_READ | KEY_WRITE,
            &parametersKey
            );
        if (!NT_SUCCESS(status)) {
            status = CreateParametersRegistryKey(
                RegistryPath,
                &parametersKey
                );
            if (!NT_SUCCESS(status)) {
                ERROR_RETURN( "CreateParametersRegistryKey failed", status );
            }
        }

        RtlInitUnicodeString( &unicodeString, ValueName );

        status = ZwSetValueKey(
            parametersKey,
            &unicodeString,
            0,
            RegistryType,
            RegistryValue,
            RegistryValueLength
            );
        if (!NT_SUCCESS(status)) {
            ERROR_RETURN( "ZwQueryValueKey failed", status );
        }

        status = STATUS_SUCCESS;

    } __finally {

        if (parametersKey) {
            ZwClose( parametersKey );
        }

    }

    return status;
}


NTSTATUS
WriteEventLogEntry (
    IN PDEVICE_EXTENSION DeviceExtension,
    IN ULONG ErrorCode,
    IN PVOID InsertionStrings, OPTIONAL
    IN ULONG StringCount, OPTIONAL
    IN PVOID DumpData, OPTIONAL
    IN ULONG DataSize OPTIONAL
    )

/*++

Routine Description:
    Writes an entry into the system eventlog.

Arguments:

    DeviceExtension - Pointer to a device extension object

    ErrorCode - Eventlog errorcode as specified in eventmsg.mc

    InsertionStrings - String to insert into the eventlog message

    StringCount - Number of InsertionStrings

    DumpData - Additional data to be include in the message

    DataSize - Size of the DumpData

Return Value:

    NT status code

--*/

{
#define ERROR_PACKET_SIZE   sizeof(IO_ERROR_LOG_PACKET)

    NTSTATUS status = STATUS_SUCCESS;
    ULONG totalPacketSize;
    ULONG i, stringSize = 0;
    PWCHAR *strings, temp;
    PIO_ERROR_LOG_PACKET logEntry;
    UNICODE_STRING unicodeString;


    __try {

        //
        // Calculate total string length, including NULL.
        //

        strings = (PWCHAR *) InsertionStrings;

        for (i=0; i<StringCount; i++) {
            RtlInitUnicodeString(&unicodeString, strings[i]);
            stringSize += unicodeString.Length + sizeof(UNICODE_NULL);
        }

        //
        // Calculate total packet size to allocate.  The packet must be
        // at least sizeof(IO_ERROR_LOG_PACKET) and not larger than
        // ERROR_LOG_MAXIMUM_SIZE or the IoAllocateErrorLogEntry call will fail.
        //

        totalPacketSize = ERROR_PACKET_SIZE + DataSize + stringSize;

        if (totalPacketSize >= ERROR_LOG_MAXIMUM_SIZE) {
            ERROR_RETURN( "WriteEventLogEntry: Error Log Entry too large", STATUS_UNSUCCESSFUL );
        }

        //
        // Allocate the error log packet
        //

        logEntry = (PIO_ERROR_LOG_PACKET) IoAllocateErrorLogEntry( DeviceExtension->DeviceObject, (UCHAR)totalPacketSize );
        if (!logEntry) {
            ERROR_RETURN( "IoAllocateErrorLogEntry failed", STATUS_INSUFFICIENT_RESOURCES );
        }

        RtlZeroMemory( logEntry, totalPacketSize );

        //
        // Fill out the packet
        //

        //logEntry->MajorFunctionCode     = 0;
        //logEntry->RetryCount            = 0;
        //logEntry->UniqueErrorValue      = 0;
        //logEntry->FinalStatus           = 0;
        //logEntry->SequenceNumber        = ErrorLogCount++;
        //logEntry->IoControlCode         = 0;
        //logEntry->DeviceOffset.QuadPart = 0;

        logEntry->DumpDataSize          = (USHORT) DataSize;
        logEntry->NumberOfStrings       = (USHORT) StringCount;
        logEntry->EventCategory         = 0x1;
        logEntry->ErrorCode             = ErrorCode;

        if (StringCount) {
            logEntry->StringOffset = (USHORT) (ERROR_PACKET_SIZE + DataSize);
        }

        //
        // Copy Dump Data
        //

        if (DataSize) {
            RtlCopyMemory( (PVOID)logEntry->DumpData, DumpData, DataSize );
        }

        //
        // Copy String Data
        //

        temp = (PWCHAR)((PUCHAR)logEntry + logEntry->StringOffset);

        for (i=0; i<StringCount; i++) {
          PWCHAR  ptr = strings[i];
          //
          // This routine will copy the null terminator on the string
          //
          while ((*temp++ = *ptr++) != UNICODE_NULL);
        }

        //
        // Submit error log packet
        //

        IoWriteErrorLogEntry(logEntry);

    } __finally {


    }

    return status;
}


ULONG
ConvertTimeoutToMilliseconds(
    IN ULONG Units,
    IN ULONG NativeTimeout
    )

/*++

Routine Description:

    Converts a time value that is represented in the native
    format that is specified by the hardware watchdog timer's
    ACPI table entry into a millisecond based value.

Arguments:

    DeviceExtension - Pointer to a device extension object

    NativeTimeout - Native timeout value

Return Value:

    Converted value or zero.

--*/

{
    ULONG Timeout = 0;


    switch (Units) {
        case 0:
            //
            // 1 seconds
            //
            Timeout = NativeTimeout * 1000;
            break;

        case 1:
            //
            // 100 miliseconds
            //
            Timeout = NativeTimeout / 100;
            break;

        case 2:
            //
            // 10 milliseconds
            //
            Timeout = NativeTimeout / 10;
            break;

        case 3:
            //
            // 1 miliseconds
            //
            Timeout = NativeTimeout;
            break;

        default:
            Timeout = 0;
            break;
    }

    return Timeout;
}


ULONG
ConvertTimeoutFromMilliseconds(
    IN ULONG Units,
    IN ULONG UserTimeout
    )

/*++

Routine Description:

    Converts a time value that is represented in milliseconds
    to the native format that is specified by the hardware
    watchdog timer's ACPI table entry.

Arguments:

    DeviceExtension - Pointer to a device extension object

    UserTimeout - Millisecond timeout value.

Return Value:

    Converted value or zero.

--*/

{
    ULONG Timeout = 0;

    switch (Units) {
        case 0:
            //
            // 1 seconds
            //
            Timeout = UserTimeout / 1000;
            break;

        case 1:
            //
            // 100 miliseconds
            //
            Timeout = UserTimeout * 100;
            break;

        case 2:
            //
            // 10 milliseconds
            //
            Timeout = UserTimeout * 10;
            break;

        case 3:
            //
            // 1 miliseconds
            //
            Timeout = UserTimeout;
            break;

        default:
            Timeout = 0;
            break;
    }

    return Timeout;
}


//------------------------------------------------------------------------
//  debugging stuff
//------------------------------------------------------------------------


#if DBG

PCHAR
PnPMinorFunctionString(
    UCHAR MinorFunction
    )

/*++

Routine Description:

   This routine translates a minor function code into a string.

Arguments:

   MinorFunction    - Minor function code

Return Value:

   Pointer to a string representation of the MinorFunction code.

--*/

{
    switch (MinorFunction) {
        case IRP_MN_START_DEVICE:
            return "IRP_MN_START_DEVICE";
        case IRP_MN_QUERY_REMOVE_DEVICE:
            return "IRP_MN_QUERY_REMOVE_DEVICE";
        case IRP_MN_REMOVE_DEVICE:
            return "IRP_MN_REMOVE_DEVICE";
        case IRP_MN_CANCEL_REMOVE_DEVICE:
            return "IRP_MN_CANCEL_REMOVE_DEVICE";
        case IRP_MN_STOP_DEVICE:
            return "IRP_MN_STOP_DEVICE";
        case IRP_MN_QUERY_STOP_DEVICE:
            return "IRP_MN_QUERY_STOP_DEVICE";
        case IRP_MN_CANCEL_STOP_DEVICE:
            return "IRP_MN_CANCEL_STOP_DEVICE";
        case IRP_MN_QUERY_DEVICE_RELATIONS:
            return "IRP_MN_QUERY_DEVICE_RELATIONS";
        case IRP_MN_QUERY_INTERFACE:
            return "IRP_MN_QUERY_INTERFACE";
        case IRP_MN_QUERY_CAPABILITIES:
            return "IRP_MN_QUERY_CAPABILITIES";
        case IRP_MN_QUERY_RESOURCES:
            return "IRP_MN_QUERY_RESOURCES";
        case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
            return "IRP_MN_QUERY_RESOURCE_REQUIREMENTS";
        case IRP_MN_QUERY_DEVICE_TEXT:
            return "IRP_MN_QUERY_DEVICE_TEXT";
        case IRP_MN_FILTER_RESOURCE_REQUIREMENTS:
            return "IRP_MN_FILTER_RESOURCE_REQUIREMENTS";
        case IRP_MN_READ_CONFIG:
            return "IRP_MN_READ_CONFIG";
        case IRP_MN_WRITE_CONFIG:
            return "IRP_MN_WRITE_CONFIG";
        case IRP_MN_EJECT:
            return "IRP_MN_EJECT";
        case IRP_MN_SET_LOCK:
            return "IRP_MN_SET_LOCK";
        case IRP_MN_QUERY_ID:
            return "IRP_MN_QUERY_ID";
        case IRP_MN_QUERY_PNP_DEVICE_STATE:
            return "IRP_MN_QUERY_PNP_DEVICE_STATE";
        case IRP_MN_QUERY_BUS_INFORMATION:
            return "IRP_MN_QUERY_BUS_INFORMATION";
        case IRP_MN_DEVICE_USAGE_NOTIFICATION:
            return "IRP_MN_DEVICE_USAGE_NOTIFICATION";
        case IRP_MN_SURPRISE_REMOVAL:
            return "IRP_MN_SURPRISE_REMOVAL";
        case IRP_MN_QUERY_LEGACY_BUS_INFORMATION:
            return "IRP_MN_QUERY_LEGACY_BUS_INFORMATION";
        default:
            return "IRP_MN_?????";
    }
}

PCHAR
PowerMinorFunctionString(
    UCHAR MinorFunction
    )

/*++

Routine Description:

   This routine translates a minor power function code into a string.

Arguments:

   MinorFunction    - Minor function code

Return Value:

   Pointer to a string representation of the MinorFunction code.

--*/

{
    switch (MinorFunction) {
        case IRP_MN_WAIT_WAKE:
            return "IRP_MN_WAIT_WAKE";
        case IRP_MN_POWER_SEQUENCE:
            return "IRP_MN_POWER_SEQUENCE";
        case IRP_MN_SET_POWER:
            return "IRP_MN_SET_POWER";
        case IRP_MN_QUERY_POWER:
            return "IRP_MN_QUERY_POWER";
        default:
            return "IRP_MN_?????";
    }
}

PCHAR
PowerDeviceStateString(
    DEVICE_POWER_STATE State
    )

/*++

Routine Description:

   This routine translates a power state code into a string.

Arguments:

   State    - State code

Return Value:

   Pointer to a string representation of the state code.

--*/

{
    switch (State) {
        case PowerDeviceUnspecified:
            return "PowerDeviceUnspecified";
        case PowerDeviceD0:
            return "PowerDeviceD0";
        case PowerDeviceD1:
            return "PowerDeviceD1";
        case PowerDeviceD2:
            return "PowerDeviceD2";
        case PowerDeviceD3:
            return "PowerDeviceD3";
        case PowerDeviceMaximum:
            return "PowerDeviceMaximum";
        default:
            return "PowerDevice?????";
    }
}

PCHAR
PowerSystemStateString(
    SYSTEM_POWER_STATE State
    )

/*++

Routine Description:

   This routine translates a power system state code into a string.

Arguments:

   State    - State code

Return Value:

   Pointer to a string representation of the state code.

--*/

{
    switch (State) {
        case PowerSystemUnspecified:
            return "PowerSystemUnspecified";
        case PowerSystemWorking:
            return "PowerSystemWorking";
        case PowerSystemSleeping1:
            return "PowerSystemSleeping1";
        case PowerSystemSleeping2:
            return "PowerSystemSleeping2";
        case PowerSystemSleeping3:
            return "PowerSystemSleeping3";
        case PowerSystemHibernate:
            return "PowerSystemHibernate";
        case PowerSystemShutdown:
            return "PowerSystemShutdown";
        case PowerSystemMaximum:
            return "PowerSystemMaximum";
        default:
            return "PowerSystem?????";
    }
}

PCHAR
IoctlString(
    ULONG IoControlCode
    )

/*++

Routine Description:

   This routine translates an IOCTL code into a string.

Arguments:

   IoControlCode    - I/O control code

Return Value:

   Pointer to a string representation of the I/O control code.

--*/

{
    switch (IoControlCode) {
        case IOCTL_MOUNTDEV_QUERY_DEVICE_NAME:
            return "IOCTL_MOUNTDEV_QUERY_DEVICE_NAME";
        case IOCTL_MOUNTDEV_QUERY_UNIQUE_ID:
            return "IOCTL_MOUNTDEV_QUERY_UNIQUE_ID";
        case IOCTL_MOUNTDEV_QUERY_SUGGESTED_LINK_NAME:
            return "IOCTL_MOUNTDEV_QUERY_SUGGESTED_LINK_NAME";
        case IOCTL_STORAGE_GET_MEDIA_TYPES:
            return "IOCTL_STORAGE_GET_MEDIA_TYPES";
        case IOCTL_DISK_GET_MEDIA_TYPES:
            return "IOCTL_DISK_GET_MEDIA_TYPES";
        case IOCTL_DISK_CHECK_VERIFY:
            return "IOCTL_DISK_CHECK_VERIFY";
        case IOCTL_DISK_GET_DRIVE_GEOMETRY:
            return "IOCTL_DISK_GET_DRIVE_GEOMETRY";
        case IOCTL_DISK_IS_WRITABLE:
            return "IOCTL_DISK_IS_WRITABLE";
        case IOCTL_DISK_VERIFY:
            return "IOCTL_DISK_VERIFY";
        case IOCTL_DISK_GET_DRIVE_LAYOUT:
            return "IOCTL_DISK_GET_DRIVE_LAYOUT";
        case IOCTL_DISK_GET_PARTITION_INFO:
            return "IOCTL_DISK_GET_PARTITION_INFO";
        case IOCTL_DISK_GET_PARTITION_INFO_EX:
            return "IOCTL_DISK_GET_PARTITION_INFO_EX";
        case IOCTL_DISK_GET_LENGTH_INFO:
            return "IOCTL_DISK_GET_LENGTH_INFO";
        case IOCTL_DISK_MEDIA_REMOVAL:
            return "IOCTL_DISK_MEDIA_REMOVAL";
        default:
            return "IOCTL_?????";
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\bulltlp3\tlp3cb.c ===
/*++

Copyright (C) 1997, 98 Microsoft Corporation

Module Name:

    tlp3cb.c

Abstract:

    Callback functions for smart card library

Author:

    Klaus U. Schutz

Environment:                       

    Kernel mode

--*/
                                            
#include <stdio.h> 
#include "bulltlp3.h"

#pragma alloc_text(PAGEABLE, TLP3TransmitT0)
#pragma alloc_text(PAGEABLE, TLP3Transmit)
#pragma alloc_text(PAGEABLE, TLP3VendorIoctl)

NTSTATUS
TLP3ReaderPower(
    PSMARTCARD_EXTENSION SmartcardExtension
    )
/*++

Routine Description:

    The smart card lib requires to have this function. It is called 
    for certain power requests to the card. We do nothing here, because
    this action is performed in the StartIo function.

--*/
{
    ULONG step, waitTime, TdIndex, numTry = 0, minWaitTime;
    NTSTATUS status = STATUS_SUCCESS;
    PSERIAL_STATUS serialStatus;
    KIRQL oldIrql, irql;
    PUCHAR requestBuffer;
    PSERIAL_READER_CONFIG serialConfigData = 
        &SmartcardExtension->ReaderExtension->SerialConfigData;

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!TLP3ReaderPower: Enter (%lx)\n",
        DRIVER_NAME,
        SmartcardExtension->MinorIoControlCode)
        );

    _try {
        
#if defined (DEBUG) && defined (DETECT_SERIAL_OVERRUNS)
        // we have to call GetCommStatus to reset the error condition
        SmartcardExtension->ReaderExtension->SerialIoControlCode =
            IOCTL_SERIAL_GET_COMMSTATUS;
        SmartcardExtension->SmartcardRequest.BufferLength = 0;
        SmartcardExtension->SmartcardReply.BufferLength = 
            sizeof(SERIAL_STATUS);

        status = TLP3SerialIo(SmartcardExtension);
        ASSERT(status == STATUS_SUCCESS);
#endif
        //
        // Set standard parameters for serial port
        // 
        serialConfigData->LineControl.Parity = EVEN_PARITY;
        serialConfigData->LineControl.StopBits = STOP_BITS_2;

        serialConfigData->BaudRate.BaudRate = 
            SmartcardExtension->ReaderCapabilities.DataRate.Default;

        // we set very short timeouts to get the ATR as fast as possible
        serialConfigData->Timeouts.ReadIntervalTimeout = 
            READ_INTERVAL_TIMEOUT_ATR;
        serialConfigData->Timeouts.ReadTotalTimeoutConstant =
            READ_TOTAL_TIMEOUT_CONSTANT_ATR;

        status = TLP3ConfigureSerialPort(SmartcardExtension);

        ASSERT(status == STATUS_SUCCESS);

        if (status != STATUS_SUCCESS) {

            leave;
        }                     

        // We don't send data to the reader, so set Number of bytes to send = 0
        SmartcardExtension->SmartcardRequest.BufferLength = 0;

        // Default number of bytes we expect to get back
        SmartcardExtension->SmartcardReply.BufferLength = 0;

        //
        // Since power down triggers the UpdateSerialStatus function, we have
        // to inform it that we forced the change of the status and not the user
        // (who might have removed and inserted a card)
        //
        // SmartcardExtension->ReaderExtension->PowerRequest = TRUE;

        // purge the serial buffer (it can contain the pnp id of the reader)
        SmartcardExtension->ReaderExtension->SerialIoControlCode =
            IOCTL_SERIAL_PURGE;
        *(PULONG) SmartcardExtension->SmartcardRequest.Buffer =
            SERIAL_PURGE_RXCLEAR | SERIAL_PURGE_TXCLEAR;;
        SmartcardExtension->SmartcardRequest.BufferLength =
            sizeof(ULONG);

        status = TLP3SerialIo(SmartcardExtension);

        ASSERT(status == STATUS_SUCCESS);

        if (status != STATUS_SUCCESS) {

            leave;
        }

        SmartcardExtension->CardCapabilities.ATR.Length = 0;

        for (step = 0; NT_SUCCESS(status); step++) {

            if (SmartcardExtension->MinorIoControlCode == 
                SCARD_WARM_RESET && 
                step == 0) {

                step = 4;           
            }

            switch (step) {

                case 0:
                    // RTS = 0 means reader is in command mode
                    SmartcardExtension->ReaderExtension->SerialIoControlCode =
                        IOCTL_SERIAL_CLR_RTS;
                    //
                    // This is the minimum wait time we have to wait before
                    // we can send commands to the microcontroller.
                    //
                    waitTime = 1000;
                    break;

                case 1:
                    // write power down command to the reader
                    SmartcardExtension->ReaderExtension->SerialIoControlCode =
                        SMARTCARD_WRITE;
                    SmartcardExtension->SmartcardRequest.BufferLength = 1;

                    SmartcardExtension->SmartcardRequest.Buffer[0] = 
                        READER_CMD_POWER_DOWN;

                    waitTime = 100;
                    break;

                case 2:
                    // Read back the echo of the reader
                    SmartcardExtension->ReaderExtension->SerialIoControlCode =
                        SMARTCARD_READ;
                    SmartcardExtension->SmartcardReply.BufferLength = 1;

                    // Wait the recovery time for the microcontroller 
                    waitTime = 1000;
                    break;

                case 3:
                    // set RTS again so the microcontroller can execute the command
                    SmartcardExtension->ReaderExtension->SerialIoControlCode =
                        IOCTL_SERIAL_SET_RTS;
                    waitTime = 10000;
                    break;

                case 4:
                    if (SmartcardExtension->MinorIoControlCode == SCARD_POWER_DOWN) {

                        KeAcquireSpinLock(&SmartcardExtension->OsData->SpinLock,
                                          &irql);
                        if (SmartcardExtension->ReaderCapabilities.CurrentState >
                            SCARD_PRESENT) {
                            
                            SmartcardExtension->ReaderCapabilities.CurrentState = 
                                SCARD_PRESENT;
                        }

                        SmartcardExtension->CardCapabilities.Protocol.Selected = 
                            SCARD_PROTOCOL_UNDEFINED;

                        KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                                          irql);
                        status = STATUS_SUCCESS;                
                        leave;
                    }

                    // clear RTS to switch to command mode
                    SmartcardExtension->ReaderExtension->SerialIoControlCode =
                        IOCTL_SERIAL_CLR_RTS;

                    // Wait the recovery time for the microcontroller 
                    waitTime = 1000;
                    break;

                case 5:
                    // write the appropriate reset command to the reader
                    SmartcardExtension->ReaderExtension->SerialIoControlCode =
                        SMARTCARD_WRITE;
                    SmartcardExtension->SmartcardRequest.BufferLength = 1;
                    switch (SmartcardExtension->MinorIoControlCode) {

                    case SCARD_COLD_RESET:
                        SmartcardExtension->SmartcardRequest.Buffer[0] = 
                            READER_CMD_COLD_RESET;
                        break;

                    case SCARD_WARM_RESET:
                        SmartcardExtension->SmartcardRequest.Buffer[0] = 
                            READER_CMD_WARM_RESET;
                        break;
                    }
                    waitTime = 100;
                    break;

                case 6:
                    // Read back the echo of the reader
                    SmartcardExtension->ReaderExtension->SerialIoControlCode =
                        SMARTCARD_READ;
                    SmartcardExtension->SmartcardReply.BufferLength = 1;

                    //
                    // This is the time we need to wait for the microcontroller
                    // to recover before we can set RTS again
                    //
                    waitTime = 1000;
                    break;

                case 7:
                    // set RTS again so the microcontroller can execute the command
                    SmartcardExtension->ReaderExtension->SerialIoControlCode =
                        IOCTL_SERIAL_SET_RTS;
                    waitTime = 10000; 
                    break;

                case 8:
                    //
                    // We now try to get the ATR as fast as possible.
                    // Therefor we prev. set a very short read timeout and
                    // 'hope' that the card delivered its ATR within this 
                    // short time. To verify the correctness of the ATR we call
                    // SmartcardUpdateCardCapabilities(). If this call returns
                    // with STATUS_SUCCESS we know that the ATR is complete.
                    // Otherwise we read again and append the new data to the 
                    // ATR buffer in the CardCapabilities and try again.
                    //
                    SmartcardExtension->ReaderExtension->SerialIoControlCode = 
                        SMARTCARD_READ;

                    SmartcardExtension->SmartcardReply.BufferLength = 
                        MAXIMUM_ATR_LENGTH - 
                        SmartcardExtension->CardCapabilities.ATR.Length;

                    waitTime = 0;                                     
                    break;

                case 9:
                    if (SmartcardExtension->SmartcardReply.BufferLength != 0) {

                        ASSERT(
                            SmartcardExtension->CardCapabilities.ATR.Length +
                            SmartcardExtension->SmartcardReply.BufferLength <
                            MAXIMUM_ATR_LENGTH
                            );

                        if( SmartcardExtension->CardCapabilities.ATR.Length +
                            SmartcardExtension->SmartcardReply.BufferLength >=
                            MAXIMUM_ATR_LENGTH) {

                            status = STATUS_UNRECOGNIZED_MEDIA;
                            leave;
                        }
                     
                        // we got some ATR bytes. 
                        RtlCopyMemory(
                            SmartcardExtension->CardCapabilities.ATR.Buffer + 
                                SmartcardExtension->CardCapabilities.ATR.Length,
                            SmartcardExtension->SmartcardReply.Buffer,
                            SmartcardExtension->SmartcardReply.BufferLength
                            );

                        SmartcardExtension->CardCapabilities.ATR.Length += 
                            (UCHAR) SmartcardExtension->SmartcardReply.BufferLength;

                        status = SmartcardUpdateCardCapabilities(
                            SmartcardExtension
                            );
                    }

                    if (status != STATUS_SUCCESS && numTry < 25) {

                        if (SmartcardExtension->SmartcardReply.BufferLength != 0) {
                            
                            // Because we received some data, we reset our counter
                            numTry = 0;

                        } else {
                            
                            // ATR is incomplete. Try again to get ATR bytes.
                            numTry += 1;
                        }

                        // continue with step 8
                        step = 7;
                        status = STATUS_TIMEOUT;
                        continue;                       
                    }

                    if (status != STATUS_SUCCESS) {

                        leave;
                    }
                    // No break

                case 10:
                    KeAcquireSpinLock(
                        &SmartcardExtension->OsData->SpinLock,
                        &oldIrql
                        );

                    if (SmartcardExtension->ReaderCapabilities.CurrentState <=
                        SCARD_ABSENT) {

                        status = STATUS_MEDIA_CHANGED;
                    } 

                    KeReleaseSpinLock(
                        &SmartcardExtension->OsData->SpinLock,
                        oldIrql
                        );

                    if (status != STATUS_SUCCESS) {

                        leave;                      
                    }

#ifdef SIMULATION
                    if (SmartcardExtension->ReaderExtension->SimulationLevel &
                        SIM_ATR_TRASH) {

                        ULONG index;
                        LARGE_INTEGER tickCount;

                        KeQueryTickCount(
                            &tickCount
                            );

                        SmartcardExtension->CardCapabilities.ATR.Length = 
                            (UCHAR) tickCount.LowPart % MAXIMUM_ATR_LENGTH;

                        for (index = 0; 
                             index < SmartcardExtension->CardCapabilities.ATR.Length;
                             index++) {

                            SmartcardExtension->CardCapabilities.ATR.Buffer[index] *= 
                                (UCHAR) tickCount.LowPart;
                        }

                        SmartcardDebug(
                            DEBUG_SIMULATION,
                            ("%s!TLP3ReaderPower: SIM ATR trash\n",
                            DRIVER_NAME)
                            );
                    }
#endif

                    // Copy ATR to user space
                    if (SmartcardExtension->IoRequest.ReplyBuffer) {
                
                        RtlCopyMemory(
                            SmartcardExtension->IoRequest.ReplyBuffer,
                            SmartcardExtension->CardCapabilities.ATR.Buffer,
                            SmartcardExtension->CardCapabilities.ATR.Length
                            );

                        // Tell user length of ATR
                        *SmartcardExtension->IoRequest.Information =
                            SmartcardExtension->CardCapabilities.ATR.Length;
                    }

                    //
                    // If the card uses invers convention we need to switch
                    // the serial driver to odd paritiy
                    //
                    if (SmartcardExtension->CardCapabilities.InversConvention) {

                        serialConfigData->LineControl.Parity = ODD_PARITY;
                    }

                    //
                    // If the extra guard time is 255 it means that our
                    // frame we have to expect from the card has only
                    // 1 instead of 2 stop bits 
                    // 1start bit + 8data bits + 1parity + 1stop == 11 etu
                    // see iso 7816-3 6.1.4.4 Extra Guard Time N
                    //
                    if (SmartcardExtension->CardCapabilities.PtsData.StopBits == 1) {

                        serialConfigData->LineControl.StopBits = STOP_BIT_1;      
                    }

                    // Change data rate according to the new settings
                    serialConfigData->BaudRate.BaudRate = 
                        SmartcardExtension->CardCapabilities.PtsData.DataRate;

                    // depending on the protocol set the timeout values
                    if (SmartcardExtension->CardCapabilities.Protocol.Selected &
                        SCARD_PROTOCOL_T1) {

                        // set timeouts
                        serialConfigData->Timeouts.ReadTotalTimeoutConstant =
                            SmartcardExtension->CardCapabilities.T1.BWT / 1000;

                        serialConfigData->Timeouts.ReadIntervalTimeout =  
                            SmartcardExtension->CardCapabilities.T1.CWT / 1000;

                    } else if (SmartcardExtension->CardCapabilities.Protocol.Selected &
                               SCARD_PROTOCOL_T0) {

                        // set timeouts
                        serialConfigData->Timeouts.ReadTotalTimeoutConstant =
                        serialConfigData->Timeouts.ReadIntervalTimeout =  
                            SmartcardExtension->CardCapabilities.T0.WT / 1000;
                    }

                    // Now make some adjustments depending on the system speed
                    minWaitTime = (KeQueryTimeIncrement() / 10000) * 5;

                    if (serialConfigData->Timeouts.ReadTotalTimeoutConstant < 
                        minWaitTime) {

                        serialConfigData->Timeouts.ReadTotalTimeoutConstant = 
                            minWaitTime;            
                    }

                    if (serialConfigData->Timeouts.ReadIntervalTimeout < 
                        minWaitTime) {

                        serialConfigData->Timeouts.ReadIntervalTimeout = 
                            minWaitTime;            
                    }

                    status = TLP3ConfigureSerialPort(SmartcardExtension);

                    ASSERT(status == STATUS_SUCCESS);

                    // We're done anyway, so leave
                    leave;                          
            }

            status = TLP3SerialIo(SmartcardExtension);

            if (!NT_SUCCESS(status)) {

                leave;              
            }

            if (waitTime) {

                LARGE_INTEGER delayPeriod;

                delayPeriod.HighPart = -1;
                delayPeriod.LowPart = waitTime * (-10);

                KeDelayExecutionThread(
                    KernelMode,
                    FALSE,
                    &delayPeriod
                    );
            }
        } 
    }
    _finally {

        if (status == STATUS_TIMEOUT) {

            status = STATUS_UNRECOGNIZED_MEDIA;             
        }

        SmartcardExtension->ReaderExtension->PowerRequest = FALSE;      

#ifdef SIMULATION

        if (SmartcardExtension->ReaderExtension->SimulationLevel & 
            SIM_WRONG_STATE) {

            // inject a wrong state after warm/cold reset
            SmartcardExtension->ReaderCapabilities.CurrentState = 
                SCARD_PRESENT;

            SmartcardDebug(
                DEBUG_SIMULATION,
                ("%s!TLP3ReaderPower: SIM wrong state\n",
                DRIVER_NAME)
                );

        } else if (SmartcardExtension->ReaderExtension->SimulationLevel & 
            SIM_INVALID_STATE) {

            // inject completely invalid state after reset.
            LARGE_INTEGER tickCount;

            KeQueryTickCount(
                &tickCount
                );  

            SmartcardExtension->ReaderCapabilities.CurrentState = 
                (UCHAR) tickCount.LowPart;

            SmartcardDebug(
                DEBUG_SIMULATION,
                ("%s!TLP3ReaderPower: SIM invalid state %ls\n",
                DRIVER_NAME,
                SmartcardExtension->ReaderCapabilities.CurrentState)
                );
        }

        if (SmartcardExtension->ReaderExtension->SimulationLevel & 
            SIM_LONG_RESET_TIMEOUT) {

            // inject a random timeout of max 60 sec.
            LARGE_INTEGER tickCount;

            KeQueryTickCount(
                &tickCount
                );  

            tickCount.LowPart %= 60;

            SmartcardDebug(
                DEBUG_SIMULATION,
                ("%s!TLP3ReaderPower: SIM reset wait %ld\n",
                DRIVER_NAME,
                tickCount.LowPart)
                );

            tickCount.QuadPart *= -10000000;

            KeDelayExecutionThread(
                KernelMode,
                FALSE,
                &tickCount
                );
        }
#endif
    }

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!TLP3ReaderPower: Exit (%lx)\n",
        DRIVER_NAME,
        status)
        );

    return status;
}

NTSTATUS
TLP3SetProtocol(
    PSMARTCARD_EXTENSION SmartcardExtension
    )
/*++

Routine Description:

    The smart card lib requires to have this function. It is called 
    to set a the transmission protocol and parameters. If this function 
    is called with a protocol mask (which means the caller doesn't card 
    about a particular protocol to be set) we first look if we can 
    set T=1 and the T=0

Arguments:

    SmartcardExtension - Pointer to smart card data struct.

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS status;
    KIRQL irql;

    PAGED_CODE();

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!TLP3SetProtocol: Enter\n",
        DRIVER_NAME)
        );

    try {
        
        PUCHAR ptsRequest = SmartcardExtension->SmartcardRequest.Buffer;
        PUCHAR ptsReply = SmartcardExtension->SmartcardReply.Buffer;
        PSERIAL_READER_CONFIG serialConfigData = 
            &SmartcardExtension->ReaderExtension->SerialConfigData;
        ULONG minWaitTime, newProtocol;

        //
        // Check if the card is already in specific state
        // and if the caller wants to have the already selected protocol.
        // We return success if this is the case.
        //
        KeAcquireSpinLock(&SmartcardExtension->OsData->SpinLock,
                          &irql);
        if (SmartcardExtension->ReaderCapabilities.CurrentState == SCARD_SPECIFIC &&
            (SmartcardExtension->CardCapabilities.Protocol.Selected & 
             SmartcardExtension->MinorIoControlCode)) {
            KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                              irql);

            status = STATUS_SUCCESS;    
            leave;
        }
        KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                          irql);

        // set normal timeout
        serialConfigData->Timeouts.ReadIntervalTimeout = 
            READ_INTERVAL_TIMEOUT_DEFAULT;
        serialConfigData->Timeouts.ReadTotalTimeoutConstant = 
            READ_TOTAL_TIMEOUT_CONSTANT_DEFAULT;

        status = TLP3ConfigureSerialPort(SmartcardExtension);

        ASSERT(status == STATUS_SUCCESS);

        if (status != STATUS_SUCCESS) {

            leave;
        }         
        
        //
        // Assemble and send a pts selection
        //

        newProtocol = SmartcardExtension->MinorIoControlCode;

        while(TRUE) {

            // set initial character of PTS
            ptsRequest[0] = 0xff;

            // set the format character
            if (SmartcardExtension->CardCapabilities.Protocol.Supported &
                newProtocol & 
                SCARD_PROTOCOL_T1) {

                // select T=1 and indicate that pts1 follows
                ptsRequest[1] = 0x11;
                SmartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_T1;

            } else if (SmartcardExtension->CardCapabilities.Protocol.Supported & 
                       newProtocol & 
                       SCARD_PROTOCOL_T0) {

                // select T=0 and indicate that pts1 follows
                ptsRequest[1] = 0x10;
                SmartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_T0;

            } else {
                
                status = STATUS_INVALID_DEVICE_REQUEST;
                leave;
            }

            // set pts1 which codes Fl and Dl
            ptsRequest[2] = 
                SmartcardExtension->CardCapabilities.PtsData.Fl << 4 |
                SmartcardExtension->CardCapabilities.PtsData.Dl;

            // set pck (check character)
            ptsRequest[3] = ptsRequest[0] ^ ptsRequest[1] ^ ptsRequest[2];   

            SmartcardExtension->SmartcardRequest.BufferLength = 4;
            SmartcardExtension->ReaderExtension->SerialIoControlCode = SMARTCARD_WRITE;

            status = TLP3SerialIo(SmartcardExtension);

            if (status != STATUS_SUCCESS) {
                
                leave;
            }

            // read back the echo of the reader
            SmartcardExtension->SmartcardReply.BufferLength = 4;
            SmartcardExtension->ReaderExtension->SerialIoControlCode = SMARTCARD_READ;

            status = TLP3SerialIo(SmartcardExtension);

            if (status != STATUS_SUCCESS) {
                
                leave;
            }

            // read back the pts data
            status = TLP3SerialIo(SmartcardExtension);

            if (status != STATUS_SUCCESS && 
                status != STATUS_TIMEOUT) {
                
                leave;       
            }

            if (status != STATUS_TIMEOUT && 
                memcmp(ptsRequest, ptsReply, 4) == 0) {

                // the card replied correctly to our pts-request
                break;
            }

            if (SmartcardExtension->CardCapabilities.PtsData.Type !=
                PTS_TYPE_DEFAULT) {

                SmartcardDebug(
                    DEBUG_TRACE,
                    ("%s!TLP3SetProtocol: PTS failed. Trying default parameters...\n",
                    DRIVER_NAME,
                    status)
                    );
                //
                // The card did either NOT reply or it replied incorrectly
                // so try default values
                //
                SmartcardExtension->CardCapabilities.PtsData.Type = 
                    PTS_TYPE_DEFAULT;

                KeAcquireSpinLock(&SmartcardExtension->OsData->SpinLock,
                                  &irql);
                SmartcardExtension->MinorIoControlCode = SCARD_COLD_RESET;
                KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                                  irql);

                status = TLP3ReaderPower(SmartcardExtension);

                continue;
            } 
            
            // the card failed the pts-request
            status = STATUS_DEVICE_PROTOCOL_ERROR;
            leave;
        } 

        //
        // The card replied correctly to the pts request
        // Set the appropriate parameters for the port
        //
        if (SmartcardExtension->CardCapabilities.Protocol.Selected &
            SCARD_PROTOCOL_T1) {

            // set timeouts
            serialConfigData->Timeouts.ReadTotalTimeoutConstant =
                SmartcardExtension->CardCapabilities.T1.BWT / 1000;
                
            serialConfigData->Timeouts.ReadIntervalTimeout =    
                SmartcardExtension->CardCapabilities.T1.CWT / 1000;

        } else if (SmartcardExtension->CardCapabilities.Protocol.Selected &
                   SCARD_PROTOCOL_T0) {

            // set timeouts
            serialConfigData->Timeouts.ReadTotalTimeoutConstant =
            serialConfigData->Timeouts.ReadIntervalTimeout =  
                SmartcardExtension->CardCapabilities.T0.WT / 1000;
        }

        // Now make some adjustments depending on the system speed
        minWaitTime = (KeQueryTimeIncrement() / 10000) * 5;

        if (serialConfigData->Timeouts.ReadTotalTimeoutConstant < minWaitTime) {

            serialConfigData->Timeouts.ReadTotalTimeoutConstant = minWaitTime;          
        }

        if (serialConfigData->Timeouts.ReadIntervalTimeout < minWaitTime) {

            serialConfigData->Timeouts.ReadIntervalTimeout = minWaitTime;           
        }

        // Change data rate according to the new settings
        serialConfigData->BaudRate.BaudRate = 
            SmartcardExtension->CardCapabilities.PtsData.DataRate;

        status = TLP3ConfigureSerialPort(SmartcardExtension);          

        ASSERT(status == STATUS_SUCCESS);

        // now indicate that we're in specific mode 
        SmartcardExtension->ReaderCapabilities.CurrentState = SCARD_SPECIFIC;

        // return the selected protocol to the caller
        *(PULONG) SmartcardExtension->IoRequest.ReplyBuffer = 
            SmartcardExtension->CardCapabilities.Protocol.Selected;

        *SmartcardExtension->IoRequest.Information = 
            sizeof(SmartcardExtension->CardCapabilities.Protocol.Selected);
    } 
    finally {

        if (status == STATUS_TIMEOUT) {

            // STATUS_TIMEOUT is not mapped to a Win32 error code
            status = STATUS_IO_TIMEOUT;             

            *SmartcardExtension->IoRequest.Information = 0;

        } else if (status != STATUS_SUCCESS) {
            
            SmartcardExtension->CardCapabilities.Protocol.Selected = 
                SCARD_PROTOCOL_UNDEFINED;

            *SmartcardExtension->IoRequest.Information = 0;
        } 
    }

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!TLP3SetProtocol: Exit(%lx)\n",
        DRIVER_NAME,
        status)
        );

   return status;
}

NTSTATUS
TLP3TransmitT0(
    PSMARTCARD_EXTENSION SmartcardExtension
    )
/*++

Routine Description:

    This function performs a T=0 transmission.

Arguments:

    SmartcardExtension - Pointer to smart card data struct.

Return Value:

    NTSTATUS

--*/
{
    PUCHAR requestBuffer = SmartcardExtension->SmartcardRequest.Buffer;
    PUCHAR replyBuffer = SmartcardExtension->SmartcardReply.Buffer;
    PULONG requestLength = &SmartcardExtension->SmartcardRequest.BufferLength;
    PULONG replyLength = &SmartcardExtension->SmartcardReply.BufferLength;
    PULONG serialIoControlCode = &SmartcardExtension->ReaderExtension->SerialIoControlCode;
    ULONG bytesToSend, bytesToRead, currentByte = 0;
    BOOLEAN restartWorkWaitingTime = FALSE;
    NTSTATUS status;

    PAGED_CODE();

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!TLP3TransmitT0: Enter\n",
        DRIVER_NAME)
        );

    try {
    
        // Let the lib build a T=0 packet
        status = SmartcardT0Request(SmartcardExtension);

        if (status != STATUS_SUCCESS) 
            leave;

        //
        // The number of bytes we expect from the card
        // is Le + 2 status bytes
        //
        bytesToSend = *requestLength;
        bytesToRead = SmartcardExtension->T0.Le + 2;

        //
        // Send the first 5 bytes to the card
        //
        *requestLength = 5;

        do {

            UCHAR procByte;

            //
            // According to ISO 7816 a procedure byte of 
            // 60 should be treated as a request for a one time wait.
            // In this case we do not write anything to the card
            //
            if (restartWorkWaitingTime == FALSE) {

                SmartcardDebug(
                    DEBUG_PROTOCOL,
                    ("%s!TLP3TransmitT0: -> Sending %s (%ld bytes)\n",
                    DRIVER_NAME,
                    (currentByte == 0 ? "header" : "data"),
                    *requestLength)
                    );
                //
                // Write to the card
                //
                *serialIoControlCode = SMARTCARD_WRITE;
                SmartcardExtension->SmartcardRequest.Buffer = &requestBuffer[currentByte];

                status = TLP3SerialIo(SmartcardExtension);

                if (status != STATUS_SUCCESS) {
                    
                    SmartcardDebug(
                        DEBUG_ERROR,
                        ("%s!TLP3TransmitT0: TLP3SerialIo(SMARTCARD_WRITE) returned %lx\n",
                        DRIVER_NAME,
                        status)
                        );
                    
                    leave;
                }

                //
                // The TLP3 echos all sent bytes. We read the echo 
                // back into our send buffer
                //
                *serialIoControlCode = SMARTCARD_READ;
                *replyLength = *requestLength;
                SmartcardExtension->SmartcardReply.Buffer = &requestBuffer[currentByte];
                                                    
                status = TLP3SerialIo(SmartcardExtension);

                if (status != STATUS_SUCCESS) {
                    
                    SmartcardDebug(
                        DEBUG_ERROR,
                        ("%s!TLP3TransmitT0: TLP3SerialIo(SMARTCARD_READ) returned %lx\n",
                        DRIVER_NAME,
                        status)
                        );

                    leave;
                }

                currentByte += *requestLength;
                bytesToSend -= *requestLength;
            }

            // Read the 'Procedure byte'.
            SmartcardExtension->SmartcardReply.Buffer = &procByte;
            *serialIoControlCode = SMARTCARD_READ;
            *replyLength = 1;

            status = TLP3SerialIo(SmartcardExtension);

            if (status != STATUS_SUCCESS) {
                
                SmartcardDebug(
                    DEBUG_ERROR,
                    ("%s!TLP3TransmitT0: TLP3SerialIo(SMARTCARD_READ) returned %lx\n",
                    DRIVER_NAME,
                    status)
                    );

                leave;
            }

            restartWorkWaitingTime = FALSE;
            //
            // Check the procedure byte. 
            // Please take a look at ISO 7816 Part 3 Section 8.2.2
            //
            if (procByte == requestBuffer[1] || 
                procByte == requestBuffer[1] + 1) {

                SmartcardDebug(
                    DEBUG_PROTOCOL,
                    ("%s!TLP3TransmitT0: <- ACK (send all)\n",
                    DRIVER_NAME)
                    );

                // All remaining data bytes can be sent at once
                *requestLength = bytesToSend;

            } else if (procByte == (UCHAR) ~requestBuffer[1] ||
                       procByte == (UCHAR) ~(requestBuffer[1] + 1)) {

                SmartcardDebug(
                    DEBUG_PROTOCOL,
                    ("%s!TLP3TransmitT0: <- ACK (send single)\n",
                    DRIVER_NAME)
                    );

                // We can send only one byte
                *requestLength = 1;

            } else if (procByte == 0x60 ||
                       SmartcardExtension->CardCapabilities.InversConvention &&
                       procByte == 0xf9) {

                //
                // We have to reset the wait time and try again to read
                //
                ULONG TimeRes;
                LARGE_INTEGER delayTime;

                SmartcardDebug(
                    DEBUG_PROTOCOL,
                    ("%s!TLP3TransmitT0: <- NULL (%ldms)\n",
                    DRIVER_NAME,
                    SmartcardExtension->CardCapabilities.T0.WT / 1000)
                    );

                TimeRes = KeQueryTimeIncrement();

                delayTime.HighPart = -1;
                delayTime.LowPart = 
                    (-1) * 
                    TimeRes * 
                    ((SmartcardExtension->CardCapabilities.T0.WT * 10l / TimeRes) + 1); 

                KeDelayExecutionThread(
                    KernelMode,
                    FALSE,
                    &delayTime
                    );

                //
                // Set flag that we only should read the proc byte
                // without writing data to the card
                //
                restartWorkWaitingTime = TRUE;

            } else {
                
                //
                // The card returned a status byte.
                // Status bytes are always two bytes long.
                // Store this byte first and then read the next
                //
                replyBuffer[0] = procByte;

                *serialIoControlCode = SMARTCARD_READ;
                *replyLength = 1;
                bytesToSend = 0;
                bytesToRead = 0;

                //
                // Read in the second status byte
                //
                SmartcardExtension->SmartcardReply.Buffer = 
                    &replyBuffer[1];

                status = TLP3SerialIo(SmartcardExtension);

                SmartcardExtension->SmartcardReply.BufferLength = 2;

                SmartcardDebug(
                    (status == STATUS_SUCCESS ? DEBUG_PROTOCOL : DEBUG_ERROR),
                    ("%s!TLP3TransmitT0: <- SW1=%02x SW2=%02x (%lx)\n",
                    DRIVER_NAME,
                    replyBuffer[0], 
                    replyBuffer[1],
                    status)
                    );
            }

        } while(bytesToSend || restartWorkWaitingTime);

        if (status != STATUS_SUCCESS)
            leave;

        if (bytesToRead != 0) {

            *serialIoControlCode = SMARTCARD_READ;
            *replyLength = bytesToRead;

            SmartcardExtension->SmartcardReply.Buffer = 
                replyBuffer;

            status = TLP3SerialIo(SmartcardExtension);

            SmartcardDebug(
                (status == STATUS_SUCCESS ? DEBUG_PROTOCOL : DEBUG_ERROR),
                ("%s!TLP3TransmitT0: <- Data %ld bytes, SW1=%02x SW2=%02x (%lx)\n",
                DRIVER_NAME,
                bytesToRead,
                replyBuffer[bytesToRead - 2], 
                replyBuffer[bytesToRead - 1],
                status)
                );
        }
    }
    finally {

        // Restore pointers to their original location
        SmartcardExtension->SmartcardRequest.Buffer = 
            requestBuffer;

        SmartcardExtension->SmartcardReply.Buffer = 
            replyBuffer;

        if (status == STATUS_TIMEOUT) {

            // STATUS_TIMEOUT is not mapped to a Win32 error code
            status = STATUS_IO_TIMEOUT;             
        }

        if (status == STATUS_SUCCESS) {
            
            status = SmartcardT0Reply(SmartcardExtension);
        }
    }

    SmartcardDebug(
        (status == STATUS_SUCCESS ? DEBUG_TRACE : DEBUG_ERROR),
        ("%s!TLP3TransmitT0: Exit(%lx)\n",
        DRIVER_NAME,
        status)
        );

    return status;
}   

NTSTATUS
TLP3Transmit(
    PSMARTCARD_EXTENSION SmartcardExtension
    )
/*++

Routine Description:

    This function is called by the smart card library whenever a transmission
    is required. 

Arguments:

    SmartcardExtension - Pointer to smart card data struct.

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS status;

    PAGED_CODE();

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!TLP3Transmit: Enter\n",
        DRIVER_NAME)
        );

    _try {
        
        do {

            PUCHAR requestBuffer = SmartcardExtension->SmartcardRequest.Buffer;
            PUCHAR replyBuffer = SmartcardExtension->SmartcardReply.Buffer;
            PULONG requestLength = &SmartcardExtension->SmartcardRequest.BufferLength;
            PULONG replyLength = &SmartcardExtension->SmartcardReply.BufferLength;
            PULONG serialIoControlCode = &SmartcardExtension->ReaderExtension->SerialIoControlCode;

            //
            // Tell the lib function how many bytes I need for the prologue
            //
            *requestLength = 0;

            switch (SmartcardExtension->CardCapabilities.Protocol.Selected) {

                case SCARD_PROTOCOL_RAW:
                    status = SmartcardRawRequest(SmartcardExtension);
                    break;

                case SCARD_PROTOCOL_T0:
                    //
                    // T=0 requires a bit more work.
                    // So we do this in a seperate function.
                    //
                    status = TLP3TransmitT0(SmartcardExtension);
                    leave;
                    
                case SCARD_PROTOCOL_T1:
                    status = SmartcardT1Request(SmartcardExtension);
                    break;

                default:
                    status = STATUS_INVALID_DEVICE_REQUEST;
                    leave;
                    
            }

            if (status != STATUS_SUCCESS) {

                leave;
            }

            //
            // Write the command to the card
            //
            *replyLength = 0;
            *serialIoControlCode = SMARTCARD_WRITE;

            status = TLP3SerialIo(SmartcardExtension);

            if (status != STATUS_SUCCESS) {

                leave;
            }

            //
            // The Bull reader always echos the bytes sent, so read that echo back
            //
            *serialIoControlCode = SMARTCARD_READ;
            *replyLength = *requestLength;

            status = TLP3SerialIo(SmartcardExtension);

            if (status != STATUS_SUCCESS) {

                leave;
            }

            switch (SmartcardExtension->CardCapabilities.Protocol.Selected) {

                case SCARD_PROTOCOL_RAW:
                    status = SmartcardRawReply(SmartcardExtension);
                    break;

                case SCARD_PROTOCOL_T1:
                    //
                    // Check if the card requested a waiting time extension
                    //
                    if (SmartcardExtension->T1.Wtx) {

                        LARGE_INTEGER waitTime;
                        waitTime.HighPart = -1;
                        waitTime.LowPart = 
                            SmartcardExtension->T1.Wtx * 
                            SmartcardExtension->CardCapabilities.T1.BWT * 
                            (-10);

                        KeDelayExecutionThread(
                            KernelMode,
                            FALSE,
                            &waitTime
                            );
                    }

                    //
                    // Read NAD, PCB and LEN fields
                    //
                    *replyLength = 3;

                    status = TLP3SerialIo(SmartcardExtension);

                    // 
                    // Check for timeout first. If the card did not reply 
                    // we need to send a resend request
                    //
                    if (status != STATUS_TIMEOUT) {

                        if (status != STATUS_SUCCESS) {

                            leave;
                        }

                        //
                        // The third byte contains the length of the data in the packet
                        // and we additinally want to have the EDC bytes which 
                        // is one for LRC and 2 for CRC
                        //
                        *replyLength = 
                            replyBuffer[2] + 
                            (SmartcardExtension->CardCapabilities.T1.EDC & 0x01 ? 2 : 1);

                        // We want to have the remaining bytes just after the first 3
                        SmartcardExtension->SmartcardReply.Buffer += 3;

                        status = TLP3SerialIo(SmartcardExtension);

                        SmartcardExtension->SmartcardReply.Buffer -= 3;
                        SmartcardExtension->SmartcardReply.BufferLength += 3;

                        if (status != STATUS_SUCCESS && status != STATUS_TIMEOUT) {

                            leave;
                        }                       
                    }

                    if (status == STATUS_TIMEOUT) {

                        //
                        // Since the card did not reply we set the number of 
                        // bytes received to 0. This will trigger a resend 
                        // request 
                        //
                        SmartcardDebug(
                            DEBUG_PROTOCOL,
                            ("%s!TLP3TransmitT1: Timeout\n",
                            DRIVER_NAME)
                            );
                        SmartcardExtension->SmartcardReply.BufferLength = 0;                        
                    }

                    status = SmartcardT1Reply(SmartcardExtension);
                    break;

                default:
                    status = STATUS_INVALID_DEVICE_REQUEST;
                    leave;
            }

        } while (status == STATUS_MORE_PROCESSING_REQUIRED);
    }

    _finally {

        if (status == STATUS_TIMEOUT) {

            // STATUS_TIMEOUT is not mapped to a Win32 error code
            status = STATUS_IO_TIMEOUT;             
        }
    }

#if defined (DEBUG) && defined (DETECT_SERIAL_OVERRUNS)
    if (status != STATUS_SUCCESS) {

        NTSTATUS status;
        PSERIALPERF_STATS perfData = 
            (PSERIALPERF_STATS) SmartcardExtension->SmartcardReply.Buffer;

        // we have to call GetCommStatus to reset the error condition
        SmartcardExtension->ReaderExtension->SerialIoControlCode =
            IOCTL_SERIAL_GET_COMMSTATUS;
        SmartcardExtension->SmartcardRequest.BufferLength = 0;
        SmartcardExtension->SmartcardReply.BufferLength = 
            sizeof(SERIAL_STATUS);

        status = TLP3SerialIo(SmartcardExtension);
        ASSERT(status == STATUS_SUCCESS);

        // now get the reason for the transmission error
        SmartcardExtension->ReaderExtension->SerialIoControlCode =
            IOCTL_SERIAL_GET_STATS;
        SmartcardExtension->SmartcardRequest.BufferLength = 0;
        SmartcardExtension->SmartcardReply.BufferLength = 
            sizeof(SERIALPERF_STATS);

        status = TLP3SerialIo(SmartcardExtension);
        ASSERT(status == STATUS_SUCCESS);

        SmartcardDebug(
            DEBUG_ERROR,
            ("%s!TLP3Transmit: Serial error statistics:\n   FrameErrors: %ld\n   SerialOverrunErrors: %ld\n   BufferOverrunErrors: %ld\n   ParityErrors: %ld\n",
            DRIVER_NAME, 
            perfData->FrameErrorCount, 
            perfData->SerialOverrunErrorCount,
            perfData->BufferOverrunErrorCount,
            perfData->ParityErrorCount)
            );      

        SmartcardExtension->ReaderExtension->SerialIoControlCode =
            IOCTL_SERIAL_CLEAR_STATS;
        SmartcardExtension->SmartcardRequest.BufferLength = 0;
        SmartcardExtension->SmartcardReply.BufferLength = 0;

        status = TLP3SerialIo(SmartcardExtension);
        ASSERT(status == STATUS_SUCCESS);
    } 
#if DEBUG && TIMEOUT_TEST 
    else {

        // inject some timeout errors

        LARGE_INTEGER Ticks;
        UCHAR RandomVal;
        KeQueryTickCount(&Ticks);

        RandomVal = (UCHAR) Ticks.LowPart % 4;

        if (RandomVal == 0) {

            status = STATUS_IO_TIMEOUT;

            SmartcardDebug(
                DEBUG_ERROR,
                ("%s!TLP3Transmit: Simulating timeout\n",
                DRIVER_NAME)
                );
        }
    }
#endif
#endif

#ifdef SIMULATION
    if (SmartcardExtension->ReaderExtension->SimulationLevel & 
        SIM_IO_TIMEOUT) {

        status = STATUS_IO_TIMEOUT;

        SmartcardDebug(
            DEBUG_SIMULATION,
            ("%s!TLP3Transmit: SIM STATUS_IO_TIMEOUT\n",
            DRIVER_NAME)
            );
    }
#endif

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!TLP3Transmit: Exit(%lx)\n",
        DRIVER_NAME,
        status)
        );

    return status;
}

NTSTATUS
TLP3CardTracking(
    PSMARTCARD_EXTENSION SmartcardExtension
    )
/*++

Routine Description:

    The smart card lib requires to have this function. It is called 
    to setup event tracking for card insertion and removal events.

Arguments:

    SmartcardExtension - pointer to the smart card data struct.

Return Value:

    NTSTATUS

--*/
{
    KIRQL ioIrql, keIrql;

    //
    // Set cancel routine for the notification irp
    //
    KeAcquireSpinLock(
        &SmartcardExtension->OsData->SpinLock, 
        &keIrql
        );
    IoAcquireCancelSpinLock(&ioIrql);

    if (SmartcardExtension->OsData->NotificationIrp) {
        
        IoSetCancelRoutine(
            SmartcardExtension->OsData->NotificationIrp, 
            TLP3Cancel
            );
    } 

    IoReleaseCancelSpinLock(ioIrql);

    KeReleaseSpinLock(
        &SmartcardExtension->OsData->SpinLock,
        keIrql
        );
    return STATUS_PENDING;
}

NTSTATUS
TLP3VendorIoctl(
    PSMARTCARD_EXTENSION SmartcardExtension
    )
{
    NTSTATUS status;
    static char answer[] = "Vendor IOCTL";

    PAGED_CODE();

    SmartcardDebug(
        DEBUG_PROTOCOL,
        ("%s!TLP3VendorIoctl: Enter\n",
        DRIVER_NAME)
        );

    if (SmartcardExtension->IoRequest.ReplyBuffer != NULL && 
        SmartcardExtension->IoRequest.ReplyBufferLength >= strlen(answer) + 1) { 
        
        strcpy(SmartcardExtension->IoRequest.ReplyBuffer, answer);
        *SmartcardExtension->IoRequest.Information = strlen(answer);
        status = STATUS_SUCCESS;

    } else {
        
        status = STATUS_BUFFER_TOO_SMALL;
    }

    SmartcardDebug(
        DEBUG_PROTOCOL,
        ("%s!TLP3VendorIoctl: Exit(%lx)\n",
        DRIVER_NAME,
        status)
        );

    return status;
}

NTSTATUS
TLP3SerialIo(
    PSMARTCARD_EXTENSION SmartcardExtension
    )
/*++

Routine Description:

    This routine sends IOCTL's to the serial driver. It waits on for their
    completion, and then returns.

    Arguments:

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS status;
    ULONG currentByte = 0;

    if (KeReadStateEvent(&READER_EXTENSION(SerialCloseDone))) {

        //
        // we have no connection to serial, fail the call
        // this could be the case if the reader was removed 
        // during stand by / hibernation
        //
        return STATUS_UNSUCCESSFUL;
    }

    // Check if the buffers are large enough
    ASSERT(SmartcardExtension->SmartcardReply.BufferLength <= 
        SmartcardExtension->SmartcardReply.BufferSize);

    ASSERT(SmartcardExtension->SmartcardRequest.BufferLength <= 
        SmartcardExtension->SmartcardRequest.BufferSize);

    if (SmartcardExtension->SmartcardReply.BufferLength > 
        SmartcardExtension->SmartcardReply.BufferSize ||
        SmartcardExtension->SmartcardRequest.BufferLength >
        SmartcardExtension->SmartcardRequest.BufferSize) {

        SmartcardLogError(
            SmartcardExtension->OsData->DeviceObject,
            TLP3_BUFFER_TOO_SMALL,
            NULL,
            0
            );

        return STATUS_BUFFER_TOO_SMALL;
    }

    do {

        IO_STATUS_BLOCK ioStatus;
        KEVENT event;
        PIRP irp;
        PIO_STACK_LOCATION irpNextStack;
        PUCHAR requestBuffer = NULL;
        PUCHAR replyBuffer = SmartcardExtension->SmartcardReply.Buffer;
        ULONG requestBufferLength = SmartcardExtension->SmartcardRequest.BufferLength;
        ULONG replyBufferLength = SmartcardExtension->SmartcardReply.BufferLength;

        KeInitializeEvent(
            &event, 
            NotificationEvent, 
            FALSE
            );

        if (READER_EXTENSION(SerialIoControlCode) == SMARTCARD_WRITE) {
            
            if (SmartcardExtension->CardCapabilities.GT != 0) {
                
                //
                // If the guardtime isn't 0 and we write data to the smart card 
                // we only write byte by byte, because we have to insert a delay 
                // between every sent byte     
                //
                requestBufferLength = 1;
            }

            requestBuffer = 
                &SmartcardExtension->SmartcardRequest.Buffer[currentByte++];

            replyBuffer = NULL;
            replyBufferLength = 0;

        } else {
            
            requestBuffer = 
                (requestBufferLength ? 
                 SmartcardExtension->SmartcardRequest.Buffer : NULL);
        }

        // Build irp to be sent to serial driver
        irp = IoBuildDeviceIoControlRequest(
            READER_EXTENSION(SerialIoControlCode),
            SmartcardExtension->ReaderExtension->AttachedDeviceObject,
            requestBuffer,
            requestBufferLength,
            replyBuffer,
            replyBufferLength,
            FALSE,
            &event,
            &ioStatus
            );

        ASSERT(irp != NULL);

        if (irp == NULL) {
                                                       
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        irpNextStack = IoGetNextIrpStackLocation(irp);

        switch (SmartcardExtension->ReaderExtension->SerialIoControlCode) {

            //
            // The serial driver trasfers data from/to irp->AssociatedIrp.SystemBuffer
            //
            case SMARTCARD_WRITE:
                //
                // Since we 'manually' change parameters, the io-manager
                // does not really know if this is an input or an ouput operation
                // unless the reply buffer is 0. We do the assertion here, because
                // if the reply buffer is not NULL, the io-manager will copy 
                // data back to the reply buffer.
                //
                ASSERT(replyBuffer == NULL);
                irpNextStack->MajorFunction = IRP_MJ_WRITE;
                irpNextStack->Parameters.Write.Length = requestBufferLength;
                irpNextStack->Parameters.Write.ByteOffset.QuadPart = 0;
                break;

            case SMARTCARD_READ:
                irpNextStack->MajorFunction = IRP_MJ_READ;
                irpNextStack->Parameters.Read.Length = replyBufferLength;
                irpNextStack->Parameters.Read.ByteOffset.QuadPart = 0;
                break;

            default:
                ASSERT(irpNextStack->MajorFunction = IRP_MJ_DEVICE_CONTROL);
                ASSERT(
                    DEVICE_TYPE_FROM_CTL_CODE(READER_EXTENSION(SerialIoControlCode)) ==
                    FILE_DEVICE_SERIAL_PORT
                    );
        }

        status = IoCallDriver(
            SmartcardExtension->ReaderExtension->AttachedDeviceObject, 
            irp
            );

        if (status == STATUS_PENDING) {

            KeWaitForSingleObject(
                &event, 
                Executive, 
                KernelMode, 
                FALSE, 
                NULL
                );

            status = ioStatus.Status;

            // save the number of bytes received
            SmartcardExtension->SmartcardReply.BufferLength = 
                (ULONG) ioStatus.Information;
        }

        // Check if we have to write more bytes to the reader
        if (SmartcardExtension->ReaderExtension->SerialIoControlCode ==
            SMARTCARD_WRITE &&
            SmartcardExtension->CardCapabilities.GT != 0 &&
            currentByte < 
            SmartcardExtension->SmartcardRequest.BufferLength) {

            // Now wait the required guard time
            KeStallExecutionProcessor(SmartcardExtension->CardCapabilities.GT);

            status = STATUS_MORE_PROCESSING_REQUIRED;
        }

    } while (status == STATUS_MORE_PROCESSING_REQUIRED);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\cmbp0\cmbp0pnp.c ===
/*****************************************************************************
@doc            INT EXT
******************************************************************************
* $ProjectName:  $
* $ProjectRevision:  $
*-----------------------------------------------------------------------------
* $Source: z:/pr/cmbp0/sw/cmbp0.ms/rcs/cmbp0pnp.c $
* $Revision: 1.4 $
*-----------------------------------------------------------------------------
* $Author: TBruendl $
*-----------------------------------------------------------------------------
* History: see EOF
*-----------------------------------------------------------------------------
*
* Copyright  2000  OMNIKEY AG
******************************************************************************/

#include <cmbp0wdm.h>
#include <cmbp0pnp.h>
#include <cmbp0scr.h>
#include <cmbp0log.h>



/*****************************************************************************
Routine Description:
   ???

Arguments:

Return Value:
******************************************************************************/
NTSTATUS CMMOB_AddDevice(
                        IN PDRIVER_OBJECT DriverObject,
                        IN PDEVICE_OBJECT PhysicalDeviceObject
                        )
{
    NTSTATUS NTStatus;
    PDEVICE_OBJECT DeviceObject = NULL;

    SmartcardDebug(DEBUG_TRACE,
                   ("%s!AddDevice: Enter\n",DRIVER_NAME));

    try {
        PDEVICE_EXTENSION DeviceExtension;

        NTStatus = CMMOB_CreateDevice(DriverObject, PhysicalDeviceObject, &DeviceObject);
        if (NTStatus != STATUS_SUCCESS) {
            leave;
        }

        DeviceExtension = DeviceObject->DeviceExtension;

        DeviceExtension->AttachedDeviceObject = IoAttachDeviceToDeviceStack(DeviceObject,
                                                                            PhysicalDeviceObject);
        if (DeviceExtension->AttachedDeviceObject == NULL) {
            NTStatus = STATUS_UNSUCCESSFUL;
            leave;
        }

        DeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    }

    finally {
        if (NTStatus != STATUS_SUCCESS) {
            CMMOB_UnloadDevice(DeviceObject);
        }
    }

    SmartcardDebug(DEBUG_TRACE,
                   ("%s!AddDevice: Exit %x\n",DRIVER_NAME,NTStatus));

    return NTStatus;
}


/*****************************************************************************
Routine Description:

   Send an Irp to the pcmcia driver and wait until the pcmcia driver has
   finished the request.

   To make sure that the pcmcia driver will not complete the Irp we first
   initialize an event and set our own completion routine for the Irp.

   When the pcmcia driver has processed the Irp the completion routine will
   set the event and tell the IO manager that more processing is required.

   By waiting for the event we make sure that we continue only if the pcmcia
   driver has processed the Irp completely.

Arguments:
   DeviceObject context of call
   Irp              Irp to send to the pcmcia driver

Return Value:

   NTStatus returned by the pcmcia driver
******************************************************************************/
NTSTATUS CMMOB_CallPcmciaDriver(
                               IN PDEVICE_OBJECT AttachedDeviceObject,
                               IN PIRP Irp
                               )
{
    NTSTATUS             NTStatus = STATUS_SUCCESS;
    PIO_STACK_LOCATION   IrpStack, IrpNextStack;
    KEVENT               Event;

   /*
   SmartcardDebug(DEBUG_TRACE,
                  ("%s!CMMOB_CallPcmciaDriver: Enter\n",DRIVER_NAME ));
   */

   //
   // Prepare everything to call the underlying driver
   //
    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    IrpNextStack = IoGetNextIrpStackLocation(Irp);

   //
   // Copy our stack to the next stack location.
   //
    *IrpNextStack = *IrpStack;

   //
   // initialize an event for process synchronization. the event is passed
   // to our completion routine and will be set if the pcmcia driver is done
   //
    KeInitializeEvent(&Event,
                      NotificationEvent,
                      FALSE);

   //
   // Our IoCompletionRoutine sets only our event
   //
    IoSetCompletionRoutine (Irp,
                            CMMOB_PcmciaCallComplete,
                            &Event,
                            TRUE,
                            TRUE,
                            TRUE);

   //
   // Call the pcmcia driver
   //
    if (IrpStack->MajorFunction == IRP_MJ_POWER) {
        NTStatus = PoCallDriver(AttachedDeviceObject,Irp);
    } else {
        NTStatus = IoCallDriver(AttachedDeviceObject,Irp);
    }

   //
   // Wait until the pcmcia driver has processed the Irp
   //
    if (NTStatus == STATUS_PENDING) {
        NTStatus = KeWaitForSingleObject(&Event,
                                         Executive,
                                         KernelMode,
                                         FALSE,
                                         NULL);

        if (NTStatus == STATUS_SUCCESS) {
            NTStatus = Irp->IoStatus.Status;
        }
    }

   /*
   SmartcardDebug(DEBUG_TRACE,
                  ("%s!CMMOB_CallPcmciaDriver: Exit %x\n",DRIVER_NAME,NTStatus));
   */

    return NTStatus;
}

/*****************************************************************************
Routine Description:
   Completion routine for an Irp sent to the pcmcia driver. The event will
   be set to notify that the pcmcia driver is done. The routine will not
   'complete' the Irp, so the caller of CMMOB_CallPcmciaDriver can continue.

Arguments:
   DeviceObject  context of call
   Irp            Irp to complete
   Event              Used by CMMOB_CallPcmciaDriver for process synchronization

Return Value:
   STATUS_CANCELLED                     Irp was cancelled by the IO manager
   STATUS_MORE_PROCESSING_REQUIRED   Irp will be finished by caller of
                                     CMMOB_CallPcmciaDriver
******************************************************************************/
NTSTATUS CMMOB_PcmciaCallComplete (
                                  IN PDEVICE_OBJECT DeviceObject,
                                  IN PIRP Irp,
                                  IN PKEVENT Event
                                  )
{
    UNREFERENCED_PARAMETER (DeviceObject);

    if (Irp->Cancel) {
        Irp->IoStatus.Status = STATUS_CANCELLED;
    }

    KeSetEvent (Event, 0, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}


/*****************************************************************************
Routine Description:

   driver callback for pnp manager

   Request:                 Action:

   IRP_MN_START_DEVICE         Notify the pcmcia driver about the new device
                               and start the device

   IRP_MN_STOP_DEVICE            Free all resources used by the device and tell
                               the pcmcia driver that the device was stopped

   IRP_MN_QUERY_REMOVE_DEVICE    If the device is opened (i.e. in use) an error will
                               be returned to prevent the PnP manager to stop
                               the driver

   IRP_MN_CANCEL_REMOVE_DEVICE  just notify that we can continue without any
                        restrictions

   IRP_MN_REMOVE_DEVICE     notify the pcmcia driver that the device was
                        removed, stop & unload the device

   All other requests will be passed to the pcmcia driver to ensure correct processing.

Arguments:
   Device Object    context of call
   Irp              irp from the PnP manager

Return Value:
   STATUS_SUCCESS
   STATUS_UNSUCCESSFUL
   NTStatus returned by pcmcia driver
******************************************************************************/
NTSTATUS CMMOB_PnPDeviceControl(
                               IN PDEVICE_OBJECT DeviceObject,
                               IN PIRP Irp
                               )
{
    NTSTATUS             NTStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION    DeviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION   IrpStack;
    PDEVICE_OBJECT       AttachedDeviceObject;
    PDEVICE_CAPABILITIES DeviceCapabilities;
    KIRQL                irql;
    LONG                 i;
    BOOLEAN              irpSkipped = FALSE;
    BOOLEAN              removed = FALSE;

    SmartcardDebug(DEBUG_TRACE,
                   ("%s!PnPDeviceControl: Enter\n",DRIVER_NAME ));

    NTStatus = SmartcardAcquireRemoveLock(&DeviceExtension->SmartcardExtension);
    ASSERT(NTStatus == STATUS_SUCCESS);
    if (NTStatus != STATUS_SUCCESS) {
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = NTStatus;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return NTStatus;
    }

    AttachedDeviceObject = DeviceExtension->AttachedDeviceObject;

//   Irp->IoStatus.Information = 0;
    IrpStack = IoGetCurrentIrpStackLocation(Irp);

   //
   // Now look what the PnP manager wants...
   //
   #ifdef DBG
    if (IrpStack->MinorFunction <= IRP_PNP_MN_FUNC_MAX) {
        SmartcardDebug(DEBUG_DRIVER,
                       ("%s!PnPDeviceControl: %s received\n",DRIVER_NAME,
                        szPnpMnFuncDesc[IrpStack->MinorFunction] ));
    }
   #endif
    switch (IrpStack->MinorFunction) {
    case IRP_MN_START_DEVICE:
         //
         // We have to call the underlying driver first
         //
        NTStatus = CMMOB_CallPcmciaDriver(AttachedDeviceObject,Irp);

        if (NT_SUCCESS(NTStatus)) {
            //
            // Now we should connect to our resources (Irql, Io etc.)
            //
            NTStatus = CMMOB_StartDevice(DeviceObject,
                                         &IrpStack->Parameters.StartDevice.AllocatedResourcesTranslated->List[0]);
        }
        break;

    case IRP_MN_QUERY_STOP_DEVICE:
        KeAcquireSpinLock(&DeviceExtension->SpinLockIoCount, &irql);
        if (DeviceExtension->lIoCount > 0) {
            // we refuse to stop if we have pending io
            KeReleaseSpinLock(&DeviceExtension->SpinLockIoCount, irql);
            NTStatus = STATUS_DEVICE_BUSY;
        } else {
            // stop processing requests

            KeClearEvent(&DeviceExtension->ReaderStarted);
            KeReleaseSpinLock(&DeviceExtension->SpinLockIoCount, irql);

            NTStatus = CMMOB_CallPcmciaDriver(AttachedDeviceObject, Irp);
        }
        break;

    case IRP_MN_CANCEL_STOP_DEVICE:
        NTStatus = CMMOB_CallPcmciaDriver(AttachedDeviceObject, Irp);
        ASSERT(NTStatus == STATUS_SUCCESS);

         // we can continue to process requests
        DeviceExtension->lIoCount = 0;

        KeSetEvent(&DeviceExtension->ReaderStarted, 0, FALSE);


        break;

    case IRP_MN_STOP_DEVICE:
         //
         // Stop the device. Aka disconnect from our resources
         //
        CMMOB_StopDevice(DeviceObject);
        NTStatus = CMMOB_CallPcmciaDriver(AttachedDeviceObject, Irp);
        break;

    case IRP_MN_QUERY_REMOVE_DEVICE:
         //
         // Remove our device
         //
        if (DeviceExtension->lOpenCount > 0) {
            NTStatus = STATUS_UNSUCCESSFUL;
        } else {
            NTStatus = IoSetDeviceInterfaceState(&DeviceExtension->PnPDeviceName,
                                                 FALSE);
            ASSERT(NTStatus == STATUS_SUCCESS);
            if (NTStatus != STATUS_SUCCESS) {
                break;
            }

            NTStatus = CMMOB_CallPcmciaDriver(AttachedDeviceObject, Irp);
        }
        break;

    case IRP_MN_CANCEL_REMOVE_DEVICE:
         //
         // Removal of device has been cancelled
         //
        NTStatus = CMMOB_CallPcmciaDriver(AttachedDeviceObject, Irp);
        if (NTStatus == STATUS_SUCCESS) {
            NTStatus = IoSetDeviceInterfaceState(&DeviceExtension->PnPDeviceName,
                                                 TRUE);

        }
        ASSERT(NTStatus == STATUS_SUCCESS);
        break;

    case IRP_MN_REMOVE_DEVICE:
         //
         // Remove our device
         //

        CMMOB_StopDevice(DeviceObject);

         // Wait until we can safely unload the device
        SmartcardReleaseRemoveLockAndWait(&DeviceExtension->SmartcardExtension);
        CMMOB_UnloadDevice(DeviceObject);

        removed = TRUE;
        NTStatus = CMMOB_CallPcmciaDriver(AttachedDeviceObject, Irp);

        break;

    case IRP_MN_QUERY_CAPABILITIES:
         //
         // Query device capabilities
         //


         //
         // Get the packet.
         //
        DeviceCapabilities=IrpStack->Parameters.DeviceCapabilities.Capabilities;


        if (DeviceCapabilities->Version < 1 ||
            DeviceCapabilities->Size < sizeof(DEVICE_CAPABILITIES)) {
            //
            // We don't support this version. Fail the requests
            //
            NTStatus = STATUS_UNSUCCESSFUL;
            break;
        }


         //
         // Set the capabilities.
         //

         // We cannot wake the system.
        DeviceCapabilities->SystemWake = PowerSystemUnspecified;
        DeviceCapabilities->DeviceWake = PowerDeviceUnspecified;

         // We have no latencies
        DeviceCapabilities->D1Latency = 0;
        DeviceCapabilities->D2Latency = 0;
        DeviceCapabilities->D3Latency = 0;

         // No locking or ejection
        DeviceCapabilities->LockSupported = FALSE;
        DeviceCapabilities->EjectSupported = FALSE;

         // Device can be physically removed.
        DeviceCapabilities->Removable = TRUE;

         // No docking device
        DeviceCapabilities->DockDevice = FALSE;

         // Device can not be removed any time
         // it has a removable media
        DeviceCapabilities->SurpriseRemovalOK = FALSE;


         //
         // Call the next lower driver
         //
        NTStatus = CMMOB_CallPcmciaDriver(AttachedDeviceObject, Irp);

         //
         // Now look at the relation system state / device state
         //

        {

            SmartcardDebug( DEBUG_DRIVER,
                            ("%s!PnPDeviceControl: systemstate to devicestate mapping\n",DRIVER_NAME ));

            for (i=1; i<PowerSystemMaximum; i++) {
                SmartcardDebug(DEBUG_DRIVER,
                               ("%s!PnPDeviceControl: %s -> %s\n",DRIVER_NAME,
                                szSystemPowerState[i],szDevicePowerState[DeviceCapabilities->DeviceState[i]] ));
                if (DeviceCapabilities->DeviceState[i] != PowerDeviceD3 &&
                    (DeviceCapabilities->DeviceState[i] != PowerDeviceD0 ||
                     i >= PowerSystemSleeping3)) {
                    DeviceCapabilities->DeviceState[i]=PowerDeviceD3;
                    SmartcardDebug(DEBUG_DRIVER,
                                   ("%s!PnPDeviceControl: altered to %s -> %s\n",DRIVER_NAME,
                                    szSystemPowerState[i],szDevicePowerState[DeviceCapabilities->DeviceState[i]] ));
                }
            }
        }

         // Store DeviceCapabilities in our DeviceExtension for later use
        RtlCopyMemory(&DeviceExtension->DeviceCapabilities,DeviceCapabilities,
                      sizeof(DeviceExtension->DeviceCapabilities));

        break;

    case IRP_MN_QUERY_DEVICE_RELATIONS:
         //
         // Query device relations
         //

        SmartcardDebug(DEBUG_DRIVER,
                       ("%s!PnPDeviceControl: Requested relation = %s\n",DRIVER_NAME,
                        szDeviceRelation[IrpStack->Parameters.QueryDeviceRelations.Type] ));
        NTStatus = CMMOB_CallPcmciaDriver(AttachedDeviceObject, Irp);
        irpSkipped = TRUE;
        break;

    default:
         //
         // This might be an Irp that is only useful
         // for the underlying bus driver
         //
        NTStatus = CMMOB_CallPcmciaDriver(AttachedDeviceObject, Irp);
        irpSkipped = TRUE;
        break;
    }

    if (!irpSkipped) {
        Irp->IoStatus.Status = NTStatus;
    }

    IoCompleteRequest(Irp,IO_NO_INCREMENT);

    if (removed == FALSE) {
        SmartcardReleaseRemoveLock(&DeviceExtension->SmartcardExtension);
    }

    SmartcardDebug(DEBUG_TRACE,
                   ( "%s!PnPDeviceControl: Exit %x\n",DRIVER_NAME,NTStatus));

    return NTStatus;
}


/*****************************************************************************
Routine Description:
    This function is called when the underlying stacks
    completed the power transition.

******************************************************************************/
VOID CMMOB_SystemPowerCompletion(
                                IN PDEVICE_OBJECT DeviceObject,
                                IN UCHAR MinorFunction,
                                IN POWER_STATE PowerState,
                                IN PKEVENT Event,
                                IN PIO_STATUS_BLOCK IoStatus
                                )
{
    UNREFERENCED_PARAMETER (DeviceObject);
    UNREFERENCED_PARAMETER (MinorFunction);
    UNREFERENCED_PARAMETER (PowerState);

    SmartcardDebug(DEBUG_TRACE,
                   ("%s!SystemPowerCompletion: Enter\n",DRIVER_NAME));
    SmartcardDebug(DEBUG_DRIVER,
                   ("%s!SystemPowerCompletion: Status of completed IRP = %x\n",DRIVER_NAME,IoStatus->Status));

    KeSetEvent(Event, 0, FALSE);

    SmartcardDebug(DEBUG_TRACE,
                   ("%s!SystemPowerCompletion: Exit\n",DRIVER_NAME));
}

/*****************************************************************************
Routine Description:
    This routine is called after the underlying stack powered
    UP the serial port, so it can be used again.

******************************************************************************/
NTSTATUS CMMOB_DevicePowerCompletion (
                                     IN PDEVICE_OBJECT DeviceObject,
                                     IN PIRP Irp,
                                     IN PSMARTCARD_EXTENSION SmartcardExtension
                                     )
{
    PDEVICE_EXTENSION    DeviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION   IrpStack = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS             NTStatus;
    UCHAR                state;
    KIRQL                irql;

    SmartcardDebug(DEBUG_TRACE,
                   ("%s!DevicePowerCompletion: Enter\n",DRIVER_NAME));
    SmartcardDebug(DEBUG_DRIVER,
                   ("%s!DevicePowerCompletion: IRQL %i\n",DRIVER_NAME,KeGetCurrentIrql()));


   //
   // If a card was present before power down or now there is
   // a card in the reader, we complete any pending card monitor
   // request, since we do not really know what card is now in the
   // reader.
   //
    KeAcquireSpinLock(&SmartcardExtension->OsData->SpinLock,
                        &irql);
    if (SmartcardExtension->ReaderExtension->fCardPresent ||
        SmartcardExtension->ReaderCapabilities.CurrentState > SCARD_ABSENT) {
        SmartcardExtension->ReaderExtension->ulOldCardState = UNKNOWN;
        SmartcardExtension->ReaderExtension->ulNewCardState = UNKNOWN;
    }
    KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                        irql);

    KeSetEvent(&DeviceExtension->CanRunUpdateThread, 0, FALSE);

   // save the current power state of the reader
    SmartcardExtension->ReaderExtension->ReaderPowerState = PowerReaderWorking;

    SmartcardReleaseRemoveLock(SmartcardExtension);

   // inform the power manager of our state.
    PoSetPowerState (DeviceObject,
                     DevicePowerState,
                     IrpStack->Parameters.Power.State);

    SmartcardDebug( DEBUG_DRIVER,
                    ("%s!DevicePowerCompletion: called PoSetPowerState with %s\n",DRIVER_NAME,
                     szDevicePowerState[IrpStack->Parameters.Power.State.DeviceState] ));

    PoStartNextPowerIrp(Irp);

   // signal that we can process ioctls again
    DeviceExtension->lIoCount = 0;
    KeSetEvent(&DeviceExtension->ReaderStarted, 0, FALSE);

    SmartcardDebug(DEBUG_TRACE,
                   ("%s!DevicePowerCompletion: Exit\n",DRIVER_NAME));
    return STATUS_SUCCESS;
}

typedef enum _ACTION {
    Undefined = 0,
    SkipRequest,
    WaitForCompletion,
    CompleteRequest,
    MarkPending
} ACTION;


/*****************************************************************************
Routine Description:
    The power dispatch routine.
    This driver is the power policy owner of the device stack,
    because this driver knows about the connected reader.
    Therefor this driver will translate system power states
    to device power states.

Arguments:
   DeviceObject - pointer to a device object.
   Irp - pointer to an I/O Request Packet.

Return Value:
      NT NTStatus code

******************************************************************************/
NTSTATUS CMMOB_PowerDeviceControl (
                                  IN PDEVICE_OBJECT DeviceObject,
                                  IN PIRP Irp
                                  )
{
    NTSTATUS                NTStatus = STATUS_SUCCESS;
    PIO_STACK_LOCATION      IrpStack = IoGetCurrentIrpStackLocation(Irp);
    PDEVICE_EXTENSION       DeviceExtension = DeviceObject->DeviceExtension;
    PSMARTCARD_EXTENSION    SmartcardExtension = &DeviceExtension->SmartcardExtension;
    POWER_STATE             DesiredPowerState;
    KIRQL                   irql;
    ACTION                  action;
    KEVENT                  event;

    SmartcardDebug(DEBUG_TRACE,
                   ( "%s!PowerDeviceControl: Enter\n",DRIVER_NAME));
    SmartcardDebug(DEBUG_DRIVER,
                   ( "%s!PowerDeviceControl: IRQL %i\n",DRIVER_NAME,KeGetCurrentIrql()));

    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

    NTStatus = SmartcardAcquireRemoveLock(SmartcardExtension);
    ASSERT(NTStatus == STATUS_SUCCESS);
    if (NTStatus!=STATUS_SUCCESS) {
        Irp->IoStatus.Status = NTStatus;
        Irp->IoStatus.Information = 0;

        PoStartNextPowerIrp(Irp);
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return NTStatus;
    }

    ASSERT(SmartcardExtension->ReaderExtension->ReaderPowerState !=
           PowerReaderUnspecified);

   #ifdef DBG
    if (IrpStack->MinorFunction <= IRP_POWER_MN_FUNC_MAX) {
        SmartcardDebug(DEBUG_DRIVER,
                       ("%s!PowerDeviceControl: %s received\n",DRIVER_NAME,
                        szPowerMnFuncDesc[IrpStack->MinorFunction] ));
    }
   #endif
    switch (IrpStack->MinorFunction) {
      // ------------------
      // IRP_MN_QUERY_POWER
      // ------------------
    case IRP_MN_QUERY_POWER:
         //
         // A power policy manager sends this IRP to determine whether it can change
         // the system or device power state, typically to go to sleep.
         //
        switch (IrpStack->Parameters.Power.Type) {
            // +++++++++++++++++++
            // SystemPowerState
            // +++++++++++++++++++
        case SystemPowerState:
            SmartcardDebug( DEBUG_DRIVER,
                            ("%s!PowerDeviceControl: SystemPowerState = %s\n",DRIVER_NAME,
                             szSystemPowerState [IrpStack->Parameters.Power.State.SystemState] ));

            switch (IrpStack->Parameters.Power.State.SystemState) {
            case PowerSystemWorking:
                action = SkipRequest;
                break;

            case PowerSystemSleeping1:
            case PowerSystemSleeping2:
            case PowerSystemSleeping3:
            case PowerSystemHibernate:
                KeAcquireSpinLock(&DeviceExtension->SpinLockIoCount, &irql);
                if (DeviceExtension->lIoCount == 0) {
                           // Block any further ioctls
                    KeClearEvent(&DeviceExtension->ReaderStarted);
                    action = SkipRequest;
                } else {
                           // can't go to sleep mode since the reader is busy.
                    NTStatus = STATUS_DEVICE_BUSY;
                    action = CompleteRequest;
                }
                KeReleaseSpinLock(&DeviceExtension->SpinLockIoCount, irql);

                break;

            case PowerSystemShutdown:
                action = SkipRequest;
                break;
            }

            break;

               // ++++++++++++++++++
               // DevicePowerState
               // ++++++++++++++++++
        case DevicePowerState:
               // For requests to D1, D2, or D3 ( sleep or off states ),
               // sets DeviceExtension->CurrentDevicePowerState to DeviceState immediately.
               // This enables any code checking state to consider us as sleeping or off
               // already, as this will imminently become our state.

            SmartcardDebug(DEBUG_DRIVER,
                           ("%s!PowerDeviceControl: DevicePowerState = %s\n",DRIVER_NAME,
                            szDevicePowerState[IrpStack->Parameters.Power.State.DeviceState] ));
            action = SkipRequest;
            break;
        }

        break; /* IRP_MN_QUERY_POWER */

         // ------------------
         // IRP_MN_SET_POWER
         // ------------------
    case IRP_MN_SET_POWER:
         // The system power policy manager sends this IRP to set the system power state.
         // A device power policy manager sends this IRP to set the device power state for a device.
         // Set Irp->IoStatus.Status to STATUS_SUCCESS to indicate that the device
         // has entered the requested state. Drivers cannot fail this IRP.

        ASSERT(SmartcardExtension->ReaderExtension->ReaderPowerState != PowerReaderUnspecified);

        switch (IrpStack->Parameters.Power.Type) {
            // +++++++++++++++++++
            // SystemPowerState
            // +++++++++++++++++++
        case SystemPowerState:
               // Get input system power state

            SmartcardDebug( DEBUG_DRIVER,
                            ("%s!PowerDeviceControl: SystemPowerState = %s\n",DRIVER_NAME,
                             szSystemPowerState[IrpStack->Parameters.Power.State.SystemState] ));

               // determine desired device powerstate
            DesiredPowerState.DeviceState=DeviceExtension->DeviceCapabilities.DeviceState[IrpStack->Parameters.Power.State.SystemState];

            SmartcardDebug( DEBUG_DRIVER,
                            ("%s!PowerDeviceControl: DesiredDevicePowerState = %s\n",DRIVER_NAME,
                             szDevicePowerState[DesiredPowerState.DeviceState] ));

            switch (DesiredPowerState.DeviceState) {
            
            case PowerDeviceD0:

                if (SmartcardExtension->ReaderExtension->ReaderPowerState == PowerReaderWorking) {
                        // We're already in the right state
                    KeSetEvent(&DeviceExtension->ReaderStarted, 0, FALSE);
                    action = SkipRequest;
                    break;
                }

                     // wake up the underlying stack...
                action = MarkPending;
                SmartcardDebug( DEBUG_DRIVER,
                                ("%s!PowerDeviceControl: setting DevicePowerState = %s\n",DRIVER_NAME,
                                 szDevicePowerState[DesiredPowerState.DeviceState] ));

                break;


            case PowerDeviceD1:
            case PowerDeviceD2:
            case PowerDeviceD3:

                DesiredPowerState.DeviceState = PowerDeviceD3;
                if (SmartcardExtension->ReaderExtension->ReaderPowerState == PowerReaderOff) {
                        // We're already in the right state
                    KeClearEvent(&DeviceExtension->ReaderStarted);
                    action = SkipRequest;
                    break;
                }

                action = MarkPending;
                SmartcardDebug( DEBUG_DRIVER,
                                ("%s!PowerDeviceControl: setting DevicePowerState = %s\n",DRIVER_NAME,
                                 szDevicePowerState[DesiredPowerState.DeviceState] ));

                break;

            default:

                action = SkipRequest;
                break;
            }

            break;


               // ++++++++++++++++++
               // DevicePowerState
               // ++++++++++++++++++
        case DevicePowerState:

            SmartcardDebug(DEBUG_DRIVER,
                           ("%s!PowerDeviceControl: DevicePowerState = %s\n",DRIVER_NAME,
                            szDevicePowerState[IrpStack->Parameters.Power.State.DeviceState] ));

            switch (IrpStack->Parameters.Power.State.DeviceState) {
            
            case PowerDeviceD0:
                     // Turn on the reader
                SmartcardDebug(DEBUG_DRIVER,
                               ("%s!PowerDeviceControl: PowerDevice D0\n",DRIVER_NAME));

                     //
                     // start update thread be signal that it should not run now
                     // this thread should be started in completion rourine
                     // but there we have a wrong IRQL for creating a thread
                     //
                KeClearEvent(&DeviceExtension->CanRunUpdateThread);
                NTStatus = CMMOB_StartCardTracking(DeviceObject);
                if (NTStatus != STATUS_SUCCESS) {
                    SmartcardDebug(DEBUG_ERROR,
                                   ("%s!StartCardTracking failed ! %lx\n",DRIVER_NAME,NTStatus));
                }

                     //
                     // First, we send down the request to the bus, in order
                     // to power on the port. When the request completes,
                     // we turn on the reader
                     //
                IoCopyCurrentIrpStackLocationToNext(Irp);
                IoSetCompletionRoutine (Irp,
                                        CMMOB_DevicePowerCompletion,
                                        SmartcardExtension,
                                        TRUE,
                                        TRUE,
                                        TRUE);

                action = WaitForCompletion;
                break;

            case PowerDeviceD1:
            case PowerDeviceD2:
            case PowerDeviceD3:
                     // Turn off the reader
                SmartcardDebug(DEBUG_DRIVER,
                               ("%s!PowerDeviceControl: PowerDevice D3\n",DRIVER_NAME));

                PoSetPowerState (DeviceObject,
                                 DevicePowerState,
                                 IrpStack->Parameters.Power.State);

                     // Block any further ioctls
                KeClearEvent(&DeviceExtension->ReaderStarted);

                     // stop the update thread
                CMMOB_StopCardTracking(DeviceObject);

                     // save the current card state

                KeAcquireSpinLock(&SmartcardExtension->OsData->SpinLock,
                                    &irql);
                SmartcardExtension->ReaderExtension->fCardPresent =
                SmartcardExtension->ReaderCapabilities.CurrentState > SCARD_ABSENT;

                KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                                    irql);

                if (SmartcardExtension->ReaderExtension->fCardPresent) {
                    SmartcardExtension->MinorIoControlCode = SCARD_POWER_DOWN;
                    NTStatus = CMMOB_PowerOffCard(SmartcardExtension);
                    ASSERT(NTStatus == STATUS_SUCCESS);
                }

                     // save the current power state of the reader
                SmartcardExtension->ReaderExtension->ReaderPowerState = PowerReaderOff;
                action = SkipRequest;
                break;

            default:

                action = SkipRequest;
                break;
            }

            break;
        } /* case irpStack->Parameters.Power.Type */

        break; /* IRP_MN_SET_POWER */

    default:
        SmartcardDebug(DEBUG_DRIVER,
                       ("%s!PowerDeviceControl: unhandled POWER IRP received\n",DRIVER_NAME));
         //
         // All unhandled power messages are passed on to the PDO
         //
        action = SkipRequest;
        break;

    } /* irpStack->MinorFunction */


    switch (action) {
    
    case CompleteRequest:
        SmartcardReleaseRemoveLock(SmartcardExtension);
        PoStartNextPowerIrp(Irp);
        Irp->IoStatus.Status = NTStatus;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        break;

    case MarkPending:
         // initialize the event we need in the completion function
        KeInitializeEvent(&event,
                          NotificationEvent,
                          FALSE);

         // request the device power irp
        NTStatus = PoRequestPowerIrp (DeviceObject,
                                      IRP_MN_SET_POWER,
                                      DesiredPowerState,
                                      CMMOB_SystemPowerCompletion,
                                      &event,
                                      NULL);

        SmartcardDebug( DEBUG_DRIVER,
                        ("%s!PowerDeviceControl: called PoRequestPowerIrp with %s\n",DRIVER_NAME,
                         szDevicePowerState[DesiredPowerState.DeviceState] ));

        ASSERT(NTStatus == STATUS_PENDING);

        if (NTStatus == STATUS_PENDING) {
            // wait until the device power irp completed
            NTStatus = KeWaitForSingleObject(&event,
                                             Executive,
                                             KernelMode,
                                             FALSE,
                                             NULL);
        }

        if (NTStatus == STATUS_SUCCESS) {
            SmartcardReleaseRemoveLock(SmartcardExtension);
            PoStartNextPowerIrp(Irp);
            IoSkipCurrentIrpStackLocation(Irp);
            NTStatus = PoCallDriver(DeviceExtension->AttachedDeviceObject, Irp);
        } else {
            SmartcardReleaseRemoveLock(SmartcardExtension);
            PoStartNextPowerIrp(Irp);
            Irp->IoStatus.Status = NTStatus;
            Irp->IoStatus.Information = 0;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
        }

        break;

    case SkipRequest:
        SmartcardReleaseRemoveLock(SmartcardExtension);
        PoStartNextPowerIrp(Irp);
        IoSkipCurrentIrpStackLocation(Irp);
        NTStatus = PoCallDriver(DeviceExtension->AttachedDeviceObject, Irp);
        break;

    case WaitForCompletion:
        NTStatus = PoCallDriver(DeviceExtension->AttachedDeviceObject, Irp);
        break;

    default:
        SmartcardReleaseRemoveLock(SmartcardExtension);
        PoStartNextPowerIrp(Irp);
        IoSkipCurrentIrpStackLocation(Irp);
        NTStatus = PoCallDriver(DeviceExtension->AttachedDeviceObject, Irp);

        break;
    }

    SmartcardDebug(DEBUG_TRACE,
                   ("%s!PowerDeviceControl: Exit %lx\n",DRIVER_NAME,NTStatus));
    return NTStatus;
}



/*****************************************************************************
* History:
* $Log: cmbp0pnp.c $
* Revision 1.4  2000/08/24 09:05:12  TBruendl
* No comment given
*
* Revision 1.3  2000/07/27 13:53:01  WFrischauf
* No comment given
*
*
******************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\bulltlp3\tlp3nt.c ===
/*++

Copyright (C) 1997, 98 Microsoft Corporation

Module Name:

    bulltlp3.c

Abstract:

    Smart card driver for Bull TLP3 reader

Author:

    Klaus U. Schutz

Environment:

    Kernel mode

Revision History :

    Nov. 1997 - 1.0 Release
    Jan. 1998 - Fix for vendor defined IOCTLs
                TLP3SerialIo now writes the whole data packet if GT is 0
                Support for higher data rates added
    Feb. 1998 - PnP version

--*/

#include <stdio.h>
#include "bulltlp3.h"

#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGEABLE, TLP3AddDevice)
#pragma alloc_text(PAGEABLE, TLP3CreateDevice)
#pragma alloc_text(PAGEABLE, TLP3RemoveDevice)
#pragma alloc_text(PAGEABLE, TLP3DriverUnload)

#if DBG
#pragma optimize ("", off)
#endif

#ifdef SIMULATION
PWSTR DriverKey;
#endif

NTSTATUS
DriverEntry(
           IN  PDRIVER_OBJECT  DriverObject,
           IN  PUNICODE_STRING RegistryPath
           )
/*++

Routine Description:

    This routine is called at system initialization time to initialize
    this driver.

Arguments:

    DriverObject    - Supplies the driver object.
    RegistryPath    - Supplies the registry path for this driver.

Return Value:

    STATUS_SUCCESS          - We could initialize at least one device.
    STATUS_NO_SUCH_DEVICE   - We could not initialize even one device.

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    ULONG device;

    SmartcardDebug(
                  DEBUG_INFO,
                  ("%s!DriverEntry: Enter - %s %s\n",
                   DRIVER_NAME,
                   __DATE__,
                   __TIME__)
                  )

    //
    // we do some stuff in this driver that
    // assumes a single digit port number
    //
    ASSERT(MAXIMUM_SERIAL_READERS < 10);

    // Initialize the Driver Object with driver's entry points
    DriverObject->DriverUnload = TLP3DriverUnload;
    DriverObject->MajorFunction[IRP_MJ_CREATE] = TLP3CreateClose;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] = TLP3CreateClose;
    DriverObject->MajorFunction[IRP_MJ_CLEANUP] = TLP3Cleanup;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = TLP3DeviceControl;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = TLP3SystemControl;
    DriverObject->MajorFunction[IRP_MJ_PNP]   = TLP3PnP;
    DriverObject->MajorFunction[IRP_MJ_POWER] = TLP3Power;
    DriverObject->DriverExtension->AddDevice = TLP3AddDevice;

#ifdef SIMULATION
    DriverKey = ExAllocatePool(PagedPool, RegistryPath->Length + sizeof(L""));

    if (DriverKey) {

        RtlZeroMemory(
                     DriverKey,
                     RegistryPath->Length + sizeof(L"")
                     );

        RtlCopyMemory(
                     DriverKey,
                     RegistryPath->Buffer,
                     RegistryPath->Length
                     );
    }
#endif

    return status;
}

NTSTATUS
TLP3AddDevice(
             IN PDRIVER_OBJECT DriverObject,
             IN PDEVICE_OBJECT PhysicalDeviceObject
             )
/*++

Routine Description:

    This routine creates an object for the physical device specified and
    sets up the deviceExtension.

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS status = STATUS_SUCCESS;
    PREADER_EXTENSION readerExtension;
    PSMARTCARD_EXTENSION smartcardExtension;
    ULONG deviceInstance;
    PDEVICE_OBJECT DeviceObject = NULL;

    // this is a list of our supported data rates
    static ULONG dataRatesSupported[] = { 9600, 19200, 38400, 57600, 115200};


    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "%s!TLP3AddDevice: Enter\n",
                    DRIVER_NAME)
                  );

    PAGED_CODE();

    __try {

      // Create the device object
        status = IoCreateDevice(
                               DriverObject,
                               sizeof(DEVICE_EXTENSION),
                               NULL,
                               FILE_DEVICE_SMARTCARD,
                               0,
                               TRUE,
                               &DeviceObject
                               );

        if (status != STATUS_SUCCESS) {

            SmartcardLogError(
                             DriverObject,
                             TLP3_CANT_CREATE_DEVICE,
                             NULL,
                             0
                             );

            __leave;
        }

        SmartcardDebug(
                      DEBUG_TRACE,
                      ( "%s!TLP3CreateDevice: Device created\n",
                        DRIVER_NAME)
                      );

      // set up the device extension.
        deviceExtension = DeviceObject->DeviceExtension;
        smartcardExtension = &deviceExtension->SmartcardExtension;

        deviceExtension->CloseSerial = IoAllocateWorkItem(
                                                         DeviceObject
                                                         );

      // Used for stop / start notification
        KeInitializeEvent(
                         &deviceExtension->ReaderStarted,
                         NotificationEvent,
                         FALSE
                         );

      // Used to keep track of open close calls
        deviceExtension->ReaderOpen = FALSE;

        KeInitializeSpinLock(&deviceExtension->SpinLock);

      // Allocate data struct space for smart card reader
        smartcardExtension->ReaderExtension = ExAllocatePool(
                                                            NonPagedPool,
                                                            sizeof(READER_EXTENSION)
                                                            );

        if (smartcardExtension->ReaderExtension == NULL) {

            SmartcardLogError(
                             DriverObject,
                             TLP3_NO_MEMORY,
                             NULL,
                             0
                             );

            status = STATUS_INSUFFICIENT_RESOURCES;
            __leave;
        }

        readerExtension = smartcardExtension->ReaderExtension;
        RtlZeroMemory(readerExtension, sizeof(READER_EXTENSION));

      // Write the version of the lib we use to the smartcard extension
        smartcardExtension->Version = SMCLIB_VERSION;
        smartcardExtension->SmartcardRequest.BufferSize =
        smartcardExtension->SmartcardReply.BufferSize = MIN_BUFFER_SIZE;

      //
      // Now let the lib allocate the buffer for data transmission
      // We can either tell the lib how big the buffer should be
      // by assigning a value to BufferSize or let the lib
      // allocate the default size
      //
        status = SmartcardInitialize(smartcardExtension);

        if (status != STATUS_SUCCESS) {

            SmartcardLogError(
                             DriverObject,
                             (smartcardExtension->OsData ? TLP3_WRONG_LIB_VERSION : TLP3_NO_MEMORY),
                             NULL,
                             0
                             );

            __leave;
        }

      // Save deviceObject
        smartcardExtension->OsData->DeviceObject = DeviceObject;

      // Set up call back functions
        smartcardExtension->ReaderFunction[RDF_TRANSMIT] = TLP3Transmit;
        smartcardExtension->ReaderFunction[RDF_SET_PROTOCOL] = TLP3SetProtocol;
        smartcardExtension->ReaderFunction[RDF_CARD_POWER] = TLP3ReaderPower;
        smartcardExtension->ReaderFunction[RDF_CARD_TRACKING] = TLP3CardTracking;
        smartcardExtension->ReaderFunction[RDF_IOCTL_VENDOR] = TLP3VendorIoctl;

      // This event signals that the serial driver has been closed
        KeInitializeEvent(
                         &READER_EXTENSION_L(SerialCloseDone),
                         NotificationEvent,
                         TRUE
                         );

      //
      // Set the vendor information
      //
        strcpy(smartcardExtension->VendorAttr.VendorName.Buffer, "Bull");

        smartcardExtension->VendorAttr.VendorName.Length =
        (USHORT) strlen(deviceExtension->SmartcardExtension.VendorAttr.VendorName.Buffer);

        strcpy(smartcardExtension->VendorAttr.IfdType.Buffer, "SmarTLP");

        smartcardExtension->VendorAttr.IfdType.Length =
        (USHORT) strlen(smartcardExtension->VendorAttr.IfdType.Buffer);

        smartcardExtension->VendorAttr.UnitNo = MAXULONG;

        for (deviceInstance = 0; deviceInstance < MAXULONG; deviceInstance++) {

            PDEVICE_OBJECT devObj;

            for (devObj = DeviceObject;
                devObj != NULL;
                devObj = devObj->NextDevice) {

                PDEVICE_EXTENSION devExt = devObj->DeviceExtension;
                PSMARTCARD_EXTENSION smcExt = &devExt->SmartcardExtension;

                if (deviceInstance == smcExt->VendorAttr.UnitNo) {

                    break;
                }
            }
            if (devObj == NULL) {

                smartcardExtension->VendorAttr.UnitNo = deviceInstance;
                break;
            }
        }

      //
      // Set the reader capabilities
      //

      // Clk frequency in KHz encoded as little endian integer
        smartcardExtension->ReaderCapabilities.CLKFrequency.Default = 3571;
        smartcardExtension->ReaderCapabilities.CLKFrequency.Max = 3571;

        smartcardExtension->ReaderCapabilities.DataRate.Default =
        smartcardExtension->ReaderCapabilities.DataRate.Max =
        dataRatesSupported[0];

      // reader could support higher data rates
        smartcardExtension->ReaderCapabilities.DataRatesSupported.List =
        dataRatesSupported;
        smartcardExtension->ReaderCapabilities.DataRatesSupported.Entries =
        sizeof(dataRatesSupported) / sizeof(dataRatesSupported[0]);

        smartcardExtension->ReaderCapabilities.MaxIFSD = 254;

      // Now setup information in our deviceExtension
        smartcardExtension->ReaderCapabilities.CurrentState =
        (ULONG) SCARD_UNKNOWN;

      // This reader supports T=0 and T=1
        smartcardExtension->ReaderCapabilities.SupportedProtocols =
        SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1;

        smartcardExtension->ReaderCapabilities.MechProperties = 0;

      //
      // Set serial configuration parameters
      //
        readerExtension->SerialConfigData.BaudRate.BaudRate = 9600;

        readerExtension->SerialConfigData.LineControl.StopBits =
        STOP_BITS_2;
        readerExtension->SerialConfigData.LineControl.Parity =
        EVEN_PARITY;
        readerExtension->SerialConfigData.LineControl.WordLength =
        SERIAL_DATABITS_8;

      // set timeouts
        readerExtension->SerialConfigData.Timeouts.ReadIntervalTimeout =
        READ_INTERVAL_TIMEOUT_DEFAULT;
        readerExtension->SerialConfigData.Timeouts.ReadTotalTimeoutConstant =
        READ_TOTAL_TIMEOUT_CONSTANT_DEFAULT;
        readerExtension->SerialConfigData.Timeouts.ReadTotalTimeoutMultiplier = 0;

      // set special characters
        readerExtension->SerialConfigData.SerialChars.ErrorChar = 0;
        readerExtension->SerialConfigData.SerialChars.EofChar = 0;
        readerExtension->SerialConfigData.SerialChars.EventChar = 0;
        readerExtension->SerialConfigData.SerialChars.XonChar = 0;
        readerExtension->SerialConfigData.SerialChars.XoffChar = 0;
        readerExtension->SerialConfigData.SerialChars.BreakChar = 0xFF;

      // Set handflow
        readerExtension->SerialConfigData.HandFlow.XonLimit = 0;
        readerExtension->SerialConfigData.HandFlow.XoffLimit = 0;
        readerExtension->SerialConfigData.HandFlow.ControlHandShake = 0;
        readerExtension->SerialConfigData.HandFlow.FlowReplace =
        SERIAL_XOFF_CONTINUE;
#if defined (DEBUG) && defined (DETECT_SERIAL_OVERRUNS)
        readerExtension->SerialConfigData.HandFlow.ControlHandShake =
        SERIAL_ERROR_ABORT;
#endif




      // save the current power state of the reader
        readerExtension->ReaderPowerState = PowerReaderWorking;

        // and attach to the PDO
        ATTACHED_DEVICE_OBJECT =
        IoAttachDeviceToDeviceStack(
                                   DeviceObject,
                                   PhysicalDeviceObject
                                   );

        ASSERT(ATTACHED_DEVICE_OBJECT != NULL);

        if (ATTACHED_DEVICE_OBJECT == NULL) {

            SmartcardLogError(
                             DriverObject,
                             TLP3_CANT_CONNECT_TO_ASSIGNED_PORT,
                             NULL,
                             status
                             );

            status = STATUS_UNSUCCESSFUL;
            __leave;
        }

        // register our new device
        status = IoRegisterDeviceInterface(
                                          PhysicalDeviceObject,
                                          &SmartCardReaderGuid,
                                          NULL,
                                          &deviceExtension->PnPDeviceName
                                          );
        ASSERT(status == STATUS_SUCCESS);

        DeviceObject->Flags |= DO_BUFFERED_IO;
        DeviceObject->Flags |= DO_POWER_PAGABLE;
        DeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    }
    __finally {

        if (status != STATUS_SUCCESS) {

            TLP3RemoveDevice(DeviceObject);
        }

        SmartcardDebug(
                      DEBUG_TRACE,
                      ( "%s!TLP3AddDevice: Exit %x\n",
                        DRIVER_NAME,
                        status)
                      );
    }
    return status;
}

NTSTATUS
TLP3StartDevice(
               IN PDEVICE_OBJECT DeviceObject
               )
/*++

Routine Description:
   Open the serial device, start card tracking and register our
    device interface. If any of the calls here fails we don't care
    to rollback since a stop will be called later which we then
    use to clean up.

--*/
{
    NTSTATUS status;
    PIRP irp;
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PSMARTCARD_EXTENSION smartcardExtension = &deviceExtension->SmartcardExtension;

    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "%s!TLP3StartDevice: Enter\n",
                    DRIVER_NAME)
                  );

    irp = IoAllocateIrp(
                       (CCHAR) (DeviceObject->StackSize + 1),
                       FALSE
                       );

    ASSERT(irp != NULL);

    if (irp == NULL) {

        return STATUS_NO_MEMORY;
    }

    _try {

        PIO_STACK_LOCATION irpStack;
        HANDLE handle = 0;
        IO_STATUS_BLOCK ioStatusBlock;

        //
        // Open the underlying serial driver.
        // This is necessary for two reasons:
        // a) The serial driver can't be used without opening it
        // b) The call will go through serenum first which informs
        //    it to stop looking/polling for new devices.
        //
        irp->UserIosb = &ioStatusBlock;
        IoSetNextIrpStackLocation(irp);
        irpStack = IoGetCurrentIrpStackLocation(irp);

        irpStack->MajorFunction = IRP_MJ_CREATE;
        irpStack->Parameters.Create.Options = 0;
        irpStack->Parameters.Create.ShareAccess = 0;
        irpStack->Parameters.Create.FileAttributes = 0;
        irpStack->Parameters.Create.EaLength = 0;

        status = TLP3CallSerialDriver(
                                     ATTACHED_DEVICE_OBJECT,
                                     irp
                                     );
        if (status != STATUS_SUCCESS) {

            leave;
        }

        KeClearEvent(&READER_EXTENSION_L(SerialCloseDone));

        status = TLP3ConfigureSerialPort(&deviceExtension->SmartcardExtension);
        if (status != STATUS_SUCCESS) {

            leave;
        }

        status = TLP3StartSerialEventTracking(
                                             &deviceExtension->SmartcardExtension
                                             );

        if (status != STATUS_SUCCESS) {

            leave;
        }

        status = IoSetDeviceInterfaceState(
                                          &deviceExtension->PnPDeviceName,
                                          TRUE
                                          );

        if (status != STATUS_SUCCESS) {

            leave;
        }

        KeSetEvent(&deviceExtension->ReaderStarted, 0, FALSE);
    }
    _finally {

        if (status == STATUS_SHARED_IRQ_BUSY) {

            SmartcardLogError(
                             DeviceObject,
                             TLP3_IRQ_BUSY,
                             NULL,
                             status
                             );
        }

        if (status != STATUS_SUCCESS) {

            TLP3StopDevice(DeviceObject);
        }

        IoFreeIrp(irp);
    }

    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "%s!TLP3StartDevice: Exit %lx\n",
                    DRIVER_NAME,
                    status)
                  );

    return status;
}

VOID
TLP3StopDevice(
              IN PDEVICE_OBJECT DeviceObject
              )
/*++

Routine Description:
    Finishes card tracking requests and closes the connection to the
    serial driver.

--*/
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PSMARTCARD_EXTENSION smartcardExtension = &deviceExtension->SmartcardExtension;

    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "%s!TLP3StopDevice: Enter\n",
                    DRIVER_NAME)
                  );

    if (KeReadStateEvent(&READER_EXTENSION_L(SerialCloseDone)) == 0l) {

        NTSTATUS status;
        PUCHAR requestBuffer;


        // test if we ever started event tracking
        if (smartcardExtension->ReaderExtension->SerialConfigData.SerialWaitMask == 0) {

            // no, we did not
            // We 'only' need to close the serial port
            TLP3CloseSerialPort(DeviceObject, NULL);

        } else {

            //
            // We now inform the serial driver that we're not longer
            // interested in serial events. This will also free the irp
            // we use for those io-completions
            //
            smartcardExtension->ReaderExtension->SerialConfigData.SerialWaitMask = 0;

            // save the pointer
            requestBuffer = smartcardExtension->SmartcardRequest.Buffer;

            *(PULONG) smartcardExtension->SmartcardRequest.Buffer =
            smartcardExtension->ReaderExtension->SerialConfigData.SerialWaitMask;

            smartcardExtension->SmartcardRequest.BufferLength = sizeof(ULONG);

            smartcardExtension->ReaderExtension->SerialIoControlCode =
            IOCTL_SERIAL_SET_WAIT_MASK;

           // We don't expect to get bytes back
            smartcardExtension->SmartcardReply.BufferLength = 0;

            TLP3SerialIo(smartcardExtension);

            // restore the pointer
            smartcardExtension->SmartcardRequest.Buffer = requestBuffer;

            // now wait until the connetion to serial is closed
            status = KeWaitForSingleObject(
                                          &READER_EXTENSION_L(SerialCloseDone),
                                          Executive,
                                          KernelMode,
                                          FALSE,
                                          NULL
                                          );
            ASSERT(status == STATUS_SUCCESS);
        }
    }

    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "%s!TLP3StopDevice: Exit\n",
                    DRIVER_NAME)
                  );
}

NTSTATUS
TLP3SystemControl(
                 PDEVICE_OBJECT DeviceObject,
                 PIRP        Irp
                 )
/*++

--*/
{
    PDEVICE_EXTENSION DeviceExtension; 
    NTSTATUS status = STATUS_SUCCESS;

    DeviceExtension      = DeviceObject->DeviceExtension;

    IoSkipCurrentIrpStackLocation(Irp);
    status = IoCallDriver(DeviceExtension->SmartcardExtension.ReaderExtension->AttachedDeviceObject, Irp);

    return status;

}

NTSTATUS
TLP3DeviceControl(
                 PDEVICE_OBJECT DeviceObject,
                 PIRP Irp
                 )
/*++

Routine Description:
    This is our IOCTL dispatch function

--*/
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PSMARTCARD_EXTENSION smartcardExtension = &deviceExtension->SmartcardExtension;
    NTSTATUS status = STATUS_SUCCESS;
    KIRQL irql;
#ifdef SIMULATION
    RTL_QUERY_REGISTRY_TABLE parameters[2];
#endif

    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "%s!TLP3DeviceControl: Enter\n",
                    DRIVER_NAME)
                  );

    if (smartcardExtension->ReaderExtension->SerialConfigData.SerialWaitMask == 0) {

      //
      // the wait mask is set to 0 whenever the device was either
      // surprise-removed or politely removed
      //
        status = STATUS_DEVICE_REMOVED;
    }

    if (status == STATUS_SUCCESS) {
        KeAcquireSpinLock(&deviceExtension->SpinLock, &irql);
        if (deviceExtension->IoCount == 0) {

            KeReleaseSpinLock(&deviceExtension->SpinLock, irql);
            status = KeWaitForSingleObject(
                                          &deviceExtension->ReaderStarted,
                                          Executive,
                                          KernelMode,
                                          FALSE,
                                          NULL
                                          );
            ASSERT(status == STATUS_SUCCESS);

            KeAcquireSpinLock(&deviceExtension->SpinLock, &irql);
        }
        ASSERT(deviceExtension->IoCount >= 0);
        deviceExtension->IoCount++;
        KeReleaseSpinLock(&deviceExtension->SpinLock, irql);


        status = SmartcardAcquireRemoveLockWithTag(smartcardExtension, 'tcoI');
    }

    if (!NT_SUCCESS(status)) {

        // the device has been removed. Fail the call
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = STATUS_DEVICE_REMOVED;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_DEVICE_REMOVED;
    }

#ifdef SIMULATION
    if (DriverKey) {

        ULONG oldLevel =
        smartcardExtension->ReaderExtension->SimulationLevel;

        RtlZeroMemory(parameters, sizeof(parameters));

        parameters[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[0].Name = L"SimulationLevel";
        parameters[0].EntryContext =
        &smartcardExtension->ReaderExtension->SimulationLevel;
        parameters[0].DefaultType = REG_DWORD;
        parameters[0].DefaultData =
        &smartcardExtension->ReaderExtension->SimulationLevel;
        parameters[0].DefaultLength = sizeof(ULONG);

        if (RtlQueryRegistryValues(
                                  RTL_REGISTRY_ABSOLUTE,
                                  DriverKey,
                                  parameters,
                                  NULL,
                                  NULL
                                  ) == STATUS_SUCCESS) {

            SmartcardDebug(
                          smartcardExtension->ReaderExtension->SimulationLevel == oldLevel ? 0 : DEBUG_SIMULATION,
                          ( "%s!TLP3AddDevice: SimulationLevel set to %lx\n",
                            DRIVER_NAME,
                            smartcardExtension->ReaderExtension->SimulationLevel)
                          );
        }
    }
#endif

    ASSERT(smartcardExtension->ReaderExtension->ReaderPowerState ==
           PowerReaderWorking);

    status = SmartcardDeviceControl(
                                   smartcardExtension,
                                   Irp
                                   );

    SmartcardReleaseRemoveLockWithTag(smartcardExtension, 'tcoI');

    KeAcquireSpinLock(&deviceExtension->SpinLock, &irql);
    deviceExtension->IoCount--;
    ASSERT(deviceExtension->IoCount >= 0);
    KeReleaseSpinLock(&deviceExtension->SpinLock, irql);

    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "%s!TLP3DeviceControl: Exit %lx\n",
                    DRIVER_NAME,
                    status)
                  );

    return status;
}

VOID
TLP3CloseSerialPort(
                   IN PDEVICE_OBJECT DeviceObject,
                   IN PVOID Context
                   )
/*++

Routine Description:
    This function closes the connection to the serial driver when the reader
    has been removed (unplugged). This function runs as a system thread at
    IRQL == PASSIVE_LEVEL. It waits for the remove event that is set by
    the IoCompletionRoutine

--*/
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PSMARTCARD_EXTENSION smartcardExtension = &deviceExtension->SmartcardExtension;
    NTSTATUS status;
    PIRP irp;
    PIO_STACK_LOCATION irpStack;
    IO_STATUS_BLOCK ioStatusBlock;

    UNREFERENCED_PARAMETER(Context);

    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "%s!TLP3CloseSerialPort: Enter\n",
                    DRIVER_NAME)
                  );

    //
    // first mark this device as 'gone'.
    // This will prevent that someone can re-open the device
    // We intentionally ignore possible errors
    //
    IoSetDeviceInterfaceState(
                             &deviceExtension->PnPDeviceName,
                             FALSE
                             );

    irp = IoAllocateIrp(
                       (CCHAR) (DeviceObject->StackSize + 1),
                       FALSE
                       );

    ASSERT(irp != NULL);

    if (irp) {

        SmartcardDebug(
                      DEBUG_DRIVER,
                      ( "%s!TLP3CloseSerialPort: Sending IRP_MJ_CLOSE\n",
                        DRIVER_NAME)
                      );

        IoSetNextIrpStackLocation(irp);

        //
        // We send down a close to the serial driver. This close goes
        // through serenum first which will trigger it to start looking
        // for changes on the com-port. Since our device is gone it will
        // call the device removal event of our PnP dispatch.
        //
        irp->UserIosb = &ioStatusBlock;
        irpStack = IoGetCurrentIrpStackLocation( irp );
        irpStack->MajorFunction = IRP_MJ_CLOSE;

        status = TLP3CallSerialDriver(
                                     ATTACHED_DEVICE_OBJECT,
                                     irp
                                     );

        ASSERT(status == STATUS_SUCCESS);

        IoFreeIrp(irp);
    }

    // now 'signal' that we closed the serial driver
    KeSetEvent(
              &READER_EXTENSION_L(SerialCloseDone),
              0,
              FALSE
              );

    SmartcardDebug(
                  DEBUG_INFO,
                  ( "%s!TLP3CloseSerialPort: Exit\n",
                    DRIVER_NAME)
                  );
}

NTSTATUS
TLP3IoCompletion (
                 IN PDEVICE_OBJECT DeviceObject,
                 IN PIRP Irp,
                 IN PKEVENT Event
                 )
{
    UNREFERENCED_PARAMETER (DeviceObject);

    if (Irp->Cancel) {

        Irp->IoStatus.Status = STATUS_CANCELLED;

    } else {

        Irp->IoStatus.Status = STATUS_MORE_PROCESSING_REQUIRED;
    }

    KeSetEvent (Event, 0, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
TLP3CallSerialDriver(
                    IN PDEVICE_OBJECT DeviceObject,
                    IN PIRP Irp
                    )
/*++

Routine Description:
   Send an Irp to the serial driver.

--*/
{

    NTSTATUS status = STATUS_SUCCESS;
    KEVENT Event;

    // Copy our stack location to the next.
    IoCopyCurrentIrpStackLocationToNext(Irp);

   //
   // initialize an event for process synchronization. The event is passed
   // to our completion routine and will be set when the serial driver is done
   //
    KeInitializeEvent(
                     &Event,
                     NotificationEvent,
                     FALSE
                     );

    // Our IoCompletionRoutine sets only our event
    IoSetCompletionRoutine (
                           Irp,
                           TLP3IoCompletion,
                           &Event,
                           TRUE,
                           TRUE,
                           TRUE
                           );

    if (IoGetCurrentIrpStackLocation(Irp)->MajorFunction == IRP_MJ_POWER) {

        status = PoCallDriver(DeviceObject, Irp);

    } else {

        // Call the serial driver
        status = IoCallDriver(DeviceObject, Irp);
    }

   // Wait until the serial driver has processed the Irp
    if (status == STATUS_PENDING) {

        status = KeWaitForSingleObject(
                                      &Event,
                                      Executive,
                                      KernelMode,
                                      FALSE,
                                      NULL
                                      );

        ASSERT (STATUS_SUCCESS == status);
        status = Irp->IoStatus.Status;
    }

    return status;
}

NTSTATUS
TLP3PnP(
       IN PDEVICE_OBJECT DeviceObject,
       IN PIRP Irp
       )
/*++

Routine Description:

--*/
{

    PUCHAR requestBuffer;
    NTSTATUS status = STATUS_SUCCESS;
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PSMARTCARD_EXTENSION smartcardExtension = &deviceExtension->SmartcardExtension;
    PREADER_EXTENSION readerExtension = smartcardExtension->ReaderExtension;
    PDEVICE_OBJECT AttachedDeviceObject;
    PIO_STACK_LOCATION irpStack;
    IO_STATUS_BLOCK ioStatusBlock;
    BOOLEAN deviceRemoved = FALSE, irpSkipped = FALSE;
    KIRQL irql;

    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "%s!TLP3PnPDeviceControl: Enter\n",
                    DRIVER_NAME)
                  );

    status = SmartcardAcquireRemoveLockWithTag(smartcardExtension, ' PnP');
    ASSERT(status == STATUS_SUCCESS);

    if (status != STATUS_SUCCESS) {

        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    AttachedDeviceObject = ATTACHED_DEVICE_OBJECT;


    irpStack = IoGetCurrentIrpStackLocation(Irp);

    // Now look what the PnP manager wants...
    switch (irpStack->MinorFunction) {
    case IRP_MN_START_DEVICE:

        SmartcardDebug(
                      DEBUG_DRIVER,
                      ("%s!TLP3PnPDeviceControl: IRP_MN_START_DEVICE\n",
                       DRIVER_NAME)
                      );

            // We have to call the underlying driver first
        status = TLP3CallSerialDriver(AttachedDeviceObject, Irp);
        ASSERT(NT_SUCCESS(status));

        if (NT_SUCCESS(status)) {

            status = TLP3StartDevice(DeviceObject);
        }
        break;

    case IRP_MN_QUERY_STOP_DEVICE:

        SmartcardDebug(
                      DEBUG_DRIVER,
                      ("%s!TLP3PnPDeviceControl: IRP_MN_QUERY_STOP_DEVICE\n",
                       DRIVER_NAME)
                      );
        KeAcquireSpinLock(&deviceExtension->SpinLock, &irql);
        if (deviceExtension->IoCount > 0) {

                // we refuse to stop if we have pending io
            KeReleaseSpinLock(&deviceExtension->SpinLock, irql);
            status = STATUS_DEVICE_BUSY;

        } else {



                // stop processing requests

            KeClearEvent(&deviceExtension->ReaderStarted);
            KeReleaseSpinLock(&deviceExtension->SpinLock, irql);

            status = TLP3CallSerialDriver(AttachedDeviceObject, Irp);
        }

        break;

    case IRP_MN_CANCEL_STOP_DEVICE:

        SmartcardDebug(
                      DEBUG_DRIVER,
                      ("%s!TLP3PnPDeviceControl: IRP_MN_CANCEL_STOP_DEVICE\n",
                       DRIVER_NAME)
                      );

        status = TLP3CallSerialDriver(AttachedDeviceObject, Irp);

        if (status == STATUS_SUCCESS) {

                // we can continue to process requests
            KeSetEvent(&deviceExtension->ReaderStarted, 0, FALSE);
        }
        break;

    case IRP_MN_STOP_DEVICE:

        SmartcardDebug(
                      DEBUG_DRIVER,
                      ("%s!TLP3PnPDeviceControl: IRP_MN_STOP_DEVICE\n",
                       DRIVER_NAME)
                      );

        TLP3StopDevice(DeviceObject);

            //
            // we don't do anything since a stop is only used
            // to reconfigure hw-resources like interrupts and io-ports
            //
        status = TLP3CallSerialDriver(AttachedDeviceObject, Irp);
        break;

    case IRP_MN_QUERY_REMOVE_DEVICE:

        SmartcardDebug(
                      DEBUG_DRIVER,
                      ("%s!TLP3PnPDeviceControl: IRP_MN_QUERY_REMOVE_DEVICE\n",
                       DRIVER_NAME)
                      );

            // disable the interface (and ignore possible errors)
        IoSetDeviceInterfaceState(
                                 &deviceExtension->PnPDeviceName,
                                 FALSE
                                 );

            // now look if someone is currently connected to us
        if (deviceExtension->ReaderOpen) {

                //
                // someone is connected, fail the call
                // we will enable the device interface in
                // IRP_MN_CANCEL_REMOVE_DEVICE again
                //
            status = STATUS_UNSUCCESSFUL;
            break;
        }

            // pass the call to the next driver in the stack
        status = TLP3CallSerialDriver(AttachedDeviceObject, Irp);
        break;

    case IRP_MN_CANCEL_REMOVE_DEVICE:

        SmartcardDebug(
                      DEBUG_DRIVER,
                      ("%s!TLP3PnPDeviceControl: IRP_MN_CANCEL_REMOVE_DEVICE\n",
                       DRIVER_NAME)
                      );

        status = TLP3CallSerialDriver(AttachedDeviceObject, Irp);

         //
         // reenable the interface only in case that the reader is
         // still connected. This covers the following case:
         // hibernate machine, disconnect reader, wake up, stop device
         // (from task bar) and stop fails since an app. holds the device open
         //
        if (status == STATUS_SUCCESS &&
            READER_EXTENSION_L(SerialConfigData.SerialWaitMask) != 0) {

            status = IoSetDeviceInterfaceState(
                                              &deviceExtension->PnPDeviceName,
                                              TRUE
                                              );

            ASSERT(status == STATUS_SUCCESS);
        }
        break;

    case IRP_MN_REMOVE_DEVICE:

        SmartcardDebug(
                      DEBUG_DRIVER,
                      ("%s!TLP3PnPDeviceControl: IRP_MN_REMOVE_DEVICE\n",
                       DRIVER_NAME)
                      );

        TLP3RemoveDevice(DeviceObject);
        status = TLP3CallSerialDriver(AttachedDeviceObject, Irp);
        deviceRemoved = TRUE;
        break;

    default:
            // This is an Irp that is only useful for underlying drivers
        SmartcardDebug(
                      DEBUG_DRIVER,
                      ("%s!TLP3PnPDeviceControl: IRP_MN_...%lx\n",
                       DRIVER_NAME,
                       irpStack->MinorFunction)
                      );

        IoSkipCurrentIrpStackLocation(Irp);
        status = IoCallDriver(AttachedDeviceObject, Irp);
        irpSkipped = TRUE;
        break;
    }

    if (irpSkipped == FALSE) {

        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    if (deviceRemoved == FALSE) {

        SmartcardReleaseRemoveLockWithTag(smartcardExtension, ' PnP');
    }

    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "%s!TLP3PnPDeviceControl: Exit %lx\n",
                    DRIVER_NAME,
                    status)
                  );

    return status;
}

VOID
TLP3SystemPowerCompletion(
                         IN PDEVICE_OBJECT DeviceObject,
                         IN UCHAR MinorFunction,
                         IN POWER_STATE PowerState,
                         IN PKEVENT Event,
                         IN PIO_STATUS_BLOCK IoStatus
                         )
/*++

Routine Description:
    This function is called when the underlying stacks
    completed the power transition.

--*/
{
    UNREFERENCED_PARAMETER (DeviceObject);
    UNREFERENCED_PARAMETER (MinorFunction);
    UNREFERENCED_PARAMETER (PowerState);
    UNREFERENCED_PARAMETER (IoStatus);

    KeSetEvent(Event, 0, FALSE);
}

NTSTATUS
TLP3DevicePowerCompletion (
                          IN PDEVICE_OBJECT DeviceObject,
                          IN PIRP Irp,
                          IN PSMARTCARD_EXTENSION SmartcardExtension
                          )
/*++

Routine Description:
    This routine is called after the underlying stack powered
    UP the serial port, so it can be used again.

--*/
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    LARGE_INTEGER delayPeriod;
    KIRQL irql;

    //
    // Allow the reader enough time to power itself up
    //
    delayPeriod.HighPart = -1;
    delayPeriod.LowPart = 100000 * (-10);

    KeDelayExecutionThread(
                          KernelMode,
                          FALSE,
                          &delayPeriod
                          );


    //
    // We issue a power request in order to figure out
    // what the actual card status is
    //
    SmartcardExtension->MinorIoControlCode = SCARD_COLD_RESET;
    TLP3ReaderPower(SmartcardExtension);

    //
    // If a card was present before power down or now there is
    // a card in the reader, we complete any pending card monitor
    // request, since we do not really know what card is now in the
    // reader.
    //
    KeAcquireSpinLock(&SmartcardExtension->OsData->SpinLock,
                      &irql);
    if (SmartcardExtension->ReaderExtension->CardPresent ||
        SmartcardExtension->ReaderCapabilities.CurrentState > SCARD_ABSENT) {
        KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                          irql);

        TLP3CompleteCardTracking(SmartcardExtension);
    } else {
        KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                          irql);
    }


    // save the current power state of the reader
    SmartcardExtension->ReaderExtension->ReaderPowerState =
    PowerReaderWorking;

    SmartcardReleaseRemoveLockWithTag(SmartcardExtension, 'rwoP');

    // inform the power manager of our state.
    PoSetPowerState (
                    DeviceObject,
                    DevicePowerState,
                    irpStack->Parameters.Power.State
                    );

    PoStartNextPowerIrp(Irp);

    // signal that we can process ioctls again
    KeSetEvent(&deviceExtension->ReaderStarted, 0, FALSE);

    return STATUS_SUCCESS;
}

typedef enum _ACTION {

    Undefined = 0,
    SkipRequest,
    WaitForCompletion,
    CompleteRequest,
    MarkPending

} ACTION;

NTSTATUS
TLP3Power (
          IN PDEVICE_OBJECT DeviceObject,
          IN PIRP Irp
          )
/*++

Routine Description:
    The power dispatch routine.
    This driver is the power policy owner of the device stack,
    because this driver knows about the connected reader.
    Therefor this driver will translate system power states
    to device power states.

Arguments:
   DeviceObject - pointer to a device object.
   Irp - pointer to an I/O Request Packet.

Return Value:
      NT status code

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PSMARTCARD_EXTENSION smartcardExtension = &deviceExtension->SmartcardExtension;
    PDEVICE_OBJECT AttachedDeviceObject;
    POWER_STATE powerState;
    ACTION action = SkipRequest;
    KEVENT event;
    KIRQL irql;

    SmartcardDebug(
                  DEBUG_DRIVER,
                  ("%s!TLP3Power: Enter\n",
                   DRIVER_NAME)
                  );


    status = SmartcardAcquireRemoveLockWithTag(smartcardExtension, 'rwoP');
    ASSERT(status == STATUS_SUCCESS);

    if (!NT_SUCCESS(status)) {

        PoStartNextPowerIrp(Irp);
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    AttachedDeviceObject = ATTACHED_DEVICE_OBJECT;


    switch (irpStack->Parameters.Power.Type) {
    case DevicePowerState:
        if (irpStack->MinorFunction == IRP_MN_SET_POWER) {

            switch (irpStack->Parameters.Power.State.DeviceState) {
            
            case PowerDeviceD0:
            // Turn on the reader
                SmartcardDebug(
                              DEBUG_DRIVER,
                              ("%s!TLP3Power: PowerDevice D0\n",
                               DRIVER_NAME)
                              );

            //
            // First, we send down the request to the bus, in order
            // to power on the port. When the request completes,
            // we turn on the reader
            //
                IoCopyCurrentIrpStackLocationToNext(Irp);
                IoSetCompletionRoutine (
                                       Irp,
                                       TLP3DevicePowerCompletion,
                                       smartcardExtension,
                                       TRUE,
                                       TRUE,
                                       TRUE
                                       );

                action = WaitForCompletion;
                break;

            case PowerDeviceD3:
            // Turn off the reader
                SmartcardDebug(
                              DEBUG_DRIVER,
                              ("%s!TLP3Power: PowerDevice D3\n",
                               DRIVER_NAME)
                              );

                PoSetPowerState (
                                DeviceObject,
                                DevicePowerState,
                                irpStack->Parameters.Power.State
                                );

            // save the current card state

                KeAcquireSpinLock(&smartcardExtension->OsData->SpinLock,
                                  &irql);
                smartcardExtension->ReaderExtension->CardPresent =
                smartcardExtension->ReaderCapabilities.CurrentState > SCARD_ABSENT;
                KeReleaseSpinLock(&smartcardExtension->OsData->SpinLock,
                                  irql);

                if (smartcardExtension->ReaderExtension->CardPresent) {

                    smartcardExtension->MinorIoControlCode = SCARD_POWER_DOWN;
                    status = TLP3ReaderPower(smartcardExtension);
                    ASSERT(status == STATUS_SUCCESS);
                }

            //
            // If there is a pending card tracking request, setting
            // this flag will prevent completion of the request
            // when the system will be waked up again.
            //
                smartcardExtension->ReaderExtension->PowerRequest = TRUE;

            // save the current power state of the reader
                smartcardExtension->ReaderExtension->ReaderPowerState =
                PowerReaderOff;

                action = SkipRequest;
                break;

            default:
                ASSERT(FALSE);
                action = SkipRequest;
                break;
            }
        }

        break;

    case SystemPowerState: {

         //
         // The system wants to change the power state.
         // We need to translate the system power state to
         // a corresponding device power state.
         //

            POWER_STATE_TYPE powerType = DevicePowerState;

            ASSERT(smartcardExtension->ReaderExtension->ReaderPowerState !=
                   PowerReaderUnspecified);

            switch (irpStack->MinorFunction) {

            case IRP_MN_QUERY_POWER:

                SmartcardDebug(
                              DEBUG_DRIVER,
                              ("%s!TLP3Power: Query Power\n",
                               DRIVER_NAME)
                              );

                switch (irpStack->Parameters.Power.State.SystemState) {
                
                case PowerSystemMaximum:
                case PowerSystemWorking:
                case PowerSystemSleeping1:
                case PowerSystemSleeping2:
                    action = SkipRequest;
                    break;

                case PowerSystemSleeping3:
                case PowerSystemHibernate:
                case PowerSystemShutdown:
                    KeAcquireSpinLock(&deviceExtension->SpinLock, &irql);
                    if (deviceExtension->IoCount == 0) {

                  // Block any further ioctls

                        KeClearEvent(&deviceExtension->ReaderStarted);
                        action = SkipRequest;
                    } else {

                  // can't go to sleep mode since the reader is busy.
                        status = STATUS_DEVICE_BUSY;
                        action = CompleteRequest;
                    }
                    KeReleaseSpinLock(&deviceExtension->SpinLock, irql);

                    break;
                }
                break;

            case IRP_MN_SET_POWER:

                SmartcardDebug(
                              DEBUG_DRIVER,
                              ("%s!TLP3Power: PowerSystem S%d\n",
                               DRIVER_NAME,
                               irpStack->Parameters.Power.State.SystemState - 1)
                              );

                switch (irpStack->Parameters.Power.State.SystemState) {
                
                case PowerSystemMaximum:
                case PowerSystemWorking:
                case PowerSystemSleeping1:
                case PowerSystemSleeping2:

                    if (smartcardExtension->ReaderExtension->ReaderPowerState ==
                        PowerReaderWorking) {

                  // We're already in the right state
                        KeSetEvent(&deviceExtension->ReaderStarted, 0, FALSE);
                        action = SkipRequest;
                        break;
                    }

               // wake up the underlying stack...
                    powerState.DeviceState = PowerDeviceD0;
                    action = MarkPending;
                    break;

                case PowerSystemSleeping3:
                case PowerSystemHibernate:
                case PowerSystemShutdown:

                    if (smartcardExtension->ReaderExtension->ReaderPowerState ==
                        PowerReaderOff) {

                  // We're already in the right state
                        action = SkipRequest;
                        break;
                    }

                    powerState.DeviceState = PowerDeviceD3;


               // first, inform the power manager of our new state.
                    PoSetPowerState (
                                    DeviceObject,
                                    SystemPowerState,
                                    powerState
                                    );

                    action = MarkPending;
                    break;

                default:
                    ASSERT(FALSE);
                    action = SkipRequest;
                    break;
                }
                break;
            }
        }
        break;

    default:
        ASSERT(FALSE);
        action = SkipRequest;
        break;
    }

    switch (action) {
    
    case CompleteRequest:
        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = 0;

        SmartcardReleaseRemoveLockWithTag(smartcardExtension, 'rwoP');
        PoStartNextPowerIrp(Irp);
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        break;

    case MarkPending:

         // initialize the event we need in the completion function
        KeInitializeEvent(
                         &event,
                         NotificationEvent,
                         FALSE
                         );

         // request the device power irp
        status = PoRequestPowerIrp (
                                   DeviceObject,
                                   IRP_MN_SET_POWER,
                                   powerState,
                                   TLP3SystemPowerCompletion,
                                   &event,
                                   NULL
                                   );
        ASSERT(status == STATUS_PENDING);

        if (status == STATUS_PENDING) {

            // wait until the device power irp completed
            status = KeWaitForSingleObject(
                                          &event,
                                          Executive,
                                          KernelMode,
                                          FALSE,
                                          NULL
                                          );

            SmartcardReleaseRemoveLockWithTag(smartcardExtension, 'rwoP');

            if (powerState.SystemState == PowerSystemWorking) {

                PoSetPowerState (
                                DeviceObject,
                                SystemPowerState,
                                powerState
                                );
            }

            PoStartNextPowerIrp(Irp);
            IoSkipCurrentIrpStackLocation(Irp);
            status = PoCallDriver(AttachedDeviceObject, Irp);

        } else {

            SmartcardReleaseRemoveLockWithTag(smartcardExtension, 'rwoP');
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
        }

        break;

    case SkipRequest:
        SmartcardReleaseRemoveLockWithTag(smartcardExtension, 'rwoP');
        PoStartNextPowerIrp(Irp);
        IoSkipCurrentIrpStackLocation(Irp);
        status = PoCallDriver(AttachedDeviceObject, Irp);
        break;

    case WaitForCompletion:
        status = PoCallDriver(AttachedDeviceObject, Irp);
        break;

    default:
        ASSERT(FALSE);
        break;
    }

    SmartcardDebug(
                  DEBUG_DRIVER,
                  ("%s!TLP3Power: Exit %lx\n",
                   DRIVER_NAME,
                   status)
                  );

    return status;
}

NTSTATUS
TLP3CreateClose(
               IN PDEVICE_OBJECT DeviceObject,
               IN PIRP Irp
               )

/*++

Routine Description:

    This routine is called by the I/O system when the device is opened or closed.

Arguments:

    DeviceObject  - Pointer to device object for this miniport
    Irp        - IRP involved.

Return Value:

    STATUS_SUCCESS.

--*/

{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS status = STATUS_SUCCESS;

    __try {

        if (irpStack->MajorFunction == IRP_MJ_CREATE) {

            status = SmartcardAcquireRemoveLockWithTag(
                                                      &deviceExtension->SmartcardExtension,
                                                      'lCrC'
                                                      );

            if (status != STATUS_SUCCESS) {

                status = STATUS_DEVICE_REMOVED;
                __leave;
            }

         // test if the device has been opened already
            if (InterlockedCompareExchange(
                                          &deviceExtension->ReaderOpen,
                                          TRUE,
                                          FALSE) == FALSE) {

                SmartcardDebug(
                              DEBUG_DRIVER,
                              ("%s!TLP3CreateClose: Open\n",
                               DRIVER_NAME)
                              );

            } else {

            // the device is already in use
                status = STATUS_UNSUCCESSFUL;

            // release the lock
                SmartcardReleaseRemoveLockWithTag(
                                                 &deviceExtension->SmartcardExtension,
                                                 'lCrC'
                                                 );
            }

        } else {

            SmartcardDebug(
                          DEBUG_DRIVER,
                          ("%s!TLP3CreateClose: Close\n",
                           DRIVER_NAME)
                          );

            SmartcardReleaseRemoveLockWithTag(
                                             &deviceExtension->SmartcardExtension,
                                             'lCrC'
                                             );

            deviceExtension->ReaderOpen = FALSE;
        }
    }
    __finally {

        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    return status;
}

NTSTATUS
TLP3Cancel(
          IN PDEVICE_OBJECT DeviceObject,
          IN PIRP Irp
          )

/*++

Routine Description:

    This routine is called by the I/O system
    when the irp should be cancelled

Arguments:

    DeviceObject  - Pointer to device object for this miniport
    Irp        - IRP involved.

Return Value:

    STATUS_CANCELLED

--*/

{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PSMARTCARD_EXTENSION smartcardExtension = &deviceExtension->SmartcardExtension;

    SmartcardDebug(
                  DEBUG_TRACE,
                  ("%s!TLP3Cancel: Enter\n",
                   DRIVER_NAME)
                  );

    ASSERT(Irp == smartcardExtension->OsData->NotificationIrp);

    IoReleaseCancelSpinLock(
                           Irp->CancelIrql
                           );

    TLP3CompleteCardTracking(smartcardExtension);

    SmartcardDebug(
                  DEBUG_TRACE,
                  ("%s!TLP3Cancel: Exit\n",
                   DRIVER_NAME)
                  );

    return STATUS_CANCELLED;
}

NTSTATUS
TLP3Cleanup(
           IN PDEVICE_OBJECT DeviceObject,
           IN PIRP Irp
           )

/*++

Routine Description:

    This routine is called when the calling application terminates.
    We can actually only have the notification irp that we have to cancel.

--*/

{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PSMARTCARD_EXTENSION smartcardExtension = &deviceExtension->SmartcardExtension;
    NTSTATUS status = STATUS_SUCCESS;

    SmartcardDebug(
                  DEBUG_TRACE,
                  ("%s!TLP3Cleanup: Enter\n",
                   DRIVER_NAME)
                  );

    ASSERT(Irp != smartcardExtension->OsData->NotificationIrp);

    // We need to complete the notification irp
    TLP3CompleteCardTracking(smartcardExtension);

    SmartcardDebug(
                  DEBUG_DRIVER,
                  ("%s!TLP3Cleanup: Completing IRP %lx\n",
                   DRIVER_NAME,
                   Irp)
                  );

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = STATUS_SUCCESS;

    IoCompleteRequest(
                     Irp,
                     IO_NO_INCREMENT
                     );

    SmartcardDebug(
                  DEBUG_TRACE,
                  ("%s!TLP3Cleanup: Exit\n",
                   DRIVER_NAME)
                  );

    return STATUS_SUCCESS;
}

VOID
TLP3RemoveDevice(
                PDEVICE_OBJECT DeviceObject
                )
/*++

Routine Description:
    Remove the device from the system.

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    PSMARTCARD_EXTENSION smartcardExtension;
    NTSTATUS status;

    PAGED_CODE();

    if (DeviceObject == NULL) {

        return;
    }

    deviceExtension = DeviceObject->DeviceExtension;
    smartcardExtension = &deviceExtension->SmartcardExtension;

    SmartcardDebug(
                  DEBUG_TRACE,
                  ( "%s!TLP3RemoveDevice: Enter\n",
                    DRIVER_NAME)
                  );

    if (smartcardExtension->OsData) {

        // complete pending card tracking requests (if any)
        TLP3CompleteCardTracking(smartcardExtension);
        ASSERT(smartcardExtension->OsData->NotificationIrp == NULL);

        // Wait until we can safely unload the device
        SmartcardReleaseRemoveLockAndWait(smartcardExtension);
    }

    TLP3StopDevice(DeviceObject);

    if (deviceExtension->SmartcardExtension.ReaderExtension &&
        deviceExtension->SmartcardExtension.ReaderExtension->AttachedDeviceObject) {

        IoDetachDevice(
                      deviceExtension->SmartcardExtension.ReaderExtension->AttachedDeviceObject
                      );
    }

    if (deviceExtension->PnPDeviceName.Buffer != NULL) {

        RtlFreeUnicodeString(&deviceExtension->PnPDeviceName);
    }

    if (smartcardExtension->OsData != NULL) {

        SmartcardExit(smartcardExtension);
    }

    if (smartcardExtension->ReaderExtension != NULL) {

        ExFreePool(smartcardExtension->ReaderExtension);
    }

    if (deviceExtension->CloseSerial != NULL) {

        IoFreeWorkItem(deviceExtension->CloseSerial);
    }
    IoDeleteDevice(DeviceObject);

    SmartcardDebug(
                  DEBUG_INFO,
                  ( "%s!TLP3RemoveDevice: Exit\n",
                    DRIVER_NAME)
                  );
}

VOID
TLP3DriverUnload(
                IN PDRIVER_OBJECT DriverObject
                )
/*++

Routine Description:
    The driver unload routine.  This is called by the I/O system
    when the device is unloaded from memory.

Arguments:
    DriverObject - Pointer to driver object created by system.

Return Value:
    STATUS_SUCCESS.

--*/
{
    PAGED_CODE();

    SmartcardDebug(
                  DEBUG_INFO,
                  ("%s!TLP3DriverUnload\n",
                   DRIVER_NAME)
                  );
}

NTSTATUS
TLP3ConfigureSerialPort(
                       PSMARTCARD_EXTENSION SmartcardExtension
                       )

/*++

Routine Description:

    This routine will appropriately configure the serial port.
    It makes synchronous calls to the serial port.

Arguments:

    SmartcardExtension - Pointer to smart card struct

Return Value:

    NTSTATUS

--*/

{
    PSERIAL_READER_CONFIG configData = &SmartcardExtension->ReaderExtension->SerialConfigData;
    NTSTATUS status = STATUS_SUCCESS;
    USHORT i;
    PUCHAR request = SmartcardExtension->SmartcardRequest.Buffer;

    SmartcardExtension->SmartcardRequest.BufferLength = 0;
    SmartcardExtension->SmartcardReply.BufferLength =
    SmartcardExtension->SmartcardReply.BufferSize;

    for (i = 0; status == STATUS_SUCCESS; i++) {

        switch (i) {
        
        case 0:
             //
             // Set up baudrate for the TLP3 reader
             //
            SmartcardExtension->ReaderExtension->SerialIoControlCode =
            IOCTL_SERIAL_SET_BAUD_RATE;

            SmartcardExtension->SmartcardRequest.Buffer =
            (PUCHAR) &configData->BaudRate;

            SmartcardExtension->SmartcardRequest.BufferLength =
            sizeof(SERIAL_BAUD_RATE);

            break;

        case 1:
               //
               // Set up line control parameters
               //
            SmartcardExtension->ReaderExtension->SerialIoControlCode =
            IOCTL_SERIAL_SET_LINE_CONTROL;

            SmartcardExtension->SmartcardRequest.Buffer =
            (PUCHAR) &configData->LineControl;

            SmartcardExtension->SmartcardRequest.BufferLength =
            sizeof(SERIAL_LINE_CONTROL);
            break;

        case 2:
               //
               // Set serial special characters
               //
            SmartcardExtension->ReaderExtension->SerialIoControlCode =
            IOCTL_SERIAL_SET_CHARS;

            SmartcardExtension->SmartcardRequest.Buffer =
            (PUCHAR) &configData->SerialChars;

            SmartcardExtension->SmartcardRequest.BufferLength =
            sizeof(SERIAL_CHARS);
            break;

        case 3:
               //
               // Set up timeouts
               //
            SmartcardExtension->ReaderExtension->SerialIoControlCode =
            IOCTL_SERIAL_SET_TIMEOUTS;

            SmartcardExtension->SmartcardRequest.Buffer =
            (PUCHAR) &configData->Timeouts;

            SmartcardExtension->SmartcardRequest.BufferLength =
            sizeof(SERIAL_TIMEOUTS);
            break;

        case 4:
               // Set flowcontrol and handshaking
            SmartcardExtension->ReaderExtension->SerialIoControlCode =
            IOCTL_SERIAL_SET_HANDFLOW;

            SmartcardExtension->SmartcardRequest.Buffer =
            (PUCHAR) &configData->HandFlow;

            SmartcardExtension->SmartcardRequest.BufferLength =
            sizeof(SERIAL_HANDFLOW);
            break;

        case 5:
               // Set break off
            SmartcardExtension->ReaderExtension->SerialIoControlCode =
            IOCTL_SERIAL_SET_BREAK_OFF;
            break;

        case 6:
                // set DTR for the reader
            SmartcardExtension->ReaderExtension->SerialIoControlCode =
            IOCTL_SERIAL_SET_DTR;
            break;

        case 7:
            SmartcardExtension->ReaderExtension->SerialIoControlCode =
            IOCTL_SERIAL_SET_RTS;
            break;

        case 8:
            return STATUS_SUCCESS;
        }

        status = TLP3SerialIo(SmartcardExtension);


      // restore pointer to original request buffer
        SmartcardExtension->SmartcardRequest.Buffer = request;
    }

    return status;
}

NTSTATUS
TLP3StartSerialEventTracking(
                            PSMARTCARD_EXTENSION SmartcardExtension
                            )
/*++

Routine Description:

    This routine initializes serial event tracking.
    It calls the serial driver to set a wait mask for CTS and DSR tracking.

--*/
{
    NTSTATUS status;
    PREADER_EXTENSION readerExtension = SmartcardExtension->ReaderExtension;
    IO_STATUS_BLOCK ioStatus;
    KEVENT event;

    PAGED_CODE();

    readerExtension->SerialConfigData.SerialWaitMask =
    SERIAL_EV_CTS | SERIAL_EV_DSR;

    KeInitializeEvent(
                     &event,
                     NotificationEvent,
                     FALSE
                     );

   //
   // Send a wait mask to the serial driver. This call only sets the
    // wait mask. We want to be informed when CTS or DSR changes its state
   //
    readerExtension->SerialStatusIrp = IoBuildDeviceIoControlRequest(
                                                                    IOCTL_SERIAL_SET_WAIT_MASK,
                                                                    readerExtension->AttachedDeviceObject,
                                                                    &readerExtension->SerialConfigData.SerialWaitMask,
                                                                    sizeof(readerExtension->SerialConfigData.SerialWaitMask),
                                                                    NULL,
                                                                    0,
                                                                    FALSE,
                                                                    &event,
                                                                    &ioStatus
                                                                    );

    if (readerExtension->SerialStatusIrp == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = IoCallDriver(
                         readerExtension->AttachedDeviceObject,
                         readerExtension->SerialStatusIrp
                         );

    if (status == STATUS_PENDING) {

        status = KeWaitForSingleObject(
                                      &event,
                                      Executive,
                                      KernelMode,
                                      FALSE,
                                      NULL
                                      );
        ASSERT(status == STATUS_SUCCESS);

        status = ioStatus.Status;
    }

    if (status == STATUS_SUCCESS) {

        KIRQL oldIrql;
        LARGE_INTEGER delayPeriod;
        PIO_STACK_LOCATION irpSp;

      //
      // Now tell the serial driver that we want to be informed
      // when CTS or DSR changes its state.
      //
        readerExtension->SerialStatusIrp = IoAllocateIrp(
                                                        (CCHAR) (SmartcardExtension->OsData->DeviceObject->StackSize + 1),
                                                        FALSE
                                                        );

        if (readerExtension->SerialStatusIrp == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;
        }

        irpSp = IoGetNextIrpStackLocation( readerExtension->SerialStatusIrp );
        irpSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;

        irpSp->Parameters.DeviceIoControl.InputBufferLength = 0;
        irpSp->Parameters.DeviceIoControl.OutputBufferLength =
        sizeof(readerExtension->SerialConfigData.SerialWaitMask);
        irpSp->Parameters.DeviceIoControl.IoControlCode =
        IOCTL_SERIAL_WAIT_ON_MASK;

        readerExtension->SerialStatusIrp->AssociatedIrp.SystemBuffer =
        &readerExtension->SerialConfigData.SerialWaitMask;

      //
      // this artificial delay is necessary to make this driver work
      // with digi board cards
      //
        delayPeriod.HighPart = -1;
        delayPeriod.LowPart = 100l * 1000 * (-10);

        KeDelayExecutionThread(
                              KernelMode,
                              FALSE,
                              &delayPeriod
                              );

        // We simulate a callback now that triggers the card supervision
        TLP3SerialEvent(
                       SmartcardExtension->OsData->DeviceObject,
                       readerExtension->SerialStatusIrp,
                       SmartcardExtension
                       );

        status = STATUS_SUCCESS;
    }

    return status;
}

VOID
TLP3CompleteCardTracking(
                        IN PSMARTCARD_EXTENSION SmartcardExtension
                        )
{
    KIRQL ioIrql, keIrql;
    PIRP notificationIrp;

    IoAcquireCancelSpinLock(&ioIrql);
    KeAcquireSpinLock(
                     &SmartcardExtension->OsData->SpinLock,
                     &keIrql
                     );

    notificationIrp = SmartcardExtension->OsData->NotificationIrp;
    SmartcardExtension->OsData->NotificationIrp = NULL;

    KeReleaseSpinLock(
                     &SmartcardExtension->OsData->SpinLock,
                     keIrql
                     );

    if (notificationIrp) {

        IoSetCancelRoutine(
                          notificationIrp,
                          NULL
                          );
    }

    IoReleaseCancelSpinLock(ioIrql);

    if (notificationIrp) {

        SmartcardDebug(
                      DEBUG_INFO,
                      ("%s!TLP3CompleteCardTracking: Completing NotificationIrp %lxh\n",
                       DRIVER_NAME,
                       notificationIrp)
                      );

       //   finish the request
        if (notificationIrp->Cancel) {

            notificationIrp->IoStatus.Status = STATUS_CANCELLED;

        } else {

            notificationIrp->IoStatus.Status = STATUS_SUCCESS;
        }
        notificationIrp->IoStatus.Information = 0;

        IoCompleteRequest(
                         notificationIrp,
                         IO_NO_INCREMENT
                         );
    }
}

NTSTATUS
TLP3SerialEvent(
               IN PDEVICE_OBJECT DeviceObject,
               IN PIRP Irp,
               IN PSMARTCARD_EXTENSION SmartcardExtension
               )
/*++

Routine Description:

    This routine is called in two cases:
    a) CTS changed (card inserted or removed) or
    b) DSR changed (reader has been removed)

    For a) we update the card status and complete outstanding
    card tracking requests.
    For b) we start to unload the driver

    NOTE: This function calls itself using IoCompletion. In the 'first'
    callback the serial driver only tells us that something has changed.
    We set up a call for 'what has changed' (GetModemStatus) which then
    call this function again.
    When we updated everything and we don't unload the driver card
    tracking is started again.

--*/
{
    NTSTATUS status;
    KIRQL irql;

    KeAcquireSpinLock(
                     &SmartcardExtension->OsData->SpinLock,
                     &irql
                     );

    if (SmartcardExtension->ReaderExtension->GetModemStatus) {

      //
      // This function requested the modem status previously.
        // As part of the io-completion, this function is then
        // called again. When we're here we can read the actual
        // modem-status to figure out if the card is in the reader
      //
        if ((SmartcardExtension->ReaderExtension->ModemStatus & SERIAL_DSR_STATE) == 0) {

            SmartcardDebug(
                          DEBUG_INFO,
                          ("%s!TLP3SerialEvent: Reader removed\n",
                           DRIVER_NAME)
                          );

            //
            // We set the mask to zero to signal that we can
            // release the irp that we use for the serial events
            //
            SmartcardExtension->ReaderExtension->SerialConfigData.SerialWaitMask = 0;
            SmartcardExtension->ReaderCapabilities.CurrentState = SCARD_UNKNOWN;

        } else {

            if (SmartcardExtension->ReaderExtension->ModemStatus & SERIAL_CTS_STATE) {

             // Card is inserted
                SmartcardExtension->ReaderCapabilities.CurrentState =
                SCARD_SWALLOWED;

                SmartcardExtension->CardCapabilities.Protocol.Selected =
                SCARD_PROTOCOL_UNDEFINED;

                SmartcardDebug(
                              DEBUG_INFO,
                              ("%s!TLP3SerialEvent: Smart card inserted\n",
                               DRIVER_NAME)
                              );

            } else {

             // Card is removed
                SmartcardExtension->CardCapabilities.ATR.Length = 0;

                SmartcardExtension->ReaderCapabilities.CurrentState =
                SCARD_ABSENT;

                SmartcardExtension->CardCapabilities.Protocol.Selected =
                SCARD_PROTOCOL_UNDEFINED;

                SmartcardDebug(
                              DEBUG_INFO,
                              ("%s!TLP3SerialEvent: Smart card removed\n",
                               DRIVER_NAME)
                              );
            }
        }
    }

    KeReleaseSpinLock(
                     &SmartcardExtension->OsData->SpinLock,
                     irql
                     );

   //
   // Only inform the user of a card insertion/removal event
   // if this function isn't called due to a power down - power up cycle
   //
    if (SmartcardExtension->ReaderExtension->PowerRequest == FALSE) {

        TLP3CompleteCardTracking(SmartcardExtension);
    }

    // The wait mask is set to 0 when the driver unloads
    if (SmartcardExtension->ReaderExtension->SerialConfigData.SerialWaitMask == 0) {

        // The reader has been unplugged.
        PDEVICE_EXTENSION deviceExtension =
        SmartcardExtension->OsData->DeviceObject->DeviceExtension;

        // schedule our remove thread
        IoQueueWorkItem(
                       deviceExtension->CloseSerial,
                       (PIO_WORKITEM_ROUTINE) TLP3CloseSerialPort,
                       DelayedWorkQueue,
                       NULL
                       );

        SmartcardDebug(
                      DEBUG_TRACE,
                      ("%s!TLP3SerialEvent: Exit (Release IRP)\n",
                       DRIVER_NAME)
                      );

      //
        // We don't need the IRP anymore, so free it and tell the
      // io subsystem not to touch it anymore by returning the value below
      //
        IoFreeIrp(Irp);
        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    if (SmartcardExtension->ReaderExtension->GetModemStatus == FALSE) {

      //
      // Setup call for device control to get modem status.
      // The CTS signal tells us if the card is inserted or removed.
      // CTS is high if the card is inserted.
      //
        PIO_STACK_LOCATION irpStack;

        irpStack = IoGetNextIrpStackLocation(
                                            SmartcardExtension->ReaderExtension->SerialStatusIrp
                                            );

        irpStack->MajorFunction = IRP_MJ_DEVICE_CONTROL;
        irpStack->MinorFunction = 0UL;
        irpStack->Parameters.DeviceIoControl.OutputBufferLength =
        sizeof(SmartcardExtension->ReaderExtension->ModemStatus);
        irpStack->Parameters.DeviceIoControl.IoControlCode =
        IOCTL_SERIAL_GET_MODEMSTATUS;

        SmartcardExtension->ReaderExtension->SerialStatusIrp->AssociatedIrp.SystemBuffer =
        &SmartcardExtension->ReaderExtension->ModemStatus;

        SmartcardExtension->ReaderExtension->GetModemStatus = TRUE;

    } else {

        PIO_STACK_LOCATION irpStack;

      // Setup call for device control to wait for a serial event
        irpStack = IoGetNextIrpStackLocation(
                                            SmartcardExtension->ReaderExtension->SerialStatusIrp
                                            );

#if defined (DEBUG) && defined (DETECT_SERIAL_OVERRUNS)
        if (Irp->IoStatus.Status != STATUS_SUCCESS) {

            //
            // we need to call the serial driver to reset the internal
            // error counters, otherwise the serial driver refuses to work
            //

            static SERIAL_STATUS serialStatus;

            SmartcardDebug(
                          DEBUG_ERROR,
                          ( "%s!TLP3SerialEvent: Reset of serial error condition...\n",
                            DRIVER_NAME)
                          );

            irpStack->MajorFunction = IRP_MJ_DEVICE_CONTROL;
            irpStack->MinorFunction = 0UL;
            irpStack->Parameters.DeviceIoControl.OutputBufferLength =
            sizeof(serialStatus);
            irpStack->Parameters.DeviceIoControl.IoControlCode =
            IOCTL_SERIAL_GET_COMMSTATUS;

            SmartcardExtension->ReaderExtension->SerialStatusIrp->AssociatedIrp.SystemBuffer =
            &serialStatus;
        } else
#endif
        {
            irpStack->MajorFunction = IRP_MJ_DEVICE_CONTROL;
            irpStack->MinorFunction = 0UL;
            irpStack->Parameters.DeviceIoControl.OutputBufferLength =
            sizeof(SmartcardExtension->ReaderExtension->SerialConfigData.SerialWaitMask);
            irpStack->Parameters.DeviceIoControl.IoControlCode =
            IOCTL_SERIAL_WAIT_ON_MASK;

            SmartcardExtension->ReaderExtension->SerialStatusIrp->AssociatedIrp.SystemBuffer =
            &SmartcardExtension->ReaderExtension->SerialConfigData.SerialWaitMask;

        }

        SmartcardExtension->ReaderExtension->GetModemStatus = FALSE;
    }

    IoSetCompletionRoutine(
                          SmartcardExtension->ReaderExtension->SerialStatusIrp,
                          TLP3SerialEvent,
                          SmartcardExtension,
                          TRUE,
                          TRUE,
                          TRUE
                          );

    status = IoCallDriver(
                         SmartcardExtension->ReaderExtension->AttachedDeviceObject,
                         SmartcardExtension->ReaderExtension->SerialStatusIrp
                         );

    return STATUS_MORE_PROCESSING_REQUIRED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\cmbp0\cmbp0pnp.h ===
/*****************************************************************************
@doc            INT EXT
******************************************************************************
* $ProjectName:  $
* $ProjectRevision:  $
*-----------------------------------------------------------------------------
* $Source: z:/pr/cmbp0/sw/cmbp0.ms/rcs/cmbp0pnp.h $
* $Revision: 1.2 $
*-----------------------------------------------------------------------------
* $Author: WFrischauf $
*-----------------------------------------------------------------------------
* History: see EOF
*-----------------------------------------------------------------------------
*
* Copyright  2000 OMNIKEY AG
******************************************************************************/

#if !defined ( __CMMOB_PNP_DRV_H__ )
   #define __CMMOB_PNP_DRV_H__

#ifdef DBG

static const PCHAR szPnpMnFuncDesc[] =
{  // note this depends on corresponding values to the indexes in wdm.h
   "IRP_MN_START_DEVICE",
   "IRP_MN_QUERY_REMOVE_DEVICE",
   "IRP_MN_REMOVE_DEVICE",
   "IRP_MN_CANCEL_REMOVE_DEVICE",
   "IRP_MN_STOP_DEVICE",
   "IRP_MN_QUERY_STOP_DEVICE",
   "IRP_MN_CANCEL_STOP_DEVICE",
   "IRP_MN_QUERY_DEVICE_RELATIONS",
   "IRP_MN_QUERY_INTERFACE",
   "IRP_MN_QUERY_CAPABILITIES",
   "IRP_MN_QUERY_RESOURCES",
   "IRP_MN_QUERY_RESOURCE_REQUIREMENTS",
   "IRP_MN_QUERY_DEVICE_TEXT",
   "IRP_MN_FILTER_RESOURCE_REQUIREMENTS",
   "IRP_MN_READ_CONFIG",
   "IRP_MN_WRITE_CONFIG",
   "IRP_MN_EJECT",
   "IRP_MN_SET_LOCK",
   "IRP_MN_QUERY_ID",
   "IRP_MN_QUERY_PNP_DEVICE_STATE",
   "IRP_MN_QUERY_BUS_INFORMATION",
   "IRP_MN_DEVICE_USAGE_NOTIFICATION",
   "IRP_MN_SURPRISE_REMOVAL"
};
#define IRP_PNP_MN_FUNC_MAX IRP_MN_SURPRISE_REMOVAL


static const PCHAR szPowerMnFuncDesc[] =
{  // note this depends on corresponding values to the indexes in wdm.h
   "IRP_MN_WAIT_WAKE",
   "IRP_MN_POWER_SEQUENCE",
   "IRP_MN_SET_POWER",
   "IRP_MN_QUERY_POWER"
};
#define IRP_POWER_MN_FUNC_MAX   IRP_MN_QUERY_POWER



static const PCHAR szSystemPowerState[] =
{
   "PowerSystemUnspecified",
   "PowerSystemWorking",
   "PowerSystemSleeping1",
   "PowerSystemSleeping2",
   "PowerSystemSleeping3",
   "PowerSystemHibernate",
   "PowerSystemShutdown",
   "PowerSystemMaximum"
};

static const PCHAR szDevicePowerState[] =
{
   "PowerDeviceUnspecified",
   "PowerDeviceD0",
   "PowerDeviceD1",
   "PowerDeviceD2",
   "PowerDeviceD3",
   "PowerDeviceMaximum"
};

static const PCHAR szDeviceRelation[] =
{
    "BusRelations",
    "EjectionRelations",
    "PowerRelations",
    "RemovalRelations",
    "TargetDeviceRelation"
};


#endif

NTSTATUS CMMOB_AddDevice(
                           IN PDRIVER_OBJECT DriverObject,
                           IN PDEVICE_OBJECT PhysicalDeviceObject
                           );

NTSTATUS CMMOB_CallPcmciaDriver(
                                  IN PDEVICE_OBJECT DeviceObject,
                                  IN PIRP Irp
                                  );

NTSTATUS CMMOB_PcmciaCallComplete (
                                     IN PDEVICE_OBJECT DeviceObject,
                                     IN PIRP Irp,
                                     IN PKEVENT Event
                                     );

NTSTATUS CMMOB_PnPDeviceControl(
                                  IN PDEVICE_OBJECT DeviceObject,
                                  IN PIRP Irp
                                  );

VOID CMMOB_SystemPowerCompletion(
                                   IN PDEVICE_OBJECT DeviceObject,
                                   IN UCHAR MinorFunction,
                                   IN POWER_STATE PowerState,
                                   IN PKEVENT Event,
                                   IN PIO_STATUS_BLOCK IoStatus
                                   );

NTSTATUS CMMOB_DevicePowerCompletion (
                                        IN PDEVICE_OBJECT DeviceObject,
                                        IN PIRP Irp,
                                        IN PSMARTCARD_EXTENSION SmartcardExtension
                                        );

NTSTATUS CMMOB_PowerDeviceControl (
                                     IN PDEVICE_OBJECT DeviceObject,
                                     IN PIRP Irp
                                     );




#endif  // __CMMOB_PNP_DRV_H__
/*****************************************************************************
* History:
* $Log: cmbp0pnp.h $
* Revision 1.2  2000/07/27 13:53:02  WFrischauf
* No comment given
*
*
******************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\cmbp0\cmbp0scr.h ===
/*****************************************************************************
@doc            INT EXT
******************************************************************************
* $ProjectName:  $
* $ProjectRevision:  $
*-----------------------------------------------------------------------------
* $Source: z:/pr/cmbp0/sw/cmbp0.ms/rcs/cmbp0scr.h $
* $Revision: 1.3 $
*-----------------------------------------------------------------------------
* $Author: WFrischauf $
*-----------------------------------------------------------------------------
* History: see EOF
*-----------------------------------------------------------------------------
*
* Copyright  2000 OMNIKEY AG
******************************************************************************/

#if !defined ( __CMMOB_PNP_SCR_H__ )
   #define __CMMOB_PNP_SCR_H__


      #define ADDR_WRITEREG_FLAGS0              0x00
      #define ADDR_WRITEREG_FLAGS1              0x01
      #define ADDR_WRITEREG_PROCEDURE_T0        0x02
      #define ADDR_WRITEREG_BUFFER_ADDR         0x03
      #define ADDR_WRITEREG_BUFFER_DATA         0x04
      #define ADDR_WRITEREG_MESSAGE_LENGTH      0x05
      #define ADDR_WRITEREG_BAUDRATE            0x06
      #define ADDR_WRITEREG_STOPBITS            0x07

      #define ADDR_READREG_FLAGS0               0x00
      #define ADDR_READREG_LASTPROCEDURE_T0     0x01
      #define ADDR_READREG_BYTESTORECEIVE_T1    0x01
      #define ADDR_READREG_BYTES_RECEIVED       0x02
      #define ADDR_READREG_FLAGS1               0x03
      #define ADDR_READREG_BUFFER_DATA          0x04

// Flags 0 Read Register
      #define FLAG_INSERTED               0x01
      #define FLAG_POWERED                0x02
      #define FLAG_BYTES_RECEIVED_B9      0x04
      // meaning of the flag:    Receiving T1
      //                         Receiving T0 finished
      //                         Reader detection
      #define FLAG_RECEIVE                0x08


// Flag 1 Read Register
      #define FLAG_NOPROCEDURE_RECEIVED   0x80

// Flags 1 Write Register
      #define FLAG_BAUDRATE_HIGH          0x01
      #define FLAG_INVERS_PARITY          0x02
      #define FLAG_CLOCK_8MHZ             0x04
      #define FLAG_T0_WRITE               0x08
      #define FLAG_BUFFER_ADDR_B9         0x10
      #define FLAG_TACTIVE                0x20
      #define FLAG_CHECK_PRESENCE         0x40
      #define FLAG_READ_CIS               0x80

// Flags 0 Write Register (Commands)
      #define CMD_RESET_SM       0x80
      #define CMD_POWERON_COLD   0x44
      #define CMD_POWERON_WARM   0x46
      #define CMD_POWEROFF       0x42
      #define CMD_WRITE_T0       0x48
      #define CMD_WRITE_T1       0x50




NTSTATUS CMMOB_CardPower (
                         IN PSMARTCARD_EXTENSION SmartcardExtension
                         );

NTSTATUS CMMOB_PowerOnCard (
                           IN  PSMARTCARD_EXTENSION SmartcardExtension,
                           IN  PUCHAR pbATR,
                           IN  BOOLEAN fMaxWaitTime,
                           OUT PULONG pulATRLength
                           );

NTSTATUS CMMOB_PowerOffCard (
                            IN PSMARTCARD_EXTENSION SmartcardExtension
                            );

NTSTATUS CMMOB_Transmit (
                        IN PSMARTCARD_EXTENSION SmartcardExtension
                        );

NTSTATUS CMMOB_TransmitT0 (
                          PSMARTCARD_EXTENSION SmartcardExtension
                          );

NTSTATUS CMMOB_TransmitT1 (
                          PSMARTCARD_EXTENSION SmartcardExtension
                          );

NTSTATUS CMMOB_SetProtocol (
                           IN PSMARTCARD_EXTENSION SmartcardExtension
                           );

NTSTATUS CMMOB_SetFlags1 (
                         PREADER_EXTENSION ReaderExtension
                         );

NTSTATUS CMMOB_IoCtlVendor (
                           IN PSMARTCARD_EXTENSION SmartcardExtension
                           );

NTSTATUS CMMOB_SetHighSpeed_CR80S_SAMOS (
                                        IN PSMARTCARD_EXTENSION SmartcardExtension
                                        );

NTSTATUS CMMOB_SetSpeed (
                        IN PSMARTCARD_EXTENSION SmartcardExtension,
                        IN PUCHAR               abFIDICommand
                        );

NTSTATUS CMMOB_SetReader_9600Baud (
                                  IN PSMARTCARD_EXTENSION SmartcardExtension
                                  );

NTSTATUS CMMOB_SetReader_38400Baud (
                                   IN PSMARTCARD_EXTENSION SmartcardExtension
                                   );

NTSTATUS CMMOB_ReadDeviceDescription(
                                    IN PSMARTCARD_EXTENSION SmartcardExtension
                                    );

NTSTATUS CMMOB_GetFWVersion (
                            IN PSMARTCARD_EXTENSION SmartcardExtension
                            );

NTSTATUS CMMOB_CardTracking (
                            IN PSMARTCARD_EXTENSION SmartcardExtension
                            );

VOID CMMOB_CompleteCardTracking(
                               IN PSMARTCARD_EXTENSION SmartcardExtension
                               );

NTSTATUS CMMOB_CancelCardTracking(
                                 PDEVICE_OBJECT DeviceObject,
                                 PIRP Irp
                                 );

NTSTATUS CMMOB_StartCardTracking(
                                IN PDEVICE_OBJECT DeviceObject
                                );

VOID CMMOB_StopCardTracking(
                           IN PDEVICE_OBJECT DeviceObject
                           );

VOID CMMOB_UpdateCurrentStateThread(
                                   IN PVOID Context
                                   );

NTSTATUS CMMOB_UpdateCurrentState(
                                 IN PSMARTCARD_EXTENSION SmartcardExtension
                                 );

NTSTATUS CMMOB_ResetReader(
                          IN PREADER_EXTENSION ReaderExtension
                          );

NTSTATUS CMMOB_BytesReceived(
                            IN PREADER_EXTENSION ReaderExtension,
                            OUT PULONG pulBytesReceived
                            );

NTSTATUS CMMOB_SetCardParameters(
                                IN PREADER_EXTENSION ReaderExtension
                                );

BOOLEAN CMMOB_CardInserted(
                          IN PREADER_EXTENSION ReaderExtension
                          );

BOOLEAN CMMOB_CardPowered(
                         IN PREADER_EXTENSION ReaderExtension
                         );

BOOLEAN CMMOB_ProcedureReceived(
                               IN PREADER_EXTENSION ReaderExtension
                               );

BOOLEAN CMMOB_GetReceiveFlag(
                            IN PREADER_EXTENSION ReaderExtension
                            );

NTSTATUS CMMOB_GetProcedureByte(
                               IN PREADER_EXTENSION ReaderExtension,
                               OUT PUCHAR pbProcedureByte
                               );
NTSTATUS CMMOB_ReadRegister(
                           IN PREADER_EXTENSION ReaderExtension,
                           IN USHORT usAddress,
                           OUT PUCHAR pbData
                           );

NTSTATUS CMMOB_WriteRegister(
                            IN PREADER_EXTENSION ReaderExtension,
                            IN USHORT usAddress,
                            IN UCHAR bData
                            );

NTSTATUS CMMOB_ReadBuffer(
                         IN PREADER_EXTENSION ReaderExtension,
                         IN ULONG ulOffset,
                         IN ULONG ulLength,
                         OUT PUCHAR pbData
                         );

NTSTATUS CMMOB_WriteBuffer(
                          IN PREADER_EXTENSION ReaderExtension,
                          IN ULONG ulLength,
                          IN PUCHAR pbData
                          );

NTSTATUS CMMOB_ReadT0(
                     IN PREADER_EXTENSION ReaderExtension,
                     IN ULONG ulBytesToRead,
                     IN ULONG ulBytesSent,
                     IN ULONG ulCWT,
                     OUT PUCHAR pbData,
                     OUT PULONG pulBytesRead,
                     OUT PBOOLEAN pfDataSent
                     );

NTSTATUS CMMOB_ReadT1(
                     IN PREADER_EXTENSION ReaderExtension,
                     IN LONG ulBytesToRead,
                     IN ULONG ulBWT,
                     IN ULONG ulCWT,
                     OUT PUCHAR pbData,
                     OUT PULONG pulBytesRead
                     );

NTSTATUS CMMOB_WriteT0(
                      IN PREADER_EXTENSION ReaderExtension,
                      IN ULONG ulBytesToWrite,
                      IN ULONG ulBytesToReceive,
                      IN PUCHAR pbData
                      );

NTSTATUS CMMOB_WriteT1(
                      IN PREADER_EXTENSION ReaderExtension,
                      IN ULONG ulBytesToWrite,
                      IN PUCHAR pbData
                      );

VOID CMMOB_InverseBuffer (
                         PUCHAR pbBuffer,
                         ULONG  ulBufferSize
                         );

#endif  // __CMMOB_PNP_SCR_H__
/*****************************************************************************
* History:
* $Log: cmbp0scr.h $
* Revision 1.3  2000/07/27 13:53:05  WFrischauf
* No comment given
*
*
******************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\cmbp0\cmbp0scr.c ===
/*****************************************************************************
@doc            INT EXT
******************************************************************************
* $ProjectName:  $
* $ProjectRevision:  $
*-----------------------------------------------------------------------------
* $Source: z:/pr/cmbp0/sw/cmbp0.ms/rcs/cmbp0scr.c $
* $Revision: 1.7 $
*-----------------------------------------------------------------------------
* $Author: WFrischauf $
*-----------------------------------------------------------------------------
* History: see EOF
*-----------------------------------------------------------------------------
*
* Copyright  2000 OMNIKEY AG
******************************************************************************/

#include <cmbp0wdm.h>
#include <cmbp0scr.h>
#include <cmbp0log.h>


// this is a FI / Fi assignment
const ULONG Fi[] = { 372, 372, 588, 744, 1116, 1488, 1860, 372,
    372, 512, 768, 1024, 1536, 2048, 372, 372};

// this is a DI / Di assignment
const ULONG Di[] = { 1, 1, 2, 4, 8, 16, 32, 1,
    12, 20, 1, 1, 1, 1, 1, 1};



/*****************************************************************************
CMMOB_CorrectAtr

Routine Description:
  This function checks if the received ATR is valid.

Arguments:

Return Value:

*****************************************************************************/
VOID CMMOB_CorrectAtr(
                     PUCHAR pbBuffer,
                     ULONG  ulBufferSize
                     )
{
    UCHAR bNumberHistoricalBytes;
    UCHAR bXorChecksum;
    ULONG i;

    if (ulBufferSize < 0x09)  // mininmum length of a modified ATR
        return ;               // ATR is ok

   // variant 1
    if (pbBuffer[0] == 0x3b   &&
        pbBuffer[1] == 0xb4   &&
        pbBuffer[2] == 0x11   &&
        pbBuffer[3] == 0x00   &&
        pbBuffer[4] == 0x81   &&
        pbBuffer[5] == 0x31   &&
        pbBuffer[6] == 0x90   &&
        pbBuffer[7] == 0x73   &&
        ulBufferSize == 13      ) {
      // correct checksum byte
        bXorChecksum = pbBuffer[1];
        for (i=2;i<ulBufferSize-1;i++)
            bXorChecksum ^= pbBuffer[i];

        if (pbBuffer[ulBufferSize -1 ] != bXorChecksum ) {
            pbBuffer[ulBufferSize -1 ] = bXorChecksum;
            SmartcardDebug(DEBUG_ATR,
                           ("%s!CorrectAtr: Correcting SAMOS ATR (variant 1)\n", DRIVER_NAME));
        }
    }

   // variant 2
    if (pbBuffer[0] == 0x3b   &&
        pbBuffer[1] == 0xbf   &&
        pbBuffer[2] == 0x11   &&
        pbBuffer[3] == 0x00   &&
        pbBuffer[4] == 0x81   &&
        pbBuffer[5] == 0x31   &&
        pbBuffer[6] == 0x90   &&
        pbBuffer[7] == 0x73   &&
        ulBufferSize == 13   ) {
      // correct number of historical bytes
        bNumberHistoricalBytes = 4;

        pbBuffer[1] &= 0xf0;
        pbBuffer[1] |= bNumberHistoricalBytes;

      // correct checksum byte
        bXorChecksum = pbBuffer[1];
        for (i=2;i<ulBufferSize-1;i++)
            bXorChecksum ^= pbBuffer[i];

        pbBuffer[ulBufferSize -1 ] = bXorChecksum;
        SmartcardDebug(DEBUG_ATR,
                       ("%s!CorrectAtr: Correcting SAMOS ATR (variant 2)\n", DRIVER_NAME));
    }

   // variant 3
    if (pbBuffer[0] == 0x3b   &&
        pbBuffer[1] == 0xbf   &&
        pbBuffer[2] == 0x11   &&
        pbBuffer[3] == 0x00   &&
        pbBuffer[4] == 0x81   &&
        pbBuffer[5] == 0x31   &&
        pbBuffer[6] == 0x90   &&
        pbBuffer[7] == 0x73   &&
        ulBufferSize ==  9      ) {
      // correct number of historical bytes
        bNumberHistoricalBytes = 0;

        pbBuffer[1] &= 0xf0;
        pbBuffer[1] |= bNumberHistoricalBytes;

      // correct checksum byte
        bXorChecksum = pbBuffer[1];
        for (i=2;i<ulBufferSize-1;i++)
            bXorChecksum ^= pbBuffer[i];

        pbBuffer[ulBufferSize -1 ] = bXorChecksum;
        SmartcardDebug(DEBUG_ATR,
                       ("%s!CorrectAtr: Correcting SAMOS ATR (variant 3)\n",DRIVER_NAME));
    }

}


/*****************************************************************************
CMMOB_CardPower:
   callback handler for SMCLIB RDF_CARD_POWER

Arguments:
   SmartcardExtension   context of call

Return Value:
   STATUS_SUCCESS
   STATUS_NO_MEDIA
   STATUS_TIMEOUT
   STATUS_BUFFER_TOO_SMALL
******************************************************************************/
NTSTATUS CMMOB_CardPower (
                         PSMARTCARD_EXTENSION SmartcardExtension
                         )
{
    NTSTATUS          NTStatus = STATUS_SUCCESS;
    PREADER_EXTENSION ReaderExtension;
    UCHAR             pbAtrBuffer[MAXIMUM_ATR_LENGTH];
    ULONG             ulAtrLength;
    BOOLEAN           fMaxWaitTime=FALSE;
    KIRQL             irql;

#if DBG || DEBUG
    static PCHAR request[] = { "PowerDown",  "ColdReset", "WarmReset"};
#endif

    SmartcardDebug(DEBUG_TRACE,
                   ("%s!CardPower: Enter, Request = %s\n",
                    DRIVER_NAME,request[SmartcardExtension->MinorIoControlCode]));

    ReaderExtension = SmartcardExtension->ReaderExtension;

    ReaderExtension->fTActive=TRUE;
    NTStatus = CMMOB_SetFlags1(ReaderExtension);
    if (NTStatus != STATUS_SUCCESS) {
        goto ExitCardPower;
    }


    switch (SmartcardExtension->MinorIoControlCode) {
    case SCARD_WARM_RESET:
    case SCARD_COLD_RESET:
         // try asynchronous cards first
         // because some asynchronous cards
         // do not return 0xFF in the first byte
        NTStatus = CMMOB_PowerOnCard(SmartcardExtension,
                                     pbAtrBuffer,
                                     fMaxWaitTime,
                                     &ulAtrLength);

        if (NTStatus != STATUS_SUCCESS) {
            // try a second time, with maximum waiting time
            fMaxWaitTime=TRUE;
            NTStatus = CMMOB_PowerOnCard(SmartcardExtension,
                                         pbAtrBuffer,
                                         fMaxWaitTime,
                                         &ulAtrLength);
        }


        if (NTStatus != STATUS_SUCCESS) {
            goto ExitCardPower;
        }

         // correct ATR in case of old Samos cards, with wrong number of historical bytes / checksum
        CMMOB_CorrectAtr(pbAtrBuffer, ulAtrLength);

        if (ReaderExtension->CardParameters.fSynchronousCard == FALSE) {
            // copy ATR to smart card structure
            // the lib needs the ATR for evaluation of the card parameters

            RtlCopyBytes((PVOID)SmartcardExtension->CardCapabilities.ATR.Buffer,
                         (PVOID)pbAtrBuffer,
                         ulAtrLength);

            KeAcquireSpinLock(&SmartcardExtension->OsData->SpinLock,
                              &irql);
            SmartcardExtension->CardCapabilities.ATR.Length = (UCHAR)ulAtrLength;

            SmartcardExtension->ReaderCapabilities.CurrentState = SCARD_NEGOTIABLE;

            SmartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_UNDEFINED;
            KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                              irql);

            NTStatus = SmartcardUpdateCardCapabilities(SmartcardExtension);
            if (NTStatus != STATUS_SUCCESS) {
                if (!fMaxWaitTime) {
                  // try a second time, with maximum waiting time
                    fMaxWaitTime=TRUE;
                    NTStatus = CMMOB_PowerOnCard(SmartcardExtension,
                                                 pbAtrBuffer,
                                                 fMaxWaitTime,
                                                 &ulAtrLength);
                    if (NTStatus != STATUS_SUCCESS) {
                        goto ExitCardPower;
                    }
                    RtlCopyBytes((PVOID)SmartcardExtension->CardCapabilities.ATR.Buffer,
                                 (PVOID)pbAtrBuffer,
                                 ulAtrLength);

                    KeAcquireSpinLock(&SmartcardExtension->OsData->SpinLock,
                                      &irql);
                    SmartcardExtension->CardCapabilities.ATR.Length = (UCHAR)ulAtrLength;
                    SmartcardExtension->ReaderCapabilities.CurrentState = SCARD_NEGOTIABLE;
                    SmartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_UNDEFINED;
                    KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                                      irql);

                    NTStatus = SmartcardUpdateCardCapabilities(SmartcardExtension);
                    if (NTStatus != STATUS_SUCCESS) {
                        goto ExitCardPower;
                    }
                } else
                    goto ExitCardPower;
            }

            // -----------------------
            // set parameters
            // -----------------------
            if (SmartcardExtension->CardCapabilities.N != 0xff) {
               // 0 <= N <= 254
                ReaderExtension->CardParameters.bStopBits = 2 + SmartcardExtension->CardCapabilities.N;
            } else {
               // N = 255
                if (SmartcardExtension->CardCapabilities.Protocol.Selected & SCARD_PROTOCOL_T0) {
                  // 12 etu for T=0;
                    ReaderExtension->CardParameters.bStopBits = 2;
                } else {
                  // 11 etu for T=1
                    ReaderExtension->CardParameters.bStopBits = 1;
                }
            }

            if (SmartcardExtension->CardCapabilities.InversConvention) {
                ReaderExtension->CardParameters.fInversRevers = TRUE;
                SmartcardDebug(DEBUG_ATR,
                               ("%s!Card with invers convention !\n",DRIVER_NAME ));
            }

            CMMOB_SetCardParameters (ReaderExtension);

#if DBG
            {
                ULONG i;
                SmartcardDebug(DEBUG_ATR,("%s!ATR : ",DRIVER_NAME));
                for (i = 0;i < ulAtrLength;i++)
                    SmartcardDebug(DEBUG_ATR,("%2.2x ",SmartcardExtension->CardCapabilities.ATR.Buffer[i]));
                SmartcardDebug(DEBUG_ATR,("\n"));
            }
#endif

        } else {
            SmartcardExtension->CardCapabilities.ATR.Buffer[0] = 0x3B;
            SmartcardExtension->CardCapabilities.ATR.Buffer[1] = 0x04;

            RtlCopyBytes((PVOID)&SmartcardExtension->CardCapabilities.ATR.Buffer[2],
                         (PVOID)pbAtrBuffer,
                         ulAtrLength);

            ulAtrLength += 2;
            SmartcardExtension->CardCapabilities.ATR.Length = (UCHAR)ulAtrLength;

            KeAcquireSpinLock(&SmartcardExtension->OsData->SpinLock,
                              &irql);
            SmartcardExtension->ReaderCapabilities.CurrentState = SCARD_SPECIFIC;
            SmartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_T0;
            KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                              irql);

            NTStatus = SmartcardUpdateCardCapabilities(SmartcardExtension);
            if (NTStatus != STATUS_SUCCESS) {
                goto ExitCardPower;
            }

            SmartcardDebug(DEBUG_ATR,("ATR of synchronous smart card : %2.2x %2.2x %2.2x %2.2x\n",
                                      pbAtrBuffer[0],pbAtrBuffer[1],pbAtrBuffer[2],pbAtrBuffer[3]));

        }

         // copy ATR to user space
        if (SmartcardExtension->IoRequest.ReplyBufferLength >=
            SmartcardExtension->CardCapabilities.ATR.Length) {
            RtlCopyBytes((PVOID)SmartcardExtension->IoRequest.ReplyBuffer,
                         (PVOID)SmartcardExtension->CardCapabilities.ATR.Buffer,
                         SmartcardExtension->CardCapabilities.ATR.Length);

            *SmartcardExtension->IoRequest.Information = SmartcardExtension->CardCapabilities.ATR.Length;
        } else {
            NTStatus = STATUS_BUFFER_TOO_SMALL;
            *SmartcardExtension->IoRequest.Information = 0;
        }

        break;

    case SCARD_POWER_DOWN:
        NTStatus = CMMOB_PowerOffCard(SmartcardExtension);
        if (NTStatus != STATUS_SUCCESS) {
            goto ExitCardPower;
        }

        KeAcquireSpinLock(&SmartcardExtension->OsData->SpinLock,
                          &irql);
        SmartcardExtension->ReaderCapabilities.CurrentState = SCARD_SWALLOWED;
        SmartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_UNDEFINED;

        KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                          irql);

        break;
    }


    ExitCardPower:

    ReaderExtension->fTActive=FALSE;
    CMMOB_SetFlags1(ReaderExtension);

    SmartcardDebug(DEBUG_TRACE,
                   ("%s!CardPower: Exit %X\n",DRIVER_NAME,NTStatus ));

    return( NTStatus );

}


/*****************************************************************************
Routine Description:
   CMMOB_PowerOnCard


Arguments:



Return Value:

*****************************************************************************/
NTSTATUS CMMOB_PowerOnCard (
                           IN  PSMARTCARD_EXTENSION SmartcardExtension,
                           IN  PUCHAR pbATR,
                           IN  BOOLEAN fMaxWaitTime,
                           OUT PULONG pulATRLength
                           )
{
    NTSTATUS             NTStatus = STATUS_SUCCESS;
    KTIMER               TimerWait;
    UCHAR                bPowerCmd;
    ULONG                ulCardType;
    ULONG                ulBytesReceived;
    UCHAR                bFirstByte;
    LONG                 lWaitTime;
    LARGE_INTEGER        liWaitTime;
    BOOLEAN              fTimeExpired;


    SmartcardDebug(DEBUG_TRACE,
                   ("%s!PowerOnCard: Enter\n",DRIVER_NAME));

    SmartcardExtension->ReaderExtension->CardParameters.bStopBits=2;
    SmartcardExtension->ReaderExtension->CardParameters.fSynchronousCard=FALSE;
    SmartcardExtension->ReaderExtension->CardParameters.fInversRevers=FALSE;
    SmartcardExtension->ReaderExtension->CardParameters.bClockFrequency=4;
    SmartcardExtension->ReaderExtension->CardParameters.fT0Mode=FALSE;
    SmartcardExtension->ReaderExtension->CardParameters.fT0Write=FALSE;
    SmartcardExtension->ReaderExtension->fReadCIS = FALSE;

   //   reset the state machine of the reader
    NTStatus = CMMOB_ResetReader (SmartcardExtension->ReaderExtension);
    if (NTStatus!=STATUS_SUCCESS)
        goto ExitPowerOnCard;

    if (CMMOB_CardInserted (SmartcardExtension->ReaderExtension)) {

      //initialize Timer
        KeInitializeTimer(&TimerWait);

      //we have to differentiate between cold and warm reset
        if (SmartcardExtension->MinorIoControlCode == SCARD_WARM_RESET &&
            CMMOB_CardPowered (SmartcardExtension->ReaderExtension)) {
         //warm reset
            bPowerCmd=CMD_POWERON_WARM;
        } else {
         //cold reset
            bPowerCmd=CMD_POWERON_COLD;

         //if card is powerde we have to turn it off for cold reset
            if (CMMOB_CardPowered (SmartcardExtension->ReaderExtension))
                CMMOB_PowerOffCard (SmartcardExtension);
        }

#define MAX_CARD_TYPE 2

        for (ulCardType = 0; ulCardType < MAX_CARD_TYPE; ulCardType++) {
            switch (ulCardType) {
            case 0:
               // BaudRate divider 372 - 1
                SmartcardExtension->ReaderExtension->CardParameters.bBaudRateHigh = 0x01;
                SmartcardExtension->ReaderExtension->CardParameters.bBaudRateLow = 0x73;
                if (fMaxWaitTime)
                    lWaitTime=1000;
                else
                    lWaitTime=100;
                SmartcardDebug(DEBUG_ATR,
                               ("%s!trying 3.57 Mhz smart card, waiting time %ims\n",DRIVER_NAME,lWaitTime));
                break;

            case 1:
               // BaudRate divider 512 - 1
                SmartcardExtension->ReaderExtension->CardParameters.bBaudRateHigh = 0x01;
                SmartcardExtension->ReaderExtension->CardParameters.bBaudRateLow = 0xFF;
                if (fMaxWaitTime)
                    lWaitTime=1400;
                else
                    lWaitTime=140;
                SmartcardDebug(DEBUG_ATR,
                               ("%s!trying 4.92 Mhz smart card, waiting time %ims\n",DRIVER_NAME,lWaitTime));
                break;
            }

         //set baud rate
            NTStatus=CMMOB_SetCardParameters(SmartcardExtension->ReaderExtension);
            if (NTStatus!=STATUS_SUCCESS)
                goto ExitPowerOnCard;

         //issue power on command
            NTStatus=CMMOB_WriteRegister(SmartcardExtension->ReaderExtension,
                                         ADDR_WRITEREG_FLAGS0, bPowerCmd);
            if (NTStatus!=STATUS_SUCCESS)
                goto ExitPowerOnCard;

         // maximum wait for power on first byte 100 ms
            liWaitTime = RtlConvertLongToLargeInteger(100L * -10000L);
            KeSetTimer(&TimerWait,liWaitTime,NULL);
            do {
                fTimeExpired = KeReadStateTimer(&TimerWait);
                NTStatus=CMMOB_BytesReceived (SmartcardExtension->ReaderExtension,&ulBytesReceived);
                if (NTStatus!=STATUS_SUCCESS)
                    goto ExitPowerOnCard;
            // wait 1 ms, so that processor is not blocked
                SysDelay(1);
            }
            while (fTimeExpired==FALSE && ulBytesReceived == 0x00);

            if (fTimeExpired) {
                NTStatus = STATUS_IO_TIMEOUT;
            } else {
                ULONG ulBytesReceivedPrevious;

                KeCancelTimer(&TimerWait);

            // maximum wait for power on last byte 1 s for 3.58 card
            // and 1.4 seconds for 4.91 cards
                liWaitTime = RtlConvertLongToLargeInteger(lWaitTime * -10000L);
                do {
                    KeSetTimer(&TimerWait,liWaitTime,NULL);
                    NTStatus=CMMOB_BytesReceived (SmartcardExtension->ReaderExtension,&ulBytesReceivedPrevious);
                    if (NTStatus!=STATUS_SUCCESS)
                        goto ExitPowerOnCard;
                    do {
                        fTimeExpired = KeReadStateTimer(&TimerWait);
                        NTStatus=CMMOB_BytesReceived (SmartcardExtension->ReaderExtension,&ulBytesReceived);
                        if (NTStatus!=STATUS_SUCCESS)
                            goto ExitPowerOnCard;
                  // wait 1 ms, so that processor is not blocked
                        SysDelay(1);
                    }
                    while (fTimeExpired==FALSE && ulBytesReceivedPrevious == ulBytesReceived);

                    if (!fTimeExpired) {
                        KeCancelTimer(&TimerWait);
                    }
                }
                while (!fTimeExpired);


            //now we should have received an ATR
                NTStatus=CMMOB_ResetReader (SmartcardExtension->ReaderExtension);
                if (NTStatus!=STATUS_SUCCESS)
                    goto ExitPowerOnCard;

                NTStatus=CMMOB_ReadBuffer(SmartcardExtension->ReaderExtension, 0, 1, &bFirstByte);
                if (NTStatus!=STATUS_SUCCESS)
                    goto ExitPowerOnCard;

                if ((bFirstByte != 0x3B &&
                     bFirstByte != 0x03 )||
                    ulBytesReceived > MAXIMUM_ATR_LENGTH) {
                    NTStatus=STATUS_UNRECOGNIZED_MEDIA;
                } else {
                    pbATR[0]=bFirstByte;
                    NTStatus=CMMOB_ReadBuffer(SmartcardExtension->ReaderExtension,
                                              1, ulBytesReceived, &pbATR[1]);
                    if (NTStatus!=STATUS_SUCCESS)
                        goto ExitPowerOnCard;
                    *pulATRLength = ulBytesReceived;
               // success leave the loop
                    break;
                }
            }
         // if not the last time in the loop power off
         // the card to get a well defined condition
         // (after the last pass the power off is
         // done outside the loop if necessary)
            if (ulCardType < MAX_CARD_TYPE-1) {
                CMMOB_PowerOffCard(SmartcardExtension);
            }
        }
    } else {
        NTStatus=STATUS_NO_MEDIA;
    }

    ExitPowerOnCard:

    if (NTStatus!=STATUS_SUCCESS) {
        if (NTStatus != STATUS_NO_MEDIA) {
            NTStatus = STATUS_UNRECOGNIZED_MEDIA;
        }
        CMMOB_PowerOffCard(SmartcardExtension);
    }

    SmartcardDebug(DEBUG_TRACE,
                   ("%s!PowerOnCard: Exit %lx\n",DRIVER_NAME,NTStatus));

    return NTStatus;
}


/*****************************************************************************
Routine Description:
   CMMOB_PowerOffCard


Arguments:



Return Value:

*****************************************************************************/
NTSTATUS CMMOB_PowerOffCard (
                            IN PSMARTCARD_EXTENSION SmartcardExtension
                            )
{
    NTSTATUS             NTStatus = STATUS_SUCCESS;
    BYTE*                pbRegsBase;
    KTIMER               TimerWait;
    LARGE_INTEGER        liWaitTime;
    BOOLEAN              fTimeExpired;


    SmartcardDebug(DEBUG_TRACE,
                   ("%s!PowerOffCard: Enter\n",DRIVER_NAME));

    NTStatus = CMMOB_ResetReader (SmartcardExtension->ReaderExtension);
    if (NTStatus!=STATUS_SUCCESS)
        goto ExitPowerOffCard;

    pbRegsBase=SmartcardExtension->ReaderExtension->pbRegsBase;
    if (CMMOB_CardInserted (SmartcardExtension->ReaderExtension)) {
      // set card state for update thread
      // otherwise a card removal/insertion would be recognized
        if (SmartcardExtension->ReaderExtension->ulOldCardState == POWERED)
            SmartcardExtension->ReaderExtension->ulOldCardState = INSERTED;

      //issue power off command
        CMMOB_WriteRegister(SmartcardExtension->ReaderExtension,
                            ADDR_WRITEREG_FLAGS0, CMD_POWEROFF);

        KeInitializeTimer(&TimerWait);
      // maximum wait for power down 1 second
        liWaitTime = RtlConvertLongToLargeInteger(1000L * -10000L);
        KeSetTimer(&TimerWait,liWaitTime,NULL);
        do {
            fTimeExpired = KeReadStateTimer(&TimerWait);
         // wait 1 ms, so that processor is not blocked
            SysDelay(1);
        }
        while (fTimeExpired==FALSE && CMMOB_CardPowered (SmartcardExtension->ReaderExtension));

        if (fTimeExpired) {
            NTStatus = STATUS_IO_TIMEOUT;
        } else {
            KeCancelTimer(&TimerWait);
        }
    } else {
        NTStatus=STATUS_NO_MEDIA;
    }

    ExitPowerOffCard:

    CMMOB_ResetReader (SmartcardExtension->ReaderExtension);

    SmartcardDebug(DEBUG_TRACE,
                   ("%s!PowerOffCard: Exit %lx\n",DRIVER_NAME,NTStatus));

    return NTStatus;
}

/*****************************************************************************
CMMOB_SetProtocol:
   callback handler for SMCLIB RDF_SET_PROTOCOL

Arguments:
   SmartcardExtension   context of call

Return Value:
   STATUS_SUCCESS
   STATUS_NO_MEDIA
   STATUS_TIMEOUT
   STATUS_BUFFER_TOO_SMALL
   STATUS_INVALID_DEVICE_STATE
   STATUS_INVALID_DEVICE_REQUEST
******************************************************************************/
NTSTATUS CMMOB_SetProtocol(
                          PSMARTCARD_EXTENSION SmartcardExtension
                          )
{
    NTSTATUS          NTStatus;
    PREADER_EXTENSION ReaderExtension;
    USHORT            usSCLibProtocol;
    UCHAR             abPTSRequest[4];
    UCHAR             abPTSReply [4];
    ULONG             ulBytesRead;
    ULONG             ulBaudRateDivider;
    ULONG             ulWaitTime;
    UCHAR             bTemp;
    ULONG             i;
    KIRQL             irql;

    SmartcardDebug(DEBUG_TRACE,
                   ("%s!SetProtocol: Enter\n",DRIVER_NAME ));

    ReaderExtension = SmartcardExtension->ReaderExtension;


    ReaderExtension->fTActive=TRUE;
    NTStatus = CMMOB_SetFlags1(ReaderExtension);
    if (NTStatus != STATUS_SUCCESS) {
        goto ExitSetProtocol;
    }


    NTStatus = STATUS_PENDING;

    usSCLibProtocol = ( USHORT )( SmartcardExtension->MinorIoControlCode );

   //
   //   check card insertion
   //
    KeAcquireSpinLock(&SmartcardExtension->OsData->SpinLock,
                      &irql);
    if (SmartcardExtension->ReaderCapabilities.CurrentState == SCARD_ABSENT) {
        NTStatus = STATUS_NO_MEDIA;
    } else {
      //
      //    Check if the card is already in specific state and if the caller
      //    wants to have the selected protocol
      //
        if (SmartcardExtension->ReaderCapabilities.CurrentState == SCARD_SPECIFIC) {
            if (SmartcardExtension->CardCapabilities.Protocol.Selected == usSCLibProtocol) {
                NTStatus = STATUS_SUCCESS;
            }
        }
    }

    KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                      irql);
    if (NTStatus == STATUS_PENDING) {

      //
      //    reset the state machine of the reader
      //
        NTStatus=CMMOB_ResetReader(ReaderExtension);
        if (NTStatus==STATUS_SUCCESS) {
         // try 2 times,
         // 0 - optimal
         // 1 - default
            for (i=0; i<2; i++) {

            // set initial character of PTS
                abPTSRequest[0] = 0xFF;

            // set the format character (PTS0)
                if (SmartcardExtension->CardCapabilities.Protocol.Supported &
                    usSCLibProtocol & SCARD_PROTOCOL_T1) {
               // select T=1 and indicate that PTS1 follows
                    abPTSRequest[1] = 0x11;
                    SmartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_T1;
                } else if (SmartcardExtension->CardCapabilities.Protocol.Supported &
                           usSCLibProtocol & SCARD_PROTOCOL_T0) {
               // select T=0 and indicate that PTS1 follows
                    abPTSRequest[1] = 0x10;
                    SmartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_T0;
                } else {
               // we do not support other protocols
                    NTStatus = STATUS_INVALID_DEVICE_REQUEST;
                    goto ExitSetProtocol;
                }


                if (i==0) {
               // optimal
                    bTemp = (BYTE) (SmartcardExtension->CardCapabilities.PtsData.Fl << 4 |
                                    SmartcardExtension->CardCapabilities.PtsData.Dl);
                    SmartcardDebug(DEBUG_PROTOCOL,
                                   ("%s! from library suggested PTS1(0x%x)\n",DRIVER_NAME,bTemp));

                    SmartcardExtension->CardCapabilities.PtsData.Type = PTS_TYPE_OPTIMAL;
                    SmartcardExtension->CardCapabilities.PtsData.Fl=SmartcardExtension->CardCapabilities.Fl;
                    SmartcardExtension->CardCapabilities.PtsData.Dl=SmartcardExtension->CardCapabilities.Dl;
                } else {
               // default
               // we dont know if it is correct to set 4.91Mhz cards to 0x11
               // but we have no card to try now
                    SmartcardExtension->CardCapabilities.PtsData.Type = PTS_TYPE_DEFAULT;
                    SmartcardExtension->CardCapabilities.PtsData.Fl=1;
                    SmartcardExtension->CardCapabilities.PtsData.Dl=1;
                }

                bTemp = (BYTE) (SmartcardExtension->CardCapabilities.PtsData.Fl << 4 |
                                SmartcardExtension->CardCapabilities.PtsData.Dl);
                SmartcardDebug(DEBUG_PROTOCOL,
                               ("%s! trying PTS1(0x%x)\n",DRIVER_NAME,bTemp));
                switch (SmartcardExtension->CardCapabilities.PtsData.Fl) {
                case 1:
                  // here we can handle all baudrates
                    break;
                case 2:
                case 3:
                    if (SmartcardExtension->CardCapabilities.PtsData.Dl == 1) {
                        SmartcardDebug(DEBUG_PROTOCOL,
                                       ("%s! overwriting PTS1(0x%x)\n",DRIVER_NAME,bTemp));
                     // we must correct Fl/Dl
                        SmartcardExtension->CardCapabilities.PtsData.Dl = 0x01;
                        SmartcardExtension->CardCapabilities.PtsData.Fl = 0x01;
                    }
                    break;
                case 4:
                case 5:
                case 6:
                    if (SmartcardExtension->CardCapabilities.PtsData.Dl == 1 ||
                        SmartcardExtension->CardCapabilities.PtsData.Dl == 2) {
                        SmartcardDebug(DEBUG_PROTOCOL,
                                       ("%s! overwriting PTS1(0x%x)\n",DRIVER_NAME,bTemp));
                     // we must correct Fl/Dl
                        SmartcardExtension->CardCapabilities.PtsData.Dl = 0x01;
                        SmartcardExtension->CardCapabilities.PtsData.Fl = 0x01;
                    }
                    break;
                case 9:
                  // here we can handle all baudrates
                    break;
                case 10:
                case 11:
                    if (SmartcardExtension->CardCapabilities.PtsData.Dl == 1) {
                        SmartcardDebug(DEBUG_PROTOCOL,
                                       ("%s! overwriting PTS1(0x%x)\n",DRIVER_NAME,bTemp));
                     // we must correct Fl/Dl
                        SmartcardExtension->CardCapabilities.PtsData.Dl = 0x01;
                        SmartcardExtension->CardCapabilities.PtsData.Fl = 0x09;
                    }
                    break;
                case 12:
                case 13:
                    if (SmartcardExtension->CardCapabilities.PtsData.Dl == 1 ||
                        SmartcardExtension->CardCapabilities.PtsData.Dl == 2) {
                        SmartcardDebug(DEBUG_PROTOCOL,
                                       ("%s! overwriting PTS1(0x%x)\n",DRIVER_NAME,bTemp));
                     // we must correct Fl/Dl
                        SmartcardExtension->CardCapabilities.PtsData.Dl = 0x01;
                        SmartcardExtension->CardCapabilities.PtsData.Fl = 0x09;
                    }
                    break;
                default:
                  // this are the RFUs
                    SmartcardDebug(DEBUG_PROTOCOL,
                                   ("%s! overwriting PTS1(0x%x)\n",DRIVER_NAME,bTemp));
                  // we must correct Fl/Dl
                    SmartcardExtension->CardCapabilities.PtsData.Dl = 0x01;
                    SmartcardExtension->CardCapabilities.PtsData.Fl = 0x01;
                    break;
                }


            // set PTS1 with codes Fl and Dl
                abPTSRequest[2] = (BYTE) (SmartcardExtension->CardCapabilities.PtsData.Fl << 4 |
                                          SmartcardExtension->CardCapabilities.PtsData.Dl);


            // set PCK (check character)
                abPTSRequest[3] = (BYTE)(abPTSRequest[0] ^ abPTSRequest[1] ^ abPTSRequest[2]);

                if (ReaderExtension->CardParameters.fInversRevers) {
                    SmartcardDebug(DEBUG_PROTOCOL,
                                   ("%s! PTS request for InversConvention\n",DRIVER_NAME));
                    CMMOB_InverseBuffer (abPTSRequest,4);
                }

#if DBG
                {
                    ULONG k;
                    SmartcardDebug(DEBUG_PROTOCOL,("%s! writing PTS request: ",DRIVER_NAME));
                    for (k = 0;k < 4;k++)
                        SmartcardDebug(DEBUG_PROTOCOL,("%2.2x ",abPTSRequest[k]));
                    SmartcardDebug(DEBUG_PROTOCOL,("\n"));
                }
#endif

                NTStatus = CMMOB_WriteT1(ReaderExtension,4,abPTSRequest);
                if (NTStatus != STATUS_SUCCESS) {
                    SmartcardDebug(DEBUG_ERROR,
                                   ("%s! writing PTS request failed\n", DRIVER_NAME));
                    goto ExitSetProtocol;
                }

            // read back PTS data
                ulWaitTime=1000;
                if (SmartcardExtension->CardCapabilities.PtsData.Fl >= 8)
                    ulWaitTime=1400;
                NTStatus = CMMOB_ReadT1(ReaderExtension,4,
                                        ulWaitTime,ulWaitTime,
                                        abPTSReply,&ulBytesRead);
            // in case of an short PTS reply an timeout will occur,
            // but that's not the standard case
                if (NTStatus != STATUS_SUCCESS && NTStatus != STATUS_IO_TIMEOUT) {
                    SmartcardDebug(DEBUG_ERROR,
                                   ("%s! reading PTS reply: failed\n",DRIVER_NAME));
                    goto ExitSetProtocol;
                }
#if DBG
                {
                    ULONG k;
                    SmartcardDebug(DEBUG_PROTOCOL,("%s! reading PTS reply: ",DRIVER_NAME));
                    for (k = 0;k < ulBytesRead;k++)
                        SmartcardDebug(DEBUG_PROTOCOL,("%2.2x ",abPTSReply[k]));
                    SmartcardDebug(DEBUG_PROTOCOL,("\n"));
                }
#endif

                if (ulBytesRead == 4 &&
                    abPTSReply[0] == abPTSRequest[0] &&
                    abPTSReply[1] == abPTSRequest[1] &&
                    abPTSReply[2] == abPTSRequest[2] &&
                    abPTSReply[3] == abPTSRequest[3] ) {
                    SmartcardDebug(DEBUG_PROTOCOL,
                                   ("%s! PTS request and reply match\n",DRIVER_NAME));

                    if ((SmartcardExtension->CardCapabilities.PtsData.Fl >= 3 &&
                         SmartcardExtension->CardCapabilities.PtsData.Fl < 8) ||
                        (SmartcardExtension->CardCapabilities.PtsData.Fl >= 11 &&
                         SmartcardExtension->CardCapabilities.PtsData.Fl < 16)) {
                        ReaderExtension->CardParameters.bClockFrequency=8;
                    }

                    ulBaudRateDivider = Fi[SmartcardExtension->CardCapabilities.PtsData.Fl] /
                                        Di[SmartcardExtension->CardCapabilities.PtsData.Dl];
               // decrease by 1, because these values have to be written to CardMan
                    ulBaudRateDivider--;
                    if (ulBaudRateDivider < 512) {
                        ReaderExtension->CardParameters.bBaudRateLow=(UCHAR)(ulBaudRateDivider & 0xFF);
                        if (ulBaudRateDivider>255) {
                            ReaderExtension->CardParameters.bBaudRateHigh=1;
                        } else {
                            ReaderExtension->CardParameters.bBaudRateHigh=0;
                        }

                        NTStatus = CMMOB_SetCardParameters (ReaderExtension);
                        if (NTStatus == STATUS_SUCCESS) {
                     //
                     // we had success, leave the loop
                     //
                            break;
                        }
                    }
                }

                if (ulBytesRead == 3 &&
                    abPTSReply[0] == abPTSRequest[0] &&
                    (abPTSReply[1] & 0x7F) == (abPTSRequest[1] & 0x0F) &&
                    abPTSReply[2] == (BYTE)(abPTSReply[0] ^ abPTSReply[1] )) {
                    SmartcardDebug(DEBUG_PROTOCOL,
                                   ("%s! Short PTS reply received\n",DRIVER_NAME));

                    if (SmartcardExtension->CardCapabilities.PtsData.Fl >= 9) {
                        ulBaudRateDivider = 512;
                    } else {
                        ulBaudRateDivider = 372;
                    }
               // decrease by 1, because these values have to be written to CardMan
                    ulBaudRateDivider--;

                    NTStatus = CMMOB_SetCardParameters (ReaderExtension);
                    if (NTStatus == STATUS_SUCCESS) {
                  //
                  // we had success, leave the loop
                  //
                        break;
                    }
                }

                if (i==0) {
               // this was the first try
               // we have a second with default values
                    SmartcardDebug(DEBUG_PROTOCOL,
                                   ("%s! PTS failed : Trying default parameters\n",DRIVER_NAME));

               // the card did either not reply or it replied incorrectly
               // so try default values
                    SmartcardExtension->MinorIoControlCode = SCARD_COLD_RESET;
                    NTStatus = CMMOB_CardPower(SmartcardExtension);
                } else {
               // the card failed the PTS request
                    NTStatus = STATUS_DEVICE_PROTOCOL_ERROR;
                }
            }
        }
    }

    ExitSetProtocol:

   //
   //   if protocol selection failed, prevent from calling invalid protocols
   //

    KeAcquireSpinLock(&SmartcardExtension->OsData->SpinLock,
                      &irql);
    if (NTStatus==STATUS_SUCCESS) {
        SmartcardExtension->ReaderCapabilities.CurrentState = SCARD_SPECIFIC;
    } else {
        SmartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_UNDEFINED;
    }
    KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                      irql);

   //
   //   Return the selected protocol to the caller.
   //
    *(PULONG) (SmartcardExtension->IoRequest.ReplyBuffer) = SmartcardExtension->CardCapabilities.Protocol.Selected;
    *SmartcardExtension->IoRequest.Information = sizeof( ULONG );


    ReaderExtension->fTActive=FALSE;
    CMMOB_SetFlags1(ReaderExtension);

    SmartcardDebug(DEBUG_TRACE,
                   ("%s!SetProtocol: Exit %X\n",DRIVER_NAME,NTStatus ));

    return( NTStatus );
}


/*****************************************************************************
CMMOB_Transmit:
   callback handler for SMCLIB RDF_TRANSMIT

Arguments:
   SmartcardExtension   context of call

Return Value:
   STATUS_SUCCESS
   STATUS_NO_MEDIA
   STATUS_TIMEOUT
   STATUS_INVALID_DEVICE_REQUEST
******************************************************************************/
NTSTATUS CMMOB_Transmit (
                        PSMARTCARD_EXTENSION SmartcardExtension
                        )
{
    NTSTATUS  NTStatus = STATUS_SUCCESS;

    SmartcardDebug(DEBUG_TRACE,
                   ("%s!Transmit: Enter\n",DRIVER_NAME ));
   //
   //   dispatch on the selected protocol
   //
    switch (SmartcardExtension->CardCapabilities.Protocol.Selected) {
    case SCARD_PROTOCOL_T0:
        NTStatus = CMMOB_TransmitT0(SmartcardExtension);
        break;

    case SCARD_PROTOCOL_T1:
        NTStatus = CMMOB_TransmitT1(SmartcardExtension);
        break;

         /*
         case SCARD_PROTOCOL_RAW:
            break;
         */

    default:
        NTStatus = STATUS_INVALID_DEVICE_REQUEST;
        break;
    }

    SmartcardDebug(DEBUG_TRACE,
                   ("%s!Transmit: Exit %X\n",DRIVER_NAME,NTStatus ));

    return( NTStatus );
}


/*****************************************************************************
CMMOB_TransmitT0:
   callback handler for SMCLIB RDF_TRANSMIT

Arguments:
   SmartcardExtension   context of call

Return Value:
   STATUS_SUCCESS
   STATUS_NO_MEDIA
   STATUS_TIMEOUT
   STATUS_INVALID_DEVICE_REQUEST
******************************************************************************/
NTSTATUS CMMOB_TransmitT0 (
                          PSMARTCARD_EXTENSION SmartcardExtension
                          )
{
    NTSTATUS NTStatus;
    UCHAR    abWriteBuffer[MIN_BUFFER_SIZE];
    UCHAR    abReadBuffer[MIN_BUFFER_SIZE];
    ULONG    ulBytesToWrite;                  //length written to card
    ULONG    ulBytesToReceive;                //length expected from card
    ULONG    ulBytesToRead;                   //length expected from reader
    ULONG    ulBytesRead;                     //length received from reader
                                              //(without length written)
    ULONG    ulCWTWaitTime;
    BOOLEAN  fDataSent;                        //data longer than T0_HEADER


    SmartcardExtension->ReaderExtension->fTActive=TRUE;
    NTStatus = CMMOB_SetFlags1(SmartcardExtension->ReaderExtension);
    if (NTStatus != STATUS_SUCCESS) {
        goto ExitTransmitT0;
    }


   //   reset the state machine of the reader
    NTStatus = CMMOB_ResetReader (SmartcardExtension->ReaderExtension);
    if (NTStatus!=STATUS_SUCCESS) {
      // there must be severe error
        goto ExitTransmitT0;
    }

   // set T0 mode
    SmartcardExtension->ReaderExtension->CardParameters.fT0Mode=TRUE;

   // increase timeout for T0 Transmission
    ulCWTWaitTime = SmartcardExtension->CardCapabilities.T0.WT/1000 + 1500;


   //
   // Let the lib build a T=0 packet
   //

   // no bytes additionally needed
    SmartcardExtension->SmartcardRequest.BufferLength = 0;
    NTStatus = SmartcardT0Request(SmartcardExtension);
    if (NTStatus != STATUS_SUCCESS) {
      // the lib detected an error in the data to send.
        goto ExitTransmitT0;
    }

   // copy data to the write buffer
    ulBytesToWrite = T0_HEADER_LEN + SmartcardExtension->T0.Lc;
    RtlCopyMemory(abWriteBuffer,SmartcardExtension->SmartcardRequest.Buffer,ulBytesToWrite);
    ulBytesToReceive = SmartcardExtension->T0.Le;

#if DBG
    {
        ULONG i;
        SmartcardDebug(DEBUG_PROTOCOL,("%s!TransmitT0: Request ",DRIVER_NAME));
        for (i = 0;i < ulBytesToWrite;i++)
            SmartcardDebug(DEBUG_PROTOCOL,("%2.2x ",abWriteBuffer[i]));
        SmartcardDebug(DEBUG_PROTOCOL,("\n"));
    }
#endif

   // set T0 write flag correctly
    if (ulBytesToReceive == 0) {
        SmartcardExtension->ReaderExtension->CardParameters.fT0Write=TRUE;
    } else {
        SmartcardExtension->ReaderExtension->CardParameters.fT0Write=FALSE;
    }
    NTStatus=CMMOB_SetCardParameters(SmartcardExtension->ReaderExtension);
    if (NTStatus != STATUS_SUCCESS)
        goto ExitTransmitT0;


    NTStatus = CMMOB_WriteT0 (SmartcardExtension->ReaderExtension,
                              ulBytesToWrite,
                              ulBytesToReceive,
                              abWriteBuffer);
    if (NTStatus != STATUS_SUCCESS) {
        goto ExitTransmitT0;
    }

   // bytes to write + answer + SW2
    if ( (MAXULONG - ulBytesToWrite < ulBytesToReceive + 1) || 
         (ulBytesToReceive == MAXULONG)) {
        NTStatus = STATUS_BUFFER_OVERFLOW;
        goto ExitTransmitT0;
    }
    ulBytesToRead = ulBytesToWrite + ulBytesToReceive + 1;

    if (ulBytesToRead > MIN_BUFFER_SIZE) {
        NTStatus = STATUS_BUFFER_OVERFLOW;
        goto ExitTransmitT0;
    }
    NTStatus = CMMOB_ReadT0 (SmartcardExtension->ReaderExtension,
                             ulBytesToRead,
                             ulBytesToWrite,
                             ulCWTWaitTime,
                             abReadBuffer,
                             &ulBytesRead,
                             &fDataSent);

#if DBG
    {
        ULONG i;
        SmartcardDebug(DEBUG_PROTOCOL,("%s!TransmitT0: Reply ",DRIVER_NAME));
        for (i = 0;i < ulBytesRead;i++)
            SmartcardDebug(DEBUG_PROTOCOL,("%2.2x ",abReadBuffer[i]));
        SmartcardDebug(DEBUG_PROTOCOL,("\n"));
    }
#endif

    if (NTStatus != STATUS_SUCCESS) {
        SmartcardDebug(DEBUG_PROTOCOL,("%s!TransmitT0: Read failed!\n",DRIVER_NAME));
        goto ExitTransmitT0;
    }

   // copy received bytes
    if (ulBytesRead <= SmartcardExtension->SmartcardReply.BufferSize) {
        RtlCopyBytes((PVOID)SmartcardExtension->SmartcardReply.Buffer,
                     (PVOID) abReadBuffer,
                     ulBytesRead);
        SmartcardExtension->SmartcardReply.BufferLength = ulBytesRead;
    } else {
        NTStatus=STATUS_BUFFER_OVERFLOW;
        goto ExitTransmitT0;
    }

   // let the lib copy the received bytes to the user buffer
    NTStatus = SmartcardT0Reply(SmartcardExtension);
    if (NTStatus != STATUS_SUCCESS) {
        goto ExitTransmitT0;
    }


    ExitTransmitT0:
   // ------------------------------------------
   // ITSEC E2 requirements: clear write buffers
   // ------------------------------------------
    RtlFillMemory((PVOID)abWriteBuffer,sizeof(abWriteBuffer),0x00);
    RtlFillMemory((PVOID)SmartcardExtension->SmartcardRequest.Buffer,
                  SmartcardExtension->SmartcardRequest.BufferSize,0x00);

   // set T0 mode back
    SmartcardExtension->ReaderExtension->CardParameters.fT0Mode=FALSE;
    SmartcardExtension->ReaderExtension->CardParameters.fT0Write=FALSE;
    CMMOB_SetCardParameters(SmartcardExtension->ReaderExtension);


    SmartcardExtension->ReaderExtension->fTActive=FALSE;
    CMMOB_SetFlags1(SmartcardExtension->ReaderExtension);


    return NTStatus;
}



/*****************************************************************************
CMMOB_TransmitT1:
   callback handler for SMCLIB RDF_TRANSMIT

Arguments:
   SmartcardExtension   context of call

Return Value:
   STATUS_SUCCESS
   STATUS_NO_MEDIA
   STATUS_TIMEOUT
   STATUS_INVALID_DEVICE_REQUEST
******************************************************************************/
NTSTATUS CMMOB_TransmitT1 (
                          PSMARTCARD_EXTENSION SmartcardExtension
                          )
{
    NTSTATUS    NTStatus;
    UCHAR       abReadBuffer[CMMOB_MAXBUFFER];
    LONG        lBytesToRead;
    ULONG       ulBytesRead;
    ULONG       ulCurrentWaitTime;
    ULONG       ulCWTWaitTime;
    ULONG       ulBWTWaitTime;
    ULONG       ulWTXWaitTime;
    ULONG       ulTemp;

    SmartcardDebug(DEBUG_PROTOCOL,
                   ("%s!TransmitT1 CWT = %ld(ms)\n",DRIVER_NAME,
                    SmartcardExtension->CardCapabilities.T1.CWT/1000));
    SmartcardDebug(DEBUG_PROTOCOL,
                   ("%s!TransmitT1 BWT = %ld(ms)\n",DRIVER_NAME,
                    SmartcardExtension->CardCapabilities.T1.BWT/1000));

    ulCWTWaitTime = (ULONG)(100 + 32*(SmartcardExtension->CardCapabilities.T1.CWT/1000));
    ulBWTWaitTime = (ULONG)(1000 + SmartcardExtension->CardCapabilities.T1.BWT/1000);
    ulWTXWaitTime = 0;


    SmartcardExtension->ReaderExtension->fTActive=TRUE;
    NTStatus = CMMOB_SetFlags1(SmartcardExtension->ReaderExtension);
    if (NTStatus != STATUS_SUCCESS) {
        goto ExitTransmitT1;
    }


   //   reset the state machine of the reader
    NTStatus = CMMOB_ResetReader (SmartcardExtension->ReaderExtension);
    if (NTStatus!=STATUS_SUCCESS) {
      // there must be severe error
        goto ExitTransmitT1;
    }

    do {
      // no bytes additionally needed
        SmartcardExtension->SmartcardRequest.BufferLength = 0;

        NTStatus = SmartcardT1Request(SmartcardExtension);
        if (NTStatus != STATUS_SUCCESS) {
         // this should never happen, so we return immediately
            goto ExitTransmitT1;
        }

#if DBG
        {
            ULONG i;
            SmartcardDebug(DEBUG_PROTOCOL,("%s!TransmitT1: Request ",DRIVER_NAME));
            for (i = 0;i < SmartcardExtension->SmartcardRequest.BufferLength;i++)
                SmartcardDebug(DEBUG_PROTOCOL,("%2.2x ",SmartcardExtension->SmartcardRequest.Buffer[i]));
            SmartcardDebug(DEBUG_PROTOCOL,("\n"));
        }
#endif

      //    write to the reader
        NTStatus = CMMOB_WriteT1 (SmartcardExtension->ReaderExtension,
                                  SmartcardExtension->SmartcardRequest.BufferLength,
                                  SmartcardExtension->SmartcardRequest.Buffer);
        if (NTStatus == STATUS_SUCCESS) {

            if (ulWTXWaitTime ==  0 ) { // use BWT
            /*
            SmartcardDebug(DEBUG_TRACE,
                           ("%s!ulCurrentWaitTime = %ld\n",DRIVER_NAME,ulCurrentWaitTime));
            */
                ulCurrentWaitTime = ulBWTWaitTime;
            } else { // use WTX time
            /*
            SmartcardDebug(DEBUG_TRACE,
                           ("%s!ulCurrentWaitTime = %ld\n",DRIVER_NAME,ulWTXWaitTime));
            */
                ulCurrentWaitTime = ulWTXWaitTime;
            }


            if (SmartcardExtension->CardCapabilities.T1.EDC == T1_CRC_CHECK) {
            // in case of card with CRC check read reply + 5 bytes
            // a negative value indicates a relative number of bytes to read
                lBytesToRead=-5;
            } else {
            // in case of card with CRC check read reply + 4 bytes
            // a negative value indicates a relative number of bytes to read
                lBytesToRead=-4;
            }

            NTStatus = CMMOB_ReadT1(SmartcardExtension->ReaderExtension,lBytesToRead,
                                    ulCurrentWaitTime,ulCWTWaitTime,abReadBuffer,&ulBytesRead);
            if (NTStatus == STATUS_SUCCESS) {

                if (abReadBuffer[1] == T1_WTX_REQUEST) {
                    ulWTXWaitTime = (ULONG)(1000 +((SmartcardExtension->CardCapabilities.T1.BWT*abReadBuffer[3])/1000));
                    SmartcardDebug(DEBUG_PROTOCOL,
                                   ("%s!TransmitT1 WTX = %ld(ms)\n",DRIVER_NAME,ulWTXWaitTime));
                } else {
                    ulWTXWaitTime = 0;
                }

#if DBG
                {
                    ULONG i;
                    SmartcardDebug(DEBUG_PROTOCOL,("%s!TransmitT1: Reply ",DRIVER_NAME));
                    for (i = 0;i < ulBytesRead;i++)
                        SmartcardDebug(DEBUG_PROTOCOL,("%2.2x ",abReadBuffer[i]));
                    SmartcardDebug(DEBUG_PROTOCOL,("\n"));
                }
#endif
            // copy received bytes
                if (ulBytesRead <= SmartcardExtension->SmartcardReply.BufferSize) {
                    RtlCopyBytes((PVOID)SmartcardExtension->SmartcardReply.Buffer,
                                 (PVOID)abReadBuffer,
                                 ulBytesRead);
                    SmartcardExtension->SmartcardReply.BufferLength = ulBytesRead;
                } else {
                    NTStatus=STATUS_BUFFER_OVERFLOW;
                    goto ExitTransmitT1;
                }
            }
        }

        if (NTStatus != STATUS_SUCCESS) {
            SmartcardExtension->SmartcardReply.BufferLength = 0L;
        }

      // bug fix for smclib
        if (SmartcardExtension->T1.State         == T1_IFS_RESPONSE &&
            SmartcardExtension->T1.OriginalState == T1_I_BLOCK) {
            SmartcardExtension->T1.State = T1_I_BLOCK;
        }

        NTStatus = SmartcardT1Reply(SmartcardExtension);
    }
    while (NTStatus == STATUS_MORE_PROCESSING_REQUIRED);


    ExitTransmitT1:
   // ------------------------------------------
   // ITSEC E2 requirements: clear write buffers
   // ------------------------------------------
    RtlFillMemory((PVOID)SmartcardExtension->SmartcardRequest.Buffer,
                  SmartcardExtension->SmartcardRequest.BufferSize,0x00);

    SmartcardExtension->ReaderExtension->fTActive=FALSE;
    CMMOB_SetFlags1(SmartcardExtension->ReaderExtension);

    return NTStatus;
}

/*****************************************************************************
CMMOB_IoCtlVendor:
   Performs generic callbacks to the reader

Arguments:
   SmartcardExtension   context of the call

Return Value:
   STATUS_SUCCESS
******************************************************************************/
NTSTATUS CMMOB_IoCtlVendor(
                          PSMARTCARD_EXTENSION SmartcardExtension
                          )
{
    NTSTATUS             NTStatus=STATUS_SUCCESS;
    PIRP                 Irp;
    PIO_STACK_LOCATION   IrpStack;

    SmartcardDebug(DEBUG_TRACE,
                   ("%s!IoCtlVendor: Enter\n",DRIVER_NAME ));

   //
   //   get pointer to current IRP stack location
   //
    Irp = SmartcardExtension->OsData->CurrentIrp;
    IrpStack = IoGetCurrentIrpStackLocation( Irp );
    Irp->IoStatus.Information = 0;

   //
   //   dispatch IOCTL
   //
    switch (IrpStack->Parameters.DeviceIoControl.IoControlCode) {
    case CM_IOCTL_GET_FW_VERSION:
        NTStatus = CMMOB_GetFWVersion(SmartcardExtension);
        break;

    case CM_IOCTL_CR80S_SAMOS_SET_HIGH_SPEED:
        NTStatus = CMMOB_SetHighSpeed_CR80S_SAMOS(SmartcardExtension);
        break;

    case CM_IOCTL_SET_READER_9600_BAUD:
        NTStatus = CMMOB_SetReader_9600Baud(SmartcardExtension);
        break;

    case CM_IOCTL_SET_READER_38400_BAUD:
        NTStatus = CMMOB_SetReader_38400Baud(SmartcardExtension);
        break;

    case CM_IOCTL_READ_DEVICE_DESCRIPTION:
        NTStatus = CMMOB_ReadDeviceDescription(SmartcardExtension);
        break;

    default:
        NTStatus = STATUS_INVALID_DEVICE_REQUEST;
        break;
    }

   //
   //   set NTStatus of the packet
   //
    Irp->IoStatus.Status = NTStatus;

    SmartcardDebug(DEBUG_TRACE,
                   ("%s!IoCtlVendor: Exit %X\n",DRIVER_NAME,NTStatus ));

    return( NTStatus );
}



/*****************************************************************************
Routine Description:


Arguments:


Return Value: STATUS_UNSUCCESSFUL
              STATUS_SUCCESS

*****************************************************************************/
NTSTATUS CMMOB_SetReader_9600Baud (
                                  IN PSMARTCARD_EXTENSION SmartcardExtension
                                  )
{
    NTSTATUS    NTStatus = STATUS_SUCCESS;
    KIRQL       irql;

    SmartcardDebug(DEBUG_TRACE,
                   ("%s!SetReader_9600Baud: Enter\n",DRIVER_NAME));

   // check if card is already in specific mode
    KeAcquireSpinLock(&SmartcardExtension->OsData->SpinLock,
                      &irql);
    if (SmartcardExtension->ReaderCapabilities.CurrentState != SCARD_SPECIFIC) {
        KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                          irql);
        NTStatus = STATUS_INVALID_DEVICE_REQUEST;
        goto ExitSetReader9600;
    }

    KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                      irql);
   // set 9600 Baud for 3.58 MHz
    SmartcardExtension->ReaderExtension->CardParameters.bBaudRateHigh=0x01;
    SmartcardExtension->ReaderExtension->CardParameters.bBaudRateLow=0x73;
    NTStatus = CMMOB_SetCardParameters (SmartcardExtension->ReaderExtension);

    ExitSetReader9600:
    *SmartcardExtension->IoRequest.Information = 0L;
    SmartcardDebug(DEBUG_TRACE,
                   ("%s!SetReader_9600Baud: Exit %lx\n",DRIVER_NAME,NTStatus));

    return(NTStatus);
}


/*****************************************************************************
Routine Description:


Arguments:


Return Value: STATUS_UNSUCCESSFUL
              STATUS_SUCCESS

*****************************************************************************/
NTSTATUS CMMOB_SetReader_38400Baud (
                                   IN PSMARTCARD_EXTENSION SmartcardExtension
                                   )
{
    NTSTATUS    NTStatus = STATUS_SUCCESS;
    KIRQL       irql;

    SmartcardDebug(DEBUG_TRACE,
                   ("%s!SetReader_38400Baud: Enter\n",DRIVER_NAME));

   // check if card is already in specific mode
    KeAcquireSpinLock(&SmartcardExtension->OsData->SpinLock,
                      &irql);
    if (SmartcardExtension->ReaderCapabilities.CurrentState != SCARD_SPECIFIC) {
        KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                          irql);
        NTStatus = STATUS_INVALID_DEVICE_REQUEST;
        goto ExitSetReader38400;
    }
    KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                      irql);

   // set 384000 Baud for 3.58 MHz card
    SmartcardExtension->ReaderExtension->CardParameters.bBaudRateHigh=0x00;
    SmartcardExtension->ReaderExtension->CardParameters.bBaudRateLow=0x5D;
    NTStatus = CMMOB_SetCardParameters (SmartcardExtension->ReaderExtension);

    ExitSetReader38400:
    *SmartcardExtension->IoRequest.Information = 0L;
    SmartcardDebug(DEBUG_TRACE,
                   ("%s!SetReader_38400Baud: Exit %lx\n",DRIVER_NAME,NTStatus));

    return(NTStatus);
}


/*****************************************************************************
Routine Description:


Arguments:


Return Value: STATUS_UNSUCCESSFUL
              STATUS_SUCCESS

*****************************************************************************/
NTSTATUS CMMOB_SetHighSpeed_CR80S_SAMOS (
                                        IN PSMARTCARD_EXTENSION SmartcardExtension
                                        )
{
    NTSTATUS    NTStatus;
    UCHAR       abCR80S_SAMOS_SET_HIGH_SPEED[4] = {0xFF,0x11,0x94,0x7A};

    SmartcardDebug(DEBUG_TRACE,
                   ("%s!SetHighSpeed_CR80S_SAMOS: Enter\n",DRIVER_NAME));

    NTStatus = CMMOB_SetSpeed (SmartcardExtension,
                               abCR80S_SAMOS_SET_HIGH_SPEED);
    SmartcardDebug(DEBUG_TRACE,
                   ("%s!SetHighSpeed_CR80S_SAMOS: Exit %lx\n",DRIVER_NAME,NTStatus));

    return(NTStatus);
}


/*****************************************************************************
Routine Description:


Arguments:


Return Value: STATUS_UNSUCCESSFUL
              STATUS_SUCCESS

*****************************************************************************/
NTSTATUS CMMOB_SetSpeed (
                        IN PSMARTCARD_EXTENSION SmartcardExtension,
                        IN PUCHAR               abFIDICommand
                        )
{
    NTSTATUS    NTStatus;
    NTSTATUS    DebugStatus;
    UCHAR       abReadBuffer[16];
    ULONG       ulBytesRead;
    ULONG       ulWaitTime;


    SmartcardDebug(DEBUG_TRACE,
                   ("%s!SetSpeed: Enter\n",DRIVER_NAME));


    SmartcardExtension->ReaderExtension->fTActive=TRUE;
    NTStatus = CMMOB_SetFlags1(SmartcardExtension->ReaderExtension);
    if (NTStatus != STATUS_SUCCESS) {
        goto ExitSetSpeed;
    }


#if DBG
    {
        ULONG k;
        SmartcardDebug(DEBUG_PROTOCOL,("%s!SetSpeed: writing: ",DRIVER_NAME));
        for (k = 0;k < 4;k++)
            SmartcardDebug(DEBUG_PROTOCOL,("%2.2x ",abFIDICommand[k]));
        SmartcardDebug(DEBUG_PROTOCOL,("\n"));
    }
#endif

    NTStatus = CMMOB_WriteT1(SmartcardExtension->ReaderExtension,4,
                             abFIDICommand);
    if (NTStatus != STATUS_SUCCESS) {
        SmartcardDebug(DEBUG_ERROR,
                       ("%s!SetSpeed: writing high speed command failed\n",DRIVER_NAME));
        goto ExitSetSpeed;
    }


   // read back pts data
   // maximim initial waiting time is 9600 * etu
   // clock divider of this card 512 => 1.4 sec is sufficient
    ulWaitTime = 1400;
    NTStatus = CMMOB_ReadT1(SmartcardExtension->ReaderExtension,4,
                            ulWaitTime,ulWaitTime,abReadBuffer,&ulBytesRead);

    SmartcardDebug(DEBUG_PROTOCOL,
                   ("%s!SetSpeed: reading echo: ",DRIVER_NAME));

    if (NTStatus != STATUS_SUCCESS) {
        SmartcardDebug(DEBUG_PROTOCOL,("failed\n"));
        goto ExitSetSpeed;
    }

#if DBG
    {
        ULONG k;
        for (k = 0;k < ulBytesRead;k++)
            SmartcardDebug(DEBUG_PROTOCOL,("%2.2x ",abReadBuffer[k]));
        SmartcardDebug(DEBUG_PROTOCOL,("\n"));
    }
#endif

   // if the card has accepted this string , the string is echoed
    if (abReadBuffer[0] == abFIDICommand[0] &&
        abReadBuffer[1] == abFIDICommand[1] &&
        abReadBuffer[2] == abFIDICommand[2] &&
        abReadBuffer[3] == abFIDICommand[3] ) {
        SmartcardExtension->ReaderExtension->CardParameters.bBaudRateLow=63;
        SmartcardExtension->ReaderExtension->CardParameters.bBaudRateHigh=0;
        NTStatus = CMMOB_SetCardParameters (SmartcardExtension->ReaderExtension);
    } else {
        SmartcardExtension->MinorIoControlCode = SCARD_COLD_RESET;
        CMMOB_CardPower(SmartcardExtension);

        NTStatus = STATUS_UNSUCCESSFUL;
    }


    ExitSetSpeed:

    *SmartcardExtension->IoRequest.Information = 0L;
    if (NTStatus != STATUS_SUCCESS) {
        NTStatus = STATUS_UNSUCCESSFUL;
    }

    SmartcardExtension->ReaderExtension->fTActive=FALSE;
    CMMOB_SetFlags1(SmartcardExtension->ReaderExtension);

    SmartcardDebug(DEBUG_TRACE,
                   ("%s!SetSpeed: Exit %lx\n",DRIVER_NAME,NTStatus));

    return NTStatus;
}


/*****************************************************************************
Routine Description:
This function always returns 'CardManMobile'.


Arguments:     pointer to SMARTCARD_EXTENSION



Return Value:  NT status

*****************************************************************************/
NTSTATUS CMMOB_ReadDeviceDescription(
                                    IN PSMARTCARD_EXTENSION SmartcardExtension
                                    )
{
    NTSTATUS NTStatus = STATUS_SUCCESS;
    BYTE abDeviceDescription[] = "CardManMobile";

    SmartcardDebug(DEBUG_TRACE,
                   ("%s!ReadDeviceDescription : Enter\n",DRIVER_NAME));

    if (SmartcardExtension->IoRequest.ReplyBufferLength  < sizeof(abDeviceDescription)) {
        NTStatus = STATUS_BUFFER_OVERFLOW;
        *SmartcardExtension->IoRequest.Information = 0L;
        goto ExitReadDeviceDescription;
    } else {
        RtlCopyBytes((PVOID)SmartcardExtension->IoRequest.ReplyBuffer,
                     (PVOID)abDeviceDescription,sizeof(abDeviceDescription));
        *SmartcardExtension->IoRequest.Information = sizeof(abDeviceDescription);
    }

    ExitReadDeviceDescription:
    SmartcardDebug(DEBUG_TRACE,
                   ("%s!ReadDeviceDescription : Exit %lx\n",DRIVER_NAME,NTStatus));
    return NTStatus;
}



/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS CMMOB_GetFWVersion (
                            IN PSMARTCARD_EXTENSION SmartcardExtension
                            )
{
    NTSTATUS NTStatus = STATUS_SUCCESS;

    SmartcardDebug(DEBUG_TRACE,
                   ("%s!GetFWVersion : Enter\n",DRIVER_NAME));

    if (SmartcardExtension->IoRequest.ReplyBufferLength  < sizeof (ULONG)) {
        NTStatus = STATUS_BUFFER_OVERFLOW;
        *SmartcardExtension->IoRequest.Information = 0;
    } else {
        *(PULONG)(SmartcardExtension->IoRequest.ReplyBuffer) =
        SmartcardExtension->ReaderExtension->ulFWVersion;
        *SmartcardExtension->IoRequest.Information = sizeof(ULONG);
    }


    SmartcardDebug(DEBUG_TRACE,
                   ("%s!GetFWVersion : Exit %lx\n",DRIVER_NAME,NTStatus));

    return NTStatus;
}


/*****************************************************************************
CMMOB_CardTracking:
   callback handler for SMCLIB RDF_CARD_TRACKING. the requested event was
   validated by the smclib (i.e. a card removal request will only be passed
   if a card is present).
   for a win95 build STATUS_PENDING will be returned without any other action.
   for NT the cancel routine for the irp will be set to the drivers cancel
   routine.

Arguments:
   SmartcardExtension   context of call

Return Value:
   STATUS_PENDING
******************************************************************************/
NTSTATUS CMMOB_CardTracking(
                           PSMARTCARD_EXTENSION SmartcardExtension
                           )
{
    KIRQL    CurrentIrql;

    SmartcardDebug(DEBUG_TRACE,
                   ("%s!CardTracking: Enter\n",DRIVER_NAME ));

   //
   //   set cancel routine
   //
    IoAcquireCancelSpinLock( &CurrentIrql );
    IoSetCancelRoutine(SmartcardExtension->OsData->NotificationIrp,
                       CMMOB_CancelCardTracking);
    IoReleaseCancelSpinLock( CurrentIrql );

   //
   // Mark notification irp pending
   //
    IoMarkIrpPending(SmartcardExtension->OsData->NotificationIrp);

    SmartcardDebug(DEBUG_TRACE,
                   ("%s!CardTracking: Exit\n",DRIVER_NAME ));

    return( STATUS_PENDING );
}

/*****************************************************************************
CMMOB_CompleteCardTracking:
   finishes a pending tracking request if the device will be unloaded

Arguments:
   DeviceObject context of the request
   NTStatus     NTStatus to report to the calling process

Return Value:

******************************************************************************/
VOID CMMOB_CompleteCardTracking(
                               PSMARTCARD_EXTENSION SmartcardExtension
                               )
{
    KIRQL ioIrql, keIrql;
    PIRP  NotificationIrp;

    IoAcquireCancelSpinLock(&ioIrql);
    KeAcquireSpinLock(&SmartcardExtension->OsData->SpinLock,
                      &keIrql);

    NotificationIrp = SmartcardExtension->OsData->NotificationIrp;
    SmartcardExtension->OsData->NotificationIrp = NULL;

    KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                      keIrql);

    if (NotificationIrp!=NULL) {
        IoSetCancelRoutine(NotificationIrp, NULL);
    }

    IoReleaseCancelSpinLock(ioIrql);

    if (NotificationIrp!=NULL) {
      //finish the request
        if (NotificationIrp->Cancel) {
            NotificationIrp->IoStatus.Status = STATUS_CANCELLED;
        } else {
            NotificationIrp->IoStatus.Status = STATUS_SUCCESS;
        }
        NotificationIrp->IoStatus.Information = 0;

        SmartcardDebug(DEBUG_DRIVER,
                       ("%s!CompleteCardTracking: Completing Irp %lx Status=%lx\n",
                        DRIVER_NAME, NotificationIrp,NotificationIrp->IoStatus.Status));

        IoCompleteRequest(NotificationIrp, IO_NO_INCREMENT );
    }
}


/*****************************************************************************
CMMOB_CancelCardTracking
    This routine is called by the I/O system
    when the irp should be cancelled

Arguments:

    DeviceObject    - Pointer to device object for this miniport
    Irp             -    IRP involved.

Return Value:

    STATUS_CANCELLED
******************************************************************************/
NTSTATUS CMMOB_CancelCardTracking(
                                 IN PDEVICE_OBJECT DeviceObject,
                                 IN PIRP Irp
                                 )
{
    PDEVICE_EXTENSION    DeviceExtension = DeviceObject->DeviceExtension;
    PSMARTCARD_EXTENSION SmartcardExtension = &DeviceExtension->SmartcardExtension;

    SmartcardDebug(DEBUG_TRACE,
                   ("%s!CancelCardTracking: Enter\n",DRIVER_NAME));

    ASSERT(Irp == SmartcardExtension->OsData->NotificationIrp);

    IoReleaseCancelSpinLock(Irp->CancelIrql);

    CMMOB_CompleteCardTracking(SmartcardExtension);

    SmartcardDebug(DEBUG_TRACE,
                   ("%s!CancelCardTracking: Exit\n",DRIVER_NAME));

    return STATUS_CANCELLED;
}




/*****************************************************************************
CMMOB_StartCardTracking:

Arguments:
   DeviceObject         context of call

Return Value:
   STATUS_SUCCESS
   NTStatus returned by LowLevel routines
******************************************************************************/
NTSTATUS CMMOB_StartCardTracking(
                                IN PDEVICE_OBJECT DeviceObject
                                )
{
    NTSTATUS             NTStatus = STATUS_SUCCESS;
    HANDLE               hThread;
    PDEVICE_EXTENSION    DeviceExtension;
    PSMARTCARD_EXTENSION SmartcardExtension;


    DeviceExtension = DeviceObject->DeviceExtension;
    SmartcardExtension = &DeviceExtension->SmartcardExtension;

    SmartcardDebug(DEBUG_TRACE,
                   ( "%s!StartCardTracking: Enter\n",DRIVER_NAME));
    SmartcardDebug(DEBUG_DRIVER,
                   ( "%s!StartCardTracking: IRQL %i\n",DRIVER_NAME,KeGetCurrentIrql()));

    KeWaitForSingleObject(&SmartcardExtension->ReaderExtension->CardManIOMutex,
                          Executive,
                          KernelMode,
                          FALSE,
                          NULL);

   // settings for thread synchronization
    SmartcardExtension->ReaderExtension->fTerminateUpdateThread = FALSE;

   // create thread for updating current state
    NTStatus = PsCreateSystemThread(&hThread,
                                    THREAD_ALL_ACCESS,
                                    NULL,
                                    NULL,
                                    NULL,
                                    CMMOB_UpdateCurrentStateThread,
                                    DeviceObject);

    if (NT_SUCCESS(NTStatus)) {
      //
      // We've got the thread.  Now get a pointer to it.
      //
        NTStatus = ObReferenceObjectByHandle(hThread,
                                             THREAD_ALL_ACCESS,
                                             NULL,
                                             KernelMode,
                                             &SmartcardExtension->ReaderExtension->ThreadObjectPointer,
                                             NULL);

        if (NT_ERROR(NTStatus)) {

            ZwClose(hThread);
            SmartcardExtension->ReaderExtension->fTerminateUpdateThread = TRUE;
        } else {
         //
         // Now that we have a reference to the thread
         // we can simply close the handle.
         //
            ZwClose(hThread);

            SmartcardExtension->ReaderExtension->fUpdateThreadRunning = TRUE;
        }
    }


    SmartcardDebug(DEBUG_DRIVER,
                   ("%s!-----------------------------------------------------------\n",DRIVER_NAME));
    SmartcardDebug(DEBUG_DRIVER,
                   ("%s!STARTING THREAD\n",DRIVER_NAME));
    SmartcardDebug(DEBUG_DRIVER,
                   ("%s!-----------------------------------------------------------\n",DRIVER_NAME));

    KeReleaseMutex(&SmartcardExtension->ReaderExtension->CardManIOMutex,FALSE);

    SmartcardDebug(DEBUG_TRACE,
                   ( "%s!CMMOB_StartCardTracking: Exit %lx\n",DRIVER_NAME,NTStatus));

    return NTStatus;
}


/*****************************************************************************
CMMOB_StopCardTracking:

Arguments:
   DeviceObject         context of call

Return Value:
******************************************************************************/
VOID CMMOB_StopCardTracking(
                           IN PDEVICE_OBJECT DeviceObject
                           )
{
    PDEVICE_EXTENSION    DeviceExtension;
    PSMARTCARD_EXTENSION SmartcardExtension;

    SmartcardDebug(DEBUG_TRACE,
                   ( "%s!StopCardTracking: Enter\n",DRIVER_NAME));
    SmartcardDebug(DEBUG_DRIVER,
                   ( "%s!StopCardTracking: IRQL %i\n",DRIVER_NAME,KeGetCurrentIrql()));

    DeviceExtension = DeviceObject->DeviceExtension;
    SmartcardExtension = &DeviceExtension->SmartcardExtension;

    if (SmartcardExtension->ReaderExtension->fUpdateThreadRunning) {

      // kill thread
        KeWaitForSingleObject(&SmartcardExtension->ReaderExtension->CardManIOMutex,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL );

        SmartcardExtension->ReaderExtension->fTerminateUpdateThread = TRUE;

        KeReleaseMutex(&SmartcardExtension->ReaderExtension->CardManIOMutex,FALSE);


      //
      // Wait on the thread handle, when the wait is satisfied, the
      // thread has gone away.
      //
        KeWaitForSingleObject(SmartcardExtension->ReaderExtension->ThreadObjectPointer,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);

    }

    SmartcardDebug(DEBUG_TRACE,
                   ( "%s!StopCardTracking: Exit\n",DRIVER_NAME));

    return;
}

/*****************************************************************************
CMMOB_UpdateCurrentStateThread:

Arguments:
   DeviceObject         context of call

Return Value:
******************************************************************************/
VOID CMMOB_UpdateCurrentStateThread(
                                   IN PVOID Context
                                   )
{
    NTSTATUS                NTStatus = STATUS_SUCCESS;
    PDEVICE_OBJECT          DeviceObject  = Context;
    PDEVICE_EXTENSION       DeviceExtension;
    PSMARTCARD_EXTENSION    SmartcardExtension;
    ULONG                   ulInterval;


    DeviceExtension = DeviceObject->DeviceExtension;
    SmartcardExtension = &DeviceExtension->SmartcardExtension;

    KeWaitForSingleObject(&DeviceExtension->CanRunUpdateThread,
                          Executive,
                          KernelMode,
                          FALSE,
                          NULL);

    SmartcardDebug(DEBUG_DRIVER,
                   ( "%s!UpdateCurrentStateThread: started\n",DRIVER_NAME));

    while (TRUE) {
      // every 500 ms  the  NTStatus request is sent
        ulInterval = 500;
        KeWaitForSingleObject(&SmartcardExtension->ReaderExtension->CardManIOMutex,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);

        if (SmartcardExtension->ReaderExtension->fTerminateUpdateThread) {
            SmartcardDebug(DEBUG_DRIVER,
                           ("%s!-----------------------------------------------------------\n",DRIVER_NAME));
            SmartcardDebug(DEBUG_DRIVER,
                           ("%s!UpdateCurrentStateThread: STOPPING THREAD\n",DRIVER_NAME));
            SmartcardDebug(DEBUG_DRIVER,
                           ("%s!-----------------------------------------------------------\n",DRIVER_NAME));

            KeReleaseMutex(&SmartcardExtension->ReaderExtension->CardManIOMutex,FALSE);
            SmartcardExtension->ReaderExtension->fUpdateThreadRunning = FALSE;
            PsTerminateSystemThread( STATUS_SUCCESS );
        }


      //
      // get current card state
      //
        NTStatus = CMMOB_UpdateCurrentState(SmartcardExtension);
        if (NTStatus == STATUS_DEVICE_DATA_ERROR) {
            SmartcardDebug(DEBUG_DRIVER,
                           ("%s!UpdateCurrentStateThread: setting update interval to 1ms\n",DRIVER_NAME));
            ulInterval = 1;
        } else if (NTStatus != STATUS_SUCCESS &&
                   NTStatus != STATUS_NO_SUCH_DEVICE) {
            SmartcardDebug(DEBUG_DRIVER,
                           ("%s!UpdateCurrentStateThread: UpdateCurrentState failed!\n",DRIVER_NAME));
        }

        KeReleaseMutex(&SmartcardExtension->ReaderExtension->CardManIOMutex,FALSE);

        SysDelay (ulInterval);
    }

}


/*****************************************************************************
CMMOB_UpdateCurrentState:

Arguments:
   DeviceObject         context of call

Return Value:
******************************************************************************/
NTSTATUS CMMOB_UpdateCurrentState(
                                 IN PSMARTCARD_EXTENSION    SmartcardExtension
                                 )
{
    NTSTATUS                NTStatus = STATUS_SUCCESS;
    BOOL                    fCardStateChanged = FALSE;
    KIRQL                   irql;

   //
   // get card state from cardman
   //
    NTStatus = CMMOB_ResetReader(SmartcardExtension->ReaderExtension);
    if (NTStatus == STATUS_SUCCESS ||
        NTStatus == STATUS_NO_SUCH_DEVICE) {
        if (NTStatus == STATUS_SUCCESS) {
            if (CMMOB_CardInserted(SmartcardExtension->ReaderExtension)) {
                if (CMMOB_CardPowered(SmartcardExtension->ReaderExtension))
                    SmartcardExtension->ReaderExtension->ulNewCardState = POWERED;
                else
                    SmartcardExtension->ReaderExtension->ulNewCardState = INSERTED;
            } else
                SmartcardExtension->ReaderExtension->ulNewCardState = REMOVED;
        } else
            SmartcardExtension->ReaderExtension->ulNewCardState = REMOVED;

        KeAcquireSpinLock(&SmartcardExtension->OsData->SpinLock,
                          &irql);
        if (SmartcardExtension->ReaderExtension->ulNewCardState == INSERTED &&
            SmartcardExtension->ReaderExtension->ulOldCardState == POWERED ) {
         // card has been removed and reinserted
            SmartcardExtension->ReaderExtension->ulNewCardState = REMOVED;
        }

        if ((SmartcardExtension->ReaderExtension->ulNewCardState == INSERTED &&
             (SmartcardExtension->ReaderExtension->ulOldCardState == UNKNOWN ||
              SmartcardExtension->ReaderExtension->ulOldCardState == REMOVED )) ||
            (SmartcardExtension->ReaderExtension->ulNewCardState == POWERED &&
             SmartcardExtension->ReaderExtension->ulOldCardState == UNKNOWN  )) {
         // card has been inserted
            SmartcardDebug(DEBUG_DRIVER,
                           ("%s!UpdateCurrentState: smartcard inserted\n",DRIVER_NAME));
            SmartcardExtension->ReaderExtension->ulOldCardState = SmartcardExtension->ReaderExtension->ulNewCardState;
            SmartcardExtension->ReaderCapabilities.CurrentState = SCARD_SWALLOWED;
            SmartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_UNDEFINED;
            fCardStateChanged = TRUE;
        }

        if (SmartcardExtension->ReaderExtension->ulNewCardState == REMOVED &&
            (SmartcardExtension->ReaderExtension->ulOldCardState == UNKNOWN ||
             SmartcardExtension->ReaderExtension->ulOldCardState == INSERTED ||
             SmartcardExtension->ReaderExtension->ulOldCardState == POWERED )) {
         // card has been removed
            SmartcardDebug(DEBUG_DRIVER,
                           ("%s!UpdateCurrentState: smartcard removed\n",DRIVER_NAME));
            SmartcardExtension->ReaderExtension->ulOldCardState = SmartcardExtension->ReaderExtension->ulNewCardState;
            SmartcardExtension->ReaderCapabilities.CurrentState = SCARD_ABSENT;
            SmartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_UNDEFINED;
            fCardStateChanged = TRUE;

         // clear any cardspecific data
            SmartcardExtension->CardCapabilities.ATR.Length = 0;
            RtlFillMemory((PVOID)&SmartcardExtension->ReaderExtension->CardParameters,
                          sizeof(CARD_PARAMETERS), 0x00);
        }

        KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                          irql);
      // complete IOCTL_SMARTCARD_IS_ABSENT or IOCTL_SMARTCARD_IS_PRESENT
        if (fCardStateChanged == TRUE &&
            SmartcardExtension->OsData->NotificationIrp ) {
            SmartcardDebug(DEBUG_DRIVER,("%s!UpdateCurrentState: completing IRP\n",DRIVER_NAME));
            CMMOB_CompleteCardTracking(SmartcardExtension);
        }

    }

    return NTStatus;
}



/*****************************************************************************
CMMOB_ResetReader:
   Resets the reader

Arguments:
   ReaderExtension  context of the call

Return Value:
   none
******************************************************************************/
NTSTATUS CMMOB_ResetReader(
                          PREADER_EXTENSION ReaderExtension
                          )
{
    NTSTATUS    NTStatus;
    BOOLEAN     fToggle;
    UCHAR       bFlags1;

    NTStatus = CMMOB_WriteRegister(ReaderExtension,ADDR_WRITEREG_FLAGS0,CMD_RESET_SM);
    if (NTStatus != STATUS_SUCCESS)
        return NTStatus;


   // check for reader presence
    bFlags1 = ReaderExtension->bPreviousFlags1;
    bFlags1 |= FLAG_CHECK_PRESENCE;
    NTStatus = CMMOB_WriteRegister(ReaderExtension, ADDR_WRITEREG_FLAGS1, bFlags1);
   // don't check for status because
   // we have to set back fCheckPresence for proper working
    fToggle = CMMOB_GetReceiveFlag(ReaderExtension);
    bFlags1 = ReaderExtension->bPreviousFlags1;
    NTStatus = CMMOB_WriteRegister(ReaderExtension, ADDR_WRITEREG_FLAGS1, bFlags1);
    if (NTStatus != STATUS_SUCCESS)
        return NTStatus;
    if (fToggle == CMMOB_GetReceiveFlag(ReaderExtension)) {
        SmartcardDebug(DEBUG_DRIVER,
                       ("%s!ResetReader: CardMan Mobile removed!\n",DRIVER_NAME));
        return STATUS_NO_SUCH_DEVICE;
    }


    return NTStatus;
}



/*****************************************************************************
CMMOB_BytesReceived:
   Reads how many bytes are already received from the card by the reader

Arguments:
   ReaderExtension  context of the call

Return Value:
   NTStatus
******************************************************************************/
NTSTATUS CMMOB_BytesReceived(
                            PREADER_EXTENSION ReaderExtension,
                            PULONG pulBytesReceived
                            )
{
    NTSTATUS          NTStatus = STATUS_SUCCESS;
    ULONG             ulBytesReceived;
    ULONG             ulBytesReceivedCheck;
    UCHAR             bReg;

   /*
   SmartcardDebug(DEBUG_TRACE,
                  ( "%s!BytesReceived Enter\n",DRIVER_NAME));
   */
    *pulBytesReceived=0;
    if (CMMOB_GetReceiveFlag(ReaderExtension) ||
        ReaderExtension->CardParameters.fT0Mode) {
        do {
            NTStatus=CMMOB_ReadRegister(ReaderExtension,ADDR_READREG_BYTES_RECEIVED,&bReg);
            if (NTStatus!=STATUS_SUCCESS)
                return NTStatus;
            ulBytesReceived=bReg;
            NTStatus=CMMOB_ReadRegister(ReaderExtension,ADDR_READREG_FLAGS0,&bReg);
            if (NTStatus!=STATUS_SUCCESS)
                return NTStatus;
            if ((bReg & FLAG_BYTES_RECEIVED_B9) == FLAG_BYTES_RECEIVED_B9) {
                ulBytesReceived+=0x100;
            }

            NTStatus=CMMOB_ReadRegister(ReaderExtension,ADDR_READREG_BYTES_RECEIVED,&bReg);
            if (NTStatus!=STATUS_SUCCESS)
                return NTStatus;
            ulBytesReceivedCheck=bReg;
            NTStatus=CMMOB_ReadRegister(ReaderExtension,ADDR_READREG_FLAGS0,&bReg);
            if (NTStatus!=STATUS_SUCCESS)
                return NTStatus;
            if ((bReg & FLAG_BYTES_RECEIVED_B9) == FLAG_BYTES_RECEIVED_B9) {
                ulBytesReceivedCheck+=0x100;
            }
        }
        while (ulBytesReceived!=ulBytesReceivedCheck);
        *pulBytesReceived=ulBytesReceived;
    }
   /*
   SmartcardDebug(DEBUG_TRACE,
                  ( "%s!BytesReceived Exit\n",DRIVER_NAME));
   */
    return NTStatus;
}


/*****************************************************************************
CMMOB_SetFlags1:
   Sets register Flags1

Arguments:
   ReaderExtension  context of the call

Return Value:
   none
******************************************************************************/
NTSTATUS CMMOB_SetFlags1 (
                         PREADER_EXTENSION ReaderExtension
                         )
{
    NTSTATUS NTStatus = STATUS_SUCCESS;
    UCHAR    bFlags1;

    bFlags1 = ReaderExtension->CardParameters.bBaudRateHigh;
    if (ReaderExtension->CardParameters.fInversRevers)
        bFlags1 |= FLAG_INVERS_PARITY;
    if (ReaderExtension->CardParameters.bClockFrequency==8)
        bFlags1 |= FLAG_CLOCK_8MHZ;
    if (ReaderExtension->CardParameters.fT0Write)
        bFlags1 |= FLAG_T0_WRITE;

    if (ReaderExtension->bAddressHigh == 1)
        bFlags1 |= FLAG_BUFFER_ADDR_B9;
    if (ReaderExtension->fTActive)
        bFlags1 |= FLAG_TACTIVE;
    if (ReaderExtension->fReadCIS)
        bFlags1 |= FLAG_READ_CIS;

    ReaderExtension->bPreviousFlags1=bFlags1;
    NTStatus = CMMOB_WriteRegister(ReaderExtension, ADDR_WRITEREG_FLAGS1, bFlags1);
    return NTStatus;
}



/*****************************************************************************
CMMOB_SetCardParameters:
   Sets card parameters (baudrate, stopbits)

Arguments:
   ReaderExtension  context of the call

Return Value:
   none
******************************************************************************/
NTSTATUS CMMOB_SetCardParameters (
                                 PREADER_EXTENSION ReaderExtension
                                 )
{
    NTSTATUS NTStatus = STATUS_SUCCESS;

    NTStatus = CMMOB_SetFlags1 (ReaderExtension);
    if (NTStatus!=STATUS_SUCCESS)
        return NTStatus;

    NTStatus = CMMOB_WriteRegister(ReaderExtension, ADDR_WRITEREG_BAUDRATE,
                                   ReaderExtension->CardParameters.bBaudRateLow);
    if (NTStatus!=STATUS_SUCCESS)
        return NTStatus;

    NTStatus = CMMOB_WriteRegister(ReaderExtension, ADDR_WRITEREG_STOPBITS,
                                   ReaderExtension->CardParameters.bStopBits);
    return NTStatus;
}


/*****************************************************************************
CMMOB_CardInserted:
   Sets card parameters (baudrate, stopbits)

Arguments:
   ReaderExtension  context of the call

Return Value:
   TRUE if card is inserted
******************************************************************************/
BOOLEAN CMMOB_CardInserted(
                          IN PREADER_EXTENSION ReaderExtension
                          )
{
    NTSTATUS NTStatus=STATUS_SUCCESS;
    UCHAR    bReg;

    NTStatus=CMMOB_ReadRegister(ReaderExtension,ADDR_READREG_FLAGS0,&bReg);
    if (NTStatus!=STATUS_SUCCESS)
        return FALSE;
   /*
   SmartcardDebug(DEBUG_TRACE,
                  ("%s!CardInserted: ReadReg Flags0 = %x\n",DRIVER_NAME, (ULONG)bReg));
   */
    if ((bReg & FLAG_INSERTED)==FLAG_INSERTED) {
        return TRUE;
    }
    return FALSE;
}

/*****************************************************************************
CMMOB_CardPowered:
   Sets card parameters (baudrate, stopbits)

Arguments:
   ReaderExtension  context of the call

Return Value:
   TRUE if card is powered
******************************************************************************/
BOOLEAN CMMOB_CardPowered(
                         IN PREADER_EXTENSION ReaderExtension
                         )
{
    NTSTATUS NTStatus=STATUS_SUCCESS;
    UCHAR    bReg;

    NTStatus=CMMOB_ReadRegister(ReaderExtension,ADDR_READREG_FLAGS0,&bReg);
    if (NTStatus!=STATUS_SUCCESS)
        return FALSE;
    if ((bReg & FLAG_POWERED)==FLAG_POWERED) {
        return TRUE;
    }
    return FALSE;
}


/*****************************************************************************
CMMOB_ProcedureReceived:

Arguments:
   ReaderExtension  context of the call

Return Value:
   TRUE if a procedure byte has been received
******************************************************************************/
BOOLEAN CMMOB_ProcedureReceived(
                               IN PREADER_EXTENSION ReaderExtension
                               )
{
    NTSTATUS NTStatus=STATUS_SUCCESS;
    UCHAR    bReg;

    NTStatus=CMMOB_ReadRegister(ReaderExtension,ADDR_READREG_FLAGS1,&bReg);
    if (NTStatus!=STATUS_SUCCESS)
        return FALSE;
    if ((bReg & FLAG_NOPROCEDURE_RECEIVED)!=FLAG_NOPROCEDURE_RECEIVED) {
        return TRUE;
    }
    return FALSE;
}

/*****************************************************************************
CMMOB_GetReceiveFlag:

Arguments:
   ReaderExtension  context of the call

Return Value:
   TRUE if a receive flag is set
******************************************************************************/
BOOLEAN CMMOB_GetReceiveFlag(
                            IN PREADER_EXTENSION ReaderExtension
                            )
{
    NTSTATUS NTStatus=STATUS_SUCCESS;
    UCHAR    bReg;

    NTStatus=CMMOB_ReadRegister(ReaderExtension,ADDR_READREG_FLAGS0,&bReg);
   /*
   SmartcardDebug(DEBUG_TRACE,
                  ("%s!GetReceiveFlag: ReadReg Flags0 = %x\n",DRIVER_NAME, (ULONG)bReg));
   */
    if (NTStatus!=STATUS_SUCCESS)
        return FALSE;
    if ((bReg & FLAG_RECEIVE)==FLAG_RECEIVE) {
        return TRUE;
    }
    return FALSE;
}

/*****************************************************************************
CMMOB_GetProcedureByte:
   Reads how many bytes are already received from the card by the reader

Arguments:
   ReaderExtension  context of the call

Return Value:
   NTStatus
******************************************************************************/
NTSTATUS CMMOB_GetProcedureByte(
                               IN PREADER_EXTENSION ReaderExtension,
                               OUT PUCHAR pbProcedureByte
                               )
{
    NTSTATUS          NTStatus = STATUS_SUCCESS;
    UCHAR             bReg;
    UCHAR             bRegPrevious;

    do {
        NTStatus=CMMOB_ReadRegister(ReaderExtension,ADDR_READREG_LASTPROCEDURE_T0,&bRegPrevious);
        if (NTStatus!=STATUS_SUCCESS)
            return NTStatus;
        NTStatus=CMMOB_ReadRegister(ReaderExtension,ADDR_READREG_LASTPROCEDURE_T0,&bReg);
        if (NTStatus!=STATUS_SUCCESS)
            return NTStatus;
    }
    while (bReg!=bRegPrevious);
    *pbProcedureByte=bReg;
    return NTStatus;
}

/*****************************************************************************
CMMOB_WriteT0:
   Writes T0 request to card

Arguments:
   ReaderExtension  context of the call

Return Value:
   NT STATUS
******************************************************************************/
NTSTATUS CMMOB_WriteT0(
                      IN PREADER_EXTENSION ReaderExtension,
                      IN ULONG ulBytesToWrite,
                      IN ULONG ulBytesToReceive,
                      IN PUCHAR pbData
                      )
{
    NTSTATUS       NTStatus = STATUS_SUCCESS;
    UCHAR          bFlags0;
    UCHAR          bReg;

    if (ulBytesToWrite > CMMOB_MAXBUFFER) {
        NTStatus = STATUS_BUFFER_OVERFLOW;
        return NTStatus;
    }
   // dummy read, to reset flag procedure received
    NTStatus=CMMOB_ReadRegister(ReaderExtension,ADDR_READREG_FLAGS1,&bReg);

    NTStatus = CMMOB_WriteBuffer(ReaderExtension,ulBytesToWrite,pbData);
    if (NTStatus != STATUS_SUCCESS)
        return NTStatus;

   // write instruction byte to register
    NTStatus = CMMOB_WriteRegister(ReaderExtension,ADDR_WRITEREG_PROCEDURE_T0,pbData[1]);
    if (NTStatus != STATUS_SUCCESS)
        return NTStatus;

   // write message length
    NTStatus = CMMOB_WriteRegister(ReaderExtension,ADDR_WRITEREG_MESSAGE_LENGTH,
                                   (UCHAR)((ulBytesToWrite+ulBytesToReceive) & 0xFF));
    if (NTStatus != STATUS_SUCCESS)
        return NTStatus;
    if ((ulBytesToWrite+ulBytesToReceive) > 0xFF) {
        bFlags0=1;
    } else {
        bFlags0=0;
    }
    bFlags0 |= CMD_WRITE_T0;
    NTStatus = CMMOB_WriteRegister(ReaderExtension,ADDR_WRITEREG_FLAGS0,bFlags0);
    return NTStatus;
}



/*****************************************************************************
CMMOB_WriteT1:
   Writes T1 request to card

Arguments:
   ReaderExtension  context of the call

Return Value:
   NT STATUS
******************************************************************************/
NTSTATUS CMMOB_WriteT1(
                      IN PREADER_EXTENSION ReaderExtension,
                      IN ULONG ulBytesToWrite,
                      IN PUCHAR pbData
                      )
{
    NTSTATUS       NTStatus = STATUS_SUCCESS;
    UCHAR          bFlags0;

    if (ulBytesToWrite > CMMOB_MAXBUFFER) {
        NTStatus = STATUS_BUFFER_OVERFLOW;
        return NTStatus;
    }
    NTStatus = CMMOB_WriteBuffer(ReaderExtension,ulBytesToWrite,pbData);
    if (NTStatus != STATUS_SUCCESS)
        return NTStatus;
    NTStatus = CMMOB_WriteRegister(ReaderExtension,ADDR_WRITEREG_MESSAGE_LENGTH,
                                   (UCHAR)(ulBytesToWrite & 0xFF));
    if (NTStatus != STATUS_SUCCESS)
        return NTStatus;
    if (ulBytesToWrite > 0xFF) {
        bFlags0=1;
    } else {
        bFlags0=0;
    }
    bFlags0 |= CMD_WRITE_T1;
    NTStatus = CMMOB_WriteRegister(ReaderExtension,ADDR_WRITEREG_FLAGS0,bFlags0);
    return NTStatus;
}



/*****************************************************************************
CMMOB_ReadT0:
   Reads T0 reply from card

Arguments:
   ReaderExtension  context of the call

Return Value:
   NT STATUS
******************************************************************************/
NTSTATUS CMMOB_ReadT0(
                     IN PREADER_EXTENSION ReaderExtension,
                     IN ULONG ulBytesToRead,
                     IN ULONG ulBytesSent,
                     IN ULONG ulCWT,
                     OUT PUCHAR pbData,
                     OUT PULONG pulBytesRead,
                     OUT PBOOLEAN pfDataSent
                     )
{
    NTSTATUS             NTStatus = STATUS_SUCCESS;
    KTIMER               TimerWait;
    ULONG                ulBytesReceived;
    ULONG                ulBytesReceivedPrevious;
    LARGE_INTEGER        liWaitTime;
    BOOLEAN              fTimeExpired;
    BOOLEAN              fProcedureReceived;
    BOOLEAN              fTransmissionFinished;
    UCHAR                bProcedureByte=0;


    SmartcardDebug(DEBUG_TRACE,
                   ("%s!ReadT0: Enter BytesToRead = %li\n",DRIVER_NAME,ulBytesToRead));

   //initialize Timer
    KeInitializeTimer(&TimerWait);
    liWaitTime = RtlConvertLongToLargeInteger(ulCWT * -10000L);

    *pulBytesRead = 0;
    *pfDataSent = FALSE;

    do {
        KeSetTimer(&TimerWait,liWaitTime,NULL);
        NTStatus=CMMOB_BytesReceived (ReaderExtension,&ulBytesReceivedPrevious);
        if (NTStatus!=STATUS_SUCCESS)
            goto ExitReadT0;
        do {
            fTimeExpired = KeReadStateTimer(&TimerWait);
            fTransmissionFinished=CMMOB_GetReceiveFlag(ReaderExtension);
            fProcedureReceived=CMMOB_ProcedureReceived(ReaderExtension);
            NTStatus=CMMOB_BytesReceived (ReaderExtension,&ulBytesReceived);
            if (NTStatus!=STATUS_SUCCESS)
                goto ExitReadT0;
         // wait 1 ms, so that processor is not blocked
            SysDelay(1);
        }
        while (fTimeExpired==FALSE &&
               fProcedureReceived==FALSE &&
               ulBytesReceivedPrevious == ulBytesReceived &&
               fTransmissionFinished==FALSE);

        if (fProcedureReceived) {
            NTStatus=CMMOB_GetProcedureByte (ReaderExtension,&bProcedureByte);
            if (NTStatus!=STATUS_SUCCESS)
                goto ExitReadT0;
         // check for SW1
            if (ReaderExtension->CardParameters.fInversRevers) {
                CMMOB_InverseBuffer(&bProcedureByte,1);
            }
        }

        if (!fTimeExpired) {
            KeCancelTimer(&TimerWait);
        }
#ifdef DBG
        else {
            SmartcardDebug(DEBUG_PROTOCOL,( "%s!----------------------------------------------\n",DRIVER_NAME));
            SmartcardDebug(DEBUG_PROTOCOL,( "%s!Read T0 timed out\n",DRIVER_NAME));
            SmartcardDebug(DEBUG_PROTOCOL,( "%s!----------------------------------------------\n",DRIVER_NAME));
        }
#endif

    }
    while (fTimeExpired==FALSE &&
           fTransmissionFinished==FALSE);

   // read once more ulBytesReceived
   // this value could have changed in the meantime
    NTStatus=CMMOB_BytesReceived (ReaderExtension,&ulBytesReceived);
    if (NTStatus!=STATUS_SUCCESS)
        goto ExitReadT0;

    SmartcardDebug(DEBUG_PROTOCOL,
                   ("%s!ReadT0: BytesReceived = %li\n",DRIVER_NAME,ulBytesReceived));

   //now we should have received a reply
    NTStatus=CMMOB_ResetReader (ReaderExtension);
    if (NTStatus!=STATUS_SUCCESS)
        goto ExitReadT0;

   // check for valid SW1
    if ((bProcedureByte > 0x60 && bProcedureByte <= 0x6F) ||
        (bProcedureByte >= 0x90 && bProcedureByte <= 0x9F)) {
        if (ReaderExtension->CardParameters.fInversRevers) {
            CMMOB_InverseBuffer(&bProcedureByte,1);
        }
        if (ulBytesReceived > ulBytesSent) {

            if (ulBytesReceived - ulBytesSent > MIN_BUFFER_SIZE) {
                NTStatus = STATUS_BUFFER_OVERFLOW;
                goto ExitReadT0;
            }
            NTStatus=CMMOB_ReadBuffer(ReaderExtension, ulBytesSent,
                                      ulBytesReceived-ulBytesSent, pbData);
            if (NTStatus==STATUS_SUCCESS) {
            // we have to insert the procedure byte (SW1)
                pbData[ulBytesReceived-ulBytesSent]=pbData[ulBytesReceived-ulBytesSent-1];
                pbData[ulBytesReceived-ulBytesSent-1]=bProcedureByte;
                *pulBytesRead=ulBytesReceived-ulBytesSent+1;
            }

            if (ulBytesSent > T0_HEADER_LEN) {
                *pfDataSent = TRUE;
            }
        } else {
            if (ulBytesReceived > T0_HEADER_LEN) {
            // it seems not all bytes were accepted by the card
            // but we got SW1 SW2 - return only SW1 SW2
                pbData[0]=bProcedureByte;
                NTStatus=CMMOB_ReadBuffer(ReaderExtension, ulBytesReceived-1,
                                          1, &pbData[1]);
                *pulBytesRead=2;
            } else {
                NTStatus = STATUS_IO_TIMEOUT;
            }
        }
    } else {
        NTStatus = STATUS_IO_TIMEOUT;
    }

    ExitReadT0:

    SmartcardDebug(DEBUG_TRACE,
                   ("%s!ReadT0: Exit\n",DRIVER_NAME ));

    return NTStatus;
}

/*****************************************************************************
CMMOB_ReadT1:
   Reads T1 reply from card

Arguments:
   ReaderExtension  context of the call

Return Value:
   NT STATUS
******************************************************************************/
NTSTATUS CMMOB_ReadT1(
                     IN PREADER_EXTENSION ReaderExtension,
                     IN LONG lBytesToRead,
                     IN ULONG ulBWT,
                     IN ULONG ulCWT,
                     OUT PUCHAR pbData,
                     OUT PULONG pulBytesRead
                     )
// a negative value of ulBytesToRead indicates a relative number of bytes to read
{
    NTSTATUS             NTStatus = STATUS_SUCCESS;
    KTIMER               TimerWait;
    ULONG                ulBytesReceived;
    LARGE_INTEGER        liWaitTime;
    BOOLEAN              fTimeExpired;
    ULONG                ulBytesReceivedPrevious;

   /*
   SmartcardDebug(DEBUG_TRACE,
                  ("%s!ReadT1: Enter\n",DRIVER_NAME ));
   */

   //initialize Timer
    KeInitializeTimer(&TimerWait);

    *pulBytesRead = 0;
   // first wait BWT (block waiting time)
    liWaitTime = RtlConvertLongToLargeInteger(ulBWT * -10000L);
    do {
        KeSetTimer(&TimerWait,liWaitTime,NULL);
        NTStatus=CMMOB_BytesReceived (ReaderExtension,&ulBytesReceivedPrevious);
        if (NTStatus!=STATUS_SUCCESS)
            goto ExitReadT1;
        do {
            fTimeExpired = KeReadStateTimer(&TimerWait);
            NTStatus=CMMOB_BytesReceived (ReaderExtension,&ulBytesReceived);
            if (NTStatus!=STATUS_SUCCESS)
                goto ExitReadT1;
         // wait 1 ms, so that processor is not blocked
            SysDelay(1);

         // make an adjustment of lBytesToRead (only one time)
            if (lBytesToRead<= 0 && ulBytesReceived >= 3) {
            // get number of bytes to receive from reader
                UCHAR bReg;
                UCHAR bRegPrevious;
                lBytesToRead = -lBytesToRead;
                do {
                    NTStatus=CMMOB_ReadRegister(ReaderExtension,ADDR_READREG_BYTESTORECEIVE_T1,&bRegPrevious);
                    if (NTStatus!=STATUS_SUCCESS)
                        goto ExitReadT1;
                    NTStatus=CMMOB_ReadRegister(ReaderExtension,ADDR_READREG_BYTESTORECEIVE_T1,&bReg);
                    if (NTStatus!=STATUS_SUCCESS)
                        goto ExitReadT1;
                }
                while (bReg!=bRegPrevious);
                lBytesToRead += bReg;
            }
        }
        while (fTimeExpired==FALSE &&
               ulBytesReceivedPrevious == ulBytesReceived &&
               (lBytesToRead<=0 || ulBytesReceived!=(ULONG)lBytesToRead));

        if (!fTimeExpired) {
            KeCancelTimer(&TimerWait);
            liWaitTime = RtlConvertLongToLargeInteger(ulCWT * -10000L);
         // now wait only CWT (character waiting time)
        }
#ifdef DBG
        else {
            SmartcardDebug(DEBUG_PROTOCOL,( "%s!----------------------------------------------\n",DRIVER_NAME));
            SmartcardDebug(DEBUG_PROTOCOL,( "%s!Read T1 timed out\n",DRIVER_NAME));
            SmartcardDebug(DEBUG_PROTOCOL,( "%s!----------------------------------------------\n",DRIVER_NAME));
        }
#endif
    }
    while (!fTimeExpired &&
           (lBytesToRead<=0 || ulBytesReceived!=(ULONG)lBytesToRead));



   //now we should have received a reply
    NTStatus=CMMOB_ResetReader (ReaderExtension);
    if (NTStatus!=STATUS_SUCCESS)
        goto ExitReadT1;

    if (ulBytesReceived > CMMOB_MAXBUFFER) {

        NTStatus = STATUS_BUFFER_OVERFLOW;

    }
    if (ulBytesReceived==(ULONG)lBytesToRead && lBytesToRead > 0) {
        NTStatus=CMMOB_ReadBuffer(ReaderExtension, 0, (ULONG)lBytesToRead, pbData);
        if (NTStatus==STATUS_SUCCESS) {
            *pulBytesRead=(ULONG)lBytesToRead;
        }
    } else {
        NTStatus=CMMOB_ReadBuffer(ReaderExtension, 0, ulBytesReceived, pbData);
        if (NTStatus==STATUS_SUCCESS) {
            *pulBytesRead=ulBytesReceived;
        }
        NTStatus = STATUS_IO_TIMEOUT;
    }

    ExitReadT1:

   /*
   SmartcardDebug(DEBUG_TRACE,
                  ("%s!ReadT1: Exit\n",DRIVER_NAME ));
   */
    return NTStatus;
}

/*****************************************************************************
CMMOB_ReadRegister:
   Sets card parameters (baudrate, stopbits)

Arguments:
   ReaderExtension  context of the call

Return Value:
   NT STATUS
******************************************************************************/
NTSTATUS CMMOB_ReadRegister(
                           IN PREADER_EXTENSION ReaderExtension,
                           IN USHORT usAddress,
                           OUT PUCHAR pbData
                           )
{
    *pbData = READ_PORT_UCHAR(ReaderExtension->pbRegsBase+usAddress);

    return STATUS_SUCCESS;
}


/*****************************************************************************
CMMOB_WriteRegister:
   Sets card parameters (baudrate, stopbits)

Arguments:
   ReaderExtension  context of the call

Return Value:
   NT STATUS
******************************************************************************/
NTSTATUS CMMOB_WriteRegister(
                            IN PREADER_EXTENSION ReaderExtension,
                            IN USHORT usAddress,
                            IN UCHAR bData
                            )
{

    WRITE_PORT_UCHAR(ReaderExtension->pbRegsBase+usAddress,bData);

    return STATUS_SUCCESS;
}


/*****************************************************************************
CMMOB_ReadBuffer:
   Sets card parameters (baudrate, stopbits)

Arguments:
   ReaderExtension  context of the call

Return Value:
   NT STATUS
******************************************************************************/
NTSTATUS CMMOB_ReadBuffer(
                         IN PREADER_EXTENSION ReaderExtension,
                         IN ULONG ulOffset,
                         IN ULONG ulLength,
                         OUT PUCHAR pbData
                         )
{
    NTSTATUS NTStatus = STATUS_SUCCESS;
    ULONG    i;


    if ((ulOffset & 0x100) == 0x100) {
        ReaderExtension->bAddressHigh=1;
    } else {
        ReaderExtension->bAddressHigh=0;
    }
    NTStatus = CMMOB_SetFlags1(ReaderExtension);
    if (NTStatus!=STATUS_SUCCESS) {
        goto ExitReadBuffer;
    }


    for (i=0; i<ulLength; i++) {
        WRITE_PORT_UCHAR(ReaderExtension->pbRegsBase+ADDR_WRITEREG_BUFFER_ADDR,
                         (BYTE)((ulOffset+i)&0xFF));
      // because we are counting up in a loop we have to set
      // bit 9 of address only once
        if (ulOffset+i == 0x100) {
            ReaderExtension->bAddressHigh=1;
            NTStatus = CMMOB_SetFlags1(ReaderExtension);
            if (NTStatus!=STATUS_SUCCESS) {
                goto ExitReadBuffer;
            }
        }
        *(pbData+i)=READ_PORT_UCHAR(ReaderExtension->pbRegsBase+ADDR_WRITEREG_BUFFER_DATA);
      // erase buffer - required for certification
        WRITE_PORT_UCHAR(ReaderExtension->pbRegsBase+ADDR_WRITEREG_BUFFER_DATA,0);

    }
    ExitReadBuffer:
    return NTStatus;
}


/*****************************************************************************
CMMOB_WriteBuffer:
   Sets card parameters (baudrate, stopbits)

Arguments:
   ReaderExtension  context of the call

Return Value:
   NT STATUS
******************************************************************************/
NTSTATUS CMMOB_WriteBuffer(
                          IN PREADER_EXTENSION ReaderExtension,
                          IN ULONG ulLength,
                          IN PUCHAR pbData
                          )
{
    NTSTATUS NTStatus = STATUS_SUCCESS;
    ULONG    i;


    ReaderExtension->bAddressHigh=0;
    NTStatus = CMMOB_SetFlags1(ReaderExtension);
    if (NTStatus!=STATUS_SUCCESS) {
        goto ExitWriteBuffer;
    }

    for (i=0; i<ulLength; i++) {
        WRITE_PORT_UCHAR(ReaderExtension->pbRegsBase+ADDR_WRITEREG_BUFFER_ADDR,
                         (BYTE)(i & 0xFF));
      // because we are counting up in a loop we have to set
      // bit 9 of address only once
        if (i == 0x100) {
            ReaderExtension->bAddressHigh=1;
            NTStatus = CMMOB_SetFlags1(ReaderExtension);
            if (NTStatus!=STATUS_SUCCESS) {
                goto ExitWriteBuffer;
            }
        }
        WRITE_PORT_UCHAR(ReaderExtension->pbRegsBase+ADDR_WRITEREG_BUFFER_DATA,*(pbData+i));

    }

    ExitWriteBuffer:
    return NTStatus;
}


/*****************************************************************************
Routine Description:
This routine inverts the buffer
Bit0 -> Bit 7
Bit1 -> Bit 6
Bit2 -> Bit 5
Bit3 -> Bit 4
Bit4 -> Bit 3
Bit5 -> Bit 2
Bit6 -> Bit 1
Bit7 -> Bit 0


Arguments: pbBuffer     ... pointer to buffer
           ulBufferSize ... size of buffer


Return Value: none

*****************************************************************************/
VOID CMMOB_InverseBuffer (
                         PUCHAR pbBuffer,
                         ULONG  ulBufferSize
                         )
{
    ULONG i,j;
    UCHAR bRevers;
    UCHAR bTemp;

    for (i=0; i<ulBufferSize; i++) {
        bRevers = 0;
        for (j=0; j<8; j++) {
            bTemp = pbBuffer[i] << j;
            bTemp &= 0x80;
            bRevers |= bTemp >> (7-j);
        }
        pbBuffer[i] = ~bRevers;
    }

    return;
}


/*****************************************************************************
* History:
* $Log: cmbp0scr.c $
* Revision 1.7  2001/01/22 07:12:36  WFrischauf
* No comment given
*
* Revision 1.6  2000/09/25 14:24:31  WFrischauf
* No comment given
*
* Revision 1.5  2000/08/24 09:05:13  TBruendl
* No comment given
*
* Revision 1.4  2000/08/09 12:45:57  WFrischauf
* No comment given
*
* Revision 1.3  2000/07/27 13:53:03  WFrischauf
* No comment given
*
*
******************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\cmbp0\makefile.inc ===
cmbp0log.h cmbp0log.rc msg00001.bin: cmbp0log.mc
    mc cmbp0log.mc

cmbp0.rc: cmbp0log.rc

cmbp0log.rc: msg00001.bin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\cmbp0\cmbp0wdm.c ===
/*****************************************************************************
@doc            INT EXT
******************************************************************************
* $ProjectName:  $
* $ProjectRevision:  $
*-----------------------------------------------------------------------------
* $Source: z:/pr/cmbp0/sw/cmbp0.ms/rcs/cmbp0wdm.c $
* $Revision: 1.11 $
*-----------------------------------------------------------------------------
* $Author: WFrischauf $
*-----------------------------------------------------------------------------
* History: see EOF
*-----------------------------------------------------------------------------
*
* Copyright  2000 OMNIKEY AG
******************************************************************************/

#include <cmbp0wdm.h>
#include <cmbp0pnp.h>
#include <cmbp0scr.h>
#include <cmbp0log.h>

BOOLEAN DeviceSlot[CMMOB_MAX_DEVICE];

// this is a list of our supported data rates
ULONG SupportedDataRates[] = { 9600, 19200, 38400, 76800, 115200,
    153600, 192000, 307200};

// this is a list of our supported clock frequencies
ULONG SupportedCLKFrequencies[] = { 4000, 8000};


/*****************************************************************************
DriverEntry:
   entry function of the driver. setup the callbacks for the OS and try to
   initialize a device object for every device in the system

Arguments:
   DriverObject context of the driver
   RegistryPath path to the registry entry for the driver

Return Value:
   STATUS_SUCCESS
   STATUS_UNSUCCESSFUL
******************************************************************************/
NTSTATUS DriverEntry(
                    PDRIVER_OBJECT DriverObject,
                    PUNICODE_STRING RegistryPath
                    )
{
    NTSTATUS NTStatus = STATUS_SUCCESS;
    ULONG    ulDevice;


//#if DBG
//   SmartcardSetDebugLevel(DEBUG_ALL);
//#endif

    SmartcardDebug(DEBUG_TRACE,
                   ("%s!DriverEntry: Enter - %s %s\n",DRIVER_NAME,__DATE__,__TIME__));

   //
   //   tell the system our entry points
   //
    DriverObject->MajorFunction[IRP_MJ_CREATE]         = CMMOB_CreateClose;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]          = CMMOB_CreateClose;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = CMMOB_DeviceIoControl;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = CMMOB_SystemControl;
    DriverObject->MajorFunction[IRP_MJ_CLEANUP]        = CMMOB_Cleanup;
    DriverObject->DriverUnload                         = CMMOB_UnloadDriver;


    DriverObject->MajorFunction[IRP_MJ_PNP]            = CMMOB_PnPDeviceControl;
    DriverObject->MajorFunction[IRP_MJ_POWER]          = CMMOB_PowerDeviceControl;
    DriverObject->DriverExtension->AddDevice           = CMMOB_AddDevice;

    SmartcardDebug(DEBUG_TRACE,
                   ("%s!DriverEntry: PnP Version\n",DRIVER_NAME));


    SmartcardDebug(DEBUG_TRACE,
                   ("%s!DriverEntry: Exit %x\n",DRIVER_NAME,NTStatus));

    return NTStatus;
}


/*****************************************************************************
Routine Description:
   Trys to read the reader name from the registry

Arguments:
   DriverObject context of call
   SmartcardExtension   ptr to smartcard extension

Return Value:
   none

******************************************************************************/
VOID CMMOB_SetVendorAndIfdName(
                              IN  PDEVICE_OBJECT PhysicalDeviceObject,
                              IN  PSMARTCARD_EXTENSION SmartcardExtension
                              )
{

    RTL_QUERY_REGISTRY_TABLE   parameters[3];
    UNICODE_STRING             vendorNameU;
    ANSI_STRING                vendorNameA;
    UNICODE_STRING             ifdTypeU;
    ANSI_STRING                ifdTypeA;
    HANDLE                     regKey = NULL;

    RtlZeroMemory (parameters, sizeof(parameters));
    RtlZeroMemory (&vendorNameU, sizeof(vendorNameU));
    RtlZeroMemory (&vendorNameA, sizeof(vendorNameA));
    RtlZeroMemory (&ifdTypeU, sizeof(ifdTypeU));
    RtlZeroMemory (&ifdTypeA, sizeof(ifdTypeA));

    try {
      //
      // try to read the reader name from the registry
      // if that does not work, we will use the default
      // (hardcoded) name
      //
        if (IoOpenDeviceRegistryKey(PhysicalDeviceObject,
                                    PLUGPLAY_REGKEY_DEVICE,
                                    KEY_READ,
                                    &regKey) != STATUS_SUCCESS) {
            SmartcardDebug(DEBUG_ERROR,
                           ("%s!SetVendorAndIfdName: IoOpenDeviceRegistryKey failed\n",DRIVER_NAME));
            leave;
        }

        parameters[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[0].Name = L"VendorName";
        parameters[0].EntryContext = &vendorNameU;
        parameters[0].DefaultType = REG_SZ;
        parameters[0].DefaultData = &vendorNameU;
        parameters[0].DefaultLength = 0;

        parameters[1].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[1].Name = L"IfdType";
        parameters[1].EntryContext = &ifdTypeU;
        parameters[1].DefaultType = REG_SZ;
        parameters[1].DefaultData = &ifdTypeU;
        parameters[1].DefaultLength = 0;

        if (RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                                   (PWSTR) regKey,
                                   parameters,
                                   NULL,
                                   NULL) != STATUS_SUCCESS) {
            SmartcardDebug(DEBUG_ERROR,
                           ("%s!SetVendorAndIfdName: RtlQueryRegistryValues failed\n",DRIVER_NAME));
            leave;
        }

        if (RtlUnicodeStringToAnsiString(&vendorNameA,&vendorNameU,TRUE) != STATUS_SUCCESS) {
            SmartcardDebug(DEBUG_ERROR,
                           ("%s!SetVendorAndIfdName: RtlUnicodeStringToAnsiString failed\n",DRIVER_NAME));
            leave;
        }

        if (RtlUnicodeStringToAnsiString(&ifdTypeA,&ifdTypeU,TRUE) != STATUS_SUCCESS) {
            SmartcardDebug(DEBUG_ERROR,
                           ("%s!SetVendorAndIfdName: RtlUnicodeStringToAnsiString failed\n",DRIVER_NAME));
            leave;
        }

        if (vendorNameA.Length == 0 ||
            vendorNameA.Length > MAXIMUM_ATTR_STRING_LENGTH ||
            ifdTypeA.Length == 0 ||
            ifdTypeA.Length > MAXIMUM_ATTR_STRING_LENGTH) {
            SmartcardDebug(DEBUG_ERROR,
                           ("%s!SetVendorAndIfdName: vendor name or ifdtype not found or to long\n",DRIVER_NAME));
            leave;
        }

        RtlCopyMemory(SmartcardExtension->VendorAttr.VendorName.Buffer,
                      vendorNameA.Buffer,
                      vendorNameA.Length);
        SmartcardExtension->VendorAttr.VendorName.Length = vendorNameA.Length;

        RtlCopyMemory(SmartcardExtension->VendorAttr.IfdType.Buffer,
                      ifdTypeA.Buffer,
                      ifdTypeA.Length);
        SmartcardExtension->VendorAttr.IfdType.Length = ifdTypeA.Length;

        SmartcardDebug(DEBUG_DRIVER,
                       ("%s!SetVendorAndIfdName: overwritting vendor name and ifdtype\n",DRIVER_NAME));

    }

    finally {
        if (vendorNameU.Buffer != NULL) {
            RtlFreeUnicodeString(&vendorNameU);
        }
        if (vendorNameA.Buffer != NULL) {
            RtlFreeAnsiString(&vendorNameA);
        }
        if (ifdTypeU.Buffer != NULL) {
            RtlFreeUnicodeString(&ifdTypeU);
        }
        if (ifdTypeA.Buffer != NULL) {
            RtlFreeAnsiString(&ifdTypeA);
        }
        if (regKey != NULL) {
            ZwClose (regKey);
        }
    }

}


/*****************************************************************************
Routine Description:
   creates a new device object for the driver, allocates & initializes all
   neccessary structures (i.e. SmartcardExtension & ReaderExtension).

Arguments:
   DriverObject context of call
   DeviceObject ptr to the created device object

Return Value:
   STATUS_SUCCESS
   STATUS_INSUFFICIENT_RESOURCES
   NTStatus returned by smclib.sys
******************************************************************************/
NTSTATUS CMMOB_CreateDevice(
                           IN  PDRIVER_OBJECT DriverObject,
                           IN  PDEVICE_OBJECT PhysicalDeviceObject,
                           OUT PDEVICE_OBJECT *DeviceObject
                           )
{
    NTSTATUS                   NTStatus = STATUS_SUCCESS;
    NTSTATUS                   RegStatus;
    RTL_QUERY_REGISTRY_TABLE   ParamTable[2];
    UNICODE_STRING             RegistryPath;
    UNICODE_STRING             RegistryValue;
    WCHAR                      szRegValue[256];
    UNICODE_STRING             DeviceName;
    UNICODE_STRING             Tmp;
    WCHAR                      Buffer[64];


    SmartcardDebug(DEBUG_TRACE,
                   ( "%s!CreateDevice: Enter\n",DRIVER_NAME ));

    try {
        ULONG ulDeviceInstance;
        PDEVICE_EXTENSION DeviceExtension;
        PREADER_EXTENSION ReaderExtension;
        PSMARTCARD_EXTENSION SmartcardExtension;

        *DeviceObject = NULL;

        for (ulDeviceInstance = 0; ulDeviceInstance < CMMOB_MAX_DEVICE; ulDeviceInstance++) {
            if (DeviceSlot[ulDeviceInstance] == FALSE) {
                DeviceSlot[ulDeviceInstance] = TRUE;
                break;
            }
        }

        if (ulDeviceInstance == CMMOB_MAX_DEVICE) {
            NTStatus = STATUS_INSUFFICIENT_RESOURCES;
            leave;
        }

      //
      //    construct the device name
      //
        DeviceName.Buffer = Buffer;
        DeviceName.MaximumLength = sizeof(Buffer);
        DeviceName.Length = 0;
        RtlInitUnicodeString(&Tmp,CARDMAN_MOBILE_DEVICE_NAME);
        RtlCopyUnicodeString(&DeviceName,&Tmp);
        DeviceName.Buffer[(DeviceName.Length)/sizeof(WCHAR)-1] = L'0' + (WCHAR)ulDeviceInstance;

      //
      // Create the device object
      //
        NTStatus = IoCreateDevice(DriverObject,
                                  sizeof(DEVICE_EXTENSION),
                                  &DeviceName,
                                  FILE_DEVICE_SMARTCARD,
                                  0,
                                  TRUE,
                                  DeviceObject);
        if (NTStatus != STATUS_SUCCESS) {
            SmartcardLogError(DriverObject,
                              CMMOB_INSUFFICIENT_RESOURCES,
                              NULL,
                              0);
            leave;
        }

      //
      //    tell the OS that we supposed to do buffered io
      //
        (*DeviceObject)->Flags |= DO_BUFFERED_IO;

      // this is necessary, that power routine is called at IRQL_PASSIVE
        (*DeviceObject)->Flags |= DO_POWER_PAGABLE;
      // tells the IO Manager initialization is done
        (*DeviceObject)->Flags &= ~DO_DEVICE_INITIALIZING;

      //
      //    set up the device extension.
      //
        DeviceExtension = (*DeviceObject)->DeviceExtension;
        RtlZeroMemory( DeviceExtension, sizeof( DEVICE_EXTENSION ));

        SmartcardExtension = &DeviceExtension->SmartcardExtension;

      // used for synchronise access to lIoCount
        KeInitializeSpinLock(&DeviceExtension->SpinLockIoCount);

      // Used for stop / start notification
        KeInitializeEvent(&DeviceExtension->ReaderStarted,
                          NotificationEvent,
                          FALSE);

      // Used for update thread notification after hibernation
        KeInitializeEvent(&DeviceExtension->CanRunUpdateThread,
                          NotificationEvent,
                          TRUE);

      //
      //    allocate the reader extension
      //
        ReaderExtension = ExAllocatePool(NonPagedPool,sizeof( READER_EXTENSION ));
        if (ReaderExtension == NULL) {
            SmartcardLogError(DriverObject,
                              CMMOB_INSUFFICIENT_RESOURCES,
                              NULL,
                              0);
            NTStatus = STATUS_INSUFFICIENT_RESOURCES;
            leave;
        }

        RtlZeroMemory( ReaderExtension, sizeof( READER_EXTENSION ));

        SmartcardExtension->ReaderExtension = ReaderExtension;

      // ----------------------------------------------
      //    initialize mutex
      // ----------------------------------------------
        KeInitializeMutex(&SmartcardExtension->ReaderExtension->CardManIOMutex,0L);

      //
      //    enter correct version of the lib
      //
        SmartcardExtension->Version = SMCLIB_VERSION;

      //
      //    setup smartcard extension - callback's
      //

        SmartcardExtension->ReaderFunction[RDF_CARD_POWER] =    CMMOB_CardPower;
        SmartcardExtension->ReaderFunction[RDF_TRANSMIT] =      CMMOB_Transmit;
        SmartcardExtension->ReaderFunction[RDF_SET_PROTOCOL] =  CMMOB_SetProtocol;
        SmartcardExtension->ReaderFunction[RDF_CARD_TRACKING] = CMMOB_CardTracking;
        SmartcardExtension->ReaderFunction[RDF_IOCTL_VENDOR] =  CMMOB_IoCtlVendor;


      //
      //    setup smartcard extension - vendor attribute
      //

      // default values
        RtlCopyMemory(SmartcardExtension->VendorAttr.VendorName.Buffer,
                      CMMOB_VENDOR_NAME,sizeof(CMMOB_VENDOR_NAME));
        SmartcardExtension->VendorAttr.VendorName.Length = sizeof(CMMOB_VENDOR_NAME);

        RtlCopyMemory(SmartcardExtension->VendorAttr.IfdType.Buffer,
                      CMMOB_PRODUCT_NAME,sizeof(CMMOB_PRODUCT_NAME));
        SmartcardExtension->VendorAttr.IfdType.Length = sizeof(CMMOB_PRODUCT_NAME);


      // try to overwrite with registry values
        CMMOB_SetVendorAndIfdName(PhysicalDeviceObject, SmartcardExtension);


        SmartcardExtension->VendorAttr.UnitNo = ulDeviceInstance;
        SmartcardExtension->VendorAttr.IfdVersion.VersionMajor = CMMOB_MAJOR_VERSION;
        SmartcardExtension->VendorAttr.IfdVersion.VersionMinor = CMMOB_MINOR_VERSION;
        SmartcardExtension->VendorAttr.IfdVersion.BuildNumber = CMMOB_BUILD_NUMBER;
        SmartcardExtension->VendorAttr.IfdSerialNo.Length = 0;


      //
      //    setup smartcard extension - reader capabilities
      //
        SmartcardExtension->ReaderCapabilities.SupportedProtocols = SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1;
        SmartcardExtension->ReaderCapabilities.ReaderType = SCARD_READER_TYPE_PCMCIA;
        SmartcardExtension->ReaderCapabilities.MechProperties = 0;
        SmartcardExtension->ReaderCapabilities.Channel = 0;

      // set supported frequencies
        SmartcardExtension->ReaderCapabilities.CLKFrequency.Default = 4000;  //not used if CLKFrequenciesSupported is supplied
        SmartcardExtension->ReaderCapabilities.CLKFrequency.Max = 8000;      //not used if CLKFrequenciesSupported is supplied
        SmartcardExtension->ReaderCapabilities.CLKFrequenciesSupported.Entries =
        sizeof(SupportedCLKFrequencies) / sizeof(SupportedCLKFrequencies[0]);
        SmartcardExtension->ReaderCapabilities.CLKFrequenciesSupported.List =
        SupportedCLKFrequencies;

      // set supported baud rates
        SmartcardExtension->ReaderCapabilities.DataRate.Default = 9600;      //not used if DataRatesSupported is supplied
        SmartcardExtension->ReaderCapabilities.DataRate.Max = 307200;        //not used if DataRatesSupported is supplied
        SmartcardExtension->ReaderCapabilities.DataRatesSupported.Entries =
        sizeof(SupportedDataRates) / sizeof(SupportedDataRates[0]);
        SmartcardExtension->ReaderCapabilities.DataRatesSupported.List =
        SupportedDataRates;

      // maximum buffer size
        SmartcardExtension->ReaderCapabilities.MaxIFSD = 254;

      //
      // Current state of the reader
      //
        SmartcardExtension->ReaderCapabilities.CurrentState = SCARD_UNKNOWN;
        SmartcardExtension->ReaderExtension->ulOldCardState = UNKNOWN;
        SmartcardExtension->ReaderExtension->ulNewCardState = UNKNOWN;

        SmartcardExtension->ReaderExtension->ulFWVersion = 100;

      //
      // Initialization of buffers
      //
        SmartcardExtension->SmartcardRequest.BufferSize   = MIN_BUFFER_SIZE;
        SmartcardExtension->SmartcardReply.BufferSize  = MIN_BUFFER_SIZE;

        NTStatus = SmartcardInitialize(SmartcardExtension);

        SmartcardExtension->ReaderExtension->ReaderPowerState = PowerReaderWorking;
        SmartcardExtension->ReaderExtension->CardParameters.bStopBits=2;
        SmartcardExtension->ReaderExtension->CardParameters.fSynchronousCard=FALSE;
        SmartcardExtension->ReaderExtension->CardParameters.fInversRevers=FALSE;
        SmartcardExtension->ReaderExtension->CardParameters.bClockFrequency=4;
        SmartcardExtension->ReaderExtension->CardParameters.fT0Mode=FALSE;
        SmartcardExtension->ReaderExtension->CardParameters.fT0Write=FALSE;
        SmartcardExtension->ReaderExtension->fReadCIS = FALSE;
        SmartcardExtension->ReaderExtension->bPreviousFlags1 = 0;

        if (NTStatus != STATUS_SUCCESS) {
            SmartcardLogError(DriverObject,
                              CMMOB_INSUFFICIENT_RESOURCES,
                              NULL,
                              0);
            leave;
        }

      //
      //    tell the lib our device object & create symbolic link
      //
        SmartcardExtension->OsData->DeviceObject = *DeviceObject;


        if (DeviceExtension->PnPDeviceName.Buffer == NULL) {

            // ----------------------------------------------
            // register our new device
            // ----------------------------------------------
            NTStatus = IoRegisterDeviceInterface(PhysicalDeviceObject,
                                                 &SmartCardReaderGuid,
                                                 NULL,
                                                 &DeviceExtension->PnPDeviceName);
            SmartcardDebug(DEBUG_DRIVER,
                           ("%s!CreateDevice: PnPDeviceName.Buffer  = %lx\n",DRIVER_NAME,
                            DeviceExtension->PnPDeviceName.Buffer));
            SmartcardDebug(DEBUG_DRIVER,
                           ("%s!CreateDevice: PnPDeviceName.BufferLength  = %lx\n",DRIVER_NAME,
                            DeviceExtension->PnPDeviceName.Length));
            SmartcardDebug(DEBUG_DRIVER,
                           ("%s!CreateDevice: IoRegisterDeviceInterface returned=%lx\n",DRIVER_NAME,NTStatus));

        } else {

            SmartcardDebug(DEBUG_DRIVER,
                           ("%s!CreateDevice: Interface already exists\n",DRIVER_NAME));

        }


        if (NTStatus != STATUS_SUCCESS) {
            SmartcardLogError(DriverObject,
                              CMMOB_INSUFFICIENT_RESOURCES,
                              NULL,
                              0);
            leave;
        }

    }

    finally {
        if (NTStatus != STATUS_SUCCESS) {
            CMMOB_UnloadDevice(*DeviceObject);
            *DeviceObject = NULL;
        }
    }

    SmartcardDebug(DEBUG_TRACE,
                   ( "%s!CreateDevice: Exit %x\n",DRIVER_NAME,NTStatus ));
    return NTStatus;
}



/*****************************************************************************
Routine Description:
   get the actual configuration from the passed FullResourceDescriptor
   and initializes the reader hardware

Note:
   for an NT 4.00 build the resources must be translated by the HAL

Arguments:
   DeviceObject         context of call
   FullResourceDescriptor   actual configuration of the reader

Return Value:
   STATUS_SUCCESS
   NTStatus returned from the HAL (NT 4.00 only )
   NTStatus returned by LowLevel routines
******************************************************************************/
NTSTATUS CMMOB_StartDevice(
                          PDEVICE_OBJECT DeviceObject,
                          PCM_FULL_RESOURCE_DESCRIPTOR FullResourceDescriptor
                          )
{
    NTSTATUS                         NTStatus = STATUS_SUCCESS;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR  PartialDescriptor;
    PDEVICE_EXTENSION                DeviceExtension = DeviceObject->DeviceExtension;
    PSMARTCARD_EXTENSION             SmartcardExtension = &DeviceExtension->SmartcardExtension;
    PREADER_EXTENSION                ReaderExtension = SmartcardExtension->ReaderExtension;
    ULONG                            ulCount;
    ULONG                            ulCISIndex;
    UCHAR                            bTupleCode[2];
    UCHAR                            bFirmware[2];


    SmartcardDebug(DEBUG_TRACE,
                   ("%s!StartDevice: Enter\n",DRIVER_NAME));

   //
   // Get the number of resources we need
   //
    ulCount = FullResourceDescriptor->PartialResourceList.Count;

    PartialDescriptor = FullResourceDescriptor->PartialResourceList.PartialDescriptors;

   //
   //   parse all partial descriptors
   //
    while (ulCount--) {
        switch (PartialDescriptor->Type) {
        

        case CmResourceTypePort:
            {
               //
               // Get IO-length
               //
                ReaderExtension->ulIoWindow = PartialDescriptor->u.Port.Length;
                ASSERT(PartialDescriptor->u.Port.Length >= 8);

               //
               // Get IO-base
               //

      #ifndef _WIN64
                ReaderExtension->pIoBase = (PVOID) PartialDescriptor->u.Port.Start.LowPart;
      #else
                ReaderExtension->pIoBase = (PVOID) PartialDescriptor->u.Port.Start.QuadPart;
      #endif


                SmartcardDebug(DEBUG_TRACE,
                               ("%s!StartDevice: IoBase = %lxh\n",DRIVER_NAME,ReaderExtension->pIoBase));
            }
            break;



        default:
            break;
        }
        PartialDescriptor++;
    }

    try {

      //
      //    Base initialized ?
      //


        if (ReaderExtension->pIoBase == NULL) {


            //
            //  under NT 4.0 the failure of this fct for the second reader
            //  means there is only one device
            //
            SmartcardLogError(DeviceObject,
                              CMMOB_ERROR_MEM_PORT,
                              NULL,
                              0);

            NTStatus = STATUS_INSUFFICIENT_RESOURCES;
            leave;
        }

         // initialize base addresses
        ReaderExtension->pbRegsBase= (PUCHAR) ReaderExtension->pIoBase;


        NTStatus=CMMOB_ResetReader (ReaderExtension);
        SmartcardDebug(DEBUG_DRIVER,
                       ("%s!DEBUG_DRIVER: ResetReader retval = %x\n",DRIVER_NAME, NTStatus));
        if (NTStatus != STATUS_SUCCESS) {
            SmartcardLogError(DeviceObject,
                              CMMOB_CANT_INITIALIZE_READER,
                              NULL,
                              0);
            leave;
        }


      //
      // read firmware version from CIS
      //
        ReaderExtension->fReadCIS=TRUE;
        ReaderExtension->fTActive=TRUE;
        NTStatus=CMMOB_SetFlags1 (ReaderExtension);
        if (NTStatus != STATUS_SUCCESS) {
            SmartcardLogError(DeviceObject,
                              CMMOB_CANT_INITIALIZE_READER,
                              NULL,
                              0);
            leave;
        }

        ulCISIndex = 0;
        do {
            NTStatus=CMMOB_ReadBuffer(ReaderExtension, ulCISIndex, 2, bTupleCode);
            if (NTStatus != STATUS_SUCCESS) {
                leave;
            }
            if (bTupleCode[0] == 0x15) {
            // this is the version tuple
            // read firmware version
                NTStatus=CMMOB_ReadBuffer(ReaderExtension, ulCISIndex+2, 2, bFirmware);
                if (NTStatus != STATUS_SUCCESS) {
                    leave;
                }
                SmartcardExtension->ReaderExtension->ulFWVersion = 100*(ULONG)bFirmware[0]+bFirmware[1];
                SmartcardDebug(DEBUG_TRACE,
                               ("%s!StartDevice: Firmware version = %li\n",
                                DRIVER_NAME, SmartcardExtension->ReaderExtension->ulFWVersion));
            }
            ulCISIndex += bTupleCode[1] + 2;
        }
        while (bTupleCode[1] != 0 &&
               bTupleCode[0] != 0x15 &&
               bTupleCode[0] != 0xFF &&
               ulCISIndex < CMMOB_MAX_CIS_SIZE);

        ReaderExtension->fReadCIS=FALSE;
        ReaderExtension->fTActive=FALSE;
        NTStatus=CMMOB_SetFlags1 (ReaderExtension);
        if (NTStatus != STATUS_SUCCESS) {
            SmartcardLogError(DeviceObject,
                              CMMOB_CANT_INITIALIZE_READER,
                              NULL,
                              0);
            leave;
        }



      //
      // start update thread
      //
        NTStatus = CMMOB_StartCardTracking(DeviceObject);

      // signal that the reader has been started (again)
        KeSetEvent(&DeviceExtension->ReaderStarted, 0, FALSE);

        NTStatus = IoSetDeviceInterfaceState(&DeviceExtension->PnPDeviceName,TRUE);

    } finally {
        if (NTStatus != STATUS_SUCCESS) {
            CMMOB_StopDevice(DeviceObject);
        }
    }

    SmartcardDebug(DEBUG_TRACE,
                   ("%s!StartDevice: Exit %x\n",DRIVER_NAME,NTStatus));
    return NTStatus;
}


/*****************************************************************************
Routine Description:
   Unmap the IO port

Arguments:
   DeviceObject context of call

Return Value:
   void
******************************************************************************/
VOID
CMMOB_StopDevice(
                PDEVICE_OBJECT DeviceObject
                )
{
    PDEVICE_EXTENSION DeviceExtension;

    if (DeviceObject == NULL) {
        return;
    }

    SmartcardDebug(DEBUG_TRACE,
                   ( "%s!StopDevice: Enter\n",DRIVER_NAME ));

    DeviceExtension = DeviceObject->DeviceExtension;
    KeClearEvent(&DeviceExtension->ReaderStarted);

   //
   // stop update thread
   //
    CMMOB_StopCardTracking(DeviceObject);

   // power down the card for saftey reasons
    if (DeviceExtension->SmartcardExtension.ReaderExtension->ulOldCardState == POWERED) {
      // we have to wait for the mutex before
        KeWaitForSingleObject(&DeviceExtension->SmartcardExtension.ReaderExtension->CardManIOMutex,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);
        CMMOB_PowerOffCard(&DeviceExtension->SmartcardExtension);
        KeReleaseMutex(&DeviceExtension->SmartcardExtension.ReaderExtension->CardManIOMutex,
                       FALSE);
    }


   //
   //   unmap ports
   //
    if (DeviceExtension->fUnMapMem) {
        MmUnmapIoSpace(DeviceExtension->SmartcardExtension.ReaderExtension->pIoBase,
                       DeviceExtension->SmartcardExtension.ReaderExtension->ulIoWindow);


        DeviceExtension->fUnMapMem = FALSE;
    }

    SmartcardDebug(DEBUG_TRACE,
                   ( "%s!StopDevice: Exit\n",DRIVER_NAME ));
}


/*****************************************************************************
Routine Description:
   close connections to smclib.sys and the pcmcia driver, delete symbolic
   link and mark the slot as unused.


Arguments:
   DeviceObject device to unload

Return Value:
   void
******************************************************************************/
VOID CMMOB_UnloadDevice(
                       PDEVICE_OBJECT DeviceObject
                       )
{
    PDEVICE_EXTENSION DeviceExtension;

    if (DeviceObject == NULL) {
        return;
    }

    SmartcardDebug(DEBUG_TRACE,
                   ( "%s!UnloadDevice: Enter\n",DRIVER_NAME ));

    DeviceExtension = DeviceObject->DeviceExtension;


    ASSERT(DeviceExtension->SmartcardExtension.VendorAttr.UnitNo < CMMOB_MAX_DEVICE);

   //
   // Mark this slot as available
   //
    DeviceSlot[DeviceExtension->SmartcardExtension.VendorAttr.UnitNo] = FALSE;

   //
   //   report to the lib that the device will be unloaded
   //
    if (DeviceExtension->SmartcardExtension.OsData != NULL) {
      //
      //    finish pending tracking requests
      //
        CMMOB_CompleteCardTracking (&DeviceExtension->SmartcardExtension);
    }

   // Wait until we can safely unload the device
    SmartcardReleaseRemoveLockAndWait(&DeviceExtension->SmartcardExtension);

    SmartcardExit(&DeviceExtension->SmartcardExtension);

    if (DeviceExtension->PnPDeviceName.Buffer != NULL) {
         // disable our device so no one can open it
        IoSetDeviceInterfaceState(&DeviceExtension->PnPDeviceName,FALSE);
        RtlFreeUnicodeString(&DeviceExtension->PnPDeviceName);
        DeviceExtension->PnPDeviceName.Buffer = NULL;
    }

    {
      //
      // Delete the symbolic link of the smart card reader
      //
        if (DeviceExtension->LinkDeviceName.Buffer != NULL) {
            NTSTATUS NTStatus;

            NTStatus = IoDeleteSymbolicLink(&DeviceExtension->LinkDeviceName);
         //
         // we continue even if an error occurs
         //
            ASSERT(NTStatus == STATUS_SUCCESS);

            RtlFreeUnicodeString(&DeviceExtension->LinkDeviceName);
            DeviceExtension->LinkDeviceName.Buffer = NULL;
        }
    }

    if (DeviceExtension->SmartcardExtension.ReaderExtension != NULL) {
        ExFreePool(DeviceExtension->SmartcardExtension.ReaderExtension);
        DeviceExtension->SmartcardExtension.ReaderExtension = NULL;
    }

   //
   // Detach from the pcmcia driver
   // Under NT 4.0 we did not attach to the pcmcia driver
   //
    if (DeviceExtension->AttachedDeviceObject) {
        IoDetachDevice(DeviceExtension->AttachedDeviceObject);
        DeviceExtension->AttachedDeviceObject = NULL;
    }

   //
   //   delete the device object
   //
    IoDeleteDevice(DeviceObject);

    SmartcardDebug(DEBUG_TRACE,
                   ( "%s!UnloadDevice: Exit\n",DRIVER_NAME ));

    return;
}


/*****************************************************************************
CMMOB_UnloadDriver:
   unloads all devices for a given driver object

Arguments:
   DriverObject context of driver

Return Value:
   void
******************************************************************************/
VOID CMMOB_UnloadDriver(
                       PDRIVER_OBJECT DriverObject
                       )
{
    PCM_FULL_RESOURCE_DESCRIPTOR  FullResourceDescriptor;
    ULONG                         ulSizeOfResources;

    SmartcardDebug(DEBUG_TRACE,
                   ( "%s!UnloadDriver: Enter\n",DRIVER_NAME ));


    SmartcardDebug(DEBUG_TRACE,
                   ( "%s!UnloadDriver: Exit\n",DRIVER_NAME ));
}


/*****************************************************************************
CMMOB_CreateClose:
   allowes only one open process a time

Arguments:
   DeviceObject context of device
   Irp              context of call

Return Value:
   STATUS_SUCCESS
   STATUS_DEVICE_BUSY
******************************************************************************/
NTSTATUS CMMOB_CreateClose(
                          PDEVICE_OBJECT DeviceObject,
                          PIRP        Irp
                          )
{
    NTSTATUS             NTStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION    DeviceExtension;
    PSMARTCARD_EXTENSION SmartcardExtension;
    PIO_STACK_LOCATION   IrpStack;

    SmartcardDebug(DEBUG_TRACE,
                   ("%s!CreateClose: Enter ",DRIVER_NAME));

    DeviceExtension = DeviceObject->DeviceExtension;
    SmartcardExtension = &DeviceExtension->SmartcardExtension;
    IrpStack = IoGetCurrentIrpStackLocation( Irp );

   //
   //   dispatch major function
   //
    switch (IrpStack->MajorFunction) {
    case IRP_MJ_CREATE:
        SmartcardDebug(DEBUG_IOCTL,("%s!CreateClose: IRP_MJ_CREATE\n",DRIVER_NAME));
        NTStatus = SmartcardAcquireRemoveLock(SmartcardExtension);
        if (NTStatus != STATUS_SUCCESS) {
            // the device has been removed. Fail the call
            NTStatus = STATUS_DELETE_PENDING;
            break;
        }

        if (InterlockedIncrement(&DeviceExtension->lOpenCount) > 1) {
            InterlockedDecrement(&DeviceExtension->lOpenCount);
            NTStatus = STATUS_ACCESS_DENIED;
        }

        break;

    case IRP_MJ_CLOSE:

        SmartcardReleaseRemoveLock(SmartcardExtension);
        SmartcardDebug(DEBUG_IOCTL,("%s!CreateClose: IRP_MJ_CLOSE\n",DRIVER_NAME));
        if (InterlockedDecrement(&DeviceExtension->lOpenCount) < 0) {
            InterlockedIncrement(&DeviceExtension->lOpenCount);
        }
        break;


    default:
         //
         // unrecognized command
         //
        SmartcardDebug(DEBUG_IOCTL,("unexpected IRP\n"));
        NTStatus = STATUS_INVALID_DEVICE_REQUEST;
        break;
    }

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = NTStatus;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    SmartcardDebug(DEBUG_TRACE,
                   ("%s!CreateClose: Exit %x\n",DRIVER_NAME,NTStatus));

    return NTStatus;
}

NTSTATUS CMMOB_SystemControl(
                            PDEVICE_OBJECT DeviceObject,
                            PIRP        Irp
                            )
{
    PDEVICE_EXTENSION DeviceExtension; 
    NTSTATUS status = STATUS_SUCCESS;

    DeviceExtension      = DeviceObject->DeviceExtension;

    IoSkipCurrentIrpStackLocation(Irp);
    status = IoCallDriver(DeviceExtension->AttachedDeviceObject, Irp);

    return status;

}


/*****************************************************************************
CMMOB_DeviceIoControl:
   all IRP's requiring IO are queued to the StartIo routine, other requests
   are served immediately

Arguments:
   DeviceObject context of device
   Irp              context of call

Return Value:
   STATUS_SUCCESS
   STATUS_PENDING
******************************************************************************/
NTSTATUS CMMOB_DeviceIoControl(
                              PDEVICE_OBJECT DeviceObject,
                              PIRP        Irp
                              )
{
    NTSTATUS             NTStatus;
    PDEVICE_EXTENSION    DeviceExtension = DeviceObject->DeviceExtension;
    KIRQL                irql;
    PIO_STACK_LOCATION   irpSL;

    SmartcardDebug(DEBUG_TRACE,
                   ("%s!DeviceIoControl: Enter\n",DRIVER_NAME));

    irpSL = IoGetCurrentIrpStackLocation(Irp);


#if DBG
    switch (irpSL->Parameters.DeviceIoControl.IoControlCode) {
    case IOCTL_SMARTCARD_EJECT:
        SmartcardDebug(DEBUG_IOCTL,
                       ("%s!DeviceIoControl: %s\n", DRIVER_NAME, "IOCTL_SMARTCARD_EJECT"));
        break;
    case IOCTL_SMARTCARD_GET_ATTRIBUTE:
        SmartcardDebug(DEBUG_IOCTL,
                       ("%s!DeviceIoControl: %s\n", DRIVER_NAME, "IOCTL_SMARTCARD_GET_ATTRIBUTE"));
        break;
    case IOCTL_SMARTCARD_GET_LAST_ERROR:
        SmartcardDebug(DEBUG_IOCTL,
                       ("%s!DeviceIoControl: %s\n", DRIVER_NAME, "IOCTL_SMARTCARD_GET_LAST_ERROR"));
        break;
    case IOCTL_SMARTCARD_GET_STATE:
        SmartcardDebug(DEBUG_IOCTL,
                       ("%s!DeviceIoControl: %s\n", DRIVER_NAME, "IOCTL_SMARTCARD_GET_STATE"));
        break;
    case IOCTL_SMARTCARD_IS_ABSENT:
        SmartcardDebug(DEBUG_IOCTL,
                       ("%s!DeviceIoControl: %s\n", DRIVER_NAME, "IOCTL_SMARTCARD_IS_ABSENT"));
        break;
    case IOCTL_SMARTCARD_IS_PRESENT:
        SmartcardDebug(DEBUG_IOCTL,
                       ("%s!DeviceIoControl: %s\n", DRIVER_NAME, "IOCTL_SMARTCARD_IS_PRESENT"));
        break;
    case IOCTL_SMARTCARD_POWER:
        SmartcardDebug(DEBUG_IOCTL,
                       ("%s!DeviceIoControl: %s\n", DRIVER_NAME, "IOCTL_SMARTCARD_POWER"));
        break;
    case IOCTL_SMARTCARD_SET_ATTRIBUTE:
        SmartcardDebug(DEBUG_IOCTL,
                       ("%s!DeviceIoControl: %s\n", DRIVER_NAME, "IOCTL_SMARTCARD_SET_ATTRIBUTE"));
        break;
    case IOCTL_SMARTCARD_SET_PROTOCOL:
        SmartcardDebug(DEBUG_IOCTL,
                       ("%s!DeviceIoControl: %s\n", DRIVER_NAME, "IOCTL_SMARTCARD_SET_PROTOCOL"));
        break;
    case IOCTL_SMARTCARD_SWALLOW:
        SmartcardDebug(DEBUG_IOCTL,
                       ("%s!DeviceIoControl: %s\n", DRIVER_NAME, "IOCTL_SMARTCARD_SWALLOW"));
        break;
    case IOCTL_SMARTCARD_TRANSMIT:
        SmartcardDebug(DEBUG_IOCTL,
                       ("%s!DeviceIoControl: %s\n", DRIVER_NAME, "IOCTL_SMARTCARD_TRANSMIT"));
        break;
    default:
        SmartcardDebug(DEBUG_IOCTL,
                       ("%s!DeviceIoControl: %s\n", DRIVER_NAME, "Vendor specific or unexpected IOCTL"));
        break;
    }
#endif



    NTStatus = SmartcardAcquireRemoveLock(&DeviceExtension->SmartcardExtension);
    if (!NT_SUCCESS(NTStatus)) {
      // the device has been removed. Fail the call
        NTStatus = STATUS_DELETE_PENDING;
        Irp->IoStatus.Status = NTStatus;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );


        SmartcardDebug(DEBUG_TRACE,
                       ("%s!DeviceIoControl: Exit %x\n",DRIVER_NAME,NTStatus));

        return NTStatus;
    }

    KeAcquireSpinLock(&DeviceExtension->SpinLockIoCount, &irql);
    if (DeviceExtension->lIoCount == 0) {
        KeReleaseSpinLock(&DeviceExtension->SpinLockIoCount, irql);

        NTStatus = KeWaitForSingleObject(&DeviceExtension->ReaderStarted,
                                         Executive,
                                         KernelMode,
                                         FALSE,
                                         NULL);
        ASSERT(NTStatus == STATUS_SUCCESS);

        KeAcquireSpinLock(&DeviceExtension->SpinLockIoCount, &irql);
    }
    ASSERT(DeviceExtension->lIoCount >= 0);
    DeviceExtension->lIoCount++;
    KeReleaseSpinLock(&DeviceExtension->SpinLockIoCount, irql);


    KeWaitForSingleObject(&DeviceExtension->SmartcardExtension.ReaderExtension->CardManIOMutex,
                          Executive,
                          KernelMode,
                          FALSE,
                          NULL);

   // get current card state
    NTStatus = CMMOB_UpdateCurrentState(&DeviceExtension->SmartcardExtension);

    NTStatus = SmartcardDeviceControl(&DeviceExtension->SmartcardExtension,Irp);

    KeReleaseMutex(&DeviceExtension->SmartcardExtension.ReaderExtension->CardManIOMutex,
                   FALSE);


    KeAcquireSpinLock(&DeviceExtension->SpinLockIoCount, &irql);
    DeviceExtension->lIoCount--;
    ASSERT(DeviceExtension->lIoCount >= 0);
    KeReleaseSpinLock(&DeviceExtension->SpinLockIoCount, irql);


    SmartcardReleaseRemoveLock(&DeviceExtension->SmartcardExtension);

    SmartcardDebug(DEBUG_TRACE,
                   ("%s!DeviceIoControl: Exit %x\n",DRIVER_NAME,NTStatus));

    return NTStatus;
}


/*****************************************************************************
Routine Description:

    This routine is called by the I/O system when the calling thread terminates

Arguments:

    DeviceObject    - Pointer to device object for this miniport
    Irp             - IRP involved.

Return Value:

    STATUS_CANCELLED
******************************************************************************/
NTSTATUS CMMOB_Cleanup(
                      IN PDEVICE_OBJECT DeviceObject,
                      IN PIRP Irp
                      )
{
    PDEVICE_EXTENSION    DeviceExtension = DeviceObject->DeviceExtension;
    PSMARTCARD_EXTENSION SmartcardExtension = &DeviceExtension->SmartcardExtension;

    SmartcardDebug(DEBUG_TRACE,
                   ("%s!Cleanup: Enter\n",DRIVER_NAME));

    if (SmartcardExtension->ReaderExtension != NULL &&
       // if the device has been removed ReaderExtension == NULL
        DeviceExtension->lOpenCount == 1 )
    // complete card tracking only if this is the the last close call
    // otherwise the card tracking of the resource manager is canceled
    {
      //
      // We need to complete the notification irp
      //
        CMMOB_CompleteCardTracking(SmartcardExtension);
    }

    SmartcardDebug(DEBUG_DRIVER,
                   ("%s!Cleanup: Completing IRP %lx\n",DRIVER_NAME,Irp));

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = STATUS_SUCCESS;

    IoCompleteRequest(Irp,IO_NO_INCREMENT);

    SmartcardDebug(DEBUG_TRACE,
                   ("%s!Cleanup: Exit\n",DRIVER_NAME));

    return STATUS_SUCCESS;
}

/*****************************************************************************
SysDelay:
   performs a required delay. The usage of KeStallExecutionProcessor is
   very nasty, but it happends only if SysDelay is called in the context of
   our DPC routine (which is only called if a card change was detected).

   For 'normal' IO we have Irql < DISPATCH_LEVEL, so if the reader is polled
   while waiting for response we will not block the entire system

Arguments:
   Timeout      delay in milli seconds

Return Value:
   void
******************************************************************************/
VOID SysDelay(
             ULONG Timeout
             )
{
    LARGE_INTEGER  SysTimeout;

    if (KeGetCurrentIrql() >= DISPATCH_LEVEL) {
        ULONG Cnt = 20 * Timeout;

        SmartcardDebug(DEBUG_DRIVER,
                       ("%s! Waiting at IRQL >= DISPATCH_LEVEL %l\n",DRIVER_NAME,Timeout));
        while (Cnt--) {
         //
         // KeStallExecutionProcessor: counted in us
         //
            KeStallExecutionProcessor( 50 );
        }
    } else {
        SysTimeout = RtlConvertLongToLargeInteger(Timeout * -10000L);
      //
      //    KeDelayExecutionThread: counted in 100 ns
      //
        KeDelayExecutionThread( KernelMode, FALSE, &SysTimeout );
    }
    return;
}




/*****************************************************************************
* History:
* $Log: cmbp0wdm.c $
* Revision 1.11  2001/01/22 08:12:22  WFrischauf
* No comment given
*
* Revision 1.9  2000/09/25 14:24:33  WFrischauf
* No comment given
*
* Revision 1.8  2000/08/24 09:05:14  TBruendl
* No comment given
*
* Revision 1.7  2000/08/16 16:52:17  WFrischauf
* No comment given
*
* Revision 1.6  2000/08/09 12:46:01  WFrischauf
* No comment given
*
* Revision 1.5  2000/07/27 13:53:06  WFrischauf
* No comment given
*
*
******************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\cmbp0\pcsc_cm.h ===
/*****************************************************************************
@doc            INT EXT
******************************************************************************
* $ProjectName:  $
* $ProjectRevision:  $
*-----------------------------------------------------------------------------
* $Source: z:/pr/cmbp0/sw/cmbp0.ms/rcs/pcsc_cm.h $
* $Revision: 1.2 $
*-----------------------------------------------------------------------------
* $Author: WFrischauf $
*-----------------------------------------------------------------------------
* History: see EOF
*-----------------------------------------------------------------------------
*
* Copyright (c) 2000 OMNIKEY AG
******************************************************************************/

#ifndef _INC_PCSC_CM
#define _INC_PCSC_CM

/*****************************************************************************/
/** includes                                                                **/
/*****************************************************************************/

#include <winsmcrd.h>
#include <devioctl.h>

/*****************************************************************************/
/** constants                                                               **/
/*****************************************************************************/

#define CM_IOCTL_CR80S_SAMOS_SET_HIGH_SPEED           SCARD_CTL_CODE (3000)
#define CM_IOCTL_CR80S_SAMOS_SET_HIGH_SPEED_OLD       SCARD_CTL_CODE (0x8100)

#define CM_IOCTL_GET_FW_VERSION                       SCARD_CTL_CODE (3001)
#define CM_IOCTL_GET_FW_VERSION_OLD                   SCARD_CTL_CODE (0x8101)

//#define CM_SPE_SECURE_PIN_ENTRY                    SCARD_CTL_CODE (0x8102)
//#define CM_IOCTL_IS_SPE_SUPPORTED                   SCARD_CTL_CODE (3003)
//#define CM_IOCTL_IS_SPE_SUPPORTED_OLD               SCARD_CTL_CODE (0x8103)

#define CM_IOCTL_READ_DEVICE_DESCRIPTION              SCARD_CTL_CODE (3004)

#define CM_IOCTL_SET_SYNC_PARAMETERS                  SCARD_CTL_CODE (3010)
#define CM_IOCTL_2WBP_RESET_CARD                      SCARD_CTL_CODE (3011)
#define CM_IOCTL_2WBP_TRANSFER                        SCARD_CTL_CODE (3012)
#define CM_IOCTL_3WBP_TRANSFER                        SCARD_CTL_CODE (3013)
#define CM_IOCTL_SYNC_CARD_POWERON                    SCARD_CTL_CODE (3014)

#define CM_IOCTL_SET_READER_38400_BAUD                SCARD_CTL_CODE (3020)
#define CM_IOCTL_SET_READER_9600_BAUD                 SCARD_CTL_CODE (3021)

#define CM_IOCTL_OPEN_CT_INTERFACE                    SCARD_CTL_CODE (3022)
#define CM_IOCTL_CLOSE_CT_INTERFACE                   SCARD_CTL_CODE (3023)
#define CM_IOCTL_GET_CT_STATE                         SCARD_CTL_CODE (3024)


//****************************************************************************
//* SYNCHRONOUS SMART CARDS
//****************************************************************************
#define SCARD_RESET_LINE_HIGH      0x00000001
#define SCARD_RESET_LINE_LOW       0x00000000

#define SCARD_PROTOCOL_2WBP        0x00000001
#define SCARD_PROTOCOL_3WBP        0x00000002

//#define CLOCK_FORDCED_2WBP         0x00000040

//----------------------------------------------------------------------------
// structure for "CM_IOCTL_SET_SYNC_PARAMETERS" IO-Control (CrasControl)
//----------------------------------------------------------------------------
#ifndef BOOL
   #define BOOL unsigned int
#endif

typedef struct _SYNC_PARAMETERS {
   ULONG  ulProtocol;
   ULONG  ulStateResetLineWhileReading;
   ULONG  ulStateResetLineWhileWriting;
   ULONG  ulWriteDummyClocks;
   ULONG  ulHeaderLen;
   BOOL   fCardResetRequested;
   BOOL   fCardPowerRequested;
} SYNC_PARAMETERS, *PSYNC_PARAMETERS;


//----------------------------------------------------------------------------
//  structure for CM_IOCTL_2WBP_TRANSFER and  CM_IOCTL_3WBP_TRANSFER
//  IO-Control (CRASControl)
//----------------------------------------------------------------------------
typedef struct _SYNC_TRANSFER
{
   ULONG ulSyncBitsToWrite;
   ULONG ulSyncBitsToRead;
}SYNC_TRANSFER, *PSYNC_TRANSFER;

#endif /* _INC_PCSC_CM */


/*****************************************************************************
* History:
* $Log: pcsc_cm.h $
* Revision 1.2  2000/07/27 13:53:08  WFrischauf
* No comment given
*
*
*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\gempc430\device.h ===
//-------------------------------------------------------------------
// This is abstract class for generic device
// Specific devices should use it as a parent device
// Author: Sergey Ivanov
// Log:
//      08/11/99    -   implemented 
//-------------------------------------------------------------------
#ifndef __DEVICE__
#define __DEVICE__

#include "generic.h"

enum DEVSTATE 
{
    STOPPED,                                // device stopped
    WORKING,                                // started and working
    PENDINGSTOP,                            // stop pending
    PENDINGREMOVE,                          // remove pending
    SURPRISEREMOVED,                        // removed by surprise
    REMOVED,                                // removed
};

// Remove eventually previous declaration!...
typedef enum _DEVICE_PNP_STATE {

    NOT_STARTED = 0,         // Not started yet
    STARTED,                 // Device has received the START_DEVICE IRP
    STOP_PENDING,            // Device has received the QUERY_STOP IRP
    _STOPPED_,                 // Device has received the STOP_DEVICE IRP
    REMOVE_PENDING,          // Device has received the QUERY_REMOVE IRP
    SURPRISE_REMOVE_PENDING, // Device has received the SURPRISE_REMOVE IRP
    DELETED                  // Device has received the REMOVE_DEVICE IRP
} DEVICE_PNP_STATE;

enum POWERSTATE 
{
    POWERON,                                // power on, device in D0 state
    POWEROFFPENDING,                        // power off operation is pending
    POWEROFF,                               // power off, device in D3 state
    IDLEOFF,                                // power off due to idle detection
};

typedef struct _PPOWER_CONTEXT_
{
    PKEVENT powerEvent;
    NTSTATUS status;
} POWER_CONTEXT,*PPOWER_CONTEXT;


#define INITIALIZE_PNP_STATE()    \
        this->m_DevicePnPState =  NOT_STARTED;\
        this->m_PreviousPnPState = NOT_STARTED

#define SET_NEW_PNP_STATE(__state_) \
        this->m_PreviousPnPState =  this->m_DevicePnPState;\
        this->m_DevicePnPState = (_state_)

#define RESTORE_PREVIOUS_PNP_STATE()   \
        this->m_DevicePnPState =   this->m_PreviousPnPState

#define IS_DEVICE_PNP_STATE(_state_)   \
        (this->m_DevicePnPState == _state_)


#define DEVICE_SURPRISE_REMOVAL_OK 1

#define PNPTABSIZE      IRP_MN_QUERY_LEGACY_BUS_INFORMATION+1
#define POWERTABSIZE    IRP_MN_QUERY_POWER+1
#define STATETABSIZE    REMOVED+1
#define SYSTEM_POWER_TAB_NAMESIZE 8
#define DEVICE_POWER_TAB_NAMESIZE 6


typedef enum PENDING_REQUEST_TYPE
{
    OPEN_REQUEST = 0,
    CLOSE_REQUEST,
    READ_REQUEST,
    WRITE_REQUEST,
    IOCTL_REQUEST,
    PNP_REQUEST,
    POWER_REQUEST,
    SYSTEM_REQUEST,
    FLUSH_REQUEST,
    CLEAN_REQUEST,
    START_IO_REQUEST
} PENDING_REQUEST_TYPE;

class CPendingIRP
{
public:
    NTSTATUS m_Status;
    SAFE_DESTRUCTORS();
    virtual VOID dispose(){self_delete();};
public:
    LIST_ENTRY entry;
    PENDING_REQUEST_TYPE Type;
    PDEVICE_OBJECT  DeviceObject;
    PIRP Irp;
public:
    CPendingIRP(PIRP Irp,PENDING_REQUEST_TYPE rt = OPEN_REQUEST,
        PDEVICE_OBJECT  tdo = NULL,PFILE_OBJECT tfo = NULL):
        Irp(Irp), Type(rt), DeviceObject(tdo)
    {
    };
};

// ABSTRUCT class
// This is main interface from system to the device.
// Specific devices should implement the interface to support system requests.
class CDevice;
class CSystem;
class CIrp;
class CEvent;
class CPower;
class CDebug;
class CLock;
class CMemory;
class CIoPacket;
class CThread;

typedef struct _REMOVE_LOCK 
{
    LONG usage;                 // reference count
    BOOLEAN removing;           // true if removal is pending
    KEVENT evRemove;            // event to wait on
} REMOVE_LOCK, *PREMOVE_LOCK;


class CDevice;
#pragma PAGEDCODE
class CDevice
{
public:
    NTSTATUS m_Status;
    SAFE_DESTRUCTORS();
public:
    ULONG m_Type;
    // Support for the linked list of devices...
    LIST_ENTRY   entry;
protected:
    LONG        m_Usage;        // use count on this device
    static ULONG DeviceNumber;  // Device instance number

    UNICODE_STRING m_Ifname;
    CUString*   m_DeviceObjectName;
    
    UCHAR       m_VendorName[MAXIMUM_ATTR_STRING_LENGTH];
    USHORT      m_VendorNameLength;
    UCHAR       m_DeviceType[MAXIMUM_ATTR_STRING_LENGTH];
    USHORT      m_DeviceTypeLength;

    BOOL        m_Started;      // Set TRUE if device started, FALSE if stopped
    BOOL        m_Openned;      // Set TRUE if device openned, FALSE if closed
    BOOL        m_Added;        // Set TRUE if device was added to system, FALSE if it is not
     
    BOOL        m_SurprizeRemoved;
    REMOVE_LOCK m_RemoveLock;

    BOOL        m_RestartActiveThread;
    KEVENT      m_evEnabled;        // event to wait on after device was disabled

    // Event to signal device Idle state
    //KMUTEX        IdleState;=========== It will be much better!!!!!!!!!
    KEVENT      IdleState;

    // Capabilities structure and device flags to handle
    DEVICE_CAPABILITIES m_DeviceCapabilities;
    ULONG               m_Flags;
    // Power management constants
    PULONG              m_Idle; // idle counter pointer
    ULONG               Idle_conservation;
    ULONG               Idle_performance;
    DEVICE_POWER_STATE  m_CurrentDevicePowerState;

    DEVICE_POWER_STATE  m_PowerDownLevel;
    PIRP                m_PowerIrp;
    BOOL                m_EnabledForWakeup;

    //Current device state
    DEVSTATE            m_DeviceState;
    // Will be used for canceled request
    DEVSTATE            m_DevicePreviousState;

    // Next members will remove previous two (eventually)...
    DEVICE_PNP_STATE    m_PreviousPnPState;
    DEVICE_PNP_STATE    m_DevicePnPState;

    CSystem*        system;
    CIrp*           irp;
    CEvent*         event;

    CPower*         power;
    CDebug*         debug;
    CLock*          lock;
    CMemory*        memory;
    
    // Support for asynchronous communications
    CThread*        IoThread;

    LONG DevicePoolingInterval;
    LONG Write_To_Read_Delay;
    LONG Power_WTR_Delay;// Delay at power command
    LONG DeviceCommandTimeout;// Timeout for the device commands

    GUID InterfaceClassGuid;
    BOOL m_DeviceInterfaceRegistered;

    ULONG  CardState;
    
    // --------- ASYNCHRONOUS REQUESTS SUPPORT FUNCTIONS ---------------------------- 
    // This group of functions will allow to create asynchronous 
    // communications with the driver.
    // It includes -
    //  -   functions to mark our Irp as pending and to include it into
    //      our device requests queue (makeRequestPending());
    //  -   to extract next Irp from the device queue (startNextPendingRequest())
    //      and to start device specific Irp processing (startIoRequest())
    //  -   getIoRequestsQueue() allows devices to verify device queue state.
    // It is completely is up to specific device how to manage the device queue and
    // to make synchronous or asynchronous Irp processing.
    // For expl. device can create specific thread to process Irps.
    // More than this - some devices can deside to make asyncronous communications only
    // for specific (time consuming) device request while processing others syschronously.
    //
    // cancelPendingIrp() will cancel current Irp and remove corresponding IoRequest from 
    // IoRequestQueue.
    
protected:
    CLinkedList<CPendingIRP>* m_IoRequests; // Clients' IO requests
    // Support for dynamic device connections
    PIRP m_OpenSessionIrp;
public:
    virtual CLinkedList<CPendingIRP>* getIoRequestsQueue() = 0;
    virtual VOID     cancelPendingIrp(PIRP Irp) = 0;
    virtual NTSTATUS cancelPendingRequest(CPendingIRP* IrpReq) = 0;
    virtual NTSTATUS cancelAllPendingRequests() = 0;

    virtual NTSTATUS makeRequestPending(PIRP Irp_request,PDEVICE_OBJECT toDeviceObject,PENDING_REQUEST_TYPE Type) = 0;
    // Next functions will be called by Irp processing thread.
    // Checks if request queue is empty and if it is NOT - starts next request...
    virtual NTSTATUS startNextPendingRequest() = 0;
    // Device specific function which processes pending requests...
    // It will be redefied by specific devices.
    virtual NTSTATUS startIoRequest(CPendingIRP*) = 0;
    // --------- ASYNCHRONOUS REQUESTS SUPPORT FUNCTIONS ---------------------------- 

public:
    CDevice()
    {
        m_Type    = GRCLASS_DEVICE;
        m_Openned = FALSE;
        m_Added   = FALSE;

        // At begining device is at stop state 
        m_DevicePreviousState = STOPPED;
        m_DeviceState = STOPPED;

        m_SurprizeRemoved = FALSE;
        m_RestartActiveThread = FALSE;
        m_DeviceInterfaceRegistered = FALSE;
        m_ParentDeviceObject = NULL;
        DevicePoolingInterval = 500;// 0.5s better for detection
		set_Default_WTR_Delay(); //1ms corrects "0 bytes" problem
        Power_WTR_Delay     = 1; //1ms should be OK...
        DeviceCommandTimeout = 60000;// 60sec

        m_IoRequests = NULL;
        DBG_PRINT("         New Device %8.8lX was created...\n",this);
    }; // Default pooling interval

    BOOL    PnPfcntab[PNPTABSIZE];
    BOOL    Powerfcntab[POWERTABSIZE];

#ifdef DEBUG
    PCHAR PnPfcnname[PNPTABSIZE];
    PCHAR Powerfcnname[POWERTABSIZE];
    PCHAR Powersysstate[SYSTEM_POWER_TAB_NAMESIZE];
    PCHAR Powerdevstate[DEVICE_POWER_TAB_NAMESIZE];
    PCHAR statenames[STATETABSIZE];
#endif // DEBUG

protected:
    virtual ~CDevice(){};
        // Complete current request with given information
    virtual NTSTATUS    completeDeviceRequest(PIRP Irp, NTSTATUS status, ULONG info) {return STATUS_SUCCESS;};

    VOID    activatePnPHandler(LONG HandlerID)
    {
        if (HandlerID >= arraysize(PnPfcntab)) return;
        PnPfcntab[HandlerID] = TRUE;
    };

    VOID    disActivatePnPHandler(LONG HandlerID)
    {
        if (HandlerID >= arraysize(PnPfcntab)) return;
        PnPfcntab[HandlerID] = FALSE;
    };
public:
    virtual CDevice* create(VOID) {return NULL;};
    virtual VOID addRef(){refcount++;};
    virtual VOID removeRef(){if(refcount) refcount--;};
    virtual LONG getRefCount(){ return refcount;};
    virtual VOID markAsOpenned(){ m_Openned = TRUE;};
    virtual VOID markAsClosed() { m_Openned = FALSE;};
    virtual BOOL isOpenned() { return m_Openned;};

    virtual VOID setDeviceState(DEVSTATE state)
    {
        m_DevicePreviousState = m_DeviceState;
        m_DeviceState = state;
    };
    virtual DEVSTATE getDeviceState(){return m_DeviceState;};   
    virtual VOID restoreDeviceState(){m_DeviceState = m_DevicePreviousState;};
    virtual getObjectType(){return m_Type;};

    virtual ULONG    getCardState(){return CardState;};
    virtual VOID     setCardState(ULONG state){CardState = state;};


    // Call this function instead of destructor.
    // It will assure safety device removal.
    virtual VOID        dispose()       {};
    // Checks if device object is still valid.
    virtual BOOL        checkValid()    {return FALSE;};

    // Next methods should be defined by ALL clients...
    virtual BOOL        createDeviceObjects()   {return FALSE;};
    virtual VOID        removeDeviceObjects()   {};

    virtual VOID        initializeRemoveLock()  {};
    virtual NTSTATUS    acquireRemoveLock()     {return STATUS_SUCCESS;};
    virtual VOID        releaseRemoveLock()     {};
    virtual VOID        releaseRemoveLockAndWait() {};
    virtual BOOL        isDeviceLocked()        {return FALSE;};

    virtual VOID        setBusy() {};
    virtual VOID        setIdle() {};
    virtual NTSTATUS    waitForIdle() {return STATUS_SUCCESS;};
    virtual NTSTATUS    waitForIdleAndBlock() {return STATUS_SUCCESS;};

    //virtual NTSTATUS  add(PDRIVER_OBJECT Driver,PDEVICE_OBJECT PnpDeviceObject) {};
    virtual NTSTATUS    add(PDRIVER_OBJECT DriverObject, PDEVICE_OBJECT pPdo) {return STATUS_UNSUCCESSFUL;};

    PDEVICE_OBJECT      getSystemObject(){return m_DeviceObject;};
    PDEVICE_OBJECT      getPhysicalObject(){return m_PhysicalDeviceObject;};
    PDEVICE_OBJECT      getLowerDriver(){return m_pLowerDeviceObject;};
    UNICODE_STRING*     getDeviceInterfaceName(){return &m_Ifname;};
    GUID*               getDeviceInterfaceGUID(){return &InterfaceClassGuid;};
    BOOL                isDeviceInterfaceRegistered(){return m_DeviceInterfaceRegistered;};
    virtual BOOL        registerDeviceInterface(const GUID* Guid) {return FALSE;};
    virtual VOID        unregisterDeviceInterface(UNICODE_STRING* InterfaceName) {};

    
    CUString*           getDeviceName(){return m_DeviceObjectName;};

    ULONG               getDeviceNumber(){ULONG ID = DeviceNumber; if(ID) --ID; return ID;};
    ULONG               incrementDeviceNumber(){ULONG ID = DeviceNumber; ++DeviceNumber; return ID;};

    virtual VOID        remove()        {};
    virtual VOID        onDeviceStart() {};
    virtual VOID        onDeviceStop()  {};

    // These functions will create driver's IRPs to transfer datas.
    // Device stack will keep track of all active (sended to lower level)
    // and pending (mark as pending) IRPs...
    virtual NTSTATUS    send(CIoPacket* Irp) {return STATUS_SUCCESS;};
    virtual NTSTATUS    sendAndWait(CIoPacket* Irp) {return STATUS_SUCCESS;};
    // Functions will send request and wait for a reply...
    virtual  NTSTATUS   write(PUCHAR pRequest,ULONG RequestLength) {return STATUS_SUCCESS;};
    virtual  NTSTATUS   writeAndWait(PUCHAR pRequest,ULONG RequestLength,PUCHAR pReply,ULONG* pReplyLength) {return STATUS_SUCCESS;};
    virtual  NTSTATUS   readAndWait(PUCHAR pRequest,ULONG RequestLength,PUCHAR pReply,ULONG* pReplyLength) {return STATUS_SUCCESS;};
    
    // Interface for system requests. ..
    virtual NTSTATUS    pnpRequest(IN PIRP Irp) {return STATUS_SUCCESS;};
    virtual NTSTATUS    powerRequest(PIRP irp)  {return STATUS_SUCCESS;};

    virtual NTSTATUS    open(PIRP irp)          {return STATUS_SUCCESS;};//Create
    virtual NTSTATUS    close(PIRP irp)         {return STATUS_SUCCESS;};

    virtual NTSTATUS    read(PIRP irp)          {return STATUS_SUCCESS;};
    virtual NTSTATUS    write(PIRP irp)         {return STATUS_SUCCESS;};
    virtual VOID        startIo(PIRP irp){};

    virtual NTSTATUS    deviceControl(PIRP irp) {return STATUS_SUCCESS;};

    virtual NTSTATUS    cleanup(PIRP Irp)       {return STATUS_SUCCESS;};
    virtual NTSTATUS    flush(PIRP Irp)         {return STATUS_SUCCESS;};

    virtual LONG        getDevicePoolingInterval()
    {
        return DevicePoolingInterval;
    };
    virtual VOID        setDevicePoolingInterval(LONG interval)
    {
        DevicePoolingInterval = interval;
    };

    virtual LONG        getCommandTimeout()
    {
        return DeviceCommandTimeout;
    };
    virtual VOID        setCommandTimeout(LONG timeout)
    {
        DeviceCommandTimeout = timeout;
    };
    
    // Inhereted classes will overwrite this function
    virtual NTSTATUS ThreadRoutine()
    {
        return STATUS_SUCCESS;
    };

    #pragma LOCKEDCODE
    // This is callback function for the attached threads
    static VOID ThreadFunction(CDevice* device)
    {
        if(device) device->ThreadRoutine();
    };
    #pragma PAGEDCODE

    virtual LONG    get_Power_WTR_Delay()
    {
        return Power_WTR_Delay;
    };
    
    virtual LONG    get_WTR_Delay()
    {
        return Write_To_Read_Delay;
    };

    virtual VOID    set_WTR_Delay(LONG Delay)
    {
        Write_To_Read_Delay = Delay;
    };
    
    virtual VOID    set_Default_WTR_Delay()
    {
        Write_To_Read_Delay = 1;
    };

    virtual VOID    registerPowerIrp(PIRP Irp){m_PowerIrp = Irp;};
    virtual PIRP    getPowerIrp(){return m_PowerIrp;};
    virtual VOID    unregisterPowerIrp(){m_PowerIrp = NULL;};
    virtual BOOL    isEnabledForWakeup(){return m_EnabledForWakeup;};
    virtual VOID    setCurrentDevicePowerState(DEVICE_POWER_STATE state){m_CurrentDevicePowerState = state;};
    virtual NTSTATUS sendDeviceSetPower(DEVICE_POWER_STATE devicePower, BOOLEAN wait) = 0;

    virtual VOID    setSurprizeRemoved(){m_SurprizeRemoved = TRUE;};
    virtual VOID    clearSurprizeRemoved(){m_SurprizeRemoved = FALSE;};
    virtual BOOL    isSurprizeRemoved(){ return m_SurprizeRemoved;};

    virtual VOID    setThreadRestart(){m_RestartActiveThread = TRUE;};
    virtual VOID    clearThreadRestart(){m_RestartActiveThread = FALSE;};
    virtual BOOL    isRequiredThreadRestart(){ return m_RestartActiveThread;};

protected:
    WCHAR Signature[3];

    PDRIVER_OBJECT  m_DriverObject;
    // Back reference to system object
    PDEVICE_OBJECT  m_DeviceObject;
    // Device object lower at stack
    PDEVICE_OBJECT  m_pLowerDeviceObject;
    // Interrupt handle/object
    IN PKINTERRUPT  m_InterruptObject;
    // Physical device object used at Power management
    PDEVICE_OBJECT  m_PhysicalDeviceObject;
    // Will be used by child at bus to access parent
    PDEVICE_OBJECT  m_ParentDeviceObject;
protected:
    BOOL    initialized;//Current object finished initialization
    LONG    refcount;
};



#ifdef DEBUG

#define INCLUDE_PNP_FUNCTIONS_NAMES()   \
    PnPfcnname[IRP_MN_START_DEVICE]         = "IRP_MN_START_DEVICE";\
    PnPfcnname[IRP_MN_QUERY_REMOVE_DEVICE]  = "IRP_MN_QUERY_REMOVE_DEVICE";\
    PnPfcnname[IRP_MN_REMOVE_DEVICE]        = "IRP_MN_REMOVE_DEVICE";\
    PnPfcnname[IRP_MN_CANCEL_REMOVE_DEVICE] = "IRP_MN_CANCEL_REMOVE_DEVICE";\
    PnPfcnname[IRP_MN_STOP_DEVICE]          = "IRP_MN_STOP_DEVICE";\
\
    PnPfcnname[IRP_MN_QUERY_STOP_DEVICE]    = "IRP_MN_QUERY_STOP_DEVICE";\
    PnPfcnname[IRP_MN_CANCEL_STOP_DEVICE]   = "IRP_MN_CANCEL_STOP_DEVICE";\
    PnPfcnname[IRP_MN_QUERY_DEVICE_RELATIONS]= "IRP_MN_QUERY_DEVICE_RELATIONS";\
\
    PnPfcnname[IRP_MN_QUERY_INTERFACE]      = "IRP_MN_QUERY_INTERFACE";\
    PnPfcnname[IRP_MN_QUERY_CAPABILITIES]   = "IRP_MN_QUERY_CAPABILITIES";\
    PnPfcnname[IRP_MN_QUERY_RESOURCES]      = "IRP_MN_QUERY_RESOURCES";\
\
    PnPfcnname[IRP_MN_QUERY_RESOURCE_REQUIREMENTS]  = "IRP_MN_QUERY_RESOURCE_REQUIREMENTS";\
    PnPfcnname[IRP_MN_QUERY_DEVICE_TEXT]    = "IRP_MN_QUERY_DEVICE_TEXT";\
    PnPfcnname[IRP_MN_FILTER_RESOURCE_REQUIREMENTS] = "IRP_MN_FILTER_RESOURCE_REQUIREMENTS";\
    PnPfcnname[14]                          = "Unsupported PnP function";\
\
    PnPfcnname[IRP_MN_READ_CONFIG]          = "IRP_MN_READ_CONFIG";\
    PnPfcnname[IRP_MN_WRITE_CONFIG]         = "IRP_MN_WRITE_CONFIG";\
    PnPfcnname[IRP_MN_EJECT]                = "IRP_MN_EJECT";\
\
    PnPfcnname[IRP_MN_SET_LOCK]                     = "IRP_MN_SET_LOCK";\
    PnPfcnname[IRP_MN_QUERY_ID]                     = "IRP_MN_QUERY_ID";\
    PnPfcnname[IRP_MN_QUERY_PNP_DEVICE_STATE]       = "IRP_MN_QUERY_PNP_DEVICE_STATE";\
    PnPfcnname[IRP_MN_QUERY_BUS_INFORMATION]        = "IRP_MN_QUERY_BUS_INFORMATION";\
    PnPfcnname[IRP_MN_DEVICE_USAGE_NOTIFICATION]    = "IRP_MN_DEVICE_USAGE_NOTIFICATION";\
    PnPfcnname[IRP_MN_SURPRISE_REMOVAL]             = "IRP_MN_SURPRISE_REMOVAL";\
    PnPfcnname[IRP_MN_QUERY_LEGACY_BUS_INFORMATION] = "IRP_MN_QUERY_LEGACY_BUS_INFORMATION";

#define INCLUDE_POWER_FUNCTIONS_NAMES() \
    Powerfcnname[IRP_MN_WAIT_WAKE]      = "IRP_MN_WAIT_WAKE";\
    Powerfcnname[IRP_MN_POWER_SEQUENCE] = "IRP_MN_POWER_SEQUENCE";\
    Powerfcnname[IRP_MN_SET_POWER]      = "IRP_MN_SET_POWER";\
    Powerfcnname[IRP_MN_QUERY_POWER]    = "IRP_MN_QUERY_POWER";\
\
    Powersysstate[0]    = "PowerSystemUnspecified";\
    Powersysstate[1]    = "PowerSystemWorking";\
    Powersysstate[2]    = "PowerSystemSleeping1";\
    Powersysstate[3]    = "PowerSystemSleeping2";\
    Powersysstate[4]    = "PowerSystemSleeping3";\
    Powersysstate[5]    = "PowerSystemShutdown";\
    Powersysstate[6]    = "PowerSystemMaximum";\
\
    Powerdevstate[0]    = "PowerDeviceUnspecified";\
    Powerdevstate[1]    = "PowerDeviceD0";\
    Powerdevstate[2]    = "PowerDeviceD1";\
    Powerdevstate[3]    = "PowerDeviceD2";\
    Powerdevstate[4]    = "PowerDeviceD3";\
    Powerdevstate[5]    = "PowerDeviceMaximum";

#define INCLUDE_STATE_NAMES()   \
    statenames[0] = "STOPPED";\
    statenames[1] = "WORKING";\
    statenames[2] = "PENDINGSTOP";\
    statenames[3] = "PENDINGREMOVE";\
    statenames[4] = "SURPRISEREMOVED";\
    statenames[5] = "REMOVED";

#else

#define INCLUDE_PNP_FUNCTIONS_NAMES()
#define INCLUDE_POWER_FUNCTIONS_NAMES()
#define INCLUDE_STATE_NAMES()

#endif // DEBUG


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\gempc430\driver.h ===
// Gemplus (C) 1999
// This is main Driver object for the driver.
//
// Version 1.0
// Author: Sergey Ivanov
// Date of creation - 18.05.1999
// Change log:
//

#ifndef DRV_INT
#define DRV_INT

// System includes
#include "kernel.h"

#pragma PAGEDCODE
#ifdef __cplusplus
extern "C"{
#endif

NTSTATUS    DriverEntry(IN PDRIVER_OBJECT DriverObject,IN PUNICODE_STRING RegistryPath);
VOID WDM_Unload(IN PDRIVER_OBJECT DriverObject);

// WDM devices
LONG WDM_AddDevice(IN PDRIVER_OBJECT DriverObject,IN PDEVICE_OBJECT DeviceObject);
LONG WDM_Add_USBDevice(IN PDRIVER_OBJECT DriverObject,IN PDEVICE_OBJECT DeviceObject);
LONG WDM_Add_USBReader(IN PDRIVER_OBJECT DriverObject,IN PDEVICE_OBJECT DeviceObject);
LONG WDM_Add_Bus(IN PDRIVER_OBJECT DriverObject,IN PDEVICE_OBJECT DeviceObject);
NTSTATUS WDM_SystemControl(PDEVICE_OBJECT DeviceObject, PIRP Irp);


#ifdef __cplusplus
}
#endif

// already included
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\gempc430\debug.h ===
// Gemplus (C) 1999
// Version 1.0
// Author: Sergey Ivanov
// Date of creation - 18.05.1999
// Change log:
//
#ifndef DBG_INT
#define DBG_INT
#include "generic.h"

#pragma PAGEDCODE

class CDebug;
class CDebug
{
public:
	NTSTATUS m_Status;
	SAFE_DESTRUCTORS();
	virtual VOID dispose(){self_delete();};
protected:
	CDebug(){initializeUsage();};
public:
	virtual ~CDebug(){};

	/*Open(CDevice*) {};
	Close(CDevice*) {};
	CopyDebug(CDevice*) {};
	trace(...) {};
	*/
	virtual VOID	start() {};
	virtual VOID	stop()  {};
	virtual VOID	trace(PCH Format,... ) {};
	virtual VOID	trace_buffer(PVOID pBuffer,ULONG BufferLength) {};
	
	VOID	initializeUsage(){usage = 0;};
	LONG	incrementUsage(){return ++usage;};
	LONG	decrementUsage(){return --usage;};
protected:
	BOOL active;
private:
	LONG usage;
};	

#define TRACE	if(debug) debug->trace
#define TRACE_BUFFER	if(debug) debug->trace_buffer
#define DEBUG_START()	if(debug) debug->start()
#define DEBUG_STOP()	if(debug) debug->stop()


#endif//DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\cmbp0\cmbp0wdm.h ===
/*****************************************************************************
@doc            INT EXT
******************************************************************************
* $ProjectName:  $
* $ProjectRevision:  $
*-----------------------------------------------------------------------------
* $Source: z:/pr/cmbp0/sw/cmbp0.ms/rcs/cmbp0wdm.h $
* $Revision: 1.3 $
*-----------------------------------------------------------------------------
* $Author: WFrischauf $
*-----------------------------------------------------------------------------
* History: see EOF
*-----------------------------------------------------------------------------
*
* Copyright  2000 OMNIKEY AG
******************************************************************************/

#if !defined ( __CMMOB_WDM_DRV_H__ )
   #define __CMMOB_WDM_DRV_H__

   #include "WDM.H"

   #include "SMCLIB.H"
   #include "PCSC_CM.H"




//
//  Constants -----------------------------------------------------------------
//
   #undef DRIVER_NAME
   #define DRIVER_NAME              "CMMOB"
   #define SMARTCARD_POOL_TAG       'MOCS'

   #define CMMOB_MAX_DEVICE     0x02
   #define CARDMAN_MOBILE_DEVICE_NAME   L"\\Device\\CM_4000_0"

   #define CMMOB_VENDOR_NAME        "OMNIKEY"
   #define CMMOB_PRODUCT_NAME       "CardMan 4000"


   #define CMMOB_MAJOR_VERSION   3
   #define CMMOB_MINOR_VERSION   2
   #define CMMOB_BUILD_NUMBER       1

// reader states
   #define UNKNOWN    0xFFFFFFFF
   #define REMOVED    0x00000001
   #define INSERTED   0x00000002
   #define POWERED    0x00000004

   #define CMMOB_MAXBUFFER        262
   #define CMMOB_MAX_CIS_SIZE      256

// for protocol T=0
   #define T0_HEADER_LEN  0x05
   #define T0_STATE_LEN   0x02


typedef struct _DEVICE_EXTENSION
   {
   // Dos device name
   UNICODE_STRING       LinkDeviceName;


   // Our PnP device name
   UNICODE_STRING       PnPDeviceName;

   //memory has been mapped, and must be unmapped during cleanup (remove device)
   BOOLEAN              fUnMapMem;

   //device is opened by application (ScardSrv, CT-API)
   LONG                 lOpenCount;

   // Used to signal that the reader is able to process reqeusts
   KEVENT               ReaderStarted;

   // Used to signal that update thread can run
   KEVENT               CanRunUpdateThread;

   // Used to signal that all IO is complete
   KEVENT               OkToStop;

   // Used to signal that all pending IO should be cancelled
   KEVENT               CancelPendingIO;

   // incremented when any IO request is received
   // decremented when any IO request is completed or passed on
   LONG                 lIoCount;

   // Used to access IoCount;
   KSPIN_LOCK           SpinLockIoCount;

   //Bus drivers set the appropriate values in this structure in response
   //to an IRP_MN_QUERY_CAPABILITIES IRP. Function and filter drivers might
   //alter the capabilities set by the bus driver.
   DEVICE_CAPABILITIES  DeviceCapabilities;


   //attached DO
   PDEVICE_OBJECT       AttachedDeviceObject;

   //smartcard extension
   SMARTCARD_EXTENSION  SmartcardExtension;

   } DEVICE_EXTENSION, *PDEVICE_EXTENSION;



typedef struct _CARD_PARAMETERS
   {
   //
   // flag if card is synchronous card
   //
   BOOLEAN  fSynchronousCard;

   //
   // parameters for asynchronous cards
   //
   UCHAR    bBaudRateHigh;
   UCHAR    bBaudRateLow;

   UCHAR    bStopBits;

   UCHAR    bClockFrequency;

   //
   // flag if card uses invers revers convention
   //
   BOOLEAN  fInversRevers;

   //
   // flag if card reader is switched to T0 mode
   //
   BOOLEAN  fT0Mode;
   BOOLEAN  fT0Write;

   } CARD_PARAMETERS, *PCARD_PARAMETERS;


typedef enum _READER_POWER_STATE
   {
   PowerReaderUnspecified = 0,
   PowerReaderWorking,
   PowerReaderOff
   } READER_POWER_STATE, *PREADER_POWER_STATE;


typedef struct _READER_EXTENSION
   {

   //
   //   Mem address where the reader is configured.
   //
   PVOID       pIoBase;
   ULONG       ulIoWindow;

   PUCHAR      pbRegsBase;

   //
   //   Software revision ID of the firmware.
   //
   ULONG       ulFWVersion;

   //
   // for communication with UpdateCurrentStateThread
   //
   BOOLEAN     fTerminateUpdateThread;
   BOOLEAN     fUpdateThreadRunning;

   //
   // state of the reader
   //
   ULONG       ulOldCardState;
   ULONG       ulNewCardState;
   // only used for hibernation
   BOOLEAN     fCardPresent;

   //
   // parameters of inserted card
   //
   CARD_PARAMETERS     CardParameters;

   //
   // previous value of Flags1 register
   //
   UCHAR       bPreviousFlags1;


   // bit 9 of data buffer address
   UCHAR       bAddressHigh;

   // flag Tactive (access to RAM)
   BOOLEAN     fTActive;

   // flag ReadCIS (access to CIS)
   BOOLEAN     fReadCIS;


   //
   // mutex for access to CardMan
   //
   KMUTEX      CardManIOMutex;

   //
   // Handle of the update current state thread
   //
   PVOID       ThreadObjectPointer;

   //
   // Current reader power state.
   //
   READER_POWER_STATE ReaderPowerState;

   } READER_EXTENSION, *PREADER_EXTENSION;

//
//  Extern declarations -----------------------------------------------------------------
//
extern BOOLEAN DeviceSlot[];


//
//  Functions -----------------------------------------------------------------
//


void SysDelay( ULONG Timeout );


NTSTATUS DriverEntry(
                    PDRIVER_OBJECT DriverObject,
                    PUNICODE_STRING   RegistryPath
                    );

NTSTATUS CMMOB_CreateDevice(
                           IN  PDRIVER_OBJECT DriverObject,
                           IN  PDEVICE_OBJECT PhysicalDeviceObject,
                           OUT PDEVICE_OBJECT *DeviceObject
                           );

VOID CMMOB_SetVendorAndIfdName(
                              IN  PDEVICE_OBJECT PhysicalDeviceObject,
                              IN  PSMARTCARD_EXTENSION SmartcardExtension
                              );

NTSTATUS CMMOB_StartDevice(
                          PDEVICE_OBJECT DeviceObject,
                          PCM_FULL_RESOURCE_DESCRIPTOR FullResourceDescriptor
                          );

VOID CMMOB_StopDevice(
                     PDEVICE_OBJECT DeviceObject
                     );

VOID CMMOB_UnloadDevice(
                       PDEVICE_OBJECT DeviceObject
                       );

VOID CMMOB_UnloadDriver(
                       PDRIVER_OBJECT DriverObject
                       );

NTSTATUS CMMOB_Cleanup(
                      PDEVICE_OBJECT DeviceObject,
                      PIRP Irp
                      );

NTSTATUS CMMOB_CreateClose(
                          PDEVICE_OBJECT DeviceObject,
                          PIRP Irp
                          );

NTSTATUS CMMOB_DeviceIoControl(
                              PDEVICE_OBJECT DeviceObject,
                              PIRP Irp
                              );

NTSTATUS CMMOB_SystemControl(
                            PDEVICE_OBJECT DeviceObject,
                            PIRP        Irp
                            );

NTSTATUS IncIoCount(
    PDEVICE_EXTENSION DevExt
    );
NTSTATUS DecIoCount(
    PDEVICE_EXTENSION DevExt
    );
NTSTATUS DecIoCountAndWait(
    PDEVICE_EXTENSION DevExt
    );


#endif  // __CMMOB_WDM_DRV_H__
/*****************************************************************************
* History:
* $Log: cmbp0wdm.h $
* Revision 1.3  2000/07/27 13:53:07  WFrischauf
* No comment given
*
*
******************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\gempc430\driver.cpp ===
//-------------------------------------------------------------------
// This is driver object
// It defines interface with specific system
// Author: Sergey Ivanov
// Log:
//      06/08/99    -   implemented 
//-------------------------------------------------------------------
#include "driver.h"

#ifdef WDM_KERNEL
#pragma message("******** WDM build... ********")
#endif

#include "usbreader.h"

// Walter Oney
// @func Determine if we're running under Windows 98 or Windows 2000
// @rdesc TRUE if running under Windows 98, FALSE if under Windows 2000
// @comm This function calls IoIsWdmVersionAvailable to see if the OS
// supports WDM version 1.10. Win98 and Win98 2d ed support 1.00, whereas
// Win2K supports 1.10.

#pragma PAGEDCODE

BOOLEAN GENERIC_EXPORT isWin98()
{                           // IsWin98
#ifdef _X86_
    return !IoIsWdmVersionAvailable(1, 0x10);
#else
    return FALSE;
#endif // _X86_
}// IsWin98

#pragma LOCKEDCODE

#if DEBUG && defined(_X86_)

extern "C" VOID __declspec(naked) __cdecl _chkesp()
{
    _asm je okay
    ASSERT(!DRIVERNAME " - Stack pointer mismatch!");
okay:
    _asm ret
}

#endif // DBG

// This will fix some linker problem
int __cdecl _purecall(VOID) {return 0;};

#pragma LOCKEDDATA
BOOLEAN SystemWin98 = TRUE;
ULONG   ObjectCounter = 0;

#pragma INITCODE
// Driver main entry...(Actually, it could have any name...)
NTSTATUS    DriverEntry(PDRIVER_OBJECT DriverObject,PUNICODE_STRING RegistryPath)
{
    DBG_PRINT ("\n");
    DBG_PRINT ("*** DriverEntry: DriverObject %8.8lX ***\n", DriverObject);

    if(SystemWin98 = isWin98())
    {
        DBG_PRINT("========  WINDOWS 98 DETECTED ========\n");
    }
    else
        DBG_PRINT("========  WINDOWS 2000 DETECTED ========\n");
    // Create driver kernel...
#pragma message("********** Compiling WDM driver version *********")
    DBG_PRINT ("        Loading WDM kernel\n");
    kernel = CKernel::loadWDMKernel();
    if(!kernel)
    {
        // LOG ERROR!
        DBG_PRINT ("ERROR: At loading WDM kernel! ***\n");
        return STATUS_UNSUCCESSFUL;
    }
    
    DBG_PRINT ("        Creating unicode string for registry path...\n");
    
    kernel->RegistryPath = new (NonPagedPool)CUString(RegistryPath);
    if (!ALLOCATED_OK(kernel->RegistryPath))
    {
        // LOG ERROR!
        DISPOSE_OBJECT(kernel->RegistryPath);
        DISPOSE_OBJECT(kernel);
        DBG_PRINT ("ERROR: At allocating WDM registry path! ***\n");
        return STATUS_UNSUCCESSFUL;
    }

    DBG_PRINT ("        Registering WDM system callbacks\n");

    DriverObject->DriverExtension->AddDevice            = WDM_AddDevice;
    DriverObject->DriverUnload                          = WDM_Unload;

    DriverObject->MajorFunction[IRP_MJ_CREATE]          = open;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]           = close;

    DriverObject->MajorFunction[IRP_MJ_WRITE]           = write;
    DriverObject->MajorFunction[IRP_MJ_READ]            = read;
    // The mechanism for handling read and write requests for a device that uses
    // interrupts includes a Start I/O routine, an interrupt service routine, and
    // a deferred procedure call routine that finishes handling interrupts. We
    // need to supply the StartIo routine address here.
    //DriverObject->DriverStartIo = startIo;

    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL]  = WDM_SystemControl;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]  = deviceControl;
    DriverObject->MajorFunction[IRP_MJ_PNP]             = pnpRequest;
    DriverObject->MajorFunction[IRP_MJ_POWER]           = powerRequest;

    DriverObject->MajorFunction[IRP_MJ_FLUSH_BUFFERS]   = flush;
    DriverObject->MajorFunction[IRP_MJ_CLEANUP]         = cleanup;

    DBG_PRINT ("**** Driver was initialized successfully! ****\n");

    return STATUS_SUCCESS;
}

NTSTATUS
WDM_SystemControl(
   PDEVICE_OBJECT DeviceObject,
   PIRP        Irp
   )
{
   NTSTATUS status = STATUS_SUCCESS;
   CDevice *device;

   device = kernel->getRegisteredDevice(DeviceObject);

   IoSkipCurrentIrpStackLocation(Irp);
   status = IoCallDriver(device->getLowerDriver(), Irp);
      
   return status;

}

#pragma PAGEDCODE
VOID WDM_Unload(IN PDRIVER_OBJECT DriverObject)
{   
    PAGED_CODE();

    DBG_PRINT ("\n*** Unload: Driver %8.8lX ***\n", DriverObject);
    kernel->dispose();
    DBG_PRINT("*** Object counter before unload %d\n",ObjectCounter);

    DBG_PRINT (">>>>>>> All active devices were removed! Driver was unloaded! <<<<<<\n");
} 


#pragma PAGEDCODE

// C wrapper functions for driver object
LONG WDM_AddDevice(IN PDRIVER_OBJECT DriverObject,IN PDEVICE_OBJECT DeviceObject)
{
NTSTATUS status = STATUS_UNSUCCESSFUL;
    // Get registry about device type installation
    // switch depends of device.
    // Create device object
    // Check device type and create device specific objects
    // like serial, usb, PCMCIA and so on...
    // Specific objects can overwrite base class functions.
    // For now we will create USB device object
    //TODO recognize device type dinamically...


#pragma message("********** Compiling USB READER driver version *********")
    //status = WDM_Add_USBDevice(DriverObject,DeviceObject);
    DBG_PRINT ("Adding USB reader...\n");
    status = WDM_Add_USBReader(DriverObject,DeviceObject);
    return status;
}


// We decided to support different devices at system...
// It requires to have different callback functions for different devices.
// So let's create wrappers and redirect requests to specific devices.

// CALLBACK WRAPPER FUNCTIONS
// This callbacks should be defined at any device object
#pragma LOCKEDCODE
IMPLEMENT_CALLBACK_LONG1(open,IN PIRP);
IMPLEMENT_CALLBACK_LONG1(close,IN PIRP);

IMPLEMENT_CALLBACK_LONG1(read,IN PIRP);
IMPLEMENT_CALLBACK_LONG1(write,IN PIRP);
IMPLEMENT_CALLBACK_VOID1(startIo,IN PIRP);
IMPLEMENT_CALLBACK_LONG1(deviceControl,IN PIRP);
IMPLEMENT_CALLBACK_LONG1(flush,IN PIRP);
IMPLEMENT_CALLBACK_LONG1(cleanup,IN PIRP);
IMPLEMENT_CALLBACK_LONG1(powerRequest,IN PIRP);

// Support callbacks
IMPLEMENT_CALLBACK_VOID1(cancelPendingIrp,IN PIRP);

#pragma LOCKEDCODE
NTSTATUS pnpRequest(IN PDEVICE_OBJECT fdo,IN PIRP Irp)
{
CDevice* device;
//CUSBReader* device;// TO CHANGE LATER....
NTSTATUS status;
PIO_STACK_LOCATION stack = IoGetCurrentIrpStackLocation(Irp);
ULONG MinorFunction = stack->MinorFunction;

    //device = (CUSBReader*) kernel->getRegisteredDevice(fdo);// TO CHANGE LATER....
    device = kernel->getRegisteredDevice(fdo);// TO CHANGE LATER....
    if(!device) 
    {
        DBG_PRINT ("*** PnP: Device was already removed...***\n");
        Irp->IoStatus.Status = STATUS_INVALID_DEVICE_STATE;
        Irp->IoStatus.Information = 0;
        ::IoCompleteRequest(Irp,IO_NO_INCREMENT);
        return STATUS_INVALID_DEVICE_STATE;
    }
    
    status = device->pnpRequest(Irp);

    if(MinorFunction == IRP_MN_REMOVE_DEVICE)
    {
        //Child devices will be removed by BUS...
        if(device->getObjectType()!= CHILD_DEVICE)
        {
            PDEVICE_OBJECT DeviceObject = device->getSystemObject();
            // Sometimes Unload can interrupt standard PnP sequence 
            // and remove device before we finish...
            DBG_PRINT ("*** PnP: Disposing device -> %8.8lX ***\n", device);
            device->dispose();
            if(DeviceObject)
            {            
                DBG_PRINT("Deleting device object %8.8lX from system...\n",DeviceObject);
                DBG_PRINT("<<<<< OBJECT REFERENCE COUNT ON REMOVE %d\n",DeviceObject->ReferenceCount);
                IoDeleteDevice(DeviceObject);
            }
        }
    }
    return  status;
}

#pragma PAGEDCODE
LONG WDM_Add_USBReader(IN PDRIVER_OBJECT DriverObject,IN PDEVICE_OBJECT DeviceObject)
{
NTSTATUS status;
WCHAR wcTemp[256];
ULONG junk;
    
    CLogger* logger = kernel->getLogger();

    DBG_PRINT("*** AddDevice: DriverObject %8.8lX, DeviceObject %8.8lX ***\n", DriverObject, DeviceObject);
    DBG_PRINT("     Creating WDM USB reader...\n");
    CUSBReader* reader = kernel->createUSBReader();
    if(ALLOCATED_OK(reader))    
    {
        reader->acquireRemoveLock();
        DBG_PRINT ("Call USB reader object to add the reader...\n");
        status = reader->add(DriverObject,DeviceObject);
        if(!NT_SUCCESS(status))     
        {
            DBG_PRINT ("###### Add() reports error! Disposing reader...\n");            
            reader->dispose();
            return status;
        }
        else//Register our device object and device class
        {
            DBG_PRINT ("        Registering new reader %8.8lX at kernel...\n",reader);
            //kernel->registerObject(reader->getSystemObject(),(CDevice*)reader);
            kernel->registerObject(reader->getSystemObject(),(CUSBReader*)reader);
        }
        
        {
        CUString*   ustrTmp;
        ANSI_STRING astrTmp;
        UNICODE_STRING valname;
        ULONG size = 0;
        HANDLE hkey;

            DBG_PRINT ("=====================================================\n");
            // Set default values..
            reader->setVendorName("Gemplus",sizeof("Gemplus"));
            reader->setDeviceType("GemPC430",sizeof("GemPC430"));

            // Get Hardware ID
            status = IoGetDeviceProperty(DeviceObject, DevicePropertyHardwareID, sizeof(wcTemp), wcTemp, &junk);
            if(NT_SUCCESS(status))      
            {
                DBG_PRINT("  Device Hardware ID  - %ws\n", wcTemp);
            }

            status = IoGetDeviceProperty(DeviceObject, DevicePropertyDeviceDescription, sizeof(wcTemp), wcTemp, &junk);
            if(NT_SUCCESS(status))      
            {
                DBG_PRINT("  Device description  - %ws\n", wcTemp);
            }           
            
            status = IoGetDeviceProperty(DeviceObject, DevicePropertyManufacturer, sizeof(wcTemp), wcTemp, &junk);
            if(NT_SUCCESS(status))      
            {
                DBG_PRINT("  Device Manufacturer - %ws\n", wcTemp);
            }

            // Get OEM IfdType if present
            status = IoOpenDeviceRegistryKey(DeviceObject, PLUGPLAY_REGKEY_DEVICE, KEY_READ, &hkey);
            if (NT_SUCCESS(status))
            {
                // Get Vendor name...
                RtlInitUnicodeString(&valname, L"VendorName");
                size = 0;
                status = ZwQueryValueKey(hkey, &valname, KeyValuePartialInformation, NULL, 0, &size);
                if (status != STATUS_OBJECT_NAME_NOT_FOUND && size)
                {
                    PKEY_VALUE_PARTIAL_INFORMATION vpip = (PKEY_VALUE_PARTIAL_INFORMATION) ExAllocatePool(NonPagedPool, size);
                    if(vpip)
                    {
                        status = ZwQueryValueKey(hkey, &valname, KeyValuePartialInformation, vpip, size, &size);
                        if (NT_SUCCESS(status))
                        {
                            DBG_PRINT(" OEM Vendor name found - '%ws' \n", vpip->Data);
                            // Copy string into the driver...
                            ustrTmp = new(NonPagedPool) CUString((PWCHAR)vpip->Data);
                            if(ALLOCATED_OK(ustrTmp))
                            {
                                RtlUnicodeStringToAnsiString(&astrTmp,&ustrTmp->m_String,TRUE);
                                reader->setVendorName(astrTmp.Buffer,astrTmp.Length);
                                RtlFreeAnsiString(&astrTmp);
                            }
                            DISPOSE_OBJECT(ustrTmp);
                        }
                        ExFreePool(vpip);
                    }
                }
            
                // Get IfdType...
                RtlInitUnicodeString(&valname, L"IfdType");
                size = 0;
                status = ZwQueryValueKey(hkey, &valname, KeyValuePartialInformation, NULL, 0, &size);
                if (status != STATUS_OBJECT_NAME_NOT_FOUND && size)
                {
                    PKEY_VALUE_PARTIAL_INFORMATION vpip = (PKEY_VALUE_PARTIAL_INFORMATION) ExAllocatePool(NonPagedPool, size);
                    if(vpip)
                    {
                        status = ZwQueryValueKey(hkey, &valname, KeyValuePartialInformation, vpip, size, &size);
                        if (NT_SUCCESS(status))
                        {
                            DBG_PRINT(" OEM IfdType found - '%ws' \n", vpip->Data);
                            // Copy string into the driver...
                            ustrTmp = new(NonPagedPool) CUString((PWCHAR)vpip->Data);
                            if(ALLOCATED_OK(ustrTmp))
                            {
                                RtlUnicodeStringToAnsiString(&astrTmp,&ustrTmp->m_String,TRUE);
                                reader->setDeviceType(astrTmp.Buffer,astrTmp.Length);
                                RtlFreeAnsiString(&astrTmp);
                            }
                            DISPOSE_OBJECT(ustrTmp);
                        }
                        ExFreePool(vpip);
                    }
                }

                ZwClose(hkey);
            }
            DBG_PRINT ("=====================================================\n");

        }
        status = STATUS_SUCCESS;
        DBG_PRINT("**** Initializing SmartCardSystem...  ****\n");          
        reader->initializeSmartCardSystem();

        DBG_PRINT("**** Creating reader interface type %d, protocol %d ****\n",READER_INTERFACE_GEMCORE,READER_PROTOCOL_LV);            
        if(!reader->createInterface(READER_INTERFACE_GEMCORE,READER_PROTOCOL_LV,reader))
        {
            DBG_PRINT("**** Failed to create reader interface...  ****\n");         
            if(ALLOCATED_OK(logger)) logger->logEvent(GRCLASS_FAILED_TO_CREATE_INTERFACE,DeviceObject);
            //Close and unregister reader...
            reader->dispose();
            return STATUS_UNSUCCESSFUL;
        }

        DBG_PRINT("**** USB reader successfuly loaded!  ****\n");           
        reader->releaseRemoveLock();
        //if(ALLOCATED_OK(logger)) logger->logEvent(GRCLASS_START_OK, reader->getSystemObject());
        return status;
    }
    else
    {
        DISPOSE_OBJECT(reader);
        DBG_PRINT("#### Failed to create USB reader...\n");         
        if(ALLOCATED_OK(logger)) logger->logEvent(GRCLASS_FAILED_TO_CREATE_READER,DeviceObject);
    }
    return STATUS_UNSUCCESSFUL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\gempc430\event.h ===
// Gemplus (C) 1999
// Version 1.0
// Author: Sergey Ivanov
// Date of creation - 18.05.1999
// Change log:
//
#ifndef EV_INT
#define EV_INT
#include "generic.h"

#pragma PAGEDCODE
class CEvent
{
public:
	NTSTATUS m_Status;
	SAFE_DESTRUCTORS();
	virtual VOID dispose(){self_delete();};
protected:
	CEvent(){};
	virtual ~CEvent(){};
public:
	
	virtual VOID		initialize(IN PRKEVENT Event,IN EVENT_TYPE Type,IN BOOLEAN State) {};
	virtual VOID		clear(PRKEVENT Event) {};
	virtual LONG		reset(PRKEVENT Event) {return 0;};
	virtual LONG		set(PRKEVENT Event,IN KPRIORITY Increment,IN BOOLEAN Wait) {return 0;};

	virtual NTSTATUS	waitForSingleObject (PVOID Object,
							KWAIT_REASON WaitReason,KPROCESSOR_MODE WaitMode,
							BOOLEAN Alertable,
							PLARGE_INTEGER Timeout) {return STATUS_SUCCESS;};

	virtual NTSTATUS	waitForMultipleObjects(ULONG Count,
							PVOID Object[],
							WAIT_TYPE WaitType,
							KWAIT_REASON WaitReason,
							KPROCESSOR_MODE WaitMode,
							BOOLEAN Alertable,
							PLARGE_INTEGER Timeout,
							PKWAIT_BLOCK WaitBlockArray) {return STATUS_SUCCESS;};
	
};	

#endif//EVENT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\gempc430\gemcore.h ===
//-------------------------------------------------------------------
// This is abstract class for generic device
// Specific devices should use it as a parent device
// Author: Sergey Ivanov
// Log:
//		08/11/99	-	implemented	
//-------------------------------------------------------------------
#ifndef __GEMCORE__
#define __GEMCORE__

#include "interface.h"
#include "rdrconfig.h"

// Reader max buffer size
#define READER_DATA_BUFFER_SIZE  255

// Tells that power command was used 
#define GEMCORE_CARD_POWER	1

//
// DEFAULT_POWER_TIMEOUT defines the default power timout in ms.
//
#define GEMCORE_DEFAULT_POWER_TIMEOUT	750


#define GEMCORE_CARD_POWER_DOWN	0x11
#define GEMCORE_CARD_POWER_UP	0x12
#define GEMCORE_CARD_READ		0x13
#define GEMCORE_CARD_WRITE		0x14
#define GEMCORE_CARD_EXCHANGE	0x15
#define GEMCORE_DEFINE_CARD_TYPE	0x17
#define GEMCORE_GET_CARD_STATUS		0x17// Commands differs only by parameter...

#define GEMCORE_GET_FIRMWARE_VERSION "\x22\x05\x3F\xE0\x10"
#define GEMCORE_READER_SET_MODE	     0x01

// Card configuration
#define  ISO_CARD                   0x02
#define  TRANSPARENT_MODE_CARD      0xEF
#define  DEFAULT_PRESENCE_DETECTION 0x0D
#define  CARD_DEFAULT_VPP           0

#define CARD_VOLTAGE_5V				0
#define CARD_VOLTAGE_3V 			1
#define CARD_DEFAULT_VOLTAGE		CARD_VOLTAGE_5V

// PTS mode parameters
#define PTS_MODE_DEFAULT			0
#define PTS_MODE_DISABLED			1
#define PTS_MODE_OPTIMAL   			2
#define PTS_MODE_MANUALLY			3

#define PTS_NEGOTIATE_PTS1			0x10
#define PTS_NEGOTIATE_PTS2			0x20
#define PTS_NEGOTIATE_PTS3			0x40

#define PTS_NEGOTIATE_T0			0x00
#define PTS_NEGOTIATE_T1			0x01

//   - ICC_DEFAULT_POWER_TIMOUT defines the default power timout in ms.
#define ICC_DEFAULT_POWER_TIMOUT     750

#pragma PAGEDCODE

class  CIoPacket;

class CGemCore : public CReaderInterface
{
public:
    NTSTATUS m_Status;
	SAFE_DESTRUCTORS();
private:
ReaderConfig configuration;
protected:
	CGemCore(){};
public:
	CGemCore(CProtocol* protocol) : CReaderInterface(protocol)
	{ 
		TRACE("Gemcore Reader Interface was created with protocol %x \n",protocol);
	  // These values went from Gemcore portocol
	  // Lets leave it for now, but eventually we could 
	  // redefine them creating Gemcore independent
	  // reader configuration
	  configuration.Type		= ISO_CARD;//ISO_CARD (02)
	  configuration.PresenceDetection = DEFAULT_PRESENCE_DETECTION;//DEFAULT_PRESENCE_DETECTION (0D)
	  configuration.Voltage	= CARD_DEFAULT_VOLTAGE;  //CARD_DEFAULT_VOLTAGE;
	  configuration.PTSMode	    = PTS_MODE_DISABLED;  //PTS_MODE_DISABLED;
	  configuration.PTS0		= 0;
	  configuration.PTS1		= 0;
	  configuration.PTS2		= 0;
	  configuration.PTS3		= 0;
	  configuration.Vpp		    = 0;  //CARD_DEFAULT_VPP;
	  configuration.ActiveProtocol = 0;// Undefined
	  configuration.PowerTimeOut = GEMCORE_DEFAULT_POWER_TIMEOUT;
	  m_Status = STATUS_SUCCESS;
	};

	virtual ~CGemCore()
	{ 
		TRACE("GemCore Reader Interface %8.8lX was destroied...\n",this);
	};

	virtual VOID dispose()
	{
		self_delete();
	};


	static CReaderInterface*  create(CProtocol* protocol)
	{ 
		CReaderInterface* interface = new (NonPagedPool) CGemCore(protocol); 
		if(!ALLOCATED_OK(interface))
		{
			DISPOSE_OBJECT(interface);
			interface = NULL;
		}
		return interface; 
	};


	virtual  NTSTATUS	translateStatus( const BYTE  ReaderStatus, const ULONG IoctlType);

	virtual  ULONG     getReaderState();
	virtual  NTSTATUS  getReaderVersion(PUCHAR pVersion, PULONG pLength);
	virtual  NTSTATUS  setReaderMode(ULONG mode);
	virtual  NTSTATUS  initialize();


	// Reader interface functions...
	virtual  ReaderConfig	getConfiguration();
	virtual  NTSTATUS setConfiguration(ReaderConfig configuration);
	virtual  NTSTATUS  setTransparentConfig(PSCARD_CARD_CAPABILITIES cardCapabilities, BYTE NewWtx);
	virtual  VOID RestoreISOsetting(VOID);
	
	virtual  NTSTATUS read(CIoPacket* Irp);
	virtual  NTSTATUS write(CIoPacket* Irp);
	virtual  NTSTATUS readAndWait(BYTE * pRequest,ULONG RequestLength,BYTE * pReply,ULONG* pReplyLength);
	virtual  NTSTATUS writeAndWait(BYTE * pRequest,ULONG RequestLength,BYTE * pReply,ULONG* pReplyLength);
    virtual  NTSTATUS ioctl(ULONG ControlCode,BYTE* pRequest,ULONG RequestLength,BYTE* pReply,ULONG* pReplyLength);
	virtual  NTSTATUS SwitchSpeed(ULONG ControlCode,BYTE* pRequest,ULONG RequestLength,BYTE* pReply,ULONG* pReplyLength);
	virtual  NTSTATUS VendorAttribute(ULONG ControlCode,BYTE* pRequest,ULONG RequestLength,BYTE* pReply,ULONG* pReplyLength);
    virtual  NTSTATUS power(ULONG ControlCode,BYTE* pReply,ULONG* pReplyLength, BOOLEAN Specific);
	virtual  NTSTATUS powerUp(BYTE* pReply,ULONG* pReplyLength);
	virtual  NTSTATUS setProtocol(ULONG ProtocolRequested);
	virtual  VOID	  cancel();
	// Process smartcard requests according to reader capabilities
	virtual  NTSTATUS translate_request(BYTE * pRequest,ULONG RequestLength,BYTE * pReply,ULONG* pReplyLength, PSCARD_CARD_CAPABILITIES cardCapabilities, BYTE NewWtx);
	virtual  NTSTATUS translate_response(BYTE * pRequest,ULONG RequestLength,BYTE * pReply,ULONG* pReplyLength);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\gempc430\guid.h ===
/*++
 The below GUID is used to generate symbolic links to
  driver instances created from user mode
--*/
#ifndef GUID_INC
#define GUID_INC

#ifdef __cplusplus
extern "C"{
#endif

#include <smclib.h>
#include <initguid.h>


// {8C7F3D60-FC17-11d2-B669-0008C7606FEB} for GRUSB.SYS
DEFINE_GUID(GUID_CLASS_GRCLASS, 
0x8c7f3d60, 0xfc17, 0x11d2, 0xb6, 0x69, 0x0, 0x8, 0xc7, 0x60, 0x6f, 0xeb);

//SmartCardReaderGuid
DEFINE_GUID(GUID_CLASS_SMARTCARD, 
0x50DD5230, 0xBA8A, 0x11D1, 0xBF, 0x5D, 0x00, 0x00, 0xF8, 0x05, 0xF5, 0x30);

#ifdef __cplusplus
}
#endif

#endif // end, #ifndef GUID_INC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\gempc430\gemcore.cpp ===
#include "gemcore.h"
#include "iopack.h"

#pragma PAGEDCODE

NTSTATUS CGemCore::read(CIoPacket* Irp)
{
NTSTATUS status;
ULONG ReplyLength;
	ReplyLength = Irp->getReadLength();
	
	TRACE("GemCore read requested...\n");

	status = readAndWait((PUCHAR)Irp->getBuffer(),Irp->getReadLength(),(PUCHAR)Irp->getBuffer(),&ReplyLength);
	if(!NT_SUCCESS(status)) ReplyLength = 0;
	Irp->setInformation(ReplyLength);

	TRACE("GemCore read response:\n");
	//TRACE_BUFFER(Irp->getBuffer(),ReplyLength);
	
	return status;
}

#pragma PAGEDCODE
NTSTATUS CGemCore::write(CIoPacket* Irp)
{
NTSTATUS status;
ULONG ReplyLength;
	ReplyLength = Irp->getWriteLength();
	
	TRACE("GemCore write requested...\n");
	//TRACE_BUFFER(Irp->getBuffer(),Irp->getWriteLength());

	status = writeAndWait((PUCHAR)Irp->getBuffer(),Irp->getReadLength(),(PUCHAR)Irp->getBuffer(),&ReplyLength);
	if(!NT_SUCCESS(status)) ReplyLength = 0;
	Irp->setInformation(ReplyLength);

	TRACE("GemCore write response:\n");
	//TRACE_BUFFER(Irp->getBuffer(),ReplyLength);
	return status;
}

#pragma PAGEDCODE
// Reader interface functions...
NTSTATUS CGemCore::readAndWait(BYTE * pRequest,ULONG RequestLength,BYTE * pReply,ULONG* pReplyLength)
{
ULONG length;
ULONG BufferLength;
BOOL  extendedCommand;
ULONG replyLength;
ULONG expectedReplyLength;	
ULONG replyBufferPosition = 0;

	if(!RequestLength || !pRequest || !pReply || !pReplyLength  || RequestLength<5)
		return STATUS_INVALID_PARAMETER;

	length = pRequest[4];
	if (!length || (length > READER_DATA_BUFFER_SIZE - 3))
	{
		// If the length is lower or equal to 252 (255 - (<IFD Status> + <SW1> + <SW2>))
		// (standard OROS cmds)
		extendedCommand = TRUE;
		TRACE("******** EXTENDED COMMAND REQUESTED! ");
		TRACE_BUFFER(pRequest,RequestLength);

		if(!length) length = 256;
		expectedReplyLength = length;
	}
	else	extendedCommand = FALSE;


	pOutputBuffer[0] = GEMCORE_CARD_READ;
	memory->copy(pOutputBuffer+1,pRequest,5);
	length = 6;
	BufferLength = InputBufferLength;
	NTSTATUS status = protocol->writeAndWait(pOutputBuffer,length,pInputBuffer,&BufferLength);			
	if(!NT_SUCCESS(status) || !BufferLength)
	{
		*pReplyLength = 0;
		return status;
	}
	status = translateStatus(pInputBuffer[0],0);
	if(!NT_SUCCESS(status))
	{
		*pReplyLength = 0;
		return status;
	}

	// Extended command valid only if card reports 0 status!
	if(pInputBuffer[0]!=0)
	{
		extendedCommand = FALSE;
	}
	// ISV: If card finish Xfer, do not send send second part of the command!
	// This will fix CyberFlex card problem...
	if(extendedCommand && BufferLength==3)
	{
		TRACE("******** EXTENDED COMMAND CANCELLED BY CARD REPLY!\n");
		extendedCommand = FALSE;
	}
	
	// Skip status byte
	replyLength = BufferLength - 1;	
	if(extendedCommand)
	{
		// Copy first part of the reply to the output buffer...
		// Skip status byte.
		if(*pReplyLength<(replyBufferPosition + replyLength))
		{
			*pReplyLength = 0;
			return STATUS_INVALID_BUFFER_SIZE;
		}
		memory->copy(pReply,pInputBuffer+1, replyLength);
		replyBufferPosition = replyLength;

		// Read second block of data...
		pOutputBuffer[0] = GEMCORE_CARD_READ;
		memory->copy(pOutputBuffer+1,"\xFF\xFF\xFF\xFF", 4);
        	pOutputBuffer[5] = (BYTE ) (expectedReplyLength - replyLength);
		length = 6;
		BufferLength = InputBufferLength;
		status = protocol->writeAndWait(pOutputBuffer,length,pInputBuffer,&BufferLength);			
		if(!NT_SUCCESS(status) || !BufferLength)
		{
			*pReplyLength = 0;
			return status;
		}

		status = translateStatus(pInputBuffer[0],0);
		if(!NT_SUCCESS(status))
		{
			*pReplyLength = 0;
			return status;
		}
		// Skip status byte.
		replyLength = BufferLength - 1;	
	}
	
	if(*pReplyLength<(replyBufferPosition + replyLength))
	{

		TRACE("Gemcore: INVALID BUFFER LENGTH - buffer length %d, reply length %d\n",*pReplyLength,(replyBufferPosition + replyLength));
		*pReplyLength = 0;
		return STATUS_INVALID_BUFFER_SIZE;
	}
	// Skip status byte.
	if(replyLength) memory->copy(pReply+replyBufferPosition,pInputBuffer+1, replyLength);
	*pReplyLength = replyBufferPosition + replyLength;

	TRACE("GemCore readAndWait() response with Length %d \n",*pReplyLength);
	//TRACE_BUFFER(pReply,*pReplyLength);

	return status;
}

#pragma PAGEDCODE
NTSTATUS CGemCore::writeAndWait(BYTE * pRequest,ULONG RequestLength,BYTE * pReply,ULONG* pReplyLength)
{
ULONG length;
ULONG BufferLength;
NTSTATUS status;

	TRACE("\nGEMCORE WRITE:\n");
	//TRACE_BUFFER(pRequest,RequestLength);
	if(!RequestLength || !pRequest || RequestLength<5)
	{
		TRACE("\nGEMCORE WRITE: INVALID IN PARAMETERS...\n");
		return STATUS_INVALID_PARAMETER;
	}

	length = pRequest[4];
	if(RequestLength<length+5)
	{
		TRACE("\nGEMCORE WRITE: INVALID REQUESTED LENGTH...\n");
		return STATUS_INVALID_PARAMETER;
	}
	
	if (length > READER_DATA_BUFFER_SIZE - 7)
	{
        // If the length is lower or equal than the extended available space (255)
        // Prepare and send the first part of the extended ISO In command:
        // The five command bytes are added in cmd buffer: 0xFF,0xFF,0xFF,0xFF,LN-248
		// Read second block of data...
 		pOutputBuffer[0] = GEMCORE_CARD_WRITE;
		memory->copy(pOutputBuffer+1,"\xFF\xFF\xFF\xFF", 4);
		length = length - (READER_DATA_BUFFER_SIZE - 7);
		pOutputBuffer[5] = (BYTE )length;
		memory->copy(pOutputBuffer+6,pRequest + 5 + 248, length);
		// Add size of header...
		length += 6;
		BufferLength = InputBufferLength;
		status = protocol->writeAndWait(pOutputBuffer,length,pInputBuffer,&BufferLength);			
		if(!NT_SUCCESS(status) || !BufferLength)
		{
			return status;
		}

		if(!NT_SUCCESS(status))
		{
			return status;
		}
		// NOW prepare and send the Second part of the extended ISO In command:
        // The five command bytes are added in cmd buffer.
        // The data field is added (248 bytes).
        // The command is sent to IFD.
		// Now set length to first block of data...
		length = 248;
	}
 	
	pOutputBuffer[0] = GEMCORE_CARD_WRITE;
	memory->copy(pOutputBuffer+1,pRequest,4);
	pOutputBuffer[5] = pRequest[4]; // Warning you must specified full APDU length
	memory->copy(pOutputBuffer+6,pRequest+5, length);
	// Add size of header...
	length += 6;
	BufferLength = InputBufferLength;
	status = protocol->writeAndWait(pOutputBuffer,length,pInputBuffer,&BufferLength);			
	if(!NT_SUCCESS(status) || !BufferLength)
	{
		*pReplyLength = 0;
		return status;
	}
	status = translateStatus(pInputBuffer[0],0);
	if(!NT_SUCCESS(status))
	{
		*pReplyLength = 0;
		return status;
	}

	// Skip status byte.
	length = BufferLength - 1;	
	if(*pReplyLength<length)
	{
		*pReplyLength = 0;
		return STATUS_INVALID_BUFFER_SIZE;
	}
	// Skip status byte.
	if(length) memory->copy(pReply,pInputBuffer+1, length);
	*pReplyLength = length;
	
	TRACE("GemCore writeAndWait() response\n");
	//TRACE_BUFFER(pReply,*pReplyLength);
	return status;
}

#pragma PAGEDCODE
ReaderConfig	CGemCore::getConfiguration()
{
	return configuration;
}

#pragma PAGEDCODE
NTSTATUS CGemCore::setConfiguration(ReaderConfig configuration)
{
	this->configuration = configuration;
	return STATUS_SUCCESS;
}

#pragma PAGEDCODE
NTSTATUS CGemCore::ioctl(ULONG ControlCode,BYTE* pRequest,ULONG RequestLength,BYTE* pReply,ULONG* pReplyLength)
{
	ULONG length;
	ULONG BufferLength;
	NTSTATUS status;

	TRACE("\nGEMCORE VendorIOCTL:\n");
	//TRACE_BUFFER(pRequest,RequestLength);
	if(!RequestLength || !pRequest)
	{
		TRACE("\nGEMCORE IOCTL: INVALID IN PARAMETERS...\n");
		*pReplyLength = 0;
		return STATUS_INVALID_PARAMETER;
	}

	memory->copy(pOutputBuffer,pRequest, RequestLength);

	// Send direct gemcore command
	BufferLength = InputBufferLength;

	status = protocol->writeAndWait(pOutputBuffer,RequestLength,pInputBuffer,&BufferLength);

	if(!NT_SUCCESS(status) || !BufferLength)
	{
		*pReplyLength = 0;
		return status;
	}
	// NOTE: DO NOT TRANSLATE REPLY, USER REQUIRED TO GET THIS INFORMATION

	// SO, keep status byte.
	length = BufferLength;
	if(*pReplyLength<length)
	{
		*pReplyLength = 0;
		return STATUS_BUFFER_TOO_SMALL;
	}
	
	// Skip status byte.
	if(length) memory->copy(pReply, pInputBuffer, length);
	*pReplyLength = length;
	
	TRACE("GemCore VendorIOCTL() response\n");
	//TRACE_BUFFER(pReply,*pReplyLength);
	return status;
}


#pragma PAGEDCODE
NTSTATUS CGemCore::SwitchSpeed(ULONG ControlCode,BYTE* pRequest,ULONG RequestLength,BYTE* pReply,ULONG* pReplyLength)
{
	ULONG length;
	ULONG BufferLength;
	NTSTATUS status;
    BYTE  NewTA1;


	TRACE("\nGEMCORE SwitchSpeed:\n");
	//TRACE_BUFFER(pRequest,RequestLength);
	if(!RequestLength || !pRequest)
	{
		TRACE("\nGEMCORE SwitchSpeed: INVALID IN PARAMETERS...\n");
		*pReplyLength = 0;
		return STATUS_INVALID_PARAMETER;
	}

	NewTA1 = pRequest[0];

    // Modify speed value in reader's memory.
    length = 6;
    pOutputBuffer[0] = 0x23;  // Write memory command
    pOutputBuffer[1] = 0x01;  // The type of memory is iData.
    pOutputBuffer[2] = 0x00;  // Address high byte.
    pOutputBuffer[3] = 0x89;  // Address low byte.
    pOutputBuffer[4] = 0x01;  // Number of byte to write

    // New speed.
    pOutputBuffer[5] = NewTA1;

	// Send direct gemcore command
	BufferLength = InputBufferLength;

	status = protocol->writeAndWait(pOutputBuffer,length,pInputBuffer,&BufferLength);

	if(!NT_SUCCESS(status) || !BufferLength)
	{
		*pReplyLength = 0;
		return status;
	}

	length = BufferLength;
	if(*pReplyLength<length)
	{
		*pReplyLength = 0;
		return STATUS_BUFFER_TOO_SMALL;
	}
	
	// Copy the full reply
	if(length) memory->copy(pReply, pInputBuffer, length);
	*pReplyLength = length;

	TRACE("GemCore SwitchSpeed() response\n");
	//TRACE_BUFFER(pReply,*pReplyLength);
	return status;
}

// TODO:
// ??????????????????
// It is specific to device not Gemcore
// I would suggest to move it into the  specific reader object!
#pragma PAGEDCODE
NTSTATUS CGemCore::VendorAttribute(ULONG ControlCode,BYTE* pRequest,ULONG RequestLength,BYTE* pReply,ULONG* pReplyLength)
{
	NTSTATUS status;
    ULONG TagValue;

	TRACE("\nGEMCORE VendorAttibute:\n");
	//TRACE_BUFFER(pRequest,RequestLength);
	if(!RequestLength || !pRequest)
	{
		TRACE("\nGEMCORE VendorAttibute: INVALID IN PARAMETERS...\n");
		*pReplyLength = 0;
		return STATUS_INVALID_PARAMETER;
	}

    if (RequestLength < sizeof(TagValue)) 
	{
		*pReplyLength = 0;
        return STATUS_BUFFER_TOO_SMALL;
    }

    TagValue = (ULONG) *((PULONG)pRequest);

    switch(ControlCode)
	{
    // Get an attribute
    case IOCTL_SMARTCARD_VENDOR_GET_ATTRIBUTE:
        switch (TagValue)
		{
        // Power Timeout (SCARD_ATTR_SPEC_POWER_TIMEOUT)
        case SCARD_ATTR_SPEC_POWER_TIMEOUT:
            if (*pReplyLength < (ULONG) sizeof(configuration.PowerTimeOut))
			{
				*pReplyLength = 0;
                return STATUS_BUFFER_TOO_SMALL;
            }
			// Copy the value of PowerTimeout in the reply buffer
			memory->copy(
				pReply,
				&configuration.PowerTimeOut,
				sizeof(configuration.PowerTimeOut));
			*pReplyLength = (ULONG)sizeof(configuration.PowerTimeOut);
			status = STATUS_SUCCESS;
            break;

        case SCARD_ATTR_MANUFACTURER_NAME:
            if (*pReplyLength < ATTR_LENGTH)
			{
				*pReplyLength = 0;
                return STATUS_BUFFER_TOO_SMALL;
            }
			// Copy the value of PowerTimeout in the reply buffer
			memory->copy(
				pReply,
				ATTR_MANUFACTURER_NAME,
				sizeof(ATTR_MANUFACTURER_NAME));
			
			*pReplyLength = (ULONG)sizeof(ATTR_MANUFACTURER_NAME);
			status = STATUS_SUCCESS;
            break;

        case SCARD_ATTR_ORIGINAL_FILENAME:
            if (*pReplyLength < ATTR_LENGTH)
			{
				*pReplyLength = 0;
                return STATUS_BUFFER_TOO_SMALL;
            }
			// Copy the value of PowerTimeout in the reply buffer
			memory->copy(
				pReply,
				ATTR_ORIGINAL_FILENAME,
				sizeof(ATTR_ORIGINAL_FILENAME));
			
			*pReplyLength = (ULONG)sizeof(ATTR_ORIGINAL_FILENAME);
			status = STATUS_SUCCESS;
            break;
        // Unknown tag, we return STATUS_NOT_SUPPORTED
        default:
			*pReplyLength = 0;
            status = STATUS_NOT_SUPPORTED;
        }
        break;

    // Set the value of one tag (IOCTL_SMARTCARD_VENDOR_SET_ATTRIBUTE)
    case IOCTL_SMARTCARD_VENDOR_SET_ATTRIBUTE:
        switch (TagValue)
		{

        // Power Timeout (SCARD_ATTR_SPEC_POWER_TIMEOUT)
        case SCARD_ATTR_SPEC_POWER_TIMEOUT:

            if (RequestLength <(ULONG) (sizeof(configuration.PowerTimeOut) + sizeof(TagValue)))
			{
				*pReplyLength = 0;
                return STATUS_BUFFER_TOO_SMALL;
            }
            memory->copy(
                &configuration.PowerTimeOut,
                pRequest + sizeof(TagValue),
                sizeof(configuration.PowerTimeOut));

			*pReplyLength = 0;
            status = STATUS_SUCCESS;
            break;

        // Unknown tag, we return STATUS_NOT_SUPPORTED
        default:
			*pReplyLength = 0;
            status = STATUS_NOT_SUPPORTED;
        }
        break;

    default:
		*pReplyLength = 0;
        status = STATUS_NOT_SUPPORTED;
        break;
    }

	TRACE("GemCore VendorAttibute() response\n");
	//TRACE_BUFFER(pReply,*pReplyLength);
	return status;
}




#pragma PAGEDCODE
NTSTATUS CGemCore::powerUp(BYTE* pReply,ULONG* pReplyLength)
{
	BYTE  CFG = 0,PCK;
	ULONG length,i;
	ULONG BufferLength;

	NTSTATUS status;

	switch(configuration.Voltage)
	{
		case CARD_VOLTAGE_3V: CFG = 0x02;break;
		case CARD_VOLTAGE_5V: CFG = 0x01;break;
		default:    		  CFG = 0x00;break;
	}

	switch(configuration.PTSMode) 
	{
		case PTS_MODE_DISABLED: CFG |= 0x10;break;
		case PTS_MODE_OPTIMAL:	CFG |= 0x20;break;
		case PTS_MODE_MANUALLY: CFG |= 0x10;break;
		case PTS_MODE_DEFAULT:  CFG = 0x00;break;  // do not add cfg field
		default:				CFG = 0x00;break;  // same
	}

	length = 0;
	pOutputBuffer[length++] = GEMCORE_CARD_POWER_UP;

	// YN: if CFG = 0 that means we just need to do a power without CFG
	// This append in the case with a card in specific mode (presence of TA2)
	if(CFG) pOutputBuffer[length++] = CFG;

	BufferLength = InputBufferLength;
	protocol->set_WTR_Delay(protocol->get_Power_WTR_Delay());
	status = protocol->writeAndWait(pOutputBuffer,length,pInputBuffer,&BufferLength);
	protocol->set_Default_WTR_Delay();

	if (NT_SUCCESS(status)) 
	{
		if(BufferLength)
		{
			BufferLength--;
			TRACE("GemCore status %x\n",pInputBuffer[0]);
			status = translateStatus(pInputBuffer[0],GEMCORE_CARD_POWER);
			
			if(!NT_SUCCESS(status))
			{
				TRACE("GemCore FAILED TO POWER UP CARD! Status %x\n", status);
				*pReplyLength = 0;
				return status;
			}

			TRACE("GemCore power() ATR");
			TRACE_BUFFER(pInputBuffer+1,BufferLength);
			// Skip status byte and copy ATR
			if(pInputBuffer[1]==0x3B || pInputBuffer[1]==0x3F)
			{
				memory->copy(pReply,pInputBuffer+1,BufferLength);
				*pReplyLength = BufferLength;
			}
			else
			{
				*pReplyLength = 0;
				return STATUS_UNSUCCESSFUL;
			}
			//return status; //YN: do not return now
		}
		else
		{
			*pReplyLength = 0;
			return STATUS_UNSUCCESSFUL;
		}

		// YN: add PTS capabilities
		if (pInputBuffer[0] == 0x00) 
		{
			if(configuration.PTSMode == PTS_MODE_MANUALLY)
			{
				length = 0;
				pOutputBuffer[length++] = GEMCORE_CARD_POWER_UP;
				CFG |= 0xF0; //Manual PPS and 3V or 5V module
				pOutputBuffer[length++] = CFG;
				pOutputBuffer[length++] = configuration.PTS0;
				if ((configuration.PTS0 & PTS_NEGOTIATE_PTS1) != 0) pOutputBuffer[length++] = configuration.PTS1;
				if ((configuration.PTS0 & PTS_NEGOTIATE_PTS2) != 0) pOutputBuffer[length++] = configuration.PTS2;
				if ((configuration.PTS0 & PTS_NEGOTIATE_PTS3) != 0) pOutputBuffer[length++] = configuration.PTS3;
				
				// computes the exclusive-oring of all characters from CFG to PTS3				
				PCK = 0xFF;
				for (i=2; i<length; i++) { PCK ^= pOutputBuffer[i];}
				pOutputBuffer[length++] = PCK;

				BufferLength = InputBufferLength;
				
				protocol->set_WTR_Delay(protocol->get_Power_WTR_Delay());
				status = protocol->writeAndWait(pOutputBuffer,length,pInputBuffer,&BufferLength);
				protocol->set_Default_WTR_Delay();

				// Copy into buffer only when it fail.
				if (!NT_SUCCESS(status) || (BufferLength != 1) || (pInputBuffer[0] != 0x00)) 
				{
					*pReplyLength = BufferLength;
					if (BufferLength > 1)
					{
						memory->copy(pReply,pInputBuffer,BufferLength);
					}
				}

				return status;
			}
		}
	}
	else
	{
		*pReplyLength = 0;
	}

	return status;
}




#pragma PAGEDCODE
NTSTATUS CGemCore::power(ULONG ControlCode,BYTE* pReply,ULONG* pReplyLength, BOOLEAN Specific)
{
	ULONG length;
	ULONG BufferLength;
	ULONG PreviousState;
	NTSTATUS status;

	switch(ControlCode)
	{
    case SCARD_COLD_RESET:

		//ISV: First treat any card as ISO card on cold reset!
        // Defines the type of the card (ISOCARD) and set the card presence 
		RestoreISOsetting();
		length = 2;
		BufferLength = InputBufferLength;
		pOutputBuffer[0] = GEMCORE_DEFINE_CARD_TYPE;
		pOutputBuffer[1] = (UCHAR)configuration.Type;
		status = protocol->writeAndWait(pOutputBuffer,length,pInputBuffer,&BufferLength);

		if(NT_SUCCESS(status))
		{
			if(BufferLength)  status = translateStatus(pInputBuffer[0],GEMCORE_CARD_POWER);
		}

		if (!NT_SUCCESS(status))
		{
			return status;
		}

		if(Specific == FALSE)
		{
			// 
			// Just define card default values
			// 
			RestoreISOsetting();
		}


		PreviousState = protocol->getCardState();

		// Power down first for a cold reset
		// YN : verify power state of card first
		
		length = 0;
		pOutputBuffer[length++] = GEMCORE_CARD_POWER_DOWN;
		BufferLength = InputBufferLength;
		status = protocol->writeAndWait(pOutputBuffer,length,pInputBuffer,&BufferLength);
		if(NT_SUCCESS(status))
		{
			if(BufferLength)  status = translateStatus(pInputBuffer[0],GEMCORE_CARD_POWER);
		}
		TRACE("GemCore powerDown() response\n");
		//TRACE_BUFFER(pInputBuffer,BufferLength);
		*pReplyLength = 0;
		if(status != STATUS_SUCCESS)
		{
			return status;
		}

		// YN this is PowerTimeout must be a 
        if ((PreviousState & SCARD_POWERED) && (configuration.PowerTimeOut))
		{
            // Waits for the Power Timeout to be elapsed.
			// before doing reset.
			TRACE("GEMCORE power, ColdReset timeout %d ms\n", configuration.PowerTimeOut);
			DELAY(configuration.PowerTimeOut);
        }

    case SCARD_WARM_RESET:
		// If card have a Specific mode let Gemcore negociate properly with this card.
		if(Specific)
		{
			// keep configuration of the reader.
			configuration.PTSMode = PTS_MODE_DEFAULT;
			status = powerUp(pReply, pReplyLength);
		}
		else if(configuration.Type == TRANSPARENT_MODE_CARD)
		{
			// ISV: Command 12 will fail in transparant mode...
			// Let's set reader in ISO mode first!
			TRACE("	WARM RESET for Transparent mode requested...\n");
			RestoreISOsetting();
			length = 2;
			BufferLength = InputBufferLength;
			pOutputBuffer[0] = GEMCORE_DEFINE_CARD_TYPE;
			pOutputBuffer[1] = (UCHAR)configuration.Type;

			status = protocol->writeAndWait(pOutputBuffer,length,pInputBuffer,&BufferLength);
			if(NT_SUCCESS(status))
			{
				if(BufferLength)  status = translateStatus(pInputBuffer[0],GEMCORE_CARD_POWER);
			}

			if (!NT_SUCCESS(status))
			{
				return status;
			}			
			// do not lost transparent config on warm reset
			// keep configuration of the reader.
			status = powerUp(pReply, pReplyLength);
		}
		else
		{
			// Do a regular ISO reset
			status = powerUp(pReply, pReplyLength);			
		}

		return status;
		break;
	case SCARD_POWER_DOWN:
			length = 0;
			pOutputBuffer[length++] = GEMCORE_CARD_POWER_DOWN;
			BufferLength = InputBufferLength;
			status = protocol->writeAndWait(pOutputBuffer,length,pInputBuffer,&BufferLength);			
			if(NT_SUCCESS(status))
			{
				if(BufferLength)  status = translateStatus(pInputBuffer[0],GEMCORE_CARD_POWER);
			}
			TRACE("GemCore powerDown() response\n");
			//TRACE_BUFFER(pInputBuffer,BufferLength);
			*pReplyLength = 0;
			return status;
		break;
	}
	*pReplyLength = 0;
	return STATUS_INVALID_DEVICE_REQUEST;
}


#pragma PAGEDCODE
VOID	 CGemCore::cancel()
{
}

#pragma PAGEDCODE
NTSTATUS CGemCore::initialize()
{
	TRACE("Initializing Gemcore interface...\n");
	TRACE("Setting Gemcore reader mode...\n");
	
	Initialized = TRUE;
	Mode = READER_MODE_NATIVE;
	NTSTATUS status = setReaderMode(READER_MODE_NATIVE);
	if(!NT_SUCCESS(status))
	{
		TRACE("Failed to set Gemcore reader mode %x\n",READER_MODE_NATIVE);
		return STATUS_INVALID_DEVICE_STATE;
	}

	TRACE("Getting Gemcore reader version...\n");
	ULONG VersionLength = VERSION_STRING_MAX_LENGTH;
	status = getReaderVersion(Version,&VersionLength);
	if(!NT_SUCCESS(status))
	{
		TRACE("Failed to get GemCore reader interface version...\n");
		return STATUS_INVALID_DEVICE_STATE;
	}
	else
	{
		Version[VersionLength] = 0x00;
		TRACE("****** GemCore version - %s ******\n",Version);
	}

	TRACE("Gemcore interface initialized...\n");
	return status;

}

#pragma PAGEDCODE
ULONG CGemCore::getReaderState()
{
ULONG BufferLength;
	pOutputBuffer[0] = GEMCORE_GET_CARD_STATUS;
	BufferLength = InputBufferLength;
	NTSTATUS status = protocol->writeAndWait(pOutputBuffer,1,pInputBuffer,&BufferLength);			
	TRACE("GemCore getReaderState() response\n");
	//TRACE_BUFFER(pInputBuffer,BufferLength);

	if(!NT_SUCCESS(status) || !BufferLength || (BufferLength<2))
	{
		TRACE("FAILED!\n");
		return SCARD_ABSENT;	
	}

	if (!(pInputBuffer[1] & 0x04))
	{
		TRACE("*** Card is absent!\n");
		return SCARD_ABSENT;
	}
	else 
	if (pInputBuffer[1] & 0x04)
	{
		TRACE("*** Card is present!\n");
		return SCARD_SWALLOWED;
	}
	else
	{
		TRACE("Card state is unknown!\n");
		return SCARD_ABSENT;
	}
	
	return SCARD_ABSENT;
}

#pragma PAGEDCODE
NTSTATUS  CGemCore::getReaderVersion(PUCHAR pVersion, PULONG pLength)
{
ULONG BufferLength;
ULONG length;
	if(!pVersion || !pLength) return STATUS_INVALID_PARAMETER;
	length = sizeof(GEMCORE_GET_FIRMWARE_VERSION);
	// Remove last 0x00
	if(length) length--;
	memory->copy(pOutputBuffer,GEMCORE_GET_FIRMWARE_VERSION,length);
	BufferLength = InputBufferLength;

	TRACE("getReaderVersion() \n");
	//TRACE_BUFFER(pOutputBuffer,length);

	NTSTATUS status = protocol->writeAndWait(pOutputBuffer,length,pInputBuffer,&BufferLength);			
	if(!NT_SUCCESS(status) || !BufferLength)
	{
		*pLength = 0;
		return STATUS_UNSUCCESSFUL;	
	}
	
	if (pInputBuffer[0])
	{
		*pLength = 0;
		return translateStatus(pInputBuffer[0],0);
	}

	if(BufferLength-1 > *pLength)
	{
		BufferLength =  *pLength;
	}
	// Remove status byte...
	BufferLength--;
	if(BufferLength) memory->copy(pVersion,pInputBuffer+1,BufferLength);
	*pLength = BufferLength;
	return STATUS_SUCCESS;
}

#pragma PAGEDCODE
NTSTATUS CGemCore::setReaderMode(ULONG mode)
{
BYTE CFG_BYTE; 
ULONG BufferLength;

	switch(mode)
	{
	case READER_MODE_NATIVE: CFG_BYTE = 0x00;	break;
	case READER_MODE_ROS:	 CFG_BYTE = 0x08;	break;
	case READER_MODE_TLP:	 CFG_BYTE = 0x09;	break;
		default:			 CFG_BYTE = 0x00;	break;
	}

	pOutputBuffer[0] = GEMCORE_READER_SET_MODE;
	pOutputBuffer[1] = 0x00;
	pOutputBuffer[2] = CFG_BYTE;

	BufferLength = InputBufferLength;
	NTSTATUS status = protocol->writeAndWait(pOutputBuffer,3,pInputBuffer,&BufferLength);			
	if(!NT_SUCCESS(status))
	{
		TRACE("Failed to set reader mode...\n");
		return status;	
	}

	return status;
};

#pragma PAGEDCODE
NTSTATUS	CGemCore::translateStatus( const BYTE  ReaderStatus, const ULONG IoctlType)
{
    switch (ReaderStatus) 
	{
    case 0x00 : return STATUS_SUCCESS;
    case 0x01 : return STATUS_NO_SUCH_DEVICE;
    case 0x02 : return STATUS_NO_SUCH_DEVICE;
    case 0x03 : return STATUS_INVALID_PARAMETER; 
    case 0x04 : return STATUS_IO_TIMEOUT;
    case 0x05 : return STATUS_INVALID_PARAMETER;
    case 0x09 : return STATUS_INVALID_PARAMETER;
    case 0x10 : return STATUS_UNRECOGNIZED_MEDIA;
    case 0x11 : return STATUS_UNRECOGNIZED_MEDIA;
    case 0x12 : return STATUS_INVALID_PARAMETER;
    case 0x13 : return STATUS_CONNECTION_ABORTED;
    case 0x14 : return STATUS_UNRECOGNIZED_MEDIA;
    case 0x15 : return STATUS_UNRECOGNIZED_MEDIA;
    case 0x16 : return STATUS_INVALID_PARAMETER;
    case 0x17 : return STATUS_UNRECOGNIZED_MEDIA;
    case 0x18 : return STATUS_UNRECOGNIZED_MEDIA;
    case 0x19 : return STATUS_INVALID_PARAMETER;
    case 0x1A : return STATUS_INVALID_PARAMETER;
    case 0x1B : return STATUS_INVALID_PARAMETER;
    case 0x1C : return STATUS_INVALID_PARAMETER;
    case 0x1D : return STATUS_UNRECOGNIZED_MEDIA;
    case 0x1E : return STATUS_INVALID_PARAMETER;
    case 0x1F : return STATUS_INVALID_PARAMETER;
    case 0x20 : return STATUS_INVALID_PARAMETER;
    case 0x30 : return STATUS_IO_TIMEOUT;
    case 0xA0 : return STATUS_SUCCESS;
    case 0xA1 : return STATUS_UNRECOGNIZED_MEDIA;
    case 0xA2 : 
        if(IoctlType == GEMCORE_CARD_POWER) return STATUS_UNRECOGNIZED_MEDIA;
        else                                return STATUS_IO_TIMEOUT;
    case 0xA3 : return STATUS_PARITY_ERROR;
    case 0xA4 : return STATUS_REQUEST_ABORTED;
    case 0xA5 : return STATUS_REQUEST_ABORTED;
    case 0xA6 : return STATUS_REQUEST_ABORTED;
    case 0xA7 : return STATUS_UNRECOGNIZED_MEDIA;
    case 0xCF : return STATUS_INVALID_PARAMETER;
    case 0xE4 : return STATUS_UNRECOGNIZED_MEDIA;
    case 0xE5 : return STATUS_SUCCESS;
    case 0xE7 : return STATUS_SUCCESS;
    case 0xF7 : return STATUS_NO_MEDIA;
    case 0xF8 : return STATUS_UNRECOGNIZED_MEDIA;
    case 0xFB : return STATUS_NO_MEDIA;
    default   : return STATUS_INVALID_PARAMETER;
    }
}


#pragma PAGEDCODE
VOID CGemCore::RestoreISOsetting(VOID)
{
	configuration.Type		= ISO_CARD;//ISO_CARD  (02)
	configuration.PresenceDetection = DEFAULT_PRESENCE_DETECTION; // (0D)
	configuration.Voltage	= CARD_DEFAULT_VOLTAGE;  //CARD_DEFAULT_VOLTAGE;
	configuration.PTSMode	= PTS_MODE_DISABLED;  //PTS_MODE_DISABLED;
	configuration.PTS0		= 0;
	configuration.PTS1		= 0;
	configuration.PTS2		= 0;
	configuration.PTS3		= 0;
	configuration.Vpp		= 0;  //CARD_DEFAULT_VPP;
	configuration.ActiveProtocol = 0;// Undefined
}


#pragma PAGEDCODE
NTSTATUS	CGemCore::setTransparentConfig(
	PSCARD_CARD_CAPABILITIES cardCapabilities,
	BYTE NewWtx
	)
/*++

Routine Description:

	Set the parameters of the transparent mode.

Arguments:
	PSCARD_CARD_CAPABILITIES CardCapabilities - structure for card 
	NewWtx               - holds the value (ms) of the new Wtx

--*/
{
    LONG etu;
    BYTE temp,mask,index;
	ULONG Length, BufferLength;

    NTSTATUS status;

	TRACE("\nGEMCORE T1 setTransparentConfig Enter\n");

    // Inverse or direct conversion
    if (cardCapabilities->InversConvention)
        configuration.transparent.CFG |= 0x20;
    else
        configuration.transparent.CFG &= 0xDF;
    // Transparent T=1 like (with 1 byte for the length).
    configuration.transparent.CFG |= 0x08;
    // ETU = ((F[Fi]/D[Di]) - 1) / 3
    etu = cardCapabilities->ClockRateConversion[
        (BYTE) configuration.transparent.Fi].F;
    if (cardCapabilities->BitRateAdjustment[
        (BYTE) configuration.transparent.Fi].DNumerator) {

        etu /= cardCapabilities->BitRateAdjustment[
            (BYTE) configuration.transparent.Di].DNumerator;
    }
    etu -= 1;
    etu /= 3;
    configuration.transparent.ETU = (BYTE) ( 0x000000FF & etu);

    if (cardCapabilities->N == 0xFF) {

        configuration.transparent.EGT = (BYTE) 0x00;
    } else {
        configuration.transparent.EGT = (BYTE) cardCapabilities->N;
    }

    configuration.transparent.CWT = (BYTE) cardCapabilities->T1.CWI;
    if (NewWtx) {

        for (mask = 0x80,index = 8; index !=0x00; index--) {
            temp = NewWtx & mask;
            if (temp == mask)
                break;
            mask = mask/2;
        }
        configuration.transparent.BWI = cardCapabilities->T1.BWI + index;
    } else {

        configuration.transparent.BWI = cardCapabilities->T1.BWI;
    }

	Length = 6;
	BufferLength = InputBufferLength;

	pOutputBuffer[0] = GEMCORE_CARD_POWER_UP;
    pOutputBuffer[1] = configuration.transparent.CFG;
    pOutputBuffer[2] = configuration.transparent.ETU;
    pOutputBuffer[3] = configuration.transparent.EGT;
    pOutputBuffer[4] = configuration.transparent.CWT;
    pOutputBuffer[5] = configuration.transparent.BWI;

	status = protocol->writeAndWait(pOutputBuffer,Length,pInputBuffer,&BufferLength);

	if(NT_SUCCESS(status))
	{
		if(BufferLength)  status = translateStatus(pInputBuffer[0],GEMCORE_CARD_POWER);
	}

	TRACE("\nGEMCORE T1 setTransparentConfig Exit\n");

	return status;
}



#pragma PAGEDCODE
NTSTATUS CGemCore::setProtocol(ULONG ProtocolRequested)
{
	NTSTATUS status;
	UCHAR Buffer[256];
	ULONG BufferLength = 256;

	switch(ProtocolRequested)
	{
	case SCARD_PROTOCOL_T1:
		configuration.PTS0 = PTS_NEGOTIATE_T1 | PTS_NEGOTIATE_PTS1;
		configuration.ActiveProtocol = SCARD_PROTOCOL_T1;
		break;
	case SCARD_PROTOCOL_T0:
		configuration.PTS0 = PTS_NEGOTIATE_T0 | PTS_NEGOTIATE_PTS1;
		configuration.ActiveProtocol = SCARD_PROTOCOL_T0;
	default:
		break;
	}
	// PTS1 has to be set before at power up...
	//configuration.PTS1 = CardCapabilities->PtsData.Fl << 4 | CardCapabilities->PtsData.Dl;

	if(configuration.PTSMode == PTS_MODE_MANUALLY)
	{
		status = powerUp(Buffer,&BufferLength);
	}
	else {
		status = power(SCARD_COLD_RESET, Buffer, &BufferLength, FALSE);
	}

	if(NT_SUCCESS(status))
	{
		if(BufferLength)  status = translateStatus(pInputBuffer[0],GEMCORE_CARD_POWER);
	}

	return status;
}


// TODO:
// What the purpose of the function?
// It's name does not tell anything...
// Actually it was suggested for the different purposes.
// Function has to be rewritten! It has a lot of mixed stuff like getting
// card status for example.
// ............................

//
// Use to made full T1 exchange in transparent mode
//
#pragma PAGEDCODE
NTSTATUS CGemCore::translate_request(BYTE * pRequest,ULONG RequestLength,BYTE * pReply,ULONG* pReplyLength, PSCARD_CARD_CAPABILITIES cardCapabilities, BYTE NewWtx)
{
	NTSTATUS status;
	UCHAR Cmd[256];
	ULONG CmdLength = 0;
	UCHAR Buffer[256];
	ULONG BufferLength;
	ULONG length;

	//
	// If the current card type <> TRANSPARENT_MODE_CARD 
	//
	if (configuration.Type != TRANSPARENT_MODE_CARD) 
	{

		// We read the status of the card to known the current voltage and the TA1
		BufferLength = 256;
		CmdLength = 1;

		Cmd[0] = GEMCORE_GET_CARD_STATUS;
		status = protocol->writeAndWait(Cmd,CmdLength,Buffer,&BufferLength);
		
		// verify return code of reader
		if(NT_SUCCESS(status))
		{
			if(BufferLength)  status = translateStatus(Buffer[0],GEMCORE_CARD_POWER);
		}
		
		if (!NT_SUCCESS(status))
		{
			return status;
		}

		// Update Config
		configuration.transparent.CFG = Buffer[1] & 0x01; //Vcc
		configuration.transparent.Fi = Buffer[3] >>4; //Fi
		configuration.transparent.Di = 0x0F & Buffer[3]; //Di

		//We define the type of the card.

		BufferLength = 256;
		CmdLength = 2;
		// assign TRANSPARENT_MODE_CARD
		configuration.Type = TRANSPARENT_MODE_CARD;
		Cmd[0] = GEMCORE_DEFINE_CARD_TYPE;
		Cmd[1] = (BYTE) configuration.Type;
		status = protocol->writeAndWait(Cmd,CmdLength,Buffer,&BufferLength);

		if(NT_SUCCESS(status))
		{
			if(BufferLength)  status = translateStatus(Buffer[0],GEMCORE_CARD_POWER);
		}
		
		if (!NT_SUCCESS(status))
		{
			return status;
		}

		// YN ?  Mandatory!!!  Else reader will be slow in T=1
        // Set the transparent configuration
		setTransparentConfig(cardCapabilities, NewWtx);

		NewWtx = 0;  // to not repeat again this call
    }
	/////// 

	if(NewWtx)
	{
		setTransparentConfig(cardCapabilities, NewWtx);
	}

	TRACE("\nGEMCORE T1 translate_request:\n");
	//TRACE_BUFFER(pRequest,RequestLength);
	if(!RequestLength || !pRequest ) return STATUS_INVALID_PARAMETER;

	length = RequestLength;  // protocol
	
	if (RequestLength >= READER_DATA_BUFFER_SIZE  )
	{
		// If the length is upper than the standard available space (254)
		// Then Send the last datas 

        // If the length is lower or equal than the extended available space (255)
        // Prepare and send the first part of the extended ISO In command:
        // The five command bytes are added in cmd buffer: 0xFF,0xFF,0xFF,0xFF,LN-248
		// Read second block of data...
 		pOutputBuffer[0] = GEMCORE_CARD_WRITE;  // specific for transparent exchange write long...

		length = length - 254 + 1;

		memory->copy(pOutputBuffer+1,pRequest + 254, length - 1);
		// Add size of header...
		length += 6;
		BufferLength = InputBufferLength;
		status = protocol->writeAndWait(pOutputBuffer,length,pInputBuffer,&BufferLength);
		if(!NT_SUCCESS(status) || !BufferLength)
		{
			return status;
		}

		// prepare next paquet
		length = 254;
	}

	pOutputBuffer[0] = GEMCORE_CARD_EXCHANGE;
	memory->copy(pOutputBuffer +1 ,pRequest, length);

	// Add size of header...
	length += 1;

	BufferLength = InputBufferLength;
	status = protocol->writeAndWait(pOutputBuffer,length,pInputBuffer,&BufferLength);
	if(!NT_SUCCESS(status) || !BufferLength)
	{
		*pReplyLength = 0;
		return status;
	}

    // If the IFD signals more data to read...
	// YN: 2 block for response...
    if (BufferLength > 0 && pInputBuffer[0] == 0x1B)
	{
		ULONG BufferLength2 = 256;
		UCHAR pInputBuffer2[256];

		// Send a command to read the last data.
 		pOutputBuffer[0] = GEMCORE_CARD_READ;  // specific for transparent exchange read long...
		length = 1;
		status = protocol->writeAndWait(pOutputBuffer,length,pInputBuffer2,&BufferLength2);

		if(!NT_SUCCESS(status) || !BufferLength2)
		{
			*pReplyLength = 0;
			return status;
		}

        if ((BufferLength + BufferLength2 - 2) > *pReplyLength) 
		{
			*pReplyLength = 0;
            return STATUS_INVALID_PARAMETER;
        }

        // Copy the last reader status
        pInputBuffer[0] = pInputBuffer2[0];

		status = translateStatus(pInputBuffer[0],0);
		if(!NT_SUCCESS(status))
		{
			*pReplyLength = 0;
			return status;
		}

		// Skip 2 status byte.
        *pReplyLength = BufferLength + BufferLength2 - 2;

		// Skip status byte.
		if(*pReplyLength) 
		{
			memory->copy(pReply,pInputBuffer+1, BufferLength -1);
			memory->copy(pReply + (BufferLength-1), pInputBuffer2 +1, BufferLength2 -1);
		}

		TRACE("GemCore translate_request2 () response\n");
		//TRACE_BUFFER(pReply,*pReplyLength);

		return status;
	}

	status = translateStatus(pInputBuffer[0],0);
	if(!NT_SUCCESS(status))
	{
		*pReplyLength = 0;
		return status;
	}

	// Skip status byte.
	length = BufferLength - 1;

	if(*pReplyLength < length)
	{
		*pReplyLength = 0;
		return STATUS_INVALID_BUFFER_SIZE;
	}
	
	// Skip status byte.
	if(length) 
	{
		memory->copy(pReply,pInputBuffer+1, length);
	}
	*pReplyLength = length;
	
	TRACE("GemCore translate_request() response\n");
	//TRACE_BUFFER(pReply,*pReplyLength);

	return status;
};


// TODO:
// ???????????
#pragma PAGEDCODE
NTSTATUS CGemCore::translate_response(BYTE * pRequest,ULONG RequestLength,BYTE * pReply,ULONG* pReplyLength)
{
	switch(configuration.ActiveProtocol)
	{
	case SCARD_PROTOCOL_T1:
		break;
	case SCARD_PROTOCOL_T0:
	default:
		break;
	}
	return STATUS_SUCCESS;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\gempc430\generic.h ===
// Gemplus (C) 1999
// This module keeps system interface for the driver.
// Version 1.0
// Author: Sergey Ivanov
// Date of creation - 18.05.1999
// Change log:
//
#ifndef GEN_INT
#define GEN_INT

#define PAGEDCODE code_seg("page")
#define LOCKEDCODE code_seg()
#define INITCODE code_seg("init")

#define PAGEDDATA data_seg("page")
#define LOCKEDDATA data_seg()
#define INITDATA data_seg("init")

#define SMARTCARD_POOL_TAG 'bGCS'

// Include files for different system objects
#ifdef WDM_KERNEL
#include "syswdm.h"
#else
#ifdef	NT4_KERNEL
#include "sysnt4.h"
#else
#ifdef	WIN9X_KERNEL
#include "syswin9x.h"
#else
#include "syswdm.h"
#endif
#endif
#endif

#include <smclib.h>

#include "gemlog.h"

// Miscellaneous useful declarations
#ifndef arraysize
#define arraysize(p) (sizeof(p)/sizeof((p)[0]))
#endif


#ifndef CTL_CODE
	#pragma message("CTL_CODE undefined. Include winioctl.h or devioctl.h before this file")
#endif

#define IOCTL_GRCLASS_GETVER	CTL_CODE(FILE_DEVICE_UNKNOWN, 0x801, METHOD_BUFFERED, FILE_ANY_ACCESS)

typedef	VOID (*PDEFERRED_FUNCTION)(IN struct _KDPC *Dpc, IN PDEVICE_OBJECT  DeviceObject,IN PIRP Irp, IN PVOID SystemArgument2);
int __cdecl _purecall(VOID);

#define SAFE_DESTRUCTORS()\
	VOID self_delete(VOID){delete this;}

#ifdef __cplusplus
	#define GENERICAPI extern "C" 
#else
	#define GENERICAPI
#endif

#define GENERIC_EXPORT __declspec(dllexport) __stdcall
typedef VOID (__stdcall *PQNOTIFYFUNC)(PVOID);

BOOLEAN GENERIC_EXPORT isWin98();

#define DRIVERNAME "GRClass.sys"
#define NT_OBJECT_NAME   L"\\Device\\GRClass"

#if DEBUG
extern "C" VOID __cdecl _chkesp();
#endif

extern BOOLEAN SystemWin98;

// Power management constants
#define GUR_IDLE_CONSERVATION	60		// sleep after 60 seconds on battery power
#define GUR_IDLE_PERFORMANCE	600		// sleep after 10 minutes on AC power

EXTERN_C const GUID FAR GUID_CLASS_GRCLASS;
EXTERN_C const GUID FAR GUID_CLASS_SMARTCARD;

// Supported by driver different type of devices
#define GRCLASS_DEVICE		0
#define USB_DEVICE			1
#define USBREADER_DEVICE	2
#define BUS_DEVICE			3
#define CHILD_DEVICE		4

inline VOID _cdecl DBG_PRINT(PCH Format,...)
{
va_list argpoint;
CHAR  strTempo[1024];
	va_start(argpoint,Format);
	vsprintf(strTempo,Format,argpoint);
	va_end(argpoint);
	SmartcardDebug (DEBUG_DRIVER,("GemPC430: "));
	SmartcardDebug (DEBUG_DRIVER, (strTempo));
};

inline VOID _cdecl DBG_PRINT_NO_PREFIX(PCH Format,...)
{
va_list argpoint;
CHAR  strTempo[1024];
	va_start(argpoint,Format);
	vsprintf(strTempo,Format,argpoint);
	va_end(argpoint);
	SmartcardDebug (DEBUG_DRIVER, (strTempo));
};

 // already included
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\gempc430\interface.h ===
//-------------------------------------------------------------------
// This is abstract class for Reader Interface
// Specific interfaces should use it as a parent device
// Author: Sergey Ivanov
// Log:
//		11/09/99	-	implemented	
//-------------------------------------------------------------------
#ifndef __READER_INTERFACE__
#define __READER_INTERFACE__

#include "generic.h"
#include "kernel.h"
#include "rdrconfig.h"


#define READER_INTERFACE_GEMCORE	1
#define READER_INTERFACE_OROS		2
#define READER_INTERFACE_USB		3
#define READER_INTERFACE_GPR		4

#define READER_MODE_NATIVE			1
#define READER_MODE_ROS				2
#define READER_MODE_TLP				3

#define INTERFACE_OUTPUT_BUFFER_SIZE	0x1000
#define INTERFACE_INPUT_BUFFER_SIZE	    0x1000

#define VERSION_STRING_MAX_LENGTH   16
class CProtocol;
class CDebug;
class CMemory;
class CIoPacket;
#pragma PAGEDCODE
class CReaderInterface
{
public:
	NTSTATUS m_Status;
	SAFE_DESTRUCTORS();
	virtual VOID dispose(){self_delete();};
protected:
	// Internal buffers to manage Xfers...
    ULONG  OutputBufferLength;
    PUCHAR pOutputBuffer;
    ULONG  InputBufferLength;
    PUCHAR pInputBuffer;

	CDebug*	 debug;
	CProtocol* protocol;
	CMemory* memory;

	BOOL     Initialized;
	UCHAR    Version[VERSION_STRING_MAX_LENGTH];
	ULONG    Mode;
protected:
	CReaderInterface();
	virtual ~CReaderInterface();
public:	

	CReaderInterface(CProtocol* protocol);

	virtual  ReaderConfig	getConfiguration() 
	{ReaderConfig c;
		c.Type = 0;
		c.PresenceDetection = 0;
		c.Vpp = 0;
		c.Voltage = 0;
		c.PTSMode = 0;
		c.PTS0 = 0;
		c.PTS1 = 0;
		c.PTS2 = 0;
		c.PTS3 = 0;
		c.ActiveProtocol = 0;
		c.PowerTimeOut = 0;
		return c;
	};
	virtual  NTSTATUS  setConfiguration(ReaderConfig configuration) {return STATUS_SUCCESS;};
	virtual  NTSTATUS  setTransparentConfig(PSCARD_CARD_CAPABILITIES cardCapabilities, BYTE NewWtx) {return STATUS_SUCCESS;};
	virtual  NTSTATUS  getReaderVersion(PUCHAR pVersion, PULONG pLength) {return STATUS_SUCCESS;};
	virtual  ULONG     getReaderState()   {return 0;};
	virtual  NTSTATUS  setReaderMode(ULONG mode) {return STATUS_SUCCESS;};
	virtual  BOOL      isInitialized(){return Initialized;};
	virtual  NTSTATUS  initialize() {return STATUS_SUCCESS;};

		// Pure virtual functions will be implemented by specific interfaces (expl: CGemCore)...
	virtual  NTSTATUS  read(CIoPacket* Irp)  {return STATUS_SUCCESS;};
	virtual  NTSTATUS  write(CIoPacket* Irp) {return STATUS_SUCCESS;};
	virtual  NTSTATUS  readAndWait(PUCHAR pRequest,ULONG RequestLength,PUCHAR pReply,ULONG* pReplyLength) {return STATUS_SUCCESS;};
	virtual  NTSTATUS  writeAndWait(PUCHAR pRequest,ULONG RequestLength,PUCHAR pReply,ULONG* pReplyLength) {return STATUS_SUCCESS;};
    virtual  NTSTATUS  ioctl(ULONG ControlCode,PUCHAR pRequest,ULONG RequestLength,PUCHAR pReply,ULONG* pReplyLength) {return STATUS_SUCCESS;};
	virtual  NTSTATUS  SwitchSpeed(ULONG ControlCode,PUCHAR pRequest,ULONG RequestLength,PUCHAR pReply,ULONG* pReplyLength) {return STATUS_SUCCESS;};
	virtual  NTSTATUS  VendorAttribute(ULONG ControlCode,PUCHAR pRequest,ULONG RequestLength,PUCHAR pReply,ULONG* pReplyLength) {return STATUS_SUCCESS;};
    virtual  NTSTATUS  power(ULONG ControlCode,PUCHAR pReply,ULONG* pReplyLength, BOOLEAN Specific) {return STATUS_SUCCESS;};
	virtual  NTSTATUS  setProtocol(ULONG ProtocolRequested) {return STATUS_SUCCESS;};

	virtual  NTSTATUS translate_request(BYTE * pRequest,ULONG RequestLength,BYTE * pReply,ULONG* pReplyLength, PSCARD_CARD_CAPABILITIES cardCapabilities, BYTE NewWtx)  {return STATUS_SUCCESS;};
	virtual  NTSTATUS translate_response(BYTE * pRequest,ULONG RequestLength,BYTE * pReply,ULONG* pReplyLength) {return STATUS_SUCCESS;};

	virtual  VOID	   cancel() {};
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\gempc430\int.h ===
// Gemplus (C) 1999
// Version 1.0
// Author: Sergey Ivanov
// Date of creation - 18.05.1999
// Change log:
//

#ifndef INT_INT
#define INT_INT
#include "generic.h"
#pragma PAGEDCODE
class CInterrupt
{
public:
	NTSTATUS m_Status;
	SAFE_DESTRUCTORS();
	virtual VOID dispose(){self_delete();};
protected:
	CInterrupt(){};
	virtual ~CInterrupt(){};
public:

	virtual NTSTATUS	connect(OUT PKINTERRUPT *InterruptObject,
							IN PKSERVICE_ROUTINE ServiceRoutine,
							IN PVOID ServiceContext,
							IN PKSPIN_LOCK SpinLock OPTIONAL,
							IN ULONG Vector,
							IN KIRQL Irql,
							IN KIRQL SynchronizeIrql,
							IN KINTERRUPT_MODE InterruptMode,
							IN BOOLEAN ShareVector,
							IN KAFFINITY ProcessorEnableMask,
							IN BOOLEAN FloatingSave
							) {return STATUS_SUCCESS;};

	virtual VOID		disconnect(IN PKINTERRUPT InterruptObject) {};
	virtual VOID		initializeDpcRequest(IN PDEVICE_OBJECT pFdo,IN PDEFERRED_FUNCTION DpcForIsr) {};
	virtual BOOLEAN		synchronizeExecution (	IN PKINTERRUPT Interrupt,
												IN PKSYNCHRONIZE_ROUTINE SynchronizeRoutine,    
												IN PVOID SynchronizeContext) {return FALSE;};         
};	

#endif//CInterrupt
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\gempc430\interface.cpp ===
#include "interface.h"
#include "kernel.h"

#pragma PAGEDCODE
CReaderInterface::CReaderInterface()
{ 
	protocol = NULL;
	memory   = NULL;
	debug	 = NULL;

	Initialized = FALSE;
	Mode = READER_MODE_NATIVE;

};

CReaderInterface::CReaderInterface(CProtocol* protocol)
{
	debug	= kernel->createDebug();
	if(protocol)	this->protocol = protocol;
	memory = kernel->createMemory();
	if(memory)
	{
		pOutputBuffer = (PUCHAR) memory->allocate(NonPagedPool,INTERFACE_OUTPUT_BUFFER_SIZE);
		pInputBuffer  = (PUCHAR) memory->allocate(NonPagedPool,INTERFACE_INPUT_BUFFER_SIZE);
		if(pOutputBuffer && pInputBuffer)
		{
			OutputBufferLength	= INTERFACE_OUTPUT_BUFFER_SIZE;
			InputBufferLength	= INTERFACE_INPUT_BUFFER_SIZE;
		}
		else
		{
			if(pOutputBuffer) memory->free(pOutputBuffer);
			if(pInputBuffer)  memory->free(pInputBuffer);
			pOutputBuffer	  = NULL;
			pInputBuffer	  = NULL;
		}
	}

	Initialized = FALSE;
	Mode = READER_MODE_NATIVE;
	TRACE("********* ReaderInterface object created ...\n");
};

CReaderInterface::~CReaderInterface()
{ 
	TRACE("******* Destroing ReaderInterface object...\n");
	if(memory)		  
	{
		if(pOutputBuffer) memory->free(pOutputBuffer);
		if(pInputBuffer)  memory->free(pInputBuffer);
		memory->dispose();
	}
	if(protocol)	protocol->dispose();
	if(debug)		debug->dispose();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\gempc430\iopack.h ===
// Gemplus (C) 1999
// Version 1.0
// Author: Sergey Ivanov
// Date of creation - 18.05.1999
// Change log:
//

#ifndef __IO_PACKET__
#define __IO_PACKET__
#include "generic.h"

// This class will manage creation and 
// manipulation of driver IRPs
class CIrp;
class CMemory;
class CEvent;
class CDebug;

#pragma LOCKEDCODE
NTSTATUS onRequestComplete(PDEVICE_OBJECT DeviceObject, PIRP Irp, PVOID Context);

#pragma PAGEDCODE
class CIoPacket;

class CIoPacket
{
public:
	NTSTATUS m_Status;
	SAFE_DESTRUCTORS();
	virtual VOID dispose(){self_delete();};
private:
IO_STACK_LOCATION Stack;
					   //Cancel;
	PIRP  m_Irp;
	UCHAR StackSize;
	CIrp* irp;
	CMemory* memory;
	CEvent*  event;
	CDebug*  debug;

	BOOL  systemIrp;
	BOOL  m_DoNotFreeIrp;
	// Event to signal xfer completion
	KEVENT	DefaultCompletionEvent;
	PKEVENT	CompletionEvent;

	IO_STATUS_BLOCK IoStatus;
	PVOID	SystemBuffer;
	LONG   m_TimeOut;
protected:
	CIoPacket(){};
	virtual ~CIoPacket();
public:
	CIoPacket(UCHAR StackSize);
	CIoPacket(PIRP Irp);

	virtual PIRP getIrpHandle(){return m_Irp;};

	virtual VOID setMajorIOCtl(UCHAR controlCode);
	virtual UCHAR getMajorIOCtl();

	virtual VOID setMinorIOCtl(UCHAR controlCode);
	virtual NTSTATUS    buildStack(PDEVICE_OBJECT DeviceObject, ULONG Major=IRP_MJ_INTERNAL_DEVICE_CONTROL, UCHAR Minor=0, ULONG IoCtl=0, PVOID Context=NULL);
	virtual PIO_STACK_LOCATION getStack();

	virtual VOID copyStackToNext();
	virtual VOID copyCurrentStackToNext();

	virtual VOID setCompletion(PIO_COMPLETION_ROUTINE CompletionFunction=NULL);
	virtual VOID setDefaultCompletionFunction();
	virtual NTSTATUS  waitForCompletion();
	virtual NTSTATUS  waitForCompletion(LONG TimeOut);

	virtual VOID setDefaultCompletionEvent();
	virtual VOID setCompletionEvent(PKEVENT CompletionEvent);
	virtual VOID setStackDefaults();
	virtual VOID setCurrentStack();

	virtual NTSTATUS  onRequestComplete();


	virtual NTSTATUS copyBuffer(PUCHAR pBuffer, ULONG BufferLength);
	virtual PVOID	getBuffer();

	virtual ULONG	getReadLength();
	virtual VOID	setReadLength(ULONG length);

	virtual ULONG	getWriteLength();
	virtual VOID	setWriteLength(ULONG length);

	virtual VOID    setInformation(ULONG_PTR information);
	virtual ULONG_PTR   getInformation();
	virtual VOID    updateInformation();

	virtual NTSTATUS getSystemReply(PUCHAR pReply,ULONG Length);
	
	virtual VOID	setStatus(NTSTATUS status);
	virtual NTSTATUS getStatus();

	virtual VOID	setTimeout(LONG TimeOut);
	virtual ULONG	getTimeout();
};

#endif//IRP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\gempc430\irp.h ===
// Gemplus (C) 1999
// Version 1.0
// Author: Sergey Ivanov
// Date of creation - 18.05.1999
// Change log:
//

#ifndef IRP_INT
#define IRP_INT
#include "generic.h"

#pragma PAGEDCODE
class CIrp;
// Interface to general system services...
class CIrp
{
public:
	NTSTATUS m_Status;
	SAFE_DESTRUCTORS();
	virtual VOID dispose(){self_delete();};
protected:
	CIrp(){};
	virtual ~CIrp(){};
public:

	virtual PIRP		allocate(CCHAR StackSize,BOOLEAN ChargeQuota) {return NULL;};
	virtual	VOID		initialize(PIRP Irp,USHORT PacketSize,CCHAR StackSize) {};
	virtual	USHORT		sizeOfIrp(IN CCHAR StackSize) =0;


	virtual VOID		free(PIRP Irp) {};
	virtual PIRP		buildDeviceIoControlRequest(
						   IN ULONG IoControlCode,
						   IN PDEVICE_OBJECT DeviceObject,
						   IN PVOID InputBuffer OPTIONAL,
						   IN ULONG InputBufferLength,
						   IN OUT PVOID OutputBuffer OPTIONAL,
						   IN ULONG OutputBufferLength,
						   IN BOOLEAN InternalDeviceIoControl,
						   IN PKEVENT Event,
						   OUT PIO_STATUS_BLOCK IoStatusBlock
						   ) {return NULL;};

	virtual PIRP		buildSynchronousFsdRequest(
							IN ULONG MajorFunction,
							IN PDEVICE_OBJECT DeviceObject,
							IN OUT PVOID Buffer OPTIONAL,
							IN ULONG Length OPTIONAL,
							IN PLARGE_INTEGER StartingOffset OPTIONAL,
							IN PKEVENT Event,
							OUT PIO_STATUS_BLOCK IoStatusBlock
							){return NULL;};


	virtual PIO_STACK_LOCATION	getCurrentStackLocation(PIRP Irp) {return NULL;};
	virtual PIO_STACK_LOCATION	getNextStackLocation(PIRP Irp) {return NULL;};
	virtual VOID		skipCurrentStackLocation(PIRP Irp) {};
	virtual VOID		setNextStackLocation(IN PIRP Irp) {};
	virtual VOID		markPending(PIRP Irp) {};
	virtual VOID		copyCurrentStackLocationToNext(PIRP Irp) {};
	virtual VOID		setCompletionRoutine(PIRP Irp, PIO_COMPLETION_ROUTINE Routine, 
					PVOID Context, BOOLEAN Success, BOOLEAN Error, BOOLEAN Cancel ) {};
	virtual PDRIVER_CANCEL	setCancelRoutine(PIRP Irp, PDRIVER_CANCEL NewCancelRoutine ) {return NULL;};
	virtual VOID		completeRequest(PIRP Irp,CCHAR PriorityBoost) {};
	virtual VOID		startPacket(PDEVICE_OBJECT DeviceObject,PIRP Irp,PULONG Key,PDRIVER_CANCEL CancelFunction) {};
	virtual VOID		startNextPacket(PDEVICE_OBJECT DeviceObject,BOOLEAN Cancelable) {};

	virtual VOID		cancel(PIRP Irp) {};
	// Should it go to interrupt??
	virtual VOID		requestDpc(PDEVICE_OBJECT DeviceObject,PIRP Irp,PVOID Context) {};
};	

#endif//IRP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\gempc430\kernel.cpp ===
#include "kernel.h"
#include "usbdev.h"
#include "usbreader.h"
#include "lvprot.h"
#include "gemcore.h"

//$(WINICE)\nmsym.exe /translate:source,package,always  obj\checked\grclass.sys
#pragma LOCKEDCODE

//The global visible instance of the kernel and system object
CKernel* kernel = NULL;

// Some static kernel variable required initialization
LONG	CKernel::systemtype = 0; 
LONG	CKernel::refcount = 0;
CDebug*		CKernel::debug  = NULL;
CLogger*	CKernel::logger = NULL;
//CLinkedList<CUSBDevice> * CKernel::USBDeviceLinkHead = NULL;
//CLinkedList<CUSBReader> * CKernel::DeviceLinkHead = NULL;
//CLinkedList<CGBus> * CKernel::BusesLinkHead = NULL;

CLinkedList<CDevice> * CKernel::DeviceLinkHead = NULL;
// Instance number for the driver devices
ULONG CDevice::DeviceNumber = 0;

CKernel* CKernel::loadWDMKernel(VOID)
{
	if( kernel == NULL )
	{
		kernel = new (NonPagedPool) CKernel;
		if (!ALLOCATED_OK(kernel))
		{
			DISPOSE_OBJECT(kernel);
			return NULL;
		}
		systemtype = WDM_SYSTEM;
		refcount++;
       CKernel::DeviceLinkHead = new (NonPagedPool) CLinkedList<CDevice>;
		if (!ALLOCATED_OK(CKernel::DeviceLinkHead))
		{
			DISPOSE_OBJECT(CKernel::DeviceLinkHead);
			DISPOSE_OBJECT(kernel);
			return NULL;
		}

		debug = createDebug();
		if(!ALLOCATED_OK(debug))
		{
			DISPOSE_OBJECT(debug);
			DISPOSE_OBJECT(CKernel::DeviceLinkHead);
			DISPOSE_OBJECT(kernel);
			return NULL;
		}

		logger = createLogger();
		if(!ALLOCATED_OK(logger))
		{
			DISPOSE_OBJECT(logger);
			DISPOSE_OBJECT(debug);
			DISPOSE_OBJECT(CKernel::DeviceLinkHead);
			DISPOSE_OBJECT(kernel);
			return NULL;
		}
	}
	return kernel;
} 

CKernel* CKernel::loadNT4Kernel(VOID)
{
	if( kernel == NULL )
	{
		kernel = new (NonPagedPool) CKernel;
		if (!ALLOCATED_OK(kernel))	
		{
			DISPOSE_OBJECT(kernel);
			return NULL;
		}

		systemtype = NT4_SYSTEM;
		refcount++;
        CKernel::DeviceLinkHead = new (NonPagedPool) CLinkedList<CDevice>;
		if (!CKernel::DeviceLinkHead)
		{
			DISPOSE_OBJECT(CKernel::DeviceLinkHead);
			DISPOSE_OBJECT(kernel);
			return NULL;
		}

		
		debug = createDebug();
		if(!ALLOCATED_OK(debug))
		{
			DISPOSE_OBJECT(debug);
			DISPOSE_OBJECT(CKernel::DeviceLinkHead);
			DISPOSE_OBJECT(kernel);
			return NULL;
		}

		logger = createLogger();
		if(!ALLOCATED_OK(logger))
		{
			DISPOSE_OBJECT(logger);
			DISPOSE_OBJECT(debug);
			DISPOSE_OBJECT(CKernel::DeviceLinkHead);
			DISPOSE_OBJECT(kernel);
			return NULL;
		}
	}
	return kernel;
}

CKernel* CKernel::loadWin9xKernel(VOID)
{
	if( kernel == NULL )
	{
		kernel = new (NonPagedPool) CKernel;
		if (!ALLOCATED_OK(kernel))
		{
			DISPOSE_OBJECT(kernel);
			return NULL;
		}

		systemtype = WIN9X_SYSTEM;
		refcount++;
        CKernel::DeviceLinkHead = new (NonPagedPool) CLinkedList<CDevice>;

		if (!CKernel::DeviceLinkHead)
		{
			DISPOSE_OBJECT(CKernel::DeviceLinkHead);
			DISPOSE_OBJECT(kernel);
			return NULL;
		}

		debug = createDebug();
		if(!ALLOCATED_OK(debug))
		{
			DISPOSE_OBJECT(debug);
			DISPOSE_OBJECT(CKernel::DeviceLinkHead);
			DISPOSE_OBJECT(kernel);
			return NULL;
		}

		logger = createLogger();
		if(!ALLOCATED_OK(logger))
		{
			DISPOSE_OBJECT(logger);
			DISPOSE_OBJECT(debug);
			DISPOSE_OBJECT(CKernel::DeviceLinkHead);
			DISPOSE_OBJECT(kernel);
			return NULL;
		}
	}
	return kernel;
}



VOID CKernel::dispose(VOID)
{	
	refcount--;
	if(refcount<=0)
	{
		TRACE("Unload: Removing all registered devices...\n");

		delete DeviceLinkHead;    // this will kill all attached devices

		if(kernel->RegistryPath)
		{
			kernel->RegistryPath->dispose();
		}

		if(debug)  debug->dispose();
		if(logger) logger->dispose();
		self_delete();
		kernel = NULL; 
	}
}

CSystem*    CKernel::createSystem(VOID)
{
	if(systemtype==WDM_SYSTEM)
	{
		CSystem* obj = CWDMSystem::create();
		RETURN_VERIFIED_OBJECT(obj);
	}
	return NULL;
}

CMemory*    CKernel::createMemory(VOID)
{
	if(systemtype==WDM_SYSTEM)
	{
		CMemory* obj = CWDMMemory::create();
		RETURN_VERIFIED_OBJECT(obj);
	}
	return NULL;
}

CIrp*		CKernel::createIrp(VOID)
{
	if(systemtype==WDM_SYSTEM)
	{
		CIrp* obj = CWDMIrp::create();
		RETURN_VERIFIED_OBJECT(obj);
	}
	return NULL;
}

CEvent*		CKernel::createEvent(VOID)
{
	if(systemtype==WDM_SYSTEM)
	{
		CEvent* obj = CWDMEvent::create();
		RETURN_VERIFIED_OBJECT(obj);
	}
	return NULL;
}

CSemaphore*		CKernel::createSemaphore(VOID)
{
	if(systemtype==WDM_SYSTEM)
	{
		CSemaphore* obj = CWDMSemaphore::create();
		RETURN_VERIFIED_OBJECT(obj);
	}
	return NULL;
}

CInterrupt* CKernel::createInterrupt(VOID)
{
	if(systemtype==WDM_SYSTEM)
	{
		CInterrupt* obj = CWDMInterrupt::create();
		RETURN_VERIFIED_OBJECT(obj);
	}
	return NULL;
}

CLock*  CKernel::createLock(VOID)
{
	if(systemtype==WDM_SYSTEM)
	{
		CLock* obj = CWDMLock::create();
		RETURN_VERIFIED_OBJECT(obj);
	}
	return NULL;
}


CPower*		CKernel::createPower(VOID)
{
	if(systemtype==WDM_SYSTEM)
	{
		CPower* obj = CWDMPower::create();
		RETURN_VERIFIED_OBJECT(obj);
	}
	return NULL;
}

CDebug*		CKernel::createDebug(VOID)
{
	// Only one debug module exist at system
	// It will be shared between all objects
	if(debug)
	{
		debug->incrementUsage();
		//TRACE("				Debug object reused %d times\n",);
		return debug;
	}
	if(systemtype==WDM_SYSTEM)
	{
		CDebug* d = CWDMDebug::create();
		if(!ALLOCATED_OK(d))
		{
			DISPOSE_OBJECT(d);
			return NULL;
		}

		d->incrementUsage();
		return d;
	}
	return NULL;
}


VOID CKernel::registerObject(PDEVICE_OBJECT fdo,CDevice* device)
{

	fdo->DeviceExtension = device;
	if(!ALLOCATED_OK(device)) return;
	if(device->m_Type!=CHILD_DEVICE)
	{
		if(DeviceLinkHead)	DeviceLinkHead->New(device);
	}
}

VOID CKernel::unregisterObject(PDEVICE_OBJECT fdo)
{
CDevice* device;
	device = ((CDevice*)fdo->DeviceExtension);
	fdo->DeviceExtension = NULL;
	if(!ALLOCATED_OK(device)) return;
	if(device->m_Type!=CHILD_DEVICE) DeviceLinkHead->remove(device);
}

CDevice* CKernel::getRegisteredDevice(PDEVICE_OBJECT fdo)
{
	return getObjectPointer(fdo);
}

CReaderInterface* CKernel::createReaderInterface(LONG interfaceType,LONG protocolType,CDevice* device)
{
CProtocol* protocol = NULL;
//CReaderInterface* interface = NULL;
CGemCore* interface = NULL;// TOBE CHANGED
	switch(protocolType)
	{
	case READER_PROTOCOL_LV:
	default:
		protocol = new (NonPagedPool) CLVProtocol(device);// TO CHANGE LATER...
		break;
	}
	if(!ALLOCATED_OK(protocol))
	{
		DISPOSE_OBJECT(protocol);
		return NULL;
	}

	switch(interfaceType)
	{
	case READER_INTERFACE_GEMCORE:
	default:
		interface = new (NonPagedPool) CGemCore(protocol);
		break;
	}
	if(!ALLOCATED_OK(interface))
	{
		DISPOSE_OBJECT(interface);
		DISPOSE_OBJECT(protocol);
		return NULL;
	}
	return interface;
};

CTimer*		CKernel::createTimer(TIMER_TYPE Type)
{
	if(systemtype==WDM_SYSTEM)
	{
		CTimer* obj = CWDMTimer::create(Type);
		RETURN_VERIFIED_OBJECT(obj);
	}
	return NULL;
}

CLogger*	CKernel::createLogger()
{
	if(logger)
	{
		logger->incrementUsage();
		return logger;
	}
	if(systemtype==WDM_SYSTEM)
	{
		logger = CWDMLogger::create();
		if(!ALLOCATED_OK(logger))
		{
			DISPOSE_OBJECT(logger);
			return NULL;
		}
		logger->incrementUsage();
		return logger;
	}
	return NULL;
}

#ifdef	USBREADER_PROJECT
#ifndef USBDEVICE_PROJECT
#define USBDEVICE_PROJECT
#endif
#endif

#ifdef USBDEVICE_PROJECT
CUSBDevice*    CKernel::createUSBDevice(VOID)
{
	if(systemtype==WDM_SYSTEM)
	{
		CUSBDevice* obj =  new (NonPagedPool) CUSBDevice;
		RETURN_VERIFIED_OBJECT(obj);
	}
	return NULL;
}
#endif

#ifdef	USBREADER_PROJECT
CUSBReader*	CKernel::createUSBReader(VOID)
{
	if(systemtype==WDM_SYSTEM)
	{
		CUSBReader* obj = new (NonPagedPool) CUSBReader;
		RETURN_VERIFIED_OBJECT(obj);
	}
	return NULL;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\gempc430\lock.h ===
// Gemplus (C) 1999
// Version 1.0
// Author: Sergey Ivanov
// Date of creation - 18.05.1999
// Change log:
//
#ifndef LOCK_INT
#define LOCK_INT
#include "generic.h"

#pragma PAGEDCODE
class CLock
{
public:
	NTSTATUS m_Status;
	SAFE_DESTRUCTORS();
	virtual VOID dispose(){self_delete();};
protected:
	CLock(){};
	virtual ~CLock(){};
public:

	virtual VOID	initializeSpinLock(PKSPIN_LOCK SpinLock) {};
	virtual VOID	acquireSpinLock(PKSPIN_LOCK SpinLock, PKIRQL oldIrql) {};
	virtual VOID	releaseSpinLock(PKSPIN_LOCK SpinLock, KIRQL oldIrql)  {};
	virtual VOID	acquireCancelSpinLock(PKIRQL Irql)	{};
	virtual VOID	releaseCancelSpinLock(KIRQL Irql)	{};
	virtual LONG	interlockedIncrement(IN PLONG  Addend) {return 0;};
	virtual LONG	interlockedDecrement(IN PLONG  Addend) {return 0;};
};	

#endif//CLock
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\gempc430\kernel.h ===
//-------------------------------------------------------------------
// This is main object
// It starts all life of the system.
// Author: Sergey Ivanov
// Log:
//		06/08/99	-	implemented	
//-------------------------------------------------------------------

/**********************************************************/
#ifndef __KERNEL__
#define __KERNEL__

// System includes
#include "generic.h"

// Objects supported by the kernel
// Client side
#include "device.h"
#include "system.h"
#include "memory.h"
#include "irp.h"
#include "event.h"
#include "semaphore.h"
#include "int.h"
#include "power.h"
#include "debug.h"
#include "logger.h"
#include "lock.h"
#include "reader.h"
#include "interface.h"
#include "protocol.h"
#include "smartcard.h"
#include "rdrconfig.h"
#include "iopack.h"
#include "timer.h"

/**********************************************************/
#pragma LOCKEDCODE
class CGBus;
class CChild;
class CUSBDevice;
class CUSBReader;
class CKernel;
class CDevice;
class CReaderInterface;

/*
 There is only one instance of the class CKernel
*/
class CKernel
{
public:
    NTSTATUS m_Status;
	SAFE_DESTRUCTORS();
	virtual VOID dispose(VOID);
public:
	~CKernel(VOID){};

	// Return the kernel object.
	static CKernel* loadWDMKernel(VOID);
	static CKernel* loadNT4Kernel(VOID);
	static CKernel* loadWin9xKernel(VOID);
	LONG			getSystemType(VOID){return systemtype;};
	CDebug*		getDebug(VOID){return debug;};
	CLogger*	getLogger(VOID){return logger;};

#ifdef	USBREADER_PROJECT
#ifndef USBDEVICE_PROJECT
#define USBDEVICE_PROJECT
#endif
#endif

	// This is kernel system objects factory
#ifdef	USBDEVICE_PROJECT
	static CUSBDevice*	createUSBDevice(VOID);
#endif
#ifdef	USBREADER_PROJECT
	static CUSBReader*	createUSBReader(VOID);
#endif
#ifdef	BUS_PROJECT
	static CDevice*		createBus(VOID);
	static CDevice*		createChild(CGBus*  parent,LONG instanceID);
	static CDevice*		createChild(CGBus*  parent,IN PUNICODE_STRING DeviceName,LONG instanceID);
#endif
	// Objects driver can create
	static CSystem*		createSystem(VOID);	
	static CMemory*		createMemory(VOID); 
	static CIrp*		createIrp(VOID);
	static CEvent*		createEvent(VOID);
	static CSemaphore*	createSemaphore(VOID);
	static CInterrupt*	createInterrupt(VOID);
	static CPower*		createPower(VOID);
	static CLock*		createLock(VOID);
	static CDebug*		createDebug(VOID);
	static CTimer*		createTimer(TIMER_TYPE Type);
	// Creates interface to comminicate with reader...
	static CReaderInterface* createReaderInterface(LONG interfaceType,LONG protocolType,CDevice* device);
	static CLogger*		createLogger(VOID);
	
	// Device registration function
	// Register device at driver
	static VOID registerObject(PDEVICE_OBJECT fdo,CDevice* dev);
	static VOID unregisterObject(PDEVICE_OBJECT fdo);
	static CDevice* getRegisteredDevice(PDEVICE_OBJECT fdo);
public:
	CUString* RegistryPath;
	// Linked list of device objects
	static CLinkedList<CDevice>	   *DeviceLinkHead;

private:
	static LONG	systemtype; 
	static LONG	refcount;
	static CDebug*		debug;
	static CLogger*		logger;
private:
	CKernel(){};
};

typedef enum _SYSTEM_TYPE_ 
{
    WDM_SYSTEM = 1,
    NT4_SYSTEM,
    WIN9X_SYSTEM
} SYSTEM_TYPE;


#define CALLBACK_FUNCTION(f) ::f

#define DECLARE_CALLBACK_VOID0(f)	VOID f(PDEVICE_OBJECT pDO)
#define DECLARE_CALLBACK_BOOL0(f)	BOOL f(PDEVICE_OBJECT pDO)
#define DECLARE_CALLBACK_LONG0(f)	NTSTATUS f(PDEVICE_OBJECT pDO)
// functions which take two argument
#define DECLARE_CALLBACK_VOID1(f,type)	VOID f(PDEVICE_OBJECT pDO,type arg)
#define DECLARE_CALLBACK_LONG1(f,type)	NTSTATUS f(PDEVICE_OBJECT pDO,type arg)
// functions which can take three argument
#define DECLARE_CALLBACK_LONG2(f,type1,type2)	NTSTATUS f(PDEVICE_OBJECT pDO,type1 arg1, type2 arg2)

//C wrapper for the DPC function
#define DECLARE_CALLBACK_DPCR(fname,type1,type2)	VOID fname(PKDPC Dpc, PDEVICE_OBJECT pDO,type1 arg1, type2 arg2)
#define DECLARE_CALLBACK_ISR(fname)		BOOL fname(struct _KINTERRUPT *Interrupt,PDEVICE_OBJECT pDO)


// This will be used to create callback functions
//#define CDEVICE(pDo)	((CDevice*)pDo->DeviceExtension)
inline CDevice* getObjectPointer(PDEVICE_OBJECT pDo)
{
	//DBG_PRINT("Object %8.8lX was called\n",pDo);
	if(!pDo || !pDo->DeviceExtension)
	{
		DBG_PRINT("\n****** ERROR! Device %8.8lX ????, CDevice %8.8lX>>> ",pDo,pDo->DeviceExtension);
		return NULL; // Object was removed...
	}

	ULONG type = ((CDevice*)pDo->DeviceExtension)->m_Type;
	switch(type)
	{
	case USB_DEVICE:
		{
			//DBG_PRINT("\nUSB_DEVICE %8.8lX >>> ",(CDevice*)((CUSBDevice*)pDo->DeviceExtension));
			return ((CDevice*)((CUSBDevice*)pDo->DeviceExtension)); break;
		}
	case USBREADER_DEVICE:
		{
			//DBG_PRINT("\nUSBREADER_DEVICE %8.8lX >>> ",(CDevice*)((CUSBReader*)pDo->DeviceExtension));
			return ((CDevice*)((CUSBReader*)pDo->DeviceExtension)); break;
		}
	default:
		DBG_PRINT("\n****** ERROR! Device %8.8lX ????, CDevice %8.8lX>>> ",pDo,pDo->DeviceExtension);
		return ((CDevice*)pDo->DeviceExtension);
	}
};
#define CDEVICE(pDo)  getObjectPointer(pDo)
// functions which take one argument -> device object
#define IMPLEMENT_CALLBACK_VOID0(f)	\
			VOID f(PDEVICE_OBJECT pDO)\
				{if(CDEVICE(pDO)) CDEVICE(pDO)->f();}
#define IMPLEMENT_CALLBACK_BOOL0(f)	\
			BOOL f(PDEVICE_OBJECT pDO) \
				{if(!CDEVICE(pDO)) return FALSE; return CDEVICE(pDO)->f();}
#define IMPLEMENT_CALLBACK_LONG0(f)	\
			NTSTATUS f(PDEVICE_OBJECT pDO) \
				{if(!CDEVICE(pDO)) return STATUS_INVALID_HANDLE; return CDEVICE(pDO)->f();}
// functions which take two argument
#define IMPLEMENT_CALLBACK_VOID1(f,type)\
		VOID f(PDEVICE_OBJECT pDO,type arg)\
				{if(CDEVICE(pDO)) CDEVICE(pDO)->f(arg);}
#define IMPLEMENT_CALLBACK_LONG1(f,type)	\
		NTSTATUS f(PDEVICE_OBJECT pDO,type arg)\
				{if(!CDEVICE(pDO)) return STATUS_INVALID_HANDLE; return CDEVICE(pDO)->f(arg);}
// functions which can take three argument
#define IMPLEMENT_CALLBACK_LONG2(f,type1,type2)\
		NTSTATUS f(PDEVICE_OBJECT pDO,type1 arg1, type2 arg2)\
				{if(!CDEVICE(pDO)) return STATUS_INVALID_HANDLE; return CDEVICE(pDO)->f(arg1, arg2);}

//C wrapper for the DPC function
#define IMPLEMENT_CALLBACK_DPCR(fname,type1,type2)	\
			VOID fname(PKDPC Dpc, PDEVICE_OBJECT pDO,type1 arg1, type2 arg2)\
				{if(CDEVICE(pDO)) CDEVICE(pDO)->DpcForIsr(Dpc, arg1,arg2);}

#define IMPLEMENT_CALLBACK_ISR(fname)	\
			BOOL fname(struct _KINTERRUPT *Interrupt,PDEVICE_OBJECT pDO)\
				{if(CDEVICE(pDO)) return CDEVICE(pDO)->fname();}


//A global reference to the one and only kernel object
extern CKernel*	kernel;

// System side
// WDM system
#ifdef WDM_KERNEL
#include "wdmsys.h"
#include "wdmmem.h"
#include "wdmirp.h"
#include "wdmevent.h"
#include "wdmsem.h"
#include "wdmint.h"
#include "wdmlock.h"
#include "wdmpower.h"
#include "wdmdebug.h"
#include "wdmlog.h"
#include "wdmtimer.h"
//#include "wdmdev.h"

#endif

// Specific supported devices
//#include "usbdev.h"

#pragma LOCKEDCODE
// Declare used device callbacks...
#ifndef _DEVICE_CALLBACKS_
#define _DEVICE_CALLBACKS_
DECLARE_CALLBACK_LONG1(open,IN PIRP);
DECLARE_CALLBACK_LONG1(close,IN PIRP);

DECLARE_CALLBACK_LONG1(read,IN PIRP);
DECLARE_CALLBACK_LONG1(write,IN PIRP);
DECLARE_CALLBACK_VOID1(startIo,IN PIRP);

DECLARE_CALLBACK_LONG1(deviceControl,IN PIRP);


DECLARE_CALLBACK_LONG1(flush,IN PIRP);
DECLARE_CALLBACK_LONG1(cleanup,IN PIRP);

DECLARE_CALLBACK_LONG1(powerRequest,IN PIRP);

NTSTATUS pnpRequest(IN PDEVICE_OBJECT fdo,IN PIRP Irp);

DECLARE_CALLBACK_VOID1(cancelPendingIrp,IN PIRP);

VOID onSendDeviceSetPowerComplete(PDEVICE_OBJECT junk, UCHAR fcn, POWER_STATE state, PPOWER_CONTEXT context, PIO_STATUS_BLOCK pstatus);

#endif

#endif//KERNEL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\gempc430\iopack.cpp ===
#include "iopack.h"
#include "kernel.h"

#pragma LOCKEDCODE
NTSTATUS onRequestComplete(PDEVICE_OBJECT pDO,IN PIRP Irp, IN PVOID context)
{
	//DBG_PRINT("		======= Request completion Irp %8.8lX, Packet %8.8lX\n",Irp,context);
	CIoPacket* packet = (CIoPacket*) context;
	if(packet)
	{
		return packet->onRequestComplete();
	}
	return STATUS_MORE_PROCESSING_REQUIRED;
}

#pragma PAGEDCODE
CIoPacket::CIoPacket(UCHAR StackSize)
{
	m_Status = STATUS_INSUFFICIENT_RESOURCES;
	systemIrp = FALSE;
	m_DoNotFreeIrp = FALSE;
	CompletionEvent = NULL;
	IoStatus.Status = STATUS_SUCCESS;
	IoStatus.Information = 0;
	SystemBuffer = NULL;
	m_Irp = NULL;
	m_TimeOut = 60000;// Default timeout 60 seconds for any kind of IORequest

	__try
	{
		debug  = kernel->createDebug();
		memory = kernel->createMemory();
		event  = kernel->createEvent();
		irp    = kernel->createIrp();

		if(	!ALLOCATED_OK(memory) || !ALLOCATED_OK(event) ||
			!ALLOCATED_OK(irp)) __leave;

		SystemBuffer = memory->allocate(NonPagedPool,PAGE_SIZE);
		if(!SystemBuffer) __leave;
		m_Irp = irp->allocate(StackSize+1, FALSE);
		if (!m_Irp)		  __leave;
		irp->initialize(m_Irp,irp->sizeOfIrp(StackSize+1),StackSize+1);
		Stack = *(irp->getNextStackLocation(m_Irp));
		irp->setCompletionRoutine(m_Irp,CALLBACK_FUNCTION(onRequestComplete),NULL,TRUE,TRUE,TRUE);
		m_Status = STATUS_SUCCESS;
	}
	__finally
	{
		if(!NT_SUCCESS(m_Status))
		{
			// Remove all allocated objects...
			// In this constructor we know that it is not system Irp...
			TRACE("FAILED TO CREATE IoPacket object %x\n",m_Status);
			TRACE("SystemBuffer - %x\n",SystemBuffer);
			TRACE("debug - %x, memory - %x\n",debug,memory);
			TRACE("event - %x, irp - %x\n",event,irp);

			if(ALLOCATED_OK(memory))
			{
				if(SystemBuffer) memory->free(SystemBuffer);
				SystemBuffer = NULL;
			}

			if(ALLOCATED_OK(irp))
			{
				if(m_Irp) irp->free(m_Irp);
				m_Irp = NULL;
			}
			DISPOSE_OBJECT(irp);
			DISPOSE_OBJECT(event);
			DISPOSE_OBJECT(memory);
			DISPOSE_OBJECT(debug);
		}
	}
};

	
CIoPacket::CIoPacket(PIRP Irp)
{
	m_Status = STATUS_INSUFFICIENT_RESOURCES;
	systemIrp = TRUE;
	m_DoNotFreeIrp = FALSE;
	CompletionEvent = NULL;
	IoStatus.Status = STATUS_SUCCESS;
	IoStatus.Information = 0;
	SystemBuffer = NULL;
	m_TimeOut = 60000;// Default timeout 60 seconds for any kind of IORequest
	m_Irp = NULL;

	__try
	{
		if(!Irp) __leave;

		debug  = kernel->createDebug();
		memory = kernel->createMemory();
		event  = kernel->createEvent();
		irp    = kernel->createIrp();

		if(	!ALLOCATED_OK(memory) || !ALLOCATED_OK(event) ||
			!ALLOCATED_OK(irp))		__leave;
		m_Irp = Irp;
		Stack = *(irp->getNextStackLocation(m_Irp));
		SystemBuffer = m_Irp->AssociatedIrp.SystemBuffer;
		// We do not care here if system buffers is NULL
		// but we will not copy data if it will be not initialized (NULL)
		m_Status = STATUS_SUCCESS;
	}
	__finally
	{
		if(!NT_SUCCESS(m_Status))
		{
			TRACE("FAILED TO CREATE IoPacket object %x\n",m_Status);
			TRACE("SystemBuffer - %x, Irp - %x\n",SystemBuffer,Irp);
			TRACE("debug - %x, memory - %x\n",debug,memory);
			TRACE("event - %x, irp - %x\n",event,irp);
			// Remove all allocated objects...
			DISPOSE_OBJECT(irp);
			DISPOSE_OBJECT(event);
			DISPOSE_OBJECT(memory);
			DISPOSE_OBJECT(debug);
		}
	}
};

CIoPacket::~CIoPacket()
{
	if(!systemIrp)
	{
		if(SystemBuffer) memory->free(SystemBuffer);
		SystemBuffer = NULL;
	}

	DISPOSE_OBJECT(irp);
	DISPOSE_OBJECT(event);
	DISPOSE_OBJECT(memory);
	DISPOSE_OBJECT(debug);
};

VOID CIoPacket::setMajorIOCtl(UCHAR controlCode)
{
	Stack.MajorFunction = controlCode;
};

UCHAR CIoPacket::getMajorIOCtl()
{				
	return Stack.MajorFunction;
};
	
VOID CIoPacket::setMinorIOCtl(UCHAR controlCode)
{
	Stack.MinorFunction = controlCode;
};

NTSTATUS    CIoPacket::buildStack(PDEVICE_OBJECT DeviceObject, ULONG Major, UCHAR Minor, ULONG IoCtl, PVOID Context)
{
	// Create copy of the next stack
	if(!m_Irp) return STATUS_INVALID_DEVICE_STATE;

	Stack = *(irp->getNextStackLocation(m_Irp));
	Stack.DeviceObject = DeviceObject;
	switch(Major)
	{
	case IRP_MJ_INTERNAL_DEVICE_CONTROL:
		{
			// Set stack parameters...
			Stack.MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
			Stack.Parameters.Others.Argument1 = Context;
			Stack.Parameters.DeviceIoControl.IoControlCode = IoCtl;
		}
		break;
	case IRP_MJ_PNP:
		{
			// Set stack parameters...
			Stack.MajorFunction = IRP_MJ_PNP;
			Stack.MinorFunction = Minor;
			if(Minor==IRP_MN_QUERY_CAPABILITIES)
			{
				Stack.Parameters.DeviceCapabilities.Capabilities = (PDEVICE_CAPABILITIES) Context;
			}
		}
		break;
	default:
		// Copy current stack location to next...
		if(systemIrp)	Stack = *(irp->getCurrentStackLocation(m_Irp));
		else
		{
			Stack.DeviceObject = DeviceObject;
			Stack.MajorFunction = (UCHAR)Major;
			Stack.MinorFunction = Minor;
		}
	}
	return STATUS_SUCCESS;
};

VOID  CIoPacket::copyStackToNext()
{
PIO_STACK_LOCATION	nextStack;
	if(!m_Irp) return;

	nextStack = irp->getNextStackLocation(m_Irp);
	if(nextStack)	*nextStack = Stack;
};

VOID  CIoPacket::copyCurrentStackToNext()
{
	if(!m_Irp) return;
	irp->copyCurrentStackLocationToNext(m_Irp);
}

// Function will set completion routine for the Irp.
VOID   CIoPacket::setCompletion(PIO_COMPLETION_ROUTINE CompletionFunction)
{
PIO_COMPLETION_ROUTINE Completion;
	if(!m_Irp) return;
	Completion = CompletionFunction==NULL ? CALLBACK_FUNCTION(onRequestComplete) : CompletionFunction;
	if(m_Irp) irp->setCompletionRoutine(m_Irp,Completion,this,TRUE,TRUE,TRUE);
};

VOID   CIoPacket::setDefaultCompletionFunction()
{
	if(m_Irp) irp->setCompletionRoutine(m_Irp,CALLBACK_FUNCTION(onRequestComplete),this,TRUE,TRUE,TRUE);
};

NTSTATUS CIoPacket::copyBuffer(PUCHAR pBuffer, ULONG BufferLength)
{
	if(!pBuffer || !BufferLength || BufferLength>PAGE_SIZE)  return STATUS_INVALID_PARAMETER;
	if(m_Irp)
	{
		if(!systemIrp)
		{
			if(!m_Irp->AssociatedIrp.SystemBuffer)
			{
				if(!SystemBuffer)
				{
					SystemBuffer = memory->allocate(NonPagedPool,PAGE_SIZE);
					if(!SystemBuffer)  return STATUS_INSUFFICIENT_RESOURCES;
				}
				m_Irp->AssociatedIrp.SystemBuffer = SystemBuffer;
			}
		}

		if(m_Irp->AssociatedIrp.SystemBuffer)
			memory->copy(m_Irp->AssociatedIrp.SystemBuffer,pBuffer,BufferLength);
		else
		{
			TRACE("	***** AssociatedIrp SYSTEM BUFFER IS NULL!\nFailed to copy bus driver reply with len %x!\n",BufferLength);
		}
		return STATUS_SUCCESS;
	}
	else return STATUS_INSUFFICIENT_RESOURCES;
};

PIO_STACK_LOCATION CIoPacket::getStack()
{
	return &Stack;
};

PVOID CIoPacket::getBuffer()
{
	return SystemBuffer;
};

ULONG CIoPacket::getReadLength()
{
	return Stack.Parameters.Read.Length;
};

VOID CIoPacket::setWriteLength(ULONG length)
{
	Stack.Parameters.Write.Length = length;
};

VOID CIoPacket::setReadLength(ULONG length)
{
	Stack.Parameters.Read.Length = length;
};

ULONG CIoPacket::getWriteLength()
{
	return Stack.Parameters.Write.Length;
};

VOID CIoPacket::setInformation(ULONG_PTR information)
{
	if(m_Irp)	m_Irp->IoStatus.Information = information;
	IoStatus.Information		= information;
};

ULONG_PTR CIoPacket::getInformation()
{
	return IoStatus.Information;
};

VOID    CIoPacket::updateInformation()
{
	if(m_Irp)	IoStatus.Information = m_Irp->IoStatus.Information;
};

NTSTATUS CIoPacket::getSystemReply(PUCHAR pReply,ULONG Length)
{
	if(!pReply || !Length || Length> PAGE_SIZE)  return STATUS_INVALID_PARAMETER;
	if(SystemBuffer)
	{
		memory->copy(pReply,SystemBuffer,Length);
		return STATUS_SUCCESS;
	}
	else return STATUS_INSUFFICIENT_RESOURCES;
};

#pragma LOCKEDCODE
NTSTATUS	CIoPacket::onRequestComplete()
{ // Callback to finish previously sended request
	TRACE("		=======> IoPacket processes Completion()\n");
	if(systemIrp)
	{
		if (m_Irp->PendingReturned)
		{
			TRACE("		Irp marked as pending...\n");
			irp->markPending(m_Irp);
		}
	}

	IoStatus.Status = m_Irp->IoStatus.Status;
	IoStatus.Information = m_Irp->IoStatus.Information;
	TRACE("		Irp completes with status %8.8lX , info %8.8lX\n",IoStatus.Status,IoStatus.Information);
	if(!systemIrp)
	{
		if(!m_DoNotFreeIrp)
		{
			PIRP  Irp = m_Irp;
			m_Irp = NULL;
			if(Irp) irp->free(Irp);
		}
	}
	if(CompletionEvent)	event->set(CompletionEvent,IO_NO_INCREMENT,FALSE);
	return STATUS_MORE_PROCESSING_REQUIRED;
};

#pragma PAGEDCODE
VOID CIoPacket::setCompletionEvent(PKEVENT CompletionEvent)
{
	if(CompletionEvent)
	{
		this->CompletionEvent = CompletionEvent;
	}
}

VOID CIoPacket::setStatus(NTSTATUS status)
{
	IoStatus.Status = status;
}

NTSTATUS CIoPacket::getStatus()
{
	return IoStatus.Status;
}

VOID  CIoPacket::setDefaultCompletionEvent()
{
	event->initialize(&DefaultCompletionEvent,NotificationEvent, FALSE);	
	setCompletionEvent(&DefaultCompletionEvent);
}

NTSTATUS  CIoPacket::waitForCompletion()
{	// Set current timeout
	return waitForCompletion(getTimeout());
}

NTSTATUS  CIoPacket::waitForCompletion(LONG TimeOut)
{
	// Because we set Alertable parameter to FALSE,
	// there are only two possible statuses from the function STATUS_SUCCESS and
	// STATUS_TIMEOUT...

	// We should not try to cancel system Irps!
	if(systemIrp)
	{
	NTSTATUS status;
		status = event->waitForSingleObject(CompletionEvent, Executive,KernelMode, FALSE, NULL);
		if(!NT_SUCCESS(status))
		{	
			TRACE("waitForCompletion() reports error %x\n", status);
			setStatus(STATUS_IO_TIMEOUT);
			setInformation(0);
		}			
		status = getStatus();
		return status;
	}
	else
	{
	LARGE_INTEGER timeout;
    timeout.QuadPart = -TimeOut * 10000;
  		if (event->waitForSingleObject(CompletionEvent, Executive, KernelMode, FALSE, &timeout) == STATUS_TIMEOUT)
		{
		KIRQL oldIrql;
			// Ok! We've got timeout..
			// Completion function still can be called.
			 // First tell completion not to free our Irp
			IoAcquireCancelSpinLock(&oldIrql);
				if(m_Irp) m_DoNotFreeIrp = TRUE;
			IoReleaseCancelSpinLock(oldIrql);
			
			DEBUG_START();
			TRACE("######## waitForCompletion() reports TIMEOUT after %d msec ############\n",getTimeout());
			if(m_Irp)
			{
				irp->cancel(m_Irp);  //  okay in this context
				// Wait for the cancel callback to be called
				event->waitForSingleObject(CompletionEvent, Executive, KernelMode, FALSE, NULL);
				TRACE("######## Current Irp cancelled!!! ############\n");
				// Now we can safely free our Irp
				if(m_DoNotFreeIrp)
				{
					if(m_Irp) irp->free(m_Irp);
					m_Irp = NULL;
					m_DoNotFreeIrp = FALSE;
				}
				// Report Irp timeout
				setStatus(STATUS_IO_TIMEOUT);
				setInformation(0);
			}
		}
		return getStatus();
	}
}

VOID  CIoPacket::setStackDefaults()
{
	setDefaultCompletionEvent();
	copyStackToNext();
	setDefaultCompletionFunction();
}

// Normally IoPacket will be created on the next stack location.
// The function allows to take current stack location.
// It is useful if we want to forward system IRP down the stack.
VOID  CIoPacket::setCurrentStack()
{
	if(m_Irp) Stack = *(irp->getCurrentStackLocation(m_Irp));
}


VOID	CIoPacket::setTimeout(LONG TimeOut)
{
	m_TimeOut = TimeOut;
};

ULONG	CIoPacket::getTimeout()
{
	return m_TimeOut;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\gempc430\logger.h ===
#ifndef __LOG__
#define __LOG__
#include "generic.h"

#pragma PAGEDCODE
class CLogger
{
public:
	NTSTATUS m_Status;
	SAFE_DESTRUCTORS();
	virtual VOID dispose(){self_delete();};
private:
	LONG usage;
public:
	CLogger(){};
	virtual ~CLogger(){};
	virtual VOID logEvent(NTSTATUS ErrorCode, PDEVICE_OBJECT fdo) {};
	LONG		incrementUsage(){return ++usage;};
	LONG		decrementUsage(){return --usage;};
};

// Message definition file for EventLog driver
// Copyright (C) 1999 by Walter Oney
// All rights reserved
//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_EVENTLOG_ERROR_CODE     0x2A


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: EVENTLOG_MSG_TEST
//
// MessageText:
//
//  %2 said, "Hello, world!"
//
#define EVENTLOG_MSG_TEST                ((NTSTATUS)0x602A0001L)


#endif//LOGGER
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\gempc430\lvprot.cpp ===
#include "lvprot.h"
#include "usbreader.h"// TO REMOVE LATER....

#pragma PAGEDCODE
VOID  CLVProtocol::set_WTR_Delay(LONG Delay)
{
	if(device) device->set_WTR_Delay(Delay);
}

#pragma PAGEDCODE
ULONG CLVProtocol::get_WTR_Delay()
{
	if(device) return device->get_WTR_Delay();
	else return 0;
}

#pragma PAGEDCODE
VOID  CLVProtocol::set_Default_WTR_Delay()
{
	if(device) device->set_Default_WTR_Delay();
}

#pragma PAGEDCODE
LONG  CLVProtocol::get_Power_WTR_Delay()
{
	if(device) return device->get_Power_WTR_Delay();
	else return 0;
}


#pragma PAGEDCODE
ULONG CLVProtocol::getCardState()
{
	if(device) return device->getCardState();
	else return 0;
}



#pragma PAGEDCODE
NTSTATUS CLVProtocol::writeAndWait(BYTE* pRequest,ULONG RequestLength,BYTE* pReply,ULONG* pReplyLength)
{
ULONG BufferLength;
NTSTATUS status;
	if(device)
	{
		if(!pRequest || !RequestLength || !pReply 
			|| !pReplyLength || !*pReplyLength  || RequestLength>=PROTOCOL_OUTPUT_BUFFER_SIZE)
		{

			TRACE("writeAndWait(): INVALID PARAMETERS PROVIDED FOR PROTOCOL!...\n");
			ASSERT(FALSE);
			return STATUS_INVALID_PARAMETER;
		}
		__try
		{
			pOutputBuffer[0] = (UCHAR)RequestLength;
			memory->copy(pOutputBuffer+1,pRequest, RequestLength+1);

			TRACE("LV protocol: writeAndWait()");
			TRACE_BUFFER(pOutputBuffer,RequestLength+1);
			BufferLength = InputBufferLength;
			status = device->writeAndWait(pOutputBuffer,RequestLength+1,pInputBuffer,&BufferLength);
			if(!NT_SUCCESS(status))
			{
				*pReplyLength = 0;
				__leave;
			}
			if(BufferLength>*pReplyLength)
			{
				*pReplyLength = 0;
				status =  STATUS_INSUFFICIENT_RESOURCES;
				__leave;
			}

			//Skip length byte
			if(BufferLength>1)	BufferLength--;
			*pReplyLength = BufferLength;
			if(BufferLength)
			{
				memory->copy(pReply,pInputBuffer+1,BufferLength);
			}

			TRACE("LV protocol: writeAndWait() response");
			TRACE_BUFFER(pReply,BufferLength);
		__leave;
		}
		__finally
		{
		}
		return status;
	}
	return STATUS_INVALID_DEVICE_STATE;
};

#pragma PAGEDCODE
NTSTATUS CLVProtocol::readAndWait(BYTE* pRequest,ULONG RequestLength,BYTE* pReply,ULONG* pReplyLength)
{
ULONG BufferLength;
NTSTATUS status;
	if(device)
	{
		if(!pRequest || !RequestLength || !pReply 
			|| !pReplyLength || !*pReplyLength  || RequestLength>=PROTOCOL_OUTPUT_BUFFER_SIZE)
		{
			TRACE("readAndWait(): INVALID PARAMETERS PROVIDED FOR PROTOCOL!...\n");
			ASSERT(FALSE);
			return STATUS_INVALID_PARAMETER;
		}
		__try
		{
			pOutputBuffer[0] = (UCHAR)RequestLength;
			memory->copy(pOutputBuffer+1,pRequest, RequestLength+1);

			TRACE("LV protocol: readAndWait()");
			TRACE_BUFFER(pOutputBuffer,RequestLength+1);
			BufferLength = InputBufferLength;
			status = device->readAndWait(pOutputBuffer,RequestLength+1,pInputBuffer,&BufferLength);
			if(!NT_SUCCESS(status))
			{
				TRACE("LV protocol: readAndWait() reports error %8.8lX\n",status);
				*pReplyLength = 0;
				__leave;
			}
			if(BufferLength>*pReplyLength)
			{
				*pReplyLength = 0;
				status =  STATUS_INSUFFICIENT_RESOURCES;
				__leave;
			}

			//Skip length byte
			if(BufferLength>1)	BufferLength--;
			*pReplyLength = BufferLength;
			if(BufferLength)
			{
				memory->copy(pReply,pInputBuffer+1,BufferLength);
			}
			TRACE("LV protocol: readAndWait() response");
			TRACE_BUFFER(pInputBuffer,BufferLength);
			__leave;
		}
		__finally
		{
		}
		return status;
	}
	return STATUS_INVALID_DEVICE_STATE;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\gempc430\memory.h ===
// Gemplus (C) 1999
// Version 1.0
// Author: Sergey Ivanov
// Date of creation - 18.05.1999
// Change log:
//

#ifndef MEM_INT
#define MEM_INT
#include "generic.h"

#pragma PAGEDCODE
class CMemory
{
public:
	NTSTATUS m_Status;
	SAFE_DESTRUCTORS();
	virtual VOID dispose(){self_delete();};
protected:
	CMemory(){};
	virtual ~CMemory(){};
public:

	virtual PVOID		allocate(IN POOL_TYPE PoolType,IN SIZE_T NumberOfBytes) {return NULL;};
	virtual VOID		zero(IN PVOID pMem,IN SIZE_T size) {};
	virtual VOID		free(IN PVOID pMem) {};
	virtual VOID		copy(IN VOID UNALIGNED *Destination,IN CONST VOID UNALIGNED *Source, IN SIZE_T Length) {};

	virtual PVOID		mapIoSpace(IN PHYSICAL_ADDRESS PhysicalAddress,IN SIZE_T NumberOfBytes,IN MEMORY_CACHING_TYPE CacheType) {return NULL;};
	virtual VOID		unmapIoSpace(IN PVOID BaseAddress,IN SIZE_T NumberOfBytes) {};
	virtual VOID		set(IN VOID UNALIGNED *Destination,IN SIZE_T Length,LONG Fill) {};

};	

#endif//MEMORY
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\gempc430\lvprot.h ===
//-------------------------------------------------------------------
// This is the class for the length-value protocol
// Author: Sergey Ivanov
// Log:
//		11/10/99	-	implemented	
//-------------------------------------------------------------------
#ifndef __LV_PROTOCOL__
#define __LV_PROTOCOL__

#include "protocol.h"

#pragma PAGEDCODE
class CDevice;

class CLVProtocol : public CProtocol
{
public:
    NTSTATUS m_Status;
	SAFE_DESTRUCTORS();
protected:
	CLVProtocol(){};
public:	
	CLVProtocol(CDevice* device) : CProtocol(device)
	{
		TRACE("\nLength-Value protocol was created...\n");
		m_Status = STATUS_SUCCESS;
	};

	virtual ~CLVProtocol()
	{ 
		TRACE("Length-Value protocol %8.8lX was destroied...\n",this);
	};

	virtual VOID dispose()
	{
		self_delete();
	};

	virtual  VOID  set_WTR_Delay(LONG Delay);
	virtual  ULONG get_WTR_Delay();
	virtual  VOID  set_Default_WTR_Delay();
	virtual  LONG  get_Power_WTR_Delay();
	virtual  ULONG getCardState(); 

	virtual  NTSTATUS writeAndWait(PUCHAR pRequest,ULONG RequestLength,PUCHAR pReply,ULONG* pReplyLength);
	virtual  NTSTATUS readAndWait(PUCHAR pRequest,ULONG RequestLength,PUCHAR pReply,ULONG* pReplyLength);
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\gempc430\protocol.cpp ===
#include "protocol.h"
#include "kernel.h"

#pragma PAGEDCODE
CProtocol::CProtocol()
{ 
	m_Status = STATUS_INSUFFICIENT_RESOURCES;
	device = NULL;
	memory = NULL;
	debug  = NULL;
	m_Status = STATUS_SUCCESS;
};

CProtocol::CProtocol(CDevice* device)
{
	m_Status = STATUS_INSUFFICIENT_RESOURCES;
	this->device = device;
	memory = kernel->createMemory();

	debug	= kernel->createDebug();
	if(ALLOCATED_OK(memory))
	{
		pOutputBuffer = (PUCHAR) memory->allocate(NonPagedPool,PROTOCOL_OUTPUT_BUFFER_SIZE);
		pInputBuffer  = (PUCHAR) memory->allocate(NonPagedPool,PROTOCOL_INPUT_BUFFER_SIZE);
		if(pOutputBuffer && pInputBuffer)
		{
			OutputBufferLength	= PROTOCOL_OUTPUT_BUFFER_SIZE;
			InputBufferLength	= PROTOCOL_INPUT_BUFFER_SIZE;
		}
		else
		{
			if(pOutputBuffer) memory->free(pOutputBuffer);
			if(pInputBuffer)  memory->free(pInputBuffer);
			pOutputBuffer	  = NULL;
			pInputBuffer	  = NULL;
		}
	}
	TRACE("New Protocol %8.8lX was created...\n",this);
	if(ALLOCATED_OK(memory) && device)	m_Status = STATUS_SUCCESS;
};

CProtocol::~CProtocol()
{ 
	if(pOutputBuffer) memory->free(pOutputBuffer);
	if(pInputBuffer)  memory->free(pInputBuffer);
	if(memory) memory->dispose();
	if(debug)  debug->dispose();
	TRACE("Protocol %8.8lX was destroied...\n",this);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\gempc430\protocol.h ===
//-------------------------------------------------------------------
// This is abstract class for generic protocol
// Specific protocols should use it as a parent device
// Author: Sergey Ivanov
// Log:
//		11/09/99	-	implemented	
//-------------------------------------------------------------------
#ifndef __PROTOCOL__
#define __PROTOCOL__

#include "generic.h"
#include "kernel.h"

#define READER_PROTOCOL_LV		1
#define READER_PROTOCOL_GBP		2
#define READER_PROTOCOL_TLP		3

#define PROTOCOL_OUTPUT_BUFFER_SIZE	0x1000
#define PROTOCOL_INPUT_BUFFER_SIZE	0x1000


//class CDevice;
class CUSBReader;
class CDebug;
class CMemory;

#pragma PAGEDCODE
class CProtocol
{
public:
	NTSTATUS m_Status;
	SAFE_DESTRUCTORS();
	virtual VOID dispose(){self_delete();};
protected:
	CDevice* device;
	//CUSBReader* device;
	CDebug*	 debug;
	CMemory* memory;

	// Internal buffers to manage Xfers...
    ULONG  OutputBufferLength;
    PUCHAR pOutputBuffer;
    ULONG  InputBufferLength;
    PUCHAR pInputBuffer;
protected:
	CProtocol();
	virtual ~CProtocol();
public:	
	CProtocol(CDevice* device);
	//CProtocol(CUSBReader* device);

	virtual  VOID  set_WTR_Delay(LONG Delay) {};
	virtual  ULONG get_WTR_Delay() {return 0;};
	virtual  VOID  set_Default_WTR_Delay() {};
	virtual  LONG  get_Power_WTR_Delay() {return 0;};
	virtual  ULONG getCardState() {return 0;}; 


	virtual  NTSTATUS writeAndWait(PUCHAR pRequest,ULONG RequestLength,PUCHAR pReply,ULONG* pReplyLength)  {return STATUS_SUCCESS;};
	virtual  NTSTATUS readAndWait(PUCHAR pRequest,ULONG RequestLength,PUCHAR pReply,ULONG* pReplyLength)  {return STATUS_SUCCESS;};
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\gempc430\message.h ===
//-------------------------------------------------------------------
// Message class
// It declare interface to send messages to the objects
// If 
// Author: Sergey Ivanov
// Log:
//		06/08/99	-	implemented	
//-------------------------------------------------------------------
// Message class
//
template class<CMessageData Md>
class CMessage 
{
	CFloat message_id;
	CFloat _from;
	CFloat _to;
	<Md>* message_data;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\gempc430\reader.h ===
// Gemplus (C) 1999
// This object defines any reader interface.
// So all reader should implement it.
// Version 1.0
// Author: Sergey Ivanov
// Date of creation - 11.01.1999
// Change log:
//
#ifndef _READER_
#define _READER_

#include "generic.h"

#pragma PAGEDCODE
class CSmartCard;
class CUSBReader;//TOBE REMOVED
// Abstruct class 
class CReader
{
public:
	NTSTATUS m_Status;
	SAFE_DESTRUCTORS();
	virtual VOID dispose(){self_delete();};
public:	
	CReader() {};
	virtual  ~CReader(){};

	//virtual BOOL	 createInterface(LONG interfaceType, LONG protocolType,CDevice* device) {return FALSE;};//TOBE CHANGED
	virtual BOOL	 createInterface(LONG interfaceType, LONG protocolType,CUSBReader* device) {return FALSE;};
	virtual BOOL	 isSmartCardInitialized() {return FALSE;};	
	virtual VOID	 setSmartCardInitialized(BOOL state) {};
	virtual VOID	 initializeSmartCardSystem() {};

	virtual PSMARTCARD_EXTENSION getCardExtention() {return NULL;};
	virtual CSmartCard* getSmartCard() {return NULL;};
	virtual PDEVICE_OBJECT	getSystemDeviceObject() {return NULL;};

	// Synchronization functions...
	virtual VOID	  reader_set_busy() {};
	virtual VOID	  reader_set_Idle() {};
	virtual NTSTATUS  reader_WaitForIdle() {return STATUS_SUCCESS;};
	virtual NTSTATUS  reader_WaitForIdleAndBlock() {return STATUS_SUCCESS;}; 

	// Interface with smartcard system
	virtual ULONG     reader_UpdateCardState() {return 0;};
	//virtual ULONG     getCardState() {return 0;};
	//virtual VOID      setCardState(ULONG state) {};

	virtual NTSTATUS  reader_getVersion(PUCHAR pVersion, PULONG pLength) {return STATUS_SUCCESS;};
	virtual NTSTATUS  reader_setMode(ULONG mode) {return STATUS_SUCCESS;};

	virtual VOID	  setNotificationState(ULONG state) {};
	virtual ULONG	  getNotificationState() {return 0;};
	virtual VOID	  completeCardTracking() {};

#ifdef DEBUG
	// Defines methods to process system requests...
	virtual NTSTATUS reader_Read(IN PIRP Irp) {return STATUS_SUCCESS;}; 
	virtual NTSTATUS reader_Write(IN PIRP Irp) {return STATUS_SUCCESS;};
#endif

	// Define methods to process driver requests...
	virtual NTSTATUS reader_Read(BYTE * pRequest,ULONG RequestLength,BYTE * pReply,ULONG* pReplyLength) {return STATUS_SUCCESS;};
	virtual NTSTATUS reader_Write(BYTE* pRequest,ULONG RequestLength,BYTE * pReply,ULONG* pReplyLength) {return STATUS_SUCCESS;};
	virtual NTSTATUS reader_Ioctl(ULONG ControlCode,BYTE* pRequest,ULONG RequestLength,BYTE* pReply,ULONG* pReplyLength) {return STATUS_SUCCESS;};
	virtual NTSTATUS reader_SwitchSpeed(ULONG ControlCode,BYTE* pRequest,ULONG RequestLength,BYTE* pReply,ULONG* pReplyLength) {return STATUS_SUCCESS;};
	virtual NTSTATUS reader_VendorAttribute(ULONG ControlCode,BYTE* pRequest,ULONG RequestLength,BYTE* pReply,ULONG* pReplyLength) {return STATUS_SUCCESS;};
	virtual NTSTATUS reader_Power(ULONG ControlCode,BYTE* pReply,ULONG* pReplyLength, BOOLEAN Specific) {return STATUS_SUCCESS;};
	virtual NTSTATUS reader_SetProtocol(ULONG ProtocolRequested, UCHAR ProtocolNegociation) {return STATUS_SUCCESS;};
	
	virtual NTSTATUS reader_translate_request(BYTE * pRequest,ULONG RequestLength,BYTE * pReply,ULONG* pReplyLength, PSCARD_CARD_CAPABILITIES cardCapabilities, BYTE NewWtx) {return STATUS_SUCCESS;};
	virtual NTSTATUS reader_translate_response(BYTE * pRequest,ULONG RequestLength,BYTE * pReply,ULONG* pReplyLength) {return STATUS_SUCCESS;};
};

#endif // If defined
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\gempc430\rdrconfig.h ===
// Gemplus (C) 1999
//
// Version 1.0
// Author: Sergey Ivanov
// Date of creation - 11.01.1999
// Change log:
//
#ifndef _READER_CONFIG_
#define _READER_CONFIG_

#include "generic.h"

#pragma PAGEDCODE
// Transparent mode configuration
struct TransparentConfig
{
  BYTE  CFG;
  BYTE  ETU;
  BYTE  EGT;
  BYTE  CWT;
  BYTE  BWI;
  BYTE  Fi;
  BYTE	Di;
};


struct  ReaderConfig 
{
  SHORT     Type;
  USHORT    PresenceDetection;
  USHORT	Vpp;
  BYTE      Voltage;
  BYTE      PTSMode;
  BYTE      PTS0;
  BYTE      PTS1;
  BYTE      PTS2;
  BYTE      PTS3;
  TransparentConfig transparent;
  ULONG     ActiveProtocol;

  ULONG		PowerTimeOut;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\gempc430\power.h ===
// Gemplus (C) 1999
// Version 1.0
// Author: Sergey Ivanov
// Date of creation - 18.05.1999
// Change log:
//

#ifndef PWR_INT
#define PWR_INT
#include "generic.h"

#pragma PAGEDCODE
class CPower
{
public:
	NTSTATUS m_Status;
	SAFE_DESTRUCTORS();
	virtual VOID dispose(){self_delete();};
protected:
	CPower(){};
	virtual ~CPower(){};
public:

	virtual PULONG		registerDeviceForIdleDetection (
							IN PDEVICE_OBJECT     DeviceObject,
							IN ULONG              ConservationIdleTime,
							IN ULONG              PerformanceIdleTime,
							IN DEVICE_POWER_STATE State
							) {return NULL;};

	virtual POWER_STATE	declarePowerState(IN PDEVICE_OBJECT   DeviceObject,IN POWER_STATE_TYPE Type,IN POWER_STATE State) 
	{POWER_STATE p; 
		p.SystemState = PowerSystemShutdown;
		p.DeviceState = PowerDeviceUnspecified;
		return p;
	};

	virtual VOID		startNextPowerIrp(IN PIRP Irp) {};
	
	virtual NTSTATUS	callPowerDriver (IN PDEVICE_OBJECT DeviceObject,IN OUT PIRP Irp) {return STATUS_SUCCESS;};
	virtual VOID		setPowerDeviceBusy(PULONG	IdlePointer) {};
	virtual NTSTATUS	requestPowerIrp(IN PDEVICE_OBJECT DeviceObject,
						IN UCHAR MinorFunction,
						IN POWER_STATE PowerState,
						IN PREQUEST_POWER_COMPLETE CompletionFunction,
						IN PVOID Context,
						OUT PIRP *Irp OPTIONAL) {return STATUS_SUCCESS;};
};	

#endif//POWER
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\gempc430\semaphore.h ===
// Gemplus (C) 2000
// Version 1.0
// Author: Sergey Ivanov
// Date of creation - 18.05.2000
// Change log:
//
#ifndef SEM_INT
#define SEM_INT
#include "generic.h"

class CSemaphore;
#pragma PAGEDCODE
class CSemaphore
{
public:
	NTSTATUS m_Status;
	SAFE_DESTRUCTORS();
	virtual VOID dispose(){self_delete();};
protected:
	CSemaphore(){};
	virtual ~CSemaphore() {};
public:

	virtual VOID		initialize(IN PRKSEMAPHORE Semaphore, IN LONG Count, IN LONG Limit) = 0;
	virtual LONG		release(IN PRKSEMAPHORE Semaphore,IN KPRIORITY Increment,IN LONG Adjustment,IN BOOLEAN Wait) = 0;
	virtual LONG		getState(IN PRKSEMAPHORE Semaphore) = 0;
};	

#endif//SEMAPHORE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\gempc430\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by grclass.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\gempc430\smartcard.cpp ===
#include "smartcard.h"
#include "usbreader.h"

#pragma PAGEDCODE
CSmartCard::CSmartCard()
{ 
	debug	= kernel->createDebug();
	memory = kernel->createMemory();
	irp  = kernel->createIrp();
	lock = kernel->createLock();
	system = kernel->createSystem();
	if(lock)	lock->initializeSpinLock(&CardLock);
	poolingIrp = NULL;
};

#pragma PAGEDCODE
CSmartCard::~CSmartCard()
{ 
	TRACE("Destroing SmartCard...\n");
	if(memory) memory->dispose();
	if(irp)	   irp->dispose();
	if(lock)   lock->dispose();
	if(system) system->dispose();
	if(debug)  debug->dispose();
};

#pragma PAGEDCODE
BOOL CSmartCard::smartCardConnect(CUSBReader* reader)
{
	TRACE("		Connecting smartcard system...\n");
	if(reader)
	{	// Check if smartCard was already initialized...
		if(!reader->isSmartCardInitialized())
		{
		PSMARTCARD_EXTENSION Smartcard;
		NTSTATUS Status;
		USHORT   Len;
			if(isWin98())
			{// At this time string should be already initialized
				Status = SmartcardCreateLink(&DosDeviceName,&reader->getDeviceName()->m_String);
				TRACE("Gemplus USB reader registered with name %ws, status %X\n",DosDeviceName.Buffer,Status);
				if(!NT_SUCCESS(Status))
				{
					TRACE("#### Failed to create Device link! Status %X\n", Status);
					return FALSE;
				}
			}
			else
			{
				TRACE("Registering reader interface at system...\n");	
				if(!reader->registerDeviceInterface(&GUID_CLASS_SMARTCARD))
				{
					TRACE("#### Failed to register device interface...\n");
					return FALSE;
				}
			}

			Smartcard = reader->getCardExtention();
			TRACE("*** Reader reports Smartcard 0x%x\n",Smartcard);
			this->reader = reader;

			memory->zero(Smartcard,sizeof(SMARTCARD_EXTENSION));

			Smartcard->ReaderExtension = (PREADER_EXTENSION)reader;

			Smartcard->Version = SMCLIB_VERSION;

			// Read the name from reader object!!!!!!!
			Len = MAXIMUM_ATTR_STRING_LENGTH;
			reader->getVendorName(Smartcard->VendorAttr.VendorName.Buffer,&Len);
			Smartcard->VendorAttr.VendorName.Length = Len;
			TRACE("	VENDOR NAME - %s\n",Smartcard->VendorAttr.VendorName.Buffer);

			Len = MAXIMUM_ATTR_STRING_LENGTH;
			reader->getDeviceType(Smartcard->VendorAttr.IfdType.Buffer,&Len);
			Smartcard->VendorAttr.IfdType.Length = Len;
			TRACE("	DEVICE TYPE - %s\n",Smartcard->VendorAttr.IfdType.Buffer);

			// Clk frequency in KHz encoded as little endian integer
			Smartcard->ReaderCapabilities.CLKFrequency.Default = SC_IFD_DEFAULT_CLK_FREQUENCY; 
			Smartcard->ReaderCapabilities.CLKFrequency.Max = SC_IFD_MAXIMUM_CLK_FREQUENCY;

			Smartcard->ReaderCapabilities.DataRate.Default = SC_IFD_DEFAULT_DATA_RATE;
			Smartcard->ReaderCapabilities.DataRate.Max = SC_IFD_MAXIMUM_DATA_RATE;

			// reader could support higher data rates
			Smartcard->ReaderCapabilities.DataRatesSupported.List = dataRatesSupported;
			Smartcard->ReaderCapabilities.DataRatesSupported.Entries =
				sizeof(dataRatesSupported) / sizeof(dataRatesSupported[0]);

			Smartcard->VendorAttr.IfdVersion.BuildNumber = 0;

			//	store firmware revision in ifd version
			Smartcard->VendorAttr.IfdVersion.VersionMajor =	0x01;
			Smartcard->VendorAttr.IfdVersion.VersionMinor =	0x00;
			Smartcard->VendorAttr.IfdSerialNo.Length = 0;
			Smartcard->ReaderCapabilities.MaxIFSD = SC_IFD_MAXIMUM_IFSD;

			// Now setup information in our deviceExtension
			Smartcard->ReaderCapabilities.CurrentState = (ULONG) SCARD_UNKNOWN;

			// TODO: get reader type from reader object!!!!!!!!!!!!!!
			// Type of Reader - USB
			Smartcard->ReaderCapabilities.ReaderType = SCARD_READER_TYPE_USB;

			// This reader supports T=0 and T=1
			Smartcard->ReaderCapabilities.SupportedProtocols = 	SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1;
			Smartcard->ReaderCapabilities.MechProperties = 0;

			Smartcard->SmartcardRequest.BufferSize = MIN_BUFFER_SIZE;
			Smartcard->SmartcardReply.BufferSize =   MIN_BUFFER_SIZE;	
			Status = SmartcardInitialize(Smartcard);
			if(NT_SUCCESS(Status))
			{
				// It looks like SmartcardInitialize() resets DeviceObject field,
				// So, we have to do it after the call.
				Smartcard->VendorAttr.UnitNo = reader->getDeviceNumber(); 
				Smartcard->OsData->DeviceObject = reader->getSystemDeviceObject();

				TRACE("		Registered device %d with DeviceObject 0x%x\n",Smartcard->VendorAttr.UnitNo,Smartcard->OsData->DeviceObject);
				
				//  (note: RDF_CARD_EJECT and RDF_READER_SWALLOW are not supported)
				// Well... Actually I could define methods at smartcard object as
				// statics and make a link to them. It will work.
				// The reason I created extenal C linkage functions - to 
				// separate smartcard system and our driver. 
				// I think driver actually may not care	about smartcard extention and all
				// settings required by smclib can be done inside our C wrappers and not
				// inside driver objects...
				Smartcard->ReaderFunction[RDF_TRANSMIT]      = smartCard_Transmit;
				Smartcard->ReaderFunction[RDF_SET_PROTOCOL]  = smartCard_SetProtocol;
				Smartcard->ReaderFunction[RDF_CARD_POWER]    = smartCard_Power;
				Smartcard->ReaderFunction[RDF_CARD_TRACKING] = smartCard_Tracking;
				Smartcard->ReaderFunction[RDF_IOCTL_VENDOR]  = smartCard_VendorIoctl;

				reader->setSmartCardInitialized(TRUE);
				TRACE("		***** SmartCard system was initialized correctly! *****\n\n");
				return TRUE;
			}
			else
			{
				TRACE("		##### FAILED to initialize smartcard system...\n");
			}
		}
		else
		{
			TRACE("		##### Smartcard system already active...\n");
		}
	}
	else
	{
		TRACE("		###### Invalid reader object...\n");
	}
	return FALSE;
};

#pragma PAGEDCODE
BOOL CSmartCard::smartCardStart()
{
	return TRUE;
};

#pragma PAGEDCODE
VOID CSmartCard::smartCardDisconnect()
{
	TRACE("		Disconnecting smartcard system...\n");
	if(reader)
	{
	PSMARTCARD_EXTENSION Smartcard;

		Smartcard = reader->getCardExtention();
		if(Smartcard->OsData && Smartcard->OsData->NotificationIrp)
		{
		KIRQL keIrql;
		
			PIRP poolingIrp = Smartcard->OsData->NotificationIrp;
			TRACE("====== COMPLETING NOTIFICATION IRP %8.8lX \n\n",poolingIrp);
			// Guard by spin lock!
			lock->acquireSpinLock(&Smartcard->OsData->SpinLock, &keIrql);
			Smartcard->OsData->NotificationIrp = NULL;
			lock->releaseSpinLock(&Smartcard->OsData->SpinLock, keIrql);
			
			lock->acquireCancelSpinLock(&keIrql);
				irp->setCancelRoutine(poolingIrp, NULL);
			lock->releaseCancelSpinLock(keIrql);

			if (poolingIrp->Cancel) poolingIrp->IoStatus.Status = STATUS_CANCELLED;
			else					poolingIrp->IoStatus.Status = STATUS_SUCCESS; 
			poolingIrp->IoStatus.Information = 0;			
			irp->completeRequest(poolingIrp, IO_NO_INCREMENT);
		}
		//Unregister the device
		if(isWin98())
		{
			TRACE("****** Removing device object name %ws \n",DosDeviceName.Buffer);
			system->deleteSymbolicLink(&DosDeviceName);
		}
		else
		{
			TRACE("Setting reader interface state to FALSE...\n");
			reader->unregisterDeviceInterface(reader->getDeviceInterfaceName());
		}


		SmartcardExit(Smartcard); 
		Smartcard->ReaderExtension = NULL;
		reader->setSmartCardInitialized(FALSE);

		reader = NULL;
		TRACE("		SmartCard system was disconnected...\n");
	}
};

// Declare Smclib system callbacks...
#pragma LOCKEDCODE
NTSTATUS smartCard_Transmit(PSMARTCARD_EXTENSION SmartcardExtension)
{
NTSTATUS Status		 = STATUS_SUCCESS;;
BOOL		Read = FALSE;
CUSBReader*	Reader = (CUSBReader*) SmartcardExtension->ReaderExtension;   
PSCARD_CARD_CAPABILITIES cardCapabilities  = &SmartcardExtension->CardCapabilities;
ULONG		selectedProtocol  = cardCapabilities->Protocol.Selected;
ULONG		protocolRequested = ((PSCARD_IO_REQUEST) SmartcardExtension->OsData->CurrentIrp->AssociatedIrp.SystemBuffer)->dwProtocol;
BYTE * pRequest = (BYTE *)SmartcardExtension->SmartcardRequest.Buffer;
BYTE * pReply = (BYTE *)SmartcardExtension->SmartcardReply.Buffer;
ULONG  RequestLength =  0;
ULONG  ReplyLength   =  0;

    PAGED_CODE();

	DBG_PRINT ("smartCard_Transmit()\n"); 
    if (!Reader || (selectedProtocol != protocolRequested)) 
	{
        DBG_PRINT ("		smartCard_Transmit requested with invalid device state...\n");
		return (STATUS_INVALID_DEVICE_STATE);
    }
	
	if (!NT_SUCCESS(Reader->acquireRemoveLock()))	return STATUS_INVALID_DEVICE_STATE;

	__try
	{
		//Set the reply buffer length to 0.
		*SmartcardExtension->IoRequest.Information = 0;
		switch (selectedProtocol) 
		{
		case SCARD_PROTOCOL_T0:
			Status = SmartcardT0Request(SmartcardExtension);
			
			RequestLength = SmartcardExtension->SmartcardRequest.BufferLength;
			
			DBG_PRINT("T0 PROTOCOL: request length %d\n",RequestLength);
			if (!NT_SUCCESS(Status)) 
			{
				DBG_PRINT ("smartCard_Transmit: SmartcardT0Request reports error 0x%x...\n",Status);
				__leave;
			}
			if (SmartcardExtension->T0.Le > 0) 
			{
				if (SmartcardExtension->T0.Le > SC_IFD_T0_MAXIMUM_LEX) 
				{
					DBG_PRINT ("smartCard_Transmit:Expected length is too big - %d\n",SmartcardExtension->T0.Le);
					Status = STATUS_BUFFER_TOO_SMALL;
					__leave;
				}
				ReplyLength   =  SmartcardExtension->SmartcardReply.BufferSize;
				if(!NT_SUCCESS(Status = Reader->reader_WaitForIdleAndBlock()))
				{
					__leave;
				}
				Status = Reader->reader_Read(pRequest,RequestLength,pReply,&ReplyLength);
				Reader->reader_set_Idle();
				if(!NT_SUCCESS(Status))
				{
					DBG_PRINT ("smartCard_Transmit: reader_Read() reports error 0x%x\n",Status);
					__leave;
				}
			}
			else
			{
				if (SmartcardExtension->T0.Lc > SC_IFD_T0_MAXIMUM_LC) 
				{
					DBG_PRINT ("smartCard_Transmit:Command length is too big - %d\n",SmartcardExtension->T0.Lc);
					Status = STATUS_BUFFER_TOO_SMALL;
					__leave;
				}

				ReplyLength   =  SmartcardExtension->SmartcardReply.BufferSize;
				if(!NT_SUCCESS(Status = Reader->reader_WaitForIdleAndBlock()))
				{
					DBG_PRINT ("smartCard_Transmit:Failed to get idle state...\n");
					__leave;
				}
				
				if(!pRequest || ! RequestLength)
				{
					DBG_PRINT("\n Transmit: cardWrite() Buffer %x length %d\n",pRequest,RequestLength);
				}
				Status = Reader->reader_Write(pRequest,RequestLength,pReply,&ReplyLength);
				Reader->reader_set_Idle();
				if(!NT_SUCCESS(Status))
				{
					DBG_PRINT ("smartCard_Transmit: reader_Write() reports error 0x%x\n",Status);
					__leave;
				}
			}
		
    		SmartcardExtension->SmartcardReply.BufferLength = ReplyLength;

			DBG_PRINT ("T0 Reply length 0x%x\n",ReplyLength);

			if(NT_SUCCESS(Status))	
			{
				Status = SmartcardT0Reply(SmartcardExtension);
			}
			if(!NT_SUCCESS(Status))
			{
				DBG_PRINT ("smartCard_Transmit: SmartcardT0Reply reports error 0x%x\n",Status);
			}
			break;
		case SCARD_PROTOCOL_T1:
			// Loop for the T=1 management
			if(!NT_SUCCESS(Status = Reader->reader_WaitForIdleAndBlock()))
			{
				DBG_PRINT ("smartCard_Transmit:Failed to get idle state...\n");
				__leave;
			}

			do 
			{
				// Tell the lib function how many bytes I need for the prologue
				SmartcardExtension->SmartcardRequest.BufferLength = 0;

				Status = SmartcardT1Request(SmartcardExtension);

				RequestLength = SmartcardExtension->SmartcardRequest.BufferLength;

				ReplyLength  =  SmartcardExtension->SmartcardReply.BufferSize;

				DBG_PRINT("T1 PROTOCOL: request, expected reply length %d, %d\n",RequestLength,ReplyLength);
				if (!NT_SUCCESS(Status)) 
				{
					DBG_PRINT ("smartCard_Transmit: SmartcardT1Request reports error 0x%x...\n",Status);
					Reader->reader_set_Idle();
					__leave;
				}
				Status = Reader->reader_translate_request(pRequest,RequestLength,pReply,&ReplyLength, cardCapabilities, SmartcardExtension->T1.Wtx);
				if(!NT_SUCCESS(Status))
				{
					DBG_PRINT ("smartCard_Transmit: reader_translate_request() reports error 0x%x\n",Status);
					//return Status;  no let smartcard assign proper status
				}

				if (SmartcardExtension->T1.Wtx)
				{
					// Set the reader BWI to the default value
					Reader->setTransparentConfig(cardCapabilities,0);
				}

				// copy buffer(pass by ptr) n length
				SmartcardExtension->SmartcardReply.BufferLength = ReplyLength;

				Status = SmartcardT1Reply(SmartcardExtension);
				if ((Status != STATUS_MORE_PROCESSING_REQUIRED) && (Status != STATUS_SUCCESS) ) 
				{
					DBG_PRINT ("smartCard_Transmit: SmartcardT1Reply reports error 0x%x\n",Status);
				}
			} while (Status == STATUS_MORE_PROCESSING_REQUIRED);

			Reader->reader_set_Idle();
			break;
		default:
			Status = STATUS_DEVICE_PROTOCOL_ERROR;
			__leave;
		}
	}// Try block
	
	__finally
	{
		Reader->releaseRemoveLock();
	}
    return Status;
};

#pragma LOCKEDCODE
NTSTATUS smartCard_VendorIoctl(PSMARTCARD_EXTENSION SmartcardExtension)
{
NTSTATUS	Status		 = STATUS_SUCCESS;;
CUSBReader*	Reader = (CUSBReader*) SmartcardExtension->ReaderExtension;   
ULONG		ControlCode = SmartcardExtension->MajorIoControlCode;
PUCHAR		pRequest = (PUCHAR) SmartcardExtension->IoRequest.RequestBuffer;
ULONG		RequestLength = SmartcardExtension->IoRequest.RequestBufferLength;
PUCHAR		pReply = (PUCHAR)SmartcardExtension->IoRequest.ReplyBuffer;
ULONG		ReplyLength = SmartcardExtension->IoRequest.ReplyBufferLength;

	PAGED_CODE();
	
	DBG_PRINT ("smartCard_VendorIoctl()\n"); 
    
	if (!Reader) 
	{
		DBG_PRINT ("smartCard_VendorIoctl: Reader is not ready...\n");
        return (STATUS_INVALID_DEVICE_STATE);
    }
    
	if (!NT_SUCCESS(Reader->acquireRemoveLock()))	return STATUS_INVALID_DEVICE_STATE;

	*SmartcardExtension->IoRequest.Information = 0;

	__try
	{
		switch(ControlCode)
		{
			// For IOCTL_SMARTCARD_VENDOR_GET_ATTRIBUTE and IOCTL_VENDOR_SMARTCARD_SET_ATTRIBUTE
			// Vendor attribut use by the device
			case IOCTL_SMARTCARD_VENDOR_GET_ATTRIBUTE:
			case IOCTL_SMARTCARD_VENDOR_SET_ATTRIBUTE:
				if(!NT_SUCCESS(Status = Reader->reader_WaitForIdleAndBlock())) 
				{
					DBG_PRINT ("smartCard_VendorIoctl:Failed to get idle state...\n");
					__leave;
				}

				Status = Reader->reader_VendorAttribute(ControlCode,pRequest,RequestLength,pReply,&ReplyLength);

				Reader->reader_set_Idle();

				if(!NT_SUCCESS(Status))
				{
					DBG_PRINT ("smartCard_VendorIoctl: reader_Attibute reports error 0x%x ...\n", Status);
					ReplyLength = 0;
				}
				*SmartcardExtension->IoRequest.Information = ReplyLength;
			break;
			// For IOCTL_SMARTCARD_VENDOR_IFD_EXCHANGE
			// Send a GemCore command to the reader
			case IOCTL_SMARTCARD_VENDOR_IFD_EXCHANGE:
				if(!NT_SUCCESS(Status = Reader->reader_WaitForIdleAndBlock()))
				{
					DBG_PRINT ("smartCard_VendorIoctl:Failed to get idle state...\n");
					__leave;
				}

				Status = Reader->reader_Ioctl(ControlCode,pRequest,RequestLength,pReply,&ReplyLength);

				Reader->reader_set_Idle();

				if(!NT_SUCCESS(Status))
				{
					DBG_PRINT ("smartCard_VendorIoctl: cardIoctl reports error 0x%x ...\n", Status);
					ReplyLength = 0;
				}
				*SmartcardExtension->IoRequest.Information = ReplyLength;

			break;
			// For IOCTL_SMARTCARD_VENDOR_SWITCH_SPEED
			// Change reader speed manually
			case IOCTL_SMARTCARD_VENDOR_SWITCH_SPEED:
				if(!NT_SUCCESS(Status = Reader->reader_WaitForIdleAndBlock()))
				{
					DBG_PRINT ("smartCard_VendorIoctl:Failed to get idle state...\n");
					__leave;
				}

				Status = Reader->reader_SwitchSpeed(ControlCode,pRequest,RequestLength,pReply,&ReplyLength);

				Reader->reader_set_Idle();

				if(!NT_SUCCESS(Status))
				{
					DBG_PRINT ("smartCard_VendorIoctl: reader_SwitchSpeed reports error 0x%x ...\n", Status);
					ReplyLength = 0;
				}
				else
				{
					// Set value inside CardCabilities
					BYTE  NewTA1 = pRequest[0];

					SmartcardExtension->CardCapabilities.Fl = NewTA1 >> 4;
					SmartcardExtension->CardCapabilities.Dl = NewTA1 & 0x0F;
					// Do not touch ClockRateConversion and BitRateAdjustment!
				}
				*SmartcardExtension->IoRequest.Information = ReplyLength;

			break;
			default:
				Status = STATUS_NOT_SUPPORTED;
			break;
		}
	}

	__finally
	{
		Reader->releaseRemoveLock();
	}
	DBG_PRINT ("smartCard_VendorIoctl Exit Status=%x\n", Status);
    return Status;
};

#pragma PAGEDCODE
// Examine if ATR identifies a specific mode (presence of TA2).
BOOLEAN CSmartCard::CheckSpecificMode(BYTE* ATR, DWORD ATRLength)
{
   DWORD pos, len;


   // ATR[1] is T0.  Examine precense of TD1.
   if (ATR[1] & 0x80)
   {
      // Find position of TD1.
      pos = 2;
      if (ATR[1] & 0x10)
         pos++;
      if (ATR[1] & 0x20)
         pos++;
      if (ATR[1] & 0x40)
         pos++;

      // Here ATR[pos] is TD1.  Examine presence of TA2.
      if (ATR[pos] & 0x10)
      {
         // To be of any interest an ATR must contains at least
         //   TS, T0, TA1, TD1, TA2 [+ T1 .. TK] [+ TCK]
         // Find the maximum length of uninteresting ATR.
         if (ATR[pos] & 0x0F)
            len = 5 + (ATR[1] & 0x0F);
         else
            len = 4 + (ATR[1] & 0x0F);  // In protocol T=0 there is no TCK.

         if (ATRLength > len)  // Interface bytes requires changes.
	 {
            if ((ATR[pos+1] & 0x10) == 0)  // TA2 asks to use interface bytes.
	    {
               return TRUE;
	    }
	 }
      }
   }

   return FALSE;
} // CheckSpecificMode


#pragma LOCKEDCODE
NTSTATUS smartCard_Power(PSMARTCARD_EXTENSION SmartcardExtension)
{
NTSTATUS	Status		 = STATUS_SUCCESS;;
CUSBReader*	Reader = (CUSBReader*) SmartcardExtension->ReaderExtension; //TO CHANGE LATER...  
ULONG		ControlCode = SmartcardExtension->MinorIoControlCode;
PUCHAR		pReply = (PUCHAR)SmartcardExtension->IoRequest.ReplyBuffer;
ULONG		ReplyLength = SmartcardExtension->IoRequest.ReplyBufferLength;
KIRQL oldirql;
ULONG State;
CSmartCard* smartcard = NULL;

	DBG_PRINT ("smartCard_Power()\n"); 
    if (!Reader) 
	{
		DBG_PRINT ("smartCard_ReaderPower(): Reader is not ready...\n");
        return STATUS_INVALID_DEVICE_STATE;
    }

	if (!NT_SUCCESS(Reader->acquireRemoveLock()))	return STATUS_INVALID_DEVICE_STATE;

	smartcard   = Reader->getSmartCard();

    *SmartcardExtension->IoRequest.Information = 0;
	if(!NT_SUCCESS(Status = Reader->reader_WaitForIdleAndBlock()))
	{
		DBG_PRINT ("smartCard_Power:Failed to get idle state...\n");
		Reader->releaseRemoveLock();
		return Status;
	}
    Status = Reader->reader_Power(ControlCode,pReply,&ReplyLength, FALSE);
	Reader->reader_set_Idle();
	switch(ControlCode) 
	{
    case SCARD_POWER_DOWN: 
		{
			if(!NT_SUCCESS(Status = Reader->reader_WaitForIdleAndBlock()))
			{
				DBG_PRINT ("smartCard_Power:Failed to get idle state...\n");
				Reader->releaseRemoveLock();
				return Status;
			}
			State		= Reader->reader_UpdateCardState();
			if(smartcard)
			{
				KeAcquireSpinLock(smartcard->getCardLock(), &oldirql);
				SmartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_UNDEFINED;
				SmartcardExtension->CardCapabilities.ATR.Length = 0;
				SmartcardExtension->ReaderCapabilities.CurrentState = State;
				KeReleaseSpinLock(smartcard->getCardLock(), oldirql);
			}
			Reader->reader_set_Idle();
			if(!NT_SUCCESS(Status))
			{
				DBG_PRINT ("smartCard_ReaderPower: cardPower down reports error 0x%x ...\n", Status);
			}
			Reader->releaseRemoveLock();
			return Status;
		}
		break;
    case SCARD_COLD_RESET:
    case SCARD_WARM_RESET:
		if(!NT_SUCCESS(Status))
		{
			DBG_PRINT ("smartCard_ReaderPower: cardPower up reports error 0x%x ...\n", Status);
	
			*SmartcardExtension->IoRequest.Information = 0;
			KeAcquireSpinLock(smartcard->getCardLock(), &oldirql);
			SmartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_UNDEFINED;
			SmartcardExtension->CardCapabilities.ATR.Length = 0;
			if(Status==STATUS_NO_MEDIA)
			{	
				DBG_PRINT("############# Reporting CARD ABSENT!... #############\n");
				SmartcardExtension->ReaderCapabilities.CurrentState = SCARD_ABSENT;
			}
			KeReleaseSpinLock(smartcard->getCardLock(), oldirql);
			
			Reader->releaseRemoveLock();
			return Status;
		}
		if(pReply && ReplyLength && (pReply[0]==0x3B || pReply[0]==0x3F) )
		{
			if ((SmartcardExtension->SmartcardReply.BufferSize>=ReplyLength) &&
				(sizeof(SmartcardExtension->CardCapabilities.ATR.Buffer)>=ReplyLength))
			{

				DBG_PRINT("Setting SMCLIB info...\n");
				// Set information...
				*SmartcardExtension->IoRequest.Information =  ReplyLength;
				// Set reply...
				RtlCopyMemory(SmartcardExtension->SmartcardReply.Buffer,pReply,ReplyLength);
				SmartcardExtension->SmartcardReply.BufferLength = ReplyLength;
				// Set ATR...
				RtlCopyMemory(SmartcardExtension->CardCapabilities.ATR.Buffer,pReply,ReplyLength);
				SmartcardExtension->CardCapabilities.ATR.Length = (UCHAR) ReplyLength;
				SmartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_UNDEFINED;
				// Parse the ATR string in order to check if it as valid
				// and to find out if the card uses invers convention
				Status = SmartcardUpdateCardCapabilities(SmartcardExtension);
				if(!NT_SUCCESS(Status))
				{
					DBG_PRINT("UpdateCardCaps() reports error 0x%x\n", Status);
					Status = 0;
				}

				// Check if Specific mode is present in TA2
				DBG_PRINT("=========== Checking specific mode....\n");
				if(smartcard->CheckSpecificMode(SmartcardExtension->CardCapabilities.ATR.Buffer,
                  						SmartcardExtension->CardCapabilities.ATR.Length))
				{	// Use automatic protocol switching!
					if(!NT_SUCCESS(Status = Reader->reader_WaitForIdleAndBlock()))
					{
						DBG_PRINT ("smartCard_Power:Failed to get idle state...\n");
						Reader->releaseRemoveLock();
						return Status;
					}
					
					Status = Reader->reader_Power(ControlCode,pReply,&ReplyLength, TRUE);
					
					Reader->reader_set_Idle();
				}

			}
			else
			{
				// ERROR!!!!!
				Status = STATUS_BUFFER_TOO_SMALL;
				*SmartcardExtension->IoRequest.Information = 0;
				DBG_PRINT ("smartCard_ReaderPower: Failed to copy ATR because of short ATR or Reply buffer...\n");
			}
		}
		else
		{
			//ERROR!!!!
			Status = STATUS_UNRECOGNIZED_MEDIA;
			*SmartcardExtension->IoRequest.Information = 0;
			DBG_PRINT ("smartCard_ReaderPower: Failed to get card ATR...\n");
			KeAcquireSpinLock(smartcard->getCardLock(), &oldirql);
			SmartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_UNDEFINED;
			SmartcardExtension->CardCapabilities.ATR.Length = 0;
			KeReleaseSpinLock(smartcard->getCardLock(), oldirql);
		}
		Reader->releaseRemoveLock();
		return Status;
		break;
	}
	Reader->releaseRemoveLock();
    return STATUS_INVALID_PARAMETER;
};

#pragma LOCKEDCODE
NTSTATUS smartCard_SetProtocol(PSMARTCARD_EXTENSION SmartcardExtension)
{
NTSTATUS	Status		 = STATUS_SUCCESS;;
CUSBReader*	Reader = (CUSBReader*) SmartcardExtension->ReaderExtension;   
ULONG		ProtocolMask = SmartcardExtension->MinorIoControlCode;

    PAGED_CODE();
	DBG_PRINT ("smartCard_SetProtocol()\n"); 

    *SmartcardExtension->IoRequest.Information = 0;
    if (!Reader) 
	{
		DBG_PRINT ("######## smartCard_SetProtocol: Reader is not ready...\n");
        return (STATUS_INVALID_DEVICE_STATE);
    }

	if (!NT_SUCCESS(Reader->acquireRemoveLock()))	return STATUS_INVALID_DEVICE_STATE;

	if(SmartcardExtension->CardCapabilities.Protocol.Supported & ProtocolMask & SCARD_PROTOCOL_T1)
			DBG_PRINT ("******* T1 PROTOCOL REQUESTED ******\n");
	if(SmartcardExtension->CardCapabilities.Protocol.Supported & ProtocolMask & SCARD_PROTOCOL_T0)
			DBG_PRINT ("******* T0 PROTOCOL REQUESTED ******\n");

    // Check if the card is already in specific state
    // and if the caller wants to have the already selected protocol.
    // We return success if this is the case.
    if (SmartcardExtension->ReaderCapabilities.CurrentState == SCARD_SPECIFIC &&
        (SmartcardExtension->CardCapabilities.Protocol.Selected & ProtocolMask))
    {
		DBG_PRINT ("Requested protocol %d already was setted.\n",SmartcardExtension->CardCapabilities.Protocol.Selected);
		Reader->releaseRemoveLock();
        return STATUS_SUCCESS;
	}

	if(!NT_SUCCESS(Status = Reader->reader_WaitForIdleAndBlock())) 
	{
		Reader->releaseRemoveLock();
		return Status;
	}

	do {
		// Select T=1 or T=0 and indicate that pts1 follows
		// What is the protocol selected
		DBG_PRINT ("Smartcard: SetProtocol Loop\n");

		if(SmartcardExtension->CardCapabilities.Protocol.Supported & ProtocolMask & SCARD_PROTOCOL_T1)
		{

			DBG_PRINT ("******* SETTING T1 PROTOCOL ******\n");
			Status = Reader->reader_SetProtocol(SCARD_PROTOCOL_T1, PROTOCOL_MODE_MANUALLY);

			if(NT_SUCCESS(Status))
			{
				SmartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_T1;
				DBG_PRINT ("******* T1 PROTOCOL WAS SET ******\n");
			}
			
		} else if(SmartcardExtension->CardCapabilities.Protocol.Supported & ProtocolMask & SCARD_PROTOCOL_T0)
		{
			// T0 selection
			DBG_PRINT ("******* SETTING T0 PROTOCOL ******\n");
			Status = Reader->reader_SetProtocol(SCARD_PROTOCOL_T0, PROTOCOL_MODE_MANUALLY);
			if(NT_SUCCESS(Status))
			{
				SmartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_T0;
				DBG_PRINT ("******* T0 PROTOCOL WAS SET ******\n");
			}
		} 
		else 
		{
			Status = STATUS_INVALID_DEVICE_REQUEST;
			DBG_PRINT ("smartCard_SetProtocol: BAD protocol selection...\n");
			SmartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_UNDEFINED;

			// close only once
			Reader->reader_set_Idle();

			Reader->releaseRemoveLock();
			return Status;
		}

		// Fail to negociate PPS, try PTS_TYPE_DEFAULT
		if( ! NT_SUCCESS(Status))
		{
			if (SmartcardExtension->CardCapabilities.PtsData.Type != PTS_TYPE_DEFAULT)
			{
				DBG_PRINT ("Smartcard: SetProtocol: PPS failed. Trying default parameters...\n");

				//
				// The card did either NOT reply or it replied incorrectly
				// so try default values.
				// Set PtsData Type to Default and do a cold reset
				// 
				SmartcardExtension->CardCapabilities.PtsData.Type = PTS_TYPE_DEFAULT;

				Status = Reader->reader_SetProtocol(ProtocolMask, PROTOCOL_MODE_DEFAULT);

				if(NT_SUCCESS(Status))
				{
					Status = SmartcardUpdateCardCapabilities(SmartcardExtension);
				}

				if(NT_SUCCESS(Status))
				{
					DBG_PRINT ("Smartcard: SetProtocol PPS default succeed, TRY AGAIN\n");
					Status = STATUS_MORE_PROCESSING_REQUIRED;
				}
			}
		}
	} while ( Status == STATUS_MORE_PROCESSING_REQUIRED );

	if(NT_SUCCESS(Status))
	{

		DBG_PRINT ("smartCard_SetProtocol: SUCCCESS Finish transaction\n");
        // Now indicate that we're in specific mode 
        // and return the selected protocol to the caller
        //
        SmartcardExtension->ReaderCapabilities.CurrentState = SCARD_SPECIFIC;

        *(PULONG) SmartcardExtension->IoRequest.ReplyBuffer = 
            SmartcardExtension->CardCapabilities.Protocol.Selected;

        *SmartcardExtension->IoRequest.Information = 
            sizeof(SmartcardExtension->CardCapabilities.Protocol.Selected);
	}
	else
	{
		Status = STATUS_DEVICE_PROTOCOL_ERROR;
		// We failed to connect at any protocol. Just report error.
		DBG_PRINT ("smartCard_SetProtocol: Failed to set any protocol...\n");
		SmartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_UNDEFINED;
	}

	// Unblock set protocol
	Reader->reader_set_Idle();
	Reader->releaseRemoveLock();
    return Status;
};


// Callback function to cancel tracking Irp
#pragma LOCKEDCODE
NTSTATUS smartCard_CancelTracking(PDEVICE_OBJECT DeviceObject, PIRP Irp)
{							// OnCancelPendingIoctl
CUSBReader* Reader = (CUSBReader*)DeviceObject->DeviceExtension;
PIRP notificationIrp;
CSmartCard* card = NULL;
PSMARTCARD_EXTENSION SmartcardExtention = NULL;
KIRQL ioIrql;
KIRQL keIrql;

	DBG_PRINT ("######### SmartCard: Cancelling card tracking...\n");
	DBG_PRINT ("######### SmartCard: DeviceObject reported - 0x%x, IRP - 0x%x\n",DeviceObject,Irp);
	DBG_PRINT ("######### SmartCard: Reader reported - 0x%x\n",Reader);

	if (!NT_SUCCESS(Reader->acquireRemoveLock()))	return STATUS_INVALID_DEVICE_STATE;

	notificationIrp = NULL;
	card = Reader->getSmartCard();
	notificationIrp = card->getPoolingIrp();
	SmartcardExtention = Reader->getCardExtention();

    ASSERT(Irp == notificationIrp);
	IoReleaseCancelSpinLock(Irp->CancelIrql);

	DBG_PRINT("######### SmartCard: notificationIrp - 0x%x\n",Irp);
    KeAcquireSpinLock(&SmartcardExtention->OsData->SpinLock,&keIrql);
		notificationIrp = SmartcardExtention->OsData->NotificationIrp;
		SmartcardExtention->OsData->NotificationIrp = NULL;
    KeReleaseSpinLock(&SmartcardExtention->OsData->SpinLock,keIrql);
   
    if (notificationIrp) 
	{
		DBG_PRINT("####### CancelTracking: Completing NotificationIrp %lxh\n",notificationIrp);
		IoAcquireCancelSpinLock(&ioIrql);
			IoSetCancelRoutine(notificationIrp, NULL);
		IoReleaseCancelSpinLock(ioIrql);
	  		//	finish the request
        notificationIrp->IoStatus.Status = STATUS_CANCELLED;
	    notificationIrp->IoStatus.Information = 0;
	    IoCompleteRequest(notificationIrp, IO_NO_INCREMENT);
	}
	Reader->releaseRemoveLock();
	return STATUS_CANCELLED;
}



#pragma LOCKEDCODE
NTSTATUS smartCard_Tracking(PSMARTCARD_EXTENSION Smartcard)
{
KIRQL oldIrql;
CUSBReader*	Reader = (CUSBReader*) Smartcard->ReaderExtension;   
	DBG_PRINT ("SmartCard: Card tracking...\n");
	if (!Reader) return	STATUS_INVALID_DEVICE_STATE;

	if (!NT_SUCCESS(Reader->acquireRemoveLock()))	return STATUS_INVALID_DEVICE_STATE;

	if(Smartcard->MajorIoControlCode == IOCTL_SMARTCARD_IS_PRESENT)
	{
		Reader->setNotificationState(SCARD_SWALLOWED);
		DBG_PRINT ("SmartCard: WAITING FOR INSERTION!\n");
	}
	else
	{
		Reader->setNotificationState(SCARD_ABSENT);
		DBG_PRINT ("SmartCard: WAITING FOR REMOVAL!\n");
	}

	if(!Smartcard->OsData || !Smartcard->OsData->NotificationIrp)
	{
		DBG_PRINT ("SmartCard: ========== CARD TRACKING CALLED WITH ZERO IRP!!!!!\n");
		Reader->releaseRemoveLock();
		return STATUS_INVALID_DEVICE_STATE;
	} 

	DBG_PRINT("######### SmartCard: POOLING IRP - %8.8lX \n",Smartcard->OsData->NotificationIrp);
	CSmartCard* card = Reader->getSmartCard();
    IoAcquireCancelSpinLock(&oldIrql);
		IoSetCancelRoutine(Smartcard->OsData->NotificationIrp, smartCard_CancelTracking);
    IoReleaseCancelSpinLock(oldIrql);

	if(card) card->setPoolingIrp(Smartcard->OsData->NotificationIrp);
	Reader->releaseRemoveLock();
	return STATUS_PENDING;
};

#pragma PAGEDCODE
VOID CSmartCard::completeCardTracking()
{
PSMARTCARD_EXTENSION Smartcard;
ULONG CurrentState;
ULONG ExpectedState;
KIRQL ioIrql;
KIRQL keIrql;
PIRP  poolingIrp;

	//DEBUG_START();//Force to debug even if thread disabled it...

	TRACE("SmartCard: completeCardTracking() ...\n");
	Smartcard     = reader->getCardExtention();
	CurrentState  = reader->getCardState();
	ExpectedState = reader->getNotificationState();

	TRACE("SMCLIB Card state is %x\n",Smartcard->ReaderCapabilities.CurrentState);
	TRACE("Current Card state is %x\n",CurrentState);
	TRACE("ExpectedState is %x\n",ExpectedState);

	if(Smartcard && Smartcard->OsData)
	{
		lock->acquireSpinLock(&Smartcard->OsData->SpinLock, &keIrql);
			if(CurrentState < SCARD_SWALLOWED)
			{
				Smartcard->ReaderCapabilities.CurrentState = CurrentState;
			}
			else
			{
				if(Smartcard->ReaderCapabilities.CurrentState<=SCARD_SWALLOWED)
				{
					Smartcard->ReaderCapabilities.CurrentState = CurrentState;
				}
			}

			TRACE("NEW SMCLIB card state is %x\n",Smartcard->ReaderCapabilities.CurrentState);
		lock->releaseSpinLock(&Smartcard->OsData->SpinLock, keIrql);
	}

	poolingIrp = NULL;
	if((ExpectedState!= SCARD_UNKNOWN) && (ExpectedState == CurrentState))
	{
		DEBUG_START();//Force to debug even if thread disabled it...
		TRACE("\n=======Expected state %d is reached=====\n\n",ExpectedState);
		// Desired state reached...
		if(Smartcard->OsData && Smartcard->OsData->NotificationIrp)
		{
			setPoolingIrp(NULL);
			reader->setNotificationState(SCARD_UNKNOWN);

			TRACE("====== COMPLETING NOTIFICATION =========\n");
			// Finish requested notification!.....
			lock->acquireSpinLock(&Smartcard->OsData->SpinLock, &keIrql);
				poolingIrp = Smartcard->OsData->NotificationIrp;
			lock->releaseSpinLock(&Smartcard->OsData->SpinLock, keIrql);			
			if(poolingIrp)
			{
				TRACE("====== COMPLETING NOTIFICATION IRP %8.8lX \n\n",poolingIrp);
				lock->acquireCancelSpinLock(&ioIrql);
					irp->setCancelRoutine(poolingIrp, NULL);
				lock->releaseCancelSpinLock(ioIrql);

				if(poolingIrp->Cancel)
					poolingIrp->IoStatus.Status  = STATUS_CANCELLED;
				else
  					poolingIrp->IoStatus.Status  = STATUS_SUCCESS;
				poolingIrp->IoStatus.Information = 0;
				lock->acquireSpinLock(&Smartcard->OsData->SpinLock, &keIrql);
					Smartcard->OsData->NotificationIrp = NULL;
				lock->releaseSpinLock(&Smartcard->OsData->SpinLock, keIrql);			
				irp->completeRequest(poolingIrp,IO_NO_INCREMENT);
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\gempc430\smartcard.h ===
//-------------------------------------------------------------------
// This is abstract class for generic device
// Specific devices should use it as a parent device
// Author: Sergey Ivanov
// Log:
//		08/11/99	-	implemented	
//-------------------------------------------------------------------
#ifndef __SMART_CARD__
#define __SMART_CARD__

#include "generic.h"
#include "kernel.h"


//
//   - IOCTL_SMARTCARD_VENDOR_IFD_EXCHANGE defines a specific IOCTL for the Gemplus 
//      Reader to exchange data with the reader without control of the driver.
//   - IOCTL_SMARTCARD_VENDOR_GET_ATTRIBUTE defines a specific IOCTL for the Gemplus 
//      Reader to gets vendor attributes.
//   - IOCTL_SMARTCARD_VENDOR_SET_ATTRIBUTE defines a specific IOCTL for the Gemplus 
//      Reader to sets vendor attributes.
//
#define IOCTL_SMARTCARD_VENDOR_IFD_EXCHANGE  CTL_CODE(FILE_DEVICE_SMARTCARD,2048,0,0)
#define IOCTL_SMARTCARD_VENDOR_GET_ATTRIBUTE CTL_CODE(FILE_DEVICE_SMARTCARD,2049,0,0)
#define IOCTL_SMARTCARD_VENDOR_SET_ATTRIBUTE CTL_CODE(FILE_DEVICE_SMARTCARD,2050,0,0)
// 2051 is reserved for Gcr420 keyboard reader.
#define IOCTL_SMARTCARD_VENDOR_SWITCH_SPEED  CTL_CODE(FILE_DEVICE_SMARTCARD,2052,0,0)


//
//   - SCARD_CLASS is a macro to know the class of a Tag.
//
#define SCARD_CLASS(Value) (ULONG) (((ULONG)(Value)) >> 16)
//
//   - SCARD_ATTR_SPEC_BAUD_RATE is the Tag to acces at the value of the baud rate (PC/IFD).
//   - SCARD_ATTR_SPEC_CMD_TIMEOUT is the Tag to access at the value of the Cmd Timeout.
//   - SCARD_ATTR_SPEC_POWER_TIMEOUT is the Tag to access at the value of the Power 
//      Timeout.
//   - SCARD_ATTR_SPEC_APDU_TIMEOUT is the Tag to access at the value of the APDU 
//      Timeout.
//
#define SCARD_ATTR_SPEC_BAUD_RATE SCARD_ATTR_VALUE(SCARD_CLASS_VENDOR_DEFINED,0x0180)
#define SCARD_ATTR_SPEC_CMD_TIMEOUT SCARD_ATTR_VALUE(SCARD_CLASS_VENDOR_DEFINED,0x0181)
#define SCARD_ATTR_SPEC_POWER_TIMEOUT SCARD_ATTR_VALUE(SCARD_CLASS_VENDOR_DEFINED,0x0182)
#define SCARD_ATTR_SPEC_APDU_TIMEOUT SCARD_ATTR_VALUE(SCARD_CLASS_VENDOR_DEFINED,0x0183)
//
// To give possibility for recognition of driver
//
#define SCARD_ATTR_MANUFACTURER_NAME  SCARD_ATTR_VALUE(SCARD_CLASS_VENDOR_DEFINED,0x0190)
#define SCARD_ATTR_ORIGINAL_FILENAME  SCARD_ATTR_VALUE(SCARD_CLASS_VENDOR_DEFINED,0x0191)

#define GBCLASS_OPEN_SESSION	0x3001
#define GBCLASS_CLOSE_SESSION	0x3002
#define GBCLASS_DRIVER_SCNAME	0x3003
#define GBCLASS_CONNECTION_TYPE 0x3004
#define IOCTL_OPEN_SESSION   CTL_CODE(FILE_DEVICE_BUS_EXTENDER,GBCLASS_OPEN_SESSION,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_CLOSE_SESSION  CTL_CODE(FILE_DEVICE_BUS_EXTENDER,GBCLASS_CLOSE_SESSION,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_DRIVER_SCNAME  CTL_CODE(FILE_DEVICE_BUS_EXTENDER,GBCLASS_DRIVER_SCNAME,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_GET_CONNECTION_TYPE  CTL_CODE(FILE_DEVICE_BUS_EXTENDER,GBCLASS_CONNECTION_TYPE,METHOD_BUFFERED,FILE_ANY_ACCESS)


#define ATTR_MANUFACTURER_NAME      "Gemplus"
#define ATTR_ORIGINAL_FILENAME      "GrClass.sys"
#define ATTR_LENGTH                 32

#define SC_IFD_DEFAULT_CLK_FREQUENCY      4000
#define SC_IFD_MAXIMUM_CLK_FREQUENCY      4000
#define SC_IFD_DEFAULT_DATA_RATE          10753
#define SC_IFD_MAXIMUM_DATA_RATE          125000
#define SC_IFD_MAXIMUM_IFSD               253// To correct problem with SMCLIB!
#define SC_IFD_T0_MAXIMUM_LEX             256
#define SC_IFD_T0_MAXIMUM_LC              255



// PTS mode parameters
#define PROTOCOL_MODE_DEFAULT			0
#define PROTOCOL_MODE_MANUALLY			1

static ULONG 
   dataRatesSupported[] = { 
     10753,  14337,  15625,  17204,
     20833,  21505,  28674,  31250,
     34409,  41667,  43011,  57348,
     62500,  83333,  86022, 114695,
    125000 
      };

#define GRCLASS_DRIVER_NAME           "GRClass"
#define GRCLASS_VENDOR_NAME           "Gemplus"
#define GRCLASS_READER_TYPE           "GemPC430"


#define REQUEST_TO_NOTIFY_INSERTION		1
#define REQUEST_TO_NOTIFY_REMOVAL		2

#pragma LOCKEDCODE
// Declare Smclib system callbacks...
#ifdef __cplusplus
extern "C"{
#endif
NTSTATUS smartCard_Transmit(PSMARTCARD_EXTENSION SmartcardExtension);
NTSTATUS smartCard_CancelTracking(IN PDEVICE_OBJECT DeviceObject,IN PIRP Irp);
NTSTATUS smartCard_Tracking(PSMARTCARD_EXTENSION SmartcardExtension);
NTSTATUS smartCard_VendorIoctl(PSMARTCARD_EXTENSION SmartcardExtension);
NTSTATUS smartCard_Power(PSMARTCARD_EXTENSION SmartcardExtension);
NTSTATUS smartCard_SetProtocol(PSMARTCARD_EXTENSION SmartcardExtension);
#ifdef __cplusplus
}
#endif

#pragma PAGEDCODE
class CUSBReader;//TO CHANGE LATER...
class CSmartCard
{
public:
	NTSTATUS m_Status;
	SAFE_DESTRUCTORS();
	virtual VOID dispose(){self_delete();};
private:
	CUSBReader* reader;
	CDebug*	 debug;
	CMemory* memory;
	CLock*   lock;
	CSystem* system;
	CIrp*    irp;

	KEVENT   evCanceled;// set when tracking is canceled...
	PIRP     poolingIrp;
	UNICODE_STRING DosDeviceName;//Used only at Win9x
public:
	KSPIN_LOCK CardLock;
protected:
	virtual ~CSmartCard();
public:
	CSmartCard();
	virtual CUSBReader* getReader() {return reader;};//TO CHANGE LATER...

	virtual BOOL smartCardConnect(CUSBReader* reader);
	virtual VOID smartCardDisconnect();
	virtual BOOL smartCardStart();

	virtual PKSPIN_LOCK getCardLock(){return &CardLock;};
	virtual VOID completeCardTracking();
	virtual VOID setPoolingIrp(PIRP Irp){poolingIrp = Irp;};
	virtual PIRP getPoolingIrp(){return poolingIrp;};
	virtual BOOLEAN CheckSpecificMode(BYTE* ATR, DWORD ATRLength);
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\gempc430\system.h ===
// Gemplus (C) 1999
// Version 1.0
// Author: Sergey Ivanov
// Date of creation - 18.05.1999
// Change log:
//

#ifndef SYS_INT
#define SYS_INT
#include "generic.h"

#pragma PAGEDCODE
// This is device interface to system...
class CSystem
{
public:
	NTSTATUS m_Status;
	SAFE_DESTRUCTORS();
	virtual VOID dispose(){self_delete();};
protected:
	CSystem(){};
	virtual ~CSystem(){};
public:

	// This object will implement next interfaces...
	virtual NTSTATUS		createDevice(PDRIVER_OBJECT DriverObject,
								ULONG DeviceExtensionSize,
								PUNICODE_STRING DeviceName OPTIONAL,
								DEVICE_TYPE DeviceType,
								ULONG DeviceCharacteristics,
								BOOLEAN Reserved,
								PDEVICE_OBJECT *DeviceObject) {return STATUS_SUCCESS;};
	virtual VOID			deleteDevice(PDEVICE_OBJECT DeviceObject) {};

	virtual PDEVICE_OBJECT	attachDevice(PDEVICE_OBJECT FuncDevice,IN PDEVICE_OBJECT PhysDevice) {return NULL;};
	virtual VOID			detachDevice(PDEVICE_OBJECT TargetDevice) {};

	virtual NTSTATUS		callDriver(PDEVICE_OBJECT DeviceObject,PIRP Irp) {return STATUS_SUCCESS;};

	virtual NTSTATUS		registerDeviceInterface(PDEVICE_OBJECT PhysicalDeviceObject,
								CONST GUID *InterfaceClassGuid,
								PUNICODE_STRING ReferenceString,     OPTIONAL
								PUNICODE_STRING SymbolicLinkName) {return STATUS_SUCCESS;};
	virtual NTSTATUS		setDeviceInterfaceState(PUNICODE_STRING SymbolicLinkName,BOOLEAN Enable) {return STATUS_SUCCESS;};

	virtual NTSTATUS		createSystemThread(OUT PHANDLE ThreadHandle,
								IN ULONG DesiredAccess,
								IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
								IN HANDLE ProcessHandle OPTIONAL,
								OUT PCLIENT_ID ClientId OPTIONAL,
								IN PKSTART_ROUTINE StartRoutine,
								IN PVOID StartContext) {return STATUS_SUCCESS;};
	virtual NTSTATUS		terminateSystemThread(IN NTSTATUS ExitStatus) {return STATUS_SUCCESS;};
	virtual NTSTATUS		referenceObjectByHandle(IN HANDLE Handle,                                           
								IN ACCESS_MASK DesiredAccess,                               
								IN POBJECT_TYPE ObjectType OPTIONAL,                        
								IN KPROCESSOR_MODE AccessMode,                              
								OUT PVOID *Object,                                          
								OUT POBJECT_HANDLE_INFORMATION HandleInformation OPTIONAL   
								) {return STATUS_SUCCESS;};
	virtual VOID			referenceObject(IN PVOID Object) {};
	virtual VOID			dereferenceObject(IN PVOID Object) {};
	virtual PDEVICE_OBJECT	getAttachedDeviceReference(IN PDEVICE_OBJECT DeviceObject) {return NULL;};

	virtual NTSTATUS	    ZwClose(IN HANDLE Handle) {return STATUS_SUCCESS;};

	virtual NTSTATUS		createSymbolicLink(IN PUNICODE_STRING SymbolicLinkName,IN PUNICODE_STRING DeviceName) {return STATUS_SUCCESS;};
	virtual NTSTATUS		deleteSymbolicLink(IN PUNICODE_STRING SymbolicLinkName) {return STATUS_SUCCESS;};

	virtual VOID			invalidateDeviceRelations(IN PDEVICE_OBJECT DeviceObject,IN DEVICE_RELATION_TYPE Type) {};

	virtual NTSTATUS		getDeviceObjectPointer(IN PUNICODE_STRING ObjectName,
								IN ACCESS_MASK DesiredAccess,
								OUT PFILE_OBJECT *FileObject,
								OUT PDEVICE_OBJECT *DeviceObject) {return STATUS_SUCCESS;};

	virtual VOID			raiseIrql(IN KIRQL NewIrql,OUT KIRQL* oldIrql) = 0;
	virtual VOID			lowerIrql (IN KIRQL NewIrql) = 0;
	virtual KIRQL			getCurrentIrql()=0;
	
	virtual VOID			initializeDeviceQueue(IN PKDEVICE_QUEUE DeviceQueue) = 0;
	virtual BOOLEAN			insertDeviceQueue(IN PKDEVICE_QUEUE DeviceQueue,IN PKDEVICE_QUEUE_ENTRY DeviceQueueEntry) = 0;
	virtual BOOLEAN			insertByKeyDeviceQueue(IN PKDEVICE_QUEUE DeviceQueue,IN PKDEVICE_QUEUE_ENTRY DeviceQueueEntry,IN ULONG SortKey) = 0;
	virtual PKDEVICE_QUEUE_ENTRY	removeDeviceQueue(IN PKDEVICE_QUEUE DeviceQueue) = 0;
	virtual PKDEVICE_QUEUE_ENTRY	removeByKeyDeviceQueue(IN PKDEVICE_QUEUE DeviceQueue,IN ULONG SortKey) = 0;
	virtual BOOLEAN			removeEntryDeviceQueue(IN PKDEVICE_QUEUE DeviceQueue,IN PKDEVICE_QUEUE_ENTRY DeviceQueueEntry) = 0;


	virtual NTSTATUS		openDeviceRegistryKey(IN PDEVICE_OBJECT DeviceObject,
								IN ULONG DevInstKeyType,
								IN ACCESS_MASK DesiredAccess,
								OUT PHANDLE DevInstRegKey
								) = 0;
	virtual NTSTATUS		ZwQueryValueKey(IN HANDLE KeyHandle,
								IN PUNICODE_STRING ValueName,
								IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
								OUT PVOID KeyValueInformation,
								IN ULONG Length,
								OUT PULONG ResultLength) = 0;

	virtual NTSTATUS		getDeviceProperty(IN PDEVICE_OBJECT DeviceObject,
								IN DEVICE_REGISTRY_PROPERTY DeviceProperty,
								IN ULONG BufferLength,
								OUT PVOID PropertyBuffer,
								OUT PULONG ResultLength
								) = 0;

	virtual VOID			initializeFastMutex(IN PFAST_MUTEX FastMutex) = 0;
	virtual VOID			acquireFastMutex(IN PFAST_MUTEX FastMutex) = 0;
	virtual VOID			releaseFastMutex(IN PFAST_MUTEX FastMutex) = 0;
};	

#endif//SYS_INT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\gempc430\thread.h ===
// Gemplus (C) 1999
// Version 1.0
// Author: Sergey Ivanov
// Date of creation - 18.05.1999
// Change log:
//

#ifndef __THREAD__
#define __THREAD__
#include "generic.h"
#include "kernel.h"

#pragma PAGEDCODE
class CUSBReader;//TOBE REMOVED
class CTimer;
//class CThread;

typedef
NTSTATUS
(*PCLIENT_THREAD_ROUTINE) (
    IN PVOID RoutineContext
    );
// Default thread pooling interval in ms
#define DEFAULT_THREAD_POOLING_INTERVAL	500

class CThread 
{
public:
	NTSTATUS m_Status;
	SAFE_DESTRUCTORS();
	virtual VOID dispose(){self_delete();};
private:
KEVENT   evKill;	// set to kill polling thread
KEVENT   evStart;	// set when requested to start, clear when need to stop pooling
KEVENT   evIdle;	// Signals that thread stopped and at Idle state
KEVENT   evStopped;	// set when requested to close thread
PKTHREAD thread;	// polling thread object
KSEMAPHORE smOnDemandStart;// request to repeate operation if semaphore is at Signal state

BOOLEAN  StopRequested;	
BOOLEAN  ThreadActive;	

CDebug*  debug;
CEvent*  event;
CSystem* system;
CTimer*  timer;
CSemaphore* semaphore;

ULONG	 PoolingTimeout;

PCLIENT_THREAD_ROUTINE pfClientThreadFunction;
PVOID ClientContext;

//CDevice* device;
//CUSBReader* device;
protected:
	CThread(){};
	virtual ~CThread();
public:
	//CThread(CDevice* device);
	//CThread(CUSBReader* device);
	CThread(PCLIENT_THREAD_ROUTINE ClientThreadFunction, PVOID ClientContext,
				ULONG delay=DEFAULT_THREAD_POOLING_INTERVAL);
	static VOID ThreadFunction(CThread* thread);

	VOID ThreadRoutine(PVOID context) ;
	PKEVENT  getKillObject(){return &evKill;};
	PKEVENT  getStartObject(){return &evStart;};
	VOID	 kill();
	VOID	 start();
	VOID	 stop();
	BOOL	 isThreadActive();
	VOID	 setPoolingInterval(ULONG delay);
	// Force to call thread function...
	// This is on demand start.
	VOID     callThreadFunction();
};

#endif//THREAD
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\gempc430\syswdm.h ===
//#pragma hdrstop
/*++
	Kernel mode definitions and function prototypes for wdm model
--*/
#ifndef WDM_INCD
#define WDM_INCD

#pragma PAGEDCODE
#ifdef __cplusplus
extern "C"{
#endif

#include <wdm.h>
#include <stdio.h>
#include <stdarg.h>

#ifndef IRP_MN_QUERY_LEGACY_BUS_INFORMATION
#define IRP_MN_QUERY_LEGACY_BUS_INFORMATION 0x18
#endif

#if DBG && defined(_X86_)
#undef ASSERT
#define ASSERT(e) if(!(e)){DbgPrint("Assertion failure in"\
__FILE__", line %d: " #e "\n", __LINE__);\
_asm int 3\
}
#endif


#define BOOL BOOLEAN
#define FALSE 0
typedef UCHAR* PBYTE;


#define MSEC	*(-(LONGLONG)10000); //milliseconds 

///////////////////////////////////////////////////////////////////////////////
/************************* LISTS MANIPULATION MACROS **************************/
//  Doubly-linked list manipulation routines.  Implemented as macros
//  but logically these are procedures.

	/*
typedef struct _LIST_ENTRY {
   struct _LIST_ENTRY * volatile Flink;
   struct _LIST_ENTRY * volatile Blink;
} LIST_ENTRY, *PLIST_ENTRY, *RESTRICTED_POINTER PRLIST_ENTRY;

  */
#ifndef LIST_ENTRY_DEF
#define LIST_ENTRY_DEF

//  VOID
//  InitializeListHead(
//      PLIST_ENTRY ListHead
//      );
#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

//  BOOLEAN
//  IsListEmpty(
//      PLIST_ENTRY ListHead
//      );
#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))

//  PLIST_ENTRY
//  RemoveHeadList(
//      PLIST_ENTRY ListHead
//      );
#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}

//  PLIST_ENTRY
//  RemoveTailList(
//      PLIST_ENTRY ListHead
//      );
#define RemoveTailList(ListHead) \
    (ListHead)->Blink;\
    {RemoveEntryList((ListHead)->Blink)}

//  VOID
//  RemoveEntryList(
//      PLIST_ENTRY Entry
//      );
#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }

//  VOID
//  InsertTailList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }

//  VOID
//  InsertHeadList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    }

//  PSINGLE_LIST_ENTRY
//  PopEntryList(
//      PSINGLE_LIST_ENTRY ListHead
//      );
#define PopEntryList(ListHead) \
    (ListHead)->Next;\
    {\
        PSINGLE_LIST_ENTRY FirstEntry;\
        FirstEntry = (ListHead)->Next;\
        if (FirstEntry != NULL) {     \
            (ListHead)->Next = FirstEntry->Next;\
        }                             \
    }

//  VOID
//  PushEntryList(
//      PSINGLE_LIST_ENTRY ListHead,
//      PSINGLE_LIST_ENTRY Entry
//      );
#define PushEntryList(ListHead,Entry) \
    (Entry)->Next = (ListHead)->Next; \
    (ListHead)->Next = (Entry)

#endif //LIST_ENTRY

#ifndef CONTAINING_RECORD
#define CONTAINING_RECORD(address, type, field) ((type *)( \
                                                  (PCHAR)(address) - \
                                                  (ULONG_PTR)(&((type *)0)->field)))
#endif

/*******************************************************************************/

#ifndef FIELDOFFSET
	#define FIELDOFFSET(type, field) ((DWORD)(&((type *)0)->field))
#endif


#ifndef CONTAINING_RECORD
#define CONTAINING_RECORD(address, type, field) ((type *)( \
                                                  (PCHAR)(address) - \
                                                  (ULONG_PTR)(&((type *)0)->field)))
#endif

/**********************************************************************************/


#ifdef __cplusplus
}
#endif

// Macros to verify allocated objects
#define ALLOCATED_OK(obj) \
	((obj!=(VOID *)0) && NT_SUCCESS((obj)->m_Status))

#define DISPOSE_OBJECT(obj) \
		{if((obj!=(VOID *)0))	obj->dispose(); obj = NULL;}

#define RETURN_VERIFIED_OBJECT(obj) \
if(ALLOCATED_OK(obj)) return obj;	\
else								\
{									\
	DISPOSE_OBJECT(obj);			\
	return NULL;					\
}

// derived class Unicode string
#define TYPE_SYSTEM_ALLOCATED 0
#define TYPE_DRIVER_ALLOCATED 1

extern ULONG ObjectCounter;
//::DBG_PRINT("=== Deleting Object %8.8lX",ptr);\
// Overrides for library new and delete operators.

/*
inline VOID* __cdecl operator new(ULONG size, POOL_TYPE iType)\
{PVOID	pMem; if(pMem = ::ExAllocatePoolWithTag(iType,size,'_GRU'))\
{ ObjectCounter++; ::RtlZeroMemory(pMem,size); DBG_PRINT("\n=== New Object %8.8lX, %d\n",pMem,ObjectCounter);\
	return pMem; \
} else return NULL; };

inline VOID __cdecl operator delete(VOID* ptr)\
{ if(ptr){ObjectCounter--; DBG_PRINT("\n=== Deleting Object %8.8lX, %d\n",ptr,ObjectCounter); ::ExFreePool((PVOID)ptr);}\
};
*/


#pragma LOCKEDCODE
inline VOID* __cdecl operator new(size_t size, POOL_TYPE iType)\
{PVOID	pMem; if(pMem = ::ExAllocatePoolWithTag(iType,size,'URG_'))\
{ ObjectCounter++; ::RtlZeroMemory(pMem,size);\
	return pMem; \
} else return NULL; };

inline VOID __cdecl operator delete(VOID* ptr)\
{ if(ptr){ObjectCounter--; ::ExFreePool((PVOID)ptr);}\
};


#include "generic.h"

#pragma PAGEDCODE
template <class T>
class CLinkedList
{
public:
	NTSTATUS m_Status;
	VOID self_delete(VOID){delete this;};
	virtual VOID dispose(VOID){self_delete();};
protected:
    LIST_ENTRY head;
    KSPIN_LOCK splock;

public:
    CLinkedList()
    {
        InitializeListHead(&head);
        KeInitializeSpinLock(&splock);
    };
    
    BOOLEAN IsEmpty(VOID) { return IsListEmpty(&head); };
    ~CLinkedList()
    {    // if list is still not empty, free all items
		T *p;
        while (p=(T *) ExInterlockedRemoveHeadList(&head,&splock))
        {
			CONTAINING_RECORD(p,T,entry)->dispose();
        }
    };

    VOID New(T *p)
    {
        ExInterlockedInsertTailList(&head,&(p->entry),&splock);
    };

    VOID insertHead(T *p)
    {
        ExInterlockedInsertHeadList(&head,&(p->entry),&splock);
    };

    T*  removeHead(VOID)
    {
        T *p=(T *) ExInterlockedRemoveHeadList(&head,&splock);
        if (p) p=CONTAINING_RECORD(p,T,entry);
        return p;
    };
    VOID remove(T *p)
    {
        RemoveEntryList(&(p->entry));
    };
    
	T*  getNext(T* p)
    {        
		if (p)
		{
		PLIST_ENTRY	Next;
			Next = p->entry.Flink;
			if (Next && (Next!= &head))
			{
				T* pp=CONTAINING_RECORD(Next,T,entry);
				return pp;
			}
			else	return NULL;
		}
		return NULL;	
    };
	
	T*  getFirst()
    {   
		PLIST_ENTRY	Next = head.Flink;
		if (Next && Next!= &head)
		{
			T* p = CONTAINING_RECORD(Next,T,entry);
			return p;
		}
		return NULL;
    };
};

#pragma PAGEDCODE
class CUString 
{ 
public:
	NTSTATUS m_Status;
	VOID self_delete(VOID){delete this;};
	virtual VOID dispose(VOID){self_delete();};
private:
    UCHAR m_bType;
public:
    UNICODE_STRING m_String;
public:
	CUString(USHORT nSize)
	{
		m_Status = STATUS_INSUFFICIENT_RESOURCES;
		m_bType = TYPE_DRIVER_ALLOCATED;
		RtlInitUnicodeString(&m_String,NULL);
		m_String.MaximumLength = nSize;
		m_String.Buffer = (USHORT *)
			ExAllocatePool(PagedPool,nSize);
		if (!m_String.Buffer) return;  // leaving status the way it is
		RtlZeroMemory(m_String.Buffer,m_String.MaximumLength);
		m_Status = STATUS_SUCCESS;
	};
	
	CUString(PWCHAR uszString)
	{
		m_Status = STATUS_SUCCESS;
		m_bType = TYPE_SYSTEM_ALLOCATED;
		RtlInitUnicodeString(&m_String,uszString);
	};

	CUString(ANSI_STRING* pString)
	{
		m_Status = STATUS_SUCCESS;
		m_bType = TYPE_SYSTEM_ALLOCATED;
		RtlAnsiStringToUnicodeString(&m_String,pString,TRUE);
	};

	CUString(PCSTR pString)
	{
	ANSI_STRING AnsiString;
		m_Status = STATUS_SUCCESS;
		m_bType = TYPE_SYSTEM_ALLOCATED;
		RtlInitAnsiString(&AnsiString,pString);
		RtlAnsiStringToUnicodeString(&m_String,&AnsiString,TRUE);
	};



	CUString(PUNICODE_STRING uString)
	{
		m_Status = STATUS_INSUFFICIENT_RESOURCES;
		m_bType = TYPE_DRIVER_ALLOCATED;
		RtlInitUnicodeString(&m_String,NULL);
		m_String.MaximumLength = MAXIMUM_FILENAME_LENGTH;
		m_String.Buffer = (USHORT *)
			ExAllocatePool(PagedPool,MAXIMUM_FILENAME_LENGTH);
		if (!m_String.Buffer) return;  // leaving status the way it is
		RtlZeroMemory(m_String.Buffer,m_String.MaximumLength);

		RtlCopyUnicodeString(&m_String,uString);
		m_Status = STATUS_SUCCESS;
	};


	CUString(LONG iVal, LONG iBase)  
	{
		m_Status = STATUS_INSUFFICIENT_RESOURCES;
		m_bType = TYPE_DRIVER_ALLOCATED;
		RtlInitUnicodeString(&m_String,NULL);
		USHORT iSize=1;
		LONG iValCopy=(!iVal)?1:iVal;
		while (iValCopy>=1)
		{
			iValCopy/=iBase;
			iSize++;
		}    // now iSize carries the number of digits

		iSize*=sizeof(WCHAR);

		m_String.MaximumLength = iSize;
		m_String.Buffer = (USHORT *)
			ExAllocatePool(PagedPool,iSize);
		if (!m_String.Buffer) return;
		RtlZeroMemory(m_String.Buffer,m_String.MaximumLength);
		m_Status = RtlIntegerToUnicodeString(iVal, iBase, &m_String);
	};

	~CUString()
	{
		if ((m_bType == TYPE_DRIVER_ALLOCATED) && m_String.Buffer) 
			ExFreePool(m_String.Buffer);
	};

	VOID append(UNICODE_STRING *uszString)
	{
		m_Status = RtlAppendUnicodeStringToString(&m_String,uszString);
	};

	VOID copyTo(CUString *pTarget)
	{
		RtlCopyUnicodeString(&pTarget->m_String,&m_String);
	};

	BOOL operator==(CUString cuArg)
	{
		return (!RtlCompareUnicodeString(&m_String,
			&cuArg.m_String,FALSE));
	};

    LONG inline getLength() { return m_String.Length; };
    PWCHAR inline getString() { return m_String.Buffer; };
    VOID inline setLength(USHORT i) { m_String.Length = i; };
};


 // already included
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\gempc430\thread.cpp ===
#include "thread.h"

// Thread callback...
#pragma LOCKEDCODE
VOID CThread::ThreadFunction(CThread* Thread)
{
	if(Thread) Thread->ThreadRoutine(NULL);
}

#pragma PAGEDCODE
VOID CThread::ThreadRoutine(PVOID context)
{
NTSTATUS status;
	TRACE("================= STARTING THREAD %8.8lX ===============\n", thread);

	// Wait for a request to Start pooling or for
	// someone to kill this thread.
	PVOID mainevents[] = {(PVOID) &evKill,(PVOID) &evStart};
	PVOID pollevents[] = {(PVOID) &evKill,(PVOID) timer->getHandle(),(PVOID) &smOnDemandStart};

	ASSERT(arraysize(mainevents) <= THREAD_WAIT_OBJECTS);
	ASSERT(arraysize(pollevents) <= THREAD_WAIT_OBJECTS);

	BOOLEAN kill = FALSE;	
	while (!kill && thread)
	{	// until told to start or to quit
		ASSERT(system->getCurrentIrql()<=DISPATCH_LEVEL);

		// Before going to thread routine thread considered to be Idle 
		if(event) event->set(&evIdle, IO_NO_INCREMENT, FALSE);
		
		status = event->waitForMultipleObjects(arraysize(mainevents),
			mainevents, WaitAny, Executive, KernelMode, FALSE, NULL, NULL);

		if(!NT_SUCCESS(status))
		{	// error in wait
			TRACE("Thread: waitForMultipleObjects failed - %X\n", status);
			break;
		}		
		if (status == STATUS_WAIT_0)
		{
			DEBUG_START();
			TRACE("Request to kill thread arrived...\n");
			TRACE("================= KILLING THREAD! ===============\n");
			break;	// kill event was set
		}

		// Starting the timer with a zero due time will cause us to perform the
		// first poll immediately. Thereafter, polls occur at the POLLING_INTERVAL
		// interval (measured in milliseconds).

		// Now thread is busy...
		if(event) event->clear(&evIdle);

		LARGE_INTEGER duetime = {0};// Signal timer right away!
		timer->set(duetime, PoolingTimeout, NULL);
		while (TRUE)
		{	// Block until time to poll again
			ASSERT(system->getCurrentIrql()<=DISPATCH_LEVEL);
			status = event->waitForMultipleObjects(arraysize(pollevents),
				pollevents, WaitAny, Executive, KernelMode, FALSE, NULL, NULL);
			if (!NT_SUCCESS(status))
			{	// error in wait
				DEBUG_START();
				TRACE("CTread - waitForMultipleObjects failed - %X\n", status);
				TRACE("================= KILLING THREAD! ===============\n");
				timer->cancel();
				kill = TRUE;
				break;
			}
						
			if (status == STATUS_WAIT_0)
			{	// told to quit
				DEBUG_START();
				TRACE("Loop: Request to kill thread arrived...\n");
				TRACE("================= KILLING THREAD! ===============\n");
				timer->cancel();
				status = STATUS_DELETE_PENDING;
				kill = TRUE;
				break;
			}
			
			//if(device)
			if(pfClientThreadFunction)
			{
				if(StopRequested) break;
				// Do device specific thread processing...
				//TRACE("Calling thread %8.8lX function...\n",thread);
				if(status = pfClientThreadFunction(ClientContext))
				{
					TRACE("Device reported error %8.8lX\n",status);
					timer->cancel();
					break;
				}
			}
			else
			{
				DEBUG_START();
				TRACE("================= THREAD FUNCTION POINTER IS NOT SET!! FINISHED... ===============\n");
				TRACE("================= KILLING THREAD! ===============\n");
				status = STATUS_DELETE_PENDING;
				kill = TRUE;
				break;
			}
		}
	}// until told to quit
	TRACE("			Leaving thread %8.8lX...\n", thread);
	if(event) event->set(&evIdle, IO_NO_INCREMENT, FALSE);
	if(event) event->set(&evStopped, IO_NO_INCREMENT, FALSE);
	if(semaphore) semaphore->initialize(&smOnDemandStart, 0, MAXLONG);
 	if(system) system->terminateSystemThread(STATUS_SUCCESS);
}

#pragma PAGEDCODE
CThread::CThread(PCLIENT_THREAD_ROUTINE ClientThreadFunction,PVOID ClientContext, ULONG delay)
{	// StartPollingThread for the device
NTSTATUS status;
HANDLE hthread;
	m_Status = STATUS_INSUFFICIENT_RESOURCES;
	//this->device = device;
	// Create objects..
	event		= kernel->createEvent();
	system		= kernel->createSystem();
	timer		= kernel->createTimer(SynchronizationTimer);
	semaphore	= kernel->createSemaphore();

	debug  = kernel->createDebug();

	StopRequested = FALSE;
	ThreadActive  = FALSE;
	if(ALLOCATED_OK(event))
	{
		event->initialize(&evKill, NotificationEvent, FALSE);
		event->initialize(&evStart, SynchronizationEvent, FALSE);
		event->initialize(&evStopped, NotificationEvent, FALSE);
		event->initialize(&evIdle, NotificationEvent, TRUE);
	}
	// At the begining there is no request to start,
	// so semaphore is not at signal state.
	if(ALLOCATED_OK(semaphore))	semaphore->initialize(&smOnDemandStart, 0, MAXLONG);
	pfClientThreadFunction = ClientThreadFunction;
	this->ClientContext = ClientContext;
	PoolingTimeout = delay; // Default thread pooling interval...
	// Create system thread object...
	status = system->createSystemThread(&hthread, THREAD_ALL_ACCESS, NULL, NULL, NULL,
									(PKSTART_ROUTINE) ThreadFunction, this);
	if(NT_SUCCESS(status))	// Get thread pointer...
	{
		thread = NULL;
		status = system->referenceObjectByHandle(hthread, THREAD_ALL_ACCESS, NULL,
										KernelMode, (PVOID*) &thread, NULL);
		if(!NT_SUCCESS(status))
		{
			TRACE("FAILED TO REFERENCE OBJECT! Error %8.8lX\n", status);
		}
	}
	else TRACE("FAILED TO CREATE SYSTEM THREAD! Error %8.8lX\n", status);

	system->ZwClose(hthread);
	if(NT_SUCCESS(status) &&
		ALLOCATED_OK(event)&&
		ALLOCATED_OK(system)&&
		ALLOCATED_OK(timer)&&
		ALLOCATED_OK(semaphore) && thread)
			m_Status = STATUS_SUCCESS;
} // StartPollingThread

#pragma PAGEDCODE
CThread::~CThread()
{	// StopPollingThread
	DEBUG_START();
	TRACE("Terminating thread %8.8lX...\n", thread);
	if(event) event->set(&evKill, IO_NO_INCREMENT, FALSE);
	StopRequested = TRUE;
	//device = NULL;
	if (thread)
	{	// wait for the thread to die
		if(system && event)
		{
			ASSERT(system->getCurrentIrql()<=DISPATCH_LEVEL);
			event->waitForSingleObject(&evStopped, Executive, KernelMode, FALSE, NULL);
			if(!isWin98()) 
				event->waitForSingleObject(thread, Executive, KernelMode, FALSE, NULL);
			system->dereferenceObject(thread);
			thread = NULL;
		}
	}
	TRACE("Thread terminated...\n");

	if(event)  event->dispose();
	if(system) system->dispose();
	if(timer)  timer->dispose();
	if(semaphore) semaphore->dispose();

	if(debug)  debug->dispose();
}

#pragma PAGEDCODE
VOID CThread::kill()
{
	DEBUG_START();
	TRACE("Killing thread %8.8lX...\n", thread);
	StopRequested = TRUE;

	if(system) 
	{
		ASSERT(system->getCurrentIrql()<=DISPATCH_LEVEL);
	}
	if(event) event->set(&evKill, IO_NO_INCREMENT, FALSE);
	if(event) event->waitForSingleObject(&evStopped, Executive, KernelMode, FALSE, NULL);
}

#pragma PAGEDCODE
VOID CThread::start()
{
	DEBUG_START();
	TRACE("Starting thread %8.8lX...\n", thread);
	if(system) 
	{
		ASSERT(system->getCurrentIrql()<=DISPATCH_LEVEL);
	}
	StopRequested = FALSE;
	ThreadActive  = TRUE;
	// Start Card pooling...
	if(event) event->set(&evStart, IO_NO_INCREMENT, FALSE);
}

#pragma PAGEDCODE
VOID CThread::stop()
{
	DEBUG_START();
	TRACE("Stop thread %8.8lX...\n", thread);
	StopRequested = TRUE;
	ThreadActive  = FALSE;
	if(system)
	{
		ASSERT(system->getCurrentIrql()<=DISPATCH_LEVEL);
	}
	if(event)	  event->clear(&evStart);
	// Unblock thread if it is blocked...
	if(semaphore) semaphore->release(&smOnDemandStart,0,1,FALSE);
	// Wait for for the thread to go to the idle state...
	if(event)	  event->waitForSingleObject(&evIdle, Executive, KernelMode, FALSE, NULL);
	// Stop thread ...
	if(semaphore) semaphore->initialize(&smOnDemandStart, 0, MAXLONG);
}

#pragma PAGEDCODE
BOOL CThread::isThreadActive()
{
	return ThreadActive;
}

#pragma PAGEDCODE
VOID CThread::setPoolingInterval(ULONG delay)
{
	PoolingTimeout = delay;
};

#pragma PAGEDCODE
VOID CThread::callThreadFunction()
{	// This will force thread function to be called right away.
	// Useful if we want to update some information or
	// start some processing without waiting for the pooling
	// timeout to occure.
	if(semaphore) semaphore->release(&smOnDemandStart,0,1,FALSE);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\gempc430\timer.h ===
// Gemplus (C) 1999
// Version 1.0
// Author: Sergey Ivanov
// Date of creation - 18.05.1999
// Change log:
//

#ifndef __TIMER__
#define __TIMER__
#include "generic.h"

#define DELAY(t)\
{if(t){CTimer* timer = kernel->createTimer(NotificationTimer);\
	if(ALLOCATED_OK(timer)) {timer->delay(t);\
timer->dispose();}}}


#pragma PAGEDCODE
// This class will manage creation and 
// manipulation of driver Timers
class CTimer;
class CTimer
{
public:
	NTSTATUS m_Status;
	SAFE_DESTRUCTORS();
	virtual VOID dispose(){self_delete();};
protected:
KTIMER Timer;
protected:
	CTimer(){};
	virtual ~CTimer(){};
public:
	PKTIMER getHandle(){return &Timer;};
	virtual BOOL set(LARGE_INTEGER DueTime,LONG Period,PKDPC Dpc) {return FALSE;};
	virtual BOOL cancel() {return FALSE;};
	virtual VOID delay(ULONG Delay) {};
};

#endif//TIMER
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\gempc430\usbdev.h ===
// Gemplus (C) 1999
//
// Version 1.0
// Author: Sergey Ivanov
// Date of creation - 04.03.1999
// Change log:
//

#ifndef USB_DEV
#define USB_DEV

#include "wdmdev.h"
#include "debug.h"

#ifdef __cplusplus
extern "C" {
#endif

#pragma warning (disable:4200)
#include <usbdi.h>
#include <usbdlib.h>
#pragma warning (default:4200)
#ifdef __cplusplus
}
#endif




// Type of request driver can construct
#define COMMAND_REQUEST		1
#define RESPONSE_REQUEST	2
#define INTERRUPT_REQUEST	3
// Default buffers' sizes (4k)
// This values will be used as a requests to the bus driver.
// It looks like bus driver will not accept values greater then these.
// It will complain with "invalid parameter" status.
// ??? Is this limitation of bus driver or our driver design?
#define DEFAULT_COMMAND_BUFFER_SIZE		0x100
#define DEFAULT_RESPONSE_BUFFER_SIZE	0x100
#define DEFAULT_INTERRUPT_BUFFER_SIZE	0x100
// If we set Xfer size greater then 256, bus driver crashes with GPF
// The problem still is under investigation...
#define GUR_MAX_TRANSFER_SIZE	256


#pragma LOCKEDCODE
// Power request callback
NTSTATUS onPowerRequestCompletion(IN PDEVICE_OBJECT DeviceObject,IN UCHAR MinorFunction,
					IN POWER_STATE PowerState,IN PVOID Context,IN PIO_STATUS_BLOCK IoStatus);
NTSTATUS onPowerIrpComplete(IN PDEVICE_OBJECT NullDeviceObject,IN PIRP Irp,IN PVOID Context);

#pragma PAGEDCODE
class CWDMDevice;

class CUSBDevice : public CWDMDevice
{
public:
    NTSTATUS m_Status;
	SAFE_DESTRUCTORS();
private:
	ULONG Idle_conservation;
	ULONG Idle_performance;

	// Max xfer size with our device
	ULONG m_MaximumTransferSize;
	
	// USB device endpoints
	USBD_PIPE_HANDLE m_ControlPipe;
	USBD_PIPE_HANDLE m_InterruptPipe;
	USBD_PIPE_HANDLE m_ResponsePipe;
	USBD_PIPE_HANDLE m_CommandPipe;

    // ptr to the USB device descriptor
    // for this device
    PUSB_DEVICE_DESCRIPTOR m_DeviceDescriptor;
    // USB configuration handle and ptr for the configuration the
    // device is currently in
	USBD_CONFIGURATION_HANDLE			m_ConfigurationHandle;
    PUSB_CONFIGURATION_DESCRIPTOR		m_Configuration;
    // we support one interface
    // this is a copy of the info structure
    // returned from select_configuration or
    // select_interface
    PUSBD_INTERFACE_INFORMATION m_Interface;

	//Bus drivers set the appropriate values in this structure in response
	//to an IRP_MN_QUERY_CAPABILITIES IRP. Function and filter drivers might
	//alter the capabilities set by the bus driver.
    DEVICE_CAPABILITIES Capabilities;

	// used to save the currently-being-handled system-requested power irp request
    //PIRP PowerIrp;

	// Xfer buffers will be dynamically allocated at device start
    ULONG ResponseBufferLength;
    PVOID m_ResponseBuffer;// Bulk IN pipe
	LONG   Response_ErrorNum;

    ULONG CommandBufferLength;
    PVOID m_CommandBuffer;// Bulk OUT pipe
	LONG   Command_ErrorNum;

    ULONG InterruptBufferLength;
    PVOID m_InterruptBuffer;// Interrupt IN pipe
	LONG   Interrupt_ErrorNum;
public:	
	CUSBDevice();
	~CUSBDevice();
	virtual VOID dispose()
	{ 
		removeRef();
		if(!getRefCount()) self_delete();
		else
		{
			TRACE("FAILED TO DISPOSE OBJECT! refcount %x\n",getRefCount());
		}
	};
protected:
	virtual NTSTATUS	PnPHandler(LONG HandlerID,IN PIRP Irp);

	virtual NTSTATUS	PnP_HandleRemoveDevice(IN PIRP Irp);
	virtual NTSTATUS	PnP_HandleStartDevice(IN PIRP Irp);
	virtual NTSTATUS	PnP_HandleStopDevice(IN PIRP Irp);
	virtual NTSTATUS	PnP_StartDevice();
	virtual VOID		PnP_StopDevice();
	virtual NTSTATUS	PnP_HandleQueryRemove(IN PIRP Irp);
	virtual NTSTATUS	PnP_HandleCancelRemove(IN PIRP Irp);
	virtual NTSTATUS	PnP_HandleQueryStop(IN PIRP Irp);
	virtual NTSTATUS	PnP_HandleCancelStop(IN PIRP Irp);
	virtual NTSTATUS	PnP_HandleQueryRelations(IN PIRP Irp);
	virtual NTSTATUS	PnP_HandleQueryInterface(IN PIRP Irp);
	virtual NTSTATUS	PnP_HandleQueryCapabilities(IN PIRP Irp);
	virtual NTSTATUS	PnP_HandleQueryResources(IN PIRP Irp);
	virtual NTSTATUS	PnP_HandleQueryResRequirements(IN PIRP Irp);
	virtual NTSTATUS	PnP_HandleQueryText(IN PIRP Irp);
	virtual NTSTATUS	PnP_HandleFilterResRequirements(IN PIRP Irp);
	virtual NTSTATUS	PnP_HandleReadConfig(IN PIRP Irp);
	virtual NTSTATUS	PnP_HandleWriteConfig(IN PIRP Irp);
	virtual NTSTATUS	PnP_HandleEject(IN PIRP Irp);
	virtual NTSTATUS	PnP_HandleSetLock(IN PIRP Irp);
	virtual NTSTATUS	PnP_HandleQueryID(IN PIRP Irp);
	virtual NTSTATUS	PnP_HandleQueryPnPState(IN PIRP Irp);
	virtual NTSTATUS	PnP_HandleQueryBusInfo(IN PIRP Irp);
	virtual NTSTATUS	PnP_HandleUsageNotification(IN PIRP Irp);
	virtual NTSTATUS	PnP_HandleSurprizeRemoval(IN PIRP Irp);

private:
	// USB device support functions
	PURB				buildBusTransferRequest(CIoPacket* Irp,UCHAR Command);
	VOID				finishBusTransferRequest(CIoPacket* Irp,UCHAR Command);

	NTSTATUS						QueryBusCapabilities(PDEVICE_CAPABILITIES Capabilities);
	PUSB_DEVICE_DESCRIPTOR			getDeviceDescriptor();
	PUSB_CONFIGURATION_DESCRIPTOR	getConfigurationDescriptor();
	PUSBD_INTERFACE_INFORMATION		activateInterface(PUSB_CONFIGURATION_DESCRIPTOR Configuration);
	NTSTATUS						disactivateInterface();
	// 
	NTSTATUS	resetDevice();
	NTSTATUS	resetPipe(IN USBD_PIPE_HANDLE Pipe);
	NTSTATUS	resetAllPipes();
	NTSTATUS	abortPipes();

	// Low level communication functions...
	virtual NTSTATUS   sendRequestToDevice(CIoPacket* Irp,PIO_COMPLETION_ROUTINE Routine);
	virtual NTSTATUS   sendRequestToDeviceAndWait(CIoPacket* Irp);
	// Handle requests for specific pipes..
	virtual NTSTATUS   readSynchronously(CIoPacket* Irp,IN USBD_PIPE_HANDLE Pipe);
	virtual NTSTATUS   writeSynchronously(CIoPacket* Irp,IN USBD_PIPE_HANDLE Pipe);
	
	// Support for the reader interface
	virtual NTSTATUS   send(CIoPacket* Irp);
	virtual NTSTATUS   sendAndWait(CIoPacket* Irp);
//	virtual  NTSTATUS   writeAndWait(PUCHAR pRequest,ULONG RequestLength,PUCHAR pReply,ULONG* pReplyLength);
//	virtual  NTSTATUS   readAndWait(PUCHAR pRequest,ULONG RequestLength,PUCHAR pReply,ULONG* pReplyLength);

public:
	virtual  NTSTATUS   writeAndWait(PUCHAR pRequest,ULONG RequestLength,PUCHAR pReply,ULONG* pReplyLength);
	virtual  NTSTATUS   readAndWait(PUCHAR pRequest,ULONG RequestLength,PUCHAR pReply,ULONG* pReplyLength);

	virtual NTSTATUS	pnpRequest(IN PIRP Irp);

#define _POWER_
#ifdef _POWER_
	// POWER MANAGEMENT FUNCTIONS
	virtual NTSTATUS	powerRequest(IN PIRP Irp);

	virtual VOID		activatePowerHandler(LONG HandlerID);
	virtual VOID		disActivatePowerHandler(LONG HandlerID);
	virtual NTSTATUS	callPowerHandler(LONG HandlerID,IN PIRP Irp);
	virtual BOOLEAN		setDevicePowerState(IN DEVICE_POWER_STATE DeviceState);
	virtual VOID	    onSystemPowerDown();
	virtual VOID		onSystemPowerUp();
	// Handlers
	virtual NTSTATUS	power_HandleSetPower(IN PIRP Irp);
	virtual NTSTATUS	power_HandleWaitWake(IN PIRP Irp);
	virtual NTSTATUS	power_HandleSequencePower(IN PIRP Irp);
	virtual NTSTATUS	power_HandleQueryPower(IN PIRP Irp);
	// callback

#endif
	// USB device specific implementations of system callbacks
	// They ovewrite base class defaults.
	virtual NTSTATUS open(PIRP Irp) 
	{
		TRACE("***** USB OPEN DEVICE *****\n");
		if (!NT_SUCCESS(acquireRemoveLock()))
			return completeDeviceRequest(Irp, STATUS_DELETE_PENDING, 0);
		releaseRemoveLock();
		return completeDeviceRequest(Irp, STATUS_SUCCESS, 0); 
	};//Create
    virtual NTSTATUS close(PIRP Irp)
	{ 
		TRACE("***** USB CLOSE DEVICE *****\n");
		return completeDeviceRequest(Irp, STATUS_SUCCESS, 0); 
	};

	virtual NTSTATUS	deviceControl(IN PIRP Irp);
	virtual NTSTATUS    read(IN PIRP Irp);
	virtual NTSTATUS    write(IN PIRP Irp);

	virtual NTSTATUS	createDeviceObjectByName(PDEVICE_OBJECT* ppFdo);
};

#endif // If defined
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\gempc430\usbdev.cpp ===
#ifdef  USBREADER_PROJECT
#ifndef USBDEVICE_PROJECT
#define USBDEVICE_PROJECT
#endif
#endif

#ifdef  USBDEVICE_PROJECT
#pragma message("COMPILING USB DEVICE...")

#include "usbdev.h"
// GUID should be defined outside of any block!
#include "guid.h"

#include "thread.h"

#include "usbreader.h" //TO BE REMOVED

VOID onSendDeviceSetPowerComplete(PDEVICE_OBJECT junk, UCHAR fcn, POWER_STATE state, PPOWER_CONTEXT context, PIO_STATUS_BLOCK pstatus)
{// SendDeviceSetPowerComplete
        context->status = pstatus->Status;
        KeSetEvent(context->powerEvent, EVENT_INCREMENT, FALSE);
}// SendDeviceSetPowerComplete


#pragma PAGEDCODE
CUSBDevice::CUSBDevice()
{
        m_Status = STATUS_INSUFFICIENT_RESOURCES;
        INCLUDE_PNP_FUNCTIONS_NAMES();
        INCLUDE_POWER_FUNCTIONS_NAMES();
        m_Type  = USB_DEVICE;
        m_Flags |= DEVICE_SURPRISE_REMOVAL_OK; 

        m_MaximumTransferSize = GUR_MAX_TRANSFER_SIZE;

        CommandBufferLength       = DEFAULT_COMMAND_BUFFER_SIZE;
        ResponseBufferLength  = DEFAULT_RESPONSE_BUFFER_SIZE;
        InterruptBufferLength = DEFAULT_INTERRUPT_BUFFER_SIZE;


        // Register handlers processed by this device...
        activatePnPHandler(IRP_MN_START_DEVICE);

        activatePnPHandler(IRP_MN_QUERY_REMOVE_DEVICE);
        activatePnPHandler(IRP_MN_REMOVE_DEVICE);
        activatePnPHandler(IRP_MN_SURPRISE_REMOVAL);
        activatePnPHandler(IRP_MN_CANCEL_REMOVE_DEVICE);
        
        activatePnPHandler(IRP_MN_QUERY_STOP_DEVICE);
        activatePnPHandler(IRP_MN_CANCEL_STOP_DEVICE);
        activatePnPHandler(IRP_MN_STOP_DEVICE);

        activatePnPHandler(IRP_MN_QUERY_CAPABILITIES);

        // Register Power handlers processed by driver...
        activatePowerHandler(IRP_MN_SET_POWER);
        activatePowerHandler(IRP_MN_QUERY_POWER);
        TRACE("                         *** New USB device %8.8lX was created ***\n",this);
        m_Status = STATUS_SUCCESS;
}

#pragma PAGEDCODE
CUSBDevice::~CUSBDevice()
{
        waitForIdle();
        TRACE("                         USB device %8.8lX was destroyed ***\n",this);
}

// Function redirects all PnP requests
// This is main entry point for the system (after c wrapper).
// It handles locking device for a PnP requests and redirecting
// it to specific PnP handlers.
// In case of IRP_MN_REMOVE_DEVICE it leaves device locked till
// remove message recieved.
#pragma PAGEDCODE
NTSTATUS        CUSBDevice::pnpRequest(IN PIRP Irp)
{ 
NTSTATUS status;

        if (!NT_SUCCESS(acquireRemoveLock()))
        {
                TRACE("Failed to lock USB device...\n");
                return completeDeviceRequest(Irp, STATUS_DELETE_PENDING, 0);
        }

        PIO_STACK_LOCATION stack = irp->getCurrentStackLocation(Irp);
        ASSERT(stack->MajorFunction == IRP_MJ_PNP);

        ULONG fcn = stack->MinorFunction;
        if (fcn >= arraysize(PnPfcntab))
        {       // some function we don't know about
                TRACE("Unknown PnP function at USB device...\n");
                status = PnP_Default(Irp); 
                releaseRemoveLock();
                return status;
        }

#ifdef DEBUG
        TRACE("PnP request (%s) \n", PnPfcnname[fcn]);
#endif

        // Call real function to handle the request
        status = PnPHandler(fcn,Irp);

        // If we've got PnP request to remove->
        // Keep device locked to prevent futher connections.
        // Device will be unlocked and removed by driver later...
        if (fcn != IRP_MN_REMOVE_DEVICE)        releaseRemoveLock();
        if(!NT_SUCCESS(status))
        {
                if(status != STATUS_NOT_SUPPORTED)
                {
                        TRACE("\n******** PnP handler reported ERROR -> %x\n", status);
                }
        }
        return status;
}

#pragma PAGEDCODE
// Main redirector of all PnP handlers...
NTSTATUS        CUSBDevice::PnPHandler(LONG HandlerID,IN PIRP Irp)
{
        // If Handler is not registered...
        if (HandlerID >= arraysize(PnPfcntab))  return PnP_Default(Irp);
        if(!PnPfcntab[HandlerID])                               return PnP_Default(Irp);
        // Call registered PnP Handler...
        switch(HandlerID)
        {
        case IRP_MN_START_DEVICE:                       return PnP_HandleStartDevice(Irp);
                break;
        case IRP_MN_QUERY_REMOVE_DEVICE:        return PnP_HandleQueryRemove(Irp);
                break;
        case IRP_MN_REMOVE_DEVICE:                      return PnP_HandleRemoveDevice(Irp);
                break;
        case IRP_MN_CANCEL_REMOVE_DEVICE:       return PnP_HandleCancelRemove(Irp);
                break;
        case IRP_MN_STOP_DEVICE:                        return PnP_HandleStopDevice(Irp);
                break;
        case IRP_MN_QUERY_STOP_DEVICE:          return PnP_HandleQueryStop(Irp);
                break;
        case IRP_MN_CANCEL_STOP_DEVICE:         return PnP_HandleCancelStop(Irp);
                break;
        case IRP_MN_QUERY_DEVICE_RELATIONS: return PnP_HandleQueryRelations(Irp);
                break;
        case IRP_MN_QUERY_INTERFACE:            return PnP_HandleQueryInterface(Irp);
                break;
        case IRP_MN_QUERY_CAPABILITIES:         return PnP_HandleQueryCapabilities(Irp);
                break;
        case IRP_MN_QUERY_RESOURCES:            return PnP_HandleQueryResources(Irp);
                break;
        case IRP_MN_QUERY_RESOURCE_REQUIREMENTS: 
                                                                                return PnP_HandleQueryResRequirements(Irp);
                break;
        case IRP_MN_QUERY_DEVICE_TEXT:          return PnP_HandleQueryText(Irp);
                break;
        case IRP_MN_FILTER_RESOURCE_REQUIREMENTS:
                                                                                return PnP_HandleFilterResRequirements(Irp);
                break;
        case 0x0E:                                                      return PnP_Default(Irp);
                break;
        case IRP_MN_READ_CONFIG:                        return PnP_HandleReadConfig(Irp);
                break;
        case IRP_MN_WRITE_CONFIG:                       return PnP_HandleWriteConfig(Irp);
                break;
        case IRP_MN_EJECT:                                      return PnP_HandleEject(Irp);
                break;
        case IRP_MN_SET_LOCK:                           return PnP_HandleSetLock(Irp);
                break;
        case IRP_MN_QUERY_ID:                           return PnP_HandleQueryID(Irp);
                break;
        case IRP_MN_QUERY_PNP_DEVICE_STATE:     return PnP_HandleQueryPnPState(Irp);
                break;
        case IRP_MN_QUERY_BUS_INFORMATION:      return PnP_HandleQueryBusInfo(Irp);
                break;
        case IRP_MN_DEVICE_USAGE_NOTIFICATION:  return PnP_HandleUsageNotification(Irp);
                break;
        case IRP_MN_SURPRISE_REMOVAL:           return PnP_HandleSurprizeRemoval(Irp);
                break;
        }
        return PnP_Default(Irp);
}

#pragma PAGEDCODE
// Asks object to remove device
// Object itself will be removed at wrapper function
NTSTATUS CUSBDevice::PnP_HandleRemoveDevice(IN PIRP Irp)
{
        // Set device removal state
        m_RemoveLock.removing = TRUE;
        // Do any processing required for *us* to remove the device. This
        // would include completing any outstanding requests, etc.
        PnP_StopDevice();

        // Do not remove actually our device here!
        // It will be done automatically by PnP handler at basic class.

        // Let lower-level drivers handle this request. Ignore whatever
        // result eventuates.
        Irp->IoStatus.Status = STATUS_SUCCESS;
        NTSTATUS status = PnP_Default(Irp);
        // lower-level completed IoStatus already
        return status;
}

#pragma PAGEDCODE
NTSTATUS CUSBDevice::PnP_HandleStartDevice(IN PIRP Irp)
{
        waitForIdleAndBlock();
        // First let all lower-level drivers handle this request. In this particular
        // sample, the only lower-level driver should be the physical device created
        // by the bus driver, but there could theoretically be any number of intervening
        // bus filter devices. Those drivers may need to do some setup at this point
        // in time before they'll be ready to handle non-PnP IRP's.
        Irp->IoStatus.Status = STATUS_SUCCESS;
        NTSTATUS status = forwardAndWait(Irp);
        if (!NT_SUCCESS(status))
        {
                TRACE("         ******* BUS DRIVER FAILED START REQUEST! %8.8lX ******",status);
                CLogger*   logger = kernel->getLogger();
                if(logger) logger->logEvent(GRCLASS_BUS_DRIVER_FAILED_REQUEST,getSystemObject());

                return completeDeviceRequest(Irp, status, Irp->IoStatus.Information);
        }

        status = PnP_StartDevice();
        setIdle();

        return completeDeviceRequest(Irp, status, Irp->IoStatus.Information);
}

#pragma PAGEDCODE
NTSTATUS CUSBDevice::PnP_HandleStopDevice(IN PIRP Irp)
{
        PnP_StopDevice();
        m_Started = FALSE;
        // Let lower-level drivers handle this request. Ignore whatever
        // result eventuates.
        Irp->IoStatus.Status = STATUS_SUCCESS;
        NTSTATUS status = PnP_Default(Irp);
        return status;
}


#pragma PAGEDCODE
NTSTATUS CUSBDevice::PnP_StartDevice()
{       // StartDevice
NTSTATUS status = STATUS_SUCCESS;
        if(m_Started)
        {
                TRACE("##### Current device was already started!\n");
                ASSERT(!m_Started);
                return STATUS_DEVICE_BUSY;
        }

        __try
        {
                // Do all required processing to start USB device.
                // It will include getting Device and configuration descriptors
                // and selecting specific interface.
                // For now our device support only interface.
                // So, it will be activated at activateInterface().

                m_DeviceDescriptor = getDeviceDescriptor();
                if(!m_DeviceDescriptor)
                {
                        status = STATUS_INSUFFICIENT_RESOURCES;
                        __leave;
                }

                TRACE("\nDeviceDescriptor %8.8lX\n",m_DeviceDescriptor);

                m_Configuration    = getConfigurationDescriptor();
                if(!m_Configuration)
                {
                        status = STATUS_INSUFFICIENT_RESOURCES;
                        __leave;
                }

                TRACE("Configuration %8.8lX\n",m_Configuration);
                
                m_Interface                = activateInterface(m_Configuration);
                if(!m_Interface)
                {
                        status = STATUS_INSUFFICIENT_RESOURCES;
                        __leave;
                }

                TRACE("Selected interface %8.8lX\n\n",m_Interface);

                // Allocate Xfer buffers
                if(m_CommandPipe)
                {
                        TRACE("Allocating command buffer (length 0x%x)...\n",CommandBufferLength);
                        m_CommandBuffer   = memory->allocate(NonPagedPool, CommandBufferLength);
                        if(!m_CommandBuffer)
                        {
                                status = STATUS_INSUFFICIENT_RESOURCES;
                                __leave;
                        }
                }
                if(m_ResponsePipe)
                {
                        TRACE("Allocating response buffer (length 0x%x)...\n", ResponseBufferLength);
                        m_ResponseBuffer  = memory->allocate(NonPagedPool, ResponseBufferLength);
                        if(!m_ResponseBuffer)
                        {
                                status = STATUS_INSUFFICIENT_RESOURCES;
                                __leave;
                        }
                }
                if(m_InterruptPipe)
                {
                        TRACE("Allocating interrupt buffer (length 0x%x)...\n", InterruptBufferLength);
                        m_InterruptBuffer = memory->allocate(NonPagedPool, InterruptBufferLength);
                        if(!m_InterruptBuffer)
                        {
                                status = STATUS_INSUFFICIENT_RESOURCES;
                                __leave;
                        }
                }
        }

        __finally
        {
                // Check memory allocations!
                if(!NT_SUCCESS(status))
                {
                        if(m_DeviceDescriptor)  memory->free(m_DeviceDescriptor);
                        if(m_Configuration)             memory->free(m_Configuration);
                        if(m_Interface)                 memory->free(m_Interface);
                        if(m_CommandBuffer)             memory->free(m_CommandBuffer);
                        if(m_ResponseBuffer)    memory->free(m_ResponseBuffer);
                        if(m_InterruptBuffer)   memory->free(m_InterruptBuffer);

                        m_DeviceDescriptor      = NULL;
                        m_Configuration         = NULL;
                        m_Interface                     = NULL;
                        m_CommandBuffer         = NULL;
                        m_ResponseBuffer        = NULL;
                        m_InterruptBuffer       = NULL;
                }
                else
                {
                        // Give chance inhereted devices to initialize...
                        onDeviceStart();

                        TRACE("USB device started successfully...\n\n");
                        // Device has been completely initialized and is ready to run.
                        m_Started = TRUE;
                }
        }
        return status;
}


#pragma PAGEDCODE
// This function used for both Stop and Remove PnP events
// It will undo everything what was done at StartDevice
VOID CUSBDevice::PnP_StopDevice()
{                                                       // StopDevice
        if (!m_Started) return; // device not started, so nothing to do

        TRACE("*** Stop USB Device %8.8lX requested... ***\n", this);


        onDeviceStop();
        // If any pipes are still open, call USBD with URB_FUNCTION_ABORT_PIPE
        // This call will also close the pipes; if any user close calls get through,
        // they will be noops
        abortPipes();
        
        //We basically just tell USB this device is now 'unconfigured'
        if(!isSurprizeRemoved()) disactivateInterface();

        // Free resources allocated at startup
        m_ControlPipe   = NULL;
        m_InterruptPipe = NULL;
        m_ResponsePipe  = NULL;
        m_CommandPipe   = NULL;

        if(m_DeviceDescriptor)  memory->free(m_DeviceDescriptor);
        if(m_Configuration)             memory->free(m_Configuration);
        if(m_Interface)                 memory->free(m_Interface);

        if(m_CommandBuffer)             memory->free(m_CommandBuffer);
        if(m_ResponseBuffer)    memory->free(m_ResponseBuffer);
        if(m_InterruptBuffer)   memory->free(m_InterruptBuffer);

        TRACE("*** Device resources released ***\n");
        setIdle();

        m_Started = FALSE;

}

#pragma PAGEDCODE
NTSTATUS CUSBDevice::PnP_HandleQueryRemove(IN PIRP Irp)
{
        TRACE("********  QUERY REMOVAL ********\n");
        // Win98 doesn't check for open handles before allowing a remove to proceed,
        // and it may deadlock in IoReleaseRemoveLockAndWait if handles are still
        // open.

        if (isWin98() && m_DeviceObject->ReferenceCount)
        {
                TRACE("Failing removal query due to open handles\n");
                return completeDeviceRequest(Irp, STATUS_DEVICE_BUSY, 0);
        }

        Irp->IoStatus.Status = STATUS_SUCCESS;
        NTSTATUS status = forwardAndWait(Irp);
        return completeDeviceRequest(Irp, Irp->IoStatus.Status,0);
}

NTSTATUS CUSBDevice::PnP_HandleCancelRemove(IN PIRP Irp)
{
        NTSTATUS status;

        status = forwardAndWait(Irp);
        ASSERT(NT_SUCCESS(status));
        
        Irp->IoStatus.Status = STATUS_SUCCESS;

        return completeDeviceRequest(Irp, Irp->IoStatus.Status,0);

}

NTSTATUS CUSBDevice::PnP_HandleQueryStop(IN PIRP Irp)
{
        TRACE("********  QUERY STOP ********\n");
        if(isDeviceLocked())
        {
                Irp->IoStatus.Status = STATUS_DEVICE_BUSY;
                return completeDeviceRequest(Irp, Irp->IoStatus.Status,0);
        }

        Irp->IoStatus.Status = STATUS_SUCCESS;
        NTSTATUS status = forwardAndWait(Irp);
        return completeDeviceRequest(Irp, Irp->IoStatus.Status,0);
}

NTSTATUS CUSBDevice::PnP_HandleCancelStop(IN PIRP Irp)
{
        TRACE("********  CANCEL STOP ********\n");
        Irp->IoStatus.Status = STATUS_SUCCESS;
        NTSTATUS status = forwardAndWait(Irp);
        return completeDeviceRequest(Irp, Irp->IoStatus.Status,0);
}

NTSTATUS CUSBDevice::PnP_HandleQueryRelations(IN PIRP Irp)
{
        return PnP_Default(Irp);
}
NTSTATUS CUSBDevice::PnP_HandleQueryInterface(IN PIRP Irp)
{
        return PnP_Default(Irp);
}

#pragma PAGEDCODE
NTSTATUS CUSBDevice::PnP_HandleQueryCapabilities(PIRP Irp)
{
        if(!Irp) return STATUS_INVALID_PARAMETER;
PIO_STACK_LOCATION stack = irp->getCurrentStackLocation(Irp);
PDEVICE_CAPABILITIES pdc = stack->Parameters.DeviceCapabilities.Capabilities;
        // Check to be sure we know how to handle this version of the capabilities structure
        if (pdc->Version < 1)   return PnP_Default(Irp);
        Irp->IoStatus.Status = STATUS_SUCCESS;
        NTSTATUS status = forwardAndWait(Irp);
        if (NT_SUCCESS(status))
        {                                               // IRP succeeded
                stack = irp->getCurrentStackLocation(Irp);
                pdc = stack->Parameters.DeviceCapabilities.Capabilities;
                if(!pdc) return STATUS_INVALID_PARAMETER;
                //if (m_Flags & DEVICE_SURPRISE_REMOVAL_OK)
                /*{     // Smartcard readers do not support it!
                        //if(!isWin98())        pdc->SurpriseRemovalOK = TRUE;
                }*/
                pdc->SurpriseRemovalOK = FALSE;
                m_DeviceCapabilities = *pdc;    // save capabilities for whoever needs to see them
                TRACE(" Device allows surprize removal - %s\n",(m_DeviceCapabilities.SurpriseRemovalOK?"YES":"NO"));
        }                               // IRP succeeded
        return completeDeviceRequest(Irp, status,Irp->IoStatus.Information);
}// HandleQueryCapabilities



NTSTATUS CUSBDevice::PnP_HandleQueryResources(IN PIRP Irp)
{
        return PnP_Default(Irp);
}
NTSTATUS CUSBDevice::PnP_HandleQueryResRequirements(IN PIRP Irp)
{
        return PnP_Default(Irp);
}
NTSTATUS CUSBDevice::PnP_HandleQueryText(IN PIRP Irp)
{
        return PnP_Default(Irp);
}

NTSTATUS CUSBDevice::PnP_HandleFilterResRequirements(IN PIRP Irp)
{
        TRACE("Default action for filtering resource requirements...");
        return PnP_Default(Irp);
}

NTSTATUS CUSBDevice::PnP_HandleReadConfig(IN PIRP Irp)
{
        return PnP_Default(Irp);
}
NTSTATUS CUSBDevice::PnP_HandleWriteConfig(IN PIRP Irp)
{
        return PnP_Default(Irp);
}
NTSTATUS CUSBDevice::PnP_HandleEject(IN PIRP Irp)
{
        return PnP_Default(Irp);
}
NTSTATUS CUSBDevice::PnP_HandleSetLock(IN PIRP Irp)
{
        return PnP_Default(Irp);
}
NTSTATUS CUSBDevice::PnP_HandleQueryID(IN PIRP Irp)
{
        return PnP_Default(Irp);
}
NTSTATUS CUSBDevice::PnP_HandleQueryPnPState(IN PIRP Irp)
{
        return PnP_Default(Irp);
}
NTSTATUS CUSBDevice::PnP_HandleQueryBusInfo(IN PIRP Irp)
{
        return PnP_Default(Irp);
}
NTSTATUS CUSBDevice::PnP_HandleUsageNotification(IN PIRP Irp)
{
        return PnP_Default(Irp);
}
NTSTATUS CUSBDevice::PnP_HandleSurprizeRemoval(IN PIRP Irp)
{
        TRACE("********  SURPRIZE REMOVAL ********\n");
        return PnP_Default(Irp);
}


// Functions allocate and initialize USB request block.
// It can be used for read/write request on specific Pipe.
// Allocated URB should be free later upon completing of the request.
PURB    CUSBDevice::buildBusTransferRequest(CIoPacket* Irp,UCHAR Command)
{
USHORT  Size;
ULONG   BufferLength;
PURB    Urb = NULL;
PVOID   pBuffer;
ULONG   TransferFlags;
IN USBD_PIPE_HANDLE Pipe = NULL;
ULONG   TransferLength;
        
        if(!Irp) return NULL;
        if(Command == COMMAND_REQUEST)
        {
                BufferLength = CommandBufferLength;
                pBuffer = m_CommandBuffer;
                TransferFlags = USBD_SHORT_TRANSFER_OK;
                Pipe = m_CommandPipe;
                TransferLength = Irp->getWriteLength();
                if(!Pipe || !TransferLength)
                {
                        TRACE("##### Requested Pipe or TransferLength == 0 for the requested command %d ...\n", Command);
                        return NULL;
                }
                TRACE("Command transfer requested...\n");
        }
        else
        if(Command == RESPONSE_REQUEST)
        {
                BufferLength = ResponseBufferLength;
                pBuffer = m_ResponseBuffer;
                TransferFlags = USBD_TRANSFER_DIRECTION_IN | USBD_SHORT_TRANSFER_OK;
                Pipe = m_ResponsePipe;
                TransferLength = BufferLength;
                if(!Pipe || !TransferLength)
                {
                        TRACE("##### Requested Pipe or TransferLength == 0 for the requested command %d ...\n", Command);
                        return NULL;
                }
                TRACE("Response transfer requested with number of expected bytes %x\n",Irp->getReadLength());
        }
        else
        if(Command == INTERRUPT_REQUEST)
        {
                BufferLength  = InterruptBufferLength;
                pBuffer = m_InterruptBuffer;
                TransferFlags = USBD_TRANSFER_DIRECTION_IN | USBD_SHORT_TRANSFER_OK;
                Pipe = m_InterruptPipe;
                TransferLength = BufferLength;
                if(!Pipe || !TransferLength)
                {
                        TRACE("##### Requested Pipe or TransferLength == 0 for the requested command %d ...\n", Command);
                        return NULL;
                }
                TRACE("Interrupt transfer requested...\n");
        }
        else
        {
                TRACE("Incorrect command was requested %d", Command);
                return NULL;
        }

        Size = sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER);
        Urb = (PURB) memory->allocate(NonPagedPool, Size);
        if (Urb) 
        {
                memory->zero(Urb, Size);
                memory->zero(pBuffer, BufferLength);
                if(Command == COMMAND_REQUEST) 
                {
                        memory->copy(pBuffer,Irp->getBuffer(), TransferLength);
                        ((PUCHAR)pBuffer)[TransferLength] = 0x00;
                        
                        //TRACE("Command ");
                        //TRACE_BUFFER(pBuffer,TransferLength);
                }

                UsbBuildInterruptOrBulkTransferRequest(Urb,(USHORT) Size,
                                               Pipe,
                                               pBuffer,
                                               NULL,
                                               TransferLength,
                                                                                           TransferFlags,
                                                                                           NULL);
        }
        else
        {
                TRACE("##### ERROR: failed to allocate URB request...\n");
        }

        return Urb;
}

VOID    CUSBDevice::finishBusTransferRequest(CIoPacket* Irp,UCHAR Command)
{
ULONG   BufferLength;
PVOID   pBuffer;
ULONG_PTR   info;

        if(!Irp)
        {
                TRACE(" **** Invalid parameter -> Irp\n");
                return;
        }

        if(!(info = Irp->getInformation())) 
        {
                TRACE(" **** There is no reported information\n");
                return;
        }
        if(Command == COMMAND_REQUEST)
        {
                BufferLength = CommandBufferLength;
                pBuffer      = m_CommandBuffer;
                TRACE("         Command transfer finished with length %d\n",info);
        }
        else
        if(Command == RESPONSE_REQUEST)
        {
                ULONG Length = Irp->getReadLength();
                BufferLength = (ULONG)(info>ResponseBufferLength?ResponseBufferLength:info);
                BufferLength = BufferLength>Length?Length:BufferLength;

                pBuffer = m_ResponseBuffer;
                TRACE("Bus Driver replied with length %d\n",info);
                memory->copy(Irp->getBuffer(),pBuffer, BufferLength);
                if(BufferLength!=info)
                {
                        TRACE("##### Response Buffer short! Buffer length %x  Reply length %x \n",ResponseBufferLength,info);
                }
                //TRACE("Response ");
                //TRACE_BUFFER(pBuffer,BufferLength);
        }
        else
        if(Command == INTERRUPT_REQUEST)
        {
                ULONG Length = Irp->getReadLength();
                BufferLength = (ULONG)(info>InterruptBufferLength?InterruptBufferLength:info);
                BufferLength = BufferLength>Length?Length:BufferLength;
                pBuffer = m_InterruptBuffer;

                TRACE("Bus Driver replied with length %d\n",info);
                memory->copy(Irp->getBuffer(),pBuffer, BufferLength);
                if(BufferLength!=info)
                {
                        TRACE("##### Interrupt Buffer short! Buffer length %x  Reply length %x \n",InterruptBufferLength,info);
                }
                TRACE("Interrupt ");
                TRACE_BUFFER(pBuffer,BufferLength);
        }
        else
        {
                TRACE("Incorrect command was requested %d", Command);
                return;
        }
}


//    This function generates an internal IRP from this driver to the PDO
//    to obtain information on the Physical Device Object's capabilities.
//    We are most interested in learning which system power states
//    are to be mapped to which device power states for honoring IRP_MJ_SET_POWER Irps.
#pragma PAGEDCODE
NTSTATUS        CUSBDevice::QueryBusCapabilities(PDEVICE_CAPABILITIES Capabilities)
{
NTSTATUS status;
CIoPacket* IoPacket;

    PAGED_CODE();

        TRACE("Quering USB bus capabilities...\n");
    // Build an IRP for us to generate an internal query request to the PDO
        IoPacket = new (NonPagedPool) CIoPacket(m_pLowerDeviceObject->StackSize);
        if(!ALLOCATED_OK(IoPacket))
        {
                DISPOSE_OBJECT(IoPacket);
                return STATUS_INSUFFICIENT_RESOURCES;
        }
        IoPacket->setTimeout(getCommandTimeout());

        IoPacket->buildStack(getSystemObject(),IRP_MJ_PNP, IRP_MN_QUERY_CAPABILITIES, 0,Capabilities);
        status = sendRequestToDeviceAndWait(IoPacket);

        DISPOSE_OBJECT(IoPacket);
    return status;
}

#pragma PAGEDCODE
// Function gets device descriptor from the USB bus driver
PUSB_DEVICE_DESCRIPTOR  CUSBDevice::getDeviceDescriptor()
{
PUSB_DEVICE_DESCRIPTOR Descriptor = NULL;
PURB Urb;
ULONG Size;
NTSTATUS Status = STATUS_INSUFFICIENT_RESOURCES;
CIoPacket* IoPacket = NULL;

        TRACE("Getting USB device descriptor...\n");
        __try
        {
                Urb = (PURB)memory->allocate(NonPagedPool,sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST));
                if(!Urb)        __leave;
                IoPacket = new (NonPagedPool) CIoPacket(m_pLowerDeviceObject->StackSize);
                if(!ALLOCATED_OK(IoPacket)) __leave;
                IoPacket->setTimeout(getCommandTimeout());

                Size = sizeof(USB_DEVICE_DESCRIPTOR);
                Descriptor = (PUSB_DEVICE_DESCRIPTOR)memory->allocate(NonPagedPool,Size);
                if(!Descriptor) __leave;
                UsbBuildGetDescriptorRequest(Urb,
                                                                         (USHORT) sizeof (struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                                                         USB_DEVICE_DESCRIPTOR_TYPE,
                                                                         0,
                                                                         0,
                                                                         Descriptor,
                                                                         NULL,
                                                                         Size,
                                                                         NULL);
                
                IoPacket->buildStack(getSystemObject(),IRP_MJ_INTERNAL_DEVICE_CONTROL, 0, IOCTL_INTERNAL_USB_SUBMIT_URB,Urb);
                Status = sendRequestToDeviceAndWait(IoPacket);
                if (NT_SUCCESS(Status)) 
                {
                        TRACE("Device Descriptor = %x, len %x\n",
                                                        Descriptor,
                                                        Urb->UrbControlDescriptorRequest.TransferBufferLength);

                        TRACE("\nGemplus USB SmartCard Device Descriptor:\n");
                        TRACE("-------------------------\n");
                        TRACE("bLength 0x%x\n", Descriptor->bLength);
                        TRACE("bDescriptorType 0x%x\n", Descriptor->bDescriptorType);
                        TRACE("bcdUSB 0x%x\n", Descriptor->bcdUSB);
                        TRACE("bDeviceClass 0x%x\n", Descriptor->bDeviceClass);
                        TRACE("bDeviceSubClass 0x%x\n", Descriptor->bDeviceSubClass);
                        TRACE("bDeviceProtocol 0x%x\n", Descriptor->bDeviceProtocol);
                        TRACE("bMaxPacketSize0 0x%x\n", Descriptor->bMaxPacketSize0);
                        TRACE("idVendor 0x%x\n", Descriptor->idVendor);
                        TRACE("idProduct 0x%x\n", Descriptor->idProduct);
                        TRACE("bcdDevice 0x%x\n", Descriptor->bcdDevice);
                        TRACE("iManufacturer 0x%x\n", Descriptor->iManufacturer);
                        TRACE("iProduct 0x%x\n", Descriptor->iProduct);
                        TRACE("iSerialNumber 0x%x\n", Descriptor->iSerialNumber);
                        TRACE("bNumConfigurations 0x%x\n", Descriptor->bNumConfigurations);
                        TRACE("-------------------------\n");
                }
                else 
                {
                        TRACE("#### ERROR: Failed to get device descriptor...\n");
                        CLogger*   logger = kernel->getLogger();
                        if(logger) logger->logEvent(GRCLASS_BUS_DRIVER_FAILED_REQUEST,getSystemObject());
                }
                __leave;;
        }

        __finally
        {
                if(Urb)                 memory->free(Urb);
                DISPOSE_OBJECT(IoPacket);
                if (!NT_SUCCESS(Status))
                {
                        if(Descriptor) memory->free(Descriptor);
                        Descriptor = NULL;
                }
                else
                {
                        if(Descriptor)  TRACE("*** Succeed to get device descriptor ***\n");
                }
        }
        return Descriptor;
}

// Function gets confuguration descriptor
PUSB_CONFIGURATION_DESCRIPTOR   CUSBDevice::getConfigurationDescriptor()
{
PUSB_CONFIGURATION_DESCRIPTOR Descriptor = NULL;
PURB Urb;
ULONG Size;
NTSTATUS Status = STATUS_INSUFFICIENT_RESOURCES;
CIoPacket* IoPacket = NULL;

        TRACE("Getting USB configuration descriptor...\n");

        __try
        {
                Urb = (PURB)memory->allocate(NonPagedPool,sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST));
                if(!Urb)        __leave;

                Size = sizeof(USB_CONFIGURATION_DESCRIPTOR);  
                while(TRUE)
                {
                        IoPacket = new (NonPagedPool) CIoPacket(m_pLowerDeviceObject->StackSize);
                        if(!ALLOCATED_OK(IoPacket)) __leave;
                        IoPacket->setTimeout(getCommandTimeout());

                        Descriptor = (PUSB_CONFIGURATION_DESCRIPTOR)memory->allocate(NonPagedPool,Size);
                        if(!Descriptor) __leave;
   
                        UsbBuildGetDescriptorRequest(Urb,
                                                                                 (USHORT) sizeof (struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                                                                 USB_CONFIGURATION_DESCRIPTOR_TYPE,
                                                                                 0,
                                                                                 0,
                                                                                 Descriptor,
                                                                                 NULL,
                                                                                 Size,
                                                                                 NULL);

                        IoPacket->buildStack(getSystemObject(),IRP_MJ_INTERNAL_DEVICE_CONTROL, 0, IOCTL_INTERNAL_USB_SUBMIT_URB,Urb);
                        Status = sendRequestToDeviceAndWait(IoPacket);
                        if (Urb->UrbControlDescriptorRequest.TransferBufferLength>0 &&
                                        Descriptor->wTotalLength > Size) 
                        {
                                // If bus driver truncated his descriptor-> resend command with
                                // bus return value
                                Size = Descriptor->wTotalLength;
                                TRACE("Descriptor length retrieved - 0x%x! Getting USB device configuration... ***\n",Size);
                                IoPacket->dispose();
                                IoPacket = NULL;
                                memory->free(Descriptor);
                                Descriptor = NULL;
                                Status = STATUS_INSUFFICIENT_RESOURCES;
                        } 
                        else    break;
                }

                if(NT_SUCCESS(Status))
                {
                        TRACE("\nUSB device Configuration Descriptor = %x, len %x\n",Descriptor,
                                                        Urb->UrbControlDescriptorRequest.TransferBufferLength);
                        TRACE("---------\n");
                        TRACE("bLength 0x%x\n", Descriptor->bLength);
                        TRACE("bDescriptorType 0x%x\n", Descriptor->bDescriptorType);
                        TRACE("wTotalLength 0x%x\n", Descriptor->wTotalLength);
                        TRACE("bNumInterfaces 0x%x\n", Descriptor->bNumInterfaces);
                        TRACE("bConfigurationValue 0x%x\n", Descriptor->bConfigurationValue);
                        TRACE("iConfiguration 0x%x\n", Descriptor->iConfiguration);
                        TRACE("bmAttributes 0x%x\n", Descriptor->bmAttributes);
                        TRACE("MaxPower 0x%x\n", Descriptor->MaxPower);
                        TRACE("---------\n");
                }
                else
                {
                        TRACE("*** Failed to get configuration descriptor ***\n");
                        CLogger*   logger = kernel->getLogger();
                        if(logger) logger->logEvent(GRCLASS_BUS_DRIVER_FAILED_REQUEST,getSystemObject());
                }
                __leave;
        }

        __finally
        {
                if(Urb)                 memory->free(Urb);
                DISPOSE_OBJECT(IoPacket);
                if (!NT_SUCCESS(Status))
                {
                        if(Descriptor) memory->free(Descriptor);
                        Descriptor = NULL;
                }
                else
                {
                        if(Descriptor)  TRACE("*** Succeed to get configuration descriptor ***\n");
                }
        }
    return Descriptor;
}

#pragma PAGEDCODE
// Function gets confuguration descriptor
PUSBD_INTERFACE_INFORMATION     CUSBDevice::activateInterface(PUSB_CONFIGURATION_DESCRIPTOR Configuration)
{
PURB Urb = NULL;
USHORT Size;
NTSTATUS Status = STATUS_INSUFFICIENT_RESOURCES;
USHORT j;

PUSBD_INTERFACE_LIST_ENTRY InterfaceList;
PUSB_INTERFACE_DESCRIPTOR InterfaceDescriptor = NULL;
PUSBD_INTERFACE_INFORMATION Interface = NULL;
PUSBD_INTERFACE_INFORMATION UsbInterface = NULL;
ULONG NumberOfInterfaces;
CIoPacket* IoPacket = NULL;

        TRACE("Activating USB device configuration %8.8lX, setting device interface...\n",Configuration);

        if(!Configuration) return NULL;
    // get this from the config descriptor
    NumberOfInterfaces = Configuration->bNumInterfaces;

    // We only support one interface!
        TRACE("\nNumber of interfaces at the configuration - %d \n",NumberOfInterfaces);
        
        // USBD_ParseConfigurationDescriptorEx searches a given configuration
        // descriptor and returns a pointer to an interface that matches the 
        //  given search criteria. 
        // We only support one interface on this device
        if(NumberOfInterfaces==1)
        {
                InterfaceDescriptor = 
                        USBD_ParseConfigurationDescriptorEx(
                                Configuration,
                                Configuration,
                                0, // intreface number, don't care
                                -1, // alt setting, don't care
                                -1, // class, don't care
                                -1, // subclass, don't care
                                -1);// protocol, don't care
        }
        else
        {
                if(NumberOfInterfaces>1)
                {
                        TRACE("Trying next to get interface descriptor for KEYBOARD READER...\n");
                        InterfaceDescriptor = 
                                USBD_ParseConfigurationDescriptorEx(
                                        Configuration,
                                        Configuration,
                                        1, // intreface number 1 for keyboard reader
                                        -1, // alt setting, don't care
                                        -1, // class, don't care
                                        -1, // subclass, don't care
                                        -1);// protocol, don't care
                }
        }

        if (!InterfaceDescriptor) 
        {
                TRACE("##### ERROR: Failed to get interface description...\n");
                return NULL;
        }
    
        InterfaceList = (PUSBD_INTERFACE_LIST_ENTRY)memory->allocate(NonPagedPool,sizeof(USBD_INTERFACE_LIST_ENTRY) * (NumberOfInterfaces+1));
        if(!InterfaceList)
        {
                TRACE("Failed to alloacte memory for the interfacelist...\n");
                return NULL;
        }

        // We support only one interface after current!
    InterfaceList->InterfaceDescriptor = InterfaceDescriptor;
    InterfaceList++; 
    InterfaceList->InterfaceDescriptor = NULL;
    InterfaceList--; 

        __try
        {
                //For now our device support only one interface.
                Urb = USBD_CreateConfigurationRequestEx(Configuration, InterfaceList);
                if(!Urb)        __leave;
   
                Interface = &Urb->UrbSelectConfiguration.Interface;
                TRACE("Pipe MaximumTransferSize set to 0x%x\n",m_MaximumTransferSize);

                for (ULONG i=0; i< Interface->NumberOfPipes; i++) 
                {
                        // perform any pipe initialization here
                        Interface->Pipes[i].MaximumTransferSize = m_MaximumTransferSize;
                        Interface->Pipes[i].PipeFlags = 0;
                }

                TRACE("Building select configuration request...\n");    
                Size = sizeof(struct _URB_SELECT_CONFIGURATION);
                UsbBuildSelectConfigurationRequest(Urb,Size, Configuration);
                
                IoPacket = new (NonPagedPool) CIoPacket(m_pLowerDeviceObject->StackSize);
                if(!ALLOCATED_OK(IoPacket)) __leave;
                IoPacket->setTimeout(getCommandTimeout());

                IoPacket->buildStack(getSystemObject(),IRP_MJ_INTERNAL_DEVICE_CONTROL, 0, IOCTL_INTERNAL_USB_SUBMIT_URB,Urb);
                Status = sendRequestToDeviceAndWait(IoPacket);
                if (!NT_SUCCESS(Status)) 
                {
                        TRACE("##### ERROR: Failed to Select configuration, ret 0x%x...\n",Status);
                        CLogger*   logger = kernel->getLogger();
                        if(logger) logger->logEvent(GRCLASS_BUS_DRIVER_FAILED_REQUEST,getSystemObject());
                        __leave;
                }

                // Save the configuration handle for this device
                // Well... It is not really nice to initialize it here, but...
                m_ConfigurationHandle = Urb->UrbSelectConfiguration.ConfigurationHandle;
                TRACE("Device Configuration handle 0x%x\n",m_ConfigurationHandle);    

                UsbInterface = (PUSBD_INTERFACE_INFORMATION)memory->allocate(NonPagedPool,Interface->Length);
                if (!UsbInterface) 
                {
                        TRACE(("##### ERROR: Failed to allocate memory for the UsbInterface\n"));
                        __leave;
                }
                // save a copy of the interface information returned
                memory->copy(UsbInterface, Interface, Interface->Length);
                
                TRACE("\nGemplus USB device interface:\n");    
                // Dump the interface to the debugger
                TRACE("---------\n");
                TRACE("NumberOfPipes 0x%x\n", UsbInterface->NumberOfPipes);
                TRACE("Length 0x%x\n", UsbInterface->Length);
                TRACE("Alt Setting 0x%x\n", UsbInterface->AlternateSetting);
                TRACE("Interface Number 0x%x\n", UsbInterface->InterfaceNumber);
                TRACE("Class, subclass, protocol 0x%x 0x%x 0x%x\n",
                                UsbInterface->Class,
                                UsbInterface->SubClass,
                                UsbInterface->Protocol);
                TRACE("---------\n");

                // Dump the pipe info
                for (j=0; j<Interface->NumberOfPipes; j++) 
                {
                PUSBD_PIPE_INFORMATION pipeInformation;
                        pipeInformation = &UsbInterface->Pipes[j];

                        TRACE("\nGemplus USB device pipe[%d] ",j);    
                        if(pipeInformation->PipeType==UsbdPipeTypeBulk)
                        { 
                                if(pipeInformation->EndpointAddress&0x80)
                                {
                                        TRACE(("(Bulk Response Pipe):\n"));
                                        m_ResponsePipe = pipeInformation->PipeHandle;
                                        TRACE("m_ResponsePipe 0x%x\n", m_ResponsePipe);
                                }
                                else
                                {
                                        TRACE("(Bulk Command pipe):\n");
                                        m_CommandPipe = pipeInformation->PipeHandle;
                                        TRACE("m_CommandPipe 0x%x\n", m_CommandPipe);
                                }
                        }
                        else
                        {
                                if(pipeInformation->PipeType==UsbdPipeTypeInterrupt)
                                {
                                        if(pipeInformation->EndpointAddress&0x80)
                                        {
                                                TRACE(("(Interrupt Response Pipe):\n"));
                                                m_InterruptPipe = pipeInformation->PipeHandle;
                                                TRACE("m_InterruptPipe 0x%x\n", m_InterruptPipe);
                                        }
                                        else
                                        {
                                                TRACE(("(Unexpected Interrupt OUT pipe):\n"));
                                                TRACE("Unexpected pipe 0x%x\n", pipeInformation);
                                        }
                                }
                                else
                                {
                                        TRACE("Unexpected pipe type 0x%x\n", pipeInformation);
                                }
                        }
                        TRACE("---------\n");
                        TRACE("PipeType 0x%x\n", pipeInformation->PipeType);
                        TRACE("EndpointAddress 0x%x\n", pipeInformation->EndpointAddress);
                        TRACE("MaxPacketSize 0x%x\n", pipeInformation->MaximumPacketSize);
                        TRACE("Interval 0x%x\n", pipeInformation->Interval);
                        TRACE("Handle 0x%x\n", pipeInformation->PipeHandle);
                        TRACE("MaximumTransferSize 0x%x\n", pipeInformation->MaximumTransferSize);
                }
                TRACE("---------\n");
                __leave;
        }
        __finally
        {
                if(Urb) memory->free(Urb);
                if(InterfaceList)       memory->free(InterfaceList);
                DISPOSE_OBJECT(IoPacket);
                if (!NT_SUCCESS(Status))
                {
                        if(UsbInterface) memory->free(UsbInterface);
                        UsbInterface = NULL;
                }
                else
                {
                        if(UsbInterface)        TRACE("*** Succeed to set UsbInterface ***\n");
                }
        }
    return UsbInterface; 
}

#pragma PAGEDCODE
// Function gets confuguration descriptor
NTSTATUS        CUSBDevice::disactivateInterface()
{
PURB Urb = NULL;
USHORT Size;
NTSTATUS Status = STATUS_SUCCESS;
CIoPacket* IoPacket;

        TRACE("Disactivating USB device interface...\n");
        Size = sizeof(struct _URB_SELECT_CONFIGURATION);
    Urb = (PURB)memory->allocate(NonPagedPool,Size);
        if(!Urb)
        {
                TRACE("##### ERROR: Failed to create disable configuration request...\n");
                return STATUS_INSUFFICIENT_RESOURCES;
        }

        //UsbBuildSelectConfigurationRequest(Urb,Size, NULL);
    (Urb)->UrbHeader.Function =  URB_FUNCTION_SELECT_CONFIGURATION;
    (Urb)->UrbHeader.Length = Size;
    (Urb)->UrbSelectConfiguration.ConfigurationDescriptor = NULL;
        
        __try
        {
                IoPacket = new (NonPagedPool) CIoPacket(m_pLowerDeviceObject->StackSize);
                if(!ALLOCATED_OK(IoPacket)) __leave;
                IoPacket->setTimeout(getCommandTimeout());

                IoPacket->buildStack(getSystemObject(),IRP_MJ_INTERNAL_DEVICE_CONTROL, 0, IOCTL_INTERNAL_USB_SUBMIT_URB,Urb);
                Status = sendRequestToDeviceAndWait(IoPacket);
                if (!NT_SUCCESS(Status)) 
                {
                        TRACE("##### ERROR: Failed to disable device interface..., ret %x...\n",Status);
                }
                __leave;
        }
        __finally
        {
                if(Urb) memory->free(Urb);
                DISPOSE_OBJECT(IoPacket);
                if (!NT_SUCCESS(Status))
                {
                        TRACE("*** Failed to disactivateInterface() %8.8lX ***\n",Status);
                }
                else
                {
                        TRACE("*** Succeed to disactivateInterface() ***\n");
                }
        }
    return Status;
}

#pragma PAGEDCODE
// Function resets specified pipe
NTSTATUS        CUSBDevice::resetPipe(IN USBD_PIPE_HANDLE Pipe)
{
PURB Urb = NULL;
NTSTATUS Status = STATUS_INSUFFICIENT_RESOURCES;
CIoPacket* IoPacket;

        TRACE("Resetting USB device pipe %8.8lX...\n",Pipe);
    Urb = (PURB)memory->allocate(NonPagedPool,sizeof(struct _URB_PIPE_REQUEST));
        if (!Urb) 
        {
                TRACE("#### ERROR: Failed to allocate Urb at Pipe reset...\n");
                return STATUS_INSUFFICIENT_RESOURCES; 
        }

    Urb->UrbHeader.Length = sizeof (struct _URB_PIPE_REQUEST);
    Urb->UrbHeader.Function = URB_FUNCTION_RESET_PIPE;
    Urb->UrbPipeRequest.PipeHandle = Pipe;

        __try
        {
                IoPacket = new (NonPagedPool) CIoPacket(m_pLowerDeviceObject->StackSize);
                if(!ALLOCATED_OK(IoPacket)) __leave;
                IoPacket->setTimeout(getCommandTimeout());

                IoPacket->buildStack(getSystemObject(),IRP_MJ_INTERNAL_DEVICE_CONTROL, 0, IOCTL_INTERNAL_USB_SUBMIT_URB,Urb);
                Status = sendRequestToDeviceAndWait(IoPacket);
                if (!NT_SUCCESS(Status)) 
                {
                        TRACE("##### ERROR: Failed to reset Pipe, ret %x...\n",Status);
                }
                __leave;
        }
        __finally
        {
                if(Urb) memory->free(Urb);
                DISPOSE_OBJECT(IoPacket);
                if (!NT_SUCCESS(Status))
                {
                        TRACE("*** Failed to resetPipe() %8.8lX ***\n",Status);
                }
                else
                {
                        TRACE("*** Succeed to resetPipe() ***\n");
                }
        }
    return Status;
}

#pragma PAGEDCODE
// Function resets specified pipe
NTSTATUS        CUSBDevice::resetDevice()
{
PURB Urb = NULL;
NTSTATUS Status = STATUS_INSUFFICIENT_RESOURCES;
CIoPacket* IoPacket;

        TRACE("Resetting USB device...\n");
    Urb = (PURB)memory->allocate(NonPagedPool,sizeof(struct _URB_PIPE_REQUEST));
        if (!Urb) 
        {
                TRACE("#### ERROR: Failed to allocate Urb at Device reset...\n");
                return STATUS_INSUFFICIENT_RESOURCES; 
        }

        __try
        {
                IoPacket = new (NonPagedPool) CIoPacket(m_pLowerDeviceObject->StackSize);
                if(!ALLOCATED_OK(IoPacket)) __leave;
                IoPacket->setTimeout(getCommandTimeout());

                IoPacket->buildStack(getSystemObject(),IRP_MJ_INTERNAL_DEVICE_CONTROL, 0, IOCTL_INTERNAL_USB_RESET_PORT,Urb);
                Status = sendRequestToDeviceAndWait(IoPacket);
                if (!NT_SUCCESS(Status)) 
                {
                        TRACE("##### ERROR: Failed to reset Device, ret %x...\n",Status);
                }
                __leave;
        }
        __finally
        {
                if(Urb) memory->free(Urb);
                DISPOSE_OBJECT(IoPacket);
                if (!NT_SUCCESS(Status))
                {
                        TRACE("*** Failed to resetPipe() %8.8lX ***\n",Status);
                }
                else
                {
                        TRACE("*** Succeed to resetPipe() ***\n");
                }
        }
    return Status;
}


//      Called as part of sudden device removal handling.
//  Cancels any pending transfers for all open pipes. 
//      If any pipes are still open, call USBD with URB_FUNCTION_ABORT_PIPE
//      Also marks the pipe 'closed' in our saved  configuration info.
NTSTATUS        CUSBDevice::abortPipes()
{
PURB Urb = NULL;
NTSTATUS Status = STATUS_INSUFFICIENT_RESOURCES;
PUSBD_PIPE_INFORMATION Pipe;
CIoPacket* IoPacket;
        
        TRACE("Aborting all USB device pipes...\n");
    Urb = (PURB)memory->allocate(NonPagedPool,sizeof(struct _URB_PIPE_REQUEST));
        if (!Urb) 
        {
                TRACE("#### ERROR: Failed to allocate Urb at Pipe reset...\n");
                return STATUS_INSUFFICIENT_RESOURCES; 
        }

    for (USHORT i=0; i<m_Interface->NumberOfPipes; i++) 
        {
                IoPacket = new (NonPagedPool) CIoPacket(m_pLowerDeviceObject->StackSize);
                if(!ALLOCATED_OK(IoPacket)) break;
                IoPacket->setTimeout(getCommandTimeout());
        
                Pipe =  &m_Interface->Pipes[i]; // PUSBD_PIPE_INFORMATION  PipeInfo;

                if ( Pipe->PipeFlags ) 
                { // we set this if open, clear if closed
                        Urb->UrbHeader.Length = sizeof (struct _URB_PIPE_REQUEST);
                        Urb->UrbHeader.Function = URB_FUNCTION_ABORT_PIPE;
                        Urb->UrbPipeRequest.PipeHandle = Pipe->PipeHandle;

                        IoPacket->buildStack(getSystemObject(),IRP_MJ_INTERNAL_DEVICE_CONTROL, 0, IOCTL_INTERNAL_USB_SUBMIT_URB,Urb);
                        Status = sendRequestToDeviceAndWait(IoPacket);
                        if (!NT_SUCCESS(Status)) 
                        {
                                TRACE("##### ERROR: Failed to abort Pipe %d\n",i);
                        }
                        Pipe->PipeFlags = FALSE; // mark the pipe 'closed'
                }
                DISPOSE_OBJECT(IoPacket);
        }

        if(Urb) memory->free(Urb);
        TRACE("**** Interface' pipes closed ****\n");
    return STATUS_SUCCESS;;
}

NTSTATUS        CUSBDevice::resetAllPipes()
{
PURB Urb = NULL;
NTSTATUS Status;
PUSBD_PIPE_INFORMATION Pipe;
CIoPacket* IoPacket;

        TRACE("Resetting all USB device pipes...\n");
    Urb = (PURB)memory->allocate(NonPagedPool,sizeof(struct _URB_PIPE_REQUEST));
        if (!Urb) 
        {
                TRACE("#### ERROR: Failed to allocate Urb at Pipe reset...\n");
                return STATUS_INSUFFICIENT_RESOURCES; 
        }

    for (USHORT i=0; i<m_Interface->NumberOfPipes; i++) 
        {
                IoPacket = new (NonPagedPool) CIoPacket(m_pLowerDeviceObject->StackSize);
                if(!ALLOCATED_OK(IoPacket)) break;
                IoPacket->setTimeout(getCommandTimeout());

                Pipe =  &m_Interface->Pipes[i]; // PUSBD_PIPE_INFORMATION  PipeInfo;
                if ( Pipe->PipeFlags ) 
                { // we set this if open, clear if closed
                        Urb->UrbHeader.Length = sizeof (struct _URB_PIPE_REQUEST);
                        Urb->UrbHeader.Function = URB_FUNCTION_RESET_PIPE;
                        Urb->UrbPipeRequest.PipeHandle = Pipe->PipeHandle;

                        IoPacket->buildStack(getSystemObject(),IRP_MJ_INTERNAL_DEVICE_CONTROL, 0, IOCTL_INTERNAL_USB_SUBMIT_URB,Urb);
                        Status = sendRequestToDeviceAndWait(IoPacket);
                        if (!NT_SUCCESS(Status)) 
                        {
                                TRACE("##### ERROR: Failed to abort Pipe %d\n",i);
                        }
                        Pipe->PipeFlags = FALSE; // mark the pipe 'closed'
                }
                DISPOSE_OBJECT(IoPacket);
        }

        if(Urb) memory->free(Urb);
        TRACE(("**** Interface pipes were resetted ****\n"));
    return STATUS_SUCCESS;;
}

// Overwrite base class virtual functions
//Handle IRP_MJ_DEVICE_CONTROL request
NTSTATUS        CUSBDevice::deviceControl(IN PIRP Irp)
{
        if (!NT_SUCCESS(acquireRemoveLock()))   return completeDeviceRequest(Irp, STATUS_DELETE_PENDING, 0);
PIO_STACK_LOCATION stack = irp->getCurrentStackLocation(Irp);
ULONG code      = stack->Parameters.DeviceIoControl.IoControlCode;
//ULONG outlength = stack->Parameters.DeviceIoControl.OutputBufferLength;
NTSTATUS status = STATUS_SUCCESS;
ULONG info = 0;

        TRACE("IRP_MJ_DEVICE_CONTROL\n");
        //switch (code)
        {                                               // process control operation
        //default:
                TRACE("INVALID_DEVICE_REQUEST\n");
                status = STATUS_INVALID_DEVICE_REQUEST;
        }

        releaseRemoveLock();

        return completeDeviceRequest(Irp, status, info);
}

NTSTATUS        CUSBDevice::read(IN PIRP Irp)
{
NTSTATUS status = STATUS_SUCCESS;
ULONG info = 0;
CIoPacket* IoPacket;
        
        if (!NT_SUCCESS(acquireRemoveLock()))   return completeDeviceRequest(Irp, STATUS_DELETE_PENDING, 0);
        
        TRACE("---- Read request ----\n");

        if(!m_ResponsePipe)
        {
                TRACE("#### ERROR: Response Pipe is not ready yet!...\n");
                releaseRemoveLock();
                return completeDeviceRequest(Irp, STATUS_INVALID_DEVICE_REQUEST, 0);
        }

        if(!NT_SUCCESS(status = waitForIdleAndBlock()))
        {
                releaseRemoveLock();
                return completeDeviceRequest(Irp, STATUS_DELETE_PENDING, 0);
        }

        if(Response_ErrorNum)
        {       
                NTSTATUS res_status = resetPipe(m_ResponsePipe);
                if(NT_SUCCESS(res_status))      Response_ErrorNum = 0;
        }

        IoPacket = new (NonPagedPool) CIoPacket(Irp);
        if(!ALLOCATED_OK(IoPacket))
        {
                DISPOSE_OBJECT(IoPacket);
                setIdle();
                releaseRemoveLock();
                return completeDeviceRequest(Irp, STATUS_INSUFFICIENT_RESOURCES, 0);
        }

        status = readSynchronously(IoPacket,m_ResponsePipe);

        TRACE("---- Read completed ----\n");
        status = completeDeviceRequest(IoPacket->getIrpHandle(), status, IoPacket->getInformation());

        DISPOSE_OBJECT(IoPacket);

        setIdle();
        releaseRemoveLock();
        return status;
}

NTSTATUS        CUSBDevice::write(IN PIRP Irp)
{
NTSTATUS status = STATUS_SUCCESS;
ULONG info = 0;
CIoPacket* IoPacket;
        
        if(!Irp) return STATUS_INVALID_PARAMETER;
        if (!NT_SUCCESS(acquireRemoveLock()))   return completeDeviceRequest(Irp, STATUS_DELETE_PENDING, 0);
        
        TRACE("---- Write request ----\n");

        if(!m_CommandPipe)
        {
                TRACE("#### ERROR: Command Pipe is not ready yet!...\n");
                releaseRemoveLock();
                return completeDeviceRequest(Irp, STATUS_INVALID_DEVICE_REQUEST, 0);
        }

        if(!NT_SUCCESS(status = waitForIdleAndBlock()))
        {
                releaseRemoveLock();
                return completeDeviceRequest(Irp, STATUS_DELETE_PENDING, 0);
        }
        if(Command_ErrorNum)
        {       
                NTSTATUS res_status = resetPipe(m_CommandPipe);
                if(NT_SUCCESS(res_status))      Command_ErrorNum = 0;
        }

        IoPacket = new (NonPagedPool) CIoPacket(Irp);
        if(!ALLOCATED_OK(IoPacket))
        {
                DISPOSE_OBJECT(IoPacket);
                releaseRemoveLock();
                return completeDeviceRequest(Irp, STATUS_INSUFFICIENT_RESOURCES, 0);
        }
        
    status = writeSynchronously(IoPacket,m_CommandPipe);
  
        releaseRemoveLock();
        TRACE("---- Write completed ----\n");
        status = completeDeviceRequest(IoPacket->getIrpHandle(), status, IoPacket->getInformation());

        DISPOSE_OBJECT(IoPacket);

    setIdle();
        releaseRemoveLock();
        return status;
}


NTSTATUS        CUSBDevice::sendRequestToDevice(CIoPacket* IoPacket,PIO_COMPLETION_ROUTINE Routine)
{
        if(!IoPacket) return STATUS_INVALID_PARAMETER;
        IoPacket->copyStackToNext();
        if(Routine) IoPacket->setCompletion(Routine);
        else        IoPacket->setDefaultCompletionFunction();
        return system->callDriver(getLowerDriver(),IoPacket->getIrpHandle());
};

// Send request to low level driver and wait for reply
// Current IRP will not be completed, so we can process it and
// complete later. 
// See also description of send() function.
NTSTATUS        CUSBDevice::sendRequestToDeviceAndWait(CIoPacket* IoPacket)
{ // Send request to low level and wait for a reply
NTSTATUS status;
        TRACE("sendAndWait...\n");
        if(!IoPacket) return STATUS_INVALID_PARAMETER;
        IoPacket->setStackDefaults();
        status = system->callDriver(getLowerDriver(),IoPacket->getIrpHandle());
        if(status == STATUS_PENDING)
        {
                TRACE("Waiting for the bus driver to complete...\n");
                ASSERT(system->getCurrentIrql()<=DISPATCH_LEVEL);
                status = IoPacket->waitForCompletion();
                TRACE("Request completed with status %x\n",status);
        }
        return status;
};


NTSTATUS   CUSBDevice::send(CIoPacket* packet)
{
NTSTATUS status;
        if(!packet) return STATUS_INVALID_PARAMETER;
        __try
        {
                if(packet->getMajorIOCtl()==IRP_MJ_READ)
                {
                        if(!m_ResponsePipe)
                        {
                                TRACE("#### ERROR: Response Pipe is not ready yet!...\n");
                                status = STATUS_INVALID_DEVICE_REQUEST;
                                __leave;
                        }
                        status = readSynchronously(packet,m_ResponsePipe);
                }
                else
                {
                        if(!m_CommandPipe)
                        {
                                TRACE("#### ERROR: Command Pipe is not ready yet!...\n");
                                status = STATUS_INVALID_DEVICE_REQUEST;
                                __leave;
                        }
                        status = writeSynchronously(packet,m_CommandPipe);
                }
                __leave;
        }
        __finally
        {
        }
        return status;
};

NTSTATUS   CUSBDevice::sendAndWait(CIoPacket* packet)
{
NTSTATUS status = STATUS_SUCCESS;
        if(!packet) return STATUS_INVALID_PARAMETER;
        __try
        {               
                if(packet->getMajorIOCtl()==IRP_MJ_READ)
                {
                        TRACE("---- Packet Read request ----\n");
                        if(!m_ResponsePipe)
                        {
                                TRACE("#### ERROR: Response Pipe is not ready yet!...\n");
                                status = STATUS_INVALID_DEVICE_REQUEST;
                                __leave;
                        }

                        status = readSynchronously(packet,m_ResponsePipe);
                        TRACE("---- Packet Read completed ----\n");
                }
                else
                {
                        TRACE("---- Packet Write request ----\n");
                        if(!m_CommandPipe)
                        {
                                TRACE("#### ERROR: Command Pipe is not ready yet!...\n");
                                status = STATUS_INVALID_DEVICE_REQUEST;
                                __leave;
                        }

                        status = writeSynchronously(packet,m_CommandPipe);

                        TRACE("---- Packet Write completed ----\n");
                        if(!NT_SUCCESS(status))
                        {
                                TRACE("writeSynchronously reported error %x\n", status);
                        }
                }
                __leave;
        }
        __finally
        {
        }
        return status;
};

NTSTATUS        CUSBDevice::readSynchronously(CIoPacket* Irp,IN USBD_PIPE_HANDLE Pipe)
{
NTSTATUS ntStatus = STATUS_SUCCESS;
PURB Urb = NULL;
NTSTATUS Status;
        if(!Irp) return STATUS_INVALID_PARAMETER;
        
        if(Pipe != m_ResponsePipe && Pipe != m_InterruptPipe)
        {
                TRACE("##### ERROR: Invalid device Pipe requested!...\n");
                return STATUS_INVALID_DEVICE_REQUEST;
        }
        Urb = buildBusTransferRequest(Irp,RESPONSE_REQUEST);
        if (!Urb) 
        {
                TRACE("#### ERROR: Failed to allocate Urb at Pipe read...\n");
                return STATUS_INSUFFICIENT_RESOURCES; 
        }
        Irp->buildStack(getSystemObject(),IRP_MJ_INTERNAL_DEVICE_CONTROL, 0, IOCTL_INTERNAL_USB_SUBMIT_URB,Urb);
        Status = sendRequestToDeviceAndWait(Irp);
        if (!NT_SUCCESS(Status)) 
        {
                TRACE("##### ERROR: Bus driver reported error 0x%x\n",Status);
                Response_ErrorNum++;
                Irp->setInformation(0);
        }
        else
        {

                Irp->setInformation(Urb->UrbBulkOrInterruptTransfer.TransferBufferLength);
                finishBusTransferRequest(Irp,RESPONSE_REQUEST);
        }

        USBD_STATUS urb_status = URB_STATUS(Urb);
        TRACE("URB reports status %8.8lX\n",urb_status);

        memory->free(Urb);
        return Status;
}

NTSTATUS        CUSBDevice::writeSynchronously(CIoPacket* Irp,IN USBD_PIPE_HANDLE Pipe)
{
NTSTATUS ntStatus = STATUS_SUCCESS;
PURB Urb = NULL;
NTSTATUS Status;
        if(!Irp) return STATUS_INVALID_PARAMETER;
        if(Pipe != m_CommandPipe)
        {
                TRACE("##### ERROR: Invalid device Pipe requested!...\n");
                return STATUS_INVALID_DEVICE_REQUEST;
        }

        Urb = buildBusTransferRequest(Irp,COMMAND_REQUEST);
        if (!Urb) 
        {
                TRACE("#### ERROR: Failed to allocate Urb at Pipe read...\n");
                return STATUS_INSUFFICIENT_RESOURCES; 
        }
        Irp->buildStack(getSystemObject(),IRP_MJ_INTERNAL_DEVICE_CONTROL, 0, IOCTL_INTERNAL_USB_SUBMIT_URB,Urb);
        Status = sendRequestToDeviceAndWait(Irp);
        if (!NT_SUCCESS(Status)) 
        {
                TRACE("##### ERROR: Bus driver reported error %8.8lX\n",Status);
                Command_ErrorNum++;
        }
        else
        {
                finishBusTransferRequest(Irp,COMMAND_REQUEST);
        }

        USBD_STATUS urb_status = URB_STATUS(Urb);
        TRACE("                 URB reports status %8.8lX\n",urb_status);

        
        Irp->setInformation(0);
        memory->free(Urb);
        return Status;
}


NTSTATUS   CUSBDevice::writeAndWait(PUCHAR pRequest,ULONG RequestLength,PUCHAR pReply,ULONG* pReplyLength)
{
NTSTATUS status;
CIoPacket* IoPacket;
        if(!pRequest || !RequestLength || !pReply || !pReplyLength) return STATUS_INVALID_PARAMETER;

        if(Response_ErrorNum || Command_ErrorNum)
        {       
                TRACE("======= RESETTING ERROR CONDITIONS! =========\n");
                NTSTATUS res_status = resetDevice();
                if(NT_SUCCESS(res_status))
                {
                        Command_ErrorNum = 0;
                        Response_ErrorNum = 0;
                }
                else
                {
                        *pReplyLength = 0;
                        TRACE("======= FAILED TO RESET DEVICE! =========\n");
                        return STATUS_INVALID_DEVICE_STATE;
                }
                /*
                NTSTATUS res_status = resetPipe(m_ResponsePipe);
                if(NT_SUCCESS(res_status))      Response_ErrorNum = 0;
                else
                {
                        *pReplyLength = 0;
                        TRACE("======= FAILED TO RESET RESPONSE PIPE! =========\n");
                        resetDevice();

                        //return STATUS_INVALID_DEVICE_STATE;
                }

                res_status = resetPipe(m_CommandPipe);
                if(NT_SUCCESS(res_status))      Command_ErrorNum = 0;
                else
                {
                        *pReplyLength = 0;
                        TRACE("======= FAILED TO RESET COMMAND PIPE! =========\n");
                        //return STATUS_INVALID_DEVICE_STATE;
                        res_status = resetDevice();
                        if(NT_SUCCESS(res_status))      Command_ErrorNum = 0;
                        else
                        {
                                *pReplyLength = 0;
                                TRACE("======= FAILED TO RESET DEVICE! =========\n");
                                return STATUS_INVALID_DEVICE_STATE;
                        }
                }
                */
        }

        IoPacket = new (NonPagedPool) CIoPacket(getLowerDriver()->StackSize);
        if(!ALLOCATED_OK(IoPacket))
        {
                DISPOSE_OBJECT(IoPacket);
                return STATUS_INSUFFICIENT_RESOURCES;
        }

        IoPacket->setTimeout(getCommandTimeout());

        TRACE("IoPacket with device %x\n",getSystemObject());
        IoPacket->buildStack(getSystemObject(),IRP_MJ_WRITE);
        IoPacket->setWriteLength(RequestLength);
        IoPacket->copyBuffer(pRequest,RequestLength);

        TRACE("                 USB sendAndWait()...\n");
        status = sendAndWait(IoPacket);
        TRACE("                 USB writeAndWait finished: %x\n",status);
        if(!NT_SUCCESS(status))
        {
                *pReplyLength = 0;
                IoPacket->dispose();
                return status;
        }

        // Ignore bus driver reply...
        DISPOSE_OBJECT(IoPacket);

        TRACE(" **** Current WTR %d\n",get_WTR_Delay());
        DELAY(get_WTR_Delay());

        IoPacket = new (NonPagedPool) CIoPacket(getLowerDriver()->StackSize);
        if(!ALLOCATED_OK(IoPacket))
        {
                DISPOSE_OBJECT(IoPacket);
                return STATUS_INSUFFICIENT_RESOURCES;
        }

        IoPacket->setTimeout(getCommandTimeout());
        IoPacket->buildStack(getSystemObject(),IRP_MJ_READ);
        IoPacket->setReadLength(RequestLength);
        IoPacket->copyBuffer(pRequest,RequestLength);

        TRACE("                 USB sendAndWait()...\n");
        status = sendAndWait(IoPacket);
        TRACE("                 USB sendAndWait finished: %x\n",status);
        if(!NT_SUCCESS(status))
        {
                *pReplyLength = 0;
                IoPacket->dispose();
                return status;
        }

        *pReplyLength = (ULONG)IoPacket->getInformation();
        IoPacket->getSystemReply(pReply,*pReplyLength);

        //TRACE_BUFFER(pReply,*pReplyLength);
        DISPOSE_OBJECT(IoPacket);
        return status;
};

NTSTATUS   CUSBDevice::readAndWait(PUCHAR pRequest,ULONG RequestLength,PUCHAR pReply,ULONG* pReplyLength)
{
CIoPacket* IoPacket;
        if(!pRequest || !RequestLength || !pReply || !pReplyLength) return STATUS_INVALID_PARAMETER;
        if(Response_ErrorNum || Command_ErrorNum)
        {       
                TRACE("======= RESETTING ERROR CONDITIONS! =========\n");
                NTSTATUS res_status = resetDevice();
                if(NT_SUCCESS(res_status))
                {
                        Command_ErrorNum = 0;
                        Response_ErrorNum = 0;
                }
                else
                {
                        *pReplyLength = 0;
                        TRACE("======= FAILED TO RESET DEVICE! =========\n");
                        return STATUS_INVALID_DEVICE_STATE;
                }

                /*TRACE("======= RESETTING ERROR CONDITIONS AT PIPES! =========\n");
                NTSTATUS res_status = resetPipe(m_ResponsePipe);
                if(NT_SUCCESS(res_status))      Response_ErrorNum = 0;
                else
                {
                        *pReplyLength = 0;
                        TRACE("======= FAILED TO RESET RESPONSE PIPE! =========\n");
                        return STATUS_INVALID_DEVICE_STATE;
                }

                res_status = resetPipe(m_CommandPipe);
                if(NT_SUCCESS(res_status))      Command_ErrorNum = 0;
                else
                {
                        *pReplyLength = 0;
                        TRACE("======= FAILED TO RESET COMMAND PIPE! =========\n");
                        return STATUS_INVALID_DEVICE_STATE;
                }
                */
        }

        IoPacket = new (NonPagedPool) CIoPacket(getLowerDriver()->StackSize);
        if(!ALLOCATED_OK(IoPacket))
        {
                DISPOSE_OBJECT(IoPacket);
                return STATUS_INSUFFICIENT_RESOURCES;
        }

        IoPacket->setTimeout(getCommandTimeout());
        IoPacket->buildStack(getSystemObject(),IRP_MJ_READ);
        IoPacket->setReadLength(RequestLength);
        IoPacket->copyBuffer(pRequest,RequestLength);

        TRACE("WDM sendAndWait()...\n");
        NTSTATUS status = sendAndWait(IoPacket);
        TRACE("WDM sendAndWait finished: %x\n",status);
        if(!NT_SUCCESS(status))
        {
                *pReplyLength = 0;
                IoPacket->dispose();
                return status;
        }

        *pReplyLength = (ULONG)IoPacket->getInformation();
        IoPacket->getSystemReply(pReply,*pReplyLength);

        //TRACE_BUFFER(pReply,*pReplyLength);
        DISPOSE_OBJECT(IoPacket);
        return status;
};

// Handle IRP_MJ_POWER request
// This routine uses the IRP's minor function code to dispatch a handler
// function (such as HandleSetPower for IRP_MN_SET_POWER). It calls DefaultPowerHandler
// for any function we don't specifically need to handle.
NTSTATUS CUSBDevice::powerRequest(IN PIRP Irp)
{
        if(!Irp) return STATUS_INVALID_PARAMETER;
        if (!NT_SUCCESS(acquireRemoveLock()))
        {
                power->startNextPowerIrp(Irp);  // must be done while we own the IRP
                return completeDeviceRequest(Irp, STATUS_DELETE_PENDING, 0);
        }

        PIO_STACK_LOCATION stack = irp->getCurrentStackLocation(Irp);
        ASSERT(stack->MajorFunction == IRP_MJ_POWER);
        ULONG fcn = stack->MinorFunction;
        NTSTATUS status;
        if (fcn >= arraysize(Powerfcntab))
        {       // unknown function
                status = power_Default(Irp);
                releaseRemoveLock();
                return status;
        }

#ifdef DEBUG
        if (fcn == IRP_MN_SET_POWER || fcn == IRP_MN_QUERY_POWER)
                {
                ULONG context = stack->Parameters.Power.SystemContext;
                POWER_STATE_TYPE type = stack->Parameters.Power.Type;


                        TRACE("\n(%s)\nSystemContext %X, ", Powerfcnname[fcn], context);
                        if (type==SystemPowerState)
                        {
                                TRACE("SYSTEM POWER STATE = %s\n", Powersysstate[stack->Parameters.Power.State.SystemState]);
                        }
                        else
                        {
                                TRACE("DEVICE POWER STATE = %s\n", Powerdevstate[stack->Parameters.Power.State.DeviceState]);
                        }
                }
        else
                TRACE("Request (%s)\n", Powerfcnname[fcn]);

#endif // DEBUG

        status = callPowerHandler(fcn,Irp);
        releaseRemoveLock();
        return status;
}

VOID    CUSBDevice::activatePowerHandler(LONG HandlerID)
{
        if (HandlerID >= arraysize(Powerfcntab)) return;
        Powerfcntab[HandlerID] = TRUE;
}

VOID    CUSBDevice::disActivatePowerHandler(LONG HandlerID)
{
        if (HandlerID >= arraysize(Powerfcntab)) return;
        Powerfcntab[HandlerID] = FALSE;
}

NTSTATUS        CUSBDevice::callPowerHandler(LONG HandlerID,IN PIRP Irp)
{
        if(!Powerfcntab[HandlerID]) // If Handler is not registered...
                return power_Default(Irp);
        // Call registered Power Handler...
        // This is virtual function...
        switch(HandlerID)
        {
        case IRP_MN_WAIT_WAKE:          return power_HandleWaitWake(Irp);
                break;
        case IRP_MN_POWER_SEQUENCE:     return power_HandleSequencePower(Irp);
                break;
        case IRP_MN_SET_POWER:          return power_HandleSetPower(Irp);
                break;
        case IRP_MN_QUERY_POWER:        return power_HandleQueryPower(Irp);
                break;
        }
        return power_Default(Irp);
}

#pragma PAGEDCODE
NTSTATUS CUSBDevice::power_HandleSetPower(IN PIRP Irp)
{
PIO_STACK_LOCATION irpStack;
NTSTATUS status = STATUS_SUCCESS;
BOOLEAN fGoingToD0 = FALSE;
POWER_STATE sysPowerState, desiredDevicePowerState;

        if(!Irp) return STATUS_INVALID_PARAMETER;

    irpStack = irp->getCurrentStackLocation (Irp);
        switch (irpStack->Parameters.Power.Type) 
        {
                case SystemPowerState:
                        // Get input system power state
                        sysPowerState.SystemState = irpStack->Parameters.Power.State.SystemState;

#ifdef DEBUG
                        TRACE("Set Power with type SystemPowerState = %s\n",Powersysstate[sysPowerState.SystemState]);
#endif
                        // If system is in working state always set our device to D0
                        //  regardless of the wait state or system-to-device state power map
                        if ( sysPowerState.SystemState == PowerSystemWorking) 
                        {
                                desiredDevicePowerState.DeviceState = PowerDeviceD0;
                                TRACE("PowerSystemWorking, device will be set to D0, state map is not used\n");
                        } 
                        else 
                        {
                                 // set to corresponding system state if IRP_MN_WAIT_WAKE pending
                                if (isEnabledForWakeup()) 
                                {   // got a WAIT_WAKE IRP pending?
                                        // Find the device power state equivalent to the given system state.
                                        // We get this info from the DEVICE_CAPABILITIES struct in our device
                                        // extension (initialized in BulkUsb_PnPAddDevice() )
                                        desiredDevicePowerState.DeviceState = m_DeviceCapabilities.DeviceState[sysPowerState.SystemState];
                                        TRACE("IRP_MN_WAIT_WAKE pending, will use state map\n");
                                } 
                                else 
                                {  
                                        // if no wait pending and the system's not in working state, just turn off
                                        desiredDevicePowerState.DeviceState = PowerDeviceD3;
                                        TRACE("Not EnabledForWakeup and the system's not in the working state,\n  settting PowerDeviceD3(off)\n");
                                }
                        }
                        // We've determined the desired device state; are we already in this state?

#ifdef DEBUG
                        TRACE("Set Power, desiredDevicePowerState = %s\n",
                                Powerdevstate[desiredDevicePowerState.DeviceState]);
#endif

                        if (desiredDevicePowerState.DeviceState != m_CurrentDevicePowerState) 
                        {
                                acquireRemoveLock();// Callback will release the lock
                                // No, request that we be put into this state
                                // by requesting a new Power Irp from the Pnp manager
                                registerPowerIrp(Irp);
                                IoMarkIrpPending(Irp);
                                status = power->requestPowerIrp(getSystemObject(),
                                                                                   IRP_MN_SET_POWER,
                                                                                   desiredDevicePowerState,
                                                                                   // completion routine will pass the Irp down to the PDO
                                                                                   (PREQUEST_POWER_COMPLETE)onPowerRequestCompletion, 
                                                                                   this, NULL);
                        } 
                        else 
                        {   // Yes, just pass it on to PDO (Physical Device Object)
                                irp->copyCurrentStackLocationToNext(Irp);
                                power->startNextPowerIrp(Irp);
                                status = power->callPowerDriver(getLowerDriver(),Irp);
                        }
                        break;
                case DevicePowerState:
#ifdef DEBUG
                        TRACE("Set DevicePowerState %s\n",
                                Powerdevstate[irpStack->Parameters.Power.State.DeviceState]);
#endif
                        // For requests to D1, D2, or D3 ( sleep or off states ),
                        // sets deviceExtension->CurrentDevicePowerState to DeviceState immediately.
                        // This enables any code checking state to consider us as sleeping or off
                        // already, as this will imminently become our state.

                        // For requests to DeviceState D0 ( fully on ), sets fGoingToD0 flag TRUE
                        // to flag that we must set a completion routine and update
                        // deviceExtension->CurrentDevicePowerState there.
                        // In the case of powering up to fully on, we really want to make sure
                        // the process is completed before updating our CurrentDevicePowerState,
                        // so no IO will be attempted or accepted before we're really ready.

                        fGoingToD0 = setDevicePowerState(irpStack->Parameters.Power.State.DeviceState); // returns TRUE for D0
                        if (fGoingToD0) 
                        {
                                acquireRemoveLock();// Callback will release the lock
                                TRACE("Set PowerIrp Completion Routine, fGoingToD0 =%d\n", fGoingToD0);
                                
                                irp->copyCurrentStackLocationToNext(Irp);
                                irp->setCompletionRoutine(Irp,
                                           onPowerIrpComplete,
                                           // Always pass FDO to completion routine as its Context;
                                           // This is because the DriverObject passed by the system to the routine
                                           // is the Physical Device Object ( PDO ) not the Functional Device Object ( FDO )
                                           this,
                                           TRUE,            // invoke on success
                                           TRUE,            // invoke on error
                                           TRUE);           // invoke on cancellation of the Irp
                                // Completion routine will set our state and start next power Irp
                        }
                        else
                        {
                                // D3 device state
                                //Device reduces power, so do specific for device processing...
                                onSystemPowerDown();

                                // Report our state to power manager
                                desiredDevicePowerState.DeviceState = PowerDeviceD3;
                                power->declarePowerState(getSystemObject(),DevicePowerState,desiredDevicePowerState);
                                irp->copyCurrentStackLocationToNext(Irp);
                                power->startNextPowerIrp(Irp);
                        }

                        status = power->callPowerDriver(getLowerDriver(),Irp);
                        break;
        } /* case irpStack->Parameters.Power.Type */

        return status;
}

#pragma PAGEDCODE
VOID    CUSBDevice::onSystemPowerDown()
{
        return;
}

#pragma PAGEDCODE
VOID    CUSBDevice::onSystemPowerUp()
{
        return;
}

#pragma PAGEDCODE
BOOLEAN CUSBDevice::setDevicePowerState(IN DEVICE_POWER_STATE DeviceState)
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    BOOLEAN fRes = FALSE;
    switch (DeviceState) 
        {
    case PowerDeviceD3:
            // Device will be going OFF, 
                // TODO: add any needed device-dependent code to save state here.
                //  ( We have nothing to do in this sample )
        TRACE("SetDevicePowerState() PowerDeviceD3 (OFF)\n");
        setCurrentDevicePowerState(DeviceState);
        break;
    case PowerDeviceD1:
    case PowerDeviceD2:
        // power states D1,D2 translate to USB suspend
#ifdef DEBUG
        TRACE("SetDevicePowerState()  %s\n",Powerdevstate[DeviceState]);
#endif
        setCurrentDevicePowerState(DeviceState);
        break;
    case PowerDeviceD0:
        TRACE("Set Device Power State to PowerDeviceD0(ON)\n");
        // We'll need to finish the rest in the completion routine;
        // signal caller we're going to D0 and will need to set a completion routine
        fRes = TRUE;
        // Caller will pass on to PDO ( Physical Device object )
        break;
    default:
        TRACE(" Bogus DeviceState = %x\n", DeviceState);
    }
    return fRes;
}


/*++

Routine Description:

        This is the completion routine set in a call to PoRequestPowerIrp()
        that was made in ProcessPowerIrp() in response to receiving
    an IRP_MN_SET_POWER of type 'SystemPowerState' when the device was
        not in a compatible device power state. In this case, a pointer to
        the IRP_MN_SET_POWER Irp is saved into the FDO device extension 
        (deviceExtension->PowerIrp), and then a call must be
        made to PoRequestPowerIrp() to put the device into a proper power state,
        and this routine is set as the completion routine.

    We decrement our pending io count and pass the saved IRP_MN_SET_POWER Irp
        on to the next driver

Arguments:

    DeviceObject - Pointer to the device object for the class device.
        Note that we must get our own device object from the Context

    Context - Driver defined context, in this case our own functional device object ( FDO )

Return Value:

    The function value is the final status from the operation.

--*/
#pragma LOCKEDCODE
NTSTATUS onPowerRequestCompletion(
    IN PDEVICE_OBJECT       DeviceObject,
    IN UCHAR                MinorFunction,
    IN POWER_STATE          PowerState,
    IN PVOID                Context,
    IN PIO_STATUS_BLOCK     IoStatus
    )
{
    PIRP Irp;
    NTSTATUS status;

        if(!Context) return STATUS_INVALID_PARAMETER;

        CUSBReader* device = (CUSBReader*) Context;
        
        // Get the Irp we saved for later processing
        // when we decided to request the Power Irp that this routine 
        // is the completion routine for.
    Irp = device->getPowerIrp();

        // We will return the status set by the PDO for the power request we're completing
    status = IoStatus->Status;
    DBG_PRINT("Enter onPowerRequestCompletion()\n");

    // we must pass down to the next driver in the stack
    IoCopyCurrentIrpStackLocationToNext(Irp);

    // Calling PoStartNextPowerIrp() indicates that the driver is finished
    // with the previous power IRP, if any, and is ready to handle the next power IRP.
    // It must be called for every power IRP.Although power IRPs are completed only once,
    // typically by the lowest-level driver for a device, PoStartNextPowerIrp must be called
    // for every stack location. Drivers must call PoStartNextPowerIrp while the current IRP
    // stack location points to the current driver. Therefore, this routine must be called
    // before IoCompleteRequest, IoSkipCurrentStackLocation, and PoCallDriver.

    PoStartNextPowerIrp(Irp);

    // PoCallDriver is used to pass any power IRPs to the PDO instead of IoCallDriver.
    // When passing a power IRP down to a lower-level driver, the caller should use
    // IoSkipCurrentIrpStackLocation or IoCopyCurrentIrpStackLocationToNext to copy the IRP to
    // the next stack location, then call PoCallDriver. Use IoCopyCurrentIrpStackLocationToNext
    // if processing the IRP requires setting a completion routine, or IoSkipCurrentStackLocation
    // if no completion routine is needed.

    PoCallDriver(device->getLowerDriver(),Irp);

    device->unregisterPowerIrp();
    device->releaseRemoveLock();

    DBG_PRINT("Exit  onPowerRequestCompletion()\n");
    return status;
}

/*++

Routine Description:

    This routine is called when An IRP_MN_SET_POWER of type 'DevicePowerState'
    has been received by BulkUsb_ProcessPowerIrp(), and that routine has  determined
        1) the request is for full powerup ( to PowerDeviceD0 ), and
        2) We are not already in that state
    A call is then made to PoRequestPowerIrp() with this routine set as the completion routine.


Arguments:

    DeviceObject - Pointer to the device object for the class device.

    Irp - Irp completed.

    Context - Driver defined context.

Return Value:

    The function value is the final status from the operation.

--*/
#pragma LOCKEDCODE
NTSTATUS        onPowerIrpComplete(
    IN PDEVICE_OBJECT NullDeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    PIO_STACK_LOCATION irpStack;
    POWER_STATE desiredDevicePowerState;

    DBG_PRINT("Enter onPowerIrpComplete()\n");

        if(!Context) return STATUS_INVALID_PARAMETER;
        
        CUSBReader* device = (CUSBReader*) Context;
    //  If the lower driver returned PENDING, mark our stack location as pending also.
    if (Irp->PendingReturned) IoMarkIrpPending(Irp);
    irpStack = IoGetCurrentIrpStackLocation (Irp);

    // We can assert that we're a  device powerup-to D0 request,
    // because that was the only type of request we set a completion routine
    // for in the first place
    ASSERT(irpStack->MajorFunction == IRP_MJ_POWER);
    ASSERT(irpStack->MinorFunction == IRP_MN_SET_POWER);
    ASSERT(irpStack->Parameters.Power.Type==DevicePowerState);
    ASSERT(irpStack->Parameters.Power.State.DeviceState==PowerDeviceD0);

    // Now that we know we've let the lower drivers do what was needed to power up,
    //  we can set our device extension flags accordingly
        device->setCurrentDevicePowerState(PowerDeviceD0);
        // Do device specific stuff...
        device->onSystemPowerUp();

    Irp->IoStatus.Status = status;
    device->releaseRemoveLock();

    desiredDevicePowerState.DeviceState = PowerDeviceD0;    
    PoSetPowerState(device->getSystemObject(),DevicePowerState,desiredDevicePowerState);    
    PoStartNextPowerIrp(Irp);


    DBG_PRINT("Exit  onPowerIrpComplete() for the state D0\n");
    return status;
}
#pragma PAGEDCODE
NTSTATUS CUSBDevice::power_HandleWaitWake(IN PIRP Irp)
{
        return power_Default(Irp);
}

NTSTATUS CUSBDevice::power_HandleSequencePower(IN PIRP Irp)
{
        return power_Default(Irp);
}

NTSTATUS CUSBDevice::power_HandleQueryPower(IN PIRP Irp)
{
        TRACE("********  QUERY POWER ********\n");
        if(isDeviceLocked())
        {
                TRACE("******** FAILED TO CHANGE POWER (DEVICE BUSY) ********\n");
                Irp->IoStatus.Status = STATUS_DEVICE_BUSY;
                power->startNextPowerIrp(Irp);  // must be done while we own the IRP
                return completeDeviceRequest(Irp, STATUS_DEVICE_BUSY, 0);
        }
        
        Irp->IoStatus.Status = STATUS_SUCCESS;
        return power_Default(Irp);
}

NTSTATUS        CUSBDevice::createDeviceObjectByName(PDEVICE_OBJECT* ppFdo)
{
NTSTATUS status;
        // Construct device name...
        CUString* index = new (PagedPool) CUString(getDeviceNumber(),10);
        CUString* base  = new (PagedPool) CUString(NT_OBJECT_NAME);
        if(!ALLOCATED_OK(index) || !ALLOCATED_OK(base))
        {
                DISPOSE_OBJECT(index);
                DISPOSE_OBJECT(base);
                return STATUS_INSUFFICIENT_RESOURCES;
        }
        USHORT    size  = (USHORT)(index->getLength() + base->getLength() + sizeof(WCHAR));
        
        // Allocate string with required length
        m_DeviceObjectName = new (NonPagedPool) CUString(size);
        if(!ALLOCATED_OK(m_DeviceObjectName))
        {
                DISPOSE_OBJECT(index);
                DISPOSE_OBJECT(base);
                DISPOSE_OBJECT(m_DeviceObjectName);
                return STATUS_INSUFFICIENT_RESOURCES;
        }

        m_DeviceObjectName->append(&base->m_String);
        m_DeviceObjectName->append(&index->m_String);
        TRACE("Driver registers DeviceObjectName as %ws\n", m_DeviceObjectName->m_String.Buffer);

        delete index;
        delete base;

        status = system->createDevice(m_DriverObject,sizeof(CWDMDevice*),&m_DeviceObjectName->m_String,
                                                        FILE_DEVICE_UNKNOWN,0,FALSE,ppFdo);
        if(!NT_SUCCESS(status))
        {
                TRACE("#### Failed to create physical device! Status %x\n",status);
                delete m_DeviceObjectName;
        }
        return status;
}

#endif  // USBDEVICE_PROJECT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\gempc430\usbreader.cpp ===
//-------------------------------------------------------------------
// This is abstract class for generic device
// Specific devices should use it as a parent device
// Author: Sergey Ivanov
// Log:
//		01.11.99	-	implemented	
//-------------------------------------------------------------------
#ifdef	USBREADER_PROJECT
#pragma message("COMPILING USB READER...")

#ifndef __USB_READER__
#define __USB_READER__

#include "generic.h"
#include "usbreader.h"

#include "smartcard.h"
#include "usbdev.h"
#include "reader.h"

#include "gemcore.h"

#pragma PAGEDCODE
CUSBReader::CUSBReader()
{
ULONG DevID;

	m_Status = STATUS_INSUFFICIENT_RESOURCES;
	m_Type    = USBREADER_DEVICE;
	interface = NULL;
	DevID = incrementDeviceNumber();
	TRACE("########### Creating USBReader with index %d\n",DevID);
	// Each reader creates own smartcard object...
	scard_Initialized = FALSE;
	smartCard = new (NonPagedPool) CSmartCard;

	TRACE("**** Creating pooling thread...  ****\n");		
	// We can not use default device function because it was already used by
	// our Io thread (unless we extend it?)
	// Lets define new thread function and xfer control to it...
	PoolingThread = new (NonPagedPool) CThread((PCLIENT_THREAD_ROUTINE)PoolingThreadFunction,this,
											getDevicePoolingInterval());
	if(!ALLOCATED_OK(PoolingThread))
	{
		DISPOSE_OBJECT(PoolingThread);
		TRACE("****** FAILED TO CREATE POOLING THREAD!\n");
	}
	else
	{
		// Thread which controls asynchronous driver communications
		IoThread = new (NonPagedPool) CThread((PCLIENT_THREAD_ROUTINE)ThreadFunction,this,0);
		if(!ALLOCATED_OK(IoThread))
		{
			DISPOSE_OBJECT(IoThread);
			TRACE("****** FAILED TO CREATE IO THREAD!\n");
		}
		else
		{
			IoThread->start();
			setDeviceState(WORKING);
			m_Status = STATUS_SUCCESS;
		}
	}
	TRACE("********* USB Reader %8.8lX was created with status %8.8lX...\n",this,m_Status);
}

#pragma PAGEDCODE
CUSBReader::~CUSBReader()
{
	TRACE("Destroing USB reader pooling thread...\n");
	
	if(PoolingThread)	PoolingThread->dispose();

	
	if(smartCard)
	{
		TRACE("Disconnecting from smartcard system...\n");
		smartCard->smartCardDisconnect();
		smartCard->dispose();
	}
	if(interface) interface->dispose();
	
	if(IoThread) IoThread->stop();
	cancelAllPendingRequests();
	if(IoThread) IoThread->dispose();

	remove();
	TRACE("********* USB Reader %8.8lX was destroied...\n",this);
}

//Handle IRP_MJ_DEVICE_READ request
#pragma PAGEDCODE
NTSTATUS	CUSBReader::open(IN PIRP Irp)
{
NTSTATUS status;
	TRACE("\n------- USB READER OPEN DEVICE --------\n");
	if(getDeviceState()!=WORKING)
	{
		TRACE("		READER IS NOT AT WORKING STATE... State %x\n",getDeviceState());
		status = STATUS_DEVICE_NOT_CONNECTED;
		return completeDeviceRequest(Irp,status,0);
	}
	if(IoThread)
	{
		status = makeRequestPending(Irp,m_DeviceObject,OPEN_REQUEST);
		// Tell thread to start processing 
		if(NT_SUCCESS(status)) 
		{
			TRACE("CALL THREAD FUNCTION...\n");
			IoThread->callThreadFunction();
		}
		else	return completeDeviceRequest(Irp,status,0);
	}
	else
	{
		// IoThread is not ready... Process synchronously!
		status = thread_open(Irp); 
	}
	return status;
}


#pragma PAGEDCODE
NTSTATUS CUSBReader::thread_open(PIRP Irp) 
{
	TRACE("\n------- PROCESSING USB READER OPEN DEVICE --------\n");
	TRACE("DEVICE NUMBER %x\n", this);
	if (!NT_SUCCESS(acquireRemoveLock()))
	{
		TRACE("------- FAILED TO LOCK USB READER --------\n");
		return completeDeviceRequest(Irp, STATUS_DELETE_PENDING, 0);
	}

	// Check if device is already active and reports
	// device busy...
	if(isOpenned())
	{
		TRACE("------- USB READER ALREADY OPENNED --------\n");
		releaseRemoveLock();
		return completeDeviceRequest(Irp, STATUS_DEVICE_BUSY, 0);
	}
	
	if(!NT_SUCCESS(synchronizeDevicePowerState()))
	{
		DEBUG_START();//Force to debug even if thread disable it...
		TRACE("******* FAILED TO SYNCHRONIZE DEVICE POWER...\n");
		releaseRemoveLock();
		return completeDeviceRequest(Irp, STATUS_INVALID_DEVICE_STATE, 0);
	}

	if(PoolingThread) PoolingThread->start();
	
	markAsOpenned();

	TRACE("\n------- USB READER OPENNED! --------\n");
	releaseRemoveLock();
	return completeDeviceRequest(Irp, STATUS_SUCCESS, 0); 
};//Create

#pragma PAGEDCODE
VOID CUSBReader::onDeviceStart() 
{
	TRACE("============= PNP START INITIALIZATION ===============\n");
	if(interface)
	{
		if(!interface->isInitialized())
		{
			interface->initialize();
		}
	}	
	
	reader_UpdateCardState();
	setNotificationState(SCARD_SWALLOWED);
	TRACE("============= PNP START INITIALIZATION FINISHED ===============\n");
};

#pragma PAGEDCODE
NTSTATUS CUSBReader::close(PIRP Irp)
{ 
	DEBUG_START();//Force to debug even if thread disable it...
	TRACE("\n------- USB READER CLOSE DEVICE -------\n");
	if(!isOpenned())
	{
		return completeDeviceRequest(Irp, STATUS_SUCCESS, 0);
	}
	// Check lock count to know if some pending calls exist...
	// Finish all pending calls...		
	// Stop Card pooling...
	if(PoolingThread) PoolingThread->stop();

	// Power down card if inserted...
	if(getCardState()== SCARD_SWALLOWED)
	{
	ULONG ResponseBufferLength = 0;
		reader_WaitForIdleAndBlock();
		reader_Power(SCARD_POWER_DOWN,NULL,&ResponseBufferLength, FALSE);
		reader_set_Idle();
	}

	setNotificationState(getCardState());
	completeCardTracking();

	markAsClosed();
	return completeDeviceRequest(Irp, STATUS_SUCCESS, 0); 
};


#pragma PAGEDCODE
NTSTATUS	CUSBReader::deviceControl(IN PIRP Irp)
{
NTSTATUS status;
	TRACE("\n----- IRP_MJ_DEVICE_CONTROL ------\n");
	if(getDeviceState()!=WORKING)
	{
		TRACE("		READER IS NOT AT WORKING STATE... State %x\n",getDeviceState());
		status = STATUS_DEVICE_NOT_CONNECTED;
		return completeDeviceRequest(Irp,status,0);
	}

	status = thread_deviceControl(Irp);
	return status;
}

// Redefine base class system interface function...
//Handle IRP_MJ_DEVICE_CONTROL request
#pragma PAGEDCODE
NTSTATUS	CUSBReader::thread_deviceControl(IN PIRP Irp)
{							// RequestControl
NTSTATUS status = STATUS_SUCCESS;
ULONG info = 0;

	if (!NT_SUCCESS(acquireRemoveLock()))
	{
		DEBUG_START();//Force to debug even if thread disable it...
		TRACE("******* DIOC: FAILED TO AQUIRE REMOVE LOCK...\n");
		return completeDeviceRequest(Irp, STATUS_DELETE_PENDING, 0);
	}

	TRACE("----- thread_deviceControl() ------\n");

	if(isSurprizeRemoved())
	{
		DEBUG_START();//Force to debug even if thread disable it...
		TRACE("******* DIOC: FAILED! DEVICE WAS SURPRIZE REMOVED...\n");
		releaseRemoveLock();
		return completeDeviceRequest(Irp, STATUS_DELETE_PENDING, 0);
	}
	
	// This was fix for "device SET_POWER without system SET_POWER"
	// It was seen first on ia64 machine
	// If device was powered off tell system to restore power on this device,
	// wait till device will be at proper state...
	/*if(!NT_SUCCESS(synchronizeDevicePowerState()))
	{
		DEBUG_START();//Force to debug even if thread disable it...
		TRACE("******* FAILED TO SYNCHRONIZE DEVICE POWER...\n");
		releaseRemoveLock();
		return completeDeviceRequest(Irp, STATUS_INVALID_DEVICE_STATE, 0);
	}
	*/

	// If we've got request but device was not enable yet -> wait for the device!
	// (One of the reasons to disable device - power state change)
	if(!synchronizeDeviceExecution())
	{
		DEBUG_START();//Force to debug even if thread disable it...
		TRACE("******* DIOC: FAILED TO SYNCHRONIZE EXECUTION ...\n");
		releaseRemoveLock();
		return completeDeviceRequest(Irp, STATUS_DELETE_PENDING, 0);
	}

	// SmartCard system will complete the request,
	// So... We do not need to do it here.
	status = SmartcardDeviceControl(getCardExtention(),Irp);
	TRACE("===== USB reader: SmartcardDeviceControl() returns %8.8lX\n", status);
	releaseRemoveLock();

	if(!NT_SUCCESS(status))
	{// In case of errors force to update card status...
		if(PoolingThread) PoolingThread->callThreadFunction();
	}
	return status;
}

#pragma PAGEDCODE
NTSTATUS 	CUSBReader::cleanup(PIRP Irp)
{
	DEBUG_START();//Force to debug even if thread disable it...
	TRACE("\n----- IRP_MJ_CLEANUP ------\n");

	if(PoolingThread) PoolingThread->stop();
	cancelAllPendingRequests();


	setNotificationState(getCardState());
	completeCardTracking();

	reader_set_Idle();
	TRACE("----- IRP_MJ_CLEANUP FINISHED... ------\n");
	return completeDeviceRequest(Irp, STATUS_SUCCESS, 0); 
}


#pragma LOCKEDCODE
// This is callback function for the attached threads
VOID CUSBReader::PoolingThreadFunction(CUSBReader* device)
{
	if(device) device->PoolingThreadRoutine();
};

#pragma PAGEDCODE
NTSTATUS CUSBReader::PoolingThreadRoutine()
{
NTSTATUS status;
ULONG State;
LONG  TimeOut;
	if(!NT_SUCCESS(status = reader_WaitForIdle())) return status;
	reader_set_busy();
	
	TimeOut = getCommandTimeout();
	setCommandTimeout(10000);//Change get status command timeout!

	DEBUG_STOP();
	State = reader_UpdateCardState();
	TRACE("======>> Card state %x\n",CardState);
	DEBUG_START();

	setCommandTimeout(TimeOut);

	reader_set_Idle();
	return STATUS_SUCCESS;
};	

#pragma LOCKEDCODE
VOID	  CUSBReader::reader_set_busy()
{
	setBusy();
};

#pragma LOCKEDCODE
VOID	  CUSBReader::reader_set_Idle()
{
	setIdle();
};

#pragma LOCKEDCODE
NTSTATUS  CUSBReader::reader_WaitForIdle()
{
	return waitForIdle();
};

#pragma LOCKEDCODE
NTSTATUS  CUSBReader::reader_WaitForIdleAndBlock()
{
	return waitForIdleAndBlock();
};


#ifdef DEBUG
/*
// Overwrite device functions...
NTSTATUS	CUSBReader::read(IN PIRP Irp)
{
NTSTATUS status = STATUS_SUCCESS;
ULONG info = 0;
	TRACE("USB reader: IRP_MJ_DEVICE_READ\n");
	if (!NT_SUCCESS(acquireRemoveLock()))	return completeDeviceRequest(Irp, STATUS_DELETE_PENDING, 0);

	status = reader_Read(Irp);
	releaseRemoveLock();
	status = completeDeviceRequest(Irp, status, info);
	return status;
}
NTSTATUS	CUSBReader::write(IN PIRP Irp)
{
NTSTATUS status = STATUS_SUCCESS;
ULONG info = 0;
	TRACE("USB reader: IRP_MJ_DEVICE_WRITE\n");
	if (!NT_SUCCESS(acquireRemoveLock()))	return completeDeviceRequest(Irp, STATUS_DELETE_PENDING, 0);
	status = reader_Write(Irp);
	releaseRemoveLock();
	status = completeDeviceRequest(Irp, status, info);
	return status;
}
*/
#endif


#pragma PAGEDCODE
BOOL	 CUSBReader::createInterface(LONG interfaceType, LONG protocolType,CUSBReader* device)
{
	interface = kernel->createReaderInterface(interfaceType,protocolType,device);
	if(interface)	return TRUE;
	else            return FALSE;
};	

#pragma PAGEDCODE
VOID	 CUSBReader::initializeSmartCardSystem()
{
	if(smartCard)
	{
		CardState = SCARD_UNKNOWN;
		StateToNotify = SCARD_UNKNOWN;
		smartCard->smartCardConnect(this);
	}
};


#pragma PAGEDCODE
VOID	CUSBReader::onSystemPowerDown()
{
	// Stop pooling thread
    TRACE("Stop polling thread going to PowerDeviceD3 (OFF)\n");
	disableDevice();

	if(PoolingThread) {if(PoolingThread->isThreadActive()) setThreadRestart();};
	if(PoolingThread) PoolingThread->stop();
	return;
}

#pragma PAGEDCODE
VOID	CUSBReader::onSystemPowerUp()
{
	// Stop pooling thread
    TRACE("Restore reader state going to PowerDeviceD0 (ON)\n");
	if(interface)
	{
		if(interface->isInitialized())
		{
			// Restore reader mode after power down
			NTSTATUS status = interface->setReaderMode(READER_MODE_NATIVE);
			if(!NT_SUCCESS(status))
			{
				TRACE("Failed to set Gemcore reader mode %x\n",READER_MODE_NATIVE);
			}
		}
	}	
	if(getCardState() >= SCARD_SWALLOWED) setCardState(SCARD_ABSENT);
	completeCardTracking();	

	if(isRequiredThreadRestart())
	{
		TRACE("Starting pooling thread going to PowerDeviceD0 (ON)\n");
		if(PoolingThread) PoolingThread->start();	
	}

	enableDevice();
	return;
}

#pragma PAGEDCODE
BOOLEAN	CUSBReader::setDevicePowerState(IN DEVICE_POWER_STATE DeviceState)
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    BOOLEAN fRes = FALSE;

	DEBUG_START();
	switch (DeviceState) 
	{
    case PowerDeviceD3:
	    // Device will be going OFF, 
		// TODO: add any needed device-dependent code to save state here.
		//  ( We have nothing to do in this sample )
        TRACE("Set Device Power State to PowerDeviceD3 (OFF)\n");
        setCurrentDevicePowerState(DeviceState);
        break;
    case PowerDeviceD1:
    case PowerDeviceD2:
        // power states D1,D2 translate to USB suspend
#ifdef DEBUG
        TRACE("Set Device Power State to %s\n",Powerdevstate[DeviceState]);
#endif
        setCurrentDevicePowerState(DeviceState);
        break;
    case PowerDeviceD0:
        TRACE("Set Device Power State to PowerDeviceD0(ON)\n");
        // We'll need to finish the rest in the completion routine;
        // signal caller we're going to D0 and will need to set a completion routine
        fRes = TRUE;
        // Caller will pass on to PDO ( Physical Device object )
        break;
    default:
        TRACE(" Bogus DeviceState = %x\n", DeviceState);
    }
    return fRes;
}

#pragma PAGEDCODE
ULONG CUSBReader::reader_UpdateCardState()
{
	if(interface)
	{
		CardState = interface->getReaderState();
		completeCardTracking();
	}
	else	CardState = 0;
	return  CardState;
};

#pragma LOCKEDCODE
VOID	CUSBReader::completeCardTracking()
{
	if(smartCard)
	{
		smartCard->completeCardTracking();
	}
};


#pragma PAGEDCODE
NTSTATUS  CUSBReader::reader_getVersion(PUCHAR pVersion, PULONG pLength)
{
	if(interface)	return interface->getReaderVersion(pVersion,pLength);
	else return STATUS_INVALID_DEVICE_STATE;
};

#pragma PAGEDCODE
NTSTATUS CUSBReader::reader_setMode(ULONG mode)
{
	if(interface)	return interface->setReaderMode(mode);
	else return STATUS_INVALID_DEVICE_STATE;
};

#ifdef DEBUG
#pragma PAGEDCODE
NTSTATUS	CUSBReader::reader_Read(IN PIRP Irp)
{
	CIoPacket* request = new (NonPagedPool) CIoPacket(Irp);
	if(!ALLOCATED_OK(request) || !ALLOCATED_OK(interface))
	{
		DISPOSE_OBJECT(request);
		return completeDeviceRequest(Irp,STATUS_INSUFFICIENT_RESOURCES,0);
	}

	NTSTATUS status = interface->read(request);
	DISPOSE_OBJECT(request);
	return status;
};

#pragma PAGEDCODE
NTSTATUS	CUSBReader::reader_Write(IN PIRP Irp)
{
	CIoPacket* request = new (NonPagedPool) CIoPacket(Irp);
	if(!ALLOCATED_OK(request) || !ALLOCATED_OK(interface))
	{
		DISPOSE_OBJECT(request);
		return completeDeviceRequest(Irp,STATUS_INSUFFICIENT_RESOURCES,0);
	}

	NTSTATUS status = interface->write(request);
	DISPOSE_OBJECT(request);
	return status;
};
#endif

#pragma PAGEDCODE
NTSTATUS CUSBReader::reader_Read(BYTE * pRequest,ULONG RequestLength,BYTE * pReply,ULONG* pReplyLength)
{
	if(interface)	return interface->readAndWait(pRequest,RequestLength,pReply,pReplyLength);
	else return STATUS_INVALID_DEVICE_STATE;
};

#pragma PAGEDCODE
NTSTATUS CUSBReader::reader_Write(BYTE* pRequest,ULONG RequestLength,BYTE * pReply,ULONG* pReplyLength)
{
	if(interface)	return interface->writeAndWait(pRequest,RequestLength,pReply,pReplyLength);
	else return STATUS_INVALID_DEVICE_STATE;
};

#pragma PAGEDCODE
NTSTATUS CUSBReader::reader_Ioctl(ULONG ControlCode,BYTE* pRequest,ULONG RequestLength,BYTE* pReply,ULONG* pReplyLength)
{
	if(interface)	return interface->ioctl(ControlCode,pRequest,RequestLength,pReply,pReplyLength);
	else return STATUS_INVALID_DEVICE_STATE;
};

#pragma PAGEDCODE
NTSTATUS CUSBReader::reader_SwitchSpeed(ULONG ControlCode,BYTE* pRequest,ULONG RequestLength,BYTE* pReply,ULONG* pReplyLength)
{
	if(interface)	return interface->SwitchSpeed(ControlCode,pRequest,RequestLength,pReply,pReplyLength);
	else return STATUS_INVALID_DEVICE_STATE;
};

#pragma PAGEDCODE
NTSTATUS CUSBReader::reader_VendorAttribute(ULONG ControlCode,BYTE* pRequest,ULONG RequestLength,BYTE* pReply,ULONG* pReplyLength)
{
	if(interface)	return interface->VendorAttribute(ControlCode,pRequest,RequestLength,pReply,pReplyLength);
	else return STATUS_INVALID_DEVICE_STATE;
};


#pragma PAGEDCODE
NTSTATUS CUSBReader::reader_Power(ULONG ControlCode,BYTE* pReply,ULONG* pReplyLength, BOOLEAN Specific)
{
	if(interface)	return interface->power(ControlCode,pReply,pReplyLength, Specific);
	else return STATUS_INVALID_DEVICE_STATE;
};

#pragma PAGEDCODE
NTSTATUS CUSBReader::reader_SetProtocol(ULONG ProtocolRequested, UCHAR ProtocolNegociation)
{
	NTSTATUS status;

	if(interface)
	{
		ReaderConfig config = interface->getConfiguration();
		// Update all required configuration fields to set specific protocol

		switch(ProtocolNegociation)
		{
			case PROTOCOL_MODE_DEFAULT: 
				config.PTSMode = PTS_MODE_DISABLED;
				break;
			case PROTOCOL_MODE_MANUALLY:
			default:
				config.PTSMode = PTS_MODE_MANUALLY;
				break;
		}

		config.PTS1 = smartCardExtention.CardCapabilities.PtsData.Fl << 4 | 
			 smartCardExtention.CardCapabilities.PtsData.Dl;

		interface->setConfiguration(config);

		status = interface->setProtocol(ProtocolRequested);
		return status;
	}
	else return STATUS_INVALID_DEVICE_STATE;
};


#pragma PAGEDCODE
NTSTATUS CUSBReader::setTransparentConfig(PSCARD_CARD_CAPABILITIES cardCapabilities, BYTE NewWtx)
{
	if(interface)	return interface->setTransparentConfig(cardCapabilities,NewWtx);
	else return STATUS_INVALID_DEVICE_STATE;
};


#pragma PAGEDCODE
NTSTATUS CUSBReader::reader_translate_request(BYTE * pRequest,ULONG RequestLength,BYTE * pReply,ULONG* pReplyLength, PSCARD_CARD_CAPABILITIES cardCapabilities, BYTE NewWtx)
{
	if(interface)	return interface->translate_request(pRequest,RequestLength,pReply,pReplyLength, cardCapabilities, NewWtx);
	else return STATUS_INVALID_DEVICE_STATE;
};

#pragma PAGEDCODE
NTSTATUS CUSBReader::reader_translate_response(BYTE * pRequest,ULONG RequestLength,BYTE * pReply,ULONG* pReplyLength)
{
	if(interface)	return interface->translate_response(pRequest,RequestLength,pReply,pReplyLength);
	else return STATUS_INVALID_DEVICE_STATE;
};

#pragma PAGEDCODE
NTSTATUS CUSBReader::PnP_HandleSurprizeRemoval(IN PIRP Irp)
{	// It is PnP internal function.
	// So, device will be locked at PnP entry and
	// we do not need to do it here.
	TRACE("********  USB READER SURPRIZE REMOVAL ********\n");

	// Just stop thread and remove all pending IOs
	if(PoolingThread) PoolingThread->stop();

	setSurprizeRemoved();
	cancelAllPendingRequests();

	return PnP_Default(Irp);
};


VOID CUSBReader::onDeviceStop()
{
	TRACE("********  ON USB READER STOP ********\n");
	// Just stop thread and remove all pending IOs
	if(PoolingThread) PoolingThread->stop();
	//if(IoThread)	  IoThread->stop();
	return;
};

// Reader startIoRequest function
// It will dispatch all pending Io requests
NTSTATUS	CUSBReader::startIoRequest(CPendingIRP* IrpReq) 
{
NTSTATUS status;
	TRACE("		CUSBReader::::startIoRequest() was called...\n");
	// Our child's functions run under protection of child BUSY/IDLE breaks.
	// So, we do not need to check idle state here...
	if(getDeviceState()!=WORKING)
	{
		TRACE("		READER IS NOT AT WORKING STATE... State %x\n",getDeviceState());
		TRACE("		<<<<<< READER IO REQUEST FINISHED WITH STATUS %8.8lX>>>>>>\n",STATUS_DEVICE_NOT_CONNECTED);
		NTSTATUS status = completeDeviceRequest(IrpReq->Irp, STATUS_DEVICE_NOT_CONNECTED, 0);
		IrpReq->dispose();
		return   status;
	}

	// Our reader will support asynchronous communications only for these functions...
	switch(IrpReq->Type)
	{
	case OPEN_REQUEST:
		TRACE("OPEN_REQUEST RECIEVED FROM THREAD...\n");
		status = thread_open(IrpReq->Irp);
		break;
	case IOCTL_REQUEST:
		TRACE("IOCTL_REQUEST RECIEVED FROM THREAD...\n");
		status = thread_deviceControl(IrpReq->Irp);
		break;
	default:
		status = STATUS_INVALID_DEVICE_REQUEST;
	}
	IrpReq->dispose();
	TRACE("		<<<<<< READER IO REQUEST FINISHED WITH STATUS %8.8lX>>>>>>\n",status);
	return status;
};

NTSTATUS CUSBReader::ThreadRoutine()
{
	// If somebody inserted pending request - dispatch it...
	// It will call specific child device startIoRequest().
	// It is up to that device how to handle it.
	// If child device is busy - it can insert this request into
	// child device request queue again and process it later...
	startNextPendingRequest();
	return STATUS_SUCCESS;
};	

#endif
#endif //USBREADER_PROJECT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\gempc430\wdmdebug.h ===
// Gemplus (C) 1999
// Version 1.0
// Author: Sergey Ivanov
// Date of creation - 18.05.1999
// Change log:
//

#ifndef WDM_DBG_INT
#define WDM_DBG_INT
#include "generic.h"
#include "debug.h"

#pragma PAGEDCODE
class CWDMDebug : public CDebug
{
public:
	NTSTATUS m_Status;
	SAFE_DESTRUCTORS();
	virtual VOID dispose(VOID);
protected:
	CWDMDebug(){m_Status = STATUS_SUCCESS;active = TRUE;};
	virtual ~CWDMDebug(){};
public:
	static CDebug*  create(VOID);

	/*Open(CDevice*) = 0;
	Close(CDevice*) = 0;
	CopyDebug(CDevice*) = 0;
	Print(...) = 0;
	*/
	virtual VOID	start();
	virtual VOID	stop();

	VOID	trace(PCH Format,... );
	VOID 	trace_no_prefix (PCH Format,...);
	VOID	trace_buffer(PVOID pBuffer,ULONG BufferLength);

};	

#endif//DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\gempc430\wdmdebug.cpp ===
#include "wdmdebug.h"

#pragma PAGEDCODE
CDebug* CWDMDebug::create(VOID)
{ 
CDebug* d;
	d = new (NonPagedPool) CWDMDebug; 
	DBG_PRINT("***** New Debug Object was created 0x%x\n",d);
	RETURN_VERIFIED_OBJECT(d);
}

#pragma PAGEDCODE
VOID CWDMDebug::dispose(VOID)
{ 
LONG Usage;
	Usage = decrementUsage();
	if(Usage<=0)
	{
		trace("**** Deleting Debug Object 0x%x\n",this);
		self_delete();
	}
}

#pragma PAGEDCODE
VOID CWDMDebug::trace (PCH Format,...)
{
	if(!active) return;

va_list argpoint;
CHAR  strTempo[1024];
	va_start(argpoint,Format);
	vsprintf(strTempo,Format,argpoint);
	va_end(argpoint);
	::DBG_PRINT(strTempo);
}
#pragma PAGEDCODE
VOID CWDMDebug::trace_no_prefix (PCH Format,...)
{
	if(!active) return;

va_list argpoint;
CHAR  strTempo[1024];
	va_start(argpoint,Format);
	vsprintf(strTempo,Format,argpoint);
	va_end(argpoint);
	::DBG_PRINT_NO_PREFIX(strTempo);
}

#pragma PAGEDCODE
VOID	CWDMDebug::trace_buffer(PVOID pBuffer,ULONG BufferLength)
{
	if(!active) return;
	trace_no_prefix("\n	");
	for(USHORT i=0;i<BufferLength;i++)
	{
		trace_no_prefix("%2.2x ", ((PUCHAR)pBuffer)[i]);
		if(i && !(i%10)) trace_no_prefix("\n	");
	}
	trace_no_prefix("\n");

}
#pragma PAGEDCODE
VOID	CWDMDebug::start()
{
	active = TRUE;
}
#pragma PAGEDCODE
VOID	CWDMDebug::stop()
{
	active = FALSE;
}



///////////////////////////////////////////////////////////////////
// Trace output
//
/*
VOID Trace::Trace(TRACE_LEVEL Level, PCHAR fmt, ...)
{
	int outLen;

	if (Level >= m_TraceLevel)
	{
	// Send the message
		va_list ap;
		va_start(ap, fmt);
		char buf[SCRATCH_BUF_SIZE];

	// format string to buffer
		outLen = _vsnprintf(buf+m_PrefixLength, SCRATCH_BUF_SIZE-m_PrefixLength, fmt, ap);

	// Copy prefix string to buffer
		if (m_Prefix != NULL)
			memcpy(buf, m_Prefix, m_PrefixLength);

	// output to debugger if requested
		if (m_TargetMask & TRACE_DEBUGGER)
			DBG_PRINT(buf);
				
	// output to monitor if requested
		if ((m_Post != 0) && (m_TargetMask & TRACE_MONITOR))
			m_Post(m_Channel, buf + (m_NeedPrefix ? 0 : m_PrefixLength));

	// if the last char was a newline, need prefix next time
		m_NeedPrefix = (buf[m_PrefixLength+outLen-1] == '\n');
	}

	// break if requested
	if ((BREAK_LEVEL) Level >= m_BreakLevel)
		DbgBreakPoint();
}

///////////////////////////////////////////////////////////////////
// Destructor
//
Trace::~Trace(VOID)
{
	if (m_Close && (m_Channel != NULL))
		m_Close(m_Channel);
	if (m_FreeOnDestroy && m_Prefix)
		delete m_Prefix;
}
*/
// End of system function remapping
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\gempc430\usbreader.h ===
// Gemplus (C) 1999
//
// Version 1.0
// Author: Sergey Ivanov
// Date of creation - 11.01.1999
// Change log:
//
#ifndef USB_READER
#define USB_READER

#include "debug.h"
#include "thread.h"
#include "usbdev.h"
#include "reader.h"


class CUSBDevice;
class CReader;
class CSmartCard;
//class CGemCore;//TOBE REMOVED

#pragma PAGEDCODE
class CUSBReader : public CUSBDevice, public CReader
{
public:
    NTSTATUS m_Status;
	SAFE_DESTRUCTORS();
	virtual VOID dispose(){self_delete();};
protected:
	virtual  ~CUSBReader();
public:	
	CUSBReader();

	virtual PDEVICE_OBJECT	getSystemDeviceObject()
	{
	PDEVICE_OBJECT pFdo = getSystemObject();

		TRACE("Reader reports device object 0x%x\n",pFdo);
		return pFdo;
	};
	
	virtual VOID	  reader_set_busy();
	virtual VOID	  reader_set_Idle();
	virtual NTSTATUS  reader_WaitForIdle();
	virtual NTSTATUS  reader_WaitForIdleAndBlock();

	// We support asynchronous communications only for Open and DeviceIOControl functions...
	virtual NTSTATUS  open(PIRP Irp); 
	virtual NTSTATUS  thread_open(IN PIRP Irp);
	virtual NTSTATUS  close(PIRP Irp);

	virtual NTSTATUS  deviceControl(IN PIRP Irp);
	virtual NTSTATUS  thread_deviceControl(IN PIRP Irp);

	virtual NTSTATUS  cleanup(PIRP irp);
	//Overwrite some generic USB device handlers
	virtual NTSTATUS  PnP_HandleSurprizeRemoval(IN PIRP Irp);

	virtual VOID	 setNotificationState(ULONG state){StateToNotify = state;};
	virtual ULONG	 getNotificationState(){ return StateToNotify;};

	virtual BOOL	 isSmartCardInitialized(){return scard_Initialized;};	
	virtual VOID	 setSmartCardInitialized(BOOL state) {scard_Initialized = state;};
	
	virtual PSMARTCARD_EXTENSION getCardExtention()
	{
		return &smartCardExtention;
	};
	virtual CSmartCard* getSmartCard()
	{
		return smartCard;
	};

	//virtual BOOL	 createInterface(LONG interfaceType, LONG protocolType,CDevice* device);//TOBE CHANGED
	virtual BOOL	 createInterface(LONG interfaceType, LONG protocolType,CUSBReader* device);
	
	virtual VOID	 initializeSmartCardSystem();
	virtual ULONG	 reader_UpdateCardState();
	virtual VOID	 completeCardTracking();
	virtual BOOLEAN	 setDevicePowerState(IN DEVICE_POWER_STATE DeviceState);
	// Do specific step on the way system goes down
	virtual VOID	 onSystemPowerDown();
	virtual VOID	 onSystemPowerUp();

	virtual NTSTATUS reader_getVersion(PUCHAR pVersion, PULONG pLength);
	virtual NTSTATUS reader_setMode(ULONG mode);
#ifdef DEBUG
	virtual NTSTATUS reader_Read(IN PIRP Irp);
	virtual NTSTATUS reader_Write(IN PIRP Irp);
#endif
	virtual NTSTATUS reader_Read(BYTE * pRequest,ULONG RequestLength,BYTE * pReply,ULONG* pReplyLength);
	virtual NTSTATUS reader_Write(BYTE* pRequest,ULONG RequestLength,BYTE * pReply,ULONG* pReplyLength);
	virtual NTSTATUS reader_Ioctl(ULONG ControlCode,BYTE* pRequest,ULONG RequestLength,BYTE* pReply,ULONG* pReplyLength);
	virtual NTSTATUS reader_SwitchSpeed(ULONG ControlCode,BYTE* pRequest,ULONG RequestLength,BYTE* pReply,ULONG* pReplyLength);
	virtual NTSTATUS reader_VendorAttribute(ULONG ControlCode,BYTE* pRequest,ULONG RequestLength,BYTE* pReply,ULONG* pReplyLength);

	virtual NTSTATUS reader_Power(ULONG ControlCode,BYTE* pReply,ULONG* pReplyLength, BOOLEAN Specific);
	virtual NTSTATUS reader_SetProtocol(ULONG ProtocolRequested, UCHAR ProtocolNegociation);
	virtual NTSTATUS setTransparentConfig(PSCARD_CARD_CAPABILITIES cardCapabilities, BYTE NewWtx);

	virtual NTSTATUS reader_translate_request(BYTE * pRequest,ULONG RequestLength,BYTE * pReply,ULONG* pReplyLength, PSCARD_CARD_CAPABILITIES cardCapabilities, BYTE NewWtx);
	virtual NTSTATUS reader_translate_response(BYTE * pRequest,ULONG RequestLength,BYTE * pReply,ULONG* pReplyLength);

#ifdef DEBUG
//	virtual NTSTATUS	read(IN PIRP Irp);
//	virtual NTSTATUS	write(IN PIRP Irp);
#endif
	static  VOID		PoolingThreadFunction(CUSBReader* device);
	virtual NTSTATUS	PoolingThreadRoutine();
	virtual NTSTATUS	startIoRequest(CPendingIRP* IrpReq);
	virtual NTSTATUS	ThreadRoutine();//Overwrite standard function...

	virtual VOID	 onDeviceStart();
	virtual VOID	 onDeviceStop();
private:
	BOOL scard_Initialized;
	// Interface to communicate with reader from smartCard system...
	CReaderInterface* interface;
	//CGemCore* interface;//TOBE CHANGED

	//ULONG  CardState;
	ULONG  StateToNotify;
	
	CSmartCard* smartCard;
	SMARTCARD_EXTENSION smartCardExtention;

	CThread* PoolingThread;
};


#endif // If defined
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\gempc430\wdmdev.h ===
//-------------------------------------------------------------------
// This is implementation of WDM device
// Author: Sergey Ivanov
// Log:
//		10/01/99	-	implemented	
//-------------------------------------------------------------------

#ifndef __WDM_ADAPTER__
#define __WDM_ADAPTER__
#include "kernel.h"

#pragma LOCKEDCODE

class CPendingIRP;
class CLinkedList;


#pragma PAGEDCODE
// This is adapter class
// It defines default device methods specific for any WDM.
class CWDMDevice : public CDevice
{
public:
	NTSTATUS m_Status;
	SAFE_DESTRUCTORS();
protected:
    NTSTATUS device_Default(PIRP Irp)
    {
	// Default functions to handle requests...
	// By default we do not handle any requests if 
	// they are not reimplimented.
        Irp->IoStatus.Status = STATUS_IO_DEVICE_ERROR;
        Irp->IoStatus.Information = 0;
        irp->completeRequest(Irp,IO_NO_INCREMENT);
        return STATUS_IO_DEVICE_ERROR;
    };

	NTSTATUS PnP_Default(IN PIRP Irp)
	{
		// Default device does not do anything.
		// So let's just transfer request to low level driver...
		irp->skipCurrentStackLocation(Irp);
		return system->callDriver(m_pLowerDeviceObject, Irp);
	};

	NTSTATUS power_Default(IN PIRP Irp)
	{
		// Default device does not do anything.
		// So let's just transfer request to low level driver...
		power->startNextPowerIrp(Irp);	// must be done while we own the IRP
		irp->skipCurrentStackLocation(Irp);
		return power->callPowerDriver(m_pLowerDeviceObject, Irp);
	}

	NTSTATUS	completeDeviceRequest(PIRP Irp, NTSTATUS status, ULONG_PTR info)
	{	
		// Complete current request with given information

		if (Irp->PendingReturned)
		{
			irp->getCurrentStackLocation(Irp)->Control &=  ~SL_PENDING_RETURNED;
		}

		Irp->IoStatus.Status = status;
		Irp->IoStatus.Information = info;
		irp->completeRequest(Irp,IO_NO_INCREMENT);
		return status;
	}
public:	
	// Redefine base class methods..
	CWDMDevice()
	{
	    m_Status = STATUS_INSUFFICIENT_RESOURCES;
		Signature[0]=L'I';
        Signature[1]=L'S';
        Signature[2]=L'V';

		initialized = FALSE;		
		if(createDeviceObjects())
		{
			//Default our interface
			memory->copy(&InterfaceClassGuid,&GUID_CLASS_GRCLASS,sizeof(GUID));

			// It is reqired to initialize our object directly 
			// through createDeviceObjects() function.
			event->initialize(&IdleState,SynchronizationEvent, TRUE);
			// This event will signal if device is ready to process requests...
			event->initialize(&m_evEnabled,NotificationEvent,TRUE);
			initializeRemoveLock();		
			m_Status = STATUS_SUCCESS;
		}

		Idle_conservation = 0;
		Idle_performance  = 0;
		m_VendorNameLength = 0;
		m_DeviceTypeLength = 0;

		TRACE("WDM device created...\n");
	};

    ~CWDMDevice()
	{
		TRACE("				Destroing WDM device %8.8lX ...\n", this);
		if(!m_RemoveLock.removing)
		{
			TRACE("######## ERROR: surprize destroing...\n");
			remove();
		}
        
		unregisterDeviceInterface(getDeviceInterfaceName());

		Signature[0]++;
        Signature[1]++;

		removeDeviceObjects();
	};


	BOOL checkValid(VOID)
    {
		if(!initialized) return FALSE;

        return (Signature[0]==L'I' && Signature[1]==L'S' 
            && Signature[2]==L'V');
    };

	// It is alright to create device directly or 
	// to call the function
	virtual CDevice*	create(VOID)
	{
		CDevice* obj = new (NonPagedPool) CWDMDevice;
		RETURN_VERIFIED_OBJECT(obj);
	};
	

	virtual VOID dispose()
	{
		TRACE("Destroing WDM device...\n");
		if(!m_RemoveLock.removing)
		{
			TRACE("######## ERROR: surprize destroing...\n");
			remove();
		}
        Signature[0]++;
        Signature[1]++;
		removeDeviceObjects();

		// The device is link to the system.
		// So let system to remove device first and
		// after this we will remove device object...
		//self_delete();
	};

	BOOL createDeviceObjects()
	{
		debug	= kernel->createDebug();
		system	= kernel->createSystem();
		lock	= kernel->createLock();
		irp		= kernel->createIrp();
		event	= kernel->createEvent();
		power	= kernel->createPower();
		memory	= kernel->createMemory();

        m_IoRequests = new (NonPagedPool) CLinkedList<CPendingIRP>;
		if(!system || !irp || !event || !power || !lock 
			|| !memory || !m_IoRequests)
		{
			removeDeviceObjects();
			return FALSE;
		}
		TRACE("WDM device objects created...\n");
		initialized = TRUE;
		return TRUE;
	};

	VOID removeDeviceObjects()
	{
		TRACE("Destroing WDM device objects...\n");

		if(m_IoRequests) delete m_IoRequests;

		if(lock)		lock->dispose();
		if(irp)			irp->dispose();
		if(event)		event->dispose();

		if(power)		power->dispose();
		if(memory)		memory->dispose();

		if(system)		system->dispose();
		if(debug)		debug->dispose();
		initialized = FALSE;
	};

	// This part contains device synchronization functions.
	// They should be used to synchronize device removal.
	// So basically any access to device should be started with acquireRemoveLock()
	// and finished with releaseRemoveLock()...
	#pragma PAGEDCODE
	VOID initializeRemoveLock()
	{							// InitializeRemoveLock
		PAGED_CODE();
		event->initialize(&m_RemoveLock.evRemove, NotificationEvent, FALSE);
		m_RemoveLock.usage = 1;
		m_RemoveLock.removing = FALSE;
	}							// InitializeRemoveLock

	#pragma LOCKEDCODE
	NTSTATUS acquireRemoveLock()
	{ 
		LONG usage = lock->interlockedIncrement(&m_RemoveLock.usage);

		if (m_RemoveLock.removing)
		{						// removal in progress
			if (lock->interlockedDecrement(&m_RemoveLock.usage) == 0)
				event->set(&m_RemoveLock.evRemove,IO_NO_INCREMENT,FALSE);

			TRACE("LOCK: m_RemoveLock.usage %d\n",m_RemoveLock.usage);
			TRACE("****** FAILED TO LOCK WDM DEVICE! REMOVE REQUEST IS ACTIVE! *******\n");
			return STATUS_DELETE_PENDING;
		}
		//TRACE("LOCK: m_RemoveLock.usage %d\n",m_RemoveLock.usage);
		return STATUS_SUCCESS;
	};

	#pragma PAGEDCODE
	VOID	releaseRemoveLock()
	{ 
		ULONG usage;
		if(m_Type==BUS_DEVICE)
		{	//???????????????????????- BIG BIG BUG!!!
			// It is connected only to BUS device!
			// At some conditions not all remove locks was released properly.
			// For other devices it is not appeared at all.
			if(m_RemoveLock.usage<0) m_RemoveLock.usage = 0;
			if (!m_RemoveLock.removing)
			{
				if(m_RemoveLock.usage<2) m_RemoveLock.usage = 2;
			}

		}

		if (usage = lock->interlockedDecrement(&m_RemoveLock.usage) == 0)
				event->set(&m_RemoveLock.evRemove,IO_NO_INCREMENT,FALSE);
		//TRACE("UNLOCK: m_RemoveLock.usage %d\n",m_RemoveLock.usage);
	};

	#pragma PAGEDCODE
	VOID	releaseRemoveLockAndWait()
	{						
		PAGED_CODE();
		TRACE("REMOVING DEVICE...\n");
		m_RemoveLock.removing = TRUE;
		// We are going to remove device.
		// So if somebody is waiting for the active device,
		// first allow them to fail request and complete Irp
		event->set(&m_evEnabled,IO_NO_INCREMENT,FALSE);

		releaseRemoveLock();
		releaseRemoveLock();
		// Child device at bus could be removed by the Bus itself
		// In this case it will not have second AquireRemoveLock from PnP system!
		if(m_Type == CHILD_DEVICE) 
			if(m_RemoveLock.usage<0) m_RemoveLock.usage = 0;
		TRACE("LOCK COUNT ON REMOVING %x\n",m_RemoveLock.usage);
		//ASSERT(m_RemoveLock.usage==0);
		event->waitForSingleObject(&m_RemoveLock.evRemove, Executive, KernelMode, FALSE, NULL);
	}

	BOOL isDeviceLocked()
	{
		lock->interlockedIncrement(&m_RemoveLock.usage);
		// Add device will increment Usage!
		// Current request will add more...
		if(lock->interlockedDecrement(&m_RemoveLock.usage)<=2)
		{
			return FALSE;
		}
		TRACE("Current lock count %d\n",m_RemoveLock.usage);
		return TRUE;
	};

	// Contrary to RemoveLock disableDevice() stops and blocks any active request
	// INSIDE driver. It will not fail the request but will synchronize its
	// execution.
	VOID	disableDevice()
	{
		TRACE("********** DISABLING DEVICE...***********\n");
		event->clear(&m_evEnabled);
	} 

	VOID	enableDevice()
	{
		TRACE("********** ENABLING DEVICE...***********\n");
		event->set(&m_evEnabled,IO_NO_INCREMENT,FALSE);
	}


	BOOL	synchronizeDeviceExecution()
	{	// If device is not ready to process requests, block waiting for the device
		ASSERT(system->getCurrentIrql()<=DISPATCH_LEVEL);
		NTSTATUS status  = event->waitForSingleObject(&m_evEnabled, Executive,KernelMode, FALSE, NULL);
		if(!NT_SUCCESS(status) || m_RemoveLock.removing) return FALSE;
		return TRUE;
	}
	// Functions to synchronize device execution
	VOID		setBusy()
	{
		event->clear(&IdleState);
		//TRACE("\n			DEVICE BUSY\n");
	};
	
	VOID		setIdle()
	{
		event->set(&IdleState,IO_NO_INCREMENT,FALSE);
		//TRACE("\n			DEVICE IDLE\n");
	};
	
	NTSTATUS	waitForIdle()
	{
		ASSERT(system->getCurrentIrql()<=DISPATCH_LEVEL);
		NTSTATUS status  = event->waitForSingleObject(&IdleState, Executive,KernelMode, FALSE, NULL);
		if(!NT_SUCCESS(status))	return STATUS_IO_TIMEOUT;
		return STATUS_SUCCESS;
	};
	NTSTATUS	waitForIdleAndBlock()
		{
		if(NT_SUCCESS(waitForIdle()))
		{ 
			setBusy();
			return STATUS_SUCCESS;
		}
		else return STATUS_IO_TIMEOUT;
	};
	
	BOOL	registerDeviceInterface(const GUID* Guid)
	{
		if(isDeviceInterfaceRegistered())
		{
			TRACE("Device interface already active...\n");	
			return TRUE;		
		}
		
		if(memory) memory->copy(&InterfaceClassGuid, Guid,sizeof(GUID));

		TRACE("Registering device interface at system...\n");	
		NTSTATUS Status = system->registerDeviceInterface(getPhysicalObject(),
						&InterfaceClassGuid, NULL, getDeviceInterfaceName());
		if(!NT_SUCCESS(Status))
		{
			TRACE("#### Failed to register device interface...\n");
			return FALSE;
		}
		system->setDeviceInterfaceState(getDeviceInterfaceName(),TRUE);
		m_DeviceInterfaceRegistered = TRUE;
		return TRUE;
	};

	VOID	unregisterDeviceInterface(UNICODE_STRING* InterfaceName)
	{
		if(isDeviceInterfaceRegistered())		
		{
			TRACE("Unregistering device interface...\n");	
			system->setDeviceInterfaceState(InterfaceName,FALSE);
		}
		m_DeviceInterfaceRegistered = FALSE;
	};

	virtual NTSTATUS setVendorName(const PCHAR Name,USHORT Length)
	{
		m_VendorNameLength = Length<MAXIMUM_ATTR_STRING_LENGTH? Length:MAXIMUM_ATTR_STRING_LENGTH;
		if(!m_VendorNameLength) return STATUS_INVALID_PARAMETER;
		memory->copy(m_VendorName, Name, m_VendorNameLength);
		return STATUS_SUCCESS;

	};
	virtual NTSTATUS getVendorName(PUCHAR Name,PUSHORT pLength)
	{
		USHORT Len = m_VendorNameLength<*pLength? m_VendorNameLength:*pLength;
		*pLength = Len;
		if(!Len)	return STATUS_INVALID_PARAMETER;
		memory->copy(Name, m_VendorName, Len);
		return STATUS_SUCCESS;
	};

	virtual NTSTATUS setDeviceType(const PCHAR Type,USHORT Length)
	{
		m_DeviceTypeLength = Length<MAXIMUM_ATTR_STRING_LENGTH? Length:MAXIMUM_ATTR_STRING_LENGTH;
		if(!m_DeviceTypeLength) return STATUS_INVALID_PARAMETER;
		memory->copy(m_DeviceType, Type, m_DeviceTypeLength);
		return STATUS_SUCCESS;
	};

	virtual NTSTATUS getDeviceType(PUCHAR Type,PUSHORT pLength)
	{
		USHORT Len = m_DeviceTypeLength<*pLength? m_DeviceTypeLength:*pLength;
		*pLength = Len;
		if(!Len)	return STATUS_INVALID_PARAMETER;
		memory->copy(Type, m_DeviceType, Len);
		return STATUS_SUCCESS;
	};

	// This is basic PnP part of driver.
	// It allows to add and remove device.
	// Specific PnP request should be reimplemented by clients...
	virtual NTSTATUS	createDeviceObjectByName(PDEVICE_OBJECT* ppFdo)
	{
		if(!ALLOCATED_OK(system)) return STATUS_INSUFFICIENT_RESOURCES;
		// By default we will create autogenerated name...
		// Specific implementations can overwrite the function to 
		// change the functionality.
		return system->createDevice(m_DriverObject,sizeof(CWDMDevice*),NULL,
							FILE_DEVICE_UNKNOWN,FILE_AUTOGENERATED_DEVICE_NAME,FALSE,ppFdo);
	};

	virtual NTSTATUS	registerDevicePowerPolicy()
	{	// By default all devices at startup are ON
		if(!ALLOCATED_OK(power)) return STATUS_INSUFFICIENT_RESOURCES;
		POWER_STATE state;
		state.DeviceState = PowerDeviceD0;
		power->declarePowerState(m_DeviceObject, DevicePowerState, state);

		if(m_PhysicalDeviceObject)
		{
			m_CurrentDevicePowerState = PowerDeviceD0;
			m_Idle = power->registerDeviceForIdleDetection(m_PhysicalDeviceObject,Idle_conservation,Idle_performance, PowerDeviceD3);
		}		
		return STATUS_SUCCESS;
	};
	
	virtual NTSTATUS	initializeInterruptSupport()
	{	
		// Here is where we can initialize our DPC (Deferred Procedure Call) object
		// that allows our interrupt service routine to request a DPC to finish handling
		// a device interrupt.
		// At default WDM device we do not do this.
		//interrupt->initializeDpcRequest(m_DeviceObject,&CALLBACK_FUNCTION(DpcForIsr));	
		return STATUS_SUCCESS;
	};

	NTSTATUS	add(PDRIVER_OBJECT DriverObject, PDEVICE_OBJECT pPdo)
	{
	NTSTATUS status;
	PDEVICE_OBJECT pFdo;
		if(!ALLOCATED_OK(system)) return STATUS_INSUFFICIENT_RESOURCES;
		TRACE("Add with Driver	%8.8lX,	pPDO %8.8lX\n",DriverObject, pPdo);

		// Init first our objects...
		m_DriverObject = DriverObject;
		m_PhysicalDeviceObject = pPdo;
		// create Fdo for the registered objects.
		// Clients can overwrite device object name and it's visibility.
		status = createDeviceObjectByName(&pFdo);
		if(!NT_SUCCESS(status))
		{
			TRACE("#### Failed to create physical device! Status %x\n",status);
			DISPOSE_OBJECT(m_DeviceObjectName);
			return status;
		}

		TRACE("		Device object was created  %8.8lX\n",pFdo);
		m_DeviceObject = pFdo;
		m_Added = TRUE;

		CLogger* logger = kernel->getLogger();

		if(pPdo)
		{
			m_pLowerDeviceObject = system->attachDevice(pFdo, pPdo);
			if(!m_pLowerDeviceObject)
			{
				TRACE("#### Failed to get lower device object...\n");
				if(ALLOCATED_OK(logger)) 
					logger->logEvent(GRCLASS_FAILED_TO_ADD_DEVICE,getSystemObject());
				system->deleteDevice(pFdo);
				return STATUS_NO_SUCH_DEVICE;
			}
		}
		else m_pLowerDeviceObject = NULL;

		
		initializeInterruptSupport();

		pFdo->Flags |= DO_BUFFERED_IO;
		pFdo->Flags |= DO_POWER_PAGABLE;
		pFdo->Flags &= ~DO_DEVICE_INITIALIZING;

		registerDevicePowerPolicy();
		TRACE("WDM device added...\n");
		return STATUS_SUCCESS;
	};

	VOID	remove()
	{
		if(!m_Added) return;
		TRACE("Removing WDM device...\n");
		// Wait untill we finished all activity at device
		releaseRemoveLockAndWait();

		// Remove device from our system
		TRACE("Unregistering device from kernel...\n");
		kernel->unregisterObject(getSystemObject());

		TRACE("Removing device object name...\n");
		if(m_DeviceObjectName) delete m_DeviceObjectName;
		m_DeviceObjectName = NULL;

		if(m_pLowerDeviceObject)
		{
			TRACE("Detaching device from system...\n");
			system->detachDevice(m_pLowerDeviceObject);
		}
		TRACE("WDM device removed...\n");

		// Tell our system - device removed...
		m_Added = FALSE;

		// Removing device from system could result in
		// requesting Unload() from system if the device was last registered device.
		// So, this call should be last call AFTER disposing the device.
	};

	virtual VOID onDeviceStop()
	{
		return;
	};


	NTSTATUS	forward(PIRP Irp, PIO_COMPLETION_ROUTINE Routine)
	{
	CIoPacket* IoPacket;
		// This function sends the current request
		// If completion routine is not set it will complete
		// the request by default(it means without doing anything special).
		TRACE("WDM forward()...\n");
		IoPacket = new (NonPagedPool) CIoPacket(Irp);
		if(!ALLOCATED_OK(IoPacket))
		{
			DISPOSE_OBJECT(IoPacket);
			return STATUS_INSUFFICIENT_RESOURCES;
		}

		IoPacket->copyCurrentStackToNext();
		if(Routine)	IoPacket->setCompletion(Routine);
		else        IoPacket->setDefaultCompletionFunction();
		NTSTATUS status = system->callDriver(getLowerDriver(),IoPacket->getIrpHandle());
		
		DISPOSE_OBJECT(IoPacket);
		return status;
	};
	// Send the current request to low level driver and wait for reply
	// Current IRP will not be completed, so we can process it and
	// complete later. 
	// See also description of send() function.
	NTSTATUS	forwardAndWait(PIRP Irp)
	{ // Send request to low level and wait for a reply
	CIoPacket* IoPacket;
	
		TRACE("WDM forwardAndWait()...\n");
		IoPacket = new (NonPagedPool) CIoPacket(Irp);
		if(!ALLOCATED_OK(IoPacket))
		{
			DISPOSE_OBJECT(IoPacket);
            Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
			return STATUS_INSUFFICIENT_RESOURCES; 
		}
		IoPacket->setCurrentStack();
		IoPacket->setStackDefaults();
		NTSTATUS status = system->callDriver(getLowerDriver(),IoPacket->getIrpHandle());
		if(status == STATUS_PENDING)
		{
			TRACE("Waiting for the bus driver to complete...\n");
			ASSERT(system->getCurrentIrql()<=DISPATCH_LEVEL);
			status = IoPacket->waitForCompletion();
			TRACE("Request completed with status %x\n",status);
		}

		DISPOSE_OBJECT(IoPacket);
		return status;
	};

	// WDM by default just forwards requests...
	virtual NTSTATUS   send(CIoPacket* Irp)
	{
		TRACE("WDM sendRequestToDevice()\n");
		if(Irp)	return forward(Irp->getIrpHandle(),NULL);
		else return STATUS_INVALID_PARAMETER;
	};

	virtual NTSTATUS   sendAndWait(CIoPacket* Irp)
	{
		TRACE("WDM sendRequestToDeviceAndWait()\n");
		if(Irp)	return forwardAndWait(Irp->getIrpHandle());
		else return STATUS_INVALID_PARAMETER;
	};

	// Define device interface functions
	virtual  NTSTATUS   write(PUCHAR pRequest,ULONG RequestLength)
	{
	CIoPacket* IoPacket;
		if(!pRequest || !RequestLength) return STATUS_INVALID_PARAMETER;
		IoPacket = new (NonPagedPool) CIoPacket(getLowerDriver()->StackSize);
		if(!ALLOCATED_OK(IoPacket))
		{
			DISPOSE_OBJECT(IoPacket);
			return STATUS_INSUFFICIENT_RESOURCES;
		}
		TRACE("IoPacket with device %x\n",getSystemObject());
		IoPacket->setTimeout(getCommandTimeout());
		IoPacket->buildStack(getSystemObject(),IRP_MJ_WRITE);
		IoPacket->setWriteLength(RequestLength);
		IoPacket->copyBuffer(pRequest,RequestLength);

		TRACE("WDM write()...\n");
		NTSTATUS status = send(IoPacket);
		TRACE("WDM write finished: %x\n", status);

		DISPOSE_OBJECT(IoPacket);
		return status;
	};
	
	virtual  NTSTATUS   writeAndWait(PUCHAR pRequest,ULONG RequestLength,PUCHAR pReply,ULONG* pReplyLength)
	{
	CIoPacket* IoPacket;
		if(!pRequest || !RequestLength || !pReply || !pReplyLength) return STATUS_INVALID_PARAMETER;
		IoPacket = new (NonPagedPool) CIoPacket(getLowerDriver()->StackSize);
		if(!ALLOCATED_OK(IoPacket))
		{
			DISPOSE_OBJECT(IoPacket);
			return STATUS_INSUFFICIENT_RESOURCES;
		}
		TRACE("IoPacket with device %x\n",getSystemObject());
		IoPacket->setTimeout(getCommandTimeout());
		IoPacket->buildStack(getSystemObject(),IRP_MJ_WRITE);
		IoPacket->setWriteLength(RequestLength);
		IoPacket->copyBuffer(pRequest,RequestLength);

		TRACE("WDM sendAndWait()...\n");
		NTSTATUS status = sendAndWait(IoPacket);
		TRACE("WDM writeAndWait finished: %x\n",status);
		if(!NT_SUCCESS(status))
		{
			*pReplyLength = 0;
			DISPOSE_OBJECT(IoPacket);
			return status;
		}

		*pReplyLength = (ULONG)IoPacket->getInformation();
		IoPacket->getSystemReply(pReply,*pReplyLength);
		//TRACE_BUFFER(pReply,*pReplyLength);
		DISPOSE_OBJECT(IoPacket);
		return status;
	};

	virtual  NTSTATUS   readAndWait(PUCHAR pRequest,ULONG RequestLength,PUCHAR pReply,ULONG* pReplyLength)
	{
	CIoPacket* IoPacket;
		if(!pRequest || !RequestLength || !pReply || !pReplyLength) return STATUS_INVALID_PARAMETER;
		IoPacket = new (NonPagedPool) CIoPacket(getLowerDriver()->StackSize);
		if(!ALLOCATED_OK(IoPacket))
		{
			DISPOSE_OBJECT(IoPacket);
			return STATUS_INSUFFICIENT_RESOURCES;
		}
		IoPacket->setTimeout(getCommandTimeout());
		IoPacket->buildStack(getSystemObject(),IRP_MJ_READ);
		IoPacket->setReadLength(RequestLength);
		IoPacket->copyBuffer(pRequest,RequestLength);
	
		TRACE("WDM sendAndWait()...\n");
		NTSTATUS status = sendAndWait(IoPacket);
		TRACE("WDM sendAndWait finished: %x\n",status);
		if(!NT_SUCCESS(status))
		{
			*pReplyLength = 0;
			DISPOSE_OBJECT(IoPacket);
			return status;
		}

		*pReplyLength = (ULONG)IoPacket->getInformation();
		IoPacket->getSystemReply(pReply,*pReplyLength);

		TRACE_BUFFER(pReply,*pReplyLength);
		DISPOSE_OBJECT(IoPacket);
		return status;
	};

	NTSTATUS synchronizeDevicePowerState()
	{
		if (m_CurrentDevicePowerState!=PowerDeviceD0) 
		{
			NTSTATUS status;
			TRACE("RESTORING DEVICE POWER ON from state %d!\n",m_CurrentDevicePowerState);
			status = sendDeviceSetPower(PowerDeviceD0,TRUE);
			if(!NT_SUCCESS(status))
			{
				TRACE("FAILED TO SET POWER ON DEVICE STATE!\n");
				return status;
			}
		}
		return STATUS_SUCCESS;
	}

	NTSTATUS sendDeviceSetPower(DEVICE_POWER_STATE devicePower, BOOLEAN wait)
	{// SendDeviceSetPower
	POWER_STATE state;
	NTSTATUS status;

		state.DeviceState = devicePower;
		if (wait)
		{// synchronous operation
			KEVENT Event;
			event->initialize(&Event, NotificationEvent, FALSE);
			POWER_CONTEXT context = {&Event};

			status = power->requestPowerIrp(getPhysicalObject(), IRP_MN_SET_POWER, state,
				(PREQUEST_POWER_COMPLETE) onSendDeviceSetPowerComplete, &context, NULL);
			if (status == STATUS_PENDING)
			{
				event->waitForSingleObject(&Event, Executive, KernelMode, FALSE, NULL);
				status = context.status;
			}
		}// synchronous operation
		else
			status = power->requestPowerIrp(getPhysicalObject(), IRP_MN_SET_POWER, 
						state, NULL, NULL, NULL);
		
		return status;
	}// SendDeviceSetPower
	// These functions define default interface with system.
	// Clients should redefine them if they would like to have
	// specific functionality.
	virtual NTSTATUS pnpRequest(IN PIRP irp){return PnP_Default(irp);};
	virtual NTSTATUS powerRequest(PIRP irp) {return power_Default(irp);};
	
	// By default we allow user to get connection with device
	virtual NTSTATUS open(PIRP irp) {return completeDeviceRequest(irp, STATUS_SUCCESS, 0); };//Create
    virtual NTSTATUS close(PIRP irp){return completeDeviceRequest(irp, STATUS_SUCCESS, 0); };

	virtual NTSTATUS read(PIRP irp) { return device_Default(irp); };
    virtual NTSTATUS write(PIRP irp) { return device_Default(irp); };

    virtual NTSTATUS deviceControl(PIRP irp) { return device_Default(irp);};
    
    virtual NTSTATUS cleanup(PIRP irp) { return device_Default(irp); };
    virtual NTSTATUS flush(PIRP irp) { return device_Default(irp); };
	// Standard system startIo
	// Actually we do not use it for now. 
	// Instead we have our own synchronization facilities.
	virtual VOID	 startIo(PIRP irp){};
//---------------------------------------------------------------------------//
//					SYNCHRONIZATION FACILITIES								 //
//---------------------------------------------------------------------------//
// To make synchronization at the driver we have to store and make pending
// all our requests.
// Specific devices should set specific thread which will start all pending Irp. 	
//---------------------------------------------------------------------------//
	// CALLBACK FUNCTION:
	// This function will not only complete current Irp but also will dispose
	// corresponding IoRequest if any was pending at driver.
#pragma LOCKEDCODE
	virtual  VOID	 cancelPendingIrp(PIRP Irp)
	{
	KIRQL ioIrql;
		// 1.
		// We keep pending Irp inside list of IoRequests.
		// So we do not need to warry about removing Irp from a queue...
		// 2.
		// As soon as IoRequest started, we do not allow to cancel it.
		// So, in this case this function will not be called and it is responsibility
		// of the driver to finish (or cancel) active IoRequest.
		// It means this function should not warry about active (and removed from our queue)
		// IoRequests. But it has to warry about not yet started requests...

		
		TRACE("		 CANCELLING IRP %8.8lX...\n", Irp);
		// Release cancel spin lock if somebody own it...
		lock->releaseCancelSpinLock(Irp->CancelIrql);

		// Get our own spin lock in case somebody desided to cancel this Irp 
		lock->acquireCancelSpinLock(&ioIrql);
		// Reset our cancel routine to prevent it being called... 
		irp->setCancelRoutine(Irp, NULL);

		// If Irp was on the queue - remove IoRequest from queue...
		if(m_IoRequests)
		{
			CPendingIRP* IrpReq = m_IoRequests->getFirst();
			while (IrpReq) 
			{
				if(IrpReq->Irp == Irp)
				{	// We found our Irp.
					m_IoRequests->remove(IrpReq);
					TRACE("		IO REQUEST WAS DISPOSED...\n");
					IrpReq->dispose();
					break;
				}
				IrpReq = m_IoRequests->getNext(IrpReq);
			}
		}


		if(m_OpenSessionIrp == Irp)
		{
			TRACE("		OPEN SESSION IRP WAS CANCELLED...\n");
			m_OpenSessionIrp = NULL;
		}

		// Complete Irp as canceled...
		Irp->IoStatus.Status = STATUS_CANCELLED;
		Irp->IoStatus.Information = 0;
		// Release our spin lock...
		lock->releaseCancelSpinLock(ioIrql);
		TRACE("		IRP %8.8lX WAS CANCELLED...\n", Irp);
		irp->completeRequest(Irp, IO_NO_INCREMENT);
	};
#pragma PAGEDCODE

	virtual CLinkedList<CPendingIRP>* getIoRequestsQueue()
	{	
        return m_IoRequests;
	};


	virtual NTSTATUS makeRequestPending(PIRP Irp_request,PDEVICE_OBJECT toDeviceObject,PENDING_REQUEST_TYPE Type)
	{
	KIRQL OldIrql;

		lock->acquireCancelSpinLock(&OldIrql);
		if (Irp_request->Cancel) 
		{            
			TRACE("		<<<<<< IO REQUEST CANCELLED... %8.8lX>>>>>>\n",Irp_request);
			lock->releaseCancelSpinLock(OldIrql);
			return STATUS_CANCELLED;
		} 
		else 
		{
			TRACE("		<<<<<< IO REQUEST PENDING %8.8lX>>>>>>\n",Irp_request);

			CPendingIRP* IrpReq = new (NonPagedPool) CPendingIRP(Irp_request,Type,toDeviceObject);
			if(!IrpReq)
			{
				lock->releaseCancelSpinLock(OldIrql);
				TRACE("ERROR! FAILED TO ALLOCATE IoRequest. LOW ON MEMORY!\n");
				return completeDeviceRequest(Irp_request,STATUS_INSUFFICIENT_RESOURCES,0);
			}

			Irp_request->IoStatus.Information=0;
			Irp_request->IoStatus.Status=STATUS_PENDING;
			irp->setCancelRoutine(Irp_request, CALLBACK_FUNCTION(cancelPendingIrp));
			lock->releaseCancelSpinLock(OldIrql);
			irp->markPending(Irp_request); 
			m_IoRequests->New(IrpReq);
			return STATUS_PENDING;
		}
	};

	// Cancel current pending IO request 
	virtual NTSTATUS cancelPendingRequest(CPendingIRP* IrpReq)
	{
		// Next function will remove and dispose our request...
		cancelPendingIrp(IrpReq->Irp);
		return STATUS_CANCELLED;
	};
	
	// Cancel all pending IO requests
	virtual NTSTATUS cancelAllPendingRequests()
	{
		// Next function will remove and dispose our request...
		if(m_IoRequests)
		{
			CPendingIRP* IrpReqNext;
			CPendingIRP* IrpReq = m_IoRequests->getFirst();
			while (IrpReq) 
			{
				IrpReqNext = m_IoRequests->getNext(IrpReq);
				cancelPendingRequest(IrpReq);// This  call will dispose request...
				IrpReq = IrpReqNext;
			}
		}
		if(m_OpenSessionIrp)	cancelPendingIrp(m_OpenSessionIrp);
		return STATUS_CANCELLED;
	};


	// Checks if request queue is empty and if it is NOT - starts next request...
	// This function will be called by the Irp processing thread.
	virtual NTSTATUS startNextPendingRequest()
	{
		TRACE("		startNextPendingRequest() was called...\n");
		if (!m_IoRequests->IsEmpty())
		{	
		KIRQL OldIrql;
		CDevice* device;
		NTSTATUS status;
			CPendingIRP* IrpReq	=	m_IoRequests->removeHead();
			if(!IrpReq) return STATUS_INVALID_PARAMETER;
			
			lock->acquireCancelSpinLock(&OldIrql);
			// Now Irp can not be canceled!
			irp->setCancelRoutine(IrpReq->Irp, NULL);
			if (IrpReq->Irp->Cancel) 
			{            
				lock->releaseCancelSpinLock(OldIrql);
				// Current Irp was already canceled,
				// Cancel function will be called shortly.
				// So just forget about current Irp.
				return STATUS_SUCCESS;;
			} 
			lock->releaseCancelSpinLock(OldIrql);
	
			device = (CDevice*)IrpReq->DeviceObject->DeviceExtension;
			// Call device specific startIo function...
			TRACE("		Device startIoRequest() was called...\n");
			if(device) status = device->startIoRequest(IrpReq);
			else	   status = STATUS_INVALID_DEVICE_STATE;
			return status;
		}
		return STATUS_SUCCESS;
	};

	virtual NTSTATUS ThreadRoutine()
	{
	//NTSTATUS status;
		//if(!NT_SUCCESS(status = waitForIdleAndBlock())) return status;
		// If somebody inserted pending request - dispatch it...
		// It will call specific child device startIoRequest().
		// It is up to that device how to handle it.
		// If child device is busy - it can insert this request into
		// child device request queue again and process it later...
		startNextPendingRequest();
		//setIdle();
		return STATUS_SUCCESS;
	};	


	// Device specific function which processes pending requests...
	// It will be redefined by specific devices.
	// This function always should be virtual because
	// we expect specific device behaviour...
	virtual NTSTATUS startIoRequest(CPendingIRP* IoReq) 
	{ 
		// Default startIo just cancel current request.
		// IoReq will be disposed...
		if(IoReq)
		{
			cancelPendingRequest(IoReq);
		}
		return STATUS_SUCCESS;
	};
};

#endif //If not defined
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\gempc430\wdmint.h ===
// Gemplus (C) 1999
// Version 1.0
// Author: Sergey Ivanov
// Date of creation - 18.05.1999
// Change log:
//

#ifndef WDM_INT_INT
#define WDM_INT_INT
#include "generic.h"
#include "int.h"

#pragma PAGEDCODE
class CWDMInterrupt : public CInterrupt
{
public:
	NTSTATUS m_Status;
	SAFE_DESTRUCTORS();
	virtual VOID dispose(VOID){self_delete();};
protected:
	CWDMInterrupt(){m_Status = STATUS_SUCCESS;};
	virtual ~CWDMInterrupt(){};
public:
	static CInterrupt*  create(VOID);

	virtual NTSTATUS	connect(OUT PKINTERRUPT *InterruptObject,
							IN PKSERVICE_ROUTINE ServiceRoutine,
							IN PVOID ServiceContext,
							IN PKSPIN_LOCK SpinLock OPTIONAL,
							IN ULONG Vector,
							IN KIRQL Irql,
							IN KIRQL SynchronizeIrql,
							IN KINTERRUPT_MODE InterruptMode,
							IN BOOLEAN ShareVector,
							IN KAFFINITY ProcessorEnableMask,
							IN BOOLEAN FloatingSave
							);

	virtual VOID		disconnect(IN PKINTERRUPT InterruptObject);
	virtual VOID		initializeDpcRequest(IN PDEVICE_OBJECT pFdo,IN PDEFERRED_FUNCTION DpcForIsr);
	virtual BOOLEAN		synchronizeExecution (	IN PKINTERRUPT Interrupt,
												IN PKSYNCHRONIZE_ROUTINE SynchronizeRoutine,    
												IN PVOID SynchronizeContext);         

};	

#endif//CInterrupt
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\gempc430\wdmint.cpp ===
#include "wdmint.h"

#pragma PAGEDCODE
CInterrupt* CWDMInterrupt::create(VOID)
{ return new (NonPagedPool) CWDMInterrupt; }

#pragma PAGEDCODE
NTSTATUS	CWDMInterrupt::connect(OUT PKINTERRUPT *InterruptObject,
					IN PKSERVICE_ROUTINE ServiceRoutine,
					IN PVOID ServiceContext,
					IN PKSPIN_LOCK SpinLock OPTIONAL,
					IN ULONG Vector,
					IN KIRQL Irql,
					IN KIRQL SynchronizeIrql,
					IN KINTERRUPT_MODE InterruptMode,
					IN BOOLEAN ShareVector,
					IN KAFFINITY ProcessorEnableMask,
					IN BOOLEAN FloatingSave	)
{

	return	::IoConnectInterrupt(InterruptObject,ServiceRoutine,ServiceContext,
						SpinLock,Vector,Irql,SynchronizeIrql,
						InterruptMode,ShareVector,ProcessorEnableMask,FloatingSave);
}

#pragma PAGEDCODE
VOID		CWDMInterrupt::disconnect(IN PKINTERRUPT InterruptObject)
{
	::IoDisconnectInterrupt(InterruptObject);
}


#pragma PAGEDCODE
VOID CWDMInterrupt::initializeDpcRequest(IN PDEVICE_OBJECT DeviceObject,IN PDEFERRED_FUNCTION DpcForIsr)
{
	IoInitializeDpcRequest(DeviceObject, DpcForIsr);
	//::KeInitializeDpc( &(DeviceObject)->Dpc,DpcForIsr,NULL);
}

#pragma PAGEDCODE
BOOLEAN		CWDMInterrupt::synchronizeExecution (IN PKINTERRUPT Interrupt,
									IN PKSYNCHRONIZE_ROUTINE SynchronizeRoutine,    
									IN PVOID SynchronizeContext)
{
	return ::KeSynchronizeExecution (Interrupt,SynchronizeRoutine,SynchronizeContext);         
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\gempc430\wdmevent.h ===
#ifndef WDM_EV_INT
#define WDM_EV_INT
#include "generic.h"
#include "event.h"

#pragma PAGEDCODE
class CWDMEvent : public CEvent
{
public:
	NTSTATUS m_Status;
	SAFE_DESTRUCTORS();
	virtual VOID dispose(VOID){self_delete();};
protected:
	CWDMEvent(){m_Status = STATUS_SUCCESS;};
	virtual ~CWDMEvent(){};
public:
	static CEvent*  create(VOID);
	
	virtual VOID		initialize(IN PRKEVENT Event,IN EVENT_TYPE Type,IN BOOLEAN State);
	virtual VOID		clear(PRKEVENT Event);
	virtual LONG		reset(PRKEVENT Event);
	virtual LONG		set(PRKEVENT Event,IN KPRIORITY Increment,IN BOOLEAN Wait);

	virtual NTSTATUS	waitForSingleObject (PVOID Object,
							KWAIT_REASON WaitReason,IN KPROCESSOR_MODE WaitMode,
							BOOLEAN Alertable,
							PLARGE_INTEGER Timeout);
	virtual NTSTATUS	waitForMultipleObjects(ULONG Count,
							PVOID Object[],
							WAIT_TYPE WaitType,
							KWAIT_REASON WaitReason,
							KPROCESSOR_MODE WaitMode,
							BOOLEAN Alertable,
							PLARGE_INTEGER Timeout,
							PKWAIT_BLOCK WaitBlockArray);

};	

#endif//WDM_EV_INT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\gempc430\wdmirp.h ===
// Gemplus (C) 1999
// Version 1.0
// Author: Sergey Ivanov
// Date of creation - 18.05.1999
// Change log:
//

#ifndef WDM_IRP_INT
#define WDM_IRP_INT
#include "generic.h"
#include "irp.h"

#pragma PAGEDCODE
class CWDMIrp : public CIrp
{
public:
	NTSTATUS m_Status;
	SAFE_DESTRUCTORS();
	virtual VOID dispose(VOID){self_delete();};
protected:
	CWDMIrp(){m_Status = STATUS_SUCCESS;};
	virtual ~CWDMIrp(){};
public:
	static  CIrp*  create(VOID);

	virtual PIRP		allocate(CCHAR StackSize,BOOLEAN ChargeQuota);
	virtual	VOID		initialize(PIRP Irp,USHORT PacketSize,CCHAR StackSize);
	virtual	USHORT		sizeOfIrp(IN CCHAR StackSize);

	virtual VOID		free(PIRP Irp);
	virtual PIRP		buildDeviceIoControlRequest(
						   IN ULONG IoControlCode,
						   IN PDEVICE_OBJECT DeviceObject,
						   IN PVOID InputBuffer OPTIONAL,
						   IN ULONG InputBufferLength,
						   IN OUT PVOID OutputBuffer OPTIONAL,
						   IN ULONG OutputBufferLength,
						   IN BOOLEAN InternalDeviceIoControl,
						   IN PKEVENT Event,
						   OUT PIO_STATUS_BLOCK IoStatusBlock
						   );

	virtual PIRP		buildSynchronousFsdRequest(
							IN ULONG MajorFunction,
							IN PDEVICE_OBJECT DeviceObject,
							IN OUT PVOID Buffer OPTIONAL,
							IN ULONG Length OPTIONAL,
							IN PLARGE_INTEGER StartingOffset OPTIONAL,
							IN PKEVENT Event,
							OUT PIO_STATUS_BLOCK IoStatusBlock
							);

	virtual PIO_STACK_LOCATION	getCurrentStackLocation(PIRP Irp);
	virtual PIO_STACK_LOCATION	getNextStackLocation(PIRP Irp);
	virtual VOID		skipCurrentStackLocation(PIRP Irp);
	virtual VOID		setNextStackLocation(IN PIRP Irp);
	virtual VOID		markPending(PIRP Irp);
	virtual VOID		copyCurrentStackLocationToNext(PIRP Irp);
	virtual VOID		setCompletionRoutine(PIRP Irp, PIO_COMPLETION_ROUTINE Routine, 
					PVOID Context, BOOLEAN Success, BOOLEAN Error, BOOLEAN Cancel );
	virtual PDRIVER_CANCEL	setCancelRoutine(PIRP Irp, PDRIVER_CANCEL NewCancelRoutine );
	virtual VOID		completeRequest(PIRP Irp,CCHAR PriorityBoost);
	virtual VOID		startPacket(PDEVICE_OBJECT DeviceObject,PIRP Irp,PULONG Key,PDRIVER_CANCEL CancelFunction);
	virtual VOID		startNextPacket(PDEVICE_OBJECT DeviceObject,BOOLEAN Cancelable);

	// Should it go to interrupt??
	virtual VOID		requestDpc(PDEVICE_OBJECT DeviceObject,PIRP Irp,PVOID Context);

	virtual VOID		cancel(PIRP Irp);
};	

#endif//WDMIRP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\gempc430\wdmevent.cpp ===
#include "wdmevent.h"

#pragma PAGEDCODE
CEvent* CWDMEvent::create(VOID)
{ return new (NonPagedPool) CWDMEvent; }

#pragma PAGEDCODE
VOID	CWDMEvent::initialize(IN PRKEVENT Event,IN EVENT_TYPE Type,IN BOOLEAN State)
{
	::KeInitializeEvent(Event,Type,State);
}


#pragma PAGEDCODE
VOID	CWDMEvent::clear(IN PRKEVENT Event)
{
	::KeClearEvent (Event);
}

#pragma PAGEDCODE
LONG	CWDMEvent::reset(IN PRKEVENT Event)
{
	return ::KeResetEvent (Event);
}

#pragma PAGEDCODE
LONG	CWDMEvent::set(IN PRKEVENT Event,IN KPRIORITY Increment,IN BOOLEAN Wait)
{
	return ::KeSetEvent (Event,Increment,Wait);
}

#pragma PAGEDCODE
NTSTATUS	CWDMEvent::waitForSingleObject (IN PVOID Object,
						IN KWAIT_REASON WaitReason,IN KPROCESSOR_MODE WaitMode,
						IN BOOLEAN Alertable,
						IN PLARGE_INTEGER Timeout OPTIONAL)
{
	ASSERT(KeGetCurrentIrql()<=DISPATCH_LEVEL);
	return ::KeWaitForSingleObject (Object,WaitReason,WaitMode,Alertable,Timeout);
}

#pragma PAGEDCODE
NTSTATUS	CWDMEvent::waitForMultipleObjects(ULONG Count,
						PVOID Object[],
						WAIT_TYPE WaitType,
						KWAIT_REASON WaitReason,
						KPROCESSOR_MODE WaitMode,
						BOOLEAN Alertable,
						PLARGE_INTEGER Timeout,
						PKWAIT_BLOCK WaitBlockArray)
{
	ASSERT(KeGetCurrentIrql()<=DISPATCH_LEVEL);
	return ::KeWaitForMultipleObjects(Count,Object,WaitType,
							WaitReason,	WaitMode,Alertable,
							Timeout,WaitBlockArray);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\gempc430\wdmirp.cpp ===
#include "wdmirp.h"

#pragma PAGEDCODE
CIrp* CWDMIrp::create(VOID)
{ return new (NonPagedPool) CWDMIrp; }

#pragma PAGEDCODE
PIRP	CWDMIrp::allocate(IN CCHAR StackSize,IN BOOLEAN ChargeQuota)
{
	return ::IoAllocateIrp(StackSize,ChargeQuota);
}

#pragma PAGEDCODE
VOID	CWDMIrp::initialize(PIRP Irp,USHORT PacketSize,CCHAR StackSize)
{
	::IoInitializeIrp(Irp,PacketSize,StackSize);
}

#pragma PAGEDCODE
USHORT	CWDMIrp::sizeOfIrp(IN CCHAR StackSize)
{
	return IoSizeOfIrp(StackSize);
}

#pragma PAGEDCODE
VOID	CWDMIrp::free(IN PIRP Irp)
{
	::IoFreeIrp(Irp);
}

#pragma PAGEDCODE
VOID	CWDMIrp::cancel(IN PIRP Irp)
{
	::IoCancelIrp(Irp);
}

#pragma PAGEDCODE
PIO_STACK_LOCATION	CWDMIrp::getCurrentStackLocation(IN PIRP Irp)
{
	return IoGetCurrentIrpStackLocation(Irp);
}

#pragma PAGEDCODE
PIO_STACK_LOCATION	CWDMIrp::getNextStackLocation(IN PIRP Irp)
{
	return IoGetNextIrpStackLocation(Irp);
}

#pragma PAGEDCODE
VOID	CWDMIrp::skipCurrentStackLocation(IN PIRP Irp)
{
	IoSkipCurrentIrpStackLocation(Irp);
}

#pragma PAGEDCODE
VOID		CWDMIrp::copyCurrentStackLocationToNext(IN PIRP Irp)
{
	IoCopyCurrentIrpStackLocationToNext(Irp);
}

#pragma PAGEDCODE
VOID		CWDMIrp::setNextStackLocation(IN PIRP Irp)
{
	IoSetNextIrpStackLocation(Irp);
}


#pragma PAGEDCODE
VOID	CWDMIrp::markPending(IN PIRP Irp)
{
	IoMarkIrpPending(Irp);
}



#pragma PAGEDCODE
PDRIVER_CANCEL	CWDMIrp::setCancelRoutine(IN PIRP Irp, PDRIVER_CANCEL NewCancelRoutine )
{
	return IoSetCancelRoutine(Irp, NewCancelRoutine);
}

#pragma PAGEDCODE
VOID	CWDMIrp::startPacket(IN PDEVICE_OBJECT DeviceObject,IN PIRP Irp,IN PULONG Key, IN PDRIVER_CANCEL CancelFunction)
{
	::IoStartPacket(DeviceObject,Irp,Key,CancelFunction);
}

#pragma PAGEDCODE
VOID	CWDMIrp::startNextPacket(IN PDEVICE_OBJECT DeviceObject,IN BOOLEAN Cancelable)
{
	::IoStartNextPacket(DeviceObject,Cancelable);
}

#pragma PAGEDCODE
VOID	CWDMIrp::completeRequest(IN PIRP Irp,IN CCHAR PriorityBoost)
{
	IoCompleteRequest(Irp,PriorityBoost);
}

#pragma PAGEDCODE
VOID	CWDMIrp::requestDpc(IN PDEVICE_OBJECT DeviceObject,IN PIRP Irp,PVOID Context)
{
	IoRequestDpc(DeviceObject,Irp,Context);
}

#pragma PAGEDCODE
VOID	CWDMIrp::setCompletionRoutine( IN PIRP Irp, PIO_COMPLETION_ROUTINE Routine, 
				PVOID Context, BOOLEAN Success, BOOLEAN Error, BOOLEAN Cancel )
{
	IoSetCompletionRoutine(Irp,Routine,Context,Success,Error,Cancel);
}


#pragma PAGEDCODE
PIRP	CWDMIrp::buildDeviceIoControlRequest(
					   IN ULONG IoControlCode,
					   IN PDEVICE_OBJECT DeviceObject,
					   IN PVOID InputBuffer OPTIONAL,
					   IN ULONG InputBufferLength,
					   IN OUT PVOID OutputBuffer OPTIONAL,
					   IN ULONG OutputBufferLength,
					   IN BOOLEAN InternalDeviceIoControl,
					   IN PKEVENT Event,
					   OUT PIO_STATUS_BLOCK IoStatusBlock
					   )
{
	return IoBuildDeviceIoControlRequest(IoControlCode,
       DeviceObject,
       InputBuffer,
       InputBufferLength,
       OutputBuffer,
       OutputBufferLength,
       InternalDeviceIoControl,
       Event,
       IoStatusBlock
       );
}


#pragma PAGEDCODE
PIRP	CWDMIrp::buildSynchronousFsdRequest(
				IN ULONG MajorFunction,
				IN PDEVICE_OBJECT DeviceObject,
				IN OUT PVOID Buffer OPTIONAL,
				IN ULONG Length OPTIONAL,
				IN PLARGE_INTEGER StartingOffset OPTIONAL,
				IN PKEVENT Event,
				OUT PIO_STATUS_BLOCK IoStatusBlock
				)
{
	return IoBuildSynchronousFsdRequest(MajorFunction,
			DeviceObject, Buffer, Length, StartingOffset, Event, IoStatusBlock);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\gempc430\wdmlock.cpp ===
#include "wdmlock.h"

#pragma PAGEDCODE
CLock* CWDMLock::create(VOID)
{ return new (NonPagedPool) CWDMLock; }

#pragma PAGEDCODE
VOID	CWDMLock::initializeSpinLock(PKSPIN_LOCK SpinLock)
{
	  KeInitializeSpinLock(SpinLock);
}

#pragma PAGEDCODE
VOID	CWDMLock::acquireSpinLock(PKSPIN_LOCK SpinLock, PKIRQL oldIrql)
{
	  KeAcquireSpinLock(SpinLock,oldIrql);
}

#pragma PAGEDCODE
VOID	CWDMLock::releaseSpinLock(PKSPIN_LOCK SpinLock, KIRQL oldIrql)
{
	  KeReleaseSpinLock(SpinLock,oldIrql);
}

#pragma PAGEDCODE
VOID	CWDMLock::acquireCancelSpinLock(PKIRQL Irql)
{
	::IoAcquireCancelSpinLock(Irql);
}

#pragma PAGEDCODE
VOID	CWDMLock::releaseCancelSpinLock(KIRQL Irql)
{
	::IoReleaseCancelSpinLock(Irql);
}


#pragma PAGEDCODE
LONG	CWDMLock::interlockedIncrement(IN PLONG  Addend)
{
	return ::InterlockedIncrement(Addend);
}

#pragma PAGEDCODE
LONG	CWDMLock::interlockedDecrement(IN PLONG  Addend)
{
	return ::InterlockedDecrement(Addend);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\gempc430\wdmlock.h ===
// Gemplus (C) 1999
// Version 1.0
// Author: Sergey Ivanov
// Date of creation - 18.05.1999
// Change log:
//
#ifndef WDM_LOCK_INT
#define WDM_LOCK_INT
#include "generic.h"
#include "lock.h"

#pragma PAGEDCODE
class CWDMLock : public CLock
{
public:
	NTSTATUS m_Status;
	SAFE_DESTRUCTORS();
	virtual VOID dispose(VOID){self_delete();};
protected:
	CWDMLock(){m_Status = STATUS_SUCCESS;};
	virtual ~CWDMLock(){};
public:
	static  CLock*  create();

	virtual VOID	initializeSpinLock(PKSPIN_LOCK SpinLock);
	virtual VOID	acquireSpinLock(PKSPIN_LOCK SpinLock, PKIRQL oldIrql);
	virtual VOID	releaseSpinLock(PKSPIN_LOCK SpinLock, KIRQL oldIrql);
	virtual VOID	acquireCancelSpinLock(PKIRQL Irql);
	virtual VOID	releaseCancelSpinLock(KIRQL Irql);
	virtual LONG	interlockedIncrement(IN PLONG  Addend);
	virtual LONG	interlockedDecrement(IN PLONG  Addend);

};	

#endif//CWDMLock
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\gempc430\wdmlog.h ===
#ifndef __WDM_LOG__
#define __WDM_LOG__
#include "logger.h"

#pragma PAGEDCODE
class CWDMLogger : public CLogger
{
public:
	NTSTATUS m_Status;
	SAFE_DESTRUCTORS();
	virtual VOID dispose(VOID);
private:
	PWSTR m_LoggerName;
protected:
	CWDMLogger();
public:
	CWDMLogger(PWSTR LoggerName);
	virtual ~CWDMLogger();
	static CLogger* create(VOID);

	virtual VOID logEvent(NTSTATUS ErrorCode, PDEVICE_OBJECT fdo);
};

#endif//LOGGER
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\gempc430\wdmmem.cpp ===
#include "wdmmem.h"

#pragma PAGEDCODE
CMemory* CWDMMemory::create(VOID)
{ return new (NonPagedPool) CWDMMemory; }

#pragma PAGEDCODE
VOID*	CWDMMemory::allocate(IN POOL_TYPE PoolType,IN SIZE_T NumberOfBytes)
{
	if(!NumberOfBytes) return NULL;
	//return ::ExAllocatePool(PoolType,NumberOfBytes);
	return ::ExAllocatePoolWithTag(PoolType,NumberOfBytes,'_GRU');
}

#pragma PAGEDCODE
VOID	CWDMMemory::zero(IN PVOID pMem,IN SIZE_T size)
{
	::RtlZeroMemory(pMem,size);
}

#pragma PAGEDCODE
VOID	CWDMMemory::free(IN PVOID pMem)
{
	::ExFreePool((PVOID)pMem);
}

#pragma PAGEDCODE
VOID	CWDMMemory::copy(IN VOID UNALIGNED *Destination,IN CONST VOID UNALIGNED *Source, IN SIZE_T Length)
{
	::RtlCopyMemory(Destination,Source,Length);
}

#pragma PAGEDCODE
PVOID CWDMMemory::mapIoSpace(IN PHYSICAL_ADDRESS PhysicalAddress,IN SIZE_T NumberOfBytes,IN MEMORY_CACHING_TYPE CacheType)
{
	return ::MmMapIoSpace(PhysicalAddress,NumberOfBytes,CacheType);
}

#pragma PAGEDCODE
VOID CWDMMemory::unmapIoSpace(IN PVOID BaseAddress,IN SIZE_T NumberOfBytes)
{
	::MmUnmapIoSpace (BaseAddress,NumberOfBytes);
}

#pragma PAGEDCODE
VOID	CWDMMemory::set(IN VOID UNALIGNED *Destination,IN SIZE_T Length,LONG Fill)
{
	::RtlFillMemory(Destination,Length,(UCHAR)Fill);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\gempc430\wdmmem.h ===
// Gemplus (C) 1999
// Version 1.0
// Author: Sergey Ivanov
// Date of creation - 18.05.1999
// Change log:

#ifndef WDM_MEM_INT
#define WDM_MEM_INT
#include "generic.h"
#include "memory.h"

#pragma PAGEDCODE
class CWDMMemory : public CMemory
{
public:
	NTSTATUS m_Status;
	SAFE_DESTRUCTORS();
	virtual VOID dispose(VOID){self_delete();};
protected:
	CWDMMemory(){m_Status = STATUS_SUCCESS;};
	virtual ~CWDMMemory(){};
public:
	static  CMemory*  create(VOID);
	virtual PVOID		allocate(IN POOL_TYPE PoolType,IN SIZE_T NumberOfBytes);
	virtual VOID		zero(IN PVOID pMem,IN SIZE_T size);
	virtual VOID		free(IN PVOID pMem);
	virtual VOID		copy(IN VOID UNALIGNED *Destination,IN CONST VOID UNALIGNED *Source, IN SIZE_T Length);

	virtual PVOID		mapIoSpace(IN PHYSICAL_ADDRESS PhysicalAddress,IN SIZE_T NumberOfBytes,IN MEMORY_CACHING_TYPE CacheType);
	virtual VOID		unmapIoSpace(IN PVOID BaseAddress,IN SIZE_T NumberOfBytes);
	virtual VOID		set(IN VOID UNALIGNED *Destination,IN SIZE_T Length,LONG Fill);

};	

#endif//MEMORY
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\gempc430\wdmpower.h ===
// Gemplus (C) 1999
// Version 1.0
// Author: Sergey Ivanov
// Date of creation - 18.05.1999
// Change log:
//
#ifndef WDM_PWR_INT
#define WDM_PWR_INT
#include "generic.h"
#include "power.h"

#pragma PAGEDCODE
class CWDMPower : public CPower
{
public:
	NTSTATUS m_Status;
	SAFE_DESTRUCTORS();
	virtual VOID dispose(VOID){self_delete();};
protected:
	CWDMPower(){m_Status = STATUS_SUCCESS;};
	virtual ~CWDMPower(){};
public:
	static CPower*  create(VOID);

	virtual PULONG		registerDeviceForIdleDetection (
							IN PDEVICE_OBJECT     DeviceObject,
							IN ULONG              ConservationIdleTime,
							IN ULONG              PerformanceIdleTime,
							IN DEVICE_POWER_STATE State
							);

	virtual POWER_STATE	declarePowerState(IN PDEVICE_OBJECT   DeviceObject,IN POWER_STATE_TYPE Type,IN POWER_STATE State);

	virtual VOID		startNextPowerIrp(IN PIRP Irp);
	virtual VOID		skipCurrentStackLocation(PIRP Irp);

	
	virtual NTSTATUS	callPowerDriver (IN PDEVICE_OBJECT DeviceObject,IN OUT PIRP Irp);
	virtual VOID		setPowerDeviceBusy(PULONG	IdlePointer);
	virtual NTSTATUS	requestPowerIrp(
						IN PDEVICE_OBJECT DeviceObject,
						IN UCHAR MinorFunction,
						IN POWER_STATE PowerState,
						IN PREQUEST_POWER_COMPLETE CompletionFunction,
						IN PVOID Context,
						OUT PIRP *Irp OPTIONAL);
};	

#endif//POWER
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\gempc430\wdmpower.cpp ===
#include "wdmpower.h"

#pragma PAGEDCODE
CPower* CWDMPower::create(VOID)
{ return new (NonPagedPool) CWDMPower; }

#pragma PAGEDCODE
PULONG		CWDMPower::registerDeviceForIdleDetection (
						IN PDEVICE_OBJECT     DeviceObject,
						IN ULONG              ConservationIdleTime,
						IN ULONG              PerformanceIdleTime,
						IN DEVICE_POWER_STATE State	)
{
	return	::PoRegisterDeviceForIdleDetection (DeviceObject,
				ConservationIdleTime,PerformanceIdleTime,State);
}

#pragma PAGEDCODE
POWER_STATE	CWDMPower::declarePowerState(IN PDEVICE_OBJECT DeviceObject,IN POWER_STATE_TYPE Type,IN POWER_STATE State)
{
	return ::PoSetPowerState(DeviceObject,Type,State);
}


#pragma PAGEDCODE
VOID		CWDMPower::startNextPowerIrp(IN PIRP Irp)
{
	::PoStartNextPowerIrp(Irp);
}

#pragma PAGEDCODE
NTSTATUS		CWDMPower::callPowerDriver (IN PDEVICE_OBJECT pFdo,IN OUT PIRP Irp)
{
	return ::PoCallDriver (pFdo,Irp);
}

#pragma PAGEDCODE
VOID		CWDMPower::setPowerDeviceBusy(PULONG	IdlePointer)
{
	PoSetDeviceBusy(IdlePointer);
}

#pragma PAGEDCODE
VOID		CWDMPower::skipCurrentStackLocation(IN PIRP Irp)
{
	IoSkipCurrentIrpStackLocation(Irp);
}

#pragma PAGEDCODE
NTSTATUS		CWDMPower::requestPowerIrp(
						IN PDEVICE_OBJECT DeviceObject,
						IN UCHAR MinorFunction,
						IN POWER_STATE PowerState,
						IN PREQUEST_POWER_COMPLETE CompletionFunction,
						IN PVOID Context,
						OUT PIRP *Irp OPTIONAL)
{
	return ::PoRequestPowerIrp(DeviceObject,MinorFunction,PowerState,
								CompletionFunction,Context,Irp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\gempc430\wdmlog.cpp ===
#include "generic.h"
#include "logger.h"
#include "wdmlog.h"

#pragma PAGEDCODE
CWDMLogger::CWDMLogger()
{
	m_LoggerName = L"GRClass";
}

#pragma PAGEDCODE
CWDMLogger::CWDMLogger(PWSTR LoggerName)
{
	wcscpy(m_LoggerName,LoggerName);
	m_Status = STATUS_SUCCESS;
}

#pragma PAGEDCODE
CWDMLogger::~CWDMLogger()
{
}

#pragma PAGEDCODE
VOID CWDMLogger::logEvent(NTSTATUS ErrorCode, PDEVICE_OBJECT fdo)
{	// Win98 doesn't support event logging, so don't bother
	if (isWin98())
	{
		switch(ErrorCode)
		{
		case GRCLASS_START_OK:
			DBG_PRINT("Logger: GrClass driver was initialized succesfuly!\n");
			break;
		case GRCLASS_FAILED_TO_ADD_DEVICE:
			DBG_PRINT("Logger: ######### GrClass failed to add device!\n");
			break;
		case GRCLASS_FAILED_TO_CREATE_INTERFACE:
			DBG_PRINT("Logger: ######### GrClass failed to create interface object!\n");
			break;
		case GRCLASS_FAILED_TO_CREATE_READER:
			DBG_PRINT("Logger: ######### GrClass failed to create reader object!\n");
			break;
		case GRCLASS_BUS_DRIVER_FAILED_REQUEST:
			DBG_PRINT("Logger: ######### Bus driver failed GrClass driver request!\n");
			break;
		}
		return;
	}
	else
	{
		ULONG packetlen = (wcslen(m_LoggerName) + 1) * sizeof(WCHAR) + sizeof(IO_ERROR_LOG_PACKET) + 4;
		// packet will be too big
		if (packetlen > ERROR_LOG_MAXIMUM_SIZE)	return;

		PIO_ERROR_LOG_PACKET p = (PIO_ERROR_LOG_PACKET) IoAllocateErrorLogEntry(fdo, (UCHAR) packetlen);
		if (!p)	return;

		memset(p, 0, sizeof(IO_ERROR_LOG_PACKET));
		p->MajorFunctionCode = IRP_MJ_PNP;
		p->ErrorCode = ErrorCode;
		p->DumpDataSize = 4;
		p->DumpData[0] = 0x2A2A2A2A;

		p->StringOffset = sizeof(IO_ERROR_LOG_PACKET) + p->DumpDataSize - sizeof(ULONG);
		p->NumberOfStrings = 1;
		wcscpy((PWSTR) ((PUCHAR) p + p->StringOffset), m_LoggerName);

		IoWriteErrorLogEntry(p);
	}
}


#pragma PAGEDCODE
CLogger* CWDMLogger::create(VOID)
{ 
CLogger* logger;
	logger = new (NonPagedPool) CWDMLogger; 
	if (isWin98())	DBG_PRINT("***** New Logger Object was created 0x%x\n",logger);
	RETURN_VERIFIED_OBJECT(logger);
}

#pragma PAGEDCODE
VOID CWDMLogger::dispose(VOID)
{ 
LONG Usage;
	Usage = decrementUsage();
	if(Usage<=0)
	{
		if (isWin98())	DBG_PRINT("**** Deleting Logger Object 0x%x\n",this);
		self_delete();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\gempc430\wdmsem.h ===
// Gemplus (C) 2000
// Version 1.0
// Author: Sergey Ivanov
// Date of creation - 18.05.2000
// Change log:
//
#ifndef WDEM_SEM_INT
#define WDM_SEM_INT
#include "generic.h"
#include "semaphore.h"

#pragma PAGEDCODE
class CWDMSemaphore: public CSemaphore
{
public:
	NTSTATUS m_Status;
	SAFE_DESTRUCTORS();
	virtual VOID dispose(VOID){self_delete();};
protected:
	CWDMSemaphore(){m_Status = STATUS_SUCCESS;};
	virtual ~CWDMSemaphore(){};
public:
	static CSemaphore* create(VOID);
	
	virtual VOID		initialize(IN PRKSEMAPHORE Semaphore, IN LONG Count, IN LONG Limit);
	virtual LONG		release(IN PRKSEMAPHORE Semaphore,IN KPRIORITY Increment,IN LONG Adjustment,IN BOOLEAN Wait);
	virtual LONG		getState(IN PRKSEMAPHORE Semaphore);
};	

#endif//SEMAPHORE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\gempc430\wdmsem.cpp ===
#include "wdmsem.h"

#pragma PAGEDCODE
CSemaphore* CWDMSemaphore::create(VOID)
{ return new (NonPagedPool) CWDMSemaphore; }

#pragma PAGEDCODE
VOID	CWDMSemaphore::initialize(IN PRKSEMAPHORE Semaphore, IN LONG Count, IN LONG Limit)
{
	::KeInitializeSemaphore (Semaphore,Count,Limit);
}

#pragma PAGEDCODE
LONG	CWDMSemaphore::release(IN PRKSEMAPHORE Semaphore,IN KPRIORITY Increment,IN LONG Adjustment,IN BOOLEAN Wait)
{
	return ::KeReleaseSemaphore(Semaphore,Increment,Adjustment,Wait);

}

#pragma PAGEDCODE
LONG	CWDMSemaphore::getState(IN PRKSEMAPHORE Semaphore)
{
	return KeReadStateSemaphore(Semaphore);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\gempc430\wdmsys.cpp ===
#include "wdmsys.h"

#pragma PAGEDCODE
CSystem* CWDMSystem::create(VOID)
{ return new (NonPagedPool) CWDMSystem; }

#pragma PAGEDCODE
NTSTATUS	CWDMSystem::createDevice(PDRIVER_OBJECT DriverObject,
							ULONG DeviceExtensionSize,
							PUNICODE_STRING DeviceName OPTIONAL,
							DEVICE_TYPE DeviceType,
							ULONG DeviceCharacteristics,
							BOOLEAN Reserved,
							PDEVICE_OBJECT *DeviceObject)
{
	return	::IoCreateDevice(DriverObject,DeviceExtensionSize,DeviceName,
		DeviceType,DeviceCharacteristics,Reserved,DeviceObject);
}

#pragma PAGEDCODE
VOID	CWDMSystem::deleteDevice(PDEVICE_OBJECT DeviceObject)
{
	::IoDeleteDevice(DeviceObject);
}

#pragma PAGEDCODE
PDEVICE_OBJECT	CWDMSystem::attachDevice(PDEVICE_OBJECT SourceDevice,PDEVICE_OBJECT TargetDevice)
{
	return ::IoAttachDeviceToDeviceStack(SourceDevice,TargetDevice);
}

#pragma PAGEDCODE
VOID	CWDMSystem::detachDevice(PDEVICE_OBJECT TargetDevice)
{
	::IoDetachDevice(TargetDevice);
}

#pragma PAGEDCODE
NTSTATUS	CWDMSystem::callDriver(PDEVICE_OBJECT DeviceObject,PIRP Irp)
{
	return IoCallDriver(DeviceObject,Irp);
}


#pragma PAGEDCODE
NTSTATUS	CWDMSystem::registerDeviceInterface(PDEVICE_OBJECT PhysicalDeviceObject,
							CONST GUID *InterfaceClassGuid,
							PUNICODE_STRING ReferenceString,
							PUNICODE_STRING SymbolicLinkName)
{
	return ::IoRegisterDeviceInterface(PhysicalDeviceObject,
							InterfaceClassGuid,
							ReferenceString,SymbolicLinkName);
}

#pragma PAGEDCODE
NTSTATUS	CWDMSystem::setDeviceInterfaceState(PUNICODE_STRING SymbolicLinkName,
							BOOLEAN Enable	)
{
	return ::IoSetDeviceInterfaceState(SymbolicLinkName,Enable);
}

#pragma PAGEDCODE
NTSTATUS CWDMSystem::createSystemThread(
					OUT PHANDLE ThreadHandle,
					IN ULONG DesiredAccess,
					IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
					IN HANDLE ProcessHandle OPTIONAL,
					OUT PCLIENT_ID ClientId OPTIONAL,
					IN PKSTART_ROUTINE StartRoutine,
					IN PVOID StartContext)
{
	return PsCreateSystemThread(ThreadHandle,DesiredAccess,ObjectAttributes,
					ProcessHandle,ClientId,	StartRoutine,StartContext);
}

#pragma PAGEDCODE
NTSTATUS CWDMSystem::terminateSystemThread(IN NTSTATUS ExitStatus)
{
	return PsTerminateSystemThread(ExitStatus);
}

#pragma PAGEDCODE
NTSTATUS CWDMSystem::referenceObjectByHandle(                                      
					IN HANDLE Handle,                                           
					IN ACCESS_MASK DesiredAccess,                               
					IN POBJECT_TYPE ObjectType OPTIONAL,                        
					IN KPROCESSOR_MODE AccessMode,                              
					OUT PVOID *Object,                                          
					OUT POBJECT_HANDLE_INFORMATION HandleInformation OPTIONAL   
					)
{
	return	ObReferenceObjectByHandle(Handle,DesiredAccess,ObjectType,AccessMode,Object,HandleInformation);
}


#pragma PAGEDCODE
VOID CWDMSystem::referenceObject(IN PVOID Object)                                      
{
	ObReferenceObject(Object);
}

#pragma PAGEDCODE
VOID	CWDMSystem::dereferenceObject(IN PVOID Object)
{
	ObfDereferenceObject(Object);
}

#pragma PAGEDCODE
PDEVICE_OBJECT	CWDMSystem::getAttachedDeviceReference(IN PDEVICE_OBJECT DeviceObject)
{
	return ::IoGetAttachedDeviceReference(DeviceObject);
}

NTKERNELAPI                                 
PDEVICE_OBJECT                              
IoGetAttachedDeviceReference(               
    IN PDEVICE_OBJECT DeviceObject          
    );  


#pragma PAGEDCODE
NTSTATUS	CWDMSystem::ZwClose(IN HANDLE Handle)
{
	return ::ZwClose(Handle);
}

#pragma PAGEDCODE
NTSTATUS	CWDMSystem::createSymbolicLink(IN PUNICODE_STRING SymbolicLinkName,IN PUNICODE_STRING DeviceName)
{
	return ::IoCreateSymbolicLink(SymbolicLinkName,DeviceName);
}

#pragma PAGEDCODE
NTSTATUS	CWDMSystem::deleteSymbolicLink(IN PUNICODE_STRING SymbolicLinkName)
{
	return ::IoDeleteSymbolicLink(SymbolicLinkName);
}

#pragma PAGEDCODE
VOID	CWDMSystem::invalidateDeviceRelations(IN PDEVICE_OBJECT DeviceObject,IN DEVICE_RELATION_TYPE Type)
{
	IoInvalidateDeviceRelations(DeviceObject,Type);
}


#pragma PAGEDCODE
NTSTATUS	CWDMSystem::getDeviceObjectPointer(IN PUNICODE_STRING ObjectName,
							IN ACCESS_MASK DesiredAccess,
							OUT PFILE_OBJECT *FileObject,
							OUT PDEVICE_OBJECT *DeviceObject)
{

	return IoGetDeviceObjectPointer(ObjectName,DesiredAccess,FileObject,DeviceObject);
}


#pragma PAGEDCODE
VOID	CWDMSystem::raiseIrql(IN KIRQL NewIrql,OUT KIRQL* oldIrql)
{
	KeRaiseIrql(NewIrql,oldIrql);
};

#pragma PAGEDCODE
VOID	CWDMSystem::lowerIrql (IN KIRQL NewIrql)
{
	KeLowerIrql(NewIrql);
};

#pragma PAGEDCODE
KIRQL	CWDMSystem::getCurrentIrql ()
{
	return	KeGetCurrentIrql();
};

#pragma PAGEDCODE
VOID	CWDMSystem::initializeDeviceQueue(IN PKDEVICE_QUEUE DeviceQueue)
{
	KeInitializeDeviceQueue (DeviceQueue);
};

#pragma PAGEDCODE
BOOLEAN	CWDMSystem::insertDeviceQueue(IN PKDEVICE_QUEUE DeviceQueue,IN PKDEVICE_QUEUE_ENTRY DeviceQueueEntry)
{
	return KeInsertDeviceQueue (DeviceQueue,DeviceQueueEntry);
}

#pragma PAGEDCODE
BOOLEAN	CWDMSystem::insertByKeyDeviceQueue(IN PKDEVICE_QUEUE DeviceQueue,IN PKDEVICE_QUEUE_ENTRY DeviceQueueEntry,IN ULONG SortKey)
{
	return KeInsertByKeyDeviceQueue(DeviceQueue,DeviceQueueEntry,SortKey);
}

#pragma PAGEDCODE
PKDEVICE_QUEUE_ENTRY	CWDMSystem::removeDeviceQueue(IN PKDEVICE_QUEUE DeviceQueue)
{
	return KeRemoveDeviceQueue (DeviceQueue);
}

#pragma PAGEDCODE
PKDEVICE_QUEUE_ENTRY	CWDMSystem::removeByKeyDeviceQueue(IN PKDEVICE_QUEUE DeviceQueue,IN ULONG SortKey)
{
	return KeRemoveByKeyDeviceQueue (DeviceQueue,SortKey);
}

#pragma PAGEDCODE
BOOLEAN	CWDMSystem::removeEntryDeviceQueue(IN PKDEVICE_QUEUE DeviceQueue,IN PKDEVICE_QUEUE_ENTRY DeviceQueueEntry)
{
	return KeRemoveEntryDeviceQueue(DeviceQueue,DeviceQueueEntry);
}


#pragma PAGEDCODE
NTSTATUS	CWDMSystem::openDeviceRegistryKey(IN PDEVICE_OBJECT DeviceObject,
							IN ULONG DevInstKeyType,
							IN ACCESS_MASK DesiredAccess,
							OUT PHANDLE DevInstRegKey)
{

	return IoOpenDeviceRegistryKey(DeviceObject,DevInstKeyType,DesiredAccess,DevInstRegKey);
}

#pragma PAGEDCODE
NTSTATUS	CWDMSystem::ZwQueryValueKey(IN HANDLE KeyHandle,
							IN PUNICODE_STRING ValueName,
							IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
							OUT PVOID KeyValueInformation,
							IN ULONG Length,
							OUT PULONG ResultLength)
{
	return ZwQueryValueKey(KeyHandle,ValueName,KeyValueInformationClass,KeyValueInformation,
						Length,ResultLength);
}

#pragma PAGEDCODE
NTSTATUS	CWDMSystem::getDeviceProperty(
							IN PDEVICE_OBJECT DeviceObject,
							IN DEVICE_REGISTRY_PROPERTY Property,
							IN ULONG BufferLength,
							OUT PVOID PropertyBuffer,
							OUT PULONG ResultLength	)
{

	return IoGetDeviceProperty(DeviceObject,Property,BufferLength,PropertyBuffer,ResultLength);
/*

// Define PnP Device Property for IoGetDeviceProperty
#define DEVICE_PROPERTY_TABSIZE		DevicePropertyEnumeratorName+1

WCHAR* DeviceProperty[DEVICE_PROPERTY_TABSIZE];

DeviceProperty[DevicePropertyDeviceDescription] = L"DeviceDesc";
DeviceProperty[DevicePropertyHardwareID] = L"HardwareID";
DeviceProperty[DevicePropertyCompatibleIDs] = L"CompatibleIDs";
DeviceProperty[DevicePropertyBootConfiguration] = L"BootConfiguration";
DeviceProperty[DevicePropertyBootConfigurationTranslated] = L"BootConfigurationTranslated";
DeviceProperty[DevicePropertyClassName] = L"ClassName";
DeviceProperty[DevicePropertyClassGuid] = L"ClassGuid";
DeviceProperty[DevicePropertyDriverKeyName] = L"DriverKeyName";
DeviceProperty[DevicePropertyManufacturer] = L"Manufacturer";
DeviceProperty[DevicePropertyFriendlyName] = L"FriendlyName";
DeviceProperty[DevicePropertyLocationInformation] = L"LocationInformation";
DeviceProperty[DevicePropertyPhysicalDeviceObjectName] = L"PhysicalDeviceObjectName";
DeviceProperty[DevicePropertyBusTypeGuid] = L"BusTypeGuid";
DeviceProperty[DevicePropertyLegacyBusType] = L"LegacyBusType";
DeviceProperty[DevicePropertyBusNumber] = L"BusNumber";
DeviceProperty[DevicePropertyEnumeratorName] = L"EnumeratorName";

	if (isWin98())
	{						// use registry
		HANDLE hkey;
		status = IoOpenDeviceRegistryKey(pdo, PLUGPLAY_REGKEY_DEVICE, KEY_READ, &hkey);

		if (NT_SUCCESS(status))
		{					// get & report description
			UNICODE_STRING valname;
			RtlInitUnicodeString(&valname, L"DeviceDesc");

			kernel->RegistryPath = new (NonPagedPool)CUString(RegistryPath);
    
			ULONG size = 0;
			status = ZwQueryValueKey(hkey, &valname, KeyValuePartialInformation, NULL, 0, &size);
			if (status != STATUS_OBJECT_NAME_NOT_FOUND && size)
				{					// value exists
				PKEY_VALUE_PARTIAL_INFORMATION vpip = (PKEY_VALUE_PARTIAL_INFORMATION) ExAllocatePool(PagedPool, size);
				status = ZwQueryValueKey(hkey, &valname, KeyValuePartialInformation, vpip, size, &size);
				if (NT_SUCCESS(status))
					KdPrint((DRIVERNAME " - AddDevice has succeeded for '%ws' device\n", vpip->Data));
				ExFreePool(vpip);
				}				// value exists
			ZwClose(hkey);
		}					// get & report description
	}						// use registry
	else
	{						// get property
		status = IoGetDeviceProperty(DeviceObject,DeviceProperty,BufferLength,PropertyBuffer,ResultLength);
	}						// get property
*/
}

#pragma PAGEDCODE
VOID		CWDMSystem::initializeFastMutex(IN PFAST_MUTEX FastMutex)
{
	ExInitializeFastMutex (FastMutex);
}

#pragma PAGEDCODE
VOID		CWDMSystem::acquireFastMutex(IN PFAST_MUTEX FastMutex)
{
	ExAcquireFastMutex (FastMutex);
}

#pragma PAGEDCODE
VOID		CWDMSystem::releaseFastMutex(IN PFAST_MUTEX FastMutex)
{
	ExReleaseFastMutex(FastMutex);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\gempc430\wdmtimer.h ===
// Gemplus (C) 1999
// Version 1.0
// Author: Sergey Ivanov
// Date of creation - 18.05.1999
// Change log:
//

#ifndef __WDM_TIMER__
#define __WDM_TIMER__
#include "generic.h"
#include "timer.h"

#pragma PAGEDCODE
// This class will manage creation and 
// manipulation of driver Timers
class CWDMTimer : public CTimer
{
public:
	NTSTATUS m_Status;
	SAFE_DESTRUCTORS();
	virtual VOID dispose(VOID){self_delete();};
protected:
	CWDMTimer(){m_Status = STATUS_SUCCESS;};
	virtual ~CWDMTimer();
public:
	CWDMTimer(TIMER_TYPE Type);

	static CTimer* create(TIMER_TYPE Type);

	virtual BOOL set(LARGE_INTEGER DueTime,LONG Period,PKDPC Dpc);
	virtual BOOL cancel();
	VOID	delay(ULONG Delay);

};

#endif//WDM_TIMER
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\gempc430\wdmsys.h ===
// Gemplus (C) 1999
// This is main Driver object for the driver.
//
// Version 1.0
// Author: Sergey Ivanov
// Date of creation - 18.05.1999
// Change log:
//
#ifndef WDMSYS_INT
#define WDMSYS_INT
#include "generic.h"
#include "system.h"

#pragma PAGEDCODE
// Interface to general system services...
class CWDMSystem : public CSystem
{
public:
	NTSTATUS m_Status;
	SAFE_DESTRUCTORS();
	virtual VOID dispose(VOID){self_delete();};
protected:
	CWDMSystem(){m_Status = STATUS_SUCCESS;};
	virtual ~CWDMSystem(){};
public:
	static CSystem*  create(VOID);

	// This object will implement next interfaces...
	virtual NTSTATUS	createDevice(PDRIVER_OBJECT DriverObject,
							ULONG DeviceExtensionSize,
							PUNICODE_STRING DeviceName OPTIONAL,
							DEVICE_TYPE DeviceType,
							ULONG DeviceCharacteristics,
							BOOLEAN Reserved,
							PDEVICE_OBJECT *DeviceObject);

	virtual VOID			deleteDevice(PDEVICE_OBJECT DeviceObject);

	virtual PDEVICE_OBJECT	attachDevice(PDEVICE_OBJECT FuncDevice,IN PDEVICE_OBJECT PhysDevice);
	virtual VOID			detachDevice(PDEVICE_OBJECT TargetDevice);

	virtual NTSTATUS		callDriver(PDEVICE_OBJECT DeviceObject,PIRP Irp);

	virtual NTSTATUS	registerDeviceInterface(PDEVICE_OBJECT PhysicalDeviceObject,
							CONST GUID *InterfaceClassGuid,
							PUNICODE_STRING ReferenceString,     OPTIONAL
							PUNICODE_STRING SymbolicLinkName);
	virtual NTSTATUS	setDeviceInterfaceState(PUNICODE_STRING SymbolicLinkName,BOOLEAN Enable);

	virtual NTSTATUS		createSystemThread(OUT PHANDLE ThreadHandle,
								IN ULONG DesiredAccess,
								IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
								IN HANDLE ProcessHandle OPTIONAL,
								OUT PCLIENT_ID ClientId OPTIONAL,
								IN PKSTART_ROUTINE StartRoutine,
								IN PVOID StartContext);
	virtual NTSTATUS		terminateSystemThread(IN NTSTATUS ExitStatus);

	virtual NTSTATUS		referenceObjectByHandle(IN HANDLE Handle,                                           
								IN ACCESS_MASK DesiredAccess,                               
								IN POBJECT_TYPE ObjectType OPTIONAL,                        
								IN KPROCESSOR_MODE AccessMode,                              
								OUT PVOID *Object,                                          
								OUT POBJECT_HANDLE_INFORMATION HandleInformation OPTIONAL   
								);
	virtual VOID			referenceObject(IN PVOID Object);
	virtual VOID			dereferenceObject(IN PVOID Object);
	virtual PDEVICE_OBJECT	getAttachedDeviceReference(IN PDEVICE_OBJECT DeviceObject);

	virtual NTSTATUS	    ZwClose(IN HANDLE Handle);

	virtual NTSTATUS		createSymbolicLink(IN PUNICODE_STRING SymbolicLinkName,IN PUNICODE_STRING DeviceName);
	virtual NTSTATUS		deleteSymbolicLink(IN PUNICODE_STRING SymbolicLinkName);
	virtual VOID			invalidateDeviceRelations(IN PDEVICE_OBJECT DeviceObject,IN DEVICE_RELATION_TYPE Type);
	virtual NTSTATUS		getDeviceObjectPointer(IN PUNICODE_STRING ObjectName,
								IN ACCESS_MASK DesiredAccess,
								OUT PFILE_OBJECT *FileObject,
								OUT PDEVICE_OBJECT *DeviceObject);

	virtual VOID			raiseIrql(IN KIRQL NewIrql,OUT KIRQL* oldIrql);
	virtual VOID			lowerIrql (IN KIRQL NewIrql);
	virtual KIRQL			getCurrentIrql();

	virtual VOID			initializeDeviceQueue(IN PKDEVICE_QUEUE DeviceQueue);
	virtual BOOLEAN			insertDeviceQueue(IN PKDEVICE_QUEUE DeviceQueue,IN PKDEVICE_QUEUE_ENTRY DeviceQueueEntry);
	virtual BOOLEAN			insertByKeyDeviceQueue(IN PKDEVICE_QUEUE DeviceQueue,IN PKDEVICE_QUEUE_ENTRY DeviceQueueEntry,IN ULONG SortKey);
	virtual PKDEVICE_QUEUE_ENTRY	removeDeviceQueue(IN PKDEVICE_QUEUE DeviceQueue);
	virtual PKDEVICE_QUEUE_ENTRY	removeByKeyDeviceQueue(IN PKDEVICE_QUEUE DeviceQueue,IN ULONG SortKey);
	virtual BOOLEAN			removeEntryDeviceQueue(IN PKDEVICE_QUEUE DeviceQueue,IN PKDEVICE_QUEUE_ENTRY DeviceQueueEntry);

	virtual NTSTATUS		openDeviceRegistryKey(IN PDEVICE_OBJECT DeviceObject,
								IN ULONG DevInstKeyType,
								IN ACCESS_MASK DesiredAccess,
								OUT PHANDLE DevInstRegKey
								);

	virtual NTSTATUS		ZwQueryValueKey(IN HANDLE KeyHandle,
								IN PUNICODE_STRING ValueName,
								IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
								OUT PVOID KeyValueInformation,
								IN ULONG Length,
								OUT PULONG ResultLength
								);
	virtual NTSTATUS		getDeviceProperty(IN PDEVICE_OBJECT DeviceObject,
								IN DEVICE_REGISTRY_PROPERTY DeviceProperty,
								IN ULONG BufferLength,
								OUT PVOID PropertyBuffer,
								OUT PULONG ResultLength
								);


	virtual VOID			initializeFastMutex(IN PFAST_MUTEX FastMutex);
	virtual VOID			acquireFastMutex(IN PFAST_MUTEX FastMutex);
	virtual VOID			releaseFastMutex(IN PFAST_MUTEX FastMutex);
};	

#endif //WDMSYS_INT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\gempc430\wdmtimer.cpp ===
#include "wdmtimer.h"

#pragma PAGEDCODE
CTimer* CWDMTimer::create(TIMER_TYPE Type)
{ 
	return new (NonPagedPool) CWDMTimer(Type);
}

#pragma PAGEDCODE
CWDMTimer::CWDMTimer(TIMER_TYPE Type)
{
	KeInitializeTimerEx(&Timer, Type);
};

#pragma PAGEDCODE
CWDMTimer::~CWDMTimer()
{
	KeCancelTimer(&Timer);
};

#pragma PAGEDCODE
BOOL CWDMTimer::set(LARGE_INTEGER DueTime,LONG Period,PKDPC Dpc)
{
	return KeSetTimerEx(&Timer,DueTime, Period, Dpc);
};

#pragma PAGEDCODE
BOOL CWDMTimer::cancel()
{
	return KeCancelTimer(&Timer);
};

#pragma PAGEDCODE
VOID CWDMTimer::delay(ULONG Delay)
{
LARGE_INTEGER duetime;
    // Waits for the Timeout to be elapsed.
    ASSERT(KeGetCurrentIrql()<=DISPATCH_LEVEL);
    duetime.QuadPart = -(LONGLONG)(Delay * 10L * 1000L);
    set(duetime,0,NULL);
    KeWaitForSingleObject(&Timer, Executive, KernelMode, FALSE, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\gpr400\gprcmd.c ===
/*++
                 Copyright (c) 1998 Gemplus Development

Name:
    gprcmd.c

Description:
    This is the module which holds the calls to the readers
    functions.

Environment:
    Kernel Mode

Revision History:
    06/04/99:            (Y. Nadeau + M. Veillette)
      - Code Review
    12/03/99: V1.00.005  (Y. Nadeau)
      - Fix Set protocol to give reader the time to process the change
    18/09/98: V1.00.004  (Y. Nadeau)
      - Correction for NT5 beta 3
    06/05/98: V1.00.003  (P. Plouidy)
        - Power management for NT5
    10/02/98: V1.00.002  (P. Plouidy)
        - Plug and Play for NT5
    03/07/97: V1.00.001  (P. Plouidy)
        - Start of development.


--*/
//
// Include section:
//   - stdio.h: standards definitons.
//   - ntddk.h: DDK Windows NT general definitons.
//   - ntdef.h: Windows NT general definitons.
//
#include <stdio.h>
#include <ntddk.h>
#include <ntdef.h>

//
//   - gprcmd.h: common definition for this module.
//   - gprnt.h: public interface definition for the NT module.
//   - gprelcmd.h :  elementary commands profile
//   - gemerror.h : Gemplus error codes

#include "gprnt.h"
#include "gprcmd.h"
#include "gprelcmd.h"



//
//   Master driver code to load in RAM
//
UCHAR MASTER_DRIVER[133]={
    0xC2,0xB5,0x12,0x14,0xC6,0xFC,0x78,0x00,0x7B,0x00,0x90,0x07,0xDF,0xE0,0xD2,0xE4,
    0xF0,0xEB,0xF8,0x12,0x14,0xD0,0x12,0x0D,0x9B,0x40,0x5C,0x0B,0xDC,0xF3,0xD2,0xB4,
    0x90,0x07,0xDF,0xE0,0xC2,0xE4,0xF0,0x90,0x06,0xD4,0xE4,0xF5,0x15,0xF5,0x11,0xC2,
    0x4D,0xA3,0x05,0x11,0x75,0x34,0x0A,0x75,0x37,0x00,0x75,0x38,0x40,0x12,0x0B,0x75,
    0x20,0x20,0x3B,0xF0,0xA3,0x05,0x11,0x7B,0x01,0x12,0x0B,0x75,0x20,0x20,0x2F,0xF0,
    0xA3,0x05,0x11,0x7C,0x03,0x33,0x33,0x50,0x01,0x0B,0xDC,0xFA,0x12,0x0B,0x75,0x20,
    0x20,0x1C,0xF0,0xA3,0x05,0x11,0xDB,0xF4,0xE4,0x90,0x06,0xD4,0xF0,0x75,0x16,0x00,
    0x75,0x15,0x00,0x12,0x14,0x15,0x22,0x74,0x0C,0x75,0x11,0x01,0x80,0xEB,0x74,0x0D,
    0x75,0x11,0x01,0x80,0xE4
    };


// Hard coded structure for different values of TA1.
// eg. If TA= 0x92 is to set, this array of structure can be scanned and
// for member variable TA1 = 0x92 and that values can be written to 
// approptiate location.
// This is done in ConfigureTA1() function.
struct tagCfgTa1
{
    BYTE TA1;
    BYTE ETU1;
    BYTE ETU2;
    BYTE ETU1P;
} cfg_ta1[] = { 

//  { 0x15, 0x01, 0x01, 0x01 },
//  { 0x95, 0x01, 0x01, 0x01 },

//  { 0x25, 0x03, 0x02, 0x01 },
    
//  { 0x14, 0x05, 0x03, 0x01 },
//  { 0x35, 0x05, 0x03, 0x01 },
    
//  { 0xa5, 0x04, 0x02, 0x01 },
    
//  { 0x94, 0x07, 0x04, 0x02 },
//  { 0xb5, 0x07, 0x04, 0x02 },
    
//  { 0x24, 0x09, 0x04, 0x04 },
//  { 0x45, 0x09, 0x04, 0x04 },
    
    { 0x13, 0x0d, 0x06, 0x09 },
    { 0x34, 0x0d, 0x06, 0x09 },
    { 0x55, 0x0d, 0x06, 0x09 },
    
    { 0xa4, 0x0c, 0x06, 0x08 },
    { 0xc5, 0x0c, 0x06, 0x08 },
    
    { 0x65, 0x10, 0x08, 0x0c },

    { 0x93, 0x11, 0x09, 0x0d },
    { 0xb4, 0x11, 0x09, 0x0d },
    { 0xd5, 0x11, 0x09, 0x0d },

    { 0x23, 0x14, 0x0a, 0x10 },
    { 0x44, 0x14, 0x0a, 0x10 },


    { 0x12, 0x1c, 0x0e, 0x15 },
    { 0x33, 0x1c, 0x0e, 0x15 },
    { 0x54, 0x1c, 0x0e, 0x15 },

    { 0xa3, 0x1c, 0x0f, 0x15 },
    { 0xc4, 0x1c, 0x0f, 0x15 },

    { 0x64, 0x24, 0x12, 0x20 },

    { 0x92, 0x26, 0x14, 0x22 },
    { 0xb3, 0x26, 0x14, 0x22 },
    { 0xd4, 0x26, 0x14, 0x22 },


    { 0x22, 0x2b, 0x16, 0x27 },
    { 0x43, 0x2b, 0x16, 0x27 },


    { 0x11, 0x3b, 0x1e, 0x37 },
    { 0x32, 0x3b, 0x1e, 0x37 },
    { 0x53, 0x3b, 0x1e, 0x37 },

//  { 0x71, 0x55, 0x2b, 0x51 },
//  { 0x91, 0x55, 0x2b, 0x51 },

    { 0, 0, 0, 0 }

};



USHORT  ATRLen (UCHAR *ATR, USHORT MaxChar)
/*++

  Routine Description :
    Used to calculate the ATR length according to its content.
  Arguments
    ATR - string to analyze
    MaxChar - Maximum number of characters to verify.
--*/
{
    USHORT Len;
    UCHAR T0;
    UCHAR Yi;
    BOOLEAN EndInterChar;
    BOOLEAN TCKPresent=FALSE;

    T0 = ATR[1];
    Len= 2;  // TS + T0

    Yi= (T0 & 0xF0);

    EndInterChar = FALSE;
    do
    {
        if (Yi & 0x10)
        {
            Len++; //TAi
        }
        if (Yi & 0x20)
        {
            Len++; //TBi
        }
        if (Yi & 0x40)
        {
            Len++; //TCi
        }
        if (Yi & 0x80)
        {
            if (Len < MaxChar) {
                Yi = ATR[Len];
                if((Yi & 0x0F)!=0)
                {
                    TCKPresent=TRUE;
                    
                }
            } 

            Len++; //TDi
        }
        else
        {
            EndInterChar = TRUE;
        }
    } while((Len < MaxChar) && (EndInterChar == FALSE));

    Len = Len + (T0 & 0x0F);

    if(TCKPresent==TRUE)
    {
        Len = Len+1; //TCK
    }

    return (Len);
}



BOOLEAN NeedToSwitchWithoutPTS( 
    BYTE *ATR,
    DWORD LengthATR
    )
/*++

  Routine Description : 
    Examine if ATR identifies a specific mode (presence of TA2).
  Arguments
    ATR - string to analyze
    LengthATR - Length of ATR.
--*/

{
   DWORD pos, len;

   // ATR[1] is T0.  Examine precense of TD1.
   if (ATR[1] & 0x80)
   {
      // Find position of TD1.
      pos = 2;
      if (ATR[1] & 0x10)
         pos++;
      if (ATR[1] & 0x20)
         pos++;
      if (ATR[1] & 0x40)
         pos++;

      // Here ATR[pos] is TD1.  Examine presence of TA2.
      if (ATR[pos] & 0x10)
      {
         // To be of any interest an ATR must contains at least
         //   TS, T0, TA1, TD1, TA2 [+ T1 .. TK] [+ TCK]
         // Find the maximum length of uninteresting ATR.
         if (ATR[pos] & 0x0F)
            len = 5 + (ATR[1] & 0x0F);
         else
            len = 4 + (ATR[1] & 0x0F);  // In protocol T=0 there is no TCK.

         if (LengthATR > len)  // Interface bytes requires changes.
            if ((ATR[pos+1] & 0x10) == 0)  // TA2 asks to use interface bytes.
               return TRUE;
      }
   }

   return FALSE;
}



NTSTATUS ValidateDriver( PSMARTCARD_EXTENSION pSmartcardExtension)
/*++

  Routine Description :
    Validate the Master driver loaded in RAM at address 2100h
  Arguments
    pSmartcardExtension: Pointer to the SmartcardExtension structure.
--*/
{
    READER_EXTENSION *pReaderExt = pSmartcardExtension->ReaderExtension;
    NTSTATUS lStatus = STATUS_SUCCESS;
    UCHAR Vi[GPR_BUFFER_SIZE];
    UCHAR To;
    USHORT Lo;
    UCHAR Vo[GPR_BUFFER_SIZE];


    Vi[0] = 0x83;  // DIR
    Vi[1] = 0x21;  // ADR MSB
    Vi[2] = 0x00;  // ADR LSB
    // Output variable initialisation
    Lo = GPR_BUFFER_SIZE;
    To = 0x00;
    Vo[0] = 0x00;

    // return a NTSTATUS
    lStatus = GprllTLVExchange (
        pReaderExt,
        VALIDATE_DRIVER_CMD,
        3,
        Vi,
        &To,
        &Lo,
        Vo
        );

    return (lStatus);

}



NTSTATUS Update(
    PSMARTCARD_EXTENSION pSmartcardExtension,
    UCHAR Addr,
    UCHAR Value)
/*++

  Routine Description :
    Write a value in RAM
  Arguments
    pSmartcardExtension: Pointer to the SmartcardExtension structure.
    Addr: Address in RAM
    Value: Value to write
--*/
{
    READER_EXTENSION *pReaderExt = pSmartcardExtension->ReaderExtension;
    NTSTATUS lStatus = STATUS_SUCCESS;
    UCHAR Vi[GPR_BUFFER_SIZE];
    UCHAR To;
    USHORT Lo;
    UCHAR Vo[GPR_BUFFER_SIZE];

    Vi[0]= 0x01;
    Vi[1]= Addr;
    Vi[2]= Value;

    // Output variable initialisation
    Lo = GPR_BUFFER_SIZE;
    To = 0x00;
    Vo[0] = 0x00;

    lStatus = GprllTLVExchange(
        pReaderExt,
        UPDATE_CMD,
        0x03,
        Vi,
        &To,
        &Lo,
        Vo
        );

    return (lStatus);

}

NTSTATUS UpdateORL(
    PSMARTCARD_EXTENSION pSmartcardExtension,
    UCHAR Addr,
    UCHAR Value)
/*++

  Routine Description :
    Write a value in RAM with OR mask
  Arguments
    pSmartcardExtension: Pointer to the SmartcardExtension structure.
--*/
{
    READER_EXTENSION *pReaderExt = pSmartcardExtension->ReaderExtension;
    NTSTATUS lStatus = STATUS_SUCCESS;
    UCHAR Vi[GPR_BUFFER_SIZE];
    UCHAR To;
    USHORT Lo;
    UCHAR Vo[GPR_BUFFER_SIZE];


    Vi[0]= 0x02;
    Vi[1]= Addr;
    // Output variable initialisation
    Lo = GPR_BUFFER_SIZE;
    To = 0x00;
    Vo[0] = 0x00;

    lStatus = GprllTLVExchange(
        pReaderExt,
        UPDATE_CMD,
        0x02,
        Vi,
        &To,
        &Lo,
        Vo
        );

    if (STATUS_SUCCESS != lStatus)
    {
        return (lStatus);
    }


    Vi[0]= 0x01;
    Vi[1]= Addr;
    Vi[2] = Vo[1] | Value;

    // Output variable initialisation
    Lo = GPR_BUFFER_SIZE;
    To = 0x00;
    Vo[0] = 0x00;

    lStatus = GprllTLVExchange(
        pReaderExt,
        UPDATE_CMD,
        0x03,
        Vi,
        &To,
        &Lo,
        Vo
        );

    return (lStatus);
}


NTSTATUS T0toT1( PSMARTCARD_EXTENSION pSmartcardExtension)
/*++

  Routine Description :
    OS patch to put the reader in T1 mode
  Arguments
    pSmartcardExtension: Pointer to the SmartcardExtension structure.
--*/
{
    NTSTATUS lStatus = STATUS_SUCCESS;

    // Verify each update to be done
    lStatus = Update(pSmartcardExtension,0x09,0x03);
    if (lStatus != STATUS_SUCCESS)
    {
        return (lStatus);
    }

    lStatus = Update(pSmartcardExtension,0x20,0x03);
    if (lStatus != STATUS_SUCCESS)
    {
        return (lStatus);
    }

    lStatus = Update(pSmartcardExtension,0x48,0x00);
    if (lStatus != STATUS_SUCCESS)
    {
        return (lStatus);
    }

    lStatus = Update(pSmartcardExtension,0x49,0x0F);
    if (lStatus != STATUS_SUCCESS)
    {
        return (lStatus);
    }

    lStatus = Update(pSmartcardExtension,0x4A,0x20);
    if (lStatus != STATUS_SUCCESS)
    {
        return (lStatus);
    }

    lStatus = Update(pSmartcardExtension,0x4B,0x0B);
    if (lStatus != STATUS_SUCCESS)
    {
        return (lStatus);
    }

    lStatus = Update(pSmartcardExtension,0x4C,0x40);
    if (lStatus != STATUS_SUCCESS)
    {
        return (lStatus);
    }
    
    lStatus = UpdateORL(pSmartcardExtension,0x2A,0x02);
    if (lStatus != STATUS_SUCCESS)
    {
        return (lStatus);
    }

    // Give the reader the time to process the change
    GprllWait(100);

    return (STATUS_SUCCESS);
}

NTSTATUS T1toT0( PSMARTCARD_EXTENSION pSmartcardExtension)
/*++

  Routine Description :
    OS patch to put the reader in T0 mode
  Arguments
    pSmartcardExtension: Pointer to the SmartcardExtension structure.
--*/
{
    READER_EXTENSION *pReaderExt = pSmartcardExtension->ReaderExtension;
    NTSTATUS lStatus = STATUS_SUCCESS;

    lStatus = Update(pSmartcardExtension,0x09,0x02);
    if (lStatus != STATUS_SUCCESS)
    {
        return (lStatus);
    }

    lStatus = Update(pSmartcardExtension,0x20,0x02);
    if (lStatus != STATUS_SUCCESS)
    {
        return (lStatus);
    }


    // Give the reader the time to process the change
    GprllWait(100);

    return (STATUS_SUCCESS);
}



NTSTATUS IccColdReset(
    PSMARTCARD_EXTENSION pSmartcardExtension
    )
/*++

  Routine Description :
    Cold reset function.
    The delay between the power down & the power up is strored
    in the PowerTimeout field of the READER_EXTENSION structure.
    The default value is 0.

  Arguments

    pSmartcardExtension: Pointer to the SmartcardExtension structure.
--*/
{
    //
    //  Local variables:
    //  - pReaderExt holds the pointer to the current ReaderExtension structure
    //  - lStatus holds the status to return.
    //  - Vi Holds the input buffer of the TLV commnand.
    //  - To holds the Tag of the returned TLV.
    //  - Lo holds the Length of the buffer of the returned TLV.
    //  - Vo holds the Buffer of the returned TLV.
    //  - RespLen holds the Length of the buffer of the TLV returned by the power up command.
    //  - Rbuff holds  the buffer of the TLV returned by the power up command.
    //
    READER_EXTENSION *pReaderExt = pSmartcardExtension->ReaderExtension;
    NTSTATUS lStatus = STATUS_SUCCESS;
    UCHAR Vi[GPR_BUFFER_SIZE];
    UCHAR To;
    USHORT Lo;
    UCHAR Vo[GPR_BUFFER_SIZE];
    USHORT RespLen;
    UCHAR RespBuff[GPR_BUFFER_SIZE];
    UCHAR BWTimeAdjust;
    USHORT MaxChar;


    // Send power on command (GprllTLVExchange: T= 20h, L = 0)
    // <= response
    // Output variable initialisation
    RespLen = GPR_BUFFER_SIZE;

    To = 0x00;
    RespBuff[0] = 0x00;

    lStatus = GprllTLVExchange(
        pReaderExt,
        OPEN_SESSION_CMD,
        0x00,
        Vi, 
        &To,
        &RespLen,
        RespBuff
        );
    if (lStatus != STATUS_SUCCESS)
    {
        return (lStatus);
    }

    // Correct  the WTX pb
    // Get the value set by the reader
    Vi [0]=0x02;
    Vi [1]=0x4A;

    // Output variable initialisation
    Lo = GPR_BUFFER_SIZE;
    To = 0x00;
    Vo[0] = 0x00;

    lStatus = GprllTLVExchange(
        pReaderExt,
        UPDATE_CMD,
        0x02,
        Vi, 
        &To,
        &Lo,
        Vo
        );
    if (lStatus != STATUS_SUCCESS)
    {
        return (lStatus);
    }


    // adjust the value of the BWT
    if(Vo[1] >= 0x80)
    {
        BWTimeAdjust = 0xff;
    }
    else
    {
        BWTimeAdjust = Vo[1] * 2;
    }

    lStatus = Update(pSmartcardExtension,0x4A,BWTimeAdjust);


    if (lStatus == STATUS_SUCCESS)
    {

        // Get the ATR length from this function
        MaxChar = RespLen - 1;
        RespLen = ATRLen(RespBuff+1, MaxChar) + 1;
        
        //
        // Copy ATR to smart card struct (remove the reader status byte)
        // The lib needs the ATR for evaluation of the card parameters
        //
        // Verification if Response buffer is larger than ATR buffer.
        //
        if (
            (pSmartcardExtension->SmartcardReply.BufferSize >= (ULONG) (RespLen - 1)) &&
            (sizeof(pSmartcardExtension->CardCapabilities.ATR.Buffer) >= (ULONG)(RespLen - 1))
            )
        {

            RtlCopyMemory(
                pSmartcardExtension->SmartcardReply.Buffer,
                RespBuff + 1,
                RespLen - 1
                );
        
            pSmartcardExtension->SmartcardReply.BufferLength = (ULONG) (RespLen - 1);
        
            RtlCopyMemory(
                pSmartcardExtension->CardCapabilities.ATR.Buffer,
                pSmartcardExtension->SmartcardReply.Buffer,
                pSmartcardExtension->SmartcardReply.BufferLength
                );

            pSmartcardExtension->CardCapabilities.ATR.Length =
                (UCHAR) pSmartcardExtension->SmartcardReply.BufferLength ;


            pSmartcardExtension->CardCapabilities.Protocol.Selected =
                SCARD_PROTOCOL_UNDEFINED;

            // Parse the ATR string in order to check if it as valid
            // and to find out if the card uses invers convention
            lStatus = SmartcardUpdateCardCapabilities(pSmartcardExtension);

            if (lStatus == STATUS_SUCCESS)
            {
                RtlCopyMemory(
                    pSmartcardExtension->IoRequest.ReplyBuffer,
                    pSmartcardExtension->CardCapabilities.ATR.Buffer,
                    pSmartcardExtension->CardCapabilities.ATR.Length
                    );

                *pSmartcardExtension->IoRequest.Information =
                    pSmartcardExtension->SmartcardReply.BufferLength;

                //
                // Implicite protocol and parameters selection?
                // Verify if TA2 require to switch in TA1
                //
                if ( NeedToSwitchWithoutPTS(
                      pSmartcardExtension->CardCapabilities.ATR.Buffer,
                      pSmartcardExtension->CardCapabilities.ATR.Length) == FALSE)
                {
                    // send reader parameters
                    IfdConfig(pSmartcardExtension, 0x11);
                }
            }
        }
        else
        {
            lStatus = STATUS_BUFFER_TOO_SMALL;
        }

    }
    return (lStatus);
}



NTSTATUS IccPowerDown(
    PSMARTCARD_EXTENSION pSmartcardExtension
    )
/*++

  Routine Description : ICC power down function

  Arguments
    pSmartcardExtension: Pointer to the SmartcardExtension structure.
--*/
{
    //  Local variables:
    //   - pReaderExt holds the pointer to the current ReaderExtension structure
    //   - lStatus holds the status to return.
    //   - Vi Holds the input buffer of the TLV commnand.
    //   - To holds the Tag of the returned TLV.
    //   - Lo holds the Length of the buffer of the returned TLV.
    //   - Vo holds the Buffer of the returned TLV.
    READER_EXTENSION *pReaderExt = pSmartcardExtension->ReaderExtension;
    NTSTATUS lStatus = STATUS_SUCCESS;
    UCHAR Vi[GPR_BUFFER_SIZE];
    UCHAR To;
    USHORT Lo;
    UCHAR Vo[GPR_BUFFER_SIZE];
    KIRQL irql;

    // Power down

    // Output variable initialisation
    Lo = GPR_BUFFER_SIZE;
    To = 0x00;
    Vo[0] = 0x00;

    lStatus = GprllTLVExchange(
        pReaderExt,
        CLOSE_SESSION_CMD,
        0x00,
        Vi,
        &To,
        &Lo,
        Vo
        );
    
    if (lStatus == STATUS_SUCCESS)
    {
        KeAcquireSpinLock(&pSmartcardExtension->OsData->SpinLock,
                          &irql);

        pSmartcardExtension->ReaderCapabilities.CurrentState = SCARD_SWALLOWED;
        KeReleaseSpinLock(&pSmartcardExtension->OsData->SpinLock,
                          irql);

    }

   return (lStatus);
}



NTSTATUS IccIsoOutput(
   PSMARTCARD_EXTENSION pSmartcardExtension,
   const UCHAR      pCommand[5],
   USHORT           *pRespLen,
   UCHAR            pRespBuff[]
    )
/*++

  Routine Description : This function sends an ISO OUT command to the card

  Arguments
    pSmartcardExtension: Pointer to the SmartcardExtension structure.
    pCommand : Iso out command to send.
    pRespLen :  in  - maximum buffer size available
                out - returned buffer length.
    pRespBuff: returned buffer
--*/
{
    //  Local variables:
    //   - pReaderExt holds the pointer to the current ReaderExtension structure
    //   - lStatus holds the status to return.
    //   - Vi Holds the input buffer of the TLV commnand.
    //   - To holds the Tag of the returned TLV.
    //   - Lo holds the Length of the buffer of the returned TLV.
    //   - Vo holds the Buffer of the returned TLV.
    READER_EXTENSION *pReaderExt = pSmartcardExtension->ReaderExtension;
    NTSTATUS lStatus = STATUS_SUCCESS;
    UCHAR Vi[GPR_BUFFER_SIZE]= { 0x01 };
    UCHAR To;
    USHORT Lo;
    UCHAR Vo[GPR_BUFFER_SIZE];

    //   The five command bytes are added in cmd buffer.
    RtlCopyMemory(Vi + 1, pCommand, 5);

    //   The command is send to IFD.
    //   Fields RespLen and RespBuff are updates
    //   <= sResponse
    Lo = *pRespLen;
    To = 0x00;
    Vo[0] = 0x00;

    lStatus = GprllTLVExchange(
        pReaderExt,
        APDU_EXCHANGE_CMD,
        6,
        Vi,
        &To,
        &Lo,
        Vo
        );

    if (lStatus != STATUS_SUCCESS)
    {
        *pRespLen = 0;
    }
    else
    {

        // To correct the bug of GPR400 version 1.0
        // If the response is 0xE7 then correct the response
        if (
           (Lo != 1) &&
           (pReaderExt->OsVersion<= 0x10 )&&
           (Vo[0]==0xE7)
           )
        {
            Lo = 0x03;
        }

        RtlCopyMemory(pRespBuff, Vo, Lo);
        *pRespLen = Lo;
    }
    return (lStatus);
}

NTSTATUS IccIsoInput(
    PSMARTCARD_EXTENSION pSmartcardExtension,
    const UCHAR        pCommand[5],
    const UCHAR        pData[],
         USHORT      *pRespLen,
         BYTE         pRespBuff[]
    )
/*++

  Routine Description : This function sends an ISO IN command to the card

  Arguments
    pSmartcardExtension: Pointer to the SmartcardExtension structure.
    pCommand : Iso out command to send.
    pData : data to send.
    pRespLen :  in  - maximum buffer size available
                out - returned buffer length.
    pRespBuff: returned buffer
--*/
{
    //  Local variables:
    //   - pReaderExt holds the pointer to the current ReaderExtension structure
    //   - Ti holds the apdu command tag.
    //   - Li holds the Iso out command length.
    //   - Vi holds Icc ISO In command whose format is
    //        <DIR=0x00> <CLA> <INS> <P1> <P2> <Length> [ Data ]
    //         Length = Length  + Dir + CLA + INS + P1 + P2
    //   - To holds the response tag
    //   - Lo holds th response buffer length.
    //   - Vo holds the response buffer
    READER_EXTENSION *pReaderExt = pSmartcardExtension->ReaderExtension;
    UCHAR Vi[GPR_BUFFER_SIZE] = { 0x00 };
    UCHAR Ti = APDU_EXCHANGE_CMD;
    UCHAR To;
    UCHAR Vo[GPR_BUFFER_SIZE];
    USHORT Li;
    USHORT Lo;
    NTSTATUS lStatus=STATUS_SUCCESS;

    // Length of the the TLV = Length of data + 6
    Li = pCommand[4]+6,

    // The five command bytes are added in cmd buffer.
    RtlCopyMemory(Vi + 1, pCommand, 5);
    
    //The data field is added.
    RtlCopyMemory(Vi + 6, pData, pCommand[4]);

    // The command is send to IFD.
    // Fields RespLen and RespBuff are updates
    // <= sResponse
    Lo = *pRespLen;

    lStatus = GprllTLVExchange(
        pReaderExt,
        Ti,
        Li,
        Vi,
        &To,
        &Lo,
        Vo
        );

    if (lStatus == STATUS_SUCCESS)
    {
        *pRespLen = Lo;
        RtlCopyMemory(pRespBuff, Vo, Lo);
    }
    else
    {
        *pRespLen = 0;
    }

   return (lStatus);
}



NTSTATUS IccIsoT1(
   PSMARTCARD_EXTENSION pSmartcardExtension,
   const USHORT     Li,
   const UCHAR      Vi[],
         USHORT     *Lo,
         UCHAR      Vo[]
    )
/*++


  Routine Description :  This function sends a T=1 frame to the card



  Arguments
    pSmartcardExtension: Pointer to the SmartcardExtension structure.
    Li : Length of the frame to send.
    Vi : frame to send.
    Lo :  in  - maximum buffer size available
          out - Length of the response buffer.
    Vo : Response buffer.
--*/
{
    //   Local variables:
    // - pReaderExt holds the pointer to the current ReaderExtension structure
    // - Ti Tag in TLV structure to send.
    // - To Tag in response TLV structure.
    UCHAR Ti = APDU_EXCHANGE_CMD;
    UCHAR To;
    NTSTATUS lStatus = STATUS_SUCCESS;
    READER_EXTENSION *pReaderExt = pSmartcardExtension->ReaderExtension;

    To = 0x00;

    // Return value for To is not needed, The function GprllTLVExchange verify that
    // it corresponds to the Ti
    lStatus = GprllTLVExchange(
        pReaderExt,
        Ti,
        Li,
        Vi,
        &To,
        Lo,
        Vo
        );
    
    return (lStatus);
}



NTSTATUS IfdConfig(
   PSMARTCARD_EXTENSION pSmartcardExtension,
   UCHAR  TA1
)
/*++

  Routine Description : This function Sets the correct internal values of the reader
               regarding the TA1 of the ATR.

  Arguments
    pSmartcardExtension: Pointer to the SmartcardExtension structure.
--*/
{
    //  Local variables:
    //   - sResponse holds the called function responses.
    //   - pReaderExt holds the pointer to the current ReaderExtension structure
    //   - lStatus holds the status to return.
    //   - Vi Holds the input buffer of the TLV commnand.
    //   - To holds the Tag of the returned TLV.
    //   - Lo holds the Length of the buffer of the returned TLV.
    //   - Vo holds the Buffer of the returned TLV.
    //
    UCHAR Card_ETU1;
    UCHAR Card_ETU2;
    UCHAR Card_ETU1P;
    UCHAR Card_TA1;
    READER_EXTENSION *pReaderExt = pSmartcardExtension->ReaderExtension;   
    NTSTATUS lStatus = STATUS_SUCCESS;
    USHORT i = 0;

    // search TA1 parameters
    do {
        if ( TA1 == cfg_ta1[i].TA1 )
        {
            break;
        }
        i++;
    } while ( cfg_ta1[i].TA1 != 0 );


    if(cfg_ta1[i].TA1 != 0)
    {
        Card_TA1  = cfg_ta1[i].TA1;
        Card_ETU1 = cfg_ta1[i].ETU1;
        Card_ETU2 = cfg_ta1[i].ETU2;
        Card_ETU1P= cfg_ta1[i].ETU1P;
    }
    else
    {
        // Default value 9600
        Card_TA1  = 0x11;
        Card_ETU1 = 0x3B;
        Card_ETU2 = 0x1E;
        Card_ETU1P= 0x37;
    }

    // Verify each update to be done

    //Set the TA1
    lStatus = Update(pSmartcardExtension,0x32,Card_TA1);
    if (lStatus != STATUS_SUCCESS)
    {
        return (lStatus);
    }

    //Set the Card ETU1
    lStatus = Update(pSmartcardExtension,0x35,Card_ETU1);
    if (lStatus != STATUS_SUCCESS)
    {
        return (lStatus);
    }

    //Set the Card ETU2
    lStatus = Update(pSmartcardExtension,0x36,Card_ETU2);
    if (lStatus != STATUS_SUCCESS)
    {
        return (lStatus);
    }

    //Set the Card ETU1 P
    lStatus = Update(pSmartcardExtension,0x39,Card_ETU1P);
    if (lStatus != STATUS_SUCCESS)
    {
        return (lStatus);
    }

    //Set the Save TA1
    lStatus = Update(pSmartcardExtension,0x3A,Card_TA1);
    if (lStatus != STATUS_SUCCESS)
    {
        return (lStatus);
    }

    //Set the Save ETU1
    lStatus = Update(pSmartcardExtension,0x3D,Card_ETU1);
    if (lStatus != STATUS_SUCCESS)
    {
        return (lStatus);
    }

    //Set the Save ETU2
    lStatus = Update(pSmartcardExtension,0x3E,Card_ETU2);
    if (lStatus != STATUS_SUCCESS)
    {
        return (lStatus);
    }

    //Set the Save ETU1 P
    lStatus = Update(pSmartcardExtension,0x41,Card_ETU1P);
    if (lStatus != STATUS_SUCCESS)
    {
        return (lStatus);
    }

    // Give the reader the time to process the change
    GprllWait(100);

    return (STATUS_SUCCESS);

}


NTSTATUS IfdCheck(
    PSMARTCARD_EXTENSION pSmartcardExtension
    )
/*++

  Routine Description : This function performs a software reset of the GPR400 using 
        the Handshake register and TEST if hardware okay.

  Arguments
    pSmartcardExtension: Pointer to the SmartcardExtension structure.
--*/
{
    //  Local variables:
    //   - pReaderExt holds the pointer to the current ReaderExtension structure
    //   - HandShakeRegister
    //
    READER_EXTENSION *pReaderExt = pSmartcardExtension->ReaderExtension;
    UCHAR HandShakeRegister;

#if DBG
    SmartcardDebug( 
        DEBUG_ERROR, 
        ( "%s!IfdCheck: Enter\n",
        SC_DRIVER_NAME)
        );
#endif

    // In the case that system reboot for Hibernate in
    // Power management. The GPR400 signal a device was been remove
    // but we have to request a second time to have the actual
    // state of the reader.

    HandShakeRegister = GprllReadRegister(pReaderExt,REGISTER_HANDSHAKE);

    SmartcardDebug( 
        DEBUG_DRIVER, 
        ("%s!IfdCheck: Read HandShakeRegister value:%x\n",
        SC_DRIVER_NAME, HandShakeRegister)
        );

    //Set to 1 the Master Reset bit from Handshake register
    GprllMaskHandshakeRegister(pReaderExt,0x01,1);

    //Wait 10 ms
    GprllWait(10);
    
    //Reset the Master Reset bit from Handshake register
    GprllMaskHandshakeRegister(pReaderExt,0x01,0);

    //Wait 80 ms
    GprllWait(80);

    HandShakeRegister = GprllReadRegister(pReaderExt,REGISTER_HANDSHAKE);

    SmartcardDebug( 
        DEBUG_DRIVER, 
        ("%s!IfdCheck: Read HandShakeRegister 2nd time value:%x\n",
        SC_DRIVER_NAME, HandShakeRegister)
        );

    if(HandShakeRegister != 0x80)
    {
        // Return reader IO problem
        return (STATUS_IO_DEVICE_ERROR);
    }

    return (STATUS_SUCCESS);
}


NTSTATUS IfdReset(
    PSMARTCARD_EXTENSION pSmartcardExtension
    )
/*++

  Routine Description : This function performs a software reset of the GPR400 using
        the Handshake register.

  Arguments
    pSmartcardExtension: Pointer to the SmartcardExtension structure.
--*/
{
    //  Local variables:
    //   - sResponse holds the called function responses.
    //   - pReaderExt holds the pointer to the current ReaderExtension structure
    //   - lStatus holds the status to return.
    //   - Vi Holds the input buffer of the TLV commnand.
    //   - To holds the Tag of the returned TLV.
    //   - Lo holds the Length of the buffer of the returned TLV.
    //   - Vo holds the Buffer of the returned TLV.
    READER_EXTENSION *pReaderExt = pSmartcardExtension->ReaderExtension;
    NTSTATUS lStatus = STATUS_SUCCESS;
    UCHAR Vi[GPR_BUFFER_SIZE];
    UCHAR To;
    USHORT Lo;
    UCHAR Vo[GPR_BUFFER_SIZE];

#if DBG
    SmartcardDebug(
        DEBUG_TRACE,
        ( "%s!IfdReset: Enter\n",
        SC_DRIVER_NAME)
        );
#endif

    // In the case that system reboot for Hibernate in
    // Power management. The GPR400 signal a device was been remove
    // but we have to request a second time to have the actual
    // state of the reader.

    //Set to 1 the Master Reset bit from Handshake register
    GprllMaskHandshakeRegister(pReaderExt,0x01,1);

    //Wait 10 ms
    GprllWait(10);
    
    //Reset the Master Reset bit from Handshake register
    GprllMaskHandshakeRegister(pReaderExt,0x01,0);

    //Wait 80 ms
    GprllWait(80);

    //Read the GPR status
    Vi[0] = 0x00;
    Lo = GPR_BUFFER_SIZE;

    lStatus = GprllTLVExchange (
        pReaderExt,
        CHECK_AND_STATUS_CMD,
        0x01,
        Vi,
        &To,
        &Lo,
        Vo
        );

#if DBG
      SmartcardDebug(
         DEBUG_TRACE,
         ( "%s!IfdReset: GprllTLVExchange status= %x\n",
         SC_DRIVER_NAME, lStatus)
         );
#endif      

        if (lStatus != STATUS_SUCCESS)
        {
        SmartcardDebug(
            DEBUG_TRACE,
            ( "%s!IfdReset: GprllTLVExchange() failed! Leaving.....\n",
            SC_DRIVER_NAME)
            );
    
            return (lStatus);
    }

    //Memorize the GPR400 version
    pReaderExt->OsVersion = Vo[1];

    pSmartcardExtension->VendorAttr.IfdVersion.VersionMinor =
        pReaderExt->OsVersion & 0x0f;

    pSmartcardExtension->VendorAttr.IfdVersion.VersionMajor =
        (pReaderExt->OsVersion & 0xf0) >> 4;

        SmartcardDebug(
            DEBUG_TRACE,
            ( "%s!IfdReset: Loading Master driver...\n",
            SC_DRIVER_NAME)
            );
    
    //Load the Master Driver in RAM at @2100h
    Vi[0] = 0x02;  // DIR
    Vi[1] = 0x01 ; // ADR MSB
    Vi[2] = 0x00 ; // ADR LSB
    memcpy(&Vi[3], MASTER_DRIVER, sizeof(MASTER_DRIVER));
    // Output variable initialisation
    Lo = GPR_BUFFER_SIZE;
    To = 0x00;
    Vo[0] = 0x00;

    lStatus = GprllTLVExchange (
        pReaderExt,
        LOAD_MEMORY_CMD,
        sizeof(MASTER_DRIVER) + 3,
        Vi,
        &To,
        &Lo,
        Vo
        );
    if (lStatus != STATUS_SUCCESS)
    {
        SmartcardDebug(
            DEBUG_TRACE,
            ( "%s!IfdReset: GprllTLVExchange() failed! Leaving.....\n",
            SC_DRIVER_NAME)
            );
        return (lStatus);
    }

    lStatus = ValidateDriver(pSmartcardExtension);
    if (lStatus != STATUS_SUCCESS)
    {
        SmartcardDebug(
            DEBUG_TRACE,
            ( "%s!IfdReset: ValidateDriver() failed! Leaving.....\n",
            SC_DRIVER_NAME)
            );
        return (lStatus);
    }

    return (STATUS_SUCCESS);

}



NTSTATUS IfdPowerDown(
    PSMARTCARD_EXTENSION pSmartcardExtension
    )
/*++

  Routine Description :
    This function powers down the IFD

  Arguments
    pSmartcardExtension: Pointer to the SmartcardExtension structure.

  --*/
{
    //  Local variables:
    //   - sResponse holds the called function responses.
    //   - pReaderExt holds the pointer to the current ReaderExtension structure
    //   - lStatus holds the status to return.
    //   - Vi Holds the input buffer of the TLV commnand.
    //   - To holds the Tag of the returned TLV.
    //   - Lo holds the Length of the buffer of the returned TLV.
    //   - Vo holds the Buffer of the returned TLV.
    READER_EXTENSION *pReaderExt = pSmartcardExtension->ReaderExtension;
    NTSTATUS lStatus = STATUS_SUCCESS;
    UCHAR Vi[GPR_BUFFER_SIZE];
    UCHAR To;
    USHORT Lo;
    UCHAR Vo[GPR_BUFFER_SIZE];

    // Put the GPR in Power-down mode (GprllTLVExchange T=0x40, L=1 and V=0x00)
    // <==      response of the GprllTLVExchange
    Vi[0] = 0x00;
    // Output variable initialisation
    Lo = GPR_BUFFER_SIZE;
    To = 0x00;
    Vo[0] = 0x00;

    lStatus = GprllTLVExchange(
        pReaderExt,
        POWER_DOWN_GPR_CMD,
        0x01,
        Vi,
        &To,
        &Lo,
        Vo
        );

    return (lStatus);
}


NTSTATUS GprCbReaderPower(
    PSMARTCARD_EXTENSION SmartcardExtension
    )
/*++

  Routine Description :
   This function is called by the Smart card library when a
     IOCTL_SMARTCARD_POWER occurs.
   This function provides 3 differents functionnality, depending of the minor
   IOCTL value
     - Cold reset (SCARD_COLD_RESET),
     - Warm reset (SCARD_WARM_RESET),
     - Power down (SCARD_POWER_DOWN).

  Arguments
      - SmartcardExtension is a pointer on the SmartCardExtension structure of
      the current device.
--*/
{
    NTSTATUS lStatus = STATUS_SUCCESS;
    PREADER_EXTENSION pReader;

    ASSERT(SmartcardExtension != NULL);

    pReader = SmartcardExtension->ReaderExtension;
    waitForIdleAndBlock(pReader);
    switch(SmartcardExtension->MinorIoControlCode)
    {
        case SCARD_POWER_DOWN:
            //Power down the ICC
            lStatus = IccPowerDown(SmartcardExtension);
            break;

        case SCARD_COLD_RESET:
            // Power up the ICC after a power down and a PowerTimeout waiting time.
            lStatus = IccPowerDown(SmartcardExtension);
            if(lStatus != STATUS_SUCCESS)
            {
                break;
            }

            // Waits for the Power Timeout to be elapsed before the reset command.
            GprllWait(SmartcardExtension->ReaderExtension->PowerTimeOut);

        case SCARD_WARM_RESET:
            lStatus = IccColdReset(SmartcardExtension);
            break;

        default:
            lStatus = STATUS_NOT_SUPPORTED;
    }

    setIdle(pReader);
    return lStatus;
}

NTSTATUS GprCbTransmit(
    PSMARTCARD_EXTENSION SmartcardExtension
    )
/*++

  Routine Description :

     This function is called by the Smart card library when a
     IOCTL_SMARTCARD_TRANSMIT occurs.
   This function is used to transmit a command to the card.

  Arguments
    - SmartcardExtension is a pointer on the SmartCardExtension structure of
      the current device.
--*/
{
    NTSTATUS lStatus=STATUS_SUCCESS;
    PUCHAR requestBuffer = SmartcardExtension->SmartcardRequest.Buffer;
    PUCHAR replyBuffer = SmartcardExtension->SmartcardReply.Buffer;
    PULONG requestLength = &SmartcardExtension->SmartcardRequest.BufferLength;
    PULONG replyLength = &SmartcardExtension->SmartcardReply.BufferLength;
    USHORT sRespLen;
    UCHAR pRespBuff[GPR_BUFFER_SIZE];
    PREADER_EXTENSION pReader;

    ASSERT(SmartcardExtension != NULL);

    *requestLength = 0;
    sRespLen = 0;
    pRespBuff[0] = 0x0;

    pReader = SmartcardExtension->ReaderExtension;
    waitForIdleAndBlock(pReader);
    switch (SmartcardExtension->CardCapabilities.Protocol.Selected)
    {
        // Raw
        case SCARD_PROTOCOL_RAW:
            lStatus = STATUS_INVALID_DEVICE_STATE;
            break;

        // T=0
        case SCARD_PROTOCOL_T0:
            lStatus = SmartcardT0Request(SmartcardExtension);
            if (lStatus != STATUS_SUCCESS)
            {
                setIdle(pReader);
                return lStatus;
            }

            sRespLen = GPR_BUFFER_SIZE;
            pRespBuff[0] = 0x0;
            
            if (SmartcardExtension->T0.Le > 0)
            {
                // ISO OUT command  if BufferLength = 5
                lStatus = IccIsoOutput(
                    SmartcardExtension,
                    ( UCHAR *) SmartcardExtension->SmartcardRequest.Buffer,
                    &sRespLen,
                    pRespBuff
                    );
            }
            else
            {
                // ISO IN command   if BufferLength >5 or BufferLength = 4
                lStatus = IccIsoInput(
                    SmartcardExtension,
                    ( UCHAR *) SmartcardExtension->SmartcardRequest.Buffer,
                    ( UCHAR *) SmartcardExtension->SmartcardRequest.Buffer+5,
                    &sRespLen,
                    pRespBuff
                    );
            }
            if (lStatus != STATUS_SUCCESS)
            {
                setIdle(pReader);
                return lStatus;
            }
            // Copy the response command without the reader status

            // Verify if the buffer is large enough
            if (SmartcardExtension->SmartcardReply.BufferSize >= (ULONG)(sRespLen - 1))
            {
                RtlCopyMemory(
                    SmartcardExtension->SmartcardReply.Buffer,
                    pRespBuff + 1,
                    sRespLen - 1);
                SmartcardExtension->SmartcardReply.BufferLength =
                    (ULONG) (sRespLen - 1);
            }
            else
            {
                        // SmartcardT0Reply must be called; prepare this call.
                    SmartcardExtension->SmartcardReply.BufferLength = 0;
            }
            lStatus = SmartcardT0Reply(SmartcardExtension);
            
            break;
        // T=1
        case SCARD_PROTOCOL_T1:

            do
            {
                SmartcardExtension->SmartcardRequest.BufferLength = 0;
                lStatus = SmartcardT1Request(SmartcardExtension);
                if(lStatus != STATUS_SUCCESS)
                {
                    setIdle(pReader);
                    return lStatus;
                }

                sRespLen = GPR_BUFFER_SIZE;
                pRespBuff[0] = 0x0;
                lStatus = IccIsoT1(
                    SmartcardExtension,
                    (USHORT) SmartcardExtension->SmartcardRequest.BufferLength,
                    (UCHAR *) SmartcardExtension->SmartcardRequest.Buffer,
                    &sRespLen,
                    pRespBuff);

                if(lStatus != STATUS_SUCCESS)
                {
                    // do not try to access the reader anymore.
                    if(lStatus == STATUS_DEVICE_REMOVED)
                    {
                        setIdle(pReader);
                        return lStatus;
                    }
                        // Let the SmartcardT1Reply determine the status
                    sRespLen = 1;
                }
                // Copy the response of the reader in the reply buffer
                // Remove the status of the reader
                // Verify if the buffer is large enough
                if (SmartcardExtension->SmartcardReply.BufferSize >= (ULONG)(sRespLen - 1))
                {
                    RtlCopyMemory(
                        SmartcardExtension->SmartcardReply.Buffer,
                        pRespBuff + 1 ,
                        sRespLen - 1
                        );
                    SmartcardExtension->SmartcardReply.BufferLength =
                        (ULONG) sRespLen - 1;
                }
                else
                {
                    // SmartcardT1Reply must be called; prepare this call.
                    SmartcardExtension->SmartcardReply.BufferLength = 0;
                }

                lStatus = SmartcardT1Reply(SmartcardExtension);

            } while(lStatus == STATUS_MORE_PROCESSING_REQUIRED);
            break;
        default:
            lStatus = STATUS_INVALID_DEVICE_REQUEST;
            break;
    }

    setIdle(pReader);
    return lStatus;
}


NTSTATUS GprCbSetProtocol(
   PSMARTCARD_EXTENSION SmartcardExtension
)
/*++

  Routine Description :

      This function is called by the Smart card library when a
      IOCTL_SMARTCARD_SET_PROTOCOL occurs.
    The minor IOCTL value holds the protocol to set.

  Arguments
    - SmartcardExtension is a pointer on the SmartCardExtension structure of
      the current device.
--*/
{
    NTSTATUS lStatus=STATUS_SUCCESS;
    UCHAR Vi[GPR_BUFFER_SIZE];
    UCHAR To;
    USHORT Lo;
    UCHAR Vo[GPR_BUFFER_SIZE];
    READER_EXTENSION *pReaderExt = SmartcardExtension->ReaderExtension;
    UCHAR PTS0=0;
    UCHAR Value = 0;
    PREADER_EXTENSION pReader;
    KIRQL irql;


    ASSERT(SmartcardExtension != NULL);


    pReader = SmartcardExtension->ReaderExtension;
    
    waitForIdleAndBlock(pReader);
    
    //  Check if the card is already in specific state
    //  and if the caller wants to have the already selected protocol.
    //  We return success if this is the case.
    //
    *SmartcardExtension->IoRequest.Information = 0x00;

	if ( SmartcardExtension->ReaderCapabilities.CurrentState == SCARD_SPECIFIC &&
		 ( SmartcardExtension->CardCapabilities.Protocol.Selected &
		   SmartcardExtension->MinorIoControlCode
         )
       )
    {
		lStatus = STATUS_SUCCESS;
	}
	else
    {

      __try
        {
            if (SmartcardExtension->CardCapabilities.Protocol.Supported &
                SmartcardExtension->MinorIoControlCode &
                SCARD_PROTOCOL_T1)
            {

                // select T=1
                SmartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_T1;
                PTS0= 0x11;
            }
            else if (SmartcardExtension->CardCapabilities.Protocol.Supported &
                    SmartcardExtension->MinorIoControlCode &
                    SCARD_PROTOCOL_T0)
            {

                // select T=0
                SmartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_T0;
                PTS0 = 0x10;

            }
            else
            {
                lStatus = STATUS_INVALID_DEVICE_REQUEST;
                __leave;
            }


            // Send the PTS function
            Vi[0] = 0xFF;
            Vi[1] = PTS0;
            Vi[2] = SmartcardExtension->CardCapabilities.PtsData.Fl <<4 |
                    SmartcardExtension->CardCapabilities.PtsData.Dl;
            Vi[3] = (0xFF ^ PTS0) ^ Vi[2];
    
            Lo = GPR_BUFFER_SIZE;
            To = 0x00;
            Vo[0] = 0x00;


            // Status of the PTS could be STATUS SUCCESS
            // or STATUS_DEVICE_PROTOCOL_ERROR if failed.
            lStatus = GprllTLVExchange(
                    pReaderExt,
                    EXEC_MEMORY_CMD,
                    0x04,
                    Vi,
                    &To,
                    &Lo,
                    Vo
                    );

#if DBG
            SmartcardDebug(
                DEBUG_TRACE,
                ( "%s!IfdReset: GprCbSetProtocol status= %x\n",
                SC_DRIVER_NAME, lStatus)
                );
#endif      

            if (lStatus != STATUS_SUCCESS)
            {
                __leave;
            }


            // reader should reply status byte of 00 or 12
            // the rest is other problem with no relation with
            // the PTS negociation
            lStatus = STATUS_SUCCESS;

            // Put the reader in the right protocol
            if (SmartcardExtension->CardCapabilities.Protocol.Selected == SCARD_PROTOCOL_T1)
            {
                lStatus = T0toT1(SmartcardExtension);
            }
            else
            {
                lStatus = T1toT0(SmartcardExtension);
            }
            if (lStatus != STATUS_SUCCESS)
            {
                __leave;
            }


            lStatus = IfdConfig(SmartcardExtension, 0x11);
            if (lStatus != STATUS_SUCCESS)
            {
                __leave;
            }

        }
        // we change the error code to a protocol error.
        __finally
        {
            if (lStatus != STATUS_SUCCESS &&
                lStatus != STATUS_INVALID_DEVICE_REQUEST
                )
            {
                lStatus = STATUS_DEVICE_PROTOCOL_ERROR;
            }

        }

    }

   
    //
    //  Set the reply buffer length to sizeof(ULONG).
    //  Check if status SUCCESS, store the selected protocol.
    //

    KeAcquireSpinLock(&SmartcardExtension->OsData->SpinLock,
                      &irql);

    if (lStatus == STATUS_SUCCESS)
    {
        *SmartcardExtension->IoRequest.Information =
            sizeof(SmartcardExtension->CardCapabilities.Protocol.Selected);

        *( PULONG) SmartcardExtension->IoRequest.ReplyBuffer =
            SmartcardExtension->CardCapabilities.Protocol.Selected;

        SmartcardExtension->ReaderCapabilities.CurrentState = SCARD_SPECIFIC;
    }
    else
    {
        SmartcardExtension->CardCapabilities.Protocol.Selected =
            SCARD_PROTOCOL_UNDEFINED;
        *SmartcardExtension->IoRequest.Information = 0;
    }
    KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                      irql);

    setIdle(pReader);
    return lStatus;

}


NTSTATUS AskForCardPresence(
    PSMARTCARD_EXTENSION pSmartcardExtension
)
/*++

  Routine Description :
    
    This functions send a TLV command to the reader to know if there
    is a card inserted.

    The function does not wait to the answer. The treatment of the
    answer is done in the interrupt routine.

  Arguments
    
      pSmartcardExtension: Pointer to the SmartcardExtension structure.
--*/
{
    // Local variables:
    //  - pReaderExt holds the pointer to the current ReaderExtension structure
    //  - V holds the value for the TLV comand.
    READER_EXTENSION *pReaderExt = pSmartcardExtension->ReaderExtension;
    UCHAR V=0x02;

    GprllSendCmd(pReaderExt,CHECK_AND_STATUS_CMD,1,&V);

    return (STATUS_SUCCESS);
}


NTSTATUS SpecificTag(
    PSMARTCARD_EXTENSION SmartcardExtension,
    DWORD                IoControlCode,
    DWORD                BufferInLen,
    BYTE                *BufferIn,
    DWORD                BufferOutLen,
    BYTE                *BufferOut,
    DWORD               *LengthOut
)
/*++


  Routine Description :
   This function is called when a specific Tag request occurs.

  Arguments
    - SmartcardExtension is a pointer on the SmartCardExtension structure of
      the current device.
    - IoControlCode holds the IOCTL value.
--*/
{
    ULONG TagValue;
    PREADER_EXTENSION pReaderExtension = SmartcardExtension->ReaderExtension;

    //Set the reply buffer length to 0.
    *LengthOut = 0;

    //Verify the length of the Tag
    //<==   STATUS_BUFFER_TOO_SMALL
    if (BufferInLen < (DWORD) sizeof(TagValue))
    {
        return(STATUS_BUFFER_TOO_SMALL);
    }


    TagValue = (ULONG) *((PULONG)BufferIn);

    //Switch for the different IOCTL:
    //Get the value of one tag (IOCTL_SMARTCARD_VENDOR_GET_ATTRIBUTE)
    //Switch for the different Tags:
    switch(IoControlCode)
    {
        case IOCTL_SMARTCARD_VENDOR_GET_ATTRIBUTE:
            switch (TagValue)
            {
                // Power Timeout (SCARD_ATTR_SPEC_POWER_TIMEOUT)
                //   Verify the length of the output buffer.
                // <==               STATUS_BUFFER_TOO_SMALL
                //   Update the output buffer and the length.
                // <==               STATUS_SUCCESS
                case SCARD_ATTR_SPEC_POWER_TIMEOUT:
                    if ( BufferOutLen < (DWORD) sizeof(pReaderExtension->PowerTimeOut))
                    {
                        return(STATUS_BUFFER_TOO_SMALL);
                    }
                    ASSERT(BufferOut != 0);
                    memcpy(
                        BufferOut,
                        &pReaderExtension->PowerTimeOut,
                        sizeof(pReaderExtension->PowerTimeOut)
                        );
                    
                    *(LengthOut) =
                        (ULONG) sizeof(pReaderExtension->PowerTimeOut);
                    
                    return STATUS_SUCCESS;
                    break;
                // Command Timeout (SCARD_ATTR_SPEC_CMD_TIMEOUT)
                //   Verify the length of the output buffer.
                // <==               STATUS_BUFFER_TOO_SMALL
                //   Update the output buffer and the length.
                // <==               STATUS_SUCCESS
                case SCARD_ATTR_SPEC_CMD_TIMEOUT:
                    if (BufferOutLen < (DWORD) sizeof(pReaderExtension->CmdTimeOut))
                    {
                        return(STATUS_BUFFER_TOO_SMALL);
                    }
                    ASSERT(BufferOut != 0);
                    memcpy(
                        BufferOut,
                        &pReaderExtension->CmdTimeOut,
                        sizeof(pReaderExtension->CmdTimeOut)
                        );
                    *(LengthOut) =
                        (ULONG) sizeof(pReaderExtension->CmdTimeOut);
                    
                    return STATUS_SUCCESS;
                    
                    break;

                case SCARD_ATTR_MANUFACTURER_NAME:
                    if (BufferOutLen < ATTR_LENGTH)
                    {
                        return STATUS_BUFFER_TOO_SMALL;
                    }
                    // Copy the string of the Manufacturer Name

                    memcpy(
                        BufferOut,
                        ATTR_MANUFACTURER_NAME,
                        sizeof(ATTR_MANUFACTURER_NAME)
                        );

                    *(LengthOut) = (ULONG)sizeof(ATTR_MANUFACTURER_NAME);

                    return STATUS_SUCCESS;
                    break;

                case SCARD_ATTR_ORIGINAL_FILENAME:
                    if (BufferOutLen < ATTR_LENGTH)
                    {
                        return STATUS_BUFFER_TOO_SMALL;
                    }
                    // Copy the string of the Original file name of the current driver
                    memcpy(
                        BufferOut,
                        ATTR_ORIGINAL_FILENAME,
                        sizeof(ATTR_ORIGINAL_FILENAME)
                        );

                    *(LengthOut) = (ULONG)sizeof(ATTR_ORIGINAL_FILENAME);

                    return STATUS_SUCCESS;
                    break;

                // Unknown tag
                // <==            STATUS_NOT_SUPPORTED
                default:
                    return STATUS_NOT_SUPPORTED;
                    break;
            }
            break;

        // Set the value of one tag (IOCTL_SMARTCARD_VENDOR_SET_ATTRIBUTE)
        // Switch for the different Tags:
        case IOCTL_SMARTCARD_VENDOR_SET_ATTRIBUTE:
            switch (TagValue)
            {
                // Power Timeout (SCARD_ATTR_SPEC_POWER_TIMEOUT)
                // Verify the length of the input buffer.
                // <==               STATUS_BUFFER_TOO_SMALL
                // Update the value.
                // <==               STATUS_SUCCESS


                case SCARD_ATTR_SPEC_POWER_TIMEOUT:
                    if (  BufferInLen <
                        (DWORD)  (sizeof(pReaderExtension->PowerTimeOut) +
                        sizeof(TagValue))
                        )
                    {
                        return(STATUS_BUFFER_TOO_SMALL);
                    }
                    ASSERT(BufferIn !=0);
                    memcpy(
                        &pReaderExtension->PowerTimeOut,
                        BufferIn + sizeof(TagValue),
                        sizeof(pReaderExtension->PowerTimeOut)
                        );
                    return STATUS_SUCCESS;
                    break;
                // Command Timeout (SCARD_ATTR_SPEC_CMD_TIMEOUT)
                // Verify the length of the input buffer.
                // <==               STATUS_BUFFER_TOO_SMALL
                // Update the value.
                // <==               STATUS_SUCCESS


                case SCARD_ATTR_SPEC_CMD_TIMEOUT:
                    if ( BufferInLen <
                        (DWORD) (   sizeof(pReaderExtension->CmdTimeOut) +
                        sizeof(TagValue))
                        )
                    {
                        return(STATUS_BUFFER_TOO_SMALL);
                    }
                    ASSERT(BufferIn != 0);
                    memcpy(
                        &pReaderExtension->CmdTimeOut,
                        BufferIn + sizeof(TagValue),
                        sizeof(pReaderExtension->CmdTimeOut)
                        );
                    return STATUS_SUCCESS;
                    break;
                // Unknown tag
                // <==            STATUS_NOT_SUPPORTED
                default:
                    return STATUS_NOT_SUPPORTED;
            }
            break;
        default:
            return STATUS_NOT_SUPPORTED;
    }
}


NTSTATUS SwitchSpeed(
    PSMARTCARD_EXTENSION   SmartcardExtension,
    ULONG                  BufferInLen,
    PUCHAR                 BufferIn,
    ULONG                  BufferOutLen,
    PUCHAR                 BufferOut,
    PULONG                 LengthOut
    )
/*++

Routine Description:

   This function is called when apps want to switch reader speed after a
   proprietary switch speed (switch protocol) command has been sent to the
   smart card.

Arguments:

   SmartcardExtension   - is a pointer on the SmartCardExtension structure of
                           the current device.
   BufferInLen          - holds the length of the input data.
   BufferIn             - holds the input data.  TA1.  If 0 
   BufferOutLen         - holds the size of the output buffer.
   BufferOut            - the output buffer. Reader status code.
   LengthOut            - holds the length of the output data.

  Return Value:

    STATUS_SUCCESS          - We could execute the request.
    STATUS_BUFFER_TOO_SMALL - The output buffer is to small.
    STATUS_NOT_SUPPORTED    - We could not support the Ioctl specified.

--*/
{
    NTSTATUS status;
    BYTE  NewTA1;
    ULONG i;

    ASSERT(SmartcardExtension != NULL);

    *LengthOut = 0;
    // Just checking if IOCTL exists.
    if (BufferInLen == 0)
    {
        SmartcardDebug(
           DEBUG_INFO,
           ("%s!SwitchSpeed: Just checking IOCTL.\n",
           SC_DRIVER_NAME)
           );
        return(STATUS_SUCCESS);
    }
    else
    {
        NewTA1 = BufferIn[0];
        i = 0;
        // Verify if this TA1 is support by the GPR400
        do {
            if ( NewTA1 == cfg_ta1[i].TA1 )
            {
                // TA1 Found!
                break;
            }
            i++;
        } while ( cfg_ta1[i].TA1 != 0 );
    }

    // If 0 means TA1 not found
    if(cfg_ta1[i].TA1 != 0)
    {
        SmartcardDebug(
           DEBUG_INFO,
           ("%s!GDDK_0ASwitchSpeed: 0x%X\n",
           SC_DRIVER_NAME, NewTA1)
           );
        status = IfdConfig(SmartcardExtension, NewTA1);
    }
    else
    {
        // TA1 not supported
        return STATUS_NOT_SUPPORTED;
    }

    return status;
}



NTSTATUS GprCbVendorIoctl(
    PSMARTCARD_EXTENSION   SmartcardExtension
)
/*++

  Routine Description :

   This routine is called when a vendor IOCTL_SMARTCARD_ is send to the driver.

  Arguments
    - SmartcardExtension is a pointer on the SmartCardExtension structure of
      the current device.

  Return Value:

    STATUS_SUCCESS          - We could execute the request.
    STATUS_BUFFER_TOO_SMALL - The output buffer is to small.
    STATUS_NOT_SUPPORTED    - We could not support the Ioctl specified.
--*/
{
    PREADER_EXTENSION pReaderExtension = SmartcardExtension->ReaderExtension;
    UCHAR To;
    UCHAR Vo[GPR_BUFFER_SIZE];
    USHORT Lo;
    USHORT BufferInLen = 0;
    NTSTATUS lStatus=STATUS_SUCCESS;
    PREADER_EXTENSION pReader;

    ASSERT(SmartcardExtension != NULL);

   // Set the reply buffer length to 0.
    *SmartcardExtension->IoRequest.Information = 0;


    pReader = SmartcardExtension->ReaderExtension;
    
    waitForIdleAndBlock(pReader);
    
    //Switch for the different IOCTL:

    switch(SmartcardExtension->MajorIoControlCode)
    {

        case IOCTL_SMARTCARD_VENDOR_GET_ATTRIBUTE:
        case IOCTL_SMARTCARD_VENDOR_SET_ATTRIBUTE:
            SpecificTag(
                SmartcardExtension,
                (ULONG)  SmartcardExtension->MajorIoControlCode,
                (ULONG)  SmartcardExtension->IoRequest.RequestBufferLength,
                (PUCHAR) SmartcardExtension->IoRequest.RequestBuffer,
                (ULONG)  SmartcardExtension->IoRequest.ReplyBufferLength,
                (PUCHAR) SmartcardExtension->IoRequest.ReplyBuffer,
                (PULONG) SmartcardExtension->IoRequest.Information
                );
        break;


        // IOCTL_SMARTCARD_VENDOR_IFD_EXCHANGE:
        // Translate the buffer to TLV and send it to the reader.
        case IOCTL_SMARTCARD_VENDOR_IFD_EXCHANGE:

            if(SmartcardExtension->IoRequest.ReplyBufferLength < 3)
            {
                setIdle(pReader);
                return(STATUS_INVALID_BUFFER_SIZE);
            }

            BufferInLen = (SmartcardExtension->IoRequest.RequestBuffer[2]*0x100)
                   +  SmartcardExtension->IoRequest.RequestBuffer[1];

            if( (ULONG) BufferInLen > (SmartcardExtension->IoRequest.ReplyBufferLength - 3))
            {
                setIdle(pReader);
                return(STATUS_INVALID_BUFFER_SIZE);
            }

            Lo = GPR_BUFFER_SIZE;
            To = 0x00;
            Vo[0] = 0x00;

            lStatus = GprllTLVExchange(
                pReaderExtension,
                (const BYTE) SmartcardExtension->IoRequest.RequestBuffer[0],
                (const USHORT) BufferInLen,
                (const BYTE *) &(SmartcardExtension->IoRequest.RequestBuffer[3]),
                &To,
                &Lo,
                Vo
                );

            if (lStatus != STATUS_SUCCESS)
            {
                setIdle(pReader);
                return (lStatus);
            }

            // Check if there is enough space in the reply buffer
            if((ULONG)(Lo+3) > SmartcardExtension->IoRequest.ReplyBufferLength)
            {
                setIdle(pReader);
                return(STATUS_INVALID_BUFFER_SIZE);
            }
            else
            {
                ASSERT(SmartcardExtension->IoRequest.ReplyBuffer != 0);
                SmartcardExtension->IoRequest.ReplyBuffer[0] = To;
                SmartcardExtension->IoRequest.ReplyBuffer[1] = LOBYTE(Lo);
                SmartcardExtension->IoRequest.ReplyBuffer[2] = HIBYTE(Lo);
                memcpy((SmartcardExtension->IoRequest.ReplyBuffer)+3,Vo,Lo);

                *(SmartcardExtension->IoRequest.Information) = (DWORD) (Lo + 3);
                setIdle(pReader);
                return(STATUS_SUCCESS);
            }       
        //
        // For IOCTL_SMARTCARD_VENDOR_SWITCH_SPEED
        //   Call the SwitchSpeed function
        //
        case IOCTL_SMARTCARD_VENDOR_SWITCH_SPEED:
            lStatus = SwitchSpeed(
                SmartcardExtension,
                (ULONG)  SmartcardExtension->IoRequest.RequestBufferLength,
                (PUCHAR) SmartcardExtension->IoRequest.RequestBuffer,
                (ULONG)  SmartcardExtension->IoRequest.ReplyBufferLength,
                (PUCHAR) SmartcardExtension->IoRequest.ReplyBuffer,
                (PULONG) SmartcardExtension->IoRequest.Information
                );
            break;

        default:
            setIdle(pReader);
            return STATUS_NOT_SUPPORTED;
    }
    setIdle(pReader);
    return lStatus;
}



NTSTATUS GprCbSetupCardTracking(
    PSMARTCARD_EXTENSION SmartcardExtension
)
/*++

Routine Description:

   This function is called by the Smart card library when an
     IOCTL_SMARTCARD_IS_PRESENT or IOCTL_SMARTCARD_IS_ABSENT occurs.

Arguments:

   SmartcardExtension   - is a pointer on the SmartCardExtension structure of
                           the current device.

Return Value:

    STATUS_PENDING                - The request is in a pending mode.

--*/
{

    NTSTATUS NTStatus = STATUS_PENDING;
    POS_DEP_DATA pOS = NULL;
    KIRQL oldIrql;

    ASSERT(SmartcardExtension != NULL);

    //
    //Initialize
    //
    pOS = SmartcardExtension->OsData;

    //
    //Set cancel routine for the notification IRP.
    //
    IoAcquireCancelSpinLock(&oldIrql);

    IoSetCancelRoutine(
        pOS->NotificationIrp,
        GprCancelEventWait
        );

    IoReleaseCancelSpinLock(oldIrql);

    NTStatus = STATUS_PENDING;

    return (NTStatus);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\gpr400\gprcmd.h ===
/*++
                 Copyright (c) 1998 Gemplus Development

Name: 
	gprcmd.h 

Description: 
	 This module holds the prototypes of the functions 
	 from gprcmd.c   
Environment:
	Kernel Mode

Revision History: 
    06/04/99:            (Y. Nadeau + M. Veillette)
      - Code Review
	06/05/98: V1.00.003  (P. Plouidy)
		- Power management for NT5 
	10/02/98: V1.00.002  (P. Plouidy)
		- Plug and Play for NT5 
	03/07/97: V1.00.001  (P. Plouidy)
		- Start of development.


--*/


//   Include
//   - smclib.h: smart card library definitions.
#include <smclib.h>


#ifndef _GPRCMD_
#define _GPRCMD_


//
// To give possibility for recognition of driver
//

#define ATTR_MANUFACTURER_NAME      "Gemplus"
#define ATTR_ORIGINAL_FILENAME      "Gpr400.sys"
#define ATTR_LENGTH                 32

//
//   - SCARD_ATTR_SPEC_BAUD_RATE is the Tag for the speed in use between the 
//      system and the reader.
//   - SCARD_ATTR_SPEC_CMD_TIMEOUT is the Tag for the value of the Cmd Timeout.
//   - SCARD_ATTR_SPEC_POWER_TIMEOUT is the Tag for the value of the Power 
//      Timeout.
//   - SCARD_ATTR_SPEC_APDU_TIMEOUT is the Tag to access at the value of the APDU 
//      Timeout.
//
#define SCARD_ATTR_SPEC_BAUD_RATE SCARD_ATTR_VALUE(SCARD_CLASS_VENDOR_DEFINED,0x0180)
#define SCARD_ATTR_SPEC_CMD_TIMEOUT SCARD_ATTR_VALUE(SCARD_CLASS_VENDOR_DEFINED,0x0181)
#define SCARD_ATTR_SPEC_POWER_TIMEOUT SCARD_ATTR_VALUE(SCARD_CLASS_VENDOR_DEFINED,0x0182)
#define SCARD_ATTR_SPEC_APDU_TIMEOUT SCARD_ATTR_VALUE(SCARD_CLASS_VENDOR_DEFINED,0x0183)
#define SCARD_ATTR_MANUFACTURER_NAME  SCARD_ATTR_VALUE(SCARD_CLASS_VENDOR_DEFINED,0x0190)
#define SCARD_ATTR_ORIGINAL_FILENAME  SCARD_ATTR_VALUE(SCARD_CLASS_VENDOR_DEFINED,0x0191)


//
//   - IOCTL_SMARTCARD_VENDOR_IFD_EXCHANGE defines a specific IOCTL for the Gemplus 
//      Reader to exchange data with the reader without control of the driver.
//   - IOCTL_SMARTCARD_VENDOR_GET_ATTRIBUTE defines a specific IOCTL for the Gemplus 
//      Reader to gets vendor attributes.
//   - IOCTL_SMARTCARD_VENDOR_SET_ATTRIBUTE defines a specific IOCTL for the Gemplus 
//      Reader to sets vendor attributes.
//
#define IOCTL_SMARTCARD_VENDOR_IFD_EXCHANGE  CTL_CODE(FILE_DEVICE_SMARTCARD,2048,0,0)
#define IOCTL_SMARTCARD_VENDOR_GET_ATTRIBUTE CTL_CODE(FILE_DEVICE_SMARTCARD,2049,0,0)
#define IOCTL_SMARTCARD_VENDOR_SET_ATTRIBUTE CTL_CODE(FILE_DEVICE_SMARTCARD,2050,0,0)
// 2051 is reserved for Gcr420 keyboard reader.
#define IOCTL_SMARTCARD_VENDOR_SWITCH_SPEED  CTL_CODE(FILE_DEVICE_SMARTCARD,2052,0,0)


#define LOWORD(l)   ((USHORT)(l))
#define HIWORD(l)   ((USHORT)(((UINT)(l)) >> 16))
#define LOBYTE(w)   ((UCHAR)(w))
#define HIBYTE(w)   ((UCHAR)(((USHORT)(w)) >> 8))


USHORT	ATRLen 
(
    UCHAR *ATR,
    USHORT MaxChar
);

BOOLEAN NeedToSwitchWithoutPTS
( 
    BYTE *ATR,
    DWORD LengthATR
);

NTSTATUS ValidateDriver
(
    PSMARTCARD_EXTENSION pSmartcardExtension
);

NTSTATUS Update
(
    PSMARTCARD_EXTENSION pSmartcardExtension,
    UCHAR Addr, 
    UCHAR Value
);


NTSTATUS UpdateORL
(
    PSMARTCARD_EXTENSION pSmartcardExtension,
    UCHAR Addr, 
    UCHAR Value
);

NTSTATUS T0toT1
(
    PSMARTCARD_EXTENSION pSmartcardExtension
);

NTSTATUS T1toT0
(
    PSMARTCARD_EXTENSION pSmartcardExtension
);


//
//   Icc Functions
//
//  - IccColdReset
//  - IccWarmReset
//  - IccPowerDown
//  - IccIsoOutput
//  - IccIsoInput
//  - IccIsoT1
//

NTSTATUS IccColdReset
(
   PSMARTCARD_EXTENSION SmartcardExtension
);

NTSTATUS IccPowerDown
(
   PSMARTCARD_EXTENSION SmartcardExtension
);
NTSTATUS IccIsoOutput
(
   PSMARTCARD_EXTENSION SmartcardExtension,
   const UCHAR			Command[5],
         USHORT			*RespLen,
         UCHAR			RespBuff[]
);
NTSTATUS IccIsoInput
(
   PSMARTCARD_EXTENSION	SmartcardExtension,
   const UCHAR			Command[5],
   const UCHAR			Data[],
         USHORT			*RespLen,
         UCHAR			RespBuff[]
);
NTSTATUS IccIsoT1
(
   PSMARTCARD_EXTENSION SmartcardExtension,
   const USHORT			CmdLen, 
   const UCHAR			Cmd[],
         USHORT			*RspLen,
         UCHAR			Rsp[] 
);


//
//   Ifd Functions
//
//  - IfdReset
//  - IfdCheck
//  - IfdPowerDown
//
NTSTATUS IfdReset
(
   PSMARTCARD_EXTENSION SmartcardExtension
);

NTSTATUS IfdCheck
(
   PSMARTCARD_EXTENSION SmartcardExtension
);

NTSTATUS IfdPowerDown
(
   PSMARTCARD_EXTENSION SmartcardExtension
);

NTSTATUS IfdConfig
(
   PSMARTCARD_EXTENSION pSmartcardExtension,
   UCHAR  TA1
);

//
//   Driver callback Functions
//
//  - GprCbReaderPower
//  - GprCbTransmit
//  - GprCbSetProtocol
//  - GprCbSetupCardTracking
//  - GprCbVendorIoctl
//
NTSTATUS GprCbReaderPower
(
   PSMARTCARD_EXTENSION SmartcardExtension
);
NTSTATUS GprCbTransmit
(
   PSMARTCARD_EXTENSION SmartcardExtension
);
NTSTATUS GprCbSetProtocol
(
   PSMARTCARD_EXTENSION SmartcardExtension
);
NTSTATUS GprCbSetupCardTracking
(
   PSMARTCARD_EXTENSION SmartcardExtension
);
NTSTATUS GprCbVendorIoctl
(
   PSMARTCARD_EXTENSION SmartcardExtension
);


//   Icc detection utilities
//
//   - AskForCardPresence
//
NTSTATUS AskForCardPresence
(
  PSMARTCARD_EXTENSION SmartcardExtension
);

//
//   Specific
//
//   - SpecificTag
//   - SwitchSpeed
//

NTSTATUS SpecificTag
(
	PSMARTCARD_EXTENSION SmartcardExtension,
    DWORD                IoControlCode,
    DWORD                BufferInLen,
    BYTE                *BufferIn,
    DWORD                BufferOutLen,
    BYTE                *BufferOut,
    DWORD               *LengthOut
);


NTSTATUS SwitchSpeed
(
	PSMARTCARD_EXTENSION   SmartcardExtension,
	ULONG                  BufferInLen,
	PUCHAR                 BufferIn,
	ULONG                  BufferOutLen,
	PUCHAR                 BufferOut,
	PULONG                 LengthOut
);



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\gpr400\gprelcmd.c ===
/*++
                 Copyright (c) 1998 Gemplus Development

Name: 
	gprelcmd.c

Description: 
	  This module holds the functions used for the PC Card I/O. 
Environment:
	Kernel Mode

Revision History: 
    06/04/99:            (Y. Nadeau + M. Veillette)
      - Code Review
	24/03/99: V1.00.004  (Y. Nadeau)
		- Fix to GprllWait to work in DPC
	06/05/98: V1.00.003  (P. Plouidy)
		- Power management for NT5 
	10/02/98: V1.00.002  (P. Plouidy)
		- Plug and Play for NT5 
	03/07/97: V1.00.001  (P. Plouidy)
		- Start of development.


--*/


//
//	Include section:
//	   - stdio.h: standards definitons.
//	   - ntddk.h: DDK Windows NT general definitons.
//	   - ntdef.h: Windows NT general definitons.
//
#include <stdio.h>
#include <ntddk.h>
#include <ntdef.h>

#include "gprelcmd.h"

//
// Function definition section:
//
     
#if DBG
void GPR_Debug_Buffer(
   PUCHAR pBuffer,
   DWORD Lenght)
{
   USHORT index;

   SmartcardDebug(
      DEBUG_TRACE,
      (" LEN=%d CMD=",
      Lenght)
      );
   for(index=0;index<Lenght;index++)
   {
      SmartcardDebug(
         DEBUG_TRACE,
         ("%02X,",
         pBuffer[index])
         );
   }
   SmartcardDebug(
      DEBUG_TRACE,
      ("\n")
      );
}
#endif



NTSTATUS GDDK_Translate(
    const BYTE  IFDStatus,
    const UCHAR Tag
    )
/*++

Routine Description:

 Translate IFD status in NT status codes.

Arguments:

   IFDStatus   - is the value to translate.
   IoctlType  - is the current smart card ioctl.
               
Return Value:

    the translated code status.

--*/
{
    switch (IFDStatus)
    {
        case 0x00 : return STATUS_SUCCESS;
        case 0x01 : return STATUS_NO_SUCH_DEVICE;
        case 0x02 : return STATUS_NO_SUCH_DEVICE;
        case 0x03 : return STATUS_INVALID_PARAMETER; 
        case 0x04 : return STATUS_IO_TIMEOUT;
        case 0x05 : return STATUS_INVALID_PARAMETER;
        case 0x09 : return STATUS_INVALID_PARAMETER;
        case 0x0C : return STATUS_DEVICE_PROTOCOL_ERROR;
        case 0x0D : return STATUS_SUCCESS;
        case 0x10 : return STATUS_UNRECOGNIZED_MEDIA;
        case 0x11 : return STATUS_UNRECOGNIZED_MEDIA;
        case 0x12 : return STATUS_INVALID_PARAMETER;
        case 0x13 : return STATUS_CONNECTION_ABORTED;
        case 0x14 : return STATUS_UNRECOGNIZED_MEDIA;
        case 0x15 : return STATUS_UNRECOGNIZED_MEDIA;
        case 0x16 : return STATUS_INVALID_PARAMETER;
        case 0x17 : return STATUS_UNRECOGNIZED_MEDIA;
        case 0x18 : return STATUS_UNRECOGNIZED_MEDIA;
        case 0x19 : return STATUS_INVALID_PARAMETER;
        case 0x1A : return STATUS_INVALID_PARAMETER;
        case 0x1B : return STATUS_INVALID_PARAMETER;
        case 0x1C : return STATUS_INVALID_PARAMETER;
        case 0x1D : return STATUS_UNRECOGNIZED_MEDIA;
        case 0x1E : return STATUS_INVALID_PARAMETER;
        case 0x1F : return STATUS_INVALID_PARAMETER;
        case 0x20 : return STATUS_INVALID_PARAMETER;
        case 0x30 : return STATUS_IO_TIMEOUT;
        case 0xA0 : return STATUS_SUCCESS;
        case 0xA1 : return STATUS_UNRECOGNIZED_MEDIA;
        case 0xA2 : 
            if      (Tag == OPEN_SESSION_CMD)
                    { return STATUS_UNRECOGNIZED_MEDIA;}
            else 
                    { return STATUS_IO_TIMEOUT;        }
        case 0xA3 : return STATUS_PARITY_ERROR;
        case 0xA4 : return STATUS_REQUEST_ABORTED;
        case 0xA5 : return STATUS_REQUEST_ABORTED;
        case 0xA6 : return STATUS_REQUEST_ABORTED;
        case 0xA7 : return STATUS_UNRECOGNIZED_MEDIA;
        case 0xCF : return STATUS_INVALID_PARAMETER;
        case 0xE4 : return STATUS_UNRECOGNIZED_MEDIA;
        case 0xE5 : return STATUS_SUCCESS;
        case 0xE7 : return STATUS_SUCCESS;
        case 0xF7 : return STATUS_NO_MEDIA;
        case 0xF8 : return STATUS_UNRECOGNIZED_MEDIA;
        case 0xFB : return STATUS_NO_MEDIA;

        default   : return STATUS_INVALID_PARAMETER;
    }
}



/*++

  Routine Description : 
	Read a byte at IO address

--*/
BOOLEAN  G_ReadByte(const USHORT BIOAddr,UCHAR *Value)
{
	*Value = READ_PORT_UCHAR((PUCHAR) BIOAddr);
	return(TRUE);
}



/*++

  Routine Description : 
	Write a byte at IO address

--*/
BOOLEAN  G_WriteByte(const USHORT BIOAddr,UCHAR *Value)
{
	WRITE_PORT_UCHAR((PUCHAR) BIOAddr,*Value);
	return(TRUE);
}


/*++

  Routine Description : 
	Read a buffer of "Len" bytes at IO address
--*/
BOOLEAN  G_ReadBuf(const USHORT BIOAddr,const USHORT Len,UCHAR *Buffer)
{                                                                      
    USHORT i;

	for(i=0;i<Len;i++)
    {
		*(Buffer+i) = READ_PORT_UCHAR((UCHAR *) UlongToPtr(BIOAddr+i));
	}						   
#if DBG
   // Excluse reader status reply
   if(! ((Buffer[0] == 0xA2) && (Buffer[1]==4)) )
   {
	   SmartcardDebug(
         DEBUG_TRACE,
         ("%s!G_ReadBuf:",
         SC_DRIVER_NAME)
         );
	   GPR_Debug_Buffer(Buffer, Len );
   }
#endif		
	return(TRUE);
}


/*++

  Routine Description : 
	Write a buffer of "Len" bytes at IO address
--*/
BOOLEAN  G_WriteBuf(const USHORT BIOAddr,const USHORT Len,UCHAR *Buffer)
{

    USHORT i;

	for(i=0;i<Len;i++)
    {
		WRITE_PORT_UCHAR((UCHAR *) UlongToPtr(BIOAddr + i),*(Buffer+i));
	}	
#if DBG
   // Excluse reader status cmd
   if(! ((Buffer[0] == 0xA0) && (Buffer[2] == 0x02)) )
   {
	   SmartcardDebug(
         DEBUG_TRACE,
         ("%s!G_WriteBuf:",
         SC_DRIVER_NAME)
         );
	   GPR_Debug_Buffer(Buffer,Len);
   }
#endif
   
	return(TRUE);

}



/*++

  Routine Description : 
	Mask a register located at a specified address with a specified 
	byte
--*/
BOOLEAN  G_MaskRegister(
    const USHORT BIOAddr,
    const UCHAR Mask,
    const UCHAR BitState)
{
	if(BitState == 0)
    {
		WRITE_PORT_UCHAR((PUCHAR)BIOAddr,(UCHAR) (READ_PORT_UCHAR((PUCHAR)BIOAddr) & ~Mask));   
	}
	else
    {	
		WRITE_PORT_UCHAR((PUCHAR)BIOAddr,(UCHAR) (READ_PORT_UCHAR((PUCHAR)BIOAddr) | Mask));   
	}

	return(TRUE);
}


/*++

  Routine Description : 
	Read a byte to an input address port
--*/
UCHAR  GprllReadRegister(
	const PREADER_EXTENSION      pReaderExt,
	const SHORT					GPRRegister
	)
{   
    //
    // Locals variables:
    //   value holds the result of the read operation.
    //
    UCHAR value;

    value = 0x0;
	G_ReadByte((const USHORT)
		(((const USHORT) (pReaderExt->BaseIoAddress)) + (const USHORT) GPRRegister),
		&value 
		);

	return(value);
}



/*++

  Routine Description : 
	Call the G_MaskRegister function in the lower level 
--*/
void  GprllMaskHandshakeRegister(
	const PREADER_EXTENSION      pReaderExt,
	const UCHAR                 Mask,
	const UCHAR                 BitState
	)
{
	G_MaskRegister((const USHORT)
		(((const USHORT) (pReaderExt->BaseIoAddress)) 
			+ (const USHORT) REGISTER_HANDSHAKE),
		(const UCHAR) Mask,
		(const UCHAR) BitState);
	// YN	
    // get hardware time to update register
    GprllWait(1);
}



NTSTATUS GprllKeWaitAckEvent(
    const	PREADER_EXTENSION	pReaderExt,
    const	UCHAR				Tx
    )
/*++
    Routine Description:
    This function Wait the acknowledge of the GPR after
    a send command to IOPort.  We made a smart verification
    of the timer depending of the Tag command. 
  
    Arguments In:
        pReaderExt holds the pointer to the READER_EXTENSION structure.
        Tx holds the command type
    Return Value:
    NTStatus
--*/
{
    UCHAR T; // Tag return
    LARGE_INTEGER lTimeout;
    NTSTATUS      NTStatus = STATUS_SUCCESS;
    ULONG       NbLoop = 0;
    ULONG       NbSecondTotal;
    ULONG       ElapsedSecond = 0;
    ULONG       TimeInLoop =1;
    BOOLEAN     Continue = TRUE;
    ULONG       i = 0;

	ASSERT( KeGetCurrentIrql() == PASSIVE_LEVEL );

    // Make a smart timer depending on type of command
    if( (Tx & 0xf0) == APDU_EXCHANGE_CMD)
    {
        NbSecondTotal = pReaderExt->CmdTimeOut;
    }
    else 
    {
        NbSecondTotal = GPR_CMD_TIME;
    }

    NbLoop = (NbSecondTotal / TimeInLoop);

    while( (Continue) && (ElapsedSecond < NbSecondTotal) )
    {
        ElapsedSecond += TimeInLoop;

        lTimeout.QuadPart = -((LONGLONG)TimeInLoop * 10000000);

        //Wait the acknowledge of the GPR
        NTStatus = KeWaitForSingleObject(
            &(pReaderExt->GPRAckEvent),
            Executive,
            KernelMode,
            TRUE,
            &lTimeout
            );

        if(NTStatus == STATUS_TIMEOUT)
        {
            // Verify if the reader was been
            // remove during exchange

            lTimeout.QuadPart = 0;

            NTStatus = KeWaitForSingleObject(         
                &(pReaderExt->ReaderRemoved),
                Executive,
                KernelMode,
                FALSE,
                &lTimeout
                );
			SmartcardDebug( 
				DEBUG_PROTOCOL, 
				( "%s!GprllKeWaitAckEvent: TIMEOUT KeWaitForSingleObject=%X(hex)\n",
				SC_DRIVER_NAME,
				NTStatus)
				);

            if (NTStatus == STATUS_SUCCESS)
            {
                NTStatus = STATUS_DEVICE_REMOVED;
                Continue = FALSE;
            }
            // Read the T register
            // <== Test if GPR hasn't been removed STATUS_DEVICE_NOT_CONNECTED


            // Reading T out
            T = GprllReadRegister(pReaderExt,REGISTER_T);
            if ( T == 0xFF )
            {
                NTStatus = STATUS_DEVICE_REMOVED;
                Continue = FALSE;
            }
            // Else is a Timeout
        }
        else
        {
            Continue = FALSE;
            NTStatus = STATUS_SUCCESS;
        }
    }
    return NTStatus;
}



NTSTATUS GprllTLVExchange(
    const	PREADER_EXTENSION	pReaderExt,
    const	UCHAR				Ti, 
    const	USHORT				Li, 
    const	UCHAR				*Vi,
            UCHAR				*To, 
            USHORT				*Lo, 
            UCHAR				*Vo
    )
/*++

    Routine Description : 
        Exchange data with GPR with a TLV command.

    Arguments 
    In:
        pReaderExt holds the pointer to the READER_EXTENSION structure.
        Ti holds the command type
        Li holds the command length
        Vi holds the command data

    Out:      
        To holds the command response type
        Lo holds the command response length
        Vo holds the command response data

    Return Value
    NTStatus

        STATUS_SUCCESS is Ok 
        else if an error condition is raised:
        STATUS_DEVICE_PROTOCOL_ERROR
        STATUS_INVALID_DEVICE_STATE
        STATUS_DEVICE_NOT_CONNECTED
        STATUS_UNRECOGNIZED_MEDIA

        and others received IFDstatus corresponding to NTSTATUS

--*/
{
    // Local variables
    // - T  is type of TLV protocol                    
    // - new_Ti is the Ti modified
    // - L  is length in TLV protocol   
    // - V  is data filed in TLV protocol

    NTSTATUS NTStatus = STATUS_SUCCESS;
    UCHAR T;
    UCHAR new_Ti;
    USHORT L;
    UCHAR V[GPR_BUFFER_SIZE];

    //Verification of Li
    if ( (USHORT) Li >= GPR_BUFFER_SIZE )
    {
        return (STATUS_DEVICE_PROTOCOL_ERROR);
    }

	new_Ti = Ti;

    //
    // Write the TLV 
    // by Write TLV if Li <= 28 or By ChainIn if Li > 28
    //
    if (Li<=MAX_V_LEN)
    {
        GprllSendCmd(pReaderExt,new_Ti,Li,Vi);                 
        
        NTStatus = GprllKeWaitAckEvent(
            pReaderExt,
            Ti
            );

        if (STATUS_SUCCESS != NTStatus)
        {
			// YN
			GprllMaskHandshakeRegister(pReaderExt,HANDSHAKE_IREQ,0);
			
            return NTStatus;
        }

		// GPR Command to read I/O Window: 
		// In the handshake register, set to 0 bit 2(IREQ) , and set to 1 bit 1 (INTR)

    }
    else
    {
        NTStatus = GprllSendChainUp( 
            pReaderExt,
            new_Ti,
            Li,
            Vi
            );

        if (STATUS_SUCCESS != NTStatus)
        {
			// YN
			GprllMaskHandshakeRegister(pReaderExt,HANDSHAKE_IREQ,0);

           return(NTStatus);
        } 
    }

    // Read the T register, need to know if new data to exchange
    T = pReaderExt->To;

    // Read Answer by Read TLV  or Chain Out method if To = Ti + 6
    if ( T == (new_Ti + 6) )
    {
        NTStatus = GprllReadChainUp(pReaderExt,&T,&L,V);
        
        if (STATUS_SUCCESS != NTStatus )
        {
			// YN
            GprllMaskHandshakeRegister(pReaderExt,HANDSHAKE_IREQ,0);

            return(NTStatus);
        }
    }
    else
    {
        L = pReaderExt->Lo;
        ASSERT(pReaderExt->Vo !=0);
        memcpy(V,pReaderExt->Vo,L);
        GprllMaskHandshakeRegister(pReaderExt,HANDSHAKE_IREQ,0);
    }  
   
    // Verify if Response buffer len is large enough
    // to contain data received from the reader
    //

    if( L > *Lo )
    {
        *To=T;
        *Lo=1;
        Vo[0]=14;
        return(STATUS_UNRECOGNIZED_MEDIA);
    }

    // Translate answer
    *To=T;
    *Lo=L;
    memcpy(Vo,V,(SHORT)L);

    return (GDDK_Translate(Vo[0], Ti));
}





void  GprllSendCmd(  
	const PREADER_EXTENSION	pReaderExt,
	const UCHAR				Ti, 
	const USHORT			Li,
	const UCHAR				*Vi
	)
/*++

  Routine Description : 
	Write TLV into I/O Window and
	Send Command to GPR to read I/O Window

  Arguments:
     pReaderExt holds the pointer to the READER_EXTENSION structure.
     Ti holds the command type
     Li holds the command length
     Vi holds the command data
--*/
{
    // Local variables
    //   - TLV is an intermediate buffer.
    UCHAR TLV[2 + MAX_V_LEN];
    USHORT Li_max;
	
	//Write Ti, Li and Vi[]
	TLV[0] = Ti;
	TLV[1] = (UCHAR) Li;
	ASSERT(Vi != 0);

    Li_max = Li;

    if (Li_max > MAX_V_LEN)
    {
        Li_max = MAX_V_LEN;
    }
	memcpy(TLV+2,Vi,Li_max);
	G_WriteBuf((const USHORT)
		(((const USHORT) (pReaderExt->BaseIoAddress)) + (const USHORT) REGISTER_T),
		(const USHORT) (Li_max + 2),
		(UCHAR *) TLV
		);

	// GPR Command to read I/O Window: 
	// In the handshake register, set to 0 bit 2(IREQ) , and set to 1 bit 1 (INTR)
	GprllMaskHandshakeRegister(pReaderExt,HANDSHAKE_IREQ,0);
	GprllMaskHandshakeRegister(pReaderExt,HANDSHAKE_INTR,1);
}



void  GprllReadResp(
	const	PREADER_EXTENSION	pReaderExt
	)
/*++

  Routine Description : 
	Read no chainning TLV into I/O Window and
	Send Command to GPR to read I/O Window

  Arguments
  In:           
     pReaderExt holds the pointer to the READER_EXTENSION structure.

  Out:     
     To holds the command response type
     Lo holds the command response length
     Vo holds the command response data
--*/
{
    //Local variables
    //   - TLV is an intermediate buffer.

    UCHAR TLV[2 + MAX_V_LEN];

    TLV[0] = 0x0;
    // Read To, Lo and Vo[]
	G_ReadBuf((const USHORT)
		(((const USHORT) (pReaderExt->BaseIoAddress)) + (const USHORT) REGISTER_T),
		MAX_V_LEN + 2,
		TLV);
	
	pReaderExt->To = TLV[0];
    // maximum number of character is set by the TLV buffer
	pReaderExt->Lo = TLV[1];

    if (pReaderExt->Lo > MAX_V_LEN)
    {
        pReaderExt->Lo = MAX_V_LEN;
    }


	memcpy(pReaderExt->Vo,TLV+2,pReaderExt->Lo);

    // Acquit the Hand shake: 
    // In the handshake register, set to 0 bit 2 (BUSY/IREQ)
	GprllMaskHandshakeRegister(pReaderExt,HANDSHAKE_IREQ,0);
}


NTSTATUS GprllSendChainUp(
	const PREADER_EXTENSION	pReaderExt,
	const UCHAR				Ti,
	const USHORT			Li,
	const UCHAR				*Vi
	)
/*++

  Routine Description : Send chainning TLV to GPR

  Arguments:
  In:
     pReaderExt holds the pointer to the READER_EXTENSION structure.
     Ti holds the command type
     Li holds the command length
     Vi holds the command data

 Out:    Nothing
--*/
{
    //	Local variables
    //	   - Tc is type of TLV protocol ( TLV chaining method )   
    //	   - Lc is Length of TLV protocol ( chaining method )    
    //	   - Vc is 28 bytes max of data to send
    //	   - Length is an temporary var to store Li   
    UCHAR Tc;
    UCHAR Response;
    UCHAR Lo;
    USHORT Lc;
    USHORT Length;
    UCHAR  Vc[MAX_V_LEN];
    NTSTATUS NTStatus = STATUS_SUCCESS;

	Length=Li;

	//Prepare Tc (Add 4 to Ti for chaining method)
	Tc=Ti+4; 
    Vc[0] = 0x0;
	while ( Length > 0 )
    {
        //Prepare Lc
        //If length TLV > 28 Length = 28 else it's last command L = Length
		if ( Length > MAX_V_LEN )
        {
			Lc=MAX_V_LEN;     
		}
		else
        {
			Lc=Length; 
			Tc=Ti;
		}
		//Prepare Vc
		memcpy(Vc,Vi+Li-Length,Lc);

		//Write to I/O window
        // Dont need the answer - handled by the interrupt function.
		GprllSendCmd(pReaderExt,Tc,Lc,Vc);
      
        NTStatus = GprllKeWaitAckEvent(
            pReaderExt,
            Ti
            );
        if(STATUS_SUCCESS != NTStatus)
        {
            return NTStatus;
        }

		//If an error test Response
		Response = GprllReadRegister(pReaderExt,REGISTER_V);

        if(0x00 != Response)
        {
			Lo = GprllReadRegister(pReaderExt,REGISTER_L);
			if (Lo == 0x01)
            {
               return (GDDK_Translate(Response, Ti));
			}
			else
            {
                // This is not a exchange is a cmd to reader
                // we don't care about the reader status.
				return (NTStatus);
			}
		}
		Length=Length-Lc;
	}
   return(NTStatus);
}



NTSTATUS GprllReadChainUp(
	const	PREADER_EXTENSION	pReaderExt,
			UCHAR				*To, 
			USHORT				*Lo,
			UCHAR				*Vo
	)
/*++

  Routine Description : Receive chainning TLV response from GPR

  Arguments
  In:   
     pReaderExt holds the pointer to the READER_EXTENSION structure.

  Out:     
     To holds the command response type
     Lo holds the command response length
     Vo holds the command response data
--*/
{
//	Local variables
//	   - Tc is type of TLV protocol ( TLV chaining method )   
//	   - Lc is Length of TLV protocol ( chaining method )    
//	   - Length is an temporary var to store Lo
    UCHAR Tc;
    USHORT Lc;
    SHORT Lenght;
    NTSTATUS NTStatus = STATUS_SUCCESS;
	
	// Reading T out
	Tc = GprllReadRegister(pReaderExt,REGISTER_T);
	*To=Tc-4; 

	Lenght = 0;
	do
    {
		// Read TLV
		Tc = pReaderExt->To;
		Lc = pReaderExt->Lo;
		ASSERT(pReaderExt->Vo != 0);

        // The Vo buffer is limited by the caller local variable.
        if ( Lenght + (SHORT) pReaderExt->Lo > GPR_BUFFER_SIZE)
        {
            return (STATUS_BUFFER_TOO_SMALL);
        }

        memcpy(Vo+Lenght,pReaderExt->Vo,pReaderExt->Lo);

        GprllMaskHandshakeRegister(pReaderExt,HANDSHAKE_IREQ,0);

        // Prepare Lo
        *Lo=(USHORT)Lenght+Lc;
        Lenght=Lenght+Lc;
		
		// GPR send the next Chainning TLV
		// In the handshake register, set to 0 bit 2(IREQ) and set to 1 bit 1 (INTR)
		if ((*To) != Tc )
        {
        	GprllMaskHandshakeRegister(pReaderExt,HANDSHAKE_IREQ,0);
			GprllMaskHandshakeRegister(pReaderExt,HANDSHAKE_INTR,1);

            NTStatus = GprllKeWaitAckEvent(
                pReaderExt,
                *To
                );

            if(STATUS_SUCCESS != NTStatus)
            {
                return NTStatus;
            }
		}

		// (End do) if To=Tc -> Last Chainning TLV
	} while( (*To) != Tc ); 

	return(NTStatus);
}


void GprllWait(
    const LONG lWaitingTime
	)
/*++

  Routine Description : This function puts the driver in a waiting state
  for a timeout.  If IRQL < DISPATCH_LEVEL, use normal fonction to process
  this delay.  use KeStallExecutionProcessor, just when GprllWait is called
  in the context of DPC routine.

  Arguments
	pReaderExt: Pointer to the current ReaderExtension structure.
	lWaitingTime: Timeout value in ms
--*/
{
    LARGE_INTEGER Delay;

	if( KeGetCurrentIrql() >= DISPATCH_LEVEL )
	{
		ULONG	Cnt = 20 * lWaitingTime;

		while( Cnt-- )
		{
			//	KeStallExecutionProcessor: counted in us
			KeStallExecutionProcessor( 50 );
		}
	}
	else
	{
		Delay.QuadPart = (LONGLONG)-10 * 1000 * lWaitingTime;

		//	KeDelayExecutionThread: counted in 100 ns
		KeDelayExecutionThread( KernelMode, FALSE, &Delay );
	}
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\gpr400\gprelcmd.h ===
/*++
                 Copyright (c) 1998 Gemplus Development

Name: 
	Gprelcmd.h 

Description: 
	 Fonctions enable to access and to deal with GPR. PC/SC version
     Header file.   
Environment:
	Kernel Mode

Revision History: 
	06/05/98: V1.00.003  (P. Plouidy)
		- Power management for NT5 
	10/02/98: V1.00.002  (P. Plouidy)
		- Plug and Play for NT5 
	03/07/97: V1.00.001  (P. Plouidy)
		- Start of development.


--*/
#include "gprnt.h"
//
// Name definition:
//   _GPRELCMD_ is used to avoid multiple inclusion.
//
#ifndef _GPRELCMD_
#define _GPRELCMD_

//
//   Constants section:
// - REGISTER_HANDSHAKE, REGISTER_PRG, REGISTER_T, REGISTER_L and REGISTER_V are
//   the offset address in the GPR.
// - HANDSHAKE_INTR defines the mask for INTR bit in the handshake register.
// - HANDSHAKE_IREQ defines the mask for IREQ bit in the handshake register.
// - MAX_V_LEN defines the maximum length data for a TLV command.
//

#define REGISTER_HANDSHAKE       0x00
#define REGISTER_PRG             0x01
#define REGISTER_T               0x02
#define REGISTER_L               0x03
#define REGISTER_V               0x04
#define HANDSHAKE_INTR           0x02
#define HANDSHAKE_IREQ           0x04
#define MAX_V_LEN                28


//
//   GPR400 commands definitions:
//
#define DEFINE_TYPE_CMD          0x50
#define OPEN_SESSION_CMD         0x20
#define CLOSE_SESSION_CMD        0x10
#define APDU_EXCHANGE_CMD        0x30
#define VALIDATE_DRIVER_CMD      0x70
#define POWER_DOWN_GPR_CMD       0x40
#define LOAD_MEMORY_CMD          0x60
#define READ_MEMORY_CMD          0x80
#define EXEC_MEMORY_CMD          0x90
#define CHECK_AND_STATUS_CMD     0xA0
#define INIT_ENCRYPTION_CMD      0xB0
#define UPDATE_CMD               0xF0


//
// Debug prototypes 
//
#if DBG

void GPR_Debug_Buffer
(
   PUCHAR pBuffer,
   DWORD Lenght
);

#endif

//
// Prototype section
//


NTSTATUS GDDK_Translate
(
    const BYTE  IFDStatus,
    const UCHAR Tag
);

BOOLEAN  G_ReadByte
(
    const USHORT BIOAddr,
    UCHAR *Value
);

BOOLEAN  G_WriteByte
(
    const USHORT BIOAddr,
    UCHAR *Value
);

BOOLEAN  G_ReadBuf
(
    const USHORT BIOAddr,
    const USHORT Len,
    UCHAR *Buffer
);

BOOLEAN  G_WriteBuf
(
    const USHORT BIOAddr,
    const USHORT Len,
    UCHAR *Buffer
);


UCHAR GprllReadRegister
(
   const PREADER_EXTENSION      pReaderExt,
   const SHORT					GPRRegister
);
void GprllMaskHandshakeRegister
(
	const PREADER_EXTENSION		pReaderExt,
	const UCHAR                 Mask,
	const UCHAR                 BitState
);
NTSTATUS GprllTLVExchange
(
   const PREADER_EXTENSION	pReaderExt,
   const UCHAR				Ti, 
   const USHORT				Li, 
   const UCHAR				*Vi,
         UCHAR				*To, 
         USHORT				*Lo, 
         UCHAR				*Vo
);
void GprllSendCmd
(  
   const PREADER_EXTENSION	pReaderExt,
   const UCHAR				Ti, 
   const USHORT				Li,
   const UCHAR				*Vi
);
void GprllReadResp
(
   const PREADER_EXTENSION	pReaderExt
);
NTSTATUS GprllSendChainUp
(
   const PREADER_EXTENSION	pReaderExt,
   const UCHAR				Ti,
   const USHORT				Li,
   const UCHAR				*Vi
);
NTSTATUS GprllReadChainUp
(
   const PREADER_EXTENSION	pReaderExt,
         UCHAR				*To, 
         USHORT				*Lo,
         UCHAR				*Vo
);

//	GprllWait
//
void GprllWait
(
	const LONG					lWaitingTime
);



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\ifdtest\ammi.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    example.cpp

Abstract:

    This is a plug-in for the smart card driver test suite.
    This plug-in is smart card dependent

Author:

    Klaus U. Schutz

Environment:

    Win32 application

Revision History :

    Nov. 1997 - initial version

--*/

#include <stdarg.h> 
#include <stdio.h>
#include <string.h>
#include <time.h>

#include <afx.h>
#include <afxtempl.h>

#include <winioctl.h>
#include <winsmcrd.h>

#include "ifdtest.h"

void 
AMMITestCardEntry(
    class CCardProvider& in_CCardProvider
    );
//
// Create a card provider object
// Note: all global varibales and all functions have to be static
//
static class CCardProvider AMMITestCard(AMMITestCardEntry);

static ULONG
AMMITestCardSetProtocol(
    class CCardProvider& in_CCardProvider,
    class CReader& in_CReader
    )
/*++

Routine Description:
    
    This function will be called after the card has been correctly 
    identified. We should here set the protocol that we need
    for further transmissions

Arguments:

    in_CCardProvider - ref. to our card provider object
    in_CReader - ref. to the reader object

Return Value:

    IFDSTATUS_FAILED - we were unable to set the protocol correctly
    IFDSTATUS_SUCCESS - protocol set correctly

--*/
{
    ULONG l_lResult;

    TestStart("Try to set incorrect protocol T=1");
    l_lResult = in_CReader.SetProtocol(SCARD_PROTOCOL_T1);

    // The test MUST fail with the incorrect protocol
    TEST_CHECK_NOT_SUPPORTED("Set protocol failed", l_lResult);
    TestEnd();

    // Now set the correct protocol
    TestStart("Set protocol T=0");
    l_lResult = in_CReader.SetProtocol(SCARD_PROTOCOL_T0);
    TEST_CHECK_SUCCESS("Set protocol failed", l_lResult);
    TestEnd();

    if (l_lResult != ERROR_SUCCESS) {

        return IFDSTATUS_FAILED;
    }

    return IFDSTATUS_SUCCESS;
}

static 
ULONG
AMMITestCardTest(
    class CCardProvider& in_CCardProvider,
    class CReader& in_CReader
    )
/*++

Routine Description:
	    
    This serves as the test function for a particular smart card

Arguments:

    in_CReader - ref. to class that provides all information for the test

Return Value:

    IFDSTATUS value

--*/
{
    ULONG l_lResult, l_uResultLength, l_uIndex;
    PUCHAR l_pbResult;
    UCHAR l_rgbBuffer[512];
	
    // Generate a 'test' pattern which will be written to the card
    for (l_uIndex = 0; l_uIndex < 256; l_uIndex++) {

        l_rgbBuffer[l_uIndex + 5] = (UCHAR) l_uIndex;             	
    }

	switch (in_CCardProvider.GetTestNo()) {
	
	    case 1: {

            // select a file
            TestStart("SELECT FILE EFptsDataCheck");

            l_lResult = in_CReader.Transmit(
                (PBYTE) "\x00\xa4\x00\x00\x02\x00\x10",
                7,
                &l_pbResult,
                &l_uResultLength
                );

            TestCheck(
                l_lResult, "==", ERROR_SUCCESS,
                l_uResultLength, 2,
                l_pbResult[0], l_pbResult[1], 0x61, 0x15,
                NULL, NULL, NULL
                );

            TEST_END();     	

            // Test read of 256 bytes
            ULONG l_uNumBytes = 256;
            TestStart("READ BINARY %3d Byte(s)", l_uNumBytes);

		    l_lResult = in_CReader.Transmit(
                (PBYTE) "\x00\xb0\x00\x00\x00",
                5,
                &l_pbResult,
                &l_uResultLength
                );

            TestCheck(
                l_lResult, "==", ERROR_SUCCESS,
                l_uResultLength, l_uNumBytes + 2,
                l_pbResult[l_uNumBytes], l_pbResult[l_uNumBytes + 1], 0x90, 0x00,
                l_pbResult, l_rgbBuffer + 5, l_uNumBytes
                );

            TEST_END();
		    break;         	
        }

	    case 2: {

            // select a file
            TestStart("SELECT FILE EFptsDataCheck");

            l_lResult = in_CReader.Transmit(
                (PBYTE) "\x00\xa4\x00\x00\x02\x00\x10",
                7,
                &l_pbResult,
                &l_uResultLength
                );

            TestCheck(
                l_lResult, "==", ERROR_SUCCESS,
                l_uResultLength, 2,
                l_pbResult[0], l_pbResult[1], 0x61, 0x15,
                NULL, NULL, NULL
                );

            TEST_END();     	

            // Test write of 255 bytes
            ULONG l_uNumBytes = 255;
            TestStart("WRITE BINARY %3d Byte(s)", l_uNumBytes);

            // set the number of bytes we want to write to the card
            memcpy(l_rgbBuffer, "\x00\xd6\x00\x00", 4);

            l_rgbBuffer[4] = (BYTE) l_uNumBytes;

		    l_lResult = in_CReader.Transmit(
                l_rgbBuffer,
                l_uNumBytes + 5,
                &l_pbResult,
                &l_uResultLength
                );

            TestCheck(
                l_lResult, "==", ERROR_SUCCESS,
                l_uResultLength, 2,
                l_pbResult[0], l_pbResult[1], 0x90, 0x00,
                NULL, NULL, 0
                );

            TEST_END();
		    break;         	
        }

        case 3: {

            //
            // Read the result file from the smart card.
            // The card stores results of each test in 
            // a special file
            //
         	
            TestStart("SELECT FILE EFresult");

            l_lResult = in_CReader.Transmit(
                (PUCHAR) "\x00\xa4\x00\x00\x02\xa0\x00",
                7,
                &l_pbResult,
                &l_uResultLength
                );

            TestCheck(
                l_lResult, "==", ERROR_SUCCESS,
                l_uResultLength, 2,
                l_pbResult[0], l_pbResult[1], 0x61, 0x15,
                NULL, NULL, NULL
                );

            TEST_END();     	

            // Read
            TestStart("READ  BINARY FILE EFresult");

            // apdu for read binary
            memcpy(l_rgbBuffer, "\x00\xb0\x00\x00", 4);

            // Append number of bytes we want to read
            l_rgbBuffer[4] = (BYTE) sizeof(T0_RESULT_FILE_HEADER);

            // read in the header of the result file
            l_lResult = in_CReader.Transmit(
                l_rgbBuffer,
                5,
                &l_pbResult,
                &l_uResultLength
                );

            TestCheck(
                l_lResult, "==", ERROR_SUCCESS,
                l_uResultLength, sizeof(T0_RESULT_FILE_HEADER) + 2,
                l_pbResult[sizeof(T0_RESULT_FILE_HEADER)], 
                l_pbResult[sizeof(T0_RESULT_FILE_HEADER) + 1], 
                0x90, 0x00,
                NULL, NULL, NULL
                );

            // get the card reset count
            PT0_RESULT_FILE_HEADER l_pCResultFileHeader;
            l_pCResultFileHeader = (PT0_RESULT_FILE_HEADER) l_pbResult;
            BYTE l_bCardResetCount = l_pCResultFileHeader->CardResetCount;

            // set the offset from where we want to read
            l_rgbBuffer[3] = (BYTE) l_pCResultFileHeader->Offset;
            // Append number of bytes
            l_rgbBuffer[4] = (BYTE) sizeof(T0_RESULT_FILE);

            // read in the result data of the result file
            l_lResult = in_CReader.Transmit(
                l_rgbBuffer,
                5,
                &l_pbResult,
                &l_uResultLength
                );

            TestCheck(
                l_lResult, "==", ERROR_SUCCESS,
                l_uResultLength, sizeof(T0_RESULT_FILE) + 2,
                l_pbResult[sizeof(T0_RESULT_FILE)], 
                l_pbResult[sizeof(T0_RESULT_FILE) + 1], 
                0x90, 0x00,
                NULL, NULL, NULL
                );

            TEST_END();

            // Now check the result file. 
            PT0_RESULT_FILE l_pCResultFile = (PT0_RESULT_FILE) l_pbResult;

            // check if the card received a proper PTS
            TestStart("'PTS'");
            TestCheck(
                l_pCResultFile->PTS.ResetCount == l_bCardResetCount,
                "Test not performed"
                );
            TestCheck(
                (l_pCResultFile->PTS.Result & 0x01) != 1, 
                "Smart card received not PTS1"
                );
            TEST_END();

            TestStart("'PTS data check'");
            TestCheck(
                l_pCResultFile->PTSDataCheck.ResetCount == l_bCardResetCount,
                "Test not performed"
                );
            TestCheck(
                (l_pCResultFile->PTSDataCheck.Result) == 0, 
                "Smart card received incorrect data"
                );
            TEST_END();
            return IFDSTATUS_END;
        }
	    default:
		    return IFDSTATUS_FAILED;

	}    
    return IFDSTATUS_SUCCESS;
}    

static void
AMMITestCardEntry(
    class CCardProvider& in_CCardProvider
    )
/*++

Routine Description:
    
    This function registers all callbacks from the test suite
	
Arguments:

    CCardProvider - ref. to card provider class

Return Value:

    -

--*/
{
    // Set protocol callback
    in_CCardProvider.SetProtocol(AMMITestCardSetProtocol);

    // Card test callback
    in_CCardProvider.SetCardTest(AMMITestCardTest);

    // Name of our card
    in_CCardProvider.SetCardName("AMMI");

    // Name of our card
    in_CCardProvider.SetAtr(
        (PBYTE) "\x3b\x7e\x13\x00\x00\x80\x53\xff\xff\xff\x62\x00\xff\x71\xbf\x83\x03\x90\x00", 
        19
        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\gpr400\gprnt.h ===
/*++
                 Copyright (c) 1998 Gemplus Development

Name: 
    gprnt.h 

Description: 
    This module holds the prototypes of the functions 
    from gprnt.C + MACRO and structures declarations 
Environment:
    Kernel Mode

Revision History:
    22/11/98: V1.00.004  (Y. Nadeau)
      - Add KEvent ReaderRemoved
    06/05/98: V1.00.003  (P. Plouidy)
        - Power management for NT5 
    10/02/98: V1.00.002  (P. Plouidy)
        - Plug and Play for NT5 
    03/07/97: V1.00.001  (P. Plouidy)
        - Start of development.


--*/

#define SMARTCARD_POOL_TAG 'bGCS'

//
//   Include
//
// - smclib.h: smart card library definitions.
//
#include <ntddk.h>
#include <smclib.h>

#ifndef _GPRNT_
#define _GPRNT_


//
//   Constant section
//

#define SC_VENDOR_NAME          "Gemplus"
#define SC_DRIVER_NAME          "GPR400"
#define SC_IFD_TYPE             "GPR400"

#define GPR_DEFAULT_FREQUENCY   3686
#define GPR_MAX_FREQUENCY       3686    
#define GPR_MAX_IFSD            253
#define GPR_DEFAULT_DATARATE    9909    
#define GPR_MAX_DATARATE        9909 
#define GPR_MAX_DEVICE          4
#define GPR_DEFAULT_TIME        120l     // Exchange Cmd
#define GPR_CMD_TIME            5        // Gpr Cmd only
#define GPR_DEFAULT_POWER_TIME  0
#define GPR_BUFFER_SIZE         262


// DRIVER FLAVOR
// 0 : Gemplus GPR400
// 1 : IBM IBM400
// 2 : COMPAQ PC_CARD_SMARTCARD_READER
// ...

#define DF_GPR400               0
#define DF_IBM400               1
#define DF_CPQ400               2

#define SZ_VENDOR_NAME          "GEMPLUS"
#define SZ_VENDOR_NAME_IBM      "IBM"
#define SZ_VENDOR_NAME_COMPAQ   "COMPAQ"

#define SZ_READER_NAME          "GPR400"
#define SZ_READER_NAME_IBM      "IBM400"
#define SZ_READER_NAME_COMPAQ   "PC_CARD_SMARTCARD_READER"

#define GPR400_ID               "\\??\\PCMCIA#GEMPLUS-GPR400"
#define COMPAQ_ID               "\\??\\PCMCIA#COMPAQ-PC_Card_SmartCard_Reader-446E"

#define CHECK_ID_LEN            25 // Check first 25 bytes!

//
//   MACRO declarations.
//
#ifndef SMARTCARD_NT_LOG
#define SMARTCARD_NT_LOG(pObj, lErrCode, pwszStr, ulDump) \
            do { \
                if (lErrCode != 0) { \
                    SmartcardLogError(pObj, \
                                      lErrCode, \
                                      pwszStr, \
                                      ulDump); } \
            } while (0)
#endif

#ifndef NT_FAIL
#define NT_FAIL(status)         (((NTSTATUS) (status)) < 0)
#endif

#ifndef IS_POINTER_INVALID
#define IS_POINTER_INVALID(p)       (!IS_POINTER_VALID(p))
#endif

#ifndef IS_POINTER_VALID
#define IS_POINTER_VALID(p) \
                    ((BOOLEAN) ((p != NULL) ? TRUE : FALSE))
#endif

#ifndef IS_HANDLE_VALID
#define IS_HANDLE_VALID(h) \
                    ((BOOLEAN) ((h == NULL) ? FALSE : TRUE))
#endif

#ifndef IS_HANDLE_INVALID
#define IS_HANDLE_INVALID(h)    (!IS_HANDLE_VALID(h))
#endif

#ifndef INIT_STRING
#define INIT_STRING(s) \
                    s.Length = 0; \
                    s.MaximumLength = 0; \
                    s.Buffer = NULL
#endif

//
//   Data structures.
//

//  PCMCIA_READER_CONFIG:Configuration data structure for PC Card readers.
typedef struct _PCMCIA_READER_CONFIG {
    KIRQL       Level;
    KAFFINITY   Affinity;
    ULONG       Vector;
    USHORT      BufferSize;
    USHORT      Reserved;
 } PCMCIA_READER_CONFIG, *PPCMCIA_READER_CONFIG, *LPPCMCIA_READER_CONFIG;

typedef enum _READER_POWER_STATE {
    PowerReaderUnspecified = 0,
    PowerReaderWorking,
    PowerReaderOff
} READER_POWER_STATE, *PREADER_POWER_STATE;


typedef enum _ACTION {
    
    Undefined = 0,
    SkipRequest,
    WaitForCompletion,
    CompleteRequest,
    MarkPending

} ACTION;


//  GPR400_REGISTERS: GPR400 I/O registers
typedef struct _GPR400_REGISTERS {
    UCHAR  ucHandshake;         
    UCHAR  ucProgram;           
    UCHAR  ucT;                 
    UCHAR  ucL;                 
    UCHAR  ucV; 
    UCHAR  Dummy[3];            
 } GPR400_REGISTERS, *PGPR400_REGISTERS, *LPGPR400_REGISTERS;


//  READER_EXTENSION:
typedef struct _READER_EXTENSION {
    
    ULONG                   CmdTimeOut;
    ULONG                   PowerTimeOut;
    PGPR400_REGISTERS       BaseIoAddress;
    PCMCIA_READER_CONFIG    ConfigData;
    KEVENT                  GPRAckEvent;
    KEVENT                  GPRIccPresEvent;

    KDPC                    CardDpcObject;
    KTIMER                  CardDetectionTimer;

    UCHAR                   OsVersion;
    USHORT                  Lo;
    UCHAR                   To;
    PUCHAR                  Vo;
    READER_POWER_STATE      ReaderPowerState;
    BOOLEAN                 PowerRequest;
    PDEVICE_OBJECT          AttachedDeviceObject;
    BOOLEAN                 CardPresent;
    // Used to signal that the device has been removed
    KEVENT                  ReaderRemoved; 
    BOOLEAN                 NewDevice;

    KEVENT                  IdleState;
    BOOLEAN                 RestartCardDetection;

 } READER_EXTENSION, *PREADER_EXTENSION, *LPREADER_EXTENSION;


//  DEVICE_EXTENSION:
typedef struct _DEVICE_EXTENSION {

    PDEVICE_OBJECT      DeviceObject;
    PDEVICE_OBJECT      PhysicalDeviceObject;
    PKINTERRUPT         InterruptObject;
    PKSERVICE_ROUTINE   InterruptServiceRoutine;
    KDPC                DpcObject;
    PVOID               IsrContext;
    SMARTCARD_EXTENSION SmartcardExtension;
    UNICODE_STRING      PnPDeviceName;
    LONG                IoCount;
    KSPIN_LOCK          SpinLock;
    BOOLEAN             OpenFlag;
    LONG                PowerState;
    KEVENT              ReaderStarted;
    KEVENT              ReaderClosed;

    // A worker thread to startup GPR gently
    PIO_WORKITEM        GprWorkStartup;
    LONG                DriverFlavor;  // GPR400(default), IBM400 or CPQ400?

    PIRP PowerIrp;
 } DEVICE_EXTENSION, *PDEVICE_EXTENSION, *LPDEVICE_EXTENSION;


//
//  Prototype section:
//
NTSTATUS DriverEntry
(
    PDRIVER_OBJECT  DriverObject,
    PUNICODE_STRING RegistryPath
);

NTSTATUS GprAddDevice
(
    IN PDRIVER_OBJECT DriverObject, 
    IN PDEVICE_OBJECT PhysicalDeviceObject
);

NTSTATUS GprSystemControl
(
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp
);

NTSTATUS GprDeviceControl
(
   PDEVICE_OBJECT DeviceObject,
   PIRP Irp
);

NTSTATUS GprCleanup
(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
);

BOOLEAN GprIsr
(
    IN PKINTERRUPT pkInterrupt,
    IN PVOID pvContext
);

NTSTATUS
GprCancelEventWait
(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
);


VOID GprCardEventDpc
(
    PKDPC               Dpc,
    PDEVICE_OBJECT      DeviceObject,
    PDEVICE_EXTENSION   pDevExt,
    PSMARTCARD_EXTENSION SmartcardExtension
);

VOID GprCardPresenceDpc
(
    IN PKDPC pDpc,
    IN PVOID pvContext,
    IN PVOID pArg1,
    IN PVOID pArg2
);

NTSTATUS GprDispatchPnp
(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP Irp
);

NTSTATUS GprCallPcmciaDriver
(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP Irp
);

NTSTATUS GprStartDevice
(
    PDEVICE_OBJECT DeviceObject,
    PCM_FULL_RESOURCE_DESCRIPTOR FullResourceDescriptor
);


VOID GprStopDevice
( 
    PDEVICE_OBJECT DeviceObject
);

VOID GprUnloadDriver
( 
    PDRIVER_OBJECT DriverObject 
);

VOID GprUnloadDevice
( 
    PDEVICE_OBJECT DeviceObject
);

NTSTATUS GprCreateClose
(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
);

NTSTATUS GprComplete 
(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT Event
);
NTSTATUS GprCreateDevice
(
    IN  PDRIVER_OBJECT DriverObject,
    IN  PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PDEVICE_OBJECT *DeviceObject
);

VOID GprFinishPendingRequest
( 
    PDEVICE_OBJECT  DeviceObject,
    NTSTATUS        NTStatus
);

VOID GprWorkStartup
(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
);

VOID        setBusy(PREADER_EXTENSION Device);
VOID        setIdle(PREADER_EXTENSION Device);
NTSTATUS    waitForIdle(PREADER_EXTENSION Device);
NTSTATUS    waitForIdleAndBlock(PREADER_EXTENSION Device);
NTSTATUS    testForIdleAndBlock(PREADER_EXTENSION Device);


NTSTATUS GprPower
(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
);

NTSTATUS power_HandleQueryPower(PDEVICE_OBJECT DeviceObject, IN PIRP Irp);
NTSTATUS power_HandleSetPower(PDEVICE_OBJECT DeviceObject, IN PIRP Irp);

NTSTATUS    onDevicePowerUpComplete(
    IN PDEVICE_OBJECT NullDeviceObject,
    IN PIRP Irp,
    IN PVOID DeviceObject
    );

NTSTATUS onPowerRequestCompletion(
    IN PDEVICE_OBJECT       DeviceObject,
    IN UCHAR                MinorFunction,
    IN POWER_STATE          PowerState,
    IN PVOID                Context,
    IN PIO_STATUS_BLOCK     IoStatus
    );

#define ATTACHED_DEVICE_OBJECT deviceExtension->SmartcardExtension.ReaderExtension->AttachedDeviceObject

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\gpr400\gprnt.c ===
/*++
                 Copyright (c) 1998 Gemplus Development

Name:
   Gprnt.C

Description:
   This is the main module which holds:
      - the main functions for a standard DDK NT  driver
      - the IOCTL functions defined for this driver.

Environment:
   Kernel Mode

Revision History:
    08/10/99: Y. Nadeau
      - Make a version for Compaq PC-CARD Reader.
    06/04/98: (Y. Nadeau M. Veillette)
      - Code review
    18/11/98: V1.00.006  (Y. Nadeau)
      - Add log errors at startup, and Cleanup revised.
    16/10/98: V1.00.005  (Y. Nadeau)
      - Remove DEVICEID in IoCreateDevice (Klaus)
    18/09/98: V1.00.004  (Y. Nadeau)
      - Correction for NT5 beta 3
   06/05/98: V1.00.003  (P. Plouidy)
      - Power management for NT5
   10/02/98: V1.00.002  (P. Plouidy)
      - Plug and Play for NT5
   03/07/97: V1.00.001  (P. Plouidy)
      - Start of development.


--*/

#include <stdio.h>
#include "gprnt.h"
#include "gprcmd.h"
#include "gprelcmd.h"
#include "logmsg.h"

//
// Pragma section
//

#pragma alloc_text (INIT,DriverEntry)
#pragma alloc_text (PAGEABLE,GprAddDevice)
#pragma alloc_text (PAGEABLE,GprCreateDevice)
#pragma alloc_text (PAGEABLE,GprUnloadDevice)
#pragma alloc_text (PAGEABLE,GprUnloadDriver)


#if DBG
#pragma optimize ("",off)
#endif

//
// Constant section
//  - MAX_DEVICES is the maximum number of device supported
//  - POLLING_TIME polling frequency in ms
//
#define MAX_DEVICES   4
#define POLLING_TIME 500


ULONG dataRatesSupported[] = {9909};

//
// Global variable section
// bDeviceSlot is an array of boolean to signal if a device is already created.
//
BOOLEAN bDeviceSlot[GPR_MAX_DEVICE];


NTSTATUS DriverEntry(
                    PDRIVER_OBJECT DriverObject,
                    PUNICODE_STRING RegistryPath
                    )
/*++

Routine description:
    This routine is called at system initialization time to initialize
    this driver.
Arguments
   DriverObject - supplies the driver object.
   RegistryPath - supplies the registry path for this driver.
Return Value:

   STATUS_SUCCESS We could initialize at least one device
--*/    
{

    SmartcardDebug(
                  DEBUG_INFO,
                  ("%s!DriverEntry: Enter - %s %s\n",
                   SC_DRIVER_NAME,
                   __DATE__,
                   __TIME__)
                  );

    //   Initialization of the Driver Object with driver's entry points.
    DriverObject->DriverUnload               = GprUnloadDriver;
    DriverObject->DriverExtension->AddDevice = GprAddDevice;

    DriverObject->MajorFunction[IRP_MJ_PNP]     = GprDispatchPnp;
    DriverObject->MajorFunction[IRP_MJ_CREATE]  = GprCreateClose;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]   = GprCreateClose;
    DriverObject->MajorFunction[IRP_MJ_CLEANUP] = GprCleanup;
    DriverObject->MajorFunction[IRP_MJ_POWER]   = GprPower;

    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]   = GprDeviceControl;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL]   = GprSystemControl;

    SmartcardDebug(
                  DEBUG_DRIVER,
                  ("%s!DriverEntry: Exit\n",
                   SC_DRIVER_NAME)
                  );
    return(STATUS_SUCCESS);
}


NTSTATUS GprAddDevice(
                     IN PDRIVER_OBJECT DriverObject,
                     IN PDEVICE_OBJECT PhysicalDeviceObject
                     )
/*++

Routine Description:
   Add device routine

Arguments
   DriverObject point to the driver object.
   PhysicalDeviceObject point to the PDO for the pnp device added

Return Value:
   STATUS_SUCCESS
   STATUS_INSUFFICIENT_RESOURCES
*/    
{
    NTSTATUS NTStatus = STATUS_SUCCESS;
    PDEVICE_OBJECT DeviceObject = NULL;
    ANSI_STRING DeviceID;

    PAGED_CODE();
    ASSERT(DriverObject != NULL);
    ASSERT(PhysicalDeviceObject != NULL);

    SmartcardDebug(
                  DEBUG_DRIVER,
                  ( "%s!GprAddDevice: Enter\n",
                    SC_DRIVER_NAME)
                  );

    __try
    {
        PDEVICE_EXTENSION DeviceExtension;
        LONG DeviceIdLength;
      //
      // try to create the device
      //
        NTStatus = GprCreateDevice(
                                  DriverObject,
                                  PhysicalDeviceObject,
                                  &DeviceObject
                                  );

        if (NTStatus != STATUS_SUCCESS) {
            SmartcardDebug(
                          DEBUG_ERROR,
                          ( "%s!GprAddDevice: GprCreateDevice=%X(hex)\n",
                            SC_DRIVER_NAME,
                            NTStatus)
                          );
            __leave;
        }
      //
      // Attach the physicalDeviceObject to the new created device
      //

        DeviceExtension = DeviceObject->DeviceExtension;

        DeviceExtension->SmartcardExtension.ReaderExtension->AttachedDeviceObject = IoAttachDeviceToDeviceStack(
                                                                                                               DeviceObject,
                                                                                                               PhysicalDeviceObject
                                                                                                               );

        ASSERT(DeviceExtension->SmartcardExtension.ReaderExtension->AttachedDeviceObject != NULL);

        if (DeviceExtension->SmartcardExtension.ReaderExtension->AttachedDeviceObject == NULL) {
            NTStatus = STATUS_UNSUCCESSFUL;
            __leave;
        }

      //
      // Register the new device object
      //
        NTStatus = IoRegisterDeviceInterface(
                                            PhysicalDeviceObject,
                                            &SmartCardReaderGuid,
                                            NULL,
                                            &DeviceExtension->PnPDeviceName
                                            );

        RtlUnicodeStringToAnsiString(&DeviceID, &DeviceExtension->PnPDeviceName, TRUE);

        DeviceIdLength = (LONG) RtlCompareMemory(DeviceID.Buffer, COMPAQ_ID, CHECK_ID_LEN);

        SmartcardDebug(
                      DEBUG_ERROR, 
                      ( "%s!GprAddDevice: DeviceIdLength = %d, PnPDeviceName=%s\n",
                        SC_DRIVER_NAME, DeviceIdLength, DeviceID.Buffer)
                      );

        // it's a DeviceID of COMPAQ ?
        if ( DeviceIdLength == CHECK_ID_LEN) {
            SmartcardDebug(
                          DEBUG_INFO,
                          ( "%s!GprAddDevice: Compaq reader detect!\n",
                            SC_DRIVER_NAME)
                          );

            DeviceExtension->DriverFlavor = DF_CPQ400;
        }

        //  Initialize the vendor information.
        //  Driver flavor
        // 
        switch (DeviceExtension->DriverFlavor) {
        case DF_IBM400:
            // IBM IBM400
            RtlCopyMemory(DeviceExtension->SmartcardExtension.VendorAttr.VendorName.Buffer,
                          SZ_VENDOR_NAME_IBM, sizeof(SZ_VENDOR_NAME_IBM));
            RtlCopyMemory(DeviceExtension->SmartcardExtension.VendorAttr.IfdType.Buffer,
                          SZ_READER_NAME_IBM, sizeof(SZ_READER_NAME_IBM));
            DeviceExtension->SmartcardExtension.VendorAttr.VendorName.Length = sizeof(SZ_VENDOR_NAME_IBM);
            DeviceExtension->SmartcardExtension.VendorAttr.IfdType.Length = sizeof(SZ_READER_NAME_IBM);
            break;
        case DF_CPQ400:
            // COMPAQ PC_CARD_SMARTCARD_READER
            RtlCopyMemory(DeviceExtension->SmartcardExtension.VendorAttr.VendorName.Buffer,
                          SZ_VENDOR_NAME_COMPAQ, sizeof(SZ_VENDOR_NAME_COMPAQ));
            RtlCopyMemory(DeviceExtension->SmartcardExtension.VendorAttr.IfdType.Buffer,
                          SZ_READER_NAME_COMPAQ, sizeof(SZ_READER_NAME_COMPAQ));
            DeviceExtension->SmartcardExtension.VendorAttr.VendorName.Length = sizeof(SZ_VENDOR_NAME_COMPAQ);
            DeviceExtension->SmartcardExtension.VendorAttr.IfdType.Length = sizeof(SZ_READER_NAME_COMPAQ);
            break;
        default:
            // Gemplus GPR400
            break;
        }

        SmartcardDebug(
                      DEBUG_INFO,
                      ( "%s!GprAddDevice: DriverFlavor VendorName:%s  IfdType:%s UnitNo:%d\n",
                        SC_DRIVER_NAME,
                        DeviceExtension->SmartcardExtension.VendorAttr.VendorName.Buffer,
                        DeviceExtension->SmartcardExtension.VendorAttr.IfdType.Buffer,
                        DeviceExtension->SmartcardExtension.VendorAttr.UnitNo)
                      );

        RtlFreeAnsiString(&DeviceID);

        ASSERT(NTStatus == STATUS_SUCCESS);

        DeviceObject->Flags |= DO_BUFFERED_IO;
        DeviceObject->Flags |= DO_POWER_PAGABLE;
        DeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    }
    __finally
    {
        if (NTStatus != STATUS_SUCCESS) {
            GprUnloadDevice(DeviceObject);
        }
    }

    SmartcardDebug(
                  DEBUG_DRIVER,
                  ( "%s!GprAddDevice: Exit =%X(hex)\n",
                    SC_DRIVER_NAME,
                    NTStatus)
                  );

    return NTStatus;
}


NTSTATUS GprCreateDevice(
                        IN  PDRIVER_OBJECT DriverObject,
                        IN PDEVICE_OBJECT PhysicalDeviceObject,
                        OUT PDEVICE_OBJECT *DeviceObject
                        )
/*++

Routine description:
   This routine creates an object for the physical device specified
   and sets up the deviceExtension

Arguments:
   DriverObject   context of call
   DeviceObject   ptr to the created device object

Return value:
   STATUS_SUCCESS
--*/    
{
    NTSTATUS NTStatus = STATUS_SUCCESS;
    ULONG DeviceInstance;
    PDEVICE_EXTENSION DeviceExtension;
    PSMARTCARD_EXTENSION SmartcardExtension;

    PAGED_CODE();
    ASSERT(DriverObject != NULL);
    ASSERT(PhysicalDeviceObject != NULL);

    *DeviceObject = NULL;

    SmartcardDebug(
                  DEBUG_DRIVER,
                  ( "%s!GprCreateDevice: Enter\n",
                    SC_DRIVER_NAME)
                  );

    __try
    {
        for ( DeviceInstance = 0; DeviceInstance < GPR_MAX_DEVICE; DeviceInstance++ ) {
            if (bDeviceSlot[DeviceInstance] == FALSE) {
                bDeviceSlot[DeviceInstance] = TRUE;
                break;
            }
        }


      // Create the device object
        NTStatus = IoCreateDevice(
                                 DriverObject,
                                 sizeof(DEVICE_EXTENSION),
                                 NULL,
                                 FILE_DEVICE_SMARTCARD,
                                 0,
                                 TRUE,
                                 DeviceObject
                                 );

        if (NTStatus != STATUS_SUCCESS) {
            SmartcardDebug(
                          DEBUG_ERROR,
                          ( "%s!GprCreateDevice: IoCreateDevice status=%X(hex)\n",
                            SC_DRIVER_NAME,
                            NTStatus)
                          );

            SmartcardLogError(
                             DriverObject,
                             GEMSCR0D_ERROR_CLAIM_RESOURCES,
                             NULL,
                             0
                             );

            __leave;
        }
        ASSERT(DeviceObject != NULL);

        // set up the device extension.
        DeviceExtension = (*DeviceObject)->DeviceExtension;

        ASSERT(DeviceExtension != NULL);

        SmartcardExtension = &DeviceExtension->SmartcardExtension;

      // allocate the reader extension
        SmartcardExtension->ReaderExtension = ExAllocatePool(
                                                            NonPagedPool,
                                                            sizeof( READER_EXTENSION )
                                                            );

        if ( SmartcardExtension->ReaderExtension == NULL ) {

            SmartcardLogError(
                             DriverObject,
                             GEMSCR0D_ERROR_CLAIM_RESOURCES,
                             NULL,
                             0
                             );

            SmartcardDebug(
                          DEBUG_ERROR,
                          ( "%s!GprCreateDevice: ReaderExtension failed %X(hex)\n",
                            SC_DRIVER_NAME,
                            NTStatus )
                          );


            NTStatus = STATUS_INSUFFICIENT_RESOURCES;
            __leave;
        }

        RtlZeroMemory(
                     SmartcardExtension->ReaderExtension,
                     sizeof( READER_EXTENSION )
                     );

      // allocate the Vo Buffer
        SmartcardExtension->ReaderExtension->Vo = ExAllocatePool(
                                                                NonPagedPool,
                                                                GPR_BUFFER_SIZE
                                                                );

        if ( SmartcardExtension->ReaderExtension->Vo == NULL ) {

            SmartcardLogError(
                             DriverObject,
                             GEMSCR0D_ERROR_CLAIM_RESOURCES,
                             NULL,
                             0
                             );

            SmartcardDebug(
                          DEBUG_ERROR,
                          ( "%s!GprCreateDevice: Vo buffer failed %X(hex)\n",
                            SC_DRIVER_NAME,
                            NTStatus )
                          );


            NTStatus = STATUS_INSUFFICIENT_RESOURCES;
            __leave;
        }

        RtlZeroMemory(
                     SmartcardExtension->ReaderExtension->Vo,
                     GPR_BUFFER_SIZE
                     );

        // Used for device removal notification
        KeInitializeEvent(
                         &(SmartcardExtension->ReaderExtension->ReaderRemoved),
                         NotificationEvent,
                         FALSE
                         );

        //
        // GPR400 acknowledge event initialization
        //
        KeInitializeEvent(
                         &(SmartcardExtension->ReaderExtension->GPRAckEvent),
                         SynchronizationEvent,
                         FALSE
                         );

        KeInitializeEvent(
                         &(SmartcardExtension->ReaderExtension->GPRIccPresEvent),
                         SynchronizationEvent,
                         FALSE
                         );

        // Setup the DPC routine to be called after the ISR completes.
        KeInitializeDpc(
                       &DeviceExtension->DpcObject,
                       GprCardEventDpc,
                       *DeviceObject                 // should be DeviceExtension
                       );

        // Card presence polling DPC routine initialization
        KeInitializeDpc(
                       &SmartcardExtension->ReaderExtension->CardDpcObject,
                       GprCardPresenceDpc,
                       DeviceExtension
                       );

        // Initialization of the card detection timer
        KeInitializeTimer(
                         &(SmartcardExtension->ReaderExtension->CardDetectionTimer)
                         );

        // This event signals Start/Stop notification
        KeInitializeEvent(
                         &DeviceExtension->ReaderStarted,
                         NotificationEvent,
                         FALSE
                         );

        // Used to keep track of open calls
        KeInitializeEvent(
                         &DeviceExtension->ReaderClosed,
                         NotificationEvent,
                         TRUE
                         );

        // Used to keep track of open calls
        KeInitializeEvent(
                         &SmartcardExtension->ReaderExtension->IdleState,
                         SynchronizationEvent,
                         TRUE
                         );

        SmartcardExtension->ReaderExtension->RestartCardDetection = FALSE;

        // void function, This routine must be called
        // before an initial call to KeAcquireSpinLock
        KeInitializeSpinLock(&DeviceExtension->SpinLock);

      // This worker thread is use to start de GPR in Power mode
        DeviceExtension->GprWorkStartup = IoAllocateWorkItem(
                                                            *DeviceObject
                                                            );
        if ( DeviceExtension->GprWorkStartup == NULL ) {
            SmartcardLogError(
                             DriverObject,
                             GEMSCR0D_ERROR_CLAIM_RESOURCES,
                             NULL,
                             0
                             );

            SmartcardDebug(
                          DEBUG_ERROR,
                          ( "%s!GprCreateDevice: GprWorkStartup failed %X(hex)\n",
                            SC_DRIVER_NAME,
                            NTStatus )
                          );


            NTStatus = STATUS_INSUFFICIENT_RESOURCES;
            __leave;
        }

        // Now setup information in our deviceExtension.
        SmartcardExtension->ReaderCapabilities.CurrentState = (ULONG) SCARD_UNKNOWN;
        SmartcardExtension->ReaderCapabilities.MechProperties = 0;

        // enter correct version of the lib
        SmartcardExtension->Version = SMCLIB_VERSION;

        // Setup the Smartcard support functions that we implement.
        SmartcardExtension->ReaderFunction[RDF_CARD_POWER] =    GprCbReaderPower;
        SmartcardExtension->ReaderFunction[RDF_TRANSMIT] =      GprCbTransmit;
        SmartcardExtension->ReaderFunction[RDF_SET_PROTOCOL] =  GprCbSetProtocol;
        SmartcardExtension->ReaderFunction[RDF_CARD_TRACKING] =   GprCbSetupCardTracking;
        SmartcardExtension->ReaderFunction[RDF_IOCTL_VENDOR] =  GprCbVendorIoctl;

        DeviceExtension->PowerState = PowerDeviceD0;

        //  Initialize the vendor information.
        strcpy(SmartcardExtension->VendorAttr.VendorName.Buffer, SC_VENDOR_NAME);
        strcpy(SmartcardExtension->VendorAttr.IfdType.Buffer, SC_IFD_TYPE);

        SmartcardExtension->VendorAttr.VendorName.Length = (USHORT)strlen(SC_VENDOR_NAME);
        SmartcardExtension->VendorAttr.IfdType.Length =  (USHORT)strlen(SC_IFD_TYPE);
        SmartcardExtension->VendorAttr.UnitNo = DeviceInstance;

        DeviceExtension->DriverFlavor = DF_GPR400;
        //
        // Reader capabilities:
        // - the type of the reader (SCARD_READER_TYPE_PCMCIA)
        // - the protocols supported by the reader (SCARD_PROTOCOL_T0, SCARD_PROTOCOL_T1)
        // - the mechanical characteristic of the reader:
        // Verify if the reader can supports the detection of the card
        // insertion/removal. Only the main reader supports this functionnality.
        // - the default clock frequency
        // - the maximum clock frequency
        // - the default data rate
        // - the maximum data rate
        // - the maximum IFSD
        //
        SmartcardExtension->ReaderCapabilities.ReaderType =
        SCARD_READER_TYPE_PCMCIA;
        SmartcardExtension->ReaderCapabilities.SupportedProtocols =
        SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1;
        SmartcardExtension->ReaderCapabilities.Channel              = DeviceInstance;
        SmartcardExtension->ReaderCapabilities.CLKFrequency.Default = GPR_DEFAULT_FREQUENCY;
        SmartcardExtension->ReaderCapabilities.CLKFrequency.Max     = GPR_MAX_FREQUENCY;
        SmartcardExtension->ReaderCapabilities.MaxIFSD              = GPR_MAX_IFSD;
        SmartcardExtension->ReaderCapabilities.DataRate.Default     = GPR_DEFAULT_DATARATE;
        SmartcardExtension->ReaderCapabilities.DataRate.Max         = GPR_MAX_DATARATE;
        //
        // Reader capabilities (continue):
        // - List all the supported data rates
        //
        SmartcardExtension->ReaderCapabilities.DataRatesSupported.List =
        dataRatesSupported;
        SmartcardExtension->ReaderCapabilities.DataRatesSupported.Entries =
        sizeof(dataRatesSupported) / sizeof(dataRatesSupported[0]);

        //
        //  Reader Extension:
        //- the command timeout for the reader (GPR_DEFAULT_TIME)
        //
        SmartcardExtension->ReaderExtension->CmdTimeOut     = GPR_DEFAULT_TIME;
        SmartcardExtension->ReaderExtension->PowerTimeOut   = GPR_DEFAULT_POWER_TIME;

        //
        // Flag will prevent completion of the request
        // when the system will be waked up again.
        //
        SmartcardExtension->ReaderExtension->PowerRequest   = FALSE;

        //
        // Flag to know we strating a new device, not an hibernation mode.
        //
        SmartcardExtension->ReaderExtension->NewDevice  = TRUE;

        SmartcardExtension->SmartcardRequest.BufferSize = MIN_BUFFER_SIZE;
        SmartcardExtension->SmartcardReply.BufferSize   = MIN_BUFFER_SIZE;

        NTStatus = SmartcardInitialize(SmartcardExtension);

        if (NTStatus != STATUS_SUCCESS) {
            SmartcardLogError(
                             DriverObject,
                             GEMSCR0D_ERROR_CLAIM_RESOURCES,
                             NULL,
                             0
                             );
            SmartcardDebug(
                          DEBUG_ERROR,
                          ( "%s!GprCreateDevice: SmartcardInitialize failed %X(hex)\n",
                            SC_DRIVER_NAME,
                            NTStatus )
                          );

            __leave;
        }

        //
        // tell the lib our device object & create
        // symbolic link
        //
        SmartcardExtension->OsData->DeviceObject = *DeviceObject;

        // save the current power state of the reader
        SmartcardExtension->ReaderExtension->ReaderPowerState =
        PowerReaderWorking;
    }
    __finally
    {
        if (NTStatus != STATUS_SUCCESS) {
            // Do the driver unload in the calling function.
        }

        SmartcardDebug(
                      DEBUG_DRIVER,
                      ( "%s!GprCreateDevice: Exit %X(hex)\n",
                        SC_DRIVER_NAME,
                        NTStatus )
                      );
    }
    return NTStatus;
}


NTSTATUS GprStartDevice(
                       PDEVICE_OBJECT DeviceObject,
                       PCM_FULL_RESOURCE_DESCRIPTOR FullResourceDescriptor
                       )
/*++
Routine Description
   get the actual configuration from the passed FullResourceDescriptor
   and initializes the reader hardware

--*/    
{
    PCM_PARTIAL_RESOURCE_DESCRIPTOR PartialDescriptor;
    PDEVICE_EXTENSION DeviceExtension = DeviceObject->DeviceExtension;
    PSMARTCARD_EXTENSION pSCardExt = &DeviceExtension->SmartcardExtension;
    PREADER_EXTENSION pReaderExt = pSCardExt->ReaderExtension;
    NTSTATUS NTStatus = STATUS_SUCCESS;
    ULONG Count;
    PCMCIA_READER_CONFIG *pConfig = NULL;


    ASSERT(DeviceObject != NULL);
    ASSERT(FullResourceDescriptor != NULL);

    SmartcardDebug(
                  DEBUG_DRIVER,
                  ("%s!GprStartDevice: Enter \n",
                   SC_DRIVER_NAME)
                  );

   // Get the number of resources we need
    Count = FullResourceDescriptor->PartialResourceList.Count;

    SmartcardDebug(
                  DEBUG_DRIVER,
                  ("%s!GprStartDevice: Resource Count = %d\n",
                   SC_DRIVER_NAME,
                   Count)
                  );

    PartialDescriptor = FullResourceDescriptor->PartialResourceList.PartialDescriptors;

    pConfig = &(pReaderExt->ConfigData);
   //
   // parse all partial descriptors
   //

    while (Count--) {
        switch (PartialDescriptor->Type) {
        case CmResourceTypePort:
            {
            //
            // 0 - memory, 1 - IO
            //
                ULONG AddressSpace = 1;

                pReaderExt->BaseIoAddress =
                (PGPR400_REGISTERS) UlongToPtr(PartialDescriptor->u.Port.Start.LowPart);

                ASSERT(PartialDescriptor->u.Port.Length >= 4);


                SmartcardDebug(
                              DEBUG_DRIVER,
                              ("%s!GprStartDevice: IoBase = %lxh\n",
                               SC_DRIVER_NAME,
                               pReaderExt->BaseIoAddress)
                              );
                break;
            }

        case CmResourceTypeInterrupt:
            {
                KINTERRUPT_MODE   Mode;
                BOOLEAN  Shared;

                Mode = (
                       PartialDescriptor->Flags &
                       CM_RESOURCE_INTERRUPT_LATCHED ?
                       Latched : LevelSensitive
                       );

                Shared = (
                         PartialDescriptor->ShareDisposition ==
                         CmResourceShareShared
                         );

                pConfig->Vector = PartialDescriptor->u.Interrupt.Vector;
                pConfig->Affinity = PartialDescriptor->u.Interrupt.Affinity;
                pConfig->Level = (KIRQL) PartialDescriptor->u.Interrupt.Level;

                //
                // store IRQ to allow query configuration
                //
                SmartcardDebug(
                              DEBUG_DRIVER,
                              ("%s!GprStartDevice: Irq Vector: %d\n",
                               SC_DRIVER_NAME,
                               PartialDescriptor->u.Interrupt.Vector)
                              );
                DeviceExtension->InterruptServiceRoutine = GprIsr;
                DeviceExtension->IsrContext = DeviceExtension;
                //
                //connect the driver's isr
                //
                NTStatus = IoConnectInterrupt(
                                             &DeviceExtension->InterruptObject,
                                             DeviceExtension->InterruptServiceRoutine,
                                             DeviceExtension->IsrContext,
                                             NULL,
                                             pConfig->Vector,
                                             pConfig->Level,
                                             pConfig->Level,
                                             Mode,
                                             Shared,
                                             pConfig->Affinity,
                                             FALSE
                                             );

                break;
            }
        default:
            NTStatus = STATUS_UNSUCCESSFUL;
            break;
        }
        PartialDescriptor++;
    }

    __try
    {
      //
      // IOBase initialized ?
      //
        if ( pReaderExt->BaseIoAddress == NULL ) {
            SmartcardDebug(
                          DEBUG_DRIVER,
                          ("%s!GprStartDevice: No IO \n",
                           SC_DRIVER_NAME)
                          );
            //
            // under NT 4.0 the failure of this fct for the second reader
            // means there is only one device
            //
            SmartcardLogError(
                             DeviceObject,
                             GEMSCR0D_ERROR_IO_PORT,
                             NULL,
                             0
                             );

            NTStatus = STATUS_INSUFFICIENT_RESOURCES;
            __leave;
        }
        //
        // irq connected ?
        //
        if ( DeviceExtension->InterruptObject == NULL ) {
            SmartcardDebug(
                          DEBUG_DRIVER,
                          ("%s!GprStartDevice: No Irq \n",
                           SC_DRIVER_NAME)
                          );

            SmartcardLogError(
                             DeviceObject,
                             GEMSCR0D_ERROR_INTERRUPT,
                             NULL,
                             0
                             );

            NTStatus = STATUS_INSUFFICIENT_RESOURCES;
            __leave;
        }

        // YN
        //
        // GPR400 Check Hardware
        //
        NTStatus = IfdCheck(pSCardExt);

        if (NTStatus != STATUS_SUCCESS) {
            SmartcardDebug(
                          DEBUG_INFO, 
                          ("%s!GprStartDevice: ####### Reader is at bad state...\n",
                           SC_DRIVER_NAME)
                          );

            SmartcardLogError(
                             DeviceObject,
                             GEMSCR0D_UNABLE_TO_INITIALIZE,
                             NULL,
                             0
                             );

            // Unblock reader
            KeClearEvent(&pReaderExt->ReaderRemoved);
            KeSetEvent(&DeviceExtension->ReaderStarted, 0, FALSE);

            __leave;
        }

        // StartGpr in a worker thread.
        IoQueueWorkItem(
                       DeviceExtension->GprWorkStartup,
                       (PIO_WORKITEM_ROUTINE) GprWorkStartup,
                       DelayedWorkQueue,
                       NULL
                       );
        //
        // Put interface here
        //
        NTStatus = IoSetDeviceInterfaceState(
                                            &DeviceExtension->PnPDeviceName,
                                            TRUE
                                            );

    }
    __finally
    {
        if (!NT_SUCCESS(NTStatus)) {
            DeviceExtension->OpenFlag = FALSE;
            GprStopDevice(DeviceObject);
        }

        SmartcardDebug(
                      DEBUG_DRIVER,
                      ("%s!GprStartDevice: Exit %X(hex)\n",
                       SC_DRIVER_NAME,
                       NTStatus)
                      );
    }
    return NTStatus;
}


VOID GprStopDevice(
                  PDEVICE_OBJECT DeviceObject
                  )
/*++

  Routine Description
   Disconnect the interrupt used by the device & unmap the IO port

--*/    
{
    PDEVICE_EXTENSION DeviceExtension;
    PSMARTCARD_EXTENSION pSCardExt = NULL;

    ASSERT(DeviceObject != NULL);

    SmartcardDebug(
                  DEBUG_DRIVER,
                  ("%s!GprStopDevice: Enter \n",
                   SC_DRIVER_NAME)
                  );

    DeviceExtension = DeviceObject->DeviceExtension;
    pSCardExt = &(DeviceExtension->SmartcardExtension);

   //
   // disconnect the interrupt
   //
    if ( DeviceExtension->InterruptObject != NULL ) {
        IoDisconnectInterrupt(DeviceExtension->InterruptObject);
        DeviceExtension->InterruptObject = NULL;
    }

    SmartcardDebug(
                  DEBUG_DRIVER,
                  ("%s!GprStopDevice: Exit \n",
                   SC_DRIVER_NAME)
                  );
}

NTSTATUS
GprSystemControl(
                IN PDEVICE_OBJECT DeviceObject,
                IN PIRP           Irp
                )

/*++

Routine Description:

Arguments:

    DeviceObject  - Pointer to device object for this miniport
    Irp        - IRP involved.

Return Value:

    STATUS_SUCCESS.

--*/    
{

    PDEVICE_EXTENSION DeviceExtension; 
    PSMARTCARD_EXTENSION SmartcardExtension; 
    PREADER_EXTENSION ReaderExtension; 
    NTSTATUS status = STATUS_SUCCESS;

    DeviceExtension      = DeviceObject->DeviceExtension;
    SmartcardExtension   = &DeviceExtension->SmartcardExtension;
    ReaderExtension      = SmartcardExtension->ReaderExtension;

    IoSkipCurrentIrpStackLocation(Irp);
    status = IoCallDriver(ReaderExtension->AttachedDeviceObject, Irp);

    return status;

} 



NTSTATUS GprDeviceControl(
                         IN PDEVICE_OBJECT DeviceObject,
                         IN PIRP Irp
                         )
/*++

Routine description
   this is the IOCTL dispatch function
--*/    
{

    PDEVICE_EXTENSION DeviceExtension = NULL;
    PSMARTCARD_EXTENSION SmartcardExtension = NULL;
    NTSTATUS NTStatus = STATUS_SUCCESS;
    LARGE_INTEGER Timeout;
    KIRQL irql;

    ASSERT(DeviceObject != NULL);
    ASSERT(Irp != NULL);

    DeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(DeviceExtension != NULL);

    SmartcardExtension = &(DeviceExtension->SmartcardExtension);
    ASSERT(SmartcardExtension != NULL);

    SmartcardDebug(
                  DEBUG_DRIVER,
                  ("%s!GprDeviceControl: Enter\n",SC_DRIVER_NAME));
    KeAcquireSpinLock(&DeviceExtension->SpinLock,&irql);

    if (DeviceExtension->IoCount == 0) {

        KeReleaseSpinLock(&DeviceExtension->SpinLock,irql);
        NTStatus = KeWaitForSingleObject(
                                        &DeviceExtension->ReaderStarted,
                                        Executive,
                                        KernelMode,
                                        FALSE,
                                        NULL);

        ASSERT(NTStatus == STATUS_SUCCESS);
        KeAcquireSpinLock(&DeviceExtension->SpinLock,&irql);
    }

    ASSERT(DeviceExtension->IoCount >= 0);
    DeviceExtension->IoCount++;
    KeReleaseSpinLock(&DeviceExtension->SpinLock,irql);

    Timeout.QuadPart = 0;

    NTStatus = KeWaitForSingleObject(
                                    &(SmartcardExtension->ReaderExtension->ReaderRemoved),
                                    Executive,
                                    KernelMode,
                                    FALSE,
                                    &Timeout
                                    );

    if (NTStatus == STATUS_SUCCESS) {
        NTStatus = STATUS_DEVICE_REMOVED;
    } else {


        NTStatus = SmartcardAcquireRemoveLockWithTag(SmartcardExtension, 'tcoI');


   // Cancel the card detection timer
        KeCancelTimer(&(DeviceExtension->SmartcardExtension.ReaderExtension->CardDetectionTimer));

        AskForCardPresence(SmartcardExtension);
        Timeout.QuadPart = -(100 * POLLING_TIME);

        KeWaitForSingleObject(
                             &(DeviceExtension->SmartcardExtension.ReaderExtension->GPRIccPresEvent),
                             Executive,
                             KernelMode,
                             FALSE,
                             &Timeout
                             );
    }

    if (NTStatus != STATUS_SUCCESS) {
      // The device has been removed. Fail the call
        KeAcquireSpinLock(&DeviceExtension->SpinLock,&irql);
        DeviceExtension->IoCount--;
        KeReleaseSpinLock(&DeviceExtension->SpinLock,irql);
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = STATUS_DEVICE_REMOVED;
        NTStatus = STATUS_DEVICE_REMOVED;
        IoCompleteRequest(Irp,IO_NO_INCREMENT);
        SmartcardDebug(
                      DEBUG_DRIVER,
                      ("%s!GprDeviceControl: Exit %x\n"
                       ,SC_DRIVER_NAME
                       ,NTStatus)
                      );
        return(STATUS_DEVICE_REMOVED);
    }



    ASSERT(DeviceExtension->SmartcardExtension.ReaderExtension->ReaderPowerState ==
           PowerReaderWorking);

    NTStatus = SmartcardDeviceControl(
                                     &DeviceExtension->SmartcardExtension,
                                     Irp
                                     );

    //   Restart the card detection timer
    Timeout.QuadPart = -(10000 * POLLING_TIME);
    KeSetTimer(
              &(SmartcardExtension->ReaderExtension->CardDetectionTimer),
              Timeout,
              &SmartcardExtension->ReaderExtension->CardDpcObject
              );

   //SmartcardReleaseRemoveLock(SmartcardExtension);
    SmartcardReleaseRemoveLockWithTag(SmartcardExtension, 'tcoI');

    KeAcquireSpinLock(&DeviceExtension->SpinLock,&irql);

    DeviceExtension->IoCount--;
    ASSERT(DeviceExtension->IoCount >= 0);

    KeReleaseSpinLock(&DeviceExtension->SpinLock,irql);

    SmartcardDebug(
                  DEBUG_DRIVER,
                  ("%s!GprDeviceControl: Exit %x\n"
                   ,SC_DRIVER_NAME
                   ,NTStatus)
                  );

    return(NTStatus);
}


VOID GprFinishPendingRequest(
                            PDEVICE_OBJECT DeviceObject,
                            NTSTATUS    NTStatus
                            )
/*++

Routine Description :

   finishes a pending tracking request if the interrupt is served or the device
   will be unloaded

Arguments
   DeviceObject   context of the request
   NTStatus    status to report to the calling process

Return Value

  STATUS_SUCCESS
--*/    
{
    PDEVICE_EXTENSION DeviceExtension;
    PSMARTCARD_EXTENSION SmartcardExtension;
    KIRQL CurrentIrql;
    PIRP PendingIrp;

    ASSERT(DeviceObject != NULL);


    DeviceExtension      = DeviceObject->DeviceExtension;
    SmartcardExtension   = &DeviceExtension->SmartcardExtension;

    if ( SmartcardExtension->OsData->NotificationIrp != NULL ) {
        SmartcardDebug(
                      DEBUG_DRIVER,
                      ( "%s!GprFinishPendingRequest: Completing Irp %lx\n",
                        SC_DRIVER_NAME,
                        SmartcardExtension->OsData->NotificationIrp)
                      );

        PendingIrp = SmartcardExtension->OsData->NotificationIrp;

        IoAcquireCancelSpinLock( &CurrentIrql );
        IoSetCancelRoutine( PendingIrp, NULL );
        IoReleaseCancelSpinLock( CurrentIrql );
        //
        // finish the request
        //
        PendingIrp->IoStatus.Status = NTStatus;
        PendingIrp->IoStatus.Information = 0;

        IoCompleteRequest(PendingIrp, IO_NO_INCREMENT );
        //
        // reset the tracking context to enable tracking
        //
        SmartcardExtension->OsData->NotificationIrp = NULL;
    }
}


NTSTATUS GprCallPcmciaDriver(
                            IN PDEVICE_OBJECT DeviceObject,
                            IN PIRP Irp
                            )
/*++

Routine Description :

   Send an Irp to the pcmcia driver and wait until the pcmcia driver has
   finished the request.

   To make sure that the pcmcia driver will not complete the Irp we first
   initialize an event and set our own completion routine for the Irp.

   When the pcmcia driver has processed the Irp the completion routine will
   set the event and tell the IO manager that more processing is required.

   By waiting for the event we make sure that we continue only if the pcmcia
   driver has processed the Irp completely.

Arguments
   DeviceObject   context of call
   Irp            Irp to send to the pcmcia driver

Return Value
   status returned by the pcmcia driver
--*/    
{
    NTSTATUS NTStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION DeviceExtension = DeviceObject->DeviceExtension;
    KEVENT Event;

    ASSERT(DeviceObject != NULL);
    ASSERT(Irp != NULL);

    // Copy our stack location to the next.
    IoCopyCurrentIrpStackLocationToNext(Irp);

    //
    // initialize an event for process synchronization. the event is passed
    // to our completion routine and will be set if the pcmcia driver is done
    //
    KeInitializeEvent(
                     &Event,
                     NotificationEvent,
                     FALSE
                     );

    //
    // Our IoCompletionRoutine sets only our event
    //
    IoSetCompletionRoutine (
                           Irp,
                           GprComplete,
                           &Event,
                           TRUE,
                           TRUE,
                           TRUE
                           );

    //
    // Call the pcmcia driver
    //
    if (IoGetCurrentIrpStackLocation(Irp)->MajorFunction == IRP_MJ_POWER) {
        NTStatus = PoCallDriver(
                               DeviceExtension->SmartcardExtension.ReaderExtension->AttachedDeviceObject,
                               Irp
                               );
    } else {
        NTStatus = IoCallDriver(
                               DeviceExtension->SmartcardExtension.ReaderExtension->AttachedDeviceObject,
                               Irp
                               );
    }

    //
    // Wait until the pcmcia driver has processed the Irp
    //
    if (NTStatus == STATUS_PENDING) {
        NTStatus = KeWaitForSingleObject(
                                        &Event,
                                        Executive,
                                        KernelMode,
                                        FALSE,
                                        NULL
                                        );

        if (NTStatus == STATUS_SUCCESS) {
            NTStatus = Irp->IoStatus.Status;
        }
    }

    SmartcardDebug(
                  DEBUG_DRIVER,
                  ("%s!GprCallPcmciaDriver: Exit %x\n",
                   SC_DRIVER_NAME,
                   NTStatus)
                  );

    return NTStatus;
}


NTSTATUS GprComplete (
                     IN PDEVICE_OBJECT DeviceObject,
                     IN PIRP Irp,
                     IN PKEVENT Event
                     )
/*++
Routine Description:
   Completion routine for an Irp sent to the pcmcia driver. The event will
   be set to notify that the pcmcia driver is done. The routine will not
   'complete' the Irp, so the caller of GprCallPcmciaDriver can continue.

Arguments:
   DeviceObject   context of call
   Irp            Irp to complete
   Event       Used by GprCallPcmciaDriver for process synchronization

Return Value

   STATUS_CANCELLED              Irp was cancelled by the IO manager
   STATUS_MORE_PROCESSING_REQUIRED     Irp will be finished by caller of
                              GprCallPcmciaDriver
--*/    
{
    UNREFERENCED_PARAMETER (DeviceObject);

    ASSERT(Irp != NULL);
    ASSERT(Event != NULL);


    if (Irp->Cancel) {
        Irp->IoStatus.Status = STATUS_CANCELLED;
    }
//    else
//    {
//        Irp->IoStatus.Status = STATUS_MORE_PROCESSING_REQUIRED;
//    }

    KeSetEvent (Event, 0, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}



NTSTATUS GprDispatchPnp(
                       IN PDEVICE_OBJECT DeviceObject,
                       IN PIRP Irp
                       )
/*++

Routine Description
   driver callback for pnp manager
   Request:             Action:

   IRP_MN_START_DEVICE        Notify the pcmcia driver about the new device
                        and start the device

   IRP_MN_STOP_DEVICE         Free all resources used by the device and tell
                        the pcmcia driver that the device was stopped

   IRP_MN_QUERY_REMOVE_DEVICE If the device is opened (i.e. in use) an error will
                        be returned to prevent the PnP manager to stop
                        the driver

   IRP_MN_CANCEL_REMOVE_DEVICE   just notify that we can continue without any
                        restrictions

   IRP_MN_REMOVE_DEVICE    notify the pcmcia driver that the device was
                        removed, stop & unload the device

   All other requests will be passed to the pcmcia driver to ensure correct processing.

Arguments:
   Device Object  context of call
   Irp            irp from the PnP manager

Return value

   STATUS_SUCCESS
   STATUS_UNSUCCESSFUL
   status returned by pcmcia driver
--*/    
{
    NTSTATUS NTStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION DeviceExtension = DeviceObject->DeviceExtension;
    PSMARTCARD_EXTENSION smartcardExtension = NULL;
    PIO_STACK_LOCATION IrpStack;              
    BOOLEAN deviceRemoved = FALSE, irpSkipped = FALSE;
    KIRQL irql;
    LARGE_INTEGER Timeout;

    ASSERT(DeviceObject != NULL);
    ASSERT(Irp != NULL);

    SmartcardDebug(
                  DEBUG_DRIVER,
                  ("%s!GprDispatchPnp: Enter\n",
                   SC_DRIVER_NAME)
                  );

    smartcardExtension = &(DeviceExtension->SmartcardExtension);
    //NTStatus = SmartcardAcquireRemoveLock(smartcardExtension);
    NTStatus = SmartcardAcquireRemoveLockWithTag(smartcardExtension, ' PnP');

    ASSERT(NTStatus == STATUS_SUCCESS);
    if (NTStatus != STATUS_SUCCESS) {
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = NTStatus;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return NTStatus;
    }


//   Irp->IoStatus.Information = 0;
    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    Timeout.QuadPart = 0;


   //
   // Now look what the PnP manager wants...
   //
    switch (IrpStack->MinorFunction) {
    case IRP_MN_START_DEVICE:
            //
            // Now we should connect to our resources (Irql, Io etc.)
            //
        SmartcardDebug(
                      DEBUG_DRIVER,
                      ("%s!GprDispatchPnp: IRP_MN_START_DEVICE\n",
                       SC_DRIVER_NAME)
                      );

            //
            // We have to call the underlying driver first
            //
        NTStatus = GprCallPcmciaDriver(
                                      DeviceObject,
                                      Irp
                                      );

        ASSERT(NT_SUCCESS(NTStatus));

        if (NT_SUCCESS(NTStatus)) {
            NTStatus = GprStartDevice(
                                     DeviceObject,
                                     &IrpStack->Parameters.StartDevice.AllocatedResourcesTranslated->List[0]
                                     );
        }
        break;
    case IRP_MN_QUERY_STOP_DEVICE:

        SmartcardDebug(
                      DEBUG_DRIVER,
                      ("%s!GprDispatchPnP: IRP_MN_QUERY_STOP_DEVICE\n",
                       SC_DRIVER_NAME)
                      );
        KeAcquireSpinLock(&DeviceExtension->SpinLock, &irql);
        if (DeviceExtension->IoCount > 0) {
                // we refuse to stop if we have pending io
            KeReleaseSpinLock(&DeviceExtension->SpinLock, irql);
            NTStatus = STATUS_DEVICE_BUSY;

        } else {
                // stop processing requests

            KeClearEvent(&DeviceExtension->ReaderStarted);
            KeReleaseSpinLock(&DeviceExtension->SpinLock, irql);

            NTStatus = GprCallPcmciaDriver(
                                          DeviceObject,
                                          Irp);
        }

        break;

    case IRP_MN_CANCEL_STOP_DEVICE:

        SmartcardDebug(
                      DEBUG_DRIVER,
                      ("%s!GprDispatchPnP: IRP_MN_CANCEL_STOP_DEVICE\n",
                       SC_DRIVER_NAME)
                      );

        NTStatus = GprCallPcmciaDriver(
                                      DeviceObject,
                                      Irp
                                      );

        if (NTStatus == STATUS_SUCCESS) {
                // we can continue to process requests
            KeSetEvent(&DeviceExtension->ReaderStarted, 0, FALSE);
        }
        break;

    case IRP_MN_STOP_DEVICE:
            //
            // Stop the device.
            //
        SmartcardDebug(
                      DEBUG_DRIVER,
                      ("%s!GprDispatchPnp: IRP_MN_STOP_DEVICE\n",
                       SC_DRIVER_NAME)
                      );

        GprStopDevice(DeviceObject);

        NTStatus = GprCallPcmciaDriver(DeviceObject, Irp);
        break;

    case IRP_MN_QUERY_REMOVE_DEVICE:
            //
            // Remove our device
            //
        SmartcardDebug(
                      DEBUG_DRIVER,
                      ("%s!GprDispatchPnp: IRP_MN_QUERY_REMOVE_DEVICE\n",
                       SC_DRIVER_NAME)
                      );

            // disable the reader
        NTStatus = IoSetDeviceInterfaceState(
                                            &DeviceExtension->PnPDeviceName,
                                            FALSE
                                            );

        SmartcardDebug(
                      DEBUG_TRACE,
                      ("%s!GprDispatchPnp: Set Pnp Interface state to FALSE, status=%x\n",
                       SC_DRIVER_NAME,
                       NTStatus)
                      );
        if (NTStatus != STATUS_SUCCESS) {
            break;
        }

            //
            // check if the reader has been opened
            // Note: This call only checks and does NOT wait for a close
            //
        Timeout.QuadPart = 0;

        NTStatus = KeWaitForSingleObject(
                                        &DeviceExtension->ReaderClosed,
                                        Executive,
                                        KernelMode,
                                        FALSE,
                                        &Timeout
                                        );

        if (NTStatus == STATUS_TIMEOUT) {
                // someone is connected, enable the reader and fail the call
            IoSetDeviceInterfaceState(
                                     &DeviceExtension->PnPDeviceName,
                                     TRUE
                                     );
            SmartcardDebug(
                          DEBUG_TRACE,
                          ("%s!GprDispatchPnp: Set Pnp Interface state to TRUE\n",
                           SC_DRIVER_NAME)
                          );

            NTStatus = STATUS_UNSUCCESSFUL;
            break;
        }

            // pass the call to the next driver in the stack
        NTStatus = GprCallPcmciaDriver(DeviceObject, Irp);
        break;

    case IRP_MN_CANCEL_REMOVE_DEVICE:
            //
            // Removal of device has been cancelled
            //
        SmartcardDebug(
                      DEBUG_DRIVER,
                      ("%s!GprDispatchPnp: IRP_MN_CANCEL_REMOVE_DEVICE\n",
                       SC_DRIVER_NAME)
                      );

        NTStatus = GprCallPcmciaDriver(DeviceObject, Irp);
        if (NTStatus == STATUS_SUCCESS) {
            NTStatus = IoSetDeviceInterfaceState(
                                                &DeviceExtension->PnPDeviceName,
                                                TRUE
                                                );
            SmartcardDebug(
                          DEBUG_TRACE,
                          ("%s!GprDispatchPnp: Set Pnp Interface state to TRUE, status=%s\n",
                           SC_DRIVER_NAME,
                           NTStatus)
                          );
        }
        break;

    case IRP_MN_REMOVE_DEVICE:

            //
            // Remove our device
            //
        SmartcardDebug(
                      DEBUG_DRIVER,
                      ("%s!GprDispatchPnp: IRP_MN_REMOVE_DEVICE\n",
                       SC_DRIVER_NAME)
                      );

        KeSetEvent(&(smartcardExtension->ReaderExtension->ReaderRemoved), 0, FALSE);

        GprStopDevice(DeviceObject);

        SmartcardDebug(
                      DEBUG_DRIVER,
                      ("%s!GprDispatchPnp: call pcmcia\n",
                       SC_DRIVER_NAME,
                       NTStatus)
                      );

        NTStatus = GprCallPcmciaDriver(DeviceObject, Irp);

        SmartcardDebug(
                      DEBUG_DRIVER,
                      ("%s!GprDispatchPnp: Finish with unload driver\n",
                       SC_DRIVER_NAME,
                       NTStatus)
                      );

        GprUnloadDevice(DeviceObject);

        deviceRemoved = TRUE;
        break;

    case IRP_MN_SURPRISE_REMOVAL:

            //
            // Unexpectedly removed our Reader
            //
        SmartcardDebug(
                      DEBUG_DRIVER,
                      ("%s!GprDispatchPnp: IRP_MN_SURPRISE_REMOVAL\n",
                       SC_DRIVER_NAME)
                      );
        if ( DeviceExtension->InterruptObject != NULL ) {
            IoDisconnectInterrupt(DeviceExtension->InterruptObject);
            DeviceExtension->InterruptObject = NULL;
        }


        KeSetEvent(&(smartcardExtension->ReaderExtension->ReaderRemoved), 0, FALSE);

        NTStatus = GprCallPcmciaDriver(DeviceObject, Irp);

        break;

    default:
            // This might be an Irp that is only useful
            // for the underlying bus driver
        NTStatus = GprCallPcmciaDriver(DeviceObject, Irp);
        irpSkipped = TRUE;
        break;
    }

    if (!irpSkipped) {
        Irp->IoStatus.Status = NTStatus;
    }

    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    if (deviceRemoved == FALSE) {
        SmartcardReleaseRemoveLockWithTag(smartcardExtension, ' PnP');
    }

    SmartcardDebug(
                  DEBUG_DRIVER,
                  ("%s!GprDispatchPnp: Exit %x\n",
                   SC_DRIVER_NAME,
                   NTStatus)
                  );
    return NTStatus;
}


BOOLEAN GprIsr(
              IN PKINTERRUPT pkInterrupt,
              IN PVOID pvContext
              )
/*++

Routine Description

  Interrupt Service routine called when an exchange has been processed by the GPR

--*/    
{
    PDEVICE_EXTENSION DeviceExtension = NULL;

    ASSERT(pvContext != NULL);

    DeviceExtension = (PDEVICE_EXTENSION) pvContext;

   //
   //Request a DPC which will complete the pending User I/O Request
   //Packet (aka, IRP), if there is one.
   //
    KeInsertQueueDpc(
                    &DeviceExtension->DpcObject,
                    DeviceExtension,
                    &DeviceExtension->SmartcardExtension
                    );
    return(TRUE);
}


NTSTATUS GprCleanup(
                   IN PDEVICE_OBJECT DeviceObject,
                   IN PIRP Irp
                   )
/*++

Routine Description:

    This routine is called by the I/O system when the calling thread terminates

Arguments:

    DeviceObject  - Pointer to device object for this miniport
    Irp        - IRP involved.

Return Value:

    STATUS_SUCCESS

--*/    
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PSMARTCARD_EXTENSION SmartcardExtension = &deviceExtension->SmartcardExtension;
    NTSTATUS NTStatus = STATUS_SUCCESS;

    ASSERT(DeviceObject != NULL);
    ASSERT(Irp != NULL);

    SmartcardDebug(
                  DEBUG_DRIVER,
                  ("%s!GprCleanUp: Enter\n",
                   SC_DRIVER_NAME)
                  );

    IoAcquireCancelSpinLock(&(Irp->CancelIrql));

    if (SmartcardExtension->OsData->NotificationIrp) {
        // We need to complete the notification irp
        IoSetCancelRoutine(
                          SmartcardExtension->OsData->NotificationIrp,
                          NULL
                          );

        GprCancelEventWait(
                          DeviceObject,
                          SmartcardExtension->OsData->NotificationIrp
                          );
    } else {
        IoReleaseCancelSpinLock( Irp->CancelIrql );
    }

    SmartcardDebug(
                  DEBUG_DRIVER,
                  ("%s!GprCleanUp: Completing IRP %lx\n",
                   SC_DRIVER_NAME,
                   Irp)
                  );

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = STATUS_SUCCESS;

    SmartcardDebug(
                  DEBUG_DRIVER,
                  ("%s!GprCleanUp: IoCompleteRequest\n",
                   SC_DRIVER_NAME)
                  );

    IoCompleteRequest(
                     Irp,
                     IO_NO_INCREMENT
                     );

    SmartcardDebug(
                  DEBUG_DRIVER,
                  ("%s!GprCleanUp: exit %x\n",
                   SC_DRIVER_NAME,
                   NTStatus)
                  );

    return(NTStatus);
}


NTSTATUS GprCancelEventWait(
                           IN PDEVICE_OBJECT DeviceObject,
                           IN PIRP Irp
                           )
/*++

Routine Description:

    This routine is called by the I/O system
    when the irp should be cancelled

Arguments:

    DeviceObject  - Pointer to device object for this miniport
    Irp        - IRP involved.

Return Value:

    STATUS_CANCELLED

--*/    
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PSMARTCARD_EXTENSION SmartcardExtension = &deviceExtension->SmartcardExtension;

    SmartcardDebug(
                  DEBUG_DRIVER,
                  ("%s!GprCancelEventWait: Enter\n",
                   SC_DRIVER_NAME)
                  );

    ASSERT(Irp == SmartcardExtension->OsData->NotificationIrp);

    SmartcardExtension->OsData->NotificationIrp = NULL;

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = STATUS_CANCELLED;

    IoReleaseCancelSpinLock(
                           Irp->CancelIrql
                           );

    SmartcardDebug(
                  DEBUG_DRIVER,
                  ("%s!GprCancelEventWait: Request completed Irp = %lx\n",
                   SC_DRIVER_NAME,
                   Irp)
                  );

    IoCompleteRequest(
                     Irp,
                     IO_NO_INCREMENT
                     );

    SmartcardDebug(
                  DEBUG_DRIVER,
                  ("%s!GprCancelEventWait: Exit\n",
                   SC_DRIVER_NAME)
                  );

    return STATUS_CANCELLED;

}


VOID GprCardEventDpc(
                    PKDPC                   Dpc,
                    PDEVICE_OBJECT          DeviceObject,
                    PDEVICE_EXTENSION    DeviceExtension,
                    PSMARTCARD_EXTENSION    SmartcardExtension
                    )
/*++

Routine Description :

    DPC routine for interrupts generated by the reader when a card is
    inserted/removed. This routine is called only when there is a user
    pending request on an insertion/removal IOCTL call. It will check
    if the Irp exists and its not being cancelled, and it will then
    complete it to signal the user event.
--*/    
{
    ULONG OldState;
    ULONG NewState;
    READER_EXTENSION *pReaderExt;
    KIRQL irql;

    ASSERT (DeviceExtension != NULL);

    ASSERT (SmartcardExtension != NULL);

    pReaderExt = SmartcardExtension->ReaderExtension;
    ASSERT (pReaderExt != NULL);
    // Read reader status response from the reader.
    GprllReadResp(pReaderExt);
    KeAcquireSpinLock(&SmartcardExtension->OsData->SpinLock,
                      &irql);


    ASSERT(pReaderExt->Vo != NULL);

    OldState = SmartcardExtension->ReaderCapabilities.CurrentState;

    if ((pReaderExt->To==0xA2) && (pReaderExt->Lo==4)) {
        //
        // The TLV answer indicates the status of the card (inserted/removed)
        //
        if ( (pReaderExt->Vo[1] & 0x80) == 0x80) {
            if (SmartcardExtension->ReaderCapabilities.CurrentState <3) {
                NewState = SCARD_SWALLOWED;
            } else {
                NewState = SmartcardExtension->ReaderCapabilities.CurrentState;
            }
        } else {
            NewState = SCARD_ABSENT;
        }

        // register this state

        SmartcardExtension->ReaderCapabilities.CurrentState = NewState;

    } else {
        KeSetEvent(&(SmartcardExtension->ReaderExtension->GPRAckEvent),0,FALSE);
    }
    //
    // If the caller was waiting on a IOCTL_SMARTCARD_IS_PRESENT or
    // IOCTL_SMARTCARD_IS_ABSENT command, complete the request, but
    // check first if its being cancelled!
    //

    if (  (OldState != SmartcardExtension->ReaderCapabilities.CurrentState)) {
        KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                          irql);

        GprFinishPendingRequest( DeviceObject, STATUS_SUCCESS );
    } else {
        KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                          irql);

    }

}


VOID GprCardPresenceDpc(
                       IN PKDPC pDpc,
                       IN PVOID pvContext,
                       IN PVOID pArg1,
                       IN PVOID pArg2
                       )
/*++

  Routine Description:
   This is the DPC routine called by polling to detect the card insertion/removal
--*/    
{
    PDEVICE_EXTENSION pDevExt = NULL;
    PSMARTCARD_EXTENSION SmartcardExtension = NULL;
    LARGE_INTEGER Timeout;
    NTSTATUS status;
    UNREFERENCED_PARAMETER (pArg1);
    UNREFERENCED_PARAMETER (pArg2);


    pDevExt = (PDEVICE_EXTENSION) pvContext;
    SmartcardExtension = &(pDevExt->SmartcardExtension);


//   SmartcardDebug(DEBUG_DRIVER,("------ CARD PRESENCE DPC ->  ENTER\n"));

   // ISV
   // If wait conditions can be satisfied - get hardware.
   // Otherwise - just restart Timer to test it next time...
    status = testForIdleAndBlock(SmartcardExtension->ReaderExtension);
    if (NT_SUCCESS(status)) {
       //  Send TLV command, to know card state,
        //  We don't care about return status, we get the response
        //  from the Interrupt
//       SmartcardDebug(DEBUG_DRIVER,("------ CARD PRESENCE DPC ->  GOT ACCESS! status %x\n", status));
        AskForCardPresence(SmartcardExtension);
       // Release hardware
        setIdle(SmartcardExtension->ReaderExtension);
    }

    if (!KeReadStateEvent(&(SmartcardExtension->ReaderExtension->ReaderRemoved))) {

       // Restart the polling timer
        Timeout.QuadPart = -(10000 * POLLING_TIME);
        KeSetTimer(&(SmartcardExtension->ReaderExtension->CardDetectionTimer),
                   Timeout,
                   &SmartcardExtension->ReaderExtension->CardDpcObject
                  );
    }

//   SmartcardDebug(DEBUG_DRIVER,("------ CARD PRESENCE DPC ->  EXIT\n"));
}



VOID GprUnloadDevice(
                    PDEVICE_OBJECT DeviceObject
                    )
/*++

    Routine description

    close connections to smclib.sys and the pcmcia driver, delete symbolic
    link and mark the slot as unused.

    Arguments

    DeviceObject  device to unload
--*/    
{
    PDEVICE_EXTENSION DeviceExtension;

    PAGED_CODE();

    ASSERT(DeviceObject != NULL);

    if (DeviceObject == NULL) {
        return;
    }

    SmartcardDebug(
                  DEBUG_DRIVER,
                  ("%s!GprUnloadDevice: Enter \n",
                   SC_DRIVER_NAME)
                  );

    DeviceExtension = DeviceObject->DeviceExtension;

    ASSERT(
          DeviceExtension->SmartcardExtension.VendorAttr.UnitNo <
          GPR_MAX_DEVICE
          );

    if (DeviceExtension->PnPDeviceName.Buffer != NULL) {
        // disble our device so no one can open it
        IoSetDeviceInterfaceState(
                                 &DeviceExtension->PnPDeviceName,
                                 FALSE
                                 );
    }

   // Mark this slot as available
    bDeviceSlot[DeviceExtension->SmartcardExtension.VendorAttr.UnitNo] = FALSE;

   // report to the lib that the device will be unloaded
    if (DeviceExtension->SmartcardExtension.OsData != NULL) {
        //  finish pending tracking requests
        GprFinishPendingRequest(DeviceObject, STATUS_CANCELLED);

        ASSERT(DeviceExtension->SmartcardExtension.OsData->NotificationIrp == NULL);

        // Wait until we can safely unload the device
        SmartcardReleaseRemoveLockAndWait(&DeviceExtension->SmartcardExtension);
    }

    if (DeviceExtension->SmartcardExtension.ReaderExtension != NULL) {
         // Free under reader stuff
        if (!KeReadStateTimer(&(DeviceExtension->SmartcardExtension.ReaderExtension->CardDetectionTimer))) {
            // Prevent restarting timer by sync functions
            KeCancelTimer(&(DeviceExtension->SmartcardExtension.ReaderExtension->CardDetectionTimer));
        }

        // Detach from the pcmcia driver
        if (DeviceExtension->SmartcardExtension.ReaderExtension->AttachedDeviceObject) {
            IoDetachDevice(
                          DeviceExtension->SmartcardExtension.ReaderExtension->AttachedDeviceObject
                          );

            DeviceExtension->SmartcardExtension.ReaderExtension->AttachedDeviceObject = NULL;
        }

        // free output buffer
        if (DeviceExtension->SmartcardExtension.ReaderExtension->Vo) {
            ExFreePool(DeviceExtension->SmartcardExtension.ReaderExtension->Vo);
            DeviceExtension->SmartcardExtension.ReaderExtension->Vo = NULL;
        }

        // free ReaderExtension structure
        ExFreePool(DeviceExtension->SmartcardExtension.ReaderExtension);
        DeviceExtension->SmartcardExtension.ReaderExtension = NULL;
    }

    if (DeviceExtension->GprWorkStartup != NULL) {
        IoFreeWorkItem(DeviceExtension->GprWorkStartup);
        DeviceExtension->GprWorkStartup = NULL;
    }

    if (DeviceExtension->SmartcardExtension.OsData != NULL) {
        SmartcardExit(&DeviceExtension->SmartcardExtension);
    }

    if (DeviceExtension->PnPDeviceName.Buffer != NULL) {
        RtlFreeUnicodeString(&DeviceExtension->PnPDeviceName);
        DeviceExtension->PnPDeviceName.Buffer = NULL;
    }

    // delete the device object
    IoDeleteDevice(DeviceObject);

    SmartcardDebug(
                  DEBUG_DRIVER,
                  ("%s!GprUnloadDevice: Exit \n",
                   SC_DRIVER_NAME)
                  );

    return;
}


VOID GprUnloadDriver(
                    PDRIVER_OBJECT DriverObject
                    )
/*++

  Routine  Description :
   unloads all devices for a given driver object

  Arguments
   DriverObject   context of driver
--*/    
{

    PAGED_CODE();

    SmartcardDebug(
                  DEBUG_DRIVER,
                  ("%s!GprUnloadDriver\n",
                   SC_DRIVER_NAME)
                  );
}


NTSTATUS GprCreateClose(
                       PDEVICE_OBJECT DeviceObject,
                       PIRP        Irp
                       )
/*++
    Routine Description
    Create / Close Device function
--*/    
{
    NTSTATUS NTStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION DeviceExtension;
    PSMARTCARD_EXTENSION SmartcardExtension;
    PIO_STACK_LOCATION IrpStack;
    LARGE_INTEGER Timeout;

    DeviceExtension      = DeviceObject->DeviceExtension;
    SmartcardExtension   = &DeviceExtension->SmartcardExtension;
    IrpStack       = IoGetCurrentIrpStackLocation( Irp );

   // Initialize
    Irp->IoStatus.Information = 0;

   // dispatch major function
    switch ( IrpStack->MajorFunction ) {
    case IRP_MJ_CREATE:

        SmartcardDebug(
                      DEBUG_DRIVER,
                      ("%s!GprCreateClose: OPEN DEVICE\n",
                       SC_DRIVER_NAME)
                      );

        NTStatus = SmartcardAcquireRemoveLockWithTag(SmartcardExtension, 'lCrC');
        if (NTStatus != STATUS_SUCCESS) {
            NTStatus = STATUS_DEVICE_REMOVED;
        } else {
            Timeout.QuadPart = 0;

                // test if the device has been opened already
            NTStatus = KeWaitForSingleObject(
                                            &DeviceExtension->ReaderClosed,
                                            Executive,
                                            KernelMode,
                                            FALSE,
                                            &Timeout
                                            );

            if (NTStatus == STATUS_SUCCESS) {
                DeviceExtension->OpenFlag = TRUE;
                SmartcardDebug(
                              DEBUG_DRIVER,
                              ("%s!GprCreateClose: Set Card Detection timer\n",
                               SC_DRIVER_NAME)
                              );

                    // start the detection timer
                Timeout.QuadPart = -(10000 * POLLING_TIME);
                KeSetTimer(
                          &(SmartcardExtension->ReaderExtension->CardDetectionTimer),
                          Timeout,
                          &SmartcardExtension->ReaderExtension->CardDpcObject
                          );

                KeClearEvent(&DeviceExtension->ReaderClosed);
            } else {
                    // the device is already in use
                NTStatus = STATUS_UNSUCCESSFUL;

                    // release the lock
                    //SmartcardReleaseRemoveLock(SmartcardExtension);
                SmartcardReleaseRemoveLockWithTag(SmartcardExtension, 'lCrC');

            }
        }

        SmartcardDebug(
                      DEBUG_DRIVER,
                      ("%s!GprCreateClose: OPEN DEVICE EXIT %x\n",
                       SC_DRIVER_NAME, NTStatus)
                      );
        break;

    case IRP_MJ_CLOSE:
        SmartcardDebug(
                      DEBUG_DRIVER,
                      ("%s!GprCreateClose: CLOSE DEVICE\n",
                       SC_DRIVER_NAME)
                      );

            // Cancel the card detection timer
            //SmartcardReleaseRemoveLock(SmartcardExtension);
        SmartcardReleaseRemoveLockWithTag(SmartcardExtension, 'lCrC');

        KeSetEvent(&DeviceExtension->ReaderClosed, 0, FALSE);

        if (DeviceExtension->OpenFlag == TRUE) {
            if (!KeReadStateTimer(&(DeviceExtension->SmartcardExtension.ReaderExtension->CardDetectionTimer))) {
                SmartcardDebug(
                              DEBUG_DRIVER,
                              ("%s!GprCreateClose: Cancel Detection timer\n",
                               SC_DRIVER_NAME)
                              );
                    // Prevent restarting timer by sync functions
                KeCancelTimer(&(DeviceExtension->SmartcardExtension.ReaderExtension->CardDetectionTimer));
            }
            DeviceExtension->OpenFlag = FALSE;
        }
        SmartcardDebug(
                      DEBUG_DRIVER,
                      ("%s!GprCreateClose: CLOSE DEVICE EXIT %x\n",
                       SC_DRIVER_NAME, NTStatus)
                      );
        break;

    default:
        NTStatus = STATUS_INVALID_DEVICE_REQUEST;
        SmartcardDebug(
                      DEBUG_DRIVER,
                      ("%s!GprCreateClose: Exit %x\n",
                       SC_DRIVER_NAME,
                       NTStatus)
                      );
        break;
    }

    Irp->IoStatus.Status = NTStatus;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return NTStatus;
}


VOID GprWorkStartup(
                   IN PDEVICE_OBJECT DeviceObject,
                   IN PVOID Context
                   )
/*++

Routine Description:
    This function start the GPR after the power completion is completed.
   This function runs as a system thread at IRQL == PASSIVE_LEVEL.

--*/    
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PSMARTCARD_EXTENSION SmartcardExtension = &deviceExtension->SmartcardExtension;
    LARGE_INTEGER Timeout;
    NTSTATUS NTStatus;
    USHORT i = 0;
    KIRQL irql;
    BOOLEAN ContinueLoop = TRUE;

    UNREFERENCED_PARAMETER(Context);

    SmartcardDebug(DEBUG_DRIVER,("------ WORK STARTUP -> ENTER\n"));


    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

   //    remove this call, use a work thread. Klaus!
    //
    // Reset the reader
    //
    waitForIdleAndBlock(SmartcardExtension->ReaderExtension);
    while ( ContinueLoop ) {

        NTStatus = IfdReset(SmartcardExtension);

        i++;

        if (NTStatus == STATUS_SUCCESS) {
            ContinueLoop = FALSE;
        } else if (i >= 3) {
            ContinueLoop= FALSE;
        } else if ( NTStatus == STATUS_DEVICE_REMOVED) {
            ContinueLoop= FALSE;
        }
    }

    SmartcardDebug(
                  DEBUG_DRIVER,
                  ("%s!GprWorkStartup: IfdReset Status: %x\n",
                   SC_DRIVER_NAME, NTStatus)
                  );

    if (NTStatus != STATUS_SUCCESS) {

        SmartcardLogError(
                         DeviceObject,
                         GEMSCR0D_UNABLE_TO_INITIALIZE,
                         NULL,
                         0
                         );

        //  Advise that reader is ready for working
        KeSetEvent(&deviceExtension->ReaderStarted, 0, FALSE);

        if (SmartcardExtension->ReaderExtension->RestartCardDetection) {
            SmartcardExtension->ReaderExtension->RestartCardDetection = FALSE;
            //   Restart the card detection timer
            Timeout.QuadPart = -(10000 * POLLING_TIME);
            KeSetTimer(
                      &(SmartcardExtension->ReaderExtension->CardDetectionTimer),
                      Timeout,
                      &SmartcardExtension->ReaderExtension->CardDpcObject
                      );
            SmartcardDebug(DEBUG_DRIVER,("           CARD DETECTION RESTARTED!\n"));
        }

        setIdle(SmartcardExtension->ReaderExtension);
        SmartcardDebug(DEBUG_DRIVER,("------ WORK STARTUP -> EXIT\n"));
        return;

    }


    // Do appropriate stuff for resume of hibernate mode.
    if ( SmartcardExtension->ReaderExtension->NewDevice == FALSE ) {
        //  Restart the card detection timer
        Timeout.QuadPart = -(10000 * POLLING_TIME);
        KeSetTimer(
                  &(SmartcardExtension->ReaderExtension->CardDetectionTimer),
                  Timeout,
                  &SmartcardExtension->ReaderExtension->CardDpcObject
                  );

        // If a card was present before power down or now there is
        // a card in the reader, we complete any pending card monitor
        // request, since we do not really know what card is now in the
        // reader.
        //
        KeAcquireSpinLock(&SmartcardExtension->OsData->SpinLock,
                          &irql);

        if (SmartcardExtension->ReaderExtension->CardPresent ||
            SmartcardExtension->ReaderCapabilities.CurrentState > SCARD_ABSENT) {
            KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                              irql);

            SmartcardDebug(
                          DEBUG_DRIVER,
                          ("%s!GprDevicePowerCompletion: GprFinishPendingRequest\n",
                           SC_DRIVER_NAME)
                          );
            GprFinishPendingRequest(
                                   DeviceObject,
                                   STATUS_SUCCESS
                                   );
        } else {
            KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                              irql);

        }
    }

    // Device initialization finish,
    // NewDevice help to know it we are in hibernation mode or non
    SmartcardExtension->ReaderExtension->NewDevice = FALSE;

   // Advise that reader is ready for working
    KeSetEvent(&deviceExtension->ReaderStarted, 0, FALSE);

    if (SmartcardExtension->ReaderExtension->RestartCardDetection) {

        SmartcardExtension->ReaderExtension->RestartCardDetection = FALSE;
        //   Restart the card detection timer
        Timeout.QuadPart = -(10000 * POLLING_TIME);
        KeSetTimer(
                  &(SmartcardExtension->ReaderExtension->CardDetectionTimer),
                  Timeout,
                  &SmartcardExtension->ReaderExtension->CardDpcObject
                  );
        SmartcardDebug(DEBUG_DRIVER,("           CARD DETECTION RESTARTED!\n"));
    }

    setIdle(SmartcardExtension->ReaderExtension);

    SmartcardDebug(DEBUG_DRIVER,("------ WORK STARTUP -> EXIT\n"));

}

// Functions to synchronize device execution
VOID        setBusy(PREADER_EXTENSION Device)
{
    KeClearEvent(&Device->IdleState);
    SmartcardDebug(DEBUG_DRIVER,("          DEVICE BUSY\n"));
};

VOID        setIdle(PREADER_EXTENSION Device)
{
    LARGE_INTEGER Timeout;
    KeSetEvent(&Device->IdleState,IO_NO_INCREMENT,FALSE);
    SmartcardDebug(DEBUG_DRIVER,("          DEVICE IDLE\n"));
};

NTSTATUS    waitForIdle(PREADER_EXTENSION Device)
{
    NTSTATUS status;
    ASSERT(KeGetCurrentIrql()<=DISPATCH_LEVEL);
    status  = KeWaitForSingleObject(&Device->IdleState, Executive,KernelMode, FALSE, NULL);
    if (!NT_SUCCESS(status)) return STATUS_IO_TIMEOUT;
    return STATUS_SUCCESS;
};

NTSTATUS    waitForIdleAndBlock(PREADER_EXTENSION Device)
{
    if (NT_SUCCESS(waitForIdle(Device))) {
        setBusy(Device);
        return STATUS_SUCCESS;
    } else return STATUS_IO_TIMEOUT;
};

NTSTATUS    testForIdleAndBlock(PREADER_EXTENSION Device)
{
    ASSERT(KeGetCurrentIrql()<=DISPATCH_LEVEL);
    if (KeReadStateEvent(&Device->IdleState)) {
        setBusy(Device);
        return STATUS_SUCCESS;
    }
    return STATUS_IO_TIMEOUT;
};

//-------------------------------------------------------------

NTSTATUS GprPower (
                  IN PDEVICE_OBJECT DeviceObject,
                  IN PIRP Irp
                  )
/*++

Routine Description:
    The power dispatch routine.
    This driver is the power policy owner of the device stack, 
    because this driver knows about the connected reader. 
    Therefor this driver will translate system power states
    to device power states.
    
Arguments:
   DeviceObject - pointer to a device object.
   Irp - pointer to an I/O Request Packet.

Return Value:
      NT status code

--*/    
{
    NTSTATUS status;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PDEVICE_OBJECT AttachedDeviceObject = ATTACHED_DEVICE_OBJECT;

    status = STATUS_SUCCESS;
    SmartcardDebug(
                  DEBUG_ERROR,
                  ("%s!GprPower: Enter\n",
                   SC_DRIVER_NAME)
                  );

    SmartcardDebug(
                  DEBUG_ERROR,
                  ("%s!GprPower: Irp = %lx\n",
                   SC_DRIVER_NAME, 
                   Irp)
                  );


    if (irpStack->MinorFunction == IRP_MN_QUERY_POWER)
        status = power_HandleQueryPower(DeviceObject,Irp);
    else if (irpStack->MinorFunction == IRP_MN_SET_POWER)
        status = power_HandleSetPower(DeviceObject,Irp);
    else {
        SmartcardDebug(
                      DEBUG_ERROR,
                      ("%s!GprPower: **** Forwarding Power request down...\n",
                       SC_DRIVER_NAME)
                      );

            // Default device does not do anything.
            // So let's just transfer request to low level driver...
        PoStartNextPowerIrp(Irp);// must be done while we own the IRP
        IoSkipCurrentIrpStackLocation(Irp);
        status = PoCallDriver(AttachedDeviceObject, Irp);       
    }

    SmartcardDebug(
                  DEBUG_DRIVER,
                  ("%s!GprPower: Exit %lx\n",
                   SC_DRIVER_NAME,
                   status)
                  );
    return status;  
}

// Manages set power requests
NTSTATUS power_HandleSetPower(PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
    PIO_STACK_LOCATION irpStack;
    NTSTATUS status = STATUS_SUCCESS;
    POWER_STATE sysPowerState, desiredDevicePowerState;
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PSMARTCARD_EXTENSION smartcardExtension = &deviceExtension->SmartcardExtension;
    PDEVICE_OBJECT AttachedDeviceObject = ATTACHED_DEVICE_OBJECT;
    KIRQL irql;

    if (!Irp) return STATUS_INVALID_PARAMETER;

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    switch (irpStack->Parameters.Power.Type) {
    case SystemPowerState:
            // Get input system power state
        sysPowerState.SystemState = irpStack->Parameters.Power.State.SystemState;

        SmartcardDebug(
                      DEBUG_ERROR,
                      ("%s!power_HandleSetPower: PowerSystem S%d\n",
                       SC_DRIVER_NAME,
                       irpStack->Parameters.Power.State.SystemState - 1)
                      );

            // If system is in working state always set our device to D0
            //  regardless of the wait state or system-to-device state power map
        if ( sysPowerState.SystemState == PowerSystemWorking) {
            desiredDevicePowerState.DeviceState = PowerDeviceD0;
            KeSetEvent(&deviceExtension->ReaderStarted, 0, FALSE);

            SmartcardDebug(
                          DEBUG_ERROR,
                          ("%s!power_HandleSetPower: PowerSystemWorking, Setting device power D0(ON)...\n",
                           SC_DRIVER_NAME)
                          );
        } else {
                //System reduces power, so do specific for device processing...
                // if no wait pending and the system's not in working state, just turn off
            desiredDevicePowerState.DeviceState = PowerDeviceD3;
            SmartcardDebug(DEBUG_ERROR,
                           ("%s!power_HandleSetPower: Going Device Power D3(off)\n",
                            SC_DRIVER_NAME));
        }

            // We've determined the desired device state; are we already in this state?
        if (smartcardExtension->ReaderExtension->ReaderPowerState != desiredDevicePowerState.DeviceState) {
            SmartcardDebug(
                          DEBUG_ERROR,
                          ("%s!power_HandleSetPower: Requesting to set DevicePower D%d\n",
                           SC_DRIVER_NAME,
                           desiredDevicePowerState.DeviceState - 1));

                // Callback will release the lock
            status = SmartcardAcquireRemoveLockWithTag(smartcardExtension, 'rwoP');

            IoMarkIrpPending(Irp);

                // No, request that we be put into this state
                // by requesting a new Power Irp from the Pnp manager
            deviceExtension->PowerIrp = Irp;
            status = PoRequestPowerIrp (DeviceObject,
                                        IRP_MN_SET_POWER,
                                        desiredDevicePowerState,
                                           // completion routine will pass the Irp down to the PDO
                                        (PREQUEST_POWER_COMPLETE)onPowerRequestCompletion, 
                                        DeviceObject, NULL);
        } else {   // Yes, just pass it on to PDO (Physical Device Object)
            IoCopyCurrentIrpStackLocationToNext(Irp);
            PoStartNextPowerIrp(Irp);
            status = PoCallDriver(AttachedDeviceObject, Irp);       
        }
        break;
    case DevicePowerState:
        SmartcardDebug(
                      DEBUG_ERROR,
                      ("%s!power_HandleSetPower: Setting Device Power D%d\n",
                       SC_DRIVER_NAME,
                       irpStack->Parameters.Power.State.DeviceState - 1));

            // For requests to D1, D2, or D3 ( sleep or off states ),
            // sets deviceExtension->CurrentDevicePowerState to DeviceState immediately.
            // This enables any code checking state to consider us as sleeping or off
            // already, as this will imminently become our state.

            // For requests to DeviceState D0 ( fully on ), sets fGoingToD0 flag TRUE
            // to flag that we must set a completion routine and update
            // deviceExtension->CurrentDevicePowerState there.
            // In the case of powering up to fully on, we really want to make sure
            // the process is completed before updating our CurrentDevicePowerState,
            // so no IO will be attempted or accepted before we're really ready.

        if (irpStack->Parameters.Power.State.DeviceState==PowerDeviceD3) {
                // save the current card state
            KeAcquireSpinLock(&smartcardExtension->OsData->SpinLock,
                              &irql);

            smartcardExtension->ReaderExtension->CardPresent = 
            smartcardExtension->ReaderCapabilities.CurrentState > SCARD_ABSENT;
            if (smartcardExtension->ReaderExtension->CardPresent) {
                KeReleaseSpinLock(&smartcardExtension->OsData->SpinLock,
                                  irql);

                SmartcardDebug(
                              DEBUG_DRIVER,
                              ("%s!power_HandleSetPower: Power down card....\n",
                               SC_DRIVER_NAME));

                smartcardExtension->MinorIoControlCode = SCARD_POWER_DOWN;
                GprCbReaderPower(smartcardExtension);
            } else {
                KeReleaseSpinLock(&smartcardExtension->OsData->SpinLock,
                                  irql);

            }

            if (!KeReadStateTimer(&smartcardExtension->ReaderExtension->CardDetectionTimer)) {
                SmartcardDebug(DEBUG_DRIVER,("          STOP CARD DETECTION!\n"));
                smartcardExtension->ReaderExtension->RestartCardDetection = TRUE;
                    // Stop detection for during power events
                KeCancelTimer(&smartcardExtension->ReaderExtension->CardDetectionTimer);
            }

                // If there is a pending card tracking request, setting
                // this flag will prevent completion of the request 
                // when the system will be waked up again.
            smartcardExtension->ReaderExtension->PowerRequest = TRUE;

            desiredDevicePowerState.DeviceState = PowerDeviceD3;
            PoSetPowerState(DeviceObject,DevicePowerState,desiredDevicePowerState);
                // save the current power state of the reader
            smartcardExtension->ReaderExtension->ReaderPowerState = PowerReaderOff;
                // Forward Irp down...
            IoCopyCurrentIrpStackLocationToNext(Irp);
            PoStartNextPowerIrp(Irp);
        } else {
            status = SmartcardAcquireRemoveLockWithTag(smartcardExtension, 'rwoP');

            SmartcardDebug(DEBUG_ERROR,
                           ("%s!power_HandleSetPower: Going to device power D0...\n",
                            SC_DRIVER_NAME));

            IoCopyCurrentIrpStackLocationToNext(Irp);
            IoSetCompletionRoutine(Irp,
                                   onDevicePowerUpComplete,
                       // Always pass FDO to completion routine as its Context;
                       // This is because the DriverObject passed by the system to the routine
                       // is the Physical Device Object ( PDO ) not the Functional Device Object ( FDO )
                                   DeviceObject,
                                   TRUE,            // invoke on success
                                   TRUE,            // invoke on error
                                   TRUE);           // invoke on cancellation of the Irp
        }
        status = PoCallDriver(AttachedDeviceObject, Irp);       
        break;
    } 
    return status;
}


// Manages device power up 
NTSTATUS    onDevicePowerUpComplete(
                                   IN PDEVICE_OBJECT NullDeviceObject,
                                   IN PIRP Irp,
                                   IN PVOID DeviceObject
                                   )
{
    NTSTATUS status = STATUS_SUCCESS;
    PIO_STACK_LOCATION irpStack;
    PDEVICE_EXTENSION deviceExtension = ((PDEVICE_OBJECT)DeviceObject)->DeviceExtension;
    PSMARTCARD_EXTENSION smartcardExtension = &deviceExtension->SmartcardExtension;
    POWER_STATE desiredDevicePowerState;

    SmartcardDebug(DEBUG_DRIVER,
                   ("%s!onDevicePowerUpComplete: Enter Device Power Up...\n",
                    SC_DRIVER_NAME));

    //  If the lower driver returned PENDING, mark our stack location as pending also.
    if (Irp->PendingReturned) IoMarkIrpPending(Irp);
    irpStack = IoGetCurrentIrpStackLocation (Irp);

    // We can assert that we're a  device powerup-to D0 request,
    // because that was the only type of request we set a completion routine
    // for in the first place
    ASSERT(irpStack->MajorFunction == IRP_MJ_POWER);
    ASSERT(irpStack->MinorFunction == IRP_MN_SET_POWER);
    ASSERT(irpStack->Parameters.Power.Type==DevicePowerState);
    ASSERT(irpStack->Parameters.Power.State.DeviceState==PowerDeviceD0);

    // We've got power up request, so...
    // Report everybody that reader is powered up again!
    smartcardExtension->ReaderExtension->ReaderPowerState = PowerReaderWorking;

    // GPR400 Check Hardware
    if (NT_SUCCESS(IfdCheck(smartcardExtension))) {
    // StartGpr in a worker thread.
        IoQueueWorkItem(
                       deviceExtension->GprWorkStartup,
                       (PIO_WORKITEM_ROUTINE) GprWorkStartup,
                       DelayedWorkQueue,
                       NULL);
    } else {
        SmartcardDebug(
                      DEBUG_ERROR, 
                      ("%s!GprDevicePowerCompletion: Reader is in Bad State\n",
                       SC_DRIVER_NAME)
                      );
    }

    smartcardExtension->ReaderExtension->PowerRequest = FALSE;

    // Now that we know we've let the lower drivers do what was needed to power up,
    //  we can set our device extension flags accordingly

    SmartcardReleaseRemoveLockWithTag(smartcardExtension, 'rwoP');

    // Report our state to Power manager...
    desiredDevicePowerState.DeviceState = PowerDeviceD0;
    PoSetPowerState(DeviceObject,DevicePowerState,desiredDevicePowerState);
    PoStartNextPowerIrp(Irp);

    SmartcardDebug(DEBUG_DRIVER,
                   ("%s!onDevicePowerUpComplete: Exit for the device state D0...\n",
                    SC_DRIVER_NAME));
    return status;
}

// Manages system power transitions
NTSTATUS onPowerRequestCompletion(
                                 IN PDEVICE_OBJECT       NullDeviceObject,
                                 IN UCHAR                MinorFunction,
                                 IN POWER_STATE          PowerState,
                                 IN PVOID                DeviceObject,
                                 IN PIO_STATUS_BLOCK     IoStatus
                                 )
{
    NTSTATUS status = STATUS_SUCCESS;
    PDEVICE_EXTENSION deviceExtension = ((PDEVICE_OBJECT)DeviceObject)->DeviceExtension;
    PSMARTCARD_EXTENSION smartcardExtension = &deviceExtension->SmartcardExtension;
    PDEVICE_OBJECT AttachedDeviceObject = ATTACHED_DEVICE_OBJECT;
    PIRP Irp;

    SmartcardDebug(DEBUG_DRIVER,
                   ("%s!onPowerRequestCompletion: Enter...\n",
                    SC_DRIVER_NAME));

    // Get the Irp we saved for later processing in BulkUsb_ProcessPowerIrp()
    // when we decided to request the Power Irp that this routine 
    // is the completion routine for.
    Irp = deviceExtension->PowerIrp;

    // We will return the status set by the PDO for the power request we're completing
    status = IoStatus->Status;
    smartcardExtension->ReaderExtension->ReaderPowerState = PowerState.DeviceState;

    // we must pass down to the next driver in the stack
    IoCopyCurrentIrpStackLocationToNext(Irp);

    // Calling PoStartNextPowerIrp() indicates that the driver is finished
    // with the previous power IRP, if any, and is ready to handle the next power IRP.
    // It must be called for every power IRP.Although power IRPs are completed only once,
    // typically by the lowest-level driver for a device, PoStartNextPowerIrp must be called
    // for every stack location. Drivers must call PoStartNextPowerIrp while the current IRP
    // stack location points to the current driver. Therefore, this routine must be called
    // before IoCompleteRequest, IoSkipCurrentStackLocation, and PoCallDriver.

    PoStartNextPowerIrp(Irp);

    // PoCallDriver is used to pass any power IRPs to the PDO instead of IoCallDriver.
    // When passing a power IRP down to a lower-level driver, the caller should use
    // IoSkipCurrentIrpStackLocation or IoCopyCurrentIrpStackLocationToNext to copy the IRP to
    // the next stack location, then call PoCallDriver. Use IoCopyCurrentIrpStackLocationToNext
    // if processing the IRP requires setting a completion routine, or IoSkipCurrentStackLocation
    // if no completion routine is needed.

    PoCallDriver(AttachedDeviceObject,Irp);

    deviceExtension->PowerIrp = NULL;
    SmartcardReleaseRemoveLockWithTag(smartcardExtension, 'rwoP');

    SmartcardDebug(DEBUG_DRIVER,
                   ("%s!onPowerRequestCompletion: Exit...\n",
                    SC_DRIVER_NAME));
    return status;
}

NTSTATUS power_HandleQueryPower(PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PSMARTCARD_EXTENSION smartcardExtension = &deviceExtension->SmartcardExtension;
    PDEVICE_OBJECT AttachedDeviceObject = ATTACHED_DEVICE_OBJECT;
    NTSTATUS status = STATUS_SUCCESS;
    KIRQL irql;

    SmartcardDebug(
                  DEBUG_ERROR,
                  ("%s!power_HandleQueryPower: Enter QueryPower...\n",
                   SC_DRIVER_NAME));

    KeAcquireSpinLock(&deviceExtension->SpinLock, &irql);
    if (deviceExtension->IoCount != 0)
    {   // can't go to sleep mode since the reader is busy.
        KeReleaseSpinLock(&deviceExtension->SpinLock, irql);                
        status = Irp->IoStatus.Status = STATUS_DEVICE_BUSY;
        Irp->IoStatus.Information = 0;
        PoStartNextPowerIrp(Irp);
            IoCompleteRequest(Irp, IO_NO_INCREMENT);        
        return status;
    }

    KeReleaseSpinLock(&deviceExtension->SpinLock, irql);                


    // Block any further ioctls
    KeClearEvent(&deviceExtension->ReaderStarted);
    

    SmartcardDebug(DEBUG_DRIVER,
                   ("%s!power_HandleQueryPower: Reader BLOCKED!!!!!!!...\n",
                    SC_DRIVER_NAME));

    Irp->IoStatus.Status = STATUS_SUCCESS;
    PoStartNextPowerIrp(Irp);
    IoSkipCurrentIrpStackLocation(Irp);
    status = PoCallDriver(AttachedDeviceObject, Irp);   
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\ifdtest\errmap.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       errmap.c
//
//--------------------------------------------------------------------------

typedef long LONG;
typedef LONG NTSTATUS;
#include <ntstatus.h>
#include <winerror.h>

//#define WIN32_NO_STATUS
#include "errmap.h"       

LONG                               
MapWinErrorToNtStatus(
    LONG in_uErrorCode
    )
{
    LONG i;

    for (i = 0; i < sizeof(CodePairs) / sizeof(CodePairs[0]); i += 2) {

        if (CodePairs[i + 1] == in_uErrorCode) {

            return CodePairs[i];
         	
        }
    }

    return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\ifdtest\giesecke.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    example.cpp

Abstract:

    This is a plug-in for the smart card driver test suite.
    This plug-in is smart card dependent

Author:

    Klaus U. Schutz

Environment:

    Win32 application

Revision History :

    Nov. 1997 - initial version

--*/

#include <stdarg.h> 
#include <stdio.h>
#include <string.h>
#include <time.h>

#include <afx.h>
#include <afxtempl.h>

#include <winioctl.h>
#include <winsmcrd.h>

#include "ifdtest.h"

#define BYTES_PER_BLOCK 64

void 
GDTestCardEntry(
    class CCardProvider& in_CCardProvider
    );
//
// Create a card provider object
// Note: all global varibales and all functions have to be static
//
static class CCardProvider GDTestCard(GDTestCardEntry);

static ULONG
GDTestCardSetProtocol(
    class CCardProvider& in_CCardProvider,
    class CReader& in_CReader
    )
/*++

Routine Description:
    
    This function will be called after the card has been correctly 
    identified. We should here set the protocol that we need
    for further transmissions

Arguments:

    in_CCardProvider - ref. to our card provider object
    in_CReader - ref. to the reader object

Return Value:

    IFDSTATUS_FAILED - we were unable to set the protocol correctly
    IFDSTATUS_SUCCESS - protocol set correctly

--*/
{
    ULONG l_lResult;

    TestStart("Set protocol to T=0 | T=1");
    l_lResult = in_CReader.SetProtocol(SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1);
    TEST_CHECK_SUCCESS("Set protocol failed", l_lResult);
    TestEnd();

    if (l_lResult != ERROR_SUCCESS) {

        return IFDSTATUS_FAILED;
    }

    return IFDSTATUS_SUCCESS;
}

static 
ULONG
GDTestCardTest(
    class CCardProvider& in_CCardProvider,
    class CReader& in_CReader
    )
/*++

Routine Description:
	    
    This serves as the test function for a particular smart card

Arguments:

    in_CReader - ref. to class that provides all information for the test

Return Value:

    IFDSTATUS value

--*/
{
    ULONG l_lResult, l_uResultLength, l_uBlock, l_uIndex;
    PUCHAR l_pchResult;
    UCHAR l_rgchBuffer[512];
	
	switch (in_CCardProvider.GetTestNo()) {
	
	    case 1: {

            ULONG l_uNumBytes = 256;

            // write some data to the test file using T=0

            TestStart("Cold reset");
            l_lResult = in_CReader.ColdResetCard();
            TEST_CHECK_SUCCESS("Set protocol failed", l_lResult);
            TestEnd();

            ULONG l_uState;
            TestStart("Check reader state");
            l_lResult = in_CReader.GetState(&l_uState);
            TEST_CHECK_SUCCESS(
                "Ioctl IOCTL_SMARTCARD_GET_STATE failed", 
                l_lResult
                );
            TestCheck(
                l_uState == SCARD_NEGOTIABLE,
                "Invalid reader state.\nReturned %d\nExpected %d",
                l_uState,
                SCARD_NEGOTIABLE
                );
            TestEnd();

            TestStart("Set protocol T=0");
            l_lResult = in_CReader.SetProtocol(SCARD_PROTOCOL_T0);
            TEST_CHECK_SUCCESS("Set protocol failed", l_lResult);
            TestEnd();

            // select a file
            TestStart("SELECT FILE EFptsDataCheck");

            l_lResult = in_CReader.Transmit(
                (PUCHAR) "\x00\xa4\x00\x00\x02\x00\x01",
                7,
                &l_pchResult,
                &l_uResultLength
                );

            TestCheck(
                l_lResult, "==", ERROR_SUCCESS,
                l_uResultLength, 2,
                l_pchResult[0], l_pchResult[1], 0x61, 0x09,
                NULL, NULL, 0
                );

            TEST_END();     	

            TestStart("WRITE BINARY %3d bytes", l_uNumBytes);

            for (l_uBlock = 0; l_uBlock < l_uNumBytes; l_uBlock += BYTES_PER_BLOCK) {
             	
                // apdu for write binary
                memcpy(l_rgchBuffer, "\x00\xd6\x00", 3);

                // offset within the file we want to write to
                l_rgchBuffer[3] = (UCHAR) l_uBlock;

                // Append number of bytes 
                l_rgchBuffer[4] = (UCHAR) BYTES_PER_BLOCK;

                // append pattern to buffer;
                for (l_uIndex = 0; l_uIndex < BYTES_PER_BLOCK; l_uIndex++) {

                    l_rgchBuffer[5 + l_uIndex] = (UCHAR) (l_uBlock + l_uIndex);
                }

                l_lResult = in_CReader.Transmit(
                    l_rgchBuffer,
                    5 + BYTES_PER_BLOCK,
                    &l_pchResult,
                    &l_uResultLength
                    );

                TestCheck(
                    l_lResult, "==", ERROR_SUCCESS,
                    l_uResultLength, 2,
                    l_pchResult[0], l_pchResult[1], 0x90, 0x00,
                    NULL, NULL, NULL
                    );
            }

            TEST_END();

            //
            // read the data back using T=1
            //

            TestStart("Cold reset");
            l_lResult = in_CReader.ColdResetCard();
            TEST_CHECK_SUCCESS("Cold reset failed", l_lResult);
            TestEnd();

            TestStart("Set protocol T=1");
            l_lResult = in_CReader.SetProtocol(SCARD_PROTOCOL_T1);
            TEST_CHECK_SUCCESS("Set protocol failed", l_lResult);
            TestEnd();

            // select a file
            TestStart("SELECT FILE EFptsDataCheck");

            l_lResult = in_CReader.Transmit(
                (PUCHAR) "\x00\xa4\x00\x00\x02\x00\x01",
                7,
                &l_pchResult,
                &l_uResultLength
                );

            TestCheck(
                l_lResult, "==", ERROR_SUCCESS,
                l_uResultLength, 11,
                l_pchResult[9], l_pchResult[10], 0x90, 0x00,
                NULL, NULL, NULL
                );

            TEST_END();     	

            TestStart("READ BINARY %3d Byte(s)", l_uNumBytes);

            for (l_uBlock = 0; l_uBlock < l_uNumBytes; l_uBlock += BYTES_PER_BLOCK) {
             	
                // apdu for read binary 
                memcpy(l_rgchBuffer, "\x00\xb0\x00", 3);

                // offset within the file we want to read from
                l_rgchBuffer[3] = (UCHAR) l_uBlock;

                // Append number of bytes (note: the buffer contains the pattern already)
                l_rgchBuffer[4] = (UCHAR) BYTES_PER_BLOCK;

                l_lResult = in_CReader.Transmit(
                    l_rgchBuffer,
                    5,
                    &l_pchResult,
                    &l_uResultLength
                    );

                // append pattern to buffer;
                for (l_uIndex = 0; l_uIndex < BYTES_PER_BLOCK; l_uIndex++) {

                    l_rgchBuffer[l_uIndex] = (UCHAR) (l_uBlock + l_uIndex);
                }

                TestCheck(
                    l_lResult, "==", ERROR_SUCCESS,
                    l_uResultLength, (l_uNumBytes / 4) + 2,
                    l_pchResult[BYTES_PER_BLOCK], l_pchResult[BYTES_PER_BLOCK + 1], 0x90, 0x00,
                    l_pchResult, l_rgchBuffer, BYTES_PER_BLOCK
                    );
            }
		    
            TEST_END();
            return IFDSTATUS_END;
        }

	    default:
		    return IFDSTATUS_FAILED;

	}    
    return IFDSTATUS_SUCCESS;
}    

static void
GDTestCardEntry(
    class CCardProvider& in_CCardProvider
    )
/*++

Routine Description:
    
    This function registers all callbacks from the test suite
	
Arguments:

    CCardProvider - ref. to card provider class

Return Value:

    -

--*/
{
    // Set protocol callback
    in_CCardProvider.SetProtocol(GDTestCardSetProtocol);

    // Card test callback
    in_CCardProvider.SetCardTest(GDTestCardTest);

    // Name of our card
    in_CCardProvider.SetCardName("G & D");

    // ATR of our card
    in_CCardProvider.SetAtr((PBYTE) "\x3B\xBF\x18\x00\xC0\x20\x31\x70\x52\x53\x54\x41\x52\x43\x4F\x53\x20\x53\x32\x31\x20\x43\x90\x00\x9C", 25);
    in_CCardProvider.SetAtr((PBYTE) "\x3b\xbf\x18\x00\x80\x31\x70\x35\x53\x54\x41\x52\x43\x4f\x53\x20\x53\x32\x31\x20\x43\x90\x00\x9b", 24);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\ifdtest\bull.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    example.cpp

Abstract:

    This is a plug-in for the smart card driver test suite.
    This plug-in is smart card dependent

Author:

    Klaus U. Schutz

Environment:

    Win32 application

Revision History :

    Nov. 1997 - initial version

--*/

#include <stdarg.h> 
#include <stdio.h>
#include <string.h>

#include <afx.h>
#include <afxtempl.h>

#include <winioctl.h>
#include "winsmcrd.h"

#include "ifdtest.h"

void MyCardEntry(class CCardProvider& in_CCardProvider);

//
// Create a card provider object
// Note: all global varibales and all functions have to be static
//
static class CCardProvider MyCard(MyCardEntry);
                                                                                          
static ULONG
MyCardSetProtocol(
    class CCardProvider& in_CCardProvider,
    class CReader& in_CReader
    )
/*++

Routine Description:
    
    This function will be called after the card has been correctly 
    identified. We should here set the protocol that we need
    for further transmissions

Arguments:

    in_CCardProvider - ref. to our card provider object
    in_CReader - ref. to the reader object

Return Value:

    IFDSTATUS_FAILED - we were unable to set the protocol correctly
    IFDSTATUS_SUCCESS - protocol set correctly

--*/
{
    ULONG l_lResult;

    TestStart("Try to set incorrect protocol T=1");
    l_lResult = in_CReader.SetProtocol(SCARD_PROTOCOL_T1);

    // The test MUST fail with the incorrect protocol
    TEST_CHECK_NOT_SUPPORTED("Set protocol failed", l_lResult);
    TestEnd();

    // Now set the correct protocol
    TestStart("Set protocol T=0");
    l_lResult = in_CReader.SetProtocol(SCARD_PROTOCOL_T0);
    TEST_CHECK_SUCCESS("Set protocol failed", l_lResult);
    TestEnd();

    if (l_lResult != ERROR_SUCCESS) {

        return IFDSTATUS_FAILED;
    }

    return IFDSTATUS_SUCCESS;
}

static ULONG
MyCardTest(
    class CCardProvider& in_CCardProvider,
    class CReader& in_CReader
    )
/*++

Routine Description:
	    
    This serves as the test function for a particular smart card

Arguments:

    in_CReader - ref. to class that provides all information for the test

Return Value:

    IFDSTATUS value

--*/
{

	ULONG l_auNumBytes[] = { 1 , 25, 50, 75, 100, 125, 150, 175, 200, 225, 254 };
    
     
    ULONG l_uNumBytes = l_auNumBytes[10];
    
	ULONG l_lResult;
    ULONG l_uResultLength, l_uIndex;
    PUCHAR l_pchResult;
    UCHAR l_rgchBuffer[512];
	ULONG l_uTest;
	UCHAR Buf_Tempo[9];
	ULONG l_Tempo;
	ULONG Adresse;

    switch (in_CCardProvider.GetTestNo()) {

        case 1:
            TestStart("Buffer boundary test");

            //
            // Check if the reader correctly determines that
            // our receive buffer is too small
            //
            in_CReader.SetReplyBufferSize(9);
            l_lResult = in_CReader.Transmit(
                (PUCHAR) "\xBC\x84\x00\x00\x08",
                5,
                &l_pchResult,
                &l_uResultLength
                );

            TestCheck(
                l_lResult == ERROR_INSUFFICIENT_BUFFER,
                "Transmit should fail due to too small buffer"
                );

            TestEnd();

            in_CReader.SetReplyBufferSize(2048);
        	break;

	    case 2:			
			TestStart("3 byte APDU");

			l_lResult = in_CReader.Transmit(
				(PUCHAR) "\xBC\xC4\x00",
				3,										
				&l_pchResult,
				&l_uResultLength
				);

            TestCheck(
                l_lResult, "==", ERROR_INVALID_PARAMETER,
                0, 0,
                0, 0, 0, 0,
                NULL, NULL, NULL
                );

            TEST_END();
			break;

	    case 3:			
			// Get Challenge
			TestStart("GET CHALLENGE");

			l_lResult = in_CReader.Transmit(
				(PUCHAR) "\xBC\xC4\x00\x00\x08",
				5,										
				&l_pchResult,
				&l_uResultLength
				);

            TestCheck(
                l_lResult, "==", ERROR_SUCCESS,
                l_uResultLength, 10,
                l_pchResult[8], l_pchResult[9], 0x90, 0x00,
                NULL, NULL, NULL
                );

            TEST_END();

            //
			// Submit Alternate Identification Code (AID)
	        //
			TestStart("VERIFY PIN");

			l_lResult = in_CReader.Transmit(
				(PUCHAR) "\xBC\x38\x00\x00\x0A\x01\x02\x03\x04\x05\x06\x07\x08\x09\0x0A",
				15,
				&l_pchResult,
				&l_uResultLength
				); 
			
            TestCheck(
                l_lResult, "==", ERROR_SUCCESS,
                l_uResultLength, 2,
                l_pchResult[0], l_pchResult[1], 0x90, 0x08,
                NULL, NULL, NULL
                );

            TEST_END();
			break;

	    case 4:
			// Translate of 4 byte APDU (Search for next blank word)
			TestStart("SEARCH BLANK WORD");

			l_lResult = in_CReader.Transmit(
				(PUCHAR) "\xBC\xA0\x00\x00",		// Search for next blank word
				4,
				&l_pchResult,
				&l_uResultLength
				);
		
            TestCheck(
                l_lResult, "==", ERROR_SUCCESS,
                l_uResultLength, 2,
                l_pchResult[0], l_pchResult[1], 0x90, 0x00,
                NULL, NULL, NULL
                );

            TEST_END();

			// Read result of Search for next blank word
			TestStart("GET RESPONSE");

			l_lResult = in_CReader.Transmit(
				(PUCHAR) "\xBC\xC0\x00\x00\x08",		// Read Result command 
				5,										
				&l_pchResult,
				&l_uResultLength
				);
		
            TestCheck(
                l_lResult, "==", ERROR_SUCCESS,
                l_uResultLength, 10,
                l_pchResult[8], l_pchResult[9], 0x90, 0x00,
                NULL, NULL, NULL
                );

            TEST_END();
			break;

    	case 5:	
			// Select Working File 2F01
			TestStart("Lc byte incorrect");

			l_lResult = in_CReader.Transmit(
                (PUCHAR) "\xBC\xA4\x00\x00\x02\x2F",
				6,
                &l_pchResult,
                &l_uResultLength
                ); 

            TestCheck(
                l_lResult, "==", ERROR_INVALID_PARAMETER,
                0, 0, 
                0, 0, 0, 0,
                NULL, NULL, NULL
                );

            TEST_END();
            break;

    	case 6:	
            //
			// Select Working File 2F01
            //
			TestStart("SELECT FILE");

			l_lResult = in_CReader.Transmit(
                (PUCHAR) "\xBC\xA4\x00\x00\x02\x2F\x01",
				7,
                &l_pchResult,
                &l_uResultLength
                ); 

            TestCheck(
                l_lResult, "==", ERROR_SUCCESS,
                l_uResultLength, 2,
                l_pchResult[0], l_pchResult[1], 0x90, 0x00,
                NULL, NULL, NULL
                );

            TEST_END();
			
			// Erase memory with restart of work waiting time
			TestStart("ERASE BINARY");

			l_lResult = in_CReader.Transmit(
                (PUCHAR) "\xBC\x0E\x00\x00\x02\x00\x78",
				7,
                &l_pchResult,
                &l_uResultLength
                ); 

            TestCheck(
                l_lResult, "==", ERROR_SUCCESS,
                l_uResultLength, 2,
                l_pchResult[0], l_pchResult[1], 0x90, 0x00,
                NULL, NULL, NULL
                );

            TEST_END();
			
            // Generate a 'test' pattern which will be written to the card
            for (l_uIndex = 0; l_uIndex < 256; l_uIndex++) {

                l_rgchBuffer[l_uIndex] = (UCHAR) l_uIndex;             	
            }
			
            // Tpdu for write binary. TB100L can write only 4 byte 4 byte
            memcpy(Buf_Tempo, "\xBC\xD0", 2);	// writting order
			Buf_Tempo[4] = 0x4;					//write 4 bytes in the card
			
            // This is the amount of bytes we write to the card 
            l_uTest = 0;
			Adresse = 0;

			while (l_uTest < 256) {
				
				for(l_Tempo=5 ; l_Tempo < 9; l_Tempo++){

					 Buf_Tempo[l_Tempo] = l_rgchBuffer[l_uTest++];
					 
				 }
					
				 Buf_Tempo[2] = 00;				// Writting address
				 Buf_Tempo[3] = (UCHAR) Adresse++;
			 
			    //
                // Write 
                //
       			TestStart("WRITE BINARY - 4 bytes (%03d)",Adresse);
                            
                //
                // Append number of bytes (note: the buffer contains the pattern already)
                //
                l_lResult = in_CReader.Transmit(
                    Buf_Tempo,
                    9,
                    &l_pchResult,
                    &l_uResultLength
                    );

                TestCheck(
                    l_lResult, "==", ERROR_SUCCESS,
                    l_uResultLength, 2,
                    l_pchResult[0], l_pchResult[1], 0x90, 0x00,
                    NULL, NULL, NULL
                    );

                TEST_END();
			}
				
			// Read 256 bytes 
			TestStart("READ BINARY - 256 bytes");

			l_lResult = in_CReader.Transmit(
                (PUCHAR) "\xBC\xB0\x00\x00\x00",
				5,
                &l_pchResult,
                &l_uResultLength
                );
			
            TestCheck(
                l_lResult, "==", ERROR_SUCCESS,
                l_uResultLength, l_uNumBytes + 4,
                l_pchResult[256], l_pchResult[257], 0x90, 0x00,
                l_pchResult, l_rgchBuffer , l_uNumBytes + 2
                );

            TEST_END();
			break;

	    case 7:
            //
			// Command with Slave Mode
			// Data bytes transferred subsequently (INS')
            //
	
			TestStart("GENERATE TEMP KEY");

			l_lResult = in_CReader.Transmit(
                (PUCHAR) "\xBC\x80\x00\x00\x02\x12\x00",
				7,
                &l_pchResult,
                &l_uResultLength
                ); 
			
            TestCheck(
                l_lResult, "==", ERROR_SUCCESS,
                l_uResultLength, 2,
                l_pchResult[0], l_pchResult[1], 0x90, 0x08,
                NULL, NULL, NULL
                );

            TEST_END();
			break;

	    case 8:
	        // Select Master File 3F00
			TestStart("SELECT FILE");

			l_lResult = in_CReader.Transmit(
                (PUCHAR) "\xBC\xA4\x00\x00\x02\x3F\x00",
				7,
                &l_pchResult,
                &l_uResultLength
                ); 
			
            TestCheck(
                l_lResult, "==", ERROR_SUCCESS,
                l_uResultLength, 2,
                l_pchResult[0], l_pchResult[1], 0x90, 0x00,
                NULL, NULL, NULL
                );

            TEST_END();
			
			// Erase memory on an invalid file => mute card
			TestStart("ERASE BINARY");

			l_lResult = in_CReader.Transmit(
                (PUCHAR) "\xBC\x0E\x00\x00\x02\x00\x78",
				7,
                &l_pchResult,
                &l_uResultLength
                ); 
			
            TestCheck(
                l_lResult, "==", ERROR_SEM_TIMEOUT,
                NULL, NULL, 
                NULL, NULL, 
                NULL, NULL, 
                NULL, NULL, NULL
                );

            TEST_END();
            return IFDSTATUS_END;
	
	    default:
            return IFDSTATUS_FAILED;        
    }
    
    return IFDSTATUS_SUCCESS;
}    

static void
MyCardEntry(
    class CCardProvider& in_CCardProvider
    )
/*++

Routine Description: 
    
    This function registers all callbacks from the test suite
	
Arguments:

    CCardProvider - ref. to card provider class

Return Value:

    -

--*/
{
    // Set protocol callback
    in_CCardProvider.SetProtocol(MyCardSetProtocol);

    // Card test callback
    in_CCardProvider.SetCardTest(MyCardTest);

    // Name of our card
    in_CCardProvider.SetCardName("Bull");

    // Maximum number of tests
    in_CCardProvider.SetAtr((PBYTE) "\x3f\x67\x25\x00\x21\x20\x00\x0F\x68\x90\x00", 11);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\ifdtest\ibm.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ibm.cpp
//
//--------------------------------------------------------------------------

/*++

Module Name:

    ibmmfc41.cpp

Abstract:

    This is a plug-in for the smart card driver test suite.
    This plug-in is smart card dependent

Environment:

    Win32 application

Revision History :

    Jan 1998 - initial version

--*/

#include <stdarg.h> 
#include <stdio.h>
#include <string.h>

#include <afx.h>
#include <afxtempl.h>

#include <winioctl.h>
#include <winsmcrd.h>

#include "ifdtest.h"

void MyCardEntry(class CCardProvider& in_CCardProvider);

//
// Create a card provider object
// Note: all global varibales and all functions have to be static
//
static class CCardProvider MyCard(MyCardEntry);
                                                  
                                          
static ULONG
MyCardSetProtocol(
    class CCardProvider& in_CCardProvider,
    class CReader& in_CReader
    )
/*++

Routine Description:
    
    This function will be called after the card has been correctly 
    identified. We should here set the protocol that we need
    for further transmissions

Arguments:

    in_CCardProvider - ref. to our card provider object
    in_CReader - ref. to the reader object

Return Value:

    IFDSTATUS_FAILED - we were unable to set the protocol correctly
    IFDSTATUS_SUCCESS - protocol set correctly

--*/
{
    ULONG l_lResult;

    TestStart("Try to set incorrect protocol T=0");
    l_lResult = in_CReader.SetProtocol(SCARD_PROTOCOL_T0);

    // The test MUST fail with the incorrect protocol
    TEST_CHECK_NOT_SUPPORTED("Set protocol failed", l_lResult);
    TestEnd();

    // Now set the correct protocol
    TestStart("Set protocol T=1");
    l_lResult = in_CReader.SetProtocol(SCARD_PROTOCOL_T1);
    TEST_CHECK_SUCCESS("Set protocol failed", l_lResult);
    TestEnd();

    if (l_lResult != ERROR_SUCCESS) {

        return IFDSTATUS_FAILED;
    }

    return IFDSTATUS_SUCCESS;
}

static ULONG
MyCardTest(
    class CCardProvider& in_CCardProvider,
    class CReader& in_CReader
    )
/*++

Routine Description:
	    
    This serves as the test function for a particular smart card

Arguments:

    in_CReader - ref. to class that provides all information for the test

Return Value:

    IFDSTATUS value

--*/
{
    ULONG l_lResult;
    ULONG l_uResultLength, l_uExpectedLength, l_uIndex;
    PUCHAR l_pchResult;
    UCHAR l_rgchBuffer[512], l_rgchBuffer2[512];

    switch (in_CCardProvider.GetTestNo()) {

	    case 1: {
            //
            // select a file 0007 and write data pattern 0 to N-1 to the card. 
			// Then read the data back and verify correctness. 
            // Check IFSC and IFSD above card limits
            //

            //
            // Select a file
            //
            TestStart("SELECT FILE 0007");

            l_lResult = in_CReader.Transmit(
                (PUCHAR) "\xa4\xa4\x00\x00\x02\x00\x07",
                7,
                &l_pchResult,
                &l_uResultLength
                );

            TestCheck(
                l_lResult, "==", ERROR_SUCCESS,
                l_uResultLength, 16,
                l_pchResult[14], l_pchResult[15], 0x90, 0x00,
                l_pchResult, 
                (PUCHAR) "\x63\x0c\x03\xe8\x00\x07\x00\x00\x00\xff\xff\x11\x01\x00\x90\x00", 
                l_uResultLength
                );

            TEST_END();

            if (TestFailed()) {
                
				return IFDSTATUS_FAILED;
            }

            //
            // Do a couple of writes and reads up to maximum size
			// Check behaviour above IFSC and IFSD Limits
            //

            //
            // Generate a 'test' pattern which will be written to the card
            //
            for (l_uIndex = 0; l_uIndex < 254; l_uIndex++) {

                l_rgchBuffer[5 + l_uIndex] = (UCHAR) l_uIndex;             	
            }

            //
            // This is the amount of bytes we write to the card in each loop
            //
            ULONG l_auNumBytes[] = { 1 , 25, 50, 75, 100, 125, 128, 150, 175, 200, 225, 250, 254 };
    
            time_t l_TimeStart;
			time(&l_TimeStart); 

            for (ULONG l_uTest = 0; l_uTest < sizeof(l_auNumBytes) / sizeof(l_auNumBytes[0]); l_uTest++) {

                ULONG l_uNumBytes = l_auNumBytes[l_uTest];
             	
                //
                // Write 
                //
                TestStart("WRITE BINARY %3d Byte(s)", l_uNumBytes);
                            
                //
                // Tpdu for write binary
                //
                memcpy(l_rgchBuffer, "\xa4\xd6\x00\x00", 4);

                //
                // Append number of bytes (note: the buffer contains the pattern already)
                //
                l_rgchBuffer[4] = (UCHAR) l_uNumBytes;

                l_lResult = in_CReader.Transmit(
                    l_rgchBuffer,
                    5 + l_uNumBytes,
                    &l_pchResult,
                    &l_uResultLength
                    );

				if (l_uNumBytes <= 128) {

                    TestCheck(
                        l_lResult, "==", ERROR_SUCCESS,
                        l_uResultLength, 2,
                        l_pchResult[0], l_pchResult[1], 0x90, 0x00,
                        NULL, NULL, NULL
                        );

                } else {
                 	
                    TestCheck(
                        l_lResult, "==", ERROR_SUCCESS,
                        l_uResultLength, 2,
                        l_pchResult[0], l_pchResult[1], 0x67, 0x00,
                        NULL, NULL, NULL
                        );
                }

                TEST_END();

                //
                // Read
                //
                TestStart("READ  BINARY %3d Byte(s)", l_uNumBytes);

                //
                // tpdu for read binary
                //
                memcpy(l_rgchBuffer, "\xa4\xB0\x00\x00", 4);

                //
                // Append number of bytes
                //
                l_rgchBuffer[4] = (UCHAR) l_uNumBytes;

                l_lResult = in_CReader.Transmit(
                    l_rgchBuffer,
                    5,
                    &l_pchResult,
                    &l_uResultLength
                    );

                //
                // check if the right number of bytes has been returned
                //
				l_uExpectedLength = min(128, l_uNumBytes);

                TestCheck(
                    l_lResult, "==", ERROR_SUCCESS,
                    l_uResultLength, l_uExpectedLength + 2,
                    l_pchResult[l_uExpectedLength], 
                    l_pchResult[l_uExpectedLength + 1], 
                    0x90, 0x00,
                    l_pchResult, l_rgchBuffer + 5, l_uExpectedLength
                    );

                TEST_END();
            }

            time_t l_TimeEnd;
            time(&l_TimeEnd); 
            CTime l_CTimeStart(l_TimeStart);
            CTime l_CTimeEnd(l_TimeEnd);
            CTimeSpan l_CTimeElapsed = l_CTimeEnd - l_CTimeStart;
            if (l_CTimeElapsed.GetTotalSeconds() < 10) {

                LogMessage(
                    "Reader performance is good (%u sec)", 
                    l_CTimeElapsed.GetTotalSeconds()
                    );
             	
            } else if (l_CTimeElapsed.GetTotalSeconds() < 30) {

                LogMessage(
                    "Reader performance is average (%u sec)", 
                    l_CTimeElapsed.GetTotalSeconds()
                    );
             	
            } else {

                LogMessage(
                    "Reader performance is bad (%u sec)", 
                    l_CTimeElapsed.GetTotalSeconds()
                    );
            }
            break;
		}

		case 2: {
            //
            // Select a file 0007 and write alternately pattern 55 and AA 
			// to the card. 
			// Read the data back and verify correctness after each write. 
            //
            //
            // Select a file
            //
            TestStart("SELECT FILE 0007");

            l_lResult = in_CReader.Transmit(
                (PUCHAR) "\xa4\xa4\x00\x00\x02\x00\x07",
                7,
                &l_pchResult,
                &l_uResultLength
                );

            TestCheck(
                l_lResult, "==", ERROR_SUCCESS,
                l_uResultLength, 16,
                l_pchResult[14], l_pchResult[15], 0x90, 0x00,
                l_pchResult, 
                (PUCHAR) "\x63\x0c\x03\xe8\x00\x07\x00\x00\x00\xff\xff\x11\x01\x00\x90\x00", 
                l_uResultLength
                );

            TEST_END();
            //
            // Do a couple of writes and reads alternately 
			// with patterns 55h and AAh 
            //

            //
            // Generate a 'test' pattern which will be written to the card
            //
            for (l_uIndex = 0; l_uIndex < 254; l_uIndex++) {

                l_rgchBuffer[5 + l_uIndex] = (UCHAR)  0x55;    
				l_rgchBuffer2[5 + l_uIndex] = (UCHAR) 0xAA;  
            }

            //
            // This is the amount of bytes we write to the card in each loop
            //
            ULONG l_uNumBytes = 128; 

            for (ULONG l_uTest = 0; l_uTest < 2; l_uTest++) {

             	
                //
                // Write 
                //
                TestStart("WRITE BINARY %3d Byte(s) Pattern 55h", l_uNumBytes);
                            
                //
                // Tpdu for write binary
                //
                memcpy(l_rgchBuffer, "\xa4\xd6\x00\x00", 4);

                //
                // Append number of bytes (note: the buffer contains the pattern already)
                //
                l_rgchBuffer[4] = (UCHAR) l_uNumBytes;

                l_lResult = in_CReader.Transmit(
                    l_rgchBuffer,
                    5 + l_uNumBytes,
                    &l_pchResult,
                    &l_uResultLength
                    );

                TestCheck(
                    l_lResult, "==", ERROR_SUCCESS,
                    l_uResultLength, 2,
                    l_pchResult[0], l_pchResult[1], 0x90, 0x00,
                    NULL, NULL, NULL
                    );

                TEST_END();

                //
                // Read
                //
                TestStart("READ  BINARY %3d Byte(s) Pattern 55h", l_uNumBytes);

                //
                // tpdu for read binary
                //
                memcpy(l_rgchBuffer, "\xa4\xB0\x00\x00", 4);

                //
                // Append number of bytes
                //
                l_rgchBuffer[4] = (UCHAR) l_uNumBytes;

                l_lResult = in_CReader.Transmit(
                    l_rgchBuffer,
                    5,
                    &l_pchResult,
                    &l_uResultLength
                    );

				l_uExpectedLength = min(128, l_uNumBytes);

                TestCheck(
                    l_lResult, "==", ERROR_SUCCESS,
                    l_uResultLength, l_uExpectedLength + 2,
                    l_pchResult[l_uNumBytes], l_pchResult[l_uNumBytes + 1], 
                    0x90, 0x00,
                    l_pchResult, l_rgchBuffer + 5, l_uExpectedLength
                    );

                TEST_END();

				//
                // Write 
                //
                TestStart("WRITE BINARY %3d Byte(s) Pattern AAh", l_uNumBytes);
                            
                //
                // Tpdu for write binary
                //
                memcpy(l_rgchBuffer2, "\xa4\xd6\x00\x00", 4);

                //
                // Append number of bytes (note: the buffer contains the pattern already)
                //
                l_rgchBuffer2[4] = (UCHAR) l_uNumBytes;

                l_lResult = in_CReader.Transmit(
                    l_rgchBuffer2,
                    5 + l_uNumBytes,
                    &l_pchResult,
                    &l_uResultLength
                    );

                TestCheck(
                    l_lResult, "==", ERROR_SUCCESS,
                    l_uResultLength, 2,
                    l_pchResult[0], l_pchResult[1], 
                    0x90, 0x00,
                    NULL, NULL, NULL
                    );

                TEST_END();

                //
                // Read
                //
                TestStart("READ  BINARY %3d Byte(s) Pattern AAh", l_uNumBytes);

                //
                // tpdu for read binary
                //
                memcpy(l_rgchBuffer2, "\xa4\xB0\x00\x00", 4);

                //
                // Append number of bytes
                //
                l_rgchBuffer2[4] = (UCHAR) l_uNumBytes;

                l_lResult = in_CReader.Transmit(
                    l_rgchBuffer2,
                    5,
                    &l_pchResult,
                    &l_uResultLength
                    );

				l_uExpectedLength = min(128, l_uNumBytes);

                TestCheck(
                    l_lResult, "==", ERROR_SUCCESS,
                    l_uResultLength, l_uExpectedLength + 2,
                    l_pchResult[l_uNumBytes], l_pchResult[l_uNumBytes + 1], 
                    0x90, 0x00,
                    l_pchResult, l_rgchBuffer2 + 5, min(l_uExpectedLength,125)
                    );

                TEST_END();
            }

        	break;         	
		}

		case 3: {
            
            // select a file 0007 and write alternately pattern 00 and FF 
			// to the card. 
			// Read the data back and verify correctness after each write. 


            //
            // Select a file
            //
            TestStart("SELECT FILE 0007");

            l_lResult = in_CReader.Transmit(
                (PUCHAR) "\xa4\xa4\x00\x00\x02\x00\x07",
                7,
                &l_pchResult,
                &l_uResultLength
                );

            TestCheck(
                l_lResult, "==", ERROR_SUCCESS,
                l_uResultLength, 16,
                l_pchResult[14], l_pchResult[15], 0x90, 0x00,
                l_pchResult, 
                (PUCHAR) "\x63\x0c\x03\xe8\x00\x07\x00\x00\x00\xff\xff\x11\x01\x00\x90\x00", 
                l_uResultLength
                );

            TEST_END();

            //
            // Do a couple of writes and reads alternately 
			// with patterns 00h and FFh 
            //

            //
            // Generate a 'test' pattern which will be written to the card
            //
            for (l_uIndex = 0; l_uIndex < 254; l_uIndex++) {

                l_rgchBuffer[5 + l_uIndex] = (UCHAR)  0x00;    
				l_rgchBuffer2[5 + l_uIndex] = (UCHAR) 0xFF;  
            }

            //
            // This is the amount of bytes we write to the card in each loop
            //
            ULONG l_uNumBytes = 128; 

            for (ULONG l_uTest = 0; l_uTest < 2; l_uTest++) {

             	
                //
                // Write 
                //
                TestStart("WRITE BINARY %3d Byte(s) Pattern 00h", l_uNumBytes);
                            
                //
                // Tpdu for write binary
                //
                memcpy(l_rgchBuffer, "\xa4\xd6\x00\x00", 4);

                //
                // Append number of bytes (note: the buffer contains the pattern already)
                //
                l_rgchBuffer[4] = (UCHAR) l_uNumBytes;

                l_lResult = in_CReader.Transmit(
                    l_rgchBuffer,
                    5 + l_uNumBytes,
                    &l_pchResult,
                    &l_uResultLength
                    );

                TestCheck(
                    l_lResult, "==", ERROR_SUCCESS,
                    l_uResultLength, 2,
                    l_pchResult[0], l_pchResult[1], 0x90, 0x00,
                    NULL, NULL, NULL
                    );

                TEST_END();

                //
                // Read
                //
                TestStart("READ  BINARY %3d Byte(s) Pattern 00h", l_uNumBytes);

                //
                // tpdu for read binary
                //
                memcpy(l_rgchBuffer, "\xa4\xB0\x00\x00", 4);

                //
                // Append number of bytes
                //
                l_rgchBuffer[4] = (UCHAR) l_uNumBytes;

                l_lResult = in_CReader.Transmit(
                    l_rgchBuffer,
                    5,
                    &l_pchResult,
                    &l_uResultLength
                    );

				l_uExpectedLength = min(128, l_uNumBytes);

                TestCheck(
                    l_lResult, "==", ERROR_SUCCESS,
                    l_uResultLength, l_uExpectedLength + 2,
                    l_pchResult[l_uNumBytes], l_pchResult[l_uNumBytes + 1], 
                    0x90, 0x00,
                    l_pchResult, 
                    l_rgchBuffer + 5, 
                    l_uExpectedLength
                    );

                TEST_END();

				//
                // Write 
                //
                TestStart("WRITE BINARY %3d Byte(s) Pattern FFh", l_uNumBytes);
                            
                //
                // Tpdu for write binary
                //
                memcpy(l_rgchBuffer2, "\xa4\xd6\x00\x00", 4);

                //
                // Append number of bytes (note: the buffer contains the pattern already)
                //
                l_rgchBuffer2[4] = (UCHAR) l_uNumBytes;

                l_lResult = in_CReader.Transmit(
                    l_rgchBuffer2,
                    5 + l_uNumBytes,
                    &l_pchResult,
                    &l_uResultLength
                    );

                TestCheck(
                    l_lResult, "==", ERROR_SUCCESS,
                    l_uResultLength, 2,
                    l_pchResult[0], l_pchResult[1], 
                    0x90, 0x00,
                    NULL, NULL, NULL
                    );

                TEST_END();

                //
                // Read
                //
                TestStart("READ  BINARY %3d Byte(s) Pattern FFh", l_uNumBytes);

                //
                // tpdu for read binary
                //
                memcpy(l_rgchBuffer2, "\xa4\xB0\x00\x00", 4);

                //
                // Append number of bytes
                //
                l_rgchBuffer2[4] = (UCHAR) l_uNumBytes;

                l_lResult = in_CReader.Transmit(
                    l_rgchBuffer2,
                    5,
                    &l_pchResult,
                    &l_uResultLength
                    );

				l_uExpectedLength = min(128, l_uNumBytes);

                TestCheck(
                    l_lResult, "==", ERROR_SUCCESS,
                    l_uResultLength, l_uExpectedLength + 2,
                    l_pchResult[l_uNumBytes], l_pchResult[l_uNumBytes + 1], 
                    0x90, 0x00,
                    l_pchResult, 
                    l_rgchBuffer2 + 5, 
                    min(l_uExpectedLength,125)
                    );

                TEST_END();
            }
        	break;         	
		}

		case 4: {
			//
			// Select Command for Nonexisting File
			//

            TestStart("SELECT NONEXISTING FILE");

            l_lResult = in_CReader.Transmit(
                (PUCHAR) "\xa4\xa4\x00\x00\x02\x77\x77",
                7,
                &l_pchResult,
                &l_uResultLength
                );

            TestCheck(
                l_lResult, "==", ERROR_SUCCESS,
                l_uResultLength, 2,
                l_pchResult[0], l_pchResult[1], 
                0x94, 0x04,
                NULL, NULL, NULL
                );

            TEST_END();
			break;
		}

		case 5: {
			//
			// Select Command without Fileid
			//
			TestStart("SELECT COMMAND WITHOUT FILEID");

            l_lResult = in_CReader.Transmit(
                (PUCHAR) "\xa4\xa4\x00\x00",
                4,
                &l_pchResult,
                &l_uResultLength
                );

            TestCheck(
                l_lResult, "==", ERROR_SUCCESS,
                l_uResultLength, 2,
                l_pchResult[0], l_pchResult[1], 
                0x67, 0x00,
                NULL, NULL, NULL
                );

            TEST_END();
			break;
		}

		case 6: {
			//
			// Select Command with path too short
			//
			
           TestStart("SELECT COMMAND PATH WITH PATH TOO SHORT");

            l_lResult = in_CReader.Transmit(
                (PUCHAR) "\xa4\xa4\x00\x00\x01\x77",
                6,
                &l_pchResult,
                &l_uResultLength
                );

            TestCheck(
                l_lResult, "==", ERROR_SUCCESS,
                l_uResultLength, 2,
                l_pchResult[0], l_pchResult[1], 
                0x67, 0x00,
                NULL, NULL, NULL
                );

            TEST_END();
			break;
		}

		case 7: {
			//
			// Select Command with wrong Lc
			//
			
           TestStart("SELECT COMMAND PATH WITH WRONG LC");

            l_lResult = in_CReader.Transmit(
                (PUCHAR) "\xa4\xa4\x00\x00\x08\x00",
                6,
                &l_pchResult,
                &l_uResultLength
                );

            TestCheck(
                l_lResult, "==", ERROR_SUCCESS,
                l_uResultLength, 2,
                l_pchResult[0], l_pchResult[1], 
                0x67, 0x00,
                NULL, NULL, NULL
                );

            TEST_END();
			break;
		}

		case 8: {
			//
			// Select Command too short
			//

           TestStart("SELECT COMMAND TOO SHORT");

            l_lResult = in_CReader.Transmit(
                (PUCHAR) "\xa4\xa4\x00",
                3,
                &l_pchResult,
                &l_uResultLength
                );

            TestCheck(
                l_lResult, "==", ERROR_SUCCESS,
                l_uResultLength, 2,
                l_pchResult[0], l_pchResult[1], 
                0x6f, 0x00,
                NULL, NULL, NULL
                );

            TEST_END();
			break;
		}

		case 9: {
			//
			// Select Command with invalid P2
			//

           TestStart("SELECT COMMAND WITH INVALID P2");

            l_lResult = in_CReader.Transmit(
                (PUCHAR) "\xa4\xa4\x00\x02\x02\x00\x07",
                7,
                &l_pchResult,
                &l_uResultLength
                );

            TestCheck(
                l_lResult, "==", ERROR_SUCCESS,
                l_uResultLength, 2,
                l_pchResult[0], l_pchResult[1], 
                0x6b, 0x00,
                NULL, NULL, NULL
                );

            TEST_END();
			break;
		}

		case 10: {
			//
			// Select command without fileid but with Le
			//
			
			TestStart("SELECT COMMAND WITHOUT FILEID BUT WITH Le");

            l_lResult = in_CReader.Transmit(
                (PUCHAR) "\xa4\xa4\x00\x00\x00",
                5,
                &l_pchResult,
                &l_uResultLength
                );

            TestCheck(
                l_lResult, "==", ERROR_SUCCESS,
                l_uResultLength, 2,
                l_pchResult[0], l_pchResult[1], 
                0x67, 0x00,
                NULL, NULL, NULL
                );

            TEST_END();
			break;
		}

		case 11: {
			//
			// Use Change Speed command to simulate unresponsive card
			//

            //
            // Select a file
            //
            TestStart("SELECT FILE 0007");

            l_lResult = in_CReader.Transmit(
                (PUCHAR) "\xa4\xa4\x00\x00\x02\x00\x07",
                7,
                &l_pchResult,
                &l_uResultLength
                );

            TestCheck(
                l_lResult, "==", ERROR_SUCCESS,
                l_uResultLength, 16,
                l_pchResult[14], l_pchResult[15], 0x90, 0x00,
                l_pchResult, 
                (PUCHAR) "\x63\x0c\x03\xe8\x00\x07\x00\x00\x00\xff\xff\x11\x01\x00\x90\x00", 
                l_uResultLength
                );

            TEST_END();

			//
			// Perform change speed command to simulate unresponsive card 
			//
            TestStart("CHANGE SPEED");

            l_lResult = in_CReader.Transmit(
                (PUCHAR) "\xb6\x42\x00\x40",
                4,
                &l_pchResult,
                &l_uResultLength
                );

            TestCheck(
                l_lResult, "==", ERROR_SUCCESS,
                l_uResultLength, 2,
                l_pchResult[0], l_pchResult[1], 
                0x90, 0x00,
                NULL, NULL, NULL
                );

            TEST_END();

            //
            // Select a file to verify bad return code
            //
            TestStart("SELECT FILE 0007 WILL GET NO VALID RESPONSE");

            l_lResult = in_CReader.Transmit(
                (PUCHAR) "\xa4\xa4\x00\x00\x02\x00\x07",
                7,
                &l_pchResult,
                &l_uResultLength
                );

            TestCheck(
                l_lResult, "!=", ERROR_SUCCESS,
                NULL, NULL,
                NULL, NULL,
                NULL, NULL,
                NULL, NULL, NULL
                );

            TEST_END();
            return IFDSTATUS_END;
		}

        default:
            return IFDSTATUS_FAILED;        
    }
    
    return IFDSTATUS_SUCCESS;
}    

static void
MyCardEntry(
    class CCardProvider& in_CCardProvider
    )
/*++

Routine Description:
    
    This function registers all callbacks from the test suite
	
Arguments:

    CCardProvider - ref. to card provider class

Return Value:

    -

--*/
{
    // Set protocol callback
    in_CCardProvider.SetProtocol(MyCardSetProtocol);

    // Card test callback
    in_CCardProvider.SetCardTest(MyCardTest);

    // Name of our card
    in_CCardProvider.SetCardName("IBM");

    in_CCardProvider.SetAtr((PBYTE) "\x3b\xef\x00\xff\x81\x31\x86\x45\x49\x42\x4d\x20\x4d\x46\x43\x34\x30\x30\x30\x30\x38\x33\x31\x43", 24);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\ifdtest\errmap.h ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    errmap.h

Abstract:

    defines an array for mapping nt-status codes to win32 error codes

Environment:

    Windows95 / Memphis static VxD

Notes:

    This files stems originally from \nt\private\ntos\rtl\error.h

Revision History:

    - Copied June 1997 by Klaus Schutz 

--*/

LONG CodePairs[] = {

    //
    // These are also defined in WINNT.H, but we are stuck with these
    // mappings.
    //

    STATUS_DATATYPE_MISALIGNMENT, ERROR_NOACCESS,
    STATUS_ACCESS_VIOLATION, ERROR_NOACCESS,

    STATUS_CTL_FILE_NOT_SUPPORTED, ERROR_NOT_SUPPORTED,
    STATUS_PORT_ALREADY_SET, ERROR_INVALID_PARAMETER,
    STATUS_SECTION_NOT_IMAGE, ERROR_INVALID_PARAMETER,
    STATUS_BAD_WORKING_SET_LIMIT, ERROR_INVALID_PARAMETER,
    STATUS_WORKING_SET_LIMIT_RANGE, ERROR_INVALID_PARAMETER,
    STATUS_INCOMPATIBLE_FILE_MAP, ERROR_INVALID_PARAMETER,
    STATUS_PORT_DISCONNECTED, ERROR_INVALID_HANDLE,
    STATUS_NOT_LOCKED, ERROR_NOT_LOCKED,
    STATUS_NOT_MAPPED_VIEW, ERROR_INVALID_ADDRESS,
    STATUS_UNABLE_TO_FREE_VM, ERROR_INVALID_PARAMETER,
    STATUS_UNABLE_TO_DELETE_SECTION, ERROR_INVALID_PARAMETER,
    STATUS_MORE_PROCESSING_REQUIRED, ERROR_MORE_DATA,
    STATUS_INVALID_CID, ERROR_INVALID_PARAMETER,
    STATUS_STACK_OVERFLOW, ERROR_STACK_OVERFLOW,
    STATUS_BAD_INITIAL_STACK, ERROR_STACK_OVERFLOW,
    STATUS_INVALID_VOLUME_LABEL, ERROR_LABEL_TOO_LONG,
    STATUS_SECTION_NOT_EXTENDED, ERROR_OUTOFMEMORY,
    STATUS_NOT_MAPPED_DATA, ERROR_INVALID_ADDRESS,

    STATUS_NO_LDT, ERROR_INVALID_THREAD_ID,

    STATUS_INFO_LENGTH_MISMATCH, ERROR_BAD_LENGTH,
    STATUS_INVALID_INFO_CLASS, ERROR_INVALID_PARAMETER,

    STATUS_SUSPEND_COUNT_EXCEEDED, ERROR_SIGNAL_REFUSED,

    STATUS_NOTIFY_ENUM_DIR, ERROR_NOTIFY_ENUM_DIR,

    STATUS_REGISTRY_RECOVERED, ERROR_REGISTRY_RECOVERED,

    STATUS_REGISTRY_IO_FAILED, ERROR_REGISTRY_IO_FAILED,

    STATUS_NOT_REGISTRY_FILE, ERROR_NOT_REGISTRY_FILE,

    STATUS_KEY_DELETED, ERROR_KEY_DELETED,

    STATUS_NO_LOG_SPACE, ERROR_NO_LOG_SPACE,

    STATUS_KEY_HAS_CHILDREN, ERROR_KEY_HAS_CHILDREN,

    STATUS_CHILD_MUST_BE_VOLATILE, ERROR_CHILD_MUST_BE_VOLATILE,

    STATUS_REGISTRY_CORRUPT, ERROR_BADDB,

    STATUS_DLL_NOT_FOUND, ERROR_MOD_NOT_FOUND,

    STATUS_DLL_INIT_FAILED, ERROR_DLL_INIT_FAILED,

    STATUS_ORDINAL_NOT_FOUND, ERROR_INVALID_ORDINAL,
    STATUS_DRIVER_ORDINAL_NOT_FOUND, ERROR_INVALID_ORDINAL,
    STATUS_DRIVER_UNABLE_TO_LOAD, ERROR_BAD_DRIVER,

    STATUS_ENTRYPOINT_NOT_FOUND, ERROR_PROC_NOT_FOUND,
    STATUS_DRIVER_ENTRYPOINT_NOT_FOUND, ERROR_PROC_NOT_FOUND,

    STATUS_PENDING, ERROR_IO_PENDING,

    STATUS_MORE_ENTRIES, ERROR_MORE_DATA,

    STATUS_INTEGER_OVERFLOW, ERROR_ARITHMETIC_OVERFLOW,

    STATUS_BUFFER_OVERFLOW, ERROR_MORE_DATA,

    STATUS_NO_MORE_FILES, ERROR_NO_MORE_FILES,

    STATUS_NO_INHERITANCE, ERROR_NO_INHERITANCE,

    STATUS_NO_MORE_EAS, ERROR_NO_MORE_ITEMS,
    STATUS_NO_MORE_ENTRIES, ERROR_NO_MORE_ITEMS,
    STATUS_GUIDS_EXHAUSTED, ERROR_NO_MORE_ITEMS,
    STATUS_AGENTS_EXHAUSTED, ERROR_NO_MORE_ITEMS,

    STATUS_UNSUCCESSFUL, ERROR_GEN_FAILURE,

    STATUS_TOO_MANY_LINKS, ERROR_TOO_MANY_LINKS,

    STATUS_NOT_IMPLEMENTED, ERROR_INVALID_FUNCTION,
    STATUS_ILLEGAL_FUNCTION, ERROR_INVALID_FUNCTION,

    STATUS_IN_PAGE_ERROR, ERROR_SWAPERROR,

    STATUS_PAGEFILE_QUOTA, ERROR_PAGEFILE_QUOTA,
    STATUS_COMMITMENT_LIMIT, ERROR_COMMITMENT_LIMIT,
    STATUS_SECTION_TOO_BIG, ERROR_NOT_ENOUGH_MEMORY,

    RPC_NT_SS_IN_NULL_CONTEXT, ERROR_INVALID_HANDLE,
    RPC_NT_INVALID_BINDING, ERROR_INVALID_HANDLE,
    STATUS_INVALID_HANDLE, ERROR_INVALID_HANDLE,
    STATUS_OBJECT_TYPE_MISMATCH, ERROR_INVALID_HANDLE,
    STATUS_FILE_CLOSED, ERROR_INVALID_HANDLE,
    STATUS_INVALID_PORT_HANDLE, ERROR_INVALID_HANDLE,
    STATUS_HANDLE_NOT_CLOSABLE, ERROR_INVALID_HANDLE,

    STATUS_NOT_COMMITTED, ERROR_INVALID_ADDRESS,
    STATUS_PARTIAL_COPY, ERROR_PARTIAL_COPY,

    STATUS_LPC_REPLY_LOST, ERROR_INTERNAL_ERROR,
    STATUS_INVALID_PARAMETER, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_1, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_2, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_3, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_4, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_5, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_6, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_7, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_8, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_9, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_10, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_11, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_12, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_MIX, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PAGE_PROTECTION, ERROR_INVALID_PARAMETER,
    STATUS_SECTION_PROTECTION, ERROR_INVALID_PARAMETER,

    STATUS_RESOURCE_DATA_NOT_FOUND, ERROR_RESOURCE_DATA_NOT_FOUND,
    STATUS_RESOURCE_TYPE_NOT_FOUND, ERROR_RESOURCE_TYPE_NOT_FOUND,
    STATUS_RESOURCE_NAME_NOT_FOUND, ERROR_RESOURCE_NAME_NOT_FOUND,
    STATUS_RESOURCE_LANG_NOT_FOUND, ERROR_RESOURCE_LANG_NOT_FOUND,

    STATUS_NO_SUCH_DEVICE, ERROR_FILE_NOT_FOUND,
    STATUS_NO_SUCH_FILE, ERROR_FILE_NOT_FOUND,

    STATUS_INVALID_DEVICE_REQUEST, ERROR_INVALID_FUNCTION,
    STATUS_VOLUME_NOT_UPGRADED, ERROR_INVALID_FUNCTION,

    STATUS_END_OF_FILE, ERROR_HANDLE_EOF,
    STATUS_FILE_FORCED_CLOSED, ERROR_HANDLE_EOF,

    STATUS_WRONG_VOLUME, ERROR_WRONG_DISK,

    STATUS_NO_MEDIA, ERROR_NO_MEDIA_IN_DRIVE,

    STATUS_NO_MEDIA_IN_DEVICE, ERROR_NOT_READY,

    STATUS_VOLUME_DISMOUNTED, ERROR_NOT_READY,

    STATUS_NONEXISTENT_SECTOR, ERROR_SECTOR_NOT_FOUND,

    STATUS_WORKING_SET_QUOTA, ERROR_WORKING_SET_QUOTA,
    STATUS_NO_MEMORY, ERROR_NOT_ENOUGH_MEMORY,
    STATUS_CONFLICTING_ADDRESSES, ERROR_INVALID_ADDRESS,

    STATUS_INVALID_SYSTEM_SERVICE, ERROR_INVALID_FUNCTION,

    STATUS_THREAD_IS_TERMINATING, ERROR_ACCESS_DENIED,
    STATUS_PROCESS_IS_TERMINATING, ERROR_ACCESS_DENIED,
    STATUS_INVALID_LOCK_SEQUENCE, ERROR_ACCESS_DENIED,
    STATUS_INVALID_VIEW_SIZE, ERROR_ACCESS_DENIED,
    STATUS_ALREADY_COMMITTED, ERROR_ACCESS_DENIED,
    STATUS_ACCESS_DENIED, ERROR_ACCESS_DENIED,
    STATUS_FILE_IS_A_DIRECTORY, ERROR_ACCESS_DENIED,
    STATUS_CANNOT_DELETE, ERROR_ACCESS_DENIED,
    STATUS_INVALID_COMPUTER_NAME, ERROR_INVALID_COMPUTERNAME,
    STATUS_FILE_DELETED, ERROR_ACCESS_DENIED,
    STATUS_DELETE_PENDING, ERROR_ACCESS_DENIED,
    STATUS_PORT_CONNECTION_REFUSED, ERROR_ACCESS_DENIED,

    STATUS_NO_SUCH_PRIVILEGE, ERROR_NO_SUCH_PRIVILEGE,

    STATUS_PRIVILEGE_NOT_HELD, ERROR_PRIVILEGE_NOT_HELD,

    STATUS_CANNOT_IMPERSONATE, ERROR_CANNOT_IMPERSONATE,

    STATUS_LOGON_FAILURE, ERROR_LOGON_FAILURE,

    STATUS_ACCOUNT_RESTRICTION, ERROR_ACCOUNT_RESTRICTION,

    STATUS_INVALID_LOGON_HOURS, ERROR_INVALID_LOGON_HOURS,

    STATUS_INVALID_WORKSTATION, ERROR_INVALID_WORKSTATION,

    STATUS_BUFFER_TOO_SMALL, ERROR_INSUFFICIENT_BUFFER,

    STATUS_UNABLE_TO_DECOMMIT_VM, ERROR_INVALID_ADDRESS,

    STATUS_DISK_CORRUPT_ERROR, ERROR_DISK_CORRUPT,

    STATUS_VARIABLE_NOT_FOUND, ERROR_ENVVAR_NOT_FOUND,

    STATUS_OBJECT_NAME_INVALID, ERROR_INVALID_NAME,

    STATUS_OBJECT_NAME_NOT_FOUND, ERROR_FILE_NOT_FOUND,

    STATUS_OBJECT_NAME_COLLISION, ERROR_ALREADY_EXISTS,

    STATUS_OBJECT_PATH_INVALID, ERROR_BAD_PATHNAME,

    STATUS_OBJECT_PATH_NOT_FOUND, ERROR_PATH_NOT_FOUND,
    STATUS_DFS_EXIT_PATH_FOUND, ERROR_PATH_NOT_FOUND,

    STATUS_OBJECT_PATH_SYNTAX_BAD, ERROR_BAD_PATHNAME,

    STATUS_NAME_TOO_LONG, ERROR_FILENAME_EXCED_RANGE,

    STATUS_DATA_ERROR, ERROR_CRC,

    STATUS_CRC_ERROR, ERROR_CRC,

    STATUS_SHARING_VIOLATION, ERROR_SHARING_VIOLATION,

    STATUS_QUOTA_EXCEEDED, ERROR_NOT_ENOUGH_QUOTA,

    STATUS_MUTANT_NOT_OWNED, ERROR_NOT_OWNER,

    STATUS_SEMAPHORE_LIMIT_EXCEEDED, ERROR_TOO_MANY_POSTS,

    STATUS_DISK_FULL, ERROR_DISK_FULL,

    STATUS_LOCK_NOT_GRANTED, ERROR_LOCK_VIOLATION,

    STATUS_FILE_LOCK_CONFLICT, ERROR_LOCK_VIOLATION,  // FIX, FIX - is this right?

    STATUS_NOT_A_DIRECTORY, ERROR_DIRECTORY,          // FIX, FIX - is this right?

    STATUS_UNKNOWN_REVISION, ERROR_UNKNOWN_REVISION,

    STATUS_REVISION_MISMATCH, ERROR_REVISION_MISMATCH,

    STATUS_INVALID_OWNER, ERROR_INVALID_OWNER,

    STATUS_INVALID_PRIMARY_GROUP, ERROR_INVALID_PRIMARY_GROUP,

    STATUS_NO_IMPERSONATION_TOKEN, ERROR_NO_IMPERSONATION_TOKEN,

    STATUS_CANT_DISABLE_MANDATORY, ERROR_CANT_DISABLE_MANDATORY,

    STATUS_NO_LOGON_SERVERS, ERROR_NO_LOGON_SERVERS,
    STATUS_DOMAIN_CONTROLLER_NOT_FOUND, ERROR_DOMAIN_CONTROLLER_NOT_FOUND,

    STATUS_NO_SUCH_LOGON_SESSION, ERROR_NO_SUCH_LOGON_SESSION,

    STATUS_INVALID_ACCOUNT_NAME, ERROR_INVALID_ACCOUNT_NAME,

    STATUS_USER_EXISTS, ERROR_USER_EXISTS,

    STATUS_NO_SUCH_USER, ERROR_NO_SUCH_USER,

    STATUS_GROUP_EXISTS, ERROR_GROUP_EXISTS,

    STATUS_NO_SUCH_GROUP, ERROR_NO_SUCH_GROUP,

    STATUS_SPECIAL_GROUP, ERROR_SPECIAL_GROUP,

    STATUS_MEMBER_IN_GROUP, ERROR_MEMBER_IN_GROUP,

    STATUS_MEMBER_NOT_IN_GROUP, ERROR_MEMBER_NOT_IN_GROUP,

    STATUS_LAST_ADMIN, ERROR_LAST_ADMIN,

    STATUS_WRONG_PASSWORD, ERROR_INVALID_PASSWORD,
    STATUS_WRONG_PASSWORD_CORE, ERROR_INVALID_PASSWORD,

    STATUS_ILL_FORMED_PASSWORD, ERROR_ILL_FORMED_PASSWORD,

    STATUS_PASSWORD_RESTRICTION, ERROR_PASSWORD_RESTRICTION,

    STATUS_PASSWORD_EXPIRED, ERROR_PASSWORD_EXPIRED,
    STATUS_PASSWORD_MUST_CHANGE, ERROR_PASSWORD_MUST_CHANGE,

    STATUS_ACCOUNT_DISABLED, ERROR_ACCOUNT_DISABLED,
    STATUS_ACCOUNT_LOCKED_OUT, ERROR_ACCOUNT_LOCKED_OUT,

    STATUS_NONE_MAPPED, ERROR_NONE_MAPPED,

    STATUS_TOO_MANY_LUIDS_REQUESTED, ERROR_TOO_MANY_LUIDS_REQUESTED,

    STATUS_LUIDS_EXHAUSTED, ERROR_LUIDS_EXHAUSTED,

    STATUS_INVALID_SUB_AUTHORITY, ERROR_INVALID_SUB_AUTHORITY,

    STATUS_INVALID_ACL, ERROR_INVALID_ACL,

    STATUS_INVALID_SID, ERROR_INVALID_SID,

    STATUS_INVALID_SECURITY_DESCR, ERROR_INVALID_SECURITY_DESCR,

    STATUS_PROCEDURE_NOT_FOUND, ERROR_PROC_NOT_FOUND,

    STATUS_BAD_INITIAL_PC, ERROR_BAD_EXE_FORMAT,
    STATUS_INVALID_FILE_FOR_SECTION, ERROR_BAD_EXE_FORMAT,
    STATUS_INVALID_IMAGE_FORMAT, ERROR_BAD_EXE_FORMAT,
    STATUS_IMAGE_MP_UP_MISMATCH, ERROR_BAD_EXE_FORMAT,
    STATUS_INVALID_IMAGE_NOT_MZ, ERROR_BAD_EXE_FORMAT,
    STATUS_IMAGE_CHECKSUM_MISMATCH, ERROR_BAD_EXE_FORMAT,
    STATUS_INVALID_IMAGE_PROTECT, ERROR_BAD_EXE_FORMAT,
    STATUS_INVALID_IMAGE_LE_FORMAT, ERROR_BAD_EXE_FORMAT,
    STATUS_INVALID_IMAGE_NE_FORMAT, ERROR_BAD_EXE_FORMAT,
    STATUS_INVALID_IMAGE_WIN_16, ERROR_BAD_EXE_FORMAT,

    STATUS_NO_TOKEN, ERROR_NO_TOKEN,

    STATUS_RANGE_NOT_LOCKED, ERROR_NOT_LOCKED,

    STATUS_SERVER_DISABLED, ERROR_SERVER_DISABLED,

    STATUS_SERVER_NOT_DISABLED, ERROR_SERVER_NOT_DISABLED,

    STATUS_INVALID_ID_AUTHORITY, ERROR_INVALID_ID_AUTHORITY,

    STATUS_ALLOTTED_SPACE_EXCEEDED, ERROR_ALLOTTED_SPACE_EXCEEDED,

    STATUS_TOO_MANY_PAGING_FILES, ERROR_NOT_ENOUGH_MEMORY,
    STATUS_INSUFFICIENT_RESOURCES, ERROR_NO_SYSTEM_RESOURCES,

    STATUS_INSUFF_SERVER_RESOURCES, ERROR_NOT_ENOUGH_SERVER_MEMORY,

    STATUS_FILE_INVALID, ERROR_FILE_INVALID,
    STATUS_MAPPED_FILE_SIZE_ZERO, ERROR_FILE_INVALID,

    STATUS_DEVICE_PAPER_EMPTY, ERROR_OUT_OF_PAPER,

    STATUS_DEVICE_POWERED_OFF, ERROR_NOT_READY,
    STATUS_DEVICE_OFF_LINE, ERROR_NOT_READY,

    STATUS_DEVICE_DATA_ERROR, ERROR_CRC,

    STATUS_DEVICE_NOT_READY, ERROR_NOT_READY,
    STATUS_DEVICE_NOT_CONNECTED, ERROR_DEVICE_NOT_CONNECTED,
    STATUS_DEVICE_POWER_FAILURE, ERROR_NOT_READY,

    STATUS_NOT_FOUND, ERROR_NOT_FOUND,
    STATUS_NO_MATCH, ERROR_NO_MATCH,
    STATUS_PROPSET_NOT_FOUND, ERROR_SET_NOT_FOUND,


    STATUS_DEVICE_BUSY, ERROR_BUSY,                   // FIX, FIX - is there a better choice?

    STATUS_FREE_VM_NOT_AT_BASE, ERROR_INVALID_ADDRESS,
    STATUS_MEMORY_NOT_ALLOCATED, ERROR_INVALID_ADDRESS,

    STATUS_NOT_SAME_DEVICE, ERROR_NOT_SAME_DEVICE,

    STATUS_NOT_SUPPORTED, ERROR_NOT_SUPPORTED,

    STATUS_REMOTE_NOT_LISTENING, ERROR_REM_NOT_LIST,

    STATUS_DUPLICATE_NAME, ERROR_DUP_NAME,

    STATUS_BAD_NETWORK_PATH, ERROR_BAD_NETPATH,

    STATUS_NETWORK_BUSY, ERROR_NETWORK_BUSY,

    STATUS_DEVICE_DOES_NOT_EXIST, ERROR_DEV_NOT_EXIST,

    STATUS_TOO_MANY_COMMANDS, ERROR_TOO_MANY_CMDS,

    STATUS_ADAPTER_HARDWARE_ERROR, ERROR_ADAP_HDW_ERR,

    STATUS_REDIRECTOR_NOT_STARTED, ERROR_PATH_NOT_FOUND,

    STATUS_INVALID_EA_NAME, ERROR_INVALID_EA_NAME,

    STATUS_EA_LIST_INCONSISTENT, ERROR_EA_LIST_INCONSISTENT,
    STATUS_EA_TOO_LARGE, ERROR_EA_LIST_INCONSISTENT,
    STATUS_INVALID_EA_FLAG, ERROR_EA_LIST_INCONSISTENT,
    STATUS_EAS_NOT_SUPPORTED, ERROR_EAS_NOT_SUPPORTED,

    STATUS_FILE_CORRUPT_ERROR, ERROR_FILE_CORRUPT,
    STATUS_EA_CORRUPT_ERROR, ERROR_FILE_CORRUPT,
    STATUS_NONEXISTENT_EA_ENTRY, ERROR_FILE_CORRUPT,
    STATUS_NO_EAS_ON_FILE, ERROR_FILE_CORRUPT,

    STATUS_NOT_A_REPARSE_POINT, ERROR_NOT_A_REPARSE_POINT,
    STATUS_IO_REPARSE_TAG_INVALID, ERROR_INVALID_PARAMETER,
    STATUS_IO_REPARSE_TAG_MISMATCH, ERROR_INVALID_PARAMETER,
    STATUS_IO_REPARSE_DATA_INVALID, ERROR_INVALID_PARAMETER,
    STATUS_IO_REPARSE_TAG_NOT_HANDLED, ERROR_CANT_ACCESS_FILE,
    STATUS_REPARSE_POINT_NOT_RESOLVED, ERROR_CANT_RESOLVE_FILENAME,
    STATUS_DIRECTORY_IS_A_REPARSE_POINT, ERROR_BAD_PATHNAME,
    STATUS_REPARSE_ATTRIBUTE_CONFLICT, ERROR_REPARSE_ATTRIBUTE_CONFLICT,
    STATUS_IO_REPARSE_DATA_INVALID, ERROR_INVALID_REPARSE_DATA,

    STATUS_FILE_IS_OFFLINE, ERROR_FILE_OFFLINE,
    STATUS_REMOTE_STORAGE_NOT_ACTIVE, ERROR_REMOTE_STORAGE_NOT_ACTIVE,
    STATUS_REMOTE_STORAGE_MEDIA_ERROR, ERROR_REMOTE_STORAGE_MEDIA_ERROR,
    STATUS_NO_TRACKING_SERVICE, ERROR_NO_TRACKING_SERVICE,

    STATUS_JOURNAL_DELETE_IN_PROGRESS, ERROR_JOURNAL_DELETE_IN_PROGRESS,
    STATUS_JOURNAL_NOT_ACTIVE, ERROR_JOURNAL_NOT_ACTIVE,

    STATUS_INVALID_NETWORK_RESPONSE, ERROR_BAD_NET_RESP,

    STATUS_USER_SESSION_DELETED, ERROR_UNEXP_NET_ERR,
    STATUS_UNEXPECTED_NETWORK_ERROR, ERROR_UNEXP_NET_ERR,

    STATUS_USER_SESSION_DELETED, ERROR_UNEXP_NET_ERR,

    STATUS_BAD_REMOTE_ADAPTER, ERROR_BAD_REM_ADAP,

    STATUS_PRINT_QUEUE_FULL, ERROR_PRINTQ_FULL,

    STATUS_NO_SPOOL_SPACE, ERROR_NO_SPOOL_SPACE,

    STATUS_PRINT_CANCELLED, ERROR_PRINT_CANCELLED,

    STATUS_NETWORK_NAME_DELETED, ERROR_NETNAME_DELETED,

    STATUS_NETWORK_ACCESS_DENIED, ERROR_NETWORK_ACCESS_DENIED,

    STATUS_BAD_DEVICE_TYPE, ERROR_BAD_DEV_TYPE,

    STATUS_BAD_NETWORK_NAME, ERROR_BAD_NET_NAME,

    STATUS_TOO_MANY_NAMES, ERROR_TOO_MANY_NAMES,
    STATUS_TOO_MANY_GUIDS_REQUESTED, ERROR_TOO_MANY_NAMES,
    STATUS_TOO_MANY_ADDRESSES, ERROR_TOO_MANY_NAMES,
    STATUS_TOO_MANY_NODES, ERROR_TOO_MANY_NAMES,

    STATUS_TOO_MANY_SESSIONS, ERROR_TOO_MANY_SESS,

    STATUS_SHARING_PAUSED, ERROR_SHARING_PAUSED,

    STATUS_REQUEST_NOT_ACCEPTED, ERROR_REQ_NOT_ACCEP,

    STATUS_REDIRECTOR_PAUSED, ERROR_REDIR_PAUSED,

    STATUS_NET_WRITE_FAULT, ERROR_NET_WRITE_FAULT,

    STATUS_VIRTUAL_CIRCUIT_CLOSED, ERROR_VC_DISCONNECTED,

    STATUS_INVALID_PIPE_STATE, ERROR_BAD_PIPE,
    STATUS_INVALID_READ_MODE, ERROR_BAD_PIPE,

    STATUS_PIPE_CLOSING, ERROR_NO_DATA,
    STATUS_PIPE_EMPTY, ERROR_NO_DATA,

    STATUS_PIPE_CONNECTED, ERROR_PIPE_CONNECTED,

    STATUS_PIPE_DISCONNECTED, ERROR_PIPE_NOT_CONNECTED,

    STATUS_PIPE_LISTENING, ERROR_PIPE_LISTENING,

    STATUS_PIPE_NOT_AVAILABLE, ERROR_PIPE_BUSY,
    STATUS_INSTANCE_NOT_AVAILABLE, ERROR_PIPE_BUSY,
    STATUS_PIPE_BUSY, ERROR_PIPE_BUSY,

    STATUS_PIPE_BROKEN, ERROR_BROKEN_PIPE,

    STATUS_DIRECTORY_NOT_EMPTY, ERROR_DIR_NOT_EMPTY,

    STATUS_TOO_MANY_OPENED_FILES, ERROR_TOO_MANY_OPEN_FILES,

    STATUS_IO_TIMEOUT, ERROR_SEM_TIMEOUT,

    STATUS_CANCELLED, ERROR_OPERATION_ABORTED,

    STATUS_UNRECOGNIZED_MEDIA, ERROR_UNRECOGNIZED_MEDIA,

    STATUS_INVALID_LEVEL, ERROR_INVALID_LEVEL,

    STATUS_UNRECOGNIZED_VOLUME, ERROR_UNRECOGNIZED_VOLUME,

    STATUS_MEDIA_WRITE_PROTECTED, ERROR_WRITE_PROTECT,
    STATUS_TOO_LATE, ERROR_WRITE_PROTECT,

    STATUS_SUCCESS, NO_ERROR,

    STATUS_FULLSCREEN_MODE, ERROR_FULLSCREEN_MODE,

    STATUS_END_OF_MEDIA, ERROR_END_OF_MEDIA,

    STATUS_EOM_OVERFLOW, ERROR_EOM_OVERFLOW,

    STATUS_BEGINNING_OF_MEDIA, ERROR_BEGINNING_OF_MEDIA,

    STATUS_MEDIA_CHANGED, ERROR_MEDIA_CHANGED,

    STATUS_BUS_RESET, ERROR_BUS_RESET,

    STATUS_FILEMARK_DETECTED, ERROR_FILEMARK_DETECTED,

    STATUS_SETMARK_DETECTED, ERROR_SETMARK_DETECTED,

    STATUS_NO_DATA_DETECTED, ERROR_NO_DATA_DETECTED,

    STATUS_PARTITION_FAILURE, ERROR_PARTITION_FAILURE,

    STATUS_INVALID_BLOCK_LENGTH, ERROR_INVALID_BLOCK_LENGTH,

    STATUS_DEVICE_NOT_PARTITIONED, ERROR_DEVICE_NOT_PARTITIONED,

    STATUS_UNABLE_TO_LOCK_MEDIA, ERROR_UNABLE_TO_LOCK_MEDIA,

    STATUS_UNABLE_TO_UNLOAD_MEDIA, ERROR_UNABLE_TO_UNLOAD_MEDIA,

    STATUS_UNMAPPABLE_CHARACTER, ERROR_NO_UNICODE_TRANSLATION,

    STATUS_NOT_ALL_ASSIGNED, ERROR_NOT_ALL_ASSIGNED,

    STATUS_SOME_NOT_MAPPED, ERROR_SOME_NOT_MAPPED,

    STATUS_NO_QUOTAS_FOR_ACCOUNT, ERROR_NO_QUOTAS_FOR_ACCOUNT,

    STATUS_LOCAL_USER_SESSION_KEY, ERROR_LOCAL_USER_SESSION_KEY,

    STATUS_NULL_LM_PASSWORD, ERROR_NULL_LM_PASSWORD,

    STATUS_BAD_INHERITANCE_ACL, ERROR_BAD_INHERITANCE_ACL,

    STATUS_INVALID_GROUP_ATTRIBUTES, ERROR_INVALID_GROUP_ATTRIBUTES,

    STATUS_BAD_IMPERSONATION_LEVEL, ERROR_BAD_IMPERSONATION_LEVEL,

    STATUS_CANT_OPEN_ANONYMOUS, ERROR_CANT_OPEN_ANONYMOUS,

    STATUS_BAD_VALIDATION_CLASS, ERROR_BAD_VALIDATION_CLASS,

    STATUS_BAD_TOKEN_TYPE, ERROR_BAD_TOKEN_TYPE,

    STATUS_NO_SECURITY_ON_OBJECT, ERROR_NO_SECURITY_ON_OBJECT,

    STATUS_CANT_ACCESS_DOMAIN_INFO, ERROR_CANT_ACCESS_DOMAIN_INFO,

    STATUS_INVALID_SERVER_STATE, ERROR_INVALID_SERVER_STATE,

    STATUS_INVALID_DOMAIN_STATE, ERROR_INVALID_DOMAIN_STATE,

    STATUS_INVALID_DOMAIN_ROLE, ERROR_INVALID_DOMAIN_ROLE,

    STATUS_NO_SUCH_DOMAIN, ERROR_NO_SUCH_DOMAIN,

    STATUS_DOMAIN_EXISTS, ERROR_DOMAIN_EXISTS,

    STATUS_DOMAIN_LIMIT_EXCEEDED, ERROR_DOMAIN_LIMIT_EXCEEDED,

    STATUS_OPLOCK_NOT_GRANTED, ERROR_OPLOCK_NOT_GRANTED,
    STATUS_INVALID_OPLOCK_PROTOCOL, ERROR_INVALID_OPLOCK_PROTOCOL,

    STATUS_INTERNAL_DB_CORRUPTION, ERROR_INTERNAL_DB_CORRUPTION,

    STATUS_INTERNAL_ERROR, ERROR_INTERNAL_ERROR,

    STATUS_GENERIC_NOT_MAPPED, ERROR_GENERIC_NOT_MAPPED,

    STATUS_BAD_DESCRIPTOR_FORMAT, ERROR_BAD_DESCRIPTOR_FORMAT,

    STATUS_NOT_LOGON_PROCESS, ERROR_NOT_LOGON_PROCESS,

    STATUS_LOGON_SESSION_EXISTS, ERROR_LOGON_SESSION_EXISTS,

    STATUS_NO_SUCH_PACKAGE, ERROR_NO_SUCH_PACKAGE,

    STATUS_BAD_LOGON_SESSION_STATE, ERROR_BAD_LOGON_SESSION_STATE,

    STATUS_LOGON_SESSION_COLLISION, ERROR_LOGON_SESSION_COLLISION,

    STATUS_INVALID_LOGON_TYPE, ERROR_INVALID_LOGON_TYPE,

    STATUS_RXACT_INVALID_STATE, ERROR_RXACT_INVALID_STATE,

    STATUS_RXACT_COMMIT_FAILURE, ERROR_RXACT_COMMIT_FAILURE,

    STATUS_SPECIAL_ACCOUNT, ERROR_SPECIAL_ACCOUNT,

    STATUS_SPECIAL_USER, ERROR_SPECIAL_USER,

    STATUS_MEMBERS_PRIMARY_GROUP, ERROR_MEMBERS_PRIMARY_GROUP,

    STATUS_TOKEN_ALREADY_IN_USE, ERROR_TOKEN_ALREADY_IN_USE,

    STATUS_NO_SUCH_ALIAS, ERROR_NO_SUCH_ALIAS,

    STATUS_MEMBER_NOT_IN_ALIAS, ERROR_MEMBER_NOT_IN_ALIAS,

    STATUS_MEMBER_IN_ALIAS, ERROR_MEMBER_IN_ALIAS,

    STATUS_ALIAS_EXISTS, ERROR_ALIAS_EXISTS,

    STATUS_LOGON_NOT_GRANTED, ERROR_LOGON_NOT_GRANTED,

    STATUS_TOO_MANY_SECRETS, ERROR_TOO_MANY_SECRETS,

    STATUS_SECRET_TOO_LONG, ERROR_SECRET_TOO_LONG,

    STATUS_INTERNAL_DB_ERROR, ERROR_INTERNAL_DB_ERROR,

    STATUS_TOO_MANY_CONTEXT_IDS, ERROR_TOO_MANY_CONTEXT_IDS,

    STATUS_LOGON_TYPE_NOT_GRANTED, ERROR_LOGON_TYPE_NOT_GRANTED,

    STATUS_NT_CROSS_ENCRYPTION_REQUIRED, ERROR_NT_CROSS_ENCRYPTION_REQUIRED,

    STATUS_NO_SUCH_MEMBER, ERROR_NO_SUCH_MEMBER,

    STATUS_INVALID_MEMBER, ERROR_INVALID_MEMBER,

    STATUS_TOO_MANY_SIDS, ERROR_TOO_MANY_SIDS,

    STATUS_LM_CROSS_ENCRYPTION_REQUIRED, ERROR_LM_CROSS_ENCRYPTION_REQUIRED,

    STATUS_MESSAGE_NOT_FOUND, ERROR_MR_MID_NOT_FOUND,

    STATUS_LOCAL_DISCONNECT, ERROR_NETNAME_DELETED,
    STATUS_REMOTE_DISCONNECT, ERROR_NETNAME_DELETED,

    STATUS_REMOTE_RESOURCES, ERROR_REM_NOT_LIST,

    STATUS_LINK_FAILED, ERROR_UNEXP_NET_ERR,
    STATUS_LINK_TIMEOUT, ERROR_UNEXP_NET_ERR,

    STATUS_INVALID_CONNECTION, ERROR_UNEXP_NET_ERR,
    STATUS_INVALID_ADDRESS, ERROR_UNEXP_NET_ERR,

    STATUS_DEVICE_PROTOCOL_ERROR, ERROR_IO_DEVICE,

    STATUS_INVALID_DEVICE_STATE, ERROR_BAD_COMMAND,

    STATUS_DEVICE_CONFIGURATION_ERROR, ERROR_INVALID_PARAMETER,

    STATUS_SOURCE_ELEMENT_EMPTY,       ERROR_SOURCE_ELEMENT_EMPTY,
    STATUS_DESTINATION_ELEMENT_FULL,   ERROR_DESTINATION_ELEMENT_FULL,
    STATUS_ILLEGAL_ELEMENT_ADDRESS,    ERROR_ILLEGAL_ELEMENT_ADDRESS,
    STATUS_MAGAZINE_NOT_PRESENT,       ERROR_MAGAZINE_NOT_PRESENT,
    STATUS_REINITIALIZATION_NEEDED,    ERROR_DEVICE_REINITIALIZATION_NEEDED,
    STATUS_DEVICE_REQUIRES_CLEANING,   ERROR_DEVICE_REQUIRES_CLEANING,
    STATUS_DEVICE_DOOR_OPEN,           ERROR_DEVICE_DOOR_OPEN,

    STATUS_ENCRYPTION_FAILED,          ERROR_ENCRYPTION_FAILED,
    STATUS_DECRYPTION_FAILED,          ERROR_DECRYPTION_FAILED,
    STATUS_NO_RECOVERY_POLICY,         ERROR_NO_RECOVERY_POLICY,
    STATUS_NO_EFS,                     ERROR_NO_EFS,
    STATUS_WRONG_EFS,                  ERROR_WRONG_EFS,
    STATUS_NO_USER_KEYS,               ERROR_NO_USER_KEYS,
    STATUS_FILE_NOT_ENCRYPTED,         ERROR_FILE_NOT_ENCRYPTED,
    STATUS_NOT_EXPORT_FORMAT,          ERROR_NOT_EXPORT_FORMAT,
    STATUS_FILE_ENCRYPTED,             ERROR_FILE_ENCRYPTED,

    STATUS_INVALID_USER_BUFFER, ERROR_INVALID_USER_BUFFER,

    STATUS_SERIAL_NO_DEVICE_INITED, ERROR_SERIAL_NO_DEVICE,

    STATUS_SHARED_IRQ_BUSY, ERROR_IRQ_BUSY,

    STATUS_SERIAL_MORE_WRITES, ERROR_MORE_WRITES,

    STATUS_SERIAL_COUNTER_TIMEOUT, ERROR_COUNTER_TIMEOUT,

    STATUS_FLOPPY_ID_MARK_NOT_FOUND, ERROR_FLOPPY_ID_MARK_NOT_FOUND,

    STATUS_FLOPPY_WRONG_CYLINDER, ERROR_FLOPPY_WRONG_CYLINDER,

    STATUS_FLOPPY_UNKNOWN_ERROR, ERROR_FLOPPY_UNKNOWN_ERROR,

    STATUS_FLOPPY_BAD_REGISTERS, ERROR_FLOPPY_BAD_REGISTERS,

    STATUS_DISK_RECALIBRATE_FAILED, ERROR_DISK_RECALIBRATE_FAILED,

    STATUS_DISK_OPERATION_FAILED, ERROR_DISK_OPERATION_FAILED,

    STATUS_DISK_RESET_FAILED, ERROR_DISK_RESET_FAILED,

    STATUS_EVENTLOG_FILE_CORRUPT, ERROR_EVENTLOG_FILE_CORRUPT,

    STATUS_EVENTLOG_CANT_START, ERROR_EVENTLOG_CANT_START,

    STATUS_NETLOGON_NOT_STARTED, ERROR_NETLOGON_NOT_STARTED,

    STATUS_ACCOUNT_EXPIRED, ERROR_ACCOUNT_EXPIRED,

    STATUS_NETWORK_CREDENTIAL_CONFLICT, ERROR_SESSION_CREDENTIAL_CONFLICT,

    STATUS_REMOTE_SESSION_LIMIT, ERROR_REMOTE_SESSION_LIMIT_EXCEEDED,

    STATUS_INVALID_BUFFER_SIZE, ERROR_INVALID_USER_BUFFER,

    STATUS_INVALID_ADDRESS_COMPONENT, ERROR_INVALID_NETNAME,
    STATUS_INVALID_ADDRESS_WILDCARD, ERROR_INVALID_NETNAME,

    STATUS_ADDRESS_ALREADY_EXISTS, ERROR_DUP_NAME,

    STATUS_ADDRESS_CLOSED, ERROR_NETNAME_DELETED,
    STATUS_CONNECTION_DISCONNECTED, ERROR_NETNAME_DELETED,

    STATUS_CONNECTION_RESET, ERROR_NETNAME_DELETED,

    STATUS_TRANSACTION_ABORTED, ERROR_UNEXP_NET_ERR,
    STATUS_TRANSACTION_TIMED_OUT, ERROR_UNEXP_NET_ERR,
    STATUS_TRANSACTION_NO_RELEASE, ERROR_UNEXP_NET_ERR,
    STATUS_TRANSACTION_NO_MATCH, ERROR_UNEXP_NET_ERR,
    STATUS_TRANSACTION_RESPONDED, ERROR_UNEXP_NET_ERR,
    STATUS_TRANSACTION_INVALID_ID, ERROR_UNEXP_NET_ERR,
    STATUS_TRANSACTION_INVALID_TYPE, ERROR_UNEXP_NET_ERR,

    STATUS_NOT_SERVER_SESSION, ERROR_NOT_SUPPORTED,
    STATUS_NOT_CLIENT_SESSION, ERROR_NOT_SUPPORTED,

    STATUS_USER_MAPPED_FILE, ERROR_USER_MAPPED_FILE,

    STATUS_PLUGPLAY_NO_DEVICE, ERROR_SERVICE_DISABLED,

    STATUS_WMI_GUID_NOT_FOUND, ERROR_WMI_GUID_NOT_FOUND,
    STATUS_WMI_INSTANCE_NOT_FOUND, ERROR_WMI_INSTANCE_NOT_FOUND,
    STATUS_WMI_ITEMID_NOT_FOUND, ERROR_WMI_ITEMID_NOT_FOUND,
    STATUS_WMI_TRY_AGAIN, ERROR_WMI_TRY_AGAIN,

    RPC_NT_SERVER_UNAVAILABLE, RPC_S_SERVER_UNAVAILABLE,

    RPC_NT_INVALID_STRING_BINDING, RPC_S_INVALID_STRING_BINDING,

    RPC_NT_WRONG_KIND_OF_BINDING, RPC_S_WRONG_KIND_OF_BINDING,

    RPC_NT_PROTSEQ_NOT_SUPPORTED, RPC_S_PROTSEQ_NOT_SUPPORTED,

    RPC_NT_INVALID_RPC_PROTSEQ, RPC_S_INVALID_RPC_PROTSEQ,

    RPC_NT_INVALID_STRING_UUID, RPC_S_INVALID_STRING_UUID,

    RPC_NT_INVALID_ENDPOINT_FORMAT, RPC_S_INVALID_ENDPOINT_FORMAT,

    RPC_NT_INVALID_NET_ADDR, RPC_S_INVALID_NET_ADDR,

    RPC_NT_NO_ENDPOINT_FOUND, RPC_S_NO_ENDPOINT_FOUND,

    RPC_NT_INVALID_TIMEOUT, RPC_S_INVALID_TIMEOUT,

    RPC_NT_OBJECT_NOT_FOUND, RPC_S_OBJECT_NOT_FOUND,

    RPC_NT_ALREADY_REGISTERED, RPC_S_ALREADY_REGISTERED,

    RPC_NT_TYPE_ALREADY_REGISTERED, RPC_S_TYPE_ALREADY_REGISTERED,

    RPC_NT_ALREADY_LISTENING, RPC_S_ALREADY_LISTENING,

    RPC_NT_NO_PROTSEQS_REGISTERED, RPC_S_NO_PROTSEQS_REGISTERED,

    RPC_NT_NOT_LISTENING, RPC_S_NOT_LISTENING,

    RPC_NT_UNKNOWN_MGR_TYPE, RPC_S_UNKNOWN_MGR_TYPE,

    RPC_NT_UNKNOWN_IF, RPC_S_UNKNOWN_IF,

    RPC_NT_NO_BINDINGS, RPC_S_NO_BINDINGS,

    RPC_NT_NO_MORE_BINDINGS, RPC_S_NO_MORE_BINDINGS,

    RPC_NT_NO_PROTSEQS, RPC_S_NO_PROTSEQS,

    RPC_NT_CANT_CREATE_ENDPOINT, RPC_S_CANT_CREATE_ENDPOINT,

    RPC_NT_OUT_OF_RESOURCES, RPC_S_OUT_OF_RESOURCES,

    RPC_NT_SERVER_TOO_BUSY, RPC_S_SERVER_TOO_BUSY,

    RPC_NT_INVALID_NETWORK_OPTIONS, RPC_S_INVALID_NETWORK_OPTIONS,

    RPC_NT_NO_CALL_ACTIVE, RPC_S_NO_CALL_ACTIVE,

    RPC_NT_CALL_FAILED, RPC_S_CALL_FAILED,

    RPC_NT_CALL_FAILED_DNE, RPC_S_CALL_FAILED_DNE,

    RPC_NT_PROTOCOL_ERROR, RPC_S_PROTOCOL_ERROR,

    RPC_NT_UNSUPPORTED_TRANS_SYN, RPC_S_UNSUPPORTED_TRANS_SYN,

    RPC_NT_UNSUPPORTED_TYPE, RPC_S_UNSUPPORTED_TYPE,

    RPC_NT_INVALID_TAG, RPC_S_INVALID_TAG,

    RPC_NT_INVALID_BOUND, RPC_S_INVALID_BOUND,

    RPC_NT_NO_ENTRY_NAME, RPC_S_NO_ENTRY_NAME,

    RPC_NT_INVALID_NAME_SYNTAX, RPC_S_INVALID_NAME_SYNTAX,

    RPC_NT_UNSUPPORTED_NAME_SYNTAX, RPC_S_UNSUPPORTED_NAME_SYNTAX,

    RPC_NT_UUID_NO_ADDRESS, RPC_S_UUID_NO_ADDRESS,

    RPC_NT_DUPLICATE_ENDPOINT, RPC_S_DUPLICATE_ENDPOINT,

    RPC_NT_UNKNOWN_AUTHN_TYPE, RPC_S_UNKNOWN_AUTHN_TYPE,

    RPC_NT_MAX_CALLS_TOO_SMALL, RPC_S_MAX_CALLS_TOO_SMALL,

    RPC_NT_STRING_TOO_LONG, RPC_S_STRING_TOO_LONG,

    RPC_NT_PROTSEQ_NOT_FOUND, RPC_S_PROTSEQ_NOT_FOUND,

    RPC_NT_PROCNUM_OUT_OF_RANGE, RPC_S_PROCNUM_OUT_OF_RANGE,

    RPC_NT_BINDING_HAS_NO_AUTH, RPC_S_BINDING_HAS_NO_AUTH,

    RPC_NT_UNKNOWN_AUTHN_SERVICE, RPC_S_UNKNOWN_AUTHN_SERVICE,

    RPC_NT_UNKNOWN_AUTHN_LEVEL, RPC_S_UNKNOWN_AUTHN_LEVEL,

    RPC_NT_INVALID_AUTH_IDENTITY, RPC_S_INVALID_AUTH_IDENTITY,

    RPC_NT_UNKNOWN_AUTHZ_SERVICE, RPC_S_UNKNOWN_AUTHZ_SERVICE,

    EPT_NT_INVALID_ENTRY, EPT_S_INVALID_ENTRY,

    EPT_NT_CANT_PERFORM_OP, EPT_S_CANT_PERFORM_OP,

    EPT_NT_NOT_REGISTERED, EPT_S_NOT_REGISTERED,

    RPC_NT_NOTHING_TO_EXPORT, RPC_S_NOTHING_TO_EXPORT,

    RPC_NT_INCOMPLETE_NAME, RPC_S_INCOMPLETE_NAME,

    RPC_NT_INVALID_VERS_OPTION, RPC_S_INVALID_VERS_OPTION,

    RPC_NT_NO_MORE_MEMBERS, RPC_S_NO_MORE_MEMBERS,

    RPC_NT_NOT_ALL_OBJS_UNEXPORTED, RPC_S_NOT_ALL_OBJS_UNEXPORTED,

    RPC_NT_INTERFACE_NOT_FOUND, RPC_S_INTERFACE_NOT_FOUND,

    RPC_NT_ENTRY_ALREADY_EXISTS, RPC_S_ENTRY_ALREADY_EXISTS,

    RPC_NT_ENTRY_NOT_FOUND, RPC_S_ENTRY_NOT_FOUND,

    RPC_NT_NAME_SERVICE_UNAVAILABLE, RPC_S_NAME_SERVICE_UNAVAILABLE,

    RPC_NT_INVALID_NAF_ID, RPC_S_INVALID_NAF_ID,

    RPC_NT_CANNOT_SUPPORT, RPC_S_CANNOT_SUPPORT,

    RPC_NT_NO_CONTEXT_AVAILABLE, RPC_S_NO_CONTEXT_AVAILABLE,

    RPC_NT_INTERNAL_ERROR, RPC_S_INTERNAL_ERROR,

    RPC_NT_ZERO_DIVIDE, RPC_S_ZERO_DIVIDE,

    RPC_NT_ADDRESS_ERROR, RPC_S_ADDRESS_ERROR,

    RPC_NT_FP_DIV_ZERO, RPC_S_FP_DIV_ZERO,

    RPC_NT_FP_UNDERFLOW, RPC_S_FP_UNDERFLOW,

    RPC_NT_FP_OVERFLOW, RPC_S_FP_OVERFLOW,

    RPC_NT_NO_MORE_ENTRIES, RPC_X_NO_MORE_ENTRIES,

    RPC_NT_SS_CHAR_TRANS_OPEN_FAIL, RPC_X_SS_CHAR_TRANS_OPEN_FAIL,

    RPC_NT_SS_CHAR_TRANS_SHORT_FILE, RPC_X_SS_CHAR_TRANS_SHORT_FILE,

    RPC_NT_SS_CONTEXT_MISMATCH, ERROR_INVALID_HANDLE,

    RPC_NT_SS_CONTEXT_DAMAGED, RPC_X_SS_CONTEXT_DAMAGED,

    RPC_NT_SS_HANDLES_MISMATCH, RPC_X_SS_HANDLES_MISMATCH,

    RPC_NT_SS_CANNOT_GET_CALL_HANDLE, RPC_X_SS_CANNOT_GET_CALL_HANDLE,

    RPC_NT_NULL_REF_POINTER, RPC_X_NULL_REF_POINTER,

    RPC_NT_ENUM_VALUE_OUT_OF_RANGE, RPC_X_ENUM_VALUE_OUT_OF_RANGE,

    RPC_NT_BYTE_COUNT_TOO_SMALL, RPC_X_BYTE_COUNT_TOO_SMALL,

    RPC_NT_BAD_STUB_DATA, RPC_X_BAD_STUB_DATA,

    RPC_NT_INVALID_OBJECT, RPC_S_INVALID_OBJECT,

    STATUS_NO_TRUST_LSA_SECRET, ERROR_NO_TRUST_LSA_SECRET,

    STATUS_NO_TRUST_SAM_ACCOUNT, ERROR_NO_TRUST_SAM_ACCOUNT,

    STATUS_TRUSTED_DOMAIN_FAILURE, ERROR_TRUSTED_DOMAIN_FAILURE,

    STATUS_TRUSTED_RELATIONSHIP_FAILURE, ERROR_TRUSTED_RELATIONSHIP_FAILURE,

    STATUS_TRUST_FAILURE, ERROR_TRUST_FAILURE,

    RPC_NT_CALL_IN_PROGRESS, RPC_S_CALL_IN_PROGRESS,

    STATUS_LOG_FILE_FULL, ERROR_LOG_FILE_FULL,

    STATUS_EVENTLOG_FILE_CHANGED, ERROR_EVENTLOG_FILE_CHANGED,

    STATUS_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT, ERROR_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT,

    STATUS_NOLOGON_WORKSTATION_TRUST_ACCOUNT, ERROR_NOLOGON_WORKSTATION_TRUST_ACCOUNT,

    STATUS_NOLOGON_SERVER_TRUST_ACCOUNT, ERROR_NOLOGON_SERVER_TRUST_ACCOUNT,

    STATUS_DOMAIN_TRUST_INCONSISTENT, ERROR_DOMAIN_TRUST_INCONSISTENT,

    STATUS_NO_USER_SESSION_KEY, ERROR_NO_USER_SESSION_KEY,

    STATUS_POSSIBLE_DEADLOCK, ERROR_POSSIBLE_DEADLOCK,

    STATUS_IMAGE_ALREADY_LOADED, ERROR_SERVICE_ALREADY_RUNNING,

    RPC_NT_GROUP_MEMBER_NOT_FOUND, RPC_S_GROUP_MEMBER_NOT_FOUND,

    RPC_NT_NO_INTERFACES, RPC_S_NO_INTERFACES,

    RPC_NT_CALL_CANCELLED, RPC_S_CALL_CANCELLED,

    RPC_NT_BINDING_INCOMPLETE, RPC_S_BINDING_INCOMPLETE,

    RPC_NT_COMM_FAILURE, RPC_S_COMM_FAILURE,

    RPC_NT_UNSUPPORTED_AUTHN_LEVEL, RPC_S_UNSUPPORTED_AUTHN_LEVEL,

    RPC_NT_NO_PRINC_NAME, RPC_S_NO_PRINC_NAME,

    RPC_NT_NOT_RPC_ERROR, RPC_S_NOT_RPC_ERROR,

    RPC_NT_UUID_LOCAL_ONLY, RPC_S_UUID_LOCAL_ONLY,

    RPC_NT_SEC_PKG_ERROR, RPC_S_SEC_PKG_ERROR,

    RPC_NT_NOT_CANCELLED, RPC_S_NOT_CANCELLED,

    RPC_NT_INVALID_ES_ACTION, RPC_X_INVALID_ES_ACTION,
    RPC_NT_WRONG_ES_VERSION, RPC_X_WRONG_ES_VERSION,
    RPC_NT_WRONG_STUB_VERSION, RPC_X_WRONG_STUB_VERSION,

    EPT_NT_CANT_CREATE,            EPT_S_CANT_CREATE,

    RPC_NT_SEND_INCOMPLETE,        RPC_S_SEND_INCOMPLETE,
    RPC_NT_INVALID_ASYNC_HANDLE,   RPC_S_INVALID_ASYNC_HANDLE,
    RPC_NT_INVALID_ASYNC_CALL,     RPC_S_INVALID_ASYNC_CALL,
    RPC_NT_PIPE_CLOSED,            RPC_X_PIPE_CLOSED,
    RPC_NT_PIPE_EMPTY,             RPC_X_PIPE_EMPTY,
    RPC_NT_PIPE_DISCIPLINE_ERROR,  RPC_X_PIPE_DISCIPLINE_ERROR,

    STATUS_NO_BROWSER_SERVERS_FOUND, ERROR_NO_BROWSER_SERVERS_FOUND,

    STATUS_MAPPED_ALIGNMENT, ERROR_MAPPED_ALIGNMENT,

    STATUS_CONNECTION_IN_USE, ERROR_DEVICE_IN_USE,

    STATUS_VERIFY_REQUIRED, ERROR_MEDIA_CHANGED,

    STATUS_ALREADY_DISCONNECTED, ERROR_ACTIVE_CONNECTIONS,

    STATUS_CONNECTION_REFUSED, ERROR_CONNECTION_REFUSED,

    STATUS_GRACEFUL_DISCONNECT, ERROR_GRACEFUL_DISCONNECT,

    STATUS_ADDRESS_ALREADY_ASSOCIATED, ERROR_ADDRESS_ALREADY_ASSOCIATED,

    STATUS_ADDRESS_NOT_ASSOCIATED, ERROR_ADDRESS_NOT_ASSOCIATED,

    STATUS_CONNECTION_INVALID, ERROR_CONNECTION_INVALID,

    STATUS_CONNECTION_ACTIVE, ERROR_CONNECTION_ACTIVE,

    STATUS_NETWORK_UNREACHABLE, ERROR_NETWORK_UNREACHABLE,

    STATUS_HOST_UNREACHABLE, ERROR_HOST_UNREACHABLE,

    STATUS_PROTOCOL_UNREACHABLE, ERROR_PROTOCOL_UNREACHABLE,

    STATUS_PORT_UNREACHABLE, ERROR_PORT_UNREACHABLE,

    STATUS_REQUEST_ABORTED, ERROR_REQUEST_ABORTED,

    STATUS_CONNECTION_ABORTED, ERROR_CONNECTION_ABORTED,

    STATUS_CONNECTION_COUNT_LIMIT, ERROR_CONNECTION_COUNT_LIMIT,

    STATUS_PATH_NOT_COVERED, ERROR_HOST_UNREACHABLE,

    STATUS_LOGIN_TIME_RESTRICTION, ERROR_LOGIN_TIME_RESTRICTION,
    STATUS_LOGIN_WKSTA_RESTRICTION, ERROR_LOGIN_WKSTA_RESTRICTION,
    STATUS_LICENSE_QUOTA_EXCEEDED, ERROR_LICENSE_QUOTA_EXCEEDED,

    STATUS_RESOURCE_NOT_OWNED, ERROR_NOT_OWNER,

    STATUS_DUPLICATE_OBJECTID, STATUS_DUPLICATE_OBJECTID,
    STATUS_OBJECTID_EXISTS, STATUS_OBJECTID_EXISTS,

    STATUS_DS_MEMBERSHIP_EVALUATED_LOCALLY,ERROR_DS_MEMBERSHIP_EVALUATED_LOCALLY,

    STATUS_DS_NO_ATTRIBUTE_OR_VALUE,ERROR_DS_NO_ATTRIBUTE_OR_VALUE,

    STATUS_DS_INVALID_ATTRIBUTE_SYNTAX,ERROR_DS_INVALID_ATTRIBUTE_SYNTAX,

    STATUS_DS_ATTRIBUTE_TYPE_UNDEFINED,ERROR_DS_ATTRIBUTE_TYPE_UNDEFINED,

    STATUS_DS_ATTRIBUTE_OR_VALUE_EXISTS,ERROR_DS_ATTRIBUTE_OR_VALUE_EXISTS,

    STATUS_DS_BUSY,ERROR_DS_BUSY,

    STATUS_DS_UNAVAILABLE,ERROR_DS_UNAVAILABLE,

    STATUS_DS_NO_RIDS_ALLOCATED,ERROR_DS_NO_RIDS_ALLOCATED,

    STATUS_DS_NO_MORE_RIDS,ERROR_DS_NO_MORE_RIDS,

    STATUS_DS_INCORRECT_ROLE_OWNER,ERROR_DS_INCORRECT_ROLE_OWNER,

    STATUS_DS_RIDMGR_INIT_ERROR,ERROR_DS_RIDMGR_INIT_ERROR,

    STATUS_DS_OBJ_CLASS_VIOLATION,ERROR_DS_OBJ_CLASS_VIOLATION,

    STATUS_DS_CANT_ON_NON_LEAF,ERROR_DS_CANT_ON_NON_LEAF,

    STATUS_DS_CANT_ON_RDN,ERROR_DS_CANT_ON_RDN,

    STATUS_DS_CROSS_DOM_MOVE_FAILED,ERROR_DS_CROSS_DOM_MOVE_ERROR,

    STATUS_DS_GC_NOT_AVAILABLE,ERROR_DS_GC_NOT_AVAILABLE,

    STATUS_SHARED_POLICY,ERROR_SHARED_POLICY,

    STATUS_POLICY_OBJECT_NOT_FOUND,ERROR_POLICY_OBJECT_NOT_FOUND,

    STATUS_POLICY_ONLY_IN_DS,ERROR_POLICY_ONLY_IN_DS,

    STATUS_DEVICE_REMOVED,ERROR_DEVICE_REMOVED,

    // Terminal Server Entries

    STATUS_CTX_CLOSE_PENDING,               ERROR_CTX_CLOSE_PENDING,
    STATUS_CTX_NO_OUTBUF,                   ERROR_CTX_NO_OUTBUF,
    STATUS_CTX_MODEM_INF_NOT_FOUND,         ERROR_CTX_MODEM_INF_NOT_FOUND,
    STATUS_CTX_INVALID_MODEMNAME,           ERROR_CTX_INVALID_MODEMNAME,
    STATUS_CTX_RESPONSE_ERROR,              ERROR_CTX_MODEM_RESPONSE_ERROR,
    STATUS_CTX_MODEM_RESPONSE_TIMEOUT,      ERROR_CTX_MODEM_RESPONSE_TIMEOUT,
    STATUS_CTX_MODEM_RESPONSE_NO_CARRIER,   ERROR_CTX_MODEM_RESPONSE_NO_CARRIER,
    STATUS_CTX_MODEM_RESPONSE_NO_DIALTONE,  ERROR_CTX_MODEM_RESPONSE_NO_DIALTONE,
    STATUS_CTX_MODEM_RESPONSE_BUSY,         ERROR_CTX_MODEM_RESPONSE_BUSY,
    STATUS_CTX_MODEM_RESPONSE_VOICE,        ERROR_CTX_MODEM_RESPONSE_VOICE,
    STATUS_CTX_TD_ERROR,                    ERROR_CTX_TD_ERROR,
    STATUS_LPC_REPLY_LOST,                  ERROR_CONNECTION_ABORTED,
    STATUS_CTX_WINSTATION_NAME_INVALID,     ERROR_CTX_WINSTATION_NAME_INVALID,
    STATUS_CTX_WINSTATION_NOT_FOUND,        ERROR_CTX_WINSTATION_NOT_FOUND,
    STATUS_CTX_WINSTATION_NAME_COLLISION,   ERROR_CTX_WINSTATION_ALREADY_EXISTS,
    STATUS_CTX_WINSTATION_BUSY,             ERROR_CTX_WINSTATION_BUSY,
    STATUS_CTX_GRAPHICS_INVALID,            ERROR_CTX_GRAPHICS_INVALID,
    STATUS_CTX_BAD_VIDEO_MODE,              ERROR_CTX_BAD_VIDEO_MODE,
    STATUS_CTX_NOT_CONSOLE,                 ERROR_CTX_NOT_CONSOLE,
    STATUS_CTX_CLIENT_QUERY_TIMEOUT,        ERROR_CTX_CLIENT_QUERY_TIMEOUT,
    STATUS_CTX_CONSOLE_DISCONNECT,          ERROR_CTX_CONSOLE_DISCONNECT,
    STATUS_CTX_CONSOLE_CONNECT,             ERROR_CTX_CONSOLE_CONNECT,
    STATUS_CTX_SHADOW_DENIED,               ERROR_CTX_SHADOW_DENIED,
    STATUS_CTX_SHADOW_INVALID,              ERROR_CTX_SHADOW_INVALID,
    STATUS_CTX_SHADOW_DISABLED,             ERROR_CTX_SHADOW_DISABLED,
    STATUS_CTX_WINSTATION_ACCESS_DENIED,    ERROR_CTX_WINSTATION_ACCESS_DENIED,
    STATUS_CTX_INVALID_PD,                  ERROR_CTX_INVALID_PD,
    STATUS_CTX_PD_NOT_FOUND,                ERROR_CTX_PD_NOT_FOUND,
    STATUS_CTX_INVALID_WD,                  ERROR_CTX_INVALID_WD,
    STATUS_CTX_WD_NOT_FOUND,                ERROR_CTX_WD_NOT_FOUND,

    0xffffffff, 0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\ifdtest\ifdtest.cpp ===
#include <stdarg.h>
#include <stdio.h>
#include <string.h>
#include <conio.h>

#include <afx.h>
#include <afxtempl.h>

#include <winioctl.h>
#include <winsmcrd.h>

#include "ifdtest.h"

class CCardProvider *CCardProvider::s_pFirst;

#define INSERT_CARD "Please insert smart card"
#define REMOVE_CARD "Please remove smart card"

PCHAR
CAtr::GetAtrString(
    PCHAR in_pchBuffer
    )
{
    for (ULONG i = 0; i < m_uAtrLength; i++) {

        sprintf(in_pchBuffer + i * 3, "%02X ", m_rgbAtr[i]);
    }

    return in_pchBuffer;
}

CCardProvider::CCardProvider(
    void
    )
{
    m_pNext = NULL;
    m_uTestNo = 0;
    m_bCardTested = FALSE;
    m_bTestFailed = FALSE;
    m_pSetProtocol = NULL;
    m_pCardTest = NULL;
}

CCardProvider::CCardProvider(
    void (*in_pEntryFunction)(class CCardProvider&)
    )
/*++

Routine Description:
   Constructor for class CCardProvider.
    This constructor is called for every card that is to be tested.
    It creates a new instance and appends it to a singly linked list

Arguments:

    Pointer to function that registers all test functions

--*/
{
    class CCardProvider *l_pCardProvider;

    *this = CCardProvider();

    if (s_pFirst == NULL) {

        s_pFirst = new CCardProvider;
        l_pCardProvider = s_pFirst;

    } else {

        l_pCardProvider = s_pFirst;

        while (l_pCardProvider->m_pNext) {

            l_pCardProvider = l_pCardProvider->m_pNext;
        }

        l_pCardProvider->m_pNext = new CCardProvider;
        l_pCardProvider = l_pCardProvider->m_pNext;
    }

    (*in_pEntryFunction)(*l_pCardProvider);
}

BOOL
CCardProvider::CardsUntested(
    void
    )
{
    class CCardProvider *l_pCCardProvider = s_pFirst;

    while (l_pCCardProvider) {

        if (l_pCCardProvider->m_bCardTested == FALSE) {

            return TRUE;
        }

        l_pCCardProvider = l_pCCardProvider->m_pNext;
    }

    return FALSE;
}

void
CCardProvider::CardTest(
    class CReader& io_pCReader,
    ULONG in_uTestNo
    )
/*++

Routine Description:

    Calls every registered card provider in the list until one of
    the providers indicates that it recognized the card

Arguments:

    io_pCReader - reference to the test structure

Return Value:

    IFDSTATUS value

--*/
{
    class CCardProvider *l_pCCardProvider = s_pFirst;
    ULONG l_uStatus;

    while (l_pCCardProvider) {

        if ( l_pCCardProvider->IsValidAtr(io_pCReader.GetAtr()) ) {

            if (l_pCCardProvider->m_bCardTested) {

                // We tested this card already
                LogMessage("Card has been tested already. Please remove the card");
                return;
            }

            l_pCCardProvider->m_bCardTested = TRUE;
            LogMessage(
                "\nTesting card %s",
                (LPCSTR) l_pCCardProvider->m_CCardName
                );

            if (l_pCCardProvider->m_pSetProtocol == NULL) {

                return;
            }

            // Call card provider function
            l_uStatus = (*l_pCCardProvider->m_pSetProtocol)(
                *l_pCCardProvider,
                io_pCReader
                );

            if (l_uStatus == IFDSTATUS_END) {

                return;
            }

            if (l_uStatus != IFDSTATUS_SUCCESS) {

                return;
            }

            // Check if the card test function pointer exists
            if (l_pCCardProvider->m_pCardTest == NULL) {

                return;
            }

            if (in_uTestNo) {

            // user wants to run only a single test
                l_pCCardProvider->m_uTestNo = in_uTestNo;

                LogMessage("Test No. %2d", l_pCCardProvider->m_uTestNo);

                // Call card provider function
                l_uStatus = (*l_pCCardProvider->m_pCardTest)(
                    *l_pCCardProvider,
                    io_pCReader
                    );

                return;
            }

         // run the whole test set
            for (l_pCCardProvider->m_uTestNo = 1; ;l_pCCardProvider->m_uTestNo++) {

                LogMessage("Test No. %2d", l_pCCardProvider->m_uTestNo);

                // Call card provider function
                l_uStatus = (*l_pCCardProvider->m_pCardTest)(
                    *l_pCCardProvider,
                    io_pCReader
                    );

                if (l_uStatus != IFDSTATUS_SUCCESS) {

                    return;
                }
            }
        }
        l_pCCardProvider = l_pCCardProvider->m_pNext;
    }

    PCHAR l_rgbAtrBuffer = new CHAR[256];

    LogMessage("Card unknown!");
    LogMessage("       CURRENT CARD");
    LogMessage("       %s", io_pCReader.GetAtrString(l_rgbAtrBuffer));

    for (l_pCCardProvider = s_pFirst;
         l_pCCardProvider;
         l_pCCardProvider = l_pCCardProvider->m_pNext) {

        if (l_pCCardProvider->m_bCardTested == FALSE) {

            LogMessage("    *  %s", (LPCSTR) l_pCCardProvider->m_CCardName);
            for (int i = 0; i < MAX_NUM_ATR && l_pCCardProvider->m_CAtr[i].GetLength(); i++) {
        
                LogMessage("       %s", l_pCCardProvider->m_CAtr[i].GetAtrString(l_rgbAtrBuffer));
            }
        }
    }

   delete l_rgbAtrBuffer;

    LogMessage("Please remove card");
}

void
CCardProvider::ListUntestedCards(
    void
    )
/*++

Routine Description:
    Prints a list of all cards that have not been tested

--*/
{
    class CCardProvider *l_pCCardProvider = s_pFirst;

    while (l_pCCardProvider) {

        if (l_pCCardProvider->m_bCardTested == FALSE) {

            LogMessage("    *  %s", (LPCSTR) l_pCCardProvider->m_CCardName);
        }

        l_pCCardProvider = l_pCCardProvider->m_pNext;
    }
}

void
CCardProvider::SetAtr(
    BYTE in_rgbAtr[],
    ULONG in_uAtrLength
    )
/*++

Routine Description:
   Sets the ATR of the card

Arguments:
    in_rgchAtr - the atr string
    in_uAtrLength - length of the atr

--*/
{
    for (int i = 0; i < MAX_NUM_ATR; i++) {

        if (m_CAtr[i].GetLength() == 0) {

           m_CAtr[i] = CAtr(in_rgbAtr, in_uAtrLength);
           return;
        }
    }
}

void
CCardProvider::SetCardName(
    CHAR in_rgchCardName[]
    )
/*++

Routine Description:
    Sets a friendly name for the card

Arguments:
    in_rgchCardName - Friendly name for the card

--*/
{
    m_CCardName = in_rgchCardName;
}

void
CheckCardMonitor(
    CReader &in_CReader
    )
{
    ULONG l_lResult, l_uReplyLength, l_lTestNo = 1;
    time_t l_lStartTime;
    BOOL l_bResult;
    OVERLAPPED l_Ovr;
    HANDLE l_hReader = in_CReader.GetHandle();

    l_Ovr.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    ResetEvent(l_Ovr.hEvent);

    LogMessage("=============================");
    LogMessage("Part A: Checking card monitor");
    LogMessage("=============================");

    LogMessage("   <<  %s", REMOVE_CARD);
    in_CReader.WaitForCardRemoval();
    TestStart("%2d. %s", l_lTestNo++, INSERT_CARD);
    l_lResult = in_CReader.WaitForCardInsertion();
    TEST_CHECK_SUCCESS("Reader failed card insertion monitor", l_lResult);
    TestEnd();

    TestStart("%2d. IOCTL_SMARTCARD_IS_PRESENT", l_lTestNo++);
      l_bResult = DeviceIoControl (
        l_hReader,
      IOCTL_SMARTCARD_IS_PRESENT,
      NULL,
      0,
      NULL,
      0,
      &l_uReplyLength,
      &l_Ovr
        );

    TestCheck(
        l_bResult == TRUE,
        "DeviceIoControl should return TRUE with card inserted"
        );
    TestEnd();

    TestStart("%2d. %s", l_lTestNo++, REMOVE_CARD);
    l_lResult = in_CReader.WaitForCardRemoval();
    TEST_CHECK_SUCCESS("Reader failed card removal monitor", l_lResult);
    TestEnd();

    TestStart("%2d. IOCTL_SMARTCARD_IS_ABSENT", l_lTestNo++);
      l_bResult = DeviceIoControl (
        l_hReader,
      IOCTL_SMARTCARD_IS_ABSENT,
      NULL,
      0,
      NULL,
      0,
      &l_uReplyLength,
      &l_Ovr
        );

    TestCheck(
        l_bResult == TRUE,
        "DeviceIoControl should return TRUE with card removed"
        );
    TestEnd();

    TestStart("%2d. Insert and remove a smart card repeatedly", l_lTestNo++);

    for (l_lStartTime = time(NULL); time(NULL) - l_lStartTime < 15;) {

        l_lResult = in_CReader.ColdResetCard();
#ifdef insert_remove_alternate
          l_bResult = DeviceIoControl (
            l_hReader,
          IOCTL_SMARTCARD_IS_PRESENT,
          NULL,
          0,
          NULL,
          0,
          &l_uReplyLength,
          &l_Ovr
            );

        SetLastError(0);

        l_bResult = GetOverlappedResult(
            l_hReader,
            &l_Ovr,
            &l_uReplyLength,
            FALSE
            );

        l_lResult = GetLastError();

        TestCheck(
            l_bResult == TRUE && l_lResult == ERROR_SUCCESS ||
            l_bResult == FALSE &&
            (l_lResult == ERROR_IO_INCOMPLETE ||
             l_lResult == ERROR_BUSY ||
             l_lResult == ERROR_IO_PENDING),
            "Reader failed card insertion monitor.\nReturned %2lxH",
            l_lResult
            );

          l_bResult = DeviceIoControl (
            l_hReader,
          IOCTL_SMARTCARD_IS_ABSENT,
          NULL,
          0,
          NULL,
          0,
          &l_uReplyLength,
          &l_Ovr
            );

        SetLastError(0);

        l_bResult = GetOverlappedResult(
            l_hReader,
            &l_Ovr,
            &l_uReplyLength,
            FALSE
            );

        l_lResult = GetLastError();

        TestCheck(
            l_bResult == TRUE && l_lResult == ERROR_SUCCESS ||
            l_bResult == FALSE &&
            (l_lResult == ERROR_IO_INCOMPLETE ||
             l_lResult == ERROR_BUSY ||
             l_lResult == ERROR_IO_PENDING),
            "Reader failed card removal monitor:\nReturned %2lxH",
            l_lResult
            );
#endif
    }
#ifdef insert_remove_alternate
    l_bResult = GetOverlappedResult(
        l_hReader,
        &l_Ovr,
        &l_uReplyLength,
        TRUE
        );
#endif
    TestEnd();

    LogMessage("Press any key to continue");
    _getch();

    if (ReaderFailed()) {

        exit(-1);
    }
}

void
CheckReader(
    CReader &in_CReader
    )
/*++

Routine Description:

    Checks the attributes of a reader.
    Once with card inserted and then without

Arguments:

Return Value:

--*/
{
    BOOL l_bResult;
    ULONG l_iIndex, l_uReplyLength, l_lTestNo = 1, l_uStart, l_uEnd;
    OVERLAPPED l_Ovr;
    UCHAR l_rgbReplyBuffer[512];
    HANDLE l_hReader = in_CReader.GetHandle();

    l_Ovr.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    ResetEvent(l_Ovr.hEvent);

#define ATTR(x) #x, x

    struct {

        PCHAR m_pchName;
        ULONG m_uType;

    } l_aAttr[] = {

        ATTR(SCARD_ATTR_VENDOR_NAME),
        ATTR(SCARD_ATTR_VENDOR_IFD_TYPE),
        ATTR(SCARD_ATTR_DEVICE_UNIT),
        ATTR(SCARD_ATTR_ATR_STRING),
        ATTR(SCARD_ATTR_DEFAULT_CLK),
        ATTR(SCARD_ATTR_MAX_CLK),
        ATTR(SCARD_ATTR_DEFAULT_DATA_RATE),
        ATTR(SCARD_ATTR_MAX_DATA_RATE),
        ATTR(SCARD_ATTR_MAX_IFSD),
        ATTR(SCARD_ATTR_CURRENT_PROTOCOL_TYPE),
        ATTR(SCARD_ATTR_PROTOCOL_TYPES),
        0, 0,
        ATTR(SCARD_ATTR_ATR_STRING),
        ATTR(SCARD_ATTR_CURRENT_PROTOCOL_TYPE)
    };

    LogMessage("=======================");
    LogMessage("Part B: Checking reader");
    LogMessage("=======================");

    BOOL l_bCardInserted = FALSE;
    LogMessage("   <<  %s", REMOVE_CARD);
    in_CReader.WaitForCardRemoval();

    TestStart("%2d. Device name", l_lTestNo++);

    CString l_COperatingSystem = GetOperatingSystem();

    if (l_COperatingSystem == OS_WINNT4) {

        TestCheck(
            in_CReader.GetDeviceName().Left(12) == "\\\\.\\SCReader",
            "Device name is not NT 4.0 compliant"
            );

    } else if (l_COperatingSystem == OS_WIN95 ||
               l_COperatingSystem == OS_WIN98) {

        // there is no special naming convention for Win9x

    } else {

        TestCheck(
            in_CReader.GetDeviceName().Find("{50dd5230-ba8a-11d1-bf5d-0000f805f530}") != -1,
            "Device name is not WDM PnP compliant"
            );
    }
    TestEnd();

    TestStart(
        "%2d. Null pointer check",
        l_lTestNo++
        );

    for (l_iIndex = 0; l_aAttr[l_iIndex].m_pchName; l_iIndex++) {

      // try to crash reader by using null pointers as arguments
       l_bResult = DeviceIoControl (
          l_hReader,
          IOCTL_SMARTCARD_GET_ATTRIBUTE,
          &l_aAttr[l_iIndex].m_uType,
            sizeof(ULONG),
            NULL,
            1000,
           &l_uReplyLength,
          &l_Ovr
            );

        ULONG l_lResult = GetLastError();

        TestCheck(
            l_lResult == ERROR_INSUFFICIENT_BUFFER ||
            l_lResult == ERROR_BAD_COMMAND,
            "IOCTL_SMARTCARD_GET_ATTRIBUTE (%lxh) should fail\nReturned %2lxH (NTSTATUS %lxH)\nExpected %2lxH (NTSTATUS %lxH)\nor       %2lxH (NTSTATUS %lxH)",
            l_aAttr[l_iIndex].m_uType & 0xFFFF,
            l_lResult,
            MapWinErrorToNtStatus(l_lResult),
            ERROR_INSUFFICIENT_BUFFER,
            MapWinErrorToNtStatus(ERROR_BAD_COMMAND),
            ERROR_BAD_COMMAND,
            MapWinErrorToNtStatus(ERROR_BAD_COMMAND)
            );
   }
    TestEnd();

    for (l_iIndex = 0; l_iIndex < sizeof(l_aAttr) / sizeof(l_aAttr[0]); l_iIndex++) {

        if (l_aAttr[l_iIndex].m_pchName == 0) {

            TestStart("%2d. Close driver with I/O-request still pending", l_lTestNo++);

            // Check if the reader correctly terminates pending io-requests
              l_bResult = DeviceIoControl (
                l_hReader,
              IOCTL_SMARTCARD_IS_PRESENT,
              NULL,
              0,
              NULL,
              0,
              &l_uReplyLength,
              &l_Ovr
                );

            TestCheck(
                l_bResult == FALSE,
                "Wait for present succeeded with no card inserted"
                );

            // With the pending i/o request close and re-open the driver
            in_CReader.Close();
            l_bResult = in_CReader.Open();

            TestCheck(
                l_bResult,
                "Reader failed to terminate pending i/o request"
                );

            TestEnd();

            if (TestFailed()) {

                // If the open failed we can't contiue
                exit(GetLastError());
            }

            l_hReader = in_CReader.GetHandle();

            LogMessage("   >>  Please insert 'IBM PC/SC Compliance Test Card'");
            in_CReader.WaitForCardInsertion();
            l_bCardInserted = TRUE;

            // Cold reset
            TestStart("%2d. Cold reset", l_lTestNo++);
         l_uStart = clock();
            LONG l_lResult = in_CReader.ColdResetCard();
         l_uEnd = clock();
            TEST_CHECK_SUCCESS("Cold reset failed", l_lResult);
         TestCheck(
            (l_uEnd - l_uStart) / CLOCKS_PER_SEC <= 2,
            "Cold reset took too long.\nElapsed time %ld sec\nExpected time %ld sec",
            (l_uEnd - l_uStart) / CLOCKS_PER_SEC,
            2
            );
            TestEnd();

            if (TestFailed()) {

                exit(l_lResult);
            }

            // Set protocol
            TestStart("%2d. Set protocol to T0 | T1", l_lTestNo++);
            l_lResult = in_CReader.SetProtocol(
                SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1
                );
            TEST_CHECK_SUCCESS("Set protocol failed", l_lResult);
            TestEnd();
            continue;
        }

        TestStart("%2d. %s", l_lTestNo++, l_aAttr[l_iIndex].m_pchName);

        SetLastError(0);
        *(PULONG) l_rgbReplyBuffer = 0;

       l_bResult = DeviceIoControl (
          l_hReader,
          IOCTL_SMARTCARD_GET_ATTRIBUTE,
          &l_aAttr[l_iIndex].m_uType,
            sizeof(ULONG),
            l_rgbReplyBuffer,
            sizeof(l_rgbReplyBuffer),
          &l_uReplyLength,
          &l_Ovr
            );

        if (l_bResult == FALSE && GetLastError() == ERROR_IO_PENDING) {

            //
            // The I/O request returned pending, so
            // wait until the request is finished
            //
            SetLastError(0);

            l_bResult = GetOverlappedResult(
                l_hReader,
                &l_Ovr,
                &l_uReplyLength,
                TRUE
                );
        }

        if (GetLastError() != ERROR_SUCCESS) {

            l_bResult = FALSE;

        } else {

            l_rgbReplyBuffer[l_uReplyLength] = 0;
        }

        LONG l_lResult = GetLastError();

        switch (l_aAttr[l_iIndex].m_uType) {

            case SCARD_ATTR_VENDOR_NAME:
                TEST_CHECK_SUCCESS(
                    "Ioctl SCARD_ATTR_VENDOR_NAME failed",
                    l_lResult
                    );
            TestCheck(
               strlen((PCHAR) l_rgbReplyBuffer) != 0,
               "No vendor name defined"
               );
                TestEnd();
               break;

            case SCARD_ATTR_VENDOR_IFD_TYPE:
                TEST_CHECK_SUCCESS(
                    "Ioctl SCARD_ATTR_VENDOR_IFD_TYPE failed",
                    l_lResult
                    );
            TestCheck(
               strlen((PCHAR) l_rgbReplyBuffer) != 0,
               "No ifd type defined"
               );
                TestEnd();
               break;

            case SCARD_ATTR_DEVICE_UNIT:
                TEST_CHECK_SUCCESS(
                    "Ioctl SCARD_ATTR_DEVICE_UNIT failed",
                    l_lResult
                    );
                TestCheck(
                    *(PULONG) l_rgbReplyBuffer < 4,
                    "Invalid value: %ld (0 - 3)",
                    *(PULONG) l_rgbReplyBuffer
                    );
                TestEnd();
               break;

            case SCARD_ATTR_ATR_STRING:
                if (l_bCardInserted) {

                    TEST_CHECK_SUCCESS(
                        "Ioctl SCARD_ATTR_ATR_STRING failed",
                        l_lResult
                        );

                } else {

                    TestCheck(
                        l_bResult == FALSE,
                        "Reader returned ATR with no card inserted"
                        );
                }
                TestEnd();
               break;

            case SCARD_ATTR_DEFAULT_CLK:
            case SCARD_ATTR_MAX_CLK:
                TEST_CHECK_SUCCESS(
                    "Ioctl SCARD_ATTR_DEFAULT_CLK/SCARD_ATTR_MAX_CLK failed",
                    l_lResult
                    );
                TestCheck(
                    *(PULONG) l_rgbReplyBuffer >= 1000 && *(PULONG) l_rgbReplyBuffer <= 20000,
                    "Invalid value %ld (1000 - 20000)",
                    *(PULONG) l_rgbReplyBuffer
                    );
                TestEnd();
               break;

            case SCARD_ATTR_DEFAULT_DATA_RATE:
            case SCARD_ATTR_MAX_DATA_RATE:
                TEST_CHECK_SUCCESS(
                    "Ioctl SCARD_ATTR_DEFAULT_DATA_RATE/SCARD_ATTR_MAX_DATA_RATE failed",
                    l_lResult
                    );
                TestEnd();
               break;

            case SCARD_ATTR_MAX_IFSD:
                TEST_CHECK_SUCCESS(
                    "Ioctl SCARD_ATTR_MAX_IFSD failed",
                    l_lResult
                    );
                TestCheck(
                    *(PULONG) l_rgbReplyBuffer >= 1 && *(PULONG) l_rgbReplyBuffer <= 254,
                    "Invalid value: %ld (1 - 254)",
                    *(PULONG) l_rgbReplyBuffer
                    );
                TestEnd();
               break;

            case SCARD_ATTR_PROTOCOL_TYPES:
                TEST_CHECK_SUCCESS(
                    "Ioctl SCARD_ATTR_PROTOCOL_TYPES failed",
                    l_lResult
                    );

                // check if the reader at least supports T=0 and T=1
                TestCheck(
                    (*(PULONG) l_rgbReplyBuffer & SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1) ==
                    (SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1),
                    "Reader must support T=0 and T=1"
                    );
                TestEnd();
                break;

            case SCARD_ATTR_CURRENT_PROTOCOL_TYPE:

                if (l_bCardInserted) {

                    TEST_CHECK_SUCCESS(
                        "Ioctl SCARD_ATTR_CURRENT_PROTOCOL_TYPE failed",
                        l_lResult
                        );

                    TestCheck(
                        *(PULONG) l_rgbReplyBuffer != 0,
                        "Reader returned no protocol"
                        );

                } else {

                    // Check that without a card the current protocol is set to 0
                    TestCheck(
                        l_bResult == FALSE,
                        "Ioctl SCARD_ATTR_CURRENT_PROTOCOL_TYPE failed should fail with no card inserted"
                        );
                }
                TestEnd();
                break;

            default:
                TestCheck(
                    l_bResult,
                    "Ioctl returned %lxh",
                    GetLastError()
                    );
                TestEnd();
                break;
        }
    }

    LogMessage("   <<  %s", REMOVE_CARD);
    in_CReader.WaitForCardRemoval();
    LogMessage("   <<  Please insert smart card BACKWARDS");
    in_CReader.WaitForCardInsertion();

    TestStart("%2d. IOCTL_SMARTCARD_GET_STATE", l_lTestNo++);
    ULONG l_uState;

   l_bResult = DeviceIoControl (
      l_hReader,
      IOCTL_SMARTCARD_GET_STATE,
      NULL,
        0,
        &l_uState,
        sizeof(l_uState),
      &l_uReplyLength,
      &l_Ovr
        );

    LONG l_lResult = GetLastError();

    TestCheck(
        l_bResult,
        "IOCTL_SMARTCARD_GET_STATE failed.\nReturned %8lxH (NTSTATUS %8lxH).\nExpected %8lxH (NTSTATUS %8lxH)",
        l_lResult,
        MapWinErrorToNtStatus(l_lResult),
        ERROR_SUCCESS,
        MapWinErrorToNtStatus(ERROR_SUCCESS)
        );

    TestCheck(
        l_uState <= SCARD_SWALLOWED,
        "Invalid reader state.\nReturned %d\nExpected <= %d",
        l_uState,
        SCARD_SWALLOWED
        );

    TestEnd();

    TestStart("%2d. Cold reset", l_lTestNo++);
   l_uStart = clock();
    l_lResult = in_CReader.ColdResetCard();
   l_uEnd = clock();

    TestCheck(
        l_lResult == ERROR_UNRECOGNIZED_MEDIA,
        "Cold reset failed.\nReturned %8lxH (NTSTATUS %8lxH).\nExpected %8lxH (NTSTATUS %8lxH)",
        l_lResult,
        MapWinErrorToNtStatus(l_lResult),
        ERROR_UNRECOGNIZED_MEDIA,
        MapWinErrorToNtStatus(ERROR_UNRECOGNIZED_MEDIA)
        );

   TestCheck(
      (l_uEnd - l_uStart) / CLOCKS_PER_SEC <= 2,
      "Cold reset took too long.\nElapsed time %ld sec\nExpected time %ld sec",
      (l_uEnd - l_uStart) / CLOCKS_PER_SEC,
      2
      );

    TestEnd();
}

void
SimulateResMngr(
    CReader &in_CReader
    )
{
    BOOL l_bWaitForPresent = FALSE, l_bWaitForAbsent = FALSE, l_bResult;
    BOOL l_bMustWait = FALSE, l_bPoweredDown = FALSE;
    ULONG l_uState, l_uStatus, l_uReplyLength, l_uStateExpected = SCARD_ABSENT, l_lTestNo = 1;
    ULONG l_uMinorIoctl;
    OVERLAPPED l_Ovr, l_OvrWait;
    HANDLE l_hReader = in_CReader.GetHandle();

    l_Ovr.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    ResetEvent(l_Ovr.hEvent);

    l_OvrWait.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    ResetEvent(l_OvrWait.hEvent);

    LogMessage("===================================");
    LogMessage("Part C: Resource Manager Simulation");
    LogMessage("===================================");

    LogMessage("   <<  %s", REMOVE_CARD);
    in_CReader.WaitForCardRemoval();

    while (TRUE) {

        TestStart("%2d. IOCTL_SMARTCARD_GET_STATE", l_lTestNo++);

       l_bResult = DeviceIoControl (
          l_hReader,
          IOCTL_SMARTCARD_GET_STATE,
          NULL,
            0,
            &l_uState,
            sizeof(l_uState),
          &l_uReplyLength,
          &l_Ovr
            );

        LONG l_lResult = GetLastError();

        TestCheck(
            l_bResult,
            "IOCTL_SMARTCARD_GET_STATE failed.\nReturned %8lxH (NTSTATUS %8lxH).\nExpected %8lxH (NTSTATUS %8lxH)",
            l_lResult,
            MapWinErrorToNtStatus(l_lResult),
            ERROR_SUCCESS,
            MapWinErrorToNtStatus(ERROR_SUCCESS)
            );

        TestEnd();

        if (l_bWaitForPresent) {

            TestStart("%2d. %s", l_lTestNo++, INSERT_CARD);

            l_bResult = GetOverlappedResult(
                l_hReader,
                &l_OvrWait,
                &l_uReplyLength,
                TRUE
                );

            l_lResult = GetLastError();

            TestCheck(
                l_bResult,
                "Card insertion monitor failed.\nReturned %8lxH (NTSTATUS %8lxH).\nExpected %8lxH (NTSTATUS %8lxH)",
                l_lResult,
                MapWinErrorToNtStatus(l_lResult),
                ERROR_SUCCESS,
                MapWinErrorToNtStatus(ERROR_SUCCESS)
                );
                l_lResult = GetLastError();

            TestEnd();

            l_bWaitForPresent = FALSE;
            continue;
        }

        if (l_bWaitForAbsent) {

            if (l_bMustWait) {

                TestStart("%2d. %s", l_lTestNo++, REMOVE_CARD);

            } else {

                TestStart("%2d. GetOverlappedResult", l_lTestNo++);
            }

            l_bResult = GetOverlappedResult(
                l_hReader,
                &l_OvrWait,
                &l_uReplyLength,
                l_bMustWait
                );

            if (l_bMustWait == FALSE) {

                TestCheck(
                    l_bResult == FALSE,
                    "Smart card not removed"
                    );

                TestEnd();

                if (TestFailed()) {

                    return;
                }

            } else {

                l_lResult = GetLastError();

                TestCheck(
                    l_bResult,
                    "Card removal monitor failed.\nReturned %8lxH (NTSTATUS %8lxH).\nExpected %8lxH (NTSTATUS %8lxH)",
                    l_lResult,
                    MapWinErrorToNtStatus(l_lResult),
                    ERROR_SUCCESS,
                    MapWinErrorToNtStatus(ERROR_SUCCESS)
                    );

                TestEnd();

                if (TestFailed()) {

                    return;
                }
                l_bWaitForAbsent = FALSE;
                continue;
            }
        }

        TestStart("%2d. Checking reader status", l_lTestNo++);

        switch (l_uState) {

            case SCARD_UNKNOWN:
                TestCheck(FALSE, "Reader returned illegal state SCARD_UNKNOWN");
                TestEnd();
                return;

            case SCARD_ABSENT:
                TestCheck(
                    l_uStateExpected == SCARD_ABSENT,
                    "Invalid reader state.\nCurrent state = %d\nExpected state = %d",
                    l_uState,
                    l_uStateExpected
                    );

                TestEnd();

                if (TestFailed()) {

                    return;
                }

                if (l_bMustWait) {

                    return;
                }

                TestStart("%2d. IOCTL_SMARTCARD_IS_PRESENT", l_lTestNo++);

               l_bResult = DeviceIoControl (
                  l_hReader,
                  IOCTL_SMARTCARD_IS_PRESENT,
                  NULL,
                    0,
                    NULL,
                    0,
                  &l_uReplyLength,
                  &l_OvrWait
                    );

                TestCheck(
                    GetLastError() == ERROR_IO_PENDING,
                    "Monitor is supposed to return ERROR_IO_PENDING (%lxh)",
                    GetLastError()
                    );

                TestEnd();

                if (TestFailed()) {

                    return;
                }

                l_bWaitForPresent = TRUE;
                l_uStateExpected = SCARD_PRESENT;
             break;

            case SCARD_PRESENT:
            case SCARD_SWALLOWED:
            case SCARD_POWERED:
                if (l_bPoweredDown) {

                    TestCheck(
                        l_uStateExpected <= SCARD_POWERED,
                        "Invalid reader state.\nCurrent state = %d\nExpected state <= %d",
                        l_uState,
                        l_uStateExpected
                        );

                    TestEnd();

                    if (TestFailed()) {

                        return;
                    }

                    l_bMustWait = TRUE;
                    l_uStateExpected = SCARD_ABSENT;
                    break;
                }

                TestCheck(
                    l_uStateExpected > SCARD_ABSENT,
                    "Invalid reader state.\nCurrent state = %d\nExpected state <= %d",
                    l_uState,
                    l_uStateExpected
                    );

                TestEnd();

                if (TestFailed()) {

                    return;
                }

                TestStart("%2d. IOCTL_SMARTCARD_IS_ABSENT", l_lTestNo++);
               l_bResult = DeviceIoControl (
                  l_hReader,
                  IOCTL_SMARTCARD_IS_ABSENT,
                  NULL,
                    0,
                    NULL,
                    0,
                  &l_uReplyLength,
                  &l_OvrWait
                    );

                l_lResult = GetLastError();

                TestCheck(
                    l_bResult == FALSE,
                    "IOCTL_SMARTCARD_IS_ABSENT should fail.\nReturned %8lxH (NTSTATUS %8lxH).\nExpected %8lxH (NTSTATUS %8lxH)",
                    l_lResult,
                    MapWinErrorToNtStatus(l_lResult),
                    ERROR_IO_PENDING,
                    MapWinErrorToNtStatus(ERROR_IO_PENDING)
                    );

                TestEnd();

                l_bWaitForAbsent = TRUE;
                TestStart("%2d. Cold reset card", l_lTestNo++);
                l_uStatus = in_CReader.ColdResetCard();
                TEST_CHECK_SUCCESS("ColdReset", l_uStatus)
                l_uStateExpected = SCARD_NEGOTIABLE;

                TestEnd();

                if (TestFailed()) {

                    return;
                }
             break;

            case SCARD_NEGOTIABLE:
                TestCheck(
                    l_bPoweredDown == FALSE,
                    "Invalid reader state.\nCurrent state = %d\nExpected state = %d",
                    l_uState,
                    SCARD_PRESENT
                    );

                TestCheck(
                    l_uStateExpected > SCARD_ABSENT,
                    "Invalid reader state.\nCurrent state = %d\nExpected state <= %d",
                    l_uState,
                    l_uStateExpected
                    );

                TestEnd();

                if (TestFailed()) {

                    return;
                }

                TestStart("%2d. Set protocol to T0 | T1", l_lTestNo++);

                l_uStatus = in_CReader.SetProtocol(
                    SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1
                    );

                TestCheck(
                    l_uStatus == ERROR_SUCCESS,
                    "Protocol selection failed with error %lxh",
                    GetLastError()
                    );
                TestEnd();

                if (TestFailed()) {

                    return;
                }
                l_uStateExpected = SCARD_SPECIFIC;
             break;

            case SCARD_SPECIFIC:
                TestCheck(
                    l_bPoweredDown == FALSE,
                    "Invalid reader state.\nCurrent state = %d\nExpected state = %d",
                    l_uState,
                    SCARD_PRESENT
                    );

                TestCheck(
                    l_uStateExpected > SCARD_ABSENT,
                    "Invalid reader state.\nReturned %d\nExpected < %d",
                    l_uState,
                    l_uStateExpected
                    );

                TestEnd();

                if (TestFailed()) {

                    return;
                }

                TestStart("%2d. IOCTL_SMARTCARD_POWER (SCARD_POWER_DOWN)", l_lTestNo++);
                l_uMinorIoctl = SCARD_POWER_DOWN;
                SetLastError(0);
               l_bResult = DeviceIoControl (
                  l_hReader,
                  IOCTL_SMARTCARD_POWER,
                  &l_uMinorIoctl,
                    sizeof(l_uMinorIoctl),
                    NULL,
                    0,
                  &l_uReplyLength,
                  &l_Ovr
                    );

                if (l_bResult == FALSE && GetLastError() == ERROR_IO_PENDING) {

                    SetLastError(0);

                    l_bResult = GetOverlappedResult(
                        l_hReader,
                        &l_Ovr,
                        &l_uReplyLength,
                        TRUE
                        );
                }

                l_lResult = GetLastError();

                TEST_CHECK_SUCCESS("IOCTL_SMARTCARD_POWER failed", l_lResult);
                TestEnd();

                l_uStateExpected = SCARD_PRESENT;
                l_bPoweredDown = TRUE;
             break;

            default:
               TestCheck(
                    FALSE,
                    "Reader returned invalid state %d",
                    l_uState
                    );
                TestEnd();
                return;
        }
    }
}

void
PowerManagementTest(
    CReader &in_CReader,
   ULONG in_uWaitTime
    )
{
   LONG l_lResult;
   ULONG l_uState, l_uPrevState, l_uRepeat;
   ULONG l_uDuration = 30;

   if (in_uWaitTime > 30 && in_uWaitTime < 120) {

      l_uDuration = in_uWaitTime;
   }

    LogMessage("=============================");
    LogMessage("Part E: Power Management Test");
    LogMessage("=============================");

   LogMessage("Note: Each test cycle takes %ld seconds!", l_uDuration);
    LogMessage("   <<  %s", REMOVE_CARD);
    in_CReader.WaitForCardRemoval();

   LogMessage("Test 1: DO NOT INSERT smart card during hibernate mode");
    TestStart("Card out / card out - Hibernate now");

   l_lResult = in_CReader.StartWaitForCardInsertion();
    l_lResult = in_CReader.GetState(&l_uPrevState);

    for (l_uRepeat = 0; l_uRepeat < l_uDuration; l_uRepeat++) {

        l_lResult = in_CReader.GetState(&l_uState);

        LONG l_uGoal = clock() + CLOCKS_PER_SEC;
        while(l_uGoal > clock())
            ;
      printf("\x08\x08%2ld", l_uDuration - l_uRepeat);
   }
   printf("\x08\x08  ");

   l_lResult = in_CReader.FinishWaitForCard(FALSE);

    TestCheck(
        l_lResult == ERROR_IO_INCOMPLETE,
        "GetOverlappedResult failed\nReturned %8lx\nExpected %8lx",
      l_lResult,
      ERROR_IO_INCOMPLETE
        );

    TestEnd();

   TestStart("%s", INSERT_CARD);
   l_lResult = in_CReader.FinishWaitForCard(TRUE);
   TEST_CHECK_SUCCESS("Reader failed card insertion", l_lResult);
   TestEnd();

    TestStart("Checking reader status");
    l_lResult = in_CReader.GetState(&l_uState);
   TEST_CHECK_SUCCESS("Reader failed IOCTL_SMARTCARD_GET_STATE", l_lResult);

    TestCheck(
        l_uState > SCARD_ABSENT,
        "Invalid reader state.\nReturned %d\nExpected > %d",
        l_uState,
        SCARD_ABSENT
        );
   TestEnd();

   //
   // Test 2
   //

   LogMessage("Test 2: REMOVE smart card DURING hibernate mode");
    TestStart("Card in / card out - Hibernate now");

   l_lResult = in_CReader.StartWaitForCardRemoval();
    l_lResult = in_CReader.GetState(&l_uPrevState);

    for (l_uRepeat = 0; l_uRepeat < l_uDuration; l_uRepeat++) {

        l_lResult = in_CReader.GetState(&l_uState);

        LONG l_uGoal = clock() + CLOCKS_PER_SEC;
        while(l_uGoal > clock())
            ;
      printf("\x08\x08%2ld", l_uDuration - l_uRepeat);
   }
   printf("\x08\x08  ");

   l_lResult = in_CReader.FinishWaitForCard(FALSE);

    TEST_CHECK_SUCCESS(
        "GetOverlappedResult failed",
      l_lResult
        );

    TestEnd();

    TestStart("Checking reader status");
    l_lResult = in_CReader.GetState(&l_uState);
   TEST_CHECK_SUCCESS("Reader failed IOCTL_SMARTCARD_GET_STATE", l_lResult);

    TestCheck(
        l_uState == SCARD_ABSENT,
        "Invalid reader state.\nReturned %d\nExpected %d",
        l_uState,
        SCARD_ABSENT
        );
   TestEnd();

    LogMessage("   >>  %s", INSERT_CARD);
    in_CReader.WaitForCardInsertion();

   //
   // Test 3
   //
   LogMessage("Test 3: DO NOT REMOVE smart card during hibernate mode");
    TestStart("Card in / card in - Hibernate now");

   l_lResult = in_CReader.StartWaitForCardRemoval();
    l_lResult = in_CReader.GetState(&l_uPrevState);

    for (l_uRepeat = 0; l_uRepeat < l_uDuration; l_uRepeat++) {

        l_lResult = in_CReader.GetState(&l_uState);

        LONG l_uGoal = clock() + CLOCKS_PER_SEC;
        while(l_uGoal > clock())
            ;
      printf("\x08\x08%2ld", l_uDuration - l_uRepeat);
   }
   printf("\x08\x08  ");

   l_lResult = in_CReader.FinishWaitForCard(FALSE);

    TEST_CHECK_SUCCESS(
        "GetOverlappedResult failed",
      l_lResult
        );

    TestEnd();

    TestStart("Checking reader status");
    l_lResult = in_CReader.GetState(&l_uState);
   TEST_CHECK_SUCCESS("Reader failed IOCTL_SMARTCARD_GET_STATE", l_lResult);

    TestCheck(
        l_uState >= SCARD_PRESENT,
        "Invalid reader state.\nReturned %d\nExpected > %d",
        l_uState,
        SCARD_ABSENT
        );
   TestEnd();

    LogMessage("   <<  %s", REMOVE_CARD);
    in_CReader.WaitForCardRemoval();

   //
   // Test 4
   //

   LogMessage("Test 4: INSERT smart card DURING hibernate mode");
    TestStart("Card out / card in - Hibernate now");

   l_lResult = in_CReader.StartWaitForCardInsertion();
    l_lResult = in_CReader.GetState(&l_uPrevState);

    for (l_uRepeat = 0; l_uRepeat < l_uDuration; l_uRepeat++) {

        l_lResult = in_CReader.GetState(&l_uState);

        LONG l_uGoal = clock() + CLOCKS_PER_SEC;
        while(l_uGoal > clock())
            ;
      printf("\x08\x08%2ld", l_uDuration - l_uRepeat);
   }
   printf("\x08\x08  ");
   l_lResult = in_CReader.FinishWaitForCard(FALSE);

    TEST_CHECK_SUCCESS(
        "GetOverlappedResult failed",
      l_lResult
        );

    TestEnd();

    TestStart("Checking reader status");
    l_lResult = in_CReader.GetState(&l_uState);
   TEST_CHECK_SUCCESS("Reader failed IOCTL_SMARTCARD_GET_STATE", l_lResult);

    TestCheck(
        l_uState >= SCARD_PRESENT,
        "Invalid reader state.\nReturned %d\nExpected > %d",
        l_uState,
        SCARD_ABSENT
        );
   TestEnd();
}

class CArgv {

    int m_iArgc;
    char **m_pArgv;
    BOOL *m_pfRef;

public:

    CArgv(int in_iArgc, char **in_pArgv);

    int OptionExist(PCHAR);

    PCHAR ParameterExist(PCHAR);

    PCHAR CheckParameters(CString);

    PCHAR CArgv::ParameterUnused(void);
};


CArgv::CArgv(
    int in_iArgc,
    char **in_pArgv
    )
{
    m_iArgc = in_iArgc;
    m_pArgv = in_pArgv;
    m_pfRef = new BOOL[in_iArgc];
    memset(m_pfRef, 0, sizeof(BOOL) * in_iArgc);
}

CArgv::OptionExist(
    PCHAR in_pchParameter
    )
{
    for (int i = 0; i < m_iArgc; i++) {

        if (m_pArgv[i][0] == '-' || m_pArgv[i][0] == '/') {

            int j = 1;

            while (m_pArgv[i][j] && m_pArgv[i][j] != ' ') {

                if (strncmp(m_pArgv[i] + j, in_pchParameter, strlen(m_pArgv[i] + j)) == 0) {

                    m_pfRef[i] = TRUE;
                    return i;
                }

                j++;
            }
        }
    }

    return 0;
}

PCHAR
CArgv::ParameterExist(
    PCHAR in_pchParameter
    )
{
    if (int i = OptionExist(in_pchParameter)) {

        m_pfRef[i + 1] = TRUE;
        return m_pArgv[i + 1];
    }

    return NULL;
}

PCHAR
CArgv::CheckParameters(
    CString in_CParameters
    )
/*++

Routine Description:
    Checks if the command line includes in invalid/unknown parameter

--*/
{
    int i, l_iPos;

    for (i = 1; i < m_iArgc; i++) {

        if ((l_iPos = in_CParameters.Find(m_pArgv[i])) == -1) {

            return m_pArgv[i];
        }

        if (l_iPos + 3 < in_CParameters.GetLength() &&
            in_CParameters[l_iPos + 3] == '*') {

            // skip the next parameter
            i += 1;
        }
    }
    return NULL;
}

PCHAR
CArgv::ParameterUnused(
    void
    )
{
    int i;

    for (i = 1; i < m_iArgc; i++) {

        if (m_pfRef[i] == FALSE) {

            return m_pArgv[i];
        }
    }
    return NULL;
}

CString &
GetOperatingSystem(
    void
    )
{
    static CString l_COperatingSystem;
    OSVERSIONINFO VersionInformation;

    if (l_COperatingSystem.GetLength() == 0) {

        VersionInformation.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

        if (GetVersionEx(&VersionInformation) == FALSE) {

            l_COperatingSystem += "Unknown";

        } else {

            if (VersionInformation.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) {

                if (VersionInformation.dwMinorVersion == 0) {

                    l_COperatingSystem += OS_WIN95;

                } else {

                    l_COperatingSystem += OS_WIN98;
                }

            } else if (VersionInformation.dwPlatformId == VER_PLATFORM_WIN32_NT) {

                if (VersionInformation.dwMajorVersion <= 4) {

                    l_COperatingSystem += OS_WINNT4;

                } else {

                    l_COperatingSystem += OS_WINNT5;
                }

            } else {

                l_COperatingSystem += "Unknown";
            }
        }
    }

    return l_COperatingSystem;
}

CString &
SelectReader(
    void
    )
{
    CReaderList l_CReaderList;
    ULONG l_uIndex, l_uReader;
    ULONG l_uNumReaders = l_CReaderList.GetNumReaders();
   static CString l_CEmpty("");

    if (l_uNumReaders == 0) {

      return l_CEmpty;
    }

    if (l_uNumReaders == 1) {

        return l_CReaderList.GetDeviceName(0);
    }

    CString l_CLetter;

    printf("\n");
    printf(" Vendor                  IfdType                  Type\n");
    printf(" -----------------------------------------------------\n");

    for (l_uIndex = 0; l_uIndex < l_uNumReaders; l_uIndex++) {

        INT l_iLetterPos;
        INT l_iLength = l_CReaderList.GetVendorName(l_uIndex).GetLength();
        CString l_CVendorName = l_CReaderList.GetVendorName(l_uIndex);

        for (l_iLetterPos = 0;
             l_iLetterPos < l_CVendorName.GetLength();
             l_iLetterPos++) {

            CHAR l_chLetter = l_CVendorName[l_iLetterPos];

            if (l_chLetter == ' ' || l_chLetter == 'x') {

                continue;
            }

            if (l_CLetter.Find(l_chLetter) == -1) {

                l_CLetter += l_chLetter;
                break;
            }
        }
        if (l_iLetterPos >= l_iLength) {

            l_CVendorName += (CHAR) (l_uIndex + '0') ;
            l_iLetterPos = l_iLength;
        }

        printf(
            " %s[%c]%-*s %-20s %8s\n",
            (LPCSTR) l_CVendorName.Left(l_iLetterPos),
            l_CVendorName[l_iLetterPos],
            20 - l_iLetterPos,
            l_CVendorName.Right(l_iLength - l_iLetterPos - 1),
            (LPCSTR) l_CReaderList.GetIfdType(l_uIndex),
            (LPCSTR) l_CReaderList.GetPnPType(l_uIndex)
            );
    }

    putchar('\n');
    do {

        printf("\rSelect reader:  \010");

        CHAR l_chInput = (CHAR) _getche();
      if (l_chInput == 3) {

         exit(-1);
      }

      l_uReader = l_CLetter.Find(l_chInput);

    } while(l_uReader == -1);

    printf("\n");

    return l_CReaderList.GetDeviceName(l_uReader);
}

CString
SelectReader(
    CString &in_CVendorName
    )
{
    CReaderList l_CReaderList;
    ULONG l_uIndex;
    ULONG l_uNumReaders = l_CReaderList.GetNumReaders();
    CString l_CVendorName = in_CVendorName;

    l_CVendorName.MakeLower();

    for (l_uIndex = 0; l_uIndex < l_uNumReaders; l_uIndex++) {

        CString l_CVendorListName = l_CReaderList.GetVendorName(l_uIndex);
        l_CVendorListName.MakeLower();

        if (l_CVendorListName.Find(l_CVendorName) != -1) {

            return l_CReaderList.GetDeviceName(l_uIndex);
        }
    }

    return CString("");
}



//**********************************************************************
// 
//  StopService()
// 
//  PURPOSE :     This function attempts to stop a service. It will fail
//				  the service has any dependent services.
//                It also allows a timeout
//                value to be passed, to prevent a scenario in which a
//                service shutdown hangs, and in turn the application
//                stopping the service hangs.
// 
//  PARAMETERS:   hSCM - open handle to the service control manager
//                hService - open handle to the service to be stopped
//                dwTimeout - maximum time (in milliseconds) to wait
//                   for the service and its dependencies to stop
// 
//  RETURN VALUE: TRUE if the service is successfully stopped
// 
//**********************************************************************

BOOL StopService( SC_HANDLE hSCM, SC_HANDLE hService, 
      DWORD dwTimeout ) {

   SERVICE_STATUS ss;
   DWORD dwStartTime = GetTickCount();

   // Make sure the service is not already stopped
   if ( !QueryServiceStatus( hService, &ss ) )
      return FALSE;

   if ( ss.dwCurrentState == SERVICE_STOPPED ) 
      return FALSE;

   // If a stop is pending, just wait for it
   while ( ss.dwCurrentState == SERVICE_STOP_PENDING ) {

      Sleep( 5000 );
      if ( !QueryServiceStatus( hService, &ss ) )
         return FALSE;

      if ( ss.dwCurrentState == SERVICE_STOPPED )
         return FALSE;

      if ( GetTickCount() - dwStartTime > dwTimeout )
         return FALSE;
   }

   // Send a stop code to service
   if ( !ControlService( hService, SERVICE_CONTROL_STOP, &ss ) )
      return FALSE;

   // Wait for the service to stop
   while ( ss.dwCurrentState != SERVICE_STOPPED ) {

      Sleep( 5000 );
      if ( !QueryServiceStatus( hService, &ss ) )
         return FALSE;

      if ( ss.dwCurrentState == SERVICE_STOPPED )
         break;

      if ( GetTickCount() - dwStartTime > dwTimeout )
         return FALSE;
   }

   // Return success
   return TRUE;
}


__cdecl
main(
    int argc,
    char* argv[]
    )
{
    CArgv l_CArgv(argc, argv);
    BOOL l_bSuccess, l_fInvalidParameter = FALSE;
	BOOL l_bStoppedScardsvr = FALSE;		// true==> we succesfully stoped scardsvr service
	SC_HANDLE l_hSCM = NULL;
	SC_HANDLE l_hService = NULL;
   
    LogMessage("Smart Card Reader Test Suite");
    LogMessage("Version 2.0.5");
    LogMessage("Copyright(c) Microsoft Corporation 1997 - 1999");

    if(PCHAR l_pchArgv = l_CArgv.CheckParameters("-d -e -h -m -r * -sa -sb -sc -sd -se -t * -v * -w *")) {

        LogMessage("Invalid Parameter '%s'", l_pchArgv);
        l_fInvalidParameter = TRUE;
    }

    if (l_fInvalidParameter ||

        l_CArgv.OptionExist("h")) {

        LogMessage("IfdTest [-d] [-m] [-r name] [-sa] [-sb] [-sc] [-sd] [-se] [-ss] [-w sec] [-t test] [-v name]\n");
        LogMessage("   -d        dumps all i/o");
        LogMessage("   -e        ends (stops) scardsvr service");
        LogMessage("   -m        manual test");
        LogMessage("   -r name   opens reader using device name");
        LogMessage("   -sa       skips card monitor test");
        LogMessage("   -sb       skips general reader test");
        LogMessage("   -sc       skips resource manager simulation");
        LogMessage("   -sd       skips card tests");
        LogMessage("   -se       skips power management tests");
        LogMessage("   -v name   opens reader using vendor name");
        LogMessage("   -t test   runs only specific card test in part d");
        LogMessage("   -w sec    runs power management test using specified waiting time");
        exit(-1);
    }

    static CReader l_CReader;
    CString l_CDeviceName;

	//
	// sandysp 5/9/01: stop scardsvr service because open will fail if it's running
	//

	if (l_CArgv.OptionExist("e")) {
		l_hSCM = OpenSCManager( NULL, NULL, SC_MANAGER_CONNECT );
		if (l_hSCM) {

			// Open the specified service
			l_hService = OpenService( l_hSCM, 
									  "scardsvr", 
									  SERVICE_STOP | SERVICE_START | SERVICE_QUERY_STATUS );
			if (l_hService) {
				// Try to stop the service, specifying a 30 second timeout
				l_bStoppedScardsvr = StopService( l_hSCM, l_hService, 30000 ) ;
			}
		}
	}

    if (PCHAR l_pchReader = l_CArgv.ParameterExist("r")) {

      l_CDeviceName = CString("\\\\.\\") + CString(l_pchReader);

    } else if (PCHAR l_pchVendorName = l_CArgv.ParameterExist("v")) {

        CReaderList l_CReaderList;
        l_CDeviceName = SelectReader(CString(l_pchVendorName));

    } else {

        CReaderList l_CReaderList;
        l_CDeviceName = SelectReader();
    }

    if (l_CDeviceName == "") {

        LogMessage("No reader found");
        exit (-1);
    }
	
	l_bSuccess = l_CReader.Open(l_CDeviceName);

    LogMessage(".");
    if (l_bSuccess == FALSE) {

        LogMessage("Can't open smart card reader");
        exit (-1);
    }

    if (l_CArgv.OptionExist("d")) {

        l_CReader.SetDump(TRUE);
    }

    void ManualTest(CReader &in_CReader);
    if (l_CArgv.OptionExist("m")) {

        ManualTest(l_CReader);
    }

    CCardProvider l_CCardProvider;

    LogOpen("ifdtest");

    time_t l_osBinaryTime;
    time( &l_osBinaryTime );
    CTime l_CTime( l_osBinaryTime );

    LogMessage("Vendor: %s", l_CReader.GetVendorName());
    LogMessage("Reader: %s", l_CReader.GetIfdType());
    LogMessage(
        "Date:   %d/%02d/%02d",
        l_CTime.GetMonth(),
        l_CTime.GetDay(),
        l_CTime.GetYear()
        );
    LogMessage(
        "Time:   %d:%02d",
        l_CTime.GetHour(),
        l_CTime.GetMinute()
        );
    LogMessage("OS:     %s", (LPCSTR) GetOperatingSystem());

    //
    // Check if the reader properly supports
    // card insertion and removal
    //
    if (l_CArgv.OptionExist("sa")) {

        LogMessage("=================================");
        LogMessage("Part A: Card monitor test skipped");
        LogMessage("=================================");

    } else {

        CheckCardMonitor(l_CReader);
    }

    if (l_CArgv.OptionExist("sb")) {

        LogMessage("===========================");
        LogMessage("Part B: Reader test skipped");
        LogMessage("===========================");

    } else {

        CheckReader(l_CReader);
    }

    if (l_CArgv.OptionExist("sc")) {

        LogMessage("===========================================");
        LogMessage("Part C: Resource Manager Simulation skipped");
        LogMessage("===========================================");

    } else {

        // Check res manager behavior
        SimulateResMngr(l_CReader);
    }

    if (l_CArgv.OptionExist("sd")) {

        LogMessage("========================================");
        LogMessage("Part D: Smart Card Provider Test skipped");
        LogMessage("========================================");

    } else {

        ULONG l_uTestNo = 0;
        PCHAR l_pchTestNo;

        if (l_pchTestNo = l_CArgv.ParameterExist("t")) {

            // The user wants us to run only one test
            l_uTestNo = atoi(l_pchTestNo);
        }

        while (l_CCardProvider.CardsUntested()) {

            LogMessage("================================");
            LogMessage("Part D: Smart Card Provider Test");
            LogMessage("================================");

            LogMessage("Insert any of the following PC/SC Compliance Test Cards:");
            l_CCardProvider.ListUntestedCards();

            LogMessage("   >>  %s", INSERT_CARD);
            if (l_CReader.WaitForCardInsertion() != ERROR_SUCCESS) {

                LogMessage("Reader failed card insertion monitor");
                return -1;
            }

            // Reset the card
            if (l_CReader.ColdResetCard() != ERROR_SUCCESS) {

                LogMessage("Unable to reset smart card");

            } else {

                // Try to run tests with this card
                l_CCardProvider.CardTest(l_CReader, l_uTestNo);

                if (l_uTestNo != 0) {

                    // Quit the program if we only run one test.
                    return 0;
                }
            }

            LogMessage("   <<  %s", REMOVE_CARD);
            if (l_CReader.WaitForCardRemoval() != ERROR_SUCCESS) {

                LogMessage("Reader failed card removal monitor");
                return -1;
            }
        }
   }

   if (GetOperatingSystem() == OS_WINNT5) {

      if (l_CArgv.OptionExist("se")) {

         LogMessage("=====================================");
         LogMessage("Part E: Power Management Test skipped");
         LogMessage("=====================================");

      } else {

         ULONG l_uWaitTime = 0;

         if (PCHAR l_pchWaitTime = l_CArgv.ParameterExist("w")) {

            // The user wants us to run only one test
            l_uWaitTime = atoi(l_pchWaitTime);
         }

         PowerManagementTest(l_CReader, l_uWaitTime);
      }
   }

   //
   // Sandysp 5/9/01: restart smart card reader service if we stopped it
   //
   if (l_bStoppedScardsvr) {
	   StartService( l_hService, 0, NULL );
   }
   if ( l_hService )
	   CloseServiceHandle( l_hService );

   if ( l_hSCM )
	   CloseServiceHandle( l_hSCM );

   
   LogMessage("Reader %s the test", (ReaderFailed() ? "failed" : "passed"));
   return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\ifdtest\ifdmsg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ifdmsg.cpp
//
//--------------------------------------------------------------------------

#include <stdarg.h> 
#include <stdio.h>
#include <string.h>
#include <conio.h>

#include <afx.h>
#include <afxtempl.h>

#include <winioctl.h>
#include <winsmcrd.h>

#include "ifdtest.h"

// Our log file
static FILE *g_pLogFile;

// These are used by the Testxxx functions
static BOOL g_bTestFailed;
static BOOL g_bReaderFailed;
static BOOL g_bTestStart;

void
LogOpen(
    PCHAR in_pchFileName
    )
{
    CHAR l_rgchFileName[128];

    sprintf(l_rgchFileName, "%s.log", in_pchFileName);
    g_pLogFile = fopen(l_rgchFileName, "w"); 	
}

void
LogMessage(
    PCHAR in_pchFormat,
    ...
    )
{
    CHAR l_rgchBuffer[128];
    va_list l_pArg;

    va_start(
        l_pArg, 
        in_pchFormat
        );

    vsprintf(
        l_rgchBuffer,
        in_pchFormat, 
        l_pArg
        ); 	

    printf("%s\n", l_rgchBuffer);
    if (g_pLogFile) {
        
        fprintf(g_pLogFile, "%s\n", l_rgchBuffer);
    }
}

void 
TestStart(
    PCHAR in_pchFormat,
    ...
    )
{ 	                                
    CHAR l_rgchBuffer[128];
    va_list l_pArg;

    if (g_bTestStart) {

        printf("\n*** WARNING: Missing TestResult() call\n");
    }

    g_bTestStart = TRUE;
    g_bTestFailed = FALSE;

    va_start(l_pArg, in_pchFormat);
    vsprintf(l_rgchBuffer, in_pchFormat, l_pArg);

    printf("   %-50s", l_rgchBuffer);
    if (g_pLogFile) {
        
        fprintf(g_pLogFile, "   %-50s", l_rgchBuffer);
    }
}

static 
void 
TestMsg(
    BOOL in_bTestEnd,
    BOOL in_bTestResult,
    PCHAR in_pchFormat,
    va_list in_pArg
    )
{     	
    CHAR l_rgchBuffer[2048];

    if (in_bTestEnd && g_bTestStart == FALSE) {

        printf("\n*** WARNING: Missing TestStart() call\n");
    }

    vsprintf(l_rgchBuffer, in_pchFormat, in_pArg);

    if (in_bTestResult == FALSE && g_bTestFailed == FALSE) {

        g_bTestFailed = TRUE;
        g_bReaderFailed = TRUE;
        printf("* FAILED\n-  %s\n", l_rgchBuffer);

        if (g_pLogFile) {
         	
            fprintf(g_pLogFile, "* FAILED\n-  %s\n", l_rgchBuffer);
        }
    }

    if (in_bTestEnd) {

        if (g_bTestFailed != TRUE) {
         	
            printf("  Passed\n");

            if (g_pLogFile) {
         	    
                fprintf(g_pLogFile, "   Passed\n");
            }
        }
    }
}

void 
TestCheck(
    BOOL in_bResult,
    PCHAR in_pchFormat,
    ...
    )
{
    va_list l_pArg;

    va_start(l_pArg, in_pchFormat);
    TestMsg(FALSE, in_bResult, in_pchFormat, l_pArg);
}

void
TestCheck(
    ULONG in_lResult,
    const PCHAR in_pchOperator,
    const ULONG in_uExpectedResult,
    ULONG in_uResultLength,
    ULONG in_uExpectedLength,
    UCHAR in_chSw1,
    UCHAR in_chSw2,
    UCHAR in_chExpectedSw1,
    UCHAR in_chExpectedSw2,
    PUCHAR in_pchData,
    PUCHAR in_pchExpectedData,
    ULONG  in_uDataLength
    )
/*++

Routine Description:

    This function checks the return code, the number of bytes
    returned, the card status bytes and the data returned by 
    a call to CReader::Transmit. 
    
--*/
{
    if (strcmp(in_pchOperator, "==") == 0 &&
        in_lResult != in_uExpectedResult ||
        strcmp(in_pchOperator, "!=") == 0 &&
        in_lResult == in_uExpectedResult) {

        TestCheck(
            FALSE,
            "IOCTL call failed:\nReturned %8lxH (NTSTATUS %8lxH)\nExpected %s%8lxH (NTSTATUS %8lxH)",
            in_lResult,
            MapWinErrorToNtStatus(in_lResult),
            (strcmp(in_pchOperator, "!=") == 0 ? "NOT " : ""),
            in_uExpectedResult,
            MapWinErrorToNtStatus(in_uExpectedResult)
            );

    } else if (in_uResultLength != in_uExpectedLength) {

        TestCheck(
            FALSE,
            "IOCTL returned wrong number of bytes:\nReturned %3ld bytes\nExpected %3ld bytes",
            in_uResultLength,
            in_uExpectedLength
            );

    } else if (in_chSw1 != in_chExpectedSw1 ||
               in_chSw2 != in_chExpectedSw2){

        TestCheck(
            FALSE,
            "Card returned wrong status:\nStatus SW1 = %02x SW2 = %02x\nExpected SW1 = %02x SW2 = %02x",
            in_chSw1,
            in_chSw2,
            in_chExpectedSw1,
            in_chExpectedSw2
            );

    } else if (memcmp(in_pchData, in_pchExpectedData, in_uDataLength)) {

        CHAR l_rgchData[2048], l_rgchExpectedData[2048];

        for (ULONG i = 0; i < in_uDataLength; i++) {

            sprintf(l_rgchData + i * 3, "%02X ", in_pchData[i]);
            sprintf(l_rgchExpectedData + i * 3, "%02X ", in_pchExpectedData[i]);

            if ((i + 1) % 24 == 0) {

                l_rgchData[i * 3 + 2] = '\n';
                l_rgchExpectedData[i * 3 + 2] = '\n';             	
            }         	
        }
              	
        TestCheck(
            FALSE,
            "IOCTL returned incorrect data:\nData returned:\n%s\nExpected data:\n%s",
            l_rgchData, 
            l_rgchExpectedData
            );
    }
}

void
TestEnd(
    void
    )
/*++

Routine Description:

    A call to this function marks the end of a test sequence.
    A sequence is usually look like:

    TestStart(Message)
    CReaderTransmit or DeviceIoControl
    TestCheck(...)
    TestEnd()
	
--*/
{
#ifdef _M_ALPHA
    va_list l_pArg;
#else
    va_list l_pArg = NULL;
#endif
    TestMsg(TRUE, TRUE, "", l_pArg);
    g_bTestStart = FALSE;
}

BOOL
TestFailed(
    void
    )
{
    return g_bTestFailed;
}

BOOL
ReaderFailed(
	void
	)
{
 	return g_bReaderFailed;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\ifdtest\mondex.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    example.cpp

Abstract:

    This is a plug-in for the smart card driver test suite.
    This plug-in is smart card dependent

Author:

    Klaus U. Schutz

Environment:

    Win32 application

Revision History :

    Nov. 1997 - initial version

--*/

#include <stdarg.h> 
#include <stdio.h>
#include <string.h>
#include <time.h>

#include <afx.h>
#include <afxtempl.h>

#include <winioctl.h>
#include <winsmcrd.h>

#include "ifdtest.h"

#define BYTES_PER_BLOCK 64

void 
MondexTestCardEntry(
    class CCardProvider& in_CCardProvider
    );
//
// Create a card provider object
// Note: all global varibales and all functions have to be static
//
static class CCardProvider MondexTestCard(MondexTestCardEntry);

static ULONG
MondexTestCardSetProtocol(
    class CCardProvider& in_CCardProvider,
    class CReader& in_CReader
    )
/*++

Routine Description:
    
    This function will be called after the card has been correctly 
    identified. We should here set the protocol that we need
    for further transmissions

Arguments:

    in_CCardProvider - ref. to our card provider object
    in_CReader - ref. to the reader object

Return Value:

    IFDSTATUS_FAILED - we were unable to set the protocol correctly
    IFDSTATUS_SUCCESS - protocol set correctly

--*/
{
    ULONG l_lResult;

    TestStart("Set protocol to T=0");
    l_lResult = in_CReader.SetProtocol(SCARD_PROTOCOL_T0);
    TEST_CHECK_SUCCESS("Set protocol failed", l_lResult);
    TestEnd();

    if (l_lResult != ERROR_SUCCESS) {

        return IFDSTATUS_FAILED;
    }

    return IFDSTATUS_SUCCESS;
}

static 
ULONG
MondexTestCardTest(
    class CCardProvider& in_CCardProvider,
    class CReader& in_CReader
    )
/*++

Routine Description:
	    
    This serves as the test function for a particular smart card

Arguments:

    in_CReader - ref. to class that provides all information for the test

Return Value:

    IFDSTATUS value

--*/
{
    ULONG l_lResult;

	switch (in_CCardProvider.GetTestNo()) {
	
	    case 1: {
            TestStart("Cold reset");
            l_lResult = in_CReader.ColdResetCard();
            TEST_CHECK_SUCCESS("Cold reset failed", l_lResult);
            TestEnd();

            ULONG l_uState;
            TestStart("Check reader state");
            l_lResult = in_CReader.GetState(&l_uState);
            TEST_CHECK_SUCCESS(
                "Ioctl IOCTL_SMARTCARD_GET_STATE failed", 
                l_lResult
                );

            TestCheck(
                l_uState == SCARD_SPECIFIC,
                "Invalid reader state.\nReturned %d\nExpected %d",
                l_uState,
                SCARD_SPECIFIC
                );
            TestEnd();

            return IFDSTATUS_END;
        }

	    default:
		    return IFDSTATUS_FAILED;

	}    
    return IFDSTATUS_SUCCESS;
}    

static void
MondexTestCardEntry(
    class CCardProvider& in_CCardProvider
    )
/*++

Routine Description:
    
    This function registers all callbacks from the test suite
	
Arguments:

    CCardProvider - ref. to card provider class

Return Value:

    -

--*/
{
    // Set protocol callback
    in_CCardProvider.SetProtocol(MondexTestCardSetProtocol);

    // Card test callback
    in_CCardProvider.SetCardTest(MondexTestCardTest);

    // Name of our card
    in_CCardProvider.SetCardName("Mondex");

    // ATR of our card
    in_CCardProvider.SetAtr((PBYTE) "\x3b\xff\x32\x00\x00\x10\x80\x80\x31\xe0\x5b\x55\x53\x44\x00\x00\x00\x00\x13\x88\x02\x55", 22);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\ifdtest\ifdrdr.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ifdrdr.cpp
//
//--------------------------------------------------------------------------

#include <stdarg.h> 
#include <stdio.h>
#include <string.h>
#include <conio.h>

#include <afx.h>
#include <afxtempl.h>

#include <winioctl.h>
#include <winsmcrd.h>

#include "ifdtest.h"

ULONG CReaderList::m_uRefCount;
ULONG CReaderList::m_uNumReaders;
CReaderList **CReaderList::m_pList;
static CString l_CEmpty("");

void
DumpData(
    PCHAR in_pchCaption,
    ULONG in_uIndent,
    PBYTE in_pbData,
    ULONG in_uLength) 
{
    ULONG l_uIndex, l_uLine, l_uCol;

    printf("%s\n%*s%04x: ", in_pchCaption, in_uIndent, "", 0);

    for (l_uLine = 0, l_uIndex = 0; 
         l_uLine < ((in_uLength - 1) / 8) + 1; 
         l_uLine++) {

        for (l_uCol = 0, l_uIndex = l_uLine * 8; 
             l_uCol < 8; l_uCol++, 
             l_uIndex++) {
        
            printf(
                l_uIndex < in_uLength ? "%02x " : "   ",
                in_pbData[l_uIndex]
                );
        }

        putchar(' ');

        for (l_uCol = 0, l_uIndex = l_uLine * 8; 
             l_uCol < 8; l_uCol++, 
             l_uIndex++) {

            printf(
                l_uIndex < in_uLength ? "%c" : " ",
                isprint(in_pbData[l_uIndex]) ? in_pbData[l_uIndex] : '.'
                );
        }

        putchar('\n');
	    if (l_uIndex  < in_uLength) {

            printf("%*s%04x: ", in_uIndent, "", l_uIndex + 1);
	    }
    }
}

CReaderList::CReaderList(
    CString &in_CDeviceName,
    CString &in_CPnPType,
	CString &in_CVendorName,
	CString &in_CIfdType
    )
{
    m_CDeviceName += in_CDeviceName;
    m_CPnPType += in_CPnPType;
    m_CVendorName += in_CVendorName;
    m_CIfdType += in_CIfdType;
}

CString &
CReaderList::GetDeviceName(
    ULONG in_uIndex
    )
/*++

Routine Description:	
	Retrieves the device name of a reader

Arguments:
	in_uIndex - index to reader list

Return Value:
	The device name that can be used to open the reader

--*/
{
	if (in_uIndex >= m_uNumReaders) {

		return l_CEmpty;
	}

    return m_pList[in_uIndex]->m_CDeviceName;
}

CString &
CReaderList::GetIfdType(
    ULONG in_uIndex
    )
{
	if (in_uIndex >= m_uNumReaders) {

		return l_CEmpty;
	}

    return m_pList[in_uIndex]->m_CIfdType;
}

CString &
CReaderList::GetPnPType(
    ULONG in_uIndex
    )
{ 	
	if (in_uIndex >= m_uNumReaders) {

		return l_CEmpty;
	}

    return m_pList[in_uIndex]->m_CPnPType;
}

CString &
CReaderList::GetVendorName(
    ULONG in_uIndex
    )
{
	if (in_uIndex >= m_uNumReaders) {

		return l_CEmpty;
	}

    return m_pList[in_uIndex]->m_CVendorName;
}

void
CReaderList::AddDevice(
    CString in_CDeviceName,
    CString in_CPnPType
    )
/*++

Routine Description:
	This functions tries to open the reader device supplied by
	in_pchDeviceName. If the device exists it adds it to the list
	of installed readers
	
Arguments:
	in_pchDeviceName - reader device name
	in_pchPnPType - type of reader (wdm-pnp, nt, win9x)

--*/
{ 	
    CReader l_CReader;

    if (l_CReader.Open(in_CDeviceName)) {

		if (l_CReader.GetVendorName().IsEmpty()) {

			LogMessage(
				"VendorName of reader device %s is NULL",
				(LPCSTR) in_CDeviceName
				);		 	

		} else if (l_CReader.GetIfdType().IsEmpty()) {
		 	
			LogMessage(
				"IfdType of reader device %s is NULL",
				(LPCSTR) in_CDeviceName
				);		 	

		} else {
		 	
			CReaderList *l_CReaderList = new CReaderList(
				in_CDeviceName,
				in_CPnPType,
				l_CReader.GetVendorName(),
				l_CReader.GetIfdType()
				);

			// extend the device list array by one
			CReaderList **l_pList = 
				new CReaderList *[m_uNumReaders + 1];

			if (m_pList) {

				// copy old list of readers to new list of readers
				memcpy(
					l_pList, 
					m_pList, 
					m_uNumReaders * sizeof(CReaderList *)
					);

				delete m_pList;
			}

			m_pList = l_pList;
			m_pList[m_uNumReaders++] = l_CReaderList;
		}

        l_CReader.Close();
    } 	
}

CReaderList::CReaderList() 
/*++

Routine Description:
	Constructor for CReaderList.	
	Builds a list of currently installed and running smart card readers.
	It first tries to find all WDM PnP drivers. These should be registered
	in the registry under the class guid for smart card readers.

	Then it looks for all 'old style' reader names like \\.\SCReaderN

	And then it looks for all Windows 9x VxD style readers, which are
	registered in the registry through smclib.vxd

--*/
{ 	
    HKEY l_hKey;
    ULONG l_uIndex;

    m_uCurrentReader = (ULONG) -1;

	if (m_uRefCount++ != 0) {

		return;	 	
	}

    // look up all WDM PnP smart card readers
    if (RegOpenKey(
        HKEY_LOCAL_MACHINE,
        "System\\CurrentControlSet\\Control\\DeviceClasses\\{50DD5230-BA8A-11D1-BF5D-0000F805F530}",
        &l_hKey) == ERROR_SUCCESS) {

        ULONG l_uStatus, l_uIndex;

        for (l_uIndex = 0; ;l_uIndex++) {

            HKEY l_hDeviceTypeKey;
            UCHAR l_rgchDeviceTypeKey[128];
            ULONG l_uDeviceTypeInstance = 0;

            // look up 'device type subkey'
            l_uStatus = RegEnumKey(  
                l_hKey,   
                l_uIndex, 
                (PCHAR) l_rgchDeviceTypeKey, 
                sizeof(l_rgchDeviceTypeKey)
                );

            if (l_uStatus != ERROR_SUCCESS) {

                // no smart card device types found 
                break;
            }

            // open the found 'device type subkey'
            l_uStatus = RegOpenKey(  
                l_hKey,    
                (PCHAR) l_rgchDeviceTypeKey,
                &l_hDeviceTypeKey
                );
        
            if (l_uStatus != ERROR_SUCCESS) {

                continue;
            }

            for (l_uDeviceTypeInstance = 0; ; l_uDeviceTypeInstance++) {

                DWORD l_dwKeyType;
                HKEY l_hDeviceTypeInstanceKey;
                UCHAR l_rgchDeviceName[128];
                UCHAR l_rgchDeviceTypeInstanceKey[128];
                ULONG l_uDeviceNameLen = sizeof(l_rgchDeviceName);
         	    
                // look up device instance subkey
                l_uStatus = RegEnumKey(  
                    l_hDeviceTypeKey,   
                    l_uDeviceTypeInstance, 
                    (PCHAR) l_rgchDeviceTypeInstanceKey, 
                    sizeof(l_rgchDeviceTypeInstanceKey)
                    );

                if (l_uStatus != ERROR_SUCCESS) {

                    // no instance of the smart card reader type found
                    break;
                }

                // open the found 'device type instance subkey'
                l_uStatus = RegOpenKey(  
                    l_hDeviceTypeKey,
                    (PCHAR) l_rgchDeviceTypeInstanceKey,
                    &l_hDeviceTypeInstanceKey
                    );

                if (l_uStatus != ERROR_SUCCESS) {

                    continue;
                }

                // get the name of the device
                if (RegQueryValueEx(
                    l_hDeviceTypeInstanceKey,
                    "SymbolicLink",
                    NULL,
                    &l_dwKeyType,
                    l_rgchDeviceName,
                    &l_uDeviceNameLen) == ERROR_SUCCESS) {

                    AddDevice(l_rgchDeviceName, READER_TYPE_WDM);
                }
            }
        }
    }

    // Now look up all non PnP readers
    for (l_uIndex = 0; l_uIndex < MAXIMUM_SMARTCARD_READERS; l_uIndex++) {

        UCHAR l_rgchDeviceName[128];

        sprintf(
            (PCHAR) l_rgchDeviceName, 
            "\\\\.\\SCReader%d", 
            l_uIndex
            );

        AddDevice(l_rgchDeviceName, READER_TYPE_NT);
    }

    // Add all Windows95 type readers to the list
    if (RegOpenKey(
        HKEY_LOCAL_MACHINE,
        "System\\CurrentControlSet\\Services\\VxD\\Smclib\\Devices",
        &l_hKey) == ERROR_SUCCESS) {

        ULONG l_uIndex;

        for (l_uIndex = 0; l_uIndex < MAXIMUM_SMARTCARD_READERS; l_uIndex++) {

            UCHAR l_rgchDeviceName[128], l_rgchValueName[128];
            DWORD l_dwValueType;
            ULONG l_uDeviceNameLen = sizeof(l_rgchDeviceName);
            ULONG l_uValueNameLen = sizeof(l_rgchValueName);

            if (RegEnumValue(  
                l_hKey,
                l_uIndex,
                (PCHAR) l_rgchValueName,
                &l_uValueNameLen,
                NULL,
                &l_dwValueType,
                (PUCHAR) l_rgchDeviceName,
                &l_uDeviceNameLen) == ERROR_SUCCESS) {

                AddDevice(CString("\\\\.\\") + l_rgchDeviceName, READER_TYPE_VXD);
            }
        }
    }
}

CReaderList::~CReaderList()
{
	ULONG l_uIndex;

	if (--m_uRefCount != 0) {

		return;	 	
	}

	for (l_uIndex = 0; l_uIndex < m_uNumReaders; l_uIndex++) {

		delete m_pList[l_uIndex];	 	
	}

	if (m_pList) {
	 	
		delete m_pList;
	}
}

// ****************************************************************************
// CReader methods 
// ****************************************************************************

CReader::CReader(
    void
    )
{
    m_uReplyBufferSize = sizeof(m_rgbReplyBuffer);

    m_Ovr.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    ResetEvent(m_Ovr.hEvent);

    m_OvrWait.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    ResetEvent(m_OvrWait.hEvent);

    m_ScardIoRequest.dwProtocol = 0;
    m_ScardIoRequest.cbPciLength = sizeof(m_ScardIoRequest);

    m_fDump = FALSE;
}
void
CReader::Close(
    void
    )
{
#ifndef SIMULATE
    CloseHandle(m_hReader);
#endif
}

CString &
CReader::GetIfdType(
    void
    )
{
    ULONG l_uAttr = SCARD_ATTR_VENDOR_IFD_TYPE;

#ifdef SIMULATE
	m_CIfdType = "DEBUG IfdType";
#endif

    if (m_CIfdType.IsEmpty()) {
     	
	    BOOL l_bResult = DeviceIoControl(
		    m_hReader,
		    IOCTL_SMARTCARD_GET_ATTRIBUTE,
		    (void *) &l_uAttr,
            sizeof(ULONG),
            m_rgbReplyBuffer,
            sizeof(m_rgbReplyBuffer),
		    &m_uReplyLength,
		    &m_Ovr
            );

        if (l_bResult) {

            m_rgbReplyBuffer[m_uReplyLength] = '\0';
            m_CIfdType = m_rgbReplyBuffer;
        }
    }

    return m_CIfdType;
}

LONG 
CReader::GetState(
    PULONG out_puState
    )
{
    SetLastError(0);

	BOOL l_bResult = DeviceIoControl(
		m_hReader,
		IOCTL_SMARTCARD_GET_STATE,
		NULL, 
        0,
        (void *) out_puState,
        sizeof(ULONG),
		&m_uReplyLength,
		&m_Ovr
        );

    return GetLastError();
}

CString &
CReader::GetVendorName(
    void
    )
{
    ULONG l_uAttr = SCARD_ATTR_VENDOR_NAME;

#ifdef SIMULATE
	m_CVendorName = "DEBUG Vendor";
#endif

    if (m_CVendorName.IsEmpty()) {
     	
	    BOOL l_bResult = DeviceIoControl(
		    m_hReader,
		    IOCTL_SMARTCARD_GET_ATTRIBUTE,
		    (void *) &l_uAttr,
            sizeof(ULONG),
            m_rgbReplyBuffer,
            sizeof(m_rgbReplyBuffer),
		    &m_uReplyLength,
		    &m_Ovr
            );

        if (l_bResult) {

            m_rgbReplyBuffer[m_uReplyLength] = '\0';
            m_CVendorName = m_rgbReplyBuffer;
        }
    }

    return m_CVendorName;
}

ULONG
CReader::GetDeviceUnit(
    void
    )
{
    ULONG l_uAttr = SCARD_ATTR_DEVICE_UNIT;

	BOOL l_bResult = DeviceIoControl(
		m_hReader,
		IOCTL_SMARTCARD_GET_ATTRIBUTE,
		(void *) &l_uAttr,
        sizeof(ULONG),
        m_rgbReplyBuffer,
        sizeof(m_rgbReplyBuffer),
		&m_uReplyLength,
		&m_Ovr
        );

    return (ULONG) *m_rgbReplyBuffer;
}

BOOL
CReader::Open(
    void    
    )
{
    if (m_CDeviceName.IsEmpty()) {

        return FALSE;
    }

    // Try to open the reader.
    m_hReader = CreateFile(
    	(LPCSTR) m_CDeviceName,
        GENERIC_READ | GENERIC_WRITE,
        0,
        NULL,
        OPEN_EXISTING,
        FILE_FLAG_OVERLAPPED,
        NULL
        );

    if (m_hReader == INVALID_HANDLE_VALUE ) {

        return FALSE;
    }

    return TRUE;
}

BOOL
CReader::Open(
    CString & in_CDeviceName
    )
{
    // save the reader name
    m_CDeviceName += in_CDeviceName;

#ifdef SIMULATE
	return TRUE;
#endif

    return Open();
}

LONG
CReader::PowerCard(
    ULONG in_uMinorIoControl
    )
/*++

Routine Description:
	
    Cold resets the current card and sets the ATR
    of the card in the reader class.

Return Value:

    Returns the result of the DeviceIoControl call

--*/
{
    BOOL l_bResult;
    ULONG l_uReplyLength;
    CHAR l_rgbAtr[SCARD_ATR_LENGTH];

    SetLastError(0);

   	l_bResult = DeviceIoControl (
        m_hReader,
		IOCTL_SMARTCARD_POWER,
		&in_uMinorIoControl,
		sizeof(in_uMinorIoControl),
        l_rgbAtr,
		sizeof(l_rgbAtr),
		&l_uReplyLength,
		&m_Ovr
        ); 	

    if (l_bResult == FALSE && GetLastError() == ERROR_IO_PENDING) {
    
        SetLastError(0);                             
        
        l_bResult = GetOverlappedResult(
            m_hReader,
            &m_Ovr,
            &l_uReplyLength,
            TRUE
            );
    }

    if (GetLastError() == ERROR_SUCCESS) {
     	
        SetAtr((PBYTE) l_rgbAtr, l_uReplyLength);
    }

    return GetLastError();
}

LONG
CReader::SetProtocol(
    const ULONG in_uProtocol
    )
{
    BOOL l_bResult;

 	m_ScardIoRequest.dwProtocol = in_uProtocol;
    m_ScardIoRequest.cbPciLength = sizeof(SCARD_IO_REQUEST);

    SetLastError(0);

	l_bResult = DeviceIoControl (
		m_hReader,
		IOCTL_SMARTCARD_SET_PROTOCOL,
		(void *) &in_uProtocol,
        sizeof(ULONG),
        m_rgbReplyBuffer,
        sizeof(m_rgbReplyBuffer),
		&m_uReplyLength,
		&m_Ovr
        ); 	

    if (l_bResult == FALSE && GetLastError() == ERROR_IO_PENDING) {
    
        SetLastError(0);
        
        l_bResult = GetOverlappedResult(
            m_hReader,
            &m_Ovr,
            &m_uReplyLength,
            TRUE
            );
    }

    return GetLastError();
}

LONG
CReader::Transmit(
    PUCHAR in_pchApdu,
    ULONG in_uApduLength,
    PUCHAR *out_pchReply,
    PULONG out_puReplyLength
    )
/*++

Routine Description:
    Transmits an apdu using the currently connected reader

Arguments:
    in_pchApdu - the apdu to send
    in_uApduLength - the length of the apdu
    out_pchReply - result returned from the reader/card
    out_puReplyLength - pointer to store number of bytes returned

Return Value:
    The nt-status code returned by the reader

--*/
{
    BOOL l_bResult;
    ULONG l_uBufferLength = m_ScardIoRequest.cbPciLength + in_uApduLength;
    PUCHAR l_pchBuffer = new UCHAR [l_uBufferLength];

    // Copy io-request header to request buffer
    memcpy(
        l_pchBuffer, 
        &m_ScardIoRequest, 
        m_ScardIoRequest.cbPciLength
        );

    // copy io-request header to reply buffer
    memcpy(
        m_rgbReplyBuffer, 
        &m_ScardIoRequest, 
        m_ScardIoRequest.cbPciLength
        );

    // append apdu to buffer
    memcpy(
        l_pchBuffer + m_ScardIoRequest.cbPciLength, 
        in_pchApdu,
        in_uApduLength
        );

    if (m_fDump) {

        DumpData(
            "\n   RequestData:",
            3,
            l_pchBuffer,
            l_uBufferLength
            );
    }

    SetLastError(0);
    // send the request to the card
	l_bResult = DeviceIoControl (
		m_hReader,
		IOCTL_SMARTCARD_TRANSMIT,
		l_pchBuffer,
        l_uBufferLength,
        m_rgbReplyBuffer,
        m_uReplyBufferSize,
		&m_uReplyLength,
		&m_Ovr
        ); 	

    if (l_bResult == FALSE && GetLastError() == ERROR_IO_PENDING) {
    
        // wait for result
        SetLastError(0);
        
        l_bResult = GetOverlappedResult(
            m_hReader,
            &m_Ovr,
            &m_uReplyLength,
            TRUE
            );
    }
    
    if (m_fDump) {

        printf("   IOCTL returned %lxh\n", GetLastError());

        if (l_bResult) {
         	
            DumpData(
                "   ReplyData:",
                3,
                m_rgbReplyBuffer,
                m_uReplyLength
                );
        }
        printf("%*s", 53, "");
    }

    *out_pchReply = (PUCHAR) m_rgbReplyBuffer + m_ScardIoRequest.cbPciLength;
    *out_puReplyLength = m_uReplyLength - m_ScardIoRequest.cbPciLength;

    delete l_pchBuffer;
    return GetLastError();
}

LONG
CReader::VendorIoctl(
    CString &o_Answer
    )
{
	BOOL l_bResult = DeviceIoControl(
		m_hReader,
        CTL_CODE(FILE_DEVICE_SMARTCARD, 2048, METHOD_BUFFERED, FILE_ANY_ACCESS),
		NULL,
        NULL, 
        m_rgbReplyBuffer,
        sizeof(m_rgbReplyBuffer),
		&m_uReplyLength,
		&m_Ovr
        );


    if (l_bResult) {

        m_rgbReplyBuffer[m_uReplyLength] = '\0';
        o_Answer = CString(m_rgbReplyBuffer);
    }

    return GetLastError();
}

LONG
CReader::WaitForCard(
    const ULONG in_uWaitFor
    )
{
    BOOL l_bResult;
    ULONG l_uReplyLength;

    SetLastError(0);
        
   	l_bResult = DeviceIoControl (
        m_hReader,
		in_uWaitFor,
		NULL,
		0,
		NULL,
		0,
		&l_uReplyLength,
		&m_Ovr
        ); 	

    if (l_bResult == FALSE && GetLastError() == ERROR_IO_PENDING) {

        SetLastError(0);

        l_bResult = GetOverlappedResult(
            m_hReader,
            &m_Ovr,
            &l_uReplyLength,
            TRUE
            );
    }
    return GetLastError();
}

LONG
CReader::StartWaitForCard(
    const ULONG in_uWaitFor
    )
{
    BOOL l_bResult;
    ULONG l_uReplyLength;

    ResetEvent(m_OvrWait.hEvent);
        
   	l_bResult = DeviceIoControl (
        m_hReader,
		in_uWaitFor,
		NULL,
		0,
		NULL,
		0,
		&l_uReplyLength,
		&m_OvrWait
        ); 	

    return GetLastError();
}

LONG
CReader::FinishWaitForCard(
	const BOOL in_bWait						   
    )
{
    BOOL l_bResult;
    ULONG l_uReplyLength;

    SetLastError(0);

    l_bResult = GetOverlappedResult(
        m_hReader,
        &m_OvrWait,
        &l_uReplyLength,
        in_bWait
        );

	return GetLastError();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\ifdtest\ifdtest.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ifdtest.h
//
//--------------------------------------------------------------------------

#define min(a, b)  (((a) < (b)) ? (a) : (b)) 

// Status codes
#define IFDSTATUS_SUCCESS       0
#define IFDSTATUS_FAILED        1
#define IFDSTATUS_CARD_UNKNOWN  2
#define IFDSTATUS_TEST_UNKNOWN  3
#define IFDSTATUS_NO_PROVIDER   4
#define IFDSTATUS_NO_FUNCTION   5
#define IFDSTATUS_END           7

// query codes
#define IFDQUERY_CARD_TESTED    0
#define IFDQUERY_CARD_NAME      1
#define IFDQUERY_TEST_RESULT    2

#define READER_TYPE_WDM         "WDM PnP"
#define READER_TYPE_NT          "NT 4.00"
#define READER_TYPE_VXD         "Win9x VxD"

#define OS_WINNT4               "Windows NT 4.0"
#define OS_WINNT5               "Windows NT 5.0"
#define OS_WIN95                "Windows 95"
#define OS_WIN98                "Windows 98"

#define MAX_NUM_ATR				3

// Prototypes 
void LogMessage(PCHAR in_pchFormat, ...);
void LogOpen(PCHAR in_pchLogFile);
void TestStart(PCHAR in_pchFormat,  ...);
void TestCheck(BOOL in_bResult, PCHAR in_pchFormat, ...);
void TestEnd(void);
BOOL TestFailed(void);
BOOL ReaderFailed(void);
CString & GetOperatingSystem(void);

void
TestCheck(
    ULONG in_lResult,
    const PCHAR in_pchOperator,
    const ULONG in_uExpectedResult,
    ULONG in_uResultLength,
    ULONG in_uExpectedLength,
    UCHAR in_chSw1,
    UCHAR in_chSw2,
    UCHAR in_chExpectedSw1,
    UCHAR in_chExpectedSw2,
    PBYTE in_pchData,
    PBYTE in_pchExpectedData,
    ULONG  in_uDataLength
    );

extern "C" {

    LONG MapWinErrorToNtStatus(ULONG in_uErrorCode);
}

//
// some useful macros
//
#define TEST_END() {TestEnd(); if(TestFailed()) return IFDSTATUS_FAILED;}

#define TEST_CHECK_SUCCESS(Text, Result) \
TestCheck( \
    Result == ERROR_SUCCESS, \
    "%s.\nReturned %8lxH (NTSTATUS %8lxH)\nExpected        0H (NTSTATUS        0H)", \
    Text, \
    Result, \
    MapWinErrorToNtStatus(Result) \
    ); 

#define TEST_CHECK_NOT_SUPPORTED(Text, Result) \
TestCheck( \
    Result == ERROR_NOT_SUPPORTED, \
    "%s.\nReturned %8lxH (NTSTATUS %8xH)\nExpected %38xH (NTSTATUS %8lxH)", \
    Text, \
    Result, \
    MapWinErrorToNtStatus(Result), \
    ERROR_NOT_SUPPORTED, \
    MapWinErrorToNtStatus(ERROR_NOT_SUPPORTED) \
    ); 
//
// Class definitions
//
class CAtr {

    UCHAR m_rgbAtr[SCARD_ATR_LENGTH];
    ULONG m_uAtrLength;
 	
public:
    CAtr() {
     	                                  
        m_uAtrLength = 0;
        memset(m_rgbAtr, 0, SCARD_ATR_LENGTH);
    }

    CAtr(
        BYTE in_rgbAtr[], 
        ULONG in_uAtrLength
        )
    {
        *this = CAtr();
        m_uAtrLength = min(SCARD_ATR_LENGTH, in_uAtrLength);
        memcpy(m_rgbAtr, in_rgbAtr, m_uAtrLength);
    }

    PCHAR GetAtrString(PCHAR io_pchBuffer);
    PBYTE GetAtr(PBYTE *io_pchBuffer, PULONG io_puAtrLength) {
     	
        *io_pchBuffer = (PBYTE) m_rgbAtr;
        *io_puAtrLength = m_uAtrLength;
        return (PBYTE) m_rgbAtr;
    }

	ULONG GetLength() {

		return m_uAtrLength;
	}

    operator==(const CAtr& a) {

        return (m_uAtrLength && 
            a.m_uAtrLength == m_uAtrLength && 
            memcmp(m_rgbAtr, a.m_rgbAtr, m_uAtrLength) == 0);
    }

    operator!=(const CAtr& a) {

        return !(*this == a);
    }
};

class CReader {

    // device name. E.g. SCReader0
    CString m_CDeviceName;

    // Name of the reader to be tested. E.g. Bull
    CString m_CVendorName;

    // Name of the reader to be tested. E.g. Bull
    CString m_CIfdType;

    // Atr of the current card
    class CAtr m_CAtr;

    // handle to the reader device
    HANDLE m_hReader;

    // Overlapped structure used by DeviceIoControl
    OVERLAPPED m_Ovr;

    // Overlapped structure used by WaitFor...
    OVERLAPPED m_OvrWait;

    // io-request struct used for transmissions
    SCARD_IO_REQUEST m_ScardIoRequest;

    // Storage area for smart card i/o
    UCHAR m_rgbReplyBuffer[1024];

    // size of the reply buffer
    ULONG m_uReplyBufferSize;

    // Number of bytes returned by the card
    ULONG m_uReplyLength;

    // function used by WaitForCardInsertion|Removal
    LONG WaitForCard(const ULONG);

    LONG StartWaitForCard(const ULONG);

    LONG PowerCard(ULONG in_uMinorIoControlCode);

    BOOL m_fDump;

public:
    CReader();

    // Close reader
    void Close(void);

    // power functions
    LONG CReader::ColdResetCard(void) {

        return PowerCard(SCARD_COLD_RESET); 	
    }  

    LONG CReader::WarmResetCard(void) {

        return PowerCard(SCARD_WARM_RESET); 	
    }  

    LONG CReader::PowerDownCard(void) {

        return PowerCard(SCARD_POWER_DOWN); 	
    }  

    PBYTE GetAtr(PBYTE *io_pchBuffer, PULONG io_puAtrLength) {
     	
        return m_CAtr.GetAtr(io_pchBuffer, io_puAtrLength);
    }

    PCHAR GetAtrString(PCHAR io_pchBuffer) {
     	
        return m_CAtr.GetAtrString(io_pchBuffer);
    }

    HANDLE GetHandle(void) {
     	
        return m_hReader;
    }

    CString &GetDeviceName(void) {
     	
        return m_CDeviceName;
    }

    LONG VendorIoctl(CString &o_CAnswer);
    CString &GetVendorName(void);
    CString &GetIfdType(void);
    ULONG GetDeviceUnit(void);
    LONG GetState(PULONG io_puState);

    // Open the reader
    BOOL Open(
        CString &in_CReaderName
        );

    // (Re)Open reader using the existing name
    BOOL Open(void);

	//
    // Set size of the reply buffer
    // (Only for testing purposes)
	//
    void SetReplyBufferSize(ULONG in_uSize) {
     	
        if (in_uSize > sizeof(m_rgbReplyBuffer)) {

            m_uReplyBufferSize = sizeof(m_rgbReplyBuffer);

        } else {
         	
            m_uReplyBufferSize = in_uSize;
        }
    }

    // assigns an ATR
    void SetAtr(PBYTE in_pchAtr, ULONG in_uAtrLength) {

        m_CAtr = CAtr(in_pchAtr, in_uAtrLength); 	    
    }

    // returns the ATR of the current card
    class CAtr &GetAtr() {

        return m_CAtr; 	
    }

    // set protocol to be used
    LONG SetProtocol(const ULONG in_uProtocol);

    // transmits an APDU to the reader/card
    LONG Transmit(
        PBYTE in_pchRequest,
        ULONG in_uRequestLength,
        PBYTE *out_pchReply,
        PULONG out_puReplyLength
		);

    // wait to insert card
    LONG WaitForCardInsertion() {
     	
        return WaitForCard(IOCTL_SMARTCARD_IS_PRESENT);
    };

    // wait to remove card
    LONG WaitForCardRemoval() {
     	
        return WaitForCard(IOCTL_SMARTCARD_IS_ABSENT);
    };

    LONG StartWaitForCardRemoval() {
     	
        return StartWaitForCard(IOCTL_SMARTCARD_IS_ABSENT);
    };

    LONG StartWaitForCardInsertion() {
     	
        return StartWaitForCard(IOCTL_SMARTCARD_IS_PRESENT);
    };

    LONG FinishWaitForCard(const BOOL in_bWait);

    void SetDump(BOOL in_fOn) {
     	
        m_fDump = in_fOn;
    }
};

class CCardProvider {
 	
    // Start of list pointer
    static class CCardProvider *s_pFirst;

    // Pointer to next provider
    class CCardProvider *m_pNext;

    // name of the card to be tested
    CString m_CCardName;

    // atr of this card
    CAtr m_CAtr[3];

    // test no to run
    ULONG m_uTestNo;

    // max number of tests
    ULONG m_uTestMax;

    // This flag indicates that the card test was unsuccessful
    BOOL m_bTestFailed;

    // This flag indicates that the card has been tested
    BOOL m_bCardTested;

    // set protocol function
    ULONG ((*m_pSetProtocol)(class CCardProvider&, class CReader&));

    // set protocol function
    ULONG ((*m_pCardTest)(class CCardProvider&, class CReader&));

public:

    // Constructor
    CCardProvider(void);

    // Constructor to be used by plug-in 
    CCardProvider(void (*pEntryFunction)(class CCardProvider&));

    // Method that mangages all card tests
    void CardTest(class CReader&, ULONG in_uTestNo);

    // return if there are still untested cards
    BOOL CardsUntested(void);

    // List all cards that have not been tested
    void ListUntestedCards(void);

    // Assigns a friendly name to a card
    void SetCardName(CHAR in_rgchCardName[]);

    // Set ATR of the card
    void SetAtr(PBYTE in_rgbAtr, ULONG in_uAtrLength);

    // Assign callback functions
    void SetProtocol(ULONG ((in_pFunction)(class CCardProvider&, class CReader&))) {
     	
        m_pSetProtocol = in_pFunction;
    }

    void SetCardTest(ULONG ((in_pFunction)(class CCardProvider&, class CReader&))) {
     	
        m_pCardTest = in_pFunction;
    }

    // returns the test number to perform
    ULONG GetTestNo(void) {
     	
        return m_uTestNo;
    }

	BOOL IsValidAtr(CAtr in_CAtr) {

		for (int i = 0; i < MAX_NUM_ATR; i++) {

			if (m_CAtr[i] == in_CAtr) {

				return TRUE;
			}
		}
		return FALSE;
	}
};

// represents a list of all installed readers
class CReaderList {

    // number of constructor calls to avoid multiple build of reader list
	static ULONG m_uRefCount;

    // number of currently installed readers
    static ULONG m_uNumReaders;

    // pointer to array of reader list
    static class CReaderList **m_pList;

    ULONG m_uCurrentReader;

    CString m_CDeviceName;
    CString m_CPnPType;
    CString m_CVendorName;
    CString m_CIfdType;

public:

    CReaderList();
    CReaderList(
        CString &in_CDeviceName,
        CString &in_CPnPType,
        CString &in_CVendorName,
        CString &in_CIfdType
        );
	~CReaderList();
	
    void AddDevice(
        CString in_pchDeviceName,
        CString in_pchPnPType
        );

    CString &GetVendorName(ULONG in_uIndex);
    CString &GetDeviceName(ULONG in_uIndex);
    CString &GetIfdType(ULONG in_uIndex);
    CString &GetPnPType(ULONG in_uIndex);

    ULONG GetNumReaders(void) {
     	
        return m_uNumReaders;
    }
};

// This structure represents the T=0 result file of a smart card
typedef struct _T0_RESULT_FILE_HEADER {
 	
    // Offset to first test result
    UCHAR Offset;

    // Number of times the card has been reset
    UCHAR CardResetCount;

    // Version number of this card
    UCHAR CardMajorVersion;
    UCHAR CardMinorVersion;

} T0_RESULT_FILE_HEADER, *PT0_RESULT_FILE_HEADER;

typedef struct _T0_RESULT_FILE {

    //
    // The following structures store the results
    // of the tests. Each result comes with the 
    // reset count when the test was performed.
    // This is used to make sure that we read not
    // the result from an old test, maybe even 
    // performed with another reader/driver.
    //
    struct {

        UCHAR Result;
        UCHAR ResetCount; 	

    } TransferAllBytes;

    struct {

        UCHAR Result;
        UCHAR ResetCount; 	

    } TransferNextByte;

    struct {

        UCHAR Result;
        UCHAR ResetCount; 	

    } Read256Bytes;

    struct {

        UCHAR Result;
        UCHAR ResetCount; 	

    } Case1Apdu;

    struct {

        UCHAR Result;
        UCHAR ResetCount; 	

    } RestartWorkWaitingTime;

    struct {

        UCHAR Result;
        UCHAR ResetCount; 	

    } PTS;

    struct {

        UCHAR Result;
        UCHAR ResetCount; 	

    } PTSDataCheck;

} T0_RESULT_FILE, *PT0_RESULT_FILE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\ifdtest\ifdscrpt.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    scdrvtst

Abstract:

     IOCTL test program for smart card driver.

Author:

    Klaus Schutz (kschutz) Dec-1996

Revision History:     

--*/

#include <afx.h>
#include <afxtempl.h>
#include <winioctl.h>

#include <conio.h>

#include <winsmcrd.h>
#include "ifdtest.h"

class CCardList;

// This represents a single function of a card
class CCardFunction  {
	
	CString m_CName;
	CHAR m_chShortCut;
	CByteArray m_CData;
	CCardFunction *m_pCNextFunction;

public:
	CCardFunction(
		CString &in_CName,
		CHAR in_chShortCut,
		CByteArray &in_CData
		);
	friend CCardList;
};

// This is a single card
class CCard {
	
	CString	m_CName;
    CHAR m_chShortCut;
	CCardFunction *m_pCFirstFunction;
	CCard *m_pCNextCard;

public:
	CCard(
		CString & in_CCardName,
		CHAR in_chShortCut
		);

	friend CCardList;
};

// This implements a list of cards
class CCardList  {

	CString	m_CScriptFileName;
	CCard *m_pCFirstCard;
	CCard *m_pCCurrentCard;
    ULONG m_uNumCards;

public:
	CCardList(CString &in_CScriptFileName);

    void 
	AddCard(
		CString	&in_CardName,
        CHAR in_chShortCut
		);

	void
	AddCardFunction(
		CString &in_CFunctionName, 
		CHAR in_chShortCut,
		CByteArray &l_pCData
		);

    void ShowCards(
        void (__cdecl *in_pCallBack)(void *in_pContext, PCHAR in_pchCardName),
        void *in_pContext
        );

	BOOL SelectCard(CHAR in_chShortCut);
	void ReleaseCard(void);
	CString GetCardName(void);
    ULONG GetNumCards(void) {
     	
        return m_uNumCards;
    }
	BOOL	IsCardSelected(void);
    BOOL	ListFunctions(void);
	CByteArray *GetApdu(CHAR in_chShortCut);
};

CCardFunction::CCardFunction(
	CString	&in_CName,
    CHAR in_chShortCut,
	CByteArray &in_CData
	)
/*++
	Adds a function to the current card
--*/
{
	m_CName = in_CName;
	m_chShortCut = in_chShortCut;
	m_CData.Copy(in_CData);
	m_pCNextFunction = NULL;
}

CCard::CCard(
	CString	&in_CCardName,
    CHAR in_chShortCut
	)
/*++

Routine Description:

	Constructor for a new card

Arguments:

	CardName - Reference to card to add
	in_uPos - index of shortcut key

Return Value:

--*/
{
	m_CName = in_CCardName;
	m_chShortCut = in_chShortCut;
	m_pCNextCard = NULL;
	m_pCFirstFunction = NULL;
}
    
void
CCardList::AddCard(
	CString	&in_CCardName,
    CHAR in_chShortCut
	)
/*++

Routine Description:
	Adds a new card to CardList

Arguments:
	in_CCardName - Reference to card to add

--*/
{
	CCard *l_pCNewCard = new CCard(in_CCardName, in_chShortCut);

	if (m_pCFirstCard == NULL) {

		m_pCFirstCard = l_pCNewCard;

	} else {

		CCard *l_pCCurrent = m_pCFirstCard;
		while (l_pCCurrent->m_pCNextCard) {

			l_pCCurrent = l_pCCurrent->m_pCNextCard;
		}

		l_pCCurrent->m_pCNextCard = l_pCNewCard;
	}

	m_pCCurrentCard = l_pCNewCard;
    m_uNumCards += 1;
}

void
CCardList::AddCardFunction(
	CString	&in_CFunctionName,
    CHAR in_chShortCut,
	CByteArray &in_pCData
	)
/*++

Routine Description:
	Adds a new function to the current card

Arguments:
	in_CCardName - Reference to card to add
	in_chShortCut - Shortcut key

Return Value:

--*/
{
	CCardFunction *l_pCNewFunction = new CCardFunction(
		in_CFunctionName, 
		in_chShortCut, 
		in_pCData
		);

	if (m_pCCurrentCard->m_pCFirstFunction == NULL) {

		m_pCCurrentCard->m_pCFirstFunction = l_pCNewFunction;

	} else {

		CCardFunction *l_pCCurrent = m_pCCurrentCard->m_pCFirstFunction;
		while (l_pCCurrent->m_pCNextFunction) {

			l_pCCurrent = l_pCCurrent->m_pCNextFunction;
		}

		l_pCCurrent->m_pCNextFunction = l_pCNewFunction;
	}
}

CCardList::CCardList(
	CString &in_CScriptFileName
	)
/*++

Routine Description:

	Adds a new function to the current card

Arguments:

	CardName - Reference to card to add
	in_uPos - index of shortcut key

Return Value:

--*/
{
	CStdioFile l_CScriptFile;
    CHAR l_rgchBuffer[255], l_chKey;
    ULONG l_uLineNumber = 0;
    BOOL l_bContinue = FALSE;
    CByteArray l_Data;
    CString l_CCommand;
        
	m_pCFirstCard = NULL;
	m_pCCurrentCard = NULL;
    
    if (l_CScriptFile.Open(in_CScriptFileName, CFile::modeRead) == NULL) {

		printf("Script file cannot be opened: %s\n", in_CScriptFileName);
    	return;
    }

	m_CScriptFileName = in_CScriptFileName;
    
    while (l_CScriptFile.ReadString(l_rgchBuffer, sizeof(l_rgchBuffer) - 1)) {

        try {

	        CString l_CLine(l_rgchBuffer);
            CString l_CCommandApdu;

            l_uLineNumber += 1;

            if (l_CLine.GetLength() != 0 && l_CLine[0] == '#') {
        
                // comment line found, skip this line
                continue;
            }

	        // Get rid of leading and trailing spaces
	        l_CLine.TrimLeft();
	        l_CLine.TrimRight();

	        int l_ichStart = l_CLine.Find('[');	   
	        int l_ichKey = l_CLine.Find('&');
	        int l_ichEnd = l_CLine.Find(']');

	        if(l_ichStart == 0 && l_ichKey > 0 && l_ichEnd > l_ichKey + 1) {

		        //
		        // Add new card to list
		        //

		        CString l_CardName;

		        // Change card name from [&Card] to [C]ard
		        l_CardName = 
			        l_CLine.Mid(l_ichStart + 1, l_ichKey - l_ichStart - 1) + 
                    '[' +
                    l_CLine[l_ichKey + 1] +
                    ']' +
			        l_CLine.Mid(l_ichKey + 2, l_ichEnd - l_ichKey - 2);
		       
                AddCard(
                    l_CardName, 
                    l_CardName[l_ichKey]
                    );

	        } else if (l_ichStart == -1 && l_ichKey >= 0 && l_ichEnd == -1) {

		        //
		        // Add new function to current card
		        //

		        // Get function name
		        CString l_CToken = l_CLine.SpanExcluding(",");

		        // Search for shurtcut key
		        l_ichKey = l_CToken.Find('&');

		        if (l_ichKey == -1) {

			        throw "Missing '&' in function name";
		        }

                l_chKey = l_CToken[l_ichKey + 1];

		        // Change card function from &Function to [F]unction

                l_CCommand = 
			        l_CToken.Mid(l_ichStart + 1, l_ichKey - l_ichStart - 1) + 
                    '[' +
                    l_CToken[l_ichKey + 1] +
                    ']' +
			        l_CToken.Right(l_CToken.GetLength() - l_ichKey - 2);
                
                LONG l_lComma = l_CLine.Find(',');
            
                if (l_lComma == -1) {

			        throw "Missing command APDU";

                } else {
            	    
		            l_CCommandApdu = l_CLine.Right(l_CLine.GetLength() - l_lComma - 1);
                }

            } else if (l_bContinue) {

                l_CCommandApdu = l_CLine;        	

            } else if (l_CLine.GetLength() != 0 && l_CLine[0] != '#') {

                throw "Line invalid";
            }
       
            if (l_CCommandApdu != "") {
        
		        do {

			        CHAR l_chData;
                    l_CCommandApdu.TrimLeft();

                    ULONG l_uLength = l_CCommandApdu.GetLength();

                    if (l_uLength >= 3 &&
                        l_CCommandApdu[0] == '\'' &&
                        l_CCommandApdu[2] == '\'') {

                        // add ascsii character like 'c'
                        l_chData = l_CCommandApdu[1];
    			        l_Data.Add(l_chData);                
                 	    
                    } else if(l_uLength >= 3 &&
                              l_CCommandApdu[0] == '\"' &&
                              l_CCommandApdu.Right(l_uLength - 2).Find('\"') != -1) {

                        // add string like "string"
                        for (INT l_iIndex = 1; l_CCommandApdu[l_iIndex] != '\"'; l_iIndex++) {

            			    l_Data.Add(l_CCommandApdu[l_iIndex]);                                     	
                        }

                    } else if (l_CCommandApdu.SpanIncluding("0123456789abcdefABCDEF").GetLength() == 2) {

                        sscanf(l_CCommandApdu, "%2x", &l_chData);
    			        l_Data.Add(l_chData);                

                    } else {
                 	    
                        l_CCommandApdu = l_CCommandApdu.SpanExcluding(",");
                        static CString l_CError;
                        l_CError = "Illegal value found: " + l_CCommandApdu;
                        throw (PCHAR) (LPCSTR) l_CError;
                    } 
                	    
                    l_ichStart = l_CCommandApdu.Find(',');
                    if (l_ichStart != -1) {
                 	    
                        l_CCommandApdu = l_CLine.Right(l_CCommandApdu.GetLength() - l_ichStart - 1);
                    }

		        } while (l_ichStart != -1);

                if (l_CLine.Find('\\') != -1) {
        	        
                    // we have to read more data from the file
                    l_bContinue = TRUE;

                } else {

                    if (m_pCCurrentCard == NULL) {

                        throw "Card command found, but no card defined";
                    }
            	        
		            AddCardFunction(
			            l_CCommand,
			            l_chKey,
			            l_Data
			            );

                    l_CCommand = "";
                    l_Data.RemoveAll();
                    l_bContinue = FALSE;            	
                }
	        } 
        }
        catch (PCHAR in_pchError){
    
		    printf(
                "%s (%d): %s\n",
                in_CScriptFileName, 
                l_uLineNumber,
                in_pchError
                );	

            l_CCommand = "";
            l_Data.RemoveAll();
            l_bContinue = FALSE;            	
        }
	}

	m_pCCurrentCard = NULL;
}	    

void
CCardList::ShowCards(
    void (__cdecl *in_pCallBack)(void *in_pContext, PCHAR in_pchCardName),
    void *in_pContext
	)
{
	CCard *l_pCCurrentCard = m_pCFirstCard;

    if (l_pCCurrentCard == NULL) {

        return;
    }

	while(l_pCCurrentCard) {

        (*in_pCallBack) (in_pContext, (PCHAR) (LPCSTR) l_pCCurrentCard->m_CName);

		l_pCCurrentCard = l_pCCurrentCard->m_pCNextCard;
	}
}

BOOL
CCardList::ListFunctions(
	void
	)
/*++
	List all card functions
--*/
{
	if (m_pCCurrentCard == NULL)
		return FALSE;

	CCardFunction *l_pCCurrentFunction = m_pCCurrentCard->m_pCFirstFunction;

	while(l_pCCurrentFunction) {

		printf("   %s\n", (LPCSTR) l_pCCurrentFunction->m_CName);
		l_pCCurrentFunction = l_pCCurrentFunction->m_pCNextFunction;
	}

	return TRUE;
}

BOOL
CCardList::SelectCard(
	CHAR in_chShortCut
	)
/*++

Routine Description:
	Selectd a card by shorcut

Arguments:
	chShortCut - Shortcut key
	
Return Value:
    TRUE - card found and selected
    FALSE - no card with that shortcut found

--*/
{
	m_pCCurrentCard = m_pCFirstCard;

	while(m_pCCurrentCard) {

        if (m_pCCurrentCard->m_chShortCut == in_chShortCut) {

			return TRUE;
		}

		m_pCCurrentCard = m_pCCurrentCard->m_pCNextCard;
	}

	m_pCCurrentCard = NULL;

	return FALSE;
}

void CCardList::ReleaseCard(
	void
	)
{
	m_pCCurrentCard = NULL;
}

BOOL
CCardList::IsCardSelected(
	void
	)
{
	return (m_pCCurrentCard != NULL);
}

CString 
CCardList::GetCardName(
	void
	)
{
    CString l_CCardName;
    INT l_iLeft = m_pCCurrentCard->m_CName.Find('[');    
    INT l_iLength = m_pCCurrentCard->m_CName.GetLength();

    l_CCardName = 
        m_pCCurrentCard->m_CName.Left(l_iLeft) + 
        m_pCCurrentCard->m_CName[l_iLeft + 1] +
        m_pCCurrentCard->m_CName.Right(l_iLength - l_iLeft - 3);

    return l_CCardName;
}


CByteArray *
CCardList::GetApdu(
	CHAR in_chShortCut
	)
{
	CCardFunction *l_pCCurrentFunction = m_pCCurrentCard->m_pCFirstFunction;

	while(l_pCCurrentFunction) {

		if (l_pCCurrentFunction->m_chShortCut == in_chShortCut) {

			return &l_pCCurrentFunction->m_CData;
		}

		l_pCCurrentFunction = l_pCCurrentFunction->m_pCNextFunction;
	}

	return NULL; 
}

void 
ManualTest(
    CReader &in_CReader
    )
{
    CCardList l_CCardList(CString("ifdtest.dat"));
    ULONG l_uRepeat = 0;
    LONG l_lResult;
    CHAR l_chSelection;
    PUCHAR l_pbResult;
    ULONG l_uState, l_uPrevState;
    CString l_CAnswer;
	CString l_CCardStates[] =  { "Unknown", "Absent", "Present" , "Swallowed", "Powered", "Negotiable", "Specific" };
	BOOL l_bWaitForInsertion, l_bWaitForRemoval;

    while (TRUE)  {

        ULONG l_uResultLength = 0;

        printf("Manual reader test\n");
        printf("------------------\n");

		if (l_CCardList.IsCardSelected()) {

			printf("%s Commands:\n", l_CCardList.GetCardName());
			l_CCardList.ListFunctions();
	        printf("Other Commands:\n");
	        printf("   [r]epeat command\n");
	        printf("   E[x]it\n");

        } else {
         	
	        printf("Reader Commands:\n");
	        printf("   Protocol: T=[0], T=[1]\n");
	        printf("   Power   : [c]oldReset, Power[d]own, Warm[r]eset\n");
	        printf("   Card    : [p]resent, [a]bsent, [s]tatus\n");
	        printf("   PwrMngnt: [h]ibernation\n");
	        printf("   Test    : [v]endor IOCTL\n");
            if (l_CCardList.GetNumCards() != 0) {
             	
	            printf("Card Commands:\n");
			    l_CCardList.ShowCards((void (__cdecl *)(void *,char *)) printf, "   %s\n");
            }
	        printf("Other Commands:\n");
            printf("   E[x]it\n");
        }

	    printf(
            "\n[%s|%s|%ld] - Command: ", 
            in_CReader.GetVendorName(), 
            in_CReader.GetIfdType(), 
            in_CReader.GetDeviceUnit()
            );

        l_chSelection = (CHAR) _getche();
        putchar('\n');

        if (l_CCardList.IsCardSelected()) {

            switch (l_chSelection) {

            case 'x':
    			l_CCardList.ReleaseCard();
                continue;

            case 'r':
	            printf("Enter repeat count: ");
                scanf("%2d", &l_uRepeat);

                if (l_uRepeat > 99) {

                    l_uRepeat = 0;
                }
    	        printf("Enter command: ");
	            l_chSelection = (CHAR) _getche();             	

                // no bbreak;

            default:             	
                CByteArray *l_pCData;

                if((l_pCData = l_CCardList.GetApdu(l_chSelection)) != NULL) {
                    
                    l_lResult = in_CReader.Transmit(
                        l_pCData->GetData(),
                        (ULONG) l_pCData->GetSize(),
                        &l_pbResult,
                        &l_uResultLength
                        );

			    } else {

				    printf("Invalid Selection");
				    continue;
			    }
                break;
            }

		} else {

			switch(l_chSelection){
        
			case '0':
    			printf("Changing to T=0");
                l_lResult = in_CReader.SetProtocol(SCARD_PROTOCOL_T0);
                break;

			case '1':
				printf("Changing to T=1");
                l_lResult = in_CReader.SetProtocol(SCARD_PROTOCOL_T1);
                break;
            
			case 'c':
    			printf("Cold reset");
                l_lResult = in_CReader.ColdResetCard();
                in_CReader.GetAtr(&l_pbResult, &l_uResultLength);
                break;

			case 'r':
    			printf("Warm reset");
                l_lResult = in_CReader.WarmResetCard();
                in_CReader.GetAtr(&l_pbResult, &l_uResultLength);
                break;
            
			case 'd':
				printf("Power down");
                l_lResult = in_CReader.PowerDownCard();
				break;

            case 'h':
                printf("Hibernation test...(1 min)\nHibernate machine now!");
				l_uPrevState = SCARD_UNKNOWN;
				l_bWaitForInsertion = FALSE;
				l_bWaitForRemoval = FALSE;
                for (l_uRepeat = 0; l_uRepeat < 60; l_uRepeat++) {
                 	
                    l_lResult = in_CReader.GetState(&l_uState);

					l_lResult = in_CReader.FinishWaitForCard(FALSE);

					if (l_uPrevState != SCARD_UNKNOWN && 
						l_lResult == ERROR_SUCCESS) {

						printf("\n   Card %s", l_bWaitForInsertion ? "inserted" : "removed"); 
						l_uPrevState = SCARD_UNKNOWN;	
						l_bWaitForInsertion = FALSE;
						l_bWaitForRemoval = FALSE;
					}

					if (l_uState == SCARD_ABSENT) { 

						if (l_bWaitForInsertion == FALSE) {

							l_lResult = in_CReader.StartWaitForCardInsertion();
							l_bWaitForInsertion = TRUE;
							l_bWaitForRemoval = FALSE;
						}

					} else {
						
						if (l_bWaitForRemoval == FALSE) {

							l_lResult = in_CReader.StartWaitForCardRemoval();
							l_bWaitForRemoval = TRUE;
							l_bWaitForInsertion = FALSE;
						}
					}

					if (l_uState != l_uPrevState) {

						printf("\n   %s", l_CCardStates[l_uState]);
					}
					if (l_uState >= SCARD_PRESENT && l_uState < SCARD_NEGOTIABLE) {

		                l_lResult = in_CReader.ColdResetCard();
					}
					if (l_uState == SCARD_NEGOTIABLE) {

		                l_lResult = in_CReader.SetProtocol(
							SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1
							);
					}
					printf(".");
					l_uPrevState = l_uState;

                    LONG l_uGoal = clock() + CLOCKS_PER_SEC;
                    while(l_uGoal > clock())
                        ;
                }
				printf("\nPlease %s card", l_uState >= SCARD_PRESENT ? "remove" : "insert");
				in_CReader.FinishWaitForCard(TRUE);
				printf("\n");
                continue;
            	break;
                
			case 's': 
				printf("Get state");
                l_lResult = in_CReader.GetState(&l_uState);
				printf("Get state 1");
                l_pbResult = (PBYTE) &l_uState;
                l_uResultLength = sizeof(ULONG);
				break;

			case 'a':
				printf("Waiting for removal...");
                l_lResult = in_CReader.WaitForCardRemoval();
                break;

			case 'p':
				printf("Waiting for insertion...");
                l_lResult = in_CReader.WaitForCardInsertion();
                break;

            case 'v':
				printf("Test Vendor IOCTL...");
                l_lResult = in_CReader.VendorIoctl(l_CAnswer);
                l_pbResult = (PUCHAR) ((LPCSTR) l_CAnswer);
                l_uResultLength = l_CAnswer.GetLength();
               	break;
            
			case 'x':
				exit(0);
            
			default:
				// Try to select a card
				if (l_CCardList.SelectCard(l_chSelection) == FALSE) {

					printf("Invalid selection\n");
				}
                l_uRepeat = 0;
				continue;
			}
		}

        printf(
            "\nReturn value: %lxh (NTSTATUS %lxh)\n",                
            l_lResult, 
            MapWinErrorToNtStatus(l_lResult)
            );

        if (l_lResult == ERROR_SUCCESS && l_uResultLength) {

            ULONG l_uIndex, l_uLine, l_uCol;
        
            // The I/O request has data returned
            printf("Data returned (%ld bytes):\n   %04x: ", l_uResultLength, 0);

            for (l_uLine = 0, l_uIndex = 0; 
                 l_uLine < ((l_uResultLength - 1) / 8) + 1; 
                 l_uLine++) {

                for (l_uCol = 0, l_uIndex = l_uLine * 8; 
                     l_uCol < 8; l_uCol++, 
                     l_uIndex++) {
            	    
                    printf(
                        l_uIndex < l_uResultLength ? "%02x " : "   ",
                        l_pbResult[l_uIndex]
                        );
                }

              	putchar(' ');

                for (l_uCol = 0, l_uIndex = l_uLine * 8; 
                     l_uCol < 8; l_uCol++, 
                     l_uIndex++) {

                    printf(
                        l_uIndex < l_uResultLength ? "%c" : " ",
                        isprint(l_pbResult[l_uIndex]) ? l_pbResult[l_uIndex] : '.'
                        );
                }

                putchar('\n');
				if (l_uIndex  < l_uResultLength) {

                	printf("   %04x: ", l_uIndex + 1);
				}
            }
        }
        putchar('\n');
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\inc\scutil.h ===
/***************************************************************************

Copyright (c) 2002 Microsoft Corporation

Module Name:

        SCUTIL.H

Abstract:

        Public interface for Smartcard Driver Utility Library

Environment:

        Kernel Mode Only

Notes:

        THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
        KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
        IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
        PURPOSE.

        Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.


Revision History:

        05/14/2002 : created

Authors:

        Randy Aull


****************************************************************************/

#ifndef __SCUTIL_H__
#define __SCUTIL_H__



typedef NTSTATUS (*PNP_CALLBACK)(PDEVICE_OBJECT DeviceObject,
                                 PIRP Irp);

typedef NTSTATUS (*POWER_CALLBACK)(PDEVICE_OBJECT DeviceObject,
                                   DEVICE_POWER_STATE DeviceState,
                                   PBOOLEAN PostWaitWake);

typedef PVOID   SCUTIL_HANDLE;

NTSTATUS
ScUtil_Initialize(
    SCUTIL_HANDLE           UtilHandle,
    PDEVICE_OBJECT          PhysicalDeviceObject,
    PDEVICE_OBJECT          LowerDeviceObject,
    PSMARTCARD_EXTENSION    SmartcardExtension,
    PIO_REMOVE_LOCK         RemoveLock,
    PNP_CALLBACK            StartDevice,
    PNP_CALLBACK            StopDevice,
    PNP_CALLBACK            RemoveDevice,
    PNP_CALLBACK            FreeResources,
    POWER_CALLBACK          SetPowerState
    );

NTSTATUS
ScUtil_DeviceIOControl(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

NTSTATUS
ScUtil_PnP(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

NTSTATUS
ScUtil_Power(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

NTSTATUS
ScUtil_Cleanup(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

NTSTATUS
ScUtil_UnloadDriver(
    PDRIVER_OBJECT DriverObject
    );

NTSTATUS
ScUtil_CreateClose(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

NTSTATUS
ScUtil_SystemControl(
    PDEVICE_OBJECT   DeviceObject,
    PIRP             Irp
    );

NTSTATUS
ScUtil_ForwardAndWait(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    );

NTSTATUS
ScUtil_Cancel(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );



#endif // __SCUTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\ifdtest\sni.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    example.cpp

Abstract:

    This is a plug-in for the smart card driver test suite.
    This plug-in is smart card dependent

Author:

    Klaus U. Schutz

Environment:

    Win32 application

Revision History :

    Nov. 1997 - initial version

--*/

#include <stdarg.h> 
#include <stdio.h>
#include <string.h>

#include <afx.h>
#include <afxtempl.h>

#include <winioctl.h>
#include <winsmcrd.h>

#include "ifdtest.h"

void MyCardEntry(class CCardProvider& in_CCardProvider);

//
// Create a card provider object
// Note: all global varibales and all functions have to be static
//
static class CCardProvider MyCard(MyCardEntry);

//
// This structure represents the result file 
// that is stored in the smart card
//
typedef struct _RESULT_FILE {
 	
    // Offset to first test result
    UCHAR Offset;

    // Number of times the card has been reset
    UCHAR CardResetCount;

    // Version number of this card
    UCHAR CardMajorVersion;
    UCHAR CardMinorVersion;

    // RFU
    UCHAR Reserved[6];

    //
    // The following structures store the results
    // of the tests. Each result comes with the 
    // reset count when the test was performed.
    // This is used to make sure that we read not
    // the result from an old test, maybe even 
    // performed with another reader/driver.
    //
    struct {

        UCHAR Result;
        UCHAR ResetCount; 	

    } Wtx;

    struct {

        UCHAR Result;
        UCHAR ResetCount; 	

    } ResyncRead;

    struct {

        UCHAR Result;
        UCHAR ResetCount; 	

    } ResyncWrite;

    struct {

        UCHAR Result;
        UCHAR ResetCount; 	

    } Seqnum;

    struct {

        UCHAR Result;
        UCHAR ResetCount; 	

    } IfscRequest;

    struct {

        UCHAR Result;
        UCHAR ResetCount; 	

    } IfsdRequest;

    struct {

        UCHAR Result;
        UCHAR ResetCount; 	

    } Timeout;

} RESULT_FILE, *PRESULT_FILE;
                                                                                           
static void 
sleep( 
    clock_t wait 
    )
{
	clock_t goal;
	goal = wait + clock();
	while( goal > clock() )
        ;
}

static ULONG
MyCardSetProtocol(
    class CCardProvider& in_CCardProvider,
    class CReader& in_CReader
    )
/*++

Routine Description:
    
    This function will be called after the card has been correctly 
    identified. We should here set the protocol that we need
    for further transmissions

Arguments:

    in_CCardProvider - ref. to our card provider object
    in_CReader - ref. to the reader object

Return Value:

    IFDSTATUS_FAILED - we were unable to set the protocol correctly
    IFDSTATUS_SUCCESS - protocol set correctly

--*/
{
    ULONG l_lResult;

    TestStart("Try to set incorrect protocol T=0");
    l_lResult = in_CReader.SetProtocol(SCARD_PROTOCOL_T0);

    // The test MUST fail with the incorrect protocol
    TEST_CHECK_NOT_SUPPORTED("Set protocol failed", l_lResult);
    TestEnd();

    // Now set the correct protocol
    TestStart("Set protocol T=1");
    l_lResult = in_CReader.SetProtocol(SCARD_PROTOCOL_T1);
    TEST_CHECK_SUCCESS("Set protocol failed", l_lResult);
    TestEnd();

    if (l_lResult != ERROR_SUCCESS) {

        return IFDSTATUS_FAILED;
    }

    return IFDSTATUS_SUCCESS;
}

static ULONG
MyCardTest(
    class CCardProvider& in_CCardProvider,
    class CReader& in_CReader
    )
/*++

Routine Description:
	    
    This serves as the test function for a particular smart card

Arguments:

    in_CReader - ref. to class that provides all information for the test

Return Value:

    IFDSTATUS value

--*/
{
    ULONG l_lResult, l_uResultLength, l_uIndex;
    PUCHAR l_pchResult;
    UCHAR l_rgchBuffer[512];
    CHAR l_chFileId;

    if (in_CCardProvider.GetTestNo() > 1 && in_CCardProvider.GetTestNo() < 7) {

        //
        // Select the appropriate file for the test
        // Each test is tied to a particular file
        //
        l_chFileId = (CHAR) in_CCardProvider.GetTestNo() - 1;

        //
        // APDU for select file
        //
        PCHAR l_pchFileDesc[] = {
            "wtx",
            "resync",
            "seqnum",
            "ifs",
            "timeout"
        };

        memcpy(l_rgchBuffer, "\x00\xa4\x08\x04\x04\x3e\x00\x00\x00", 9);

        //
        // add file number to select
        //
        l_rgchBuffer[8] = l_chFileId;

        //
        // select a file
        //
        TestStart("SELECT FILE EF%s", l_pchFileDesc[l_chFileId - 1]);

        l_lResult = in_CReader.Transmit(
            (PUCHAR) l_rgchBuffer,
            9,
            &l_pchResult,
            &l_uResultLength
            );

        TestCheck(
            l_lResult, "==", ERROR_SUCCESS,
            l_uResultLength, 2,
            l_pchResult[0], l_pchResult[1], 0x90, 0x00,
            NULL, NULL, NULL
            );

        TEST_END();     	

        //
        // Generate a 'test' pattern which will be written to the card
        //
        for (l_uIndex = 0; l_uIndex < 256; l_uIndex++) {

            l_rgchBuffer[5 + l_uIndex] = (UCHAR) l_uIndex;             	
        }
    }


    switch (in_CCardProvider.GetTestNo()) {

        case 1:
            //
            // First test
            //
            TestStart("Buffer boundary test");

            //
            // Check if the reader correctly determines that
            // our receive buffer is too small
            //
            in_CReader.SetReplyBufferSize(9);
            l_lResult = in_CReader.Transmit(
                (PUCHAR) "\x08\x84\x00\x00\x08",
                5,
                &l_pchResult,
                &l_uResultLength
                );

            TestCheck(
                l_lResult == ERROR_INSUFFICIENT_BUFFER,
                "Transmit should fail due to too small buffer\nReturned %2lxH\nExpected %2lxH",
                l_lResult, 
                ERROR_INSUFFICIENT_BUFFER
                );

            TestEnd();

            in_CReader.SetReplyBufferSize(2048);
        	break;

        case 2: {

            //
            // Wtx test file id 00 01
            // This test checks if the reader/driver correctly handles WTX requests
            //
            ULONG l_auNumBytes[] = { 1 , 2, 5, 30 };

            for (ULONG l_uTest = 0; 
                 l_uTest < sizeof(l_auNumBytes) / sizeof(l_auNumBytes[0]); 
                 l_uTest++) {

                ULONG l_uNumBytes = l_auNumBytes[l_uTest];

                //
                // Now read from this file
                // The number of bytes we read corresponds to 
                // the waiting time extension this command produces
                //
                TestStart("READ  BINARY %3d byte(s)", l_uNumBytes);

                //
                // apdu for read binary
                //
                memcpy(l_rgchBuffer, "\x00\xB0\x00\x00", 4);

                //
                // Append number of bytes
                //
                l_rgchBuffer[4] = (UCHAR) l_uNumBytes;

                l_lResult = in_CReader.Transmit(
                    l_rgchBuffer,
                    5,
                    &l_pchResult,
                    &l_uResultLength
                    );

                TestCheck(
                    l_lResult, "==", ERROR_SUCCESS,
                    l_uResultLength, l_uNumBytes + 2,
                    l_pchResult[l_uNumBytes], l_pchResult[l_uNumBytes + 1], 
                    0x90, 0x00,
                    l_pchResult, l_rgchBuffer + 5, l_uNumBytes
                    );

                TEST_END();
            }
            break;
        }

        case 3: {
         	
            ULONG l_uNumBytes = 255;

            // resync. on write file id 00 02
            TestStart("WRITE BINARY %3d bytes", l_uNumBytes);
                    
            // Tpdu for write binary
            memcpy(l_rgchBuffer, "\x00\xd6\x00\x00", 4);

            // Append number of bytes (note: the buffer contains the pattern already)
            l_rgchBuffer[4] = (UCHAR) l_uNumBytes;

            l_lResult = in_CReader.Transmit(
                l_rgchBuffer,
                5 + l_uNumBytes,
                &l_pchResult,
                &l_uResultLength
                );
            TestCheck(
                l_lResult, "==", ERROR_IO_DEVICE,
                0, 0,
                0, 0, 0, 0,
                NULL, NULL, 0
                );
            TEST_END();

            // resync. on read file id 00 02
            TestStart("READ  BINARY %3d byte(s)", l_uNumBytes);

            // tpdu for read binary
            memcpy(l_rgchBuffer, "\x00\xB0\x00\x00", 4);

            // Append number of bytes
            l_rgchBuffer[4] = (UCHAR) l_uNumBytes;

            l_lResult = in_CReader.Transmit(
                l_rgchBuffer,
                5,
                &l_pchResult,
                &l_uResultLength
                );

            TestCheck(
                l_lResult, "==", ERROR_IO_DEVICE,
                0, 0,
                0, 0, 0, 0,
                NULL, NULL, 0
                );
            TEST_END();
            break;
        }

        case 4: {
         	
            // wrong block seq. no file id 00 03
            ULONG l_uNumBytes = 255;
            
            TestStart("READ BINARY %3d bytes", l_uNumBytes);
                    
            // Tpdu for read binary
            memcpy(l_rgchBuffer, "\x00\xb0\x00\x00", 4);

            // Append number of bytes (note: the buffer contains the pattern already)
            l_rgchBuffer[4] = (UCHAR) l_uNumBytes;

            l_lResult = in_CReader.Transmit(
                l_rgchBuffer,
                5,
                &l_pchResult,
                &l_uResultLength
                );
            TestCheck(
                l_lResult, "==", ERROR_IO_DEVICE,
                0, 0,
                0, 0, 0, 0,
                NULL, NULL, 0
                );
            TEST_END();
            break;
        }

        case 5: { 

            // ifsc request file id 00 04
            ULONG l_uNumBytes = 255;

            TestStart("WRITE BINARY %3d bytes", l_uNumBytes);
                    
            // Tpdu for write binary
            memcpy(l_rgchBuffer, "\x00\xd6\x00\x00", 4);

            // Append number of bytes (note: the buffer contains the pattern already)
            l_rgchBuffer[4] = (UCHAR) l_uNumBytes;

            l_lResult = in_CReader.Transmit(
                l_rgchBuffer,
                5 + l_uNumBytes,
                &l_pchResult,
                &l_uResultLength
                );
            TestCheck(
                l_lResult, "==", ERROR_SUCCESS,
                l_uResultLength, 2,
                l_pchResult[0], l_pchResult[1], 0x90, 0x00,
                NULL, NULL, NULL
                );
            TEST_END();
#ifdef junk
            l_uNumBytes = 255;
            TestStart("READ  BINARY %3d byte(s)", l_uNumBytes);

            // tpdu for read binary
            memcpy(l_rgchBuffer, "\x00\xB0\x00\x00", 4);

            // Append number of bytes
            l_rgchBuffer[4] = (UCHAR) l_uNumBytes;

            l_lResult = in_CReader.Transmit(
                l_rgchBuffer,
                5,
                &l_pchResult,
                &l_uResultLength
                );

            TestCheck(
                l_lResult, "==", ERROR_SUCCESS,
                l_uResultLength, l_uNumBytes + 2,
                l_pchResult[l_uNumBytes], l_pchResult[l_uNumBytes + 1], 
                0x90, 0x00,
                l_pchResult, l_rgchBuffer + 5, l_uNumBytes
                );

            TEST_END();
#endif
            break;
        }

        case 6: {

            // forced timeout file id 00 05
            ULONG l_uNumBytes = 254;
            TestStart("READ  BINARY %3d bytes", l_uNumBytes);

            // tpdu for read binary
            memcpy(l_rgchBuffer, "\x00\xB0\x00\x00", 4);

            // Append number of bytes
            l_rgchBuffer[4] = (UCHAR) l_uNumBytes;

            l_lResult = in_CReader.Transmit(
                l_rgchBuffer,
                5,
                &l_pchResult,
                &l_uResultLength
                );

            TestCheck(
                l_lResult, "==", ERROR_IO_DEVICE,
                0, 0,
                0, 0, 0, 0,
                NULL, NULL, 0
                );

            TEST_END();
            break;         	
        }

        case 7:{

            //
            // Read the result file from the smart card.
            // The card stores results of each test in 
            // a special file
            //
            ULONG l_uNumBytes = sizeof(RESULT_FILE);
            PRESULT_FILE pCResultFile;
            
            TestStart("SELECT FILE EFresult");

            l_lResult = in_CReader.Transmit(
                (PUCHAR) "\x00\xa4\x08\x04\x04\x3e\x00\xA0\x00",
                9,
                &l_pchResult,
                &l_uResultLength
                );

            TestCheck(
                l_lResult, "==", ERROR_SUCCESS,
                l_uResultLength, 2,
                l_pchResult[0], l_pchResult[1], 0x90, 0x00,
                NULL, NULL, NULL
                );

            TEST_END();     	

            // Read
            TestStart("READ  BINARY %3d bytes", l_uNumBytes);

            // apdu for read binary
            memcpy(l_rgchBuffer, "\x00\xB0\x00\x00", 4);

            // Append number of bytes
            l_rgchBuffer[4] = (UCHAR) l_uNumBytes;

            l_lResult = in_CReader.Transmit(
                l_rgchBuffer,
                5,
                &l_pchResult,
                &l_uResultLength
                );

            TestCheck(
                l_lResult, "==", ERROR_SUCCESS,
                l_uResultLength, l_uNumBytes + 2,
                l_pchResult[l_uNumBytes], l_pchResult[l_uNumBytes + 1], 
                0x90, 0x00,
                NULL, NULL, NULL
                );

            TEST_END();

            pCResultFile = (PRESULT_FILE) l_pchResult;

            //
            // Now check the result file. 
            //

            //
            // Check wtx result
            //
            TestStart("WTX result");
            TestCheck(
                pCResultFile->Wtx.ResetCount == pCResultFile->CardResetCount,
                "Test not performed"
                );
            TestCheck(
                (pCResultFile->Wtx.Result & 0x01) == 0, 
                "Smart card received no WTX reply"
                );
            TestCheck(
                (pCResultFile->Wtx.Result & 0x02) == 0, 
                "Smart card received wrong WTX reply"
                );
            TestCheck(
                pCResultFile->Wtx.Result == 0, 
                "Test failed. Error code %02xH",
                pCResultFile->Wtx.Result
                );
            TestEnd();

            //
            // Check resync. read result
            //
            TestStart("RESYNCH read result");
            TestCheck(
                pCResultFile->ResyncRead.ResetCount == pCResultFile->CardResetCount,
                "Test not performed"
                );
            TestCheck(
                (pCResultFile->ResyncRead.Result & 0x01) == 0, 
                "Smart card received no RESYNCH request"
                );
            TestCheck(
                pCResultFile->ResyncRead.Result == 0, 
                "Test failed. Error code %02xH",
                pCResultFile->ResyncRead.Result
                );
            TestEnd();

            //
            // Check resync. write result
            //
            TestStart("RESYNCH write result");
            TestCheck(
                pCResultFile->ResyncWrite.ResetCount == pCResultFile->CardResetCount,
                "Test not performed"
                );
            TestCheck(
                (pCResultFile->ResyncWrite.Result & 0x01) == 0, 
                "Smart card received no RESYNCH request"
                );
            TestCheck(
                (pCResultFile->ResyncWrite.Result & 0x02) == 0, 
                "Smart card received incorrect data"
                );
            TestCheck(
                pCResultFile->ResyncWrite.Result == 0, 
                "Test failed. Error code %02xH",
                pCResultFile->ResyncWrite.Result
                );
            TestEnd();

            //
            // Sequence number result
            //
            TestStart("Sequence number result");
            TestCheck(
                pCResultFile->ResyncRead.ResetCount == pCResultFile->CardResetCount,
                "Test not performed"
                );
            TestCheck(
                (pCResultFile->Seqnum.Result & 0x01) == 0, 
                "Smart card received no RESYNCH request"
                );
            TestCheck(
                (pCResultFile->Seqnum.Result & 0x02) == 0, 
                "Smart card received incorrect data"
                );
            TestCheck(
                pCResultFile->Seqnum.Result == 0, 
                "Test failed. Error code %02xH",
                pCResultFile->Seqnum.Result
                );
            TestEnd();

            //
            // IFSC Request
            //
            TestStart("IFSC request");
            TestCheck(
                pCResultFile->IfscRequest.ResetCount == pCResultFile->CardResetCount,
                "Test not performed"
                );
            TestCheck(
                (pCResultFile->IfscRequest.Result & 0x01) == 0, 
                "Smart card received no IFSC reply"
                );
            TestCheck(
                (pCResultFile->IfscRequest.Result & 0x02) == 0, 
                "Smart card received incorrect data"
                );
            TestCheck(
                (pCResultFile->IfscRequest.Result & 0x04) == 0, 
                "Block size BEFORE IFSC request incorrect",
                pCResultFile->IfscRequest.Result
                );
            TestCheck(
                (pCResultFile->IfscRequest.Result & 0x08) == 0, 
                "Block size AFTER IFSC request incorrect",
                pCResultFile->IfscRequest.Result
                );
            TestCheck(
                pCResultFile->IfscRequest.Result == 0x00, 
                "Test failed. Error code %02xH",
                pCResultFile->IfscRequest.Result
                );
            TestEnd();

            //
            // IFSD Request
            //
            TestStart("IFSD request");
            TestCheck(
                pCResultFile->IfsdRequest.ResetCount == pCResultFile->CardResetCount,
                "Test not performed"
                );
            TestCheck(
                (pCResultFile->IfsdRequest.Result & 0x01) == 0, 
                "Smart card received no IFSD request"
                );
            TestCheck(
                pCResultFile->IfsdRequest.Result == 0x00, 
                "Test failed. Error code %02xH",
                pCResultFile->IfsdRequest.Result
                );
            TestEnd();

            //
            // Timeout
            //
            TestStart("Forced timeout result");
            TestCheck(
                pCResultFile->Timeout.ResetCount == pCResultFile->CardResetCount,
                "Test not performed"
                );
            TestCheck(
                pCResultFile->Timeout.Result == 0, 
                "Test failed. Error code %02xH",
                pCResultFile->Timeout.Result
                );
            TestEnd();
            return IFDSTATUS_END;
        }

        default:
            return IFDSTATUS_FAILED;        
    }
    
    return IFDSTATUS_SUCCESS;

}    

static void
MyCardEntry(
    class CCardProvider& in_CCardProvider
    )
/*++

Routine Description:
    
    This function registers all callbacks from the test suite
	
Arguments:

    CCardProvider - ref. to card provider class

Return Value:                                           

    -

--*/
{                                                           
    // Set protocol callback
    in_CCardProvider.SetProtocol(MyCardSetProtocol);

    // Card test callback
    in_CCardProvider.SetCardTest(MyCardTest);

    // Name of our card
    in_CCardProvider.SetCardName("SIEMENS NIXDORF");

    // Set ATR of our card
    in_CCardProvider.SetAtr(
        (PBYTE) "\x3b\xef\x00\x00\x81\x31\x20\x49\x00\x5c\x50\x43\x54\x10\x27\xf8\xd2\x76\x00\x00\x38\x33\x00\x4d", 
        24
        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\inc\smcdbg.h ===
/*++

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    smcdbg.h

Abstract:

    This header contains all definitions for the smart card debugger

Environment:

    Kernel mode only.

Revision History:

    - Created Jan. 1999 by Klaus Schutz 

--*/
#define IOCTL_SMCLIB_SEND_DEBUG_REQUEST     SCARD_CTL_CODE(100)
#define IOCTL_SMCLIB_PROCESS_T1_REQUEST     SCARD_CTL_CODE(101)
#define IOCTL_SMCLIB_GET_T1_REQUEST         SCARD_CTL_CODE(102)
#define IOCTL_SMCLIB_GET_T1_REPLY           SCARD_CTL_CODE(103)
#define IOCTL_SMCLIB_PROCESS_T1_REPLY       SCARD_CTL_CODE(104)
#define IOCTL_SMCLIB_IGNORE_T1_REPLY        SCARD_CTL_CODE(105)
#define IOCTL_SMCLIB_NOTIFY_DEVICE_REMOVAL  SCARD_CTL_CODE(106)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\ifdtest\schlumbgr.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    example.cpp

Abstract:

    This is a plug-in for the smart card driver test suite.
    This plug-in is smart card dependent

Author:

    Klaus U. Schutz

Environment:

    Win32 application

Revision History :

    Nov. 1997 - initial version

--*/

#include <stdarg.h> 
#include <stdio.h>
#include <string.h>
#include <time.h>

#include <afx.h>
#include <afxtempl.h>

#include <winioctl.h>
#include <winsmcrd.h>

#include "ifdtest.h"


void 
SLBTestCardEntry(
    class CCardProvider& in_CCardProvider
    );
//
// Create a card provider object
// Note: all global varibales and all functions have to be static
//
static class CCardProvider SLBTestCard(SLBTestCardEntry);

//Pauses for a specified number of milliseconds. 
static void 
sleep( 
    clock_t wait 
    )
{
	clock_t goal;
	goal = wait + clock();
	while( goal > clock() )
        ;
}

static ULONG
SLBTestCardSetProtocol(
    class CCardProvider& in_CCardProvider,
    class CReader& in_CReader
    )
/*++

Routine Description:
    
    This function will be called after the card has been correctly 
    identified. We should here set the protocol that we need
    for further transmissions

Arguments:

    in_CCardProvider - ref. to our card provider object
    in_CReader - ref. to the reader object

Return Value:

    IFDSTATUS_FAILED - we were unable to set the protocol correctly
    IFDSTATUS_SUCCESS - protocol set correctly

--*/
{
    ULONG l_lResult;

    // Try to set INCORRECT protocol T=1
    TestStart("Try to set incorrect protocol T=1");
    l_lResult = in_CReader.SetProtocol(SCARD_PROTOCOL_T1);

    // The test MUST fail with the incorrect protocol
    TEST_CHECK_NOT_SUPPORTED("Set protocol failed", l_lResult);
    TestEnd();

    // Now set the correct protocol
    TestStart("Set protocol T=0");
    l_lResult = in_CReader.SetProtocol(SCARD_PROTOCOL_T0);
    TEST_CHECK_SUCCESS("Set protocol failed", l_lResult);
    TestEnd();

    if (l_lResult != ERROR_SUCCESS) {

        return IFDSTATUS_FAILED;
    }

    return IFDSTATUS_SUCCESS;
}

static 
ULONG
SLBTestCardTest(
    class CCardProvider& in_CCardProvider,
    class CReader& in_CReader
    )
/*++

Routine Description:
	    
    This serves as the test function for a particular smart card

Arguments:

    in_CReader - ref. to class that provides all information for the test

Return Value:

    IFDSTATUS value

--*/
{
    ULONG l_lResult, l_uResultLength, l_uIndex;
    PBYTE l_pbResult;
    BYTE l_rgbBuffer[512];
    CHAR l_chFileId;
	
    // First select the file
    if (in_CCardProvider.GetTestNo() < 6) {

        //
        // Select the appropriate file for the test
        // Each test is tied to a particular file
        //
        l_chFileId = (CHAR) in_CCardProvider.GetTestNo();

        PCHAR l_pchFileDesc[] = {
            "transferAllBytes",
            "transferNextByte",
            "read256Bytes",
            "case1Apdu",
            "restartWorkWaitingTime"
        };

        // APDU for select file
		memcpy(l_rgbBuffer, "\x00\xa4\x00\x00\x02\x00\x00", 7);

        // add file number to select
        l_rgbBuffer[6] = l_chFileId;

        // select a file
        TestStart("SELECT FILE EF%s", l_pchFileDesc[l_chFileId - 1]);

        sleep( (clock_t) 1 * (CLOCKS_PER_SEC / 2) );

        l_lResult = in_CReader.Transmit(
            (PBYTE) l_rgbBuffer,
            7,
            &l_pbResult,
            &l_uResultLength
            );

        TestCheck(
            l_lResult, "==", ERROR_SUCCESS,
            l_uResultLength, 2,
            l_pbResult[0], l_pbResult[1], 0x90, 0x00,
            NULL, NULL, NULL
            );

        TEST_END();     	

        //
        // Generate a 'test' pattern which will be written to the card
        //
        for (l_uIndex = 0; l_uIndex < 256; l_uIndex++) {

            l_rgbBuffer[5 + l_uIndex] = (UCHAR) l_uIndex;             	
        }
    }

	switch (in_CCardProvider.GetTestNo()) {
	
	    case 1:
	    case 2: {
		    //
		    // Write 
		    //
            ULONG l_auNumBytes[] = { 1 , 25 }; //, 50, 75, 100, 125 };
    
            for (ULONG l_uTest = 0; 
                 l_uTest < sizeof(l_auNumBytes) / sizeof(l_auNumBytes[0]); 
                 l_uTest++) {

                ULONG l_uNumBytes = l_auNumBytes[l_uTest];

			    TestStart("WRITE BINARY %3d Byte(s)", l_uNumBytes);
				    
		        // Tpdu for write binary
			    memcpy(l_rgbBuffer, "\x00\xd6\x00\x00", 4);
				    
		        // Append number of bytes (note: the buffer contains the pattern already)
			    l_rgbBuffer[4] = (UCHAR) l_uNumBytes;

			    sleep( (clock_t) 1 * (CLOCKS_PER_SEC / 4) );
								    
			    l_lResult = in_CReader.Transmit(
				    l_rgbBuffer,
				    5 + l_uNumBytes,
				    &l_pbResult,
				    &l_uResultLength
				    );
				    
                TestCheck(
                    l_lResult, "==", ERROR_SUCCESS,
                    l_uResultLength, 2,
                    l_pbResult[0], l_pbResult[1], 0x90, 0x00,
                    NULL, NULL, NULL
                    );

                TEST_END();
		    }		    
		    break;         	
        }

	    case 3: {
         	
            // Test read of 256 bytes
            ULONG l_uNumBytes = 256;
            TestStart("READ BINARY %3d Byte(s)", l_uNumBytes);

            // tpdu for read binary 256 bytes
            memcpy(l_rgbBuffer, "\x00\xb0\x00\x00\x00", 5);
		    
		    sleep((clock_t) 1 * (CLOCKS_PER_SEC / 2) );
	    
		    l_lResult = in_CReader.Transmit(
                l_rgbBuffer,
                5,
                &l_pbResult,
                &l_uResultLength
                );

            TestCheck(
                l_lResult, "==", ERROR_SUCCESS,
                l_uResultLength, l_uNumBytes + 2,
                l_pbResult[l_uNumBytes], l_pbResult[l_uNumBytes + 1], 0x90, 0x00,
                l_pbResult, l_rgbBuffer + 5, l_uNumBytes
                );

            TEST_END();
            break;
        }

	    case 4: {

            // Test write of 0 bytes
            TestStart("WRITE BINARY %3d Byte", 0);

            // tpdu for write binary
            memcpy(l_rgbBuffer, "\x00\xd6\x00\x00", 4);
		    
		    sleep((clock_t) 1 * (CLOCKS_PER_SEC / 2) );
	    
		    l_lResult = in_CReader.Transmit(
                l_rgbBuffer,
                4,
                &l_pbResult,
                &l_uResultLength
                );

            TestCheck(
                l_lResult, "==", ERROR_SUCCESS,
                l_uResultLength, 2,
                l_pbResult[0], l_pbResult[1], 0x90, 0x00,
                NULL, NULL, 0
                );

            TEST_END();
		    break;         	
        }

	    case 5: {
		    // Test restart or work waiting time
            ULONG l_auNumBytes[] = { 1, 2, 5, 30 };

            for (ULONG l_uTest = 0; 
                 l_uTest < sizeof(l_auNumBytes) / sizeof(l_auNumBytes[0]); 
                 l_uTest++) {

                ULONG l_uNumBytes = l_auNumBytes[l_uTest];
	            TestStart("READ BINARY %3d Byte(s)", l_uNumBytes);

			    // tpdu for read binary
			    memcpy(l_rgbBuffer, "\x00\xb0\x00\x00", 4);

			    // Append number of bytes
			    l_rgbBuffer[4] = (UCHAR)l_uNumBytes;
		    
			    sleep( (clock_t) 1 * (CLOCKS_PER_SEC / 2) );

			    l_lResult = in_CReader.Transmit(
				    l_rgbBuffer,
				    5,
				    &l_pbResult,
				    &l_uResultLength
			    );

                TestCheck(
                    l_lResult, "==", ERROR_SUCCESS,
                    l_uResultLength, l_uNumBytes + 2,
                    l_pbResult[l_uNumBytes], l_pbResult[l_uNumBytes + 1], 0x90, 0x00,
                    l_pbResult, l_rgbBuffer + 5, l_uNumBytes
                    );

                TEST_END();
		    }
		    break;         	
        }

        case 6: {

            //
            // Read the result file from the smart card.
            // The card stores results of each test in 
            // a special file
            //
         	
            TestStart("SELECT FILE EFresult");

            sleep( (clock_t) 1 * (CLOCKS_PER_SEC / 2) );

            l_lResult = in_CReader.Transmit(
                (PBYTE) "\x00\xa4\x00\x00\x02\xa0\x00",
                7,
                &l_pbResult,
                &l_uResultLength
                );

            TestCheck(
                l_lResult, "==", ERROR_SUCCESS,
                l_uResultLength, 2,
                l_pbResult[0], l_pbResult[1], 0x90, 0x00,
                NULL, NULL, NULL
                );

            TEST_END();     	

            // Read
            TestStart("READ  BINARY FILE EFresult");

            // apdu for read binary
            memcpy(l_rgbBuffer, "\x00\xb0\x00\x00", 4);

            // Append number of bytes we want to read
            l_rgbBuffer[4] = (UCHAR) sizeof(T0_RESULT_FILE_HEADER);

            sleep( (clock_t) 1 * (CLOCKS_PER_SEC / 2) );

            l_lResult = in_CReader.Transmit(
                l_rgbBuffer,
                5,
                &l_pbResult,
                &l_uResultLength
                );

            TestCheck(
                l_lResult, "==", ERROR_SUCCESS,
                l_uResultLength, sizeof(T0_RESULT_FILE_HEADER) + 2,
                l_pbResult[sizeof(T0_RESULT_FILE_HEADER)], 
                l_pbResult[sizeof(T0_RESULT_FILE_HEADER) + 1], 
                0x90, 0x00,
                NULL, NULL, NULL
                );

            // get the card reset count
            PT0_RESULT_FILE_HEADER l_pCResultFileHeader;
            l_pCResultFileHeader = (PT0_RESULT_FILE_HEADER) l_pbResult;
            BYTE l_bCardResetCount = l_pCResultFileHeader->CardResetCount;

            // set the offset from where we want to read
            l_rgbBuffer[3] = (BYTE) l_pCResultFileHeader->Offset;
            // Append number of bytes
            l_rgbBuffer[4] = (BYTE) sizeof(T0_RESULT_FILE);

            sleep( (clock_t) 1 * (CLOCKS_PER_SEC / 2) );

            // read in the result data of the result file
            l_lResult = in_CReader.Transmit(
                l_rgbBuffer,
                5,
                &l_pbResult,
                &l_uResultLength
                );

            TestCheck(
                l_lResult, "==", ERROR_SUCCESS,
                l_uResultLength, sizeof(T0_RESULT_FILE) + 2,
                l_pbResult[sizeof(T0_RESULT_FILE)], 
                l_pbResult[sizeof(T0_RESULT_FILE) + 1], 
                0x90, 0x00,
                NULL, NULL, NULL
                );

            TEST_END();

            PT0_RESULT_FILE l_pCResultFile = (PT0_RESULT_FILE) l_pbResult;

            //
            // Now check the result file. 
            //

            // procedure byte interpretation - write all bytes 
            TestStart("'Transfer all remaining bytes result'");
            TestCheck(
                l_pCResultFile->TransferAllBytes.ResetCount == l_bCardResetCount,
                "Test not performed"
                );
            TestCheck(
                (l_pCResultFile->TransferAllBytes.Result & 0x01) == 0, 
                "Smart card received incorrect data"
                );
            TestCheck(
                l_pCResultFile->TransferAllBytes.Result == 0, 
                "Test failed. Error code %02xH",
                l_pCResultFile->TransferAllBytes.Result
                );
            TestEnd();

            // procedure byte interpretation - write single bytes
            TestStart("'Transfer next byte result'");
            TestCheck(
                l_pCResultFile->TransferNextByte.ResetCount == l_bCardResetCount,
                "Test not performed"
                );
            TestCheck(
                (l_pCResultFile->TransferNextByte.Result & 0x01) == 0, 
                "Smart card received incorrect data"
                );
            TestCheck(
                l_pCResultFile->TransferNextByte.Result == 0, 
                "Test failed. Error code %02xH",
                l_pCResultFile->TransferNextByte.Result
                );
            TestEnd();

            // Check read of 256 bytes
            TestStart("'Read 256 bytes bytes' result");
            TestCheck(
                l_pCResultFile->Read256Bytes.ResetCount == l_bCardResetCount,
                "Test not performed"
                );
            TestCheck(
                (l_pCResultFile->Read256Bytes.Result & 0x01) == 0, 
                "Smart card received P3 != 0"
                );
            TestCheck(
                l_pCResultFile->Read256Bytes.Result == 0, 
                "Test failed. Error code %02xH",
                l_pCResultFile->Read256Bytes.Result
                );
            TestEnd();

            // Test of case 1 APDU
            TestStart("'Case 1 APDU' result");
            TestCheck(
                l_pCResultFile->Case1Apdu.ResetCount == l_bCardResetCount,
                "Test not performed"
                );
            TestCheck(
                (l_pCResultFile->Case1Apdu.Result & 0x01) == 0, 
                "Smart card received only 4-byte-TPDU"
                );
            TestCheck(
                (l_pCResultFile->Case1Apdu.Result & 0x02) == 0, 
                "Smart card received P3 !=0"
                );
            TestCheck(
                l_pCResultFile->Case1Apdu.Result == 0, 
                "Test failed. Error code %02xH",
                l_pCResultFile->Case1Apdu.Result
                );
            TestEnd();

            // Test of restart of work waiting time
            TestStart("'Restart of work waiting time' result");
            TestCheck(
                l_pCResultFile->RestartWorkWaitingTime.ResetCount == l_bCardResetCount,
                "Test not performed"
                );
            TestCheck(
                (l_pCResultFile->RestartWorkWaitingTime.Result & 0x01) == 0, 
                "Smart card received only 4-byte-TPDU"
                );
            TestCheck(
                (l_pCResultFile->RestartWorkWaitingTime.Result & 0x02) == 0, 
                "Smart card received P3 !=0"
                );
            TestCheck(
                l_pCResultFile->RestartWorkWaitingTime.Result == 0, 
                "Test failed. Error code %02xH",
                l_pCResultFile->RestartWorkWaitingTime.Result
                );
            TestEnd();
            return IFDSTATUS_END;
        }
	    default:
		    return IFDSTATUS_FAILED;

	}    
    return IFDSTATUS_SUCCESS;
}    

static void
SLBTestCardEntry(
    class CCardProvider& in_CCardProvider
    )
/*++

Routine Description:
    
    This function registers all callbacks from the test suite
	
Arguments:

    CCardProvider - ref. to card provider class

Return Value:

    -

--*/
{
    // Set protocol callback
    in_CCardProvider.SetProtocol(SLBTestCardSetProtocol);

    // Card test callback
    in_CCardProvider.SetCardTest(SLBTestCardTest);

    // Name of our card
    in_CCardProvider.SetCardName("SCHLUMBERGER");

    // Name of our card
    in_CCardProvider.SetAtr((PBYTE) "\x3b\xe2\x00\x00\x40\x20\x99\x01", 8);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\inc\smclib.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    smclib.h

Abstract:

    This module contains all definitions for the smart card library.
	All defintions are made according to ISO 7816.

Environment:

    Kernel mode only.

Notes:

Revision History:

    - Created December 1996 by Klaus Schutz 
    - Jun. 97:  Definitions for Windows 9x added
    - Feb. 98:  PTS struct added 
                Async./Sync. protocols now combined

--*/

#ifndef _SMCLIB_
#define _SMCLIB_

#if DBG || DEBUG
#undef DEBUG
#define DEBUG 1
#undef DBG
#define DBG 1
#pragma message("Debug is turned on")
#endif

#ifdef __cplusplus
extern "C" {
#endif

#ifdef SMCLIB_VXD
//
// Include windows 9x specific data definitions
//
#include "smcvxd.h"
#elif defined(SMCLIB_CE)
//
// Include Windows CE specific data definitons
//
#include "smcce.h"
#else
//
// Include Windows NT specific data definitions
//
#include "smcnt.h"
#endif

#include "winsmcrd.h"
//
// This name is displayed in debugging messages
//
#ifndef DRIVER_NAME
#define DRIVER_NAME "SMCLIB"
#endif

//
// This version number changes for every change of the device extension.
// (I.e. new fields were added)
// The required version is the version number that the lib is compatible to.
//
#define SMCLIB_VERSION          0x150
#define SMCLIB_VERSION_REQUIRED 0x100

#if DEBUG
#define DEBUG_IOCTL     ((ULONG) 0x00000001)
#define DEBUG_ATR       ((ULONG) 0x00000002)
#define DEBUG_PROTOCOL  ((ULONG) 0x00000004)
#define DEBUG_DRIVER    ((ULONG) 0x00000008)
#define DEBUG_TRACE     ((ULONG) 0x00000010)
#define DEBUG_ERROR     ((ULONG) 0x00000020)
#define DEBUG_INFO      DEBUG_ERROR
#define DEBUG_PERF      ((ULONG) 0x10000000)
#define DEBUG_T1_TEST   ((ULONG) 0x40000000)
#define DEBUG_BREAK     ((ULONG) 0x80000000)
#define DEBUG_ALL       ((ULONG) 0x0000FFFF)
#endif

#ifdef SMCLIB_VXD

// ****************************************************************************
// Windows 9x definitions
// ****************************************************************************

typedef LONG NTSTATUS;
typedef UCHAR BOOLEAN;           

//
// include this file to get nt status codes
//
#include <ntstatus.h>

//
// The following three definition are taken out of the ntddk.h file
// Please refer to this file for a description
//
#define METHOD_BUFFERED                 0
#define FILE_ANY_ACCESS                 0
#define CTL_CODE( DeviceType, Function, Method, Access ) (                 \
    ((DeviceType) << 16) | ((Access) << 14) | ((Function) << 2) | (Method) \
)

//
// Define the ASSERT macro for Windows 9x
//
#if DEBUG
NTSTATUS
VXDINLINE 
SmartcardAssert(
    PVOID FailedAssertion,
    PVOID FileName,
    ULONG LineNumber,
    PCHAR Message
	);

#define ASSERT( exp ) \
    if (!(exp)) { \
     	SmartcardAssert( #exp, __FILE__, __LINE__, NULL ); \
        _asm int 3 \
    } else


#define ASSERTMSG( msg, exp ) \
    if (!(exp)) { \
     	SmartcardAssert( #exp, __FILE__, __LINE__, msg ); \
        _asm int 3 \
    } else 
        
#define SmartcardDebug(LEVEL, STRING) \
        { \
            if ((LEVEL) & (DEBUG_ERROR | SmartcardGetDebugLevel())) \
                _Debug_Printf_Service STRING; \
            if (SmartcardGetDebugLevel() & DEBUG_BREAK) \
                _asm int 3 \
        }

#else
#define ASSERT( exp )
#define ASSERTMSG( msg, exp )
#define SmartcardDebug(LEVEL, STRING)
#endif // DEBUG

#define AccessUnsafeData(Irql) 
#define EndAccessUnsafeData(Irql)

#define RtlCopyMemory memcpy
#define RtlZeroMemory(d, c) memset((d), 0, (c))

// ****************************************************************************
// End Windows 9x definitions
// ****************************************************************************

#elif defined(SMCLIB_CE)
// ****************************************************************************
// Windows CE definitions
// ****************************************************************************

// Use the debug message structs and macros from dbgapi.h
// Driver has to define and initialize a DEBUGPARAM struct


#define SmartcardDebug(LEVEL, STRING) DEBUGMSG(dpCurSettings.ulZoneMask & (LEVEL), STRING)

#define SmartcardLockDevice(SmartcardExtension) EnterCriticalSection(&(SmartcardExtension)->OsData->CritSect)
#define SmartcardUnlockDevice(SmartcardExtension) LeaveCriticalSection(&(SmartcardExtension)->OsData->CritSect)

#define AccessUnsafeData(Irql) SmartcardLockDevice(SmartcardExtension)
#define EndAccessUnsafeData(Irql) SmartcardUnlockDevice(SmartcardExtension)

// ****************************************************************************
// End Windows CE definitions
// ****************************************************************************

#else

// ****************************************************************************
// Windows NT definitions
// ****************************************************************************

#if DEBUG
#define SmartcardDebug(LEVEL, STRING) \
        { \
            if ((LEVEL) & (DEBUG_ERROR | SmartcardGetDebugLevel())) \
                DbgPrint STRING; \
            if (SmartcardGetDebugLevel() & DEBUG_BREAK) \
                DbgBreakPoint(); \
        }

#else
#define SmartcardDebug(LEVEL, STRING) 
#endif

#define AccessUnsafeData(Irql) \
    KeAcquireSpinLock(&SmartcardExtension->OsData->SpinLock, (Irql));
#define EndAccessUnsafeData(Irql) \
    KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock, (Irql));

#ifndef SMART_CARD_READER_GUID_DEFINED
#define SMART_CARD_READER_GUID_DEFINED
#include <initguid.h>
DEFINE_GUID(SmartCardReaderGuid, 0x50DD5230, 0xBA8A, 0x11D1, 0xBF,0x5D,0x00,0x00,0xF8,0x05,0xF5,0x30);

// ****************************************************************************
// End Windows NT definitions
// ****************************************************************************

#endif
#endif

//
// Indexes to the callback functions of the ReaderFunction array 
// in the SmartcardExtension
//
#define RDF_CARD_POWER 		0
#define RDF_TRANSMIT		1
#define RDF_CARD_EJECT		2
#define RDF_READER_SWALLOW 	3
#define RDF_CARD_TRACKING	4
#define RDF_SET_PROTOCOL	5
#define RDF_DEBUG_LEVEL		6
#define RDF_CARD_CONFISCATE 7
#define RDF_IOCTL_VENDOR    8
#define RDF_ATR_PARSE       9

//
// Minimum buffer size for request and reply buffer
//
#define MIN_BUFFER_SIZE	288

//
// This union is used for data type conversion
//
typedef union _LENGTH {
	
	struct {

		ULONG	l0;

	} l;

	struct {

		UCHAR 	b0;
		UCHAR	b1;
		UCHAR	b2;
		UCHAR	b3;
	} b;

} LENGTH, *PLENGTH;

#define MAXIMUM_ATR_CODES					4
#define MAXIMUM_ATR_LENGTH					33

typedef struct _T0_DATA {

	// Number of data bytes in this request
	ULONG	Lc;

	// Number of expected bytes from the card
	ULONG	Le;

} T0_DATA, *PT0_DATA;

//
// constants for the T=1 i/o function
//
#define T1_INIT             0
#define T1_START			1
#define T1_I_BLOCK			2
#define T1_R_BLOCK			3
#define T1_RESTART          4
#define T1_RESYNCH_REQUEST	0xC0
#define T1_RESYNCH_RESPONSE	0xE0
#define T1_IFS_REQUEST		0xC1
#define T1_IFS_RESPONSE		0xE1
#define T1_ABORT_REQUEST   	0xC2
#define T1_ABORT_RESPONSE  	0xE2
#define T1_WTX_REQUEST		0xC3
#define T1_WTX_RESPONSE		0xE3
#define T1_VPP_ERROR		0xE4

//
// Information field size the lib uses
//
#define T1_IFSD             254
#define T1_IFSD_DEFAULT		 32

//
// Maximum attempts to resend a block in T1
//
#define T1_MAX_RETRIES		2

//
// Bit that indenticates if there are more data to send
//
#define T1_MORE_DATA		0x20

//
// T1 Error values
//
#define T1_ERROR_CHKSUM		1
#define T1_ERROR_OTHER		2

//
// Error detection bit as defined by ISO 
//
#define T1_CRC_CHECK		1

//
// Character waiting integer default value as definded by ISO
//
#define T1_CWI_DEFAULT		13

//
// Block waiting integer default value as definded by ISO
//
#define T1_BWI_DEFAULT		4

//
// This struct is used by the lib for processing T1 I/O
// It should not be modified by a driver directly.
//
typedef struct _T1_DATA {

	// Current information field size that can be transmitted
	UCHAR	IFSC;

    // Current information field size we can receive
    UCHAR   IFSD;

	// Number of bytes already received from smart card
	ULONG	BytesReceived;

	// Number of bytes already sent to the card;
	ULONG	BytesSent;

	// Total number of bytes still to send
	ULONG	BytesToSend;

	// Type of error 
	UCHAR 	LastError;

	// This flag is set whenever the IFD has to send more data
	BOOLEAN	MoreData;

	// This is the node address byte to be sent to the card
	UCHAR 	NAD;

	// The state before an error occured
	ULONG	OriginalState;

	// Resend counter
	UCHAR	Resend;

	// Resync counter
	UCHAR	Resynch;

	// The 'number' of received I-Blocks
	UCHAR	RSN;

	// The 'number' of sent I-Blocks as defined in ISO 7816-3
	UCHAR	SSN;

	// Current state of protocol
	ULONG	State;

	//
	// Waiting time extension requested by the smart card
	// This value should be used by the driver to extend block waiting time.
	//
	UCHAR	Wtx;

    // Pointer to result buffer
    PUCHAR  ReplyData;

    // This flag indicates that we're waiting for a reply from the card
    BOOLEAN WaitForReply;

    UCHAR   InfBytesSent;

#ifndef _WIN64
    // Reserved, do not use
    UCHAR Reserved[
        10 - 
        sizeof(PUCHAR) -
        sizeof(BOOLEAN) - 
        sizeof(UCHAR)];
#endif

} T1_DATA, *PT1_DATA;

//
// This struct is used by the lib for T1 I/O
//
typedef struct _T1_BLOCK_FRAME {
    
    UCHAR   Nad;
    UCHAR   Pcb;
    UCHAR   Len;
    PUCHAR  Inf;

} T1_BLOCK_FRAME, *PT1_BLOCK_FRAME;

//
// All lib functions put their data to send in this struct.
// The driver must send this data to the reader.
//
typedef struct _SMARTCARD_REQUEST {

	// Data to send
	PUCHAR	Buffer;

	// Allocted size of this buffer
	ULONG 	BufferSize;

	// Length of data for this command
	ULONG	BufferLength;

} SMARTCARD_REQUEST, *PSMARTCARD_REQUEST;

//
// The driver must put the received bytes into this buffer and 
// adjust the buffer length to the number of received bytes.
//
typedef struct _SMARTCARD_REPLY {
	
	// Buffer for received smart card data
	PUCHAR	Buffer;

	// Allocted size of this buffer
	ULONG 	BufferSize;

	// Number of bytes received from the card
	ULONG	BufferLength;

} SMARTCARD_REPLY, *PSMARTCARD_REPLY;

//
// Clock rate conversion table according to ISO 
//
typedef struct _CLOCK_RATE_CONVERSION {

	const ULONG F;
	const ULONG fs; 

} CLOCK_RATE_CONVERSION, *PCLOCK_RATE_CONVERSION;

//
// Bit rate adjustment factor 
// The layout of this table has been slightly modified due to 
// the unavailibility of floating point math support in the kernel.
// The value D has beed devided into a numerator and a divisor.
//
typedef struct _BIT_RATE_ADJUSTMENT {

	const ULONG DNumerator;
	const ULONG DDivisor;

} BIT_RATE_ADJUSTMENT, *PBIT_RATE_ADJUSTMENT;

#ifdef _ISO_TABLES_
#define MHZ * 1000000l

//
// The clock rate conversion table itself.
// All R(eserved)F(or Future)U(se) fields MUST be 0
//
static CLOCK_RATE_CONVERSION ClockRateConversion[] = {

		{ 372, 	4 MHZ	}, 
		{ 372, 	5 MHZ	}, 
		{ 558, 	6 MHZ	}, 
		{ 744, 	8 MHZ	}, 
		{ 1116, 12 MHZ	}, 
		{ 1488, 16 MHZ	},
		{ 1860, 20 MHZ	},
		{ 0, 	0		},
		{ 0, 	0		},
		{ 512, 	5 MHZ	},
		{ 768, 	7500000	},
		{ 1024, 10 MHZ	},
		{ 1536, 15 MHZ	},
		{ 2048, 20 MHZ	},
		{ 0, 	0		},
		{ 0, 	0		}
};		

#undef MHZ

//
// The bit rate adjustment table itself.
// All R(eserved)F(or)U(se) fields MUST be 0
//
static BIT_RATE_ADJUSTMENT BitRateAdjustment[] = {

	{ 0,	0	},
	{ 1,	1	},
	{ 2,	1	},
	{ 4,	1	},
	{ 8,	1	},
	{ 16,	1	},
	{ 32,	1	},
	{ 0,	0	},
	{ 12,	1	},
	{ 20,	1	},
	{ 0,	0	},
	{ 0,	0	},
	{ 0,	0	},
	{ 0,	0	},
	{ 0,	0	},
	{ 0,	0	}
};
#endif

#if defined (DEBUG) && defined (SMCLIB_NT)
typedef struct _PERF_INFO { 

    ULONG NumTransmissions;
    ULONG BytesSent;
    ULONG BytesReceived;
    LARGE_INTEGER IoTickCount;
    LARGE_INTEGER TickStart;
    LARGE_INTEGER TickEnd;
} PERF_INFO, *PPERF_INFO;
#endif

//
// structure used for protocol type selection (PTS)
//
typedef struct _PTS_DATA {

#define PTS_TYPE_DEFAULT 0x00
#define PTS_TYPE_OPTIMAL 0x01
#define PTS_TYPE_USER    0x02

    UCHAR Type;

    // Fl value for PTS
    UCHAR Fl;

    // Dl value for PTS
    UCHAR Dl;     	

    // New clock frequency
    ULONG CLKFrequency;

    // New baud rate to be used after pts
    ULONG DataRate;

    // new stop bits to be used after pts
    UCHAR StopBits;

} PTS_DATA, *PPTS_DATA;

//
// This struct holds information for the card currently in use
// The driver must store a received ATR into the ATR struct which is
// part of this struct. The lib will get all other information 
// out of the ATR.
//
typedef struct _SCARD_CARD_CAPABILITIES{

	// Flag that indicates that the current card uses invers convention
	BOOLEAN InversConvention;

	// Calculated etu 
	ULONG	etu;
      
    //
    // Answer To Reset string returned by card.
    // Use OsData->SpinLock to access this member
    //
	struct {

		UCHAR Buffer[64];
		UCHAR Length;

	} ATR;

	struct {

		UCHAR Buffer[16];
		UCHAR Length;

	} HistoricalChars;

    // !!! DO NOT MODIFY ANY OF THE BELOW VALUES
    // OTHERWISE THE LIBRARY WON'T WORK PROPERLY

	//
	// The following 2 tables are provided to give 
	// the driver access to the ISO definitions
	//
	PCLOCK_RATE_CONVERSION 	ClockRateConversion;
	PBIT_RATE_ADJUSTMENT 	BitRateAdjustment;

	// Clock rate conversion 
	UCHAR Fl;

	// Bit rate adjustment
	UCHAR Dl;

	// Maximum programming current
	UCHAR II;

	// Programming voltage in .1 Volts
	UCHAR P;

	// Extra guard time in etu 
	UCHAR N;

	// Calculated guard time in micro seconds
	ULONG GT;

	struct {

		// This is a bit mask of the supported protocols
		ULONG Supported;
		// The currently selected protocol
		ULONG Selected;

	} Protocol;

	// T=0 specific data
	struct {

		// Waiting integer
		UCHAR WI;

		// Waiting time in micro seconds
		ULONG WT;

	} T0;

	// T=1 specific data
	struct {

		// Information field size of card
		UCHAR IFSC;

		// Character waiting integer and block waiting integer
		UCHAR CWI;
		UCHAR BWI;

		// Error detection code
		UCHAR EDC;

		// Character and block waiting time in micro seconds
		ULONG CWT;
		ULONG BWT;

		// Block guarding time in micro seconds
		ULONG BGT;

	} T1;

    PTS_DATA PtsData;

    UCHAR Reserved[100 - sizeof(PTS_DATA)];

} SCARD_CARD_CAPABILITIES, *PSCARD_CARD_CAPABILITIES;

//
// structure used for passing configuration info between miniport/class
//
typedef struct _SCARD_READER_CAPABILITIES {

	// Supported protocol by the reader/driver (mandatory)
    ULONG SupportedProtocols;

    ULONG Reserved;

	// Type of reader (Serial/USB/PCMCIA/Keyboard etc)
	ULONG	ReaderType;

	// Mechanical characteristics like SCARD_READER_SWALLOWS etc.
	ULONG	MechProperties;

    //
    // Current state of reader (card present/removed/activated)
    // Use OsData->SpinLock to access this member
    // (mandatory)
    //
    ULONG 	CurrentState;

	//
	// The channel id the reader uses depending on the type of reader:
	// 	- Port number for serial reader
	//	- Port number for par reader
	//	- Scsi id for scsi reader
	//	- 0 for keyboard reader
	//	- device number for USB
	//
	ULONG	Channel;

    //
    // Clock rates in KHz encoded as little endian
    // (I.e. 3.58MHz is encoded as 3580)
    // (mandatory)
    //
    struct {
     	
        ULONG Default;
        ULONG Max;

    } CLKFrequency;

    // Data rates in bps encoded as little endian (mandatory)
    struct {
     	
        ULONG Default;
        ULONG Max;

    } DataRate;

    // Maximum IFSD supported by IFD
    ULONG   MaxIFSD;              

    //
    // Type of power management the card supports
    // (0 = ifd doesn't support pwr mgnt)
    //
    ULONG   PowerMgmtSupport;

    // Boolean that indicates that the card has been confiscated
    ULONG   CardConfiscated;

    //
    // A list of data rates supported by the ifd.
    // If this list is empty, the DataRate struct will be taken
    // (optional)
    //
    struct _DataRatesSupported {

        PULONG List;
        UCHAR  Entries;
     	
    } DataRatesSupported;

    //
    // A list of supported clock frequencies.
    // If this list is empty, the CLKFrequency struct will be taken
    // (optional)
    //
    struct _CLKFrequenciesSupported {
     	
        PULONG List;
        UCHAR  Entries;

    } CLKFrequenciesSupported;

    // Reserved, do not use
    UCHAR Reserved1[
        100 - 
        sizeof(ULONG) - 
        sizeof(struct _DataRatesSupported) - 
        sizeof(struct _CLKFrequenciesSupported)
        ];

} SCARD_READER_CAPABILITIES, *PSCARD_READER_CAPABILITIES;

//
// This struct holds the mandatory reader info
//
typedef struct _VENDOR_ATTR {

	// Manufacturer name (mandatory)
	struct {
		
		USHORT Length;
		UCHAR  Buffer[MAXIMUM_ATTR_STRING_LENGTH];
	} VendorName;

	// Name (designation) of reader (mandatory)
	struct {
		
		USHORT Length;
		UCHAR  Buffer[MAXIMUM_ATTR_STRING_LENGTH];
	} IfdType;

	//
	// If more than one reader of the same type are installed
	// this unit number is used to destinguish these readers
	// (mandatory)
    //
	ULONG	UnitNo;

    // IFD Version number (optional)
    struct {
        
        USHORT  BuildNumber;
        UCHAR   VersionMinor;
        UCHAR   VersionMajor;
    } IfdVersion;

    // IFD Serial number (optional)
	struct {
		
		USHORT Length;
		UCHAR  Buffer[MAXIMUM_ATTR_STRING_LENGTH];
	} IfdSerialNo;

    // Reserved, do not use
    ULONG   Reserved[25];

} VENDOR_ATTR, *PVENDOR_ATTR;

//                                           
// Forward definitions
//
typedef struct _READER_EXTENSION *PREADER_EXTENSION;
typedef struct _OS_DEP_DATA *POS_DEP_DATA;
typedef struct _SMARTCARD_EXTENSION *PSMARTCARD_EXTENSION;

//
// Define the smartcard portion of the port device extension.
//
typedef struct _SMARTCARD_EXTENSION {

    // Version of this structure
    ULONG           Version;

	// Mandatory reader info
	VENDOR_ATTR		VendorAttr;

	// Array of callback reader functions
	NTSTATUS (*ReaderFunction[16])(PSMARTCARD_EXTENSION);

	// Capabilities of the current inserted card
	SCARD_CARD_CAPABILITIES	CardCapabilities;

	//
	// This is used to store the last error of an overlapped operation
	// (Used only for Win9x VxD's)
    //
	ULONG LastError;

	// This struct holds the data of the users io request
	struct {

		// Number of bytes returned
		PULONG	Information;
		
		// Pointer to data to send to the card
		PUCHAR	RequestBuffer;

		// Number of bytes to send
		ULONG	RequestBufferLength;

		// Pointer to buffer that receives the answer
		PUCHAR	ReplyBuffer;

		// Size of reply buffer
		ULONG	ReplyBufferLength;

	} IoRequest;

	// Major and minor io control code for current request
	ULONG	MajorIoControlCode;
	ULONG	MinorIoControlCode;

	// OS dependent data
	POS_DEP_DATA    OsData;

	// Capabilities of the keyboard-reader
	SCARD_READER_CAPABILITIES	ReaderCapabilities;

	// Reader specific data
	PREADER_EXTENSION	ReaderExtension;

    //
	// The reader stores all replies from the card here
    // This can be used by the driver for data coming from the reader
    //
	SMARTCARD_REPLY		SmartcardReply;

    //
	// Current command that will be sent to the smart card
    // This can be used by the driver for data to send to the readaer
    //
	SMARTCARD_REQUEST	SmartcardRequest;

	// Data for T=0
	T0_DATA	T0;

	// Data for T=1
	T1_DATA	T1;

#if defined (DEBUG) && defined (SMCLIB_NT)
    PPERF_INFO PerfInfo;
#endif
    // Reserved, do not use
    ULONG   Reserved[
        25 
#if defined (DEBUG) && defined (SMCLIB_NT)
        - sizeof(PPERF_INFO)
#endif
        ];

} SMARTCARD_EXTENSION, *PSMARTCARD_EXTENSION;

#ifdef SMCLIB_VXD

// ****************************************************************************
// Windows 95 definitions and prototyping
// ****************************************************************************

#ifndef SMCLIB_DEVICE_ID
#define SMCLIB_DEVICE_ID    0x0004E /* Smart Card port driver */
#else
#if SMCLIB_DEVICE_ID != 0x0004E
#error "Incorrect SMCLIB_DEVICE_ID Definition"
#endif
#endif

#define SMCLIB_Service Declare_Service
#pragma warning(disable:4003)

Begin_Service_Table(SMCLIB)
SMCLIB_Service(SMCLIB_Get_Version)
SMCLIB_Service(SMCLIB_SmartcardCreateLink)
SMCLIB_Service(SMCLIB_SmartcardDeleteLink)
SMCLIB_Service(SMCLIB_SmartcardDeviceControl)
SMCLIB_Service(SMCLIB_SmartcardExit)
SMCLIB_Service(SMCLIB_SmartcardInitialize)
SMCLIB_Service(SMCLIB_SmartcardLogError)
SMCLIB_Service(SMCLIB_SmartcardRawReply)
SMCLIB_Service(SMCLIB_SmartcardRawRequest)
SMCLIB_Service(SMCLIB_SmartcardT0Reply)
SMCLIB_Service(SMCLIB_SmartcardT0Request)
SMCLIB_Service(SMCLIB_SmartcardT1Reply)
SMCLIB_Service(SMCLIB_SmartcardT1Request)
SMCLIB_Service(SMCLIB_SmartcardUpdateCardCapabilities)
SMCLIB_Service(SMCLIB_SmartcardGetDebugLevel)
SMCLIB_Service(SMCLIB_SmartcardSetDebugLevel)
SMCLIB_Service(SMCLIB_MapNtStatusToWinError)
SMCLIB_Service(SMCLIB_Assert)
SMCLIB_Service(SMCLIB_VxD_CreateDevice)
SMCLIB_Service(SMCLIB_VxD_DeleteDevice)
SMCLIB_Service(SMCLIB_SmartcardCompleteCardTracking)
SMCLIB_Service(SMCLIB_SmartcardCompleteRequest)
End_Service_Table(SMCLIB)

PVMMDDB
VXDINLINE 
VxD_CreateDevice(
    char *Device, 
    void (*ControlProc)(void)
	)
{
    _asm push ControlProc
    _asm push Device
    VxDCall(SMCLIB_VxD_CreateDevice); 	
    _asm add sp, 8
}

BOOL
VXDINLINE 
VxD_DeleteDevice(
    PVMMDDB pDDB
	)
{
    _asm push pDDB
    VxDCall(SMCLIB_VxD_DeleteDevice); 	
    _asm add sp, 4
}

NTSTATUS
VXDINLINE 
SmartcardAssert(
    PVOID FailedAssertion,
    PVOID FileName,
    ULONG LineNumber,
    PCHAR Message
	)
{
    _asm push Message
    _asm push LineNumber
    _asm push FileName
    _asm push FailedAssertion
    VxDCall(SMCLIB_Assert); 	
    _asm add sp, 16
}

NTSTATUS
VXDINLINE 
SmartcardCreateLink(
	PUCHAR LinkName,
	PUCHAR DeviceName
	)
{
    _asm push DeviceName
    _asm push LinkName
    VxDCall(SMCLIB_SmartcardCreateLink); 	
    _asm add sp, 8
}

NTSTATUS
VXDINLINE 
SmartcardDeleteLink(
	PUCHAR LinkName
	)
{
    _asm push LinkName
    VxDCall(SMCLIB_SmartcardDeleteLink); 	
    _asm add sp, 4
}

NTSTATUS
VXDINLINE 
SmartcardDeviceControl(
    PSMARTCARD_EXTENSION SmartcardExtension,
    DIOCPARAMETERS *lpDIOCParmas
    )
{
    _asm push lpDIOCParmas
    _asm push SmartcardExtension
    VxDCall(SMCLIB_SmartcardDeviceControl); 	
    _asm add sp, 8
}

VOID
VXDINLINE 
SmartcardExit(
    PSMARTCARD_EXTENSION SmartcardExtension
    )
{
    _asm push SmartcardExtension
    VxDCall(SMCLIB_SmartcardExit); 	
    _asm add sp, 4
}

NTSTATUS
VXDINLINE 
SmartcardInitialize(
    PSMARTCARD_EXTENSION SmartcardExtension
    )
{
    _asm push SmartcardExtension
    VxDCall(SMCLIB_SmartcardInitialize); 	
    _asm add sp, 4
}

VOID
VXDINLINE 
SmartcardLogError(
    )
{
    VxDCall(SMCLIB_SmartcardLogError); 		
}

NTSTATUS
VXDINLINE 
SmartcardRawReply(
	PSMARTCARD_EXTENSION SmartcardExtension
	)
{
    _asm push SmartcardExtension
    VxDCall(SMCLIB_SmartcardRawReply); 	
    _asm add sp, 4
}

NTSTATUS
VXDINLINE 
SmartcardRawRequest(
	PSMARTCARD_EXTENSION SmartcardExtension
	)
{
    _asm push SmartcardExtension
    VxDCall(SMCLIB_SmartcardRawRequest); 	
    _asm add sp, 4
}

NTSTATUS
VXDINLINE 
SmartcardT0Reply(
	PSMARTCARD_EXTENSION SmartcardExtension
	)
{
    _asm push SmartcardExtension
    VxDCall(SMCLIB_SmartcardT0Reply); 	
    _asm add sp, 4
}

NTSTATUS
VXDINLINE 
SmartcardT0Request(
	PSMARTCARD_EXTENSION SmartcardExtension
	)
{
    _asm push SmartcardExtension
    VxDCall(SMCLIB_SmartcardT0Request); 	
    _asm add sp, 4
}

NTSTATUS
VXDINLINE 
SmartcardT1Reply(
	PSMARTCARD_EXTENSION SmartcardExtension
	)
{
    _asm push SmartcardExtension
    VxDCall(SMCLIB_SmartcardT1Reply); 	
    _asm add sp, 4
}

NTSTATUS
VXDINLINE 
SmartcardT1Request(
	PSMARTCARD_EXTENSION SmartcardExtension
	)
{
    _asm push SmartcardExtension
    VxDCall(SMCLIB_SmartcardT1Request); 	
    _asm add sp, 4
}

NTSTATUS
VXDINLINE 
SmartcardUpdateCardCapabilities(
    PSMARTCARD_EXTENSION SmartcardExtension
    )
{
    _asm push SmartcardExtension
    VxDCall(SMCLIB_SmartcardUpdateCardCapabilities); 	
    _asm add sp, 4
}

ULONG
VXDINLINE 
SmartcardGetDebugLevel(
	void
	)
{
    VxDCall(SMCLIB_SmartcardGetDebugLevel); 	
}

void
VXDINLINE 
SmartcardSetDebugLevel(
	ULONG Level
	)
{
    _asm push Level
    VxDCall(SMCLIB_SmartcardSetDebugLevel); 	
    _asm add sp, 4
}

void
VXDINLINE 
SmartcardCompleteCardTracking(
	PSMARTCARD_EXTENSION SmartcardExtension
	)
{
    _asm push SmartcardExtension
    VxDCall(SMCLIB_SmartcardCompleteCardTracking); 	
    _asm add sp, 4
}

void
VXDINLINE 
SmartcardCompleteRequest(
	PSMARTCARD_EXTENSION SmartcardExtension
	)
{
    _asm push SmartcardExtension
    VxDCall(SMCLIB_SmartcardCompleteRequest); 	
    _asm add sp, 4
}

ULONG
VXDINLINE 
MapNtStatusToWinError(
	NTSTATUS status
	)
{
    _asm push status
    VxDCall(SMCLIB_MapNtStatusToWinError); 	
    _asm add sp, 4
}

VOID
SmartcardInvertData(
	PUCHAR Buffer,
	ULONG Length
    );

#else 

// ****************************************************************************
// Windows NT and Windows CE prototyping
// ****************************************************************************

#ifndef _SMCLIBSYSTEM_
#define SMCLIBAPI _declspec(dllimport)
#else
#define SMCLIBAPI
#endif

#ifdef SMCLIB_CE
#define SmartcardLogError(Object,ErrorCode,Insertion,DumpWord)
#else
VOID
SMCLIBAPI
SmartcardLogError(
    PVOID Object,
	LONG ErrorCode,
	PUNICODE_STRING Insertion,
    ULONG DumpWord
	);
#endif


#ifdef SMCLIB_CE
NTSTATUS
SMCLIBAPI
SmartcardDeviceControl(
    PSMARTCARD_EXTENSION SmartcardExtension,
    DWORD dwIoControlCode,
    PBYTE pInBuf,
    DWORD nInBufSize,
    PBYTE pOutBuf,
    DWORD nOutBufSize,
    PDWORD pBytesReturned
    );
#else
NTSTATUS
SMCLIBAPI
SmartcardDeviceControl(
    PSMARTCARD_EXTENSION SmartcardExtension,
    PIRP Irp
    );
#endif

VOID
SMCLIBAPI
SmartcardInitializeCardCapabilities(
    PSMARTCARD_EXTENSION SmartcardExtension
    );

NTSTATUS
SMCLIBAPI
SmartcardInitialize(
    PSMARTCARD_EXTENSION SmartcardExtension
    );

VOID
SMCLIBAPI
SmartcardCompleteCardTracking(
    PSMARTCARD_EXTENSION SmartcardExtension
    );

VOID
SMCLIBAPI
SmartcardExit(
    PSMARTCARD_EXTENSION SmartcardExtension
    );

NTSTATUS
SMCLIBAPI
SmartcardUpdateCardCapabilities(
    PSMARTCARD_EXTENSION SmartcardExtension
    );

NTSTATUS
SMCLIBAPI
SmartcardRawRequest(
	PSMARTCARD_EXTENSION SmartcardExtension
	);

NTSTATUS
SMCLIBAPI
SmartcardT0Request(
	PSMARTCARD_EXTENSION SmartcardExtension
	);

NTSTATUS
SMCLIBAPI
SmartcardT1Request(
	PSMARTCARD_EXTENSION SmartcardExtension
	);

NTSTATUS
SMCLIBAPI
SmartcardRawReply(
	PSMARTCARD_EXTENSION SmartcardExtension
	);

NTSTATUS
SMCLIBAPI
SmartcardT0Reply(
	PSMARTCARD_EXTENSION SmartcardExtension
	);

NTSTATUS
SMCLIBAPI
SmartcardT1Reply(
	PSMARTCARD_EXTENSION SmartcardExtension
	);

VOID 
SMCLIBAPI
SmartcardInvertData(
	PUCHAR Buffer,
	ULONG Length
	);

#ifndef SMCLIB_CE
// Following APIs not defined in Windows CE
NTSTATUS
SMCLIBAPI
SmartcardCreateLink(
	IN OUT PUNICODE_STRING LinkName,
	IN PUNICODE_STRING DeviceName
	);

ULONG
SMCLIBAPI
SmartcardGetDebugLevel(
	void
	);

void
SMCLIBAPI
SmartcardSetDebugLevel(
	ULONG Level
	);

NTSTATUS
SmartcardAcquireRemoveLock(
	IN PSMARTCARD_EXTENSION SmartcardExtension
	);

NTSTATUS
SmartcardAcquireRemoveLockWithTag(
	IN PSMARTCARD_EXTENSION SmartcardExtension,
	IN ULONG Tag
	);

VOID
SmartcardReleaseRemoveLock(
	IN PSMARTCARD_EXTENSION SmartcardExtension
	);

VOID
SmartcardReleaseRemoveLockWithTag(
	IN PSMARTCARD_EXTENSION SmartcardExtension,
	IN ULONG Tag
	);

VOID
SmartcardReleaseRemoveLockAndWait(
	IN PSMARTCARD_EXTENSION SmartcardExtension
    );
#else
// WinCE only
ULONG
MapNtStatusToWinError(
	NTSTATUS status
	);
#endif

#endif

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\inc\smcnt.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    smcnt.h

Abstract:

    This files inlcudes the Windows NT specific data structure
    for the smart card library

Environment:

    Kernel mode only.

Notes:

Revision History:

    - Created December 1996 by Klaus Schutz 

--*/

#define SMCLIB_NT 1

typedef struct _OS_DEP_DATA {

	// Pointer to the device object (Must be set by driver)
	PDEVICE_OBJECT DeviceObject;

    //
	// This is the current Irp to be processed
    // Use OsData->SpinLock to access this member
    //
	PIRP CurrentIrp;

    //
    // Irp to be notified of card insertion/removal 
    // Use OsData->SpinLock to access this member
    //
    PIRP NotificationIrp;

    // Used to synchronize access to the driver 
    KMUTANT Mutex;

    // Use this spin lock to access protected members (see smclib.h)
    KSPIN_LOCK SpinLock;

    struct {
     	
        BOOLEAN Removed;
        LONG RefCount;
        KEVENT RemoveEvent;
		LIST_ENTRY TagList;
    } RemoveLock;

#ifdef DEBUG_INTERFACE
    PDEVICE_OBJECT DebugDeviceObject;
#endif

} OS_DEP_DATA, *POS_DEP_DATA;

#ifdef  POOL_TAGGING
#ifndef ExAllocatePool
#error  ExAllocatePool not defined
#endif
#undef  ExAllocatePool
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b, SMARTCARD_POOL_TAG) 
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\lit220\l220fltr.c ===
/*++

Module Name:

    L220FLTR.c

Abstract:

    This module contains the input filter routine and the notification 
    procedure for insertion/removal events.  

Environment:

    Kernel mode only.

Notes:

Revision History:

    - Created December 1996 by Klaus Schutz (kschutz)

    - Modified December 1997 by Brian Manahan for use with
        our 220 reader.

--*/

#include <stdarg.h>
#include <stdio.h>
#include <string.h>

#include "L220SCR.h"


#pragma alloc_text(PAGEABLE, Lit220StartTimer)
#pragma alloc_text(PAGEABLE, Lit220StopTimer)


static DWORD bTrue = TRUE;
static DWORD bFalse = FALSE;


BOOLEAN
Lit220InputFilter(
    IN BYTE SmartcardByte,
    IN PSMARTCARD_EXTENSION smartcardExtension
    )
/*++

Routine Description:

    This routine is processes each byte from the serial port.
    Lit220SerialEventCallback call this function when it receives a byte
    of data from the serial port.  For card insertion/removal it will call the
    Lit220NotifyCardChange to process the notificiation.  
    If an ACK is received it will signal the Lit220SendCommand so it can continue.
    After a data block is received it will signal the Lit220SendCommand
    to notifiy that the data is ready.
--*/
{
    PREADER_EXTENSION readerExtension = smartcardExtension->ReaderExtension;
    PDEVICE_EXTENSION deviceExtension = smartcardExtension->OsData->DeviceObject->DeviceExtension;

    LONG semState;
    BOOLEAN retVal = TRUE;
    KIRQL irql;


    //
    // The first byte of each packet identifies the packet-type
    // A packet containing data starts with the packet-type and then
    // 2 bytes of packet length.
    //
    if (++readerExtension->ReceivedByteNo == 1) {
    
        readerExtension->GotLengthB0 = FALSE;
        readerExtension->GotLengthB1 = FALSE;
        readerExtension->DataByteNo = 0;
         
        switch (SmartcardByte) {
        
            case LIT220_READER_TYPE:
    
                // Prepare for reader type input
                readerExtension->GotLengthB0 = TRUE;
                readerExtension->GotLengthB1 = TRUE;
                readerExtension->DataLength.l.l0 = 
                    LIT220_READER_TYPE_LEN;
                break;
                
            case LIT220_READER_STATUS:

                // Prepare for reader status input
                readerExtension->GotLengthB0 = TRUE;
                readerExtension->GotLengthB1 = TRUE;
                readerExtension->DataLength.l.l0 = 
                    LIT220_READER_STATUS_LEN;
                break;    
                
            case LIT220_RECEIVE_BLOCK:
                // If a smart card was already inserted in the boot phase
                // the reader sends only the ATR but no CARD_IN - msg.
                // We fix that missing msg here.
                //

                KeAcquireSpinLock(&smartcardExtension->OsData->SpinLock,
                                  &irql);
                if (smartcardExtension->ReaderCapabilities.CurrentState == SCARD_UNKNOWN) {
                
                    smartcardExtension->ReaderCapabilities.CurrentState = SCARD_SWALLOWED;
                }

                KeReleaseSpinLock(&smartcardExtension->OsData->SpinLock,
                                  irql);
                
                break;    
                
            case LIT220_CARD_IN:

                Lit220NotifyCardChange(
                    smartcardExtension,
                    TRUE
                    );

                readerExtension->ReceivedByteNo = 0;
                break;    
                
            case LIT220_CARD_OUT:

                Lit220NotifyCardChange(
                    smartcardExtension,
                    FALSE
                    );

                    
                readerExtension->ReceivedByteNo = 0;
                    
                break;    
                
            case LIT220_ACK:
            case KBD_ACK: // Also allow kdb_ack for the case for getting keyboard attention
                readerExtension->GotNack = FALSE;
                readerExtension->ReceivedByteNo = 0;


                // Check if anyone needs to be singaled for this event.
                // The Lit220SendCommand waits for the ACK signal so it knows
                // when it can continue.
                if (readerExtension->WaitMask & WAIT_ACK) {
                    
                    // Only signal once
                    readerExtension->WaitMask &= ~WAIT_ACK;

                    // Signal the AckEvnt
                    KeSetEvent(
                        &readerExtension->AckEvnt,
                        0, 
                        FALSE
                        );
                }   
                             
                break;    
                
                
            case LIT220_NACK:
                SmartcardDebug(
                    DEBUG_ERROR, 
                    ("%s!Lit220InteruptService: LIT220_NACK\n",
                    DRIVER_NAME)
                    );

                Lit220ProcessNack(smartcardExtension);

                break;    

            default:
                readerExtension->ReceivedByteNo = 0;
                
                SmartcardDebug(
                    DEBUG_ERROR,
                    ("%s!Lit220InteruptService: Invalid PacketType %xh\n",
                    DRIVER_NAME,
                    SmartcardByte)
                    );

                // Return false so the rest of this bad buffer 
                // will not be sent to us.
                retVal = FALSE; 

                // We want to force a NACK so the
                // the state of the card being inserted or not
                // is re-checked
                Lit220ProcessNack(smartcardExtension);
        }
        
        return retVal;
    }    
       
    //
    // Get length-byte-0 from reader
    //        
    if (readerExtension->ReceivedByteNo == 2 &&
        readerExtension->GotLengthB0 == FALSE)  {
            
        readerExtension->DataLength.b.b1 = SmartcardByte;
        readerExtension->GotLengthB0 = TRUE;
        return TRUE;
    }
        
    //
    // Get length-byte-1 from reader
    //        
    if (readerExtension->ReceivedByteNo == 3 &&
        readerExtension->GotLengthB1 == FALSE)  {
            
        readerExtension->DataLength.b.b0 = SmartcardByte;
        readerExtension->GotLengthB1 = TRUE;
        
        // 
        // test if the reader has sent a zero-length block of data
        //
        if (readerExtension->DataLength.l.l0 == 0) {
        
            readerExtension->ReceivedByteNo = 0;
            readerExtension->WaitForATR = FALSE;        
            
            SmartcardDebug(
                DEBUG_ERROR,
                ("%s!SmartcardInterruptService: Zero length block received\n",
                DRIVER_NAME)
                );
        }

        if (readerExtension->DataLength.l.l0 > 
            smartcardExtension->SmartcardReply.BufferSize) {

            readerExtension->ReceivedByteNo = 0;
            readerExtension->WaitForATR = FALSE;        
            
            SmartcardDebug(
                DEBUG_ERROR,
                ("%s!SmartcardInterruptService: Reply buffer not large enough\n",
                DRIVER_NAME)
                );

        }
        return TRUE;
    }

    //
    // store data from reader
    //
    if ((readerExtension->DataByteNo < readerExtension->DataLength.l.l0) &&
        (readerExtension->DataByteNo < smartcardExtension->SmartcardReply.BufferSize))
    {

        smartcardExtension->SmartcardReply.Buffer[readerExtension->DataByteNo++] = 
            SmartcardByte;

    } else {
        SmartcardDebug(
            DEBUG_ERROR,
            ("%s!SmartcardInterruptService: DataByteNo %X too large buffer %X, %X bytest expected\n",
            DRIVER_NAME,
            readerExtension->DataByteNo,
            smartcardExtension->SmartcardReply.BufferSize,
            readerExtension->DataLength.l.l0)
            );

    }

    ASSERT(readerExtension->DataByteNo <= readerExtension->DataLength.l.l0);
    //
    // Have we received all the bytes in the packet yet?
    //
    if (readerExtension->DataByteNo == readerExtension->DataLength.l.l0) {
                                     
        // Stop the input timeout timer
        // schedule our remove thread
        Lit220ScheduleTimer(
            smartcardExtension,
            Lit220StopTimer
            );


        smartcardExtension->SmartcardReply.BufferLength = 
            readerExtension->DataByteNo;

        readerExtension->ReceivedByteNo = 0;
        
        if (readerExtension->WaitForATR)  {
            
            //
            // Transfer ATR to smartcard-struct
            //
            smartcardExtension->CardCapabilities.ATR.Length = 
                (UCHAR) (readerExtension->DataByteNo % (SCARD_ATR_LENGTH + 1));
              
            readerExtension->WaitForATR = FALSE;        

            if (smartcardExtension->CardCapabilities.ATR.Length >
                smartcardExtension->SmartcardReply.BufferLength)
            {
                SmartcardDebug(
                    DEBUG_ERROR,
                    ("%s!SmartcardInterruptService: SmarcardReply buffer too  small for ATR\n",
                    DRIVER_NAME)
                    );
            } else {

                RtlCopyMemory(
                    smartcardExtension->CardCapabilities.ATR.Buffer,
                    smartcardExtension->SmartcardReply.Buffer,
                    smartcardExtension->CardCapabilities.ATR.Length
                    );
          
                SmartcardUpdateCardCapabilities(
                    smartcardExtension
                    );
            }
        }
        
        
        // Check if anyone needs to be singaled for this event.
        // The Lit220SendCommand waits for the DataEvnt signal so it knows
        // when the data has been received.
        if (readerExtension->WaitMask & WAIT_DATA) {
        
            //
            // Do any necessary post proccessing after we have receive the packet
            //
            if (smartcardExtension->OsData->CurrentIrp != NULL)  {
  
                NTSTATUS status = STATUS_SUCCESS;

                switch (smartcardExtension->MajorIoControlCode) {
      
                    case IOCTL_SMARTCARD_POWER:
                        if (smartcardExtension->ReaderExtension->GotNack) {                
              
                            status = STATUS_NO_MEDIA;
                            break;
                        }
          
                        switch(smartcardExtension->MinorIoControlCode) {
                      
                            case SCARD_COLD_RESET:
                            case SCARD_WARM_RESET:
                                if (smartcardExtension->IoRequest.ReplyBufferLength <
                                    smartcardExtension->CardCapabilities.ATR.Length) {
                              
                                        status = STATUS_BUFFER_TOO_SMALL;
                              
                                } else {
                  
                                    //
                                    // copy ATR to user buffer
                                    //
                                    if (smartcardExtension->CardCapabilities.ATR.Length <=
                                        sizeof(smartcardExtension->CardCapabilities.ATR.Buffer)) 
                                    {
                                        RtlCopyMemory(
                                            smartcardExtension->IoRequest.ReplyBuffer,
                                            &smartcardExtension->CardCapabilities.ATR.Buffer, 
                                            smartcardExtension->CardCapabilities.ATR.Length
                                            );
                            
                                        // 
                                        // length of buffer
                                        //        
                                        *(smartcardExtension->IoRequest.Information) = 
                                            smartcardExtension->CardCapabilities.ATR.Length;                            
                                    }
                                }
                      
                                break;
                      
                        case SCARD_POWER_DOWN:
                                KeAcquireSpinLock(&smartcardExtension->OsData->SpinLock,
                                                  &irql);
                                if (smartcardExtension->ReaderCapabilities.CurrentState != SCARD_ABSENT) {
                                    smartcardExtension->ReaderCapabilities.CurrentState = 
                                        SCARD_SWALLOWED;
                              
                                    smartcardExtension->CardCapabilities.Protocol.Selected = 
                                        SCARD_PROTOCOL_UNDEFINED;
                                }
                                KeReleaseSpinLock(&smartcardExtension->OsData->SpinLock,
                                                  irql);
                                break;
                      
                        }
                        break;
              
                    case IOCTL_SMARTCARD_SET_PROTOCOL:
                        if (smartcardExtension->ReaderExtension->GotNack) {                
              
                            smartcardExtension->CardCapabilities.Protocol.Selected = 
                                SCARD_PROTOCOL_UNDEFINED;

                            status = STATUS_NO_MEDIA;
                            break;
                        }

                        //
                        // protocol has been changed successfully
                        //    

                        KeAcquireSpinLock(&smartcardExtension->OsData->SpinLock,
                                          &irql);
                        if (smartcardExtension->ReaderCapabilities.CurrentState != SCARD_ABSENT) {
                            smartcardExtension->ReaderCapabilities.CurrentState = 
                                SCARD_SPECIFIC;
                        }
                        KeReleaseSpinLock(&smartcardExtension->OsData->SpinLock,
                                          irql);

                        //
                        // Tell the caller what the current protocol is.
                        //
                        *(PULONG) smartcardExtension->IoRequest.ReplyBuffer =
                            smartcardExtension->CardCapabilities.Protocol.Selected;
    
                        *(smartcardExtension->IoRequest.Information) = 
                          sizeof(ULONG);

                        break;

                } 
      
            }

            // Only signal once
            readerExtension->WaitMask &= ~WAIT_DATA;
             
            // Signal the DataEvnt
            KeSetEvent(
                &readerExtension->DataEvnt,
                0, 
                FALSE
                );
        }
    }

    return TRUE;
}




VOID 
Lit220ProcessNack(
    PSMARTCARD_EXTENSION SmartcardExtension
    )
/*++

Routine Description:

    This routine handles everything that needs to be done when we have an error
    with the reader.  The state of the input filter is reset.  All signals that
    the Lit220Command function may be waiting on are fired.  The flag GotNack is
    set which will trigger Lit220Command to resync with the reader (get the last
    error and refresh the card inserted state).

--*/
{
    PREADER_EXTENSION readerExtension = SmartcardExtension->ReaderExtension;

    // Set GotNack so we know something went wrong
    readerExtension->GotNack = TRUE;

    // Reset the input state of the filter
    readerExtension->ReceivedByteNo = 0;
    

    //
    // Signal the ACK and data semaphores and set error code
    // This will keep the Lit220SendCommand from having to 
    // wait for a timeout to continue when something goes wrong.
    //
    if (readerExtension->WaitMask & WAIT_ACK) {
    
        // Signal the AckEvnt
        KeSetEvent(
            &readerExtension->AckEvnt,
            0, 
            FALSE
            );
    }

    if (readerExtension->WaitMask & WAIT_DATA) {

        // Signal the DataEvnt
        KeSetEvent(
            &readerExtension->DataEvnt,
            0, 
            FALSE
            );
    }


    //
    // Reset WaitMask since the card has nacked the command
    // 
    readerExtension->WaitMask &= (WAIT_INSERTION | WAIT_REMOVAL);
}




VOID
Lit220NotifyCardChange(
    IN PSMARTCARD_EXTENSION smartcardExtension,
    IN DWORD CardInserted
    )
/*++

Routine Description:

    This routine runs at DISPATCH_LEVEL IRQL to finish processing
    a card insertion/removal event.  It is queued in the smartcard filter
    and notifies a caller of an insertion/removal event.

--*/

{
    PREADER_EXTENSION readerExtension = smartcardExtension->ReaderExtension;
    KIRQL oldOsDataIrql;
    
    if (readerExtension->CardIn == CardInserted) {
        return;
    }
    readerExtension->CardIn = CardInserted;


    KeAcquireSpinLock(
        &smartcardExtension->OsData->SpinLock,
        &oldOsDataIrql
        );


    if (CardInserted) {
        // Set the default state for the new card
        smartcardExtension->ReaderCapabilities.CurrentState = 
            SCARD_SWALLOWED;

        smartcardExtension->CardCapabilities.Protocol.Selected = 
            SCARD_PROTOCOL_UNDEFINED;
    } else {
        // Reset card state to reflect the card removal
        smartcardExtension->ReaderCapabilities.CurrentState = 
            SCARD_ABSENT;

        smartcardExtension->CardCapabilities.Protocol.Selected = 
            SCARD_PROTOCOL_UNDEFINED;

        smartcardExtension->CardCapabilities.ATR.Length = 0; 
    }

    if (readerExtension->WaitMask & WAIT_INSERTION) {

        // We only make this notification once
        readerExtension->WaitMask &= ~WAIT_INSERTION;
    }      
    
    Lit220CompleteCardTracking(smartcardExtension);

    KeReleaseSpinLock(
        &smartcardExtension->OsData->SpinLock,
        oldOsDataIrql
        );

}


VOID
Lit220CompleteCardTracking(
    IN PSMARTCARD_EXTENSION SmartcardExtension
    )
{
    KIRQL oldIrql;
    PIRP notificationIrp;

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!Lit220CompleteCardTracking: Enter\n",
        DRIVER_NAME)
        );

    IoAcquireCancelSpinLock(&oldIrql);

    notificationIrp = InterlockedExchangePointer(
        &(SmartcardExtension->OsData->NotificationIrp),
        NULL
        );
    
    if (notificationIrp) {

        IoSetCancelRoutine(
            notificationIrp, 
            NULL
            );
    }

    IoReleaseCancelSpinLock(oldIrql);

    if (notificationIrp) {
        
        //  finish the request
        if (notificationIrp->Cancel) {
            
            notificationIrp->IoStatus.Status = STATUS_CANCELLED;

        } else {
            
            notificationIrp->IoStatus.Status = STATUS_SUCCESS;
        }
        notificationIrp->IoStatus.Information = 0;

        IoCompleteRequest(
            notificationIrp, 
            IO_NO_INCREMENT 
            );
    }
}


     
NTSTATUS 
Lit220SerialEventCallback(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PSMARTCARD_EXTENSION SmartcardExtension
    )
/*++

Routine Description:

    This routine is first called as the deferred procedure when a character is received
    or when DSR changes its status.
    It first calls the serial driver to get the modem status to see if the events was
    due to DSR changing (meaning the reader has been removed).  
    If DSR did not change it then checks the input queue size and reads the characters in
    the input queue.  It then sends the input characters to the input filter for processing.
    Finally it calls the serial driver again to start new cts tracking (starting all over again).
    This routine gets continually called back from itself until the driver is ready
    to unload (indicated by the WaitMask set to 0).
    When the WaitMask is set to 0 it frees this IRP and signals the Lit220WaitForRemoval thread
    to close the serial port.
--*/
{
    NTSTATUS status;
    PIO_STACK_LOCATION irpStack;
    DWORD indx;         
    KIRQL irql;
    PDEVICE_EXTENSION deviceExtension = SmartcardExtension->OsData->DeviceObject->DeviceExtension;

    SmartcardExtension->ReaderExtension->SerialEventState++;

    //
    // First check to see we are being unloaded
    //
    if (SmartcardExtension->ReaderExtension->SerialConfigData.WaitMask == 0) {
        SmartcardDebug(
            DEBUG_DRIVER,
            ("%s!Lit220SerialEventCallback: WAIT MASK 0 UNLOADING !!!!\n",
            DRIVER_NAME)
            );

        KeAcquireSpinLock(&SmartcardExtension->OsData->SpinLock,
                          &irql);
        SmartcardExtension->ReaderCapabilities.CurrentState = SCARD_UNKNOWN;

        KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                          irql);

        //
        // If the WaitMask is 0 then the driver is about to unload and we've
        // been called because the unload function has directed the serial
        // driver to complete the outstanding io completion.
        //

        // schedule our remove thread
        IoQueueWorkItem(
            deviceExtension->WorkItem,
            (PIO_WORKITEM_ROUTINE) Lit220CloseSerialPort,
            DelayedWorkQueue,
            NULL
            );

        //
        // We don't need the IRP anymore, so free it and tell the 
        // io subsystem not to touch it anymore by returning the value below
        //
        IoFreeIrp(Irp);
        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    // Get next stack location for next IRP
    irpStack = IoGetNextIrpStackLocation(
        SmartcardExtension->ReaderExtension->CardStatus.Irp
        );

    if (irpStack == NULL) {
        // Fatal Error
        SmartcardDebug(
            DEBUG_ERROR,
            ("%s!Lit220SerialEventCallback: Error IoGetNextIrpStackLocation returned NULL - exiting.\n",
            DRIVER_NAME)
            );
        return STATUS_SUCCESS;
    }

    switch (SmartcardExtension->ReaderExtension->SerialEventState) {
        case 1:
            //
            // First we send a get modem status
            //
            irpStack->MajorFunction = IRP_MJ_DEVICE_CONTROL;
            irpStack->MinorFunction = 0UL;
            irpStack->Parameters.DeviceIoControl.OutputBufferLength = 
                sizeof(SmartcardExtension->ReaderExtension->ModemStatus);
            irpStack->Parameters.DeviceIoControl.IoControlCode = 
                IOCTL_SERIAL_GET_MODEMSTATUS;

            SmartcardExtension->ReaderExtension->CardStatus.Irp->AssociatedIrp.SystemBuffer = 
                &SmartcardExtension->ReaderExtension->ModemStatus;

            break;

        case 2:
            //
            // Check modem status if DSR = 0 then unload driver if not 
            // then get queuestatus
            //
            if ((SmartcardExtension->ReaderExtension->ModemStatus & SERIAL_DSR_STATE) == 0) {
                // DSR is 0 this means the reader has been removed

                SmartcardDebug(
                    DEBUG_DRIVER,
                    ("%s!Lit220SerialEventCallback: DSR = 0 signaling to close device\n",
                    DRIVER_NAME)
                    );

                KeAcquireSpinLock(&SmartcardExtension->OsData->SpinLock,
                                  &irql);
                SmartcardExtension->ReaderExtension->SerialConfigData.WaitMask = 0;
                SmartcardExtension->ReaderCapabilities.CurrentState = SCARD_UNKNOWN;

                KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                                  irql);
                // schedule our remove thread
                IoQueueWorkItem(
                    deviceExtension->WorkItem,
                    (PIO_WORKITEM_ROUTINE) Lit220CloseSerialPort,
                    DelayedWorkQueue,
                    NULL
                    );
                
                //
                // We don't need the IRP anymore, so free it and tell the 
                // io subsystem not to touch it anymore by returning the value below
                //
                IoFreeIrp(Irp);
                return STATUS_MORE_PROCESSING_REQUIRED;

            } else {

                // Device is not removed - there must be a character ready
                // Read the data into our temporary buffer.  The temporary buffer
                // is large enough to read whatever the reader can send us a one time.
                // The character interval timeout will stop the read at the end of whatever
                // the reader sends us.
                SmartcardExtension->ReaderExtension->SerialStatus.AmountInInQueue =
                    sizeof(SmartcardExtension->ReaderExtension->TempXferBuf);

                // Read the characters
                irpStack->MajorFunction = IRP_MJ_READ;
                irpStack->Parameters.Read.Length = 
                    sizeof(SmartcardExtension->ReaderExtension->TempXferBuf);
                irpStack->MinorFunction = 0UL;

                SmartcardExtension->ReaderExtension->CardStatus.Irp->AssociatedIrp.SystemBuffer = 
                    SmartcardExtension->ReaderExtension->TempXferBuf;


            } 


            break;

        case 3:
            //
            // Send the characers we read to the input filter then setup for read input
            // queue again (in case some characters came in while we were processing the
            // ones we just read).
            // 
            for (indx = 0; indx < Irp->IoStatus.Information; indx++) {

                if (!Lit220InputFilter(
                        SmartcardExtension->ReaderExtension->TempXferBuf[indx],
                        SmartcardExtension
                        ))
                {
                    // An invalid character was received so stop sending the rest of
                    // the data to the filter because it is probably corrupted.
                    break;
                }
            }

            // Check if we are in the middle of a block of data
            if (SmartcardExtension->ReaderExtension->ReceivedByteNo != 0) {

                // Start the timeout timer.  If we don't get the rest of this 
                // data block in a few seconds we will timeout.  This prevents 
                // communication problems between the reader and the PC causing
                // locking up a T=0 card for too long.
                Lit220ScheduleTimer(
                    SmartcardExtension,
                    Lit220StartTimer
                    );

            }

                
            //
            // Read done - start all over again with the wait_on_mask
            //
            irpStack->MajorFunction = IRP_MJ_DEVICE_CONTROL;
            irpStack->MinorFunction = 0UL;
            irpStack->Parameters.DeviceIoControl.OutputBufferLength = 
                sizeof(SmartcardExtension->ReaderExtension->SerialConfigData.WaitMask);
            irpStack->Parameters.DeviceIoControl.IoControlCode = 
                IOCTL_SERIAL_WAIT_ON_MASK;

            SmartcardExtension->ReaderExtension->CardStatus.Irp->AssociatedIrp.SystemBuffer = 
                &SmartcardExtension->ReaderExtension->SerialConfigData.WaitMask;

            // Reset SerialEventState value
            SmartcardExtension->ReaderExtension->SerialEventState = 0;
            break;

        default:
            SmartcardDebug(
                DEBUG_ERROR,
                ("%s!Lit220SerialEventCallback: Error SerialEventState is out of bounds - resetting to 0\n",
                DRIVER_NAME)
                );
            //
            // We should never get here, but if we do we should try to recover the
            // best we can by setting up for the wait_on_mask.
            //

            // Reset value
            SmartcardExtension->ReaderExtension->SerialEventState = 0;

            // Setup for next callback
            irpStack->MajorFunction = IRP_MJ_DEVICE_CONTROL;
            irpStack->MinorFunction = 0UL;
            irpStack->Parameters.DeviceIoControl.OutputBufferLength = 
                sizeof(SmartcardExtension->ReaderExtension->SerialConfigData.WaitMask);
            irpStack->Parameters.DeviceIoControl.IoControlCode = 
                IOCTL_SERIAL_WAIT_ON_MASK;

            SmartcardExtension->ReaderExtension->CardStatus.Irp->AssociatedIrp.SystemBuffer = 
                &SmartcardExtension->ReaderExtension->SerialConfigData.WaitMask;

    }

    // We always call this same function when we complete a call
    IoSetCompletionRoutine(
        SmartcardExtension->ReaderExtension->CardStatus.Irp,
        Lit220SerialEventCallback,
        SmartcardExtension,
        TRUE,
        TRUE,
        TRUE
        );

    // Call the serial driver
    status = IoCallDriver(
        SmartcardExtension->ReaderExtension->ConnectedSerialPort, 
        SmartcardExtension->ReaderExtension->CardStatus.Irp
        );

    // Return STATUS_MORE_PROCESSING_REQUIRED so our IRP stays around
    return STATUS_MORE_PROCESSING_REQUIRED;
}   



VOID 
Lit220ScheduleTimer(
    IN PSMARTCARD_EXTENSION SmartcardExtension,
    IN PIO_WORKITEM_ROUTINE Routine
    )
{
        PIO_WORKITEM workItem = IoAllocateWorkItem(
            SmartcardExtension->OsData->DeviceObject
            );

        if (workItem != NULL) {

            IoQueueWorkItem(
                workItem,
                Routine,
                CriticalWorkQueue,
                workItem
                );
        } 
}


VOID 
Lit220StartTimer(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIO_WORKITEM WorkItem
    )
/*++

Routine Description:

    This routine starts the timeout timer.  The function is executed as a worker
    thread so IoStartTimer does not get called at the wrong IRQL.
--*/
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;

    PAGED_CODE();

    deviceExtension->EntryCount = 0;

    IoStartTimer(DeviceObject);

    IoFreeWorkItem(WorkItem);

}

VOID 
Lit220StopTimer(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIO_WORKITEM WorkItem
    )
/*++

Routine Description:

    This routine stops the timeout timer.  The function is executed as a worker
    thread so IoStopTimer does not get called at the wrong IRQL.
--*/
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;

    PAGED_CODE();


    IoStopTimer(DeviceObject);

    IoFreeWorkItem(WorkItem);
}



VOID
Lit220ReceiveBlockTimeout(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is timeout callback.  A timeout is setup every time we get an
    incomplete block of data.  Once we receive the complete block the timeout 
    will be canceled.  The type of timer we use for the timeout gets called 
    once every second.  We want to time out after a few seconds, so we keep track
    of how many time we get called and then timeout after we have been called 
    5 times.
--*/
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PSMARTCARD_EXTENSION smartcardExtension = &deviceExtension->SmartcardExtension;
    PREADER_EXTENSION readerExtension = smartcardExtension->ReaderExtension;

    if (readerExtension->DataByteNo == readerExtension->DataLength.l.l0) {
        // Stop the timer we got all the bytes we need
        Lit220ScheduleTimer(
            smartcardExtension,
            Lit220StopTimer
            );

        return;
    }

    if (++deviceExtension->EntryCount >= 5) {
        SmartcardDebug(
            DEBUG_ERROR, 
            ("%s!Lit220ReceiveBlockTimeout: Communication with reader timed-out\n",
            DRIVER_NAME)
            );

        // Process the timeout
        Lit220ProcessNack(smartcardExtension);
        
        // A timeout has occured schedule worker thread to 
        // stop the timer
        Lit220ScheduleTimer(
            smartcardExtension,
            Lit220StopTimer
            );

        deviceExtension->EntryCount = 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\lit220\l220pnp.c ===
/*++

   Copyright (C) Microsoft Corporation and Litronic, 1998 - 1999

Module Name:

    L220pnp.c

Abstract:

   This module contains the functions for the PnP and Power management.


Environment:

    Kernel mode only.

Notes:

Revision History:

    - Created Febuary 1998 by Brian Manahan for use with
        the 220 reader.
--*/
#include <ntddk.h>
#include "L220SCR.h"
#include <stdio.h>


// Next statement so memory for DriverEntry is released when finished
#pragma alloc_text (INIT, DriverEntry)
#pragma alloc_text(PAGEABLE, Lit220RemoveDevice)
#pragma alloc_text(PAGEABLE, Lit220StopDevice)
#pragma alloc_text(PAGEABLE, Lit220StartDevice)



#include <initguid.h>






NTSTATUS
DriverEntry(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    This routine is called at system initialization time to initialize
    this driver.

Arguments:

    DriverObject    - Supplies the driver object.
    RegistryPath    - Supplies the registry path for this driver.

Return Value:

    STATUS_SUCCESS          - We could initialize at least one device.
    STATUS_NO_SUCH_DEVICE   - We could not initialize even one device.

--*/
{
    SmartcardDebug(
        DEBUG_DRIVER,
       ("%s!DriverEntry: Enter - %s %s\n",
        DRIVER_NAME,
        __DATE__,
        __TIME__)
        );


    //
    // Initialize the Driver Object with driver's entry points
    //
    DriverObject->DriverUnload = Lit220Unload;
    DriverObject->MajorFunction[IRP_MJ_CREATE] = Lit220CreateClose;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] = Lit220CreateClose;
    DriverObject->MajorFunction[IRP_MJ_CLEANUP] = Lit220Cleanup;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = Lit220DeviceControl;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = Lit220SystemControl;

    //
    // Init PNP entries
    //
    DriverObject->DriverExtension->AddDevice = Lit220AddDevice;

    // Power functionality temporarily removed
    DriverObject->MajorFunction[IRP_MJ_PNP]  = Lit220PnP;

    // Power
    // Power functionality temporarily removed
    DriverObject->MajorFunction[IRP_MJ_POWER] = Lit220DispatchPower;

    // Always return STATUS_SUCCESS
    return STATUS_SUCCESS;
}





NTSTATUS
Lit220AddDevice(
    IN     PDRIVER_OBJECT  DriverObject,
    IN     PDEVICE_OBJECT  PhysicalDeviceObject
    )

/*++

Routine Description:

    This routine is called by the Operating System to create a new
    instance of a Litronic 220 Smartcard Reader.  Still can't touch hardware
    at this point, or submit requests to the serial driver.  But at
    least at this point we get a handle to the serial bus driver, which
    we'll use in submitting requests in the future.

Arguments:

    DriverObject - Pointer to our driver object

    PhysicalDeviceObject - Pointer to Device Object created by parent

Return Value:

    Status is returned.

--*/

{
    NTSTATUS status = STATUS_SUCCESS;
    PDEVICE_OBJECT DeviceObject = NULL;
    PSMARTCARD_EXTENSION SmartcardExtension = NULL;
    PDEVICE_EXTENSION deviceExtension = NULL;
    PREADER_EXTENSION ReaderExtension = NULL;
    static BYTE devUnitNo = 0;
    BOOLEAN smclibInitialized = FALSE;
    BOOLEAN symbolicLinkCreated = FALSE;
    BOOLEAN deviceInterfaceStateSet = FALSE;
    KIRQL oldIrql;


    SmartcardDebug(
        DEBUG_DRIVER,
        ("%s!Lit220AddDevice: enter\n",
        DRIVER_NAME)
        );

    try {

        //
        // Create our device object with a our own specific device
        // extension.
        //

        status = IoCreateDevice(
          DriverObject,
            sizeof(DEVICE_EXTENSION),
            NULL,
            FILE_DEVICE_SMARTCARD,
            0,
            TRUE,
            &DeviceObject
            );

        if (!NT_SUCCESS(status)) {

            if (status == STATUS_INSUFFICIENT_RESOURCES) {
                SmartcardLogError(
                   DriverObject,
                   LIT220_INSUFFICIENT_RESOURCES,
                   NULL,
                   0
                   );
            } else {
                SmartcardLogError(
                   DriverObject,
                   LIT220_NAME_CONFLICT,
                   NULL,
                   0
                   );
            }

            leave;
        }

        //
        // Allocate data struct space for smart card reader
        //
        SmartcardExtension = DeviceObject->DeviceExtension;
      deviceExtension = DeviceObject->DeviceExtension;

        SmartcardExtension->ReaderExtension = ExAllocatePool(
              NonPagedPool,
              sizeof(READER_EXTENSION)
              );

        if (SmartcardExtension->ReaderExtension == NULL) {

            SmartcardLogError(
               DriverObject,
               LIT220_INSUFFICIENT_RESOURCES,
               NULL,
               0
               );

            status = STATUS_INSUFFICIENT_RESOURCES;
            leave;
        }

        ReaderExtension = SmartcardExtension->ReaderExtension;

        // Zero the contents of the ReaderExtension
        RtlZeroMemory(
            SmartcardExtension->ReaderExtension,
            sizeof(READER_EXTENSION)
            );

        //
        // Attach ourself into the driver stack on top of our parent (serial).
        //
        ReaderExtension->BusDeviceObject = IoAttachDeviceToDeviceStack(
            DeviceObject,
            PhysicalDeviceObject
            );


        if (!ReaderExtension->BusDeviceObject) {
            status = STATUS_NO_SUCH_DEVICE;

            SmartcardLogError(
               DriverObject,
               LIT220_SERIAL_CONNECTION_FAILURE,
               NULL,
               0
               );

            leave;
        }

        // Set flag so if something fails we know to disable the interface
        deviceInterfaceStateSet = TRUE;


        //
        // Initialize Smartcard Library
        //
        //
        // Write the version of the lib we use to the smartcard extension
        //
        SmartcardExtension->Version = SMCLIB_VERSION;

        SmartcardExtension->SmartcardReply.BufferSize =
            MIN_BUFFER_SIZE;

        SmartcardExtension->SmartcardRequest.BufferSize =
            MIN_BUFFER_SIZE;

        //
        // Now let the lib allocate the buffer for data transmission
        // We can either tell the lib how big the buffer should be
        // by assigning a value to BufferSize or let the lib
        // allocate the default size
        //
        status = SmartcardInitialize(
            SmartcardExtension
            );

        if (status != STATUS_SUCCESS) {
            SmartcardLogError(
               DriverObject,
               LIT220_SMARTCARD_LIB_ERROR,
               NULL,
               0
               );
            leave;
        }

        // Set flag so if something fails we know to exit out of the
        // smartcard library
        smclibInitialized = TRUE;

        status = IoInitializeTimer(
           DeviceObject,
           Lit220ReceiveBlockTimeout,
           NULL
           );

        if (status != STATUS_SUCCESS) {

            SmartcardLogError(
               DriverObject,
               LIT220_INSUFFICIENT_RESOURCES,
               NULL,
               0
               );

            status = STATUS_INSUFFICIENT_RESOURCES;
            leave;
        }

        deviceExtension->WorkItem = NULL;
        deviceExtension->WorkItem = IoAllocateWorkItem(
          DeviceObject
          );
        if (deviceExtension->WorkItem == NULL) {

            SmartcardLogError(
               DriverObject,
               LIT220_INSUFFICIENT_RESOURCES,
               NULL,
               0
               );

            status = STATUS_INSUFFICIENT_RESOURCES;
            leave;
        }


        // register our new device
        status = IoRegisterDeviceInterface(
            PhysicalDeviceObject,
            &SmartCardReaderGuid,
            NULL,
            &deviceExtension->PnPDeviceName
            );
        ASSERT(status == STATUS_SUCCESS);

        SmartcardDebug(
            DEBUG_DRIVER,
            ("%s!Lit220AddDevice: DevName - %ws\n",
            DRIVER_NAME, deviceExtension->PnPDeviceName.Buffer)
            );


      //
      // Initialize some events
      //
      KeInitializeEvent(&ReaderExtension->AckEvnt,
         NotificationEvent,
         FALSE);
      KeInitializeEvent(&ReaderExtension->DataEvnt,
         NotificationEvent,
         FALSE);

      KeInitializeEvent(
         &deviceExtension->SerialCloseDone,
         NotificationEvent,
         TRUE
         );

      // Used for stop / start notification
      KeInitializeEvent(
         &deviceExtension->ReaderStarted,
         NotificationEvent,
         FALSE
         );

      // Used to keep track of open close calls
      deviceExtension->ReaderOpen = FALSE;

    } finally {
        if (status != STATUS_SUCCESS) {
         Lit220RemoveDevice(DeviceObject);
        }
    }

    if (status != STATUS_SUCCESS) {
        return (status);
    }


    //
    // Set up call back functions for smartcard library
    //
    SmartcardExtension->ReaderFunction[RDF_TRANSMIT] =
        Lit220IoRequest;
    SmartcardExtension->ReaderFunction[RDF_SET_PROTOCOL] =
        Lit220SetProtocol;
    SmartcardExtension->ReaderFunction[RDF_CARD_POWER] =
        Lit220Power;
    SmartcardExtension->ReaderFunction[RDF_CARD_TRACKING] =
        Lit220CardTracking;

    //
    // Save deviceObject
    //
    KeAcquireSpinLock(
        &SmartcardExtension->OsData->SpinLock,
        &oldIrql
        );

    SmartcardExtension->OsData->DeviceObject =
        DeviceObject;

    //
    // Set the Current and Notification IRPs to NULL
    //
    SmartcardExtension->OsData->CurrentIrp = NULL;
    SmartcardExtension->OsData->NotificationIrp = NULL;

    KeReleaseSpinLock(
        &SmartcardExtension->OsData->SpinLock,
        oldIrql
        );

    //
    // Save the deviceObject for the connected serial port
    //
    SmartcardExtension->ReaderExtension->ConnectedSerialPort =
        PhysicalDeviceObject;


    //
    // Set the vendor info
    //
    strcpy(
        SmartcardExtension->VendorAttr.VendorName.Buffer,
        LIT220_VENDOR_NAME);

    SmartcardExtension->VendorAttr.VendorName.Length =
        (USHORT) strlen(SmartcardExtension->VendorAttr.VendorName.Buffer);

    SmartcardExtension->VendorAttr.UnitNo = devUnitNo++;

    strcpy(
        SmartcardExtension->VendorAttr.IfdType.Buffer,
        LIT220_PRODUCT_NAME);

    SmartcardExtension->VendorAttr.IfdType.Length =
        (USHORT) strlen(SmartcardExtension->VendorAttr.IfdType.Buffer);


    //
    // Clk frequency in KHz encoded as little endian integer
    //
    SmartcardExtension->ReaderCapabilities.CLKFrequency.Default = 3571;
    SmartcardExtension->ReaderCapabilities.CLKFrequency.Max = 3571;

    SmartcardExtension->ReaderCapabilities.DataRate.Default = 9600;
    SmartcardExtension->ReaderCapabilities.DataRate.Max = 115200;

    SmartcardExtension->ReaderCapabilities.MaxIFSD = MAX_IFSD;

    SmartcardExtension->ReaderCapabilities.SupportedProtocols =
        SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1;

    // Save a copy to the PhysicalDeviceObject
    ReaderExtension->PhysicalDeviceObject = PhysicalDeviceObject;

    // Set initial state for SerialEventState
    SmartcardExtension->ReaderExtension->SerialEventState = 0;

    // Device is connected
    SmartcardExtension->ReaderExtension->DeviceRemoved = FALSE;

    // Assume reader is attached until we ask the serial driver
    SmartcardExtension->ReaderExtension->ModemStatus = SERIAL_DSR_STATE;

   // Set initial power state
    deviceExtension->PowerState = PowerDeviceD0;

    // save the current power state of the reader
    SmartcardExtension->ReaderExtension->ReaderPowerState =
        PowerReaderWorking;

    // Clear the DO_DEVICE_INITIALIZING bit
    DeviceObject->Flags |= DO_BUFFERED_IO;
   DeviceObject->Flags |= DO_POWER_PAGABLE;
    DeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    return status;
}



VOID
Lit220CloseSerialPort(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine closes the connection to the serial driver when the
    reader has been removed (unplugged).  This routine runs as a system
    thread at IRQL == PASSIVE_LEVEL.
    It waits for a DeviceClose event sent by another part of the driver to
    indicate that the serial connection should be close.
    If the notification IRP is still pending we complete it.
    Once the connection is closed it will signal the SerialCloseDone event so the
    PnP Remove IRP knows when it is safe to unload the device.
*/
{
    PSMARTCARD_EXTENSION SmartcardExtension = DeviceObject->DeviceExtension;
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PREADER_EXTENSION ReaderExtension = SmartcardExtension->ReaderExtension;
    NTSTATUS status;
    PIRP irp;
    PIO_STACK_LOCATION irpStack;
    IO_STATUS_BLOCK ioStatusBlock;
    KIRQL oldIrql;

    //
    // first mark this device as 'gone'.
    // This will prevent that someone can re-open the device
    //
    // We intentionally ignore error here for the case we are disabling an interface
    // that is already disabled.
    //
    IoSetDeviceInterfaceState(
        &deviceExtension->PnPDeviceName,
        FALSE
        );

    // Mark the device as removed so no more IRPs will be sent to the
    // serial port
    ReaderExtension->DeviceRemoved = TRUE;

    SmartcardDebug(
        DEBUG_DRIVER,
        ("%s!Lit220CloseSerialPort: Got Close signal.  Checking if we can remove device now.\n",
        DRIVER_NAME)
        );

    //
    // Cancel the Notification IRP if it is around
    //
    Lit220CompleteCardTracking(SmartcardExtension);


    SmartcardDebug(
        DEBUG_DRIVER,
        ("%s!Lit220CloseSerialPort: Sending IRP_MJ_CLOSE\n",
        DRIVER_NAME)
        );

    //
    // Create an IRP for closing the serial driver
    //
    irp = IoAllocateIrp(
        (CCHAR)(DeviceObject->StackSize + 1),
        FALSE
        );

    ASSERT(irp != NULL);

    if (irp) {

        //
        // Send a close to the serial driver.  The serial enumerator
        // will receive this and start tracking again.  This will
        // eventually trigger a device removal.
        //
        IoSetNextIrpStackLocation(irp);
        irp->UserIosb = &ioStatusBlock;
        irpStack = IoGetCurrentIrpStackLocation(irp);
        irpStack->MajorFunction = IRP_MJ_CLOSE;

        status = Lit220CallSerialDriver(
            ReaderExtension->BusDeviceObject,
            irp
            );

        ASSERT(status == STATUS_SUCCESS);

        IoFreeIrp(irp);
    } else {

        SmartcardDebug(
            DEBUG_ERROR,
            ("%s!Lit220CloseSerialPort: Could not allocate IRP for close!\n",
            DRIVER_NAME)
            );
    }

    // Inform the remove function that the call is complete
    KeSetEvent(
        &deviceExtension->SerialCloseDone,
        0,
        FALSE
        );

}




NTSTATUS
Lit220SerialCallComplete(
                         IN PDEVICE_OBJECT DeviceObject,
                         IN PIRP Irp,
                         IN PKEVENT Event)
/*++

Routine Description:

    Completion routine for an Irp sent to the serial driver.
    It sets only an event that we can use to wait for.

--*/
{
    UNREFERENCED_PARAMETER (DeviceObject);

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!Lit220SerialCallComplete: enter\n",
        DRIVER_NAME)
        );

    if (Irp->Cancel) {
        Irp->IoStatus.Status = STATUS_CANCELLED;
    }

    KeSetEvent(Event, 0, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
Lit220CallSerialDriver(
                         IN PDEVICE_OBJECT DeviceObject,
                         IN PIRP Irp)
/*++

Routine Description:

    Sends an Irp to the serial driver.

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    KEVENT Event;

    // Copy out stack location to the next
    IoCopyCurrentIrpStackLocationToNext(Irp);

    // Initializate event for process synchronication.
    KeInitializeEvent(
        &Event,
        NotificationEvent,
        FALSE
        );

    // Set the completion routine
    IoSetCompletionRoutine(
        Irp,
        Lit220SerialCallComplete,
        &Event,
        TRUE,
        TRUE,
        TRUE
        );

    // Call the serial driver
    status = IoCallDriver(
        DeviceObject,
        Irp
        );

    // Wait for it to complete
    if (status == STATUS_PENDING) {
        status = KeWaitForSingleObject(
            &Event,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );

        ASSERT(STATUS_SUCCESS == status);

        status = Irp->IoStatus.Status;
    }

    return status;
}




NTSTATUS
Lit220PnP(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine will receive the various Plug N Play messages.  It is
    here that we start our device, stop it, etc.  Safe to submit requests
    to the serial bus driver.

Arguments:

    DeviceObject - Pointer to class device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/

{
    KEVENT Event;
    NTSTATUS status;
    PIO_STACK_LOCATION IrpStack;
    PSMARTCARD_EXTENSION SmartcardExtension = DeviceObject->DeviceExtension;
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PREADER_EXTENSION ReaderExtension = SmartcardExtension->ReaderExtension;
   PDEVICE_OBJECT busDeviceObject = ReaderExtension->BusDeviceObject;
    PIRP pIrp = NULL;
    IO_STATUS_BLOCK     ioStatusBlock;
    LARGE_INTEGER Interval;
    PIRP createIrp = NULL;
    HANDLE handle;
    PIO_STACK_LOCATION NextIrpStack;
    PIRP irp;
    BOOLEAN deviceRemoved = FALSE;
    KIRQL irql;


    status = SmartcardAcquireRemoveLockWithTag(
      SmartcardExtension,
      'PnP'
      );
    ASSERT(status == STATUS_SUCCESS);

    if (status != STATUS_SUCCESS) {

        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    //
    // pull the minor code out of our Irp Stack so we know what
    // PnP function we're supposed to do
    //
    IrpStack = IoGetCurrentIrpStackLocation(Irp);

    ASSERT(IrpStack);

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!Lit220PnP: Enter - MinorFunction %X\n",
        DRIVER_NAME,
        IrpStack->MinorFunction)
        );

    switch (IrpStack->MinorFunction) {

        PDEVICE_OBJECT BusDeviceObject = ReaderExtension->BusDeviceObject;


        case IRP_MN_START_DEVICE:

            SmartcardDebug(
                DEBUG_DRIVER,
                ("%s!Lit220PnP: MN_START_DEVICE\n",
                DRIVER_NAME)
                );

            //
            // Before we start initializing our device, we must
            // call to the layer below us first.
            //
            IoCopyCurrentIrpStackLocationToNext (Irp);

            KeInitializeEvent(
                &Event,
                SynchronizationEvent,
                FALSE
                );

            IoSetCompletionRoutine(
                Irp,
                Lit220SynchCompletionRoutine,
               &Event,
                TRUE,
                TRUE,
                TRUE
                );

            //
            // Call down to the serial bus driver.
            //
            status = IoCallDriver(
                        ReaderExtension->BusDeviceObject,
                        Irp
                        );

            if (status == STATUS_PENDING) {

                //
                // Still pending, wait for the IRP to complete
                //

                status = KeWaitForSingleObject(
                   &Event,
                    Executive,
                    KernelMode,
                    FALSE,
                    NULL
                    );

            }

         if (NT_SUCCESS(status)) {

            status = Lit220StartDevice(SmartcardExtension);

         } else {

                SmartcardLogError(
                   SmartcardExtension->OsData->DeviceObject,
                   LIT220_SERIAL_CONNECTION_FAILURE,
                   NULL,
                   0
                   );
         }

         //
         // Complete the IRP first otherwise if we failed we may remove
         // the driver before we have a chance to complete this IRP.
         // Causing a system crash.
         //

            Irp->IoStatus.Status = status;
            Irp->IoStatus.Information = 0;

            IoCompleteRequest(Irp, IO_NO_INCREMENT);


            break;

        case IRP_MN_QUERY_STOP_DEVICE:

            SmartcardDebug(
                DEBUG_DRIVER,
                ("%s!Lit220PnP: IRP_MN_QUERY_STOP_DEVICE\n",
                DRIVER_NAME)
                );

            KeAcquireSpinLock(&deviceExtension->SpinLock, &irql);
            if ((deviceExtension->IoCount > 0) /* ***&& (!ReaderExtension->DeviceRemoved)*/) {

                // we refuse to stop if we have pending io
                KeReleaseSpinLock(&deviceExtension->SpinLock, irql);
                status = STATUS_DEVICE_BUSY;

            } else {

                // stop processing requests
                KeClearEvent(&deviceExtension->ReaderStarted);
                KeReleaseSpinLock(&deviceExtension->SpinLock, irql);
                IoCopyCurrentIrpStackLocationToNext (Irp);
                status = IoCallDriver(ReaderExtension->BusDeviceObject, Irp);
            }


            break;

        case IRP_MN_CANCEL_STOP_DEVICE:

            SmartcardDebug(
                DEBUG_DRIVER,
                ("%s!Lit220PnP: IRP_MN_CANCEL_STOP_DEVICE\n",
                DRIVER_NAME)
                );

            IoCopyCurrentIrpStackLocationToNext (Irp);
            status = IoCallDriver(ReaderExtension->BusDeviceObject, Irp);

            if (status == STATUS_SUCCESS) {

                // we can continue to process requests
                KeSetEvent(&deviceExtension->ReaderStarted, 0, FALSE);
            }

            break;

        case IRP_MN_STOP_DEVICE:

            //
            // Do whatever you need to do to shutdown the device.
            //

            SmartcardDebug(
                DEBUG_DRIVER,
                ("%s!Lit220PnP: MN_STOP_DEVICE\n",
                DRIVER_NAME)
                );

         Lit220StopDevice(SmartcardExtension);

            //
            // Send the stop IRP down
            //
            IoCopyCurrentIrpStackLocationToNext (Irp);

            status = (IoCallDriver(
                ReaderExtension->BusDeviceObject,
                Irp)
                );
            break;


        case IRP_MN_QUERY_REMOVE_DEVICE:

            // now look if someone is currently connected to us
            if (deviceExtension->ReaderOpen) {

                //
                // someone is connected, fail the call
                // we will enable the device interface in
                // IRP_MN_CANCEL_REMOVE_DEVICE again
                //
                status = STATUS_UNSUCCESSFUL;
                Irp->IoStatus.Status = status;
                Irp->IoStatus.Information = 0;
                IoCompleteRequest (
                    Irp,
                    IO_NO_INCREMENT
                    );
                
                break;
            }

            // disable the reader
            status = IoSetDeviceInterfaceState(
                &deviceExtension->PnPDeviceName,
                FALSE
                );


            // Send the call down the DevNode
            IoCopyCurrentIrpStackLocationToNext (Irp);

            status = IoCallDriver(
                ReaderExtension->BusDeviceObject,
                Irp
                );

            break;

        case IRP_MN_CANCEL_REMOVE_DEVICE:
            //
            // Send call down to serial driver - we need
            // to process this call on the way up the devNode
            //

            IoCopyCurrentIrpStackLocationToNext (Irp);

            //
            // Initialize the event
            //
            KeInitializeEvent(
                &Event,
                SynchronizationEvent,
                FALSE
                );

            IoSetCompletionRoutine (
                Irp,
                Lit220SynchCompletionRoutine,
                &Event,
                TRUE,
                TRUE,
                TRUE
                );

            status = IoCallDriver (
                ReaderExtension->BusDeviceObject,
                Irp
                );

            if (STATUS_PENDING == status) {
                KeWaitForSingleObject(
                    &Event,
                    Executive, // Waiting for reason of a driver
                    KernelMode, // Waiting in kernel mode
                    FALSE, // No allert
                    NULL    // No timeout
                    );

                status = Irp->IoStatus.Status;
            }


         // Re-enable the device interface
         if ((status == STATUS_SUCCESS) &&
            (ReaderExtension->SerialConfigData.WaitMask != 0))
         {

            status = IoSetDeviceInterfaceState(
               &deviceExtension->PnPDeviceName,
               TRUE
               );

                ASSERT(NT_SUCCESS(status));
         }


            //
            // We must now complete the IRP, since we stopped it in the
            // completetion routine with MORE_PROCESSING_REQUIRED.
            //
            Irp->IoStatus.Status = status;
            Irp->IoStatus.Information = 0;
            IoCompleteRequest (
                Irp,
                IO_NO_INCREMENT
                );

            break;

        case IRP_MN_REMOVE_DEVICE:

            SmartcardDebug(
                DEBUG_DRIVER,
                ("%s!Lit220PnP: MN_REMOVE_DEVICE\n",
                DRIVER_NAME)
                );
         // Wait until we can safely unload the device
         SmartcardReleaseRemoveLockAndWait(SmartcardExtension);

         Lit220RemoveDevice(DeviceObject);

         // Mark the device as removed
         deviceRemoved = TRUE;

            //
            // Send on the remove IRP.
            // We need to send the remove down the stack before we detach,
            // but we don't need to wait for the completion of this operation
            // (and to register a completion routine).
            //

            IoCopyCurrentIrpStackLocationToNext (Irp);

            status = IoCallDriver(
                busDeviceObject,
                Irp
                );

            break;


        default:

            IoCopyCurrentIrpStackLocationToNext (Irp);

            status = IoCallDriver(
                ReaderExtension->BusDeviceObject,
                Irp
                );
            break;

    }

    if (deviceRemoved == FALSE) {

        SmartcardReleaseRemoveLockWithTag(
         SmartcardExtension,
         'PnP'
         );
    }

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!Lit220PnP: Exit %X\n",
        DRIVER_NAME,
        status)
        );

    return status;

}



NTSTATUS
Lit220StartDevice(
   IN PSMARTCARD_EXTENSION SmartcardExtension
    )
{
    PDEVICE_OBJECT deviceObject = SmartcardExtension->OsData->DeviceObject;
    PDEVICE_EXTENSION deviceExtension = deviceObject->DeviceExtension;
    PREADER_EXTENSION readerExtension = SmartcardExtension->ReaderExtension;
    NTSTATUS status;
    KEVENT Event;
    PIRP irp;
    IO_STATUS_BLOCK     ioStatusBlock;
    PIO_STACK_LOCATION IrpStack;

    PAGED_CODE();


    try {

        //
        // Send a create IRP to the serial driver
        //
        KeInitializeEvent(
            &Event,
            NotificationEvent,
            FALSE
            );

        //
        // Create an IRP for opening the serial driver
        //
        irp = IoAllocateIrp(
            (CCHAR)(deviceObject->StackSize + 1),
            FALSE
            );

        ASSERT(irp != NULL);

        if (irp == NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;

            SmartcardLogError(
               SmartcardExtension->OsData->DeviceObject,
               LIT220_INSUFFICIENT_RESOURCES,
               NULL,
               0
               );

            leave;
        }

      //
      // Open the underlying serial driver.
      // This is necessary for two reasons:
      // a) The serial driver can't be used without opening it
      // b) The call will go through serenum first which informs
      //    it to stop looking/polling for new devices.
      //
        IoSetNextIrpStackLocation(irp);
        irp->UserIosb = &ioStatusBlock;
        IrpStack = IoGetCurrentIrpStackLocation(irp);
        IrpStack->MajorFunction = IRP_MJ_CREATE;
        IrpStack->MinorFunction = 0UL;
        IrpStack->Parameters.Create.Options = 0;
        IrpStack->Parameters.Create.ShareAccess = 0;
        IrpStack->Parameters.Create.FileAttributes = 0;
        IrpStack->Parameters.Create.EaLength = 0;

        status = Lit220CallSerialDriver(
            readerExtension->BusDeviceObject,
            irp
            );

        ASSERT(status == STATUS_SUCCESS);

        IoFreeIrp(irp);


        if (status != STATUS_SUCCESS) {
            SmartcardDebug(
                DEBUG_ERROR,
                ("%s!Lit220PNP: CreateIRP failed %X\n",
                DRIVER_NAME,
                status)
                );

         if (status == STATUS_SHARED_IRQ_BUSY) {
            SmartcardLogError(
               SmartcardExtension->OsData->DeviceObject,
               LIT220_SERIAL_SHARE_IRQ_CONFLICT,
               NULL,
               0
               );
         } else {
            SmartcardLogError(
               SmartcardExtension->OsData->DeviceObject,
               LIT220_SERIAL_CONNECTION_FAILURE,
               NULL,
               0
               );
         }
            leave;
        }

        KeClearEvent(&deviceExtension->SerialCloseDone);

        //
        // Configure the reader
        //
        SmartcardDebug(
            DEBUG_DRIVER,
            ("%s!Lit220PnP: Now doing Lit220Initialize - SmartcardExt %X\n",
            DRIVER_NAME,
            SmartcardExtension)
            );

        ASSERT(SmartcardExtension != NULL);

        status = Lit220Initialize(SmartcardExtension);

        if (status != STATUS_SUCCESS) {

            // The function fails in Lit220Initialize will log
            // the appropriate error.  So we don't need to do that
            // here

            SmartcardDebug(
                DEBUG_ERROR,
                ("%s!Lit220PNP: Lit220Initialize failed %X\n",
                DRIVER_NAME,
                status)
                );

            SmartcardLogError(
               SmartcardExtension->OsData->DeviceObject,
               LIT220_INITIALIZATION_FAILURE,
               NULL,
               0
               );

            leave;
        }

      // Enable the interface for the device
      status = IoSetDeviceInterfaceState(
         &deviceExtension->PnPDeviceName,
         TRUE
         );

      if (!NT_SUCCESS(status)) {

            SmartcardLogError(
               SmartcardExtension->OsData->DeviceObject,
               LIT220_SERIAL_CONNECTION_FAILURE,
               NULL,
               0
               );

         leave;
      }

        KeSetEvent(&deviceExtension->ReaderStarted, 0, FALSE);

    }

    finally {

        if (status != STATUS_SUCCESS) {

         Lit220StopDevice(SmartcardExtension);

        }

    }

   return status;

}


VOID
Lit220StopDevice(
   IN PSMARTCARD_EXTENSION SmartcardExtension
    )
/*++

Routine Description:

    This routine handles stopping the device.  It closes
   connection to serial port and stops the input filter
   if it has been activated.

Arguments:

    SmartcardExtension - pointer to the smart card data struct.

Return Value:

    NTSTATUS

--*/
{
    PDEVICE_OBJECT deviceObject = SmartcardExtension->OsData->DeviceObject;
    PDEVICE_EXTENSION deviceExtension = deviceObject->DeviceExtension;
    PREADER_EXTENSION readerExtension = SmartcardExtension->ReaderExtension;
    NTSTATUS status;

    PAGED_CODE();

    if (KeReadStateEvent(&deviceExtension->SerialCloseDone) == 0l) {

        // test if we ever started event tracking
        if (SmartcardExtension->ReaderExtension->SerialConfigData.WaitMask == 0) {

            // no, we did not
            // We 'only' need to close the serial port
            Lit220CloseSerialPort(deviceObject, NULL);

        } else {
            PUCHAR requestBuffer;

            //
            // Stop the wait for character input and DSR changes.
            // When this happens it will signal the our waitforclose
            // thread to close the connection to the serial driver (if
            // it is not already closed).
            //
            readerExtension->SerialConfigData.WaitMask = 0;

            // save the pointer
            requestBuffer = SmartcardExtension->SmartcardRequest.Buffer;


            // Stop the event requests
            *(PULONG) SmartcardExtension->SmartcardRequest.Buffer =
                readerExtension->SerialConfigData.WaitMask;

            SmartcardExtension->SmartcardRequest.BufferLength =
                sizeof(ULONG);

            readerExtension->SerialIoControlCode =
                IOCTL_SERIAL_SET_WAIT_MASK;

            // No bytes expected back
            SmartcardExtension->SmartcardReply.BufferLength = 0;

            status = Lit220SerialIo(SmartcardExtension);
            ASSERT(status == STATUS_SUCCESS);

            // Restore the pointer
            SmartcardExtension->SmartcardRequest.Buffer = requestBuffer;

            // Wait for the close thread to complete
            KeWaitForSingleObject(
               &deviceExtension->SerialCloseDone,
                Executive,
                KernelMode,
                FALSE,
                NULL
                );

        }
    }

}


VOID
Lit220RemoveDevice(
   IN PDEVICE_OBJECT DeviceObject
    )
{
    PDEVICE_EXTENSION deviceExtension;
    PSMARTCARD_EXTENSION smartcardExtension;
    NTSTATUS status;

    PAGED_CODE();

    if (DeviceObject == NULL) {

        return;
    }

    deviceExtension = DeviceObject->DeviceExtension;
    smartcardExtension = &deviceExtension->SmartcardExtension;

   SmartcardDebug(
      DEBUG_TRACE,
      ( "%s!Lit220RemoveDevice: Enter\n",
        DRIVER_NAME)
      );

   // We need to stop the device before we can remove it.
   Lit220StopDevice(smartcardExtension);

/*  Superfluous -- Remove later
   // now wait until our device has been closed
   status = KeWaitForSingleObject(
      &deviceExtension->ReaderClosed,
      Executive,
      KernelMode,
      FALSE,
      NULL
      );

   ASSERT(status == STATUS_SUCCESS);
*/

   //
   // Clean ourself out of the driver stack layer
   //
    if (deviceExtension->SmartcardExtension.ReaderExtension &&
        deviceExtension->SmartcardExtension.ReaderExtension->BusDeviceObject) {

        IoDetachDevice(
            deviceExtension->SmartcardExtension.ReaderExtension->BusDeviceObject
            );
    }

   // Free PnPDeviceName
   if(deviceExtension->PnPDeviceName.Buffer != NULL) {

      RtlFreeUnicodeString(&deviceExtension->PnPDeviceName);
   }

   //
   // Let the lib free the send/receive buffers
   //
   if(smartcardExtension->OsData != NULL) {

      SmartcardExit(smartcardExtension);
   }


   // Free reader extension
    if (smartcardExtension->ReaderExtension != NULL) {

        ExFreePool(smartcardExtension->ReaderExtension);
    }



   // Free the work item
   if (deviceExtension->WorkItem != NULL) {
      IoFreeWorkItem(deviceExtension->WorkItem);
      deviceExtension->WorkItem = NULL;
   }


   // Delete the device object
   IoDeleteDevice(DeviceObject);
}



NTSTATUS
Lit220SynchCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT Event
    )

/*++

Routine Description:

    This routine is for use with synchronous IRP processing.
    All it does is signal an event, so the driver knows it
    can continue.

Arguments:

    DriverObject - Pointer to driver object created by system.

    Irp - Irp that just completed

    Event - Event we'll signal to say Irp is done

Return Value:

    None.

--*/

{
    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!Lit220SynchCompletionRoutine: Enter\n",
        DRIVER_NAME)
        );

    KeSetEvent(
        (PKEVENT) Event,
        0,
        FALSE
        );
    return (STATUS_MORE_PROCESSING_REQUIRED);
}



VOID
Lit220SystemPowerCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PIRP Irp,
    IN PIO_STATUS_BLOCK IoStatus
    )
/*++

Routine Description:
    This function is called when the underlying stacks
    completed the power transition.

--*/
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PSMARTCARD_EXTENSION smartcardExtension = &deviceExtension->SmartcardExtension;

    UNREFERENCED_PARAMETER (MinorFunction);

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = IoStatus->Status;

    SmartcardReleaseRemoveLockWithTag(
      smartcardExtension,
      'rwoP'
      );

    if (PowerState.SystemState == PowerSystemWorking) {

        PoSetPowerState (
            DeviceObject,
            SystemPowerState,
            PowerState
            );
    }
                          
    PoStartNextPowerIrp(Irp);
    IoSkipCurrentIrpStackLocation(Irp);
    PoCallDriver(smartcardExtension->ReaderExtension->BusDeviceObject, Irp);

   // IoCompleteRequest(Irp, IO_NO_INCREMENT);
}



NTSTATUS
Lit220DevicePowerCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PSMARTCARD_EXTENSION SmartcardExtension
    )
/*++

Routine Description:
    This routine is called after the underlying stack powered
    UP the serial port, so it can be used again.

--*/
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS status;
    ULONG state;
    KIRQL irql;

    ASSERT(irpStack != NULL);
    
    if(Irp->PendingReturned) {
       IoMarkIrpPending(Irp);
    }

    state = Lit220IsCardPresent(SmartcardExtension) ? SCARD_PRESENT : SCARD_ABSENT;
    //
    // Check if the card is inserted
    //
    
    KeAcquireSpinLock(&SmartcardExtension->OsData->SpinLock,
                      &irql);
    SmartcardExtension->ReaderCapabilities.CurrentState = state;
        
    //
    // If a card was present before power down or now there is
    // a card in the reader, we complete any pending card monitor
    // request, since we do not really know what card is now in the
    // reader.
    //
    if(SmartcardExtension->ReaderExtension->CardPresent ||
       SmartcardExtension->ReaderCapabilities.CurrentState > SCARD_ABSENT) {

        state = SmartcardExtension->ReaderCapabilities.CurrentState & SCARD_PRESENT;
        //
        // Issue a power request in order to reset the card's status
        //
        if (SmartcardExtension->ReaderCapabilities.CurrentState == SCARD_PRESENT) {
            SmartcardExtension->MinorIoControlCode = SCARD_COLD_RESET;
            KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                              irql);

            status = Lit220Power(SmartcardExtension);
            ASSERT(status == STATUS_SUCCESS);  
        } else {
            KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                              irql);
        }
        
        Lit220NotifyCardChange(
         SmartcardExtension,
         state
         );
    } else {
        KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock,
                                      irql);
    }

    // save the current power state of the reader
    SmartcardExtension->ReaderExtension->ReaderPowerState =
        PowerReaderWorking;

    SmartcardReleaseRemoveLockWithTag(
      SmartcardExtension,
      'rwoP'
      );

    // inform the power manager of our state.
    PoSetPowerState (
        DeviceObject,
        DevicePowerState,
        irpStack->Parameters.Power.State
        );

    PoStartNextPowerIrp(Irp);

    // signal that we can process ioctls again
    KeSetEvent(&deviceExtension->ReaderStarted, 0, FALSE);

    return STATUS_SUCCESS;
}

typedef enum _ACTION {

    Undefined = 0,
    SkipRequest,
    WaitForCompletion,
    CompleteRequest,
    MarkPending

} ACTION;

NTSTATUS
Lit220DispatchPower (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:
    The power dispatch routine.
    All we care about is the transition from a low D state to D0.

Arguments:
   DeviceObject - pointer to a device object.
   Irp - pointer to an I/O Request Packet.

Return Value:
      NT status code

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PSMARTCARD_EXTENSION smartcardExtension = &deviceExtension->SmartcardExtension;
    PDEVICE_OBJECT AttachedDeviceObject;
    POWER_STATE powerState;
    ACTION action = SkipRequest;
    KIRQL irql;

    SmartcardDebug(
        DEBUG_DRIVER,
        ("%s!Lit220DispatchPower: Enter\n",
        DRIVER_NAME)
        );

    status = SmartcardAcquireRemoveLockWithTag(
      smartcardExtension,
      'rwoP'
      );

    ASSERT(status == STATUS_SUCCESS);

    if (!NT_SUCCESS(status)) {

        PoStartNextPowerIrp(Irp);
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    AttachedDeviceObject = smartcardExtension->ReaderExtension->BusDeviceObject;

   switch (irpStack->Parameters.Power.Type) {
   case DevicePowerState:
      if (irpStack->MinorFunction == IRP_MN_SET_POWER) {

         switch (irpStack->Parameters.Power.State.DeviceState) {

         case PowerDeviceD0:
            // Turn on the reader
            SmartcardDebug(
                          DEBUG_DRIVER,
                          ("%s!Lit220DispatchPower: PowerDevice D0\n",
                           DRIVER_NAME)
                          );

            //
            // First, we send down the request to the bus, in order
            // to power on the port. When the request completes,
            // we turn on the reader
            //
            IoCopyCurrentIrpStackLocationToNext(Irp);
            IoSetCompletionRoutine (
                                   Irp,
                                   Lit220DevicePowerCompletion,
                                   smartcardExtension,
                                   TRUE,
                                   TRUE,
                                   TRUE
                                   );

            action = WaitForCompletion;
            break;

         case PowerDeviceD3:
            // Turn off the reader
            SmartcardDebug(
                          DEBUG_DRIVER,
                          ("%s!Lit220DispatchPower: PowerDevice D3\n",
                           DRIVER_NAME)
                          );

            PoSetPowerState (
                            DeviceObject,
                            DevicePowerState,
                            irpStack->Parameters.Power.State
                            );

            // save the current card state
            KeAcquireSpinLock(&smartcardExtension->OsData->SpinLock,
                              &irql);
            smartcardExtension->ReaderExtension->CardPresent =
            smartcardExtension->ReaderCapabilities.CurrentState > SCARD_ABSENT;
            KeReleaseSpinLock(&smartcardExtension->OsData->SpinLock,
                              irql);

            if (smartcardExtension->ReaderExtension->CardPresent) {

               smartcardExtension->MinorIoControlCode = SCARD_POWER_DOWN;
               status = Lit220Power(smartcardExtension);
               ASSERT(status == STATUS_SUCCESS);
            }

            //
            // If there is a pending card tracking request, setting
            // this flag will prevent completion of the request
            // when the system will be waked up again.
            //
            smartcardExtension->ReaderExtension->PowerRequest = TRUE;

            // save the current power state of the reader
            smartcardExtension->ReaderExtension->ReaderPowerState =
            PowerReaderOff;

            action = SkipRequest;
            break;

         default:
            ASSERT(FALSE);
            action = SkipRequest;
            break;
         }
      } else {
         ASSERT(FALSE);
         action = SkipRequest;
         break;
      }
      break;

   case SystemPowerState: {

         //
         // The system wants to change the power state.
         // We need to translate the system power state to
         // a corresponding device power state.
         //

         POWER_STATE_TYPE powerType = DevicePowerState;

         ASSERT(smartcardExtension->ReaderExtension->ReaderPowerState !=
                PowerReaderUnspecified);

         switch (irpStack->MinorFunction) {

         case IRP_MN_QUERY_POWER:

            SmartcardDebug(
                          DEBUG_DRIVER,
                          ("%s!Lit220DispatchPower: Query Power\n",
                           DRIVER_NAME)
                          );

            //
            // By default we succeed and pass down
            //

            action = SkipRequest;
            Irp->IoStatus.Status = STATUS_SUCCESS;

            switch (irpStack->Parameters.Power.State.SystemState) {

            case PowerSystemMaximum:
            case PowerSystemWorking:
            case PowerSystemSleeping1:
            case PowerSystemSleeping2:
               break;

            case PowerSystemSleeping3:
            case PowerSystemHibernate:
            case PowerSystemShutdown:
               KeAcquireSpinLock(&deviceExtension->SpinLock, &irql);
               if (deviceExtension->IoCount == 0) {

                  // Block any further ioctls
                  KeClearEvent(&deviceExtension->ReaderStarted);

               } else {

                  // can't go to sleep mode since the reader is busy.
                  status = STATUS_DEVICE_BUSY;
                  action = CompleteRequest;
               }
               KeReleaseSpinLock(&deviceExtension->SpinLock, irql);
               break;
            }
            break;

         case IRP_MN_SET_POWER:

            SmartcardDebug(
                          DEBUG_DRIVER,
                          ("%s!Lit220DispatchPower: PowerSystem S%d\n",
                           DRIVER_NAME,
                           irpStack->Parameters.Power.State.SystemState - 1)
                          );

            switch (irpStack->Parameters.Power.State.SystemState) {

            case PowerSystemMaximum:
            case PowerSystemWorking:
            case PowerSystemSleeping1:
            case PowerSystemSleeping2:

               if (smartcardExtension->ReaderExtension->ReaderPowerState ==
                   PowerReaderWorking) {

                  // We're already in the right state
                  KeSetEvent(&deviceExtension->ReaderStarted, 0, FALSE);
                  action = SkipRequest;
                  break;
               }

               // wake up the underlying stack...
               powerState.DeviceState = PowerDeviceD0;
               action = MarkPending;
               break;

            case PowerSystemSleeping3:
            case PowerSystemHibernate:
            case PowerSystemShutdown:

               if (smartcardExtension->ReaderExtension->ReaderPowerState ==
                   PowerReaderOff) {

                  // We're already in the right state
                  action = SkipRequest;
                  break;
               }

               powerState.DeviceState = PowerDeviceD3;

               // first, inform the power manager of our new state.
               PoSetPowerState (
                               DeviceObject,
                               SystemPowerState,
                               powerState
                               );

               action = MarkPending;
               break;

            default:
               ASSERT(FALSE);
               action = CompleteRequest;
               break;
            }
         }
      }
      break;

   default:
      ASSERT(FALSE);
      action = CompleteRequest;
      break;
   }

    switch (action) {

        case CompleteRequest:
            Irp->IoStatus.Status = status;
            Irp->IoStatus.Information = 0;

            SmartcardReleaseRemoveLockWithTag(
            smartcardExtension,
            'rwoP'
            );
            PoStartNextPowerIrp(Irp);
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
         break;

        case MarkPending:
            Irp->IoStatus.Status = STATUS_PENDING;
            IoMarkIrpPending(Irp);
            status = PoRequestPowerIrp (
                DeviceObject,
                IRP_MN_SET_POWER,
                powerState,
                Lit220SystemPowerCompletion,
                Irp,
                NULL
                );
            ASSERT(status == STATUS_PENDING);
         break;

        case SkipRequest:
            SmartcardReleaseRemoveLockWithTag(
            smartcardExtension,
            'rwoP'
            );
            PoStartNextPowerIrp(Irp);
            IoSkipCurrentIrpStackLocation(Irp);
            status = PoCallDriver(AttachedDeviceObject, Irp);
         break;

        case WaitForCompletion:
            status = PoCallDriver(AttachedDeviceObject, Irp);
         break;

        default:
            ASSERT(FALSE);
            break;
    }

    SmartcardDebug(
        DEBUG_DRIVER,
        ("%s!Lit220DispatchPower: Exit %lx\n",
        DRIVER_NAME,
        status)
        );

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\lit220\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Lit220.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\smartcrd\lit220\l220scr.h ===
/*++

Module Name:

    L220SCR.h

Abstract:

    smartcard 220 serial miniport defines and structures

Revision History:

--*/


#ifndef _L220SCR_
#define _L220SCR_



#define DRIVER_NAME "LIT220P"

#ifndef _WDMDDK_
#include <ntddk.h>
#endif
#include <ntddser.h>

// Pool tag for Litronic xlCS where x is a number we choose
#define SMARTCARD_POOL_TAG '0lCS'

#include "smclib.h"
#include "L220log.h"


#define IOCTL_SMARTCARD_220_READ            SCARD_CTL_CODE( 8) 
#define IOCTL_SMARTCARD_220_WRITE           SCARD_CTL_CODE( 9)       

#define MAX_IFSD 254


//
// 220 smart card reader command constants
//
#define LIT220_READER_ATTENTION     0xF4
#define KBD_ACK                     0xFA

#define LIT220_GET_READER_TYPE      0xB0
#define LIT220_SET_MODE             0xB1
#define LIT220_CARD_POWER_ON        0xB2
#define LIT220_CARD_POWER_OFF       0xB3
#define LIT220_RESET                0xB4
#define LIT220_GET_READER_STATUS    0xB5
#define LIT220_SEND_BYTE            0xB6
#define LIT220_SEND_BLOCK           0xB7
#define LIT220_RESEND_BLOCK         0xB8
#define LIT220_GET_READER_CAPS      0xB9
#define LIT220_DEACTIVATE_READER    0xBA


//
// 220 smart card respons bytes 
// every received packet starts with one of these bytes
//
#define LIT220_READER_TYPE          0x60            
#define LIT220_READER_STATUS        0x61
#define LIT220_ACK                  0x62
#define LIT220_RECEIVE_BYTE         0x63
#define LIT220_RECEIVE_BLOCK        0x64
#define LIT220_CARD_IN              0x65
#define LIT220_CARD_OUT             0x66
#define LIT220_NACK                 0x67

//
// Length of constant size reply packets
//
#define LIT220_READER_TYPE_LEN      16
#define LIT220_READER_STATUS_LEN    4

//
// Length of constant command packets
//
#define LIT220_READER_SET_MODE_LEN  8

//
// Reader status flags
//
#define LIT220_STATUS_CARD_INSERTED    0x08



#define LIT220_VENDOR_NAME          "Litronic"
#define LIT220_PRODUCT_NAME         "220 Smartcard Reader"


//
// WaitMask values
//
#define WAIT_DATA           0x0001
#define WAIT_ACK            0x0002
#define WAIT_INSERTION      0x0004
#define WAIT_REMOVAL        0x0008

//
// 220 smart card reader dependent flags
//
#define LIT220_READER_PROTOCOL_T1           0x10
#define LIT220_READER_CONVENTION_INVERSE    0x02
#define LIT220_READER_CHECK_CRC             0x01
#define LIT220_READER_BWT_EXTENSION         0x04


// Set mode flags
#define SETMODE_PROTOCOL    0x01
#define SETMODE_GT          0x02
#define SETMODE_WI          0x04
#define SETMODE_BWI         0x08
#define SETMODE_WTX         0x10
#define SETMODE_FI_DI       0x20


#define UNICODE_SIZE(x) ((x) * sizeof(WCHAR))

typedef enum _READER_POWER_STATE {
    PowerReaderUnspecified = 0,
    PowerReaderWorking,
    PowerReaderOff
} READER_POWER_STATE, *PREADER_POWER_STATE;

typedef struct _SERIAL_READER_CONFIG {

    //
    // flow control
    //
    SERIAL_HANDFLOW HandFlow;           

    //
    // special characters
    //
    SERIAL_CHARS SerialChars;           

    //
    // read/write timeouts
    //
    SERIAL_TIMEOUTS Timeouts;           

    //
    // Baudrate for reader
    //
    SERIAL_BAUD_RATE BaudRate;          

    //
    // Stop bits, parity configuration
    //
    SERIAL_LINE_CONTROL LineControl;    

    //
    // Event serial reader uses to signal insert/removal
    //
    ULONG WaitMask; 
    

} SERIAL_READER_CONFIG, *PSERIAL_READER_CONFIG;

//
// Define the reader specific portion of the smart card extension
//
typedef struct _READER_EXTENSION {

    //
    // DeviceObject pointer to serial port
    //
    PDEVICE_OBJECT ConnectedSerialPort;


    //
    // This struct is used for CardTracking
    //
    struct {

        PIRP    Irp;

        KEVENT  Event;

        IO_STATUS_BLOCK IoStatus;

        KDPC    Dpc;

    } CardStatus;

    // 
    // This struct is used to get the number of characters in the input queue
    //
    SERIAL_STATUS SerialStatus;

    //
    // IOCTL to send to the serial driver
    //
    ULONG   SerialIoControlCode;


    //
    // This holds state bits for the COM port such as DSR
    //
    ULONG   ModemStatus;

    //
    // This holds the serial parameters used to configure the serial port
    //
    SERIAL_READER_CONFIG SerialConfigData;

    //
    // This is the data byte no in reply packet
    //
    ULONG   DataByteNo;

    //
    // Number of bytes expected in the reply packer as indicated by byte 2 
    // and 3 of the receive packet
    //
    LENGTH  DataLength;

    //
    // Flags that indicate if we have received the length-bytes in the receive packet
    //
    BOOLEAN GotLengthB0;
    BOOLEAN GotLengthB1;

    //
    // Nack received from reader
    //
    BOOLEAN GotNack;

    //