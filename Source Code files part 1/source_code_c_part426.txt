Session->PrimaryCredentials.UserName.Length = RegLogonSession->UserName.Length;
       LogonSession->PrimaryCredentials.UserName.MaximumLength = RegLogonSession->UserName.MaximumLength;


       // actually copy the domainname struct and alloc domainname.buffer

       LogonSession->PrimaryCredentials.DomainName.Buffer = (LPWSTR) KerbAllocate(RegLogonSession->DomainName.MaximumLength);

       if (LogonSession->PrimaryCredentials.DomainName.Buffer == NULL)
       {
            DebugLog((DEB_ERROR, "Error allocing KERBEROS_TICKET_LOGONSESSION_KEY \n"));
            goto Cleanup;
       }

       RtlCopyMemory(LogonSession->PrimaryCredentials.DomainName.Buffer,
                     RegLogonSession->DomainName.Buffer,
                     RegLogonSession->DomainName.MaximumLength);

       LogonSession->PrimaryCredentials.DomainName.Length = RegLogonSession->DomainName.Length;
       LogonSession->PrimaryCredentials.DomainName.MaximumLength = RegLogonSession->DomainName.MaximumLength;


       //
       //  What is the size of the Credentials struct
       //

       EncryptKeySize = sizeof(KERB_KEY_DATA) * RegLogonSession->CredentialCount;
       PasswordSize = 0;

       for (Index = 0; Index < RegLogonSession->CredentialCount ; Index++ )
       {
           PasswordSize += RegLogonSession->Credentials[Index].keyvalue.length;
           RegLogonSession->Credentials[Index].keyvalue.value = (unsigned char*)
                   ((PUCHAR) RegLogonSession  +
                   (INT)(RegLogonSession->Credentials[Index].keyvalue.value));
       } // for

       //
       // Alloc & copy over the Credentials block
       //

       CredentialSize = sizeof(KERB_STORED_CREDENTIAL) -
                        (ANYSIZE_ARRAY * sizeof(KERB_KEY_DATA)) +
                        EncryptKeySize + PasswordSize;

       LogonSession->PrimaryCredentials.Passwords = (PKERB_STORED_CREDENTIAL) KerbAllocate(CredentialSize);

       if (LogonSession->PrimaryCredentials.Passwords == NULL)
       {
            DebugLog((DEB_ERROR, "Error allocing KERBEROS_TICKET_LOGONSESSION_KEY \n"));
            goto Cleanup;
       }

       //
       // copy revision, flags & credentialcount
       //

       LogonSession->PrimaryCredentials.Passwords->Revision = RegLogonSession->Revision;
       LogonSession->PrimaryCredentials.Passwords->Flags = RegLogonSession->Flags;
       LogonSession->PrimaryCredentials.Passwords->CredentialCount = RegLogonSession->CredentialCount;

       //
       // copy all keyvalue.value
       //

       Offset = 0;
       Base = (PUCHAR)LogonSession->PrimaryCredentials.Passwords +
              CredentialSize - PasswordSize;

       for (Index = 0; Index < RegLogonSession->CredentialCount ; Index++ )
       {
           RtlCopyMemory(Base + Offset,
                         RegLogonSession->Credentials[Index].keyvalue.value,
                         RegLogonSession->Credentials[Index].keyvalue.length);

           LogonSession->PrimaryCredentials.Passwords->Credentials[Index].Key.keytype =
                         RegLogonSession->Credentials[Index].keytype;
           LogonSession->PrimaryCredentials.Passwords->Credentials[Index].Key.keyvalue.length =
                         RegLogonSession->Credentials[Index].keyvalue.length;
           LogonSession->PrimaryCredentials.Passwords->Credentials[Index].Key.keyvalue.value =
                         (unsigned char*) (Base + Offset);
           Offset += RegLogonSession->Credentials[Index].keyvalue.length;
       } // for

       //
       // All logons are deferred until proven otherwise
       //

       LogonSession->LogonSessionFlags = KERB_LOGON_DEFERRED;

       if (LogonSession->PrimaryCredentials.Passwords == NULL)
       {
           LogonSession->LogonSessionFlags |= KERB_LOGON_NO_PASSWORD;
       }

       //
       // Now that the logon session structure is filled out insert it
       // into the list. After this you need to hold the logon session lock
       // to read or write this logon session.
       //

       Status = KerbInsertLogonSession(LogonSession);
       if (!NT_SUCCESS(Status))
       {
           goto Cleanup;
       }
    }

Cleanup:

    if (!NT_SUCCESS(Status))
    {
        if (LogonSession != NULL)
        {
            KerbReferenceLogonSessionByPointer(LogonSession, TRUE);
            KerbFreeLogonSession(LogonSession);
        }
    }
    else
    {
        if (LogonSession != NULL)
        {
            KerbDereferenceLogonSession(LogonSession);
        }
    }

    if (RegLogonSession != NULL)
    {
        KerbFree(RegLogonSession);
    }
    // NOTE - what about pUsername & pDomainname

    DebugLog((DEB_TRACE_API, "Leaving KerbInitSecurityInterface\n"));
    return SEC_SUCCESS(Status) ? &KerbDllSecurityFunctionTable : NULL;
}


VOID
KerbShutdownSecurityInterface(
    VOID
    )

/*++

Routine Description:

    Cleanup the data shared by the DLL and SERVICE.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PKERB_LOGON_SESSION LogonSession;
    LUID LogonId;
    PKERB_LOGON_SESSION_CACHE RegLogonSession;

    HKEY hRegKey;
    DWORD dwDisposition;
    DWORD dwError = 0;
    NTSTATUS Status = STATUS_SUCCESS;

    DebugLog((DEB_TRACE_API, "Entering KerbShutdownSecurityInterface\n"));

    Status = NtAllocateLocallyUniqueId (&LogonId);

    LogonSession = KerbReferenceLogonSession(
                           &LogonId,
                           TRUE);

    // Need to dump out logon session info in the registry
    // create or open the parameters key
    if ( ( dwError = RegCreateKeyEx (
                                   HKEY_LOCAL_MACHINE,
                                   KERBEROS_TICKET_KEY,
                                   0,
                                   "",
                                   REG_OPTION_NON_VOLATILE,
                                   KEY_ALL_ACCESS,
                                   NULL,
                                   &hRegKey,
                                   &dwDisposition) ) )
    {
        DebugLog((DEB_ERROR, "Error creating KERBEROS_TICKET_KEY\n"));
        goto Cleanup;
    }

    if (LogonSession != NULL)
    {
        ULONG PasswordSize, Offset;
        ULONG Index;
        ULONG TotalSize = 0 ;
        PUCHAR Base;

        //
        // Compute the size of the passwords, which are assumed to be
        // marshalled in order.
        //

        PasswordSize = sizeof(KERB_LOGON_SESSION_CACHE) - sizeof(KERB_KEY_DATA) * ANYSIZE_ARRAY +
                        LogonSession->PrimaryCredentials.Passwords->CredentialCount * sizeof(KERB_KEY_DATA);

        for (Index = 0; Index < LogonSession->PrimaryCredentials.Passwords->CredentialCount ; Index++ )
        {
            PasswordSize += LogonSession->PrimaryCredentials.Passwords->Credentials[Index].Key.keyvalue.length;
            DsysAssert((PUCHAR) LogonSession->PrimaryCredentials.Passwords->Credentials[Index].Key.keyvalue.value <=
                (PUCHAR) LogonSession->PrimaryCredentials.Passwords + PasswordSize );
        }

        // Total size of the logon session cache
        TotalSize = LogonSession->PrimaryCredentials.UserName.MaximumLength +
                    LogonSession->PrimaryCredentials.DomainName.MaximumLength +
                    PasswordSize;

        RegLogonSession = (PKERB_LOGON_SESSION_CACHE) KerbAllocate(TotalSize);

        if (RegLogonSession == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        RegLogonSession->Lifetime =
                    LogonSession->Lifetime;
        RegLogonSession->LogonSessionFlags =
                    LogonSession->LogonSessionFlags;
        RegLogonSession->UserName.Length =
                    LogonSession->PrimaryCredentials.UserName.Length;
        RegLogonSession->UserName.MaximumLength =
                    LogonSession->PrimaryCredentials.UserName.MaximumLength;
        RegLogonSession->DomainName.Length =
                    LogonSession->PrimaryCredentials.DomainName.Length;
        RegLogonSession->DomainName.MaximumLength =
                    LogonSession->PrimaryCredentials.DomainName.MaximumLength;
        RegLogonSession->Revision =
                    LogonSession->PrimaryCredentials.Passwords->Revision;
        RegLogonSession->Flags =
                    LogonSession->PrimaryCredentials.Passwords->Flags;
        RegLogonSession->CredentialCount=
                    LogonSession->PrimaryCredentials.Passwords->CredentialCount;

        Base = (PUCHAR) RegLogonSession;

        Offset = sizeof(KERB_LOGON_SESSION_CACHE) -
                 (ANYSIZE_ARRAY * sizeof(KERB_KEY_DATA)) +
                 (RegLogonSession->CredentialCount * sizeof(KERB_KEY_DATA));
        // Offset from the struct

        RegLogonSession->UserName.Buffer = (LPWSTR)Offset;

        RtlCopyMemory(Base + Offset,
                      LogonSession->PrimaryCredentials.UserName.Buffer,
                      LogonSession->PrimaryCredentials.UserName.MaximumLength);

        Offset += LogonSession->PrimaryCredentials.UserName.MaximumLength;

        RegLogonSession->DomainName.Buffer = (LPWSTR)(Offset);

        RtlCopyMemory(Base + Offset,
                      LogonSession->PrimaryCredentials.DomainName.Buffer,
                      LogonSession->PrimaryCredentials.DomainName.MaximumLength);
        Offset += LogonSession->PrimaryCredentials.DomainName.MaximumLength;

        for (Index = 0; Index < RegLogonSession->CredentialCount ; Index++ )
        {
            RegLogonSession->Credentials[Index].keytype =
                    LogonSession->PrimaryCredentials.Passwords->Credentials[Index].Key.keytype;

            RegLogonSession->Credentials[Index].keyvalue.length =
                    LogonSession->PrimaryCredentials.Passwords->Credentials[Index].Key.keyvalue.length;

            RegLogonSession->Credentials[Index].keyvalue.value =
                    (unsigned char *) (Offset);

            RtlCopyMemory(Base + Offset,
                    LogonSession->PrimaryCredentials.Passwords->Credentials[Index].Key.keyvalue.value,
                    LogonSession->PrimaryCredentials.Passwords->Credentials[Index].Key.keyvalue.length);

            Offset += LogonSession->PrimaryCredentials.Passwords->Credentials[Index].Key.keyvalue.length;

        } // for


        // add username from LogonSession->PrimaryCredentials->Username
        if ( ( dwError = RegSetValueEx (
                                   hRegKey,
                                   KERBEROS_TICKET_USERNAME_KEY,
                                   0,
                                   REG_BINARY,
                                   (LPBYTE) LogonSession->PrimaryCredentials.UserName.Buffer,
                                   LogonSession->PrimaryCredentials.UserName.Length
                                   ) ))
        {
            DebugLog((DEB_ERROR, "Error writing to KERBEROS_TICKET_USERNAME_KEY\n"));
            goto Cleanup;
        }

        // add domainname from LogonSession->PrimaryCredentials->domainname
        if ( ( dwError = RegSetValueEx (
                                   hRegKey,
                                   KERBEROS_TICKET_DOMAINNAME_KEY,
                                   0,
                                   REG_BINARY,
                                   (LPBYTE) LogonSession->PrimaryCredentials.DomainName.Buffer,
                                   LogonSession->PrimaryCredentials.DomainName.Length)))
        {
            DebugLog((DEB_ERROR, "Error writing to KERBEROS_TICKET_DOMAINNAME_KEY\n"));
            goto Cleanup;
        }

        // add logon session data from RegLogonSession & TotalSize
        if ( ( dwError = RegSetValueEx (
                                   hRegKey,
                                   KERBEROS_TICKET_LOGONSESSION_KEY,
                                   0,
                                   REG_BINARY,
                                   (LPBYTE) RegLogonSession,
                                   TotalSize) ) )
        {
            DebugLog((DEB_ERROR, "Error writing to KERBEROS_TICKET_LOGONSESSION_KEY\n"));
            goto Cleanup;
        }
    }
    else // (LogonSession is NULL)
    {
        // We did not have any valid kerberos logon sessions.
        // Delete all the registry values in keys.

        DebugLog((DEB_TRACE, "No Kerberos LogonSession\n"));
        if ( ( dwError = RegDeleteValue (
                                   hRegKey,
                                   KERBEROS_TICKET_USERNAME_KEY)))
        {
            DebugLog((DEB_ERROR, "Error deleting value KERBEROS_TICKET_USERNAME_KEY\n"));
        }

        if ( ( dwError = RegDeleteValue (
                                   hRegKey,
                                   KERBEROS_TICKET_DOMAINNAME_KEY)))
        {
            DebugLog((DEB_ERROR, "Error deleting value KERBEROS_TICKET_DOMAINNAME_KEY\n"));
        }

        if ( ( dwError = RegDeleteValue (
                                   hRegKey,
                                   KERBEROS_TICKET_LOGONSESSION_KEY)))
        {
            DebugLog((DEB_ERROR, "Error deleting value KERBEROS_TICKET_LOGONSESSION_KEY\n"));
        }

    }

Cleanup:

    if ( ( dwError = RegFlushKey ( hRegKey) ))
    {
        DebugLog((DEB_ERROR, "Error Flushing KERBEROS_TICKET_KEY\n"));
    }

    if ( ( dwError = RegCloseKey ( hRegKey) ))
    {
        DebugLog((DEB_ERROR, "Error closing KERBEROS_TICKET_KEY\n"));
    }

    if (LogonSession != NULL)
    {
        KerbDereferenceLogonSession(LogonSession);
        LogonSession = NULL;
    }

    SpShutdown();

    DebugLog((DEB_TRACE_API, "Leaving KerbShutdownSecurityInterface\n"));

}


SECURITY_STATUS
KerbSpGetInfo(
    IN LPTSTR PackageName,
    OUT PSecPkgInfo *PackageInfo
    )

/*++

Routine Description:

    This API is intended to provide basic information about Security
    Packages themselves.  This information will include the bounds on sizes
    of authentication information, credentials and contexts.

    ?? This is a local routine rather than the real API call since the API
    call has a bad interface that neither allows me to allocate the
    buffer nor tells me how big the buffer is.  Perhaps when the real API
    is fixed, I'll make this the real API.

Arguments:

     PackageName - Name of the package being queried.

     PackageInfo - Returns a pointer to an allocated block describing the
        security package.  The allocated block must be freed using
        FreeContextBuffer.

Return Value:

    SEC_E_OK -- Call completed successfully

    SEC_E_PACKAGE_UNKNOWN -- Package being queried is not this package
    SEC_E_INSUFFICIENT_MEMORY -- Not enough memory

--*/
{
    LPTSTR Where;

    //
    // Ensure the correct package name was passed in.
    //

    if ( lstrcmpi( PackageName, KERBEROS_PACKAGE_NAME ) != 0 ) {
        return SEC_E_SECPKG_NOT_FOUND;
    }

    //
    // Allocate a buffer for the PackageInfo
    //

    *PackageInfo = (PSecPkgInfo) LocalAlloc( 0, sizeof(SecPkgInfo) +
                                  sizeof(KERBEROS_PACKAGE_NAME) +
                                  sizeof(KERBEROS_PACKAGE_COMMENT) );

    if ( *PackageInfo == NULL ) {
        return SEC_E_INSUFFICIENT_MEMORY;
    }

    //
    // Fill in the information.
    //

    (*PackageInfo)->fCapabilities = KerbGlobalCapabilities;
    (*PackageInfo)->wVersion = SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION;
    (*PackageInfo)->wRPCID = RPC_C_AUTHN_GSS_KERBEROS;
    (*PackageInfo)->cbMaxToken = KERBEROS_MAX_TOKEN;

    Where = (LPTSTR)((*PackageInfo)+1);

    (*PackageInfo)->Name = Where;
    lstrcpy( Where, KERBEROS_PACKAGE_NAME);
    Where += lstrlen(Where) + 1;

    (*PackageInfo)->Comment = Where;
    lstrcpy( Where, KERBEROS_PACKAGE_COMMENT);
    Where += lstrlen(Where) + 1;

    return SEC_E_OK;
}


SECURITY_STATUS
KerbEnumerateSecurityPackages(
    OUT PULONG PackageCount,
    OUT PSecPkgInfo *PackageInfo
    )

/*++

Routine Description:

    This API returns a list of Security Packages available to client (i.e.
    those that are either loaded or can be loaded on demand).  The caller
    must free the returned buffer with FreeContextBuffer.  This API returns
    a list of all the security packages available to a service.  The names
    returned can then be used to acquire credential handles, as well as
    determine which package in the system best satisfies the requirements
    of the caller.  It is assumed that all available packages can be
    included in the single call.

    This is really a dummy API that just returns information about this
    security package.  It is provided to ensure this security package has the
    same interface as the multiplexer DLL does.

Arguments:

     PackageCount - Returns the number of packages supported.

     PackageInfo - Returns an allocate array of structures
        describing the security packages.  The array must be freed
        using FreeContextBuffer.

Return Value:

    SEC_E_OK -- Call completed successfully

    SEC_E_PACKAGE_UNKNOWN -- Package being queried is not this package
    SEC_E_INSUFFICIENT_MEMORY -- Not enough memory

--*/
{
    //
    // Get the information for this package.
    //

    LPTSTR Where;

    *PackageCount = 1;
    //
    // Allocate a buffer for the PackageInfo
    //

    *PackageInfo = (PSecPkgInfo) LocalAlloc( 0, sizeof(SecPkgInfo) +
                                  sizeof(KERBEROS_PACKAGE_NAME) +
                                  sizeof(KERBEROS_PACKAGE_COMMENT) );

    if ( *PackageInfo == NULL ) {
        return SEC_E_INSUFFICIENT_MEMORY;
    }

    //
    // Fill in the information.
    //

    (*PackageInfo)->fCapabilities = KerbGlobalCapabilities;
    (*PackageInfo)->wVersion = SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION;
    (*PackageInfo)->wRPCID = RPC_C_AUTHN_GSS_KERBEROS;
    (*PackageInfo)->cbMaxToken = KERBEROS_MAX_TOKEN;

    Where = (LPTSTR)((*PackageInfo)+1);

    (*PackageInfo)->Name = Where;
    lstrcpy( Where, KERBEROS_PACKAGE_NAME);
    Where += lstrlen(Where) + 1;

    (*PackageInfo)->Comment = Where;
    lstrcpy( Where, KERBEROS_PACKAGE_COMMENT);
    Where += lstrlen(Where) + 1;


    return SEC_E_OK;

}

SECURITY_STATUS
KerbQuerySecurityPackageInfo (
    LPTSTR PackageName,
    PSecPkgInfo SEC_FAR * Package
    )
{

        return ( KerbSpGetInfo(
                                PackageName,
                                Package));

}



SECURITY_STATUS SEC_ENTRY
KerbFreeContextBuffer (
    void __SEC_FAR * ContextBuffer
    )

/*++

Routine Description:

    This API is provided to allow callers of security API such as
    InitializeSecurityContext() for free the memory buffer allocated for
    returning the outbound context token.

Arguments:

    ContextBuffer - Address of the buffer to be freed.

Return Value:

    SEC_E_OK - Call completed successfully

--*/

{
    //
    // The only allocated buffer that the kerb currently returns to the caller
    // is from EnumeratePackages.  It uses LocalAlloc to allocate memory.  If
    // we ever need memory to be allocated by the service, we have to rethink
    // how this routine distinguishes between to two types of allocated memory.
    //

    (VOID) LocalFree( ContextBuffer );
    return SEC_E_OK;
}

#if DBG
//
// Control which messages get displayed
//

// DWORD KerbInfoLevel = DEB_ERROR | DEB_WARN | DEB_TRACE | DEB_TRACE_API;

//
// SspPrintRoutine - Displays debug output
//
VOID __cdecl
KerbPrintRoutine(
    IN DWORD DebugFlag,
    IN LPCSTR FormatString,    // PRINTF()-STYLE FORMAT STRING.
    ...                        // OTHER ARGUMENTS ARE POSSIBLE.
    )
{
    static char prefix[] = "KERB: ";
    char outbuf[256];
    va_list args;

    if ( DebugFlag & KerbInfoLevel) {
        EnterCriticalSection( &KerbGlobalLogFileCritSect );
        lstrcpy(outbuf, prefix);
        va_start(args, FormatString);
        wvsprintf(outbuf + sizeof(prefix) - 1, FormatString, args);
        OutputDebugString(outbuf);
        LeaveCriticalSection( &KerbGlobalLogFileCritSect );
    }

    return;
}
#endif DBG

SECURITY_STATUS
KerbAcquireCredentialsHandle(
    IN LPTSTR PrincipalName,
    IN LPTSTR PackageName,
    IN ULONG CredentialUseFlags,
    IN PVOID LogonId,
    IN PVOID AuthData,
    IN SEC_GET_KEY_FN GetKeyFunction,
    IN PVOID GetKeyArgument,
    OUT PCredHandle CredentialHandle,
    OUT PTimeStamp Lifetime
    )
{
    SECURITY_STATUS SecStatus = SEC_E_OK;
    UNICODE_STRING NewPrincipalName;

    //
    // Validate the arguments
    //

    if ( lstrcmpi( PackageName, KERBEROS_PACKAGE_NAME ) != 0 ) {
        SecStatus = SEC_E_SECPKG_NOT_FOUND;
        goto Cleanup;
    }

    if ( (CredentialUseFlags & SECPKG_CRED_OUTBOUND) &&
         ARGUMENT_PRESENT(PrincipalName) && *PrincipalName != '\0' ) {
        SecStatus = SEC_E_UNKNOWN_CREDENTIALS;
        goto Cleanup;
    }

    if ( ARGUMENT_PRESENT(LogonId) ) {
        SecStatus = SEC_E_UNSUPPORTED_FUNCTION;
        goto Cleanup;
    }

    if ( ARGUMENT_PRESENT(GetKeyFunction) ) {
        SecStatus = SEC_E_UNSUPPORTED_FUNCTION;
        goto Cleanup;
    }

    if ( ARGUMENT_PRESENT(GetKeyArgument) ) {
        SecStatus = SEC_E_UNSUPPORTED_FUNCTION;
        goto Cleanup;
    }

    //
    // Don't allow inbound credentials if we don't have an authentication
    // server avaiable
    //

    if ( (KerbGlobalCapabilities & SECPKG_FLAG_CLIENT_ONLY)
         && (CredentialUseFlags & SECPKG_CRED_INBOUND) ) {
        DebugLog(( SSP_API,
            "KerbAcquireCredentialHandle: no authentication service for inbound handle.\n" ));
        SecStatus = SEC_E_NO_AUTHENTICATING_AUTHORITY;
        goto Cleanup;
    }

    if (!RtlCreateUnicodeStringFromAsciiz( &NewPrincipalName, PrincipalName)){
        SecStatus = SEC_E_INSUFFICIENT_MEMORY;;
        goto Cleanup;
    }


    SecStatus = SpAcquireCredentialsHandle(
                            &NewPrincipalName,
                            CredentialUseFlags,
                            (PLUID)LogonId,
                            AuthData,
                            GetKeyFunction,
                            GetKeyArgument,
                            &CredentialHandle->dwUpper,
                            Lifetime );

Cleanup:

    return SecStatus;

}

SECURITY_STATUS
KerbFreeCredentialsHandle(
    IN PCredHandle CredentialHandle
    )

/*++

Routine Description:

    This API is used to notify the security system that the credentials are
    no longer needed and allows the application to free the handle acquired
    in the call described above. When all references to this credential
    set has been removed then the credentials may themselves be removed.

Arguments:

    CredentialHandle - Credential Handle obtained through
        AcquireCredentialHandle.

Return Value:


    SEC_E_OK -- Call completed successfully

    SEC_E_NO_SPM -- Security Support Provider is not running
    SEC_E_INVALID_HANDLE -- Credential Handle is invalid


--*/

{
    SECURITY_STATUS SecStatus;




    SecStatus = SpFreeCredentialsHandle(
                            CredentialHandle->dwUpper );



    return SecStatus;

}

SECURITY_STATUS
KerbQueryCredentialsAttributes(
    IN PCredHandle CredentialsHandle,
    IN ULONG Attribute,
    OUT PVOID Buffer
    )
{
    SECURITY_STATUS SecStatus;


    SecStatus = SpQueryCredentialsAttributes(
                            CredentialsHandle->dwUpper,
                            Attribute,
                            Buffer );

    return SecStatus;
}

SECURITY_STATUS
KerbInitializeSecurityContext(
    IN PCredHandle CredentialHandle,
    IN PCtxtHandle OldContextHandle,
    IN LPTSTR TargetName,
    IN ULONG ContextReqFlags,
    IN ULONG Reserved1,
    IN ULONG TargetDataRep,
    IN PSecBufferDesc InputToken,
    IN ULONG Reserved2,
    OUT PCtxtHandle NewContextHandle,
    OUT PSecBufferDesc OutputToken,
    OUT PULONG ContextAttributes,
    OUT PTimeStamp ExpirationTime
    )
{
    UNICODE_STRING TargetNameUStr;
    BOOLEAN fMappedContext;
    SecBuffer ContextData;
    SECURITY_STATUS SecStatus = SEC_E_OK;
    SECURITY_STATUS SecondaryStatus = SEC_E_OK;
    SecBufferDesc EmptyBuffer =  {0,0, NULL};

    RtlCreateUnicodeStringFromAsciiz (&TargetNameUStr, TargetName);

    if (!ARGUMENT_PRESENT(InputToken))
    {
        InputToken = &EmptyBuffer;
    }

    if (!ARGUMENT_PRESENT(OutputToken))
    {
        OutputToken = &EmptyBuffer;
    }

    SecStatus = SpInitLsaModeContext (
                          CredentialHandle ? CredentialHandle->dwUpper : NULL,
                          OldContextHandle ? OldContextHandle->dwUpper : NULL,
                          &TargetNameUStr,
                          ContextReqFlags,
                          TargetDataRep,
                          InputToken,
                          &NewContextHandle->dwUpper,
                          OutputToken,
                          ContextAttributes,
                          ExpirationTime,
                          &fMappedContext,
                          &ContextData);

    if (NT_SUCCESS(SecStatus) && fMappedContext)
    {
        SecondaryStatus = SpInitUserModeContext(NewContextHandle->dwUpper,
                                 &ContextData);

        if (!NT_SUCCESS(SecondaryStatus))
        {
            SecStatus = SecondaryStatus;

            SecondaryStatus = KerbDeleteSecurityContext(NewContextHandle);
        }
    }

    return SecStatus;
}

SECURITY_STATUS
KerbDeleteSecurityContext (
    IN PCtxtHandle ContextHandle
    )
{
    SECURITY_STATUS SecStatus = SEC_E_OK;

    SecStatus = SpDeleteContext (ContextHandle->dwUpper);

    return SecStatus;

}

SECURITY_STATUS
KerbApplyControlToken (
    PCtxtHandle ContextHandle,
    PSecBufferDesc Input
    )
{
    SECURITY_STATUS SecStatus = SEC_E_OK;

    SecStatus = SpApplyControlToken(ContextHandle->dwUpper, Input);

    return SecStatus;
}


SECURITY_STATUS
KerbImpersonateSecurityContext (
    PCtxtHandle ContextHandle
    )
{
    return (SEC_E_NO_IMPERSONATION);
}

SECURITY_STATUS
KerbRevertSecurityContext (
    PCtxtHandle ContextHandle
    )
{
    return (SEC_E_NO_IMPERSONATION);
}

SECURITY_STATUS
KerbQueryContextAttributes(
    IN PCtxtHandle ContextHandle,
    IN ULONG Attribute,
    OUT PVOID Buffer
    )
{
    SECURITY_STATUS SecStatus = SEC_E_OK;

    SecStatus = SpQueryContextAttributes(ContextHandle->dwUpper,
                                         Attribute,
                                         Buffer);

    return SecStatus;
}

SECURITY_STATUS SEC_ENTRY
KerbCompleteAuthToken (
    PCtxtHandle ContextHandle,
    PSecBufferDesc BufferDescriptor
    )
{
    SECURITY_STATUS SecStatus = SEC_E_OK;

    SecStatus = SpCompleteAuthToken(ContextHandle->dwUpper, BufferDescriptor);

    return SecStatus;
}

SECURITY_STATUS
KerbMakeSignature (
    PCtxtHandle ContextHandle,
    unsigned long QualityOfProtection,
    PSecBufferDesc Message,
    unsigned long SequenceNumber
    )
{
    SECURITY_STATUS SecStatus = SEC_E_OK;

    SecStatus = SpMakeSignature(ContextHandle->dwUpper,
                                QualityOfProtection,
                                Message,
                                SequenceNumber);

    return SecStatus;
}

SECURITY_STATUS
KerbVerifySignature (
    PCtxtHandle ContextHandle,
    PSecBufferDesc Message,
    unsigned long SequenceNumber,
    unsigned long * QualityOfProtection
    )
{
    SECURITY_STATUS SecStatus = SEC_E_OK;

    SecStatus = SpVerifySignature(ContextHandle->dwUpper,
                                  Message,
                                  SequenceNumber,
                                  QualityOfProtection);

    return SecStatus;
}

SECURITY_STATUS
KerbSealMessage (
    PCtxtHandle ContextHandle,
    unsigned long QualityOfProtection,
    PSecBufferDesc Message,
    unsigned long SequenceNumber
    )
{
    SECURITY_STATUS SecStatus = SEC_E_OK;

    SecStatus = SpSealMessage(ContextHandle->dwUpper,
                              QualityOfProtection,
                              Message,
                              SequenceNumber);

    return SecStatus;
}

SECURITY_STATUS
KerbUnsealMessage (
    PCtxtHandle ContextHandle,
    PSecBufferDesc Message,
    unsigned long SequenceNumber,
    unsigned long * QualityOfProtection
    )
{
    SECURITY_STATUS SecStatus = SEC_E_OK;

    SecStatus = SpUnsealMessage(ContextHandle->dwUpper,
                                Message,
                                SequenceNumber,
                                QualityOfProtection);

    return SecStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\chicago\debug.h ===
/*++

Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    debug.h

Abstract:

    NtLmSsp service debug support

Author:

    Ported from Lan Man 2.0

Revision History:

    21-May-1991 (cliffv)
        Ported to NT.  Converted to NT style.
    09-Apr-1992 JohnRo
        Prepare for WCHAR.H (_wcsicmp vs _wcscmpi, etc).

--*/

//
// kerbstub.cxx will #include this file with DEBUG_ALLOCATE defined.
// That will cause each of these variables to be allocated.
//
#ifdef EXTERN
#undef EXTERN
#endif

#ifdef DEBUG_ALLOCATE
#define EXTERN
#else
#define EXTERN extern
#endif


////////////////////////////////////////////////////////////////////////
//
// Debug Definititions
//
////////////////////////////////////////////////////////////////////////

#define SSP_INIT          0x00000001 // Initialization
#define SSP_MISC          0x00000002 // Misc debug
#define SSP_API           0x00000004 // API processing
#define SSP_LPC           0x00000008 // LPC
#define SSP_CRITICAL      0x00000100 // Only real important errors

//
// Very verbose bits
//

#define SSP_API_MORE      0x04000000 // verbose API
#define SSP_LPC_MORE      0x08000000 // verbose LPC

//
// Control bits.
//

#define SSP_TIMESTAMP         0x20000000 // TimeStamp each output line
#define SSP_REQUEST_TARGET    0x40000000 // Force client to ask for target name
#define SSP_USE_OEM           0x80000000 // Force client to use OEM character set

// bits from kerberos (from kerbdbg.h)

#define DEB_ERROR             0x00000001
#define DEB_WARN              0x00000002
#define DEB_TRACE             0x00000004
#define DEB_TRACE_API         0x00000008
#define DEB_TRACE_CRED        0x00000010
#define DEB_TRACE_CTXT        0x00000020
#define DEB_TRACE_LSESS       0x00000040
#define DEB_TRACE_LOGON       0x00000100
#define DEB_TRACE_KDC         0x00000200
#define DEB_TRACE_CTXT2       0x00000400
#define DEB_TRACE_LOCKS       0x01000000
#define DEB_T_SOCK            0x00000080

// bits from kerberos (from security\dsysdbg.h)
#define DSYSDBG_CLEAN         0x40000000

//
// Name and directory of log file
//

#define DEBUG_DIR           L"\\debug"
#define DEBUG_FILE          L"\\ntlmssp.log"
#define DEBUG_BAK_FILE      L"\\ntlmssp.bak"

//#if DBG
#ifdef RETAIL_LOG_SUPPORT

#define DebugLog(_x_) KerbPrintRoutine _x_

VOID __cdecl
KerbPrintRoutine(
    IN DWORD DebugFlag,
    IN LPCSTR FORMATSTRING,     // PRINTF()-STYLE FORMAT STRING.
    ...                         // OTHER ARGUMENTS ARE POSSIBLE.
    );

#else

#define IF_DEBUG(Function) if (FALSE)

// Nondebug version.
#define DebugLog(_x_)

#endif // DBG

#undef EXTERN
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\utest\hello2\hello2.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.00.39 */
/* at Thu Jun 27 14:12:43 1996
 */
/* Compiler settings for .\hello2.idl:
    Oi (OptLev=i0), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref 
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"

#ifndef __hello2_h__
#define __hello2_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __hello2_INTERFACE_DEFINED__
#define __hello2_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: hello2
 * at Thu Jun 27 14:12:43 1996
 * using MIDL 3.00.39
 ****************************************/
/* [implicit_handle][unique][version][uuid] */ 


void HelloProc2( 
    /* [string][in] */ unsigned char __RPC_FAR *pszString);

void Shutdown2( void);


extern handle_t hello2_IfHandle;


extern RPC_IF_HANDLE hello2_v1_0_c_ifspec;
extern RPC_IF_HANDLE hello2_v1_0_s_ifspec;
#endif /* __hello2_INTERFACE_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\chicago\kerbstub.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    kerbcomn.h

Abstract:

    Header file describing the interface to code common to the
    NT Lanman Security Support Provider (NtLmSsp) Service and the DLL.

Author:

    Cliff Van Dyke (CliffV) 17-Sep-1993

Revision History:

--*/

#ifndef _KERBSTUB_INCLUDED_
#define _KERBSTUB_INCLUDED_

//
// kerbstub.cxx will #include this file with KERBCOMN_ALLOCATE defined.
// That will cause each of these variables to be allocated.
//
#ifdef EXTERN
#undef EXTERN
#endif

#ifdef KERBSTUB_ALLOCATE
#define EXTERN
#else
#define EXTERN extern
#endif

EXTERN CRITICAL_SECTION KerbDllCritSect;    // Serializes access to all globals in module

#if DBG

//
// To serialize access to log file.
//

EXTERN CRITICAL_SECTION KerbGlobalLogFileCritSect;

//
// Control which messages get displayed
//

EXTERN DWORD KerbInfoLevel;
#endif // DBG

#define KERBEROS_TICKET_KEY TEXT("Network\\KerberosLogon")
#define KERBEROS_TICKET_USERNAME_KEY TEXT("UserName")
#define KERBEROS_TICKET_DOMAINNAME_KEY TEXT("DomainName")
#define KERBEROS_TICKET_LOGONSESSION_KEY TEXT("LogonSession")

EXTERN SecurityFunctionTable KerbDllSecurityFunctionTable;
EXTERN LSA_SECPKG_FUNCTION_TABLE FunctionTable;

////////////////////////////////////////////////////////////////////////
//
// Typedefs required for dumping to/from registry
//
////////////////////////////////////////////////////////////////////////

typedef struct _KERB_LOGON_SESSION_CACHE {
    TimeStamp      Lifetime;
    ULONG          LogonSessionFlags;
    UNICODE_STRING UserName;
    UNICODE_STRING DomainName;
    USHORT         Revision;
    USHORT         Flags;
    USHORT         CredentialCount;
    KERB_ENCRYPTION_KEY Credentials[ANYSIZE_ARRAY];
} KERB_LOGON_SESSION_CACHE, *PKERB_LOGON_SESSION_CACHE;

////////////////////////////////////////////////////////////////////////
//
// Procedure Forwards
//
////////////////////////////////////////////////////////////////////////

//
// Procedure forwards from stub.c
//


SECURITY_STATUS
KerbEnumerateSecurityPackages(
    OUT PULONG PackageCount,
    OUT PSecPkgInfo *PackageInfo
    );

SECURITY_STATUS
KerbQuerySecurityPackageInfo (
    LPTSTR PackageName,
    PSecPkgInfo * Package
    );

SECURITY_STATUS SEC_ENTRY
KerbFreeContextBuffer (
    void __SEC_FAR * ContextBuffer
    );

SECURITY_STATUS
KerbAcquireCredentialsHandle(
    IN LPTSTR PrincipalName,
    IN LPTSTR PackageName,
    IN ULONG CredentialUseFlags,
    IN PVOID LogonId,
    IN PVOID AuthData,
    IN SEC_GET_KEY_FN GetKeyFunction,
    IN PVOID GetKeyArgument,
    OUT PCredHandle CredentialHandle,
    OUT PTimeStamp Lifetime
    );

SECURITY_STATUS
KerbFreeCredentialsHandle(
    IN PCredHandle CredentialHandle
    );

SECURITY_STATUS
KerbQueryCredentialsAttributes(
    IN PCredHandle CredentialsHandle,
    IN ULONG Attribute,
    OUT PVOID Buffer
    );

SECURITY_STATUS
KerbSspiLogonUser(
    IN LPTSTR PackageName,
    IN LPTSTR UserName,
    IN LPTSTR DomainName,
    IN LPTSTR Password
    );

SECURITY_STATUS
KerbInitializeSecurityContext(
    IN PCredHandle CredentialHandle,
    IN PCtxtHandle OldContextHandle,
    IN LPTSTR TargetName,
    IN ULONG ContextReqFlags,
    IN ULONG Reserved1,
    IN ULONG TargetDataRep,
    IN PSecBufferDesc InputToken,
    IN ULONG Reserved2,
    OUT PCtxtHandle NewContextHandle,
    OUT PSecBufferDesc OutputToken,
    OUT PULONG ContextAttributes,
    OUT PTimeStamp ExpirationTime
    );

SECURITY_STATUS
KerbDeleteSecurityContext (
    PCtxtHandle ContextHandle
    );

SECURITY_STATUS
KerbApplyControlToken (
    PCtxtHandle ContextHandle,
    PSecBufferDesc Input
    );


SECURITY_STATUS
KerbImpersonateSecurityContext (
    PCtxtHandle ContextHandle
    );

SECURITY_STATUS
KerbRevertSecurityContext (
    PCtxtHandle ContextHandle
    );

SECURITY_STATUS
KerbQueryContextAttributes(
    IN PCtxtHandle ContextHandle,
    IN ULONG Attribute,
    OUT PVOID Buffer
    );

SECURITY_STATUS SEC_ENTRY
KerbCompleteAuthToken (
    PCtxtHandle ContextHandle,
    PSecBufferDesc BufferDescriptor
    );

SECURITY_STATUS
KerbMakeSignature (
    PCtxtHandle ContextHandle,
    unsigned long QualityOfProtection,
    PSecBufferDesc Message,
    unsigned long SequenceNumber
    );

SECURITY_STATUS
KerbVerifySignature (
    PCtxtHandle ContextHandle,
    PSecBufferDesc Message,
    unsigned long SequenceNumber,
    unsigned long * QualityOfProtection
    );

SECURITY_STATUS
KerbSealMessage (
    PCtxtHandle ContextHandle,
    unsigned long QualityOfProtection,
    PSecBufferDesc Message,
    unsigned long SequenceNumber
    );

SECURITY_STATUS
KerbUnsealMessage (
    PCtxtHandle ContextHandle,
    PSecBufferDesc Message,
    unsigned long SequenceNumber,
    unsigned long * QualityOfProtection
    );

NTSTATUS
GetClientInfo(
    OUT PSECPKG_CLIENT_INFO ClientInfo
    );

BOOLEAN
GetCallInfo(
    OUT PSECPKG_CALL_INFO CallInfo
    );

// fake it.
//typedef ULONG LSA_CLIENT_REQUEST;
//typedef LSA_CLIENT_REQUEST *LSA_CLIENT_REQUEST;

NTSTATUS
CopyFromClientBuffer(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN ULONG Length,
    IN PVOID BufferToCopy,
    IN PVOID ClientBaseAddress
    );

NTSTATUS
AllocateClientBuffer(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN ULONG LengthRequired,
    OUT PVOID *ClientBaseAddress
    );

NTSTATUS
CopyToClientBuffer(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN ULONG Length,
    IN PVOID ClientBaseAddress,
    IN PVOID BufferToCopy
    );

NTSTATUS
FreeClientBuffer (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ClientBaseAddress
    );

VOID
AuditLogon(
    IN NTSTATUS Status,
    IN NTSTATUS SubStatus,
    IN PUNICODE_STRING AccountName,
    IN PUNICODE_STRING AuthenticatingAuthority,
    IN PUNICODE_STRING WorkstationName,
    IN OPTIONAL PSID UserSid,
    IN SECURITY_LOGON_TYPE LogonType,
    IN PTOKEN_SOURCE TokenSource,
    IN PLUID LogonId
    );

NTSTATUS
MapBuffer(
    IN PSecBuffer InputBuffer,
    OUT PSecBuffer OutputBuffer
    );

NTSTATUS
KerbDuplicateHandle(
    IN HANDLE SourceHandle,
    OUT PHANDLE DestionationHandle
    );

PVOID
AllocateLsaHeap(
    IN ULONG Length
    );

VOID
FreeLsaHeap(
    IN PVOID Base
    );

VOID
FreeReturnBuffer(
    IN PVOID Base
    );

#endif // ifndef _KERBSTUB_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\utest\hello2\server\hello2s.c ===
/****************************************************************************
                          Microsoft RPC Version 1.0
                         Copyright Microsoft Corp. 1992
                                Hello Example

    FILE:       hellos.c
    USAGE:      hellos
    PURPOSE:    Server side of RPC distributed application hello
    FUNCTIONS:  main() - registers server as RPC server
    COMMENTS:
    This distributed application prints "hello, world" on the server.
    This version features a client that manages its connection to
    the server. It uses the binding handle hello_IfHandle that is defined
    in the generated header file hello.h.
****************************************************************************/
#include <stdlib.h>
#include <windows.h>
#include <string.h>
#include <stdio.h>
#include <ctype.h>
#include <rpc.h>    // RPC data structures and APIs
#include "hello2.h"    // header file generated by MIDL compiler

void Usage(char * pszProgramName)
{
    fprintf(stderr, "Usage:  %s\n", pszProgramName);
    fprintf(stderr, " -p protocol_sequence\n");
    fprintf(stderr, " -n network_address\n");
    fprintf(stderr, " -e endpoint\n");
    fprintf(stderr, " -o options\n");
    fprintf(stderr, " -u uuid\n");
    exit(1);
}

HANDLE TerminateEvent;

int __cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    RPC_STATUS status;
    unsigned char * pszUuid = "12345678-1234-1234-1234-123456789AB3";
    unsigned char * pszProtocolSequence = "ncacn_ip_tcp";
    unsigned char * pszNetworkAddress   = NULL;
    unsigned char * pszEndpoint         = "760";
    unsigned char * pszOptions          = NULL;
    unsigned char * pszStringBinding    = NULL;
    int i;
    DWORD WaitStatus;

    // allow the user to override settings with command line switches
    for (i = 1; i < argc; i++) {
        if ((*argv[i] == '-') || (*argv[i] == '/')) {
            switch (tolower(*(argv[i]+1))) {
                case 'p':  // protocol sequence
                    pszProtocolSequence = argv[++i];
                    break;
                case 'n':  // network address
                    pszNetworkAddress = argv[++i];
                    break;
                case 'e':
                    pszEndpoint = argv[++i];
                    break;
                case 'o':
                    pszOptions = argv[++i];
                    break;
                case 'u':
                    pszUuid = argv[++i];
                    break;
                case 'h':
                case '?':
                default:
                    Usage(argv[0]);
            }
        }
        else
            Usage(argv[0]);
    }

    //
    // Create an event to wait on
    //

    TerminateEvent = CreateEvent( NULL,     // No security attributes
                                  TRUE,     // Must be manually reset
                                  FALSE,    // Initially not signaled
                                  NULL );   // No name

    if ( TerminateEvent == NULL ) {
        printf( "Couldn't CreateEvent %ld\n", GetLastError() );
        return 2;
    }


    status = RpcServerUseProtseqEp(pszProtocolSequence,
                                   1, // maximum concurrent calls
                                   pszEndpoint,
                                   0);
    if (status) {
        printf("RpcServerUseProtseqEp returned 0x%x\n", status);
        exit(2);
    }

    status = RpcServerRegisterIf(hello2_v1_0_s_ifspec, 0, 0);
    if (status) {
        printf("RpcServerRegisterIf returned 0x%x\n", status);
        exit(2);
    }

    status = RpcServerRegisterAuthInfo( "HelloS", RPC_C_AUTHN_DCE_PRIVATE, NULL, NULL );
    if (status) {
        printf("RpcServerRegisterAuthInfo returned 0x%x\n", status);
        exit(2);
    }

    printf("Calling RpcServerListen\n");
    status = RpcServerListen(1,12345,1);
    if (status) {
        printf("RpcServerListen returned: 0x%x\n", status);
        exit(2);
    }

    WaitStatus = WaitForSingleObject( TerminateEvent, INFINITE );

    if ( WaitStatus != WAIT_OBJECT_0 ) {
        printf( "Couldn't WaitForSingleObject %ld %ld\n", WaitStatus, GetLastError() );
        return 2;
    }

    return 0;

} /* end main() */


// ====================================================================
//                MIDL allocate and free
// ====================================================================


void __RPC_FAR * __RPC_API MIDL_user_allocate(size_t len)
{
    return(malloc(len));
}

void __RPC_API MIDL_user_free(void __RPC_FAR * ptr)
{
    free(ptr);
}

/*
    PURPOSE:    Remote procedures that are linked with the server
                side of RPC distributed application
    FUNCTIONS:  HelloProc() - prints "hello, world" or other string
                sent by client to server
    COMMENTS:
    This version of the distributed application that prints
    "hello, world" (or other string) on the server features a client
    that manages its connection to the server. It uses the binding
    handle hello_IfHandle, defined in the file hello.h.
****************************************************************************/

void HelloProc2(unsigned char * pszString)
{
    RPC_STATUS RpcStatus;
    CHAR UserName[100];
    ULONG NameLen = 100;

    RpcStatus = RpcImpersonateClient( NULL );

    if ( RpcStatus != RPC_S_OK ) {
        printf( "RpcImpersonateClient Failed %ld\n", RpcStatus );
    }
    GetUserName(UserName,&NameLen);
    printf("%s: %s\n",UserName, pszString);

    RpcStatus = RpcRevertToSelf();

    if ( RpcStatus != RPC_S_OK ) {
        printf( "RpcRevertToSelf Failed %ld\n", RpcStatus );
    }


}

void Shutdown2(void)
{
    RPC_STATUS status;

    printf("Calling RpcMgmtStopServerListening\n");
    status = RpcMgmtStopServerListening(NULL);
    if (status) {
        printf("RpcMgmtStopServerListening returned: 0x%x\n", status);
        exit(2);
    }

    printf("Calling RpcServerUnregisterIf\n");
    status = RpcServerUnregisterIf(NULL, NULL, FALSE);
    if (status) {
        printf("RpcServerUnregisterIf returned 0x%x\n", status);
        exit(2);
    }

    if ( !SetEvent( TerminateEvent) ) {
        printf( "Couldn't SetEvent %ld\n", GetLastError() );
    }

}

/* end hellos.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\utest\hello3\server\hello2c.c ===
/****************************************************************************
           Microsoft RPC Version 1`1
         Copyright Microsoft Corp. 1992
                Hello Example

    FILE:   helloc.c
    USAGE:   client    -n network_address
          -p protocol_sequence
          -e endpoint
          -o options
          -u uuid

    PURPOSE:   Client side of RPC distributed application
    FUNCTIONS:   main() - binds to server and calls remote procedure
    COMMENTS:
    This distributed application prints a string such as "hello, world"
    on the server. The client manages its connection to the server.
    The client uses the binding handle hello_IfHandle defined in the
    file hello.h.

****************************************************************************/
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <rpc.h>       // RPC API functions, types
#include "hello2.h"     // header file generated by MIDL compiler


int __cdecl
hello2_main (argc, argv)
    int argc;
    char *argv[];
{
    RPC_STATUS status;             // returned by RPC API function
    unsigned char * pszUuid = "12345678-1234-1234-1234-123456789ABD";
    unsigned char * pszProtocolSequence = "ncacn_ip_tcp";
    unsigned char * pszNetworkAddress   = NULL;
    unsigned char * pszEndpoint    = "760";
    unsigned char * pszOptions          = NULL;
    unsigned char * pszStringBinding   = NULL;
    unsigned char * pszString      = "hello, world";
    int i;

    // allow the user to override settings with command line switches
    for (i = 1; i < argc; i++) {
        if ((*argv[i] == '-') || (*argv[i] == '/')) {
            switch (tolower(*(argv[i]+1))) {
            case 'p':  // protocol sequence
                pszProtocolSequence = argv[++i];
                break;
            case 'n':  // network address
                pszNetworkAddress = argv[++i];
                break;
            case 'e':
                pszEndpoint = argv[++i];
                break;
            case 'o':
                pszOptions = argv[++i];
                break;
            case 'u':
                pszUuid = argv[++i];
                break;
            case 's':
                pszString = argv[++i];
                break;
            case 'h':
            case '?':
            default:
                Usage(argv[0]);
            }
        } else {
            Usage(argv[0]);
        }
    }


    // Use a convenience function to concatenate the elements of
    // the string binding into the proper sequence.

    status = RpcStringBindingCompose(pszUuid,
                                     pszProtocolSequence,
                                     pszNetworkAddress,
                                     pszEndpoint,
                                     pszOptions,
                                     &pszStringBinding);

    if (status) {
        printf("RpcStringBindingCompose returned 0x%x\n", status);
        exit(2);
    }
    printf("pszStringBinding = %s\n", pszStringBinding);



    //
    // Set the binding handle that will be used to bind to the server.
    //

    status = RpcBindingFromStringBinding(pszStringBinding,
                &hello2_IfHandle);
    if (status) {
        printf("RpcBindingFromStringBinding returned 0x%x\n", status);
        exit(2);
    }


    //
    // Tell RPC to do the security thing.
    //

    status = RpcBindingSetAuthInfo(
                    hello2_IfHandle,
                    "makalu\\suzannep",
                    RPC_C_AUTHN_LEVEL_CONNECT,
                    RPC_C_AUTHN_DCE_PRIVATE,
                    NULL,
                    RPC_C_AUTHZ_NAME );

    if ( status ) {
        printf("RpcBindingSetAuthInfo returned %ld\n", status);
        exit(2);
    }


    //
    // Do the actual RPC calls to the server.
    //

    printf("  print the string '%s' on the server\n", pszString);

    RpcTryExcept {
        int i;
        for ( i=0; i<10 ; i++ ) {
            HelloProc2(pszString);    // make call with user message
        }
//        Shutdown2();              // shut down the server side
    } RpcExcept(1) {
        printf("Runtime library reported an exception 0x%lx\n",
               RpcExceptionCode());
    } RpcEndExcept



    // The calls to the remote procedures are complete.
    // Free the string and the binding handle

    status = RpcStringFree(&pszStringBinding);   // remote calls done; unbind
    if (status) {
        printf("RpcStringFree returned 0x%x\n", status);
        exit(2);
    }

    status = RpcBindingFree(&hello2_IfHandle);  // remote calls done; unbind
    if (status) {
        printf("RpcBindingFree returned 0x%x\n", status);
        exit(2);
    }


    return 0;

}

/* end file helloc.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\utest\hello2\client\hello2c.c ===
/****************************************************************************
           Microsoft RPC Version 1`1
         Copyright Microsoft Corp. 1992
                Hello Example

    FILE:   helloc.c
    USAGE:   client    -n network_address
          -p protocol_sequence
          -e endpoint
          -o options
          -u uuid

    PURPOSE:   Client side of RPC distributed application
    FUNCTIONS:   main() - binds to server and calls remote procedure
    COMMENTS:
    This distributed application prints a string such as "hello, world"
    on the server. The client manages its connection to the server.
    The client uses the binding handle hello_IfHandle defined in the
    file hello.h.

****************************************************************************/
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <rpc.h>       // RPC API functions, types
#include "hello2.h"     // header file generated by MIDL compiler

void Usage(char * pszProgramName)
{
    fprintf(stderr, "Usage:  %s\n", pszProgramName);
    fprintf(stderr, " -p protocol_sequence\n");
    fprintf(stderr, " -n network_address\n");
    fprintf(stderr, " -e endpoint\n");
    fprintf(stderr, " -o options\n");
    fprintf(stderr, " -u uuid\n");
    fprintf(stderr, " -s string\n");
    exit(1);
}

int __cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    RPC_STATUS status;             // returned by RPC API function
    unsigned char * pszUuid = "12345678-1234-1234-1234-123456789ABD";
    unsigned char * pszProtocolSequence = "ncacn_ip_tcp";
    unsigned char * pszNetworkAddress   = NULL;
    unsigned char * pszEndpoint    = "760";
    unsigned char * pszOptions          = NULL;
    unsigned char * pszStringBinding   = NULL;
    unsigned char * pszString      = "hello, world";
    int i;

    // allow the user to override settings with command line switches
    for (i = 1; i < argc; i++) {
        if ((*argv[i] == '-') || (*argv[i] == '/')) {
            switch (tolower(*(argv[i]+1))) {
            case 'p':  // protocol sequence
                pszProtocolSequence = argv[++i];
                break;
            case 'n':  // network address
                pszNetworkAddress = argv[++i];
                break;
            case 'e':
                pszEndpoint = argv[++i];
                break;
            case 'o':
                pszOptions = argv[++i];
                break;
            case 'u':
                pszUuid = argv[++i];
                break;
            case 's':
                pszString = argv[++i];
                break;
            case 'h':
            case '?':
            default:
                Usage(argv[0]);
            }
        } else {
            Usage(argv[0]);
        }
    }


    // Use a convenience function to concatenate the elements of
    // the string binding into the proper sequence.

    status = RpcStringBindingCompose(pszUuid,
                                     pszProtocolSequence,
                                     pszNetworkAddress,
                                     pszEndpoint,
                                     pszOptions,
                                     &pszStringBinding);

    if (status) {
        printf("RpcStringBindingCompose returned 0x%x\n", status);
        exit(2);
    }
    printf("pszStringBinding = %s\n", pszStringBinding);



    //
    // Set the binding handle that will be used to bind to the server.
    //

    status = RpcBindingFromStringBinding(pszStringBinding,
                &hello2_IfHandle);
    if (status) {
        printf("RpcBindingFromStringBinding returned 0x%x\n", status);
        exit(2);
    }


    //
    // Tell RPC to do the security thing.
    //

    status = RpcBindingSetAuthInfo(
                    hello2_IfHandle,
                    "makalu\\mikesw",
                    RPC_C_AUTHN_LEVEL_CONNECT,
                    RPC_C_AUTHN_DCE_PRIVATE,
                    NULL,
                    RPC_C_AUTHZ_NAME );

    if ( status ) {
        printf("RpcBindingSetAuthInfo returned %ld\n", status);
        exit(2);
    }


    //
    // Do the actual RPC calls to the server.
    //

    printf("  print the string '%s' on the server\n", pszString);

    RpcTryExcept {
        int i;
        for ( i=0; i<100 ; i++ ) {
            HelloProc2(pszString);    // make call with user message
        }
        Shutdown2();              // shut down the server side
    } RpcExcept(1) {
        printf("Runtime library reported an exception 0x%lx\n",
               RpcExceptionCode());
    } RpcEndExcept



    // The calls to the remote procedures are complete.
    // Free the string and the binding handle

    status = RpcStringFree(&pszStringBinding);   // remote calls done; unbind
    if (status) {
        printf("RpcStringFree returned 0x%x\n", status);
        exit(2);
    }

    status = RpcBindingFree(&hello2_IfHandle);  // remote calls done; unbind
    if (status) {
        printf("RpcBindingFree returned 0x%x\n", status);
        exit(2);
    }


    return 0;

}

// ====================================================================
//                MIDL allocate and free
// ====================================================================


void __RPC_FAR * __RPC_API MIDL_user_allocate(size_t len)
{
    return(malloc(len));
}

void __RPC_API MIDL_user_free(void __RPC_FAR * ptr)
{
    free(ptr);
}

/* end file helloc.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\utest\hello3\server\hellos.c ===
/****************************************************************************
                          Microsoft RPC Version 1.0
                         Copyright Microsoft Corp. 1992
                                Hello Example

    FILE:       hellos.c
    USAGE:      hellos
    PURPOSE:    Server side of RPC distributed application hello
    FUNCTIONS:  main() - registers server as RPC server
    COMMENTS:
    This distributed application prints "hello, world" on the server.
    This version features a client that manages its connection to
    the server. It uses the binding handle hello_IfHandle that is defined
    in the generated header file hello.h.
****************************************************************************/
#include <stdlib.h>
#include <windows.h>
#include <string.h>
#include <stdio.h>
#include <ctype.h>
#include <rpc.h>    // RPC data structures and APIs
#include "hello.h"    // header file generated by MIDL compiler

int __cdecl
hello2_main (int argc, char *argv[]);

void Usage(char * pszProgramName)
{
    fprintf(stderr, "Usage:  %s\n", pszProgramName);
    fprintf(stderr, " -p protocol_sequence\n");
    fprintf(stderr, " -n network_address\n");
    fprintf(stderr, " -e endpoint\n");
    fprintf(stderr, " -o options\n");
    fprintf(stderr, " -u uuid\n");
    exit(1);
}

HANDLE TerminateEvent;

int __cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    RPC_STATUS status;
    unsigned char * pszUuid = "12345678-1234-1234-1234-123456789ABC";
    unsigned char * pszProtocolSequence = "ncacn_ip_tcp";
    unsigned char * pszNetworkAddress   = NULL;
    unsigned char * pszEndpoint         = "761";
    unsigned char * pszOptions          = NULL;
    unsigned char * pszStringBinding    = NULL;
    int i;
    DWORD WaitStatus;

    // allow the user to override settings with command line switches
    for (i = 1; i < argc; i++) {
        if ((*argv[i] == '-') || (*argv[i] == '/')) {
            switch (tolower(*(argv[i]+1))) {
                case 'p':  // protocol sequence
                    pszProtocolSequence = argv[++i];
                    break;
                case 'n':  // network address
                    pszNetworkAddress = argv[++i];
                    break;
                case 'e':
                    pszEndpoint = argv[++i];
                    break;
                case 'o':
                    pszOptions = argv[++i];
                    break;
                case 'u':
                    pszUuid = argv[++i];
                    break;
                case 'h':
                case '?':
                default:
                    Usage(argv[0]);
            }
        }
        else
            Usage(argv[0]);
    }

    //
    // Create an event to wait on
    //

    TerminateEvent = CreateEvent( NULL,     // No security attributes
                                  TRUE,     // Must be manually reset
                                  FALSE,    // Initially not signaled
                                  NULL );   // No name

    if ( TerminateEvent == NULL ) {
        printf( "Couldn't CreateEvent %ld\n", GetLastError() );
        return 2;
    }


    status = RpcServerUseProtseqEp(pszProtocolSequence,
                                   1, // maximum concurrent calls
                                   pszEndpoint,
                                   0);
    if (status) {
        printf("RpcServerUseProtseqEp returned 0x%x\n", status);
        exit(2);
    }

    status = RpcServerRegisterIf(hello_v1_0_s_ifspec, 0, 0);
    if (status) {
        printf("RpcServerRegisterIf returned 0x%x\n", status);
        exit(2);
    }

    status = RpcServerRegisterAuthInfo( "HelloS", RPC_C_AUTHN_DCE_PRIVATE, NULL, NULL );
    if (status) {
        printf("RpcServerRegisterAuthInfo returned 0x%x\n", status);
        exit(2);
    }

    printf("Calling RpcServerListen\n");
    status = RpcServerListen(1,12345,1);
    if (status) {
        printf("RpcServerListen returned: 0x%x\n", status);
        exit(2);
    }

    WaitStatus = WaitForSingleObject( TerminateEvent, INFINITE );

    if ( WaitStatus != WAIT_OBJECT_0 ) {
        printf( "Couldn't WaitForSingleObject %ld %ld\n", WaitStatus, GetLastError() );
        return 2;
    }

    return 0;

} /* end main() */


// ====================================================================
//                MIDL allocate and free
// ====================================================================


void __RPC_FAR * __RPC_API MIDL_user_allocate(size_t len)
{
    return(malloc(len));
}

void __RPC_API MIDL_user_free(void __RPC_FAR * ptr)
{
    free(ptr);
}

/*
    PURPOSE:    Remote procedures that are linked with the server
                side of RPC distributed application
    FUNCTIONS:  HelloProc() - prints "hello, world" or other string
                sent by client to server
    COMMENTS:
    This version of the distributed application that prints
    "hello, world" (or other string) on the server features a client
    that manages its connection to the server. It uses the binding
    handle hello_IfHandle, defined in the file hello.h.
****************************************************************************/

void HelloProc(unsigned char * pszString)
{
    RPC_STATUS RpcStatus;
    CHAR UserName[100];
    ULONG NameLen = 100;

    char * args[] = {"", "-n", "mikesw5" };

    RpcStatus = RpcImpersonateClient( NULL );

    if ( RpcStatus != RPC_S_OK ) {
        printf( "RpcImpersonateClient Failed %ld\n", RpcStatus );
    }

    GetUserName(UserName,&NameLen);
    printf("%s: %s\n",UserName, pszString);
    hello2_main(3, args);

    RpcStatus = RpcRevertToSelf();

    if ( RpcStatus != RPC_S_OK ) {
        printf( "RpcRevertToSelf Failed %ld\n", RpcStatus );
    }


}

void Shutdown(void)
{
    RPC_STATUS status;

    printf("Calling RpcMgmtStopServerListening\n");
    status = RpcMgmtStopServerListening(NULL);
    if (status) {
        printf("RpcMgmtStopServerListening returned: 0x%x\n", status);
        exit(2);
    }

    printf("Calling RpcServerUnregisterIf\n");
    status = RpcServerUnregisterIf(NULL, NULL, FALSE);
    if (status) {
        printf("RpcServerUnregisterIf returned 0x%x\n", status);
        exit(2);
    }

    if ( !SetEvent( TerminateEvent) ) {
        printf( "Couldn't SetEvent %ld\n", GetLastError() );
    }

}

/* end hellos.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\utest\tlogon\logon32.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       logon32.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    9-30-94   RichardW   Created
//
//----------------------------------------------------------------------------

#undef UNICODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <crypt.h>
#include <mpr.h>
#include <ntlsa.h>
#include <ntmsv1_0.h>
#include <wchar.h>
#include <stdlib.h>
#include <lmcons.h>

#define SECURITY_WIN32
#define SECURITY_KERBEROS
#include <security.h>

//
// We dynamically load mpr.dll (no big surprise there), in order to call
// WNetLogonNotify, as defined in private\inc\mpr.h.  This prototype matches
// it -- consult the header file for all the parameters.
//
typedef (* LOGONNOTIFYFN)(LPCWSTR, PLUID, LPCWSTR, LPVOID,
                            LPCWSTR, LPVOID, LPWSTR, LPVOID, LPWSTR *);

//
// The QuotaLimits are global, because the defaults
// are always used for accounts, based on server/wksta, and no one ever
// calls lsasetaccountquota
//

HANDLE      Logon32LsaHandle = NULL;
ULONG       Logon32MsvHandle = 0xFFFFFFFF;
ULONG       Logon32KerbHandle = 0xFFFFFFFF;
WCHAR       Logon32DomainName[16] = L"";    // NOTE:  This should be DNLEN from
                                            // lmcons.h, but that would be a
                                            // lot of including
QUOTA_LIMITS    Logon32QuotaLimits;
HINSTANCE       Logon32MprHandle = NULL;
LOGONNOTIFYFN   Logon32LogonNotify = NULL;


RTL_CRITICAL_SECTION    Logon32Lock;

#define LockLogon()     RtlEnterCriticalSection( &Logon32Lock )
#define UnlockLogon()   RtlLeaveCriticalSection( &Logon32Lock )


SID_IDENTIFIER_AUTHORITY L32SystemSidAuthority = SECURITY_NT_AUTHORITY;
SID_IDENTIFIER_AUTHORITY L32LocalSidAuthority = SECURITY_LOCAL_SID_AUTHORITY;



#define COMMON_CREATE_SUSPENDED 0x00000001  // Suspended, do not Resume()
#define COMMON_CREATE_PROCESSSD 0x00000002  // Whack the process SD
#define COMMON_CREATE_THREADSD  0x00000004  // Whack the thread SD

#define BaseSetLastNTError(_x_) \
    { \
        ULONG dwErrorCode; \
        dwErrorCode = RtlNtStatusToDosError( (_x_) ); \
        SetLastError( dwErrorCode ); \
    }


//+---------------------------------------------------------------------------
//
//  Function:   Logon32Initialize
//
//  Synopsis:   Initializes the critical section
//
//  Arguments:  [hMod]    --
//              [Reason]  --
//              [Context] --
//
//----------------------------------------------------------------------------
BOOL
Logon32Initialize(
    VOID
    )
{
    NTSTATUS    Status;

    Status = RtlInitializeCriticalSection( &Logon32Lock );
    return( Status == STATUS_SUCCESS );
}


/***************************************************************************\
* CreateLogonSid
*
* Creates a logon sid for a new logon.
*
* If LogonId is non NULL, on return the LUID that is part of the logon
* sid is returned here.
*
* History:
* 12-05-91 Davidc       Created
\***************************************************************************/
PSID
L32CreateLogonSid(
    PLUID LogonId OPTIONAL
    )
{
    NTSTATUS Status;
    ULONG   Length;
    PSID    Sid;
    LUID    Luid;

    //
    // Generate a locally unique id to include in the logon sid
    //

    Status = NtAllocateLocallyUniqueId(&Luid);
    if (!NT_SUCCESS(Status)) {
        return(NULL);
    }


    //
    // Allocate space for the sid and fill it in.
    //

    Length = RtlLengthRequiredSid(SECURITY_LOGON_IDS_RID_COUNT);

    Sid = (PSID)LocalAlloc(LMEM_FIXED, Length);

    if (Sid != NULL) {

        RtlInitializeSid(Sid, &L32SystemSidAuthority, SECURITY_LOGON_IDS_RID_COUNT);

        ASSERT(SECURITY_LOGON_IDS_RID_COUNT == 3);

        *(RtlSubAuthoritySid(Sid, 0)) = SECURITY_LOGON_IDS_RID;
        *(RtlSubAuthoritySid(Sid, 1 )) = Luid.HighPart;
        *(RtlSubAuthoritySid(Sid, 2 )) = Luid.LowPart;
    }


    //
    // Return the logon LUID if required.
    //

    if (LogonId != NULL) {
        *LogonId = Luid;
    }

    return(Sid);
}


/*******************************************************************

    NAME:       GetDefaultDomainName

    SYNOPSIS:   Fills in the given array with the name of the default
                domain to use for logon validation.

    ENTRY:      pszDomainName - Pointer to a buffer that will receive
                    the default domain name.

                cchDomainName - The size (in charactesr) of the domain
                    name buffer.

    RETURNS:    TRUE if successful, FALSE if not.

    HISTORY:
        KeithMo     05-Dec-1994 Created.
        RichardW    10-Jan-95   Liberated from sockets and stuck in base

********************************************************************/
BOOL
L32GetDefaultDomainName(
    PUNICODE_STRING     pDomainName
    )
{
    OBJECT_ATTRIBUTES           ObjectAttributes;
    NTSTATUS                    NtStatus;
    INT                         Result;
    DWORD                       err             = 0;
    LSA_HANDLE                  LsaPolicyHandle = NULL;
    PPOLICY_ACCOUNT_DOMAIN_INFO DomainInfo      = NULL;
    PUNICODE_STRING             pDomain;

    if (Logon32DomainName[0] != L'\0')
    {
        RtlInitUnicodeString(pDomainName, Logon32DomainName);
        return(TRUE);
    }
    //
    //  Open a handle to the local machine's LSA policy object.
    //

    InitializeObjectAttributes( &ObjectAttributes,  // object attributes
                                NULL,               // name
                                0L,                 // attributes
                                NULL,               // root directory
                                NULL );             // security descriptor

    NtStatus = LsaOpenPolicy( NULL,                 // system name
                              &ObjectAttributes,    // object attributes
                              POLICY_EXECUTE,       // access mask
                              &LsaPolicyHandle );   // policy handle

    if( !NT_SUCCESS( NtStatus ) )
    {
        BaseSetLastNTError(NtStatus);
        return(FALSE);
    }

    //
    //  Query the domain information from the policy object.
    //
    NtStatus = LsaQueryInformationPolicy( LsaPolicyHandle,
                                          PolicyAccountDomainInformation,
                                          (PVOID *) &DomainInfo );

    if (!NT_SUCCESS(NtStatus))
    {
        BaseSetLastNTError(NtStatus);
        LsaClose(LsaPolicyHandle);
        return(FALSE);
    }


    (void) LsaClose(LsaPolicyHandle);

    //
    // Copy the domain name into our cache, and
    //

    CopyMemory( Logon32DomainName,
                DomainInfo->DomainName.Buffer,
                DomainInfo->DomainName.Length );

    //
    // Null terminate it appropriately
    //

    Logon32DomainName[DomainInfo->DomainName.Length / sizeof(WCHAR)] = L'\0';

    //
    // Clean up
    //
    LsaFreeMemory( (PVOID)DomainInfo );

    //
    // And init the string
    //
    RtlInitUnicodeString(pDomainName, Logon32DomainName);

    return TRUE;

}   // GetDefaultDomainName

//+---------------------------------------------------------------------------
//
//  Function:   L32pInitLsa
//
//  Synopsis:   Initialize connection with LSA
//
//  Arguments:  (none)
//
//  History:    4-21-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
L32pInitLsa(void)
{
    char    MyName[MAX_PATH];
    char *  ModuleName;
    STRING  LogonProcessName;
    STRING  PackageName;
    ULONG   dummy;
    NTSTATUS Status;
    BOOLEAN WasEnabled;

    Status = RtlAdjustPrivilege(SE_TCB_PRIVILEGE, TRUE, FALSE, &WasEnabled);
    if (!NT_SUCCESS(Status))
    {
        BaseSetLastNTError(Status);
        return(FALSE);
    }

    GetModuleFileNameA(NULL, MyName, MAX_PATH);
    ModuleName = strrchr(MyName, '\\');
    if (!ModuleName)
    {
        ModuleName = MyName;
    }


    //
    // Hookup to the LSA and locate our authentication package.
    //

    RtlInitString(&LogonProcessName, ModuleName);
    Status = LsaRegisterLogonProcess(
                 &LogonProcessName,
                 &Logon32LsaHandle,
                 &dummy
                 );


    //
    // Turn off the privilege now.
    //
    if (!WasEnabled)
    {
        (VOID) RtlAdjustPrivilege(SE_TCB_PRIVILEGE, FALSE, FALSE, &WasEnabled);
    }

    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return(FALSE);
    }


    //
    // Connect with the MSV1_0 authentication package
    //
    RtlInitString(&PackageName, "MICROSOFT_AUTHENTICATION_PACKAGE_V1_0");
    Status = LsaLookupAuthenticationPackage (
                Logon32LsaHandle,
                &PackageName,
                &Logon32MsvHandle
                );

    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        (VOID) LsaDeregisterLogonProcess( Logon32LsaHandle );
        Logon32LsaHandle = NULL;
        return(FALSE);
    }

    //
    // Connect with the Kerberos authentication package
    //
    RtlInitString(&PackageName, MICROSOFT_KERBEROS_NAME_A);
    Status = LsaLookupAuthenticationPackage (
                Logon32LsaHandle,
                &PackageName,
                &Logon32KerbHandle
                );

    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        (VOID) LsaDeregisterLogonProcess( Logon32LsaHandle );
        Logon32LsaHandle = NULL;
        return(FALSE);
    }

    return(TRUE);
}

//+---------------------------------------------------------------------------
//
//  Function:   L32pNotifyMpr
//
//  Synopsis:   Loads the MPR DLL and notifies the network providers (like
//              csnw) so they know about this logon session and the credentials
//
//  Arguments:  [NewLogon] -- New logon information
//              [LogonId]  -- Logon ID
//
//  History:    4-24-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
L32pNotifyMpr(
    PMSV1_0_INTERACTIVE_LOGON   NewLogon,
    PLUID                       LogonId
    )
{
    MSV1_0_INTERACTIVE_LOGON    OldLogon;
    LPWSTR                      LogonScripts;
    DWORD                       status;

    if ( Logon32MprHandle == NULL )
    {
        LockLogon();

        if ( Logon32MprHandle == NULL)
        {
            Logon32MprHandle =  LoadLibrary("mpr.dll");
            if (Logon32MprHandle != NULL) {

                Logon32LogonNotify = (LOGONNOTIFYFN) GetProcAddress(
                                        Logon32MprHandle,
                                        "WNetLogonNotify");

            }
        }

        UnlockLogon();

    }

    if ( Logon32LogonNotify != NULL )
    {


        CopyMemory(&OldLogon, NewLogon, sizeof(OldLogon));

        status = Logon32LogonNotify(
                        L"Windows NT Network Provider",
                        LogonId,
                        L"MSV1_0:Interactive",
                        (LPVOID)NewLogon,
                        L"MSV1_0:Interactive",
                        (LPVOID)&OldLogon,
                        L"SvcCtl",          // StationName
                        NULL,               // StationHandle
                        &LogonScripts);     // LogonScripts

        if (status == NO_ERROR) {
            if (LogonScripts != NULL ) {
                (void) LocalFree(LogonScripts);
            }
        }

        return( TRUE );
    }

    return( FALSE );
}

//+---------------------------------------------------------------------------
//
//  Function:   L32pLogonUser
//
//  Synopsis:   Wraps up the call to LsaLogonUser
//
//  Arguments:  [LsaHandle]             --
//              [AuthenticationPackage] --
//              [LogonType]             --
//              [UserName]              --
//              [Domain]                --
//              [Password]              --
//              [LogonSid]              --
//              [LogonId]               --
//              [LogonToken]            --
//              [Quotas]                --
//              [pProfileBuffer]        --
//              [pProfileBufferLength]  --
//              [pSubStatus]            --
//
//  History:    4-24-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
L32pLogonUser(
    IN HANDLE LsaHandle,
    IN ULONG AuthenticationPackage,
    IN SECURITY_LOGON_TYPE LogonType,
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING Domain,
    IN PUNICODE_STRING Password,
    IN PSID LogonSid,
    OUT PLUID LogonId,
    OUT PHANDLE LogonToken,
    OUT PQUOTA_LIMITS Quotas,
    OUT PVOID *pProfileBuffer,
    OUT PULONG pProfileBufferLength,
    OUT PNTSTATUS pSubStatus
    )
{
    NTSTATUS Status;
    STRING OriginName;
    TOKEN_SOURCE SourceContext;
    PMSV1_0_INTERACTIVE_LOGON MsvAuthInfo;
    PKERB_INTERACTIVE_LOGON KerbAuthInfo;
    PMSV1_0_LM20_LOGON MsvNetAuthInfo;
    PVOID AuthInfoBuf;
    ULONG AuthInfoSize;
    PTOKEN_GROUPS TokenGroups;
    PSID LocalSid;
    WCHAR ComputerName[ MAX_COMPUTERNAME_LENGTH + 1 ];
    DWORD ComputerNameLength;

    union {
        LUID            Luid;
        NT_CHALLENGE    NtChallenge;
    } Challenge;

    NT_OWF_PASSWORD PasswordHash;
    OEM_STRING  LmPassword;
    UCHAR       LmPasswordBuf[ LM20_PWLEN + 1 ];
    LM_OWF_PASSWORD LmPasswordHash;


#if DBG
    if (!RtlValidSid(LogonSid))
    {
        return(STATUS_INVALID_PARAMETER);
    }
#endif

    //
    // Initialize source context structure
    //

    strncpy(SourceContext.SourceName, "Advapi  ", sizeof(SourceContext.SourceName)); // LATER from res file

    Status = NtAllocateLocallyUniqueId(&SourceContext.SourceIdentifier);

    if (!NT_SUCCESS(Status)) {
        return(Status);
    }



    //
    // Set logon origin
    //

    RtlInitString(&OriginName, "LogonUser API");


    //
    // For network logons, do the magic.
    //

    if (AuthenticationPackage == Logon32MsvHandle)
    {
        if ( LogonType == Network )
        {
            ComputerNameLength = MAX_COMPUTERNAME_LENGTH + 1;

            if (!GetComputerNameW( ComputerName, &ComputerNameLength ) )
            {
                return( STATUS_INVALID_PARAMETER );
            }

            AuthInfoSize = sizeof( MSV1_0_LM20_LOGON ) +
                            sizeof( WCHAR ) * ( wcslen( UserName->Buffer ) + 1 +
                                                wcslen( Domain->Buffer ) + 1 +
                                                ComputerNameLength + 1) +
                                                NT_RESPONSE_LENGTH +
                                                LM_RESPONSE_LENGTH ;

            MsvNetAuthInfo = AuthInfoBuf = RtlAllocateHeap( RtlProcessHeap(),
                                                            HEAP_ZERO_MEMORY,
                                                            AuthInfoSize );

            if ( !MsvNetAuthInfo )
            {
                return( STATUS_NO_MEMORY );
            }

            //
            // Start packing in the string
            //

            MsvNetAuthInfo->MessageType = MsV1_0NetworkLogon;

            //
            // Copy the user name into the authentication buffer
            //

            MsvNetAuthInfo->UserName.Length =
                        (USHORT)sizeof(WCHAR)*wcslen(UserName->Buffer);
            MsvNetAuthInfo->UserName.MaximumLength =
                        MsvNetAuthInfo->UserName.Length + sizeof(WCHAR);

            MsvNetAuthInfo->UserName.Buffer = (PWSTR)(MsvNetAuthInfo+1);
            wcscpy(MsvNetAuthInfo->UserName.Buffer, UserName->Buffer);


            //
            // Copy the domain name into the authentication buffer
            //

            MsvNetAuthInfo->LogonDomainName.Length =
                         (USHORT)sizeof(WCHAR)*wcslen(Domain->Buffer);
            MsvNetAuthInfo->LogonDomainName.MaximumLength =
                         MsvNetAuthInfo->LogonDomainName.Length + sizeof(WCHAR);

            MsvNetAuthInfo->LogonDomainName.Buffer = (PWSTR)
                                         ((PBYTE)(MsvNetAuthInfo->UserName.Buffer) +
                                         MsvNetAuthInfo->UserName.MaximumLength);

            wcscpy(MsvNetAuthInfo->LogonDomainName.Buffer, Domain->Buffer);

            //
            // Copy the workstation name into the buffer
            //

            MsvNetAuthInfo->Workstation.Length = (USHORT)
                                (sizeof(WCHAR) * ComputerNameLength);

            MsvNetAuthInfo->Workstation.MaximumLength =
                                MsvNetAuthInfo->Workstation.Length + sizeof(WCHAR);

            MsvNetAuthInfo->Workstation.Buffer = (PWSTR)
                                ((PBYTE) (MsvNetAuthInfo->LogonDomainName.Buffer) +
                                MsvNetAuthInfo->LogonDomainName.MaximumLength );

            wcscpy( MsvNetAuthInfo->Workstation.Buffer, ComputerName );

            //
            // Now, generate the bits for the challenge
            //

            Status = NtAllocateLocallyUniqueId( &Challenge.Luid );

            if ( !NT_SUCCESS(Status) )
            {
                RtlFreeHeap( RtlProcessHeap(), 0, MsvNetAuthInfo );

                return( Status );
            }

            RtlCopyMemory(  MsvNetAuthInfo->ChallengeToClient,
                            & Challenge,
                            MSV1_0_CHALLENGE_LENGTH );

            //
            // Set up space for response
            //

            MsvNetAuthInfo->CaseSensitiveChallengeResponse.Buffer = (PUCHAR)
                        ((PBYTE) (MsvNetAuthInfo->Workstation.Buffer) +
                        MsvNetAuthInfo->Workstation.MaximumLength );

            MsvNetAuthInfo->CaseSensitiveChallengeResponse.Length =
                                NT_RESPONSE_LENGTH;

            MsvNetAuthInfo->CaseSensitiveChallengeResponse.MaximumLength =
                                NT_RESPONSE_LENGTH;

            RtlCalculateNtOwfPassword(
                        Password,
                        & PasswordHash );

            RtlCalculateNtResponse(
                    & Challenge.NtChallenge,
                    & PasswordHash,
                    (PNT_RESPONSE) MsvNetAuthInfo->CaseSensitiveChallengeResponse.Buffer );


            //
            // Now do the painful LM compatible hash, so anyone who is maintaining
            // their account from a WfW machine will still have a password.
            //

            LmPassword.Buffer = LmPasswordBuf;
            LmPassword.Length = LmPassword.MaximumLength = LM20_PWLEN + 1;

            Status = RtlUpcaseUnicodeStringToOemString(
                            & LmPassword,
                            Password,
                            FALSE );

            if ( NT_SUCCESS(Status) )
            {

                MsvNetAuthInfo->CaseInsensitiveChallengeResponse.Buffer = (PUCHAR)
                   ((PBYTE) (MsvNetAuthInfo->CaseSensitiveChallengeResponse.Buffer) +
                   MsvNetAuthInfo->CaseSensitiveChallengeResponse.MaximumLength );

                MsvNetAuthInfo->CaseInsensitiveChallengeResponse.Length =
                                LM_RESPONSE_LENGTH;

                MsvNetAuthInfo->CaseInsensitiveChallengeResponse.MaximumLength =
                                LM_RESPONSE_LENGTH;


                RtlCalculateLmOwfPassword(
                            LmPassword.Buffer,
                            & LmPasswordHash );

                ZeroMemory( LmPassword.Buffer, LmPassword.Length );

                RtlCalculateLmResponse(
                            & Challenge.NtChallenge,
                            & LmPasswordHash,
                            (PLM_RESPONSE) MsvNetAuthInfo->CaseInsensitiveChallengeResponse.Buffer );

            }
            else
            {
                //
                // If we're here, the NT (supplied) password is longer than the
                // limit allowed for LM passwords.  NULL out the field, so that
                // MSV knows not to worry about it.
                //

                RtlZeroMemory( &MsvNetAuthInfo->CaseInsensitiveChallengeResponse,
                               sizeof( STRING ) );
            }

        }
        else
        {
            //
            // Build logon structure for non-network logons - service,
            // batch, interactive
            //

            AuthInfoSize = sizeof(MSV1_0_INTERACTIVE_LOGON) +
                sizeof(WCHAR)*(wcslen(UserName->Buffer) + 1 +
                               wcslen(Domain->Buffer)   + 1 +
                               wcslen(Password->Buffer) + 1 );

            MsvAuthInfo = AuthInfoBuf = RtlAllocateHeap(RtlProcessHeap(),
                                                        HEAP_ZERO_MEMORY,
                                                        AuthInfoSize);

            if (MsvAuthInfo == NULL) {
                return(STATUS_NO_MEMORY);
            }

            //
            // This authentication buffer will be used for a logon attempt
            //

            MsvAuthInfo->MessageType = MsV1_0InteractiveLogon;


            //
            // Copy the user name into the authentication buffer
            //

            MsvAuthInfo->UserName.Length =
                        (USHORT)sizeof(WCHAR)*wcslen(UserName->Buffer);
            MsvAuthInfo->UserName.MaximumLength =
                        MsvAuthInfo->UserName.Length + sizeof(WCHAR);

            MsvAuthInfo->UserName.Buffer = (PWSTR)(MsvAuthInfo+1);
            wcscpy(MsvAuthInfo->UserName.Buffer, UserName->Buffer);


            //
            // Copy the domain name into the authentication buffer
            //

            MsvAuthInfo->LogonDomainName.Length =
                         (USHORT)sizeof(WCHAR)*wcslen(Domain->Buffer);
            MsvAuthInfo->LogonDomainName.MaximumLength =
                         MsvAuthInfo->LogonDomainName.Length + sizeof(WCHAR);

            MsvAuthInfo->LogonDomainName.Buffer = (PWSTR)
                                         ((PBYTE)(MsvAuthInfo->UserName.Buffer) +
                                         MsvAuthInfo->UserName.MaximumLength);

            wcscpy(MsvAuthInfo->LogonDomainName.Buffer, Domain->Buffer);

            //
            // Copy the password into the authentication buffer
            // Hide it once we have copied it.  Use the same seed value
            // that we used for the original password in pGlobals.
            //


            MsvAuthInfo->Password.Length =
                         (USHORT)sizeof(WCHAR)*wcslen(Password->Buffer);
            MsvAuthInfo->Password.MaximumLength =
                         MsvAuthInfo->Password.Length + sizeof(WCHAR);

            MsvAuthInfo->Password.Buffer = (PWSTR)
                                         ((PBYTE)(MsvAuthInfo->LogonDomainName.Buffer) +
                                         MsvAuthInfo->LogonDomainName.MaximumLength);

            wcscpy(MsvAuthInfo->Password.Buffer, Password->Buffer);

        }
    }
    else if (AuthenticationPackage == Logon32KerbHandle)
    {
        //
        // Build logon structure for non-network logons - service,
        // batch, interactive
        //

        AuthInfoSize = sizeof(KERB_INTERACTIVE_LOGON) +
            sizeof(WCHAR)*(wcslen(UserName->Buffer) + 1 +
                           wcslen(Domain->Buffer)   + 1 +
                           wcslen(Password->Buffer) + 1 );

        KerbAuthInfo = AuthInfoBuf = RtlAllocateHeap(RtlProcessHeap(),
                                                    HEAP_ZERO_MEMORY,
                                                    AuthInfoSize);

        if (KerbAuthInfo == NULL) {
            return(STATUS_NO_MEMORY);
        }

        //
        // This authentication buffer will be used for a logon attempt
        //

        KerbAuthInfo->MessageType = KerbInteractiveLogon;


        //
        // Copy the user name into the authentication buffer
        //

        KerbAuthInfo->UserName.Length =
                    (USHORT)sizeof(WCHAR)*wcslen(UserName->Buffer);
        KerbAuthInfo->UserName.MaximumLength =
                    KerbAuthInfo->UserName.Length + sizeof(WCHAR);

        KerbAuthInfo->UserName.Buffer = (PWSTR)(KerbAuthInfo+1);
        wcscpy(KerbAuthInfo->UserName.Buffer, UserName->Buffer);


        //
        // Copy the domain name into the authentication buffer
        //

        KerbAuthInfo->LogonDomainName.Length =
                     (USHORT)sizeof(WCHAR)*wcslen(Domain->Buffer);
        KerbAuthInfo->LogonDomainName.MaximumLength =
                     KerbAuthInfo->LogonDomainName.Length + sizeof(WCHAR);

        KerbAuthInfo->LogonDomainName.Buffer = (PWSTR)
                                     ((PBYTE)(KerbAuthInfo->UserName.Buffer) +
                                     KerbAuthInfo->UserName.MaximumLength);

        wcscpy(KerbAuthInfo->LogonDomainName.Buffer, Domain->Buffer);

        //
        // Copy the password into the authentication buffer
        // Hide it once we have copied it.  Use the same seed value
        // that we used for the original password in pGlobals.
        //


        KerbAuthInfo->Password.Length =
                     (USHORT)sizeof(WCHAR)*wcslen(Password->Buffer);
        KerbAuthInfo->Password.MaximumLength =
                     KerbAuthInfo->Password.Length + sizeof(WCHAR);

        KerbAuthInfo->Password.Buffer = (PWSTR)
                                     ((PBYTE)(KerbAuthInfo->LogonDomainName.Buffer) +
                                     KerbAuthInfo->LogonDomainName.MaximumLength);

        wcscpy(KerbAuthInfo->Password.Buffer, Password->Buffer);

    }




    //
    // Create logon token groups
    //

#define TOKEN_GROUP_COUNT   2 // We'll add the local SID and the logon SID

    TokenGroups = (PTOKEN_GROUPS) RtlAllocateHeap(RtlProcessHeap(), 0,
                                    sizeof(TOKEN_GROUPS) +
                  (TOKEN_GROUP_COUNT - ANYSIZE_ARRAY) * sizeof(SID_AND_ATTRIBUTES));

    if (TokenGroups == NULL) {
        RtlFreeHeap(RtlProcessHeap(), 0, AuthInfoBuf);
        return(STATUS_NO_MEMORY);
    }

    //
    // Fill in the logon token group list
    //

    Status = RtlAllocateAndInitializeSid(
                    &L32LocalSidAuthority,
                    1,
                    SECURITY_LOCAL_RID,
                    0, 0, 0, 0, 0, 0, 0,
                    &LocalSid
                    );

    if ( NT_SUCCESS( Status ) )
    {

        TokenGroups->GroupCount = TOKEN_GROUP_COUNT;
        TokenGroups->Groups[0].Sid = LogonSid;
        TokenGroups->Groups[0].Attributes =
                SE_GROUP_MANDATORY | SE_GROUP_ENABLED |
                SE_GROUP_ENABLED_BY_DEFAULT | SE_GROUP_LOGON_ID;
        TokenGroups->Groups[1].Sid = LocalSid;
        TokenGroups->Groups[1].Attributes =
                SE_GROUP_MANDATORY | SE_GROUP_ENABLED |
                SE_GROUP_ENABLED_BY_DEFAULT;

        //
        // Now try to log this on
        //


        Status = LsaLogonUser (
                     LsaHandle,
                     &OriginName,
                     LogonType,
                    AuthenticationPackage,
                    AuthInfoBuf,
                    AuthInfoSize,
                    TokenGroups,
                    &SourceContext,
                    pProfileBuffer,
                    pProfileBufferLength,
                    LogonId,
                    LogonToken,
                    Quotas,
                    pSubStatus
                    );

        RtlFreeSid(LocalSid);

    }

    //
    // Discard token group list
    //

    RtlFreeHeap(RtlProcessHeap(), 0, TokenGroups);

    //
    // Notify all the network providers, if this is a NON network logon
    //

    if ( NT_SUCCESS( Status ) &&
         (LogonType != Network) )
    {
        L32pNotifyMpr(AuthInfoBuf, LogonId);
    }

    //
    // Discard authentication buffer
    //

    RtlFreeHeap(RtlProcessHeap(), 0, AuthInfoBuf);


    return(Status);
}


//+---------------------------------------------------------------------------
//
//  Function:   LogonUserA
//
//  Synopsis:   ANSI wrapper for LogonUserW.  See description below
//
//  Arguments:  [lpszUsername]    --
//              [lpszDomain]      --
//              [lpszPassword]    --
//              [dwLogonType]     --
//              [dwLogonProvider] --
//              [phToken]         --
//
//  History:    4-25-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
WINAPI
KerbLogonUserA(
    LPSTR       lpszUsername,
    LPSTR       lpszDomain,
    LPSTR       lpszPassword,
    DWORD       dwLogonType,
    DWORD       dwLogonProvider,
    HANDLE *    phToken
    )
{
    UNICODE_STRING Username;
    UNICODE_STRING Domain;
    UNICODE_STRING Password;
    NTSTATUS Status;
    BOOL    bRet;


    Username.Buffer = NULL;
    Domain.Buffer = NULL;
    Password.Buffer = NULL;

    Status = RtlCreateUnicodeStringFromAsciiz(&Username, lpszUsername);
    if (!NT_SUCCESS(Status))
    {
        BaseSetLastNTError(Status);
        bRet = FALSE;
        goto Cleanup;
    }
    Status = RtlCreateUnicodeStringFromAsciiz(&Domain, lpszDomain);
    if (!NT_SUCCESS(Status))
    {
        BaseSetLastNTError(Status);
        bRet = FALSE;
        goto Cleanup;
    }

    Status = RtlCreateUnicodeStringFromAsciiz(&Password, lpszPassword);
    if (!NT_SUCCESS(Status))
    {
        BaseSetLastNTError(Status);
        bRet = FALSE;
        goto Cleanup;
    }

    bRet = KerbLogonUserW(
                Username.Buffer,
                Domain.Buffer,
                Password.Buffer,
                dwLogonType,
                dwLogonProvider,
                phToken);

Cleanup:

    if (Username.Buffer)
    {
        RtlFreeUnicodeString(&Username);
    }

    if (Domain.Buffer)
    {
        RtlFreeUnicodeString(&Domain);
    }

    if (Password.Buffer)
    {
        RtlZeroMemory(Password.Buffer, Password.Length);
        RtlFreeUnicodeString(&Password);
    }

    return(bRet);

}


//+---------------------------------------------------------------------------
//
//  Function:   LogonUserW
//
//  Synopsis:   Logs a user on via plaintext password, username and domain
//              name via the LSA.
//
//  Arguments:  [lpszUsername]    -- User name
//              [lpszDomain]      -- Domain name
//              [lpszPassword]    -- Password
//              [dwLogonType]     -- Logon type
//              [dwLogonProvider] -- Provider
//              [phToken]         -- Returned handle to primary token
//
//  History:    4-25-95   RichardW   Created
//
//  Notes:      Requires SeTcbPrivilege, and will enable it if not already
//              present.
//
//----------------------------------------------------------------------------
BOOL
WINAPI
KerbLogonUserW(
    PWSTR       lpszUsername,
    PWSTR       lpszDomain,
    PWSTR       lpszPassword,
    DWORD       dwLogonType,
    DWORD       dwLogonProvider,
    HANDLE *    phToken
    )
{

    NTSTATUS    Status;
    ULONG       PackageId;
    UNICODE_STRING  Username;
    UNICODE_STRING  Domain;
    UNICODE_STRING  Password;
    LUID        LogonId;
    PSID        pLogonSid;
    PVOID       Profile;
    ULONG       ProfileLength;
    NTSTATUS    SubStatus;
    SECURITY_LOGON_TYPE LogonType;


    //
    // Validate the provider
    //
    if (dwLogonProvider == LOGON32_PROVIDER_DEFAULT)
    {
        dwLogonProvider = LOGON32_PROVIDER_WINNT35;
    }

    if (dwLogonProvider > LOGON32_PROVIDER_WINNT40)
    {
        BaseSetLastNTError(STATUS_INVALID_PARAMETER);
        return(FALSE);
    }

    switch (dwLogonType)
    {
        case LOGON32_LOGON_INTERACTIVE:
            LogonType = Interactive;
            break;

        case LOGON32_LOGON_BATCH:
            LogonType = Batch;
            break;

        case LOGON32_LOGON_SERVICE:
            LogonType = Service;
            break;

        case LOGON32_LOGON_NETWORK:
            LogonType = Network;
            break;

        default:
            BaseSetLastNTError(STATUS_INVALID_PARAMETER);
            return(FALSE);
            break;
    }

    //
    // If the MSV handle is -1, grab the lock, and try again:
    //

    if (Logon32MsvHandle == 0xFFFFFFFF)
    {
        LockLogon();

        //
        // If the MSV handle is still -1, init our connection to lsa.  We
        // have the lock, so no other threads can be trying this right now.
        //
        if (Logon32MsvHandle == 0xFFFFFFFF)
        {
            if (!L32pInitLsa())
            {
                return( FALSE );
            }
        }

        UnlockLogon();
    }

    //
    // Validate the parameters.  NULL or empty domain or NULL or empty
    // user name is invalid.
    //

    RtlInitUnicodeString(&Username, lpszUsername);
    if (Username.Length == 0)
    {
        BaseSetLastNTError(STATUS_INVALID_PARAMETER);
        return(FALSE);
    }

    //
    // Initialize the token handle, if the pointer is invalid, then catch
    // the exception now.
    //

    *phToken = NULL;

    //
    // Parse that domain.  Note, if the special token . is passed in for
    // domain, we will use the right value from the LSA, meaning AccountDomain.
    // If the domain is null, the lsa will talk to the local domain, the
    // primary domain, and then on from there...
    //
    if (lpszDomain && *lpszDomain)
    {
        if ((lpszDomain[0] == L'.') &&
            (lpszDomain[1] == L'\0') )
        {
            if (!L32GetDefaultDomainName(&Domain))
            {
                return(FALSE);
            }
        }
        else
            RtlInitUnicodeString(&Domain, lpszDomain);
    }
    else
    {
        RtlInitUnicodeString(&Domain, lpszDomain);
    }

    //
    // Finally, init the password
    //
    RtlInitUnicodeString(&Password, lpszPassword);


    //
    // Get a logon sid to refer to this guy (not that anyone will be able to
    // use it...
    //
    pLogonSid = L32CreateLogonSid(NULL);
    if (!pLogonSid)
    {
        BaseSetLastNTError(STATUS_NO_MEMORY);
        return(FALSE);
    }


    //
    // Attempt the logon
    //

    Status = L32pLogonUser(
                    Logon32LsaHandle,
                    (dwLogonProvider == LOGON32_PROVIDER_WINNT35) ?
                        Logon32MsvHandle : Logon32KerbHandle,
                    LogonType,
                    &Username,
                    &Domain,
                    &Password,
                    pLogonSid,
                    &LogonId,
                    phToken,
                    &Logon32QuotaLimits,
                    &Profile,
                    &ProfileLength,
                    &SubStatus);

    //
    // Done with logon sid, regardless of result:
    //

    LocalFree( pLogonSid );

    if (!NT_SUCCESS(Status))
    {
        if (Status == STATUS_ACCOUNT_RESTRICTION)
        {
            BaseSetLastNTError(SubStatus);
        }
        else
            BaseSetLastNTError(Status);

        return(FALSE);
    }

    if (Profile != NULL)
    {
        LsaFreeReturnBuffer(Profile);
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\utest\hello3\client\helloc.c ===
/****************************************************************************
           Microsoft RPC Version 1`1
         Copyright Microsoft Corp. 1992
                Hello Example

    FILE:   helloc.c
    USAGE:   client    -n network_address
          -p protocol_sequence
          -e endpoint
          -o options
          -u uuid

    PURPOSE:   Client side of RPC distributed application
    FUNCTIONS:   main() - binds to server and calls remote procedure
    COMMENTS:
    This distributed application prints a string such as "hello, world"
    on the server. The client manages its connection to the server.
    The client uses the binding handle hello_IfHandle defined in the
    file hello.h.

****************************************************************************/
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <rpc.h>       // RPC API functions, types
#include "hello.h"     // header file generated by MIDL compiler

void Usage(char * pszProgramName)
{
    fprintf(stderr, "Usage:  %s\n", pszProgramName);
    fprintf(stderr, " -p protocol_sequence\n");
    fprintf(stderr, " -n network_address\n");
    fprintf(stderr, " -e endpoint\n");
    fprintf(stderr, " -o options\n");
    fprintf(stderr, " -u uuid\n");
    fprintf(stderr, " -s string\n");
    exit(1);
}

int __cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    RPC_STATUS status;             // returned by RPC API function
    unsigned char * pszUuid = "12345678-1234-1234-1234-123456789ABC";
    unsigned char * pszProtocolSequence = "ncacn_ip_tcp";
    unsigned char * pszNetworkAddress   = NULL;
    unsigned char * pszEndpoint    = "761";
    unsigned char * pszOptions          = NULL;
    unsigned char * pszStringBinding   = NULL;
    unsigned char * pszString      = "hello, world";
    int i;

    // allow the user to override settings with command line switches
    for (i = 1; i < argc; i++) {
        if ((*argv[i] == '-') || (*argv[i] == '/')) {
            switch (tolower(*(argv[i]+1))) {
            case 'p':  // protocol sequence
                pszProtocolSequence = argv[++i];
                break;
            case 'n':  // network address
                pszNetworkAddress = argv[++i];
                break;
            case 'e':
                pszEndpoint = argv[++i];
                break;
            case 'o':
                pszOptions = argv[++i];
                break;
            case 'u':
                pszUuid = argv[++i];
                break;
            case 's':
                pszString = argv[++i];
                break;
            case 'h':
            case '?':
            default:
                Usage(argv[0]);
            }
        } else {
            Usage(argv[0]);
        }
    }


    // Use a convenience function to concatenate the elements of
    // the string binding into the proper sequence.

    status = RpcStringBindingCompose(pszUuid,
                                     pszProtocolSequence,
                                     pszNetworkAddress,
                                     pszEndpoint,
                                     pszOptions,
                                     &pszStringBinding);

    if (status) {
        printf("RpcStringBindingCompose returned 0x%x\n", status);
        exit(2);
    }
    printf("pszStringBinding = %s\n", pszStringBinding);



    //
    // Set the binding handle that will be used to bind to the server.
    //

    status = RpcBindingFromStringBinding(pszStringBinding,
                &hello_IfHandle);
    if (status) {
        printf("RpcBindingFromStringBinding returned 0x%x\n", status);
        exit(2);
    }


    //
    // Tell RPC to do the security thing.
    //

    status = RpcBindingSetAuthInfo(
                    hello_IfHandle,
                    "makalu\\mikesw",
                    RPC_C_AUTHN_LEVEL_CONNECT,
                    RPC_C_AUTHN_DCE_PRIVATE,
                    NULL,
                    RPC_C_AUTHZ_NAME );

    if ( status ) {
        printf("RpcBindingSetAuthInfo returned %ld\n", status);
        exit(2);
    }


    //
    // Do the actual RPC calls to the server.
    //

    printf("  print the string '%s' on the server\n", pszString);

    RpcTryExcept {
        int i;
        for ( i=0; i<5 ; i++ ) {
            HelloProc(pszString);    // make call with user message
        }
        Shutdown();              // shut down the server side
    } RpcExcept(1) {
        printf("Runtime library reported an exception 0x%lx\n",
               RpcExceptionCode());
    } RpcEndExcept



    // The calls to the remote procedures are complete.
    // Free the string and the binding handle

    status = RpcStringFree(&pszStringBinding);   // remote calls done; unbind
    if (status) {
        printf("RpcStringFree returned 0x%x\n", status);
        exit(2);
    }

    status = RpcBindingFree(&hello_IfHandle);  // remote calls done; unbind
    if (status) {
        printf("RpcBindingFree returned 0x%x\n", status);
        exit(2);
    }


    return 0;

}

// ====================================================================
//                MIDL allocate and free
// ====================================================================


void __RPC_FAR * __RPC_API MIDL_user_allocate(size_t len)
{
    return(malloc(len));
}

void __RPC_API MIDL_user_free(void __RPC_FAR * ptr)
{
    free(ptr);
}

/* end file helloc.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\utest\tlogon\tlogon.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       logon2.c
//
//  Contents:   Logon test app
//
//  Classes:
//
//  Functions:
//
//  History:    6-20-94   richardw   Created
//
//----------------------------------------------------------------------------


#ifdef UNICODE
#undef UNICODE
#endif

#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>

#include <windows.h>

#define DUMP_TOKEN  1
#define DUMP_HEX    2


char *User = NULL;
char *Domain = NULL;
char *Password = NULL;
char *SecPackage = NULL;
char *Cmd = NULL;

DWORD   fLogon = 0;
DWORD   fMe = 0;
DWORD   fService = 0;
DWORD   fCookie = 0;
FILE *  fOut;
DWORD   Threads;
DWORD   fDup = 0;
DWORD   LogonType = LOGON32_LOGON_INTERACTIVE;

char *  ImpLevels[] = { "Anonymous", "Identity", "Impersonation", "Delegation"};

char *  LogonTypes[] = { "Invalid", "Invalid", "Interactive", "Network", "Batch", "Service", "Proxy" };

void DumpToken(HANDLE hToken);

BOOL
WINAPI
KerbLogonUserW(
    PWSTR       lpszUsername,
    PWSTR       lpszDomain,
    PWSTR       lpszPassword,
    DWORD       dwLogonType,
    DWORD       dwLogonProvider,
    HANDLE *    phToken
    );

BOOL
WINAPI
KerbLogonUserA(
    LPSTR       lpszUsername,
    LPSTR       lpszDomain,
    LPSTR       lpszPassword,
    DWORD       dwLogonType,
    DWORD       dwLogonProvider,
    HANDLE *    phToken
    );

BOOL
Logon32Initialize(
    VOID
    );

void
DoArgs(int argc,
        char **argv)

{
    int i;

    Threads = 1;

    if (argc < 3)
    {
        fprintf( fOut,"usage: %s <name> <domain> [-p pw] [-f flags] [-s] [-d] [-x cmd]\n", argv[0]);
        fprintf( fOut,"Tests logon path\n");
        fprintf( fOut," -p     \tOverride password\n");
        fprintf( fOut," -D     \tDump token\n");
        fprintf( fOut," -d     \tduplicate\n");
        fprintf( fOut," -s     \tLogon as service\n");
        fprintf( fOut," -x cmd \tStart cmd as user\n");
        fprintf( fOut," -o file\tSend output to file\n");
        fprintf( fOut," -t #   \tHit with # threads at once\n");
        fprintf( fOut," -l type\tLogon type\n");
        exit(1);
    }

    for (i = 1; i < argc ; i++ )
    {
        if (*argv[i] == '-')
        {
            switch (*(argv[i]+1))
            {
                case 'f':
                    fLogon = atoi(argv[++i]);
                    break;

                case 'd':
                    fDup = 1;
                    break;

                case 'D':
                    fMe |= DUMP_TOKEN;
                    break;

                case 'x':
                    Cmd = argv[++i];
                    break;

                case 'p':
                    Password = argv[++i];
                    break;

                case 't':
                    Threads = atoi(argv[++i]);
                    break;

                case 's':
                    LogonType = LOGON32_LOGON_SERVICE;
                    break;

                case 'l':
                    ++i;
                    if (argv[i] == NULL )
                    {
                        fprintf(fOut, "No logon type specified\n");
                        exit(1);
                    }
                    for (LogonType = 2 ;
                         LogonType < sizeof(LogonTypes) / sizeof(PSTR) ;
                         LogonType ++ )
                    {
                        if (_stricmp( LogonTypes[LogonType], argv[i]) == 0 )
                        {
                            break;
                        }
                    }

                    if (LogonType == (sizeof(LogonTypes) / sizeof(PSTR) ))
                    {
                        fprintf(fOut, "Invalid logon type '%s'\n", argv[i]);
                        exit(1);
                    }
                    break;

                case 'o':
                    fOut = fopen(argv[++i], "w");
                    if (!fOut)
                    {
                        fOut = stderr;
                    }
                    break;

                default:
                    fprintf( fOut,"Invalid switch %s\n", argv[i]);
                    exit(1);
            }
        }
        else
        {
            if (!User)
                User = argv[i];
             else
                if (!Domain)
                    Domain = argv[i];
        }
    }

    if (!Password)
        Password = User;
}

DWORD
DoIt(
    PVOID   pv)
{
    NTSTATUS         scRet, SubStatus, Status;
    PISID                   pSid;
    LUID                    Luid;
    TOKEN_GROUPS            TokenGroups;
    STRING                  sMe;
    HANDLE                  hToken;
    HANDLE                  hImp;
    HANDLE                  hDup;
    STRING                  sPackage;
    ULONG                   Package;
    LUID                    LogonId;
    TOKEN_SOURCE            TokenSource;
    char                    ImpersonateName[MAX_PATH];
    DWORD                   cbImpersonateName = MAX_PATH;
    STARTUPINFO             si;
    PROCESS_INFORMATION     pi;
    POBJECT_TYPE_INFORMATION    pTypeInfo;
    POBJECT_NAME_INFORMATION    pNameInfo;
    POBJECT_BASIC_INFORMATION   pBasicInfo;
    UCHAR   Buffer[1024];
    HANDLE  hWait;

    hWait = (HANDLE) pv;

    if (hWait != NULL)
    {
        WaitForSingleObjectEx( hWait, INFINITE, FALSE );
    }

    fprintf( fOut,"Logging on %s to %s\n", User, Domain);

    //
    // Copy the strings into the right places:
    //

    if (!KerbLogonUserA(User, Domain, Password,
                LogonType,
                LOGON32_PROVIDER_WINNT40, &hToken))
    {
        fprintf( fOut,"FAILED to logon, GetLastError is %d\n", GetLastError());
    }

    else
    {
        if (fMe & DUMP_TOKEN)
            DumpToken(hToken);

        if (!ImpersonateLoggedOnUser(hToken))
        {
            fprintf( fOut, "FAILED to impersonate, GetLastError is %d\n", GetLastError());
        }

        GetUserName(ImpersonateName, &cbImpersonateName);
        if (fDup)
        {
            if (OpenThreadToken( GetCurrentThread(),
                            MAXIMUM_ALLOWED,
                            TRUE,
                            &hImp))
            {
                DumpToken( hImp );
                if (DuplicateTokenEx(   hImp,
                                        MAXIMUM_ALLOWED,
                                        NULL,
                                        SecurityImpersonation,
                                        TokenPrimary,
                                        &hDup ) )
                {
                    fprintf( fOut, "Success!  Duplicated that token!\n");
                    DumpToken( hToken );
                    CloseHandle( hToken );
                }
                else
                {
                    fprintf( fOut, "DuplicateTokenEx FAILED, %d\n", GetLastError() );

                }

                CloseHandle( hImp );

            }
            else
            {
                fprintf( fOut, "OpenThreadToken FAILED, %d\n", GetLastError() );
            }

        }
        RevertToSelf();
        fprintf( fOut,"Hey look!  I'm %s\n", ImpersonateName);

        if (Cmd)
        {
            fprintf( fOut,"Starting '%s' as user\n", Cmd);
            ZeroMemory(&si, sizeof(si));
            si.cb = sizeof(si);
            if (!CreateProcessAsUser(hToken, NULL, Cmd, NULL, NULL, FALSE,
                                CREATE_SEPARATE_WOW_VDM, NULL,
                                NULL, &si, &pi))
            {
                fprintf( fOut,"FAILED, %d\n", GetLastError());
            }

            fprintf( fOut,"Process Info:\n");
            fprintf( fOut,"  Process Handle    \t%x\n", pi.hProcess );
            fprintf( fOut,"  Thread Handle     \t%x\n", pi.hThread );
            fprintf( fOut,"  Process Id        \t%d\n", pi.dwProcessId );
            fprintf( fOut,"  Thread Id         \t%d\n", pi.dwThreadId );

            ZeroMemory( Buffer, 1024 );
#ifdef notdef

            pTypeInfo = (POBJECT_TYPE_INFORMATION) Buffer;
            pNameInfo = (POBJECT_NAME_INFORMATION) Buffer;
            pBasicInfo = (POBJECT_BASIC_INFORMATION) Buffer;

            Status = NtQueryObject( pi.hProcess, ObjectTypeInformation, pTypeInfo, 1024, NULL );

            if (NT_SUCCESS(Status))
            {
                fprintf( fOut,"  Type         \t%ws\n", pTypeInfo->TypeName.Buffer );
            }

            ZeroMemory( Buffer, 1024 );
            Status = NtQueryObject(pi.hProcess, ObjectBasicInformation, pBasicInfo, 1024, NULL);
            if (NT_SUCCESS(Status))
            {
                fprintf( fOut,"  Attributes   \t%#x\n", pBasicInfo->Attributes );
                fprintf( fOut,"  GrantedAccess\t%#x\n", pBasicInfo->GrantedAccess );
                fprintf( fOut,"  HandleCount  \t%d\n", pBasicInfo->HandleCount );
                fprintf( fOut,"  PointerCount \t%d\n", pBasicInfo->PointerCount );
            }
            else
            {
                fprintf( fOut,"FAILED %x to query basic info\n", Status );
            }

            ZeroMemory( Buffer, 1024 );
            Status = NtQueryObject( pi.hProcess, ObjectNameInformation, pNameInfo, 1024, NULL );

            if (NT_SUCCESS(Status))
            {
                fprintf( fOut,"  Name         \t%ws\n", pNameInfo->Name.Buffer);
            }
            else
            {
                fprintf( fOut,"FAILED %x to query name info\n", Status );
            }
#endif
            CloseHandle( pi.hProcess );
            CloseHandle( pi.hThread );

        }
        CloseHandle(hToken);

    }



    return(0);

}


__cdecl
main (int argc, char *argv[])
{
    HANDLE  hWait;
    DWORD   i;
    DWORD   tid;
    HANDLE  hThreads[64];

    fOut = stdout;

    Logon32Initialize();

    //
    // Get params
    //
    DoArgs(argc, argv);

    if (Threads == 1)
    {
        DoIt(NULL);

    }
    else
    {
        if (Threads > 64 )
        {
            Threads = 64;
        }

        hWait = CreateEvent( NULL, TRUE, FALSE, NULL );

        for (i = 0; i < Threads ; i++ )
        {
            hThreads[i] = CreateThread( NULL, 0, DoIt, hWait, 0, &tid);
        }

        SetEvent( hWait );

        WaitForMultipleObjectsEx( Threads, hThreads, TRUE, INFINITE, FALSE );

        for ( i = 0 ; i < Threads ; i++ )
        {
            CloseHandle( hThreads[i] );
        }
    }


    return( 0 );
}


#define SATYPE_USER     1
#define SATYPE_GROUP    2
#define SATYPE_PRIV     3


ULONG   PID;

void
DumpSid(PSID    pxSid)
{
    PISID   pSid = pxSid;
    int i, j =0;


    fprintf( fOut,"  S-%d-", pSid->Revision);
    for (i = 0;i < 6 ; i++ )
    {
        if (j)
        {
            fprintf( fOut,"%x", pSid->IdentifierAuthority.Value[i]);
        }
        else
        {
            if (pSid->IdentifierAuthority.Value[i])
            {
                j = 1;
                fprintf( fOut,"%x", pSid->IdentifierAuthority.Value[i]);
            }
        }
        if (i==4)
        {
            j = 1;
        }
    }
    for (i = 0; i < pSid->SubAuthorityCount ; i++ )
    {
        fprintf( fOut,(fMe & DUMP_HEX ? "-%x" : "-%lu"), pSid->SubAuthority[i]);
    }
}

void
DumpSidAttr(PSID_AND_ATTRIBUTES pSA,
            int                 SAType)
{
    DumpSid(pSA->Sid);

    if (SAType == SATYPE_GROUP)
    {
        fprintf( fOut,"\tAttributes - ");
        if (pSA->Attributes & SE_GROUP_MANDATORY)
        {
            fprintf( fOut,"Mandatory ");
        }
        if (pSA->Attributes & SE_GROUP_ENABLED_BY_DEFAULT)
        {
            fprintf( fOut,"Default ");
        }
        if (pSA->Attributes & SE_GROUP_ENABLED)
        {
            fprintf( fOut,"Enabled ");
        }
        if (pSA->Attributes & SE_GROUP_OWNER)
        {
            fprintf( fOut,"Owner ");
        }
        if (pSA->Attributes & SE_GROUP_LOGON_ID)
        {
            fprintf( fOut,"LogonId ");
        }
    }

}

CHAR *  GetPrivName(PLUID   pPriv)
{
    switch (pPriv->LowPart)
    {
        case SE_CREATE_TOKEN_PRIVILEGE:
            return(SE_CREATE_TOKEN_NAME);
        case SE_ASSIGNPRIMARYTOKEN_PRIVILEGE:
            return(SE_ASSIGNPRIMARYTOKEN_NAME);
        case SE_LOCK_MEMORY_PRIVILEGE:
            return(SE_LOCK_MEMORY_NAME);
        case SE_INCREASE_QUOTA_PRIVILEGE:
            return(SE_INCREASE_QUOTA_NAME);
        case SE_UNSOLICITED_INPUT_PRIVILEGE:
            return(SE_UNSOLICITED_INPUT_NAME);
        case SE_TCB_PRIVILEGE:
            return(SE_TCB_NAME);
        case SE_SECURITY_PRIVILEGE:
            return(SE_SECURITY_NAME);
        case SE_TAKE_OWNERSHIP_PRIVILEGE:
            return(SE_TAKE_OWNERSHIP_NAME);
        case SE_LOAD_DRIVER_PRIVILEGE:
            return(SE_LOAD_DRIVER_NAME);
        case SE_SYSTEM_PROFILE_PRIVILEGE:
            return(SE_SYSTEM_PROFILE_NAME);
        case SE_SYSTEMTIME_PRIVILEGE:
            return(SE_SYSTEMTIME_NAME);
        case SE_PROF_SINGLE_PROCESS_PRIVILEGE:
            return(SE_PROF_SINGLE_PROCESS_NAME);
        case SE_INC_BASE_PRIORITY_PRIVILEGE:
            return(SE_INC_BASE_PRIORITY_NAME);
        case SE_CREATE_PAGEFILE_PRIVILEGE:
            return(SE_CREATE_PAGEFILE_NAME);
        case SE_CREATE_PERMANENT_PRIVILEGE:
            return(SE_CREATE_PERMANENT_NAME);
        case SE_BACKUP_PRIVILEGE:
            return(SE_BACKUP_NAME);
        case SE_RESTORE_PRIVILEGE:
            return(SE_RESTORE_NAME);
        case SE_SHUTDOWN_PRIVILEGE:
            return(SE_SHUTDOWN_NAME);
        case SE_DEBUG_PRIVILEGE:
            return(SE_DEBUG_NAME);
        case SE_AUDIT_PRIVILEGE:
            return(SE_AUDIT_NAME);
        case SE_SYSTEM_ENVIRONMENT_PRIVILEGE:
            return(SE_SYSTEM_ENVIRONMENT_NAME);
        case SE_CHANGE_NOTIFY_PRIVILEGE:
            return(SE_CHANGE_NOTIFY_NAME);
        case SE_REMOTE_SHUTDOWN_PRIVILEGE:
            return(SE_REMOTE_SHUTDOWN_NAME);
        default:
            return("Unknown Privilege");
    }
}

void
DumpLuidAttr(PLUID_AND_ATTRIBUTES   pLA,
             int                    LAType)
{
    char *  PrivName;

    fprintf( fOut,"0x%x%08x", pLA->Luid.HighPart, pLA->Luid.LowPart);
    fprintf( fOut," %-32s", GetPrivName(&pLA->Luid));

    if (LAType == SATYPE_PRIV)
    {
        fprintf( fOut,"  Attributes - ");
        if (pLA->Attributes & SE_PRIVILEGE_ENABLED)
        {
            fprintf( fOut,"Enabled ");
        }

        if (pLA->Attributes & SE_PRIVILEGE_ENABLED_BY_DEFAULT)
        {
            fprintf( fOut,"Default ");
        }
    }

}

void
DumpToken(HANDLE    hToken)
{
    PTOKEN_USER         pTUser;
    PTOKEN_GROUPS       pTGroups;
    PTOKEN_PRIVILEGES   pTPrivs;
    PTOKEN_OWNER        pTOwner;
    PTOKEN_PRIMARY_GROUP    pTPrimaryGroup;
    TOKEN_STATISTICS    TStats;
    ULONG               cbInfo;
    ULONG               cbRetInfo;
    NTSTATUS            status;
    DWORD               i;


    pTUser = malloc(256);


    status = GetTokenInformation(   hToken,
                                        TokenUser,
                                        pTUser,
                                        256,
                                        &cbRetInfo);

    if (!NT_SUCCESS(status))
    {
        fprintf( fOut,"FAILED querying token, %#x\n", status);
        return;
    }

    fprintf( fOut,"User\n  ");
    DumpSidAttr(&pTUser->User, SATYPE_USER);

    fprintf( fOut,"\nGroups");
    pTGroups = malloc(4096);
    status = GetTokenInformation(   hToken,
                                        TokenGroups,
                                        pTGroups,
                                        4096,
                                        &cbRetInfo);

    for (i = 0; i < pTGroups->GroupCount ; i++ )
    {
        fprintf( fOut,"\n %02d ", i);
        DumpSidAttr(&pTGroups->Groups[i], SATYPE_GROUP);
    }

    pTPrimaryGroup  = malloc(128);
    status = GetTokenInformation(   hToken,
                                        TokenPrimaryGroup,
                                        pTPrimaryGroup,
                                        128,
                                        &cbRetInfo);

    fprintf( fOut,"\nPrimary Group:\n  ");
    DumpSid(pTPrimaryGroup->PrimaryGroup);

    fprintf( fOut,"\nPrivs\n");
    pTPrivs = malloc(4096);
    status = GetTokenInformation(   hToken,
                                        TokenPrivileges,
                                        pTPrivs,
                                        4096,
                                        &cbRetInfo);

    for (i = 0; i < pTPrivs->PrivilegeCount ; i++ )
    {
        fprintf( fOut,"\n %02d ", i);
        DumpLuidAttr(&pTPrivs->Privileges[i], SATYPE_PRIV);
    }

    status = GetTokenInformation(   hToken,
                                        TokenStatistics,
                                        &TStats,
                                        sizeof(TStats),
                                        &cbRetInfo);

    fprintf( fOut, "\n\nAuth ID  %x:%x\n", TStats.AuthenticationId.HighPart, TStats.AuthenticationId.LowPart);
    fprintf( fOut, "TokenId     %x:%x\n", TStats.TokenId.HighPart, TStats.TokenId.LowPart);
    fprintf( fOut, "TokenType   %s\n", TStats.TokenType == TokenPrimary ? "Primary" : "Impersonation");
    fprintf( fOut, "Imp Level   %s\n", ImpLevels[ TStats.ImpersonationLevel ]);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\utest\ssp\ssptest.c ===
/*--

Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    ssptest.c

Abstract:

    Test program for the NtLmSsp service.

Author:

    28-Jun-1993 (cliffv)

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/


//
// Common include files.
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>
#include <winbase.h>
#include <winsvc.h>     // Needed for service controller APIs
#include <lmcons.h>
#include <lmerr.h>
#include <lmaccess.h>
#include <lmsname.h>
#include <rpc.h>
#include <stdio.h>      // printf
#include <stdlib.h>     // strtoul
#include <netlib.h>     // NetpGetLocalDomainId


#define SECURITY_KERBEROS
#include <security.h>   // General definition of a Security Support Provider

BOOLEAN QuietMode = FALSE; // Don't be verbose
ULONG RecursionDepth = 0;
CredHandle ServerCredHandleStorage;
PCredHandle ServerCredHandle = NULL;
#define MAX_RECURSION_DEPTH 2


VOID
DumpBuffer(
    PVOID Buffer,
    DWORD BufferSize
    )
/*++

Routine Description:

    Dumps the buffer content on to the debugger output.

Arguments:

    Buffer: buffer pointer.

    BufferSize: size of the buffer.

Return Value:

    none

--*/
{
#define NUM_CHARS 16

    DWORD i, limit;
    CHAR TextBuffer[NUM_CHARS + 1];
    LPBYTE BufferPtr = Buffer;


    printf("------------------------------------\n");

    //
    // Hex dump of the bytes
    //
    limit = ((BufferSize - 1) / NUM_CHARS + 1) * NUM_CHARS;

    for (i = 0; i < limit; i++) {

        if (i < BufferSize) {

            printf("%02x ", BufferPtr[i]);

            if (BufferPtr[i] < 31 ) {
                TextBuffer[i % NUM_CHARS] = '.';
            } else if (BufferPtr[i] == '\0') {
                TextBuffer[i % NUM_CHARS] = ' ';
            } else {
                TextBuffer[i % NUM_CHARS] = (CHAR) BufferPtr[i];
            }

        } else {

            printf("  ");
            TextBuffer[i % NUM_CHARS] = ' ';

        }

        if ((i + 1) % NUM_CHARS == 0) {
            TextBuffer[NUM_CHARS] = 0;
            printf("  %s\n", TextBuffer);
        }

    }

    printf("------------------------------------\n");
}


VOID
PrintTime(
    LPSTR Comment,
    TimeStamp ConvertTime
    )
/*++

Routine Description:

    Print the specified time

Arguments:

    Comment - Comment to print in front of the time

    Time - Local time to print

Return Value:

    None

--*/
{
    LARGE_INTEGER LocalTime;

    LocalTime.HighPart = ConvertTime.HighPart;
    LocalTime.LowPart = ConvertTime.LowPart;

    printf( "%s", Comment );

    //
    // If the time is infinite,
    //  just say so.
    //

    if ( LocalTime.HighPart == 0x7FFFFFFF && LocalTime.LowPart == 0xFFFFFFFF ) {
        printf( "Infinite\n" );

    //
    // Otherwise print it more clearly
    //

    } else {

        TIME_FIELDS TimeFields;

        RtlTimeToTimeFields( &LocalTime, &TimeFields );

        printf( "%ld/%ld/%ld %ld:%2.2ld:%2.2ld\n",
                TimeFields.Month,
                TimeFields.Day,
                TimeFields.Year,
                TimeFields.Hour,
                TimeFields.Minute,
                TimeFields.Second );
    }

}

VOID
PrintStatus(
    NET_API_STATUS NetStatus
    )
/*++

Routine Description:

    Print a net status code.

Arguments:

    NetStatus - The net status code to print.

Return Value:

    None

--*/
{
    printf( "Status = %lu 0x%lx", NetStatus, NetStatus );

    switch (NetStatus) {
    case NERR_Success:
        printf( " NERR_Success" );
        break;

    case NERR_DCNotFound:
        printf( " NERR_DCNotFound" );
        break;

    case ERROR_LOGON_FAILURE:
        printf( " ERROR_LOGON_FAILURE" );
        break;

    case ERROR_ACCESS_DENIED:
        printf( " ERROR_ACCESS_DENIED" );
        break;

    case ERROR_NOT_SUPPORTED:
        printf( " ERROR_NOT_SUPPORTED" );
        break;

    case ERROR_NO_LOGON_SERVERS:
        printf( " ERROR_NO_LOGON_SERVERS" );
        break;

    case ERROR_NO_SUCH_DOMAIN:
        printf( " ERROR_NO_SUCH_DOMAIN" );
        break;

    case ERROR_NO_TRUST_LSA_SECRET:
        printf( " ERROR_NO_TRUST_LSA_SECRET" );
        break;

    case ERROR_NO_TRUST_SAM_ACCOUNT:
        printf( " ERROR_NO_TRUST_SAM_ACCOUNT" );
        break;

    case ERROR_DOMAIN_TRUST_INCONSISTENT:
        printf( " ERROR_DOMAIN_TRUST_INCONSISTENT" );
        break;

    case ERROR_BAD_NETPATH:
        printf( " ERROR_BAD_NETPATH" );
        break;

    case ERROR_FILE_NOT_FOUND:
        printf( " ERROR_FILE_NOT_FOUND" );
        break;

    case NERR_NetNotStarted:
        printf( " NERR_NetNotStarted" );
        break;

    case NERR_WkstaNotStarted:
        printf( " NERR_WkstaNotStarted" );
        break;

    case NERR_ServerNotStarted:
        printf( " NERR_ServerNotStarted" );
        break;

    case NERR_BrowserNotStarted:
        printf( " NERR_BrowserNotStarted" );
        break;

    case NERR_ServiceNotInstalled:
        printf( " NERR_ServiceNotInstalled" );
        break;

    case NERR_BadTransactConfig:
        printf( " NERR_BadTransactConfig" );
        break;

    case SEC_E_NO_SPM:
        printf( " SEC_E_NO_SPM" );
        break;
    case SEC_E_BAD_PKGID:
        printf( " SEC_E_BAD_PKGID" ); break;
    case SEC_E_NOT_OWNER:
        printf( " SEC_E_NOT_OWNER" ); break;
    case SEC_E_CANNOT_INSTALL:
        printf( " SEC_E_CANNOT_INSTALL" ); break;
    case SEC_E_INVALID_TOKEN:
        printf( " SEC_E_INVALID_TOKEN" ); break;
    case SEC_E_CANNOT_PACK:
        printf( " SEC_E_CANNOT_PACK" ); break;
    case SEC_E_QOP_NOT_SUPPORTED:
        printf( " SEC_E_QOP_NOT_SUPPORTED" ); break;
    case SEC_E_NO_IMPERSONATION:
        printf( " SEC_E_NO_IMPERSONATION" ); break;
    case SEC_E_LOGON_DENIED:
        printf( " SEC_E_LOGON_DENIED" ); break;
    case SEC_E_UNKNOWN_CREDENTIALS:
        printf( " SEC_E_UNKNOWN_CREDENTIALS" ); break;
    case SEC_E_NO_CREDENTIALS:
        printf( " SEC_E_NO_CREDENTIALS" ); break;
    case SEC_E_MESSAGE_ALTERED:
        printf( " SEC_E_MESSAGE_ALTERED" ); break;
    case SEC_E_OUT_OF_SEQUENCE:
        printf( " SEC_E_OUT_OF_SEQUENCE" ); break;
    case SEC_E_INSUFFICIENT_MEMORY:
        printf( " SEC_E_INSUFFICIENT_MEMORY" ); break;
    case SEC_E_INVALID_HANDLE:
        printf( " SEC_E_INVALID_HANDLE" ); break;
    case SEC_E_NOT_SUPPORTED:
        printf( " SEC_E_NOT_SUPPORTED" ); break;


    }

    printf( "\n" );
}

VOID
ConfigureServiceRoutine(
    VOID
    )
/*++

Routine Description:

    Configure the NtLmSsp Service

Arguments:

    None

Return Value:

    None

--*/
{
    SC_HANDLE ScManagerHandle = NULL;
    SC_HANDLE ServiceHandle = NULL;
    WCHAR ServiceName[MAX_PATH];
    DWORD WinStatus,NetStatus;
    HKEY LsaKey = NULL;
    USER_INFO_1 UserInfo;
    PSID PrimaryDomain = NULL;
    PSID AccountDomain = NULL;

    if (NetpGetLocalDomainId(LOCAL_DOMAIN_TYPE_ACCOUNTS, &AccountDomain) != NERR_Success)
    {
        printf("Failed to get account domain ID\n");
        return;
    }

    if (NetpGetLocalDomainId(LOCAL_DOMAIN_TYPE_PRIMARY, &PrimaryDomain) != NERR_Success)
    {
        printf("Failed to get primary domain ID\n");
        return;
    }


    //
    // First set REDMOND as the preferred domain
    //

    WinStatus = RegOpenKey(
                    HKEY_LOCAL_MACHINE,
                    L"System\\currentcontrolset\\control\\lsa\\MSV1_0",
                    &LsaKey
                    );
    if (WinStatus != 0)
    {
        printf("RegOpenKeyW failed:" );
        PrintStatus(WinStatus);
        goto Cleanup;
    }

    WinStatus = RegSetValueEx(
                    LsaKey,
                    L"PreferredDomain",
                    0,
                    REG_SZ,
                    (PBYTE) L"REDMOND",
                    sizeof(L"REDMOND")
                    );
    RegCloseKey(LsaKey);
    if (WinStatus != 0)
    {
        printf("RegOpenKeyW failed:");
        PrintStatus(WinStatus);
        goto Cleanup;
    }
    //
    // Then add Kerberos as a security package
    //


    WinStatus = RegOpenKey(
                    HKEY_LOCAL_MACHINE,
                    L"System\\currentcontrolset\\control\\lsa",
                    &LsaKey
                    );
    if (WinStatus != 0)
    {
        printf("RegOpenKeyW failed:" );
        PrintStatus(WinStatus);
        goto Cleanup;
    }

    WinStatus = RegSetValueEx(
                    LsaKey,
                    L"Security Packages",
                    0,
                    REG_MULTI_SZ,
                    (PBYTE) L"Kerberos\0",
                    sizeof(L"Kerberos\0")
                    );
    RegCloseKey(LsaKey);
    if (WinStatus != 0)
    {
        printf("RegOpenKeyW failed:");
        PrintStatus(WinStatus);
        goto Cleanup;
    }


    //
    // First add Kerberos as a security package for RPC
    //

    WinStatus = RegOpenKey(
                    HKEY_LOCAL_MACHINE,
                    L"Software\\Microsoft\\Rpc\\SecurityService",
                    &LsaKey
                    );
    if (WinStatus != 0)
    {
        printf("RegOpenKeyW failed:" );
        PrintStatus(WinStatus);
        goto Cleanup;
    }

    WinStatus = RegSetValueEx(
                    LsaKey,
                    L"1",
                    0,
                    REG_SZ,
                    (PBYTE) L"secur32.dll",
                    sizeof(L"secur32.dll")
                    );
    RegCloseKey(LsaKey);
    if (WinStatus != 0)
    {
        printf("RegOpenKeyW failed:");
        PrintStatus(WinStatus);
        goto Cleanup;
    }

    //
    // If we are on a DC (and the primary domain sid == account domain sid)
    // setup the KDC service
    //

    if ((PrimaryDomain) != NULL && RtlEqualSid(PrimaryDomain, AccountDomain))
    {
        //
        // Build the name of the Kerberos service.
        //

        if ( !GetWindowsDirectoryW(
                ServiceName,
                sizeof(ServiceName)/sizeof(WCHAR) ) ) {
            printf( "GetWindowsDirectoryW failed:" );
            PrintStatus( GetLastError() );
            goto Cleanup;
        }

        wcscat( ServiceName, L"\\system32\\lsass.exe" );


        //
        // Open a handle to the Service Controller
        //

        ScManagerHandle = OpenSCManager(
                              NULL,
                              NULL,
                              SC_MANAGER_CREATE_SERVICE );

        if (ScManagerHandle == NULL) {
            printf( "OpenSCManager failed:" );
            PrintStatus( GetLastError() );
            goto Cleanup;
        }

        //
        // If the service already exists,
        //  delete it and start afresh.
        //

        ServiceHandle = OpenService(
                            ScManagerHandle,
                            L"KDC",
                            DELETE );

        if ( ServiceHandle == NULL ) {
            WinStatus = GetLastError();
            if ( WinStatus != ERROR_SERVICE_DOES_NOT_EXIST ) {
                printf( "OpenService failed:" );
                PrintStatus( WinStatus );
                goto Cleanup;
            }
        } else {

            if ( !DeleteService( ServiceHandle ) ) {
                printf( "DeleteService failed:" );
                PrintStatus( GetLastError() );
                goto Cleanup;
            }

            (VOID) CloseServiceHandle(ServiceHandle);
        }

        //
        // Create the service
        //

        ServiceHandle = CreateService(
                            ScManagerHandle,
                            L"KDC",
                            L"Key Distribution Center",
                            SERVICE_QUERY_STATUS | SERVICE_QUERY_CONFIG,
                            SERVICE_WIN32_SHARE_PROCESS,
                            SERVICE_AUTO_START,
                            SERVICE_ERROR_NORMAL,
                            ServiceName,
                            NULL,       // No load order group
                            NULL,       // No Tag Id required
                            L"Netlogon\0rpcss\0afd\0",
                            NULL,       // Run as LocalSystem
                            NULL );     // No password



        if ( ServiceHandle == NULL ) {
            printf( "CreateService failed:" );
            PrintStatus( GetLastError() );
            goto Cleanup;
        }


        //
        // Create the KDC user account
        //

        UserInfo.usri1_name = L"KDC";
        UserInfo.usri1_password = L"KDC";
        UserInfo.usri1_password_age = 0;
        UserInfo.usri1_priv = USER_PRIV_USER;
        UserInfo.usri1_home_dir = NULL;
        UserInfo.usri1_comment = L"Key Distribution Center Service Account";
        UserInfo.usri1_script_path = NULL;
        UserInfo.usri1_flags = UF_SCRIPT;

        NetStatus = NetUserAdd(
                        NULL,
                        1,
                        &UserInfo,
                        NULL
                        );
        if ((NetStatus != NERR_Success) && (NetStatus != NERR_UserExists))
        {
            printf("Failed to create KDC account: %d\n",NetStatus);
        }

    }

Cleanup:
    if (PrimaryDomain != NULL)
    {
        LocalFree(PrimaryDomain);
    }
    if (AccountDomain != NULL)
    {
        LocalFree(AccountDomain);
    }

    if ( ScManagerHandle != NULL ) {
        (VOID) CloseServiceHandle(ScManagerHandle);
    }
    if ( ServiceHandle != NULL ) {
        (VOID) CloseServiceHandle(ServiceHandle);
    }
    return;

}


VOID
TestSspRoutine(
    )
/*++

Routine Description:

    Test base SSP functionality

Arguments:

    None

Return Value:

    None

--*/
{
    SECURITY_STATUS SecStatus;
    SECURITY_STATUS AcceptStatus;
    SECURITY_STATUS InitStatus;
    CredHandle CredentialHandle2;
    CtxtHandle ClientContextHandle;
    CtxtHandle ServerContextHandle;
    TimeStamp Lifetime;
    ULONG ContextAttributes;
    ULONG PackageCount, Index;
    PSecPkgInfo PackageInfo = NULL;
    HANDLE Token = NULL;
    static int Calls;
    ULONG ClientFlags;
    ULONG ServerFlags;
    BOOLEAN AcquiredServerCred = FALSE;
    LPWSTR DomainName = NULL;
    LPWSTR UserName = NULL;
    WCHAR TargetName[100];



    SecBufferDesc NegotiateDesc;
    SecBuffer NegotiateBuffer;

    SecBufferDesc ChallengeDesc;
    SecBuffer ChallengeBuffer;

    SecBufferDesc AuthenticateDesc;
    SecBuffer AuthenticateBuffer;

    SecPkgContext_Sizes ContextSizes;
    SecPkgContext_Lifespan ContextLifespan;
    UCHAR ContextNamesBuffer[sizeof(SecPkgContext_Names)+UNLEN*sizeof(WCHAR)];
    PSecPkgContext_Names ContextNames = (PSecPkgContext_Names) ContextNamesBuffer;

    SecBufferDesc SignMessage;
    SecBuffer SigBuffers[2];
    BYTE    bDataBuffer[20];
    BYTE    bSigBuffer[100];

    NegotiateBuffer.pvBuffer = NULL;
    ChallengeBuffer.pvBuffer = NULL;
    AuthenticateBuffer.pvBuffer = NULL;

    SigBuffers[1].pvBuffer = bSigBuffer;
    SigBuffers[1].cbBuffer = sizeof(bSigBuffer);
    SigBuffers[1].BufferType = SECBUFFER_TOKEN;

    SigBuffers[0].pvBuffer = bDataBuffer;
    SigBuffers[0].cbBuffer = sizeof(bDataBuffer);
    SigBuffers[0].BufferType = SECBUFFER_DATA;
    memset(bDataBuffer,0xeb,sizeof(bDataBuffer));

    SignMessage.pBuffers = SigBuffers;
    SignMessage.cBuffers = 2;
    SignMessage.ulVersion = 0;

    DomainName = _wgetenv(L"USERDOMAIN");
    UserName = _wgetenv(L"USERNAME");


    printf("Recursion depth = %d\n",RecursionDepth);
    //
    // Get info about the security packages.
    //

    SecStatus = EnumerateSecurityPackages( &PackageCount, &PackageInfo );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "EnumerateSecurityPackages failed:" );
        PrintStatus( SecStatus );
        return;
    }

    if ( !QuietMode ) {
        printf( "PackageCount: %ld\n", PackageCount );
        for (Index = 0; Index < PackageCount ; Index++ )
        {
            printf( "Package %d:\n",Index);
            printf( "Name: %ws Comment: %ws\n", PackageInfo[Index].Name, PackageInfo[Index].Comment );
            printf( "Cap: %ld Version: %ld RPCid: %ld MaxToken: %ld\n\n",
                    PackageInfo[Index].fCapabilities,
                    PackageInfo[Index].wVersion,
                    PackageInfo[Index].wRPCID,
                    PackageInfo[Index].cbMaxToken );
        }

    }

    //
    // Get info about the security packages.
    //

    SecStatus = QuerySecurityPackageInfo( L"kerberos", &PackageInfo );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "QuerySecurityPackageInfo failed:" );
        PrintStatus( SecStatus );
        return;
    }

    if ( !QuietMode ) {
        printf( "Name: %ws Comment: %ws\n", PackageInfo->Name, PackageInfo->Comment );
        printf( "Cap: %ld Version: %ld RPCid: %ld MaxToken: %ld\n\n",
                PackageInfo->fCapabilities,
                PackageInfo->wVersion,
                PackageInfo->wRPCID,
                PackageInfo->cbMaxToken );
    }



    //
    // Acquire a credential handle for the server side
    //
    if (ServerCredHandle == NULL)
    {

        ServerCredHandle = &ServerCredHandleStorage;
        AcquiredServerCred = TRUE;

        SecStatus = AcquireCredentialsHandle(
                        NULL,           // New principal
                        L"kerberos",    // Package Name
                        SECPKG_CRED_INBOUND,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        ServerCredHandle,
                        &Lifetime );

        if ( SecStatus != STATUS_SUCCESS ) {
            printf( "AcquireCredentialsHandle failed: ");
            PrintStatus( SecStatus );
            return;
        }

        if ( !QuietMode ) {
            printf( "ServerCredHandle: 0x%lx 0x%lx   ",
                    ServerCredHandle->dwLower, ServerCredHandle->dwUpper );
            PrintTime( "Lifetime: ", Lifetime );
        }

    }

    //
    // Acquire a credential handle for the client side
    //



    SecStatus = AcquireCredentialsHandle(
                    NULL,           // New principal
                    L"kerberos",    // Package Name
                    SECPKG_CRED_OUTBOUND,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    &CredentialHandle2,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "AcquireCredentialsHandle failed: " );
        PrintStatus( SecStatus );
        return;
    }


    if ( !QuietMode ) {
        printf( "CredentialHandle2: 0x%lx 0x%lx   ",
                CredentialHandle2.dwLower, CredentialHandle2.dwUpper );
        PrintTime( "Lifetime: ", Lifetime );
    }



    //
    // Get the NegotiateMessage (ClientSide)
    //

    NegotiateDesc.ulVersion = 0;
    NegotiateDesc.cBuffers = 1;
    NegotiateDesc.pBuffers = &NegotiateBuffer;

    NegotiateBuffer.cbBuffer = PackageInfo->cbMaxToken;
    NegotiateBuffer.BufferType = SECBUFFER_TOKEN;
    NegotiateBuffer.pvBuffer = LocalAlloc( 0, NegotiateBuffer.cbBuffer );
    if ( NegotiateBuffer.pvBuffer == NULL ) {
        printf( "Allocate NegotiateMessage failed: 0x%ld\n", GetLastError() );
        return;
    }

    ClientFlags = ISC_REQ_SEQUENCE_DETECT | ISC_REQ_MUTUAL_AUTH | ISC_REQ_USE_DCE_STYLE  | ISC_REQ_DATAGRAM; // | ISC_REQ_DELEGATE;

    if (Calls == 0)
    {
        ClientFlags |= ISC_REQ_IDENTIFY;
    }
    Calls++;

    wcscpy(
        TargetName,
        DomainName
        );
    wcscat(
        TargetName,
        L"\\"
        );
    wcscat(
        TargetName,
        UserName
        );

    InitStatus = InitializeSecurityContext(
                    &CredentialHandle2,
                    NULL,               // No Client context yet
                    TargetName,  // Faked target name
                    ClientFlags,
                    0,                  // Reserved 1
                    SECURITY_NATIVE_DREP,
                    NULL,                  // No initial input token
                    0,                  // Reserved 2
                    &ClientContextHandle,
                    &NegotiateDesc,
                    &ContextAttributes,
                    &Lifetime );

    if ( InitStatus != STATUS_SUCCESS ) {
        if ( !QuietMode || !NT_SUCCESS(InitStatus) ) {
            printf( "InitializeSecurityContext (negotiate): " );
            PrintStatus( InitStatus );
        }
        if ( !NT_SUCCESS(InitStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        printf( "\n\nNegotiate Message:\n" );

        printf( "ClientContextHandle: 0x%lx 0x%lx   Attributes: 0x%lx ",
                ClientContextHandle.dwLower, ClientContextHandle.dwUpper,
                ContextAttributes );
        PrintTime( "Lifetime: ", Lifetime );

        DumpBuffer(  NegotiateBuffer.pvBuffer, NegotiateBuffer.cbBuffer );
    }



#if 0



    //
    // Query as many attributes as possible
    //


    SecStatus = QueryContextAttributes(
                    &ClientContextHandle,
                    SECPKG_ATTR_SIZES,
                    &ContextSizes );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "QueryContextAttributes (sizes): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        printf( "QuerySizes: %ld %ld %ld %ld\n",
                    ContextSizes.cbMaxToken,
                    ContextSizes.cbMaxSignature,
                    ContextSizes.cbBlockSize,
                    ContextSizes.cbSecurityTrailer );
    }

    SecStatus = QueryContextAttributes(
                    &ClientContextHandle,
                    SECPKG_ATTR_NAMES,
                    ContextNamesBuffer );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "QueryContextAttributes (names): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        printf( "QueryNames: %ws\n", ContextNames->sUserName );
    }


    SecStatus = QueryContextAttributes(
                    &ClientContextHandle,
                    SECPKG_ATTR_LIFESPAN,
                    &ContextLifespan );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "QueryContextAttributes (lifespan): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        PrintTime("   Start:", ContextLifespan.tsStart );
        PrintTime("  Expiry:", ContextLifespan.tsExpiry );
    }

#endif



    //
    // Get the ChallengeMessage (ServerSide)
    //

    NegotiateBuffer.BufferType |= SECBUFFER_READONLY;
    ChallengeDesc.ulVersion = 0;
    ChallengeDesc.cBuffers = 1;
    ChallengeDesc.pBuffers = &ChallengeBuffer;

    ChallengeBuffer.cbBuffer = PackageInfo->cbMaxToken;
    ChallengeBuffer.BufferType = SECBUFFER_TOKEN;
    ChallengeBuffer.pvBuffer = LocalAlloc( 0, ChallengeBuffer.cbBuffer );
    if ( ChallengeBuffer.pvBuffer == NULL ) {
        printf( "Allocate ChallengeMessage failed: 0x%ld\n", GetLastError() );
        return;
    }
    ServerFlags = ISC_REQ_SEQUENCE_DETECT | ISC_REQ_DATAGRAM;

    AcceptStatus = AcceptSecurityContext(
                    ServerCredHandle,
                    NULL,               // No Server context yet
                    &NegotiateDesc,
                    ServerFlags,
                    SECURITY_NATIVE_DREP,
                    &ServerContextHandle,
                    &ChallengeDesc,
                    &ContextAttributes,
                    &Lifetime );

    if ( AcceptStatus != STATUS_SUCCESS ) {
        if ( !QuietMode || !NT_SUCCESS(AcceptStatus) ) {
            printf( "AcceptSecurityContext (Challenge): " );
            PrintStatus( AcceptStatus );
        }
        if ( !NT_SUCCESS(AcceptStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        printf( "\n\nChallenge Message:\n" );

        printf( "ServerContextHandle: 0x%lx 0x%lx   Attributes: 0x%lx ",
                ServerContextHandle.dwLower, ServerContextHandle.dwUpper,
                ContextAttributes );
        PrintTime( "Lifetime: ", Lifetime );

        DumpBuffer( ChallengeBuffer.pvBuffer, ChallengeBuffer.cbBuffer );
    }




    if (InitStatus != STATUS_SUCCESS)
    {

        //
        // Get the AuthenticateMessage (ClientSide)
        //

        ChallengeBuffer.BufferType |= SECBUFFER_READONLY;
        AuthenticateDesc.ulVersion = 0;
        AuthenticateDesc.cBuffers = 1;
        AuthenticateDesc.pBuffers = &AuthenticateBuffer;

        AuthenticateBuffer.cbBuffer = PackageInfo->cbMaxToken;
        AuthenticateBuffer.BufferType = SECBUFFER_TOKEN;
        AuthenticateBuffer.pvBuffer = LocalAlloc( 0, AuthenticateBuffer.cbBuffer );
        if ( AuthenticateBuffer.pvBuffer == NULL ) {
            printf( "Allocate AuthenticateMessage failed: 0x%ld\n", GetLastError() );
            return;
        }

        SecStatus = InitializeSecurityContext(
                        NULL,
                        &ClientContextHandle,
                        L"\\\\Frank\\IPC$",     // Faked target name
                        0,
                        0,                      // Reserved 1
                        SECURITY_NATIVE_DREP,
                        &ChallengeDesc,
                        0,                  // Reserved 2
                        &ClientContextHandle,
                        &AuthenticateDesc,
                        &ContextAttributes,
                        &Lifetime );

        if ( SecStatus != STATUS_SUCCESS ) {
            printf( "InitializeSecurityContext (Authenticate): " );
            PrintStatus( SecStatus );
            if ( !NT_SUCCESS(SecStatus) ) {
                return;
            }
        }

        if ( !QuietMode ) {
            printf( "\n\nAuthenticate Message:\n" );

            printf( "ClientContextHandle: 0x%lx 0x%lx   Attributes: 0x%lx ",
                    ClientContextHandle.dwLower, ClientContextHandle.dwUpper,
                    ContextAttributes );
            PrintTime( "Lifetime: ", Lifetime );

            DumpBuffer( AuthenticateBuffer.pvBuffer, AuthenticateBuffer.cbBuffer );
        }

        if (AcceptStatus != STATUS_SUCCESS)
        {

            //
            // Finally authenticate the user (ServerSide)
            //

            AuthenticateBuffer.BufferType |= SECBUFFER_READONLY;

            SecStatus = AcceptSecurityContext(
                            NULL,
                            &ServerContextHandle,
                            &AuthenticateDesc,
                            0,
                            SECURITY_NATIVE_DREP,
                            &ServerContextHandle,
                            NULL,
                            &ContextAttributes,
                            &Lifetime );

            if ( SecStatus != STATUS_SUCCESS ) {
                printf( "AcceptSecurityContext (Challenge): " );
                PrintStatus( SecStatus );
                if ( !NT_SUCCESS(SecStatus) ) {
                    return;
                }
            }

            if ( !QuietMode ) {
                printf( "\n\nFinal Authentication:\n" );

                printf( "ServerContextHandle: 0x%lx 0x%lx   Attributes: 0x%lx ",
                        ServerContextHandle.dwLower, ServerContextHandle.dwUpper,
                        ContextAttributes );
                PrintTime( "Lifetime: ", Lifetime );
                printf(" \n" );
            }
        }

    }

#ifdef notdef
    //
    // Now make a third call to Initialize to check that RPC can
    // reauthenticate.
    //

    AuthenticateBuffer.BufferType = SECBUFFER_TOKEN;


    SecStatus = InitializeSecurityContext(
                    NULL,
                    &ClientContextHandle,
                    L"\\\\Frank\\IPC$",     // Faked target name
                    0,
                    0,                      // Reserved 1
                    SECURITY_NATIVE_DREP,
                    NULL,
                    0,                  // Reserved 2
                    &ClientContextHandle,
                    &AuthenticateDesc,
                    &ContextAttributes,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "InitializeSecurityContext (Re-Authenticate): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }



    //
    // Now try to re-authenticate the user (ServerSide)
    //

    AuthenticateBuffer.BufferType |= SECBUFFER_READONLY;

    SecStatus = AcceptSecurityContext(
                    NULL,
                    &ServerContextHandle,
                    &AuthenticateDesc,
                    0,
                    SECURITY_NATIVE_DREP,
                    &ServerContextHandle,
                    NULL,
                    &ContextAttributes,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "AcceptSecurityContext (Re-authenticate): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }
#endif

    //
    // Impersonate the client (ServerSide)
    //

    SecStatus = ImpersonateSecurityContext( &ServerContextHandle );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "ImpersonateSecurityContext: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    //
    // Do something while impersonating (Access the token)
    //

    {
        NTSTATUS Status;
        HANDLE TokenHandle = NULL;

        //
        // Open the token,
        //

        Status = NtOpenThreadToken(
                    NtCurrentThread(),
                    TOKEN_QUERY,
                    (BOOLEAN) TRUE, // Not really using the impersonation token
                    &TokenHandle );

        if ( !NT_SUCCESS(Status) ) {
            printf( "Access Thread token while impersonating: " );
            PrintStatus( Status );
            return;
        } else {
            (VOID) NtClose( TokenHandle );
        }

    }

    //
    // If delegation is enabled and we are below our recursion depth, try
    // this again.
    //
    if ((ClientFlags & ISC_REQ_DELEGATE) && (++RecursionDepth < MAX_RECURSION_DEPTH))
    {
        TestSspRoutine();
    }

    //
    // RevertToSelf (ServerSide)
    //

//    SecStatus = RevertSecurityContext( &ServerContextHandle );
//
//    if ( SecStatus != STATUS_SUCCESS ) {
//        printf( "RevertSecurityContext: " );
//        PrintStatus( SecStatus );
//        if ( !NT_SUCCESS(SecStatus) ) {
//            return;
//        }
//    }


#ifdef notdef
    //
    // Impersonate the client manually
    //

    SecStatus = QuerySecurityContextToken( &ServerContextHandle,&Token );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "QuerySecurityContextToken: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if (!ImpersonateLoggedOnUser(Token))
    {
        printf("Impersonate logged on user failed: %d\n",GetLastError());
        return;
    }
    //
    // Do something while impersonating (Access the token)
    //

    {
        NTSTATUS Status;
        HANDLE TokenHandle = NULL;
        WCHAR UserName[100];
        ULONG NameLength = 100;

        //
        // Open the token,
        //

        Status = NtOpenThreadToken(
                    NtCurrentThread(),
                    TOKEN_QUERY,
                    (BOOLEAN) TRUE, // Not really using the impersonation token
                    &TokenHandle );

        if ( !NT_SUCCESS(Status) ) {
            printf( "Access Thread token while impersonating: " );
            PrintStatus( Status );
            return;
        } else {
            (VOID) NtClose( TokenHandle );
        }
        if (!GetUserName(UserName, &NameLength))
        {
            printf("Failed to get username: %d\n",GetLastError());
            return;
        }
        else
        {
            printf("Username = %ws\n",UserName);
        }
    }


    //
    // RevertToSelf (ServerSide)
    //

//    if (!RevertToSelf())
//    {
//        printf( "RevertToSelf failed: %d\n ",GetLastError() );
//        return;
//    }
    CloseHandle(Token);
#endif

    //
    // Sign a message
    //

    SecStatus = MakeSignature(
                        &ClientContextHandle,
                        0,
                        &SignMessage,
                        0 );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "MakeSignature: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {

        printf("\n Signature: \n");
        DumpBuffer(SigBuffers[1].pvBuffer,SigBuffers[1].cbBuffer);

    }


    //
    // Verify the signature
    //

    SecStatus = VerifySignature(
                        &ServerContextHandle,
                        &SignMessage,
                        0,
                        0 );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "VerifySignature: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }



    //
    // Sign a message, this time to check if it can detect a change in the
    // message
    //

    SecStatus = MakeSignature(
                        &ClientContextHandle,
                        0,
                        &SignMessage,
                        0 );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "MakeSignature: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {

        printf("\n Signature: \n");
        DumpBuffer(SigBuffers[1].pvBuffer,SigBuffers[1].cbBuffer);

    }

    //
    // Mess up the message to see if VerifySignature works
    //

    bDataBuffer[10] = 0xec;

    //
    // Verify the signature
    //

    SecStatus = VerifySignature(
                        &ServerContextHandle,
                        &SignMessage,
                        0,
                        0 );

    if ( SecStatus != SEC_E_MESSAGE_ALTERED ) {
        printf( "VerifySignature: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    //
    // Delete both contexts.
    //


    SecStatus = DeleteSecurityContext( &ClientContextHandle );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "DeleteSecurityContext failed: " );
        PrintStatus( SecStatus );
        return;
    }

    SecStatus = DeleteSecurityContext( &ServerContextHandle );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "DeleteSecurityContext failed: " );
        PrintStatus( SecStatus );
        return;
    }



    //
    // Free both credential handles
    //

    if (AcquiredServerCred)
    {
        SecStatus = FreeCredentialsHandle( ServerCredHandle );

        if ( SecStatus != STATUS_SUCCESS ) {
            printf( "FreeCredentialsHandle failed: " );
            PrintStatus( SecStatus );
            return;
        }
        ServerCredHandle = NULL;

    }

    SecStatus = FreeCredentialsHandle( &CredentialHandle2 );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "FreeCredentialsHandle failed: " );
        PrintStatus( SecStatus );
        return;
    }


    //
    // Final Cleanup
    //

    if ( NegotiateBuffer.pvBuffer != NULL ) {
        (VOID) LocalFree( NegotiateBuffer.pvBuffer );
    }

    if ( ChallengeBuffer.pvBuffer != NULL ) {
        (VOID) LocalFree( ChallengeBuffer.pvBuffer );
    }

    if ( AuthenticateBuffer.pvBuffer != NULL ) {
        (VOID) LocalFree( AuthenticateBuffer.pvBuffer );
    }
}

VOID
TestLogonRoutine(
    IN LPSTR UserName,
    IN LPSTR DomainName,
    IN LPSTR Password
    )
{
    NTSTATUS Status;
    PKERB_INTERACTIVE_LOGON LogonInfo;
    ULONG LogonInfoSize = sizeof(KERB_INTERACTIVE_LOGON);
    BOOLEAN WasEnabled;
    STRING Name;
    ULONG Dummy;
    HANDLE LogonHandle = NULL;
    ULONG PackageId;
    TOKEN_SOURCE SourceContext;
    PKERB_INTERACTIVE_PROFILE Profile = NULL;
    ULONG ProfileSize;
    LUID LogonId;
    HANDLE TokenHandle = NULL;
    QUOTA_LIMITS Quotas;
    NTSTATUS SubStatus;
    WCHAR UserNameString[100];
    ULONG NameLength = 100;
    PUCHAR Where;

    printf("Logging On %s\\%s %s\n",DomainName, UserName, Password);
    LogonInfoSize += (strlen(UserName) + ((DomainName == NULL)? 0 : strlen(DomainName)) + strlen(Password) + 3 ) * sizeof(WCHAR);

    LogonInfo = (PKERB_INTERACTIVE_LOGON) LocalAlloc(LMEM_ZEROINIT, LogonInfoSize);

    LogonInfo->MessageType = KerbInteractiveLogon;

    RtlInitString(
        &Name,
        UserName
        );

    Where = (PUCHAR) (LogonInfo + 1);

    LogonInfo->UserName.Buffer = (LPWSTR) Where;
    LogonInfo->UserName.MaximumLength = LogonInfoSize;
    RtlAnsiStringToUnicodeString(
        &LogonInfo->UserName,
        &Name,
        FALSE
        );
    Where += LogonInfo->UserName.Length + sizeof(WCHAR);

    RtlInitString(
        &Name,
        DomainName
        );

    LogonInfo->LogonDomainName.Buffer = (LPWSTR) Where;
    LogonInfo->LogonDomainName.MaximumLength = LogonInfoSize;
    RtlAnsiStringToUnicodeString(
        &LogonInfo->LogonDomainName,
        &Name,
        FALSE
        );
    Where += LogonInfo->LogonDomainName.Length + sizeof(WCHAR);

    RtlInitString(
        &Name,
        Password
        );

    LogonInfo->Password.Buffer = (LPWSTR) Where;
    LogonInfo->Password.MaximumLength = LogonInfoSize;
    RtlAnsiStringToUnicodeString(
        &LogonInfo->Password,
        &Name,
        FALSE
        );
    Where += LogonInfo->Password.Length + sizeof(WCHAR);

    LogonInfo->MessageType = KerbInteractiveLogon;
    LogonInfo->Flags = 0;

    //
    // Turn on the TCB privilege
    //

    Status = RtlAdjustPrivilege(SE_TCB_PRIVILEGE, TRUE, FALSE, &WasEnabled);
    if (!NT_SUCCESS(Status))
    {
        printf("Failed to adjust privilege: 0x%x\n",Status);
        return;
    }
    RtlInitString(
        &Name,
        "SspTest"
        );
    Status = LsaRegisterLogonProcess(
                &Name,
                &LogonHandle,
                &Dummy
                );
    if (!NT_SUCCESS(Status))
    {
        printf("Failed to register as a logon process: 0x%x\n",Status);
        return;
    }

    strncpy(
        SourceContext.SourceName,
        "ssptest        ",sizeof(SourceContext.SourceName)
        );
    NtAllocateLocallyUniqueId(
        &SourceContext.SourceIdentifier
        );


    RtlInitString(
        &Name,
        MICROSOFT_KERBEROS_NAME_A
        );
    Status = LsaLookupAuthenticationPackage(
                LogonHandle,
                &Name,
                &PackageId
                );
    if (!NT_SUCCESS(Status))
    {
        printf("Failed to lookup package %Z: 0x%x\n",&Name, Status);
        return;
    }

    //
    // Now call LsaLogonUser
    //

    RtlInitString(
        &Name,
        "ssptest"
        );

    Status = LsaLogonUser(
                LogonHandle,
                &Name,
                Interactive,
                PackageId,
                LogonInfo,
                LogonInfoSize,
                NULL,           // no token groups
                &SourceContext,
                (PVOID *) &Profile,
                &ProfileSize,
                &LogonId,
                &TokenHandle,
                &Quotas,
                &SubStatus
                );
    if (!NT_SUCCESS(Status))
    {
        printf("lsalogonuser failed: 0x%x\n",Status);
        return;
    }
    if (!NT_SUCCESS(SubStatus))
    {
        printf("LsalogonUser failed: substatus = 0x%x\n",SubStatus);
        return;
    }

    ImpersonateLoggedOnUser( TokenHandle );
    GetUserName(UserNameString,&NameLength);
    printf("Username = %ws\n",UserNameString);
    RevertToSelf();
    NtClose(TokenHandle);



}



int __cdecl
main(
    IN int argc,
    IN char ** argv
    )
/*++

Routine Description:

    Drive the NtLmSsp service

Arguments:

    argc - the number of command-line arguments.

    argv - an array of pointers to the arguments.

Return Value:

    Exit status

--*/
{
    LPSTR argument;
    int i;
    ULONG j;
    ULONG Iterations;
    LPSTR UserName,DomainName,Password;




    enum {
        NoAction,
#define TESTSSP_PARAM "/TestSsp"
        TestSsp,
#define CONFIG_PARAM "/ConfigureService"
        ConfigureService,
#define LOGON_PARAM "/Logon"
        TestLogon,
    } Action = NoAction;





    //
    // Loop through the arguments handle each in turn
    //

    for ( i=1; i<argc; i++ ) {

        argument = argv[i];

        //
        // Handle /ConfigureService
        //

        if ( _stricmp( argument, CONFIG_PARAM ) == 0 ) {
            if ( Action != NoAction ) {
                goto Usage;
            }

            Action = ConfigureService;


        } else if ( _stricmp( argument, TESTSSP_PARAM ) == 0 ) {
            if ( Action != NoAction ) {
                goto Usage;
            }

            Action = TestSsp;
            Iterations = 1;


        } else if ( _stricmp( argument, LOGON_PARAM ) == 0 ) {
            if ( Action != NoAction ) {
                goto Usage;
            }

            Action = TestLogon;
            Iterations = 1;

            if (argc < i + 2)
            {
                goto Usage;
            }
            Password = argv[++i];
            UserName = argv[++i];
            if (i < argc)
            {
                DomainName = argv[++i];
            }
            else
            {
                DomainName = NULL;
            }
        }
    }

    //
    // Perform the action requested
    //

    switch ( Action ) {

    case ConfigureService:
        ConfigureServiceRoutine();
        break;

    case TestSsp: {
        for ( j=0; j<Iterations ; j++ ) {
            TestSspRoutine( );
        }
        break;
    }
    case TestLogon : {
            TestLogonRoutine(
                UserName,
                DomainName,
                Password
                );
    }
    }

Usage:
    return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\winnt5\makefile.inc ===
$(O)\kerbevt.h  : ..\kerbevt.mc
    mc -h .\$(O) -r .\$(O) -v ..\kerbevt.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\common2\crypt.c ===
//+-----------------------------------------------------------------------
//
// File:        crypt.c
//
// Contents:    cryptography routines for building EncryptedData structs
//
//
// History:     17-Dec-91,  RichardW    Created
//              25-Feb-92,  RichardW    Revised for CryptoSystems
//
//------------------------------------------------------------------------

#ifndef WIN32_CHICAGO
#include "krbprgma.h"
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <kerbcomm.h>
#include <kerberr.h>
#include <kerbcon.h>
#else // WIN32_CHICAGO
#include <kerb.hxx>
#include <kerbp.h>
#endif // WIN32_CHICAGO


#define CONFOUNDER_SIZE     8
#define CHECKSUM_SIZE       sizeof(CheckSum)



//+-------------------------------------------------------------------------
//
//  Function:   KerbEncryptData
//
//  Synopsis:   shim for KerbEncryptDataEx
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


KERBERR NTAPI
KerbEncryptData(
    OUT PKERB_ENCRYPTED_DATA EncryptedData,
    IN ULONG DataSize,
    IN PUCHAR Data,
    IN ULONG Algorithm,
    IN PKERB_ENCRYPTION_KEY Key
    )
{
    return KerbEncryptDataEx(
                EncryptedData,
                DataSize,
                Data,
                KERB_NO_KEY_VERSION,
                0,              // no usage flags
                Key
                );
}

//+---------------------------------------------------------------------------
//
//  Function:   KerbEncryptDataEx
//
//  Synopsis:   Turns cleartext into cipher text
//
//  Effects:    In place encryption of data
//
//  Arguments:  Data - Contains data to be encrypted
//              DataSize - Contains length of data in bytes
//              KeyVersion - KERB_NO_KEY_VERSION for no key version or kvno for KERB_ENCRYPTED_DATA
//              Algorithm - Algorithm to be used for encryption/checksum
//              UsageFlags - Flags indicating usage (client/serve, encryption/authentication)
//              Key - Key to use for encryption
//
//
//
//  Notes:
//
//----------------------------------------------------------------------------

KERBERR NTAPI
KerbEncryptDataEx(
    OUT PKERB_ENCRYPTED_DATA EncryptedData,
    IN ULONG DataSize,
    IN PUCHAR Data,
    IN ULONG KeyVersion,
    IN ULONG UsageFlags,
    IN PKERB_ENCRYPTION_KEY Key
    )
{
    PCRYPTO_SYSTEM pcsCrypt = NULL;
    PCRYPT_STATE_BUFFER psbCryptBuffer = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

    Status = CDLocateCSystem(Key->keytype, &pcsCrypt);
    if (!NT_SUCCESS(Status))
    {
        return(KDC_ERR_ETYPE_NOTSUPP);
    }

    //
    // Initialize header
    //

    EncryptedData->encryption_type = Key->keytype;

    Status = pcsCrypt->Initialize(
                (PUCHAR) Key->keyvalue.value,
                Key->keyvalue.length,
                UsageFlags,
                &psbCryptBuffer
                );

    if (!NT_SUCCESS(Status))
    {
        return(KRB_ERR_GENERIC);
    }

    Status =  pcsCrypt->Encrypt(
                psbCryptBuffer,
                Data,
                DataSize,
                EncryptedData->cipher_text.value,
                &EncryptedData->cipher_text.length
                );

    (void) pcsCrypt->Discard(&psbCryptBuffer);

    if (!NT_SUCCESS(Status))
    {
        return(KRB_ERR_GENERIC);
    }

    if (KeyVersion != KERB_NO_KEY_VERSION)
    {
        EncryptedData->version = KeyVersion;
        EncryptedData->bit_mask |= version_present;
    }

    return(KDC_ERR_NONE);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbDecryptData
//
//  Synopsis:   Shim for KerbDecryptDataEx with no usage flags
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


KERBERR NTAPI
KerbDecryptData(
    IN PKERB_ENCRYPTED_DATA EncryptedData,
    IN PKERB_ENCRYPTION_KEY pkKey,
    OUT PULONG DataSize,
    OUT PUCHAR Data
    )
{
    return(KerbDecryptDataEx(
            EncryptedData,
            pkKey,
            0,          // no usage flags
            DataSize,
            Data
            ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   KerbDecryptDataEx
//
//  Synopsis:   Decrypts an EncryptedData structure
//
//  Effects:
//
//  Arguments:  [pedData] -- EncryptedData
//              [pkKey]   -- Key to use
//
//  History:    4-16-93   RichardW   Created Comment
//
//----------------------------------------------------------------------------

KERBERR NTAPI
KerbDecryptDataEx(
    IN PKERB_ENCRYPTED_DATA EncryptedData,
    IN PKERB_ENCRYPTION_KEY pkKey,
    IN ULONG UsageFlags,
    OUT PULONG DataSize,
    OUT PUCHAR Data
    )
{
    PCRYPTO_SYSTEM       pcsCrypt = NULL;
    PCRYPT_STATE_BUFFER psbCryptBuffer = NULL;
    NTSTATUS     Status = STATUS_SUCCESS;

    Status = CDLocateCSystem(
                EncryptedData->encryption_type,
                &pcsCrypt
                );
    if (!NT_SUCCESS(Status))
    {
        return(KDC_ERR_ETYPE_NOTSUPP);
    }

    if (EncryptedData->cipher_text.length & (pcsCrypt->BlockSize - 1))
    {
        return(KRB_ERR_GENERIC);
    }


    Status = pcsCrypt->Initialize(
                (PUCHAR) pkKey->keyvalue.value,
                pkKey->keyvalue.length,
                UsageFlags,
                &psbCryptBuffer
                );
    if (!NT_SUCCESS(Status))
    {
        return(KRB_ERR_GENERIC);
    }

    Status = pcsCrypt->Decrypt(
                psbCryptBuffer,
                EncryptedData->cipher_text.value,
                EncryptedData->cipher_text.length,
                Data,
                DataSize
                );

    (VOID) pcsCrypt->Discard(&psbCryptBuffer);

    if (!NT_SUCCESS(Status))
    {
        return(KRB_AP_ERR_MODIFIED);
    }
    else
    {
        return(KDC_ERR_NONE);
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbGetEncryptionOverhead
//
//  Synopsis:   Gets the extra space required for encryption to store the ckecksum
//
//  Effects:
//
//  Arguments:  Algorithm - the algorithm to use
//              Overhead - receives the overhead in bytes
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS or KRB_E_ETYPE_NOSUPP
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KerbGetEncryptionOverhead(
    IN ULONG Algorithm,
    OUT PULONG Overhead,
    OUT OPTIONAL PULONG BlockSize
    )
{
    PCRYPTO_SYSTEM       pcsCrypt;
    NTSTATUS Status = STATUS_SUCCESS;

    Status = CDLocateCSystem(Algorithm, &pcsCrypt);
    if (!NT_SUCCESS(Status))
    {
        return(KDC_ERR_ETYPE_NOTSUPP);
    }
    *Overhead = pcsCrypt->HeaderSize;
    if (ARGUMENT_PRESENT(BlockSize))
    {
        *BlockSize = pcsCrypt->BlockSize;
    }
    return(KDC_ERR_NONE);

}


//+-------------------------------------------------------------------------
//
//  Function:   KerbAllocateEncryptionBuffer
//
//  Synopsis:   Allocates the space required for encryption with a given
//              key
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


KERBERR
KerbAllocateEncryptionBuffer(
    IN ULONG EncryptionType,
    IN ULONG BufferSize,
    OUT PUINT EncryptionBufferSize,
    OUT PBYTE * EncryptionBuffer
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    ULONG EncryptionOverhead = 0;
    ULONG BlockSize = 0;

    KerbErr = KerbGetEncryptionOverhead(
                EncryptionType,
                &EncryptionOverhead,
                &BlockSize
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }


    *EncryptionBufferSize = (UINT) ROUND_UP_COUNT(EncryptionOverhead + BufferSize, BlockSize);

    *EncryptionBuffer =  (PBYTE) MIDL_user_allocate(*EncryptionBufferSize);
    if (*EncryptionBuffer == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
    }

Cleanup:
    return(KerbErr);

}

KERBERR
KerbAllocateEncryptionBufferWrapper(
    IN ULONG EncryptionType,
    IN ULONG BufferSize,
    OUT unsigned long * EncryptionBufferSize,
    OUT PBYTE * EncryptionBuffer
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    unsigned int tempInt = 0;

    KerbErr = KerbAllocateEncryptionBuffer(
                EncryptionType,
                BufferSize,
                &tempInt,
                EncryptionBuffer
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }
    *EncryptionBufferSize = tempInt;

Cleanup:
    return (KerbErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\common2\keygen.c ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        keygen.c
//
// Contents:    Key generation unit, with very random numbers
//
//
// History:     created, 10 Dec 91, richardw
//
//------------------------------------------------------------------------

#ifndef WIN32_CHICAGO
#include "krbprgma.h"
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <kerbcomm.h>
#include <kerberr.h>
#include <kerbcon.h>
#include <dsysdbg.h>
#else // WIN32_CHICAGO
#include <kerb.hxx>
#include <kerbp.h>
#endif // WIN32_CHICAGO


//+---------------------------------------------------------------------------
//
//  Function:   KerbRandomFill
//
//  Synopsis:   Generates random data in the buffer.
//
//  Arguments:  [pbBuffer] --
//              [cbBuffer] --
//
//  History:    5-20-93   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

KERBERR NTAPI
KerbRandomFill( PUCHAR      pbBuffer,
                ULONG       cbBuffer)
{
    if (!CDGenerateRandomBits(pbBuffer, cbBuffer))
    {
        return(KRB_ERR_GENERIC);
    }
    return(KDC_ERR_NONE);
}




//+-----------------------------------------------------------------------
//
// Function:    KerbMakeKey, public
//
// Synopsis:    Create a random desKey
//
// Effects:     fills a desKey with (more or less) cryptographically random
//              bytes.
//
// Arguments:   [EncryptionType]        - Encryption type of key
//              [NewKey] -- Key to create
//
// Returns:     KDC_ERR_NONE or KRB_ERR_GENERIC
//
//
// History:     10 Dec 91   RichardW    Created
//
//------------------------------------------------------------------------

KERBERR NTAPI
KerbMakeKey(
    IN ULONG EncryptionType,
    OUT PKERB_ENCRYPTION_KEY NewKey
    )
{
    KERBERR Status = KDC_ERR_NONE;
    NTSTATUS NtStatus;
    PCRYPTO_SYSTEM CryptoSystem;

    NewKey->keyvalue.value = NULL;

    //
    // Locate the crypto system
    //

    NtStatus = CDLocateCSystem(
                EncryptionType,
                &CryptoSystem
                );
    if (!NT_SUCCESS(NtStatus))
    {
        Status = KDC_ERR_ETYPE_NOTSUPP;
        goto Cleanup;
    }

    NewKey->keyvalue.value = (PUCHAR) MIDL_user_allocate(CryptoSystem->KeySize);
    if (NewKey->keyvalue.value == NULL)
    {
        Status = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    NtStatus = CryptoSystem->RandomKey(
                NULL,   // no seed
                0,      // no seed length
                NewKey->keyvalue.value
                );
    if (!NT_SUCCESS(NtStatus))
    {
        Status = KRB_ERR_GENERIC;
        goto Cleanup;
    }
    NewKey->keyvalue.length = CryptoSystem->KeySize;

    NewKey->keytype = EncryptionType;

Cleanup:
    if (!KERB_SUCCESS(Status) && NewKey->keyvalue.value != NULL)
    {
        MIDL_user_free(NewKey->keyvalue.value);
        NewKey->keyvalue.value = NULL;
    }

    return(Status);
}


//+-----------------------------------------------------------------------
//
// Function:    KerbCreateKeyFromBuffer
//
// Synopsis:    Create a KERB_ENCRYPT_KEY from a buffer
//
// Effects:
//
// Arguments:   NewKey -- Key to create
//              Buffer -- Buffer to create key
//              BufferSize - Length of buffer in bytes
//
// Returns:     KDC_ERR_NONE or KRB_ERR_GENERIC
//
//
// History:     21-May-1996     Created         MikeSw
//
//------------------------------------------------------------------------

KERBERR NTAPI
KerbCreateKeyFromBuffer(
    OUT PKERB_ENCRYPTION_KEY NewKey,
    IN PUCHAR Buffer,
    IN ULONG BufferSize,
    IN ULONG EncryptionType
    )
{

    NewKey->keytype = EncryptionType;
    NewKey->keyvalue.length = BufferSize;
    NewKey->keyvalue.value = (PUCHAR) Buffer;
    return(KDC_ERR_NONE);
}


//+-----------------------------------------------------------------------
//
// Function:    KerbDuplicateKey
//
// Synopsis:    Duplicates a KERB_ENCRYPT_KEY
//
// Effects:     Allocates memory
//
// Arguments:   NewKey -- Key to create
//              Key - key to duplicate
//
// Returns:     KDC_ERR_NONE or KRB_ERR_GENERIC
//
//
// History:     21-May-1996     Created         MikeSw
//
//------------------------------------------------------------------------

KERBERR NTAPI
KerbDuplicateKey(
    OUT PKERB_ENCRYPTION_KEY NewKey,
    IN PKERB_ENCRYPTION_KEY Key
    )
{


    *NewKey = *Key;
    NewKey->keyvalue.value = (PUCHAR) MIDL_user_allocate(Key->keyvalue.length);
    if (NewKey->keyvalue.value == NULL)
    {
        return(KRB_ERR_GENERIC);
    }
    RtlCopyMemory(
        NewKey->keyvalue.value,
        Key->keyvalue.value,
        Key->keyvalue.length
        );
    return(KDC_ERR_NONE);
}



//+-------------------------------------------------------------------------
//
//  Function:   KerbFreeKey
//
//  Synopsis:   Frees a key created by KerbMakeKey or KerbCreateKeyFromBuffer
//
//  Effects:
//
//  Arguments:  Key - the key to free
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KerbFreeKey(
    IN PKERB_ENCRYPTION_KEY Key
    )
{
    if (Key->keyvalue.value != NULL)
    {
        MIDL_user_free(Key->keyvalue.value);
        Key->keyvalue.value = NULL;
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbMakeExportableKey
//
//  Synopsis:   Takes a keytype and makes a new key that uses export-strength
//              encryption from the key
//
//  Effects:    
//
//  Arguments:  
//
//  Requires:
//
//  Returns:    
//
//  Notes:      
//              
//
//--------------------------------------------------------------------------

KERBERR
KerbMakeExportableKey(
    IN ULONG KeyType,
    OUT PKERB_ENCRYPTION_KEY NewKey
    )
{
    KERBERR Status = KDC_ERR_NONE;
    NTSTATUS NtStatus;
    PCRYPTO_SYSTEM CryptoSystem;

    NewKey->keyvalue.value = NULL;

    //
    // Locate the crypto system
    //

    NtStatus = CDLocateCSystem(
                KeyType,
                &CryptoSystem
                );
    if (!NT_SUCCESS(NtStatus) || (CryptoSystem->ExportableEncryptionType == 0))
    {
        Status = KDC_ERR_ETYPE_NOTSUPP;
        goto Cleanup;
    }
    NtStatus = CDLocateCSystem(
                CryptoSystem->ExportableEncryptionType,
                &CryptoSystem
                );
    if (!NT_SUCCESS(NtStatus))
    {
        Status = KDC_ERR_ETYPE_NOTSUPP;
        goto Cleanup;
    }

    NewKey->keyvalue.value = (PUCHAR) MIDL_user_allocate(CryptoSystem->KeySize);
    if (NewKey->keyvalue.value == NULL)
    {
        Status = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    NtStatus = CryptoSystem->RandomKey(
                NULL,   // no seed
                0,      // no seed length
                NewKey->keyvalue.value
                );
    if (!NT_SUCCESS(NtStatus))
    {
        Status = KRB_ERR_GENERIC;
        goto Cleanup;
    }
    NewKey->keyvalue.length = CryptoSystem->KeySize;

    NewKey->keytype = CryptoSystem->EncryptionType;

Cleanup:
    if (!KERB_SUCCESS(Status) && NewKey->keyvalue.value != NULL)
    {
        MIDL_user_free(NewKey->keyvalue.value);
        NewKey->keyvalue.value = NULL;
    }

    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbIsKeyExportable
//
//  Synopsis:   Checks to see if a key is exportable
//
//  Effects:    
//
//  Arguments:  
//
//  Requires:
//
//  Returns:    
//
//  Notes:      
//              
//
//--------------------------------------------------------------------------


BOOLEAN
KerbIsKeyExportable(
    IN PKERB_ENCRYPTION_KEY Key
    )
{

    NTSTATUS NtStatus;
    PCRYPTO_SYSTEM CryptoSystem;
    //
    // Locate the crypto system
    //

    NtStatus = CDLocateCSystem(
                (ULONG) Key->keytype,
                &CryptoSystem
                );
    if (!NT_SUCCESS(NtStatus))
    {
        return(FALSE);
    }

    if ((CryptoSystem->Attributes & CSYSTEM_EXPORT_STRENGTH) != 0)
    {
        return(TRUE);
    }
    else
    {
        return(FALSE);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\common2\kerbscav.cxx ===
//+----------------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2001
//
// File:        kerbscav.cxx
//
// Contents:    Scavenger (task automation) code
//
//
// History:     22-April-2001   Created         MarkPu
//
//-----------------------------------------------------------------------------

#ifndef WIN32_CHICAGO
extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <dsysdbg.h>
}
#else
#include <kerb.hxx>
#include <kerbp.h>
#endif
#include <kerbcomm.h>
#include <kerbscav.h>

//
// FESTER: not a good idea to have these as globals, in case the application
//         would want multiple scavenger instances.  This will do for now.
//

BOOLEAN ScavengerInitialized = FALSE;
RTL_CRITICAL_SECTION ScavengerLock;
HANDLE ScavengerTimerQueue = NULL;
HANDLE ScavengerTimerShutdownEvent = NULL;
LIST_ENTRY ScavengerTaskQueue = {0};
LIST_ENTRY ScavengerDeadPool = {0};
ULONG ScavengerTaskQueueSize = 0;
ULONG ScavengerDeadPoolSize = 0;

#define LockScavengerQueue()   RtlEnterCriticalSection( &ScavengerLock )
#define UnlockScavengerQueue() RtlLeaveCriticalSection( &ScavengerLock )

struct SCAVENGER_TASK
{
    LIST_ENTRY m_ListEntry;

    //
    // Periodicity control code
    //

    DWORD m_InsideTrigger;           // Set to the ID of the callback thread
    BOOLEAN m_Canceled;              // TRUE if task was canceled
    BOOLEAN m_Periodic;              // TRUE if periodic
    LONG m_Interval;                 // recurrence interval, in milliseconds

    //
    // Task management
    //

    HANDLE m_Timer;                  // Timer handle
    ULONG m_Flags;                   // Timer flags (see CreateTimerQueueTimer)
    HANDLE m_ShutdownEvent;          // Shutdown event
    LONG m_Processing;               // Set to TRUE while inside the trigger
    KERB_TASK_TRIGGER m_pfnTrigger;  // Invocation callback
    KERB_TASK_DESTROY m_pfnDestroy;  // Destruction callback
    void * m_Context;                  // User-supplied task context
};

typedef SCAVENGER_TASK * PSCAVENGER_TASK;


// ----------------------------------------------------------------------------
//
// Internal scavenger routines
//
// ----------------------------------------------------------------------------

VOID
ScavengerTimerCallback(
    IN PVOID Parameter,
    IN BOOLEAN Reason
    );


//+----------------------------------------------------------------------------
//
//  Function:   ScavengerFreeTask
//
//  Synopsis:   Task 'destructor'
//
//  Arguments:  Task            - task to be freed
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

void
ScavengerFreeTask(
    IN PSCAVENGER_TASK Task
    )
{
    DsysAssert( Task );

    if ( Task->m_pfnDestroy ) {

        Task->m_pfnDestroy( Task->m_Context );
    }

    NtClose( Task->m_ShutdownEvent );
    MIDL_user_free( Task );

    return;
}


//+----------------------------------------------------------------------------
//
//  Function:   ScavengerPurgeDeadPool
//
//  Synopsis:   Disposes of items in the deadpool
//
//  Arguments:  TaskToAvoid     - Task to leave hanging around (because
//                                it corresponds to the current timer callback)
//                                This parameter can be NULL
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

void
ScavengerPurgeDeadPool(    
    IN OPTIONAL PSCAVENGER_TASK TaskToAvoid
    )
{
    ULONG TasksLeftOver = 0;

    LockScavengerQueue();

    while ( !IsListEmpty( &ScavengerDeadPool ) &&
             TasksLeftOver < ScavengerDeadPoolSize ) {

        //
        // Get a task out of the list
        //

        BOOLEAN PutItBack = FALSE;
        PSCAVENGER_TASK Task = CONTAINING_RECORD(
                                   RemoveHeadList( &ScavengerDeadPool ),
                                   SCAVENGER_TASK,
                                   m_ListEntry
                                   );

        //
        // Only canceled tasks are allowed in the deadpool
        //

        DsysAssert( Task->m_Canceled );

        DsysAssert( ScavengerDeadPoolSize > 0 );
        ScavengerDeadPoolSize -= 1;

        UnlockScavengerQueue();

        if ( Task == TaskToAvoid ) {

            //
            // If this is the task associated with the current callback, skip it
            // This routine might be called from inside a timer callback routine,
            // and deleting a timer handle from inside its timer callback routine
            // leads to devastating consequences
            //

            PutItBack = TRUE;

        } else {

            //
            // Destroy the timer handle if it still exists
            //

            if ( Task->m_Timer != NULL ) {

                BOOL Success;

                Success = DeleteTimerQueueTimer(
                              ScavengerTimerQueue,
                              Task->m_Timer,
                              Task->m_ShutdownEvent
                              );

                DsysAssert( Success || ( GetLastError() == ERROR_IO_PENDING ));

                Task->m_Timer = NULL;
            }

            //
            // If the shutdown event is signaled,
            // it is safe to dispose of the task;
            // Otherwise, someone else will have to garbage collect this one
            //

            if ( WAIT_OBJECT_0 == WaitForSingleObject(
                                      Task->m_ShutdownEvent,
                                      0 )) {

                ScavengerFreeTask( Task );

            } else {

                PutItBack = TRUE;
            }
        }

        LockScavengerQueue();

        //
        // If this is 'our' task, or there was trouble, insert it at the tail
        // so we can continue with tasks at the head of the deadpool list
        //

        if ( PutItBack ) {

            InsertTailList( &ScavengerDeadPool, &Task->m_ListEntry );
            ScavengerDeadPoolSize += 1;
            TasksLeftOver += 1;
        }
    }

    UnlockScavengerQueue();

    return;
}


//+----------------------------------------------------------------------------
//
//  Function:   ScavengerCancelTask
//
//  Synopsis:   Stops a task's timer for subsequent removal
//
//  Arguments:  Task            - Task to cancel
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

void
ScavengerCancelTask(
    IN PSCAVENGER_TASK Task
    )
{
    DsysAssert( Task );

    KERB_TASK_DESTROY pfnDestroy = NULL;
    void * Context = NULL;

    LockScavengerQueue();

    //
    // Only canceled tasks are allowed in the deadpool
    //

    DsysAssert( Task->m_Canceled );

    //
    // Move the task from the active task list to the deadpool
    //

    //
    // First, remove the task from the active task list
    //

    RemoveEntryList( &Task->m_ListEntry );
    ScavengerTaskQueueSize -= 1;

    //
    // Invoke the destruction callback right away, any further manipulation
    // of this task by the client is illegal.  Do this outside the queue lock.
    //

    if ( Task->m_pfnDestroy ) {

        pfnDestroy = Task->m_pfnDestroy;
        Context = Task->m_Context;
        Task->m_pfnDestroy = NULL;
    }

    //
    // Finally, put the task on the deadpool
    //

    InsertTailList( &ScavengerDeadPool, &Task->m_ListEntry );
    ScavengerDeadPoolSize += 1;

    UnlockScavengerQueue();

    if ( pfnDestroy ) {

        pfnDestroy( Context );
    }

    return;
}


//+----------------------------------------------------------------------------
//
//  Function:   ScavengerAddTask
//
//  Synopsis:   Common logic involved in scheduling a new task
//
//  Arguments:  Parameter       - Task being scheduled
//
//  Returns:    STATUS_SUCCESS if happy
//              STATUS_ error code otherwise
//
//-----------------------------------------------------------------------------

NTSTATUS
ScavengerAddTask(
    IN PSCAVENGER_TASK Task
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOL Success;

    DsysAssert( Task );

    LockScavengerQueue();

    //
    // Assumptions: properly configured task, ready to be scheduled
    //

    DsysAssert( Task->m_InsideTrigger == 0 );
    DsysAssert( !Task->m_Canceled );
    DsysAssert( Task->m_Timer == NULL );
    DsysAssert( Task->m_ShutdownEvent != NULL );
    DsysAssert( Task->m_Processing == FALSE );

    //
    // Schedule the task by creating its timer
    //

    Success = CreateTimerQueueTimer(
                  &Task->m_Timer,
                  ScavengerTimerQueue,
                  ScavengerTimerCallback,
                  Task,
                  Task->m_Interval,
                  Task->m_Periodic ? Task->m_Interval : 0,
                  Task->m_Flags
                  );

    if ( !Success ) {

        //
        // FESTER: map GetLastError() to an NT status code maybe?
        //

        Status = STATUS_UNSUCCESSFUL;
//      DsysAssert( FALSE );

    } else {

        InsertHeadList( &ScavengerTaskQueue, &Task->m_ListEntry );
        ScavengerTaskQueueSize += 1;
    }

    UnlockScavengerQueue();

    return Status;
}


//+----------------------------------------------------------------------------
//
//  Function:   ScavengerTimerCallback
//
//  Synopsis:   Scavenger worker routine
//
//  Arguments:  Parameter       - Task handle
//              Reason          - see definition of WAITORTIMERCALLBACK
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

VOID
ScavengerTimerCallback(
    IN PVOID Parameter,
    IN BOOLEAN Reason
    )
{
    PSCAVENGER_TASK Task = ( PSCAVENGER_TASK )Parameter;

    UNREFERENCED_PARAMETER( Reason );

    DsysAssert( Task );
    DsysAssert( Reason == TRUE );
    DsysAssert( Task->m_pfnTrigger );

    //
    // Callbacks that step on each others' heels are thrown out
    //

    if ( FALSE != InterlockedCompareExchange(
                      &Task->m_Processing,
                      TRUE,
                      FALSE )) {

        return;
    }

    //
    // Invoke the trigger
    //

    DsysAssert( Task->m_InsideTrigger == 0 );
    DsysAssert( !Task->m_Canceled );

    Task->m_InsideTrigger = GetCurrentThreadId();
    Task->m_pfnTrigger( Task, Task->m_Context );
    Task->m_InsideTrigger = 0;

    if ( !Task->m_Periodic ) {

        //
        // Non-periodic tasks get removed right away
        //

        Task->m_Canceled = TRUE;
    }

    //
    // If the task has been canceled, move it to the deadpool
    //

    if ( Task->m_Canceled ) {

        ScavengerCancelTask( Task );

    } else {

        //
        // Task has not been canceled, so open it up to timer callbacks
        //

        InterlockedExchange( &Task->m_Processing, FALSE );
    }

    //
    // A timer callback is a good place to bury some bodies
    //

    ScavengerPurgeDeadPool( Task );

    return;
}


// ----------------------------------------------------------------------------
//
// External scavenger interfaces
//
// ----------------------------------------------------------------------------

//+----------------------------------------------------------------------------
//
//  Function:   KerbInitializeScavenger
//
//  Synopsis:   Initializes the scavenger
//
//  Arguments:  None
//
//  Returns:    STATUS_SUCCESS if happy
//              STATUS_ error code otherwise
//
//-----------------------------------------------------------------------------

NTSTATUS
KerbInitializeScavenger()
{
    NTSTATUS Status;

    DsysAssert( !ScavengerInitialized );

    //
    // Task queue and dead pool could be protected by different
    // locks, but the amount of time spent inside those locks is minimal,
    // so the same lock is used
    //

    Status = RtlInitializeCriticalSection( &ScavengerLock );

    if ( !NT_SUCCESS( Status )) {

        return Status;
    }

    InitializeListHead( &ScavengerTaskQueue );
    InitializeListHead( &ScavengerDeadPool );
    ScavengerTaskQueueSize = 0;
    ScavengerDeadPoolSize = 0;

    DsysAssert( ScavengerTimerShutdownEvent == NULL );

    Status = NtCreateEvent(
                 &ScavengerTimerShutdownEvent,
                 EVENT_QUERY_STATE |
                    EVENT_MODIFY_STATE |
                    SYNCHRONIZE,
                 NULL,
                 SynchronizationEvent,
                 FALSE
                 );

    if ( !NT_SUCCESS( Status )) {

        goto Error;
    }

    DsysAssert( ScavengerTimerQueue == NULL );

    Status = RtlCreateTimerQueue( &ScavengerTimerQueue );

    if ( !NT_SUCCESS( Status )) {

        goto Error;
    }

    //
    // We're ready to rock-n-roll
    //

    ScavengerInitialized = TRUE;

    Status = STATUS_SUCCESS;

Cleanup:

    return Status;

Error:

    DsysAssert( !NT_SUCCESS( Status ));

    if ( ScavengerTimerQueue != NULL ) {

        RtlDeleteTimerQueue( ScavengerTimerQueue );
        ScavengerTimerQueue = NULL;
    }

    if ( ScavengerTimerShutdownEvent != NULL ) {

        NtClose( ScavengerTimerShutdownEvent );
        ScavengerTimerShutdownEvent = NULL;
    }

    RtlDeleteCriticalSection( &ScavengerLock );

    ScavengerInitialized = FALSE;

    goto Cleanup;
}


//+----------------------------------------------------------------------------
//
//  Function:   KerbShutdownScavenger
//
//  Synopsis:   Shuts down the scavenger
//
//  Arguments:  None
//
//  Returns:    STATUS_SUCCESS if everything cleaned up properly
//              STATUS_ error code otherwise
//
//  Note:       If errors are encountered, the scavenger will not be destroyed,
//              but the task queue will be emptied.
//
//-----------------------------------------------------------------------------

NTSTATUS
KerbShutdownScavenger()
{
    NTSTATUS Status;

    DsysAssert( ScavengerInitialized );

    Status = RtlDeleteTimerQueueEx(
                 ScavengerTimerQueue,
                 ScavengerTimerShutdownEvent
                 );

    ScavengerPurgeDeadPool( NULL );

    WaitForSingleObject( ScavengerTimerShutdownEvent, INFINITE );

    //
    // Purge the contents of the scavenger queue
    // NOTE: no need to lock the queue anymore, as the timer has been shut down
    //

    while ( !IsListEmpty( &ScavengerTaskQueue )) {

        PSCAVENGER_TASK Task = CONTAINING_RECORD(
                                   RemoveHeadList( &ScavengerTaskQueue ),
                                   SCAVENGER_TASK,
                                   m_ListEntry
                                   );

        ScavengerFreeTask( Task );

        ScavengerTaskQueueSize -= 1;
    }

    DsysAssert( ScavengerTaskQueueSize == 0 );

    if ( NT_SUCCESS( Status )) {

        NtClose( ScavengerTimerShutdownEvent );
        ScavengerTimerShutdownEvent = NULL;
        ScavengerTimerQueue = NULL;
        RtlDeleteCriticalSection( &ScavengerLock );
        ScavengerInitialized = FALSE;
    }

    return Status;
}


//+----------------------------------------------------------------------------
//
//  Function:   KerbAddScavengerTask
//
//  Synopsis:   Adds a task to the list of those managed by the scavenger object
//
//  Arguments:  Periodic        - If TRUE, this is to be a recurring task
//              Interval        - Execution interval in milliseconds
//              Flags           - WT_ flags (see CreateTimerQueueTimer)
//              pfnTrigger      - Trigger callback
//              pfnDestroy      - Destruction callback (OPTIONAL)
//              TaskItem        - Task context (OPTIONAL)
//
//  Returns:    STATUS_SUCCESS if everything cleaned up properly
//              STATUS_ error code otherwise
//
//-----------------------------------------------------------------------------

NTSTATUS
KerbAddScavengerTask(
    IN BOOLEAN Periodic,
    IN LONG Interval,
    IN ULONG Flags,
    IN KERB_TASK_TRIGGER pfnTrigger,
    IN KERB_TASK_DESTROY pfnDestroy,
    IN void * TaskItem,
    OUT OPTIONAL void * * TaskHandle
    )
{
    NTSTATUS Status;
    PSCAVENGER_TASK Task;

    DsysAssert( ScavengerInitialized );

    //
    // Validate the passed in parameters
    //

    if ( pfnTrigger == NULL ||
         ( Periodic && Interval == 0 )) {

//      DsysAssert( FALSE && "RTFM: Invalid parameter passed in to KerbAddScavengerTask." );
        return STATUS_INVALID_PARAMETER;
    }

    Task = ( PSCAVENGER_TASK )MIDL_user_allocate( sizeof( SCAVENGER_TASK ));

    if ( Task == NULL ) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    Task->m_InsideTrigger = 0;
    Task->m_Canceled = FALSE;
    Task->m_Periodic = Periodic;
    Task->m_Interval = Interval;
    Task->m_Timer = NULL;
    Task->m_Flags = Flags;
    Task->m_ShutdownEvent = NULL;
    Task->m_Processing = FALSE;
    Task->m_pfnTrigger = pfnTrigger;
    Task->m_pfnDestroy = pfnDestroy;
    Task->m_Context = TaskItem;

    Status = NtCreateEvent(
                 &Task->m_ShutdownEvent,
                 EVENT_QUERY_STATE |
                    EVENT_MODIFY_STATE |
                    SYNCHRONIZE,
                 NULL,
                 SynchronizationEvent,
                 FALSE
                 );

    if ( !NT_SUCCESS( Status )) {

        MIDL_user_free( Task );
        return Status;
    }

    Status = ScavengerAddTask( Task );

    if ( !NT_SUCCESS( Status )) {

        Task->m_pfnDestroy = NULL; // Didn't take ownership yet, caller will destroy
        ScavengerFreeTask( Task );
        Task = NULL;

    }

    if ( TaskHandle ) {

        *TaskHandle = Task;
    }

    return Status;
}


//+----------------------------------------------------------------------------
//
//  Function:   KerbTaskDoItNow
//
//  Synopsis:   Makes the task fire right away
//
//  Arguments:  TaskHandle      - Task handle
//
//  Returns:    TRUE if successful, FALSE otherwise
//
//  NOTE: this function can only be called from outside a task trigger callback
//
//-----------------------------------------------------------------------------

BOOL
KerbTaskDoItNow(
    IN HANDLE TaskHandle
    )
{
    PSCAVENGER_TASK Task = ( PSCAVENGER_TASK )TaskHandle;

    DsysAssert( Task );

    return ChangeTimerQueueTimer( ScavengerTimerQueue, Task->m_Timer, 0, 0 );
}


//+----------------------------------------------------------------------------
//
//  Function:   KerbTaskIsPeriodic
//
//  Synopsis:   Tells whether a given task is a periodic task
//
//  Arguments:  TaskHandle      - Task handle
//
//  Returns:    TRUE if the task is periodic, FALSE otherwise
//
//  NOTE: this function can only be called from inside a task trigger callback
//
//-----------------------------------------------------------------------------

BOOLEAN
KerbTaskIsPeriodic(
    IN void * TaskHandle
    )
{
    PSCAVENGER_TASK Task = ( PSCAVENGER_TASK )TaskHandle;

    DsysAssert( Task );
    DsysAssert( Task->m_InsideTrigger == GetCurrentThreadId());

    return Task->m_Periodic;
}


//+----------------------------------------------------------------------------
//
//  Function:   KerbTaskGetInterval
//
//  Synopsis:   Retrieves the interval of a periodic task
//
//  Arguments:  TaskHandle      - Task handle
//
//  Returns:    Interval associated with the task, in milliseconds
//
//  NOTE: this function can only be called from inside a task trigger callback
//
//-----------------------------------------------------------------------------

LONG
KerbTaskGetInterval(
    IN void * TaskHandle
    )
{
    PSCAVENGER_TASK Task = ( PSCAVENGER_TASK )TaskHandle;

    DsysAssert( Task );
    DsysAssert( Task->m_InsideTrigger == GetCurrentThreadId());

    return Task->m_Interval;
}


//+----------------------------------------------------------------------------
//
//  Function:   KerbTaskCancel
//
//  Synopsis:   Cancels the task
//
//  Arguments:  TaskHandle      - Task handle
//
//  Returns:    Nothing
//
//  NOTE: this function can only be called from inside a task trigger callback
//
//-----------------------------------------------------------------------------

void
KerbTaskCancel(
    IN void * TaskHandle
    )
{
    PSCAVENGER_TASK Task = ( PSCAVENGER_TASK )TaskHandle;

    DsysAssert( Task );
    DsysAssert( Task->m_InsideTrigger == GetCurrentThreadId());

    Task->m_Canceled = TRUE;

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\common2\authen.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       authen.cxx
//
//  Contents:   Authenticator verification code
//
//  Classes:    CAuthenticatorList
//
//  Functions:  Compare, AuthenAllocate, AuthenFree
//
//  History:    4-04-93   WadeR   Created
//
//----------------------------------------------------------------------------

#include "krbprgma.h"
#include <secpch2.hxx>
#pragma hdrstop

//
// Security include files.
//
#include <kerbcomm.h>
#include <authen.hxx>
extern "C"
{
#include <md5.h>
}

#include "debug.h"



typedef struct _KERB_AUTHEN_HEADER
{
    LARGE_INTEGER tsTime;
    ULONG Count;
    BYTE Checksum[MD5DIGESTLEN];
} KERB_AUTHEN_HEADER, *PKERB_AUTHEN_HEADER;

#define KERB_MAX_AUTHEN_SIZE 1024

//+---------------------------------------------------------------------------
//
//  Function:   Compare
//
//  Synopsis:   Compares two KerbInternalAuthenticators for RTL_GENERIC_TABLE
//
//  Effects:    none.
//
//  Arguments:  [Table]        -- ignored
//              [FirstStruct]  --
//              [SecondStruct] --
//
//  Returns:    GenericEqual, GenericLessThan, GenericGreaterThan.
//
//  Algorithm:  Sorts by TimeStamp first, than nonce, then principal, and
//              finally by realm
//
//  History:    4-04-93   WadeR   Created
//
//  Notes:      This must impose a complete ordering.  The table package
//              will not allow an authenticator to be inserted in the table
//              if it is equal (according to this function) to one already
//              there.
//
//----------------------------------------------------------------------------

RTL_GENERIC_COMPARE_RESULTS
Compare(
    IN struct _RTL_GENERIC_TABLE *Table,
    IN PVOID FirstStruct,
    IN PVOID SecondStruct
    )
{
    PKERB_AUTHEN_HEADER pOne, pTwo;
    RTL_GENERIC_COMPARE_RESULTS ret;
    int comp;
    pOne = (PKERB_AUTHEN_HEADER) FirstStruct ;
    pTwo = (PKERB_AUTHEN_HEADER) SecondStruct ;

    DsysAssert( (pOne != NULL) && (pTwo != NULL) );


    comp = memcmp( pOne->Checksum,
                   pTwo->Checksum,
                   MD5DIGESTLEN );
    if (comp > 0)
    {
        ret = GenericGreaterThan;
    }
    else if (comp < 0)
    {
        ret = GenericLessThan;
    }
    else
    {
        ret = GenericEqual;
    }

    return(ret);
}


//+---------------------------------------------------------------------------
//
//  Function:   AuthenAllocate
//
//  Synopsis:   Memory allocator for RTL_GENERIC_TABLE
//
//  Effects:    Allcoates memory.
//
//  Arguments:  [Table]    -- ignored
//              [ByteSize] -- number of bytes to allocate
//
//  Signals:    Throws exception on failure.
//
//  History:    4-04-93   WadeR   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

PVOID
AuthenAllocate( struct _RTL_GENERIC_TABLE *Table, CLONG ByteSize )
{
    return(MIDL_user_allocate ( ByteSize ) );
}



//+---------------------------------------------------------------------------
//
//  Function:   AuthenFree
//
//  Synopsis:   Memory deallacotor for the RTL_GENERIC_TABLE.
//
//  Effects:    frees memory.
//
//  Arguments:  [Table]  -- ingnored
//              [Buffer] -- buffer to free
//
//  History:    4-04-93   WadeR   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

VOID
AuthenFree( struct _RTL_GENERIC_TABLE *Table, PVOID Buffer )
{
    MIDL_user_free ( Buffer );
}



//+---------------------------------------------------------------------------
//
//  Member:     CAuthenticatorList::CAuthenticatorList
//
//  Synopsis:   Initializes the authenticator list.
//
//  Effects:    Calls RtlInitializeGenericTable (does not allocate memory).
//
//  Arguments:  [tsMax] -- Maximum acceptable age for an authenticator.
//
//  History:    4-04-93   WadeR   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

CAuthenticatorList::CAuthenticatorList(LARGE_INTEGER tsMax, ULONG maxCount, BOOLEAN debugme)
    :_tsMaxAge(tsMax), _uMaxCount(maxCount), _fDebug(debugme)
{
    _fMutexInitialized = FALSE;
    RtlInitializeGenericTable( &_Table, Compare, AuthenAllocate, AuthenFree, NULL );
}


//+---------------------------------------------------------------------------
//
//  Member:     CAuthenticatorList::~CAuthenticatorList
//
//  Synopsis:   Destructor removes all authenticators in the list.
//
//  Effects:    Frees memory
//
//  Arguments:  (none)
//
//  Algorithm:  Uses "Age" to remove everything.
//
//  History:    4-04-93   WadeR   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

CAuthenticatorList::~CAuthenticatorList()
{
    LARGE_INTEGER tsForever;
    LARGE_INTEGER tsZero = {0};
    SetMaxTimeStamp( tsForever );
    (void) Age( tsForever, tsZero );
    DsysAssert( RtlIsGenericTableEmpty( &_Table ) );

    if (_fMutexInitialized)
    {
        RtlDeleteCriticalSection(&_Mutex);
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CAuthenticatorList::Init
//
//  Synopsis:   Can't return values from a C++ destructor -- initialization
//              that can fail should go here
//
//  Effects:
//
//  Arguments:
//
//  Algorithm:
//
//  History:    5-24-94   WadeR   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

NTSTATUS
CAuthenticatorList::Init()
{
    NTSTATUS Status;

    Status = RtlInitializeCriticalSection(&_Mutex);

    if (NT_SUCCESS(Status))
    {
        _fMutexInitialized = TRUE;
    }

    return Status;
}


//+---------------------------------------------------------------------------
//
//  Member:     CAuthenticatorList::SetMaxAge
//
//  Synopsis:   Changes the new maximum age for an Authenticator.
//
//  Effects:    May cause some authenticators to be aged out.
//
//  Arguments:  [tsNewMaxAge] --
//
//  Algorithm:
//
//  History:    24-May-94   wader   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CAuthenticatorList::SetMaxAge( LARGE_INTEGER tsNewMaxAge )
{
    LARGE_INTEGER tsNow;
    LARGE_INTEGER tsCutoffPast, tsCutoffFuture;

    _tsMaxAge = tsNewMaxAge;

    GetSystemTimeAsFileTime((PFILETIME) &tsNow );

    tsCutoffPast.QuadPart = tsNow.QuadPart - _tsMaxAge.QuadPart;
    tsCutoffFuture.QuadPart = tsNow.QuadPart + _tsMaxAge.QuadPart;

    (void) Age( tsCutoffPast, tsCutoffFuture );
}



//+---------------------------------------------------------------------------
//
//  Member:     CAuthenticatorList::Age
//
//  Synopsis:   Deletes all entries from the table that are earlier than
//              the given time.
//
//  Effects:    Frees memory
//
//  Arguments:  [tsCutoffTime] -- Delete all elements before this time.
//
//  Returns:    number of elements deleted.
//
//  Algorithm:  Get the oldest element in the table.  If it is older than
//              the time, delete it and loop back.  Else return.
//
//  History:    4-04-93   WadeR   Created
//
//  Notes:      The table contains the packed forms of Authenticators (as
//              created by PackAuthenticator in Kerbsupp).  The TimeStamp
//              must be first.
//
//----------------------------------------------------------------------------

ULONG
CAuthenticatorList::Age(const LARGE_INTEGER& tsCutoffPast, const LARGE_INTEGER& tsCutoffFuture)
{
    PKERB_AUTHEN_HEADER pahOldest;

    BOOL fDeleted;
    ULONG cDeleted = 0;

    do
    {
        // Number 0 is the oldest element in the table.
        pahOldest = (PKERB_AUTHEN_HEADER) RtlGetElementGenericTable( &_Table, 0 );
        if ((pahOldest != NULL) &&
            ((pahOldest->tsTime.QuadPart < tsCutoffPast.QuadPart) ||
             (pahOldest->tsTime.QuadPart > tsCutoffFuture.QuadPart)))        // Bug # - clean up entires after clock reset
        {
            fDeleted = RtlDeleteElementGenericTable( &_Table, pahOldest );
            DsysAssert( fDeleted );
            cDeleted++;
        }
        else
        {
            fDeleted = FALSE;
        }
    } while ( fDeleted );
    return(cDeleted);
}

//+---------------------------------------------------------------------------
//
//  Member:     CAuthenticatorList::Check
//
//  Synopsis:   Determines if an authenticator is valid.  This check always
//               checks for time skew and optionally checks for repeats.  This is necessary
//               since we check for repeats on AP requests but not TGS requests.
//
//  Effects:    Allocates memory
//
//  Arguments:  [pedAuth] -- Authenticator to check (decrypted, but marshalled)
//
//  Returns:    KDC_ERR_NONE if authenticator is OK.
//              KRB_AP_ERR_SKEW if authenticator is expired (assumes clock skew).
//              KRB_AP_ERR_REPEAT if authenticator has been used already.
//              some other error if something throws an exception.
//
//  Signals:    none.
//
//  Modifies:   _Table
//
//  History:    4-04-93   WadeR   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

KERBERR
CAuthenticatorList::Check(
    IN PVOID Buffer,
    IN ULONG BufferLength,
    IN OPTIONAL PVOID OptionalBuffer,
    IN OPTIONAL ULONG OptionalBufferLength,
    IN PLARGE_INTEGER Time,
    IN BOOLEAN Insert,
    IN BOOLEAN PurgeEntry,
    IN BOOLEAN fCheckReplay
    )
{
    PKERB_AUTHEN_HEADER pDataInTable = NULL;
    KERBERR KerbErr = KDC_ERR_NONE;

    LARGE_INTEGER tsNow;
    LARGE_INTEGER tsCutoffPast;
    LARGE_INTEGER tsCutoffFuture;
    
    //
    // Determine the cut off time.
    //
    
    GetSystemTimeAsFileTime((PFILETIME) &tsNow );
    
    tsCutoffPast.QuadPart = tsNow.QuadPart - _tsMaxAge.QuadPart;
    tsCutoffFuture.QuadPart = tsNow.QuadPart + _tsMaxAge.QuadPart; 
    
    if ((Time->QuadPart < tsCutoffPast.QuadPart) ||
        (Time->QuadPart > tsCutoffFuture.QuadPart))
    {
        KerbErr = KRB_AP_ERR_SKEW;
    }

    //
    // Hold the mutex until we have finished the insert and the Age
    // operations.
    //

   if (fCheckReplay)
   {       
        RtlEnterCriticalSection(&_Mutex);
        
        __try
        {
            // Age out the old ones.
            (void) Age( tsCutoffPast, tsCutoffFuture );
            
            BOOLEAN fIsNew;
            KERB_AUTHEN_HEADER Header;
            MD5_CTX Md5Context;
        
            //
            // Store the first chunk of the authenticator. If the authenticator
            // doesn't fit on the stack, allocate some space on the heap.
            //
        
            Header.tsTime = *Time;
            MD5Init(
                &Md5Context
                );
        
            MD5Update(
                &Md5Context,
                (PBYTE) Buffer,
                BufferLength
                );

            if ((OptionalBuffer != NULL) && (OptionalBufferLength != 0))
            {
                MD5Update(
                    &Md5Context,
                    (PBYTE) OptionalBuffer,
                    OptionalBufferLength
                    );
            }

            MD5Final(
                &Md5Context
                );

            RtlCopyMemory(
                Header.Checksum,
                Md5Context.digest,
                MD5DIGESTLEN
                );   

            if (Insert)
            {
                pDataInTable = (PKERB_AUTHEN_HEADER) RtlInsertElementGenericTable( 
                                                        &_Table,
                                                        &Header,
                                                        sizeof( KERB_AUTHEN_HEADER ),
                                                        &fIsNew
                                                        );

                if ( pDataInTable == NULL )
                {
                    KerbErr = KRB_ERR_GENERIC;
                    __leave;
                }
        
                if ( fIsNew )
                {
                    pDataInTable->Count = 1;
                    if (_fDebug)
                    {
                        D_DebugLog((DEB_ERROR, "NEW cache entry\n"));
                    }
                }
                else if ( ++(pDataInTable->Count) >= _uMaxCount )
                {
                    KerbErr = KRB_AP_ERR_REPEAT;
                    if (_fDebug)
                    {
                        D_DebugLog((DEB_ERROR, "Repeat <on insert>\n"));
                    } 
                }
            }
            else
            {
                pDataInTable = (PKERB_AUTHEN_HEADER)RtlLookupElementGenericTable(
                                                            &_Table,
                                                            &Header 
                                                            );
        
                if (NULL != pDataInTable)
                {    
                    if (PurgeEntry)
                    {
                        BOOLEAN fCompleted = FALSE;
                        fCompleted = RtlDeleteElementGenericTable(&_Table, pDataInTable);
                        DsysAssert(fCompleted);
                        if (_fDebug)
                        {
                            D_DebugLog((DEB_ERROR, "Purged cache entry\n"));
                        }                                                   
        
                    }
                    else if (pDataInTable->Count >= _uMaxCount)
                    {   
                        KerbErr = KRB_AP_ERR_REPEAT;
                        if (_fDebug)
                        {
                            D_DebugLog((DEB_ERROR, "Repeat detected \n"));
                        } 
                    }
                }
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            KerbErr = KRB_ERR_GENERIC;
        }
        
        RtlLeaveCriticalSection(&_Mutex);             
    }

    return(KerbErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\common2\names.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        tickets.c
//
// Contents:    Ticket bundling code
//
//
// History:      6 Dec 91,  RichardW    Created
//              04 Jun 92   RichardW    NT-ized
//              08-Jun-93   WadeR       Converted to C++, rewrote packing code
//
//------------------------------------------------------------------------

#ifdef WIN32_CHICAGO
#include <kerb.hxx>
#include <kerbp.h>
#endif // WIN32_CHICAGO

#ifndef WIN32_CHICAGO
extern "C"
{
#include "krbprgma.h"
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#include <samrpc.h>
#include <samisrv.h>
#include <dnsapi.h>
#include <wincrypt.h>
#include <certca.h>
}
#include <kerbcomm.h>
#include <kerberr.h>
#include <kerbcon.h>
#include "debug.h"
#include <sddl.h>
#include <malloc.h>
#include <alloca.h>

#endif // WIN32_CHICAGO

#define KERB_NAME_PREFIX L"Kerberos:"
UNICODE_STRING KerbNamePrefix = {sizeof(KERB_NAME_PREFIX) - sizeof(WCHAR), sizeof(KERB_NAME_PREFIX), KERB_NAME_PREFIX };
UNICODE_STRING KerbNameSeparator = {sizeof(WCHAR), 2*sizeof(WCHAR), L"/" };
UNICODE_STRING KerbDomainSeparator = {sizeof(WCHAR), 2*sizeof(WCHAR), L"@" };

#ifndef SHA1DIGESTLEN
#define SHA1DIGESTLEN 20
#endif

// Local Prototype */
BOOL SafeRtlInitString(
    OUT PSTRING DestinationString,
    IN PCSZ SourceString OPTIONAL
    );

BOOL SafeRtlInitUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PCWSTR SourceString OPTIONAL
    );

LPWSTR
KerbAllocWStrFromUtf8Str(
    IN PCHAR Utf8String
    )

/*++

Routine Description:

    Convert a UTF8 (zero terminated) string to the corresponding UNICODE
    string.

Arguments:

    Utf8String - Specifies the UTF8 zero terminated string to convert.


Return Value:

    NULL - There was some error in the conversion.

    Otherwise, it returns a pointer to the zero terminated UNICODE string in
    an allocated buffer.  The buffer must be freed using NetApiBufferFree.

--*/

{
    LPWSTR UnicodeString = NULL;
    int UnicodeStringLen;

    //
    // Determine the length of the Unicode string.
    //

    UnicodeStringLen = MultiByteToWideChar(
#ifndef WIN32_CHICAGO
                        CP_UTF8,
#else // WIN32_CHICAGO
                        CP_OEMCP,
#endif // WIN32_CHICAGO
                        0,      // All characters can be mapped.
                        Utf8String,
                        -1,             // calculate length
                        UnicodeString,
                        0 );

    if ( UnicodeStringLen == 0 ) {
        return NULL;
    }

    //
    // Allocate a buffer for the Unicode string.
    //

    UnicodeString = (LPWSTR) MIDL_user_allocate( (UnicodeStringLen+1)*sizeof(WCHAR) );

    if ( UnicodeString == NULL ) {
        return NULL;
    }

    //
    // Translate the string to Unicode.
    //

    UnicodeStringLen = MultiByteToWideChar(
#ifndef WIN32_CHICAGO
                        CP_UTF8,
#else // WIN32_CHICAGO
                        CP_OEMCP,
#endif // WIN32_CHICAGO
                        0,      // All characters can be mapped.
                        Utf8String,
                        -1,
                        UnicodeString,
                        UnicodeStringLen );

    if ( UnicodeStringLen == 0 ) {
        MIDL_user_free( UnicodeString );
        return NULL;
    }

    UnicodeString[UnicodeStringLen] = L'\0';

    return UnicodeString;
}

NTSTATUS
KerbUnicodeStringFromUtf8Str(
    IN PCHAR Utf8String,
    OUT PUNICODE_STRING UnicodeString
    )

/*++

Routine Description:

    Convert a UTF8 (zero terminated) string to the corresponding UNICODE
    string.

Arguments:

    Utf8String - Specifies the UTF8 zero terminated string to convert.
    UnicodeString - Receives the converted unicode string


Return Value:

    NULL - There was some error in the conversion.

    Otherwise, it returns a pointer to the zero terminated UNICODE string in
    an allocated buffer.  The buffer must be freed using NetApiBufferFree.

--*/

{
    int UnicodeStringLen;
    ULONG ulLength = 0;

    //
    // Determine the length of the Unicode string.
    //

    UnicodeStringLen = MultiByteToWideChar(
#ifndef WIN32_CHICAGO
                        CP_UTF8,
#else // WIN32_CHICAGO
                        CP_OEMCP,
#endif // WIN32_CHICAGO
                        0,      // All characters can be mapped.
                        Utf8String,
                        -1,             // calculate length
                        UnicodeString->Buffer,
                        0 );

    if ( UnicodeStringLen == 0 ) {
        return (STATUS_SUCCESS);
    }

    //
    // The conversion routine returns space for a null terminator, so
    // adjust for that.
    //

    // check to make sure size fits into a USHORT value (with NULL appended)
    ulLength = (UnicodeStringLen - 1) * sizeof(WCHAR);

    if (ulLength > KERB_MAX_UNICODE_STRING)        
    {
        return(STATUS_NAME_TOO_LONG);
    }

    UnicodeString->Length = (USHORT)ulLength;

    if (UnicodeString->MaximumLength < UnicodeString->Length + sizeof(WCHAR))
    {
        return(STATUS_BUFFER_TOO_SMALL);
    }

    //
    // Translate the string to Unicode.
    //

    UnicodeStringLen = MultiByteToWideChar(
#ifndef WIN32_CHICAGO
                        CP_UTF8,
#else // WIN32_CHICAGO
                        CP_OEMCP,
#endif // WIN32_CHICAGO
                        0,      // All characters can be mapped.
                        Utf8String,
                        -1,
                        UnicodeString->Buffer,
                        UnicodeStringLen );

    DsysAssert( UnicodeStringLen != 0 );

    UnicodeString->Buffer[UnicodeStringLen-1] = L'\0';
    UnicodeString->Length = (USHORT)((UnicodeStringLen-1) * sizeof(WCHAR));
    UnicodeString->MaximumLength = (USHORT)(UnicodeStringLen * sizeof(WCHAR));

    return STATUS_SUCCESS;
}

PCHAR
KerbAllocUtf8StrFromUnicodeString(
    IN PUNICODE_STRING UnicodeString
    )

/*++

Routine Description:

    Convert a Unicode (zero terminated) string to the corresponding UTF8
    string.

Arguments:

    UnicodeString - Specifies the Unicode zero terminated string to convert.


Return Value:

    NULL - There was some error in the conversion.

    Otherwise, it returns a pointer to the zero terminated UTF8 string in
    an allocated buffer.  The buffer must be freed using NetApiBufferFree.

--*/

{
    PCHAR Utf8String = NULL;
    int Utf8StringLen;

    //
    // If the length is zero, return a null string.
    //

    if (UnicodeString->Length == 0)
    {
        Utf8String = (PCHAR) MIDL_user_allocate(sizeof(CHAR));
        if (Utf8String != NULL)
        {
            *Utf8String = '\0';
        }
        return(Utf8String);
    }

    //
    // Determine the length of the Unicode string.
    //

    Utf8StringLen = WideCharToMultiByte(
#ifndef WIN32_CHICAGO
                        CP_UTF8,
#else // WIN32_CHICAGO
                        CP_OEMCP,
#endif // WIN32_CHICAGO
                        0,      // All characters can be mapped.
                        UnicodeString->Buffer,
                        UnicodeString->Length / sizeof(WCHAR),
                        Utf8String,
                        0,
                        NULL,
                        NULL );

    if ( Utf8StringLen == 0 ) {

        return NULL;
    }

    //
    // Allocate a buffer for the Unicode string.
    //

    Utf8String = (PCHAR) MIDL_user_allocate( Utf8StringLen+1 );

    if ( Utf8String == NULL ) {
        return NULL;
    }

    //
    // Translate the string to Unicode.
    //

    Utf8StringLen = WideCharToMultiByte(
#ifndef WIN32_CHICAGO
                        CP_UTF8,
#else // WIN32_CHICAGO
                        CP_OEMCP,
#endif // WIN32_CHICAGO
                        0,      // All characters can be mapped.
                        UnicodeString->Buffer,
                        UnicodeString->Length / sizeof(WCHAR),
                        Utf8String,
                        Utf8StringLen,
                        NULL,
                        NULL );

    if ( Utf8StringLen == 0 ) {
        MIDL_user_free( Utf8String );
        return NULL;
    }

    Utf8String[Utf8StringLen] = '\0';

    return Utf8String;
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbUnicodeStringToKerbString
//
//  Synopsis:   Converts a UNICODE_STRING to a kerberos-ansi string
//
//  Effects:    allocates destination with MIDL_user_allocate
//
//  Arguments:  KerbString - receives ansi-ized string
//              String - containes source unicode string
//
//  Requires:
//
//  Returns:    KDC_ERR_NONE or KRB_ERR_GENERIC
//
//  Notes:      This routine hides the details of whether we use UTF-8 or
//              unicode->ansi conversion
//
//
//--------------------------------------------------------------------------

KERBERR
KerbUnicodeStringToKerbString(
    OUT PSTRING KerbString,
    IN PUNICODE_STRING String
    )
{
    STRING TempString;
    BOOL fAssigned = FALSE;

    if (!ARGUMENT_PRESENT(KerbString))
    {
        return(KRB_ERR_GENERIC);
    }

    TempString.Buffer = KerbAllocUtf8StrFromUnicodeString(String);
    if (TempString.Buffer == NULL)
    {
        return(KRB_ERR_GENERIC);
    }
    
    fAssigned = SafeRtlInitString(
        &TempString,
        TempString.Buffer
        );
    if (fAssigned == FALSE)
    {
        return(KRB_ERR_GENERIC);    // string length would not fit into USHORT
    }

    *KerbString = TempString;
    return(KDC_ERR_NONE);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbStringToUnicodeString
//
//  Synopsis:   Converts a kerberos string to a unicode string
//
//  Effects:    allocates result string with MIDL_user_allocate
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KerbStringToUnicodeString(
    OUT PUNICODE_STRING String,
    IN PSTRING KerbString
    )
{
    PCHAR TerminatedString;
    UNICODE_STRING TempString;
    BOOL fAssigned = FALSE;

    if (!ARGUMENT_PRESENT(KerbString) || !ARGUMENT_PRESENT(String))
    {
        return(KRB_ERR_GENERIC);
    }
    //
    // Null terminate the string
    //

    if ((KerbString->MaximumLength > KerbString->Length) &&
        (KerbString->Buffer[KerbString->Length] == '\0'))
    {
        TerminatedString = KerbString->Buffer;
    }
    else
    {
        //
        // Validate inputs before doing alloc.. This is because the Length can only be USHORT_MAX - 1 - sizeof(CHAR)
        // or we'll set max_length == 0.
        //
        if ( KerbString->Length > KERB_MAX_STRING )
        {
            return (KRB_ERR_GENERIC);
        } 

        TerminatedString = (PCHAR) MIDL_user_allocate(KerbString->Length + sizeof(CHAR));
        if (TerminatedString == NULL)
        {
            return(KRB_ERR_GENERIC);
        }
        RtlCopyMemory(
            TerminatedString,
            KerbString->Buffer,
            KerbString->Length
            );
        TerminatedString[KerbString->Length] = '\0';
    }

    TempString.Buffer = KerbAllocWStrFromUtf8Str(
                            TerminatedString
                            );
    if (TerminatedString != KerbString->Buffer)
    {
        MIDL_user_free(TerminatedString);
    }

    if (TempString.Buffer == NULL)
    {
        return(KRB_ERR_GENERIC);
    }

    fAssigned = SafeRtlInitUnicodeString(
        &TempString,
        TempString.Buffer
        );

    if (fAssigned == FALSE)
    {
        MIDL_user_free(TempString.Buffer);
        return(KRB_ERR_GENERIC);
    }

    *String = TempString;
    return(KDC_ERR_NONE);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbComparePrincipalNames
//
//  Synopsis:   Compares two principal names for equality
//
//  Effects:
//
//  Arguments:  Name1 - the first principal name
//              Name2 - the second principal name
//
//  Requires:
//
//  Returns:    TRUE for eqaulity, FALSE for non-equality.
//
//  Notes:
//
//
//--------------------------------------------------------------------------

BOOLEAN
KerbComparePrincipalNames(
    IN PKERB_PRINCIPAL_NAME Name1,
    IN PKERB_PRINCIPAL_NAME Name2
    )
{
    BOOLEAN Result = TRUE;
    PKERB_PRINCIPAL_NAME_ELEM NextName1, NextName2;

    if ((Name1 == NULL) && (Name2 == NULL))
    {
        return TRUE;
    }
    else if ((Name1 == NULL) || (Name2 == NULL))
    {
        return FALSE;
    }

    //
    // If the name types are known, make sure they match.
    //

    if ((Name1->name_type != KRB_NT_UNKNOWN) &&
        (Name2->name_type != KRB_NT_UNKNOWN) &&
        (Name1->name_type != Name2->name_type))
    {
        Result = FALSE;
        goto Cleanup;
    }

    NextName1 = Name1->name_string;
    NextName2 = Name2->name_string;

    while ((NextName1 != NULL) && (NextName2 != NULL))
    {
        if (lstrcmpiA(
                NextName1->value,
                NextName2->value
                ) != 0)
        {
            Result = FALSE;
            goto Cleanup;
        }
        NextName1 = NextName1->next;
        NextName2 = NextName2->next;

    }

    //
    // if one has more names than the other, fail
    //

    if (!((NextName1 == NULL) && (NextName2 == NULL)))
    {
        Result = FALSE;
        goto Cleanup;
    }

    return(TRUE);

Cleanup:

    //
    // BUG 455493: transitional code
    //

    if (Result == FALSE)
    {
        KERBERR KerbErr;
        ULONG NameType;
        UNICODE_STRING UName1;
        UNICODE_STRING UName2;

        KerbErr = KerbConvertPrincipalNameToString(
                    &UName1,
                    &NameType,
                    Name1
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            return(FALSE);
        }
        KerbErr = KerbConvertPrincipalNameToString(
                    &UName2,
                    &NameType,
                    Name2
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            KerbFreeString(&UName1);
            return(FALSE);
        }
        Result = RtlEqualUnicodeString(
                    &UName1,
                    &UName2,
                    TRUE
                    );

        KerbFreeString( &UName1 );
        KerbFreeString( &UName2 );

        // FESTER
        // IF THIS ASSERT GETS FIRED, Contact Todds (0x30864)
        // This code *should* be transitional, and I've not seen it called,
        // but the only way to be certain is to add Assert and let it rot in
        // Whistler...  Remove before B2.
        //
        if (Result)
        {
            D_DebugLog((DEB_ERROR,"Assert about to fire.  Dead code called. Contact Todds\n"));
            DsysAssert(FALSE);
        }
    }
    return (Result);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbCompareRealmNames
//
//  Synopsis:   Compares two realm names for equality
//
//  Effects:
//
//  Arguments:  Realm1 - First realm to compare
//              Realm2 - Second realm to compare
//
//  Requires:
//
//  Returns:    TRUE if they are equal, FALSE otherwise
//
//  Notes:
//
//
//--------------------------------------------------------------------------

BOOLEAN
KerbCompareRealmNames(
    IN PKERB_REALM Realm1,
    IN PKERB_REALM Realm2
    )
{
    INT len1;
    INT len2;
    INT retval;
    
    
    if ((Realm1 == NULL) && (Realm2 == NULL))
    {
        return TRUE;
    }
    else if ((Realm1 == NULL) || (Realm2 == NULL))
    {
        return FALSE;
    }

    len1 = (INT) strlen( *Realm1 );
    len2 = (INT) strlen( *Realm2 );

    //
    // Check if any trailing '.' need to be stripped off
    //

    if ( len2 != len1 )
    {
        if ( len2 == len1+1 )
        {
            if ( (*Realm2)[len1] != '.' )
            {
                return( FALSE );
            }

            //
            //  len1 is comparable length
            //
        }
        else if ( len2+1 == len1 )
        {
            if ( (*Realm1)[len2] != '.' )
            {
                return( FALSE );
            }

            //
            //  len1 is set to comparable length
            //

            len1 = len2;
        }
        else
        {
            return( FALSE );
        }
    }

    retval = CompareStringA( GetSystemDefaultLCID(),
                             LOCALE_USE_CP_ACP | NORM_IGNORECASE,
                             (*Realm1),
                             len1,
                             (*Realm2),
                             len1
                              );      

    return ( retval == CSTR_EQUAL );
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbCompareUnicodeRealmNames
//
//  Synopsis:   Compares two realm names for equality
//
//  Effects:
//
//  Arguments:  Realm1 - First realm to compare
//              Realm2 - Second realm to compare
//
//  Requires:
//
//  Returns:    TRUE if they are equal, FALSE otherwise
//
//  Notes:
//
//
//--------------------------------------------------------------------------

BOOLEAN
KerbCompareUnicodeRealmNames(
    IN PUNICODE_STRING Domain1,
    IN PUNICODE_STRING Domain2
    )
{
    UNICODE_STRING Realm1 = {0};
    UNICODE_STRING Realm2 = {0};

    if ((Domain1 == NULL) && (Domain2 == NULL))
    {
        return TRUE;
    }
    else if ((Domain1 == NULL) || (Domain2 == NULL))
    {
        return FALSE;
    }
    else if ((Domain1->Buffer == NULL) && (Domain2->Buffer == NULL))
    {
        return(TRUE);
    }
    else if ((Domain1->Buffer == NULL) || (Domain2->Buffer == NULL))
    {
        return(FALSE);
    }

    Realm1 = *Domain1;
    Realm2 = *Domain2;

    //
    // Check if any trailing '.' need to be stripped off
    //

    if ( Realm2.Length != Realm1.Length )
    {
        if ( Realm2.Length == Realm1.Length+sizeof(WCHAR) )
        {
            if ( Realm2.Buffer[Realm1.Length / sizeof(WCHAR)] != '.' )
            {
                return( FALSE );
            }
            else
            {
                Realm2.Length = Realm1.Length;
            }
        }
        else if ( Realm2.Length+sizeof(WCHAR) == Realm1.Length )
        {
            if ( Realm1.Buffer[Realm2.Length / sizeof(WCHAR)] != '.' )
            {
                return( FALSE );
            }
            else
            {
                Realm1.Length = Realm2.Length;
            }
        }
        else
        {
            return( FALSE );
        }
    }

    //
    //  compare only comparable length of string
    //

    return( RtlEqualUnicodeString( &Realm1, &Realm2, TRUE ));

}

//+-------------------------------------------------------------------------
//
//  Function:   KdcFreeKdcName
//
//  Synopsis:   Frees all parts of a KDC name structure
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbFreeKdcName(
    IN PKERB_INTERNAL_NAME *  KdcName
    )
{
    if (*KdcName != NULL)
    {
        MIDL_user_free(*KdcName);
        *KdcName = NULL;
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbConvertPrincipalNameToKdcName
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KerbConvertPrincipalNameToKdcName(
    OUT PKERB_INTERNAL_NAME * OutputName,
    IN PKERB_PRINCIPAL_NAME PrincipalName
    )
{
    NTSTATUS Status;
    KERBERR KerbErr = KDC_ERR_NONE;
    ULONG NameCount = 0;
    ULONG Index;
    STRING Names[MAX_NAME_ELEMENTS+1];
    PKERB_PRINCIPAL_NAME_ELEM NameElement;
    PKERB_INTERNAL_NAME KdcName = NULL;
    ULONG NameSize = 0;
    ULONG NameLength = 0;
    PUCHAR Where;
    BOOL fAssigned = FALSE;

    NameElement = PrincipalName->name_string;
    while (NameElement!= NULL)
    {
        //  Verify we do not overrun a USHORT length
        fAssigned = SafeRtlInitString(
                            &Names[NameCount],
                            NameElement->value
                            );
        if (fAssigned == FALSE)
        {
            D_DebugLog((DEB_ERROR,"KerbConvertPrincipalNameToKdcName:Name part too long\n"));
            return(KRB_ERR_GENERIC);
        }
        NameLength += (Names[NameCount].Length + 1) * sizeof(WCHAR);
        NameCount++;
        NameElement = NameElement->next;
        if (NameCount > MAX_NAME_ELEMENTS)
        {
            D_DebugLog((DEB_ERROR,"Too many name parts: %d\n",NameCount));
            return(KRB_ERR_GENERIC);
        }
    }

    // check to make sure size fits into a USHORT value (with NULL appended)
    // NameLength will be casted to USHORT below.
    if (NameLength > KERB_MAX_UNICODE_STRING)        
    {
        D_DebugLog((DEB_ERROR,"KerbConvertPrincipalNameToKdcName: Overall size too large\n"));
        return(KRB_ERR_GENERIC);
    }

    //
    // Now we have the count of parts, so allocate the destination structure
    //

    if (NameCount == 0)
    {
        D_DebugLog((DEB_ERROR,"Illegal name with zero parts\n"));
        return(KRB_ERR_GENERIC);
    }

    NameSize = KERB_INTERNAL_NAME_SIZE(NameCount) + NameLength;
    KdcName = (PKERB_INTERNAL_NAME) MIDL_user_allocate(NameSize);
    if (KdcName == NULL)
    {
        return(KRB_ERR_GENERIC);
    }

    RtlZeroMemory(
        KdcName,
        NameSize
        );
    KdcName->NameCount = (USHORT) NameCount;
    KdcName->NameType = (USHORT) PrincipalName->name_type;

    Where = (PUCHAR) KdcName + KERB_INTERNAL_NAME_SIZE(NameCount);

    //
    // Now convert all the strings from the temporary array into
    // UNICODE_STRINGs in the final array
    //

    for (Index = 0; Index < NameCount ; Index++ )
    {
        KdcName->Names[Index].Length = 0;
        KdcName->Names[Index].MaximumLength = (USHORT)NameLength;
        KdcName->Names[Index].Buffer = (LPWSTR) Where;
        Status = KerbUnicodeStringFromUtf8Str(
                    Names[Index].Buffer,
                    &KdcName->Names[Index]
                    );
        if (!NT_SUCCESS(Status))
        {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }
        Where += KdcName->Names[Index].MaximumLength;
        NameLength = NameLength - KdcName->Names[Index].MaximumLength;
    }
    *OutputName = KdcName;
    KdcName = NULL;

Cleanup:
    if (KdcName != NULL)
    {
        KerbFreeKdcName(&KdcName);
    }
    return(KerbErr);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbCovnertKdcNameToPrincipalName
//
//  Synopsis:   Converts a KDC name to a Principal name & allocates output with
//              MIDL_user_allocate
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KerbConvertKdcNameToPrincipalName(
    OUT PKERB_PRINCIPAL_NAME PrincipalName,
    IN PKERB_INTERNAL_NAME KdcName
    )
{
    PKERB_PRINCIPAL_NAME_ELEM Elem = NULL;
    PKERB_PRINCIPAL_NAME_ELEM * Last;
    STRING TempKerbString = {0};
    KERBERR KerbErr = KDC_ERR_NONE;
    ULONG Index;

    PrincipalName->name_type = (int) KdcName->NameType;
    PrincipalName->name_string = NULL;
    Last = &PrincipalName->name_string;

    //
    // Index through the KDC name and add each element to the list
    //

    for (Index = 0; Index < KdcName->NameCount ; Index++ )
    {
        KerbErr = KerbUnicodeStringToKerbString(
                    &TempKerbString,
                    &KdcName->Names[Index]
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }
        Elem = (PKERB_PRINCIPAL_NAME_ELEM) MIDL_user_allocate(sizeof(KERB_PRINCIPAL_NAME_ELEM));
        if (Elem == NULL)
        {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }
        Elem->value = TempKerbString.Buffer;
        Elem->next = NULL;
        *Last = Elem;
        Last = &Elem->next;
        TempKerbString.Buffer = NULL;
    }

Cleanup:

    if (!KERB_SUCCESS(KerbErr))
    {
        //
        // Cleanup the principal name
        //

        KerbFreePrincipalName(PrincipalName);

        if (TempKerbString.Buffer)
        {
            MIDL_user_free(TempKerbString.Buffer);
            TempKerbString.Buffer = NULL;
        }
    }

    return(KerbErr);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbEqualKdcNames
//
//  Synopsis:   Compares to KDC names for equality
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:    TRUE if the names are identical
//
//  Notes:
//
//
//--------------------------------------------------------------------------

BOOLEAN
KerbEqualKdcNames(
    IN PKERB_INTERNAL_NAME Name1,
    IN PKERB_INTERNAL_NAME Name2
    )
{
    BOOLEAN Equal = TRUE;
    ULONG Index;

    if ((Name1 == NULL) && (Name2 == NULL))
    {
        return TRUE;
    }
    else if ((Name1 == NULL) || (Name2 == NULL))
    {
        return FALSE;
    }

    //
    // Special case some Microsoft name types
    //

    if (Name1->NameCount != Name2->NameCount)
    {
        Equal = FALSE;
    }
    else
    {
        for (Index = 0; Index < Name1->NameCount ; Index++ )
        {
            if (!RtlEqualUnicodeString(
                    &Name1->Names[Index],
                    &Name2->Names[Index],
                    TRUE                        // case insensitive
                    ))
            {
                Equal = FALSE;
                break;
            }
        }
    }

    return(Equal);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbComparePrincipalNameToKdcName
//
//  Synopsis:   Compares a princial name to a KDC name by first converting
//              and then comparing.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KerbCompareKdcNameToPrincipalName(
    IN PKERB_PRINCIPAL_NAME PrincipalName,
    IN PKERB_INTERNAL_NAME KdcName,
    OUT PBOOLEAN Result
    )
{
    PKERB_INTERNAL_NAME TempName = NULL;

    DsysAssert(Result);

    if (!KERB_SUCCESS(KerbConvertPrincipalNameToKdcName(
                        &TempName,
                        PrincipalName
                        )))
    {
        return(KRB_ERR_GENERIC);
    }

    *Result = KerbEqualKdcNames( TempName, KdcName );

    KerbFreeKdcName( &TempName );
    return(KDC_ERR_NONE);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbDuplicateKdcName
//
//  Synopsis:   Duplicates an internal name by copying the pointer and
//              referencing the structure.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbDuplicateKdcName(
    OUT PKERB_INTERNAL_NAME * Destination,
    IN PKERB_INTERNAL_NAME Source
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    USHORT Index;
    PKERB_INTERNAL_NAME KdcName = NULL;
    ULONG NameSize = 0;
    ULONG NameLength = 0;
    PUCHAR Where;



    //
    // Now we have the count of parts, so allocate the destination structure
    //

    if (Source->NameCount == 0)
    {
        D_DebugLog((DEB_ERROR,"Illegal name with zero parts\n"));
        return(STATUS_INVALID_PARAMETER);
    }

    for (Index = 0; Index < Source->NameCount ; Index++ )
    {
        NameLength += Source->Names[Index].Length + sizeof(WCHAR);
    }

    NameSize = KERB_INTERNAL_NAME_SIZE(Source->NameCount) + NameLength;
    KdcName = (PKERB_INTERNAL_NAME) MIDL_user_allocate(NameSize);
    if (KdcName == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    RtlZeroMemory(
        KdcName,
        NameSize
        );
    KdcName->NameCount = (USHORT) Source->NameCount;
    Where = (PUCHAR) KdcName + KERB_INTERNAL_NAME_SIZE(Source->NameCount);

    //
    // Now convert all the strings from the temporary array into
    // UNICODE_STRINGs in the final array
    //

    for (Index = 0; Index < Source->NameCount ; Index++ )
    {
        if (Source->Names[Index].Length > KERB_MAX_UNICODE_STRING)
        {
            Status = STATUS_NAME_TOO_LONG;
            goto Cleanup;    // length will not fit into USHORT value
        }
        KdcName->Names[Index].Length = Source->Names[Index].Length;
        KdcName->Names[Index].MaximumLength = Source->Names[Index].Length + sizeof(WCHAR);
        KdcName->Names[Index].Buffer = (LPWSTR) Where;
        RtlCopyMemory(
            Where,
            Source->Names[Index].Buffer,
            Source->Names[Index].Length
            );
        KdcName->Names[Index].Buffer[Source->Names[Index].Length / sizeof(WCHAR)] = L'\0';
        Where += KdcName->Names[Index].MaximumLength;
    }
    KdcName->NameType = Source->NameType;
    *Destination = KdcName;
    KdcName = NULL;

Cleanup:
    if (KdcName != NULL)
    {
        KerbFreeKdcName(&KdcName);
    }
    return(Status);
}

#ifdef RETAIL_LOG_SUPPORT
VOID
KerbPrintKdcNameEx(
    IN ULONG DebugLevel,
    IN ULONG InfoLevel,
    IN PKERB_INTERNAL_NAME Name
    )
{
    ULONG Index;
    if ((InfoLevel & DebugLevel) != 0)
    {
        for (Index = 0; Name && (Index < Name->NameCount); Index++)
        {
            DebugLog((DebugLevel | DSYSDBG_CLEAN, " %wZ ", &Name->Names[Index]));
        }
        DebugLog((DebugLevel | DSYSDBG_CLEAN, "\n"));
    }
}

VOID
KerbPrintPrincipalName(
    IN ULONG DebugLevel,
    IN PKERB_PRINCIPAL_NAME Name
    )
{
    KERBERR KerbErr;
    PKERB_INTERNAL_NAME KdcName = NULL;

    KerbErr = KerbConvertPrincipalNameToKdcName(
                            &KdcName,
                            Name
                            );

    if (KERB_SUCCESS(KerbErr))
    {
        KerbPrintKdcNameEx(DebugLevel, DebugLevel, KdcName);
        KerbFreeKdcName(&KdcName);
    }
}

VOID
KerbPrintKerbRealm(
    IN ULONG DebugLevel,
    IN PKERB_REALM Realm
    )
{
    KERBERR KerbErr;
    UNICODE_STRING RealmName = {0};

    KerbErr = KerbConvertRealmToUnicodeString(
                            &RealmName,
                            Realm
                            );

    if (KERB_SUCCESS(KerbErr))
    {
        DebugLog((DebugLevel, "%wZ\n", &RealmName));
        KerbFreeString(&RealmName);
    }
}

#endif

//+-------------------------------------------------------------------------
//
//  Function:   KerbConvertStringToKdcName
//
//  Synopsis:   Converts a string to a KRB_NT_MS_PRINCIPAL kdc name
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KerbConvertStringToKdcName(
    OUT PKERB_INTERNAL_NAME * PrincipalName,
    IN PUNICODE_STRING String
    )
{
    PKERB_INTERNAL_NAME LocalName = NULL;

    LocalName = (PKERB_INTERNAL_NAME) MIDL_user_allocate(KERB_INTERNAL_NAME_SIZE(1) + String->Length + sizeof(WCHAR));
    if (LocalName == NULL)
    {
        return(KRB_ERR_GENERIC);
    }

    LocalName->NameCount = 1;
    LocalName->NameType = KRB_NT_MS_PRINCIPAL;
    LocalName->Names[0].Length = String->Length;
    LocalName->Names[0].MaximumLength = String->Length + sizeof(WCHAR);
    LocalName->Names[0].Buffer = (LPWSTR) ((PUCHAR) LocalName + KERB_INTERNAL_NAME_SIZE(1));
    RtlCopyMemory(
        LocalName->Names[0].Buffer,
        String->Buffer,
        String->Length
        );
    LocalName->Names[0].Buffer[String->Length/sizeof(WCHAR)] = L'\0';

    *PrincipalName = LocalName;
    return(KDC_ERR_NONE);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbConvertKdcNameToString
//
//  Synopsis:   Converts a KdcName to a '/' separated unicode string.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KerbConvertKdcNameToString(
    OUT PUNICODE_STRING String,
    IN PKERB_INTERNAL_NAME PrincipalName,
    IN OPTIONAL PUNICODE_STRING RealmName
    )
{
    ULONG StringLength = 0;
    ULONG Index;
    PBYTE Where;

    if (!ARGUMENT_PRESENT(PrincipalName) || !ARGUMENT_PRESENT(String))
    {
        return(KRB_ERR_GENERIC);
    }

    //
    // Count up the size of the name parts
    //

    for (Index = 0; Index < PrincipalName->NameCount ; Index++ )
    {
        StringLength = StringLength + PrincipalName->Names[Index].Length;
    }

    if (ARGUMENT_PRESENT(RealmName) && (RealmName->Length != 0))
    {
        StringLength = StringLength + (sizeof(WCHAR) + RealmName->Length);
    }

    //
    // Add in '/' separators and a null terminator
    //

    DsysAssert(PrincipalName->NameCount > 0);
    StringLength = StringLength + (PrincipalName->NameCount * sizeof(WCHAR));

    if ((StringLength - sizeof(WCHAR)) > KERB_MAX_UNICODE_STRING)
    {
        return(KRB_ERR_GENERIC);   // required size too large for Length
    }

    String->Buffer = (LPWSTR) MIDL_user_allocate(StringLength);
    if (String->Buffer == NULL)
    {
        return(KRB_ERR_GENERIC);
    }
    String->MaximumLength = (USHORT)StringLength;
    String->Length = (USHORT)(StringLength - sizeof(WCHAR));

    Where = (PBYTE) String->Buffer;

    for (Index = 0; Index < PrincipalName->NameCount ; Index++ )
    {
        //
        // Add a '/' before every segment but the first
        //

        if (Index != 0)
        {
            *((LPWSTR)(Where)) = L'/';
            Where += sizeof(WCHAR);
        }
        RtlCopyMemory(
            Where,
            PrincipalName->Names[Index].Buffer,
            PrincipalName->Names[Index].Length
            );
        Where += PrincipalName->Names[Index].Length;
    }
    if (ARGUMENT_PRESENT(RealmName) && (RealmName->Length != 0))
    {
        *((LPWSTR)(Where)) = L'@';
        Where += sizeof(WCHAR);

        RtlCopyMemory(
            Where,
            RealmName->Buffer,
            RealmName->Length
            );
        Where += RealmName->Length;

    }

    *((LPWSTR)(Where)) = L'\0';
    Where += sizeof(WCHAR);
    DsysAssert((Where - (PUCHAR) String->Buffer) == (LONG)StringLength);

    return(KDC_ERR_NONE);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbBuildFullServiceName
//
//  Synopsis:   Combines a service name and domain name to make a full
//              service name.
//
//  Effects:
//
//  Arguments:  DomainName - Domain name of service
//              Servicename - Name of service
//              FullServiceName - Receives full service name
//
//  Requires:
//
//  Returns:    KDC_ERR_NONE or KRB_ERR_GENERIC
//
//  Notes:      This is dependent on our DS naming conventions
//
//
//--------------------------------------------------------------------------

KERBERR
KerbBuildFullServiceName(
    IN PUNICODE_STRING DomainName,
    IN PUNICODE_STRING ServiceName,
    OUT PUNICODE_STRING FullServiceName
    )
{
    PUCHAR Where;
    ULONG ulLength = 0;

    FullServiceName->Buffer = NULL;

    ulLength = (ULONG)DomainName->Length +
               (ULONG)ServiceName->Length +
               sizeof(WCHAR);

    if (ulLength > KERB_MAX_UNICODE_STRING)
    {
        return(KRB_ERR_GENERIC);   // required size too large for Length
    }

    FullServiceName->Length = (USHORT)ulLength;

    FullServiceName->MaximumLength =
        FullServiceName->Length + sizeof(WCHAR);

    FullServiceName->Buffer = (LPWSTR) MIDL_user_allocate(
                                            FullServiceName->MaximumLength
                                            );
    if (FullServiceName->Buffer == NULL)
    {
        return(KRB_ERR_GENERIC);
    }

    Where = (PUCHAR) FullServiceName->Buffer;

    RtlCopyMemory(
        FullServiceName->Buffer,
        DomainName->Buffer,
        DomainName->Length
        );
    Where += DomainName->Length;

    if ((DomainName->Length !=0) && (ServiceName->Length != 0))
    {
        *(LPWSTR) Where = L'\\';
        Where += sizeof(WCHAR);
    }


    RtlCopyMemory(
        Where,
        ServiceName->Buffer,
        ServiceName->Length
        );

    Where += ServiceName->Length;
    FullServiceName->Length = (USHORT)(Where - (PUCHAR) FullServiceName->Buffer);
    *(LPWSTR) Where = L'\0';
    return(KDC_ERR_NONE);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbBuildEmailName
//
//  Synopsis:   Combines a service name and domain name to make an email
//              name = "service@domain".
//
//
//  Effects:
//
//  Arguments:  DomainName - Domain name of service
//              Servicename - Name of service
//              FullServiceName - Receives full service name
//
//  Requires:
//
//  Returns:    KDC_ERR_NONE or KRB_ERR_GENERIC
//
//  Notes:      This is dependent on our DS naming conventions
//
//
//--------------------------------------------------------------------------

KERBERR
KerbBuildEmailName(
    IN PUNICODE_STRING DomainName,
    IN PUNICODE_STRING ServiceName,
    OUT PUNICODE_STRING EmailName
    )
{
    PUCHAR Where;
    ULONG ulLength;

    EmailName->Buffer = NULL;

    ulLength = (ULONG)DomainName->Length +
               (ULONG)ServiceName->Length +
               sizeof(WCHAR);


    if (ulLength > KERB_MAX_UNICODE_STRING)
    {
        return(KRB_ERR_GENERIC);   // required size too large for Length
    }

    EmailName->Length = (USHORT)ulLength;

    EmailName->MaximumLength =
        EmailName->Length + sizeof(WCHAR);

    EmailName->Buffer = (LPWSTR) MIDL_user_allocate(
                                            EmailName->MaximumLength
                                            );
    if (EmailName->Buffer == NULL)
    {
        return(KRB_ERR_GENERIC);
    }

    Where = (PUCHAR) EmailName->Buffer;

    RtlCopyMemory(
        EmailName->Buffer,
        ServiceName->Buffer,
        ServiceName->Length
        );
    Where += ServiceName->Length;

    *(LPWSTR) Where = L'@';
    Where += sizeof(WCHAR);


    RtlCopyMemory(
        Where,
        DomainName->Buffer,
        DomainName->Length
        );

    Where += DomainName->Length;
    EmailName->Length = (USHORT)(Where - (PUCHAR) EmailName->Buffer);
    *(LPWSTR) Where = L'\0';
    return(KDC_ERR_NONE);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbBuildUnicodeSpn
//
//  Synopsis:   Builds a 2 part SPN
//
//  Effects:
//
//  Arguments:  DomainName - Domain name of service
//              ServiceName - Name of service
//              Spn - Receives full service name
//
//  Requires:
//
//  Returns:    KDC_ERR_NONE or KRB_ERR_GENERIC
//
//  Notes:      This is dependent on our DS naming conventions
//
//
//--------------------------------------------------------------------------
KERBERR
KerbBuildUnicodeSpn(
    IN PUNICODE_STRING DomainName,
    IN PUNICODE_STRING ServiceName,
    OUT PUNICODE_STRING UnicodeSpn
    )

{

    PWSTR Spn, tmp;
    ULONG BuffSize;
    BOOL fAssigned = FALSE;

    BuffSize = DomainName->MaximumLength +
                ServiceName->MaximumLength +
                (sizeof(WCHAR) * 2);

    Spn = (PWSTR) MIDL_user_allocate(BuffSize);
    if (NULL == Spn)
    {
        return KRB_ERR_GENERIC;
    }

    tmp = Spn;

    RtlCopyMemory(
        Spn,
        ServiceName->Buffer,
        ServiceName->Length
        );

    tmp += (ServiceName->Length / sizeof(WCHAR));
    *tmp = L'/';

    RtlCopyMemory(
        ++tmp,
        DomainName->Buffer,
        DomainName->Length
        );

    tmp += (DomainName->Length / sizeof(WCHAR));
    *tmp = L'\0';

    fAssigned = SafeRtlInitUnicodeString(
        UnicodeSpn,
        Spn
        );

    if (fAssigned == FALSE)
    {
        return(KRB_ERR_GENERIC);    // string length would not fit into USHORT
    }

    return KDC_ERR_NONE;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbBuildFullServiceKdcName
//
//  Synopsis:   Combines a service name and domain name to make a full
//              service name. If the name type is MS_PRINCIPAL they are
//              combined into one portion of the name, otherise left in
//              two portions
//
//  Effects:
//
//  Arguments:  DomainName - Domain name of service
//              ServiceName - Name of service
//              NameType - Type of name to produce
//              FullServiceName - Receives full service name
//
//  Requires:
//
//  Returns:    KDC_ERR_NONE or KRB_ERR_GENERIC
//
//  Notes:      This is dependent on our DS naming conventions
//
//
//--------------------------------------------------------------------------
KERBERR
KerbBuildFullServiceKdcName(
    IN PUNICODE_STRING DomainName,
    IN PUNICODE_STRING ServiceName,
    IN ULONG NameType,
    OUT PKERB_INTERNAL_NAME * FullServiceName
    )
{

    return(KerbBuildFullServiceKdcNameWithSid(
            DomainName,
            ServiceName,
            NULL,
            NameType,
            FullServiceName
            ));
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbBuildKpasswdName
//
//  Synopsis:   Builds the name of the kpasswd service
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
KerbBuildKpasswdName(
    OUT PKERB_INTERNAL_NAME * KpasswdName
    )
{
    UNICODE_STRING KpasswdServiceNames[2];

    //
    // Build the service name for the ticket
    //

    (void)RtlInitUnicodeString(
        &KpasswdServiceNames[0],
        KERB_KPASSWD_FIRST_NAME
        );

    (void)RtlInitUnicodeString(
        &KpasswdServiceNames[1],
        KERB_KPASSWD_SECOND_NAME
        );

    if (!KERB_SUCCESS(KerbBuildFullServiceKdcName(
                        &KpasswdServiceNames[1],
                        &KpasswdServiceNames[0],
                        KRB_NT_SRV_INST,
                        KpasswdName
                        )))

    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }
    return(STATUS_SUCCESS);

}


//+-------------------------------------------------------------------------
//
//  Function:   KerbBuildFullServiceKdcNameWithSid
//
//  Synopsis:   Combines a service name and domain name to make a full
//              service name. If the name type is MS_PRINCIPAL they are
//              combined into one portion of the name, otherise left in
//              two portions. If a sid is presenet, it is tacked on as
//              the last segment of the name
//
//  Effects:
//
//  Arguments:  DomainName - Domain name of service
//              ServiceName - Name of service
//              Sid - Optionally contains the sid to use
//              NameType - Type of name to produce
//              FullServiceName - Receives full service name
//
//  Requires:
//
//  Returns:    KDC_ERR_NONE or KRB_ERR_GENERIC
//
//  Notes:      This is dependent on our DS naming conventions
//
//
//--------------------------------------------------------------------------
KERBERR
KerbBuildFullServiceKdcNameWithSid(
    IN PUNICODE_STRING DomainName,
    IN PUNICODE_STRING ServiceName,
    IN OPTIONAL PSID Sid,
    IN ULONG NameType,
    OUT PKERB_INTERNAL_NAME * FullServiceName
    )
{
    PKERB_INTERNAL_NAME FinalName = NULL;
    PUCHAR Where;
    ULONG NameParts;
    ULONG NameLength = 0;
    ULONG ulLength = 0;
    WCHAR SidBuffer[256];
    UNICODE_STRING SidString;
    KERBERR KerbErr = KRB_ERR_GENERIC;

    SidString.Length = 0;
    SidString.MaximumLength = sizeof(SidBuffer);
    SidString.Buffer = SidBuffer;

    if ((NameType == KRB_NT_MS_PRINCIPAL) ||
        (NameType == KRB_NT_MS_PRINCIPAL_AND_ID))

    {
        NameParts = 1;
        NameLength = DomainName->Length + ServiceName->Length + 2*sizeof(WCHAR);
    }
    else if ((NameType == KRB_NT_PRINCIPAL) ||
            (NameType == KRB_NT_PRINCIPAL_AND_ID) ||
            (NameType == KRB_NT_ENTERPRISE_PRINCIPAL) ||
            (NameType == KRB_NT_ENT_PRINCIPAL_AND_ID))
    {
        NameParts = 1;
        NameLength = ServiceName->Length + sizeof(WCHAR);
    }
    else
    {
        NameParts = 2;
        NameLength = DomainName->Length + ServiceName->Length + 2*sizeof(WCHAR);
    }

    //
    // If a SID is present, add another name part
    //

    if (ARGUMENT_PRESENT(Sid))
    {
        NTSTATUS Status;
        Status = KerbConvertSidToString(
                    Sid,
                    &SidString,
                    FALSE               // don't allocate
                    );
        if (!NT_SUCCESS(Status))
        {
            return(KRB_ERR_GENERIC);
        }
        NameParts++;
        NameLength += SidString.Length + sizeof(WCHAR);
    }


    *FullServiceName = NULL;

    FinalName = (PKERB_INTERNAL_NAME) MIDL_user_allocate(KERB_INTERNAL_NAME_SIZE(NameParts) + NameLength);
    if (FinalName == NULL)
    {
        return(KRB_ERR_GENERIC);
    }
    RtlZeroMemory(
        FinalName,
        KERB_INTERNAL_NAME_SIZE(NameParts) + NameLength
        );

    Where = (PUCHAR) FinalName + KERB_INTERNAL_NAME_SIZE(NameParts);
    FinalName->NameType = (USHORT) NameType;
    FinalName->NameCount = (USHORT) NameParts;

    if ((NameType == KRB_NT_MS_PRINCIPAL) ||
        (NameType == KRB_NT_MS_PRINCIPAL_AND_ID))
    {
        //
        // If the domain name does not have an initial '\', reserve space for one
        //

        FinalName->Names[0].Buffer = (LPWSTR) Where;

        // This is dependent on our naming conventions.
        //
        // The full service name is the '\' domain name ':' service name.
        //

        ulLength = (ULONG)DomainName->Length +
                   (ULONG)ServiceName->Length +
                   sizeof(WCHAR);

        if (ulLength > KERB_MAX_UNICODE_STRING)
        {
            KerbErr = KRB_ERR_GENERIC;   // required size too large for Length
            goto Cleanup;
        }

        FinalName->Names[0].Length = (USHORT)ulLength;

        FinalName->Names[0].MaximumLength =
            FinalName->Names[0].Length + sizeof(WCHAR);


        RtlCopyMemory(
            FinalName->Names[0].Buffer,
            DomainName->Buffer,
            DomainName->Length
            );
        Where += DomainName->Length;

        if ((DomainName->Length !=0) && (ServiceName->Length != 0))
        {
            *(LPWSTR) Where = L'\\';
            Where += sizeof(WCHAR);
        }


        RtlCopyMemory(
            Where,
            ServiceName->Buffer,
            ServiceName->Length
            );

        Where += ServiceName->Length;
        ulLength = (ULONG)(Where - (PUCHAR) FinalName->Names[0].Buffer);

        if (ulLength > KERB_MAX_UNICODE_STRING)
        {
            KerbErr = KRB_ERR_GENERIC;   // required size too large for Length
            goto Cleanup;
        }

        FinalName->Names[0].Length = (USHORT)ulLength;
        *(LPWSTR) Where = L'\0';
    }
    else if ((NameType == KRB_NT_PRINCIPAL) ||
             (NameType == KRB_NT_PRINCIPAL_AND_ID) ||
             (NameType == KRB_NT_ENTERPRISE_PRINCIPAL)||
             (NameType == KRB_NT_ENT_PRINCIPAL_AND_ID))
    {
        //
        // Principals have no domain name
        //

        FinalName->Names[0].Length = ServiceName->Length;
        FinalName->Names[0].MaximumLength = ServiceName->Length + sizeof(WCHAR);
        FinalName->Names[0].Buffer = (LPWSTR) Where;

        RtlCopyMemory(
            Where,
            ServiceName->Buffer,
            ServiceName->Length
            );
        Where += ServiceName->Length;
        *((LPWSTR) Where) = L'\0';

    }
    else
    {

        FinalName->Names[0].Length = ServiceName->Length;
        FinalName->Names[0].MaximumLength = ServiceName->Length + sizeof(WCHAR);
        FinalName->Names[0].Buffer = (LPWSTR) Where;

        RtlCopyMemory(
            Where,
            ServiceName->Buffer,
            ServiceName->Length
            );
        Where += ServiceName->Length;
        *((LPWSTR) Where) = L'\0';
        Where += sizeof(WCHAR);


        FinalName->Names[1].Length = DomainName->Length;
        FinalName->Names[1].MaximumLength = DomainName->Length + sizeof(WCHAR);
        FinalName->Names[1].Buffer = (LPWSTR) Where;

        RtlCopyMemory(
            Where,
            DomainName->Buffer,
            DomainName->Length
            );
        Where += DomainName->Length;
        *((LPWSTR) Where) = L'\0';
        Where += sizeof(WCHAR);

    }

    //
    // Append the string, if present
    //

    if (ARGUMENT_PRESENT(Sid))
    {
        FinalName->Names[NameParts-1].Length = SidString.Length;
        FinalName->Names[NameParts-1].MaximumLength = SidString.Length + sizeof(WCHAR);
        FinalName->Names[NameParts-1].Buffer = (LPWSTR) Where;

        RtlCopyMemory(
            Where,
            SidString.Buffer,
            SidString.Length
            );
        Where += SidString.Length;
        *((LPWSTR) Where) = L'\0';
    }

    *FullServiceName = FinalName;
    FinalName = NULL;
    KerbErr = KDC_ERR_NONE;

Cleanup:

    if (FinalName)
    {
        MIDL_user_free(FinalName);
    }

    return(KerbErr);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbExtractSidFromKdcName
//
//  Synopsis:   Extracts the sid portion from a KDC name with a sid. This
//              routine also decrements the name count so that future
//              users of the name don't see the sid.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
KERBERR
KerbExtractSidFromKdcName(
    IN OUT PKERB_INTERNAL_NAME Name,
    OUT PSID * Sid
    )
{
    NTSTATUS Status;

    DsysAssert(Sid);

    //
    // The sid is in the last portion of the name.
    //

    Status = KerbConvertStringToSid(
                &Name->Names[Name->NameCount-1],
                Sid
                );
    if (NT_SUCCESS(Status))
    {
        Name->NameCount--;
    }
    else
    {
        //
        // If the name wasn't a sid, return success. If it was another
        // problem, return an error
        //

        if (Status != STATUS_INVALID_PARAMETER)
        {
            return(KRB_ERR_GENERIC);
        }
    }
    return(KDC_ERR_NONE);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbDuplicateStringEx
//
//  Synopsis:   Duplicates a UNICODE_STRING. If the source string buffer is
//              NULL the destionation will be too.  The EX function doesn't
//              automatically NULL terminate your buffer...
//
//  Effects:    allocates memory with LsaFunctions.AllocateLsaHeap
//
//  Arguments:  DestinationString - Receives a copy of the source string
//              SourceString - String to copy
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS - the copy succeeded
//              STATUS_INSUFFICIENT_RESOURCES - the call to allocate
//                  memory failed.
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
KerbDuplicateStringEx(
    OUT PUNICODE_STRING DestinationString,
    IN OPTIONAL PUNICODE_STRING SourceString,
    IN BOOLEAN NullTerminate
    )
{   
    ULONG Buffsize = SourceString->Length + (NullTerminate ? sizeof(WCHAR) :  0);

    if ((SourceString == NULL) || (SourceString->Buffer == NULL))
    {
        DestinationString->Buffer = NULL;
        DestinationString->Length = DestinationString->MaximumLength = 0;
        return(STATUS_SUCCESS);
    }

    //
    // Detect potential B.0.s here on USHORT
    //
    if (SourceString->Length > KERB_MAX_UNICODE_STRING ) 
    {
        // DsysAssert(FALSE);
        return (STATUS_NAME_TOO_LONG);
    }                                 

    DestinationString->Buffer = (LPWSTR) MIDL_user_allocate(Buffsize);
    if (DestinationString->Buffer == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    DestinationString->Length = SourceString->Length;
    DestinationString->MaximumLength = (USHORT) Buffsize;
    RtlCopyMemory(
        DestinationString->Buffer,
        SourceString->Buffer,
        SourceString->Length
        );


    if (NullTerminate)
    {
        DestinationString->Buffer[SourceString->Length/sizeof(WCHAR)] = L'\0';
    }

    return(STATUS_SUCCESS);

}


//+-------------------------------------------------------------------------
//
//  Function:   KerbDuplicateString
//
//  Synopsis:   Duplicates a UNICODE_STRING. If the source string buffer is
//              NULL the destionation will be too.
//
//  Effects:    allocates memory with LsaFunctions.AllocateLsaHeap
//
//  Arguments:  DestinationString - Receives a copy of the source string
//              SourceString - String to copy
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS - the copy succeeded
//              STATUS_INSUFFICIENT_RESOURCES - the call to allocate
//                  memory failed.
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
KerbDuplicateString(
    OUT PUNICODE_STRING DestinationString,
    IN OPTIONAL PUNICODE_STRING SourceString
    )
{
    return(KerbDuplicateStringEx(
                DestinationString,
                SourceString,
                TRUE
                ));

}


//+-------------------------------------------------------------------------
//
//  Function:   KerbBuildNullTerminatedString
//
//  Synopsis:   Converts a UNICODE_STRING to a NULL-termianted string
//
//  Effects:    allocates return with MIDL_user_allocate
//
//  Arguments:  String - string to null terminate.
//
//  Requires:
//
//  Returns:    NULL on error, a pointer on success
//
//  Notes:      an input string with a NULL buffer pointe results in a
//              return string consisting of just "\0"
//
//
//--------------------------------------------------------------------------
LPWSTR
KerbBuildNullTerminatedString(
    IN PUNICODE_STRING String
    )
{
    LPWSTR ReturnString;

    ReturnString = (LPWSTR) MIDL_user_allocate(String->Length + sizeof(WCHAR));
    if (ReturnString == NULL)
    {
        return(NULL);
    }
    if (String->Buffer != NULL)
    {
        RtlCopyMemory(
            ReturnString,
            String->Buffer,
            String->Length
            );
    }
    ReturnString[String->Length/sizeof(WCHAR)] = L'\0';
    return(ReturnString);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbFreeString
//
//  Synopsis:   Frees a string allocated by KerbDuplicateString
//
//  Effects:
//
//  Arguments:  String - Optionally points to a UNICODE_STRING
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
VOID
KerbFreeString(
    IN OPTIONAL PUNICODE_STRING String
    )
{
    if (ARGUMENT_PRESENT(String) && String->Buffer != NULL)
    {
        MIDL_user_free(String->Buffer);
        ZeroMemory(String, sizeof(UNICODE_STRING));
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbFreeRealm
//
//  Synopsis:   Frees a realm allcoated with KerbConvertXXXToRealm
//
//  Effects:    null out the realm.
//
//  Arguments:  Realm - Realm to free
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
VOID
KerbFreeRealm(
    IN PKERB_REALM Realm
    )
{
    if (*Realm != NULL)
    {
        MIDL_user_free(*Realm);
        *Realm = NULL;
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbCompareUnicodeRealmToKerbRealm
//
//  Synopsis:   Compares a kerb_realm to a unicode kerb realm
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


KERBERR
KerbCompareUnicodeRealmToKerbRealm(
    IN PKERB_REALM KerbRealm,
    IN PUNICODE_STRING UnicodeRealm,
    OUT PBOOLEAN Result
    )
{
    KERB_REALM TempName = NULL;


    if (!KERB_SUCCESS(KerbConvertUnicodeStringToRealm(
                        &TempName,
                        UnicodeRealm
                        )))
    {
        return(KRB_ERR_GENERIC);
    }

    *Result = KerbCompareRealmNames(&TempName, KerbRealm);

    KerbFreeRealm( &TempName );
    return(KDC_ERR_NONE);

}

//+-------------------------------------------------------------------------
//
//  Function:   KerbFreePrincipalName
//
//  Synopsis:   Frees a principal name allocated with KerbConvertxxxToPrincipalName
//
//  Effects:    zeros out principal name so it won't be freed again
//
//  Arguments:  Name - The name to free
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
VOID
KerbFreePrincipalName(
    IN PKERB_PRINCIPAL_NAME Name
    )
{
    PKERB_PRINCIPAL_NAME_ELEM Elem,NextElem;

    Elem = Name->name_string;
    while (Elem != NULL)
    {
        if (Elem->value != NULL)
        {
            MIDL_user_free(Elem->value);
        }
        NextElem = Elem->next;
        MIDL_user_free(Elem);
        Elem = NextElem;
    }
    Name->name_string = NULL;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbConvertUnicodeStringToRealm
//
//  Synopsis:   Converts a unicode-string form of a domain name to a
//              KERB_REALM structure.
//
//  Effects:
//
//  Arguments:  Realm - the realm
//              String - The string to convert
//
//  Requires:
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------
KERBERR
KerbConvertUnicodeStringToRealm(
    OUT PKERB_REALM Realm,
    IN PUNICODE_STRING String
    )
{
    KERBERR KerbErr;
    STRING TempString = {0};

    *Realm = NULL;
    KerbErr = KerbUnicodeStringToKerbString(
                  &TempString,
                  String
                  );

    if (!KERB_SUCCESS(KerbErr))
    {
        return(KerbErr);
    }
    *Realm = TempString.Buffer;
    return(KDC_ERR_NONE);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbConvertRealmToUnicodeString
//
//  Synopsis:   Converts a KERB_REALM structure to a unicode-string form
//              of a domain name.
//
//  Effects:
//
//  Arguments:  String - the unicode realm name
//              Realm - the realm to convert
//
//  Requires:
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KerbConvertRealmToUnicodeString(
    OUT PUNICODE_STRING String,
    IN PKERB_REALM Realm
    )
{
    KERBERR Status;
    STRING TempString;
    BOOL fAssigned = FALSE;

    fAssigned = SafeRtlInitString(
            &TempString,
            *Realm
            );
    if (fAssigned == FALSE)
    {
        return(KRB_ERR_GENERIC);
    }

    Status = KerbStringToUnicodeString(
                String,
                &TempString
                );
    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbDuplicateRealm
//
//  Synopsis:   Duplciates a realm name
//
//  Effects:
//
//  Arguments:  Realm - the realm
//              SourceRealm - The realm to duplicate
//
//  Requires:
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------
KERBERR
KerbDuplicateRealm(
    OUT PKERB_REALM Realm,
    IN KERB_REALM SourceRealm
    )
{
    ULONG RealmLength;

    if (ARGUMENT_PRESENT(SourceRealm))
    {
        RealmLength = lstrlenA(SourceRealm);
        *Realm = (PCHAR) MIDL_user_allocate(RealmLength + sizeof(CHAR));
        if (*Realm == NULL)
        {
            return(KRB_ERR_GENERIC);
        }
        RtlCopyMemory(
            *Realm,
            SourceRealm,
            RealmLength + sizeof(CHAR)
            );
    }
    else
    {
        *Realm = NULL;
    }
    return(KDC_ERR_NONE);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbCompareStringToPrincipalName
//
//  Synopsis:   Compares a unicode string name to a principal name for
//              equality
//
//  Effects:
//
//  Arguments:  PrincipalName - kerberos principal name
//              String - String name
//
//  Requires:
//
//  Returns:    TRUE if one of the principal names matches the string name
//
//  Notes:
//
//
//--------------------------------------------------------------------------
BOOLEAN
KerbCompareStringToPrincipalName(
    IN PKERB_PRINCIPAL_NAME PrincipalName,
    IN PUNICODE_STRING String
    )
{
    KERBERR Status;
    BOOLEAN FoundMatch = FALSE;
    UNICODE_STRING TempString = {0};
    ULONG NameType;

    Status = KerbConvertPrincipalNameToString(
                &TempString,
                &NameType,
                PrincipalName
                );

    if (!KERB_SUCCESS(Status))
    {
        return(FALSE);
    }

    if (RtlEqualUnicodeString(
            &TempString,
            String,
            TRUE                        // case insensitive
            ))
    {
        FoundMatch = TRUE;
    }

    KerbFreeString(&TempString);
    return(FoundMatch);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbConvertStringToPrincipalName
//
//  Synopsis:   converts a string to a principal name
//
//  Effects:    allocate memory
//
//  Arguments:  PrincipalName - receives the principal name
//              String - the string name to convert
//
//  Requires:
//
//  Returns:    KDC_ERR_NONE or STATUS_INSUFFICIENT_MEMORY
//
//  Notes:      principalname->name_value must be freed with MIDL_user_free and
//                  principalname->name_value->value must be freed with
//                  MIDL_user_Free.
//
//
//--------------------------------------------------------------------------

KERBERR
KerbConvertStringToPrincipalName(
    OUT PKERB_PRINCIPAL_NAME PrincipalName,
    IN PUNICODE_STRING String,
    IN ULONG NameType
    )
{
    PKERB_PRINCIPAL_NAME_ELEM Elem;
    STRING TempKerbString;
    KERBERR Status = KDC_ERR_NONE;
    UNICODE_STRING TempElemString;
    UNICODE_STRING TempString;
    ULONG Index;
    ULONG ulLength;

    RtlZeroMemory(
        PrincipalName,
        sizeof(KERB_PRINCIPAL_NAME)
        );

    PrincipalName->name_type = (int) NameType;

    //
    // MS principals are stuck all in one string
    //

    if (NameType == KRB_NT_MS_PRINCIPAL)
    {
        Status = KerbUnicodeStringToKerbString(
                    &TempKerbString,
                    String
                    );

        if (!KERB_SUCCESS(Status))
        {
            goto Cleanup;
        }
        Elem = (PKERB_PRINCIPAL_NAME_ELEM) MIDL_user_allocate(sizeof(KERB_PRINCIPAL_NAME_ELEM));
        if (Elem == NULL)
        {
            MIDL_user_free(TempKerbString.Buffer);
            Status = KRB_ERR_GENERIC;
            goto Cleanup;
        }
        Elem->value = TempKerbString.Buffer;
        Elem->next = PrincipalName->name_string;
        PrincipalName->name_string = Elem;

        Status = KDC_ERR_NONE;
        goto Cleanup;
    }
    else
    {
        //
        // Go through the string. If we hit  a '\\' separator, split
        // the name there into another component.
        //

        TempString = *String;
        Index = 0;

        while (Index <= TempString.Length / sizeof(WCHAR))
        {
            if ((Index == TempString.Length/sizeof(WCHAR)) ||
                (TempString.Buffer[Index] == L'\\') )
            {
                //
                // Build the element string
                //

                ulLength = Index * sizeof(WCHAR);

                if (ulLength > KERB_MAX_UNICODE_STRING)
                {
                    Status = KRB_ERR_GENERIC;    // length exceed USHORT range
                    goto Cleanup;
                }

                TempElemString.Buffer = TempString.Buffer;
                TempElemString.MaximumLength = (USHORT) ulLength;
                TempElemString.Length = TempElemString.MaximumLength;

                Status = KerbUnicodeStringToKerbString(
                            &TempKerbString,
                            &TempElemString
                            );

                if (!KERB_SUCCESS(Status))
                {
                    goto Cleanup;
                }

                Elem = (PKERB_PRINCIPAL_NAME_ELEM) MIDL_user_allocate(sizeof(KERB_PRINCIPAL_NAME_ELEM));
                if (Elem == NULL)
                {
                    MIDL_user_free(TempKerbString.Buffer);
                    Status = KRB_ERR_GENERIC;
                    goto Cleanup;
                }

                Elem->value = TempKerbString.Buffer;
                Elem->next = PrincipalName->name_string;
                PrincipalName->name_string = Elem;

                //
                // Reset the string to be the remains of the name
                //

                if (Index != TempString.Length / sizeof(WCHAR))
                {
                    ulLength = (Index+1) * sizeof(WCHAR);

                    if (ulLength > KERB_MAX_UNICODE_STRING)
                    {
                        Status = KRB_ERR_GENERIC;    // length exceed USHORT range
                        goto Cleanup;
                    }
                    TempString.Buffer = TempString.Buffer + Index + 1;
                    TempString.Length = TempString.Length - (USHORT) ulLength;
                    TempString.MaximumLength = TempString.MaximumLength - (USHORT) ulLength;
                    Index = 0;
                }
                else
                {
                    break;
                }
            }
            else
            {
                Index++;
            }
        }
    }

Cleanup:

    if (!KERB_SUCCESS(Status))
    {
        KerbFreePrincipalName(PrincipalName);
    }

    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbDuplicatePrincipalName
//
//  Synopsis:   Duplicates  a principal name
//
//  Effects:    allocate memory
//
//  Arguments:  PrincipalName - receives the principal name
//              SourcePrincipalName - the name to copy
//
//  Requires:
//
//  Returns:    KDC_ERR_NONE or STATUS_INSUFFICIENT_MEMORY
//
//  Notes:      principalname->name_value must be freed with MIDL_user_free and
//                  principalname->name_value->value must be freed with
//                  MIDL_user_Free.
//
//
//--------------------------------------------------------------------------
KERBERR
KerbDuplicatePrincipalName(
    OUT PKERB_PRINCIPAL_NAME PrincipalName,
    IN PKERB_PRINCIPAL_NAME SourcePrincipalName
    )
{
    KERBERR Status = KDC_ERR_NONE;
    ULONG NameLen;
    PKERB_PRINCIPAL_NAME_ELEM SourceElem;
    PKERB_PRINCIPAL_NAME_ELEM DestElem;
    PKERB_PRINCIPAL_NAME_ELEM * NextElem;

    // DSYSASSERT(PrincipalName);
    // DSYSASSERT(SourcePrincipalName);

    RtlZeroMemory(
        PrincipalName,
        sizeof(KERB_PRINCIPAL_NAME)
        );

    //
    // Fill in correct name type
    //

    PrincipalName->name_type = SourcePrincipalName->name_type;
    SourceElem = SourcePrincipalName->name_string;
    NextElem = &PrincipalName->name_string;

    *NextElem = NULL;
    while (SourceElem != NULL)
    {
        DestElem = (PKERB_PRINCIPAL_NAME_ELEM) MIDL_user_allocate(sizeof(KERB_PRINCIPAL_NAME_ELEM));
        if (DestElem == NULL)
        {
            Status = KRB_ERR_GENERIC;
            goto Cleanup;
        }
        NameLen = lstrlenA(SourceElem->value);

        DestElem->value = (PCHAR) MIDL_user_allocate(NameLen + sizeof(CHAR));
        if (DestElem->value == NULL)
        {
            MIDL_user_free(DestElem);
            Status = KRB_ERR_GENERIC;
            goto Cleanup;
        }
        RtlCopyMemory(
            DestElem->value,
            SourceElem->value,
            NameLen + sizeof(CHAR)
        );
        DestElem->next = NULL;
        *NextElem = DestElem;
        NextElem = &DestElem->next;
        SourceElem = SourceElem->next;
    }

Cleanup:

    if (!KERB_SUCCESS(Status))
    {
        KerbFreePrincipalName(PrincipalName);
    }

    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbConvertPrincipalNameToString
//
//  Synopsis:   Converts a KERB_PRINCIPAL_NAME to a unicode string
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KerbConvertPrincipalNameToString(
    OUT PUNICODE_STRING String,
    OUT PULONG NameType,
    IN PKERB_PRINCIPAL_NAME PrincipalName
    )
{
    KERBERR KerbErr;
    STRING TempAnsiString;
    ULONG StringLength = 0;
    ULONG NameParts = 0;
    ULONG Index;
    PCHAR Where;
    PKERB_PRINCIPAL_NAME_ELEM NameElements[MAX_NAME_ELEMENTS+1];

    *NameType = (ULONG) PrincipalName->name_type;
    NameElements[NameParts] = PrincipalName->name_string;

    while (NameElements[NameParts] != NULL)
    {
        //
        // add in a separator plus the length of the element
        //

        StringLength += lstrlenA(NameElements[NameParts]->value) + 1;
        NameElements[NameParts+1] = NameElements[NameParts]->next;
        NameParts++;
        if (NameParts >= MAX_NAME_ELEMENTS)
        {
            D_DebugLog((DEB_ERROR,"Too many name parts: %d\n",NameParts));
            return(KRB_ERR_GENERIC);
        }
    }

    //
    // Make sure there is at least one name part
    //

    if (NameParts == 0)
    {
        return(KRB_ERR_GENERIC);
    }

    //
    // Test for overflow on USHORT lengths
    //

    if ( (StringLength - sizeof(CHAR)) > KERB_MAX_STRING )
    {
        return (KRB_ERR_GENERIC);
    } 

    //
    // Now build the name, backwards to front, with '\\' separators
    //

    TempAnsiString.Length = (USHORT) StringLength - sizeof(CHAR);
    TempAnsiString.MaximumLength = (USHORT) StringLength;

    SafeAllocaAllocate( TempAnsiString.Buffer, StringLength );

    if (TempAnsiString.Buffer == NULL)
    {
        return(KRB_ERR_GENERIC);
    }

    Where = TempAnsiString.Buffer;
    for (Index = 0; Index < NameParts; Index++ )
    {
        ULONG NameLength = lstrlenA(NameElements[Index]->value);
        RtlCopyMemory(
            Where,
            NameElements[Index]->value,
            NameLength
            );

        Where += NameLength;

        //
        // Add either a separating '\' or a trailing '\0'
        //

        if (Index != NameParts - 1)
        {
            *Where = '/';
        }
        else
        {
            *Where = '\0';
        }
        Where++;
    }

    DsysAssert(Where - TempAnsiString.Buffer == TempAnsiString.MaximumLength);

    KerbErr = KerbStringToUnicodeString(
                String,
                &TempAnsiString
                );

    SafeAllocaFree( TempAnsiString.Buffer );

    return(KerbErr);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbConvertPrincipalNameToFullServiceString
//
//  Synopsis:   Converts a KERB_PRINCIPAL_NAME to a unicode string with
//              a realm name
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KerbConvertPrincipalNameToFullServiceString(
    OUT PUNICODE_STRING String,
    IN PKERB_PRINCIPAL_NAME PrincipalName,
    IN KERB_REALM RealmName
    )
{
    KERBERR KerbErr;
    STRING TempAnsiString;
    ULONG StringLength = 0;
    ULONG NameParts = 0;
    ULONG NameLength;
    ULONG Index;
    PCHAR Where;
    PKERB_PRINCIPAL_NAME_ELEM NameElements[MAX_NAME_ELEMENTS+1];

    NameElements[NameParts] = PrincipalName->name_string;
    while (NameElements[NameParts] != NULL)
    {
        //
        // add in a separator plus the length of the element
        //

        StringLength += lstrlenA(NameElements[NameParts]->value) + 1;
        NameElements[NameParts+1] = NameElements[NameParts]->next;
        NameParts++;
        if (NameParts >= MAX_NAME_ELEMENTS)
        {
            D_DebugLog((DEB_ERROR,"Too many name parts: %d\n",NameParts));
            return(KRB_ERR_GENERIC);
        }
    }

    //
    // Make sure there is at least one name part
    //

    if (NameParts == 0)
    {
        return(KRB_ERR_GENERIC);
    }

    //
    // Add in space for the "@" and the realm
    //

    StringLength += lstrlenA(RealmName) + 1;

    //
    // Test for overflow on USHORT lengths
    //

    if ( (StringLength - sizeof(CHAR)) > KERB_MAX_STRING )
    {
        return (KRB_ERR_GENERIC);
    } 

    //
    // Now build the name, backwards to front, with '\\' separators
    //

    TempAnsiString.Length = (USHORT) StringLength - sizeof(CHAR);
    TempAnsiString.MaximumLength = (USHORT) StringLength;
    SafeAllocaAllocate( TempAnsiString.Buffer, StringLength );
    if (TempAnsiString.Buffer == NULL)
    {
        return(KRB_ERR_GENERIC);
    }

    Where = TempAnsiString.Buffer;
    for (Index = 0; Index < NameParts; Index++ )
    {
        NameLength = lstrlenA(NameElements[Index]->value);
        RtlCopyMemory(
            Where,
            NameElements[Index]->value,
            NameLength
            );

        Where += NameLength;

        //
        // Add either a separating '\' or a trailing '\0'
        //

        if (Index != NameParts - 1)
        {
            *Where = '/';
        }
        else
        {
            *Where = '@';
        }
        Where++;
    }

    NameLength = lstrlenA(RealmName);
    RtlCopyMemory(
        Where,
        RealmName,
        NameLength
        );

    Where += NameLength;

    //
    // Add either a trailing '\0'
    //

    *Where = '\0';
    Where++;

    DsysAssert(Where - TempAnsiString.Buffer == TempAnsiString.MaximumLength);

    KerbErr = KerbStringToUnicodeString(
                String,
                &TempAnsiString
                );

    SafeAllocaFree( TempAnsiString.Buffer );

    return(KerbErr);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbBuildKeySalt
//
//  Synopsis:   Combines a service name and domain name to make a key salt.
//              For machine account it is DOMAINNAMEhostmachinenamedomainname
//              For users it is DOMAINNAMEusername
//              For trusted domains it is DOMAINNAMEkrbtgtservicename
//
//  Effects:
//
//  Arguments:  DomainName - Domain name of service
//              Servicename - Name of service
//              AccountType - Type of account, which changes the salt
//              KeySalt - Receives the key salt
//
//  Requires:
//
//  Returns:    KDC_ERR_NONE or KRB_ERR_GENERIC
//
//  Notes:      This is dependent on our DS naming conventions
//
//
//--------------------------------------------------------------------------
KERBERR
KerbBuildKeySalt(
    IN PUNICODE_STRING DomainName,
    IN PUNICODE_STRING ServiceName,
    IN KERB_ACCOUNT_TYPE AccountType,
    OUT PUNICODE_STRING KeySalt
    )
{
    PUCHAR Where;
    ULONG  FinalLength;
    ULONG  ulLength = 0;
    USHORT DeadSpace = 0;
    USHORT Index;
    KERBERR KerbErr = KDC_ERR_NONE;

    DsysAssert(KeySalt);

    KeySalt->Buffer = NULL;

    //
    // If there is no domain name, this is a UPN so build a UPN salt.
    //

    if (DomainName->Length == 0)
    {
        return(KerbBuildKeySaltFromUpn(
                    ServiceName,
                    KeySalt ));
    }

    FinalLength = (ULONG)DomainName->Length +
                  (ULONG)ServiceName->Length;

    //
    // Add in any fixed strings, such as "host" for machines or "krbtgt" for
    // interdomain accounts
    //

    if (AccountType == MachineAccount)
    {
        //
        // Check to see if the name is already a "host/..." name. If so,
        // we don't need to do this work.
        //

        if ((ServiceName->Length > sizeof(KERB_HOST_STRING) &&
            (_wcsnicmp(
                ServiceName->Buffer,
                KERB_HOST_STRING,
                (sizeof(KERB_HOST_STRING) - sizeof(WCHAR)) / sizeof(WCHAR)) == 0) &&
            (ServiceName->Buffer[(sizeof(KERB_HOST_STRING) - sizeof(WCHAR)) / sizeof(WCHAR)] == L'/')))
        {
            AccountType = UserAccount;
        }
        else
        {
            FinalLength += sizeof(KERB_HOST_STRING) - sizeof(WCHAR);

            //
            // Add in the rest of the DNS name of the principal
            // as well
            //

            FinalLength += DomainName->Length + sizeof(WCHAR);
        }
    }
    else if (AccountType == DomainTrustAccount)
    {
        FinalLength += sizeof(KDC_PRINCIPAL_NAME) - sizeof(WCHAR);
    }
    else if (AccountType == UnknownAccount)
    {
        for (Index = 0; Index < ServiceName->Length/ sizeof(WCHAR) ; Index++ )
        {
            if (ServiceName->Buffer[Index] == L'/')
            {
                DeadSpace += sizeof(WCHAR);
            }
        }

        FinalLength = FinalLength - DeadSpace;
    }

    //
    // Detect and reject overflows
    //

    if (FinalLength > KERB_MAX_UNICODE_STRING)
    {
        KerbErr =  KRB_ERR_GENERIC;
        goto Cleanup;
    }

    KeySalt->Length        = 0;
    KeySalt->MaximumLength = (USHORT) FinalLength + sizeof(WCHAR);
    KeySalt->Buffer        = (LPWSTR) MIDL_user_allocate(KeySalt->MaximumLength);

    if (KeySalt->Buffer == NULL)
    {
        return KRB_ERR_GENERIC;
    }

    Where = (PUCHAR) KeySalt->Buffer;

    RtlCopyMemory(
        KeySalt->Buffer,
        DomainName->Buffer,
        DomainName->Length
        );
    // KeySalt->Length = KeySalt->Length + DomainName->Length;
    ulLength = (ULONG)KeySalt->Length + (ULONG)DomainName->Length;

    if (ulLength > KERB_MAX_UNICODE_STRING)
    {
        KerbErr =  KRB_ERR_GENERIC;
        goto Cleanup;
    }

    KeySalt->Length = (USHORT)ulLength;

    Where += DomainName->Length;

    //
    // Add in any fixed strings, such as "host" for machines or "krbtgt" for
    // interdomain accounts
    //

    if (AccountType == MachineAccount)
    {
        USHORT DontCopyChars = 0;
        UNICODE_STRING LowerCase = {0};
        NTSTATUS Status;

        ulLength = 0;

        RtlCopyMemory(
            Where,
            KERB_HOST_STRING,
            sizeof(KERB_HOST_STRING) - sizeof(WCHAR)
            );
        Where += sizeof(KERB_HOST_STRING) - sizeof(WCHAR);

        //
        // The service name may have a '$' at the end - if so, don't copy
        // it.
        //

        if ((ServiceName->Length >= sizeof(WCHAR)) &&
            (ServiceName->Buffer[-1 + ServiceName->Length / sizeof(WCHAR)] == L'$'))
        {
            DontCopyChars = 1;
        }

        LowerCase.Buffer = (LPWSTR) Where;

        RtlCopyMemory(
            Where,
            ServiceName->Buffer,
            ServiceName->Length - sizeof(WCHAR) * DontCopyChars
            );

        Where += ServiceName->Length - sizeof(WCHAR) * DontCopyChars;
        // LowerCase.Length += ServiceName->Length - sizeof(WCHAR) * DontCopyChars;
        ulLength += ServiceName->Length - sizeof(WCHAR) * DontCopyChars;

        //
        // add in the rest of the DNS name of the server
        //

        *(LPWSTR) Where = L'.';
        Where += sizeof(WCHAR);
        // LowerCase.Length += sizeof(WCHAR);
        ulLength += sizeof(WCHAR);

        RtlCopyMemory(
            Where,
            DomainName->Buffer,
            DomainName->Length
            );
        Where += DomainName->Length;
        // LowerCase.Length = LowerCase.Length + DomainName->Length;
        ulLength = ulLength + DomainName->Length;

        // Test for overflow on USHORT lengths
        if (ulLength > KERB_MAX_UNICODE_STRING )
        {
            KerbErr =  KRB_ERR_GENERIC;
            goto Cleanup;
        } 

        LowerCase.Length = (USHORT) ulLength;
        LowerCase.MaximumLength = LowerCase.Length;

        Status = RtlDowncaseUnicodeString(
                    &LowerCase,
                    &LowerCase,
                    FALSE
                    );

        DsysAssert(NT_SUCCESS(Status));
    }
    else if (AccountType == DomainTrustAccount)
    {
        ULONG DontCopyChars = 0;

        RtlCopyMemory(
            Where,
            KDC_PRINCIPAL_NAME,
            sizeof(KDC_PRINCIPAL_NAME) - sizeof(WCHAR)
            );
        Where += sizeof(KDC_PRINCIPAL_NAME) - sizeof(WCHAR);

        //
        // The service name may have a '$' at the end - if so, don't copy
        // it.
        //

        if ((ServiceName->Length >= sizeof(WCHAR)) &&
            (ServiceName->Buffer[-1 + ServiceName->Length / sizeof(WCHAR)] == L'$'))
        {
            DontCopyChars = 1;
        }

        RtlCopyMemory(
            Where,
            ServiceName->Buffer,
            ServiceName->Length - sizeof(WCHAR) * DontCopyChars
            );

        Where += ServiceName->Length - sizeof(WCHAR) * DontCopyChars;
    }
    else if (AccountType == UnknownAccount)
    {
        //
        // Pull out an '/' from unknown accounts
        //

        for (Index = 0; Index < ServiceName->Length / sizeof(WCHAR) ; Index++)
        {
            if (ServiceName->Buffer[Index] != L'/')
            {
                *((LPWSTR) Where) = ServiceName->Buffer[Index];
                Where += sizeof(WCHAR);
            }
        }
    }
    else
    {
        for (Index = 0; Index < ServiceName->Length / sizeof(WCHAR); Index++ )
        {
            if (ServiceName->Buffer[Index] != L'/')
            {
                *((LPWSTR)Where) = ServiceName->Buffer[Index];
                Where += sizeof(WCHAR);
            }
        }
    }

    // check for USHORT overflow on length

    ulLength = (ULONG)(Where - (PUCHAR) KeySalt->Buffer);

    if (ulLength > KERB_MAX_UNICODE_STRING )
    {
        KerbErr =  KRB_ERR_GENERIC;
        goto Cleanup;
    } 

    KeySalt->Length = (USHORT) ulLength;
    *(LPWSTR) Where = L'\0';
    KerbErr = KDC_ERR_NONE;

Cleanup:

    if (!KERB_SUCCESS(KerbErr))
    {
        if (KeySalt->Buffer)
        {
            MIDL_user_free(KeySalt->Buffer);
            KeySalt->Buffer = NULL;
        }
    }

    return(KerbErr);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbBuildKeySaltFromUpn
//
//  Synopsis:   Creaes salt from a UPN
//
//  Effects:
//              For users it is DOMAINNAMEusername
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KerbBuildKeySaltFromUpn(
    IN PUNICODE_STRING Upn,
    OUT PUNICODE_STRING Salt
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    UNICODE_STRING RealUpn = {0};
    UNICODE_STRING RealmName = {0};
    UNICODE_STRING LocalSalt = {0};
    ULONG Index;
    ULONG ulLength = 0;

    //
    // If there is an "@" in UPN, strip it out & use the dns domain name
    //

    RealUpn = *Upn;
    for (Index = 0; Index < RealUpn.Length/sizeof(WCHAR) ; Index++ )
    {
        if (RealUpn.Buffer[Index] == L'@')
        {
            RealUpn.Length = (USHORT) (Index * sizeof(WCHAR));
            RealmName.Buffer = &RealUpn.Buffer[Index+1];
            RealmName.Length = Upn->Length - RealUpn.Length - sizeof(WCHAR);
            RealmName.MaximumLength = RealmName.Length;
            break;
        }
    }

    if (RealmName.Length == 0)
    {
        KerbErr = KDC_ERR_C_PRINCIPAL_UNKNOWN;
        goto Cleanup;
    }

    //
    // Create the salt. It starts off with the domain name & then has the
    // UPN without any of the / pieces
    //

    ulLength = (ULONG)RealmName.Length + (ULONG)RealUpn.Length;

    // Test for overflow on USHORT lengths
    if (ulLength > KERB_MAX_UNICODE_STRING )
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    LocalSalt.MaximumLength = (USHORT)ulLength;
    LocalSalt.Length = 0;
    LocalSalt.Buffer = (LPWSTR) MIDL_user_allocate(LocalSalt.MaximumLength);
    if (LocalSalt.Buffer == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    RtlCopyMemory(
        LocalSalt.Buffer,
        RealmName.Buffer,
        RealmName.Length
        );
    // LocalSalt.Length = LocalSalt.Length + RealmName.Length;
    ulLength = RealmName.Length;

    //
    // Add in the real upn but leave out any "/" marks
    //

    for (Index = 0; Index < RealUpn.Length/sizeof(WCHAR) ; Index++ )
    {
        if (RealUpn.Buffer[Index] != L'/')
        {
            LocalSalt.Buffer[ulLength / sizeof(WCHAR)] = RealUpn.Buffer[Index];
            ulLength += sizeof(WCHAR);
        }
    }

    // Test for overflow on USHORT lengths - no need already done on MAX size possible
    LocalSalt.Length = (USHORT)ulLength;

    //
    // We have to lowercase the username for users
    //

#ifndef WIN32_CHICAGO
    CharLowerBuff(&(LocalSalt.Buffer[RealmName.Length/sizeof(WCHAR)]), RealUpn.Length/sizeof(WCHAR));
#endif // WIN32_CHICAGO

    *Salt = LocalSalt;     // give memory to caller
    LocalSalt.Buffer = NULL;

Cleanup:
    return(KerbErr);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbConvertSidToString
//
//  Synopsis:   Converts a sid to a string using RtlConvertSidToUnicodeString
//              but with a different allocator.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbConvertSidToString(
    IN PSID Sid,
    OUT PUNICODE_STRING String,
    IN BOOLEAN AllocateDestination
    )
{
    NTSTATUS Status;
    WCHAR Buffer[256];
    UNICODE_STRING TempString;

    if (AllocateDestination)
    {
        TempString.Length = 0;
        TempString.MaximumLength = sizeof(Buffer);
        TempString.Buffer = Buffer;
    }
    else
    {
         TempString = *String;
    }

    Status = RtlConvertSidToUnicodeString(
                &TempString,
                Sid,
                FALSE
                );
    if (NT_SUCCESS(Status))
    {
        if (!AllocateDestination)
        {
            *String = TempString;
        }
        else
        {
            String->Buffer = (LPWSTR) MIDL_user_allocate(TempString.Length+sizeof(WCHAR));
            if (String->Buffer == NULL)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
            else
            {
                String->Length = TempString.Length;
                String->MaximumLength = TempString.Length+sizeof(WCHAR);
                RtlCopyMemory(
                    String->Buffer,
                    TempString.Buffer,
                    TempString.Length
                    );
                String->Buffer[TempString.Length / sizeof(WCHAR)] = L'\0';
            }
        }
    }

    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbConvertStringToSid
//
//  Synopsis:   Converts back a sid from KerbConvertSidToString. If the
//              string is malformed, it will return STATUS_INVALID_PARAMTER
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbConvertStringToSid(
    IN PUNICODE_STRING String,
    OUT PSID * Sid
    )
{
    NTSTATUS Status;
    WCHAR Buffer[256];
    PSID SidT;

    *Sid = NULL;

    if ( String->Length + sizeof( WCHAR ) <= sizeof( Buffer )) {

        RtlCopyMemory( Buffer, String->Buffer, String->Length );

    } else {

        return STATUS_INVALID_PARAMETER;
    }

    Buffer[String->Length / sizeof( WCHAR )] = L'\0';

    if ( ConvertStringSidToSidW(
             Buffer,
             &SidT )) {

        Status = KerbDuplicateSid(
                     Sid,
                     SidT
                     );

        LocalFree( SidT );

    } else {

        switch( GetLastError()) {

        case ERROR_NOT_ENOUGH_MEMORY:

            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;

        case ERROR_INVALID_SID:

            Status = STATUS_INVALID_PARAMETER;
            break;

        default:
            DsysAssert( FALSE ); // add mapping for the error code
            Status = STATUS_INVALID_PARAMETER;
            break;
        }
    }

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbBuildAltSecId
//
//  Synopsis:   Builds the name for the alt-sec-id field lookup
//
//  Effects:    Converts a principal name from name1 name2 name3 to
//              "kerberos:name1/name2/name3@realm"
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
KERBERR
KerbBuildAltSecId(
    OUT PUNICODE_STRING AlternateName,
    IN PKERB_INTERNAL_NAME PrincipalName,
    IN OPTIONAL PKERB_REALM Realm,
    IN OPTIONAL PUNICODE_STRING UnicodeRealm
    )
{
    ULONG StringLength = sizeof(KERB_NAME_PREFIX) - sizeof(WCHAR);
    ULONG Index;
    UNICODE_STRING TempString = {0};
    UNICODE_STRING LocalRealm = {0};
    KERBERR KerbErr = KDC_ERR_NONE;

    *AlternateName = TempString;

    if (ARGUMENT_PRESENT(UnicodeRealm))
    {
        LocalRealm = *UnicodeRealm;
    }
    else if (ARGUMENT_PRESENT(Realm))
    {
        KerbErr = KerbConvertRealmToUnicodeString(
                    &LocalRealm,
                    Realm
                    );

        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }
    }

    if (PrincipalName->NameCount == 0)
    {
        KerbErr = KDC_ERR_C_PRINCIPAL_UNKNOWN;
        goto Cleanup;
    }

    //
    // Add in the size of all the components of the name plus a separtor
    // or a null terminator.
    //

    for (Index = 0; Index < PrincipalName->NameCount; Index++ )
    {
        StringLength += PrincipalName->Names[Index].Length + sizeof(WCHAR);
    }

    if (LocalRealm.Length != 0)
    {
        StringLength += sizeof(WCHAR) + // for @
                        LocalRealm.Length;
    }

    //
    // Now build the name, front to back (differently from KerbConvertPrincipalNameToString()
    //

    // Test for overflow on USHORT lengths
    if (StringLength > KERB_MAX_UNICODE_STRING )   // actually more accurate to use (StringLength - 1) > MAX
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    TempString.Buffer = (LPWSTR) MIDL_user_allocate(StringLength);
    if (TempString.Buffer == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }
    TempString.Length = 0;
    TempString.MaximumLength = (USHORT) StringLength;

    //
    // Now start appending the various portions to the string - max length already tested for overflow
    //

    RtlAppendUnicodeStringToString(
        &TempString,
        &KerbNamePrefix
        );

    for (Index = 0; Index < PrincipalName->NameCount ; Index++ )
    {
        if (Index != 0)
        {
            RtlAppendUnicodeStringToString(
                &TempString,
                &KerbNameSeparator
                );
        }

        RtlAppendUnicodeStringToString(
            &TempString,
            &PrincipalName->Names[Index]
            );
    }

    if (LocalRealm.Length != 0)
    {
        RtlAppendUnicodeStringToString(
            &TempString,
            &KerbDomainSeparator
            );
        RtlAppendUnicodeStringToString(
            &TempString,
            &LocalRealm
            );
    }

    *AlternateName = TempString;

Cleanup:

    if (!ARGUMENT_PRESENT(UnicodeRealm))
    {
        KerbFreeString(&LocalRealm);
    }

    return(KerbErr);
}


#ifndef WIN32_CHICAGO
//+-------------------------------------------------------------------------
//
//  Function:   KerbGetPrincipalNameFromCertificate
//
//  Synopsis:   Derives the principal name from a certificate
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
KerbGetPrincipalNameFromCertificate(
    IN PCCERT_CONTEXT ClientCert,
    OUT PUNICODE_STRING String
    )
{
    UNICODE_STRING NameString = {0};
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG   ExtensionIndex = 0;
    BOOL fAssigned = FALSE;
    PCERT_ALT_NAME_INFO AltName=NULL;
    PCERT_NAME_VALUE    PrincipalNameBlob = NULL;
    LPWSTR              CertNameString = NULL;

    CRYPT_DECODE_PARA   DecodePara = {sizeof(CRYPT_DECODE_PARA),
                                      MIDL_user_allocate,
                                      MIDL_user_free };


    //
    // Get the client name from the cert
    //

    // See if cert has UPN in AltSubjectName->otherName
    for(ExtensionIndex = 0;
        ExtensionIndex < ClientCert->pCertInfo->cExtension;
        ExtensionIndex++)
    {
        if(strcmp(ClientCert->pCertInfo->rgExtension[ExtensionIndex].pszObjId,
                  szOID_SUBJECT_ALT_NAME2) == 0)
        {
            DWORD               AltNameStructSize = 0;
            ULONG               CertAltNameIndex = 0;
            if(CryptDecodeObjectEx(ClientCert->dwCertEncodingType,
                                X509_ALTERNATE_NAME,
                                ClientCert->pCertInfo->rgExtension[ExtensionIndex].Value.pbData,
                                ClientCert->pCertInfo->rgExtension[ExtensionIndex].Value.cbData,
                                CRYPT_DECODE_ALLOC_FLAG,
                                &DecodePara,
                                (PVOID)&AltName,
                                &AltNameStructSize))
            {

                for(CertAltNameIndex = 0; CertAltNameIndex < AltName->cAltEntry; CertAltNameIndex++)
                {
                    PCERT_ALT_NAME_ENTRY AltNameEntry = &AltName->rgAltEntry[CertAltNameIndex];
                    if((CERT_ALT_NAME_OTHER_NAME  == AltNameEntry->dwAltNameChoice) &&
                       (NULL != AltNameEntry->pOtherName) &&
                       (0 == strcmp(szOID_NT_PRINCIPAL_NAME, AltNameEntry->pOtherName->pszObjId)))
                    {
                        DWORD            PrincipalNameBlobSize = 0;

                        // We found a UPN!
                        if(CryptDecodeObjectEx(ClientCert->dwCertEncodingType,
                                            X509_UNICODE_ANY_STRING,
                                            AltNameEntry->pOtherName->Value.pbData,
                                            AltNameEntry->pOtherName->Value.cbData,
                                            CRYPT_DECODE_ALLOC_FLAG,
                                            &DecodePara,
                                            (PVOID)&PrincipalNameBlob,
                                            &PrincipalNameBlobSize))
                        {

                            fAssigned = SafeRtlInitUnicodeString(&NameString,
                                                                 (LPCWSTR)PrincipalNameBlob->Value.pbData);
                            if (fAssigned == FALSE)
                            {
                                Status = STATUS_NAME_TOO_LONG;
                                goto Cleanup;
                            }

                            if(NameString.Length)
                            {
                                break;
                            }

                            MIDL_user_free(PrincipalNameBlob);
                            PrincipalNameBlob = NULL;
                        }
                    }
                }
                if(NameString.Length)
                {
                    break;
                }
                MIDL_user_free(AltName);
                AltName = NULL;
            }
        }
    }
 
    if(0 != NameString.Length)
    {
        Status = KerbDuplicateString(String, &NameString);
        if (!NT_SUCCESS(Status))
        {
            D_DebugLog((DEB_ERROR,"Failed to normalize name "));
            // KerbPrintKdcName(DEB_ERROR,ClientName);
            goto Cleanup;
        }

        D_DebugLog((DEB_TRACE,"UPN from certificate is %wZ\n",&NameString));
    }
    else
    {
        Status = STATUS_PKINIT_NAME_MISMATCH;
        D_DebugLog((DEB_ERROR,"No valid name in Sclogon certificate\n"));
        goto Cleanup;
    }

Cleanup:

    if(PrincipalNameBlob)
    {
        MIDL_user_free(PrincipalNameBlob);
    }
    if(AltName)
    {
        MIDL_user_free(AltName);
    }
    if(CertNameString)
    {
        MIDL_user_free(CertNameString);
    }

    return(Status);
}
#endif


BOOL
SafeRtlInitString(
    OUT PSTRING DestinationString,
    IN PCSZ SourceString OPTIONAL
    )

/*++

Routine Description:

    The RtlInitString function initializes an NT counted string.
    The DestinationString is initialized to point to the SourceString
    and the Length and MaximumLength fields of DestinationString are
    initialized to the length of the SourceString, which is zero if
    SourceString is not specified.

Arguments:

    DestinationString - Pointer to the counted string to initialize

    SourceString - Optional pointer to a null terminated string that
        the counted string is to point to.


Return Value:

    TRUE if assignment took place, FALSE on error - such as USHORT overflow

--*/

{
    ULONG Length;

    DestinationString->Buffer = (PCHAR)SourceString;
    if (ARGUMENT_PRESENT( SourceString )) {
        Length = (ULONG)strlen(SourceString);
        if (Length > KERB_MAX_STRING)
        {
            return FALSE;    // length will not fit into USHORT value
        }
        DestinationString->Length = (USHORT)Length;
        DestinationString->MaximumLength = (USHORT)(Length+1);
        }
    else {
        DestinationString->Length = 0;
        DestinationString->MaximumLength = 0;
        }
    return TRUE;
}

BOOL
SafeRtlInitUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PCWSTR SourceString OPTIONAL
    )

/*++

Routine Description:

    The RtlInitUnicodeString function initializes an NT counted
    unicode string.  The DestinationString is initialized to point to
    the SourceString and the Length and MaximumLength fields of
    DestinationString are initialized to the length of the SourceString,
    which is zero if SourceString is not specified.

Arguments:

    DestinationString - Pointer to the counted string to initialize

    SourceString - Optional pointer to a null terminated unicode string that
        the counted string is to point to.


Return Value:

    None.

--*/

{
    ULONG Length;

    DestinationString->Buffer = (PWSTR)SourceString;
    if (ARGUMENT_PRESENT( SourceString )) {
        Length = (ULONG)wcslen( SourceString ) * sizeof( WCHAR );
        ASSERT( Length <= KERB_MAX_UNICODE_STRING );
        if (Length > KERB_MAX_UNICODE_STRING)
        {
            return FALSE;    // length will not fit into USHORT value
        }
        DestinationString->Length = (USHORT)Length;
        DestinationString->MaximumLength = (USHORT)(Length + sizeof(UNICODE_NULL));
        }
    else {
        DestinationString->MaximumLength = 0;
        DestinationString->Length = 0;
        }
    return TRUE;
}




//+-------------------------------------------------------------------------
//
//  Function:   KerbGetCertificateHash
//
//  Synopsis:   Gets the SHA1 hash of a certificate.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
KerbGetCertificateHash(
    OUT LPBYTE pCertHash,
    IN ULONG cbCertHash,
    IN PCCERT_CONTEXT pCertContext
    )
{
    ULONG cbHash = cbCertHash;

    if ( CertGetCertificateContextProperty(
             pCertContext,
             CERT_SHA1_HASH_PROP_ID,
             pCertHash,
             &cbHash
             ) == FALSE )
    {
        return( STATUS_PKINIT_FAILURE );
    }

    return( STATUS_SUCCESS );
}





//+-------------------------------------------------------------------------
//
//  Function:   KerbCreateUnicodeStringFromHash
//
//  Synopsis:  Creates a hash string from a hash blob
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//
//--------------------------------------------------------------------------
NTSTATUS
KerbCreateUnicodeStringFromBlob(
    IN PBYTE Blob,  
    IN ULONG BlobSize,
    IN OUT PUNICODE_STRING String,
    IN BOOLEAN ReverseOrder
    )
{
    LPWSTR out = NULL;  
    WCHAR  buff[256];
    PBYTE  pb;
    ULONG cb, length;


    //
    // Don't overflow USHORT.
    //
    length = ((2 * BlobSize + 1) * sizeof(WCHAR));
    if ( length > KERB_MAX_UNICODE_STRING )        
    {
        return(STATUS_NAME_TOO_LONG);
    }                                             


    out = (LPWSTR) MIDL_user_allocate(length);
    if ( out == NULL )
    {
        return STATUS_NO_MEMORY;
    }      

    if ( ReverseOrder )
    {
        pb = Blob;
        for ( cb = BlobSize; cb > 0; cb--, pb++ )
        {
            swprintf(buff, L"%02X", *pb);
            wcscat(out, buff);
        }
    }
    else
    {
        pb = Blob + ( BlobSize - 1 );
        for ( cb = BlobSize; cb > 0; cb--, pb-- )
        {
            swprintf(buff, L"%02X", *pb);
            wcscat(out, buff);
        }
    }


    out[(2*BlobSize)] = L'\0';

    RtlInitUnicodeString(
            String,
            out
            );

    return STATUS_SUCCESS;
    
}           


//+-------------------------------------------------------------------------
//
//  Function:   KerbGetCertificateString
//
//  Synopsis:  Gets the specified name type from a cert context
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//
//--------------------------------------------------------------------------
NTSTATUS
KerbGetCertificateString(
    IN PCCERT_CONTEXT       Certificate,
    IN DWORD                Type,
    IN DWORD                Flags,
    IN OUT PUNICODE_STRING  CertString
    )
{

    NTSTATUS    Status = STATUS_SUCCESS;
    LPWSTR      wszRet = NULL;
    DWORD       dwChars = 0;
    ULONG       len;

    dwChars = CertGetNameStringW(
                Certificate,
                Type,
                Flags,
                NULL,
                NULL, 
                0
                );
                
    //
    //  If dwChars is 1, then it is an empty string.  No reason
    //  to do anything more, as Subject wasn't found.
    //  
    if (dwChars == 1) 
    { 
        DebugLog((DEB_ERROR, "Missing %x from cert %p\n", Type, Certificate));
        DsysAssert(FALSE);
        return STATUS_OBJECT_NAME_NOT_FOUND;
    }   

    len =  (dwChars + 1) * sizeof(WCHAR);
    if (len > KERB_MAX_UNICODE_STRING)        
    {
        return(STATUS_NAME_TOO_LONG);
    }


    wszRet = (LPWSTR) MIDL_user_allocate(len);
    if ( NULL == wszRet)
    {
        return STATUS_NO_MEMORY;
    }
    
    dwChars = CertGetNameStringW(
                Certificate,
                Type,
                Flags, 
                NULL,
                wszRet,
                dwChars
                );

    //
    // Huh?
    //
    if (dwChars == 1) 
    { 
        DebugLog((DEB_ERROR, "Missing %x from cert %p\n", Type, Certificate));
        Status = STATUS_OBJECT_NAME_NOT_FOUND;
        goto Cleanup;
    }     

    RtlInitUnicodeString(
        CertString,
        wszRet
        );

Cleanup:

    if (!NT_SUCCESS( Status ))
    {
        if ( wszRet )
        {
            MIDL_user_free( wszRet );
        }

        ZeroMemory(
            CertString,
            sizeof(UNICODE_STRING)
            );
    }  

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbGetCertificateHashString
//
//  Synopsis:  Creates a string from a hash.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//----
NTSTATUS
KerbGetCertificateHashString(
    IN PCCERT_CONTEXT Certificate,
    IN OUT PUNICODE_STRING HashString
    )
{   
    NTSTATUS    Status = STATUS_SUCCESS;  
    ULONG       HashSize = SHA1DIGESTLEN;
    BYTE        Hash[SHA1DIGESTLEN];   


    Status = KerbGetCertificateHash(
                Hash,
                HashSize,
                Certificate
                );

    if (!NT_SUCCESS( Status ))
    {
        DebugLog((DEB_ERROR, "KerbGetCertificateHash failed %x\n", Status));
        goto Cleanup;
    } 

    Status = KerbCreateUnicodeStringFromBlob(
                Hash,
                HashSize,
                HashString,
                TRUE
                );

    if (!NT_SUCCESS( Status ))
    {
        DebugLog((DEB_ERROR, "KerbCreateUnicodeStringFromHash failed %x\n", Status));
        goto Cleanup;
    }

Cleanup:

    return Status;

}



//+-------------------------------------------------------------------------
//
//  Function:   KerbGetCertificateIssuer
//
//  Synopsis:   Gets the simply display name from a certificate.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//----
NTSTATUS
KerbGetCertificateIssuer(
    IN PCCERT_CONTEXT Certificate,
    IN OUT PUNICODE_STRING Issuer
    )
{

    NTSTATUS            Status = STATUS_SUCCESS;

    Status = KerbGetCertificateString(
                Certificate,
                CERT_NAME_SIMPLE_DISPLAY_TYPE,
                CERT_NAME_ISSUER_FLAG,
                Issuer
                );

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\common2\krb5.c ===
#include "krbprgma.h"
#include <windows.h>
#include "krb5.h"

ASN1module_t KRB5_Module = NULL;

static int ASN1CALL ASN1Enc_PKERB_AUTHORIZATION_DATA_LIST(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_AUTHORIZATION_DATA_LIST *val);
static int ASN1CALL ASN1Enc_PKERB_IF_RELEVANT_AUTH_DATA(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_IF_RELEVANT_AUTH_DATA *val);
static int ASN1CALL ASN1Enc_KERB_KDC_REQUEST_BODY_encryption_type(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_KDC_REQUEST_BODY_encryption_type *val);
static int ASN1CALL ASN1Enc_PKERB_TICKET_EXTENSIONS_Seq(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_TICKET_EXTENSIONS_Seq *val);
static int ASN1CALL ASN1Enc_KERB_PRINCIPAL_NAME_name_string(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PRINCIPAL_NAME_name_string *val);
static int ASN1CALL ASN1Enc_PKERB_LAST_REQUEST_Seq(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_LAST_REQUEST_Seq *val);
static int ASN1CALL ASN1Enc_PKERB_AUTHORIZATION_DATA_Seq(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_AUTHORIZATION_DATA_Seq *val);
static int ASN1CALL ASN1Enc_PKERB_HOST_ADDRESSES_Seq(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_HOST_ADDRESSES_Seq *val);
static int ASN1CALL ASN1Enc_KERB_HOST_ADDRESS(ASN1encoding_t enc, ASN1uint32_t tag, KERB_HOST_ADDRESS *val);
static int ASN1CALL ASN1Enc_PKERB_HOST_ADDRESSES(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_HOST_ADDRESSES *val);
static int ASN1CALL ASN1Enc_PKERB_AUTHORIZATION_DATA(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_AUTHORIZATION_DATA *val);
static int ASN1CALL ASN1Enc_PKERB_LAST_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_LAST_REQUEST *val);
static int ASN1CALL ASN1Enc_KERB_PRINCIPAL_NAME(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PRINCIPAL_NAME *val);
static int ASN1CALL ASN1Enc_PKERB_TICKET_EXTENSIONS(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_TICKET_EXTENSIONS *val);
static int ASN1CALL ASN1Enc_KERB_TRANSITED_ENCODING(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TRANSITED_ENCODING *val);
static int ASN1CALL ASN1Enc_KERB_PA_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_DATA *val);
static int ASN1CALL ASN1Enc_PKERB_PREAUTH_DATA_LIST(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_PREAUTH_DATA_LIST *val);
static int ASN1CALL ASN1Enc_KERB_SAFE_BODY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SAFE_BODY *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_PRIV(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_PRIV *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_CRED(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_CRED *val);
static int ASN1CALL ASN1Enc_KERB_ERROR(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ERROR *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_DATA *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTION_KEY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTION_KEY *val);
static int ASN1CALL ASN1Enc_KERB_CHECKSUM(ASN1encoding_t enc, ASN1uint32_t tag, KERB_CHECKSUM *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_TIMESTAMP(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_TIMESTAMP *val);
static int ASN1CALL ASN1Enc_KERB_SALTED_ENCRYPTED_TIMESTAMP(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SALTED_ENCRYPTED_TIMESTAMP *val);
static int ASN1CALL ASN1Enc_KERB_ETYPE_INFO_ENTRY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ETYPE_INFO_ENTRY *val);
static int ASN1CALL ASN1Enc_PKERB_ETYPE_INFO(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_ETYPE_INFO *val);
static int ASN1CALL ASN1Enc_KERB_TGT_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TGT_REQUEST *val);
static int ASN1CALL ASN1Enc_KERB_PKCS_SIGNATURE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PKCS_SIGNATURE *val);
static int ASN1CALL ASN1Enc_KERB_ALGORITHM_IDENTIFIER(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ALGORITHM_IDENTIFIER *val);
static int ASN1CALL ASN1Enc_KERB_SIGNATURE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SIGNATURE *val);
static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REP(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PK_AS_REP *val);
static int ASN1CALL ASN1Enc_KERB_ENVELOPED_KEY_PACKAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENVELOPED_KEY_PACKAGE *val);
static int ASN1CALL ASN1Enc_KERB_REPLY_KEY_PACKAGE2(ASN1encoding_t enc, ASN1uint32_t tag, KERB_REPLY_KEY_PACKAGE2 *val);
static int ASN1CALL ASN1Enc_KERB_REPLY_KEY_PACKAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_REPLY_KEY_PACKAGE *val);
static int ASN1CALL ASN1Enc_KERB_KDC_DH_KEY_INFO(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KDC_DH_KEY_INFO *val);
static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REQ(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PK_AS_REQ *val);
static int ASN1CALL ASN1Enc_KERB_KERBEROS_NAME(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KERBEROS_NAME *val);
static int ASN1CALL ASN1Enc_KERB_PK_AUTHENTICATOR(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PK_AUTHENTICATOR *val);
static int ASN1CALL ASN1Enc_KERB_SUBJECT_PUBLIC_KEY_INFO(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SUBJECT_PUBLIC_KEY_INFO *val);
static int ASN1CALL ASN1Enc_KERB_DH_PARAMTER(ASN1encoding_t enc, ASN1uint32_t tag, KERB_DH_PARAMTER *val);
static int ASN1CALL ASN1Enc_KERB_CERTIFICATE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_CERTIFICATE *val);
static int ASN1CALL ASN1Enc_KERB_TYPED_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TYPED_DATA *val);
static int ASN1CALL ASN1Enc_KERB_KDC_ISSUED_AUTH_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KDC_ISSUED_AUTH_DATA *val);
static int ASN1CALL ASN1Enc_KERB_PA_SERV_REFERRAL(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_SERV_REFERRAL *val);
static int ASN1CALL ASN1Enc_KERB_PA_PAC_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PAC_REQUEST *val);
static int ASN1CALL ASN1Enc_KERB_CHANGE_PASSWORD_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_CHANGE_PASSWORD_DATA *val);
static int ASN1CALL ASN1Enc_KERB_ERROR_METHOD_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ERROR_METHOD_DATA *val);
static int ASN1CALL ASN1Enc_KERB_EXT_ERROR(ASN1encoding_t enc, ASN1uint32_t tag, KERB_EXT_ERROR *val);
static int ASN1CALL ASN1Enc_TYPED_DATA(ASN1encoding_t enc, ASN1uint32_t tag, PTYPED_DATA *val);
static int ASN1CALL ASN1Enc_KERB_PA_FOR_USER(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_FOR_USER *val);
static int ASN1CALL ASN1Enc_KERB_KDC_ISSUED_AUTH_DATA_elements(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_KDC_ISSUED_AUTH_DATA_elements *val);
static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REQ2_trusted_certifiers(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ2_trusted_certifiers *val);
static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REQ2_user_certs(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ2_user_certs *val);
static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REP2_kdc_cert(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_PK_AS_REP2_kdc_cert *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data *val);
static int ASN1CALL ASN1Enc_KERB_KDC_REPLY_preauth_data(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_KDC_REPLY_preauth_data *val);
static int ASN1CALL ASN1Enc_KERB_KDC_REQUEST_preauth_data(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_KDC_REQUEST_preauth_data *val);
static int ASN1CALL ASN1Enc_KERB_TICKET(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TICKET *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_TICKET(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_TICKET *val);
static int ASN1CALL ASN1Enc_KERB_AUTHENTICATOR(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AUTHENTICATOR *val);
static int ASN1CALL ASN1Enc_KERB_KDC_REQUEST_BODY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KDC_REQUEST_BODY *val);
static int ASN1CALL ASN1Enc_KERB_KDC_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KDC_REPLY *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_KDC_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_KDC_REPLY *val);
static int ASN1CALL ASN1Enc_KERB_AP_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AP_REQUEST *val);
static int ASN1CALL ASN1Enc_KERB_AP_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AP_REPLY *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_AP_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_AP_REPLY *val);
static int ASN1CALL ASN1Enc_KERB_SAFE_MESSAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SAFE_MESSAGE *val);
static int ASN1CALL ASN1Enc_KERB_PRIV_MESSAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PRIV_MESSAGE *val);
static int ASN1CALL ASN1Enc_KERB_CRED(ASN1encoding_t enc, ASN1uint32_t tag, KERB_CRED *val);
static int ASN1CALL ASN1Enc_KERB_CRED_INFO(ASN1encoding_t enc, ASN1uint32_t tag, KERB_CRED_INFO *val);
static int ASN1CALL ASN1Enc_KERB_TGT_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TGT_REPLY *val);
static int ASN1CALL ASN1Enc_KERB_SIGNED_REPLY_KEY_PACKAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SIGNED_REPLY_KEY_PACKAGE *val);
static int ASN1CALL ASN1Enc_KERB_SIGNED_KDC_PUBLIC_VALUE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SIGNED_KDC_PUBLIC_VALUE *val);
static int ASN1CALL ASN1Enc_KERB_TRUSTED_CAS(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TRUSTED_CAS *val);
static int ASN1CALL ASN1Enc_KERB_AUTH_PACKAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AUTH_PACKAGE *val);
static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REQ_trusted_certifiers(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ_trusted_certifiers *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_CRED_ticket_info(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_ENCRYPTED_CRED_ticket_info *val);
static int ASN1CALL ASN1Enc_KERB_CRED_tickets(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_CRED_tickets *val);
static int ASN1CALL ASN1Enc_KERB_KDC_REQUEST_BODY_additional_tickets(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_KDC_REQUEST_BODY_additional_tickets *val);
static int ASN1CALL ASN1Enc_KERB_KDC_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KDC_REQUEST *val);
static int ASN1CALL ASN1Enc_KERB_MARSHALLED_REQUEST_BODY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_MARSHALLED_REQUEST_BODY *val);
static int ASN1CALL ASN1Enc_KERB_AS_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AS_REPLY *val);
static int ASN1CALL ASN1Enc_KERB_TGS_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TGS_REPLY *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_AS_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_AS_REPLY *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_TGS_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_TGS_REPLY *val);
static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REP2(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PK_AS_REP2 *val);
static int ASN1CALL ASN1Enc_KERB_SIGNED_AUTH_PACKAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SIGNED_AUTH_PACKAGE *val);
static int ASN1CALL ASN1Enc_KERB_AS_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AS_REQUEST *val);
static int ASN1CALL ASN1Enc_KERB_TGS_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TGS_REQUEST *val);
static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REQ2(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PK_AS_REQ2 *val);
static int ASN1CALL ASN1Dec_PKERB_AUTHORIZATION_DATA_LIST(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_AUTHORIZATION_DATA_LIST *val);
static int ASN1CALL ASN1Dec_PKERB_IF_RELEVANT_AUTH_DATA(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_IF_RELEVANT_AUTH_DATA *val);
static int ASN1CALL ASN1Dec_KERB_KDC_REQUEST_BODY_encryption_type(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_KDC_REQUEST_BODY_encryption_type *val);
static int ASN1CALL ASN1Dec_PKERB_TICKET_EXTENSIONS_Seq(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_TICKET_EXTENSIONS_Seq *val);
static int ASN1CALL ASN1Dec_KERB_PRINCIPAL_NAME_name_string(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PRINCIPAL_NAME_name_string *val);
static int ASN1CALL ASN1Dec_PKERB_LAST_REQUEST_Seq(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_LAST_REQUEST_Seq *val);
static int ASN1CALL ASN1Dec_PKERB_AUTHORIZATION_DATA_Seq(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_AUTHORIZATION_DATA_Seq *val);
static int ASN1CALL ASN1Dec_PKERB_HOST_ADDRESSES_Seq(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_HOST_ADDRESSES_Seq *val);
static int ASN1CALL ASN1Dec_KERB_HOST_ADDRESS(ASN1decoding_t dec, ASN1uint32_t tag, KERB_HOST_ADDRESS *val);
static int ASN1CALL ASN1Dec_PKERB_HOST_ADDRESSES(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_HOST_ADDRESSES *val);
static int ASN1CALL ASN1Dec_PKERB_AUTHORIZATION_DATA(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_AUTHORIZATION_DATA *val);
static int ASN1CALL ASN1Dec_PKERB_LAST_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_LAST_REQUEST *val);
static int ASN1CALL ASN1Dec_KERB_PRINCIPAL_NAME(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PRINCIPAL_NAME *val);
static int ASN1CALL ASN1Dec_PKERB_TICKET_EXTENSIONS(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_TICKET_EXTENSIONS *val);
static int ASN1CALL ASN1Dec_KERB_TRANSITED_ENCODING(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TRANSITED_ENCODING *val);
static int ASN1CALL ASN1Dec_KERB_PA_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_DATA *val);
static int ASN1CALL ASN1Dec_PKERB_PREAUTH_DATA_LIST(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_PREAUTH_DATA_LIST *val);
static int ASN1CALL ASN1Dec_KERB_SAFE_BODY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SAFE_BODY *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_PRIV(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_PRIV *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_CRED(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_CRED *val);
static int ASN1CALL ASN1Dec_KERB_ERROR(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ERROR *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_DATA *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTION_KEY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTION_KEY *val);
static int ASN1CALL ASN1Dec_KERB_CHECKSUM(ASN1decoding_t dec, ASN1uint32_t tag, KERB_CHECKSUM *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_TIMESTAMP(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_TIMESTAMP *val);
static int ASN1CALL ASN1Dec_KERB_SALTED_ENCRYPTED_TIMESTAMP(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SALTED_ENCRYPTED_TIMESTAMP *val);
static int ASN1CALL ASN1Dec_KERB_ETYPE_INFO_ENTRY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ETYPE_INFO_ENTRY *val);
static int ASN1CALL ASN1Dec_PKERB_ETYPE_INFO(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_ETYPE_INFO *val);
static int ASN1CALL ASN1Dec_KERB_TGT_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TGT_REQUEST *val);
static int ASN1CALL ASN1Dec_KERB_PKCS_SIGNATURE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PKCS_SIGNATURE *val);
static int ASN1CALL ASN1Dec_KERB_ALGORITHM_IDENTIFIER(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ALGORITHM_IDENTIFIER *val);
static int ASN1CALL ASN1Dec_KERB_SIGNATURE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SIGNATURE *val);
static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REP(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PK_AS_REP *val);
static int ASN1CALL ASN1Dec_KERB_ENVELOPED_KEY_PACKAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENVELOPED_KEY_PACKAGE *val);
static int ASN1CALL ASN1Dec_KERB_REPLY_KEY_PACKAGE2(ASN1decoding_t dec, ASN1uint32_t tag, KERB_REPLY_KEY_PACKAGE2 *val);
static int ASN1CALL ASN1Dec_KERB_REPLY_KEY_PACKAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_REPLY_KEY_PACKAGE *val);
static int ASN1CALL ASN1Dec_KERB_KDC_DH_KEY_INFO(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KDC_DH_KEY_INFO *val);
static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REQ(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PK_AS_REQ *val);
static int ASN1CALL ASN1Dec_KERB_KERBEROS_NAME(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KERBEROS_NAME *val);
static int ASN1CALL ASN1Dec_KERB_PK_AUTHENTICATOR(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PK_AUTHENTICATOR *val);
static int ASN1CALL ASN1Dec_KERB_SUBJECT_PUBLIC_KEY_INFO(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SUBJECT_PUBLIC_KEY_INFO *val);
static int ASN1CALL ASN1Dec_KERB_DH_PARAMTER(ASN1decoding_t dec, ASN1uint32_t tag, KERB_DH_PARAMTER *val);
static int ASN1CALL ASN1Dec_KERB_CERTIFICATE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_CERTIFICATE *val);
static int ASN1CALL ASN1Dec_KERB_TYPED_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TYPED_DATA *val);
static int ASN1CALL ASN1Dec_KERB_KDC_ISSUED_AUTH_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KDC_ISSUED_AUTH_DATA *val);
static int ASN1CALL ASN1Dec_KERB_PA_SERV_REFERRAL(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_SERV_REFERRAL *val);
static int ASN1CALL ASN1Dec_KERB_PA_PAC_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PAC_REQUEST *val);
static int ASN1CALL ASN1Dec_KERB_CHANGE_PASSWORD_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_CHANGE_PASSWORD_DATA *val);
static int ASN1CALL ASN1Dec_KERB_ERROR_METHOD_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ERROR_METHOD_DATA *val);
static int ASN1CALL ASN1Dec_KERB_EXT_ERROR(ASN1decoding_t dec, ASN1uint32_t tag, KERB_EXT_ERROR *val);
static int ASN1CALL ASN1Dec_TYPED_DATA(ASN1decoding_t dec, ASN1uint32_t tag, PTYPED_DATA *val);
static int ASN1CALL ASN1Dec_KERB_PA_FOR_USER(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_FOR_USER *val);
static int ASN1CALL ASN1Dec_KERB_KDC_ISSUED_AUTH_DATA_elements(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_KDC_ISSUED_AUTH_DATA_elements *val);
static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REQ2_trusted_certifiers(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ2_trusted_certifiers *val);
static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REQ2_user_certs(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ2_user_certs *val);
static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REP2_kdc_cert(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_PK_AS_REP2_kdc_cert *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data *val);
static int ASN1CALL ASN1Dec_KERB_KDC_REPLY_preauth_data(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_KDC_REPLY_preauth_data *val);
static int ASN1CALL ASN1Dec_KERB_KDC_REQUEST_preauth_data(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_KDC_REQUEST_preauth_data *val);
static int ASN1CALL ASN1Dec_KERB_TICKET(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TICKET *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_TICKET(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_TICKET *val);
static int ASN1CALL ASN1Dec_KERB_AUTHENTICATOR(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AUTHENTICATOR *val);
static int ASN1CALL ASN1Dec_KERB_KDC_REQUEST_BODY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KDC_REQUEST_BODY *val);
static int ASN1CALL ASN1Dec_KERB_KDC_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KDC_REPLY *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_KDC_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_KDC_REPLY *val);
static int ASN1CALL ASN1Dec_KERB_AP_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AP_REQUEST *val);
static int ASN1CALL ASN1Dec_KERB_AP_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AP_REPLY *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_AP_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_AP_REPLY *val);
static int ASN1CALL ASN1Dec_KERB_SAFE_MESSAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SAFE_MESSAGE *val);
static int ASN1CALL ASN1Dec_KERB_PRIV_MESSAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PRIV_MESSAGE *val);
static int ASN1CALL ASN1Dec_KERB_CRED(ASN1decoding_t dec, ASN1uint32_t tag, KERB_CRED *val);
static int ASN1CALL ASN1Dec_KERB_CRED_INFO(ASN1decoding_t dec, ASN1uint32_t tag, KERB_CRED_INFO *val);
static int ASN1CALL ASN1Dec_KERB_TGT_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TGT_REPLY *val);
static int ASN1CALL ASN1Dec_KERB_SIGNED_REPLY_KEY_PACKAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SIGNED_REPLY_KEY_PACKAGE *val);
static int ASN1CALL ASN1Dec_KERB_SIGNED_KDC_PUBLIC_VALUE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SIGNED_KDC_PUBLIC_VALUE *val);
static int ASN1CALL ASN1Dec_KERB_TRUSTED_CAS(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TRUSTED_CAS *val);
static int ASN1CALL ASN1Dec_KERB_AUTH_PACKAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AUTH_PACKAGE *val);
static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REQ_trusted_certifiers(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ_trusted_certifiers *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_CRED_ticket_info(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_ENCRYPTED_CRED_ticket_info *val);
static int ASN1CALL ASN1Dec_KERB_CRED_tickets(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_CRED_tickets *val);
static int ASN1CALL ASN1Dec_KERB_KDC_REQUEST_BODY_additional_tickets(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_KDC_REQUEST_BODY_additional_tickets *val);
static int ASN1CALL ASN1Dec_KERB_KDC_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KDC_REQUEST *val);
static int ASN1CALL ASN1Dec_KERB_MARSHALLED_REQUEST_BODY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_MARSHALLED_REQUEST_BODY *val);
static int ASN1CALL ASN1Dec_KERB_AS_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AS_REPLY *val);
static int ASN1CALL ASN1Dec_KERB_TGS_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TGS_REPLY *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_AS_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_AS_REPLY *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_TGS_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_TGS_REPLY *val);
static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REP2(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PK_AS_REP2 *val);
static int ASN1CALL ASN1Dec_KERB_SIGNED_AUTH_PACKAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SIGNED_AUTH_PACKAGE *val);
static int ASN1CALL ASN1Dec_KERB_AS_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AS_REQUEST *val);
static int ASN1CALL ASN1Dec_KERB_TGS_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TGS_REQUEST *val);
static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REQ2(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PK_AS_REQ2 *val);
static void ASN1CALL ASN1Free_PKERB_AUTHORIZATION_DATA_LIST(PKERB_AUTHORIZATION_DATA_LIST *val);
static void ASN1CALL ASN1Free_PKERB_IF_RELEVANT_AUTH_DATA(PKERB_IF_RELEVANT_AUTH_DATA *val);
static void ASN1CALL ASN1Free_KERB_KDC_REQUEST_BODY_encryption_type(PKERB_KDC_REQUEST_BODY_encryption_type *val);
static void ASN1CALL ASN1Free_PKERB_TICKET_EXTENSIONS_Seq(PKERB_TICKET_EXTENSIONS_Seq *val);
static void ASN1CALL ASN1Free_KERB_PRINCIPAL_NAME_name_string(PKERB_PRINCIPAL_NAME_name_string *val);
static void ASN1CALL ASN1Free_PKERB_LAST_REQUEST_Seq(PKERB_LAST_REQUEST_Seq *val);
static void ASN1CALL ASN1Free_PKERB_AUTHORIZATION_DATA_Seq(PKERB_AUTHORIZATION_DATA_Seq *val);
static void ASN1CALL ASN1Free_PKERB_HOST_ADDRESSES_Seq(PKERB_HOST_ADDRESSES_Seq *val);
static void ASN1CALL ASN1Free_KERB_HOST_ADDRESS(KERB_HOST_ADDRESS *val);
static void ASN1CALL ASN1Free_PKERB_HOST_ADDRESSES(PPKERB_HOST_ADDRESSES *val);
static void ASN1CALL ASN1Free_PKERB_AUTHORIZATION_DATA(PPKERB_AUTHORIZATION_DATA *val);
static void ASN1CALL ASN1Free_PKERB_LAST_REQUEST(PPKERB_LAST_REQUEST *val);
static void ASN1CALL ASN1Free_KERB_PRINCIPAL_NAME(KERB_PRINCIPAL_NAME *val);
static void ASN1CALL ASN1Free_PKERB_TICKET_EXTENSIONS(PPKERB_TICKET_EXTENSIONS *val);
static void ASN1CALL ASN1Free_KERB_TRANSITED_ENCODING(KERB_TRANSITED_ENCODING *val);
static void ASN1CALL ASN1Free_KERB_PA_DATA(KERB_PA_DATA *val);
static void ASN1CALL ASN1Free_PKERB_PREAUTH_DATA_LIST(PPKERB_PREAUTH_DATA_LIST *val);
static void ASN1CALL ASN1Free_KERB_SAFE_BODY(KERB_SAFE_BODY *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_PRIV(KERB_ENCRYPTED_PRIV *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_CRED(KERB_ENCRYPTED_CRED *val);
static void ASN1CALL ASN1Free_KERB_ERROR(KERB_ERROR *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_DATA(KERB_ENCRYPTED_DATA *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTION_KEY(KERB_ENCRYPTION_KEY *val);
static void ASN1CALL ASN1Free_KERB_CHECKSUM(KERB_CHECKSUM *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_TIMESTAMP(KERB_ENCRYPTED_TIMESTAMP *val);
static void ASN1CALL ASN1Free_KERB_SALTED_ENCRYPTED_TIMESTAMP(KERB_SALTED_ENCRYPTED_TIMESTAMP *val);
static void ASN1CALL ASN1Free_KERB_ETYPE_INFO_ENTRY(KERB_ETYPE_INFO_ENTRY *val);
static void ASN1CALL ASN1Free_PKERB_ETYPE_INFO(PPKERB_ETYPE_INFO *val);
static void ASN1CALL ASN1Free_KERB_TGT_REQUEST(KERB_TGT_REQUEST *val);
static void ASN1CALL ASN1Free_KERB_PKCS_SIGNATURE(KERB_PKCS_SIGNATURE *val);
static void ASN1CALL ASN1Free_KERB_ALGORITHM_IDENTIFIER(KERB_ALGORITHM_IDENTIFIER *val);
static void ASN1CALL ASN1Free_KERB_SIGNATURE(KERB_SIGNATURE *val);
static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REP(KERB_PA_PK_AS_REP *val);
static void ASN1CALL ASN1Free_KERB_ENVELOPED_KEY_PACKAGE(KERB_ENVELOPED_KEY_PACKAGE *val);
static void ASN1CALL ASN1Free_KERB_REPLY_KEY_PACKAGE2(KERB_REPLY_KEY_PACKAGE2 *val);
static void ASN1CALL ASN1Free_KERB_REPLY_KEY_PACKAGE(KERB_REPLY_KEY_PACKAGE *val);
static void ASN1CALL ASN1Free_KERB_KDC_DH_KEY_INFO(KERB_KDC_DH_KEY_INFO *val);
static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REQ(KERB_PA_PK_AS_REQ *val);
static void ASN1CALL ASN1Free_KERB_KERBEROS_NAME(KERB_KERBEROS_NAME *val);
static void ASN1CALL ASN1Free_KERB_PK_AUTHENTICATOR(KERB_PK_AUTHENTICATOR *val);
static void ASN1CALL ASN1Free_KERB_SUBJECT_PUBLIC_KEY_INFO(KERB_SUBJECT_PUBLIC_KEY_INFO *val);
static void ASN1CALL ASN1Free_KERB_CERTIFICATE(KERB_CERTIFICATE *val);
static void ASN1CALL ASN1Free_KERB_TYPED_DATA(KERB_TYPED_DATA *val);
static void ASN1CALL ASN1Free_KERB_KDC_ISSUED_AUTH_DATA(KERB_KDC_ISSUED_AUTH_DATA *val);
static void ASN1CALL ASN1Free_KERB_PA_SERV_REFERRAL(KERB_PA_SERV_REFERRAL *val);
static void ASN1CALL ASN1Free_KERB_CHANGE_PASSWORD_DATA(KERB_CHANGE_PASSWORD_DATA *val);
static void ASN1CALL ASN1Free_KERB_ERROR_METHOD_DATA(KERB_ERROR_METHOD_DATA *val);
static void ASN1CALL ASN1Free_TYPED_DATA(PTYPED_DATA *val);
static void ASN1CALL ASN1Free_KERB_PA_FOR_USER(KERB_PA_FOR_USER *val);
static void ASN1CALL ASN1Free_KERB_KDC_ISSUED_AUTH_DATA_elements(PKERB_KDC_ISSUED_AUTH_DATA_elements *val);
static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REQ2_trusted_certifiers(PKERB_PA_PK_AS_REQ2_trusted_certifiers *val);
static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REQ2_user_certs(PKERB_PA_PK_AS_REQ2_user_certs *val);
static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REP2_kdc_cert(PKERB_PA_PK_AS_REP2_kdc_cert *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data(PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data *val);
static void ASN1CALL ASN1Free_KERB_KDC_REPLY_preauth_data(PKERB_KDC_REPLY_preauth_data *val);
static void ASN1CALL ASN1Free_KERB_KDC_REQUEST_preauth_data(PKERB_KDC_REQUEST_preauth_data *val);
static void ASN1CALL ASN1Free_KERB_TICKET(KERB_TICKET *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_TICKET(KERB_ENCRYPTED_TICKET *val);
static void ASN1CALL ASN1Free_KERB_AUTHENTICATOR(KERB_AUTHENTICATOR *val);
static void ASN1CALL ASN1Free_KERB_KDC_REQUEST_BODY(KERB_KDC_REQUEST_BODY *val);
static void ASN1CALL ASN1Free_KERB_KDC_REPLY(KERB_KDC_REPLY *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_KDC_REPLY(KERB_ENCRYPTED_KDC_REPLY *val);
static void ASN1CALL ASN1Free_KERB_AP_REQUEST(KERB_AP_REQUEST *val);
static void ASN1CALL ASN1Free_KERB_AP_REPLY(KERB_AP_REPLY *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_AP_REPLY(KERB_ENCRYPTED_AP_REPLY *val);
static void ASN1CALL ASN1Free_KERB_SAFE_MESSAGE(KERB_SAFE_MESSAGE *val);
static void ASN1CALL ASN1Free_KERB_PRIV_MESSAGE(KERB_PRIV_MESSAGE *val);
static void ASN1CALL ASN1Free_KERB_CRED(KERB_CRED *val);
static void ASN1CALL ASN1Free_KERB_CRED_INFO(KERB_CRED_INFO *val);
static void ASN1CALL ASN1Free_KERB_TGT_REPLY(KERB_TGT_REPLY *val);
static void ASN1CALL ASN1Free_KERB_SIGNED_REPLY_KEY_PACKAGE(KERB_SIGNED_REPLY_KEY_PACKAGE *val);
static void ASN1CALL ASN1Free_KERB_SIGNED_KDC_PUBLIC_VALUE(KERB_SIGNED_KDC_PUBLIC_VALUE *val);
static void ASN1CALL ASN1Free_KERB_TRUSTED_CAS(KERB_TRUSTED_CAS *val);
static void ASN1CALL ASN1Free_KERB_AUTH_PACKAGE(KERB_AUTH_PACKAGE *val);
static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REQ_trusted_certifiers(PKERB_PA_PK_AS_REQ_trusted_certifiers *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_CRED_ticket_info(PKERB_ENCRYPTED_CRED_ticket_info *val);
static void ASN1CALL ASN1Free_KERB_CRED_tickets(PKERB_CRED_tickets *val);
static void ASN1CALL ASN1Free_KERB_KDC_REQUEST_BODY_additional_tickets(PKERB_KDC_REQUEST_BODY_additional_tickets *val);
static void ASN1CALL ASN1Free_KERB_KDC_REQUEST(KERB_KDC_REQUEST *val);
static void ASN1CALL ASN1Free_KERB_MARSHALLED_REQUEST_BODY(KERB_MARSHALLED_REQUEST_BODY *val);
static void ASN1CALL ASN1Free_KERB_AS_REPLY(KERB_AS_REPLY *val);
static void ASN1CALL ASN1Free_KERB_TGS_REPLY(KERB_TGS_REPLY *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_AS_REPLY(KERB_ENCRYPTED_AS_REPLY *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_TGS_REPLY(KERB_ENCRYPTED_TGS_REPLY *val);
static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REP2(KERB_PA_PK_AS_REP2 *val);
static void ASN1CALL ASN1Free_KERB_SIGNED_AUTH_PACKAGE(KERB_SIGNED_AUTH_PACKAGE *val);
static void ASN1CALL ASN1Free_KERB_AS_REQUEST(KERB_AS_REQUEST *val);
static void ASN1CALL ASN1Free_KERB_TGS_REQUEST(KERB_TGS_REQUEST *val);
static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REQ2(KERB_PA_PK_AS_REQ2 *val);

typedef ASN1BerEncFun_t ASN1EncFun_t;
static const ASN1EncFun_t encfntab[49] = {
    (ASN1EncFun_t) ASN1Enc_PKERB_AUTHORIZATION_DATA_LIST,
    (ASN1EncFun_t) ASN1Enc_PKERB_IF_RELEVANT_AUTH_DATA,
    (ASN1EncFun_t) ASN1Enc_PKERB_PREAUTH_DATA_LIST,
    (ASN1EncFun_t) ASN1Enc_KERB_ENCRYPTED_PRIV,
    (ASN1EncFun_t) ASN1Enc_KERB_ENCRYPTED_CRED,
    (ASN1EncFun_t) ASN1Enc_KERB_ERROR,
    (ASN1EncFun_t) ASN1Enc_KERB_ENCRYPTED_DATA,
    (ASN1EncFun_t) ASN1Enc_KERB_ENCRYPTION_KEY,
    (ASN1EncFun_t) ASN1Enc_KERB_CHECKSUM,
    (ASN1EncFun_t) ASN1Enc_KERB_ENCRYPTED_TIMESTAMP,
    (ASN1EncFun_t) ASN1Enc_KERB_SALTED_ENCRYPTED_TIMESTAMP,
    (ASN1EncFun_t) ASN1Enc_PKERB_ETYPE_INFO,
    (ASN1EncFun_t) ASN1Enc_KERB_TGT_REQUEST,
    (ASN1EncFun_t) ASN1Enc_KERB_PKCS_SIGNATURE,
    (ASN1EncFun_t) ASN1Enc_KERB_PA_PK_AS_REP,
    (ASN1EncFun_t) ASN1Enc_KERB_REPLY_KEY_PACKAGE2,
    (ASN1EncFun_t) ASN1Enc_KERB_REPLY_KEY_PACKAGE,
    (ASN1EncFun_t) ASN1Enc_KERB_KDC_DH_KEY_INFO,
    (ASN1EncFun_t) ASN1Enc_KERB_PA_PK_AS_REQ,
    (ASN1EncFun_t) ASN1Enc_KERB_DH_PARAMTER,
    (ASN1EncFun_t) ASN1Enc_KERB_KDC_ISSUED_AUTH_DATA,
    (ASN1EncFun_t) ASN1Enc_KERB_PA_SERV_REFERRAL,
    (ASN1EncFun_t) ASN1Enc_KERB_PA_PAC_REQUEST,
    (ASN1EncFun_t) ASN1Enc_KERB_CHANGE_PASSWORD_DATA,
    (ASN1EncFun_t) ASN1Enc_KERB_ERROR_METHOD_DATA,
    (ASN1EncFun_t) ASN1Enc_KERB_EXT_ERROR,
    (ASN1EncFun_t) ASN1Enc_TYPED_DATA,
    (ASN1EncFun_t) ASN1Enc_KERB_PA_FOR_USER,
    (ASN1EncFun_t) ASN1Enc_KERB_TICKET,
    (ASN1EncFun_t) ASN1Enc_KERB_ENCRYPTED_TICKET,
    (ASN1EncFun_t) ASN1Enc_KERB_AUTHENTICATOR,
    (ASN1EncFun_t) ASN1Enc_KERB_AP_REQUEST,
    (ASN1EncFun_t) ASN1Enc_KERB_AP_REPLY,
    (ASN1EncFun_t) ASN1Enc_KERB_ENCRYPTED_AP_REPLY,
    (ASN1EncFun_t) ASN1Enc_KERB_SAFE_MESSAGE,
    (ASN1EncFun_t) ASN1Enc_KERB_PRIV_MESSAGE,
    (ASN1EncFun_t) ASN1Enc_KERB_CRED,
    (ASN1EncFun_t) ASN1Enc_KERB_TGT_REPLY,
    (ASN1EncFun_t) ASN1Enc_KERB_SIGNED_REPLY_KEY_PACKAGE,
    (ASN1EncFun_t) ASN1Enc_KERB_AUTH_PACKAGE,
    (ASN1EncFun_t) ASN1Enc_KERB_MARSHALLED_REQUEST_BODY,
    (ASN1EncFun_t) ASN1Enc_KERB_AS_REPLY,
    (ASN1EncFun_t) ASN1Enc_KERB_TGS_REPLY,
    (ASN1EncFun_t) ASN1Enc_KERB_ENCRYPTED_AS_REPLY,
    (ASN1EncFun_t) ASN1Enc_KERB_ENCRYPTED_TGS_REPLY,
    (ASN1EncFun_t) ASN1Enc_KERB_PA_PK_AS_REP2,
    (ASN1EncFun_t) ASN1Enc_KERB_AS_REQUEST,
    (ASN1EncFun_t) ASN1Enc_KERB_TGS_REQUEST,
    (ASN1EncFun_t) ASN1Enc_KERB_PA_PK_AS_REQ2,
};
typedef ASN1BerDecFun_t ASN1DecFun_t;
static const ASN1DecFun_t decfntab[49] = {
    (ASN1DecFun_t) ASN1Dec_PKERB_AUTHORIZATION_DATA_LIST,
    (ASN1DecFun_t) ASN1Dec_PKERB_IF_RELEVANT_AUTH_DATA,
    (ASN1DecFun_t) ASN1Dec_PKERB_PREAUTH_DATA_LIST,
    (ASN1DecFun_t) ASN1Dec_KERB_ENCRYPTED_PRIV,
    (ASN1DecFun_t) ASN1Dec_KERB_ENCRYPTED_CRED,
    (ASN1DecFun_t) ASN1Dec_KERB_ERROR,
    (ASN1DecFun_t) ASN1Dec_KERB_ENCRYPTED_DATA,
    (ASN1DecFun_t) ASN1Dec_KERB_ENCRYPTION_KEY,
    (ASN1DecFun_t) ASN1Dec_KERB_CHECKSUM,
    (ASN1DecFun_t) ASN1Dec_KERB_ENCRYPTED_TIMESTAMP,
    (ASN1DecFun_t) ASN1Dec_KERB_SALTED_ENCRYPTED_TIMESTAMP,
    (ASN1DecFun_t) ASN1Dec_PKERB_ETYPE_INFO,
    (ASN1DecFun_t) ASN1Dec_KERB_TGT_REQUEST,
    (ASN1DecFun_t) ASN1Dec_KERB_PKCS_SIGNATURE,
    (ASN1DecFun_t) ASN1Dec_KERB_PA_PK_AS_REP,
    (ASN1DecFun_t) ASN1Dec_KERB_REPLY_KEY_PACKAGE2,
    (ASN1DecFun_t) ASN1Dec_KERB_REPLY_KEY_PACKAGE,
    (ASN1DecFun_t) ASN1Dec_KERB_KDC_DH_KEY_INFO,
    (ASN1DecFun_t) ASN1Dec_KERB_PA_PK_AS_REQ,
    (ASN1DecFun_t) ASN1Dec_KERB_DH_PARAMTER,
    (ASN1DecFun_t) ASN1Dec_KERB_KDC_ISSUED_AUTH_DATA,
    (ASN1DecFun_t) ASN1Dec_KERB_PA_SERV_REFERRAL,
    (ASN1DecFun_t) ASN1Dec_KERB_PA_PAC_REQUEST,
    (ASN1DecFun_t) ASN1Dec_KERB_CHANGE_PASSWORD_DATA,
    (ASN1DecFun_t) ASN1Dec_KERB_ERROR_METHOD_DATA,
    (ASN1DecFun_t) ASN1Dec_KERB_EXT_ERROR,
    (ASN1DecFun_t) ASN1Dec_TYPED_DATA,
    (ASN1DecFun_t) ASN1Dec_KERB_PA_FOR_USER,
    (ASN1DecFun_t) ASN1Dec_KERB_TICKET,
    (ASN1DecFun_t) ASN1Dec_KERB_ENCRYPTED_TICKET,
    (ASN1DecFun_t) ASN1Dec_KERB_AUTHENTICATOR,
    (ASN1DecFun_t) ASN1Dec_KERB_AP_REQUEST,
    (ASN1DecFun_t) ASN1Dec_KERB_AP_REPLY,
    (ASN1DecFun_t) ASN1Dec_KERB_ENCRYPTED_AP_REPLY,
    (ASN1DecFun_t) ASN1Dec_KERB_SAFE_MESSAGE,
    (ASN1DecFun_t) ASN1Dec_KERB_PRIV_MESSAGE,
    (ASN1DecFun_t) ASN1Dec_KERB_CRED,
    (ASN1DecFun_t) ASN1Dec_KERB_TGT_REPLY,
    (ASN1DecFun_t) ASN1Dec_KERB_SIGNED_REPLY_KEY_PACKAGE,
    (ASN1DecFun_t) ASN1Dec_KERB_AUTH_PACKAGE,
    (ASN1DecFun_t) ASN1Dec_KERB_MARSHALLED_REQUEST_BODY,
    (ASN1DecFun_t) ASN1Dec_KERB_AS_REPLY,
    (ASN1DecFun_t) ASN1Dec_KERB_TGS_REPLY,
    (ASN1DecFun_t) ASN1Dec_KERB_ENCRYPTED_AS_REPLY,
    (ASN1DecFun_t) ASN1Dec_KERB_ENCRYPTED_TGS_REPLY,
    (ASN1DecFun_t) ASN1Dec_KERB_PA_PK_AS_REP2,
    (ASN1DecFun_t) ASN1Dec_KERB_AS_REQUEST,
    (ASN1DecFun_t) ASN1Dec_KERB_TGS_REQUEST,
    (ASN1DecFun_t) ASN1Dec_KERB_PA_PK_AS_REQ2,
};
static const ASN1FreeFun_t freefntab[49] = {
    (ASN1FreeFun_t) ASN1Free_PKERB_AUTHORIZATION_DATA_LIST,
    (ASN1FreeFun_t) ASN1Free_PKERB_IF_RELEVANT_AUTH_DATA,
    (ASN1FreeFun_t) ASN1Free_PKERB_PREAUTH_DATA_LIST,
    (ASN1FreeFun_t) ASN1Free_KERB_ENCRYPTED_PRIV,
    (ASN1FreeFun_t) ASN1Free_KERB_ENCRYPTED_CRED,
    (ASN1FreeFun_t) ASN1Free_KERB_ERROR,
    (ASN1FreeFun_t) ASN1Free_KERB_ENCRYPTED_DATA,
    (ASN1FreeFun_t) ASN1Free_KERB_ENCRYPTION_KEY,
    (ASN1FreeFun_t) ASN1Free_KERB_CHECKSUM,
    (ASN1FreeFun_t) ASN1Free_KERB_ENCRYPTED_TIMESTAMP,
    (ASN1FreeFun_t) ASN1Free_KERB_SALTED_ENCRYPTED_TIMESTAMP,
    (ASN1FreeFun_t) ASN1Free_PKERB_ETYPE_INFO,
    (ASN1FreeFun_t) ASN1Free_KERB_TGT_REQUEST,
    (ASN1FreeFun_t) ASN1Free_KERB_PKCS_SIGNATURE,
    (ASN1FreeFun_t) ASN1Free_KERB_PA_PK_AS_REP,
    (ASN1FreeFun_t) ASN1Free_KERB_REPLY_KEY_PACKAGE2,
    (ASN1FreeFun_t) ASN1Free_KERB_REPLY_KEY_PACKAGE,
    (ASN1FreeFun_t) ASN1Free_KERB_KDC_DH_KEY_INFO,
    (ASN1FreeFun_t) ASN1Free_KERB_PA_PK_AS_REQ,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) ASN1Free_KERB_KDC_ISSUED_AUTH_DATA,
    (ASN1FreeFun_t) ASN1Free_KERB_PA_SERV_REFERRAL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) ASN1Free_KERB_CHANGE_PASSWORD_DATA,
    (ASN1FreeFun_t) ASN1Free_KERB_ERROR_METHOD_DATA,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) ASN1Free_TYPED_DATA,
    (ASN1FreeFun_t) ASN1Free_KERB_PA_FOR_USER,
    (ASN1FreeFun_t) ASN1Free_KERB_TICKET,
    (ASN1FreeFun_t) ASN1Free_KERB_ENCRYPTED_TICKET,
    (ASN1FreeFun_t) ASN1Free_KERB_AUTHENTICATOR,
    (ASN1FreeFun_t) ASN1Free_KERB_AP_REQUEST,
    (ASN1FreeFun_t) ASN1Free_KERB_AP_REPLY,
    (ASN1FreeFun_t) ASN1Free_KERB_ENCRYPTED_AP_REPLY,
    (ASN1FreeFun_t) ASN1Free_KERB_SAFE_MESSAGE,
    (ASN1FreeFun_t) ASN1Free_KERB_PRIV_MESSAGE,
    (ASN1FreeFun_t) ASN1Free_KERB_CRED,
    (ASN1FreeFun_t) ASN1Free_KERB_TGT_REPLY,
    (ASN1FreeFun_t) ASN1Free_KERB_SIGNED_REPLY_KEY_PACKAGE,
    (ASN1FreeFun_t) ASN1Free_KERB_AUTH_PACKAGE,
    (ASN1FreeFun_t) ASN1Free_KERB_MARSHALLED_REQUEST_BODY,
    (ASN1FreeFun_t) ASN1Free_KERB_AS_REPLY,
    (ASN1FreeFun_t) ASN1Free_KERB_TGS_REPLY,
    (ASN1FreeFun_t) ASN1Free_KERB_ENCRYPTED_AS_REPLY,
    (ASN1FreeFun_t) ASN1Free_KERB_ENCRYPTED_TGS_REPLY,
    (ASN1FreeFun_t) ASN1Free_KERB_PA_PK_AS_REP2,
    (ASN1FreeFun_t) ASN1Free_KERB_AS_REQUEST,
    (ASN1FreeFun_t) ASN1Free_KERB_TGS_REQUEST,
    (ASN1FreeFun_t) ASN1Free_KERB_PA_PK_AS_REQ2,
};
static const ULONG sizetab[49] = {
    SIZE_KRB5_Module_PDU_0,
    SIZE_KRB5_Module_PDU_1,
    SIZE_KRB5_Module_PDU_2,
    SIZE_KRB5_Module_PDU_3,
    SIZE_KRB5_Module_PDU_4,
    SIZE_KRB5_Module_PDU_5,
    SIZE_KRB5_Module_PDU_6,
    SIZE_KRB5_Module_PDU_7,
    SIZE_KRB5_Module_PDU_8,
    SIZE_KRB5_Module_PDU_9,
    SIZE_KRB5_Module_PDU_10,
    SIZE_KRB5_Module_PDU_11,
    SIZE_KRB5_Module_PDU_12,
    SIZE_KRB5_Module_PDU_13,
    SIZE_KRB5_Module_PDU_14,
    SIZE_KRB5_Module_PDU_15,
    SIZE_KRB5_Module_PDU_16,
    SIZE_KRB5_Module_PDU_17,
    SIZE_KRB5_Module_PDU_18,
    SIZE_KRB5_Module_PDU_19,
    SIZE_KRB5_Module_PDU_20,
    SIZE_KRB5_Module_PDU_21,
    SIZE_KRB5_Module_PDU_22,
    SIZE_KRB5_Module_PDU_23,
    SIZE_KRB5_Module_PDU_24,
    SIZE_KRB5_Module_PDU_25,
    SIZE_KRB5_Module_PDU_26,
    SIZE_KRB5_Module_PDU_27,
    SIZE_KRB5_Module_PDU_28,
    SIZE_KRB5_Module_PDU_29,
    SIZE_KRB5_Module_PDU_30,
    SIZE_KRB5_Module_PDU_31,
    SIZE_KRB5_Module_PDU_32,
    SIZE_KRB5_Module_PDU_33,
    SIZE_KRB5_Module_PDU_34,
    SIZE_KRB5_Module_PDU_35,
    SIZE_KRB5_Module_PDU_36,
    SIZE_KRB5_Module_PDU_37,
    SIZE_KRB5_Module_PDU_38,
    SIZE_KRB5_Module_PDU_39,
    SIZE_KRB5_Module_PDU_40,
    SIZE_KRB5_Module_PDU_41,
    SIZE_KRB5_Module_PDU_42,
    SIZE_KRB5_Module_PDU_43,
    SIZE_KRB5_Module_PDU_44,
    SIZE_KRB5_Module_PDU_45,
    SIZE_KRB5_Module_PDU_46,
    SIZE_KRB5_Module_PDU_47,
    SIZE_KRB5_Module_PDU_48,
};

/* forward declarations of values: */
/* definitions of value components: */
/* definitions of values: */

void ASN1CALL KRB5_Module_Startup(void)
{
    KRB5_Module = ASN1_CreateModule(0x10000, ASN1_BER_RULE_DER, ASN1FLAGS_NOASSERT, 49, (const ASN1GenericFun_t *) encfntab, (const ASN1GenericFun_t *) decfntab, freefntab, sizetab, 0x3562726b);
}

void ASN1CALL KRB5_Module_Cleanup(void)
{
    ASN1_CloseModule(KRB5_Module);
    KRB5_Module = NULL;
}

static int ASN1CALL ASN1Enc_PKERB_AUTHORIZATION_DATA_LIST(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_AUTHORIZATION_DATA_LIST *val)
{
    if (!ASN1Enc_PKERB_AUTHORIZATION_DATA(enc, tag, val))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_AUTHORIZATION_DATA_LIST(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_AUTHORIZATION_DATA_LIST *val)
{
    if (!ASN1Dec_PKERB_AUTHORIZATION_DATA(dec, tag, val))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_AUTHORIZATION_DATA_LIST(PKERB_AUTHORIZATION_DATA_LIST *val)
{
    if (val) {
    ASN1Free_PKERB_AUTHORIZATION_DATA(val);
    }
}

static int ASN1CALL ASN1Enc_PKERB_IF_RELEVANT_AUTH_DATA(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_IF_RELEVANT_AUTH_DATA *val)
{
    if (!ASN1Enc_PKERB_AUTHORIZATION_DATA(enc, tag, val))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_IF_RELEVANT_AUTH_DATA(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_IF_RELEVANT_AUTH_DATA *val)
{
    if (!ASN1Dec_PKERB_AUTHORIZATION_DATA(dec, tag, val))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_IF_RELEVANT_AUTH_DATA(PKERB_IF_RELEVANT_AUTH_DATA *val)
{
    if (val) {
    ASN1Free_PKERB_AUTHORIZATION_DATA(val);
    }
}

static int ASN1CALL ASN1Enc_KERB_KDC_REQUEST_BODY_encryption_type(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_KDC_REQUEST_BODY_encryption_type *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_KDC_REQUEST_BODY_encryption_type f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000008, &nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
    return 0;
    for (f = *val; f; f = f->next) {
    if (!ASN1BEREncS32(enc, 0x2, f->value))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KDC_REQUEST_BODY_encryption_type(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_KDC_REQUEST_BODY_encryption_type *val)
{
    PKERB_KDC_REQUEST_BODY_encryption_type *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000008, &dd0, &di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
    return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
    if (!ASN1BERDecPeekTag(dd, &t))
        return 0;
    if (!(*f = (PKERB_KDC_REQUEST_BODY_encryption_type)ASN1DecAlloc(dd, sizeof(**f))))
        return 0;
    if (!ASN1BERDecS32Val(dd, 0x2, &(*f)->value))
        return 0;
    f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KDC_REQUEST_BODY_encryption_type(PKERB_KDC_REQUEST_BODY_encryption_type *val)
{
    PKERB_KDC_REQUEST_BODY_encryption_type f, ff;
    if (val) {
    for (f = *val; f; f = ff) {
        ff = f->next;
        ASN1Free(f);
    }
    }
}

static int ASN1CALL ASN1Enc_PKERB_TICKET_EXTENSIONS_Seq(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_TICKET_EXTENSIONS_Seq *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->te_type))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->te_data).length, ((val)->te_data).value))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_TICKET_EXTENSIONS_Seq(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_TICKET_EXTENSIONS_Seq *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->te_type))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->te_data))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_TICKET_EXTENSIONS_Seq(PKERB_TICKET_EXTENSIONS_Seq *val)
{
    if (val) {
    ASN1octetstring_free(&(val)->te_data);
    }
}

static int ASN1CALL ASN1Enc_KERB_PRINCIPAL_NAME_name_string(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PRINCIPAL_NAME_name_string *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_PRINCIPAL_NAME_name_string f;
    ASN1uint32_t nLenOff;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
    return 0;
    for (f = *val; f; f = f->next) {
    t = lstrlenA(f->value);
    if (!ASN1DEREncCharString(enc, 0x1b, t, f->value))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PRINCIPAL_NAME_name_string(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PRINCIPAL_NAME_name_string *val)
{
    PKERB_PRINCIPAL_NAME_name_string *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
    return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
    if (!ASN1BERDecPeekTag(dd, &t))
        return 0;
    if (!(*f = (PKERB_PRINCIPAL_NAME_name_string)ASN1DecAlloc(dd, sizeof(**f))))
        return 0;
    if (!ASN1BERDecZeroCharString(dd, 0x1b, &(*f)->value))
        return 0;
    f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PRINCIPAL_NAME_name_string(PKERB_PRINCIPAL_NAME_name_string *val)
{
    PKERB_PRINCIPAL_NAME_name_string f, ff;
    if (val) {
    for (f = *val; f; f = ff) {
        ASN1ztcharstring_free(f->value);
        ff = f->next;
        ASN1Free(f);
    }
    }
}

static int ASN1CALL ASN1Enc_PKERB_LAST_REQUEST_Seq(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_LAST_REQUEST_Seq *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->last_request_type))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->last_request_value))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_LAST_REQUEST_Seq(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_LAST_REQUEST_Seq *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->last_request_type))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->last_request_value))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_LAST_REQUEST_Seq(PKERB_LAST_REQUEST_Seq *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_PKERB_AUTHORIZATION_DATA_Seq(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_AUTHORIZATION_DATA_Seq *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->auth_data_type))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->auth_data).length, ((val)->auth_data).value))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_AUTHORIZATION_DATA_Seq(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_AUTHORIZATION_DATA_Seq *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->auth_data_type))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->auth_data))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_AUTHORIZATION_DATA_Seq(PKERB_AUTHORIZATION_DATA_Seq *val)
{
    if (val) {
    ASN1octetstring_free(&(val)->auth_data);
    }
}

static int ASN1CALL ASN1Enc_PKERB_HOST_ADDRESSES_Seq(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_HOST_ADDRESSES_Seq *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->address_type))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->address).length, ((val)->address).value))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_HOST_ADDRESSES_Seq(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_HOST_ADDRESSES_Seq *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->address_type))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->address))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_HOST_ADDRESSES_Seq(PKERB_HOST_ADDRESSES_Seq *val)
{
    if (val) {
    ASN1octetstring_free(&(val)->address);
    }
}

static int ASN1CALL ASN1Enc_KERB_HOST_ADDRESS(ASN1encoding_t enc, ASN1uint32_t tag, KERB_HOST_ADDRESS *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->addr_type))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->address).length, ((val)->address).value))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_HOST_ADDRESS(ASN1decoding_t dec, ASN1uint32_t tag, KERB_HOST_ADDRESS *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->addr_type))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->address))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_HOST_ADDRESS(KERB_HOST_ADDRESS *val)
{
    if (val) {
    ASN1octetstring_free(&(val)->address);
    }
}

static int ASN1CALL ASN1Enc_PKERB_HOST_ADDRESSES(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_HOST_ADDRESSES *val)
{
    PPKERB_HOST_ADDRESSES f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    for (f = *val; f; f = f->next) {
    if (!ASN1Enc_PKERB_HOST_ADDRESSES_Seq(enc, 0, &f->value))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_HOST_ADDRESSES(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_HOST_ADDRESSES *val)
{
    PPKERB_HOST_ADDRESSES *f;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
    if (!ASN1BERDecPeekTag(dd, &t))
        return 0;
    if (!(*f = (PPKERB_HOST_ADDRESSES)ASN1DecAlloc(dd, sizeof(**f))))
        return 0;
    if (!ASN1Dec_PKERB_HOST_ADDRESSES_Seq(dd, 0, &(*f)->value))
        return 0;
    f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_HOST_ADDRESSES(PPKERB_HOST_ADDRESSES *val)
{
    PPKERB_HOST_ADDRESSES f, ff;
    if (val) {
    for (f = *val; f; f = ff) {
        ASN1Free_PKERB_HOST_ADDRESSES_Seq(&f->value);
        ff = f->next;
        ASN1Free(f);
    }
    }
}

static int ASN1CALL ASN1Enc_PKERB_AUTHORIZATION_DATA(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_AUTHORIZATION_DATA *val)
{
    PPKERB_AUTHORIZATION_DATA f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    for (f = *val; f; f = f->next) {
    if (!ASN1Enc_PKERB_AUTHORIZATION_DATA_Seq(enc, 0, &f->value))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_AUTHORIZATION_DATA(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_AUTHORIZATION_DATA *val)
{
    PPKERB_AUTHORIZATION_DATA *f;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
    if (!ASN1BERDecPeekTag(dd, &t))
        return 0;
    if (!(*f = (PPKERB_AUTHORIZATION_DATA)ASN1DecAlloc(dd, sizeof(**f))))
        return 0;
    if (!ASN1Dec_PKERB_AUTHORIZATION_DATA_Seq(dd, 0, &(*f)->value))
        return 0;
    f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_AUTHORIZATION_DATA(PPKERB_AUTHORIZATION_DATA *val)
{
    PPKERB_AUTHORIZATION_DATA f, ff;
    if (val) {
    for (f = *val; f; f = ff) {
        ASN1Free_PKERB_AUTHORIZATION_DATA_Seq(&f->value);
        ff = f->next;
        ASN1Free(f);
    }
    }
}

static int ASN1CALL ASN1Enc_PKERB_LAST_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_LAST_REQUEST *val)
{
    PPKERB_LAST_REQUEST f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    for (f = *val; f; f = f->next) {
    if (!ASN1Enc_PKERB_LAST_REQUEST_Seq(enc, 0, &f->value))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_LAST_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_LAST_REQUEST *val)
{
    PPKERB_LAST_REQUEST *f;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
    if (!ASN1BERDecPeekTag(dd, &t))
        return 0;
    if (!(*f = (PPKERB_LAST_REQUEST)ASN1DecAlloc(dd, sizeof(**f))))
        return 0;
    if (!ASN1Dec_PKERB_LAST_REQUEST_Seq(dd, 0, &(*f)->value))
        return 0;
    f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_LAST_REQUEST(PPKERB_LAST_REQUEST *val)
{
    PPKERB_LAST_REQUEST f, ff;
    if (val) {
    for (f = *val; f; f = ff) {
        ASN1Free_PKERB_LAST_REQUEST_Seq(&f->value);
        ff = f->next;
        ASN1Free(f);
    }
    }
}

static int ASN1CALL ASN1Enc_KERB_PRINCIPAL_NAME(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PRINCIPAL_NAME *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->name_type))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME_name_string(enc, 0, &(val)->name_string))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PRINCIPAL_NAME(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PRINCIPAL_NAME *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->name_type))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME_name_string(dd, 0, &(val)->name_string))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PRINCIPAL_NAME(KERB_PRINCIPAL_NAME *val)
{
    if (val) {
    ASN1Free_KERB_PRINCIPAL_NAME_name_string(&(val)->name_string);
    }
}

static int ASN1CALL ASN1Enc_PKERB_TICKET_EXTENSIONS(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_TICKET_EXTENSIONS *val)
{
    PPKERB_TICKET_EXTENSIONS f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    for (f = *val; f; f = f->next) {
    if (!ASN1Enc_PKERB_TICKET_EXTENSIONS_Seq(enc, 0, &f->value))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_TICKET_EXTENSIONS(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_TICKET_EXTENSIONS *val)
{
    PPKERB_TICKET_EXTENSIONS *f;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
    if (!ASN1BERDecPeekTag(dd, &t))
        return 0;
    if (!(*f = (PPKERB_TICKET_EXTENSIONS)ASN1DecAlloc(dd, sizeof(**f))))
        return 0;
    if (!ASN1Dec_PKERB_TICKET_EXTENSIONS_Seq(dd, 0, &(*f)->value))
        return 0;
    f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_TICKET_EXTENSIONS(PPKERB_TICKET_EXTENSIONS *val)
{
    PPKERB_TICKET_EXTENSIONS f, ff;
    if (val) {
    for (f = *val; f; f = ff) {
        ASN1Free_PKERB_TICKET_EXTENSIONS_Seq(&f->value);
        ff = f->next;
        ASN1Free(f);
    }
    }
}

static int ASN1CALL ASN1Enc_KERB_TRANSITED_ENCODING(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TRANSITED_ENCODING *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->transited_type))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->contents).length, ((val)->contents).value))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_TRANSITED_ENCODING(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TRANSITED_ENCODING *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->transited_type))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->contents))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_TRANSITED_ENCODING(KERB_TRANSITED_ENCODING *val)
{
    if (val) {
    ASN1octetstring_free(&(val)->contents);
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_DATA *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->preauth_data_type))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
    return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->preauth_data).length, ((val)->preauth_data).value))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_DATA *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->preauth_data_type))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
    return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->preauth_data))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_DATA(KERB_PA_DATA *val)
{
    if (val) {
    ASN1octetstring_free(&(val)->preauth_data);
    }
}

static int ASN1CALL ASN1Enc_PKERB_PREAUTH_DATA_LIST(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_PREAUTH_DATA_LIST *val)
{
    PPKERB_PREAUTH_DATA_LIST f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    for (f = *val; f; f = f->next) {
    if (!ASN1Enc_KERB_PA_DATA(enc, 0, &f->value))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_PREAUTH_DATA_LIST(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_PREAUTH_DATA_LIST *val)
{
    PPKERB_PREAUTH_DATA_LIST *f;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
    if (!ASN1BERDecPeekTag(dd, &t))
        return 0;
    if (!(*f = (PPKERB_PREAUTH_DATA_LIST)ASN1DecAlloc(dd, sizeof(**f))))
        return 0;
    if (!ASN1Dec_KERB_PA_DATA(dd, 0, &(*f)->value))
        return 0;
    f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_PREAUTH_DATA_LIST(PPKERB_PREAUTH_DATA_LIST *val)
{
    PPKERB_PREAUTH_DATA_LIST f, ff;
    if (val) {
    for (f = *val; f; f = ff) {
        ASN1Free_KERB_PA_DATA(&f->value);
        ff = f->next;
        ASN1Free(f);
    }
    }
}

static int ASN1CALL ASN1Enc_KERB_SAFE_BODY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SAFE_BODY *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->user_data).length, ((val)->user_data).value))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
        return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->timestamp))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
        return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->usec))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
        return 0;
    if (!ASN1BEREncU32(enc, 0x2, (val)->sequence_number))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_HOST_ADDRESS(enc, 0, &(val)->sender_address))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if ((val)->o[0] & 0x10) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000005, &nLenOff0))
        return 0;
    if (!ASN1Enc_KERB_HOST_ADDRESS(enc, 0, &(val)->recipient_address))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_SAFE_BODY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SAFE_BODY *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->user_data))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
    (val)->o[0] |= 0x80;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
        return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->timestamp))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
    (val)->o[0] |= 0x40;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
        return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->usec))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
    (val)->o[0] |= 0x20;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
        return 0;
    if (!ASN1BERDecU32Val(dd0, 0x2, (ASN1uint32_t *) &(val)->sequence_number))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_HOST_ADDRESS(dd0, 0, &(val)->sender_address))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000005) {
    (val)->o[0] |= 0x10;
    if (!ASN1BERDecExplicitTag(dd, 0x80000005, &dd0, &di0))
        return 0;
    if (!ASN1Dec_KERB_HOST_ADDRESS(dd0, 0, &(val)->recipient_address))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_SAFE_BODY(KERB_SAFE_BODY *val)
{
    if (val) {
    ASN1octetstring_free(&(val)->user_data);
    if ((val)->o[0] & 0x80) {
    }
    ASN1Free_KERB_HOST_ADDRESS(&(val)->sender_address);
    if ((val)->o[0] & 0x10) {
        ASN1Free_KERB_HOST_ADDRESS(&(val)->recipient_address);
    }
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_PRIV(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_PRIV *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000001c, &nExplTagLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->user_data).length, ((val)->user_data).value))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
        return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->timestamp))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
        return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->usec))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
        return 0;
    if (!ASN1BEREncU32(enc, 0x2, (val)->sequence_number))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_HOST_ADDRESS(enc, 0, &(val)->sender_address))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if ((val)->o[0] & 0x10) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000005, &nLenOff0))
        return 0;
    if (!ASN1Enc_KERB_HOST_ADDRESS(enc, 0, &(val)->recipient_address))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_PRIV(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_PRIV *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000001c, &pExplTagDec0, &pbExplTagDataEnd0))
    return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
    return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->user_data))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
    (val)->o[0] |= 0x80;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
        return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->timestamp))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
    (val)->o[0] |= 0x40;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
        return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->usec))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
    (val)->o[0] |= 0x20;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
        return 0;
    if (!ASN1BERDecU32Val(dd0, 0x2, (ASN1uint32_t *) &(val)->sequence_number))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_HOST_ADDRESS(dd0, 0, &(val)->sender_address))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000005) {
    (val)->o[0] |= 0x10;
    if (!ASN1BERDecExplicitTag(dd, 0x80000005, &dd0, &di0))
        return 0;
    if (!ASN1Dec_KERB_HOST_ADDRESS(dd0, 0, &(val)->recipient_address))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_PRIV(KERB_ENCRYPTED_PRIV *val)
{
    if (val) {
    ASN1octetstring_free(&(val)->user_data);
    if ((val)->o[0] & 0x80) {
    }
    ASN1Free_KERB_HOST_ADDRESS(&(val)->sender_address);
    if ((val)->o[0] & 0x10) {
        ASN1Free_KERB_HOST_ADDRESS(&(val)->recipient_address);
    }
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_CRED(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_CRED *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000001d, &nExplTagLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
    return 0;
    if (!ASN1Enc_KERB_ENCRYPTED_CRED_ticket_info(enc, 0, &(val)->ticket_info))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
        return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->nonce))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
        return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->timestamp))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
        return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->usec))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if ((val)->o[0] & 0x10) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
        return 0;
    if (!ASN1Enc_KERB_HOST_ADDRESS(enc, 0, &(val)->sender_address))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if ((val)->o[0] & 0x8) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000005, &nLenOff0))
        return 0;
    if (!ASN1Enc_KERB_HOST_ADDRESS(enc, 0, &(val)->recipient_address))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_CRED(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_CRED *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000001d, &pExplTagDec0, &pbExplTagDataEnd0))
    return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
    return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1Dec_KERB_ENCRYPTED_CRED_ticket_info(dd, 0, &(val)->ticket_info))
    return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
    (val)->o[0] |= 0x80;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
        return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->nonce))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
    (val)->o[0] |= 0x40;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
        return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->timestamp))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
    (val)->o[0] |= 0x20;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
        return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->usec))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000004) {
    (val)->o[0] |= 0x10;
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
        return 0;
    if (!ASN1Dec_KERB_HOST_ADDRESS(dd0, 0, &(val)->sender_address))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000005) {
    (val)->o[0] |= 0x8;
    if (!ASN1BERDecExplicitTag(dd, 0x80000005, &dd0, &di0))
        return 0;
    if (!ASN1Dec_KERB_HOST_ADDRESS(dd0, 0, &(val)->recipient_address))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_CRED(KERB_ENCRYPTED_CRED *val)
{
    if (val) {
    ASN1Free_KERB_ENCRYPTED_CRED_ticket_info(&(val)->ticket_info);
    if ((val)->o[0] & 0x40) {
    }
    if ((val)->o[0] & 0x10) {
        ASN1Free_KERB_HOST_ADDRESS(&(val)->sender_address);
    }
    if ((val)->o[0] & 0x8) {
        ASN1Free_KERB_HOST_ADDRESS(&(val)->recipient_address);
    }
    }
}

static int ASN1CALL ASN1Enc_KERB_ERROR(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ERROR *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000001e, &nExplTagLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->message_type))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
        return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->client_time))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
        return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->client_usec))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
    return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->server_time))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000005, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->server_usec))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000006, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->error_code))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if ((val)->o[0] & 0x20) {
    t = lstrlenA((val)->client_realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000007, &nLenOff0))
        return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->client_realm))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if ((val)->o[0] & 0x10) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000008, &nLenOff0))
        return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->client_name))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    t = lstrlenA((val)->realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000009, &nLenOff0))
    return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->realm))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x8000000a, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->server_name))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if ((val)->o[0] & 0x8) {
    if (!ASN1BEREncExplicitTag(enc, 0x8000000b, &nLenOff0))
        return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, ((val)->error_text).length, ((val)->error_text).value))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if ((val)->o[0] & 0x4) {
    if (!ASN1BEREncExplicitTag(enc, 0x8000000c, &nLenOff0))
        return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->error_data).length, ((val)->error_data).value))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ERROR(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ERROR *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000001e, &pExplTagDec0, &pbExplTagDataEnd0))
    return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
    return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->message_type))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
    (val)->o[0] |= 0x80;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
        return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->client_time))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
    (val)->o[0] |= 0x40;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
        return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->client_usec))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
    return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->server_time))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000005, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->server_usec))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000006, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->error_code))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000007) {
    (val)->o[0] |= 0x20;
    if (!ASN1BERDecExplicitTag(dd, 0x80000007, &dd0, &di0))
        return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->client_realm))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000008) {
    (val)->o[0] |= 0x10;
    if (!ASN1BERDecExplicitTag(dd, 0x80000008, &dd0, &di0))
        return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->client_name))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000009, &dd0, &di0))
    return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->realm))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x8000000a, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->server_name))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x8000000b) {
    (val)->o[0] |= 0x8;
    if (!ASN1BERDecExplicitTag(dd, 0x8000000b, &dd0, &di0))
        return 0;
    if (!ASN1BERDecCharString(dd0, 0x1b, &(val)->error_text))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x8000000c) {
    (val)->o[0] |= 0x4;
    if (!ASN1BERDecExplicitTag(dd, 0x8000000c, &dd0, &di0))
        return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->error_data))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ERROR(KERB_ERROR *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
    }
    if ((val)->o[0] & 0x20) {
        ASN1ztcharstring_free((val)->client_realm);
    }
    if ((val)->o[0] & 0x10) {
        ASN1Free_KERB_PRINCIPAL_NAME(&(val)->client_name);
    }
    ASN1ztcharstring_free((val)->realm);
    ASN1Free_KERB_PRINCIPAL_NAME(&(val)->server_name);
    if ((val)->o[0] & 0x8) {
        ASN1charstring_free(&(val)->error_text);
    }
    if ((val)->o[0] & 0x4) {
        ASN1octetstring_free(&(val)->error_data);
    }
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_DATA *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->encryption_type))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
        return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
    return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->cipher_text).length, ((val)->cipher_text).value))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_DATA *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->encryption_type))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
    (val)->o[0] |= 0x80;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
        return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
    return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->cipher_text))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_DATA(KERB_ENCRYPTED_DATA *val)
{
    if (val) {
    ASN1octetstring_free(&(val)->cipher_text);
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTION_KEY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTION_KEY *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->keytype))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->keyvalue).length, ((val)->keyvalue).value))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTION_KEY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTION_KEY *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->keytype))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->keyvalue))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTION_KEY(KERB_ENCRYPTION_KEY *val)
{
    if (val) {
    ASN1octetstring_free(&(val)->keyvalue);
    }
}

static int ASN1CALL ASN1Enc_KERB_CHECKSUM(ASN1encoding_t enc, ASN1uint32_t tag, KERB_CHECKSUM *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->checksum_type))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->checksum).length, ((val)->checksum).value))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_CHECKSUM(ASN1decoding_t dec, ASN1uint32_t tag, KERB_CHECKSUM *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->checksum_type))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->checksum))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_CHECKSUM(KERB_CHECKSUM *val)
{
    if (val) {
    ASN1octetstring_free(&(val)->checksum);
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_TIMESTAMP(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_TIMESTAMP *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->timestamp))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
        return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->usec))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_TIMESTAMP(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_TIMESTAMP *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->timestamp))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
    (val)->o[0] |= 0x80;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
        return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->usec))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_TIMESTAMP(KERB_ENCRYPTED_TIMESTAMP *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_KERB_SALTED_ENCRYPTED_TIMESTAMP(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SALTED_ENCRYPTED_TIMESTAMP *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->timestamp))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
        return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->usec))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
    return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->salt).length, ((val)->salt).value))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_SALTED_ENCRYPTED_TIMESTAMP(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SALTED_ENCRYPTED_TIMESTAMP *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->timestamp))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
    (val)->o[0] |= 0x80;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
        return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->usec))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
    return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->salt))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_SALTED_ENCRYPTED_TIMESTAMP(KERB_SALTED_ENCRYPTED_TIMESTAMP *val)
{
    if (val) {
    ASN1octetstring_free(&(val)->salt);
    }
}

static int ASN1CALL ASN1Enc_KERB_ETYPE_INFO_ENTRY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ETYPE_INFO_ENTRY *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->encryption_type))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
        return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->salt).length, ((val)->salt).value))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ETYPE_INFO_ENTRY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ETYPE_INFO_ENTRY *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->encryption_type))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
    (val)->o[0] |= 0x80;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
        return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->salt))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ETYPE_INFO_ENTRY(KERB_ETYPE_INFO_ENTRY *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1octetstring_free(&(val)->salt);
    }
    }
}

static int ASN1CALL ASN1Enc_PKERB_ETYPE_INFO(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_ETYPE_INFO *val)
{
    PPKERB_ETYPE_INFO f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    for (f = *val; f; f = f->next) {
    if (!ASN1Enc_KERB_ETYPE_INFO_ENTRY(enc, 0, &f->value))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_ETYPE_INFO(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_ETYPE_INFO *val)
{
    PPKERB_ETYPE_INFO *f;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
    if (!ASN1BERDecPeekTag(dd, &t))
        return 0;
    if (!(*f = (PPKERB_ETYPE_INFO)ASN1DecAlloc(dd, sizeof(**f))))
        return 0;
    if (!ASN1Dec_KERB_ETYPE_INFO_ENTRY(dd, 0, &(*f)->value))
        return 0;
    f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_ETYPE_INFO(PPKERB_ETYPE_INFO *val)
{
    PPKERB_ETYPE_INFO f, ff;
    if (val) {
    for (f = *val; f; f = ff) {
        ASN1Free_KERB_ETYPE_INFO_ENTRY(&f->value);
        ff = f->next;
        ASN1Free(f);
    }
    }
}

static int ASN1CALL ASN1Enc_KERB_TGT_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TGT_REQUEST *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->message_type))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
        return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->server_name))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    t = lstrlenA((val)->server_realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
        return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->server_realm))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_TGT_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TGT_REQUEST *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->message_type))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
    (val)->o[0] |= 0x80;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
        return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->server_name))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
    (val)->o[0] |= 0x40;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
        return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->server_realm))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_TGT_REQUEST(KERB_TGT_REQUEST *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1Free_KERB_PRINCIPAL_NAME(&(val)->server_name);
    }
    if ((val)->o[0] & 0x40) {
        ASN1ztcharstring_free((val)->server_realm);
    }
    }
}

static int ASN1CALL ASN1Enc_KERB_PKCS_SIGNATURE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PKCS_SIGNATURE *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->encryption_type))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->signature).length, ((val)->signature).value))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PKCS_SIGNATURE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PKCS_SIGNATURE *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->encryption_type))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->signature))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PKCS_SIGNATURE(KERB_PKCS_SIGNATURE *val)
{
    if (val) {
    ASN1octetstring_free(&(val)->signature);
    }
}

static int ASN1CALL ASN1Enc_KERB_ALGORITHM_IDENTIFIER(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ALGORITHM_IDENTIFIER *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncObjectIdentifier(enc, 0x6, &(val)->algorithm))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1BEREncOpenType(enc, &(val)->parameters))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ALGORITHM_IDENTIFIER(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ALGORITHM_IDENTIFIER *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecObjectIdentifier(dd, 0x6, &(val)->algorithm))
    return 0;
    if (ASN1BERDecPeekTag(dd, &t)) {
    (val)->o[0] |= 0x80;
    if (!ASN1BERDecOpenType2(dd, &(val)->parameters))
        return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ALGORITHM_IDENTIFIER(KERB_ALGORITHM_IDENTIFIER *val)
{
    if (val) {
    ASN1objectidentifier_free(&(val)->algorithm);
    if ((val)->o[0] & 0x80) {
    }
    }
}

static int ASN1CALL ASN1Enc_KERB_SIGNATURE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SIGNATURE *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_ALGORITHM_IDENTIFIER(enc, 0, &(val)->signature_algorithm))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->pkcs_signature).length, ((val)->pkcs_signature).value))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_SIGNATURE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SIGNATURE *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_ALGORITHM_IDENTIFIER(dd0, 0, &(val)->signature_algorithm))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1BERDecBitString(dd0, 0x3, &(val)->pkcs_signature))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_SIGNATURE(KERB_SIGNATURE *val)
{
    if (val) {
    ASN1Free_KERB_ALGORITHM_IDENTIFIER(&(val)->signature_algorithm);
    ASN1bitstring_free(&(val)->pkcs_signature);
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REP(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PK_AS_REP *val)
{
    switch ((val)->choice) {
    case 1:
    if (!ASN1DEREncOctetString(enc, 0x80000000, ((val)->u.dh_signed_data).length, ((val)->u.dh_signed_data).value))
        return 0;
    break;
    case 2:
    if (!ASN1DEREncOctetString(enc, 0x80000001, ((val)->u.key_package).length, ((val)->u.key_package).value))
        return 0;
    break;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REP(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PK_AS_REP *val)
{
    ASN1uint32_t t;
    if (!ASN1BERDecPeekTag(dec, &t))
    return 0;
    switch (t) {
    case 0x80000000:
    (val)->choice = 1;
    if (!ASN1BERDecOctetString(dec, 0x80000000, &(val)->u.dh_signed_data))
        return 0;
    break;
    case 0x80000001:
    (val)->choice = 2;
    if (!ASN1BERDecOctetString(dec, 0x80000001, &(val)->u.key_package))
        return 0;
    break;
    default:
    ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REP(KERB_PA_PK_AS_REP *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1octetstring_free(&(val)->u.dh_signed_data);
        break;
    case 2:
        ASN1octetstring_free(&(val)->u.key_package);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_KERB_ENVELOPED_KEY_PACKAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENVELOPED_KEY_PACKAGE *val)
{
    ASN1uint32_t nLenOff0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
        return 0;
    if (!ASN1Enc_KERB_ENCRYPTED_DATA(enc, 0, &(val)->u.encrypted_data))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    break;
    case 2:
    if (!ASN1DEREncOctetString(enc, 0x80000004, ((val)->u.pkinit_enveloped_data).length, ((val)->u.pkinit_enveloped_data).value))
        return 0;
    break;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENVELOPED_KEY_PACKAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENVELOPED_KEY_PACKAGE *val)
{
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecPeekTag(dec, &t))
    return 0;
    switch (t) {
    case 0x80000001:
    (val)->choice = 1;
    if (!ASN1BERDecExplicitTag(dec, 0x80000001, &dd0, &di0))
        return 0;
    if (!ASN1Dec_KERB_ENCRYPTED_DATA(dd0, 0, &(val)->u.encrypted_data))
        return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
        return 0;
    break;
    case 0x80000004:
    (val)->choice = 2;
    if (!ASN1BERDecOctetString(dec, 0x80000004, &(val)->u.pkinit_enveloped_data))
        return 0;
    break;
    default:
    ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENVELOPED_KEY_PACKAGE(KERB_ENVELOPED_KEY_PACKAGE *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_KERB_ENCRYPTED_DATA(&(val)->u.encrypted_data);
        break;
    case 2:
        ASN1octetstring_free(&(val)->u.pkinit_enveloped_data);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_KERB_REPLY_KEY_PACKAGE2(ASN1encoding_t enc, ASN1uint32_t tag, KERB_REPLY_KEY_PACKAGE2 *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_ENCRYPTION_KEY(enc, 0, &(val)->reply_key))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->nonce))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
        return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->subject_public_key).length, ((val)->subject_public_key).value))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_REPLY_KEY_PACKAGE2(ASN1decoding_t dec, ASN1uint32_t tag, KERB_REPLY_KEY_PACKAGE2 *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_ENCRYPTION_KEY(dd0, 0, &(val)->reply_key))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->nonce))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
    (val)->o[0] |= 0x80;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
        return 0;
    if (!ASN1BERDecBitString(dd0, 0x3, &(val)->subject_public_key))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_REPLY_KEY_PACKAGE2(KERB_REPLY_KEY_PACKAGE2 *val)
{
    if (val) {
    ASN1Free_KERB_ENCRYPTION_KEY(&(val)->reply_key);
    if ((val)->o[0] & 0x80) {
        ASN1bitstring_free(&(val)->subject_public_key);
    }
    }
}

static int ASN1CALL ASN1Enc_KERB_REPLY_KEY_PACKAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_REPLY_KEY_PACKAGE *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_ENCRYPTION_KEY(enc, 0, &(val)->reply_key))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->nonce))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_REPLY_KEY_PACKAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_REPLY_KEY_PACKAGE *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_ENCRYPTION_KEY(dd0, 0, &(val)->reply_key))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->nonce))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_REPLY_KEY_PACKAGE(KERB_REPLY_KEY_PACKAGE *val)
{
    if (val) {
    ASN1Free_KERB_ENCRYPTION_KEY(&(val)->reply_key);
    }
}

static int ASN1CALL ASN1Enc_KERB_KDC_DH_KEY_INFO(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KDC_DH_KEY_INFO *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->nonce))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->subject_public_key).length, ((val)->subject_public_key).value))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KDC_DH_KEY_INFO(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KDC_DH_KEY_INFO *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->nonce))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1BERDecBitString(dd0, 0x3, &(val)->subject_public_key))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KDC_DH_KEY_INFO(KERB_KDC_DH_KEY_INFO *val)
{
    if (val) {
    ASN1bitstring_free(&(val)->subject_public_key);
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REQ(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PK_AS_REQ *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1DEREncOctetString(enc, 0x80000000, ((val)->signed_auth_pack).length, ((val)->signed_auth_pack).value))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_KERB_PA_PK_AS_REQ_trusted_certifiers(enc, 0, &(val)->trusted_certifiers))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1DEREncOctetString(enc, 0x80000003, ((val)->kdc_cert).length, ((val)->kdc_cert).value))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1DEREncOctetString(enc, 0x80000004, ((val)->encryption_cert).length, ((val)->encryption_cert).value))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REQ(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PK_AS_REQ *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecOctetString(dd, 0x80000000, &(val)->signed_auth_pack))
    return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
    (val)->o[0] |= 0x80;
    if (!ASN1Dec_KERB_PA_PK_AS_REQ_trusted_certifiers(dd, 0, &(val)->trusted_certifiers))
        return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
    (val)->o[0] |= 0x40;
    if (!ASN1BERDecOctetString(dd, 0x80000003, &(val)->kdc_cert))
        return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000004) {
    (val)->o[0] |= 0x20;
    if (!ASN1BERDecOctetString(dd, 0x80000004, &(val)->encryption_cert))
        return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REQ(KERB_PA_PK_AS_REQ *val)
{
    if (val) {
    ASN1octetstring_free(&(val)->signed_auth_pack);
    if ((val)->o[0] & 0x80) {
        ASN1Free_KERB_PA_PK_AS_REQ_trusted_certifiers(&(val)->trusted_certifiers);
    }
    if ((val)->o[0] & 0x40) {
        ASN1octetstring_free(&(val)->kdc_cert);
    }
    if ((val)->o[0] & 0x20) {
        ASN1octetstring_free(&(val)->encryption_cert);
    }
    }
}

static int ASN1CALL ASN1Enc_KERB_KERBEROS_NAME(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KERBEROS_NAME *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t t;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    t = lstrlenA((val)->realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->realm))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->principal_name))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KERBEROS_NAME(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KERBEROS_NAME *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->realm))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->principal_name))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KERBEROS_NAME(KERB_KERBEROS_NAME *val)
{
    if (val) {
    ASN1ztcharstring_free((val)->realm);
    ASN1Free_KERB_PRINCIPAL_NAME(&(val)->principal_name);
    }
}

static int ASN1CALL ASN1Enc_KERB_PK_AUTHENTICATOR(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PK_AUTHENTICATOR *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->kdc_name))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    t = lstrlenA((val)->kdc_realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->kdc_realm))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->cusec))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
    return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->client_time))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->nonce))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PK_AUTHENTICATOR(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PK_AUTHENTICATOR *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->kdc_name))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->kdc_realm))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->cusec))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
    return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->client_time))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->nonce))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PK_AUTHENTICATOR(KERB_PK_AUTHENTICATOR *val)
{
    if (val) {
    ASN1Free_KERB_PRINCIPAL_NAME(&(val)->kdc_name);
    ASN1ztcharstring_free((val)->kdc_realm);
    }
}

static int ASN1CALL ASN1Enc_KERB_SUBJECT_PUBLIC_KEY_INFO(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SUBJECT_PUBLIC_KEY_INFO *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_ALGORITHM_IDENTIFIER(enc, 0, &(val)->algorithm))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->subjectPublicKey).length, ((val)->subjectPublicKey).value))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_SUBJECT_PUBLIC_KEY_INFO(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SUBJECT_PUBLIC_KEY_INFO *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_ALGORITHM_IDENTIFIER(dd0, 0, &(val)->algorithm))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1BERDecBitString(dd0, 0x3, &(val)->subjectPublicKey))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_SUBJECT_PUBLIC_KEY_INFO(KERB_SUBJECT_PUBLIC_KEY_INFO *val)
{
    if (val) {
    ASN1Free_KERB_ALGORITHM_IDENTIFIER(&(val)->algorithm);
    ASN1bitstring_free(&(val)->subjectPublicKey);
    }
}

static int ASN1CALL ASN1Enc_KERB_DH_PARAMTER(ASN1encoding_t enc, ASN1uint32_t tag, KERB_DH_PARAMTER *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->prime))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->base))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
        return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->private_value_length))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_DH_PARAMTER(ASN1decoding_t dec, ASN1uint32_t tag, KERB_DH_PARAMTER *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->prime))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->base))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
    (val)->o[0] |= 0x80;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
        return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->private_value_length))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_KERB_CERTIFICATE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_CERTIFICATE *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->cert_type))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->cert_data).length, ((val)->cert_data).value))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_CERTIFICATE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_CERTIFICATE *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->cert_type))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->cert_data))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_CERTIFICATE(KERB_CERTIFICATE *val)
{
    if (val) {
    ASN1octetstring_free(&(val)->cert_data);
    }
}

static int ASN1CALL ASN1Enc_KERB_TYPED_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TYPED_DATA *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->data_type))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->data_value).length, ((val)->data_value).value))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_TYPED_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TYPED_DATA *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->data_type))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->data_value))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_TYPED_DATA(KERB_TYPED_DATA *val)
{
    if (val) {
    ASN1octetstring_free(&(val)->data_value);
    }
}

static int ASN1CALL ASN1Enc_KERB_KDC_ISSUED_AUTH_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KDC_ISSUED_AUTH_DATA *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_SIGNATURE(enc, 0, &(val)->checksum))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_KDC_ISSUED_AUTH_DATA_elements(enc, 0, &(val)->elements))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KDC_ISSUED_AUTH_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KDC_ISSUED_AUTH_DATA *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_SIGNATURE(dd0, 0, &(val)->checksum))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1Dec_KERB_KDC_ISSUED_AUTH_DATA_elements(dd, 0, &(val)->elements))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KDC_ISSUED_AUTH_DATA(KERB_KDC_ISSUED_AUTH_DATA *val)
{
    if (val) {
    ASN1Free_KERB_SIGNATURE(&(val)->checksum);
    ASN1Free_KERB_KDC_ISSUED_AUTH_DATA_elements(&(val)->elements);
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_SERV_REFERRAL(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_SERV_REFERRAL *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
        return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->referred_server_name))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    t = lstrlenA((val)->referred_server_realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->referred_server_realm))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_SERV_REFERRAL(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_SERV_REFERRAL *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
    (val)->o[0] |= 0x80;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
        return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->referred_server_name))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->referred_server_realm))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_SERV_REFERRAL(KERB_PA_SERV_REFERRAL *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1Free_KERB_PRINCIPAL_NAME(&(val)->referred_server_name);
    }
    ASN1ztcharstring_free((val)->referred_server_realm);
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PAC_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PAC_REQUEST *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1BEREncBool(enc, 0x1, (val)->include_pac))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PAC_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PAC_REQUEST *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1BERDecBool(dd0, 0x1, &(val)->include_pac))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_KERB_CHANGE_PASSWORD_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_CHANGE_PASSWORD_DATA *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->new_password).length, ((val)->new_password).value))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
        return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->target_name))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    t = lstrlenA((val)->target_realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
        return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->target_realm))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_CHANGE_PASSWORD_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_CHANGE_PASSWORD_DATA *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->new_password))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
    (val)->o[0] |= 0x80;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
        return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->target_name))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
    (val)->o[0] |= 0x40;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
        return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->target_realm))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_CHANGE_PASSWORD_DATA(KERB_CHANGE_PASSWORD_DATA *val)
{
    if (val) {
    ASN1octetstring_free(&(val)->new_password);
    if ((val)->o[0] & 0x80) {
        ASN1Free_KERB_PRINCIPAL_NAME(&(val)->target_name);
    }
    if ((val)->o[0] & 0x40) {
        ASN1ztcharstring_free((val)->target_realm);
    }
    }
}

static int ASN1CALL ASN1Enc_KERB_ERROR_METHOD_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ERROR_METHOD_DATA *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->data_type))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
        return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->data_value).length, ((val)->data_value).value))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ERROR_METHOD_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ERROR_METHOD_DATA *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->data_type))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
    (val)->o[0] |= 0x80;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
        return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->data_value))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ERROR_METHOD_DATA(KERB_ERROR_METHOD_DATA *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1octetstring_free(&(val)->data_value);
    }
    }
}

static int ASN1CALL ASN1Enc_KERB_EXT_ERROR(ASN1encoding_t enc, ASN1uint32_t tag, KERB_EXT_ERROR *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->status))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->klininfo))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->flags))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_EXT_ERROR(ASN1decoding_t dec, ASN1uint32_t tag, KERB_EXT_ERROR *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->status))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->klininfo))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->flags))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_TYPED_DATA(ASN1encoding_t enc, ASN1uint32_t tag, PTYPED_DATA *val)
{
    PTYPED_DATA f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    for (f = *val; f; f = f->next) {
    if (!ASN1Enc_KERB_TYPED_DATA(enc, 0, &f->value))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TYPED_DATA(ASN1decoding_t dec, ASN1uint32_t tag, PTYPED_DATA *val)
{
    PTYPED_DATA *f;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
    if (!ASN1BERDecPeekTag(dd, &t))
        return 0;
    if (!(*f = (PTYPED_DATA)ASN1DecAlloc(dd, sizeof(**f))))
        return 0;
    if (!ASN1Dec_KERB_TYPED_DATA(dd, 0, &(*f)->value))
        return 0;
    f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_TYPED_DATA(PTYPED_DATA *val)
{
    PTYPED_DATA f, ff;
    if (val) {
    for (f = *val; f; f = ff) {
        ASN1Free_KERB_TYPED_DATA(&f->value);
        ff = f->next;
        ASN1Free(f);
    }
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_FOR_USER(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_FOR_USER *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->userName))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    t = lstrlenA((val)->userRealm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->userRealm))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_CHECKSUM(enc, 0, &(val)->cksum))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    t = lstrlenA((val)->authentication_package);
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
    return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->authentication_package))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
        return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->authorization_data).length, ((val)->authorization_data).value))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_FOR_USER(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_FOR_USER *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->userName))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->userRealm))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_CHECKSUM(dd0, 0, &(val)->cksum))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
    return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->authentication_package))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000004) {
    (val)->o[0] |= 0x80;
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
        return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->authorization_data))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    while (ASN1BERDecNotEndOfContents(dd, di)) {
    if (!ASN1BERDecSkip(dd))
        return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_FOR_USER(KERB_PA_FOR_USER *val)
{
    if (val) {
    ASN1Free_KERB_PRINCIPAL_NAME(&(val)->userName);
    ASN1ztcharstring_free((val)->userRealm);
    ASN1Free_KERB_CHECKSUM(&(val)->cksum);
    ASN1ztcharstring_free((val)->authentication_package);
    if ((val)->o[0] & 0x80) {
        ASN1octetstring_free(&(val)->authorization_data);
    }
    }
}

static int ASN1CALL ASN1Enc_KERB_KDC_ISSUED_AUTH_DATA_elements(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_KDC_ISSUED_AUTH_DATA_elements *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_KDC_ISSUED_AUTH_DATA_elements f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
    return 0;
    for (f = *val; f; f = f->next) {
    if (!ASN1Enc_KERB_PA_DATA(enc, 0, &f->value))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KDC_ISSUED_AUTH_DATA_elements(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_KDC_ISSUED_AUTH_DATA_elements *val)
{
    PKERB_KDC_ISSUED_AUTH_DATA_elements *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
    return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
    if (!ASN1BERDecPeekTag(dd, &t))
        return 0;
    if (!(*f = (PKERB_KDC_ISSUED_AUTH_DATA_elements)ASN1DecAlloc(dd, sizeof(**f))))
        return 0;
    if (!ASN1Dec_KERB_PA_DATA(dd, 0, &(*f)->value))
        return 0;
    f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KDC_ISSUED_AUTH_DATA_elements(PKERB_KDC_ISSUED_AUTH_DATA_elements *val)
{
    PKERB_KDC_ISSUED_AUTH_DATA_elements f, ff;
    if (val) {
    for (f = *val; f; f = ff) {
        ASN1Free_KERB_PA_DATA(&f->value);
        ff = f->next;
        ASN1Free(f);
    }
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REQ2_trusted_certifiers(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ2_trusted_certifiers *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_PA_PK_AS_REQ2_trusted_certifiers f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000002, &nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
    return 0;
    for (f = *val; f; f = f->next) {
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &f->value))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REQ2_trusted_certifiers(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ2_trusted_certifiers *val)
{
    PKERB_PA_PK_AS_REQ2_trusted_certifiers *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000002, &dd0, &di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
    return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
    if (!ASN1BERDecPeekTag(dd, &t))
        return 0;
    if (!(*f = (PKERB_PA_PK_AS_REQ2_trusted_certifiers)ASN1DecAlloc(dd, sizeof(**f))))
        return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd, 0, &(*f)->value))
        return 0;
    f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REQ2_trusted_certifiers(PKERB_PA_PK_AS_REQ2_trusted_certifiers *val)
{
    PKERB_PA_PK_AS_REQ2_trusted_certifiers f, ff;
    if (val) {
    for (f = *val; f; f = ff) {
        ASN1Free_KERB_PRINCIPAL_NAME(&f->value);
        ff = f->next;
        ASN1Free(f);
    }
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REQ2_user_certs(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ2_user_certs *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_PA_PK_AS_REQ2_user_certs f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
    return 0;
    for (f = *val; f; f = f->next) {
    if (!ASN1Enc_KERB_CERTIFICATE(enc, 0, &f->value))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REQ2_user_certs(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ2_user_certs *val)
{
    PKERB_PA_PK_AS_REQ2_user_certs *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
    return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
    if (!ASN1BERDecPeekTag(dd, &t))
        return 0;
    if (!(*f = (PKERB_PA_PK_AS_REQ2_user_certs)ASN1DecAlloc(dd, sizeof(**f))))
        return 0;
    if (!ASN1Dec_KERB_CERTIFICATE(dd, 0, &(*f)->value))
        return 0;
    f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REQ2_user_certs(PKERB_PA_PK_AS_REQ2_user_certs *val)
{
    PKERB_PA_PK_AS_REQ2_user_certs f, ff;
    if (val) {
    for (f = *val; f; f = ff) {
        ASN1Free_KERB_CERTIFICATE(&f->value);
        ff = f->next;
        ASN1Free(f);
    }
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REP2_kdc_cert(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_PK_AS_REP2_kdc_cert *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_PA_PK_AS_REP2_kdc_cert f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000003, &nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
    return 0;
    for (f = *val; f; f = f->next) {
    if (!ASN1Enc_KERB_CERTIFICATE(enc, 0, &f->value))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REP2_kdc_cert(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_PK_AS_REP2_kdc_cert *val)
{
    PKERB_PA_PK_AS_REP2_kdc_cert *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000003, &dd0, &di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
    return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
    if (!ASN1BERDecPeekTag(dd, &t))
        return 0;
    if (!(*f = (PKERB_PA_PK_AS_REP2_kdc_cert)ASN1DecAlloc(dd, sizeof(**f))))
        return 0;
    if (!ASN1Dec_KERB_CERTIFICATE(dd, 0, &(*f)->value))
        return 0;
    f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REP2_kdc_cert(PKERB_PA_PK_AS_REP2_kdc_cert *val)
{
    PKERB_PA_PK_AS_REP2_kdc_cert f, ff;
    if (val) {
    for (f = *val; f; f = ff) {
        ASN1Free_KERB_CERTIFICATE(&f->value);
        ff = f->next;
        ASN1Free(f);
    }
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x8000000c, &nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
    return 0;
    for (f = *val; f; f = f->next) {
    if (!ASN1Enc_KERB_PA_DATA(enc, 0, &f->value))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data *val)
{
    PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x8000000c, &dd0, &di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
    return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
    if (!ASN1BERDecPeekTag(dd, &t))
        return 0;
    if (!(*f = (PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data)ASN1DecAlloc(dd, sizeof(**f))))
        return 0;
    if (!ASN1Dec_KERB_PA_DATA(dd, 0, &(*f)->value))
        return 0;
    f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data(PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data *val)
{
    PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data f, ff;
    if (val) {
    for (f = *val; f; f = ff) {
        ASN1Free_KERB_PA_DATA(&f->value);
        ff = f->next;
        ASN1Free(f);
    }
    }
}

static int ASN1CALL ASN1Enc_KERB_KDC_REPLY_preauth_data(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_KDC_REPLY_preauth_data *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_KDC_REPLY_preauth_data f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000002, &nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
    return 0;
    for (f = *val; f; f = f->next) {
    if (!ASN1Enc_KERB_PA_DATA(enc, 0, &f->value))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KDC_REPLY_preauth_data(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_KDC_REPLY_preauth_data *val)
{
    PKERB_KDC_REPLY_preauth_data *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000002, &dd0, &di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
    return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
    if (!ASN1BERDecPeekTag(dd, &t))
        return 0;
    if (!(*f = (PKERB_KDC_REPLY_preauth_data)ASN1DecAlloc(dd, sizeof(**f))))
        return 0;
    if (!ASN1Dec_KERB_PA_DATA(dd, 0, &(*f)->value))
        return 0;
    f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KDC_REPLY_preauth_data(PKERB_KDC_REPLY_preauth_data *val)
{
    PKERB_KDC_REPLY_preauth_data f, ff;
    if (val) {
    for (f = *val; f; f = ff) {
        ASN1Free_KERB_PA_DATA(&f->value);
        ff = f->next;
        ASN1Free(f);
    }
    }
}

static int ASN1CALL ASN1Enc_KERB_KDC_REQUEST_preauth_data(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_KDC_REQUEST_preauth_data *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_KDC_REQUEST_preauth_data f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000003, &nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
    return 0;
    for (f = *val; f; f = f->next) {
    if (!ASN1Enc_KERB_PA_DATA(enc, 0, &f->value))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KDC_REQUEST_preauth_data(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_KDC_REQUEST_preauth_data *val)
{
    PKERB_KDC_REQUEST_preauth_data *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000003, &dd0, &di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
    return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
    if (!ASN1BERDecPeekTag(dd, &t))
        return 0;
    if (!(*f = (PKERB_KDC_REQUEST_preauth_data)ASN1DecAlloc(dd, sizeof(**f))))
        return 0;
    if (!ASN1Dec_KERB_PA_DATA(dd, 0, &(*f)->value))
        return 0;
    f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KDC_REQUEST_preauth_data(PKERB_KDC_REQUEST_preauth_data *val)
{
    PKERB_KDC_REQUEST_preauth_data f, ff;
    if (val) {
    for (f = *val; f; f = ff) {
        ASN1Free_KERB_PA_DATA(&f->value);
        ff = f->next;
        ASN1Free(f);
    }
    }
}

static int ASN1CALL ASN1Enc_KERB_TICKET(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TICKET *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x40000001, &nExplTagLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->ticket_version))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    t = lstrlenA((val)->realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->realm))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->server_name))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_ENCRYPTED_DATA(enc, 0, &(val)->encrypted_part))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
        return 0;
    if (!ASN1Enc_PKERB_TICKET_EXTENSIONS(enc, 0, &(val)->ticket_extensions))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_TICKET(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TICKET *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x40000001, &pExplTagDec0, &pbExplTagDataEnd0))
    return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
    return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->ticket_version))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->realm))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->server_name))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_ENCRYPTED_DATA(dd0, 0, &(val)->encrypted_part))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000004) {
    (val)->o[0] |= 0x80;
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
        return 0;
    if (!ASN1Dec_PKERB_TICKET_EXTENSIONS(dd0, 0, &(val)->ticket_extensions))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_TICKET(KERB_TICKET *val)
{
    if (val) {
    ASN1ztcharstring_free((val)->realm);
    ASN1Free_KERB_PRINCIPAL_NAME(&(val)->server_name);
    ASN1Free_KERB_ENCRYPTED_DATA(&(val)->encrypted_part);
    if ((val)->o[0] & 0x80) {
        ASN1Free_PKERB_TICKET_EXTENSIONS(&(val)->ticket_extensions);
    }
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_TICKET(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_TICKET *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x40000003, &nExplTagLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->flags).length, ((val)->flags).value))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_ENCRYPTION_KEY(enc, 0, &(val)->key))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    t = lstrlenA((val)->client_realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
    return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->client_realm))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->client_name))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_TRANSITED_ENCODING(enc, 0, &(val)->transited))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000005, &nLenOff0))
    return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->authtime))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000006, &nLenOff0))
        return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->starttime))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000007, &nLenOff0))
    return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->endtime))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if ((val)->o[0] & 0x40) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000008, &nLenOff0))
        return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->renew_until))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000009, &nLenOff0))
        return 0;
    if (!ASN1Enc_PKERB_HOST_ADDRESSES(enc, 0, &(val)->client_addresses))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if ((val)->o[0] & 0x10) {
    if (!ASN1BEREncExplicitTag(enc, 0x8000000a, &nLenOff0))
        return 0;
    if (!ASN1Enc_PKERB_AUTHORIZATION_DATA(enc, 0, &(val)->authorization_data))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_TICKET(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_TICKET *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x40000003, &pExplTagDec0, &pbExplTagDataEnd0))
    return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
    return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1BERDecBitString(dd0, 0x3, &(val)->flags))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_ENCRYPTION_KEY(dd0, 0, &(val)->key))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
    return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->client_realm))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->client_name))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_TRANSITED_ENCODING(dd0, 0, &(val)->transited))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000005, &dd0, &di0))
    return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->authtime))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000006) {
    (val)->o[0] |= 0x80;
    if (!ASN1BERDecExplicitTag(dd, 0x80000006, &dd0, &di0))
        return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->starttime))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000007, &dd0, &di0))
    return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->endtime))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000008) {
    (val)->o[0] |= 0x40;
    if (!ASN1BERDecExplicitTag(dd, 0x80000008, &dd0, &di0))
        return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->renew_until))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000009) {
    (val)->o[0] |= 0x20;
    if (!ASN1BERDecExplicitTag(dd, 0x80000009, &dd0, &di0))
        return 0;
    if (!ASN1Dec_PKERB_HOST_ADDRESSES(dd0, 0, &(val)->client_addresses))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x8000000a) {
    (val)->o[0] |= 0x10;
    if (!ASN1BERDecExplicitTag(dd, 0x8000000a, &dd0, &di0))
        return 0;
    if (!ASN1Dec_PKERB_AUTHORIZATION_DATA(dd0, 0, &(val)->authorization_data))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_TICKET(KERB_ENCRYPTED_TICKET *val)
{
    if (val) {
    ASN1bitstring_free(&(val)->flags);
    ASN1Free_KERB_ENCRYPTION_KEY(&(val)->key);
    ASN1ztcharstring_free((val)->client_realm);
    ASN1Free_KERB_PRINCIPAL_NAME(&(val)->client_name);
    ASN1Free_KERB_TRANSITED_ENCODING(&(val)->transited);
    if ((val)->o[0] & 0x80) {
    }
    if ((val)->o[0] & 0x40) {
    }
    if ((val)->o[0] & 0x20) {
        ASN1Free_PKERB_HOST_ADDRESSES(&(val)->client_addresses);
    }
    if ((val)->o[0] & 0x10) {
        ASN1Free_PKERB_AUTHORIZATION_DATA(&(val)->authorization_data);
    }
    }
}

static int ASN1CALL ASN1Enc_KERB_AUTHENTICATOR(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AUTHENTICATOR *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x40000002, &nExplTagLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->authenticator_version))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    t = lstrlenA((val)->client_realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->client_realm))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->client_name))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
        return 0;
    if (!ASN1Enc_KERB_CHECKSUM(enc, 0, &(val)->checksum))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->client_usec))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000005, &nLenOff0))
    return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->client_time))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if ((val)->o[0] & 0x40) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000006, &nLenOff0))
        return 0;
    if (!ASN1Enc_KERB_ENCRYPTION_KEY(enc, 0, &(val)->subkey))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000007, &nLenOff0))
        return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->sequence_number))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if ((val)->o[0] & 0x10) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000008, &nLenOff0))
        return 0;
    if (!ASN1Enc_PKERB_AUTHORIZATION_DATA(enc, 0, &(val)->authorization_data))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_AUTHENTICATOR(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AUTHENTICATOR *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x40000002, &pExplTagDec0, &pbExplTagDataEnd0))
    return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
    return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->authenticator_version))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->client_realm))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->client_name))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
    (val)->o[0] |= 0x80;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
        return 0;
    if (!ASN1Dec_KERB_CHECKSUM(dd0, 0, &(val)->checksum))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->client_usec))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000005, &dd0, &di0))
    return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->client_time))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000006) {
    (val)->o[0] |= 0x40;
    if (!ASN1BERDecExplicitTag(dd, 0x80000006, &dd0, &di0))
        return 0;
    if (!ASN1Dec_KERB_ENCRYPTION_KEY(dd0, 0, &(val)->subkey))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000007) {
    (val)->o[0] |= 0x20;
    if (!ASN1BERDecExplicitTag(dd, 0x80000007, &dd0, &di0))
        return 0;
    if (!ASN1BERDecSXVal(dd0, 0x2, &(val)->sequence_number))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000008) {
    (val)->o[0] |= 0x10;
    if (!ASN1BERDecExplicitTag(dd, 0x80000008, &dd0, &di0))
        return 0;
    if (!ASN1Dec_PKERB_AUTHORIZATION_DATA(dd0, 0, &(val)->authorization_data))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_AUTHENTICATOR(KERB_AUTHENTICATOR *val)
{
    if (val) {
    ASN1ztcharstring_free((val)->client_realm);
    ASN1Free_KERB_PRINCIPAL_NAME(&(val)->client_name);
    if ((val)->o[0] & 0x80) {
        ASN1Free_KERB_CHECKSUM(&(val)->checksum);
    }
    if ((val)->o[0] & 0x40) {
        ASN1Free_KERB_ENCRYPTION_KEY(&(val)->subkey);
    }
    if ((val)->o[0] & 0x20) {
        ASN1intx_free(&(val)->sequence_number);
    }
    if ((val)->o[0] & 0x10) {
        ASN1Free_PKERB_AUTHORIZATION_DATA(&(val)->authorization_data);
    }
    }
}

static int ASN1CALL ASN1Enc_KERB_KDC_REQUEST_BODY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KDC_REQUEST_BODY *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->kdc_options).length, ((val)->kdc_options).value))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
        return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->client_name))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    t = lstrlenA((val)->realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
    return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->realm))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if ((val)->o[0] & 0x40) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
        return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->server_name))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
        return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->starttime))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000005, &nLenOff0))
    return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->endtime))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if ((val)->o[0] & 0x10) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000006, &nLenOff0))
        return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->renew_until))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000007, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->nonce))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_KDC_REQUEST_BODY_encryption_type(enc, 0, &(val)->encryption_type))
    return 0;
    if ((val)->o[0] & 0x8) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000009, &nLenOff0))
        return 0;
    if (!ASN1Enc_PKERB_HOST_ADDRESSES(enc, 0, &(val)->addresses))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if ((val)->o[0] & 0x4) {
    if (!ASN1BEREncExplicitTag(enc, 0x8000000a, &nLenOff0))
        return 0;
    if (!ASN1Enc_KERB_ENCRYPTED_DATA(enc, 0, &(val)->enc_authorization_data))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if ((val)->o[0] & 0x2) {
    if (!ASN1Enc_KERB_KDC_REQUEST_BODY_additional_tickets(enc, 0, &(val)->additional_tickets))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KDC_REQUEST_BODY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KDC_REQUEST_BODY *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1BERDecBitString(dd0, 0x3, &(val)->kdc_options))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
    (val)->o[0] |= 0x80;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
        return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->client_name))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
    return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->realm))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
    (val)->o[0] |= 0x40;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
        return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->server_name))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000004) {
    (val)->o[0] |= 0x20;
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
        return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->starttime))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000005, &dd0, &di0))
    return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->endtime))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000006) {
    (val)->o[0] |= 0x10;
    if (!ASN1BERDecExplicitTag(dd, 0x80000006, &dd0, &di0))
        return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->renew_until))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000007, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->nonce))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1Dec_KERB_KDC_REQUEST_BODY_encryption_type(dd, 0, &(val)->encryption_type))
    return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000009) {
    (val)->o[0] |= 0x8;
    if (!ASN1BERDecExplicitTag(dd, 0x80000009, &dd0, &di0))
        return 0;
    if (!ASN1Dec_PKERB_HOST_ADDRESSES(dd0, 0, &(val)->addresses))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x8000000a) {
    (val)->o[0] |= 0x4;
    if (!ASN1BERDecExplicitTag(dd, 0x8000000a, &dd0, &di0))
        return 0;
    if (!ASN1Dec_KERB_ENCRYPTED_DATA(dd0, 0, &(val)->enc_authorization_data))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x8000000b) {
    (val)->o[0] |= 0x2;
    if (!ASN1Dec_KERB_KDC_REQUEST_BODY_additional_tickets(dd, 0, &(val)->additional_tickets))
        return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KDC_REQUEST_BODY(KERB_KDC_REQUEST_BODY *val)
{
    if (val) {
    ASN1bitstring_free(&(val)->kdc_options);
    if ((val)->o[0] & 0x80) {
        ASN1Free_KERB_PRINCIPAL_NAME(&(val)->client_name);
    }
    ASN1ztcharstring_free((val)->realm);
    if ((val)->o[0] & 0x40) {
        ASN1Free_KERB_PRINCIPAL_NAME(&(val)->server_name);
    }
    if ((val)->o[0] & 0x20) {
    }
    if ((val)->o[0] & 0x10) {
    }
    ASN1Free_KERB_KDC_REQUEST_BODY_encryption_type(&(val)->encryption_type);
    if ((val)->o[0] & 0x8) {
        ASN1Free_PKERB_HOST_ADDRESSES(&(val)->addresses);
    }
    if ((val)->o[0] & 0x4) {
        ASN1Free_KERB_ENCRYPTED_DATA(&(val)->enc_authorization_data);
    }
    if ((val)->o[0] & 0x2) {
        ASN1Free_KERB_KDC_REQUEST_BODY_additional_tickets(&(val)->additional_tickets);
    }
    }
}

static int ASN1CALL ASN1Enc_KERB_KDC_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KDC_REPLY *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->message_type))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_KERB_KDC_REPLY_preauth_data(enc, 0, &(val)->preauth_data))
        return 0;
    }
    t = lstrlenA((val)->client_realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
    return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->client_realm))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->client_name))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000005, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_TICKET(enc, 0, &(val)->ticket))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000006, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_ENCRYPTED_DATA(enc, 0, &(val)->encrypted_part))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KDC_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KDC_REPLY *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->message_type))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
    (val)->o[0] |= 0x80;
    if (!ASN1Dec_KERB_KDC_REPLY_preauth_data(dd, 0, &(val)->preauth_data))
        return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
    return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->client_realm))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->client_name))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000005, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_TICKET(dd0, 0, &(val)->ticket))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000006, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_ENCRYPTED_DATA(dd0, 0, &(val)->encrypted_part))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KDC_REPLY(KERB_KDC_REPLY *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1Free_KERB_KDC_REPLY_preauth_data(&(val)->preauth_data);
    }
    ASN1ztcharstring_free((val)->client_realm);
    ASN1Free_KERB_PRINCIPAL_NAME(&(val)->client_name);
    ASN1Free_KERB_TICKET(&(val)->ticket);
    ASN1Free_KERB_ENCRYPTED_DATA(&(val)->encrypted_part);
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_KDC_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_KDC_REPLY *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_ENCRYPTION_KEY(enc, 0, &(val)->session_key))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1Enc_PKERB_LAST_REQUEST(enc, 0, &(val)->last_request))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->nonce))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
        return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->key_expiration))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
    return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->flags).length, ((val)->flags).value))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000005, &nLenOff0))
    return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->authtime))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if ((val)->o[0] & 0x40) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000006, &nLenOff0))
        return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->starttime))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000007, &nLenOff0))
    return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->endtime))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if ((val)->o[0] & 0x20) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000008, &nLenOff0))
        return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->renew_until))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    t = lstrlenA((val)->server_realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000009, &nLenOff0))
    return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->server_realm))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x8000000a, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->server_name))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if ((val)->o[0] & 0x10) {
    if (!ASN1BEREncExplicitTag(enc, 0x8000000b, &nLenOff0))
        return 0;
    if (!ASN1Enc_PKERB_HOST_ADDRESSES(enc, 0, &(val)->client_addresses))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if ((val)->o[0] & 0x8) {
    if (!ASN1Enc_KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data(enc, 0, &(val)->encrypted_pa_data))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_KDC_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_KDC_REPLY *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_ENCRYPTION_KEY(dd0, 0, &(val)->session_key))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1Dec_PKERB_LAST_REQUEST(dd0, 0, &(val)->last_request))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->nonce))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
    (val)->o[0] |= 0x80;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
        return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->key_expiration))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
    return 0;
    if (!ASN1BERDecBitString(dd0, 0x3, &(val)->flags))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000005, &dd0, &di0))
    return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->authtime))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000006) {
    (val)->o[0] |= 0x40;
    if (!ASN1BERDecExplicitTag(dd, 0x80000006, &dd0, &di0))
        return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->starttime))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000007, &dd0, &di0))
    return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->endtime))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000008) {
    (val)->o[0] |= 0x20;
    if (!ASN1BERDecExplicitTag(dd, 0x80000008, &dd0, &di0))
        return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->renew_until))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000009, &dd0, &di0))
    return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->server_realm))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x8000000a, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->server_name))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x8000000b) {
    (val)->o[0] |= 0x10;
    if (!ASN1BERDecExplicitTag(dd, 0x8000000b, &dd0, &di0))
        return 0;
    if (!ASN1Dec_PKERB_HOST_ADDRESSES(dd0, 0, &(val)->client_addresses))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x8000000c) {
    (val)->o[0] |= 0x8;
    if (!ASN1Dec_KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data(dd, 0, &(val)->encrypted_pa_data))
        return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_KDC_REPLY(KERB_ENCRYPTED_KDC_REPLY *val)
{
    if (val) {
    ASN1Free_KERB_ENCRYPTION_KEY(&(val)->session_key);
    ASN1Free_PKERB_LAST_REQUEST(&(val)->last_request);
    if ((val)->o[0] & 0x80) {
    }
    ASN1bitstring_free(&(val)->flags);
    if ((val)->o[0] & 0x40) {
    }
    if ((val)->o[0] & 0x20) {
    }
    ASN1ztcharstring_free((val)->server_realm);
    ASN1Free_KERB_PRINCIPAL_NAME(&(val)->server_name);
    if ((val)->o[0] & 0x10) {
        ASN1Free_PKERB_HOST_ADDRESSES(&(val)->client_addresses);
    }
    if ((val)->o[0] & 0x8) {
        ASN1Free_KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data(&(val)->encrypted_pa_data);
    }
    }
}

static int ASN1CALL ASN1Enc_KERB_AP_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AP_REQUEST *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000000e, &nExplTagLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->message_type))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
    return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->ap_options).length, ((val)->ap_options).value))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_TICKET(enc, 0, &(val)->ticket))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_ENCRYPTED_DATA(enc, 0, &(val)->authenticator))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_AP_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AP_REQUEST *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000000e, &pExplTagDec0, &pbExplTagDataEnd0))
    return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->message_type))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
    return 0;
    if (!ASN1BERDecBitString(dd0, 0x3, &(val)->ap_options))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_TICKET(dd0, 0, &(val)->ticket))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_ENCRYPTED_DATA(dd0, 0, &(val)->authenticator))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_AP_REQUEST(KERB_AP_REQUEST *val)
{
    if (val) {
    ASN1bitstring_free(&(val)->ap_options);
    ASN1Free_KERB_TICKET(&(val)->ticket);
    ASN1Free_KERB_ENCRYPTED_DATA(&(val)->authenticator);
    }
}

static int ASN1CALL ASN1Enc_KERB_AP_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AP_REPLY *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000000f, &nExplTagLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->message_type))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_ENCRYPTED_DATA(enc, 0, &(val)->encrypted_part))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_AP_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AP_REPLY *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000000f, &pExplTagDec0, &pbExplTagDataEnd0))
    return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->message_type))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_ENCRYPTED_DATA(dd0, 0, &(val)->encrypted_part))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_AP_REPLY(KERB_AP_REPLY *val)
{
    if (val) {
    ASN1Free_KERB_ENCRYPTED_DATA(&(val)->encrypted_part);
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_AP_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_AP_REPLY *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000001b, &nExplTagLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->client_time))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->client_usec))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
        return 0;
    if (!ASN1Enc_KERB_ENCRYPTION_KEY(enc, 0, &(val)->subkey))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
        return 0;
    if (!ASN1BEREncU32(enc, 0x2, (val)->sequence_number))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_AP_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_AP_REPLY *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000001b, &pExplTagDec0, &pbExplTagDataEnd0))
    return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
    return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->client_time))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->client_usec))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
    (val)->o[0] |= 0x80;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
        return 0;
    if (!ASN1Dec_KERB_ENCRYPTION_KEY(dd0, 0, &(val)->subkey))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
    (val)->o[0] |= 0x40;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
        return 0;
    if (!ASN1BERDecU32Val(dd0, 0x2, (ASN1uint32_t *) &(val)->sequence_number))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_AP_REPLY(KERB_ENCRYPTED_AP_REPLY *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1Free_KERB_ENCRYPTION_KEY(&(val)->subkey);
    }
    }
}

static int ASN1CALL ASN1Enc_KERB_SAFE_MESSAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SAFE_MESSAGE *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x40000014, &nExplTagLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->message_type))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_SAFE_BODY(enc, 0, &(val)->safe_body))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_CHECKSUM(enc, 0, &(val)->checksum))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_SAFE_MESSAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SAFE_MESSAGE *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x40000014, &pExplTagDec0, &pbExplTagDataEnd0))
    return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->message_type))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_SAFE_BODY(dd0, 0, &(val)->safe_body))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_CHECKSUM(dd0, 0, &(val)->checksum))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_SAFE_MESSAGE(KERB_SAFE_MESSAGE *val)
{
    if (val) {
    ASN1Free_KERB_SAFE_BODY(&(val)->safe_body);
    ASN1Free_KERB_CHECKSUM(&(val)->checksum);
    }
}

static int ASN1CALL ASN1Enc_KERB_PRIV_MESSAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PRIV_MESSAGE *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x40000015, &nExplTagLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->message_type))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_ENCRYPTED_DATA(enc, 0, &(val)->encrypted_part))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PRIV_MESSAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PRIV_MESSAGE *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x40000015, &pExplTagDec0, &pbExplTagDataEnd0))
    return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->message_type))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_ENCRYPTED_DATA(dd0, 0, &(val)->encrypted_part))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PRIV_MESSAGE(KERB_PRIV_MESSAGE *val)
{
    if (val) {
    ASN1Free_KERB_ENCRYPTED_DATA(&(val)->encrypted_part);
    }
}

static int ASN1CALL ASN1Enc_KERB_CRED(ASN1encoding_t enc, ASN1uint32_t tag, KERB_CRED *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x40000016, &nExplTagLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->message_type))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_CRED_tickets(enc, 0, &(val)->tickets))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_ENCRYPTED_DATA(enc, 0, &(val)->encrypted_part))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_CRED(ASN1decoding_t dec, ASN1uint32_t tag, KERB_CRED *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x40000016, &pExplTagDec0, &pbExplTagDataEnd0))
    return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->message_type))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1Dec_KERB_CRED_tickets(dd, 0, &(val)->tickets))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_ENCRYPTED_DATA(dd0, 0, &(val)->encrypted_part))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_CRED(KERB_CRED *val)
{
    if (val) {
    ASN1Free_KERB_CRED_tickets(&(val)->tickets);
    ASN1Free_KERB_ENCRYPTED_DATA(&(val)->encrypted_part);
    }
}

static int ASN1CALL ASN1Enc_KERB_CRED_INFO(ASN1encoding_t enc, ASN1uint32_t tag, KERB_CRED_INFO *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_ENCRYPTION_KEY(enc, 0, &(val)->key))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if ((val)->o[0] & 0x80) {
    t = lstrlenA((val)->principal_realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
        return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->principal_realm))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
        return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->principal_name))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
        return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->flags).length, ((val)->flags).value))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if ((val)->o[0] & 0x10) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
        return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->authtime))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if ((val)->o[0] & 0x8) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000005, &nLenOff0))
        return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->starttime))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if ((val)->o[0] & 0x4) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000006, &nLenOff0))
        return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->endtime))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if ((val)->o[0] & 0x2) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000007, &nLenOff0))
        return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->renew_until))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if ((val)->o[0] & 0x1) {
    t = lstrlenA((val)->service_realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000008, &nLenOff0))
        return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->service_realm))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if ((val)->o[1] & 0x80) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000009, &nLenOff0))
        return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->service_name))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if ((val)->o[1] & 0x40) {
    if (!ASN1BEREncExplicitTag(enc, 0x8000000a, &nLenOff0))
        return 0;
    if (!ASN1Enc_PKERB_HOST_ADDRESSES(enc, 0, &(val)->client_addresses))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_CRED_INFO(ASN1decoding_t dec, ASN1uint32_t tag, KERB_CRED_INFO *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    ZeroMemory((val)->o, 2);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_ENCRYPTION_KEY(dd0, 0, &(val)->key))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
    (val)->o[0] |= 0x80;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
        return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->principal_realm))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
    (val)->o[0] |= 0x40;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
        return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->principal_name))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
    (val)->o[0] |= 0x20;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
        return 0;
    if (!ASN1BERDecBitString(dd0, 0x3, &(val)->flags))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000004) {
    (val)->o[0] |= 0x10;
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
        return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->authtime))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000005) {
    (val)->o[0] |= 0x8;
    if (!ASN1BERDecExplicitTag(dd, 0x80000005, &dd0, &di0))
        return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->starttime))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000006) {
    (val)->o[0] |= 0x4;
    if (!ASN1BERDecExplicitTag(dd, 0x80000006, &dd0, &di0))
        return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->endtime))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000007) {
    (val)->o[0] |= 0x2;
    if (!ASN1BERDecExplicitTag(dd, 0x80000007, &dd0, &di0))
        return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->renew_until))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000008) {
    (val)->o[0] |= 0x1;
    if (!ASN1BERDecExplicitTag(dd, 0x80000008, &dd0, &di0))
        return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->service_realm))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000009) {
    (val)->o[1] |= 0x80;
    if (!ASN1BERDecExplicitTag(dd, 0x80000009, &dd0, &di0))
        return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->service_name))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x8000000a) {
    (val)->o[1] |= 0x40;
    if (!ASN1BERDecExplicitTag(dd, 0x8000000a, &dd0, &di0))
        return 0;
    if (!ASN1Dec_PKERB_HOST_ADDRESSES(dd0, 0, &(val)->client_addresses))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_CRED_INFO(KERB_CRED_INFO *val)
{
    if (val) {
    ASN1Free_KERB_ENCRYPTION_KEY(&(val)->key);
    if ((val)->o[0] & 0x80) {
        ASN1ztcharstring_free((val)->principal_realm);
    }
    if ((val)->o[0] & 0x40) {
        ASN1Free_KERB_PRINCIPAL_NAME(&(val)->principal_name);
    }
    if ((val)->o[0] & 0x20) {
        ASN1bitstring_free(&(val)->flags);
    }
    if ((val)->o[0] & 0x10) {
    }
    if ((val)->o[0] & 0x8) {
    }
    if ((val)->o[0] & 0x4) {
    }
    if ((val)->o[0] & 0x2) {
    }
    if ((val)->o[0] & 0x1) {
        ASN1ztcharstring_free((val)->service_realm);
    }
    if ((val)->o[1] & 0x80) {
        ASN1Free_KERB_PRINCIPAL_NAME(&(val)->service_name);
    }
    if ((val)->o[1] & 0x40) {
        ASN1Free_PKERB_HOST_ADDRESSES(&(val)->client_addresses);
    }
    }
}

static int ASN1CALL ASN1Enc_KERB_TGT_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TGT_REPLY *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->message_type))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_TICKET(enc, 0, &(val)->ticket))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_TGT_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TGT_REPLY *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->message_type))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_TICKET(dd0, 0, &(val)->ticket))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_TGT_REPLY(KERB_TGT_REPLY *val)
{
    if (val) {
    ASN1Free_KERB_TICKET(&(val)->ticket);
    }
}

static int ASN1CALL ASN1Enc_KERB_SIGNED_REPLY_KEY_PACKAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SIGNED_REPLY_KEY_PACKAGE *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_REPLY_KEY_PACKAGE2(enc, 0, &(val)->reply_key_package))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_SIGNATURE(enc, 0, &(val)->reply_key_signature))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_SIGNED_REPLY_KEY_PACKAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SIGNED_REPLY_KEY_PACKAGE *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_REPLY_KEY_PACKAGE2(dd0, 0, &(val)->reply_key_package))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_SIGNATURE(dd0, 0, &(val)->reply_key_signature))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_SIGNED_REPLY_KEY_PACKAGE(KERB_SIGNED_REPLY_KEY_PACKAGE *val)
{
    if (val) {
    ASN1Free_KERB_REPLY_KEY_PACKAGE2(&(val)->reply_key_package);
    ASN1Free_KERB_SIGNATURE(&(val)->reply_key_signature);
    }
}

static int ASN1CALL ASN1Enc_KERB_SIGNED_KDC_PUBLIC_VALUE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SIGNED_KDC_PUBLIC_VALUE *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_SUBJECT_PUBLIC_KEY_INFO(enc, 0, &(val)->kdc_public_value))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_SIGNATURE(enc, 0, &(val)->kdc_public_value_sig))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_SIGNED_KDC_PUBLIC_VALUE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SIGNED_KDC_PUBLIC_VALUE *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_SUBJECT_PUBLIC_KEY_INFO(dd0, 0, &(val)->kdc_public_value))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_SIGNATURE(dd0, 0, &(val)->kdc_public_value_sig))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_SIGNED_KDC_PUBLIC_VALUE(KERB_SIGNED_KDC_PUBLIC_VALUE *val)
{
    if (val) {
    ASN1Free_KERB_SUBJECT_PUBLIC_KEY_INFO(&(val)->kdc_public_value);
    ASN1Free_KERB_SIGNATURE(&(val)->kdc_public_value_sig);
    }
}

static int ASN1CALL ASN1Enc_KERB_TRUSTED_CAS(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TRUSTED_CAS *val)
{
    ASN1uint32_t nLenOff0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
        return 0;
    if (!ASN1Enc_KERB_KERBEROS_NAME(enc, 0, &(val)->u.principal_name))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    break;
    case 2:
    if (!ASN1DEREncOctetString(enc, 0x80000001, ((val)->u.ca_name).length, ((val)->u.ca_name).value))
        return 0;
    break;
    case 3:
    if (!ASN1DEREncOctetString(enc, 0x80000002, ((val)->u.issuer_and_serial).length, ((val)->u.issuer_and_serial).value))
        return 0;
    break;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_TRUSTED_CAS(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TRUSTED_CAS *val)
{
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecPeekTag(dec, &t))
    return 0;
    switch (t) {
    case 0x80000000:
    (val)->choice = 1;
    if (!ASN1BERDecExplicitTag(dec, 0x80000000, &dd0, &di0))
        return 0;
    if (!ASN1Dec_KERB_KERBEROS_NAME(dd0, 0, &(val)->u.principal_name))
        return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
        return 0;
    break;
    case 0x80000001:
    (val)->choice = 2;
    if (!ASN1BERDecOctetString(dec, 0x80000001, &(val)->u.ca_name))
        return 0;
    break;
    case 0x80000002:
    (val)->choice = 3;
    if (!ASN1BERDecOctetString(dec, 0x80000002, &(val)->u.issuer_and_serial))
        return 0;
    break;
    default:
    ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_KERB_TRUSTED_CAS(KERB_TRUSTED_CAS *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_KERB_KERBEROS_NAME(&(val)->u.principal_name);
        break;
    case 2:
        ASN1octetstring_free(&(val)->u.ca_name);
        break;
    case 3:
        ASN1octetstring_free(&(val)->u.issuer_and_serial);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_KERB_AUTH_PACKAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AUTH_PACKAGE *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_PK_AUTHENTICATOR(enc, 0, &(val)->pk_authenticator))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
        return 0;
    if (!ASN1Enc_KERB_SUBJECT_PUBLIC_KEY_INFO(enc, 0, &(val)->client_public_value))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_AUTH_PACKAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AUTH_PACKAGE *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_PK_AUTHENTICATOR(dd0, 0, &(val)->pk_authenticator))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
    (val)->o[0] |= 0x80;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
        return 0;
    if (!ASN1Dec_KERB_SUBJECT_PUBLIC_KEY_INFO(dd0, 0, &(val)->client_public_value))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_AUTH_PACKAGE(KERB_AUTH_PACKAGE *val)
{
    if (val) {
    ASN1Free_KERB_PK_AUTHENTICATOR(&(val)->pk_authenticator);
    if ((val)->o[0] & 0x80) {
        ASN1Free_KERB_SUBJECT_PUBLIC_KEY_INFO(&(val)->client_public_value);
    }
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REQ_trusted_certifiers(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ_trusted_certifiers *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_PA_PK_AS_REQ_trusted_certifiers f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000002, &nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
    return 0;
    for (f = *val; f; f = f->next) {
    if (!ASN1Enc_KERB_TRUSTED_CAS(enc, 0, &f->value))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REQ_trusted_certifiers(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ_trusted_certifiers *val)
{
    PKERB_PA_PK_AS_REQ_trusted_certifiers *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000002, &dd0, &di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
    return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
    if (!ASN1BERDecPeekTag(dd, &t))
        return 0;
    if (!(*f = (PKERB_PA_PK_AS_REQ_trusted_certifiers)ASN1DecAlloc(dd, sizeof(**f))))
        return 0;
    if (!ASN1Dec_KERB_TRUSTED_CAS(dd, 0, &(*f)->value))
        return 0;
    f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REQ_trusted_certifiers(PKERB_PA_PK_AS_REQ_trusted_certifiers *val)
{
    PKERB_PA_PK_AS_REQ_trusted_certifiers f, ff;
    if (val) {
    for (f = *val; f; f = ff) {
        ASN1Free_KERB_TRUSTED_CAS(&f->value);
        ff = f->next;
        ASN1Free(f);
    }
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_CRED_ticket_info(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_ENCRYPTED_CRED_ticket_info *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_ENCRYPTED_CRED_ticket_info f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
    return 0;
    for (f = *val; f; f = f->next) {
    if (!ASN1Enc_KERB_CRED_INFO(enc, 0, &f->value))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_CRED_ticket_info(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_ENCRYPTED_CRED_ticket_info *val)
{
    PKERB_ENCRYPTED_CRED_ticket_info *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
    return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
    if (!ASN1BERDecPeekTag(dd, &t))
        return 0;
    if (!(*f = (PKERB_ENCRYPTED_CRED_ticket_info)ASN1DecAlloc(dd, sizeof(**f))))
        return 0;
    if (!ASN1Dec_KERB_CRED_INFO(dd, 0, &(*f)->value))
        return 0;
    f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_CRED_ticket_info(PKERB_ENCRYPTED_CRED_ticket_info *val)
{
    PKERB_ENCRYPTED_CRED_ticket_info f, ff;
    if (val) {
    for (f = *val; f; f = ff) {
        ASN1Free_KERB_CRED_INFO(&f->value);
        ff = f->next;
        ASN1Free(f);
    }
    }
}

static int ASN1CALL ASN1Enc_KERB_CRED_tickets(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_CRED_tickets *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_CRED_tickets f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000002, &nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
    return 0;
    for (f = *val; f; f = f->next) {
    if (!ASN1Enc_KERB_TICKET(enc, 0, &f->value))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_CRED_tickets(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_CRED_tickets *val)
{
    PKERB_CRED_tickets *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000002, &dd0, &di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
    return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
    if (!ASN1BERDecPeekTag(dd, &t))
        return 0;
    if (!(*f = (PKERB_CRED_tickets)ASN1DecAlloc(dd, sizeof(**f))))
        return 0;
    if (!ASN1Dec_KERB_TICKET(dd, 0, &(*f)->value))
        return 0;
    f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_CRED_tickets(PKERB_CRED_tickets *val)
{
    PKERB_CRED_tickets f, ff;
    if (val) {
    for (f = *val; f; f = ff) {
        ASN1Free_KERB_TICKET(&f->value);
        ff = f->next;
        ASN1Free(f);
    }
    }
}

static int ASN1CALL ASN1Enc_KERB_KDC_REQUEST_BODY_additional_tickets(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_KDC_REQUEST_BODY_additional_tickets *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_KDC_REQUEST_BODY_additional_tickets f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x8000000b, &nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
    return 0;
    for (f = *val; f; f = f->next) {
    if (!ASN1Enc_KERB_TICKET(enc, 0, &f->value))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KDC_REQUEST_BODY_additional_tickets(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_KDC_REQUEST_BODY_additional_tickets *val)
{
    PKERB_KDC_REQUEST_BODY_additional_tickets *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x8000000b, &dd0, &di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
    return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
    if (!ASN1BERDecPeekTag(dd, &t))
        return 0;
    if (!(*f = (PKERB_KDC_REQUEST_BODY_additional_tickets)ASN1DecAlloc(dd, sizeof(**f))))
        return 0;
    if (!ASN1Dec_KERB_TICKET(dd, 0, &(*f)->value))
        return 0;
    f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KDC_REQUEST_BODY_additional_tickets(PKERB_KDC_REQUEST_BODY_additional_tickets *val)
{
    PKERB_KDC_REQUEST_BODY_additional_tickets f, ff;
    if (val) {
    for (f = *val; f; f = ff) {
        ASN1Free_KERB_TICKET(&f->value);
        ff = f->next;
        ASN1Free(f);
    }
    }
}

static int ASN1CALL ASN1Enc_KERB_KDC_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KDC_REQUEST *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
    return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->message_type))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_KERB_KDC_REQUEST_preauth_data(enc, 0, &(val)->preauth_data))
        return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_KDC_REQUEST_BODY(enc, 0, &(val)->request_body))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KDC_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KDC_REQUEST *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
    return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->message_type))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
    (val)->o[0] |= 0x80;
    if (!ASN1Dec_KERB_KDC_REQUEST_preauth_data(dd, 0, &(val)->preauth_data))
        return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_KDC_REQUEST_BODY(dd0, 0, &(val)->request_body))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KDC_REQUEST(KERB_KDC_REQUEST *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1Free_KERB_KDC_REQUEST_preauth_data(&(val)->preauth_data);
    }
    ASN1Free_KERB_KDC_REQUEST_BODY(&(val)->request_body);
    }
}

static int ASN1CALL ASN1Enc_KERB_MARSHALLED_REQUEST_BODY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_MARSHALLED_REQUEST_BODY *val)
{
    if (!ASN1Enc_KERB_KDC_REQUEST_BODY(enc, tag, val))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_MARSHALLED_REQUEST_BODY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_MARSHALLED_REQUEST_BODY *val)
{
    if (!ASN1Dec_KERB_KDC_REQUEST_BODY(dec, tag, val))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_MARSHALLED_REQUEST_BODY(KERB_MARSHALLED_REQUEST_BODY *val)
{
    if (val) {
    ASN1Free_KERB_KDC_REQUEST_BODY(val);
    }
}

static int ASN1CALL ASN1Enc_KERB_AS_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AS_REPLY *val)
{
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000000b, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_KDC_REPLY(enc, 0, val))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_AS_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AS_REPLY *val)
{
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000000b, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_KDC_REPLY(dd0, 0, val))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_AS_REPLY(KERB_AS_REPLY *val)
{
    if (val) {
    ASN1Free_KERB_KDC_REPLY(val);
    }
}

static int ASN1CALL ASN1Enc_KERB_TGS_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TGS_REPLY *val)
{
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000000d, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_KDC_REPLY(enc, 0, val))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_TGS_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TGS_REPLY *val)
{
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000000d, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_KDC_REPLY(dd0, 0, val))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_TGS_REPLY(KERB_TGS_REPLY *val)
{
    if (val) {
    ASN1Free_KERB_KDC_REPLY(val);
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_AS_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_AS_REPLY *val)
{
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x40000019, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_ENCRYPTED_KDC_REPLY(enc, 0, val))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_AS_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_AS_REPLY *val)
{
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x40000019, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_ENCRYPTED_KDC_REPLY(dd0, 0, val))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_AS_REPLY(KERB_ENCRYPTED_AS_REPLY *val)
{
    if (val) {
    ASN1Free_KERB_ENCRYPTED_KDC_REPLY(val);
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_TGS_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_TGS_REPLY *val)
{
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000001a, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_ENCRYPTED_KDC_REPLY(enc, 0, val))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_TGS_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_TGS_REPLY *val)
{
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000001a, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_ENCRYPTED_KDC_REPLY(dd0, 0, val))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_TGS_REPLY(KERB_ENCRYPTED_TGS_REPLY *val)
{
    if (val) {
    ASN1Free_KERB_ENCRYPTED_KDC_REPLY(val);
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REP2(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PK_AS_REP2 *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
        return 0;
    if (!ASN1Enc_KERB_ENCRYPTED_DATA(enc, 0, &(val)->key_package))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_ENVELOPED_KEY_PACKAGE(enc, 0, &(val)->temp_key_package))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if ((val)->o[0] & 0x40) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
        return 0;
    if (!ASN1Enc_KERB_SIGNED_KDC_PUBLIC_VALUE(enc, 0, &(val)->signed_kdc_public_value))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1Enc_KERB_PA_PK_AS_REP2_kdc_cert(enc, 0, &(val)->kdc_cert))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REP2(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PK_AS_REP2 *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
    (val)->o[0] |= 0x80;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
        return 0;
    if (!ASN1Dec_KERB_ENCRYPTED_DATA(dd0, 0, &(val)->key_package))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_ENVELOPED_KEY_PACKAGE(dd0, 0, &(val)->temp_key_package))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
    (val)->o[0] |= 0x40;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
        return 0;
    if (!ASN1Dec_KERB_SIGNED_KDC_PUBLIC_VALUE(dd0, 0, &(val)->signed_kdc_public_value))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
    (val)->o[0] |= 0x20;
    if (!ASN1Dec_KERB_PA_PK_AS_REP2_kdc_cert(dd, 0, &(val)->kdc_cert))
        return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REP2(KERB_PA_PK_AS_REP2 *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1Free_KERB_ENCRYPTED_DATA(&(val)->key_package);
    }
    ASN1Free_KERB_ENVELOPED_KEY_PACKAGE(&(val)->temp_key_package);
    if ((val)->o[0] & 0x40) {
        ASN1Free_KERB_SIGNED_KDC_PUBLIC_VALUE(&(val)->signed_kdc_public_value);
    }
    if ((val)->o[0] & 0x20) {
        ASN1Free_KERB_PA_PK_AS_REP2_kdc_cert(&(val)->kdc_cert);
    }
    }
}

static int ASN1CALL ASN1Enc_KERB_SIGNED_AUTH_PACKAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SIGNED_AUTH_PACKAGE *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_AUTH_PACKAGE(enc, 0, &(val)->auth_package))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_SIGNATURE(enc, 0, &(val)->auth_package_signature))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_SIGNED_AUTH_PACKAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SIGNED_AUTH_PACKAGE *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_AUTH_PACKAGE(dd0, 0, &(val)->auth_package))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_SIGNATURE(dd0, 0, &(val)->auth_package_signature))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_SIGNED_AUTH_PACKAGE(KERB_SIGNED_AUTH_PACKAGE *val)
{
    if (val) {
    ASN1Free_KERB_AUTH_PACKAGE(&(val)->auth_package);
    ASN1Free_KERB_SIGNATURE(&(val)->auth_package_signature);
    }
}

static int ASN1CALL ASN1Enc_KERB_AS_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AS_REQUEST *val)
{
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000000a, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_KDC_REQUEST(enc, 0, val))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_AS_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AS_REQUEST *val)
{
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000000a, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_KDC_REQUEST(dd0, 0, val))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_AS_REQUEST(KERB_AS_REQUEST *val)
{
    if (val) {
    ASN1Free_KERB_KDC_REQUEST(val);
    }
}

static int ASN1CALL ASN1Enc_KERB_TGS_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TGS_REQUEST *val)
{
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000000c, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_KDC_REQUEST(enc, 0, val))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_TGS_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TGS_REQUEST *val)
{
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000000c, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_KDC_REQUEST(dd0, 0, val))
    return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_TGS_REQUEST(KERB_TGS_REQUEST *val)
{
    if (val) {
    ASN1Free_KERB_KDC_REQUEST(val);
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REQ2(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PK_AS_REQ2 *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
    return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
    return 0;
    if (!ASN1Enc_KERB_SIGNED_AUTH_PACKAGE(enc, 0, &(val)->signed_auth_pack))
    return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_KERB_PA_PK_AS_REQ2_user_certs(enc, 0, &(val)->user_certs))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1Enc_KERB_PA_PK_AS_REQ2_trusted_certifiers(enc, 0, &(val)->trusted_certifiers))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
        return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->serial_number))
        return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
        return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REQ2(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PK_AS_REQ2 *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
    return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
    return 0;
    if (!ASN1Dec_KERB_SIGNED_AUTH_PACKAGE(dd0, 0, &(val)->signed_auth_pack))
    return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
    return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
    (val)->o[0] |= 0x80;
    if (!ASN1Dec_KERB_PA_PK_AS_REQ2_user_certs(dd, 0, &(val)->user_certs))
        return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
    (val)->o[0] |= 0x40;
    if (!ASN1Dec_KERB_PA_PK_AS_REQ2_trusted_certifiers(dd, 0, &(val)->trusted_certifiers))
        return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
    (val)->o[0] |= 0x20;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
        return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->serial_number))
        return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
        return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REQ2(KERB_PA_PK_AS_REQ2 *val)
{
    if (val) {
    ASN1Free_KERB_SIGNED_AUTH_PACKAGE(&(val)->signed_auth_pack);
    if ((val)->o[0] & 0x80) {
        ASN1Free_KERB_PA_PK_AS_REQ2_user_certs(&(val)->user_certs);
    }
    if ((val)->o[0] & 0x40) {
        ASN1Free_KERB_PA_PK_AS_REQ2_trusted_certifiers(&(val)->trusted_certifiers);
    }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\common2\debug.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       debug.h
//
//  Contents:   Debug definitions that shouldn't be necessary
//              in the retail build.
//
//  History:    28-Jun-93   WadeR   Created
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifndef __DEBUG_H__
#define __DEBUG_H__

#ifdef __cplusplus
extern "C"
{
#endif

#include <dsysdbg.h>

#ifdef __cplusplus
}
#endif

#define DEB_T_SOCK  0x00001000

#if DBG
#define DEBUG_SUPPORT
#endif

#ifdef DEBUG_SUPPORT

    #undef DEF_INFOLEVEL
    #define DEF_INFOLEVEL       (DEB_ERROR | DEB_WARN)

    DECLARE_DEBUG2(KSupp);

    #define KerbPrintKdcName(Level, Name) KerbPrintKdcNameEx(KSuppInfoLevel, (Level), (Name))
    #define DebugLog(_x_)                 KSuppDebugPrint _x_

#else

    #define DebugLog(_x_)
    #define KerbPrintKdcName(Level, Name)

#endif  // DBG

#define MAX_EXPR_LEN        50


////////////////////////////////////////////////////////////////////
//
//  Name:       RET_IF_ERROR
//
//  Synopsis:   Evaluates an expression, returns from the caller if error.
//
//  Arguments:  l    - Error level to print error message at.
//              e    - expression to evaluate
//
// NOTE: THIS MACRO WILL RETURN FROM THE CALLING FUNCTION ON ERROR!!!!
//
// This will execute the expression (e), and check the return code.  If the
// return code indicates a failure, it prints an error message and returns
// from the calling function.
//
#define RET_IF_ERROR(l,e)                                           \
    {   NTSTATUS X_hr_XX__=(e) ;                                              \
        if (!NT_SUCCESS(X_hr_XX__)) {                                           \
            DebugLog(( (l), (sizeof( #e ) > MAX_EXPR_LEN)?          \
                                "%s(%d):\n\t %.*s ... == 0x%X\n"    \
                            :                                       \
                                "%s(%d):\n\t %.*s == 0x%X\n"        \
                    , __FILE__, __LINE__, MAX_EXPR_LEN, #e, X_hr_XX__ ));  \
            return(X_hr_XX__);                                             \
        }                                                           \
    }


////////////////////////////////////////////////////////////////////
//
//  Name:       WARN_IF_ERROR
//
//  Synopsis:   Evaluates an expression, prints warning if error.
//
//  Arguments:  l    - Error level to print warning at.
//              e    - expression to evaluate
//
//  Notes:      This calls DebugLog(()) to print.  In retail, it just
//              evaluates the expression.
//
#if DBG
#define WARN_IF_ERROR(l,e)                                          \
    {   NTSTATUS X_hr_XX__=(e) ;                                    \
        if (!NT_SUCCESS(X_hr_XX__)) {                               \
            DebugLog(( (l), (sizeof( #e ) > MAX_EXPR_LEN)?          \
                                "%s(%d):\n\t %.*s ... == 0x%X\n"    \
                            :                                       \
                                "%s(%d):\n\t %.*s == 0x%X\n"        \
             , __FILE__, __LINE__, MAX_EXPR_LEN, #e, X_hr_XX__ ));  \
        }                                                           \
    }

#define D_KerbPrintKdcName(_x_) KerbPrintKdcName _x_
#define D_DebugLog(_x_)         DebugLog(_x_)

#else // not DBG

#define WARN_IF_ERROR(l,e)  (e)
#define D_KerbPrintKdcName(_x_)
#define D_DebugLog(_x_)
#endif


#endif // __DEBUG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\common2\passwd.c ===
//+-----------------------------------------------------------------------
//
// File:        passwd.c
//
// Contents:    Password hashing routine
//
//
// History:     12-20-91, RichardW, created
//
//------------------------------------------------------------------------

#ifndef WIN32_CHICAGO
#include "krbprgma.h"
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <kerbcomm.h>
#include <kerbcon.h>
#include <kerberr.h>
#else // WIN32_CHICAGO
#include <kerb.hxx>
#include <kerbp.h>
#endif // WIN32_CHICAGO
#include "wincrypt.h"

//
// Globals used for allowing the replacement of the StringToKey functions
//
HCRYPTPROV KerbGlobalStrToKeyProvider = 0;

//+-------------------------------------------------------------------------
//
//  Function:   CheckForOutsideStringToKey
//
//  Synopsis:   Call CryptoAPI to query to see if a CSP is registered
//              of the type PROV_REPLACE_OWF.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns: STATUS_SUCCESS if it succeeds, otherwise STATUS_UNSUCCESSFUL
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
CheckForOutsideStringToKey()
{
    HCRYPTPROV hProv = 0;

    KerbGlobalStrToKeyProvider = 0;

    //
    // Try to acquire a context to a CSP which is used for OWF replacement
    //
    if (!CryptAcquireContext(&hProv,
                             NULL,
                             NULL,
                             PROV_REPLACE_OWF,
                             CRYPT_VERIFYCONTEXT))
    {
        return;
    }

    KerbGlobalStrToKeyProvider = hProv;

    return;
}


//+-------------------------------------------------------------------------
//
//  Function:   UseOutsideStringToKey
//
//  Synopsis:   Calls the CSP to do an outside StringToKey function
//              using the hashing entry points of CryptoAPI.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
UseOutsideStringToKey(
    IN PUNICODE_STRING pPassword,
    IN ULONG cbKey,
    OUT PUCHAR pbKey
    )
{
    HCRYPTHASH hHash = 0;
    ULONG cb;
    NTSTATUS Status = STATUS_UNSUCCESSFUL;

    //
    // create the hash
    //
    if (!CryptCreateHash(KerbGlobalStrToKeyProvider,
                         CALG_HASH_REPLACE_OWF,
                         0,
                         0,
                         &hHash))
    {
        goto Cleanup;
    }

    //
    // hash the password
    //

    if (!CryptHashData(hHash,
                       (PUCHAR)pPassword->Buffer,
                       pPassword->Length,
                       0))
    {
        if (NTE_BAD_DATA == GetLastError())
        {
            Status = NTE_BAD_DATA;
        }
        goto Cleanup;
    }

    //
    // Get the HP_HASHVAL, this is the key
    //
    cb = cbKey;
    if (!CryptGetHashParam(hHash,
                           HP_HASHVAL,
                           pbKey,
                           &cb,
                           0))
    {
        if (NTE_BAD_LEN == GetLastError())
        {
            Status = NTE_BAD_DATA;
        }
        goto Cleanup;
    }

    Status = STATUS_SUCCESS;
Cleanup:
    if (0 != hHash)
    {
        CryptDestroyHash(hHash);
    }
    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbHashPasswordEx
//
//  Synopsis:   Hashes a password into a kerberos encryption key
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


KERBERR NTAPI
KerbHashPasswordEx(
    IN PUNICODE_STRING Password,
    IN PUNICODE_STRING PrincipalName,
    IN ULONG EncryptionType,
    OUT PKERB_ENCRYPTION_KEY Key
    )
{
    PCRYPTO_SYSTEM CryptoSystem;
    NTSTATUS Status;
    KERBERR KerbErr;
    UNICODE_STRING CombinedName;
    ULONG Temp = 0;
    BOOLEAN fUseDefaultStringToKey = TRUE;


    RtlInitUnicodeString(
        &CombinedName,
        NULL
        );

    Key->keyvalue.value = NULL;

    //
    // Locate the crypto system
    //

    Status = CDLocateCSystem(
                EncryptionType,
                &CryptoSystem
                );
    if (!NT_SUCCESS(Status))
    {
        return(KDC_ERR_ETYPE_NOTSUPP);
    }

    //
    // Check to see if the principal name must be appended to the password
    //

    if ((CryptoSystem->Attributes & CSYSTEM_USE_PRINCIPAL_NAME) != 0)
    {
        Temp = (ULONG) Password->Length + (ULONG) PrincipalName->Length;

        if (Temp > (USHORT) -1)
        {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }
        
        CombinedName.Length = (USHORT) Temp;
        CombinedName.MaximumLength = CombinedName.Length;
        CombinedName.Buffer = (LPWSTR) MIDL_user_allocate(CombinedName.Length);
        if (CombinedName.Buffer == NULL)
        {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }
        RtlCopyMemory(
            CombinedName.Buffer,
            Password->Buffer,
            Password->Length
            );
        RtlCopyMemory(
            CombinedName.Buffer + Password->Length/sizeof(WCHAR),
            PrincipalName->Buffer,
            PrincipalName->Length
            );
    }
    else
    {
        CombinedName = *Password;
    }

    //
    // Get the preferred checksum
    //



    Key->keyvalue.value = (PUCHAR) MIDL_user_allocate(CryptoSystem->KeySize);
    if (Key->keyvalue.value == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    //
    // Check if we need to use an outside supplied string to key
    // calculation
    //
    if (0 != KerbGlobalStrToKeyProvider)
    {
        Status = UseOutsideStringToKey(
                    &CombinedName,
                    CryptoSystem->KeySize,
                    Key->keyvalue.value
                    );

        if (NT_SUCCESS(Status))
        {
            fUseDefaultStringToKey = FALSE;
        }
        //
        // the function will return STATUS_UNSUCCESSFUL indicates not to fall
        // back to the typical string to key function.
        // 
        else if (STATUS_UNSUCCESSFUL == Status)
        {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }
    }

    if (fUseDefaultStringToKey)
    {
        Status = CryptoSystem->HashString(
                    &CombinedName,
                    Key->keyvalue.value
                    );
        
        if (!NT_SUCCESS(Status))
        {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }
    }

    Key->keyvalue.length = CryptoSystem->KeySize;

    Key->keytype = EncryptionType;
    KerbErr = KDC_ERR_NONE;

Cleanup:

    if ((CombinedName.Buffer != Password->Buffer) &&
        (CombinedName.Buffer != NULL))
    {
        MIDL_user_free(CombinedName.Buffer);
    }

    if (!KERB_SUCCESS(KerbErr) && Key->keyvalue.value != NULL)
    {
        MIDL_user_free(Key->keyvalue.value);
        Key->keyvalue.value = NULL;
    }

    return(KerbErr);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbHashPassword
//
//  Synopsis:   Hashes a password into a kerberos encryption key
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


KERBERR NTAPI
KerbHashPassword(
    IN PUNICODE_STRING Password,
    IN ULONG EncryptionType,
    OUT PKERB_ENCRYPTION_KEY Key
    )
{
    UNICODE_STRING TempString;
    RtlInitUnicodeString(
        &TempString,
        NULL
        );
    return( KerbHashPasswordEx(
                Password,
                &TempString,                   // no principal name
                EncryptionType,
                Key
                ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\common2\tickets.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        tickets.c
//
// Contents:    Ticket bundling code
//
//
// History:      6 Dec 91,  RichardW    Created
//              04 Jun 92   RichardW    NT-ized
//              08-Jun-93   WadeR       Converted to C++, rewrote packing code
//
//------------------------------------------------------------------------

#ifdef WIN32_CHICAGO
#include<kerb.hxx>
#include<kerbp.h>
#endif // WIN32_CHICAGO

#ifndef WIN32_CHICAGO
extern "C"
{
#include "krbprgma.h"
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntlsa.h>
#include <samrpc.h>
#include <samisrv.h>
#include <lsarpc.h>
#include <lsaisrv.h>
#include <lsaitf.h>
#include <wincrypt.h>
}
#include <kerbcomm.h>
#include <kerberr.h>
#include <kerbcon.h>
#include <midles.h>
#include <authen.hxx>
#include <kerberos.h>
#include "debug.h"
#include "fileno.h"
#else// WIN32_CHICAGO
#include "tostring.hxx"
#endif // WIN32_CHICAGO

#include <utils.hxx>

#define FILENO  FILENO_TICKETS

//
// Debugging support.
//

#ifndef WIN32_CHICAGO
#ifdef DEBUG_SUPPORT


DEBUG_KEY   KSuppDebugKeys[] = { {DEB_ERROR, "Error"},
                                 {DEB_WARN,  "Warning"},
                                 {DEB_TRACE, "Trace"},
                                 {DEB_T_SOCK, "Sock"},
                                 {0, NULL }
                                 };
#endif

DEFINE_DEBUG_DEFER(KSupp, KSuppDebugKeys);
#endif // WIN32_CHICAGO


RTL_CRITICAL_SECTION OssCriticalSection;
BOOLEAN TicketsInitialized;
BOOLEAN KerbUseFastDecodeAlloc = FALSE;

#define I_LsaIThreadAlloc MIDL_user_allocate
#define I_LsaIThreadFree MIDL_user_free

//+-------------------------------------------------------------------------
//
//  Function:   KerbConvertGeneralizedTimeToLargeInt
//
//  Synopsis:   Converts a generalized time (ASN.1 format) to a large integer
//              (NT format)
//
//  Effects:
//
//  Arguments:  TimeStamp - receives NT-style time
//              ClientTime - client generalized time
//              ClientUsec - client micro second count
//
//  Requires:   none
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbConvertGeneralizedTimeToLargeInt(
    OUT PTimeStamp TimeStamp,
    IN PKERB_TIME ClientTime,
    IN int ClientUsec
    )
{
    KERB_TIME ZeroTime;
    TIME_FIELDS TimeFields;

    //
    // Special case zero time
    //

    RtlZeroMemory(
        &ZeroTime,
        sizeof(KERB_TIME)
        );

    ZeroTime.universal = TRUE;

    //
    // Skip this check after 3/1/97 - no clients should send this sort of
    // zero time
    //


    if (RtlEqualMemory(
            &ZeroTime,
            ClientTime,
            sizeof(KERB_TIME)
            ))
    {
#ifndef WIN32_CHICAGO
        TimeStamp->QuadPart = 0;
#else // WIN32_CHICAGO
        *TimeStamp = 0;
#endif // WIN32_CHICAGO
        return;
    }

    //
    // Check for MIT zero time
    //

    ZeroTime.year = 1970;
    ZeroTime.month = 1;
    ZeroTime.day = 1;

    if (RtlEqualMemory(
            &ZeroTime,
            ClientTime,
            sizeof(KERB_TIME)
            ))
    {
#ifndef WIN32_CHICAGO
        TimeStamp->QuadPart = 0;
#else // WIN32_CHICAGO
        *TimeStamp = 0;
#endif // WIN32_CHICAGO
        return;
    }
    else
    {
        TimeFields.Year = ClientTime->year;
        TimeFields.Month = ClientTime->month;
        TimeFields.Day = ClientTime->day;
        TimeFields.Hour = ClientTime->hour;
        TimeFields.Minute = ClientTime->minute;
        TimeFields.Second = ClientTime->second;
        TimeFields.Milliseconds = ClientTime->millisecond;  // to convert from micro to milli
        TimeFields.Weekday = 0;

#ifndef WIN32_CHICAGO
        RtlTimeFieldsToTime(
            &TimeFields,
            TimeStamp
            );
#else // WIN32_CHICAGO
        LARGE_INTEGER TempTimeStamp;
        RtlTimeFieldsToTime(
            &TimeFields,
            &TempTimeStamp
            );
        *TimeStamp = TempTimeStamp.QuadPart;
#endif // WIN32_CHICAGO

        //
        // add in any micro seconds
        //

#ifndef WIN32_CHICAGO
        TimeStamp->QuadPart += ClientUsec * 10;
#else // WIN32_CHICAGO
        *TimeStamp += ClientUsec * 10;
#endif // WIN32_CHICAGO

    }
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbConvertLargeIntToGeneralizedTime
//
//  Synopsis:   Converts a large integer to ageneralized time
//
//  Effects:
//
//  Arguments:  ClientTime - receives generalized time
//              ClientUsec - receives micro second count
//              TimeStamp - contains NT-style time
//
//  Requires:   none
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbConvertLargeIntToGeneralizedTime(
    OUT PKERB_TIME ClientTime,
    OUT OPTIONAL int * ClientUsec,
    IN PTimeStamp TimeStamp
    )
{
    TIME_FIELDS TimeFields;

    //
    // Special case zero time
    //

#ifndef WIN32_CHICAGO
    if (TimeStamp->QuadPart == 0)
#else // WIN32_CHICAGO
    if (*TimeStamp == 0)
#endif // WIN32_CHICAGO
    {
        RtlZeroMemory(
            ClientTime,
            sizeof(KERB_TIME)
            );

        //
        // For MIT compatibility, time zero is 1/1/70
        //

        ClientTime->year = 1970;
        ClientTime->month = 1;
        ClientTime->day = 1;

        if (ARGUMENT_PRESENT(ClientUsec))

        {
            *ClientUsec  = 0;
        }
        ClientTime->universal = TRUE;
    }
    else
    {

#ifndef WIN32_CHICAGO
        RtlTimeToTimeFields(
            TimeStamp,
            &TimeFields
            );
#else // WIN32_CHICAGO
        RtlTimeToTimeFields(
            (LARGE_INTEGER*)TimeStamp,
            &TimeFields
            );
#endif // WIN32_CHICAGO

        //
        // Generalized times can only contains years up to four digits.
        //

        if (TimeFields.Year > 2037)
        {
            ClientTime->year = 2037;
        }
        else
        {
            ClientTime->year = TimeFields.Year;
        }

        ClientTime->month = (ASN1uint8_t) TimeFields.Month;
        ClientTime->day = (ASN1uint8_t) TimeFields.Day;
        ClientTime->hour = (ASN1uint8_t) TimeFields.Hour;
        ClientTime->minute = (ASN1uint8_t) TimeFields.Minute;
        ClientTime->second = (ASN1uint8_t) TimeFields.Second;

        // MIT kerberos does not support millseconds
        //

        ClientTime->millisecond = 0;

        if (ARGUMENT_PRESENT(ClientUsec))
        {
            //
            // Since we don't include milliseconds above, use the whole
            // thing here.
            //

#ifndef WIN32_CHICAGO
            *ClientUsec = (TimeStamp->LowPart / 10) % 1000000;
#else // WIN32_CHICAGO
            *ClientUsec = (int) ((*TimeStamp / 10) % 1000000);
#endif // WIN32_CHICAGO
        }

        ClientTime->diff = 0;
        ClientTime->universal = TRUE;
    }

}


VOID
KerbConvertLargeIntToGeneralizedTimeWrapper(
    OUT PKERB_TIME ClientTime,
    OUT OPTIONAL long * ClientUsec,
    IN PTimeStamp TimeStamp
    )
{
    int temp;

    if (ClientUsec != NULL)
    {
        KerbConvertLargeIntToGeneralizedTime(
            ClientTime,
            &temp,
            TimeStamp
            );

        *ClientUsec = temp;
    }
    else
    {
        KerbConvertLargeIntToGeneralizedTime(
            ClientTime,
            NULL,
            TimeStamp
            );
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbFreeHostAddresses
//
//  Synopsis:   Frees a host address  allocated with KerbBuildHostAddresses
//
//  Effects:
//
//  Arguments:  Addresses - The name to free
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbFreeHostAddresses(
    IN PKERB_HOST_ADDRESSES Addresses
    )
{
    PKERB_HOST_ADDRESSES Elem,NextElem;

    Elem = Addresses;
    while (Elem != NULL)
    {
        if (Elem->value.address.value != NULL)
        {
            MIDL_user_free(Elem->value.address.value);
        }
        NextElem = Elem->next;
        MIDL_user_free(Elem);
        Elem = NextElem;
    }
}

#ifndef WIN32_CHICAGO

//+-------------------------------------------------------------------------
//
//  Function:   KerbCheckTimeSkew
//
//  Synopsis:   Verifies the supplied time is within the skew of another
//              supplied time
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

BOOLEAN
KerbCheckTimeSkew(
    IN PTimeStamp CurrentTime,
    IN PTimeStamp ClientTime,
    IN PTimeStamp AllowedSkew
    )
{
    TimeStamp TimePlus, TimeMinus;

    TimePlus.QuadPart = CurrentTime->QuadPart + AllowedSkew->QuadPart;
    TimeMinus.QuadPart = CurrentTime->QuadPart - AllowedSkew->QuadPart;

    if ((ClientTime->QuadPart > TimePlus.QuadPart) ||
        (ClientTime->QuadPart < TimeMinus.QuadPart))
    {
        return(FALSE);
    }

    return(TRUE);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbVerifyTicket
//
//  Synopsis:   Verifies that the specified ticket is valid by checking
//              for valid times, flags, and server principal name. This is
//              called by KerbCheckTicket to verify an AP request and by the
//              KDC to verify additional tickets in TGS request
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KerbVerifyTicket(
    IN PKERB_TICKET PackedTicket,
    IN ULONG NameCount,
    IN OPTIONAL PUNICODE_STRING ServiceNames,
    IN PUNICODE_STRING ServiceRealm,
    IN PKERB_ENCRYPTION_KEY ServiceKey,
    IN OPTIONAL PTimeStamp SkewTime,
    OUT PKERB_ENCRYPTED_TICKET * DecryptedTicket
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    UNICODE_STRING TicketRealm = {0};
    PKERB_ENCRYPTED_TICKET EncryptPart = NULL;
    TimeStamp TimePlus, TimeMinus, TimeNow, StartTime,EndTime, Time2Plus;
    ULONG TicketFlags = 0;

#ifdef notedef
    if ( ARGUMENT_PRESENT(ServiceNames) )
    {
        ULONG Index;

        KerbErr = KRB_AP_ERR_NOT_US;

        //
        // Loop through names looking for a match
        //

        for (Index = 0; Index < NameCount ; Index++ )
        {
            if (KerbCompareStringToPrincipalName(
                &PackedTicket->server_name,
                &ServiceNames[Index]
                ) )
            {
                KerbErr = KDC_ERR_NONE;
                break;
            }

        }

        if (!KERB_SUCCESS(KerbErr))
        {
            DebugLog(( DEB_WARN, "KLIN(%x) Ticket (%s) not for this service (%wZ).\n",
                                 KLIN(FILENO, __LINE__),
                                 PackedTicket->server_name.name_string->value,
                                 &ServiceNames[0] ));
            goto Cleanup;
        }
    }

    if (ARGUMENT_PRESENT(ServiceRealm))
    {
        KerbErr = KerbConvertRealmToUnicodeString(
                    &TicketRealm,
                    &PackedTicket->realm
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }

        if (!KerbCompareUnicodeRealmNames(
                &TicketRealm,
                ServiceRealm
                ))
        {
            KerbErr = KRB_AP_ERR_NOT_US;
            DebugLog(( DEB_WARN, "KLIN(%x) Ticket (%wZ) not for this realm (%wZ).\n",
                                 KLIN(FILENO, __LINE__), &TicketRealm, ServiceRealm ));
            goto Cleanup;

        }
    }
#endif

    //
    // Unpack ticket.
    //

    KerbErr = KerbUnpackTicket(
                    PackedTicket,
                    ServiceKey,
                    &EncryptPart
                    );

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_WARN, "KLIN(%x) KerbUnpackTicket failed: 0x%x",
            KLIN(FILENO, __LINE__), KerbErr));
        goto Cleanup;
    }

    if (PackedTicket->ticket_version != KERBEROS_VERSION)
    {
        DebugLog(( DEB_WARN, "KLIN(%x) Ticket has bad version %d\n",
            KLIN(FILENO, __LINE__),PackedTicket->ticket_version ));
        KerbErr = KRB_AP_ERR_BADVERSION;
        goto Cleanup;
    }

    //
    // If the caller provided a skew time, check the times on the ticket.
    // Otherwise it is up to the caller to check that the ticket times are
    // correct
    //

    if (ARGUMENT_PRESENT(SkewTime))
    {
        //
        // Check the times on the ticket.  We do this last because when the KDC
        // wants to renew a ticket, the timestamps may be incorrect, but it will
        // accept the ticket anyway.  This way the KDC can be certain when the
        // times are wrong that everything else is OK.
        //

        GetSystemTimeAsFileTime((PFILETIME) &TimeNow );

    #ifndef WIN32_CHICAGO
        TimePlus.QuadPart = TimeNow.QuadPart + SkewTime->QuadPart;
        Time2Plus.QuadPart = TimePlus.QuadPart + SkewTime->QuadPart;
        TimeMinus.QuadPart = TimeNow.QuadPart - SkewTime->QuadPart;
    #else // WIN32_CHICAGO
        TimePlus = TimeNow + *SkewTime;
        Time2Plus = TimePlus + *SkewTime;
        TimeMinus = TimeNow - *SkewTime;
    #endif // WIN32_CHICAGO

        KerbConvertGeneralizedTimeToLargeInt(
            &EndTime,
            &EncryptPart->endtime,
            0
            );

        //
        // Did the ticket expire already?
        //

    #ifndef WIN32_CHICAGO
        if ( EndTime.QuadPart < TimeMinus.QuadPart )
    #else // WIN32_CHICAGO
        if ( EndTime < TimeMinus )
    #endif // WIN32_CHICAGO
        {
            DebugLog(( DEB_WARN, "KLIN(%x) KerbCheckTicket: ticket is expired.\n",
                KLIN(FILENO, __LINE__)));

            KerbErr = KRB_AP_ERR_TKT_EXPIRED;
            goto Cleanup;
        }

        //
        // Is the ticket  valid yet?
        //

        if (EncryptPart->bit_mask & KERB_ENCRYPTED_TICKET_starttime_present)
        {
            KerbConvertGeneralizedTimeToLargeInt(
                &StartTime,
                &EncryptPart->KERB_ENCRYPTED_TICKET_starttime,
                0
                );

            TicketFlags = KerbConvertFlagsToUlong(
                            &EncryptPart->flags
                            );
            //
            // BUG 403734: Look into this a bit more
            // We don't check for tickets that aren't valid yet, as
            // our KDC doesn't normally hand out post dated tickets. As long
            // as the end time is valid, that is good enough for us.
            //

            //
            // Does the ticket start in the future? Allow twice the skew in
            // the reverse direction.
            //
    #ifndef WIN32_CHICAGO
            if ( (StartTime.QuadPart > Time2Plus.QuadPart) ||
    #else // WIN32_CHICAGO
            if ( (StartTime > Time2Plus) ||
    #endif // WIN32_CHICAGO
                ((TicketFlags & KERB_TICKET_FLAGS_invalid) != 0 ))
            {
                KerbErr = KRB_AP_ERR_TKT_NYV;
                goto Cleanup;
            }
        }
    }

    *DecryptedTicket = EncryptPart;
    EncryptPart = NULL;

Cleanup:

    if (EncryptPart != NULL)
    {
        KerbFreeTicket(EncryptPart);
    }

    KerbFreeString(&TicketRealm);
    return(KerbErr);
}


//+---------------------------------------------------------------------------
//
//  Function:   KerbCheckTicket
//
//  Synopsis:   Decrypts a ticket and authenticator, verifies them.
//
//  Effects:    decrypts the ticket and authenticator (in place) allocates mem.
//
//  Arguments:  [PackedTicket]    -- Encrypted ticket
//              [PackedTicketSize] - Size of encrypted ticket
//              [pedAuth]         -- Encrypted authenticator
//              [pkKey]           -- Key to decrypt ticket with
//              [alAuthenList]    -- List of authenticators to check against
//              [NameCount]       -- Count of service names
//              [pwzServiceName]  -- Name of service (may be NULL).
//              [CheckForTimeSKewReplay]  -- If TRUE, check authenticator cache for timeskew and/or replay
//              [KdcRequest]      -- If TRUE, this is the ticket in a TGS req (allows for checking time skew only)
//              [pkitTicket]      -- Decrypted ticket
//              [pkiaAuth]        -- Decrypted authenticator
//              [pkTicketKey]     -- Session key from ticket
//              [pkSessionKey]    -- Session key to use
//
//  Returns:    KDC_ERR_NONE if everything is OK, else error.
//
//  History:    4-04-93   WadeR   Created
//
//  Notes:      The caller must call KerbFreeTicket and
//              KerbFreeAuthenticator on pkitTicket and pkiaAuth,
//              respectively.
//
//              If pwzServiceName == NULL, it won't check the service name.
//
//              See sections 3.2.3 and A.10 of the Kerberos V5 R5.2 spec
//
//----------------------------------------------------------------------------

KERBERR NTAPI
KerbCheckTicket(
    IN  PKERB_TICKET PackedTicket,
    IN  PKERB_ENCRYPTED_DATA EncryptedAuthenticator,
    IN  PKERB_ENCRYPTION_KEY pkKey,
    IN  OUT CAuthenticatorList * AuthenticatorList,
    IN  PTimeStamp SkewTime,
    IN  ULONG NameCount,
    IN  PUNICODE_STRING ServiceNames,
    IN  PUNICODE_STRING ServiceRealm,
    IN  BOOLEAN CheckForTimeSkewReplay,
    IN  BOOLEAN KdcRequest,
    OUT PKERB_ENCRYPTED_TICKET * EncryptTicket,
    OUT PKERB_AUTHENTICATOR  * Authenticator,
    OUT OPTIONAL PKERB_ENCRYPTION_KEY pkTicketKey,
    OUT PKERB_ENCRYPTION_KEY pkSessionKey,
    OUT PBOOLEAN UseSubKey
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    PKERB_ENCRYPTED_TICKET EncryptPart = NULL;
    LARGE_INTEGER AuthenticatorTime;

    //
    // The caller will free these, so we must make sure they are valid
    // if we return before putting anything in them.  This will zero out
    // all of the pointers in them, so it's safe to free them later.
    //

    *EncryptTicket = NULL;
    *Authenticator = NULL;
    *UseSubKey = FALSE;

    RtlZeroMemory(
        pkSessionKey,
        sizeof(KERB_ENCRYPTION_KEY)
        );
    if (ARGUMENT_PRESENT(pkTicketKey))
    {
        *pkTicketKey = *pkSessionKey;
    }

    //
    // Is the ticket for this service?
    // ServerName in ticket is different length then ServerName passed in,
    // or same length but contents don't match.

    //
    // If either of KerbUnpackTicket or KerbUnpackAuthenticator
    // get bad data, they could access violate.
    //

    __try
    {
        KerbErr = KerbVerifyTicket(
                    PackedTicket,
                    NameCount,
                    ServiceNames,
                    ServiceRealm,
                    pkKey,
                    SkewTime,
                    &EncryptPart
                    );

        if (!KERB_SUCCESS(KerbErr))
        {
            __leave;
        }

        //
        // Unpack Authenticator.
        //

        KerbErr = KerbUnpackAuthenticator(
                    &EncryptPart->key,
                    EncryptedAuthenticator,
                    KdcRequest,
                    Authenticator
                    );

        if (!KERB_SUCCESS(KerbErr))
        {
            DebugLog((DEB_WARN,"KerbUnpackAuthenticator failed: 0x%x\n", KerbErr) );
            __leave;
        }

        //
        // Check the contents of the authenticator
        //

        if ((*Authenticator)->authenticator_version != KERBEROS_VERSION)
        {
            DebugLog(( DEB_WARN, "Authenticator has bad version %d\n",
                                  (*Authenticator)->authenticator_version ));
            KerbErr = KRB_AP_ERR_BADVERSION;
            __leave;
        }

        if (!KerbComparePrincipalNames(
                &EncryptPart->client_name,
                &(*Authenticator)->client_name
                ) ||
            !KerbCompareRealmNames(
                &EncryptPart->client_realm,
                &(*Authenticator)->client_realm
                ) )
        {
            DebugLog(( DEB_WARN, "Authenticator principal != ticket principal\n"));
            KerbErr = KRB_AP_ERR_BADMATCH;
            __leave;
        }

        //
        // Make sure the authenticator isn't a repeat, or too old.
        //

        if (CheckForTimeSkewReplay)
        {
            BOOLEAN fCheckReplay = TRUE;

            if (KdcRequest)
            {
                fCheckReplay = FALSE;    // bug 38404  for KDC TGS check timeskew only
            }

            KerbConvertGeneralizedTimeToLargeInt(
                &AuthenticatorTime,
                &(*Authenticator)->client_time,
                (*Authenticator)->client_usec
                );

            KerbErr = (KERBERR) AuthenticatorList->Check(
                                    EncryptedAuthenticator->cipher_text.value,
                                    EncryptedAuthenticator->cipher_text.length,
                                    NULL,
                                    0,
                                    &AuthenticatorTime,
                                    TRUE,
                                    FALSE,
                                    fCheckReplay);
            if (!KERB_SUCCESS(KerbErr))
            {
                DebugLog((DEB_WARN,"Failed authenticator (replay/time_skew) check: 0x%x\n",KerbErr));
                __leave;
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        // Any exceptions are likely from bad ticket data being unmarshalled.
        DebugLog(( DEB_WARN, "Exception 0x%X in KerbCheckTicket (likely bad ticket or auth.\n",
            GetExceptionCode() ));
        KerbErr = KRB_AP_ERR_BADVERSION;
    }

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    //
    // Extract the correct session key.  If the Sub-session key in the
    // Authenticator is present, use it.  Otherwise, use the session key
    // from the ticket.
    //

    if (((*Authenticator)->bit_mask & KERB_AUTHENTICATOR_subkey_present) != 0)
    {
        D_DebugLog(( DEB_TRACE, "KerbCheckTicket: Using sub session key from authenticator.\n" ));
        KerbErr = KerbDuplicateKey(
                    pkSessionKey,
                    &(*Authenticator)->KERB_AUTHENTICATOR_subkey
                    );
        *UseSubKey = TRUE;
    }
    else
    {
        KerbErr = KerbDuplicateKey(
                    pkSessionKey,
                    &EncryptPart->key
                    );
    }

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    //
    // The reply has to be encrypted with the ticket key, not the new
    // session key
    //

    if (ARGUMENT_PRESENT(pkTicketKey))
    {
        KerbErr = KerbDuplicateKey(
                    pkTicketKey,
                    &EncryptPart->key
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }
    }

    *EncryptTicket = EncryptPart;
    EncryptPart = NULL;

Cleanup:
    if (EncryptPart != NULL)
    {
        KerbFreeTicket(EncryptPart);
    }
    if (!KERB_SUCCESS(KerbErr))
    {
        KerbFreeKey(pkSessionKey);
        if (ARGUMENT_PRESENT(pkTicketKey))
        {
            KerbFreeKey(pkTicketKey);
        }
    }

    return(KerbErr);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbDuplicateSid
//
//  Synopsis:   Duplicates a SID
//
//  Effects:    allocates memory with LsaFunctions.AllocateLsaHeap
//
//  Arguments:  DestinationSid - Receives a copy of the SourceSid
//              SourceSid - SID to copy
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS - the copy succeeded
//              STATUS_INSUFFICIENT_RESOURCES - the call to allocate memory
//                  failed
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbDuplicateSid(
    OUT PSID * DestinationSid,
    IN PSID SourceSid
    )
{
    ULONG SidSize;

    if (!RtlValidSid(SourceSid))
    {
        return STATUS_INVALID_PARAMETER;
    }

    DsysAssert(RtlValidSid(SourceSid));

    SidSize = RtlLengthSid(SourceSid);
    *DestinationSid = (PSID) MIDL_user_allocate( SidSize );
    if (*DestinationSid == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    RtlCopyMemory(
        *DestinationSid,
        SourceSid,
        SidSize
        );

    return(STATUS_SUCCESS);
}

#endif // WIN32_CHICAGO

//
// Ticket pack/unpack code.
//

//+---------------------------------------------------------------------------
//
//  Function:   KerbPackTicket
//
//  Synopsis:   Packs a KerbInternalTicket to a KerbTicket
//
//  Effects:    Allocates the KerbTicket via MIDL.
//
//  Arguments:  [InternalTicket] -- Internal ticket to pack. Those fields
//                      reused in the packed ticket are zeroed.
//              [pkKey]      -- Key to pack it with
//              [KeyVersion] -- Key version of pkKey (KERB_NO_KEY_VERSION if none)
//              [PackedTicket] -- (out) encrypted ticket. Only the encrypt_part
//                      is allocated.
//
//  History:    08-Jun-93   WadeR   Created
//
//  Notes:      The MES encoding needs to be changed to ASN1 encoding
//
//----------------------------------------------------------------------------

KERBERR NTAPI
KerbPackTicket(
    IN PKERB_TICKET InternalTicket,
    IN PKERB_ENCRYPTION_KEY pkKey,
    IN ULONG KeyVersion,
    OUT PKERB_TICKET PackedTicket
    )
{
    KERBERR       KerbErr = KDC_ERR_NONE;
    PKERB_ENCRYPTED_TICKET EncryptedTicket = NULL;
    ULONG           cbEncryptedPart;
    KERB_TICKET     TemporaryTicket;
    PUCHAR          MarshalledEncryptPart = NULL;
    BOOLEAN RestoreDataOnError = FALSE;

    //
    // Pack the data into the encrypted portion.
    //

    RtlZeroMemory(
        &TemporaryTicket,
        sizeof(KERB_TICKET)
        );

    EncryptedTicket = (PKERB_ENCRYPTED_TICKET) InternalTicket->encrypted_part.cipher_text.value;

    KerbErr = KerbPackData(
                EncryptedTicket,
                KERB_ENCRYPTED_TICKET_PDU,
                &cbEncryptedPart,
                &MarshalledEncryptPart
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"Failed to marshall ticket: 0x%x\n",KerbErr));
        goto Cleanup;
    }

    //
    // And encrypt it.
    //

    TemporaryTicket = *InternalTicket;

    RtlZeroMemory(
        &InternalTicket->realm,
        sizeof(KERB_REALM)
        );

    RtlZeroMemory(
        &InternalTicket->server_name,
        sizeof(KERB_PRINCIPAL_NAME)
        );

    InternalTicket->ticket_extensions = NULL;

    RestoreDataOnError = TRUE;

    KerbErr = KerbAllocateEncryptionBufferWrapper(
                pkKey->keytype,
                cbEncryptedPart,
                &TemporaryTicket.encrypted_part.cipher_text.length,
                &TemporaryTicket.encrypted_part.cipher_text.value
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    DebugLog((DEB_TRACE,"KerbPackTicket: Using KeyVersion 0x%x and Algorithm %d to encrypt ticket\n",
              KeyVersion, pkKey->keytype));

    KerbErr = KerbEncryptDataEx(
                &TemporaryTicket.encrypted_part,
                cbEncryptedPart,
                MarshalledEncryptPart,
                KeyVersion,
                KERB_TICKET_SALT,
                pkKey
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"Failed to encrypt data: 0x%x\n",KerbErr));
        goto Cleanup;
    }

    *PackedTicket = TemporaryTicket;

Cleanup:

    if (MarshalledEncryptPart != NULL)
    {
        MIDL_user_free(MarshalledEncryptPart);
    }

    if (!KERB_SUCCESS(KerbErr))
    {
        if (TemporaryTicket.encrypted_part.cipher_text.value != NULL)
        {
            MIDL_user_free(TemporaryTicket.encrypted_part.cipher_text.value);
        }

        if (RestoreDataOnError)
        {
            InternalTicket->realm = TemporaryTicket.realm;
            InternalTicket->server_name = TemporaryTicket.server_name;
            InternalTicket->ticket_extensions = TemporaryTicket.ticket_extensions;
        }
    }

    return(KerbErr);
}


//+---------------------------------------------------------------------------
//
//  Function:   KerbUnpackTicket
//
//  Synopsis:   Decrypts and unpacks the encyrpted part of aticket.
//
//  Effects:    Allocates memory, decrypts pktTicket in place
//
//  Arguments:  [PackedTicket]  -- ticket to unpack
//              [PackedTicketSize] -- length of packed ticket
//              [pkKey]      -- key to unpack it with
//              [InternalTicket] -- (out) unpacked ticket
//
//  Returns:    KDC_ERR_NONE or error from decrypt
//
//  Signals:    Any exception the MIDL unpacking code throws.
//
//  History:    09-Jun-93   WadeR   Created
//
//  Notes:      Free InternalTicket with KerbFreeTicket, below.
//
//----------------------------------------------------------------------------

KERBERR NTAPI
KerbUnpackTicket(
    IN PKERB_TICKET PackedTicket,
    IN PKERB_ENCRYPTION_KEY pkKey,
    OUT PKERB_ENCRYPTED_TICKET * InternalTicket
    )
{
    KERBERR   KerbErr = KDC_ERR_NONE;
    PUCHAR EncryptedPart = NULL;
    ULONG EncryptSize;
    PKERB_ENCRYPTED_TICKET EncryptedTicket = NULL;

    //
    // Now decrypt the encrypted part of the ticket
    //

    EncryptedPart = (PUCHAR) MIDL_user_allocate(PackedTicket->encrypted_part.cipher_text.length);

    if (EncryptedPart == NULL)
    {
        return(KRB_ERR_GENERIC);
    }

    EncryptSize = PackedTicket->encrypted_part.cipher_text.length;

    KerbErr = KerbDecryptDataEx(
        &PackedTicket->encrypted_part,
        pkKey,
        KERB_TICKET_SALT,
        &EncryptSize,
        EncryptedPart
        );

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"Failed to decrypt ticket: 0x%x\n",KerbErr));

#if DBG
        //
        // Who's this ticket *supposed* to be for?
        //
        KerbPrintPrincipalName(DEB_ERROR, &PackedTicket->server_name);
        KerbPrintKerbRealm(DEB_ERROR, &PackedTicket->realm);
#endif

        goto Cleanup;
    }

    KerbErr = KerbUnpackData(
                EncryptedPart,
                EncryptSize,
                KERB_ENCRYPTED_TICKET_PDU,
                (PVOID *) &EncryptedTicket
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"Failed to unmarshall ticket: 0x%x\n",KerbErr));
        goto Cleanup;
    }

    *InternalTicket = EncryptedTicket;

Cleanup:

    if (EncryptedPart != NULL)
    {
        MIDL_user_free(EncryptedPart);
    }

    return(KerbErr);
}


//+---------------------------------------------------------------------------
//
//  Function:   KerbCreateAuthenticator
//
//  Synopsis:   Creates an authenticator for a client to pass to a service
//
//  Effects:    Encrypts pedAuthenticator
//
//  Arguments:  [pkKey]            -- (in) session key from the ticket this
//                                         authenticator is for.
//              [dwEncrType]       -- (in) Desired encryption type
//              [dwSeq]            -- (in) nonce for authenticator
//              [pTimeStamp]       -- (out) Time for authenticator
//              [ClientName]       -- (in) name of principal
//              [ClientRealm]      -- (in) logon realm of principal
//              [SkewTime]         -- (in) Skew of server's time
//              [pkSubKey]         -- (in) desired sub key (may be NULL)
//              [GssChecksum]      -- (in) optional checksum message to put in authenticator
//              [KdcRequest]       -- (in) If TRUE, this is an authenticator for a KDC request
//                                              and we use a different salt
//              [Authenticator]-- (out) completed authenticator
//              [pAuthenticatorTime]  -- (out optional) timestamp placed on AP request
//
//  History:    4-28-93   WadeR   Created
//
//  Notes:      If pkKey is NULL, a null subkey is used.
//
//
//----------------------------------------------------------------------------

KERBERR NTAPI
KerbCreateAuthenticator(
    IN PKERB_ENCRYPTION_KEY pkKey,
    IN ULONG SequenceNumber,
    OUT OPTIONAL PTimeStamp pAuthenticatorTime,
    IN PKERB_INTERNAL_NAME ClientName,
    IN PUNICODE_STRING ClientRealm,
    IN OPTIONAL PTimeStamp SkewTime,
    IN PKERB_ENCRYPTION_KEY pkSubKey,
    IN OPTIONAL PKERB_CHECKSUM GssChecksum,
    IN BOOLEAN KdcRequest,
    OUT PKERB_ENCRYPTED_DATA Authenticator
    )
{
    KERB_AUTHENTICATOR InternalAuthenticator;
    PKERB_AUTHENTICATOR AuthPointer = &InternalAuthenticator;
    ULONG cbAuthenticator;
    PUCHAR PackedAuthenticator = NULL;
    KERBERR KerbErr = KDC_ERR_NONE;
    TimeStamp TimeToUse;

    Authenticator->cipher_text.value = NULL;

    RtlZeroMemory(
        &InternalAuthenticator,
        sizeof(KERB_AUTHENTICATOR)
        );

    // Build an authenticator

    InternalAuthenticator.authenticator_version = KERBEROS_VERSION;

    // Use "InitString" because we will marshall and then discard the
    // InternalAthenticator.  Therefore it's not a problem having the
    // string point to memory we don't own.

    KerbErr = KerbConvertUnicodeStringToRealm(
                &InternalAuthenticator.client_realm,
                ClientRealm
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    KerbErr = KerbConvertKdcNameToPrincipalName(
                &InternalAuthenticator.client_name,
                ClientName
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    //
    // Stick the correct time in the authenticator
    //

    GetSystemTimeAsFileTime((PFILETIME)&TimeToUse);
    if (ARGUMENT_PRESENT(SkewTime))
    {
#ifndef WIN32_CHICAGO
        TimeToUse.QuadPart += SkewTime->QuadPart;
#else // WIN32_CHICAGO
        TimeToUse += *SkewTime;
#endif // WIN32_CHICAGO
    }

    KerbConvertLargeIntToGeneralizedTimeWrapper(
        &InternalAuthenticator.client_time,
        &InternalAuthenticator.client_usec,
        &TimeToUse
        );

    if (pAuthenticatorTime)
    {
        *pAuthenticatorTime = TimeToUse;        // return the authenticator time
    }

    InternalAuthenticator.bit_mask |= KERB_AUTHENTICATOR_sequence_number_present;

    ASN1intx_setuint32(
        &InternalAuthenticator.KERB_AUTHENTICATOR_sequence_number,
        SequenceNumber
        );

    if (InternalAuthenticator.KERB_AUTHENTICATOR_sequence_number.value == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    if (ARGUMENT_PRESENT(pkSubKey))
    {
        InternalAuthenticator.bit_mask |= KERB_AUTHENTICATOR_subkey_present;
        InternalAuthenticator.KERB_AUTHENTICATOR_subkey = *pkSubKey;
    }

    //
    // If the GSS checksum is present, include it and set it in the bitmask
    //

    if (ARGUMENT_PRESENT(GssChecksum))
    {
        InternalAuthenticator.checksum = *GssChecksum;
        InternalAuthenticator.bit_mask |= checksum_present;
    }

    KerbErr = KerbPackData(
                  AuthPointer,
                  KERB_AUTHENTICATOR_PDU,
                  &cbAuthenticator,
                  &PackedAuthenticator
                  );

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"Failed to marshall authenticator: 0x%x\n",KerbErr));
        goto Cleanup;
    }

    //
    // Now we need to encrypt the buffer
    //

    KerbErr = KerbAllocateEncryptionBufferWrapper(
                pkKey->keytype,
                cbAuthenticator,
                &Authenticator->cipher_text.length,
                &Authenticator->cipher_text.value
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    KerbErr = KerbEncryptDataEx(
                Authenticator,
                cbAuthenticator,
                PackedAuthenticator,
                KERB_NO_KEY_VERSION,
                KdcRequest ? KERB_TGS_REQ_AP_REQ_AUTH_SALT : KERB_AP_REQ_AUTH_SALT,
                pkKey
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"Failed to encrypt data: 0x%x\n",KerbErr));
        goto Cleanup;
    }

Cleanup:

    KerbFreePrincipalName(&InternalAuthenticator.client_name);
    KerbFreeRealm(&InternalAuthenticator.client_realm);

    if (InternalAuthenticator.KERB_AUTHENTICATOR_sequence_number.value != NULL)
    {
        ASN1intx_free(&InternalAuthenticator.KERB_AUTHENTICATOR_sequence_number);
    }

    if (PackedAuthenticator != NULL)
    {
        MIDL_user_free(PackedAuthenticator);

    }

    return(KerbErr);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbUnpackAuthenticator
//
//  Synopsis:   Unpacks and decrypts an authenticator
//
//  Effects:    allocates memory for output authenticator
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR NTAPI
KerbUnpackAuthenticator(
    IN PKERB_ENCRYPTION_KEY Key,
    IN PKERB_ENCRYPTED_DATA EncryptedAuthenticator,
    IN BOOLEAN KdcRequest,
    OUT PKERB_AUTHENTICATOR * Authenticator
    )
{
    KERBERR  KerbErr = KDC_ERR_NONE;
    PUCHAR EncryptedPart;
    ULONG EncryptedSize;
    ULONG Pdu = KERB_AUTHENTICATOR_PDU;

    *Authenticator = NULL;

    //
    // Decrypt it
    //

    EncryptedPart = (PUCHAR) MIDL_user_allocate(EncryptedAuthenticator->cipher_text.length);
    if (EncryptedPart == NULL)
    {
        return(KRB_ERR_GENERIC);
    }

    EncryptedSize = EncryptedAuthenticator->cipher_text.length;
    KerbErr = KerbDecryptDataEx(
                EncryptedAuthenticator,
                Key,
                KdcRequest ? KERB_TGS_REQ_AP_REQ_AUTH_SALT : KERB_AP_REQ_AUTH_SALT,
                &EncryptedSize,
                EncryptedPart
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"Failed to decrypt authenticator: 0x%x\n",KerbErr));
        goto Cleanup;
    }

    //
    // Unpack it
    //

    KerbErr = KerbUnpackData(
                EncryptedPart,
                EncryptedSize,
                Pdu,
                (PVOID *) Authenticator
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"Failed to unmarshall authenticator: 0x%x\n",KerbErr));
        goto Cleanup;
    }

Cleanup:

    if (EncryptedPart != NULL)
    {
        MIDL_user_free(EncryptedPart);
    }

    if (!KERB_SUCCESS(KerbErr) && (*Authenticator != NULL))
    {
        MIDL_user_free(*Authenticator);
        *Authenticator = NULL;
    }

    return (KerbErr);
}

//
// KDC Reply stuff
//

//+-------------------------------------------------------------------------
//
//  Function:   KerbPackKdcReplyBody
//
//  Synopsis:   Marshalls a the body of a KDC reply
//
//  Effects:    allocates value of encrypted reply
//
//  Arguments:  ReplyBody - The reply body to marshall
//              Key - The key to encrypt the reply
//              Pdu - Pdu to pack with, eith AS or TGS reply
//              EncryptedReplyBody - receives the encrypted and marshalled reply
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR NTAPI
KerbPackKdcReplyBody(
    IN PKERB_ENCRYPTED_KDC_REPLY ReplyBody,
    IN PKERB_ENCRYPTION_KEY Key,
    IN ULONG KeyVersion,
    IN ULONG KeySalt,
    IN ULONG Pdu,
    OUT PKERB_ENCRYPTED_DATA EncryptedReply
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    ULONG BodySize;
    ULONG EncryptionOverhead;
    PUCHAR MarshalledReply = NULL;
    ULONG TotalSize;
    ULONG BlockSize = 0;

    EncryptedReply->cipher_text.value = NULL;

    KerbErr = KerbPackData(
                ReplyBody,
                Pdu,
                &BodySize,
                &MarshalledReply
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR, "Failed to marshall kdc reply body: 0x%x\n", KerbErr));
        goto Cleanup;
    }

    //
    // Now we need to encrypt this into the encrypted  data structure.
    //

    //
    // First get the overhead size
    //

    KerbErr = KerbGetEncryptionOverhead(
                Key->keytype,
                &EncryptionOverhead,
                &BlockSize
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    DsysAssert(BlockSize <= 8);


    TotalSize = ROUND_UP_COUNT(EncryptionOverhead + BodySize, BlockSize);

    EncryptedReply->cipher_text.length = TotalSize;
    EncryptedReply->cipher_text.value = (PUCHAR) MIDL_user_allocate(TotalSize);

    if (EncryptedReply->cipher_text.value == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    //
    // Now encrypt the buffer  see raid 502476 if adding in new etypes - must fix I_GetASTIcket()'s call to
    // pass in correct value KERB_AS_REP_SALT rather than KERB_AS_REP_SALT but need to map for rc4 first
    //

    KerbErr = KerbEncryptDataEx(
                  EncryptedReply,
                  BodySize,
                  MarshalledReply,
                  KeyVersion,
                  KeySalt,
                  Key
                  );

    DebugLog((DEB_TRACE,"KerbPackKdcReplyBody: KeyVersion 0x%lx Algorithm %d  KerbErr 0x%x\n",
              KeyVersion, Key->keytype, KerbErr));

Cleanup:

    if (MarshalledReply != NULL)
    {
        MIDL_user_free(MarshalledReply);
    }

    if (!KERB_SUCCESS(KerbErr) && (EncryptedReply->cipher_text.value != NULL))
    {
        MIDL_user_free(EncryptedReply->cipher_text.value);
        EncryptedReply->cipher_text.value = NULL;
    }

    return(KerbErr);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbUnpackKdcReplyBody
//
//  Synopsis:   Unpacks a KDC reply body
//
//  Effects:
//
//  Arguments:  EncryptedReplyBody - an encrypted marshalled reply body.
//              Key - Key to decrypt the reply.
//              Pdu - PDU of reply body (eithe AS or TGS)
//              ReplyBody - receives the decrypted reply body, allocated with
//                      MIDL_user_allocate.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR NTAPI
KerbUnpackKdcReplyBody(
    IN PKERB_ENCRYPTED_DATA EncryptedReplyBody,
    IN PKERB_ENCRYPTION_KEY Key,
    IN ULONG Pdu,
    OUT PKERB_ENCRYPTED_KDC_REPLY * ReplyBody
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    PUCHAR MarshalledReply = NULL;
    ULONG ReplySize;

    *ReplyBody = NULL;
    MarshalledReply = (PUCHAR) MIDL_user_allocate(EncryptedReplyBody->cipher_text.length);

    if (MarshalledReply == NULL)
    {
        return(KRB_ERR_GENERIC);
    }

    //
    // First decrypt the buffer
    //   Note:   The switch on KERB_AS_REPLY_PDU below is incorrect.  See bug 502476
    //

    ReplySize = EncryptedReplyBody->cipher_text.length;
    KerbErr = KerbDecryptDataEx(
                EncryptedReplyBody,
                Key,
                (Pdu == KERB_AS_REPLY_PDU) ? KERB_AS_REP_SALT : KERB_TGS_REP_SALT,
                &ReplySize,
                MarshalledReply
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    KerbErr = KerbUnpackData(
                MarshalledReply,
                ReplySize,
                Pdu,
                (PVOID *) ReplyBody
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        //
        // MIT KDCs send back TGS reply bodies instead of AS reply bodies
        // so try TGS here
        //

        if (Pdu == KERB_ENCRYPTED_AS_REPLY_PDU)
        {
            KerbErr = KerbUnpackData(
                          MarshalledReply,
                          ReplySize,
                          KERB_ENCRYPTED_TGS_REPLY_PDU,
                          (PVOID *) ReplyBody
                          );
        }

        if (!KERB_SUCCESS(KerbErr))
        {
            DebugLog((DEB_ERROR,"Failed to unmarshall kdc reply body: 0x%x\n",KerbErr));
            goto Cleanup;
        }
    }

Cleanup:

    if (MarshalledReply != NULL)
    {
        MIDL_user_free(MarshalledReply);
    }

    if (!KERB_SUCCESS(KerbErr) && (*ReplyBody != NULL))
    {
        MIDL_user_free(*ReplyBody);
        *ReplyBody = NULL;
    }

    return(KerbErr);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbFindAuthDataEntry
//
//  Synopsis:   Finds a specific entry in an authorization data structure
//
//  Effects:
//
//  Arguments:  EntryId - ID of the entry to locate
//              AuthData - the authorization data to search
//
//  Requires:
//
//  Returns:    NULL if it wasn't found of the auth data entry
//
//  Notes:
//
//
//--------------------------------------------------------------------------

PKERB_AUTHORIZATION_DATA
KerbFindAuthDataEntry(
    IN ULONG EntryId,
    IN PKERB_AUTHORIZATION_DATA AuthData
    )
{
    PKERB_AUTHORIZATION_DATA TempData = AuthData;

    while (TempData != NULL)
    {
        if (TempData->value.auth_data_type == (int) EntryId)
        {
            break;
        }

        TempData = TempData->next;
    }

    return(TempData);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbFindPreAuthDataEntry
//
//  Synopsis:   Finds a specific entry in an authorization data structure
//
//  Effects:
//
//  Arguments:  EntryId - ID of the entry to locate
//              AuthData - the authorization data to search
//
//  Requires:
//
//  Returns:    NULL if it wasn't found of the auth data entry
//
//  Notes:
//
//
//--------------------------------------------------------------------------

PKERB_PA_DATA
KerbFindPreAuthDataEntry(
    IN ULONG EntryId,
    IN PKERB_PA_DATA_LIST AuthData
    )
{
    PKERB_PA_DATA_LIST TempData = AuthData;

    while (TempData != NULL)
    {
        if (TempData->value.preauth_data_type == (int) EntryId)
        {
            break;
        }

        TempData = TempData->next;
    }

    return(TempData  != NULL ? &TempData->value : NULL);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbFreePreAuthData
//
//  Synopsis:   Frees a pa-data list
//
//  Effects:
//
//  Arguments:  PreAuthData - data to free
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbFreePreAuthData(
    IN OPTIONAL PKERB_PA_DATA_LIST PreAuthData
    )
{
    PKERB_PA_DATA_LIST Next,Last;

    Next = PreAuthData;

    while (Next != NULL)
    {
        Last = Next->next;

        if (Next->value.preauth_data.value != NULL)
        {
            MIDL_user_free(Next->value.preauth_data.value);
        }

        MIDL_user_free(Next);
        Next = Last;
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbFreeAuthData
//
//  Synopsis:   Frees and auth data structure that was allocated in
//              pieces
//
//  Effects:    frees with MIDL_user_Free
//
//  Arguments:  AuthData - the auth data to free
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbFreeAuthData(
    IN PKERB_AUTHORIZATION_DATA AuthData
    )
{
    PKERB_AUTHORIZATION_DATA TempData1,TempData2;

    TempData1 = AuthData;

    while (TempData1 != NULL)
    {
        TempData2 = TempData1->next;

        if (TempData1->value.auth_data.value != NULL)
        {
            MIDL_user_free(TempData1->value.auth_data.value);
        }

        MIDL_user_free(TempData1);
        TempData1 = TempData2;
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbCopyAndAppendAuthData
//
//  Synopsis:   copies the elements from the input auth data and appends
//              them to the end of the output auth data.
//
//  Effects:    allocates each auth data with MIDL_user_allocate
//
//  Arguments:  OutputAuthData - receives list of append auth data
//              InputAuthData - optionally contains auth data to append
//
//  Requires:
//
//  Returns:    KDC_ERR_NONE or KRB_ERR_GENERIC;
//
//  Notes:      on failure output auth data will be freed and set to NULL.
//
//
//--------------------------------------------------------------------------

KERBERR
KerbCopyAndAppendAuthData(
    OUT PKERB_AUTHORIZATION_DATA * OutputAuthData,
    IN PKERB_AUTHORIZATION_DATA InputAuthData
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    PKERB_AUTHORIZATION_DATA  *LastEntry = OutputAuthData;
    PKERB_AUTHORIZATION_DATA TempEntry = NULL;

    //
    // Find the end of the list
    //

    while (*LastEntry != NULL)
    {
        LastEntry = &((*LastEntry)->next);
    }

    while (InputAuthData != NULL)
    {
        //
        // copy the existing entry
        //

        TempEntry = (PKERB_AUTHORIZATION_DATA) MIDL_user_allocate(sizeof(KERB_AUTHORIZATION_DATA));

        if (TempEntry == NULL)
        {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }

        TempEntry->value.auth_data.length = InputAuthData->value.auth_data.length;
        TempEntry->value.auth_data_type = InputAuthData->value.auth_data_type;
        TempEntry->next = NULL;

        TempEntry->value.auth_data.value = (PUCHAR) MIDL_user_allocate(InputAuthData->value.auth_data.length);

        if (TempEntry->value.auth_data.value == NULL)
        {
            MIDL_user_free(TempEntry);
            goto Cleanup;
        }

        RtlCopyMemory(
            TempEntry->value.auth_data.value,
            InputAuthData->value.auth_data.value,
            InputAuthData->value.auth_data.length
            );

        //
        // add it to the end of the list
        //

        *LastEntry = TempEntry;
        LastEntry = &TempEntry->next;
        InputAuthData = InputAuthData->next;
    }

    KerbErr = KDC_ERR_NONE;

Cleanup:

    if (!KERB_SUCCESS(KerbErr))
    {
        KerbFreeAuthData(*OutputAuthData);
        *OutputAuthData = NULL;
    }

    return(KerbErr);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbConvertCryptListToArray
//
//  Synopsis:   Converts a linked-list crypt vector to an array of ULONGs
//
//  Effects:    allocates return with MIDL_user_allocate
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KerbConvertCryptListToArray(
    OUT PULONG * ETypeArray,
    OUT PULONG ETypeCount,
    IN PKERB_CRYPT_LIST CryptList
    )
{
    KERBERR Status = KDC_ERR_NONE;
    PKERB_CRYPT_LIST NextEType;
    ULONG ClientETypeCount;
    PULONG ClientETypes = NULL;

    //
    // Build a vector of the client encrypt types
    //

    NextEType = CryptList;

    ClientETypeCount = 0;
    while (NextEType != NULL)
    {
        ClientETypeCount++;
        NextEType = NextEType->next;
    }

    ClientETypes = (PULONG) MIDL_user_allocate(sizeof(ULONG) * ClientETypeCount);
    if (ClientETypes == NULL)
    {
        Status = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    NextEType = CryptList;

    ClientETypeCount = 0;

    while (NextEType != NULL)
    {
        ClientETypes[ClientETypeCount] = NextEType->value;
        ClientETypeCount++;
        NextEType = NextEType->next;
    }

    *ETypeCount = ClientETypeCount;
    *ETypeArray = ClientETypes;

Cleanup:

    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbConvertArrayToCryptList
//
//  Synopsis:   Converts an array of encryption to types to a linked list
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KerbConvertArrayToCryptList(
    OUT PKERB_CRYPT_LIST * CryptList,
    IN PULONG ETypeArray,
    IN ULONG ETypeCount,
    IN BOOL bIncludeOldEtypes
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    ULONG Index;
    PKERB_CRYPT_LIST ListHead = NULL;
    PKERB_CRYPT_LIST ListTail = NULL;
    PKERB_CRYPT_LIST NewListEntry = NULL;

    //
    // If there no encryption types, bail out now.
    //

    if (ETypeCount == 0)
    {
        *CryptList = NULL;
        return(KDC_ERR_NONE);
    }

    for (Index = 0; Index < ETypeCount ; Index++)
    {
        if ( !bIncludeOldEtypes &&
             ((ETypeArray[Index] == KERB_ETYPE_RC4_MD4) ||
               (ETypeArray[Index] == KERB_ETYPE_RC4_HMAC_OLD)) )
        {
            continue;
        }

        NewListEntry = (PKERB_CRYPT_LIST) MIDL_user_allocate(sizeof(KERB_CRYPT_LIST));

        if (NewListEntry == NULL)
        {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }

        NewListEntry->value = ETypeArray[Index];
        NewListEntry->next = NULL;

        if (ListTail != NULL)
        {
            ListTail->next = NewListEntry;
        }
        else
        {
            DsysAssert(ListHead == NULL);
            ListHead = NewListEntry;
        }

        ListTail = NewListEntry;
    }

    *CryptList = ListHead;
    ListHead = NULL;

Cleanup:

    while (ListHead != NULL)
    {
        NewListEntry = ListHead->next;
        MIDL_user_free(ListHead);
        ListHead = NewListEntry;
    }

    return(KerbErr);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbConvertKeysToCryptList
//
//  Synopsis:   Converts an array of keys to types to a linked list
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KerbConvertKeysToCryptList(
    OUT PKERB_CRYPT_LIST * CryptList,
    IN PKERB_STORED_CREDENTIAL Keys
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    ULONG Index;
    PKERB_CRYPT_LIST ListHead = NULL;
    PKERB_CRYPT_LIST ListTail = NULL;
    PKERB_CRYPT_LIST NewListEntry = NULL;

    //
    // If there no encryption types, bail out now.
    //

    if (Keys->CredentialCount == 0)
    {
        *CryptList = NULL;
        return(KDC_ERR_NONE);
    }

    for (Index = 0; Index < Keys->CredentialCount ; Index++ )
    {
        NewListEntry = (PKERB_CRYPT_LIST) MIDL_user_allocate(sizeof(KERB_CRYPT_LIST));

        if (NewListEntry == NULL)
        {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }

        NewListEntry->value = Keys->Credentials[Index].Key.keytype;
        NewListEntry->next = NULL;

        if (ListTail != NULL)
        {
            ListTail->next = NewListEntry;
        }
        else
        {
            DsysAssert(ListHead == NULL);
            ListHead = NewListEntry;
        }

        ListTail = NewListEntry;
    }

    *CryptList = ListHead;
    ListHead = NULL;

Cleanup:

    while (ListHead != NULL)
    {
        NewListEntry = ListHead->next;
        MIDL_user_free(ListHead);
        ListHead = NewListEntry;
    }

    return(KerbErr);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbFreeCryptList
//
//  Synopsis:   Frees a list of crypt types
//
//  Effects:
//
//  Arguments:  CryptList - List to free
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbFreeCryptList(
    IN PKERB_CRYPT_LIST CryptList
    )
{
    PKERB_CRYPT_LIST ListHead = CryptList;
    PKERB_CRYPT_LIST NewListEntry;

    while (ListHead != NULL)
    {
        NewListEntry = ListHead->next;
        MIDL_user_free(ListHead);
        ListHead = NewListEntry;
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbInitAsn
//
//  Synopsis:   Initializes asn1 marshalling code
//
//  Effects:
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:    KDC_ERR_NONE on success, KRB_ERR_GENERIC on failure
//
//  Notes:
//
//
//--------------------------------------------------------------------------

BOOL fKRB5ModuleStarted = FALSE;

KERBERR
KerbInitAsn(
    IN OUT ASN1encoding_t * pEnc,
        IN OUT ASN1decoding_t * pDec
    )
{
    KERBERR KerbErr = KRB_ERR_GENERIC;
    ASN1error_e Asn1Err;

    if (!fKRB5ModuleStarted)
    {
        fKRB5ModuleStarted = TRUE;
        KRB5_Module_Startup();
    }

    if (pEnc != NULL)
    {
        Asn1Err = ASN1_CreateEncoder(
                      KRB5_Module,
                      pEnc,
                      NULL,           // pbBuf
                      0,              // cbBufSize
                      NULL            // pParent
                      );
    }
    else
    {
        Asn1Err = ASN1_CreateDecoder(
                      KRB5_Module,
                      pDec,
                      NULL,           // pbBuf
                      0,              // cbBufSize
                      NULL            // pParent
                      );
    }

    if (ASN1_SUCCESS != Asn1Err)
    {
        DebugLog((DEB_ERROR, "Failed to init ASN1: 0x%x\n",Asn1Err));
        goto Cleanup;
    }

    KerbErr = KDC_ERR_NONE;

Cleanup:

    return(KerbErr);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbTermAsn
//
//  Synopsis:   terminates an ASN world
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbTermAsn(
        IN ASN1encoding_t pEnc,
        IN ASN1decoding_t pDec
    )
{
    if (pEnc != NULL)
    {
        ASN1_CloseEncoder(pEnc);
    }
    else if (pDec != NULL)
    {
        ASN1_CloseDecoder(pDec);
    }

    //KRB5_Module_Cleanup();
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbPackData
//
//  Synopsis:   Packs a datatype using ASN.1 encoding
//
//  Effects:    allocates memory with MIDL_user_allocate
//
//  Arguments:  Data - The message to marshall/pack.
//              PduValue - The PDU for the message type
//              DataSize - receives the size of the marshalled message in
//                      bytes.
//              MarshalledData - receives a pointer to the marshalled
//                      message buffer.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR NTAPI
KerbPackData(
    IN PVOID Data,
    IN ULONG PduValue,
    OUT PULONG DataSize,
    OUT PUCHAR * MarshalledData
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    ASN1encoding_t pEnc = NULL;
    ASN1error_e Asn1Err;

    KerbErr = KerbInitAsn(
                &pEnc,          // we are encoding
                NULL
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    //
    // Encode the data type.
    //

    // D_DebugLog((DEB_TRACE, "KerbPackData encoding pdu #%d\n", PduValue));
    Asn1Err = ASN1_Encode(
                pEnc,
                Data,
                PduValue,
                ASN1ENCODE_ALLOCATEBUFFER,
                NULL,                       // pbBuf
                0                           // cbBufSize
                );

    if (!ASN1_SUCCEEDED(Asn1Err))
    {
        DebugLog((DEB_ERROR,"Failed to encode data: %d\n",Asn1Err));
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }
    else
    {
        //
        // when the oss compiler was used the allocation routines were configurable.
        // therefore, the encoded data could just be free'd using our
        // deallocator.  in the new model we cannot configure the allocation routines
        // for encoding.

        // so we do not have to go and change every place where a free
        // of an encoded buffer is done, use our allocator to allocate a new buffer,
        // then copy the encoded data to it, and free the buffer that was allocated by
        // the encoding engine.  THIS SHOULD BE CHANGED FOR BETTER PERFORMANCE
        //

        *MarshalledData = (PUCHAR) MIDL_user_allocate(pEnc->len);

        if (*MarshalledData == NULL)
        {
            KerbErr = KRB_ERR_GENERIC;
            *DataSize = 0;
        }
        else
        {
            RtlCopyMemory(*MarshalledData, pEnc->buf, pEnc->len);
            *DataSize = pEnc->len;

        }

        ASN1_FreeEncoded(pEnc, pEnc->buf);
    }

Cleanup:

    KerbTermAsn(pEnc, NULL);

    return(KerbErr);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbUnpackData
//
//  Synopsis:   Unpacks an message from the ASN.1 encoding
//
//  Effects:
//
//  Arguments:  Data - Buffer containing the reply message.
//              DataSize - Size of the reply message in bytes
//              Reply - receives a KERB_ENCRYPTED_DATA structure allocated with
//                      MIDL_user_allocate.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR NTAPI
KerbUnpackData(
    IN PUCHAR Data,
    IN ULONG DataSize,
    IN ULONG PduValue,
    OUT PVOID * DecodedData
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    ASN1decoding_t pDec = NULL;
    ASN1error_e Asn1Err;

    if ((DataSize == 0) || (Data == NULL))
    {
        DebugLog((DEB_ERROR, "KerbUnpackData Trying to unpack NULL data\n"));
        return(KRB_ERR_GENERIC);
    }

    KerbErr = KerbInitAsn(
                NULL,
                &pDec           // we are decoding
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR, "KerbUnpackData failed to init Asn %#x\n", KerbErr));
        return(KerbErr);
    }

    *DecodedData = NULL;

    Asn1Err = ASN1_Decode(
                pDec,
                DecodedData,
                PduValue,
                ASN1DECODE_SETBUFFER,
                (BYTE *) Data,
                DataSize
                );

    if (!ASN1_SUCCEEDED(Asn1Err))
    {
        D_DebugLog((DEB_TRACE, "KerbUnpackData Asn1Err %#x\n", Asn1Err));

        if ((ASN1_ERR_BADARGS == Asn1Err) ||
            (ASN1_ERR_EOD == Asn1Err))
        {
            D_DebugLog((DEB_TRACE, "More input required to decode data %d.\n", PduValue));
            KerbErr = KDC_ERR_MORE_DATA;
        }
        else
        {
            if (ASN1_ERR_BADTAG != Asn1Err)
            {
                DebugLog((DEB_ERROR, "Failed to decode data: %d\n", Asn1Err ));
            }

            KerbErr = KRB_ERR_GENERIC;
        }

        *DecodedData = NULL;
    }

    KerbTermAsn(NULL, pDec);

    return(KerbErr);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbFreeData
//
//  Synopsis:   Frees a structure unpacked by the ASN1 decoder
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbFreeData(
    IN ULONG PduValue,
    IN PVOID Data
    )
{
    ASN1decoding_t pDec = NULL;

    if (ARGUMENT_PRESENT(Data))
    {
        KERBERR KerbErr;
        KerbErr = KerbInitAsn(
                    NULL,
                    &pDec       // this is a decoded structure
                    );

        if (KERB_SUCCESS(KerbErr))
        {
            ASN1_FreeDecoded(pDec, Data, PduValue);

            KerbTermAsn(NULL, pDec);
        }
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbFreeTicketExtensions
//
//  Synopsis:   Frees a host address  allocated with KerbDuplicateTicketExtensions
//
//  Effects:
//
//  Arguments:  Addresses - The name to free
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbFreeTicketExtensions(
    IN PKERB_TICKET_EXTENSIONS Extensions
    )
{
    PKERB_TICKET_EXTENSIONS Elem,NextElem;

    Elem = Extensions;
    while (Elem != NULL)
    {
        if (Elem->value.te_data.value != NULL)
        {
            MIDL_user_free(Elem->value.te_data.value);
        }

        NextElem = Elem->next;
        MIDL_user_free(Elem);
        Elem = NextElem;
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbDuplicateTicketExtensions
//
//  Synopsis:   duplicates the ticket extensions field from a ticket
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KerbDuplicateTicketExtensions(
    OUT PKERB_TICKET_EXTENSIONS * Dest,
    IN PKERB_TICKET_EXTENSIONS Source
    )
{
    KERBERR Status = KDC_ERR_NONE;
    PKERB_TICKET_EXTENSIONS  SourceElem;
    PKERB_TICKET_EXTENSIONS DestElem;
    PKERB_TICKET_EXTENSIONS * NextElem;

    *Dest = NULL;

    SourceElem = Source;
    NextElem = Dest;

    while (SourceElem != NULL)
    {
        DestElem = (PKERB_TICKET_EXTENSIONS) MIDL_user_allocate(sizeof(KERB_TICKET_EXTENSIONS));

        if (DestElem == NULL)
        {
            Status = KRB_ERR_GENERIC;
            goto Cleanup;
        }

        *DestElem = *SourceElem;
        DestElem->value.te_data.value = (PUCHAR) MIDL_user_allocate(SourceElem->value.te_data.length);

        if (DestElem->value.te_data.value == NULL)
        {
            MIDL_user_free(DestElem);
            Status = KRB_ERR_GENERIC;
            goto Cleanup;
        }

        RtlCopyMemory(
            DestElem->value.te_data.value,
            SourceElem->value.te_data.value,
            SourceElem->value.te_data.length
            );

        DestElem->next = NULL;
        *NextElem = DestElem;
        NextElem = &DestElem->next;
        SourceElem = SourceElem->next;
    }

Cleanup:

    if (!KERB_SUCCESS(Status))
    {
        KerbFreeTicketExtensions(*Dest);
        *Dest = NULL;
    }

    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbDuplicateTicket
//
//  Synopsis:   Duplicates a ticket so the original may be freed
//
//  Effects:
//
//  Arguments:  Dest - Destination, receives duplicate
//              Source - Source ticket
//
//  Requires:
//
//  Returns:    KDC_ERR_NONE or KRB_ERR_GENERIC;
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR NTAPI
KerbDuplicateTicket(
    OUT PKERB_TICKET Dest,
    IN PKERB_TICKET Source
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    RtlZeroMemory(
        Dest,
        sizeof(KERB_TICKET)
        );

    Dest->ticket_version = Source->ticket_version;

    KerbErr = KerbDuplicatePrincipalName(
                &Dest->server_name,
                &Source->server_name
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    KerbErr = KerbDuplicateRealm(
                &Dest->realm,
                Source->realm
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    KerbErr = KerbDuplicateTicketExtensions(
                &Dest->ticket_extensions,
                Source->ticket_extensions
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    Dest->encrypted_part = Source->encrypted_part;
    Dest->encrypted_part.cipher_text.value = (PUCHAR) MIDL_user_allocate(Dest->encrypted_part.cipher_text.length);

    if (Dest->encrypted_part.cipher_text.value == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    RtlCopyMemory(
        Dest->encrypted_part.cipher_text.value,
        Source->encrypted_part.cipher_text.value,
        Dest->encrypted_part.cipher_text.length
        );

Cleanup:

    if (!KERB_SUCCESS(KerbErr))
    {
        KerbFreeDuplicatedTicket(Dest);
    }

    return(KerbErr);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbFreeDuplicatedTicket
//
//  Synopsis:   Frees ticket duplicated with KerbDuplicateTicket
//
//  Effects:    frees memory
//
//  Arguments:  Ticket - ticket to free
//
//  Requires:
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbFreeDuplicatedTicket(
    IN PKERB_TICKET Ticket
    )
{
    KerbFreePrincipalName(
        &Ticket->server_name
        );

    KerbFreeRealm(
        &Ticket->realm
        );

    if (Ticket->encrypted_part.cipher_text.value != NULL)
    {
        MIDL_user_free(Ticket->encrypted_part.cipher_text.value);
    }

    KerbFreeTicketExtensions(
        Ticket->ticket_extensions
        );
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbBuildErrorMessageEx
//
//  Synopsis:   Builds an error message
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:    marshalled error message, to be freed with MIDL_user_free
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KerbBuildErrorMessageEx(
    IN KERBERR ErrorCode,
    IN OPTIONAL PKERB_EXT_ERROR pExtendedError,
    IN PUNICODE_STRING ServerRealm,
    IN PKERB_INTERNAL_NAME ServerName,
    IN OPTIONAL PUNICODE_STRING ClientRealm,
    IN PBYTE ErrorData,
    IN ULONG ErrorDataSize,
    OUT PULONG ErrorMessageSize,
    OUT PUCHAR* ErrorMessage
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    KERB_ERROR Error;
    KERB_TYPED_DATA Data = {0};
    TimeStamp TimeNow;

    *ErrorMessageSize = 0;
    *ErrorMessage = NULL;

    GetSystemTimeAsFileTime(
        (PFILETIME) &TimeNow
        );

    RtlZeroMemory(
        &Error,
        sizeof(KERB_ERROR)
        );

    DsysAssert(ErrorCode != KDC_ERR_MORE_DATA);

    Error.version = KERBEROS_VERSION;
    Error.message_type = KRB_ERROR;

    KerbConvertLargeIntToGeneralizedTimeWrapper(
        &Error.server_time,
        &Error.server_usec,
        &TimeNow
        );



    //
    // These errors must *never* hit the wire.  They're for use in the KDC
    // and kerb innards only.
    //

    switch (ErrorCode)
    {
    case KDC_ERR_MORE_DATA:
    case KDC_ERR_NOT_RUNNING:
    case KDC_ERR_NO_RESPONSE:
    case KDC_ERR_NO_TRUST_PATH:
    case KRB_ERR_NAME_TOO_LONG:
        ErrorCode = KRB_ERR_GENERIC;
        break;
    default:
        
        NOTHING;
    }
    
    

    Error.error_code = ErrorCode;

    //
    // Ignore errors because this is already an error return
    //

    KerbConvertUnicodeStringToRealm(
        &Error.realm,
        ServerRealm
        );

    if (ARGUMENT_PRESENT(ClientRealm) && (ClientRealm->Buffer != NULL))
    {
        KerbConvertUnicodeStringToRealm(
            &Error.client_realm,
            ClientRealm
            );

        Error.bit_mask |= client_realm_present;
    }

    KerbConvertKdcNameToPrincipalName(
        &Error.server_name,
        ServerName
        );

    //
    // Small problem here.  We may have preauth data that we want
    // to return to the client, instead of extended errors.  To
    // avoid this, we just make sure that we only return extended
    // errors if no ErrorData previously set.
    //

    if (ARGUMENT_PRESENT(ErrorData))
    {
        Error.error_data.length = (int) ErrorDataSize;
        Error.error_data.value = ErrorData;
        Error.bit_mask |= error_data_present;
    }
    else if (ARGUMENT_PRESENT(pExtendedError) && !EXT_ERROR_SUCCESS((*pExtendedError)))
    {
        Data.data_type = TD_EXTENDED_ERROR;

        KerbErr = KerbPackData(
            pExtendedError,
            KERB_EXT_ERROR_PDU,
            &Data.data_value.length,
            &Data.data_value.value
            );

        if (!KERB_SUCCESS(KerbErr))
        {
            DebugLog((DEB_WARN, "KerbBuildErrorMessageEx failed To pack extended error %#x!\n", KerbErr));
            goto Cleanup;
        }

        Error.bit_mask |= error_data_present;

        KerbErr = TypedDataListPushFront(
                      NULL,
                      &Data,
                      &Error.error_data.length,
                      &Error.error_data.value
                      );

        if (!KERB_SUCCESS(KerbErr))
        {
            DebugLog((DEB_WARN, "KerbBuildErrorMessageEx failed To pack typed data %#x!\n", KerbErr));
            goto Cleanup;
        }
    }

    KerbErr = KerbPackData(
                  &Error,
                  KERB_ERROR_PDU,
                  ErrorMessageSize,
                  ErrorMessage
                  );

Cleanup:

    KerbFreeRealm(
        &Error.realm
        );

    KerbFreeRealm(
        &Error.client_realm
        );

    KerbFreePrincipalName(
        &Error.server_name
        );

    if (Data.data_value.value && Data.data_value.length)
    {
        MIDL_user_free(Data.data_value.value);
    }

    if ((ErrorData != Error.error_data.value)
        && Error.error_data.value
        && Error.error_data.length)
    {
        MIDL_user_free(Error.error_data.value);
    }

    return (KerbErr);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbGetKeyFromList
//
//  Synopsis:   Gets the key of the appropriate encryption type off the list
//
//  Effects:
//
//  Arguments:  Passwords - list of keys
//              EncryptionType - Encryption type to use
//
//  Requires:
//
//  Returns:    The found key, or NULL if one wasn't found
//
//  Notes:
//
//
//--------------------------------------------------------------------------

PKERB_ENCRYPTION_KEY
KerbGetKeyFromList(
    IN PKERB_STORED_CREDENTIAL Passwords,
    IN ULONG EncryptionType
    )
{
    ULONG Index;

    if (!ARGUMENT_PRESENT(Passwords))
    {
        return(NULL);
    }

    for (Index = 0; Index < Passwords->CredentialCount ; Index++ )
    {
        if (Passwords->Credentials[Index].Key.keytype == (int) EncryptionType)
        {
            return(&Passwords->Credentials[Index].Key);
        }
    }

    return(NULL);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbGetKeyFromListByIndex
//
//  Synopsis:   Gets the key of the appropriate encryption type off the list
//       starting from a provided index
//
//  Effects:
//
//  Arguments:  Passwords - list of keys
//              EncryptionType - Encryption type to use
//              pIndex - provides starting location for key selection
//
//  Requires:
//
//  Returns:    The found key, or NULL if one wasn't found
//
//  Notes:
//
//
//--------------------------------------------------------------------------

PKERB_ENCRYPTION_KEY
KerbGetKeyFromListByIndex(
    IN PKERB_STORED_CREDENTIAL Passwords,
    IN ULONG EncryptionType,
    OUT PULONG pIndex
    )
{
    ULONG Index;

    if (!ARGUMENT_PRESENT(Passwords) || !ARGUMENT_PRESENT(pIndex))
    {
        return(NULL);
    }

    if (*pIndex >= Passwords->CredentialCount)
    {
        return(NULL);
    }

    for (Index = *pIndex; Index < Passwords->CredentialCount ; Index++ )
    {
        if (Passwords->Credentials[Index].Key.keytype == (int) EncryptionType)
        {
            *pIndex = Index + 1;    // Start on next key if called again
            return(&Passwords->Credentials[Index].Key);
        }
    }

    return(NULL);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbFindCommonCryptSystem
//
//  Synopsis:   Finds a common crypt system including availablity
//              of passwords.
//
//  Effects:
//
//  Arguments:  CryptList - List of client's crypto systems
//              Passwords - List of passwords
//              MorePassword - Optionally another list of passwords to consider
//              Key - Receives key for common crypt system
//
//  Requires:
//
//  Returns:    KDC_ERR_ETYPE_NOTSUPP if no common system can be found
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KerbFindCommonCryptSystem(
    IN PKERB_CRYPT_LIST CryptList,
    IN PKERB_STORED_CREDENTIAL Passwords,
    IN OPTIONAL PKERB_STORED_CREDENTIAL MorePasswords,
    OUT PKERB_ENCRYPTION_KEY * Key
    )
{
    ULONG PasswordTypes[KERB_MAX_CRYPTO_SYSTEMS] = {0};

    PULONG pCryptoSystems = NULL;
    ULONG CryptoSystems[KERB_MAX_CRYPTO_SYSTEMS];
    ULONG PasswordCount;
    ULONG CryptoCount;
    ULONG Index;
    PKERB_CRYPT_LIST NextEType;
    ULONG Index2;
    ULONG KeyCount;
    KERBERR KerbErr = KDC_ERR_ETYPE_NOTSUPP;
    ULONG CommonCryptSystem = KERB_ETYPE_DEFAULT;

    DsysAssert(CryptList != NULL);

    if ((Passwords == NULL ) || (CryptList == NULL))
    {
        DebugLog((DEB_ERROR, "Null password or crypt list passed to KerbFindCommonCryptSystem\n"));
        DsysAssert(FALSE);
        return(KDC_ERR_ETYPE_NOTSUPP);
    }

    PasswordCount = Passwords->CredentialCount;

    if (PasswordCount >= KERB_MAX_CRYPTO_SYSTEMS)
    {
        D_DebugLog((DEB_ERROR, "Got more than 20 crypto systems in password list\n"));
        DsysAssert(PasswordCount < KERB_MAX_CRYPTO_SYSTEMS);
        return(KDC_ERR_ETYPE_NOTSUPP);
    }

    KeyCount = 0;

    for (Index = 0; Index < PasswordCount ; Index++ )
    {
        if (ARGUMENT_PRESENT(MorePasswords))
        {
            for (Index2 = 0; Index2 < MorePasswords->CredentialCount; Index2++ )
            {
                if (Passwords->Credentials[Index].Key.keytype == MorePasswords->Credentials[Index2].Key.keytype)
                {
                    PasswordTypes[KeyCount++] = (ULONG) Passwords->Credentials[Index].Key.keytype;
                    break;
                }
            }
        }
        else
        {
            PasswordTypes[KeyCount++] = (ULONG) Passwords->Credentials[Index].Key.keytype;
        }
    }

    CryptoCount = 0;
    NextEType = CryptList;

    while (NextEType != NULL)
    {
        NextEType = NextEType->next;
        CryptoCount++;

        // restrict to 100 crypt systems, even on a slowbuffer.
        if (CryptoCount > KERB_MAX_CRYPTO_SYSTEMS_SLOWBUFF)
        {
            return(KDC_ERR_ETYPE_NOTSUPP);
        }
    }

    if (CryptoCount >= KERB_MAX_CRYPTO_SYSTEMS)
    {
        pCryptoSystems = (PULONG) MIDL_user_allocate(CryptoCount * sizeof(ULONG));
        if (NULL == pCryptoSystems)
        {
            return ( KRB_ERR_GENERIC );
        }
    }
    else // fast buff
    {
        pCryptoSystems = CryptoSystems;
    }

    // populate values
    NextEType = CryptList;
    Index = 0;

    while (NextEType != NULL)
    {
        pCryptoSystems[Index] = NextEType->value;
        NextEType = NextEType->next;
        Index++;
    }

    DsysAssert(Index == CryptoCount);

    KerbErr = KerbMapStatusToKerbError(
        CDFindCommonCSystemWithKey(
            CryptoCount,
            pCryptoSystems,
            PasswordCount,
            PasswordTypes,
            &CommonCryptSystem
            ));

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR, "KLIN(%x) Missing common crypt system: %#x\n", KLIN(FILENO, __LINE__), KerbErr));
        goto cleanup;
    }

    //
    // Now find the key to return.
    //

    for (Index = 0; Index < Passwords->CredentialCount ; Index++ )
    {
        if (Passwords->Credentials[Index].Key.keytype == (int) CommonCryptSystem)
        {
            *Key = &Passwords->Credentials[Index].Key;
            KerbErr = KDC_ERR_NONE;
            break;
        }
    }

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"KLIN(%x) Couldn't find password type after finding common csystem!\n", KLIN(FILENO, __LINE__)));
    }

cleanup:

    if ((pCryptoSystems != NULL) &&
        (pCryptoSystems != CryptoSystems))
    {
        MIDL_user_free(pCryptoSystems);
    }

    return (KerbErr);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbFindCommonCryptSystemForSKey
//
//  Synopsis:   Finds a common crypt system including availablity
//              for session keys.
//
//  Effects:
//
//  Arguments:  CryptList - List of client's crypto systems
//              CryptListSupported - List of crypto systems supported
//              Etype - Receives the common crypt system
//
//  Requires:
//
//  Returns:    KDC_ERR_ETYPE_NOTSUPP if no common system can be found
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KerbFindCommonCryptSystemForSKey(
    IN PKERB_CRYPT_LIST CryptList,
    IN PKERB_CRYPT_LIST CryptListSupported,
    OUT ULONG * Etype
    )
{    
    *Etype = KERB_ETYPE_NULL;

    for (PKERB_CRYPT_LIST NextEType1 = CryptList; 
         NextEType1 != NULL; 
         NextEType1 = NextEType1->next)
    {
        for (PKERB_CRYPT_LIST NextEType2 = CryptListSupported; 
             NextEType2 != NULL; 
             NextEType2 = NextEType2->next)
        {
            if (NextEType1->value == NextEType2->value) 
            {
                *Etype = NextEType1->value; 
                return KDC_ERR_NONE;
            }
        }
    }

    return KDC_ERR_ETYPE_NOTSUPP;
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbMapKerbError
//
//  Synopsis:   Maps a kerb error to an NTSTATUS
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbMapKerbError(
    IN KERBERR KerbError
    )
{
    NTSTATUS Status;
    switch(KerbError) {
    case KDC_ERR_NONE:
        Status = STATUS_SUCCESS;
        break;
    case KDC_ERR_CLIENT_REVOKED:
        Status = STATUS_ACCOUNT_DISABLED;
        break;
    case KDC_ERR_KEY_EXPIRED:
        Status = STATUS_PASSWORD_EXPIRED;
        break;
    case KRB_ERR_GENERIC:
        Status = STATUS_INSUFFICIENT_RESOURCES;
        break;
    case KRB_AP_ERR_SKEW:
    case KRB_AP_ERR_TKT_NYV:
    // Note this was added because of the following scenario:
    // Let's say the dc and the client have the correct time. And the
    // server's time is off. We aren't going to get rid of the ticket for the
    // server on the client because it hasn't expired yet. But, the server
    // thinks it has. If event logging was turned on, then admins could look
    // at the server's event log and potentially deduce that the server's
    // time is off relative to the dc.
    case KRB_AP_ERR_TKT_EXPIRED:
        Status = STATUS_TIME_DIFFERENCE_AT_DC;
        break;
    case KDC_ERR_POLICY:
        Status = STATUS_ACCOUNT_RESTRICTION;
        break;
    case KDC_ERR_C_PRINCIPAL_UNKNOWN:
        Status = STATUS_NO_SUCH_USER;
        break;
    case KDC_ERR_S_PRINCIPAL_UNKNOWN:
        Status = STATUS_NO_TRUST_SAM_ACCOUNT;
        break;
    case KRB_AP_ERR_MODIFIED:
    case KDC_ERR_PREAUTH_FAILED:
    case KDC_ERR_PREAUTH_REQUIRED:
        Status = STATUS_WRONG_PASSWORD;
        break;
    case KRB_ERR_RESPONSE_TOO_BIG:
        Status = STATUS_INVALID_BUFFER_SIZE;
        break;
    case KDC_ERR_PADATA_TYPE_NOSUPP:
        Status = STATUS_NOT_SUPPORTED;
        break;
    case KRB_AP_ERR_NOT_US:
        Status = SEC_E_WRONG_PRINCIPAL;
        break;

    case KDC_ERR_SVC_UNAVAILABLE:
        Status = STATUS_NO_LOGON_SERVERS;
        break;
    case KDC_ERR_WRONG_REALM:
        Status = STATUS_NO_LOGON_SERVERS;
        break;
    case KDC_ERR_CANT_VERIFY_CERTIFICATE:
        Status = TRUST_E_SYSTEM_ERROR;
        break;
    case KDC_ERR_INVALID_CERTIFICATE:
        Status = STATUS_INVALID_PARAMETER;
        break;
    case KDC_ERR_REVOKED_CERTIFICATE:
        Status = CRYPT_E_REVOKED;
        break;
    case KDC_ERR_REVOCATION_STATUS_UNKNOWN:
        Status = CRYPT_E_NO_REVOCATION_CHECK;
        break;
    case KDC_ERR_REVOCATION_STATUS_UNAVAILABLE:
        Status = CRYPT_E_REVOCATION_OFFLINE;
        break;
    case KDC_ERR_CLIENT_NAME_MISMATCH:
    case KERB_PKINIT_CLIENT_NAME_MISMATCH:
    case KDC_ERR_KDC_NAME_MISMATCH:
        Status = STATUS_PKINIT_NAME_MISMATCH;
        break;
    case KDC_ERR_PATH_NOT_ACCEPTED:
        Status = STATUS_TRUST_FAILURE;
        break;
    case KDC_ERR_ETYPE_NOTSUPP:
        Status = STATUS_KDC_UNKNOWN_ETYPE;
        break;
    case KDC_ERR_MUST_USE_USER2USER:
    case KRB_AP_ERR_USER_TO_USER_REQUIRED:
        Status = STATUS_USER2USER_REQUIRED;
        break;
    case KRB_AP_ERR_NOKEY:
        Status = STATUS_NO_KERB_KEY;
        break;
    case KRB_ERR_NAME_TOO_LONG:
        Status = STATUS_NAME_TOO_LONG;
        break;
    default:
        Status = STATUS_LOGON_FAILURE;
    }

    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbMakeDomainRelativeSid
//
//  Synopsis:   Given a domain Id and a relative ID create the corresponding
//              SID allocated with MIDL_user_allocate.
//
//  Effects:
//
//  Arguments:  DomainId - The template SID to use.
//
//                  RelativeId - The relative Id to append to the DomainId.
//
//  Requires:
//
//  Returns:    Sid - Returns a pointer to a buffer allocated from
//              MIDL_user_allocate containing the resultant Sid.
//
//  Notes:
//
//
//--------------------------------------------------------------------------

PSID
KerbMakeDomainRelativeSid(
    IN PSID DomainId,
    IN ULONG RelativeId
    )
{
    UCHAR DomainIdSubAuthorityCount;
    ULONG Size;
    PSID Sid;

    //
    // Allocate a Sid which has one more sub-authority than the domain ID.
    //

    DomainIdSubAuthorityCount = *(RtlSubAuthorityCountSid( DomainId ));
    Size = RtlLengthRequiredSid(DomainIdSubAuthorityCount+1);

    if ((Sid = MIDL_user_allocate( Size )) == NULL ) {
        return NULL;
    }

    //
    // Initialize the new SID to have the same inital value as the
    // domain ID.
    //

    if ( !NT_SUCCESS( RtlCopySid( Size, Sid, DomainId ) ) ) {
        MIDL_user_free( Sid );
        return NULL;
    }

    //
    // Adjust the sub-authority count and
    //  add the relative Id unique to the newly allocated SID
    //

    (*(RtlSubAuthorityCountSid( Sid ))) ++;
    *RtlSubAuthoritySid( Sid, DomainIdSubAuthorityCount ) = RelativeId;

    return Sid;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbFreeCertificateList
//
//  Synopsis:   Frees a list of certificates created by KerbCreateCertificateList
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbFreeCertificateList(
    IN PKERB_CERTIFICATE_LIST Certificates
    )
{
    PKERB_CERTIFICATE_LIST Last,Next;

    Last = NULL;
    Next = Certificates;

    while (Next != NULL)
    {
        Last = Next;
        Next = Next->next;

        if (Last->value.cert_data.value != NULL)
        {
            MIDL_user_free(Last->value.cert_data.value);
        }

        MIDL_user_free(Last);
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbCreateCertificateList
//
//  Synopsis:   Creates a list of certificates from a cert context
//
//  Effects:
//
//  Arguments:  Certficates - receives list of certificates.
//              CertContext - Context containing certificates
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KerbCreateCertificateList(
    OUT PKERB_CERTIFICATE_LIST * Certificates,
    IN PCCERT_CONTEXT CertContext
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    PKERB_CERTIFICATE_LIST ListEntry = NULL;

    if (!ARGUMENT_PRESENT(CertContext))
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    //
    // Croft up a bogus certificate entry
    //

    ListEntry = (PKERB_CERTIFICATE_LIST) MIDL_user_allocate(sizeof(KERB_CERTIFICATE_LIST));

    if (ListEntry == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    ListEntry->next = NULL;
    ListEntry->value.cert_type = KERB_CERTIFICATE_TYPE_X509;
    ListEntry->value.cert_data.length = CertContext->cbCertEncoded;
    ListEntry->value.cert_data.value = (PUCHAR) MIDL_user_allocate(ListEntry->value.cert_data.length);

    if (ListEntry->value.cert_data.value == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    RtlCopyMemory(
        ListEntry->value.cert_data.value,
        CertContext->pbCertEncoded,
        CertContext->cbCertEncoded
        );

    *Certificates = ListEntry;
    ListEntry = NULL;

Cleanup:

    KerbFreeCertificateList(ListEntry);
    return(KerbErr);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbConvertFlagsToUlong
//
//  Synopsis:   Converts a bit-stream flags field into a ULONG
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

ULONG
KerbConvertFlagsToUlong(
    IN PVOID Flags
    )
{
    ULONG Output = 0;
    PUCHAR OutputPointer = &((PUCHAR) &Output)[3];
    ULONG Index = 0;
    PKERB_TICKET_FLAGS InternalFlags = (PKERB_TICKET_FLAGS) Flags;
    ULONG InternalLength;

    if (InternalFlags->length > 32)
    {
        InternalLength = 32;
    }
    else
    {
        InternalLength = (ULONG) InternalFlags->length;
    }

    while (InternalLength > 7)
    {
        *OutputPointer = InternalFlags->value[Index++];
        OutputPointer--;
        InternalLength -= 8;
    }

    //
    // Copy the remaining bits, masking off what should be zero
    //

    if (InternalLength != 0)
    {
        *OutputPointer = (UCHAR) (InternalFlags->value[Index] & ~((1 << (8-InternalLength)) - 1));
    }

    return(Output);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbConvertUlongToFlagUlong
//
//  Synopsis:   Converts the byte order of a ULONG into that used by flags
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

ULONG
KerbConvertUlongToFlagUlong(
    IN ULONG Flag
    )
{
    ULONG ReturnFlag;

    ((PUCHAR) &ReturnFlag)[0] = ((PUCHAR) &Flag)[3];
    ((PUCHAR) &ReturnFlag)[1] = ((PUCHAR) &Flag)[2];
    ((PUCHAR) &ReturnFlag)[2] = ((PUCHAR) &Flag)[1];
    ((PUCHAR) &ReturnFlag)[3] = ((PUCHAR) &Flag)[0];

    return(ReturnFlag);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbCompareObjectIds
//
//  Synopsis:   Compares two object IDs for equality
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

BOOLEAN
KerbCompareObjectIds(
    IN PKERB_OBJECT_ID Object1,
    IN PKERB_OBJECT_ID Object2
    )
{
    while (Object1 != NULL)
    {
        if (Object2 == NULL)
        {
            return(FALSE);
        }

        if (Object1->value != Object2->value)
        {
            return(FALSE);
        }

        Object1 = Object1->next;
        Object2 = Object2->next;
    }

    if (Object2 != NULL)
    {
        return(FALSE);
    }
    else
    {
        return(TRUE);
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   KdcGetClientNetbiosAddress
//
//  Synopsis:   Gets the client's netbios address from the list of
//              addresses it sends.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KerbGetClientNetbiosAddress(
    OUT PUNICODE_STRING ClientNetbiosAddress,
    IN PKERB_HOST_ADDRESSES Addresses
    )
{
    PKERB_HOST_ADDRESSES TempAddress = Addresses;
    STRING TempString;
    KERBERR KerbErr;

    RtlInitUnicodeString(
        ClientNetbiosAddress,
        NULL
        );

    while (TempAddress != NULL)
    {
        //
        // Check for netbios
        //

        if (TempAddress->value.address_type == KERB_ADDRTYPE_NETBIOS)
        {
            //
            // Copy out the string
            //

            TempString.Buffer = (PCHAR) TempAddress->value.address.value;
            TempString.Length = TempString.MaximumLength = (USHORT) TempAddress->value.address.length;

            KerbErr = KerbStringToUnicodeString(
                        ClientNetbiosAddress,
                        &TempString
                        );
            if (KERB_SUCCESS(KerbErr))
            {
                //
                // Strip trailing spaces
                //

                if (ClientNetbiosAddress->Length >= sizeof(WCHAR))
                {
                    while ((ClientNetbiosAddress->Length > 0) &&
                           (ClientNetbiosAddress->Buffer[(ClientNetbiosAddress->Length / sizeof(WCHAR))-1] == L' '))
                    {
                        ClientNetbiosAddress->Length -= sizeof(WCHAR);
                    }
                    return(KDC_ERR_NONE);
                }
            }
            else
            {
                return(KerbErr);
            }

        }

        TempAddress = TempAddress->next;
    }

    //
    // It is o.k. to not have a netbios name
    //

    return(KDC_ERR_NONE);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbGetPacFromAuthData
//
//  Synopsis:   Gets the PAC from the auth data list
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KerbGetPacFromAuthData(
    IN PKERB_AUTHORIZATION_DATA AuthData,
    OUT PKERB_IF_RELEVANT_AUTH_DATA ** ReturnIfRelevantData,
    OUT PKERB_AUTHORIZATION_DATA * Pac
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    PKERB_AUTHORIZATION_DATA PacAuthData = NULL;
    PKERB_AUTHORIZATION_DATA RelevantAuthData = NULL;
    PKERB_IF_RELEVANT_AUTH_DATA * IfRelevantData = NULL;

    *ReturnIfRelevantData = NULL;
    *Pac = NULL;

    //
    // Look for the if-relevant data
    //

    RelevantAuthData = KerbFindAuthDataEntry(
                        KERB_AUTH_DATA_IF_RELEVANT,
                        AuthData
                        );

    if (RelevantAuthData != NULL)
    {
        //
        // Unpack it
        //

        KerbErr = KerbUnpackData(
                    RelevantAuthData->value.auth_data.value,
                    RelevantAuthData->value.auth_data.length,
                    PKERB_IF_RELEVANT_AUTH_DATA_PDU,
                    (PVOID *) &IfRelevantData
                    );

        if (KERB_SUCCESS(KerbErr))
        {
            //
            // Look for the PAC in the if-relevant data
            //

            PacAuthData = KerbFindAuthDataEntry(
                            KERB_AUTH_DATA_PAC,
                            *IfRelevantData
                            );
        }
        else
        {
            //
            // We don't mind if we couldn't unpack it.
            // Tickets do not always have PAC information.
            //

            KerbErr = KDC_ERR_NONE;
        }
    }

    //
    // If we didn't find it in the if-relevant data, look outside
    //

    if (PacAuthData == NULL)
    {
        PacAuthData = KerbFindAuthDataEntry(
                          KERB_AUTH_DATA_PAC,
                          AuthData
                          );
    }

    //
    // Copy the PAC to return it
    //

    if (PacAuthData != NULL)
    {
        *Pac = PacAuthData;
    }

    *ReturnIfRelevantData = IfRelevantData;
    IfRelevantData = NULL;

    return(KerbErr);
}

#if DBG
#define KERB_DEBUG_WARN_LEVEL   0x0002

//+-------------------------------------------------------------------------
//
//  Function:   DebugDisplayTime
//
//  Synopsis:   Displays a FILETIME
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

void
DebugDisplayTime(
    IN ULONG DebugLevel,
    IN FILETIME *pFileTime
    )
{
    SYSTEMTIME SystemTime;

    if (DebugLevel & KERB_DEBUG_WARN_LEVEL)
    {
        FileTimeToSystemTime(pFileTime, &SystemTime);

        DebugLog((DEB_ERROR," %02d:%02d:%02d - %02d %02d %04d\n",
                 SystemTime.wHour,SystemTime.wMinute,SystemTime.wSecond,
                 SystemTime.wDay,SystemTime.wMonth,SystemTime.wYear));
    }
    return;
}
#endif


//+-------------------------------------------------------------------------
//
//  Function:   VerifyClientAddress
//
//  Synopsis:   Verifies that the client address is present in the address list
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:    TRUE if the address checks out OK, FALSE otherwise
//
//  Notes:
//
//
//--------------------------------------------------------------------------

BOOLEAN
KerbVerifyClientAddress(
    IN SOCKADDR * ClientAddress,
    IN PKERB_HOST_ADDRESSES Addresses
    )
{
    PKERB_HOST_ADDRESSES TempAddress = Addresses;
    BOOLEAN IpAddressesPresent = FALSE;

    //
    // ISSUE-2001/03/05-markpu
    // This routine is inadequate in that it only deals with IPv4
    // addresses.  Address matching has to be more elaborate than that.
    //

    while (TempAddress != NULL)
    {
        if ( TempAddress->value.address_type == KERB_ADDRTYPE_INET &&
             ClientAddress->sa_family == AF_INET )
        {
            struct sockaddr_in * InetAddress = (struct sockaddr_in *) ClientAddress;

            IpAddressesPresent = TRUE;

            //
            // Check that the addresses match
            //

            if (TempAddress->value.address.length == sizeof(ULONG))
            {
                if (RtlEqualMemory(
                        TempAddress->value.address.value,
                        &InetAddress->sin_addr.S_un.S_addr,
                        sizeof(ULONG)))
                {
                    return TRUE;
                }
            }
        }

        TempAddress = TempAddress->next;
    }

    D_DebugLog((DEB_WARN,"Client address not in address list\n"));

    //
    // If there were no IP addresses in the ticket, return TRUE, since we
    // probably are in a situation where only netbios addresses are in the
    // ticket, so the socket address matched none of them
    //

    return !IpAddressesPresent;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbCopyDomainRelativeSid
//
//  Synopsis:   Given a domain Id and a relative ID create the corresponding
//              SID at the location indicated by TargetSid
//
//  Effects:
//
//  Arguments:  TargetSid - target memory location
//              DomainId - The template SID to use.
//
//                  RelativeId - The relative Id to append to the DomainId.
//
//  Requires:
//
//  Returns:    Size - Size of the sid copied
//
//  Notes:
//
//
//--------------------------------------------------------------------------

DWORD
KerbCopyDomainRelativeSid(
    OUT PSID TargetSid,
    IN PSID  DomainId,
    IN ULONG RelativeId
    )
{
    UCHAR DomainIdSubAuthorityCount;
    ULONG Size;

    //
    // Allocate a Sid which has one more sub-authority than the domain ID.
    //

    DomainIdSubAuthorityCount = *(RtlSubAuthorityCountSid( DomainId ));
    Size = RtlLengthRequiredSid(DomainIdSubAuthorityCount+1);

    //
    // Initialize the new SID to have the same inital value as the
    // domain ID.
    //

    if ( !NT_SUCCESS( RtlCopySid( Size, TargetSid, DomainId ) ) ) {

        return 0;
    }

    //
    // Adjust the sub-authority count and
    //  add the relative Id unique to the newly allocated SID
    //

    (*(RtlSubAuthorityCountSid( TargetSid ))) ++;
    *RtlSubAuthoritySid( TargetSid, DomainIdSubAuthorityCount ) = RelativeId;

    return Size;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbHashS4UPreauth
//
//  Synopsis:   Given a domain Id and a relative ID create the corresponding
//              SID at the location indicated by TargetSid
//
//  Effects:
//
//  Arguments:  TargetSid - target memory location
//              DomainId - The template SID to use.
//
//                  RelativeId - The relative Id to append to the DomainId.
//
//  Requires:
//
//  Returns:    Size - Size of the sid copied
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbHashS4UPreauth(
    IN PKERB_PA_FOR_USER S4UPreauth,
    IN PKERB_ENCRYPTION_KEY Key,
    IN LONG ChecksumType,
    IN OUT PKERB_CHECKSUM CheckSum
    )
{
    NTSTATUS Status;

    PCHECKSUM_FUNCTION MD5Check = NULL;
    PCHECKSUM_BUFFER MD5ScratchBuffer = NULL;
    PKERB_PRINCIPAL_NAME_name_string TmpName = S4UPreauth->userName.name_string;

    //
    // Locate the MD5 Hash Function
    //

    Status = CDLocateCheckSum(ChecksumType, &MD5Check);

    if( !NT_SUCCESS(Status) )
    {
        D_DebugLog( (DEB_ERROR,
                   "Failure Locating MD5: 0x%x.\n",
                   Status));

        goto Cleanup;
    }

    //
    // Initialize the HMAC using the TGT session key
    //

    if (NULL != MD5Check->InitializeEx2)
    {
        Status = MD5Check->InitializeEx2(
                       Key->keyvalue.value,
                       Key->keyvalue.length,
                       NULL,
                       KERB_NON_KERB_CKSUM_SALT,
                       &MD5ScratchBuffer
                       );
    }
    else
    {
        Status = MD5Check->InitializeEx(
                       Key->keyvalue.value,
                       Key->keyvalue.length,
                       KERB_NON_KERB_CKSUM_SALT,
                       &MD5ScratchBuffer
                       );
    }

    if( !NT_SUCCESS(Status) )
    {
        D_DebugLog((DEB_ERROR,"Failure initializing MD5HMAC: 0x%x.\n",Status));
        goto Cleanup;
    }

    //
    // Build the MD5 hash
    //

    //
    // Pull in client realm name.
    //

    Status = MD5Check->Sum(
                       MD5ScratchBuffer,
                       sizeof(DWORD),
                       (PUCHAR) &S4UPreauth->userName.name_type
                       );

    if( !NT_SUCCESS(Status) )
    {
        D_DebugLog((DEB_ERROR,"Failure building MD5: 0x%x.\n",Status));
        goto Cleanup;
    }

    if (TmpName->value == NULL)
    {
        DsysAssert(FALSE);
        goto Cleanup;
    }

    do
    {
        Status = MD5Check->Sum(
                            MD5ScratchBuffer,
                            lstrlenA( TmpName->value ),
                            (PUCHAR) TmpName->value
                            );

        if( !NT_SUCCESS(Status) )
        {
            D_DebugLog((DEB_ERROR,"Failure building MD5: 0x%x.\n",Status));
            goto Cleanup;
        }

        TmpName = TmpName->next;

    } while ( TmpName != NULL );

    //
    // Then the client realm
    //

    Status = MD5Check->Sum(
                        MD5ScratchBuffer,
                        lstrlenA( S4UPreauth->userRealm ),
                        (PUCHAR) S4UPreauth->userRealm
                        );
 
    if( !NT_SUCCESS(Status) )
    {
        D_DebugLog((DEB_ERROR,"Failure building MD5: 0x%x.\n",Status));
        goto Cleanup;
    }
 
    //
    // Authentication package.
    //

    Status = MD5Check->Sum(
                        MD5ScratchBuffer,
                        lstrlenA( S4UPreauth->authentication_package ),
                        (PUCHAR) S4UPreauth->authentication_package
                        );
 
    if( !NT_SUCCESS(Status) )
    {
        D_DebugLog( (DEB_ERROR,"Failure building MD5: 0x%x.\n",Status));
        goto Cleanup;
    }
 
    if ( S4UPreauth->bit_mask & KERB_PA_FOR_USER_authorization_data_present )
    {
        //
        // Hash authorization data.
        //
 
        Status = MD5Check->Sum(
                        MD5ScratchBuffer,
                        S4UPreauth->authorization_data.length,
                        (PUCHAR) S4UPreauth->authorization_data.value
                        );
 
        if( !NT_SUCCESS(Status) )
        {
            D_DebugLog( (DEB_ERROR,"Failure building MD5: 0x%x.\n",Status));
            goto Cleanup;
        }
    }
 
    //
    // Copy the hash results into the checksum field
    //

    CheckSum->checksum_type = ChecksumType;
    CheckSum->checksum.length = MD5Check->CheckSumSize;
 
    Status = MD5Check->Finalize(
                        MD5ScratchBuffer,
                        CheckSum->checksum.value
                        );
 
    if ( !NT_SUCCESS(Status) )
    {
        D_DebugLog( (DEB_ERROR,"Failure FINALIZING MD5: 0x%x.\n",Status));
        goto Cleanup;
    }
 
 Cleanup:
 
    if ( MD5Check != NULL )
    {
        MD5Check->Finish( &MD5ScratchBuffer );
    }
 
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\common2\sockets.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       sockets.cxx
//
//  Contents:   Code for kerberos client sockets
//
//  Classes:
//
//  Functions:
//
//  History:    26-Jul-1996     MikeSw          Created
//
//----------------------------------------------------------------------------

#ifdef WIN32_CHICAGO
#include <kerb.hxx>
#include <kerbp.h>
#endif // WIN32_CHICAGO

#ifndef WIN32_CHICAGO
extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#ifndef WIN32_CHICAGO
#include <winsock2.h>
#else // WIN32_CHICAGO
#include <winsock.h>
#endif // WIN32_CHICAGO
#include <dsgetdc.h>
}
#include <kerbcomm.h>
#include <kerberr.h>
#include <kerbcon.h>
#include <midles.h>
#include <authen.hxx>
#include "debug.h"
#else // WIN32_CHICAGO
extern "C"
{
#include <winsock.h>
}
#endif // WIN32_CHICAGO


LONG SocketStarts = -1;
ULONG TcpFragLength = 0x7fffffff ;
ULONG TcpFragDelay = 0 ;

//+-------------------------------------------------------------------------
//
//  Function:   KerbInitializeSockets
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbInitializeSockets(
    IN WORD VersionRequired,
    IN ULONG MinSockets,
    OUT BOOLEAN *TcpNotInstalled
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    int Error;
    WSADATA SocketData;
#ifndef WIN32_CHICAGO
    WSAPROTOCOL_INFO *lpProtocolBuf = NULL;
    DWORD dwBufLen = 0;
    INT protocols[2];
    int nRet = 0;
#endif // WIN32_CHICAGO

    //
    // Initialze sockets
    //

    *TcpNotInstalled = FALSE;

    if (InterlockedIncrement(&SocketStarts) != 0)
    {
        return(STATUS_SUCCESS);
    }

    Error = WSAStartup(VersionRequired, &SocketData);
    if (Error != 0)
    {
        DebugLog((DEB_ERROR,"WSAStartup failed: 0x%x\n",Error));
        Status = STATUS_NO_LOGON_SERVERS;
        goto Cleanup;
    }


    //
    // Make sure the version is high enough for us
    //

    if ((LOBYTE(SocketData.wVersion) < HIBYTE(VersionRequired)) ||
        (((LOBYTE(SocketData.wVersion) == HIBYTE(VersionRequired)) &&
         (HIBYTE(SocketData.wVersion) < LOBYTE(VersionRequired)))))
    {
        DebugLog((DEB_ERROR,"Invalid socket version: wanted 0x%x, got 0x%x\n",
            VersionRequired, SocketData.wVersion));
        Status = STATUS_NO_LOGON_SERVERS;
        goto Cleanup;
    }

    if (SocketData.iMaxSockets < MinSockets)
    {
        DebugLog((DEB_ERROR,"Not enough sockets available: wanted %d, got %d\n",
            MinSockets, SocketData.iMaxSockets ));
        Status = STATUS_NO_LOGON_SERVERS;
        goto Cleanup;
    }

#ifndef WIN32_CHICAGO
    //
    // Check if TCP is an available xport
    //

    protocols[0] = IPPROTO_TCP;                                             
    protocols[1] = NULL;                                                    
    nRet = WSAEnumProtocols(protocols, lpProtocolBuf, &dwBufLen);           
    if (nRet == 0)                                                          
    {                                                                       
        //                                                                  
        // Tcp is not installed as a xport.                                 
        //                                                                  
                                                                        
        D_DebugLog((DEB_T_SOCK,"WSAEnumProtocols returned 0x%x.\n", nRet));
        *TcpNotInstalled = TRUE;                                             
    }
#endif // WIN32_CHICAGO
Cleanup:
    if (!NT_SUCCESS(Status))
    {
        if (SocketStarts != -1)
        {
            WSACleanup();
            InterlockedDecrement(&SocketStarts);
        }
    }
    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbCleanupSockets
//
//  Synopsis:   Cleansup socket handling code
//
//  Effects:    calls WSACleanup()
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KerbCleanupSockets(
    )
{
    if (InterlockedDecrement(&SocketStarts) < 0)
    {
        WSACleanup();
    }

}


//+-------------------------------------------------------------------------
//
//  Function:   KerbCloseSocket
//
//  Synopsis:   Closes a socket binding handle
//
//  Effects:    calls closesocket on the handle
//
//  Arguments:  SocketHandle - handle to close
//
//  Requires:
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbCloseSocket(
    IN SOCKET SocketHandle
    )
{
    int SockError;
    if (SocketHandle != 0)
    {
        SockError = closesocket(SocketHandle);
        if (SockError != 0)
        {
            DebugLog((DEB_ERROR,"CloseSocket failed: last error = %d\n",WSAGetLastError()));
        }
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbBindSocketByAddress
//
//  Synopsis:   Binds to the KDC socket on the specified address
//
//  Effects:
//
//  Arguments:  Address - Address to bind to
//              AddressType - Address type, as specified by DC locator
//              ContextHandle - Receives bound socket
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbBindSocketByAddress(
    IN PUNICODE_STRING Address,
    IN ULONG AddressType,
    IN BOOLEAN UseDatagram,
    IN USHORT PortNumber,
    OUT SOCKET * ContextHandle
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    SOCKET ClientSocket = INVALID_SOCKET;
    struct sockaddr_in ServerAddress;
    struct sockaddr_in ClientAddress;
    LPHOSTENT ServerInfo = NULL;
    STRING AnsiAddress = {0};

    AnsiAddress.Buffer = NULL;

    Status = RtlUnicodeStringToAnsiString(
                &AnsiAddress,
                Address,
                TRUE
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    ClientSocket = socket(
                    PF_INET,
                    (UseDatagram ? SOCK_DGRAM : SOCK_STREAM),
                    0
                    );
    if (ClientSocket == INVALID_SOCKET)
    {
        DebugLog((DEB_ERROR,"Failed to create socket: %d\n",WSAGetLastError()));
        Status = STATUS_NO_LOGON_SERVERS;
        goto Cleanup;
    }

    if (UseDatagram)
    {
        //
        // Bind client socket to any local interface and port
        //

        ClientAddress.sin_family = AF_INET;
        ClientAddress.sin_addr.s_addr = INADDR_ANY;
        ClientAddress.sin_port = 0;                 // no specific port

        if (bind(
                ClientSocket,
                (LPSOCKADDR) &ClientAddress,
                sizeof(ClientAddress)
                ) == SOCKET_ERROR )
        {
            DebugLog((DEB_ERROR,"Failed to bind client socket: %d\n",WSAGetLastError()));
            Status = STATUS_NO_LOGON_SERVERS;
            goto Cleanup;
        }
    }

    if (AddressType == DS_INET_ADDRESS)
    {
        ULONG InetAddress;
        //
        // Get the address of the server
        //

        InetAddress = inet_addr(AnsiAddress.Buffer);


        if (InetAddress == SOCKET_ERROR)
        {
            DebugLog((DEB_ERROR,"Failed to convert %Z to address: %d\n", &AnsiAddress, WSAGetLastError()));
            Status = STATUS_NO_LOGON_SERVERS;
            goto Cleanup;
        }

        ServerAddress.sin_family = AF_INET;

        RtlCopyMemory(
            &ServerAddress.sin_addr,
            &InetAddress,
            sizeof(ULONG)
            );

    }
    else
    {
        //
        // Get the address of the server
        //

        ServerInfo = gethostbyname(AnsiAddress.Buffer);
        if (ServerInfo == NULL)
        {
            DebugLog((DEB_ERROR,"Failed to get host %Z by name: %d\n", &AnsiAddress, WSAGetLastError()));
            Status = STATUS_NO_LOGON_SERVERS;
            goto Cleanup;
        }

        ServerAddress.sin_family = ServerInfo->h_addrtype;

        RtlCopyMemory(
            &ServerAddress.sin_addr,
            ServerInfo->h_addr,
            sizeof(ULONG)
            );

    }

    ServerAddress.sin_port = htons(PortNumber);

    if (connect(
            ClientSocket,
            (LPSOCKADDR) &ServerAddress,
            sizeof(ServerAddress)
            ) == SOCKET_ERROR)
    {
        DebugLog((DEB_ERROR,"Failed to connect to server %Z: %d\n",&AnsiAddress, WSAGetLastError()));
        Status = STATUS_NO_LOGON_SERVERS;
        goto Cleanup;
    }
    *ContextHandle = ClientSocket;
    D_DebugLog((DEB_TRACE,"Successfully bound to %Z\n",&AnsiAddress));

Cleanup:
    if (AnsiAddress.Buffer != NULL)
    {
        RtlFreeAnsiString(&AnsiAddress);
    }
    if (!NT_SUCCESS(Status))
    {
        if (ClientSocket != INVALID_SOCKET)
        {
            closesocket(ClientSocket);
        }
    }
    return(Status);


}


//+-------------------------------------------------------------------------
//
//  Function:   KerbCallKdc
//
//  Synopsis:   Socket client stub for calling the KDC.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

extern ULONG KerbGlobalMaxDatagramSize;

NTSTATUS
KerbCallKdc(
    IN PUNICODE_STRING KdcAddress,
    IN ULONG AddressType,
    IN ULONG Timeout,
    IN BOOLEAN UseDatagram,
    IN USHORT PortNumber,
    IN PKERB_MESSAGE_BUFFER Input,
    OUT PKERB_MESSAGE_BUFFER Output
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG Bytes;
    int NumberReady;
    SOCKET Socket = 0;
    PUCHAR RemainingBuffer;
    ULONG RemainingSize;
    fd_set ReadHandles;
    struct timeval TimeoutTime;
    ULONG NetworkSize;
    BOOLEAN RetriedOnce = FALSE;

#ifndef WIN32_CHICAGO
    WSABUF Buffers[2] = {0};
    LPWSABUF SendBuffers = NULL;
    ULONG BufferCount = 0;
    int SendStatus;
#endif // WIN32_CHICAGO

    //
    // Start out by binding to the KDC
    //

    DebugLog((DEB_TRACE, "Calling KDC: %S\n", KdcAddress->Buffer));

    Status = KerbBindSocketByAddress(
                KdcAddress,
                AddressType,
                UseDatagram,
                PortNumber,
                &Socket
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    RemainingBuffer = Input->Buffer;
    RemainingSize = Input->BufferSize;

#ifndef WIN32_CHICAGO

    //
    // Use winsock2
    //

    Buffers[0].len = sizeof(ULONG);
    NetworkSize = htonl(RemainingSize);
    Buffers[0].buf = (PCHAR) &NetworkSize;
    Buffers[1].len = Input->BufferSize;
    Buffers[1].buf = (PCHAR) Input->Buffer;

    if (UseDatagram)
    {
        BufferCount = 1;
        SendBuffers = &Buffers[1];
        RemainingSize = Buffers[1].len;
    }
    else
    {
        BufferCount = 2;
        SendBuffers = &Buffers[0];
        RemainingSize = Buffers[0].len + Buffers[1].len;
    }

RetrySend:

    SendStatus = WSASend(
                    Socket,
                    SendBuffers,
                    BufferCount,
                    &Bytes,
                    0,          // no flags
                    NULL,               // no overlapped
                    NULL                // no completion routine
                    );

    if ((SendStatus != 0) || (Bytes == 0))
    {
        DsysAssert(SendStatus == SOCKET_ERROR);
        DebugLog((DEB_ERROR,"Failed to send data: %d\n",WSAGetLastError()));
        Status = SEC_E_NO_AUTHENTICATING_AUTHORITY;
        goto Cleanup;
    }
    if (Bytes < RemainingSize)
    {
        RemainingSize -= Bytes;
        if (Bytes > SendBuffers->len)
        {
            //
            // We sent the whole of a buffer, so move on to the next
            //

            Bytes -= SendBuffers->len;

            DsysAssert(BufferCount > 1);
            BufferCount--;
            SendBuffers++;
            SendBuffers->len -= Bytes;
            SendBuffers->buf += Bytes;
        }
        else
        {
            SendBuffers->len -= Bytes;
            SendBuffers->buf += Bytes;
        }
        goto RetrySend;
    }




#else // WIN32_CHICAGO

    //
    // Use winsock1 for win9x
    //

    //
    // For TCP, send length first
    //

RetrySend:

    if (!UseDatagram)
    {
        NetworkSize = htonl(RemainingSize);
        Bytes = send(Socket, (char *)&NetworkSize,sizeof(ULONG), 0);
        if (Bytes != sizeof(ULONG) )
        {
            DebugLog((DEB_ERROR,"Failed to send TCP packet length: bytes sent = %d, last err = %d\n",
                Bytes,
                WSAGetLastError()));
            Status = SEC_E_NO_AUTHENTICATING_AUTHORITY;
            goto Cleanup;
        }
    }
    do
    {
        if (!UseDatagram)
        {
            if ( RemainingSize > TcpFragLength )
            {
                SendSize = TcpFragLength ;
            }
            else
            {
                SendSize = RemainingSize ;
            }
            if ( TcpFragDelay )
            {
                Sleep( TcpFragDelay );
            }
        }
        else
        {
            SendSize = RemainingSize ;
        }
        D_DebugLog(( DEB_T_SOCK, "Sending %x bytes to %wZ\n",
                        SendSize, KdcAddress ));
        Bytes = send(Socket, (char *) RemainingBuffer, SendSize, 0);
        if (Bytes == SOCKET_ERROR)
        {
            DebugLog((DEB_ERROR,"Failed to send data: %d\n",WSAGetLastError()));
            Status = SEC_E_NO_AUTHENTICATING_AUTHORITY;
            goto Cleanup;
        }
        if (Bytes != SendSize)
        {
            DebugLog((DEB_ERROR,"Failed to send all data - only send %d out of %d\n",
                Bytes, RemainingSize ));
            Status = SEC_E_NO_AUTHENTICATING_AUTHORITY;
            goto Cleanup;
        }
        RemainingBuffer += Bytes;
        RemainingSize -= Bytes;
    } while ((Bytes != 0) && (RemainingSize != 0));

#endif

    //
    // Now select on the socket and wait for a response
    // ReadHandles and TimeoutTime must be reset each time, cause winsock
    // zeroes them out in case of error

    ReadHandles.fd_count = 1;
    ReadHandles.fd_array[0] = Socket;
    TimeoutTime.tv_sec = Timeout;
    TimeoutTime.tv_usec = 0;

    D_DebugLog(( DEB_T_SOCK, "Socket being used for select is 0x%x\n", ReadHandles.fd_array[0] ));
    NumberReady = select(
                    1,
                    &ReadHandles,
                    NULL,
                    NULL,
                    &TimeoutTime
                    );
    if ((NumberReady == SOCKET_ERROR) ||
        (NumberReady == 0))
    {

        DebugLog((DEB_ERROR,"Failed to select on response on socket 0x%x from kdc: %d\n", ReadHandles.fd_array[0], WSAGetLastError()));

        DebugLog((DEB_ERROR,"select returned  %d\n",NumberReady));

        //
        // Retry again and wait.
        //

        if ((NumberReady == 0) && (!RetriedOnce))
        {
            RetriedOnce = TRUE;
            goto RetrySend;
        }
        Status = STATUS_NO_LOGON_SERVERS;
        goto Cleanup;
    }


    //
    // Now receive the data
    //

    if (UseDatagram)
    {
        Output->BufferSize = max( KerbGlobalMaxDatagramSize,  KERB_MAX_KDC_RESPONSE_SIZE );
        Output->Buffer = (PUCHAR) MIDL_user_allocate(Output->BufferSize);
        if (Output->Buffer == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        Bytes = recv(
                    Socket,
                    (char *) Output->Buffer,
                    Output->BufferSize,
                    0
                    );
        if ((Bytes == SOCKET_ERROR) || (Bytes == 0))
        {
            DebugLog((DEB_ERROR,"Failed to receive socket data: %d\n",WSAGetLastError()));
            Status = SEC_E_NO_AUTHENTICATING_AUTHORITY;
            goto Cleanup;
        }
        Output->BufferSize = Bytes;
    }
    else
    {
        Bytes = recv(
                    Socket,
                    (char *) &NetworkSize,
                    sizeof(ULONG),
                    0
                    );
        if (Bytes != sizeof(ULONG) )
        {
            DebugLog((DEB_ERROR,"Failed to receive socket data: %d\n",WSAGetLastError()));
            Status = SEC_E_NO_AUTHENTICATING_AUTHORITY;
            goto Cleanup;
        }
        RemainingSize = ntohl(NetworkSize);
        Output->BufferSize = RemainingSize;
        Output->Buffer = (PUCHAR) MIDL_user_allocate(RemainingSize);
        if (Output->Buffer == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        while (RemainingSize != 0)
        {
            //
            // Make sure there is data ready
            //

            D_DebugLog(( DEB_T_SOCK, "Socket being used for select is 0x%x\n", ReadHandles.fd_array[0] ));
            NumberReady = select(
                            1,
                            &ReadHandles,
                            NULL,
                            NULL,
                            &TimeoutTime
                            );
            if ((NumberReady == SOCKET_ERROR) ||
                (NumberReady == 0))
            {
                DebugLog((DEB_ERROR,"Failed to select on response on socket 0x%x from kdc: %d\n", ReadHandles.fd_array[0], WSAGetLastError()));

                DebugLog((DEB_ERROR,"select returned  %d\n",NumberReady));

                Status = STATUS_NO_LOGON_SERVERS;
                goto Cleanup;
            }

            //
            // Receive the data
            //

            Bytes = recv(
                        Socket,
                        (char *) Output->Buffer + Output->BufferSize - RemainingSize,
                        RemainingSize,
                        0
                        );
            if ((Bytes == SOCKET_ERROR) || (Bytes == 0))
            {
                DebugLog((DEB_ERROR,"Failed to receive socket data: %d\n",WSAGetLastError()));
                Status = SEC_E_NO_AUTHENTICATING_AUTHORITY;
                goto Cleanup;
            }
            RemainingSize -= Bytes;
        }
    }

Cleanup:
    if (Socket != 0)
    {
        KerbCloseSocket(Socket);
    }
    if (!NT_SUCCESS(Status))
    {
        if (Output->Buffer != NULL)
        {
            MIDL_user_free(Output->Buffer);
            Output->Buffer = NULL;
        }
    }
    return(Status);



}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\idl\pacimp.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1993
//
// File:        pacimp.h
//
// Contents:    imports for pac.idl
//
//
// History:     4-Aug-1993      MikeSw  Created
//
//------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <lsass.h>
#include <windef.h>
#include <winbase.h>
#include <crypt.h>
#include <lmcons.h>
#include <ntmsv1_0.h>
#include <logonmsv.h>
#define SECURITY_PACKAGE
#include <security.h>
#include <secint.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\idl\secimp.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1993
//
// File:        secimp.h
//
// Contents:    imports for security .idl files
//
//
// History:     4-Aug-1993      MikeSw  Created
//
//------------------------------------------------------------------------

#include <nt.h>
#include <security.h>
#include <kerbcred.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\common2\utils.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        utils.cxx
//
//  Contents:   utilities
//
//  History:    LZhu   Feb 1, 2002 Created
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef WIN32_CHICAGO
#include<kerb.hxx>
#include<kerbp.h>
#endif // WIN32_CHICAGO

extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntlsa.h>
#include <samrpc.h>
#include <samisrv.h>
#include <lsarpc.h>
#include <lsaisrv.h>
#include <lsaitf.h>
#include <wincrypt.h>
}
#include <kerbcomm.h>
#include <kerberr.h>
#include <kerbcon.h>
#include <midles.h>
#include <authen.hxx>
#include <kerberos.h>
#include "debug.h"
#include <fileno.h>
#include <pac.hxx>
#include <utils.hxx>

#define FILENO  FILENO_COMMON_UTILS

//+-------------------------------------------------------------------------
//
//  Function: KerbUnpackErrorData
//
//  Synopsis: This routine unpacks error information from a KERB_ERROR message
//
//  Effects:
//
//  Arguments: Unpacked error data.  Returns extended error to
//             be freed using KerbFreeData with KERB_EXT_ERROR_PDU
//
//  Requires:
//
//  Returns:  KERB_ERROR
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KerbUnpackErrorData(
   IN OUT PKERB_ERROR ErrorMessage,
   IN OUT PKERB_EXT_ERROR * ExtendedError
   )
{
    KERBERR KerbErr = KDC_ERR_NONE;

    TYPED_DATA_Element* TypedDataElem = NULL;


    TYPED_DATA_Element* ErrorData = NULL;
    KERB_ERROR_METHOD_DATA* ErrorMethodData = NULL;

    UCHAR* ExtErrTemp = NULL; // need to free it

    UCHAR* ExtErr = NULL;
    ULONG ExtErrSize = 0;

    *ExtendedError = NULL;

    if ((ErrorMessage->bit_mask & error_data_present) == 0)
    {
        KerbErr = (KRB_ERR_GENERIC);
        goto Cleanup;
    }

    KerbErr = KerbUnpackData(
                ErrorMessage->error_data.value,
                ErrorMessage->error_data.length,
                TYPED_DATA_PDU,
                (VOID**) &ErrorData
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        //
        // we do not use error method data from kdc any more, but need to watch
        // for those slipped into clients with ServicePacks
        //

        DebugLog((DEB_WARN, "KerbUnpackData failed to unpack typed data, trying error method data\n"));

        KerbErr = KerbUnpackData(
                    ErrorMessage->error_data.value,
                    ErrorMessage->error_data.length,
                    KERB_ERROR_METHOD_DATA_PDU,
                    (VOID**) &ErrorMethodData
                    );

        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }

        if ((ErrorMethodData->bit_mask & data_value_present)
            && (KERB_ERR_TYPE_EXTENDED == ErrorMethodData->data_type)
            && ErrorMethodData->data_value.length >= sizeof(KERB_EXT_ERROR))
        {
            //
            // pack the raw data
            //

            KerbErr = KerbPackData(
                        ErrorMethodData->data_value.value,
                        KERB_EXT_ERROR_PDU,
                        &ExtErrSize,
                        &ExtErrTemp
                        );
            if (!KERB_SUCCESS(KerbErr))
            {
                goto Cleanup;
            }

            ExtErr = ExtErrTemp;
        }
    }
    else
    {
        TypedDataElem = TypedDataListFind(ErrorData, TD_EXTENDED_ERROR);
        if (TypedDataElem)
        {
            ExtErrSize = TypedDataElem->value.data_value.length;
            ExtErr = TypedDataElem->value.data_value.value;
        }

        if ((KDC_ERR_S_PRINCIPAL_UNKNOWN == ErrorMessage->error_code)
            && (NULL != TypedDataListFind(ErrorData, TD_MUST_USE_USER2USER)))
        {
            DebugLog((DEB_WARN, "KerbUnpackData remap KDC_ERR_S_PRINCIPAL_UNKNOWN to KDC_ERR_MUST_USE_USER2USER\n"));

            ErrorMessage->error_code = KDC_ERR_MUST_USE_USER2USER;
        }
    }

    if (ExtErr && ExtErrSize)
    {
        KerbErr = KerbUnpackData(
                    ExtErr,
                    ExtErrSize,
                    KERB_EXT_ERROR_PDU,
                    (VOID**)ExtendedError
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }
    }

    if (*ExtendedError)
    {
        DebugLog((DEB_ERROR, "KerbUnpackErrorData received failure from kdc %#x KLIN(%#x) NTSTATUS(%#x)\n",
            ErrorMessage->error_code, (*ExtendedError)->klininfo, (*ExtendedError)->status));
    }

Cleanup:

    if (NULL != ErrorMethodData)
    {
        KerbFreeData(KERB_ERROR_METHOD_DATA_PDU, ErrorMethodData);
    }

    if (NULL != ErrorData)
    {
        KerbFreeData(TYPED_DATA_PDU, ErrorData);
    }

    if (NULL != ExtErrTemp)
    {
        MIDL_user_free(ExtErrTemp);
    }

    return (KerbErr);
}

//+-------------------------------------------------------------------------
//
//  Function:   TypedDataListFind
//
//  Synopsis:   find a kerb typed data from a type data list
//
//  Effects:    none
//
//  Arguments:
//
//  Requires:
//
//  Returns:    TYPED_DATA_Element that is found, NULL otherwise
//
//  Notes:
//
//
//--------------------------------------------------------------------------

TYPED_DATA_Element*
TypedDataListFind(
    IN OPTIONAL TYPED_DATA_Element* InputDataList,
    IN LONG Type
    )
{
    for (TYPED_DATA_Element* p = InputDataList; p != NULL; p = p->next)
    {
        if (p->value.data_type == Type)
        {
            return p;
        }
    }

    return NULL;
}

//+-------------------------------------------------------------------------
//
//  Function:   TypedDataListPushFront
//
//  Synopsis:   Insert a kerb typed data to a type data list
//
//  Effects:    none
//
//  Arguments:
//
//  Requires:
//
//  Returns:    KERBERR
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
TypedDataListPushFront(
    IN OPTIONAL TYPED_DATA_Element* InputDataList,
    IN KERB_TYPED_DATA* Data,
    OUT ULONG* OutputDataListSize,
    OUT UCHAR** OutputDataList
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;

    TYPED_DATA_Element TypedDataElem = {0};
    TYPED_DATA_Element* TypedDataList = &TypedDataElem;

    TypedDataElem.value = *Data;
    TypedDataElem.next = InputDataList;

    KerbErr = KerbPackData(
                &TypedDataList,
                TYPED_DATA_PDU,
                OutputDataListSize,
                OutputDataList
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        D_DebugLog((DEB_ERROR, "KdcGetTicket faild to pack error data as typed data %#x\n", KLIN(FILENO, __LINE__)));
        goto Cleanup;
    }

Cleanup:

    return KerbErr;
}

//+-------------------------------------------------------------------------
//
//  Function:   PackUnicodeStringAsUnicodeStringZ
//
//  Synopsis:   Pack a unicode string as null-terminated
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//-------------------------------------------------------------------------

VOID
PackUnicodeStringAsUnicodeStringZ(
    IN UNICODE_STRING* pString,
    IN OUT WCHAR** ppWhere,
    OUT UNICODE_STRING* pDestString
    )
{
    RtlCopyMemory(*ppWhere, pString->Buffer, pString->Length);
    pDestString->Buffer = *ppWhere;

    pDestString->Length = pString->Length;
    pDestString->MaximumLength = pString->Length + sizeof(WCHAR);

    *ppWhere +=  pDestString->MaximumLength / sizeof(WCHAR);

    //
    // add unicode NULL
    //

    pDestString->Buffer[(pDestString->MaximumLength / sizeof(WCHAR)) - 1] = UNICODE_NULL;
}

//+-------------------------------------------------------------------------
//
//  Function:   PackS4UDelegationInformation
//
//  Synopsis:   Pack S4U DelegationInformation
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//-------------------------------------------------------------------------

NTSTATUS
PackS4UDelegationInformation(
    IN OPTIONAL PS4U_DELEGATION_INFO DelegationInfo,
    OUT PS4U_DELEGATION_INFO* NewDelegationInfo
    )
{
    ULONG NewDelegationInfoSize = 0;
    WCHAR* Where = NULL;

    *NewDelegationInfo = NULL;
    if (DelegationInfo)
    {
        NewDelegationInfoSize = ROUND_UP_COUNT(sizeof(S4U_DELEGATION_INFO), ALIGN_QUAD)
            + ROUND_UP_COUNT(DelegationInfo->S4U2proxyTarget.Length + sizeof(WCHAR), ALIGN_QUAD);

        if (DelegationInfo->TransitedListSize)
        {
            NewDelegationInfoSize += ROUND_UP_COUNT(NewDelegationInfoSize, ALIGN_QUAD);

            for (ULONG i = 0; i < DelegationInfo->TransitedListSize; i++)
            {
                NewDelegationInfoSize += ROUND_UP_COUNT(sizeof(UNICODE_STRING), ALIGN_QUAD)
                    + ROUND_UP_COUNT(DelegationInfo->S4UTransitedServices[i].Length + sizeof(WCHAR), ALIGN_QUAD);
            }
        }

        *NewDelegationInfo = (PS4U_DELEGATION_INFO) MIDL_user_allocate(NewDelegationInfoSize);

        if (NULL == *NewDelegationInfo)
        {
            return STATUS_NO_MEMORY;
        }

        RtlZeroMemory(*NewDelegationInfo, NewDelegationInfoSize);
        Where = (WCHAR*) (*NewDelegationInfo + 1);
        PackUnicodeStringAsUnicodeStringZ(&DelegationInfo->S4U2proxyTarget, &Where, &(*NewDelegationInfo)->S4U2proxyTarget);

        (*NewDelegationInfo)->TransitedListSize = DelegationInfo->TransitedListSize;
        (*NewDelegationInfo)->S4UTransitedServices = (UNICODE_STRING*) ROUND_UP_POINTER(Where, ALIGN_QUAD);
        Where = (WCHAR*) ((*NewDelegationInfo)->S4UTransitedServices + DelegationInfo->TransitedListSize);

        for (ULONG j = 0; j < DelegationInfo->TransitedListSize; j++)
        {
            PackUnicodeStringAsUnicodeStringZ(
                &DelegationInfo->S4UTransitedServices[j],
                &Where,
                &(*NewDelegationInfo)->S4UTransitedServices[j]
                );
        }
    }

    return STATUS_SUCCESS;
}

//+-------------------------------------------------------------------------
//
//  Function:   PackS4UDelegationInformation
//
//  Synopsis:   Pack S4U DelegationInformation
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//-------------------------------------------------------------------------

NTSTATUS
UnmarshalS4UDelegationInformation(
    IN ULONG DelegInfoMarshalledSize,
    IN OPTIONAL BYTE* DelegInfoMarshalled,
    OUT PS4U_DELEGATION_INFO* S4UDelegationInfo
    )
{
    NTSTATUS Status;

    PS4U_DELEGATION_INFO RawDelegInfo = NULL;

    Status = PAC_UnmarshallS4UDelegationInfo(
                &RawDelegInfo,
                DelegInfoMarshalled,
                DelegInfoMarshalledSize
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "KdcUpdateAndValidateS4UProxyPAC failed to unmarshall S4U delgation info %#x\n", Status));
        goto Cleanup;
    }

    Status = PackS4UDelegationInformation(
                RawDelegInfo,
                S4UDelegationInfo
                );
    if (!NT_SUCCESS( Status ))
    {
        DebugLog((DEB_ERROR, "KdcUpdateAndValidateS4UProxyPAC: PackS4UDelegationInformation failed - %#x\n", Status));
        goto Cleanup;
    }

Cleanup:

    if (RawDelegInfo != NULL)
    {
        MIDL_user_free(RawDelegInfo);
    }

    return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbMapStatusToKerbError
//
//  Synopsis:   Maps an NTSTATUS or SECURITY_STATUS to a KERBERR
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KerbMapStatusToKerbError(
    IN LONG Status
    )
{
    KERBERR KerbError = KRB_ERR_GENERIC;
    switch (Status) {
    case SEC_E_ETYPE_NOT_SUPP:
        KerbError = KDC_ERR_ETYPE_NOTSUPP;
        break;
    case SEC_E_OK:
        KerbError = KDC_ERR_NONE;
        break;
     default:
        KerbError = KRB_ERR_GENERIC;
        break;
    }
    return KerbError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\exts\kerbexts.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:
//
// Contents:
//
//
// History:
//
//------------------------------------------------------------------------


extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
}
#include <stdio.h>

#include <wincred.h>
#include <ntsdexts.h>

#include <dsysdbg.h>
#define SECURITY_PACKAGE
#define SECURITY_WIN32
#include <security.h>
#include <secint.h>



#include <cryptdll.h>
#include <kerberos.h>
#include <..\client2\kerb.hxx>
#include <..\client2\kerbp.h>

typedef struct _KDC_DOMAIN_INFO {
    LIST_ENTRY Next;
    UNICODE_STRING DnsName;
    UNICODE_STRING NetbiosName;
    struct _KDC_DOMAIN_INFO * ClosestRoute;     // Points to referral target
    ULONG Flags;
    ULONG Attributes;
    ULONG Type;
    LONG References;

    //
    // Types used during building the tree
    //

    struct _KDC_DOMAIN_INFO * Parent;
    ULONG Touched;
} KDC_DOMAIN_INFO, *PKDC_DOMAIN_INFO;

#define AllocHeap(x)    RtlAllocateHeap(RtlProcessHeap(), HEAP_ZERO_MEMORY, x)
#define FreeHeap(x) RtlFreeHeap(RtlProcessHeap(), 0, x)

PNTSD_EXTENSION_APIS    pExtApis;
HANDLE                  hDbgThread;
HANDLE                  hDbgProcess;

#define DebuggerOut     (pExtApis->lpOutputRoutine)
#define GetExpr         (PVOID) (pExtApis->lpGetExpressionRoutine)
#define InitDebugHelp(hProc,hThd,pApis) {hDbgProcess = hProc; hDbgThread = hThd; pExtApis = pApis;}

char * ContextState[] = {
    "IdleState",
    "TgtRequestSentState",
    "TgtReplySentState",
    "ApRequestSentState",
    "ApReplySentState",
    "AuthenticatedState",
    "ErrorMessageSentState",
    "InvalidState"};

void PrintContextAttributes( ULONG Attributes)
{
    DebuggerOut("  ContextAttributes\t0x%lx:", Attributes);
    if (Attributes & KERB_CONTEXT_MAPPED)
    {
        DebuggerOut(" KERB_CONTEXT_MAPPED");
    }
    if (Attributes & KERB_CONTEXT_OUTBOUND)
    {
        DebuggerOut(" KERB_CONTEXT_OUTBOUND");
    }
    if (Attributes & KERB_CONTEXT_INBOUND)
    {
        DebuggerOut(" KERB_CONTEXT_INBOUND");
    }
    if (Attributes & KERB_CONTEXT_USED_SUPPLIED_CREDS)
    {
        DebuggerOut(" KERB_CONTEXT_USED_SUPPLIED_CREDS");
    }
    if (Attributes & KERB_CONTEXT_USER_TO_USER)
    {
        DebuggerOut(" KERB_CONTEXT_USER_TO_USER");
    }
    if (Attributes & KERB_CONTEXT_REQ_SERVER_NAME)
    {
        DebuggerOut(" KERB_CONTEXT_REQ_SERVER_NAME");
    }
    if (Attributes & KERB_CONTEXT_REQ_SERVER_REALM)
    {
        DebuggerOut(" KERB_CONTEXT_REQ_SERVER_REALM");
    }
    if (Attributes & KERB_CONTEXT_IMPORTED)
    {
        DebuggerOut(" KERB_CONTEXT_IMPORTED");
    }
    if (Attributes & KERB_CONTEXT_EXPORTED)
    {
        DebuggerOut(" KERB_CONTEXT_EXPORTED");
    }
    DebuggerOut("\n");
}
void PrintContextFlags ( ULONG Flags)
{
    DebuggerOut("  ContextFlags for 0x%lx are:\n", Flags);
    if (Flags & 0x00000001)
    {
        DebuggerOut("\tISC(ASC)_REQ(RET)_DELEGATE\n");
    }
    if (Flags & 0x00000002)
    {
        DebuggerOut("\tISC(ASC)_REQ(RET)_MUTUAL_AUTH\n");
    }
    if (Flags & 0x00000004)
    {
        DebuggerOut("\tISC(ASC)_REQ(RET)_REPLAY_DETECT\n");
    }
    if (Flags & 0x00000008)
    {
        DebuggerOut("\tISC(ASC)_REQ(RET)_SEQUENCE_DETECT\n");
    }
    if (Flags & 0x00000010)
    {
        DebuggerOut("\tISC(ASC)_REQ(RET)_CONFIDENTIALITY\n");
    }
    if (Flags & 0x00000020)
    {
        DebuggerOut("\tISC(ASC)_REQ(RET)_USE_SESSION_KEY\n");
    }
    if (Flags & 0x00000040)
    {
        DebuggerOut("\tISC_REQ_PROMPT_FOR_CREDS or ISC_RET_USED_COLLECTED_CREDS\n");
    }
    if (Flags & 0x00000080)
    {
        DebuggerOut("\tISC_REQ_USE_SUPPLIED_CREDS or ISC_RET_USED_SUPPLIED_CREDS\n");
    }
    if (Flags & 0x00000100)
    {
        DebuggerOut("\tISC(ASC)_REQ_ALLOCATE_MEMORY or ISC(ASC)_RET_ALLOCATED_MEMORY\n");
    }
    if (Flags & 0x00000200)
    {
        DebuggerOut("\tISC(ASC)_REQ_USE_DCE_STYLE or ISC(ASC)_RET_USED_DCE_STYLE\n");
    }
    if (Flags & 0x00000400)
    {
        DebuggerOut("\tISC(ASC)_REQ(RET)_DATAGRAM\n");
    }
    if (Flags & 0x00000800)
    {
        DebuggerOut("\tISC(ASC)_REQ(RET)_CONNECTION\n");
    }
    if (Flags & 0x00001000)
    {
        DebuggerOut("\tISC(ASC)_REQ_CALL_LEVEL or ISC_RET_INTERMEDIATE_RETURN\n");
    }
    if (Flags & 0x00002000)
    {
        DebuggerOut("\tISC(ASC)_RET_CALL_LEVEL\n");
    }
    if (Flags & 0x00004000)
    {
        DebuggerOut("\tISC_REQ(RET)_EXTENDED_ERROR or ASC_RET_THIRD_LEG_FAILED\n");
    }
    if (Flags & 0x00008000)
    {
        DebuggerOut("\tISC_REQ(RET)_STREAM or ASC_REQ(RET)_EXTENDED_ERROR\n");
    }
    if (Flags & 0x00010000)
    {
        DebuggerOut("\tISC_REQ(RET)_INTEGRITY or ASC_REQ(RET)_STREAM\n");
    }
    if (Flags & 0x00020000)
    {
        DebuggerOut("\tISC_REQ(RET)_IDENTIFY or ASC_REQ(RET)_INTEGRITY\n");
    }
    if (Flags & 0x00040000)
    {
        DebuggerOut("\tISC_REQ(RET)_NULL_SESSION or ASC_REQ(RET)_LICENSING\n");
    }
    if (Flags & 0x00080000)
    {
        DebuggerOut("\tISC_REQ(RET)_MANUAL_CRED_VALIDATION or ASC_REQ(RET)_IDENTIFY\n");
    }
    if (Flags & 0x00100000)
    {
        DebuggerOut("\tISC_REQ(RET)_DELEGATE_IF_SAFE or ASC_REQ_ALLOW_NULL_SESSION or ASC_RET_NULL_SESSION\n");
    }
    if (Flags & 0x00200000)
    {
        DebuggerOut("\tASC_REQ(RET)_ALLOW_NON_USER_LOGONS\n");
    }
    if (Flags & 0x00400000)
    {
        DebuggerOut("\tASC_REQ(RET)_ALLOW_CONTEXT_REPLAY\n");
    }
}
SECURITY_STATUS
ReadMemory( PVOID               pvAddress,
            ULONG               cbMemory,
            PVOID               pvLocalMemory)
{
    SIZE_T       cbActual = cbMemory;

    if (ReadProcessMemory(hDbgProcess, pvAddress, pvLocalMemory, cbMemory, &cbActual))
    {
        if (cbActual != cbMemory)
        {
            DebuggerOut("  counts don't match\n");
            return(-1);
        }
        return(0);
    }
    DebuggerOut("  GetLastError from readMemory is %d\n", GetLastError());
    return(GetLastError());

}

SECURITY_STATUS
WriteMemory(PVOID           pvLocalMemory,
            ULONG           cbMemory,
            PVOID           pvAddress)
{
    SIZE_T       cbActual = cbMemory;

    if (WriteProcessMemory(hDbgProcess, pvAddress, pvLocalMemory, cbMemory, &cbActual))
    {
        if (cbActual != cbMemory)
        {
            return(-1);
        }
        return(0);
    }
    return(GetLastError());
}

DWORD
GetDword(PVOID  pvMemory)
{
    DWORD   dwVal;
    SIZE_T   cbActual = sizeof(DWORD);

    if (ReadProcessMemory(hDbgProcess, pvMemory, &dwVal, sizeof(DWORD), &cbActual))
    {
        if (cbActual != sizeof(DWORD))
        {
            return((DWORD) -1);
        }
        return(dwVal);
    }
    return((DWORD) -1);
}

#define TIMEBUF_SZ  64
char *Months[]      = { "", "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul",
            "Aug", "Sep", "Oct", "Nov", "Dec" };
void CTimeStamp(PTimeStamp      ptsTime,
                LPSTR           pszTimeBuf)
{
    SYSTEMTIME      stTime;
    FILETIME        tLocal;
    SYSTEMTIME      stLocal;

    if (ptsTime->HighPart == 0)
    {
        strcpy(pszTimeBuf, "<Zero>");
    }
    else if (ptsTime->HighPart >= 0x7FFFFFFF)
    {
        strcpy(pszTimeBuf, "<Never>");
    }
    FileTimeToLocalFileTime((LPFILETIME) ptsTime, &tLocal);
    FileTimeToSystemTime((LPFILETIME) ptsTime, &stTime);
    FileTimeToSystemTime(&tLocal, &stLocal);
    sprintf(pszTimeBuf, "%02d:%02d:%02d.%03d, %s %02d, %d UTC (%02d:%02d:%02d.%03d, %s %02d, %d Local)", stTime.wHour,
        stTime.wMinute, stTime.wSecond, stTime.wMilliseconds,
        Months[stTime.wMonth], stTime.wDay, stTime.wYear,
        stLocal.wHour, stLocal.wMinute, stLocal.wSecond, stLocal.wMilliseconds, Months[stLocal.wMonth], stLocal.wDay, stLocal.wYear);
}

void ContextTimeStamp(PTimeStamp      ptsTime,
                      LPSTR           pszTimeBuf)
{
    // We set local times in sspi
    SYSTEMTIME      stTime;
    FILETIME        tutc;
    SYSTEMTIME      stLocal;
    TimeStamp       Time;

    if (ReadMemory( ptsTime, sizeof( TimeStamp), &Time))
    {
        DebuggerOut("  Could not read context\n");
        return;
    }
    if (Time.HighPart == 0)
    {
        strcpy(pszTimeBuf, "<Zero>");
    }
    else if (Time.HighPart >= 0x7FFFFFFF)
    {
        strcpy(pszTimeBuf, "<Never>");
    }
    FileTimeToSystemTime((LPFILETIME) &Time, &stLocal);
    LocalFileTimeToFileTime((LPFILETIME) &Time, &tutc);
    FileTimeToSystemTime(&tutc, &stTime);
    sprintf(pszTimeBuf, "%02d:%02d:%02d.%03d, %s %02d, %d UTC (%02d:%02d:%02d.%03d, %s %02d, %d Local)", stTime.wHour,
        stTime.wMinute, stTime.wSecond, stTime.wMilliseconds,
        Months[stTime.wMonth], stTime.wDay, stTime.wYear,
        stLocal.wHour, stLocal.wMinute, stLocal.wSecond, stLocal.wMilliseconds, Months[stLocal.wMonth], stLocal.wDay, stLocal.wYear);
}

void
MapString(PSECURITY_STRING  pClientString,
      PSECURITY_STRING  pLocalString)
{
    if (!pLocalString->Buffer)
    {
        pLocalString->Buffer = (PWSTR) AllocHeap(pClientString->Length + 2);
        if (pLocalString->Buffer == NULL)
        {
            return;
        }
        pLocalString->MaximumLength = pClientString->Length + 2;
    }

    RtlZeroMemory(pLocalString->Buffer, pLocalString->MaximumLength);

    if (!ReadMemory(pClientString->Buffer, pClientString->Length, pLocalString->Buffer))
    {
        pLocalString->Length = pClientString->Length;
    }
    else
    {
        DebuggerOut("\nWarning: could not read string @%x\n", pClientString->Buffer);
    }

}

void PrintSid(PVOID pvSid)
{
    SID Sid;
    PSID   pSid;
    UNICODE_STRING  ucsSid = {0};

    DebuggerOut("  UserSid         \t0x%lx ", pvSid);
    if (pvSid)
    {
        if (ReadMemory(pvSid, sizeof(SID), &Sid))
        {
            DebuggerOut("Could not read from %x\n", pvSid);
        }

        pSid = AllocHeap(RtlLengthRequiredSid(Sid.SubAuthorityCount));
        if (pSid == NULL)
        {
            return;
        }
        if (ReadMemory(pvSid, RtlLengthRequiredSid(Sid.SubAuthorityCount), pSid))
        {
            DebuggerOut("Could not read from %x\n", pvSid);
        }

        RtlConvertSidToUnicodeString(&ucsSid, pSid, TRUE);
        if ( ucsSid.Buffer )
        {   
            DebuggerOut("  %wZ", &ucsSid);
            RtlFreeUnicodeString(&ucsSid);
        }
        FreeHeap(pSid);
    }
    DebuggerOut("\n");
}

VOID
PrintEType(
    ULONG EType
)
{
    switch(EType)
    {
    case KERB_ETYPE_NULL:
    DebuggerOut("KERB_ETYPE_NULL\n"); break;
    case KERB_ETYPE_DES_CBC_CRC:
    DebuggerOut("KERB_ETYPE_DES_CBC_CRC\n"); break;
    case KERB_ETYPE_DES_CBC_MD4:
    DebuggerOut("KERB_ETYPE_DES_CBC_MD4\n"); break;
    case KERB_ETYPE_DES_CBC_MD5:
    DebuggerOut("KERB_ETYPE_DES_CBC_MD5\n"); break;
    case KERB_ETYPE_OLD_RC4_MD4:
    DebuggerOut("KERB_ETYPE_OLD_RC4_MD4\n"); break;
    case KERB_ETYPE_OLD_RC4_PLAIN:
    DebuggerOut("KERB_ETYPE_OLD_RC4_PLAIN\n"); break;
    case KERB_ETYPE_OLD_RC4_LM:
    DebuggerOut("KERB_ETYPE_OLD_RC4_LM\n"); break;
    case KERB_ETYPE_OLD_RC4_SHA:
    DebuggerOut("KERB_ETYPE_OLD_RC4_SHA\n"); break;
    case KERB_ETYPE_OLD_DES_PLAIN:
    DebuggerOut("KERB_ETYPE_OLD_DES_PLAIN\n"); break;
    case KERB_ETYPE_RC4_MD4:
    DebuggerOut("KERB_ETYPE_RC4_MD4\n"); break;
    case KERB_ETYPE_RC4_PLAIN2:
    DebuggerOut("KERB_ETYPE_RC4_PLAIN2\n"); break;
    case KERB_ETYPE_RC4_LM:
    DebuggerOut("KERB_ETYPE_RC4_LM\n"); break;
    case KERB_ETYPE_RC4_SHA:
    DebuggerOut("KERB_ETYPE_RC4_SHA\n"); break;
    case KERB_ETYPE_DES_PLAIN:
    DebuggerOut("KERB_ETYPE_DES_PLAIN\n"); break;
    case KERB_ETYPE_RC4_PLAIN:
    DebuggerOut("KERB_ETYPE_RC4_PLAIN\n"); break;
    case KERB_ETYPE_RC4_HMAC_OLD:
    DebuggerOut("KERB_ETYPE_RC4_HMAC_OLD\n"); break;
    case KERB_ETYPE_RC4_HMAC_OLD_EXP:
    DebuggerOut("KERB_ETYPE_RC4_HMAC_OLD_EXP\n"); break;
    case KERB_ETYPE_RC4_PLAIN_EXP:
    DebuggerOut("KERB_ETYPE_RC4_PLAIN_EXP\n"); break;
    case KERB_ETYPE_DSA_SIGN:
    DebuggerOut("KERB_ETYPE_DSA_SIGN\n"); break;
    case KERB_ETYPE_RSA_PRIV:
    DebuggerOut("KERB_ETYPE_RSA_PRIV\n"); break;
    case KERB_ETYPE_RSA_PUB:
    DebuggerOut("KERB_ETYPE_RSA_PUB\n"); break;
    case KERB_ETYPE_RSA_PUB_MD5:
    DebuggerOut("KERB_ETYPE_RSA_PUB_MD5\n"); break;
    case KERB_ETYPE_RSA_PUB_SHA1:
    DebuggerOut("KERB_ETYPE_RSA_PUB_SHA1\n"); break;
    case KERB_ETYPE_PKCS7_PUB:
    DebuggerOut("KERB_ETYPE_PKCS7_PUB\n"); break;
    case KERB_ETYPE_DES_CBC_MD5_NT:
    DebuggerOut("KERB_ETYPE_DES_CBC_MD5_NT\n"); break;
default:
    DebuggerOut("Unknown EType: 0x%lx\n", EType); break;
    }
}
VOID
ShowKerbContext(
    IN PVOID pContext
    )
{
    KERB_CONTEXT Context;
    CHAR TimeBuf[80];
    SECURITY_STRING sLocal;
    sLocal.Buffer = NULL;

    if (ReadMemory( pContext, sizeof( KERB_CONTEXT), &Context ))
    {
        DebuggerOut("  Could not read context\n");
        return;
    }

    CTimeStamp( &Context.Lifetime, TimeBuf );
    DebuggerOut("  Lifetime       \t%s\n", TimeBuf );

    CTimeStamp( &Context.RenewTime, TimeBuf );
    DebuggerOut("  RenewTime       \t%s\n", TimeBuf );

    MapString( &Context.ClientName, &sLocal);
    DebuggerOut("  ClientName     \t%ws\n", sLocal.Buffer);
    FreeHeap(sLocal.Buffer);
    sLocal.Buffer = NULL;

    MapString( &Context.ClientRealm, &sLocal);
    DebuggerOut("  ClientRealm     \t%ws\n", sLocal.Buffer);
    FreeHeap(sLocal.Buffer);
    sLocal.Buffer = NULL;

    DebuggerOut("  Process ID      \t0x%lx\n", Context.ClientProcess);
    DebuggerOut("  LogonId         \t0x%lx : 0x%lx\n", Context.LogonId.LowPart, Context.LogonId.HighPart );
    DebuggerOut("  TokenHandle     \t0x%lx\n", Context.TokenHandle );
    DebuggerOut("  CredentialHandle\t0x%lx\n", Context.CredentialHandle);
    DebuggerOut("  SessionKey type \t");
    PrintEType(Context.SessionKey.keytype);
    DebuggerOut("  SessionKey length \t0x%lx\n", Context.SessionKey.keyvalue.length);
    DebuggerOut("  Nonce           \t0x%lx\n", Context.Nonce);
    DebuggerOut("  ReceiveNonce    \t0x%lx\n", Context.ReceiveNonce);
    DebuggerOut("  ContextFlags    \t0x%lx\n", Context.ContextFlags);
    PrintContextAttributes(Context.ContextAttributes);
    DebuggerOut("  EncryptionType  \t");
    PrintEType(Context.EncryptionType);
    PrintSid(Context.UserSid);
    DebuggerOut("  ContextState    \t%s\n", ContextState[Context.ContextState]);
    DebuggerOut("  Retries         \t0x%lx\n", Context.Retries );
    DebuggerOut("  TicketKey type  \t");
    PrintEType(Context.TicketKey.keytype);
    DebuggerOut("  TicketKey length\t0x%lx\n", Context.TicketKey.keyvalue.length);
    DebuggerOut("  TicketCacheEntry\t0x%lx\n", Context.TicketCacheEntry);
}

VOID
DumpContext(
    HANDLE                  hProcess,
    HANDLE                  hThread,
    DWORD                   dwCurrentPc,
    PNTSD_EXTENSION_APIS    lpExt,
    LPSTR                   pszCommand)
{
    PVOID pContext;

    InitDebugHelp( hProcess,
                   hThread,
                   lpExt);

    pContext = GetExpr( pszCommand );

    if ( pContext == NULL ) {

        return;
    }

    ShowKerbContext( pContext );

}

void PrintLogonType(SECURITY_LOGON_TYPE LogonType)
{
    switch(LogonType)
    {
    case Interactive:
    DebuggerOut("Interactive\n"); break;
    case Network:
    DebuggerOut("Network\n"); break;
    case Batch:
    DebuggerOut("Batch\n"); break;
    case Service:
    DebuggerOut("Service\n"); break;
    case Proxy:
    DebuggerOut("Proxy\n"); break;
    case Unlock:
    DebuggerOut("Unlock\n"); break;
    default:
    DebuggerOut("Unknown Logon Type: 0x%lx\n", LogonType); break;
    }
}

VOID
ShowKerbTCacheEntry(PVOID pCache)
{
/*
typedef struct _KERB_TICKET_CACHE_ENTRY {
    KERBEROS_LIST_ENTRY ListEntry;
    PKERB_INTERNAL_NAME ServiceName;
    PKERB_INTERNAL_NAME TargetName;
    UNICODE_STRING DomainName;
    UNICODE_STRING TargetDomainName;
    UNICODE_STRING AltTargetDomainName;
    PKERB_INTERNAL_NAME ClientName;
    ULONG TicketFlags;
    ULONG CacheFlags;
    KERB_ENCRYPTION_KEY SessionKey;
    TimeStamp KeyExpirationTime;
    TimeStamp StartTime;
    TimeStamp EndTime;
    TimeStamp RenewUntil;
    KERB_TICKET Ticket;
    TimeStamp TimeSkew;
} KERB_TICKET_CACHE_ENTRY, *PKERB_TICKET_CACHE_ENTRY;
*/
    KERB_TICKET_CACHE_ENTRY Cache;
    CHAR TimeBuf[64];
    SECURITY_STRING sLocal;
    ULONG Temp;
    sLocal.Buffer = NULL;

    if (ReadMemory( pCache, sizeof( KERB_TICKET_CACHE_ENTRY), &Cache))
    {
        DebuggerOut("  Could not read ticket cache entry\n");
        return;
    }
    DebuggerOut("  ServiceName     \t0x%lx\n", Cache.ServiceName);
    DebuggerOut("  TargetName      \t0x%lx\n", Cache.TargetName);

    MapString( &Cache.DomainName, &sLocal);
    DebuggerOut("  DomainName       \t%ws\n", sLocal.Buffer);
    FreeHeap(sLocal.Buffer);
    sLocal.Buffer = NULL;

    MapString( &Cache.TargetDomainName, &sLocal);
    DebuggerOut("  TargetDomainName \t%ws\n", sLocal.Buffer);
    FreeHeap(sLocal.Buffer);
    sLocal.Buffer = NULL;

    MapString( &Cache.AltTargetDomainName, &sLocal);
    DebuggerOut("  AltTargetDomainName  \t%ws\n", sLocal.Buffer);
    FreeHeap(sLocal.Buffer);
    sLocal.Buffer = NULL;

    DebuggerOut("  ClientName      \t0x%lx\n", Cache.ClientName);
    DebuggerOut("  TicketFlags     \t0x%lx\n", Cache.TicketFlags);
    DebuggerOut("  CacheFlags      \t0x%lx\n", Cache.CacheFlags);
    DebuggerOut("  EncryptionType  \t");
    PrintEType(Cache.SessionKey.keytype);
    CTimeStamp( &Cache.StartTime, TimeBuf );
    DebuggerOut("  StartTime       \t%s\n", TimeBuf );
    CTimeStamp( &Cache.EndTime, TimeBuf );
    DebuggerOut("  Endtime          \t%s\n", TimeBuf );
    CTimeStamp( &Cache.RenewUntil, TimeBuf );
    DebuggerOut("  RenewUntil       \t%s\n", TimeBuf );
}

VOID
ShowKerbLSession(
    IN PVOID pSession
    )
{
    KERB_LOGON_SESSION Session;
    CHAR TimeBuf[64];
    SECURITY_STRING sLocal;
    ULONG_PTR Temp;
    sLocal.Buffer = NULL;

    if (ReadMemory( pSession, sizeof( KERB_LOGON_SESSION), &Session))
    {
        DebuggerOut("  Could not read logon session\n");
        return;
    }
    //DebuggerOut("  Credential      \t0x%lx\n", Session.SspCredentials);
    DebuggerOut("  LogonId         \t0x%lx : 0x%lx\n", Session.LogonId.LowPart, Session.LogonId.HighPart );
    CTimeStamp( &Session.Lifetime, TimeBuf );
    DebuggerOut("  Lifetime       \t%s\n", TimeBuf );
    //PrintPCred(Session.PrimaryCredentials);

    MapString( &Session.PrimaryCredentials.UserName, &sLocal);
    DebuggerOut("  UserName       \t%ws\n", sLocal.Buffer);
    FreeHeap(sLocal.Buffer);
    sLocal.Buffer = NULL;

    MapString( &Session.PrimaryCredentials.DomainName, &sLocal);
    DebuggerOut("  DomainName       \t%ws\n", sLocal.Buffer);
    FreeHeap(sLocal.Buffer);
    sLocal.Buffer = NULL;

    DebuggerOut("  Passwords        \t0x%lx\n", Session.PrimaryCredentials.Passwords);
    DebuggerOut("  OldPasswords     \t0x%lx\n", Session.PrimaryCredentials.OldPasswords);
    DebuggerOut("  PublicKeyCreds   \t0x%lx\n", Session.PrimaryCredentials.PublicKeyCreds);
    DebuggerOut("  LogonSessionFlags\t0x%lx\n", Session.LogonSessionFlags);

    // ServerTicketCache
    Temp =  (ULONG_PTR)pSession+ FIELD_OFFSET(KERB_LOGON_SESSION, PrimaryCredentials) + FIELD_OFFSET(KERB_PRIMARY_CREDENTIAL, ServerTicketCache);

    DebuggerOut("  ServerTicketCache \t0x%p\n", Temp);

    // AuthenticationTicketCache
    Temp =  (ULONG_PTR)pSession+ FIELD_OFFSET(KERB_LOGON_SESSION, PrimaryCredentials) + FIELD_OFFSET(KERB_PRIMARY_CREDENTIAL, AuthenticationTicketCache);

    DebuggerOut("  AuthenticationTicketCache \t0x%p\n", Temp );


}

VOID
DumpLSession(
    HANDLE                  hProcess,
    HANDLE                  hThread,
    DWORD                   dwCurrentPc,
    PNTSD_EXTENSION_APIS    lpExt,
    LPSTR                   pszCommand)
{
    PVOID pSession;

    InitDebugHelp( hProcess,
                   hThread,
                   lpExt);

    pSession = GetExpr( pszCommand );

    if ( pSession == NULL ) {

        return;
    }

    ShowKerbLSession( pSession);

}

VOID
DumpTCacheEntry(
    HANDLE                  hProcess,
    HANDLE                  hThread,
    DWORD                   dwCurrentPc,
    PNTSD_EXTENSION_APIS    lpExt,
    LPSTR                   pszCommand)
{
    PVOID pCache;

    InitDebugHelp( hProcess,
                   hThread,
                   lpExt);

    pCache = GetExpr( pszCommand );

    if ( pCache == NULL ) {

        return;
    }

    ShowKerbTCacheEntry( pCache);
}

/*
VOID
ShowDomainList(PVOID pDomain)
{
    PLIST_ENTRY DomainList = (PLIST_ENTRY) pDomain;
    SECURITY_STRING sLocal;
    PLIST_ENTRY ListEntry;
    PKDC_DOMAIN_INFO Domain;


    for (ListEntry = DomainList->Flink;
         ListEntry != DomainList ;
         ListEntry = ListEntry->Flink )
    {
        Domain = (PKDC_DOMAIN_INFO) CONTAINING_RECORD(ListEntry, KDC_DOMAIN_INFO, Next);

        MapString( &Domain->DnsName, &sLocal);
        DebuggerOut("  DomainName       \t%ws\n", sLocal.Buffer);
        FreeHeap(sLocal.Buffer);
        sLocal.Buffer = NULL;

        if (Domain->ClosestRoute == NULL)
        {
            DebuggerOut("  No closest route\n");
        }
        else
        {
            MapString( Domain->ClosestRoute, &sLocal);
            DebuggerOut("  Closest Route      \t%ws\n", sLocal.Buffer);
            FreeHeap(sLocal.Buffer);
            sLocal.Buffer = NULL;
        }

        if (Domain->Parent == NULL)
        {
            DebuggerOut("  No parent\n");
        }
        else
        {
            MapString( &Domain->Parent->DnsName, &sLocal);
            DebuggerOut("  Parent       \t%ws\n", sLocal.Buffer);
            FreeHeap(sLocal.Buffer);
            sLocal.Buffer = NULL;
        }
    }
}

VOID
DumpReferralTree(
    HANDLE                  hProcess,
    HANDLE                  hThread,
    DWORD                   dwCurrentPc,
    PNTSD_EXTENSION_APIS    lpExt,
    LPSTR                   pszCommand)
{
    PVOID pDomain;

    InitDebugHelp( hProcess,
                   hThread,
                   lpExt);

    pDomain = GetExpr( pszCommand );

    if ( pDomain == NULL ) {

        return;
    }
    ShowDomainList(pDomain);
}
*/

VOID
DumpContextFlags(
    HANDLE                  hProcess,
    HANDLE                  hThread,
    DWORD                   dwCurrentPc,
    PNTSD_EXTENSION_APIS    lpExt,
    LPSTR                   pszCommand)
{
    PVOID pContext;

    InitDebugHelp( hProcess,
                   hThread,
                   lpExt);

    pContext = GetExpr( pszCommand );

    if ( pContext == NULL ) {

        return;
    }

    PrintContextFlags( (ULONG)((ULONG_PTR)pContext) );

}

VOID
DumpCTimeStamp(
    HANDLE                  hProcess,
    HANDLE                  hThread,
    DWORD                   dwCurrentPc,
    PNTSD_EXTENSION_APIS    lpExt,
    LPSTR                   pszCommand)
{
    PVOID pContext;
    CHAR TimeBuf[100];

    InitDebugHelp( hProcess,
                   hThread,
                   lpExt);

    pContext = GetExpr( pszCommand );

    if ( pContext == NULL ) {

        return;
    }

    ContextTimeStamp( (PTimeStamp) pContext, TimeBuf );
    DebuggerOut("  TimeStamp  \t%s\n", TimeBuf );

}

void
Help(   HANDLE                  hProcess,
        HANDLE                  hThread,
        DWORD                   dwCurrentPc,
        PNTSD_EXTENSION_APIS    lpExt,
        LPSTR                   pszCommand)
{

    InitDebugHelp(hProcess, hThread, lpExt);

    DebuggerOut("Kerberos Exts Debug Help\n");
    DebuggerOut("   DumpContext  <addr>     \tDumps a Kerberos context\n");
    DebuggerOut("   DumpLSession <addr>     \tDumps a Kerberos logon session\n");
    DebuggerOut("   DumpTCacheEntry <addr>  \tDumps a Kerberos ticket cache entry\n");
    DebuggerOut("   DumpContextFlags <hex ulong>\tDumps an SSPI context flags\n");
    DebuggerOut("   DumpCTimeStamp <hex ulong>\tDumps a Context Expiry Time\n");

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\inc\exterr.h ===
//+-----------------------------------------------------------------------
//
// File:        exterr.h
//
// Contents:    Kerberos extended error structures and macros
//
// History:     23-Feb-2000    Todds   Created
//
//
//------------------------------------------------------------------------

#ifndef __EXTERR_H__
#define __EXTERR_H__

//
// This macro is universally used for extended errors
//
#define EXT_ERROR_SUCCESS(s)             (NT_SUCCESS(s.status))

//
// defines for flags member of KERB_EXT_ERROR structure
//
#define EXT_ERROR_CLIENT_INFO      0x1   // this is an extended error for use by client
#define EXT_ERROR_CODING_ASN       0x2   // this is an exteneded error encoded in ASN when sent over the wire

//
// is there a useful NTSTATUS embedded in returned error?
//
#define  EXT_CLIENT_INFO_PRESENT(p)    ((NULL != (p)) && ((p)->flags & EXT_ERROR_CLIENT_INFO) && !NT_SUCCESS((p)->status))

//
// do we need to pack the exteneded error as RAW data by preprocessing?
//
#define  EXT_ERROR_PRE_PROCESSING_NEEDED(p)    (EXT_CLIENT_INFO_PRESENT(p) && (0 == ((p)->flags & EXT_ERROR_CODING_ASN)))

#endif // __EXTERR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\inc\fileno.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       fileno.h
//
//  Stolen from DS line number obfuscation macros
//
//--------------------------------------------------------------------------

//
// fileno.h - defines symbolic constants  for kerberos c code
// files. File numbers are 16 bit values. The high byte is the directory number and
// the low byte is the file number within the directory.
//

// Why not make the macro have just one arg, since line is always
// __LINE__?  Because if we did then __LINE__ would be evaluated here,
// rather than at the invocation of the macro, and so would always
// have the value 11.
#define KLIN(fileno,line) (((fileno) << 16) | (line))

//
//  *** NOTE: ***
//
//  If you add FILENO_*'s to this list, be sure to make a corresponding update
//  to kerberos\utest\klin.c so that dsid.exe can properly decode the DSID
//  corresponding to the new file.
//
//  If you add DIRNO_*'s to this list, be sure to make a corresponding update
//  to ds\src\dscommon\dsvent.c - rEventSourceMappings[].
//

// define directory numbers

#define DIRNO_CLIENT2   (0)                             // \client2
#define DIRNO_COMMON2   (1 << 8)                        // \common2
#define DIRNO_KERNEL    (2 << 8)                        // \kernel
#define DIRNO_RTL       (3 << 8)                        // \rtl
#define DIRNO_SERVER    (4 << 8)                        // \server

// client2 directory
#define FILENO_BNDCACHE         (DIRNO_CLIENT2 + 0)      // bndcache.cxx
#define FILENO_CREDAPI          (DIRNO_CLIENT2 + 1)      // credapi.cxx
#define FILENO_CREDMGR          (DIRNO_CLIENT2 + 2)      // credmgr.cxx
#define FILENO_CTXTAPI          (DIRNO_CLIENT2 + 3)      // ctxtapi.cxx
#define FILENO_CTXTMGR          (DIRNO_CLIENT2 + 4)      // ctxtmgr.cxx
#define FILENO_GSSUTIL          (DIRNO_CLIENT2 + 5)      // gssutil.cxx
#define FILENO_KERBEROS         (DIRNO_CLIENT2 + 6)      // kerberos.cxx
#define FILENO_KERBLIST         (DIRNO_CLIENT2 + 7)      // kerblist.cxx
#define FILENO_KERBPASS         (DIRNO_CLIENT2 + 8)      // kerbpass.cxx
#define FILENO_KERBTICK         (DIRNO_CLIENT2 + 9)      // kerbtick.cxx
#define FILENO_KERBUTIL         (DIRNO_CLIENT2 + 10)     // kerbutil.cxx
#define FILENO_KERBWOW          (DIRNO_CLIENT2 + 11)     // kerbwow.cxx
#define FILENO_KRBEVENT         (DIRNO_CLIENT2 + 12)     // krbevent.cxx
#define FILENO_KRBTOKEN         (DIRNO_CLIENT2 + 13)     // krbtoken.cxx
#define FILENO_LOGONAPI         (DIRNO_CLIENT2 + 14)     // logonapi.cxx
#define FILENO_MISCAPI          (DIRNO_CLIENT2 + 15)     // miscapi.cxx
#define FILENO_MITUTIL          (DIRNO_CLIENT2 + 16)     // mitutil.cxx
#define FILENO_PKAUTH           (DIRNO_CLIENT2 + 17)     // pkauth.cxx
#define FILENO_PROXYAPI         (DIRNO_CLIENT2 + 18)     // proxyapi.cxx
#define FILENO_RPCUTIL          (DIRNO_CLIENT2 + 19)     // rpcutil.cxx
#define FILENO_SIDCACHE         (DIRNO_CLIENT2 + 20)     // sidcache.cxx
#define FILENO_TIMESYNC         (DIRNO_CLIENT2 + 21)     // timesync.cxx
#define FILENO_TKTCACHE         (DIRNO_CLIENT2 + 22)     // tktcache.cxx
#define FILENO_TKTLOGON         (DIRNO_CLIENT2 + 23)     // tktlogon.cxx
#define FILENO_USERAPI          (DIRNO_CLIENT2 + 24)     // userapi.cxx
#define FILENO_USERLIST         (DIRNO_CLIENT2 + 25)     // userlist.cxx
#define FILENO_S4U              (DIRNO_CLIENT2 + 26)     // kerbs4u.cxx

// common2 directory
#define FILENO_AUTHEN           (DIRNO_COMMON2 + 0)       // authen.cxx
#define FILENO_CRYPT            (DIRNO_COMMON2 + 1)       // crypt.c
#define FILENO_KEYGEN           (DIRNO_COMMON2 + 2)       // keygen.c
#define FILENO_KRB5             (DIRNO_COMMON2 + 3)       // krb5.c
#define FILENO_NAMES            (DIRNO_COMMON2 + 4)       // names.cxx
#define FILENO_PASSWD           (DIRNO_COMMON2 + 5)       // passwd.c
// skip (DIRNO_COMMON2 + 6) was restrict.cxx
#define FILENO_SOCKETS          (DIRNO_COMMON2 + 7)       // sockets.cxx
#define FILENO_TICKETS          (DIRNO_COMMON2 + 8)       // tickets.cxx
#define FILENO_COMMON_UTILS     (DIRNO_COMMON2 + 9)       // utils.cxx


// kernel directory
#define FILENO_CPGSSUTL            (DIRNO_KERNEL + 0)         // cpgssutl.cxx
#define FILENO_CTXTMGR2            (DIRNO_KERNEL + 1)         // ctxtmgr.cxx
#define FILENO_KERBLIST2           (DIRNO_KERNEL + 2)         // kerblist.cxx
#define FILENO_KRNLAPI             (DIRNO_KERNEL + 3)         // krnlapi.cxxc

// RTL directory
#define FILENO_AUTHDATA         (DIRNO_RTL + 0)     // authdata.cxx
#define FILENO_CRACKPAC         (DIRNO_RTL + 1)     // crackpac.cxx
#define FILENO_CRED             (DIRNO_RTL + 2)     // cred.cxx
#define FILENO_CREDLIST         (DIRNO_RTL + 3)     // credlist.cxx
#define FILENO_CREDLOCK         (DIRNO_RTL + 4)     // credlock.cxx
#define FILENO_DBUTIL           (DIRNO_RTL + 5)     // dbutil.cxx
#define FILENO_DBOPEN           (DIRNO_RTL + 6)     // domain.cxx
#define FILENO_DOMCACHE         (DIRNO_RTL + 7)     // domcache.cxx
#define FILENO_FILTER           (DIRNO_RTL + 8)     // filter.cxx
#define FILENO_MAPERR           (DIRNO_RTL + 9)     // maperr.cxx
#define FILENO_MAPSECER         (DIRNO_RTL + 10)    // mapsecerr.cxx
#define FILENO_MISCID           (DIRNO_RTL + 11)    // miscid.cxx
#define FILENO_PAC              (DIRNO_RTL + 12)    // pac.cxx
#define FILENO_PAC2             (DIRNO_RTL + 13)    // pac2.cxx
#define FILENO_PARMCHK          (DIRNO_RTL + 14)    // parmchk.cxx
#define FILENO_REG              (DIRNO_RTL + 15)    // reg.cxx
#define FILENO_SECSTR           (DIRNO_RTL + 16)    // secstr.cxx
#define FILENO_SERVICES         (DIRNO_RTL + 17)    // services.c
#define FILENO_STRING           (DIRNO_RTL + 18)    // string.cxx
#define FILENO_TIMESERV         (DIRNO_RTL + 19)    // timeserv.cxx
#define FILENO_TOKENUTL         (DIRNO_RTL + 20)    // tokenutl.cxx
#define FILENO_TRNSPORT         (DIRNO_RTL + 21)    // trnsport.cxx

// Server directory
#define FILENO_DEBUG            (DIRNO_SERVER + 0)     // debug.cxx
#define FILENO_DGUTIL           (DIRNO_SERVER + 1)     // dgutil.cxx
#define FILENO_EVENTS           (DIRNO_SERVER + 2)     // events.cxx
#define FILENO_GETAS            (DIRNO_SERVER + 3)     // getas.cxx
#define FILENO_GETTGS           (DIRNO_SERVER + 4)     // gettgs.cxx
#define FILENO_KDC              (DIRNO_SERVER + 5)     // kdc.cxx
#define FILENO_KDCTRACE         (DIRNO_SERVER + 6)     // kdctrace.cxx
#define FILENO_KPASSWD          (DIRNO_SERVER + 7)     // kpasswd.cxx
#define FILENO_NOTIFY2          (DIRNO_SERVER + 8)     // notify2.cxx
#define FILENO_SRVPAC           (DIRNO_SERVER + 9)     // pac.cxx
#define FILENO_PKSERV           (DIRNO_SERVER + 10)    // pkserv.cxx
#define FILENO_REFER            (DIRNO_SERVER + 11)    // refer.cxx
#define FILENO_RPCIF            (DIRNO_SERVER + 12)    // rpcif.cxx
#define FILENO_SECDATA          (DIRNO_SERVER + 13)    // secdata.cxx
#define FILENO_SOCKUTIL         (DIRNO_SERVER + 14)    // sockutil.cxx
#define FILENO_TKTUTIL          (DIRNO_SERVER + 15)    // tktutil.cxx
#define FILENO_TRANSIT          (DIRNO_SERVER + 16)    // transit.cxx
#define FILENO_RESTRICT         (DIRNO_SERVER + 17)       // restrict.cxx
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\inc\dsstring.h ===
//+------------------------------------------------------------------
//
// File: DSSTRING.H
//
// Contents:  It contains the all the constant strings used all thru
//            DS project
//
// Synoposis: Collection of strings.
//
// Classes:    -none-
//
// Functions: -none-
//
// History:     Oct 27, 1993    AlokS   Created
//              5-Apr095        MikeSe  Moved, modified
//
//-------------------------------------------------------------------

#ifndef __DSSTRING_H__
#define __DSSTRING_H__

#include <lmsname.h>    // for SERVICE_SERVER, SERVICE_NETLOGON,
                        // and SERVICE_SCHEDULE

#define ACCOUNT_OPERATORS      L"AccountOperators"
#define BACKUP_OPERATORS       L"BackupOperators"
#define CAIRODSGROUP           L"Cairo DS"
#define COMP_NAME_KEY          L"System\\CurrentControlSet\\Control\\ComputerName\\ActiveComputerName"
#define COMP_NAME_VALUE        L"ComputerName"
#define DC_TYPE                L"DCType"
#define DFS_VOLUME             L"\\volumes"
#define DFSM_PASSWORD          L"dfsm"
#define DFSM_PRINCIPAL         L"DFSM"
#define ORASVC_PASSWORD        L"ora"
#define ORASVC_PRINCIPAL       L"ORA"
#define DOMAIN_ADMIN           L"DomainAdmin"
#define DOMAIN_ADMIN_PASSWORD  L"DomainAdmin"
#define DOMAIN_ADMINS          L"DomainAdmins"
#define DOMAIN_NAME            L"CairoDomainName"
#define DOMAIN_PASSWORD        L"DomainPassword"
#define DOMAIN_ROOT            L"DOM:\\"
#define DOMAIN_USERS           L"DomainUsers"
#define DOMAINOBJECTNAME       L"Domain"
#define DS_REG_DOMAIN_ID       L"DomainID"// Type Binary
#define DS_REG_SITE_ID         L"SiteID"// Type Binary
#define DS_REG_DOMAIN_NAME     L"DomainName"// Type REG_SZ
#define DS_REG_DOMAIN_ROOT     L"DomainRoot"// Type REG_SZ
#define DS_REG_LOCAL_ID        L"LocalID"// Type Binary
#define DS_REG_MACHINE_NAME    L"MachineName"// Type REG_SZ
#define DS_REG_MACHINE_ROOT    L"MachineRoot"// Type REG_SZ
#define DS_REG_MACHINE_STATE   L"MachineState"// Type DWORD
#define DS_REG_MACHINE_TARGET_STATE  L"MachineTargetState"// Type DWORD
#define DS_REG_MACHINE_VOLID   L"MachineVolumeId" // Type Binary
#define DS_REG_MACHINE_WEIGHT  L"MachineWeight"  // type DWORD
#define DS_REG_OU_NAME         L"OUName"// Type REG_SZ
#define DS_REG_PATH            L"System\\CurrentControlSet\\Control\\Cairo\\DS"
#define DS_REG_PUSER_NAME      L"PUserName"// Type REG_SZ
#define DS_REG_TIME_SYNC_STATE L"ReliableTimeSource" // Type DWORD
#define DS_REG_DOWNLEVEL_SID   L"DownlevelDomainSid" // Type REG_BINARY
#define DSDFSVOLUMES           L"VOLUMES"
#define DSDOMAINROOT           L"DSDomain"
#define DSLOCALROOT            L"DSLocal"
#define DSORGROOT              L"DSOrg"
#define DSORAROOT              L"Ora"
#define DSROOTNAME             L"DS"
#define DSSERVER               L"DSServer"
#define DSSERVERPWD            L"dsserver"
#define DSDOMAIN_REPLICA_SET_NAME        L"dsdomain"
#define DSDOMAIN_REPLICA_OBJECT_SET_ROOT L"dsshare\\dsdomain"
#define DSORG_REPLICA_SET_NAME   L"dsorg"
#define DSORG_REPLICA_OBJECT_SET_ROOT L"dsshare\\dsorg"
#define GUEST_ACCOUNT          L"Guest"
#define NET_DSSHARE            L"DsShare"
#define NET_DSSHARE_COMMENT    L"Replication share for DS domain objects"
#define NET_ORASHARE           L"Ora"
#define NET_ORASHARE_COMMENT   L"Replication share for Object Replication Agent"
#define FIRST_NONROOT_DC       L"FirstNonRootDC"
#define INST_TYPE_STANDALONE   L"Standalone"
#define INST_TYPE_DC           L"DC"
#define INST_TYPE_WKSTA        L"Workstation"
#define INSTALL_DIR            L"InstallDir"
#define INSTALL_DRIVE          L"ObjDrive"
#define INSTALL_TYPE           L"InstallType"
#define KDC_KEY                L"System\\CurrentControlSet\\Control\\Cairo\\CairoKDC"
#define KDC_NOTIFYADDRS        L"System\\CurrentControlSet\\Control\\Cairo\\DS\\DC\\NotifyAddrs"
#define KDC_PASSWORD           L"kdc"
#define KDC_PRINCIPAL          L"KDC"
#define KDC_LOGONNAME          L"\\" KDC_PRINCIPAL
#define LOCAL_DOMAIN_NAME      L"WORKGROUP"
#define MACHINE_ADDR           L"MachineAddress"
#define MACHINE_NAME           L"MachineName"
#define MACHINE_PWD            L"MachinePassword"
#define MACHINE_ROOT           L"MACH:\\"
#define NTLMSVC_PASSWORD       L"netlogon"
#define NTLMSVC_PRINCIPAL      L"Netlogon"
#define OU_NAME                L"OuName"
#define PRINT_OPERATORS        L"PrintOperators"
#define PRIVATE_GROUP          L"Private"
#define PRIVSVR_PRINCIPAL      L"PrivSvr"
#define PRIVSVR_PASSWORD       L"privsvr"
#define PROFILE_IMAGE_PATH     L"ProfileImagePath"
#define PROFILE_LIST_KEY       L"Software\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList"
#define PROFILE_PATH           L"ProfilePath"
#define DAYTONA_PROFILE        L"DaytonaProfile"
#define PUBLIC_GROUP           L"Public"
#define REPL_DC                L"ReplicaDC"
#define FIRST_DC               L"FirstDC"
#define SECTION_HEADER         L"FirstPass"
#define SECURITY_FOLDER        L"security"
#define SERVER_OPERATORS       L"ServerOperators"
#define SERVICE_CAIROKDC       L"CairoKdc"
#define SERVICE_CAIROORA       L"CairoOra"
#define SERVICE_ORASVC         L"CairoOra"
#define SERVICE_DFSDRIVER      L"Dfs"
#define SERVICE_DFSMANAGER     L"DfsManager"
#define SERVICE_NTLM           L"Netlogon"
#define SERVICE_PRIVSVR        L"PrivSvrService"
#define STANDALONE_DOMAIN_NAME L"Local"
#define USER_NAME              L"UserName"

#define UNICODE_BACKSLASH      L"\\"
#define UNICODE_NULL_STRING    L""
#define WCHAR_BACKSLASH        L'\\'
#define WCHAR_NULL             L'\0'

#endif // __DSSTRING_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\inc\kdcexp.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1997
//
// File:        kdcexp.h
//
// Contents:    Private Exports from kdcsvc.dll
//
//
// History:     27-June-1997    MikeSw          Created
//
//------------------------------------------------------------------------


#ifndef __KDCEXP_H__
#define __KDCEXP_H__

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus

NTSTATUS
KdcVerifyPac(
    IN ULONG ChecksumSize,
    IN PUCHAR Checksum,
    IN ULONG SignatureType,
    IN ULONG SignatureSize,
    IN PUCHAR Signature
    );


#define KDC_VERIFY_PAC_NAME "KdcVerifyPac"
typedef NTSTATUS
(NTAPI *PKDC_VERIFY_PAC_ROUTINE)(
    IN ULONG ChecksumSize,
    IN PUCHAR Checksum,
    IN ULONG SignatureType,
    IN ULONG SignatureSize,
    IN PUCHAR Signature
    );

KERBERR
KdcGetTicket(
    IN OPTIONAL PVOID Context,
    IN OPTIONAL PSOCKADDR ClientAddress,
    IN OPTIONAL PSOCKADDR ServerAddress,
    IN PKERB_MESSAGE_BUFFER InputMessage,
    OUT PKERB_MESSAGE_BUFFER OutputMessage
    );

#define KDC_GET_TICKET_NAME "KdcGetTicket"
typedef KERBERR
(NTAPI *PKDC_GET_TICKET_ROUTINE) (
    IN OPTIONAL PVOID Context,
    IN OPTIONAL PSOCKADDR ClientAddress,
    IN OPTIONAL PSOCKADDR ServerAddress,
    IN PKERB_MESSAGE_BUFFER InputMessage,
    OUT PKERB_MESSAGE_BUFFER OutputMessage
    );


#define KDC_CHANGE_PASSWORD_NAME "KdcChangePassword"

KERBERR
KdcChangePassword(
    IN OPTIONAL PVOID Context,
    IN OPTIONAL PSOCKADDR ClientAddress,
    IN OPTIONAL PSOCKADDR ServerAddress,
    IN PKERB_MESSAGE_BUFFER InputMessage,
    OUT PKERB_MESSAGE_BUFFER OutputMessage
    );

VOID
KdcFreeMemory(
     IN PVOID Ptr
     );

#define KDC_FREE_MEMORY_NAME "KdcFreeMemory"

typedef VOID
(NTAPI * PKDC_FREE_MEMORY_ROUTINE) (
    IN PVOID Ptr
    );

NTSTATUS
KdcAccountChangeNotification (
    IN PSID DomainSid,
    IN SECURITY_DB_DELTA_TYPE DeltaType,
    IN SECURITY_DB_OBJECT_TYPE ObjectType,
    IN ULONG ObjectRid,
    IN OPTIONAL PUNICODE_STRING ObjectName,
    IN PLARGE_INTEGER ModifiedCount,
    IN PSAM_DELTA_DATA DeltaData OPTIONAL
    );

BOOLEAN
KdcUpdateKrbtgtPassword(
    IN PUNICODE_STRING DnsDomainName,
    IN PLARGE_INTEGER MaxPasswordAge
    );

//
// Exported routines from kerberos.dll
//

NTSTATUS
KerbMakeKdcCall(
    IN PUNICODE_STRING RealmName,
    IN OPTIONAL PUNICODE_STRING AccountName,
    IN BOOLEAN CallPDC,
    IN BOOLEAN UseTcp,
    IN PKERB_MESSAGE_BUFFER RequestMessage,
    IN OUT PKERB_MESSAGE_BUFFER ReplyMessage,
    IN ULONG AdditionalFlags,
    OUT PBOOLEAN CalledPDC
    );

VOID
KerbFree(
    IN PVOID Buffer
    );

NTSTATUS
KerbCreateTokenFromTicket(
    IN PLUID NewLuid,
    IN OPTIONAL PKERB_AP_REQUEST Request,
    IN PKERB_ENCRYPTED_TICKET InternalTicket,
    IN PKERB_AUTHENTICATOR Authenticator,
    IN ULONG ContextFlags,
    IN PKERB_ENCRYPTION_KEY TicketKey,
    IN PUNICODE_STRING ServiceDomain,
    IN KERB_ENCRYPTION_KEY* pSessionKey,
    OUT PLUID NewLogonId,
    OUT PSID * UserSid,
    OUT PHANDLE NewTokenHandle,
    OUT PUNICODE_STRING ClientName,
    OUT PUNICODE_STRING ClientDomain,
    OUT PUNICODE_STRING ClientNetbiosDomain,
    OUT OPTIONAL PS4U_DELEGATION_INFO* S4uDelegationInfo
    );

BOOLEAN
KerbIsInitialized(
);

NTSTATUS
KerbKdcCallBack(
);

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __KDCEXP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\inc\kerbcred.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        kerbcred.h
//
// Contents:    structures for kerberos primary and supplemental credentials
//
//
// History:     20-Aug-1996     MikeSw          Created
//
//------------------------------------------------------------------------

#ifndef __KERBCRED_H__
#define __KERBCRED_H__


//
// Kerberos primary credentials store keys suitable for different
// encryption types.
//
#ifndef _KRB5_Module_H_
typedef struct _KERB_RPC_OCTET_STRING {
    unsigned long length;
#ifdef MIDL_PASS
    [size_is(length)]
#endif // MIDL_PASS
    unsigned char *value;
} KERB_RPC_OCTET_STRING;

typedef struct _KERB_ENCRYPTION_KEY {
    long keytype;
    KERB_RPC_OCTET_STRING keyvalue;
} KERB_ENCRYPTION_KEY;
#endif // _KRB5_Module_H_


typedef struct _KERB_KEY_DATA {
    UNICODE_STRING Salt;
    KERB_ENCRYPTION_KEY Key;
} KERB_KEY_DATA, *PKERB_KEY_DATA;

typedef struct _KERB_STORED_CREDENTIAL {
    USHORT Revision;
    USHORT Flags;
    USHORT CredentialCount;
    USHORT OldCredentialCount;
    UNICODE_STRING DefaultSalt;
#ifdef MIDL_PASS
    [size_is(CredentialCount + OldCredentialCount)]
    KERB_KEY_DATA Credentials[*];
#else
    KERB_KEY_DATA Credentials[ANYSIZE_ARRAY];
#endif // MIDL_PASS

} KERB_STORED_CREDENTIAL, *PKERB_STORED_CREDENTIAL;


#define KERB_PRIMARY_CRED_OWF_ONLY      2
#define KERB_PRIMARY_CRED_REVISION      3

//
// Flags for setting account keys
//

#define KERB_SET_KEYS_REPLACE   0x1



//
// KERB_STORED_CREDENTIALS are stored in the DS (blob), so
// they've got to be stored in 32 bit format, for W2k and 
// 32bit DC compatibility. 7/6/2000 - TS
//

#define KERB_KEY_DATA32_SIZE 20 
#define KERB_STORED_CREDENTIAL32_SIZE 16

#pragma pack(4)

typedef struct _KERB_ENCRYPTION_KEY32 {
    LONG keytype;
    ULONG keyvaluelength;       // KERB_RPC_OCTET_STRING32 
    ULONG keyvaluevalue;
} KERB_ENCRYPTION_KEY32;

typedef struct _KERB_KEY_DATA32 {
    UNICODE_STRING32 Salt;
    KERB_ENCRYPTION_KEY32 Key; // KERB_ENCRYPTION_KEY32
} KERB_KEY_DATA32, *PKERB_KEY_DATA32;



typedef struct _KERB_STORED_CREDENTIAL32 {
    USHORT Revision;
    USHORT Flags;
    USHORT CredentialCount;
    USHORT OldCredentialCount;
    UNICODE_STRING32 DefaultSalt;
#ifdef MIDL_PASS
    [size_is(CredentialCount + OldCredentialCount)]
    KERB_KEY_DATA32 Credentials[*];              // KERB_KEY_DATA32
#else
    KERB_KEY_DATA32 Credentials[ANYSIZE_ARRAY];
#endif // MIDL_PASS

} KERB_STORED_CREDENTIAL32, *PKERB_STORED_CREDENTIAL32;

#pragma pack()

#ifdef _WIN64

NTSTATUS
KdcPack32BitStoredCredential(
   IN PKERB_STORED_CREDENTIAL Cred64,
   OUT PKERB_STORED_CREDENTIAL32 * ppCred32,
   OUT PULONG pCredSize
   );

NTSTATUS
KdcUnpack32BitStoredCredential(
    IN PKERB_STORED_CREDENTIAL32 Cred32,
    IN OUT PKERB_STORED_CREDENTIAL * ppCred64,
    IN OUT PULONG CredLength
    );
#endif // WIN64
       



#endif // __KERBCRED_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\inc\kerbcomm.h ===
//+-----------------------------------------------------------------------
//
// File:        kerbcomm.h
//
// Contents:    prototypes for common kerberos routines
//
//
// History:     15-May-1996     Created         MikeSw
//
//------------------------------------------------------------------------

#ifndef _KERBCOMM_H_
#define _KERBCOMM_H_

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus
#include <rpc.h>
#include <rpcndr.h>
#ifndef WIN32_CHICAGO
#include <ntsam.h>
#endif // WIN32_CHICAGO
#include <windef.h>
#include <stdio.h>
#include <limits.h>
#include <winbase.h>
#include <winsock2.h>
#include <krb5.h>
#include <cryptdll.h>
#include <align.h>
#ifdef __cplusplus
}
#endif // _cplusplus
#include <krb5p.h>
#include <kerberr.h>
#include <exterr.h>
#include <kerbcred.h>
#ifndef WIN32_CHICAGO
// SECURITY_WIN32 is already defined
#include <security.h>
#endif // WIN32_CHICAGO

//////////////////////////////////////////////////////////////////////////
//
// Definitions (for lack of a better place)
//
//////////////////////////////////////////////////////////////////////////

//
// Message types
//

#define KRB_AS_REQ      10      // Request for initial authentication
#define KRB_AS_REP      11      // Response to  KRB_AS_REQ request
#define KRB_TGS_REQ     12      // Request for authentication based on TGT
#define KRB_TGS_REP     13      // Response to KRB_TGS_REQ request
#define KRB_AP_REQ      14      // application request to server
#define KRB_AP_REP      15      // Response to KRB_AP_REQ_MUTUAL
#define KRB_TGT_REQ     16      // Request for TGT for user-to-user
#define KRB_TGT_REP     17      // Reply to TGT request
#define KRB_SAFE        20      // Safe (checksummed) application message
#define KRB_PRIV        21      // Private (encrypted) application message
#define KRB_CRED        22      // Private (encrypted) message to forward
                                // credentials
#define KRB_ERROR       30      // Error response


//
// Pre-auth data types

#define KRB5_PADATA_NONE                0
#define KRB5_PADATA_AP_REQ              1
#define KRB5_PADATA_TGS_REQ             KRB5_PADATA_AP_REQ
#define KRB5_PADATA_ENC_TIMESTAMP       2
#define KRB5_PADATA_PW_SALT             3
#define KRB5_PADATA_ENC_UNIX_TIME       5  /* timestamp encrypted in key */
#define KRB5_PADATA_ENC_SANDIA_SECURID  6  /* SecurId passcode */
#define KRB5_PADATA_SESAME              7  /* Sesame project */
#define KRB5_PADATA_OSF_DCE             8  /* OSF DCE */
#define KRB5_CYBERSAFE_SECUREID         9  /* Cybersafe */
#define KRB5_PADATA_AFS3_SALT           10 /* Cygnus */
#define KRB5_PADATA_ETYPE_INFO          11 /* Etype info for preauth */
#define KRB5_PADATA_SAM_CHALLENGE       12 /* draft challenge system */
#define KRB5_PADATA_SAM_RESPONSE        13 /* draft challenge system response */
#define KRB5_PADATA_PK_AS_REQ           14 /* pkinit */
#define KRB5_PADATA_PK_AS_REP           15 /* pkinit */
#define KRB5_PADATA_PK_AS_SIGN          16 /* pkinit */
#define KRB5_PADATA_PK_KEY_REQ          17 /* pkinit */
#define KRB5_PADATA_PK_KEY_REP          18 /* pkinit */
#define KRB5_PADATA_REFERRAL_INFO       20 /* referral names for canonicalization */
#define KRB5_PADATA_PAC_REQUEST         128 /* allow client do request or ignore PAC */
#define KRB5_PADATA_FOR_USER            129 /* target client identity */

//
// Authorization data types
//
#define KERB_AUTH_OSF_DCE       64
#define KERB_AUTH_SESAME        65

//
// NT authorization data type definitions
//

#define KERB_AUTH_DATA_PAC              128     // entry id for a PAC in authorization data
#define KERB_AUTH_PROXY_ANNOTATION      139     // entry id for a proxy logon annotation string

#define KERB_AUTH_DATA_IF_RELEVANT      1       // entry id for optional auth data
#define KERB_AUTH_DATA_KDC_ISSUED       4       // entry id for data generated & signed by KDC
#define KERB_AUTH_DATA_TOKEN_RESTRICTIONS 141   // entry id for token restrictions
//
// Transited realm compression types:
//

#define DOMAIN_X500_COMPRESS            1

//
// Certificate types for PKINIT
//

#define KERB_CERTIFICATE_TYPE_X509      1
#define KERB_CERTIFICATE_TYPE_PGP       2

//
// Signature & seal types used by PKINIT
//

#define KERB_PKINIT_SIGNATURE_ALG               CALG_MD5
#define KERB_PKINIT_EXPORT_SEAL_OID             szOID_RSA_RC2CBC
#define KERB_PKINIT_EXPORT_SEAL_ETYPE           KERB_ETYPE_RC2_CBC_ENV
#define KERB_PKINIT_SEAL_ETYPE                  KERB_ETYPE_DES_EDE3_CBC_ENV
#define KERB_PKINIT_SEAL_OID                    szOID_RSA_DES_EDE3_CBC
#define KERB_PKINIT_SIGNATURE_OID               szOID_RSA_MD5RSA
#define KERB_PKINIT_KDC_CERT_TYPE               szOID_PKIX_KP_SERVER_AUTH

#ifdef szOID_KP_SMARTCARD_LOGON
#define KERB_PKINIT_CLIENT_CERT_TYPE szOID_KP_SMARTCARD_LOGON
#else
#define KERB_PKINIT_CLIENT_CERT_TYPE "1.3.6.1.4.1.311.20.2.2"
#endif


//
// Transport information
//

#define KERB_KDC_PORT                   88
#define KERB_KPASSWD_PORT               464

//
// KDC service principal
//

#define KDC_PRINCIPAL_NAME              L"krbtgt"
#define KDC_PRINCIPAL_NAME_A            "krbtgt"
#define KERB_HOST_STRING_A              "host"
#define KERB_HOST_STRING                L"host"
#define KERB_KPASSWD_FIRST_NAME         L"kadmin"
#define KERB_KPASSWD_SECOND_NAME        L"changepw"


//
// address types - corresponds to GSS types
//
#define KERB_ADDRTYPE_UNSPEC           0x0
#define KERB_ADDRTYPE_LOCAL            0x1
#define KERB_ADDRTYPE_INET             0x2
#define KERB_ADDRTYPE_IMPLINK          0x3
#define KERB_ADDRTYPE_PUP              0x4
#define KERB_ADDRTYPE_CHAOS            0x5
#define KERB_ADDRTYPE_NS               0x6
#define KERB_ADDRTYPE_NBS              0x7
#define KERB_ADDRTYPE_ECMA             0x8
#define KERB_ADDRTYPE_DATAKIT          0x9
#define KERB_ADDRTYPE_CCITT            0xA
#define KERB_ADDRTYPE_SNA              0xB
#define KERB_ADDRTYPE_DECnet           0xC
#define KERB_ADDRTYPE_DLI              0xD
#define KERB_ADDRTYPE_LAT              0xE
#define KERB_ADDRTYPE_HYLINK           0xF
#define KERB_ADDRTYPE_APPLETALK        0x10
#define KERB_ADDRTYPE_BSC              0x11
#define KERB_ADDRTYPE_DSS              0x12
#define KERB_ADDRTYPE_OSI              0x13
#define KERB_ADDRTYPE_NETBIOS          0x14
#define KERB_ADDRTYPE_X25              0x15


//
// Misc. Flags
//

#define KERB_EXPORT_KEY_FLAG 0x20000000
#define KERB_NO_KEY_VERSION 0

//
// SALT flags for encryption, from rfc1510 update 3des enctype
//

#define KERB_ENC_TIMESTAMP_SALT         1
#define KERB_TICKET_SALT                2
#define KERB_AS_REP_SALT                3
#define KERB_TGS_REQ_SESSKEY_SALT       4
#define KERB_TGS_REQ_SUBKEY_SALT        5
#define KERB_TGS_REQ_AP_REQ_AUTH_CKSUM_SALT     6
#define KERB_TGS_REQ_AP_REQ_AUTH_SALT   7
#define KERB_TGS_REP_SALT               8
#define KERB_TGS_REP_SUBKEY_SALT        9
#define KERB_AP_REQ_AUTH_CKSUM_SALT     10
#define KERB_AP_REQ_AUTH_SALT           11
#define KERB_AP_REP_SALT                12
#define KERB_PRIV_SALT                  13
#define KERB_CRED_SALT                  14
#define KERB_SAFE_SALT                  15
#define KERB_NON_KERB_SALT              16
#define KERB_NON_KERB_CKSUM_SALT        17
#define KERB_KERB_ERROR_SALT            18
#define KERB_KDC_ISSUED_CKSUM_SALT      19
#define KERB_MANDATORY_TKT_EXT_CKSUM_SALT       20
#define KERB_AUTH_DATA_TKT_EXT_CKSUM_SALT       21

//
// Types for AP error data
//

#define KERB_AP_ERR_TYPE_NTSTATUS             1
#define KERB_AP_ERR_TYPE_SKEW_RECOVERY        2
#define KERB_ERR_TYPE_EXTENDED                3 // obselete

//
// Types for extended errors
//

#define TD_MUST_USE_USER2USER                 -128
#define TD_EXTENDED_ERROR                     -129

//
// PKINIT method errors
//
#define KERB_PKINIT_UNSPEC_ERROR        0       // not specified
#define KERB_PKINIT_BAD_PUBLIC_KEY      1       // cannot verify public key
#define KERB_PKINIT_INVALID_CERT        2       // invalid certificate
#define KERB_PKINIT_REVOKED_CERT        3       // revoked certificate
#define KERB_PKINIT_INVALID_KDC_NAME    4       // invalid KDC name
#define KERB_PKINIT_CLIENT_NAME_MISMATCH 5      // client name mismatch

//
// HACK for MAX_UNICODE_STRING, as KerbDuplicateString & others add a NULL
// terminator when doing the duplication
//
#define KERB_MAX_UNICODE_STRING (UNICODE_STRING_MAX_BYTES - sizeof(WCHAR))
#define KERB_MAX_STRING         (UNICODE_STRING_MAX_BYTES - sizeof(CHAR))


//////////////////////////////////////////////////////////////////////////
//
// Structures
//
//////////////////////////////////////////////////////////////////////////

typedef struct _KERB_PREAUTH_DATA {
    ULONG Flags;
} KERB_PREAUTH_DATA, *PKERB_PREAUTH_DATA;

#define KERBFLAG_LOGON                  0x1
#define KERBFLAG_INTERACTIVE            0x2

//
// KDC-Kerberos interaction
//

#define KDC_START_EVENT                 L"\\Security\\KdcStartEvent"

#define KERB_MAX_CRYPTO_SYSTEMS 20
#define KERB_MAX_CRYPTO_SYSTEMS_SLOWBUFF 100

#define KERB_DEFAULT_AP_REQ_CSUM        KERB_CHECKSUM_MD5
#define KERB_DEFAULT_PREAUTH_TYPE       0

//
// Registry parameters
//

#define KERB_PATH                       L"System\\CurrentControlSet\\Control\\Lsa\\Kerberos"
#define KERB_PARAMETER_PATH             L"System\\CurrentControlSet\\Control\\Lsa\\Kerberos\\Parameters"
#define KERB_PARAMETER_SKEWTIME         L"SkewTime"
#define KERB_PARAMETER_MAX_UDP_PACKET   L"MaxPacketSize"
#define KERB_PARAMETER_START_TIME       L"StartupTime"
#define KERB_PARAMETER_KDC_CALL_TIMEOUT L"KdcWaitTime"
#define KERB_PARAMETER_KDC_BACKOFF_TIME L"KdcBackoffTime"
#define KERB_PARAMETER_KDC_SEND_RETRIES L"KdcSendRetries"
#define KERB_PARAMETER_LOG_LEVEL        L"LogLevel"
#define KERB_PARAMETER_DEFAULT_ETYPE    L"DefaultEncryptionType"
#define KERB_PARAMETER_FAR_KDC_TIMEOUT  L"FarKdcTimeout"
#define KERB_PARAMETER_NEAR_KDC_TIMEOUT L"NearKdcTimeout"
#define KERB_PARAMETER_STRONG_ENC_DG    L"StronglyEncryptDatagram"
#define KERB_PARAMETER_MAX_REFERRAL_COUNT L"MaxReferralCount"
#define KERB_PARAMETER_MAX_TOKEN_SIZE     L"MaxTokenSize"
#define KERB_PARAMETER_SPN_CACHE_TIMEOUT  L"SpnCacheTimeout"
#define KERB_PARAMETER_S4UCACHE_TIMEOUT   L"S4UCacheTimeout"
#define KERB_PARAMETER_S4UTICKET_LIFETIME L"S4UTicketLifetime"
#define KERB_PARAMETER_CACHE_S4UTICKET    L"CacheS4UTickets"

#define KERB_PARAMETER_RETRY_PDC          L"RetryPDC"
#define KERB_PARAMETER_REQUEST_OPTIONS      L"RequestOptions"
#define KERB_PARAMETER_CLIENT_IP_ADDRESSES  L"ClientIpAddresses"
#define KERB_PARAMETER_TGT_RENEWAL_TIME     L"TgtRenewalTime"
#define KERB_PARAMETER_ALLOW_TGT_SESSION_KEY L"AllowTgtSessionKey"
#define KERB_PARAMETER_MAX_TICKETS       L"MaximumTickets"


//
// Registry defaults
//

#define KERB_DEFAULT_LOGLEVEL 0
#define KERB_DEFAULT_USE_STRONG_ENC_DG FALSE
#define KERB_DEFAULT_CACHE_S4UTICKET   TRUE
#define KERB_DEFAULT_CLIENT_IP_ADDRESSES 0
#define KERB_DEFAULT_TGT_RENEWAL_TIME 600
#define KERB_DEFAULT_ALLOW_TGT_SESSION_KEY FALSE


#define KERB_TICKET_COLLECTOR_INTERVAL              1000 * 60 * 15 // every 15 minutes
#define KERB_TICKET_COLLECTOR_THRESHHOLD            2000

//
// These are arbitrary sizes for max request and responses sizes for datagram
// requests.
//

// specifies how large a receive buffer to create for a datagram (UDP) read
#define KERB_MAX_KDC_RESPONSE_SIZE      4000

// specifies the incremental buffer size expansion to use to socket re-read
#define KERB_MAX_KDC_REQUEST_SIZE       4000

// initial setting (registry modifiable KERB_PARAMETER_MAX_UDP_PACKET)
//       - controls kerberos client message size threshold for change from UDP to TCP
#define KERB_MAX_DATAGRAM_SIZE          1465

// initial setting (registry modifiable) - controls KDC message reply size threshold for request change from UDP to TCP
//  original default was KERB_MAX_KDC_RESPONSE_SIZE = 4000  Raid 632547
#define KERB_MAX_DATAGRAM_REPLY_SIZE          1465

#define KERB_MAX_RETRIES                3
#define KERB_MAX_REFERRAL_COUNT         3

//
// timeout values in minutes and appropriate minimums.
//

#define KERB_BINDING_FAR_DC_TIMEOUT     10
#define KERB_BINDING_NEAR_DC_TIMEOUT    30
#define KERB_SPN_CACHE_TIMEOUT          15
#define KERB_S4U_CACHE_TIMEOUT          15
#define KERB_S4U_QUERY_INTERVAL         15
#define KERB_S4U_TICKET_LIFETIME        15
#define KERB_DEFAULT_SKEWTIME           5



#define KERB_MIN_S4UTICKET_LIFETIME     5



//
// Network service session timer callback frequency
//

#define KERB_SKLIST_CALLBACK_FEQ        10

//
// timeout values in seconds
//

#define KERB_KDC_CALL_TIMEOUT                   5
#define KERB_KDC_CALL_TIMEOUT_BACKOFF           5
#define KERB_KDC_WAIT_TIME      120

//
// BER encoding values
//

#define KERB_BER_APPLICATION_TAG 0xc0
#define KERB_BER_APPLICATION_MASK 0x1f
#define KERB_TGS_REQ_TAG 12
#define KERB_AS_REQ_TAG 10
#define KERB_TGS_REP_TAG 13
#define KERB_AS_REP_TAG 11
#define KERB_ERROR_TAG 30

//
// Common types
//

typedef struct _KERB_MESSAGE_BUFFER {
    ULONG BufferSize;
    PUCHAR Buffer;
} KERB_MESSAGE_BUFFER, *PKERB_MESSAGE_BUFFER;

typedef enum _KERB_ACCOUNT_TYPE {
    UserAccount,
    MachineAccount,
    DomainTrustAccount,
    UnknownAccount
} KERB_ACCOUNT_TYPE, *PKERB_ACCOUNT_TYPE;

//
// This is the maximum number of elements in a KERB_INTERNAL_NAME
//

#define MAX_NAME_ELEMENTS 20

typedef struct _KERB_INTERNAL_NAME {
    SHORT NameType;
    USHORT NameCount;
    UNICODE_STRING Names[ANYSIZE_ARRAY];
} KERB_INTERNAL_NAME, *PKERB_INTERNAL_NAME;

//
// Prototypes
//
#ifdef __cplusplus

class CAuthenticatorList;

KERBERR NTAPI
KerbCheckTicket(
    IN  PKERB_TICKET PackedTicket,
    IN  PKERB_ENCRYPTED_DATA EncryptedAuthenticator,
    IN  PKERB_ENCRYPTION_KEY pkKey,
    IN  OUT CAuthenticatorList * AuthenticatorList,
    IN  PTimeStamp SkewTime,
    IN  ULONG ServiceNameCount,
    IN  OPTIONAL PUNICODE_STRING ServiceName,
    IN  OPTIONAL PUNICODE_STRING ServiceRealm,
    IN  BOOLEAN CheckForReplay,
    IN  BOOLEAN KdcRequest,
    OUT PKERB_ENCRYPTED_TICKET * EncryptTicket,
    OUT PKERB_AUTHENTICATOR  * Authenticator,
    OUT PKERB_ENCRYPTION_KEY pkSessionKey,
    OUT OPTIONAL PKERB_ENCRYPTION_KEY pkTicketKey,
    OUT PBOOLEAN UseSubKey
    );

extern "C" {

#endif // __cplusplus

KERBERR
KerbVerifyTicket(
    IN PKERB_TICKET PackedTicket,
    IN ULONG NameCount,
    IN OPTIONAL PUNICODE_STRING ServiceNames,
    IN OPTIONAL PUNICODE_STRING ServiceRealm,
    IN PKERB_ENCRYPTION_KEY ServiceKey,
    IN OPTIONAL PTimeStamp SkewTime,
    OUT PKERB_ENCRYPTED_TICKET * DecryptedTicket
    );

BOOLEAN
KerbVerifyClientAddress(
    IN SOCKADDR * ClientAddress,
    IN PKERB_HOST_ADDRESSES Addresses
    );


KERBERR NTAPI
KerbPackTicket(
    IN PKERB_TICKET InternalTicket,
    IN PKERB_ENCRYPTION_KEY pkKey,
    IN ULONG KeyVersion,
    OUT PKERB_TICKET PackedTicket
    );

VOID
KerbPrintPrincipalName(
    IN ULONG DebugLevel,
    IN PKERB_PRINCIPAL_NAME Name
    );

NTSTATUS
KerbHashS4UPreauth(
    IN PKERB_PA_FOR_USER S4UPreauth,
    IN PKERB_ENCRYPTION_KEY Key,
    IN LONG ChecksumType,
    IN OUT PKERB_CHECKSUM CheckSum
    );

VOID KerbPrintKerbRealm(
    IN ULONG DebugLevel,
    IN PKERB_REALM Realm
    );

KERBERR NTAPI
KerbUnpackTicket(
    IN PKERB_TICKET PackedTicket,
    IN PKERB_ENCRYPTION_KEY pkKey,
    OUT PKERB_ENCRYPTED_TICKET * InternalTicket
    );

// VOID NTAPI
// KerbFreeTicket(
//     IN PKERB_ENCRYPTED_TICKET Ticket
//     );

#define KerbFreeTicket( Ticket ) \
    KerbFreeData( \
        KERB_ENCRYPTED_TICKET_PDU, \
        (Ticket) \
        )

KERBERR NTAPI
KerbDuplicateTicket(
    OUT PKERB_TICKET DestinationTicket,
    IN PKERB_TICKET SourceTicket
    );

VOID
KerbFreeDuplicatedTicket(
    IN PKERB_TICKET Ticket
    );

VOID
CheckForOutsideStringToKey();

KERBERR NTAPI
KerbHashPassword(
    IN PUNICODE_STRING Password,
    IN ULONG EncryptionType,
    OUT PKERB_ENCRYPTION_KEY Key
    );

KERBERR NTAPI
KerbHashPasswordEx(
    IN PUNICODE_STRING Password,
    IN PUNICODE_STRING PrincipalName,
    IN ULONG EncryptionType,
    OUT PKERB_ENCRYPTION_KEY Key
    );

KERBERR NTAPI
KerbMakeKey(
    IN ULONG EncryptionType,
    OUT PKERB_ENCRYPTION_KEY NewKey
    );

BOOLEAN
KerbIsKeyExportable(
    IN PKERB_ENCRYPTION_KEY Key
    );

KERBERR
KerbMakeExportableKey(
    IN ULONG KeyType,
    OUT PKERB_ENCRYPTION_KEY NewKey
    );

KERBERR NTAPI
KerbCreateKeyFromBuffer(
    OUT PKERB_ENCRYPTION_KEY NewKey,
    IN PUCHAR Buffer,
    IN ULONG BufferSize,
    IN ULONG EncryptionType
    );

KERBERR NTAPI
KerbDuplicateKey(
    OUT PKERB_ENCRYPTION_KEY NewKey,
    IN PKERB_ENCRYPTION_KEY Key
    );

VOID
KerbFreeKey(
    IN PKERB_ENCRYPTION_KEY Key
    );

PKERB_ENCRYPTION_KEY
KerbGetKeyFromList(
    IN PKERB_STORED_CREDENTIAL Passwords,
    IN ULONG EncryptionType
    );

PKERB_ENCRYPTION_KEY
KerbGetKeyFromListByIndex(
    IN PKERB_STORED_CREDENTIAL Passwords,
    IN ULONG EncryptionType,
    OUT PULONG pIndex
    );

KERBERR
KerbFindCommonCryptSystem(
    IN PKERB_CRYPT_LIST CryptList,
    IN PKERB_STORED_CREDENTIAL Passwords,
    IN OPTIONAL PKERB_STORED_CREDENTIAL MorePasswords,
    OUT PKERB_ENCRYPTION_KEY * Key
    );

KERBERR
KerbFindCommonCryptSystemForSKey(
    IN PKERB_CRYPT_LIST CryptList,
    IN PKERB_CRYPT_LIST CryptListSupported,
    OUT ULONG * Etype
    );

KERBERR NTAPI
KerbRandomFill(
    IN OUT PUCHAR pbBuffer,
    IN ULONG cbBuffer
    );

KERBERR NTAPI
KerbCreateAuthenticator(
    IN PKERB_ENCRYPTION_KEY pkKey,
    IN ULONG SequenceNumber,
    OUT OPTIONAL PTimeStamp pAuthenticatorTime,
    IN PKERB_INTERNAL_NAME ClientName,
    IN PUNICODE_STRING ClientRealm,
    IN PTimeStamp ptsTime,
    IN PKERB_ENCRYPTION_KEY pkSubKey,
    IN OPTIONAL PKERB_CHECKSUM GssChecksum,
    IN BOOLEAN KdcRequest,
    OUT PKERB_ENCRYPTED_DATA Authenticator
    );

KERBERR NTAPI
KerbUnpackAuthenticator(
    IN PKERB_ENCRYPTION_KEY Key,
    IN PKERB_ENCRYPTED_DATA EncryptedAuthenticator,
    IN BOOLEAN KdcRequest,
    OUT PKERB_AUTHENTICATOR * Authenticator
    );


DWORD
KerbCopyDomainRelativeSid(
    OUT PSID TargetSid,
    IN PSID  DomainId,
    IN ULONG RelativeId
    );


// VOID NTAPI
// KerbFreeAuthenticator(
//     IN PKERB_AUTHENTICATOR Authenticator
//     );

#define KerbFreeAuthenticator( Authenticator ) \
    KerbFreeData( \
        KERB_AUTHENTICATOR_PDU, \
        (Authenticator) \
        )

KERBERR NTAPI
KerbPackKdcReplyBody(
    IN PKERB_ENCRYPTED_KDC_REPLY ReplyBody,
    IN PKERB_ENCRYPTION_KEY Key,
    IN ULONG KeyVersion,
    IN ULONG KeySalt,
    IN ULONG Pdu,
    OUT PKERB_ENCRYPTED_DATA EncryptedReply
    );

KERBERR NTAPI
KerbUnpackKdcReplyBody(
    IN PKERB_ENCRYPTED_DATA EncryptedReplyBody,
    IN PKERB_ENCRYPTION_KEY Key,
    IN ULONG Pdu,
    OUT PKERB_ENCRYPTED_KDC_REPLY * ReplyBody
    );

KERBERR NTAPI
KerbPackData(
    IN PVOID Data,
    IN ULONG PduValue,
    OUT PULONG DataSize,
    OUT PUCHAR * MarshalledData
    );

KERBERR NTAPI
KerbUnpackData(
    IN PUCHAR Data,
    IN ULONG DataSize,
    IN ULONG PduValue,
    OUT PVOID * DecodedData
    );

VOID
KerbFreeData(
    IN ULONG PduValue,
    IN PVOID Data
    );

// KERBERR NTAPI
// KerbPackAsReply(
//     IN PKERB_KDC_REPLY ReplyMessage,
//     OUT PULONG ReplySize,
//     OUT PUCHAR * MarshalledReply
//     );

#define KerbPackAsReply( ReplyMessage, ReplySize, MarshalledReply ) \
    KerbPackData( \
        (PVOID) (ReplyMessage), \
        KERB_AS_REPLY_PDU, \
        (ReplySize), \
        (MarshalledReply) \
        )

// KERBERR NTAPI
// KerbUnpackAsReply(
//     IN PUCHAR ReplyMessage,
//     IN ULONG ReplySize,
//     OUT PKERB_KDC_REPLY * Reply
//     );

#define KerbUnpackAsReply( ReplyMessage, ReplySize, Reply ) \
    KerbUnpackData( \
        (ReplyMessage), \
        (ReplySize), \
        KERB_AS_REPLY_PDU, \
        (PVOID *) (Reply) \
        )

// VOID
// KerbFreeAsReply(
//    IN PKERB_KDC_REPLY Request
//    );

#define KerbFreeAsReply( Request) \
    KerbFreeData( \
        KERB_AS_REPLY_PDU, \
        (PVOID) (Request) \
        )

// KERBERR NTAPI
// KerbPackTgsReply(
//     IN PKERB_KDC_REPLY ReplyMessage,
//     OUT PULONG ReplySize,
//     OUT PUCHAR * MarshalledReply
//     );

#define KerbPackTgsReply( ReplyMessage, ReplySize, MarshalledReply ) \
    KerbPackData( \
        (PVOID) (ReplyMessage), \
        KERB_TGS_REPLY_PDU, \
        (ReplySize), \
        (MarshalledReply) \
        )

// KERBERR NTAPI
// KerbUnpackTgsReply(
//     IN PUCHAR ReplyMessage,
//     IN ULONG ReplySize,
//     OUT PKERB_KDC_REPLY * Reply
//     );

#define KerbUnpackTgsReply( ReplyMessage, ReplySize, Reply ) \
    KerbUnpackData( \
        (ReplyMessage), \
        (ReplySize), \
        KERB_TGS_REPLY_PDU, \
        (PVOID *) (Reply) \
        )

// VOID
// KerbFreeTgsReply(
//    IN PKERB_KDC_REPLY Request
//    );

#define KerbFreeTgsReply( Request) \
    KerbFreeData( \
        KERB_TGS_REPLY_PDU, \
        (PVOID) (Request) \
        )

// VOID
// KerbFreeKdcReplyBody(
//    IN PKERB_ENCRYPTED_KDC_REPLY Request
//    );

#define KerbFreeKdcReplyBody( Request) \
    KerbFreeData( \
        KERB_ENCRYPTED_TGS_REPLY_PDU, \
        (PVOID) (Request) \
        )

// KERBERR NTAPI
// KerbPackAsRequest(
//     IN PKERB_KDC_REQUEST RequestMessage,
//     OUT PULONG RequestSize,
//     OUT PUCHAR * MarshalledRequest
//     );

#define KerbPackAsRequest( RequestMessage, RequestSize, MarshalledRequest )\
    KerbPackData( \
        (PVOID) (RequestMessage), \
        KERB_AS_REQUEST_PDU, \
        (RequestSize), \
        (MarshalledRequest) \
        )

// KERBERR NTAPI
// KerbUnpackAsRequest(
//     IN PUCHAR RequestMessage,
//     IN ULONG RequestSize,
//     OUT PKERB_KDC_REQUEST * Request
//     );

#define KerbUnpackAsRequest( RequestMessage, RequestSize, Request ) \
    KerbUnpackData( \
        (RequestMessage), \
        (RequestSize), \
        KERB_AS_REQUEST_PDU, \
        (PVOID *) (Request) \
        )

// VOID
// KerbFreeAsRequest(
//    IN PKERB_KDC_REQUEST Request
//    );

#define KerbFreeAsRequest( Request) \
    KerbFreeData( \
        KERB_TGS_REQUEST_PDU, \
        (PVOID) (Request) \
        )

// KERBERR NTAPI
// KerbPackTgsRequest(
//     IN PKERB_KDC_REQUEST RequestMessage,
//     OUT PULONG RequestSize,
//     OUT PUCHAR * MarshalledRequest
//     );

#define KerbPackTgsRequest( RequestMessage, RequestSize, MarshalledRequest )\
    KerbPackData( \
        (PVOID) (RequestMessage), \
        KERB_TGS_REQUEST_PDU, \
        (RequestSize), \
        (MarshalledRequest) \
        )

// KERBERR NTAPI
// KerbUnpackTgsRequest(
//     IN PUCHAR RequestMessage,
//     IN ULONG RequestSize,
//     OUT PKERB_KDC_REQUEST * Request
//     );

#define KerbUnpackTgsRequest( RequestMessage, RequestSize, Request ) \
    KerbUnpackData( \
        (RequestMessage), \
        (RequestSize), \
        KERB_TGS_REQUEST_PDU, \
        (PVOID *) (Request) \
        )

// VOID
// KerbFreeTgsRequest(
//    IN PKERB_KDC_REQUEST Request
//    );

#define KerbFreeTgsRequest( Request) \
    KerbFreeData( \
        KERB_TGS_REQUEST_PDU, \
        (PVOID) (Request) \
        )

// KERBERR NTAPI
// KerbPackEncryptedData(
//     IN PKERB_ENCRYPTED_DATA EncryptedData,
//     OUT PULONG DataSize,
//     OUT PUCHAR * MarshalledData
//     );

#define KerbPackEncryptedData( EncryptedData, DataSize, MarshalledData ) \
    KerbPackData( \
        (PVOID) (EncryptedData), \
        KERB_ENCRYPTED_DATA_PDU, \
        (DataSize), \
        (PUCHAR *) (MarshalledData) \
        )

// KERBERR NTAPI
// KerbUnpackEncryptedData(
//     IN PUCHAR EncryptedData,
//    IN ULONG DataSize,
//    OUT PKERB_ENCRYPTED_DATA * Data
//    );

#define KerbUnpackEncryptedData( EncryptedData,DataSize,Data ) \
    KerbUnpackData( \
        (EncryptedData), \
        (DataSize), \
        KERB_ENCRYPTED_DATA_PDU, \
        (PVOID *) (Data) \
        )

// VOID
// KerbFreeEncryptedData(
//    IN PKERB_ENCRYPTED_DATA EncryptedData
//    );

#define KerbFreeEncryptedData( EncryptedData) \
    KerbFreeData( \
        KERB_ENCRYPTED_DATA_PDU, \
        (PVOID) (EncryptedData) \
        )

#ifdef notdef
// KERBERR NTAPI
// KerbPackAuthData(
//     IN PKERB_AUTHORIZATION_DATA AuthData,
//     OUT PULONG AuthDataSize,
//     OUT PUCHAR * MarshalledAuthData
//     );

#define KerbPackAuthData( AuthData, AuthDataSize, MarshalledAuthData ) \
    KerbPackData( \
        (PVOID) (AuthData), \
        KERB_AUTHORIZATION_DATA_PDU, \
        (AuthDataSize), \
        (MarshalledAuthData) \
        )

// KERBERR NTAPI
// KerbUnpackAuthData(
//     IN PUCHAR PackedAuthData,
//     IN ULONG AuthDataSize,
//     OUT PKERB_AUTHORIZATION_DATA * AuthData
//     );

#define KerbUnpackAuthData( PackedAuthData, AuthDataSize, AuthData ) \
    KerbUnpackData( \
        (PackedAuthData), \
        (AuthDataSize), \
        KERB_AUTHORIZATION_DATA_PDU, \
        (PVOID *) (AuthData) \
        )

// VOID
// KerbFreeAuthData(
//    IN PKERB_AUTH_DATA AuthData
//    );

#define KerbFreeAuthData( AuthData) \
    KerbFreeData( \
        KERB_AUTHORIZATION_DATA_PDU, \
        (PVOID) (AuthData) \
        )

#endif // notdef

VOID
KerbFreeAuthData(
   IN PKERB_AUTHORIZATION_DATA AuthData
   );

// KERBERR NTAPI
// KerbPackApRequest(
//     IN PKERB_AP_REQUEST ApRequestMessage,
//     OUT PULONG ApRequestSize,
//     OUT PUCHAR * MarshalledApRequest
//     );

#define KerbPackApRequest( ApRequestMessage, ApRequestSize, MarshalledApRequest ) \
    KerbPackData( \
        (PVOID) (ApRequestMessage), \
        KERB_AP_REQUEST_PDU, \
        (ApRequestSize), \
        (MarshalledApRequest) \
        )

// KERBERR NTAPI
// KerbUnpackApRequest(
//    IN PUCHAR ApRequestMessage,
//    IN ULONG ApRequestSize,
//    OUT PKERB_AP_REQUEST * ApRequest
//    );

#define KerbUnpackApRequest( ApRequestMessage,ApRequestSize, ApRequest) \
    KerbUnpackData( \
        (ApRequestMessage), \
        (ApRequestSize), \
        KERB_AP_REQUEST_PDU, \
        (PVOID *) (ApRequest) \
        )

// VOID
// KerbFreeApRequest(
//    IN PKERB_AP_REQUEST Request
//    );

#define KerbFreeApRequest( Request) \
    KerbFreeData( \
        KERB_AP_REQUEST_PDU, \
        (PVOID) (Request) \
        )


// KERBERR NTAPI
// KerbPackApReply(
//     IN PKERB_AP_REPLY ApReplyMessage,
//     OUT PULONG ApReplySize,
//     OUT PUCHAR * MarshalledApReply
//     );

#define KerbPackApReply( ApReplyMessage, ApReplySize, MarshalledApReply ) \
    KerbPackData( \
        (PVOID) (ApReplyMessage), \
        KERB_AP_REPLY_PDU, \
        (ApReplySize), \
        (MarshalledApReply) \
        )

// KERBERR NTAPI
// KerbUnpackApReply(
//     IN PUCHAR ApReplyMessage,
//     IN ULONG ApReplySize,
//     OUT PKERB_AP_REPLY * ApReply
//    );

#define KerbUnpackApReply( ApReplyMessage,ApReplySize, ApReply) \
    KerbUnpackData( \
        (ApReplyMessage), \
        (ApReplySize), \
        KERB_AP_REPLY_PDU, \
        (PVOID *) (ApReply) \
        )

// VOID
// KerbFreeApReply(
//    IN PKERB_AP_REPLY Reply
//    );

#define KerbFreeApReply( Reply) \
    KerbFreeData( \
        KERB_AP_REPLY_PDU, \
        (PVOID) (Reply) \
        )

// KERBERR NTAPI
// KerbPackApReplyBody(
//     IN PKERB_ENCRYPTED_AP_REPLY ApReplyBodyMessage,
//     OUT PULONG ApReplyBodySize,
//     OUT PUCHAR * MarshalledApReplyBody
//    );

#define KerbPackApReplyBody( ApReplyBodyMessage, ApReplyBodySize, MarshalledApReplyBody ) \
    KerbPackData( \
        (PVOID) (ApReplyBodyMessage), \
        KERB_ENCRYPTED_AP_REPLY_PDU, \
        (ApReplyBodySize), \
        (MarshalledApReplyBody) \
        )

// KERBERR NTAPI
// KerbUnpackApReplyBody(
//     IN PUCHAR ApReplyBodyMessage,
//     IN ULONG ApReplyBodySize,
//     OUT PKERB_ENCRYPTED_AP_REPLY * ApReplyBody
//    );

#define KerbUnpackApReplyBody( ApReplyBodyMessage,ApReplyBodySize, ApReplyBody) \
    KerbUnpackData( \
        (ApReplyBodyMessage), \
        (ApReplyBodySize), \
        KERB_ENCRYPTED_AP_REPLY_PDU, \
        (PVOID *) (ApReplyBody) \
        )

// VOID
// KerbFreeApReplyBody(
//    IN PKERB_ENCRYPTED_AP_REPLY ReplyBody
//    );

#define KerbFreeApReplyBody( ReplyBody) \
    KerbFreeData( \
        KERB_ENCRYPTED_AP_REPLY_PDU, \
        (PVOID) (ReplyBody) \
        )

// KERBERR NTAPI
// KerbUnmarshallTicket(
//     IN PUCHAR TicketMessage,
//     IN ULONG TicketSize,
//     OUT PKERB_ENCRYPTED_TICKET * Ticket
//     );

#define KerbUnmarshallTicket( TicketMessage, TicketSize, Ticket ) \
    KerbUnpackData( \
        (TicketMessage), \
        (TicketSize), \
        KERB_ENCRYPTED_TICKET_PDU, \
        (PVOID *) (Ticket) \
        )

// KERBERR NTAPI
// KerbPackEncryptedCred(
//     IN PKERB_ENCRYPTED_CRED EncryptedCred,
//     OUT PULONG CredSize,
//     OUT PUCHAR * MarshalledCred
//     );

#define KerbPackEncryptedCred( EncryptedCred, CredSize, MarshalledCred ) \
    KerbPackData( \
        (PVOID) (EncryptedCred), \
        KERB_ENCRYPTED_CRED_PDU, \
        (CredSize), \
        (MarshalledCred) \
        )

// KERBERR NTAPI
// KerbUnpackEncryptedCred(
//     IN PUCHAR EncryptedCred,
//    IN ULONG CredSize,
//    OUT PKERB_ENCRYPTED_CRED * Cred
//    );

#define KerbUnpackEncryptedCred( EncryptedCred,CredSize,Cred ) \
    KerbUnpackData( \
        (EncryptedCred), \
        (CredSize), \
        KERB_ENCRYPTED_CRED_PDU, \
        (PVOID *) (Cred) \
        )

// VOID
// KerbFreeEncryptedCred(
//    IN PKERB_ENCRYPTED_CRED EncryptedCred
//    );

#define KerbFreeEncryptedCred( EncryptedCred) \
    KerbFreeData( \
        KERB_ENCRYPTED_CRED_PDU, \
        (PVOID) (EncryptedCred) \
        )

// KERBERR NTAPI
// KerbPackKerbCred(
//     IN PKERB_CRED KerbCred,
//     OUT PULONG KerbCredSize,
//     OUT PUCHAR * MarshalledKerbCred
//     );

#define KerbPackKerbCred( KerbCred, KerbCredSize, MarshalledKerbCred ) \
    KerbPackData( \
        (PVOID) (KerbCred), \
        KERB_CRED_PDU, \
        (KerbCredSize), \
        (MarshalledKerbCred) \
        )

// KERBERR NTAPI
// KerbUnpackKerbCred(
//    IN PUCHAR MarshalledKerbCred,
//    IN ULONG KerbCredSize,
//    OUT PKERB_CRED * KerbCred
//    );

#define KerbUnpackKerbCred( MarshalledKerbCred,KerbCredSize,KerbCred ) \
    KerbUnpackData( \
        (MarshalledKerbCred), \
        (KerbCredSize), \
        KERB_CRED_PDU, \
        (PVOID *) (KerbCred) \
        )

// VOID
// KerbFreeKerbCred(
//    IN PKERB_CRED KerbCred
//    );

#define KerbFreeKerbCred( KerbCred) \
    KerbFreeData( \
        KERB_CRED_PDU, \
        (PVOID) (KerbCred) \
        )

// KERBERR NTAPI
// KerbPackKerbError(
//     IN PKERB_ERROR ErrorMessage,
//     OUT PULONG ErrorSize,
//     OUT PUCHAR * MarshalledError
//     );

#define KerbPackKerbError( ErrorMessage, ErrorSize, MarshalledError ) \
    KerbPackData( \
        (PVOID) (ErrorMessage), \
        KERB_ERROR_PDU, \
        (ErrorSize), \
        (MarshalledError) \
        )

// KERBERR NTAPI
// KerbUnpackKerbError(
//     IN PUCHAR ErrorMessage,
//     IN ULONG ErrorSize,
//     OUT PKERB_ERROR * Error
//     );

#define KerbUnpackKerbError( ErrorMessage, ErrorSize, Error ) \
    KerbUnpackData( \
        (ErrorMessage), \
        (ErrorSize), \
        KERB_ERROR_PDU, \
        (PVOID *) (Error) \
        )

// VOID
// KerbFreeKerbError(
//    IN PKERB_ERROR Request
//    );

#define KerbFreeKerbError( Error ) \
    KerbFreeData( \
        KERB_ERROR_PDU, \
        (PVOID) (Error) \
        )

// KERBERR NTAPI
// KerbPackEncryptedTime(
//     IN PKERB_ENCRYPTED_TIMESTAMP EncryptedTimeMessage,
//     OUT PULONG EncryptedTimeSize,
//     OUT PUCHAR * MarshalledEncryptedTime
//     );

#define KerbPackEncryptedTime( EncryptedTimeMessage, EncryptedTimeSize, MarshalledEncryptedTime ) \
    KerbPackData( \
        (PVOID) (EncryptedTimeMessage), \
        KERB_ENCRYPTED_TIMESTAMP_PDU, \
        (EncryptedTimeSize), \
        (MarshalledEncryptedTime) \
        )

// KERBERR NTAPI
// KerbUnpackEncryptedTime(
//     IN PUCHAR EncryptedTimeMessage,
//     IN ULONG EncryptedTimeSize,
//     OUT PKERB_ENCRYPTED_TIMESTAMP * EncryptedTime
//     );

#define KerbUnpackEncryptedTime( EncryptedTimeMessage, EncryptedTimeSize, EncryptedTime ) \
    KerbUnpackData( \
        (EncryptedTimeMessage), \
        (EncryptedTimeSize), \
        KERB_ENCRYPTED_TIMESTAMP_PDU, \
        (PVOID *) (EncryptedTime) \
        )

// VOID
// KerbFreeEncryptedTime(
//    IN PKERB_ENCRYPTED_TIMESTAMP EncryptedTime
//    );

#define KerbFreeEncryptedTime( EncryptedTime ) \
    KerbFreeData( \
        KERB_ENCRYPTED_TIMESTAMP_PDU, \
        (PVOID) (EncryptedTime) \
        )

KERBERR
KerbAllocateEncryptionBuffer(
    IN ULONG EncryptionType,
    IN ULONG BufferSize,
    OUT PUINT EncryptionBufferSize,
    OUT PBYTE * EncryptionBuffer
    );

KERBERR
KerbAllocateEncryptionBufferWrapper(
    IN ULONG EncryptionType,
    IN ULONG BufferSize,
    OUT unsigned long * EncryptionBufferSize,
    OUT PBYTE * EncryptionBuffer
    );

KERBERR NTAPI
KerbEncryptData(
    OUT PKERB_ENCRYPTED_DATA EncryptedData,
    IN ULONG DataSize,
    IN PUCHAR Data,
    IN ULONG Algorithm,
    IN PKERB_ENCRYPTION_KEY Key
    );

KERBERR NTAPI
KerbDecryptData(
    IN PKERB_ENCRYPTED_DATA EncryptedData,
    IN PKERB_ENCRYPTION_KEY pkKey,
    OUT PULONG DataSize,
    OUT PUCHAR Data
    );

KERBERR NTAPI
KerbEncryptDataEx(
    OUT PKERB_ENCRYPTED_DATA EncryptedData,
    IN ULONG DataSize,
    IN PUCHAR Data,
    IN ULONG KeyVersion,
    IN ULONG UsageFlags,
    IN PKERB_ENCRYPTION_KEY Key
    );

KERBERR NTAPI
KerbDecryptDataEx(
    IN PKERB_ENCRYPTED_DATA EncryptedData,
    IN PKERB_ENCRYPTION_KEY pkKey,
    IN ULONG UsageFlags,
    OUT PULONG DataSize,
    OUT PUCHAR Data
    );

#ifndef WIN32_CHICAGO
KERBERR NTAPI
KerbCheckSumVerify(
    IN PUCHAR pbBuffer,
    IN ULONG cbBuffer,
    OUT PKERB_CHECKSUM pcsCheck
    );

KERBERR NTAPI
KerbCheckSum(
    PUCHAR pbData,
    ULONG cbData,
    PCHECKSUM_FUNCTION pcsfSum,
    PKERB_CHECKSUM pcsCheckSum
    );
#endif // WIN32_CHICAGO

KERBERR
KerbGetEncryptionOverhead(
    IN ULONG Algorithm,
    OUT PULONG Overhead,
    OUT OPTIONAL PULONG BlockSize
    );

NTSTATUS
KerbDuplicateSid(
    OUT PSID * DestinationSid,
    IN PSID SourceSid
    );

NTSTATUS
KerbConvertStringToSid(
    IN PUNICODE_STRING String,
    OUT PSID * Sid
    );

NTSTATUS
KerbConvertSidToString(
    IN PSID Sid,
    OUT PUNICODE_STRING String,
    IN BOOLEAN AllocateDestination
    );

KERBERR
KerbExtractSidFromKdcName(
    IN OUT PKERB_INTERNAL_NAME Name,
    OUT PSID * Sid
    );

KERBERR
KerbBuildFullServiceKdcNameWithSid(
    IN PUNICODE_STRING DomainName,
    IN PUNICODE_STRING ServiceName,
    IN OPTIONAL PSID Sid,
    IN ULONG NameType,
    OUT PKERB_INTERNAL_NAME * FullServiceName
    );

NTSTATUS
KerbDuplicateString(
    OUT PUNICODE_STRING DestinationString,
    IN OPTIONAL PUNICODE_STRING SourceString
    );

LPWSTR
KerbBuildNullTerminatedString(
    IN PUNICODE_STRING String
    );

VOID
KerbFreeString(
    IN OPTIONAL PUNICODE_STRING String
    );

VOID
KerbFreeRealm(
    IN PKERB_REALM Realm
    );



KERBERR
KerbCompareUnicodeRealmToKerbRealm(
    IN PKERB_REALM KerbRealm,
    IN PUNICODE_STRING UnicodeRealm,
    OUT PBOOLEAN Result
    );




VOID
KerbFreePrincipalName(
    IN PKERB_PRINCIPAL_NAME Name
    );

#ifndef WIN32_CHICAGO
KERBERR
KerbCheckLogonRestrictions(
    IN PVOID UserHandle,
    IN PUNICODE_STRING Workstation,
    IN PUSER_ALL_INFORMATION UserAll,
    IN ULONG LogonRestrictionsFlags,
    OUT PTimeStamp LogoffTime,
    OUT PNTSTATUS RetStatus
    );

#include <pacndr.h>
NTSTATUS
PAC_EncodeTokenRestrictions(
    IN PKERB_TOKEN_RESTRICTIONS TokenRestrictions,
    OUT PBYTE * EncodedData,
    OUT PULONG DataSize
    );

NTSTATUS
PAC_DecodeTokenRestrictions(
    IN PBYTE EncodedData,
    IN ULONG DataSize,
    OUT PKERB_TOKEN_RESTRICTIONS * TokenRestrictions
    );



#define KERB_TOKEN_RESTRICTION_DISABLE_GROUPS   1
#define KERB_TOKEN_RESTRICTION_RESTRICT_SIDS    2
#define KERB_TOKEN_RESTRICTION_DELETE_PRIVS     4


#endif // WIN32_CHICAGO

KERBERR
KerbConvertStringToPrincipalName(
    OUT PKERB_PRINCIPAL_NAME PrincipalName,
    IN PUNICODE_STRING String,
    IN ULONG NameType
    );

KERBERR
KerbDuplicatePrincipalName(
    OUT PKERB_PRINCIPAL_NAME PrincipalName,
    IN PKERB_PRINCIPAL_NAME SourcePrincipalName
    );

KERBERR
KerbConvertPrincipalNameToString(
    OUT PUNICODE_STRING String,
    OUT PULONG NameType,
    IN PKERB_PRINCIPAL_NAME PrincipalName
    );

KERBERR
KerbConvertPrincipalNameToFullServiceString(
    OUT PUNICODE_STRING String,
    IN PKERB_PRINCIPAL_NAME PrincipalName,
    IN KERB_REALM RealmName
    );

BOOLEAN
KerbComparePrincipalNames(
    IN PKERB_PRINCIPAL_NAME Name1,
    IN PKERB_PRINCIPAL_NAME Name2
    );

KERBERR
KerbConvertUnicodeStringToRealm(
    OUT PKERB_REALM Realm,
    IN PUNICODE_STRING String
    );

KERBERR
KerbConvertRealmToUnicodeString(
    OUT PUNICODE_STRING String,
    IN PKERB_REALM Realm
    );

KERBERR
KerbDuplicateRealm(
    OUT PKERB_REALM Realm,
    IN KERB_REALM SourceRealm
    );

BOOLEAN
KerbCompareRealmNames(
    IN PKERB_REALM Realm1,
    IN PKERB_REALM Realm2
    );

BOOLEAN
KerbCompareUnicodeRealmNames(
    IN PUNICODE_STRING Domain1,
    IN PUNICODE_STRING Domain2
    );

BOOLEAN
KerbCompareStringToPrincipalName(
    IN PKERB_PRINCIPAL_NAME PrincipalName,
    IN PUNICODE_STRING String
    );

VOID
KerbConvertLargeIntToGeneralizedTime(
    OUT PKERB_TIME ClientTime,
    OUT OPTIONAL int * ClientUsec,
    IN PTimeStamp TimeStamp
    );

VOID
KerbConvertLargeIntToGeneralizedTimeWrapper(
    OUT PKERB_TIME ClientTime,
    OUT OPTIONAL long * ClientUsec,
    IN PTimeStamp TimeStamp
    );

VOID
KerbConvertGeneralizedTimeToLargeInt(
    OUT PTimeStamp TimeStamp,
    IN PKERB_TIME ClientTime,
    IN int ClientUsec
    );

BOOLEAN
KerbCheckTimeSkew(
    IN PTimeStamp CurrentTime,
    IN PTimeStamp ClientTime,
    IN PTimeStamp AllowedSkew
    );

KERBERR
KerbConvertArrayToCryptList(
    OUT PKERB_CRYPT_LIST * CryptList,
    IN PULONG ETypeArray,
    IN ULONG ETypeCount,
    IN BOOL bIncludeOldEtypes
    );

KERBERR
KerbConvertKeysToCryptList(
    OUT PKERB_CRYPT_LIST * CryptList,
    IN PKERB_STORED_CREDENTIAL Keys
    );

KERBERR
KerbConvertCryptListToArray(
    OUT PULONG * ETypeArray,
    OUT PULONG ETypeCount,
    IN PKERB_CRYPT_LIST CryptList
    );

VOID
KerbFreeCryptList(
    IN PKERB_CRYPT_LIST CryptList
    );

PKERB_AUTHORIZATION_DATA
KerbFindAuthDataEntry(
    IN ULONG EntryId,
    IN PKERB_AUTHORIZATION_DATA AuthData
    );

PKERB_PA_DATA
KerbFindPreAuthDataEntry(
    IN ULONG EntryId,
    IN PKERB_PA_DATA_LIST AuthData
    );

VOID
KerbFreePreAuthData(
    IN OPTIONAL PKERB_PA_DATA_LIST PreAuthData
    );

KERBERR
KerbCopyAndAppendAuthData(
    OUT PKERB_AUTHORIZATION_DATA * OutputAuthData,
    IN PKERB_AUTHORIZATION_DATA InputAuthData
    );

KERBERR
KerbGetPacFromAuthData(
    IN PKERB_AUTHORIZATION_DATA AuthData,
    OUT PKERB_IF_RELEVANT_AUTH_DATA ** ReturnIfRelevantData,
    OUT PKERB_AUTHORIZATION_DATA * Pac
    );

KERBERR
KerbBuildFullServiceName(
    IN PUNICODE_STRING DomainName,
    IN PUNICODE_STRING ServiceName,
    OUT PUNICODE_STRING FullServiceName
    );

KERBERR
KerbBuildUnicodeSpn(
    IN PUNICODE_STRING DomainName,
    IN PUNICODE_STRING ServiceName,
    OUT PUNICODE_STRING UnicodeSpn
    );


KERBERR
KerbBuildEmailName(
    IN PUNICODE_STRING DomainName,
    IN PUNICODE_STRING ServiceName,
    OUT PUNICODE_STRING EmailName
    );

KERBERR
KerbBuildFullServiceKdcName(
    IN PUNICODE_STRING DomainName,
    IN PUNICODE_STRING ServiceName,
    IN ULONG NameType,
    OUT PKERB_INTERNAL_NAME * FullServiceName
    );

KERBERR
KerbBuildAltSecId(
    OUT PUNICODE_STRING AlternateName,
    IN PKERB_INTERNAL_NAME PrincipalName,
    IN OPTIONAL PKERB_REALM Realm,
    IN OPTIONAL PUNICODE_STRING UnicodeRealm
    );

KERBERR
KerbBuildKeySalt(
    IN PUNICODE_STRING DomainName,
    IN PUNICODE_STRING ServiceName,
    IN KERB_ACCOUNT_TYPE AccountType,
    OUT PUNICODE_STRING KeySalt
    );

KERBERR
KerbBuildKeySaltFromUpn(
    IN PUNICODE_STRING Upn,
    OUT PUNICODE_STRING Salt
    );

KERBERR
KerbBuildErrorMessageEx(
    IN KERBERR ErrorCode,
    IN OPTIONAL PKERB_EXT_ERROR pExtendedError,
    IN PUNICODE_STRING ServerRealm,
    IN PKERB_INTERNAL_NAME ServerName,
    IN OPTIONAL PUNICODE_STRING ClientRealm,
    IN OPTIONAL PBYTE ErrorData,
    IN ULONG ErrorDataSize,
    OUT PULONG ErrorMessageSize,
    OUT PUCHAR * ErrorMessage
    );

#ifdef __cplusplus
}   // extern "C"
#endif

//
// Socket functions
//

NTSTATUS
KerbInitializeSockets(
    IN WORD VersionRequired,
    IN ULONG MinSockets,
    OUT BOOLEAN *TcpNotInstalled
    );

VOID
KerbCleanupSockets(
    );

NTSTATUS
KerbCallKdc(
    IN PUNICODE_STRING KdcAddress,
    IN ULONG AddressType,
    IN ULONG Timeout,
    IN BOOLEAN UseDatagram,
    IN USHORT PortNumber,
    IN PKERB_MESSAGE_BUFFER Input,
    OUT PKERB_MESSAGE_BUFFER Output
    );

NTSTATUS
KerbMapKerbError(
    IN KERBERR KerbError
    );

VOID
KerbFreeHostAddresses(
    IN PKERB_HOST_ADDRESSES Addresses
    );

KERBERR
KerbDuplicateHostAddresses(
    OUT PKERB_HOST_ADDRESSES * DestAddresses,
    IN PKERB_HOST_ADDRESSES SourceAddresses
    );

PCHAR
KerbAllocUtf8StrFromUnicodeString(
    IN PUNICODE_STRING UnicodeString
    );

KERBERR
KerbUnicodeStringToKerbString(
    OUT PSTRING KerbString,
    IN PUNICODE_STRING String
    );

KERBERR
KerbStringToUnicodeString(
    OUT PUNICODE_STRING String,
    IN PSTRING KerbString
    );

BOOLEAN
KerbMbStringToUnicodeString(
      PUNICODE_STRING     pDest,
      char *              pszString
      );

VOID
KerbFreeKdcName(
    IN PKERB_INTERNAL_NAME * KdcName
    );

KERBERR
KerbConvertPrincipalNameToKdcName(
    OUT PKERB_INTERNAL_NAME * OutputName,
    IN PKERB_PRINCIPAL_NAME PrincipalName
    );

KERBERR
KerbConvertKdcNameToPrincipalName(
    OUT PKERB_PRINCIPAL_NAME PrincipalName,
    IN PKERB_INTERNAL_NAME KdcName
    );

BOOLEAN
KerbEqualKdcNames(
    IN PKERB_INTERNAL_NAME Name1,
    IN PKERB_INTERNAL_NAME Name2
    );

KERBERR
KerbCompareKdcNameToPrincipalName(
    IN PKERB_PRINCIPAL_NAME PrincipalName,
    IN PKERB_INTERNAL_NAME KdcName,
    OUT PBOOLEAN Result
    );

VOID
KerbPrintKdcNameEx(
    IN ULONG DebugLevel,
    IN ULONG InfoLevel,
    IN PKERB_INTERNAL_NAME Name
    );

#define KERB_INTERNAL_NAME_SIZE(NameCount) (sizeof(KERB_INTERNAL_NAME) + ((NameCount) - ANYSIZE_ARRAY) * sizeof(UNICODE_STRING))

KERBERR
KerbConvertStringToKdcName(
    OUT PKERB_INTERNAL_NAME * PrincipalName,
    IN PUNICODE_STRING String
    );

NTSTATUS
KerbBuildKpasswdName(
    OUT PKERB_INTERNAL_NAME * KpasswdName
    );

KERBERR
KerbConvertKdcNameToString(
    OUT PUNICODE_STRING String,
    IN PKERB_INTERNAL_NAME PrincipalName,
    IN PUNICODE_STRING Realm
    );

NTSTATUS
KerbDuplicateKdcName(
    OUT PKERB_INTERNAL_NAME * Destination,
    IN PKERB_INTERNAL_NAME Source
    );

PSID
KerbMakeDomainRelativeSid(
    IN PSID DomainId,
    IN ULONG RelativeId
    );

ULONG
KerbConvertFlagsToUlong(
    IN PVOID Flags
    );

ULONG
KerbConvertUlongToFlagUlong(
    IN ULONG Flag
    );

BOOLEAN
KerbCompareObjectIds(
    IN PKERB_OBJECT_ID Object1,
    IN PKERB_OBJECT_ID Object2
    );

KERBERR
KerbGetClientNetbiosAddress(
    OUT PUNICODE_STRING ClientNetbiosAddress,
    IN PKERB_HOST_ADDRESSES Addresses
    );

#ifdef __WINCRYPT_H__
KERBERR
KerbCreateCertificateList(
    OUT PKERB_CERTIFICATE_LIST * Certificates,
    IN PCCERT_CONTEXT CertContext
    );

VOID
KerbFreeCertificateList(
    IN PKERB_CERTIFICATE_LIST Certificates
    );

NTSTATUS
KerbGetPrincipalNameFromCertificate(
    IN PCCERT_CONTEXT ClientCert,
    OUT PUNICODE_STRING String
    );

NTSTATUS
KerbDuplicateStringEx(
    OUT PUNICODE_STRING DestinationString,
    IN OPTIONAL PUNICODE_STRING SourceString,
    IN BOOLEAN NullTerminate
    );

NTSTATUS
KerbGetCertificateHash(
    OUT LPBYTE pCertHash,
    IN ULONG cbCertHash,
    IN PCCERT_CONTEXT pCertContext
    );

NTSTATUS
KerbCreateUnicodeStringFromBlob(
    IN PBYTE Blob,  
    IN ULONG BlobSize,
    IN OUT PUNICODE_STRING String,
    IN BOOLEAN ReverseOrder
    );

NTSTATUS
KerbGetCertificateIssuer(
    IN PCCERT_CONTEXT Certificate,
    IN OUT PUNICODE_STRING Issuer
    );

NTSTATUS
KerbGetCertificateHashString(
    IN PCCERT_CONTEXT Certificate,
    IN OUT PUNICODE_STRING HashString
    );



#if DBG

void
DebugDisplayTime(
    IN ULONG DebugLevel,
    IN FILETIME *pFileTime
    );
#endif

#endif //  __WINCRYPT_H__

#endif // _KERBCOMM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\inc\kerbscav.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2001
//
// File:        kerbscav.h
//
// Contents:    Scavenger (task automation) code
//
//
// History:     29-April-2001   Created         MarkPu
//
//------------------------------------------------------------------------

#ifndef __KERBSCAV_HXX_
#define __KERBSCAV_HXX_

#ifdef __cplusplus
extern "C" {
#endif

//
// Scavenger API
//

NTSTATUS
KerbInitializeScavenger();

NTSTATUS
KerbShutdownScavenger();

//
// A trigger function fires when it's time to execute a task
//
//      TaskHandle -- a context for KerbTask* functions
//      TaskItem -- context that was passed to KerbAddScavengerTask
//
// The scavenger code serializes the calls to trigger functions (NT timers don't)
//

typedef void ( *KERB_TASK_TRIGGER )( void * TaskHandle, void * TaskItem );

//
// A destroy function fires when the scavenger is done with a task and it will
// not be rescheduled.
//

typedef void ( *KERB_TASK_DESTROY )( void * TaskItem );

NTSTATUS
KerbAddScavengerTask(
    IN BOOLEAN Periodic,
    IN LONG Interval,
    IN ULONG Flags,
    IN KERB_TASK_TRIGGER pfnTrigger,
    IN KERB_TASK_DESTROY pfnDestroy,
    IN void * TaskItem,
    OUT OPTIONAL void * * TaskHandle
    );

//
// Task manipulation code to be used at any time
//

BOOL
KerbTaskDoItNow(
    IN HANDLE TaskHandle
    );

//
// Task manipulation code to be used inside trigger functions
//

BOOLEAN
KerbTaskIsPeriodic(
    IN void * TaskHandle
    );

LONG
KerbTaskGetInterval(
    IN void * TaskHandle
    );

void
KerbTaskCancel(
    IN void * TaskHandle
    );

#ifdef __cplusplus
}
#endif

#endif // __KERBSCAV_HXX_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\inc\kerberr.h ===
//+-----------------------------------------------------------------------
//
// File:        kerberr.h
//
// Contents:    Security Status codes
//
// History:     <Whenever>  RichardW    Created secscode.h
//              26-May-93   RichardW    fixed dependency & conflict with scode.h
//              02-Jun-93   WadeR   Added FAILED and SUCCEDED macros
//              14-Jun-93   WadeR   Added "proper" kerberos errors, changed
//                                  to hex.
//              07-Jul-93   WadeR   Removed FAILED and SUCCEEDED macros
//              20-Sep-93   WadeR   Moved to $(SECURITY)\h\kerberr.h
//
//------------------------------------------------------------------------

#ifndef __KERBERR_H__
#define __KERBERR_H__




// Component specific errors:

//
// KERBERR is a kerberos-specific error. Make it a pointer to a structure
// to make sure we only return the correct error.
//

typedef LONG KERBERR, *PKERBERR;

#define KERB_SUCCESS(_kerberr_) ((KERBERR)(_kerberr_) == KDC_ERR_NONE)

// These are the error codes as defined by the Kerberos V5 R5.2
// spec, section 8.3


#define KDC_ERR_NONE                  ((KERBERR) 0x0 ) // 0 No error
#define KDC_ERR_NAME_EXP              ((KERBERR) 0x1 ) // 1 Client's entry in database has expired
#define KDC_ERR_SERVICE_EXP           ((KERBERR) 0x2 ) // 2 Server's entry in database has expired
#define KDC_ERR_BAD_PVNO              ((KERBERR) 0x3 ) // 3 Requested protocol version number not supported
#define KDC_ERR_C_OLD_MAST_KVNO       ((KERBERR) 0x4 ) // 4 Client's key encrypted in old master key
#define KDC_ERR_S_OLD_MAST_KVNO       ((KERBERR) 0x5 ) // 5 Server's key encrypted in old master key
#define KDC_ERR_C_PRINCIPAL_UNKNOWN   ((KERBERR) 0x6 ) // 6 Client not found in Kerberos database
#define KDC_ERR_S_PRINCIPAL_UNKNOWN   ((KERBERR) 0x7 ) // 7 Server not found in Kerberos database
#define KDC_ERR_PRINCIPAL_NOT_UNIQUE  ((KERBERR) 0x8 ) // 8 Multiple principal entries in database
#define KDC_ERR_NULL_KEY              ((KERBERR) 0x9 ) // 9 The client or server has a null key
#define KDC_ERR_CANNOT_POSTDATE       ((KERBERR) 0xA ) // 10 Ticket not eligible for postdating
#define KDC_ERR_NEVER_VALID           ((KERBERR) 0xB ) // 11 Requested start time is later than end time
#define KDC_ERR_POLICY                ((KERBERR) 0xC ) // 12 KDC policy rejects request
#define KDC_ERR_BADOPTION             ((KERBERR) 0xD ) // 13 KDC cannot accommodate requested option
#define KDC_ERR_ETYPE_NOTSUPP         ((KERBERR) 0xE ) // 14 KDC has no support for encryption type
#define KDC_ERR_SUMTYPE_NOSUPP        ((KERBERR) 0xF ) // 15 KDC has no support for checksum type
#define KDC_ERR_PADATA_TYPE_NOSUPP    ((KERBERR) 0x10 ) // 16 KDC has no support for padata type
#define KDC_ERR_TRTYPE_NO_SUPP        ((KERBERR) 0x11 ) // 17 KDC has no support for transited type
#define KDC_ERR_CLIENT_REVOKED        ((KERBERR) 0x12 ) // 18 Clients credentials have been revoked
#define KDC_ERR_SERVICE_REVOKED       ((KERBERR) 0x13 ) // 19 Credentials for server have been revoked
#define KDC_ERR_TGT_REVOKED           ((KERBERR) 0x14 ) // 20 TGT has been revoked
#define KDC_ERR_CLIENT_NOTYET         ((KERBERR) 0x15 ) // 21 Client not yet valid - try again later
#define KDC_ERR_SERVICE_NOTYET        ((KERBERR) 0x16 ) // 22 Server not yet valid - try again later
#define KDC_ERR_KEY_EXPIRED           ((KERBERR) 0x17 ) // 23 Password has expired - change password to reset
#define KDC_ERR_PREAUTH_FAILED        ((KERBERR) 0x18 ) // 24 Pre-authentication information was invalid
#define KDC_ERR_PREAUTH_REQUIRED      ((KERBERR) 0x19 ) // 25 Additional pre-authenticationrequired [40]
#define KDC_ERR_SERVER_NOMATCH        ((KERBERR) 0x1A ) // 26 Requested server and ticket don't match
#define KDC_ERR_MUST_USE_USER2USER    ((KERBERR) 0x1B ) // 27 Server principal valid for user2user only
#define KDC_ERR_PATH_NOT_ACCEPTED     ((KERBERR) 0x1C ) // 28 KDC Policy rejects transited path
#define KDC_ERR_SVC_UNAVAILABLE       ((KERBERR) 0x1D ) // 29 A service is not available
#define KRB_AP_ERR_BAD_INTEGRITY      ((KERBERR) 0x1F ) // 31 Integrity check on decrypted field failed
#define KRB_AP_ERR_TKT_EXPIRED        ((KERBERR) 0x20 ) // 32 Ticket expired
#define KRB_AP_ERR_TKT_NYV            ((KERBERR) 0x21 ) // 33 Ticket not yet valid
#define KRB_AP_ERR_REPEAT             ((KERBERR) 0x22 ) // 34 Request is a replay
#define KRB_AP_ERR_NOT_US             ((KERBERR) 0x23 ) // 35 The ticket isn't for us
#define KRB_AP_ERR_BADMATCH           ((KERBERR) 0x24 ) // 36 Ticket and authenticator don't match
#define KRB_AP_ERR_SKEW               ((KERBERR) 0x25 ) // 37 Clock skew too great
#define KRB_AP_ERR_BADADDR            ((KERBERR) 0x26 ) // 38 Incorrect net address
#define KRB_AP_ERR_BADVERSION         ((KERBERR) 0x27 ) // 39 Protocol version mismatch
#define KRB_AP_ERR_MSG_TYPE           ((KERBERR) 0x28 ) // 40 Invalid msg type
#define KRB_AP_ERR_MODIFIED           ((KERBERR) 0x29 ) // 41 Message stream modified
#define KRB_AP_ERR_BADORDER           ((KERBERR) 0x2A ) // 42 Message out of order
#define KRB_AP_ERR_ILL_CR_TKT         ((KERBERR) 0x2B ) // 43 Illegal cross realm ticket
#define KRB_AP_ERR_BADKEYVER          ((KERBERR) 0x2C ) // 44 Specified version of key is not available
#define KRB_AP_ERR_NOKEY              ((KERBERR) 0x2D ) // 45 Service key not available
#define KRB_AP_ERR_MUT_FAIL           ((KERBERR) 0x2E ) // 46 Mutual authentication failed
#define KRB_AP_ERR_BADDIRECTION       ((KERBERR) 0x2F ) // 47 Incorrect message direction
#define KRB_AP_ERR_METHOD             ((KERBERR) 0x30 ) // 48 Alternative authentication method required
#define KRB_AP_ERR_BADSEQ             ((KERBERR) 0x31 ) // 49 Incorrect sequence number in message
#define KRB_AP_ERR_INAPP_CKSUM        ((KERBERR) 0x32 ) // 50 Inappropriate type of checksum in message
#define KRB_AP_PATH_NOT_ACCEPTED      ((KERBERR) 0x33 ) // 51 Policy rejects transited path
#define KRB_ERR_RESPONSE_TOO_BIG      ((KERBERR) 0x34 ) // 52 Response too big for UDP, retry with TCP
#define KRB_ERR_GENERIC               ((KERBERR) 0x3C ) // 60 Generic error (description in e-text)
#define KRB_ERR_FIELD_TOOLONG         ((KERBERR) 0x3D ) // 61 Field is too long for this implementation
#define KDC_ERR_CLIENT_NOT_TRUSTED    ((KERBERR) 0x3E ) // 62 (pkinit)
#define KDC_ERR_KDC_NOT_TRUSTED       ((KERBERR) 0x3F ) // 63 (pkinit)
#define KDC_ERR_INVALID_SIG           ((KERBERR) 0x40 ) // 64 (pkinit)
#define KDC_ERR_KEY_TOO_WEAK          ((KERBERR) 0x41 ) // 65 (pkinit)
#define KDC_ERR_CERTIFICATE_MISMATCH  ((KERBERR) 0x42 ) // 66 (pkinit)
#define KRB_AP_ERR_NO_TGT             ((KERBERR) 0x43 ) // 67 (user-to-user)
#define KDC_ERR_WRONG_REALM           ((KERBERR) 0x44 ) // 68 (user-to-user)
#define KRB_AP_ERR_USER_TO_USER_REQUIRED ((KERBERR) 0x45 ) // 69 (user-to-user)
#define KDC_ERR_CANT_VERIFY_CERTIFICATE ((KERBERR) 0x46 ) // 70 (pkinit)
#define KDC_ERR_INVALID_CERTIFICATE     ((KERBERR) 0x47 ) // 71 (pkinit)
#define KDC_ERR_REVOKED_CERTIFICATE     ((KERBERR) 0x48 ) // 72 (pkinit)
#define KDC_ERR_REVOCATION_STATUS_UNKNOWN ((KERBERR) 0x49 ) // 73 (pkinit)
#define KDC_ERR_REVOCATION_STATUS_UNAVAILABLE ((KERBERR) 0x4a ) // 74 (pkinit)
#define KDC_ERR_CLIENT_NAME_MISMATCH    ((KERBERR) 0x4b ) // 75 (pkinit)
#define KDC_ERR_KDC_NAME_MISMATCH       ((KERBERR) 0x4c ) // 76 (pkinit)
//
// These are local definitions that should not be sent over the network
//

#define KDC_ERR_MORE_DATA             ((KERBERR) 0x80000001 )
#define KDC_ERR_NOT_RUNNING           ((KERBERR) 0x80000002 )
#define KDC_ERR_NO_RESPONSE           ((KERBERR) 0x80000003 ) // used when we don't get a certain level of "goodness" in our response.
#define KRB_ERR_NAME_TOO_LONG         ((KERBERR) 0x80000004 )
#define KDC_ERR_NO_TRUST_PATH         ((KERBERR) 0x80000005 )


#endif // __KERBERR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\inc\kpasswd.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        kpasswd.h
//
// Contents:    types for Kerberos change password
//
//
// History:     30-Sep-1998     MikeSw          Created
//
//------------------------------------------------------------------------

#ifndef __KPASSWD_H__
#define __KPASSWD_H__


//
// Name of the kpasswd service
//


#define KERB_KPASSWD_NAME L"kadmin"

#define KERB_KPASSWD_VERSION 0x0001
#define KERB_KPASSWD_SET_VERSION 0xff80

#define SET_SHORT(_field_, _short_) \
{ \
    (_field_)[0] = (BYTE) (((_short_)&0xff00) >> 8); \
    (_field_)[1] = (BYTE) (_short_)&0xff; \
}

#define GET_SHORT( _short_,_field_) \
{ \
    (_short_) = ((_field_)[0] << 8) + (_field_)[1]; \
}

//
// Type for a kpasswd request
//

#include <pshpack1.h>
typedef struct _KERB_KPASSWD_REQ {
    BYTE MessageLength[2];
    BYTE Version[2];
    BYTE ApReqLength[2];
    BYTE Data[ANYSIZE_ARRAY];   // for KERB_AP_REQUEST-REQ and KERB_PRIV
} KERB_KPASSWD_REQ, *PKERB_KPASSWD_REQ;

//
// type for a kpasswd reply
//

typedef struct _KERB_KPASSWD_REP {
    BYTE MessageLength[2];
    BYTE Version[2];
    BYTE ApRepLength[2];
    BYTE Data[ANYSIZE_ARRAY];   // for KERB_AP_REPLY and KERB_PRIV or KERB_ERROR
} KERB_KPASSWD_REP, *PKERB_KPASSWD_REP;


//
// Type for a set password request
//

typedef struct _KERB_SET_PASSWORD_REQ {
    BYTE MessageLength[2];
    BYTE Version[2];
    BYTE ApReqLength[2];
    BYTE Data[ANYSIZE_ARRAY];   // for KERB_AP_REQUEST-REQ and KERB_PRIV
} KERB_SET_PASSWORD_REQ, *PKERB_SET_PASSWORD_REQ;

//
// type for a set password reply
//

typedef struct _KERB_SET_PASSWORD_REP {
    BYTE MessageLength[2];
    BYTE Version[2];
    BYTE ApRepLength[2];
    BYTE Data[ANYSIZE_ARRAY];   // for KERB_AP_REPLY and KERB_PRIV or KERB_ERROR
} KERB_SET_PASSWORD_REP, *PKERB_SET_PASSWORD_REP;
#include <poppack.h>

//
// Result codes:
//

#define KERB_KPASSWD_SUCCESS            0x0000
#define KERB_KPASSWD_MALFORMED          0x0001
#define KERB_KPASSWD_ERROR              0x0002
#define KERB_KPASSWD_AUTHENTICATION     0x0003
#define KERB_KPASSWD_POLICY             0x0004
#define KERB_KPASSWD_AUTHORIZATION      0x0005
#endif // __KERBLIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\inc\secmisc.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:        secmisc.h
//
//  Contents:    Helper functions and macros for security packages
//
//  Classes:
//
//  Functions:
//
//  History:    10-Dec-91 Richardw    Created
//
//--------------------------------------------------------------------------

#ifndef __SECMISC_H__
#define __SECMISC_H__

#ifdef __cplusplus
extern "C" {
#endif


///////////////////////////////////////////////////////////////////////////
//
//  Common TimeStamp Manipulation Functions
//
///////////////////////////////////////////////////////////////////////////


// Functions to get/set current local time, or time in UTC:

void    GetCurrentTimeStamp(PLARGE_INTEGER);


#define SetMaxTimeStamp(ts)      \
        (ts).HighPart = 0x7FFFFFFF; \
        (ts).LowPart = 0xFFFFFFFF;

void    AddSecondsToTimeStamp(PLARGE_INTEGER, ULONG);


#ifdef __cplusplus
}
#endif


#endif  // __SECMISC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\inc\krb5p.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        krb5p.h
//
// Contents:    pointer type definitions for ASN.1 stub types
//
//
// History:     8-May-1996      Created         MikeSw
//
//------------------------------------------------------------------------

#ifndef __KERB5P_H__
#define __KERB5P_H__

typedef KERB_HOST_ADDRESS *PKERB_HOST_ADDRESS;
typedef KERB_PRINCIPAL_NAME *PKERB_PRINCIPAL_NAME;
typedef KERB_REALM *PKERB_REALM;
typedef KERB_TIME *PKERB_TIME;
typedef KERB_ENCRYPTED_DATA *PKERB_ENCRYPTED_DATA;
typedef KERB_TICKET *PKERB_TICKET;
typedef KERB_TRANSITED_ENCODING *PKERB_TRANSITED_ENCODING;
typedef KERB_ENCRYPTION_KEY *PKERB_ENCRYPTION_KEY;
typedef KERB_ENCRYPTED_TICKET *PKERB_ENCRYPTED_TICKET;
typedef KERB_CHECKSUM *PKERB_CHECKSUM;
typedef KERB_AUTHENTICATOR *PKERB_AUTHENTICATOR;
typedef KERB_PA_DATA *PKERB_PA_DATA;
typedef KERB_KDC_REQUEST_BODY *PKERB_KDC_REQUEST_BODY;
typedef KERB_KDC_REQUEST *PKERB_KDC_REQUEST;
typedef KERB_AS_REQUEST *PKERB_AS_REQUEST;
typedef KERB_TGS_REQUEST *PKERB_TGS_REQUEST;
typedef KERB_KDC_REPLY *PKERB_KDC_REPLY;
typedef KERB_AS_REPLY *PKERB_AS_REPLY;
typedef KERB_TGS_REPLY *PKERB_TGS_REPLY;
typedef KERB_ENCRYPTED_KDC_REPLY *PKERB_ENCRYPTED_KDC_REPLY;
typedef KERB_ENCRYPTED_AS_REPLY *PKERB_ENCRYPTED_AS_REPLY;
typedef KERB_ENCRYPTED_TGS_REPLY *PKERB_ENCRYPTED_TGS_REPLY;
typedef KERB_AP_OPTIONS *PKERB_AP_OPTIONS;
typedef KERB_AP_REQUEST *PKERB_AP_REQUEST;
typedef KERB_AP_REPLY *PKERB_AP_REPLY;
typedef KERB_ENCRYPTED_AP_REPLY *PKERB_ENCRYPTED_AP_REPLY;
typedef KERB_SAFE_BODY *PKERB_SAFE_BODY;
typedef KERB_SAFE_MESSAGE *PKERB_SAFE_MESSAGE;
typedef KERB_PRIV_MESSAGE *PKERB_PRIV_MESSAGE;
typedef KERB_ENCRYPTED_PRIV *PKERB_ENCRYPTED_PRIV;
typedef KERB_ERROR *PKERB_ERROR;
typedef KERB_EXT_ERROR *PKERB_EXT_ERROR;
typedef KERB_ERROR_METHOD_DATA *PKERB_ERROR_METHOD_DATA;
typedef struct PKERB_AUTHORIZATION_DATA_s KERB_AUTHORIZATION_DATA;
typedef struct PKERB_TICKET_EXTENSIONS_s KERB_TICKET_EXTENSIONS;
typedef KERB_CRED *PKERB_CRED;
typedef KERB_ENCRYPTED_CRED *PKERB_ENCRYPTED_CRED;
typedef KERB_CRED_INFO *PKERB_CRED_INFO;
typedef struct PKERB_LAST_REQUEST_s KERB_LAST_REQUEST;
typedef struct PKERB_HOST_ADDRESSES_s KERB_HOST_ADDRESSES;
typedef struct PKERB_ETYPE_INFO_s KERB_ETYPE_INFO;
typedef KERB_ETYPE_INFO_ENTRY * PKERB_ETYPE_INFO_ENTRY;
typedef KERB_ENCRYPTED_TIMESTAMP *PKERB_ENCRYPTED_TIMESTAMP;
typedef struct PKERB_PREAUTH_DATA_LIST_s KERB_PREAUTH_DATA_LIST, *PKERB_PREAUTH_DATA_LIST;
typedef KERB_TICKET_FLAGS *PKERB_TICKET_FLAGS;
typedef KERB_PA_PAC_REQUEST *PKERB_PA_PAC_REQUEST;
typedef KERB_PA_FOR_USER *PKERB_PA_FOR_USER;

#ifndef MIDL_PASS

typedef struct KERB_PRINCIPAL_NAME_name_string_s KERB_PRINCIPAL_NAME_ELEM, *PKERB_PRINCIPAL_NAME_ELEM;
typedef struct KERB_KDC_REQUEST_BODY_encryption_type_s KERB_CRYPT_LIST, *PKERB_CRYPT_LIST;
typedef struct KERB_KDC_REQUEST_BODY_additional_tickets_s KERB_TICKET_LIST, *PKERB_TICKET_LIST;
typedef struct KERB_KDC_REQUEST_preauth_data_s KERB_PA_DATA_LIST, *PKERB_PA_DATA_LIST;
typedef struct KERB_KDC_REPLY_preauth_data_s KERB_REPLY_PA_DATA_LIST, *PKERB_REPLY_PA_DATA_LIST;
typedef struct KERB_CRED_tickets_s KERB_CRED_TICKET_LIST, *PKERB_CRED_TICKET_LIST;
typedef struct KERB_ENCRYPTED_CRED_ticket_info_s KERB_CRED_INFO_LIST, *PKERB_CRED_INFO_LIST;
typedef struct KERB_PA_PK_AS_REQ2_user_certs_s KERB_CERTIFICATE_LIST, *PKERB_CERTIFICATE_LIST;
typedef struct KERB_PA_PK_AS_REQ2_trusted_certifiers_s KERB_CERTIFIER_LIST, *PKERB_CERTIFIER_LIST;
typedef struct KERB_KDC_ISSUED_AUTH_DATA_elements_s KERB_KDC_AUTH_DATA_LIST, *PKERB_KDC_AUTH_DATA_LIST;

#endif // MIDL_PASS

typedef KERB_KDC_ISSUED_AUTH_DATA *PKERB_KDC_ISSUED_AUTH_DATA;
typedef struct PKERB_IF_RELEVANT_AUTH_DATA_ KERB_IF_RELEVANT_AUTH_DATA;
typedef KERB_DH_PARAMTER *PKERB_DH_PARAMTER;
typedef KERB_PA_PK_AS_REQ *PKERB_PA_PK_AS_REQ;
typedef KERB_PA_PK_AS_REQ2 *PKERB_PA_PK_AS_REQ2;
typedef KERB_SIGNED_AUTH_PACKAGE *PKERB_SIGNED_AUTH_PACKAGE;
typedef KERB_AUTH_PACKAGE *PKERB_AUTH_PACKAGE;
typedef KERB_PK_AUTHENTICATOR *PKERB_PK_AUTHENTICATOR;
typedef KERB_SIGNED_REPLY_KEY_PACKAGE *PKERB_SIGNED_REPLY_KEY_PACKAGE;
typedef struct ASN1objectidentifier_s KERB_OBJECT_ID, *PKERB_OBJECT_ID;
typedef KERB_REPLY_KEY_PACKAGE *PKERB_REPLY_KEY_PACKAGE;
typedef KERB_PA_PK_AS_REP *PKERB_PA_PK_AS_REP;
typedef KERB_PA_PK_AS_REP2 *PKERB_PA_PK_AS_REP2;
typedef KERB_CERTIFICATE *PKERB_CERTIFICATE;
typedef KERB_SIGNED_KDC_PUBLIC_VALUE *PKERB_SIGNED_KDC_PUBLIC_VALUE;
typedef KERB_SUBJECT_PUBLIC_KEY_INFO *PKERB_SUBJECT_PUBLIC_KEY_INFO;
typedef KERB_ALGORITHM_IDENTIFIER *PKERB_ALGORITHM_IDENTIFIER;
typedef KERB_SIGNATURE *PKERB_SIGNATURE;
typedef KERB_TGT_REPLY *PKERB_TGT_REPLY;
typedef KERB_TGT_REQUEST *PKERB_TGT_REQUEST;
typedef KERB_PA_SERV_REFERRAL *PKERB_PA_SERV_REFERRAL;
typedef KERB_CHANGE_PASSWORD_DATA *PKERB_CHANGE_PASSWORD_DATA;

#define KERB_KDC_OPTIONS_reserved             0x80000000
#define KERB_KDC_OPTIONS_forwardable          0x40000000
#define KERB_KDC_OPTIONS_forwarded            0x20000000
#define KERB_KDC_OPTIONS_proxiable            0x10000000
#define KERB_KDC_OPTIONS_proxy                0x08000000
#define KERB_KDC_OPTIONS_postdated            0x02000000
#define KERB_KDC_OPTIONS_allow_postdate       0x04000000
#define KERB_KDC_OPTIONS_unused7              0x01000000
#define KERB_KDC_OPTIONS_renewable            0x00800000
#define KERB_KDC_OPTIONS_unused9              0x00400000
#define KERB_KDC_OPTIONS_name_canonicalize    0x00010000
#define KERB_KDC_OPTIONS_cname_in_addl_tkt    0x00020000
#define KERB_KDC_OPTIONS_cname_in_pa_data     0x00040000
#define KERB_KDC_OPTIONS_renewable_ok         0x00000010
#define KERB_KDC_OPTIONS_enc_tkt_in_skey      0x00000008
#define KERB_KDC_OPTIONS_renew                0x00000002
#define KERB_KDC_OPTIONS_validate             0x00000001

#define KERB_AP_OPTIONS_reserved              0x80000000
#define KERB_AP_OPTIONS_use_session_key       0x40000000
#define KERB_AP_OPTIONS_mutual_required       0x20000000
#define KERB_AP_OPTIONS_reserved1             0x00000001

//
// these #define's are done for the conversion from the old oss compiler to the
// new telis compiler.
//
#define KERB_AUTHENTICATOR_sequence_number              sequence_number
#define KERB_ENCRYPTED_TICKET_client_addresses          client_addresses
#define KERB_ENCRYPTED_TICKET_renew_until               renew_until
#define KERB_CRED_INFO_renew_until                      renew_until
#define KERB_KDC_REQUEST_BODY_renew_until               renew_until
#define KERB_KDC_REQUEST_BODY_server_name               server_name
#define KERB_KDC_REQUEST_preauth_data                   preauth_data
#define KERB_AUTHENTICATOR_sequence_number              sequence_number
#define KERB_ENCRYPTED_AP_REPLY_sequence_number         sequence_number
#define KERB_AUTHENTICATOR_subkey                       subkey
#define KERB_ENCRYPTED_AP_REPLY_subkey                  subkey
#define KERB_TGT_REQUEST_server_name                    server_name
#define KERB_ERROR_client_name                          client_name
#define KERB_ENCRYPTED_TIMESTAMP_usec                   usec
#define KERB_KDC_REQUEST_BODY_client_name               client_name
#define KERB_KDC_REPLY_preauth_data                     preauth_data
#define KERB_ENCRYPTED_TIMESTAMP_usec                   usec
#define KERB_ENCRYPTED_KDC_REPLY_starttime              starttime
#define KERB_CRED_INFO_starttime                        starttime
#define KERB_ENCRYPTED_KDC_REPLY_renew_until            renew_until
#define KERB_ENCRYPTED_TICKET_authorization_data        authorization_data
#define KERB_ENCRYPTED_TICKET_starttime                 starttime
#define KERB_ENCRYPTED_PRIV_sequence_number             sequence_number
#define KERB_KDC_REQUEST_BODY_starttime                 starttime
#define KERB_ENCRYPTED_KDC_REPLY_client_addresses       client_addresses

#endif // __KERB5P_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\inc\krb5.h ===
#ifndef _KRB5_Module_H_
#define _KRB5_Module_H_

#include "msber.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef struct KERB_KDC_REQUEST_BODY_encryption_type_s * PKERB_KDC_REQUEST_BODY_encryption_type;

typedef struct KERB_PRINCIPAL_NAME_name_string_s * PKERB_PRINCIPAL_NAME_name_string;

typedef struct PKERB_HOST_ADDRESSES_s * PPKERB_HOST_ADDRESSES;

typedef struct PKERB_AUTHORIZATION_DATA_s * PPKERB_AUTHORIZATION_DATA;

typedef struct PKERB_LAST_REQUEST_s * PPKERB_LAST_REQUEST;

typedef struct PKERB_TICKET_EXTENSIONS_s * PPKERB_TICKET_EXTENSIONS;

typedef struct PKERB_PREAUTH_DATA_LIST_s * PPKERB_PREAUTH_DATA_LIST;

typedef struct PKERB_ETYPE_INFO_s * PPKERB_ETYPE_INFO;

typedef struct TYPED_DATA_s * PTYPED_DATA;

typedef struct KERB_KDC_ISSUED_AUTH_DATA_elements_s * PKERB_KDC_ISSUED_AUTH_DATA_elements;

typedef struct KERB_PA_PK_AS_REQ2_trusted_certifiers_s * PKERB_PA_PK_AS_REQ2_trusted_certifiers;

typedef struct KERB_PA_PK_AS_REQ2_user_certs_s * PKERB_PA_PK_AS_REQ2_user_certs;

typedef struct KERB_PA_PK_AS_REP2_kdc_cert_s * PKERB_PA_PK_AS_REP2_kdc_cert;

typedef struct KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data_s * PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data;

typedef struct KERB_KDC_REPLY_preauth_data_s * PKERB_KDC_REPLY_preauth_data;

typedef struct KERB_KDC_REQUEST_preauth_data_s * PKERB_KDC_REQUEST_preauth_data;

typedef struct KERB_PA_PK_AS_REQ_trusted_certifiers_s * PKERB_PA_PK_AS_REQ_trusted_certifiers;

typedef struct KERB_ENCRYPTED_CRED_ticket_info_s * PKERB_ENCRYPTED_CRED_ticket_info;

typedef struct KERB_CRED_tickets_s * PKERB_CRED_tickets;

typedef struct KERB_KDC_REQUEST_BODY_additional_tickets_s * PKERB_KDC_REQUEST_BODY_additional_tickets;

typedef ASN1ztcharstring_t KERB_PRINCIPAL_NAME_name_string_Seq;

typedef ASN1int32_t KERB_KDC_REQUEST_BODY_encryption_type_Seq;

typedef ASN1ztcharstring_t KERB_REALM;

typedef PPKERB_AUTHORIZATION_DATA PKERB_AUTHORIZATION_DATA_LIST;
#define PKERB_AUTHORIZATION_DATA_LIST_PDU 0
#define SIZE_KRB5_Module_PDU_0 sizeof(PKERB_AUTHORIZATION_DATA_LIST)

typedef ASN1bitstring_t KERB_KDC_OPTIONS;

typedef ASN1generalizedtime_t KERB_TIME;

typedef ASN1intx_t KERB_SEQUENCE_NUMBER_LARGE;

typedef ASN1uint32_t KERB_SEQUENCE_NUMBER;

typedef ASN1bitstring_t KERB_TICKET_FLAGS;

typedef ASN1bitstring_t KERB_AP_OPTIONS;

typedef ASN1open_t NOCOPYANY;

typedef ASN1int32_t KERB_CERTIFICATE_SERIAL_NUMBER;

typedef PPKERB_AUTHORIZATION_DATA PKERB_IF_RELEVANT_AUTH_DATA;
#define PKERB_IF_RELEVANT_AUTH_DATA_PDU 1
#define SIZE_KRB5_Module_PDU_1 sizeof(PKERB_IF_RELEVANT_AUTH_DATA)

typedef struct KERB_KDC_REQUEST_BODY_encryption_type_s {
    PKERB_KDC_REQUEST_BODY_encryption_type next;
    KERB_KDC_REQUEST_BODY_encryption_type_Seq value;
} KERB_KDC_REQUEST_BODY_encryption_type_Element, *KERB_KDC_REQUEST_BODY_encryption_type;

typedef struct PKERB_TICKET_EXTENSIONS_Seq {
    ASN1int32_t te_type;
    ASN1octetstring_t te_data;
} PKERB_TICKET_EXTENSIONS_Seq;

typedef struct KERB_PRINCIPAL_NAME_name_string_s {
    PKERB_PRINCIPAL_NAME_name_string next;
    KERB_PRINCIPAL_NAME_name_string_Seq value;
} KERB_PRINCIPAL_NAME_name_string_Element, *KERB_PRINCIPAL_NAME_name_string;

typedef struct PKERB_LAST_REQUEST_Seq {
    ASN1int32_t last_request_type;
    KERB_TIME last_request_value;
} PKERB_LAST_REQUEST_Seq;

typedef struct PKERB_AUTHORIZATION_DATA_Seq {
    ASN1int32_t auth_data_type;
    ASN1octetstring_t auth_data;
} PKERB_AUTHORIZATION_DATA_Seq;

typedef struct PKERB_HOST_ADDRESSES_Seq {
    ASN1int32_t address_type;
    ASN1octetstring_t address;
} PKERB_HOST_ADDRESSES_Seq;

typedef struct KERB_HOST_ADDRESS {
    ASN1int32_t addr_type;
    ASN1octetstring_t address;
} KERB_HOST_ADDRESS;

typedef struct PKERB_HOST_ADDRESSES_s {
    PPKERB_HOST_ADDRESSES next;
    PKERB_HOST_ADDRESSES_Seq value;
} PKERB_HOST_ADDRESSES_Element, *PKERB_HOST_ADDRESSES;

typedef struct PKERB_AUTHORIZATION_DATA_s {
    PPKERB_AUTHORIZATION_DATA next;
    PKERB_AUTHORIZATION_DATA_Seq value;
} PKERB_AUTHORIZATION_DATA_Element, *PKERB_AUTHORIZATION_DATA;

typedef struct PKERB_LAST_REQUEST_s {
    PPKERB_LAST_REQUEST next;
    PKERB_LAST_REQUEST_Seq value;
} PKERB_LAST_REQUEST_Element, *PKERB_LAST_REQUEST;

typedef struct KERB_PRINCIPAL_NAME {
    ASN1int32_t name_type;
    PKERB_PRINCIPAL_NAME_name_string name_string;
} KERB_PRINCIPAL_NAME;

typedef struct PKERB_TICKET_EXTENSIONS_s {
    PPKERB_TICKET_EXTENSIONS next;
    PKERB_TICKET_EXTENSIONS_Seq value;
} PKERB_TICKET_EXTENSIONS_Element, *PKERB_TICKET_EXTENSIONS;

typedef struct KERB_TRANSITED_ENCODING {
    ASN1int32_t transited_type;
    ASN1octetstring_t contents;
} KERB_TRANSITED_ENCODING;

typedef struct KERB_PA_DATA {
    ASN1int32_t preauth_data_type;
    ASN1octetstring_t preauth_data;
} KERB_PA_DATA;

typedef struct PKERB_PREAUTH_DATA_LIST_s {
    PPKERB_PREAUTH_DATA_LIST next;
    KERB_PA_DATA value;
} PKERB_PREAUTH_DATA_LIST_Element, *PKERB_PREAUTH_DATA_LIST;
#define PKERB_PREAUTH_DATA_LIST_PDU 2
#define SIZE_KRB5_Module_PDU_2 sizeof(PKERB_PREAUTH_DATA_LIST_Element)

typedef struct KERB_SAFE_BODY {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1octetstring_t user_data;
#   define KERB_SAFE_BODY_timestamp_present 0x80
    KERB_TIME timestamp;
#   define KERB_SAFE_BODY_usec_present 0x40
    ASN1int32_t usec;
#   define KERB_SAFE_BODY_sequence_number_present 0x20
    KERB_SEQUENCE_NUMBER sequence_number;
    KERB_HOST_ADDRESS sender_address;
#   define KERB_SAFE_BODY_recipient_address_present 0x10
    KERB_HOST_ADDRESS recipient_address;
} KERB_SAFE_BODY;

typedef struct KERB_ENCRYPTED_PRIV {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1octetstring_t user_data;
#   define KERB_ENCRYPTED_PRIV_timestamp_present 0x80
    KERB_TIME timestamp;
#   define KERB_ENCRYPTED_PRIV_usec_present 0x40
    ASN1int32_t usec;
#   define KERB_ENCRYPTED_PRIV_sequence_number_present 0x20
    KERB_SEQUENCE_NUMBER sequence_number;
    KERB_HOST_ADDRESS sender_address;
#   define KERB_ENCRYPTED_PRIV_recipient_address_present 0x10
    KERB_HOST_ADDRESS recipient_address;
} KERB_ENCRYPTED_PRIV;
#define KERB_ENCRYPTED_PRIV_PDU 3
#define SIZE_KRB5_Module_PDU_3 sizeof(KERB_ENCRYPTED_PRIV)

typedef struct KERB_ENCRYPTED_CRED {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    PKERB_ENCRYPTED_CRED_ticket_info ticket_info;
#   define nonce_present 0x80
    ASN1int32_t nonce;
#   define KERB_ENCRYPTED_CRED_timestamp_present 0x40
    KERB_TIME timestamp;
#   define KERB_ENCRYPTED_CRED_usec_present 0x20
    ASN1int32_t usec;
#   define sender_address_present 0x10
    KERB_HOST_ADDRESS sender_address;
#   define KERB_ENCRYPTED_CRED_recipient_address_present 0x8
    KERB_HOST_ADDRESS recipient_address;
} KERB_ENCRYPTED_CRED;
#define KERB_ENCRYPTED_CRED_PDU 4
#define SIZE_KRB5_Module_PDU_4 sizeof(KERB_ENCRYPTED_CRED)

typedef struct KERB_ERROR {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t version;
    ASN1int32_t message_type;
#   define client_time_present 0x80
    KERB_TIME client_time;
#   define client_usec_present 0x40
    ASN1int32_t client_usec;
    KERB_TIME server_time;
    ASN1int32_t server_usec;
    ASN1int32_t error_code;
#   define client_realm_present 0x20
    KERB_REALM client_realm;
#   define KERB_ERROR_client_name_present 0x10
    KERB_PRINCIPAL_NAME client_name;
    KERB_REALM realm;
    KERB_PRINCIPAL_NAME server_name;
#   define error_text_present 0x8
    ASN1charstring_t error_text;
#   define error_data_present 0x4
    ASN1octetstring_t error_data;
} KERB_ERROR;
#define KERB_ERROR_PDU 5
#define SIZE_KRB5_Module_PDU_5 sizeof(KERB_ERROR)

typedef struct KERB_ENCRYPTED_DATA {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t encryption_type;
#   define version_present 0x80
    ASN1int32_t version;
    ASN1octetstring_t cipher_text;
} KERB_ENCRYPTED_DATA;
#define KERB_ENCRYPTED_DATA_PDU 6
#define SIZE_KRB5_Module_PDU_6 sizeof(KERB_ENCRYPTED_DATA)

typedef struct KERB_ENCRYPTION_KEY {
    ASN1int32_t keytype;
    ASN1octetstring_t keyvalue;
} KERB_ENCRYPTION_KEY;
#define KERB_ENCRYPTION_KEY_PDU 7
#define SIZE_KRB5_Module_PDU_7 sizeof(KERB_ENCRYPTION_KEY)

typedef struct KERB_CHECKSUM {
    ASN1int32_t checksum_type;
    ASN1octetstring_t checksum;
} KERB_CHECKSUM;
#define KERB_CHECKSUM_PDU 8
#define SIZE_KRB5_Module_PDU_8 sizeof(KERB_CHECKSUM)

typedef struct KERB_ENCRYPTED_TIMESTAMP {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_TIME timestamp;
#   define KERB_ENCRYPTED_TIMESTAMP_usec_present 0x80
    ASN1int32_t usec;
} KERB_ENCRYPTED_TIMESTAMP;
#define KERB_ENCRYPTED_TIMESTAMP_PDU 9
#define SIZE_KRB5_Module_PDU_9 sizeof(KERB_ENCRYPTED_TIMESTAMP)

typedef struct KERB_SALTED_ENCRYPTED_TIMESTAMP {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_TIME timestamp;
#   define KERB_SALTED_ENCRYPTED_TIMESTAMP_usec_present 0x80
    ASN1int32_t usec;
    ASN1octetstring_t salt;
} KERB_SALTED_ENCRYPTED_TIMESTAMP;
#define KERB_SALTED_ENCRYPTED_TIMESTAMP_PDU 10
#define SIZE_KRB5_Module_PDU_10 sizeof(KERB_SALTED_ENCRYPTED_TIMESTAMP)

typedef struct KERB_ETYPE_INFO_ENTRY {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t encryption_type;
#   define salt_present 0x80
    ASN1octetstring_t salt;
} KERB_ETYPE_INFO_ENTRY;

typedef struct PKERB_ETYPE_INFO_s {
    PPKERB_ETYPE_INFO next;
    KERB_ETYPE_INFO_ENTRY value;
} PKERB_ETYPE_INFO_Element, *PKERB_ETYPE_INFO;
#define PKERB_ETYPE_INFO_PDU 11
#define SIZE_KRB5_Module_PDU_11 sizeof(PKERB_ETYPE_INFO_Element)

typedef struct KERB_TGT_REQUEST {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t version;
    ASN1int32_t message_type;
#   define KERB_TGT_REQUEST_server_name_present 0x80
    KERB_PRINCIPAL_NAME server_name;
#   define server_realm_present 0x40
    KERB_REALM server_realm;
} KERB_TGT_REQUEST;
#define KERB_TGT_REQUEST_PDU 12
#define SIZE_KRB5_Module_PDU_12 sizeof(KERB_TGT_REQUEST)

typedef struct KERB_PKCS_SIGNATURE {
    ASN1int32_t encryption_type;
    ASN1octetstring_t signature;
} KERB_PKCS_SIGNATURE;
#define KERB_PKCS_SIGNATURE_PDU 13
#define SIZE_KRB5_Module_PDU_13 sizeof(KERB_PKCS_SIGNATURE)

typedef struct KERB_ALGORITHM_IDENTIFIER {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1objectidentifier_t algorithm;
#   define parameters_present 0x80
    NOCOPYANY parameters;
} KERB_ALGORITHM_IDENTIFIER;

typedef struct KERB_SIGNATURE {
    KERB_ALGORITHM_IDENTIFIER signature_algorithm;
    ASN1bitstring_t pkcs_signature;
} KERB_SIGNATURE;

typedef struct KERB_PA_PK_AS_REP {
    ASN1choice_t choice;
    union {
#	define dh_signed_data_chosen 1
	ASN1octetstring_t dh_signed_data;
#	define key_package_chosen 2
	ASN1octetstring_t key_package;
    } u;
} KERB_PA_PK_AS_REP;
#define KERB_PA_PK_AS_REP_PDU 14
#define SIZE_KRB5_Module_PDU_14 sizeof(KERB_PA_PK_AS_REP)

typedef struct KERB_ENVELOPED_KEY_PACKAGE {
    ASN1choice_t choice;
    union {
#	define encrypted_data_chosen 1
	KERB_ENCRYPTED_DATA encrypted_data;
#	define pkinit_enveloped_data_chosen 2
	ASN1octetstring_t pkinit_enveloped_data;
    } u;
} KERB_ENVELOPED_KEY_PACKAGE;

typedef struct KERB_REPLY_KEY_PACKAGE2 {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_ENCRYPTION_KEY reply_key;
    ASN1int32_t nonce;
#   define subject_public_key_present 0x80
    ASN1bitstring_t subject_public_key;
} KERB_REPLY_KEY_PACKAGE2;
#define KERB_REPLY_KEY_PACKAGE2_PDU 15
#define SIZE_KRB5_Module_PDU_15 sizeof(KERB_REPLY_KEY_PACKAGE2)

typedef struct KERB_REPLY_KEY_PACKAGE {
    KERB_ENCRYPTION_KEY reply_key;
    ASN1int32_t nonce;
} KERB_REPLY_KEY_PACKAGE;
#define KERB_REPLY_KEY_PACKAGE_PDU 16
#define SIZE_KRB5_Module_PDU_16 sizeof(KERB_REPLY_KEY_PACKAGE)

typedef struct KERB_KDC_DH_KEY_INFO {
    ASN1int32_t nonce;
    ASN1bitstring_t subject_public_key;
} KERB_KDC_DH_KEY_INFO;
#define KERB_KDC_DH_KEY_INFO_PDU 17
#define SIZE_KRB5_Module_PDU_17 sizeof(KERB_KDC_DH_KEY_INFO)

typedef struct KERB_PA_PK_AS_REQ {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1octetstring_t signed_auth_pack;
#   define KERB_PA_PK_AS_REQ_trusted_certifiers_present 0x80
    PKERB_PA_PK_AS_REQ_trusted_certifiers trusted_certifiers;
#   define KERB_PA_PK_AS_REQ_kdc_cert_present 0x40
    ASN1octetstring_t kdc_cert;
#   define encryption_cert_present 0x20
    ASN1octetstring_t encryption_cert;
} KERB_PA_PK_AS_REQ;
#define KERB_PA_PK_AS_REQ_PDU 18
#define SIZE_KRB5_Module_PDU_18 sizeof(KERB_PA_PK_AS_REQ)

typedef struct KERB_KERBEROS_NAME {
    KERB_REALM realm;
    KERB_PRINCIPAL_NAME principal_name;
} KERB_KERBEROS_NAME;

typedef struct KERB_PK_AUTHENTICATOR {
    KERB_PRINCIPAL_NAME kdc_name;
    KERB_REALM kdc_realm;
    ASN1int32_t cusec;
    KERB_TIME client_time;
    ASN1int32_t nonce;
} KERB_PK_AUTHENTICATOR;

typedef struct KERB_SUBJECT_PUBLIC_KEY_INFO {
    KERB_ALGORITHM_IDENTIFIER algorithm;
    ASN1bitstring_t subjectPublicKey;
} KERB_SUBJECT_PUBLIC_KEY_INFO;

typedef struct KERB_DH_PARAMTER {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t prime;
    ASN1int32_t base;
#   define private_value_length_present 0x80
    ASN1int32_t private_value_length;
} KERB_DH_PARAMTER;
#define KERB_DH_PARAMTER_PDU 19
#define SIZE_KRB5_Module_PDU_19 sizeof(KERB_DH_PARAMTER)

typedef struct KERB_CERTIFICATE {
    ASN1int32_t cert_type;
    ASN1octetstring_t cert_data;
} KERB_CERTIFICATE;

typedef struct KERB_TYPED_DATA {
    ASN1int32_t data_type;
    ASN1octetstring_t data_value;
} KERB_TYPED_DATA;

typedef struct KERB_KDC_ISSUED_AUTH_DATA {
    KERB_SIGNATURE checksum;
    PKERB_KDC_ISSUED_AUTH_DATA_elements elements;
} KERB_KDC_ISSUED_AUTH_DATA;
#define KERB_KDC_ISSUED_AUTH_DATA_PDU 20
#define SIZE_KRB5_Module_PDU_20 sizeof(KERB_KDC_ISSUED_AUTH_DATA)

typedef struct KERB_PA_SERV_REFERRAL {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define referred_server_name_present 0x80
    KERB_PRINCIPAL_NAME referred_server_name;
    KERB_REALM referred_server_realm;
} KERB_PA_SERV_REFERRAL;
#define KERB_PA_SERV_REFERRAL_PDU 21
#define SIZE_KRB5_Module_PDU_21 sizeof(KERB_PA_SERV_REFERRAL)

typedef struct KERB_PA_PAC_REQUEST {
    ASN1bool_t include_pac;
} KERB_PA_PAC_REQUEST;
#define KERB_PA_PAC_REQUEST_PDU 22
#define SIZE_KRB5_Module_PDU_22 sizeof(KERB_PA_PAC_REQUEST)

typedef struct KERB_CHANGE_PASSWORD_DATA {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1octetstring_t new_password;
#   define target_name_present 0x80
    KERB_PRINCIPAL_NAME target_name;
#   define target_realm_present 0x40
    KERB_REALM target_realm;
} KERB_CHANGE_PASSWORD_DATA;
#define KERB_CHANGE_PASSWORD_DATA_PDU 23
#define SIZE_KRB5_Module_PDU_23 sizeof(KERB_CHANGE_PASSWORD_DATA)

typedef struct KERB_ERROR_METHOD_DATA {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t data_type;
#   define data_value_present 0x80
    ASN1octetstring_t data_value;
} KERB_ERROR_METHOD_DATA;
#define KERB_ERROR_METHOD_DATA_PDU 24
#define SIZE_KRB5_Module_PDU_24 sizeof(KERB_ERROR_METHOD_DATA)

typedef struct KERB_EXT_ERROR {
    ASN1int32_t status;
    ASN1int32_t klininfo;
    ASN1int32_t flags;
} KERB_EXT_ERROR;
#define KERB_EXT_ERROR_PDU 25
#define SIZE_KRB5_Module_PDU_25 sizeof(KERB_EXT_ERROR)

typedef struct TYPED_DATA_s {
    PTYPED_DATA next;
    KERB_TYPED_DATA value;
} TYPED_DATA_Element, *TYPED_DATA;
#define TYPED_DATA_PDU 26
#define SIZE_KRB5_Module_PDU_26 sizeof(TYPED_DATA_Element)

typedef struct KERB_PA_FOR_USER {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_PRINCIPAL_NAME userName;
    KERB_REALM userRealm;
    KERB_CHECKSUM cksum;
    ASN1ztcharstring_t authentication_package;
#   define KERB_PA_FOR_USER_authorization_data_present 0x80
    ASN1octetstring_t authorization_data;
} KERB_PA_FOR_USER;
#define KERB_PA_FOR_USER_PDU 27
#define SIZE_KRB5_Module_PDU_27 sizeof(KERB_PA_FOR_USER)

typedef struct KERB_KDC_ISSUED_AUTH_DATA_elements_s {
    PKERB_KDC_ISSUED_AUTH_DATA_elements next;
    KERB_PA_DATA value;
} KERB_KDC_ISSUED_AUTH_DATA_elements_Element, *KERB_KDC_ISSUED_AUTH_DATA_elements;

typedef struct KERB_PA_PK_AS_REQ2_trusted_certifiers_s {
    PKERB_PA_PK_AS_REQ2_trusted_certifiers next;
    KERB_PRINCIPAL_NAME value;
} KERB_PA_PK_AS_REQ2_trusted_certifiers_Element, *KERB_PA_PK_AS_REQ2_trusted_certifiers;

typedef struct KERB_PA_PK_AS_REQ2_user_certs_s {
    PKERB_PA_PK_AS_REQ2_user_certs next;
    KERB_CERTIFICATE value;
} KERB_PA_PK_AS_REQ2_user_certs_Element, *KERB_PA_PK_AS_REQ2_user_certs;

typedef struct KERB_PA_PK_AS_REP2_kdc_cert_s {
    PKERB_PA_PK_AS_REP2_kdc_cert next;
    KERB_CERTIFICATE value;
} KERB_PA_PK_AS_REP2_kdc_cert_Element, *KERB_PA_PK_AS_REP2_kdc_cert;

typedef struct KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data_s {
    PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data next;
    KERB_PA_DATA value;
} KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data_Element, *KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data;

typedef struct KERB_KDC_REPLY_preauth_data_s {
    PKERB_KDC_REPLY_preauth_data next;
    KERB_PA_DATA value;
} KERB_KDC_REPLY_preauth_data_Element, *KERB_KDC_REPLY_preauth_data;

typedef struct KERB_KDC_REQUEST_preauth_data_s {
    PKERB_KDC_REQUEST_preauth_data next;
    KERB_PA_DATA value;
} KERB_KDC_REQUEST_preauth_data_Element, *KERB_KDC_REQUEST_preauth_data;

typedef struct KERB_TICKET {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t ticket_version;
    KERB_REALM realm;
    KERB_PRINCIPAL_NAME server_name;
    KERB_ENCRYPTED_DATA encrypted_part;
#   define ticket_extensions_present 0x80
    PPKERB_TICKET_EXTENSIONS ticket_extensions;
} KERB_TICKET;
#define KERB_TICKET_PDU 28
#define SIZE_KRB5_Module_PDU_28 sizeof(KERB_TICKET)

typedef struct KERB_ENCRYPTED_TICKET {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_TICKET_FLAGS flags;
    KERB_ENCRYPTION_KEY key;
    KERB_REALM client_realm;
    KERB_PRINCIPAL_NAME client_name;
    KERB_TRANSITED_ENCODING transited;
    KERB_TIME authtime;
#   define KERB_ENCRYPTED_TICKET_starttime_present 0x80
    KERB_TIME starttime;
    KERB_TIME endtime;
#   define KERB_ENCRYPTED_TICKET_renew_until_present 0x40
    KERB_TIME renew_until;
#   define KERB_ENCRYPTED_TICKET_client_addresses_present 0x20
    PPKERB_HOST_ADDRESSES client_addresses;
#   define KERB_ENCRYPTED_TICKET_authorization_data_present 0x10
    PPKERB_AUTHORIZATION_DATA authorization_data;
} KERB_ENCRYPTED_TICKET;
#define KERB_ENCRYPTED_TICKET_PDU 29
#define SIZE_KRB5_Module_PDU_29 sizeof(KERB_ENCRYPTED_TICKET)

typedef struct KERB_AUTHENTICATOR {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t authenticator_version;
    KERB_REALM client_realm;
    KERB_PRINCIPAL_NAME client_name;
#   define checksum_present 0x80
    KERB_CHECKSUM checksum;
    ASN1int32_t client_usec;
    KERB_TIME client_time;
#   define KERB_AUTHENTICATOR_subkey_present 0x40
    KERB_ENCRYPTION_KEY subkey;
#   define KERB_AUTHENTICATOR_sequence_number_present 0x20
    KERB_SEQUENCE_NUMBER_LARGE sequence_number;
#   define KERB_AUTHENTICATOR_authorization_data_present 0x10
    PPKERB_AUTHORIZATION_DATA authorization_data;
} KERB_AUTHENTICATOR;
#define KERB_AUTHENTICATOR_PDU 30
#define SIZE_KRB5_Module_PDU_30 sizeof(KERB_AUTHENTICATOR)

typedef struct KERB_KDC_REQUEST_BODY {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_KDC_OPTIONS kdc_options;
#   define KERB_KDC_REQUEST_BODY_client_name_present 0x80
    KERB_PRINCIPAL_NAME client_name;
    KERB_REALM realm;
#   define KERB_KDC_REQUEST_BODY_server_name_present 0x40
    KERB_PRINCIPAL_NAME server_name;
#   define KERB_KDC_REQUEST_BODY_starttime_present 0x20
    KERB_TIME starttime;
    KERB_TIME endtime;
#   define KERB_KDC_REQUEST_BODY_renew_until_present 0x10
    KERB_TIME renew_until;
    ASN1int32_t nonce;
    PKERB_KDC_REQUEST_BODY_encryption_type encryption_type;
#   define addresses_present 0x8
    PPKERB_HOST_ADDRESSES addresses;
#   define enc_authorization_data_present 0x4
    KERB_ENCRYPTED_DATA enc_authorization_data;
#   define additional_tickets_present 0x2
    PKERB_KDC_REQUEST_BODY_additional_tickets additional_tickets;
} KERB_KDC_REQUEST_BODY;

typedef struct KERB_KDC_REPLY {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t version;
    ASN1int32_t message_type;
#   define KERB_KDC_REPLY_preauth_data_present 0x80
    PKERB_KDC_REPLY_preauth_data preauth_data;
    KERB_REALM client_realm;
    KERB_PRINCIPAL_NAME client_name;
    KERB_TICKET ticket;
    KERB_ENCRYPTED_DATA encrypted_part;
} KERB_KDC_REPLY;

typedef struct KERB_ENCRYPTED_KDC_REPLY {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_ENCRYPTION_KEY session_key;
    PPKERB_LAST_REQUEST last_request;
    ASN1int32_t nonce;
#   define key_expiration_present 0x80
    KERB_TIME key_expiration;
    KERB_TICKET_FLAGS flags;
    KERB_TIME authtime;
#   define KERB_ENCRYPTED_KDC_REPLY_starttime_present 0x40
    KERB_TIME starttime;
    KERB_TIME endtime;
#   define KERB_ENCRYPTED_KDC_REPLY_renew_until_present 0x20
    KERB_TIME renew_until;
    KERB_REALM server_realm;
    KERB_PRINCIPAL_NAME server_name;
#   define KERB_ENCRYPTED_KDC_REPLY_client_addresses_present 0x10
    PPKERB_HOST_ADDRESSES client_addresses;
#   define encrypted_pa_data_present 0x8
    PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data encrypted_pa_data;
} KERB_ENCRYPTED_KDC_REPLY;

typedef struct KERB_AP_REQUEST {
    ASN1int32_t version;
    ASN1int32_t message_type;
    KERB_AP_OPTIONS ap_options;
    KERB_TICKET ticket;
    KERB_ENCRYPTED_DATA authenticator;
} KERB_AP_REQUEST;
#define KERB_AP_REQUEST_PDU 31
#define SIZE_KRB5_Module_PDU_31 sizeof(KERB_AP_REQUEST)

typedef struct KERB_AP_REPLY {
    ASN1int32_t version;
    ASN1int32_t message_type;
    KERB_ENCRYPTED_DATA encrypted_part;
} KERB_AP_REPLY;
#define KERB_AP_REPLY_PDU 32
#define SIZE_KRB5_Module_PDU_32 sizeof(KERB_AP_REPLY)

typedef struct KERB_ENCRYPTED_AP_REPLY {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_TIME client_time;
    ASN1int32_t client_usec;
#   define KERB_ENCRYPTED_AP_REPLY_subkey_present 0x80
    KERB_ENCRYPTION_KEY subkey;
#   define KERB_ENCRYPTED_AP_REPLY_sequence_number_present 0x40
    KERB_SEQUENCE_NUMBER sequence_number;
} KERB_ENCRYPTED_AP_REPLY;
#define KERB_ENCRYPTED_AP_REPLY_PDU 33
#define SIZE_KRB5_Module_PDU_33 sizeof(KERB_ENCRYPTED_AP_REPLY)

typedef struct KERB_SAFE_MESSAGE {
    ASN1int32_t version;
    ASN1int32_t message_type;
    KERB_SAFE_BODY safe_body;
    KERB_CHECKSUM checksum;
} KERB_SAFE_MESSAGE;
#define KERB_SAFE_MESSAGE_PDU 34
#define SIZE_KRB5_Module_PDU_34 sizeof(KERB_SAFE_MESSAGE)

typedef struct KERB_PRIV_MESSAGE {
    ASN1int32_t version;
    ASN1int32_t message_type;
    KERB_ENCRYPTED_DATA encrypted_part;
} KERB_PRIV_MESSAGE;
#define KERB_PRIV_MESSAGE_PDU 35
#define SIZE_KRB5_Module_PDU_35 sizeof(KERB_PRIV_MESSAGE)

typedef struct KERB_CRED {
    ASN1int32_t version;
    ASN1int32_t message_type;
    PKERB_CRED_tickets tickets;
    KERB_ENCRYPTED_DATA encrypted_part;
} KERB_CRED;
#define KERB_CRED_PDU 36
#define SIZE_KRB5_Module_PDU_36 sizeof(KERB_CRED)

typedef struct KERB_CRED_INFO {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    KERB_ENCRYPTION_KEY key;
#   define principal_realm_present 0x80
    KERB_REALM principal_realm;
#   define principal_name_present 0x40
    KERB_PRINCIPAL_NAME principal_name;
#   define flags_present 0x20
    KERB_TICKET_FLAGS flags;
#   define authtime_present 0x10
    KERB_TIME authtime;
#   define KERB_CRED_INFO_starttime_present 0x8
    KERB_TIME starttime;
#   define endtime_present 0x4
    KERB_TIME endtime;
#   define KERB_CRED_INFO_renew_until_present 0x2
    KERB_TIME renew_until;
#   define service_realm_present 0x1
    KERB_REALM service_realm;
#   define service_name_present 0x8000
    KERB_PRINCIPAL_NAME service_name;
#   define KERB_CRED_INFO_client_addresses_present 0x4000
    PPKERB_HOST_ADDRESSES client_addresses;
} KERB_CRED_INFO;

typedef struct KERB_TGT_REPLY {
    ASN1int32_t version;
    ASN1int32_t message_type;
    KERB_TICKET ticket;
} KERB_TGT_REPLY;
#define KERB_TGT_REPLY_PDU 37
#define SIZE_KRB5_Module_PDU_37 sizeof(KERB_TGT_REPLY)

typedef struct KERB_SIGNED_REPLY_KEY_PACKAGE {
    KERB_REPLY_KEY_PACKAGE2 reply_key_package;
    KERB_SIGNATURE reply_key_signature;
} KERB_SIGNED_REPLY_KEY_PACKAGE;
#define KERB_SIGNED_REPLY_KEY_PACKAGE_PDU 38
#define SIZE_KRB5_Module_PDU_38 sizeof(KERB_SIGNED_REPLY_KEY_PACKAGE)

typedef struct KERB_SIGNED_KDC_PUBLIC_VALUE {
    KERB_SUBJECT_PUBLIC_KEY_INFO kdc_public_value;
    KERB_SIGNATURE kdc_public_value_sig;
} KERB_SIGNED_KDC_PUBLIC_VALUE;

typedef struct KERB_TRUSTED_CAS {
    ASN1choice_t choice;
    union {
#	define principal_name_chosen 1
	KERB_KERBEROS_NAME principal_name;
#	define ca_name_chosen 2
	ASN1octetstring_t ca_name;
#	define issuer_and_serial_chosen 3
	ASN1octetstring_t issuer_and_serial;
    } u;
} KERB_TRUSTED_CAS;

typedef struct KERB_AUTH_PACKAGE {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_PK_AUTHENTICATOR pk_authenticator;
#   define client_public_value_present 0x80
    KERB_SUBJECT_PUBLIC_KEY_INFO client_public_value;
} KERB_AUTH_PACKAGE;
#define KERB_AUTH_PACKAGE_PDU 39
#define SIZE_KRB5_Module_PDU_39 sizeof(KERB_AUTH_PACKAGE)

typedef struct KERB_PA_PK_AS_REQ_trusted_certifiers_s {
    PKERB_PA_PK_AS_REQ_trusted_certifiers next;
    KERB_TRUSTED_CAS value;
} KERB_PA_PK_AS_REQ_trusted_certifiers_Element, *KERB_PA_PK_AS_REQ_trusted_certifiers;

typedef struct KERB_ENCRYPTED_CRED_ticket_info_s {
    PKERB_ENCRYPTED_CRED_ticket_info next;
    KERB_CRED_INFO value;
} KERB_ENCRYPTED_CRED_ticket_info_Element, *KERB_ENCRYPTED_CRED_ticket_info;

typedef struct KERB_CRED_tickets_s {
    PKERB_CRED_tickets next;
    KERB_TICKET value;
} KERB_CRED_tickets_Element, *KERB_CRED_tickets;

typedef struct KERB_KDC_REQUEST_BODY_additional_tickets_s {
    PKERB_KDC_REQUEST_BODY_additional_tickets next;
    KERB_TICKET value;
} KERB_KDC_REQUEST_BODY_additional_tickets_Element, *KERB_KDC_REQUEST_BODY_additional_tickets;

typedef struct KERB_KDC_REQUEST {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t version;
    ASN1int32_t message_type;
#   define KERB_KDC_REQUEST_preauth_data_present 0x80
    PKERB_KDC_REQUEST_preauth_data preauth_data;
    KERB_KDC_REQUEST_BODY request_body;
} KERB_KDC_REQUEST;

typedef KERB_KDC_REQUEST_BODY KERB_MARSHALLED_REQUEST_BODY;
#define KERB_MARSHALLED_REQUEST_BODY_PDU 40
#define SIZE_KRB5_Module_PDU_40 sizeof(KERB_MARSHALLED_REQUEST_BODY)

typedef KERB_KDC_REPLY KERB_AS_REPLY;
#define KERB_AS_REPLY_PDU 41
#define SIZE_KRB5_Module_PDU_41 sizeof(KERB_AS_REPLY)

typedef KERB_KDC_REPLY KERB_TGS_REPLY;
#define KERB_TGS_REPLY_PDU 42
#define SIZE_KRB5_Module_PDU_42 sizeof(KERB_TGS_REPLY)

typedef KERB_ENCRYPTED_KDC_REPLY KERB_ENCRYPTED_AS_REPLY;
#define KERB_ENCRYPTED_AS_REPLY_PDU 43
#define SIZE_KRB5_Module_PDU_43 sizeof(KERB_ENCRYPTED_AS_REPLY)

typedef KERB_ENCRYPTED_KDC_REPLY KERB_ENCRYPTED_TGS_REPLY;
#define KERB_ENCRYPTED_TGS_REPLY_PDU 44
#define SIZE_KRB5_Module_PDU_44 sizeof(KERB_ENCRYPTED_TGS_REPLY)

typedef struct KERB_PA_PK_AS_REP2 {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define key_package_present 0x80
    KERB_ENCRYPTED_DATA key_package;
    KERB_ENVELOPED_KEY_PACKAGE temp_key_package;
#   define signed_kdc_public_value_present 0x40
    KERB_SIGNED_KDC_PUBLIC_VALUE signed_kdc_public_value;
#   define KERB_PA_PK_AS_REP2_kdc_cert_present 0x20
    PKERB_PA_PK_AS_REP2_kdc_cert kdc_cert;
} KERB_PA_PK_AS_REP2;
#define KERB_PA_PK_AS_REP2_PDU 45
#define SIZE_KRB5_Module_PDU_45 sizeof(KERB_PA_PK_AS_REP2)

typedef struct KERB_SIGNED_AUTH_PACKAGE {
    KERB_AUTH_PACKAGE auth_package;
    KERB_SIGNATURE auth_package_signature;
} KERB_SIGNED_AUTH_PACKAGE;

typedef KERB_KDC_REQUEST KERB_AS_REQUEST;
#define KERB_AS_REQUEST_PDU 46
#define SIZE_KRB5_Module_PDU_46 sizeof(KERB_AS_REQUEST)

typedef KERB_KDC_REQUEST KERB_TGS_REQUEST;
#define KERB_TGS_REQUEST_PDU 47
#define SIZE_KRB5_Module_PDU_47 sizeof(KERB_TGS_REQUEST)

typedef struct KERB_PA_PK_AS_REQ2 {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_SIGNED_AUTH_PACKAGE signed_auth_pack;
#   define user_certs_present 0x80
    PKERB_PA_PK_AS_REQ2_user_certs user_certs;
#   define KERB_PA_PK_AS_REQ2_trusted_certifiers_present 0x40
    PKERB_PA_PK_AS_REQ2_trusted_certifiers trusted_certifiers;
#   define serial_number_present 0x20
    KERB_CERTIFICATE_SERIAL_NUMBER serial_number;
} KERB_PA_PK_AS_REQ2;
#define KERB_PA_PK_AS_REQ2_PDU 48
#define SIZE_KRB5_Module_PDU_48 sizeof(KERB_PA_PK_AS_REQ2)


extern ASN1module_t KRB5_Module;
extern void ASN1CALL KRB5_Module_Startup(void);
extern void ASN1CALL KRB5_Module_Cleanup(void);

/* Prototypes of element functions for SEQUENCE OF and SET OF constructs */

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* _KRB5_Module_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\inc\userall.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2001
//
// File:        userall.h
//
// Contents:    Flags for prefetching for SAM information
//
//
// History:     23-March-2001       Created     MarkPu
//
//------------------------------------------------------------------------

#ifndef __USERALL_H
#define __USERALL_H

const ULONG USER_ALL_PAC_BUILD_CREDENTIALS =
    USER_ALL_LMPASSWORDPRESENT |
    USER_ALL_OWFPASSWORD |
    USER_ALL_NTPASSWORDPRESENT;

const ULONG USER_ALL_KDC_GET_USER_KEYS =
    USER_ALL_LMPASSWORDPRESENT |
    USER_ALL_OWFPASSWORD |
    USER_ALL_NTPASSWORDPRESENT |
    USER_ALL_PRIVATEDATA |
    USER_ALL_USERACCOUNTCONTROL |
    USER_ALL_USERID |
    USER_ALL_USERNAME;

const ULONG USER_ALL_KDC_BUILD_SUPPLEMENTAL_CREDENTIALS =
    USER_ALL_PAC_BUILD_CREDENTIALS;

const ULONG USER_ALL_PAC_MARSHALL_VALIDATION_INFO =
    USER_ALL_ACCOUNTEXPIRES |
    USER_ALL_BADPASSWORDCOUNT |
    USER_ALL_FULLNAME |
    USER_ALL_HOMEDIRECTORY |
    USER_ALL_HOMEDIRECTORYDRIVE |
    USER_ALL_LASTLOGON |
    USER_ALL_LOGONCOUNT |
    USER_ALL_PARAMETERS |
    USER_ALL_PASSWORDCANCHANGE |
    USER_ALL_PASSWORDLASTSET |
    USER_ALL_PASSWORDMUSTCHANGE |
    USER_ALL_PRIMARYGROUPID |
    USER_ALL_PROFILEPATH |
    USER_ALL_SCRIPTPATH |
    USER_ALL_USERACCOUNTCONTROL |
    USER_ALL_USERID |
    USER_ALL_USERNAME;

const ULONG USER_ALL_PAC_INIT =
    USER_ALL_PAC_MARSHALL_VALIDATION_INFO;

const ULONG USER_ALL_GET_PAC_AND_SUPP_CRED =
    USER_ALL_KDC_BUILD_SUPPLEMENTAL_CREDENTIALS |
    USER_ALL_PAC_INIT;

const ULONG USER_ALL_KDC_GET_PAC_AUTH_DATA =
    USER_ALL_GET_PAC_AND_SUPP_CRED;

const ULONG USER_ALL_KERB_CHECK_LOGON_RESTRICTIONS =
    USER_ALL_ACCOUNTEXPIRES |
    USER_ALL_LOGONHOURS |
    USER_ALL_PASSWORDMUSTCHANGE |
    USER_ALL_USERACCOUNTCONTROL |
    USER_ALL_USERID |
    USER_ALL_WORKSTATIONS;

const ULONG USER_ALL_KDC_CHECK_PREAUTH_DATA =
    USER_ALL_USERACCOUNTCONTROL;

const ULONG USER_ALL_SUCCESSFUL_LOGON =
    USER_ALL_BADPASSWORDCOUNT;

#endif // __USERALL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\inc\krbprgma.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    krbprgma.h

Abstract:

    This file contains compiler pragmas to disable specific warnings to
    let Kerberos compile at warning level 4

Author:

    Jonathan Schwartz (jschwart)  25-Apr-2000

Environment:

    User Mode -Win32

Revision History:

    25-Apr-2000
        created

--*/

// Unreferenced formal parameter

#pragma warning (disable: 4100)

// Named type definition in parentheses

#pragma warning (disable: 4115)

// Conditional expression is constant

#pragma warning (disable: 4127)

// Zero-sized array in struct/union

#pragma warning (disable: 4200)

// Nameless struct/union

#pragma warning (disable: 4201)

// Redefined extern to static

#pragma warning (disable: 4211)

// Bit field types other than int

#pragma warning (disable: 4214)

// Address of dllimport is not static

#pragma warning (disable: 4232)

// Cast truncates constant value

#pragma warning (disable: 4310)

// Structure was padded due to __declspec(align())

#pragma warning (disable: 4324)

// LHS indirection alignment greater than argument alignment

#pragma warning (disable: 4327)

// Pointer indirection alignment greater than argument alignment

#pragma warning (disable: 4328)

// Removal of unused inline functions

#pragma warning (disable: 4514)

// Assignment within conditional expression

#pragma warning (disable: 4706)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\kerbproxy\kerbproxy.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation
//
// File:        KerbProxy.cxx
//
// Contents:    dllmain, which does nothing for this ISAPI extension.
//
// History:     10-Jul-2001     t-ryanj         Created
//
//------------------------------------------------------------------------
#include <windows.h>

//+-------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:   Main dll entrypoint.
//
//  Effects:    
//
//  Arguments:  
//
//  Requires:   
//
//  Returns:    
//
//  Notes:      
//
//--------------------------------------------------------------------------
BOOL WINAPI 
DllMain( 
    HINSTANCE hinstDLL,
    DWORD dwReason,
    LPVOID lpvReserved 
    )
{
    switch(dwReason)
    {
    case DLL_PROCESS_ATTACH:
        break;
        
    case DLL_PROCESS_DETACH:
        break;
        
    case DLL_THREAD_ATTACH:
        break;
        
    case DLL_THREAD_DETACH:
        break;      
        
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\kerbproxy\kpcommon.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation
//
// File:        kpcommon.cxx
//
// Contents:    kproxy module-shared resources
//
// History:     10-Jul-2001     t-ryanj         Created
//
//------------------------------------------------------------------------
#include "kpcommon.h"

HANDLE KpGlobalIocp = NULL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\kerbcli\changepw.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1999
//
// File:        changepw.cxx
//
// Contents:    Code for KerbSetPassword and KerbChangePassword
//
//
// History:     24-May-1999     MikeSw          Created
//
//------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <sspi.h>
#include <ntsecapi.h>
#include <align.h>
#include <dsgetdc.h>
#include <kerbcli.h>




//+-------------------------------------------------------------------------
//
//  Function:   KerbChangePasswordUserEx
//
//  Synopsis:   Changes a users password. If the user is logged on,
//              it also updates the in-memory password.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbChangePasswordUser(
    IN LPWSTR DomainName,
    IN LPWSTR UserName,
    IN LPWSTR OldPassword,
    IN LPWSTR NewPassword
    )
{
    NTSTATUS Status;
    STRING Name;
    HANDLE LogonHandle = NULL;
    ULONG PackageId;
    PVOID Response = NULL ;
    ULONG ResponseSize;
    NTSTATUS SubStatus;
    PKERB_CHANGEPASSWORD_REQUEST ChangeRequest = NULL;
    ULONG ChangeSize;
    UNICODE_STRING User,Domain,OldPass,NewPass;

    Status = LsaConnectUntrusted(
                &LogonHandle
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    RtlInitString(
        &Name,
        MICROSOFT_KERBEROS_NAME_A
        );

    Status = LsaLookupAuthenticationPackage(
                LogonHandle,
                &Name,
                &PackageId
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    RtlInitUnicodeString(
        &User,
        UserName
        );
    RtlInitUnicodeString(
        &Domain,
        DomainName
        );
    RtlInitUnicodeString(
        &OldPass,
        OldPassword
        );
    RtlInitUnicodeString(
        &NewPass,
        NewPassword
        );

    if ( OldPass.Length > (127*sizeof(WCHAR)) ||
         NewPass.Length > (127*sizeof(WCHAR)) )
    {
        Status = STATUS_NAME_TOO_LONG;
        goto Cleanup;
    }

    ChangeSize = ROUND_UP_COUNT(sizeof(KERB_CHANGEPASSWORD_REQUEST),4)+
                                    User.Length +
                                    Domain.Length +
                                    OldPass.Length +
                                    NewPass.Length ;
    ChangeRequest = (PKERB_CHANGEPASSWORD_REQUEST) LocalAlloc(LMEM_ZEROINIT, ChangeSize );
    if (NULL == ChangeRequest)
    {
        goto Cleanup;
    }

    ChangeRequest->MessageType = KerbChangePasswordMessage;

    ChangeRequest->AccountName = User;
    ChangeRequest->AccountName.Buffer = (LPWSTR) ROUND_UP_POINTER(sizeof(KERB_CHANGEPASSWORD_REQUEST) + (PBYTE) ChangeRequest,4);

    RtlCopyMemory(
        ChangeRequest->AccountName.Buffer,
        User.Buffer,
        User.Length
        );

    ChangeRequest->DomainName = Domain;
    ChangeRequest->DomainName.Buffer = ChangeRequest->AccountName.Buffer + ChangeRequest->AccountName.Length / sizeof(WCHAR);

    RtlCopyMemory(
        ChangeRequest->DomainName.Buffer,
        Domain.Buffer,
        Domain.Length
        );

    ChangeRequest->OldPassword = OldPass;
    ChangeRequest->OldPassword.Buffer = ChangeRequest->DomainName.Buffer + ChangeRequest->DomainName.Length / sizeof(WCHAR);

    RtlCopyMemory(
        ChangeRequest->OldPassword.Buffer,
        OldPass.Buffer,
        OldPass.Length
        );

    ChangeRequest->NewPassword = NewPass;
    ChangeRequest->NewPassword.Buffer = ChangeRequest->OldPassword.Buffer + ChangeRequest->OldPassword.Length / sizeof(WCHAR);

    RtlCopyMemory(
        ChangeRequest->NewPassword.Buffer,
        NewPass.Buffer,
        NewPass.Length
        );


    //
    // We are running as the caller, so state we are impersonating
    //

    ChangeRequest->Impersonating = TRUE;

    Status = LsaCallAuthenticationPackage(
                LogonHandle,
                PackageId,
                ChangeRequest,
                ChangeSize,
                &Response,
                &ResponseSize,
                &SubStatus
                );
    if (!NT_SUCCESS(Status) || !NT_SUCCESS(SubStatus))
    {
        if (NT_SUCCESS(Status))
        {
            Status = SubStatus;
        }
        goto Cleanup;
    }

Cleanup:

    if (LogonHandle != NULL)
    {
        LsaDeregisterLogonProcess(LogonHandle);
    }

    if (Response != NULL)
    {
        LsaFreeReturnBuffer(Response);
    }

    if (ChangeRequest != NULL)
    {
        LocalFree(ChangeRequest);
    }
    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbSetPasswordUserEx
//
//  Synopsis:   Sets a password for a user in the specified domain
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbSetPasswordUserEx(
    IN LPWSTR DomainName,
    IN LPWSTR UserName,
    IN LPWSTR NewPassword,
    IN OPTIONAL PCredHandle CredentialsHandle,
    IN OPTIONAL LPWSTR  KdcAddress
    )
{
    NTSTATUS Status;
    STRING Name;
    HANDLE LogonHandle = NULL;
    ULONG PackageId;
    PVOID Response = NULL;
    ULONG ResponseSize;
    KERB_PROTOCOL_MESSAGE_TYPE MessageType = KerbSetPasswordMessage;
    NTSTATUS SubStatus;
    PKERB_SETPASSWORD_EX_REQUEST SetRequest = NULL;
    ULONG ChangeSize;
    UNICODE_STRING User, Domain, NewPass, KdcAddr, ClientName, ClientRealm;
    
    // If you supply a KdcAddress, you must supply name type
    if (ARGUMENT_PRESENT(KdcAddress))
    {
       MessageType = KerbSetPasswordExMessage;
       
       RtlInitUnicodeString(
          &KdcAddr,
          KdcAddress
          );  
    } 
    else                                     
    {         
       RtlInitUnicodeString(
          &KdcAddr,
          NULL
          );  
    }
    
    Status = LsaConnectUntrusted(
                &LogonHandle
                );      

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
    
    RtlInitString(
        &Name,
        MICROSOFT_KERBEROS_NAME_A
        );
    Status = LsaLookupAuthenticationPackage(
                LogonHandle,
                &Name,
                &PackageId
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    RtlInitUnicodeString(
        &User,
        UserName
        );
    RtlInitUnicodeString(
        &Domain,
        DomainName
        );
    RtlInitUnicodeString(
        &NewPass,
        NewPassword
        );

    // These aren't used here (yet)
    RtlInitUnicodeString(
        &ClientName,
        NULL
        );
    
    RtlInitUnicodeString(
        &ClientRealm,
        NULL
        );          

    if ( NewPass.Length > (127 * sizeof(WCHAR)) )
    {
        Status = STATUS_NAME_TOO_LONG;
        goto Cleanup;
    }

    ChangeSize = ROUND_UP_COUNT(sizeof(KERB_SETPASSWORD_EX_REQUEST),4)+
                                    User.Length +
                                    Domain.Length +
                                    NewPass.Length +
                                    KdcAddr.Length +
                                    ClientName.Length +
                                    ClientRealm.Length;

    SetRequest = (PKERB_SETPASSWORD_EX_REQUEST) LocalAlloc(LMEM_ZEROINIT, ChangeSize );
    if (NULL == SetRequest)
    {
        goto Cleanup;
    }

    SetRequest->MessageType = MessageType;
    SetRequest->KdcAddressType = DS_UNKNOWN_ADDRESS_TYPE;
    SetRequest->AccountRealm = Domain;
    SetRequest->AccountRealm.Buffer = (LPWSTR) ROUND_UP_POINTER(sizeof(KERB_SETPASSWORD_EX_REQUEST) + (PBYTE) SetRequest,4);

    RtlCopyMemory(
        SetRequest->AccountRealm.Buffer,
        Domain.Buffer,
        Domain.Length
        );

    SetRequest->AccountName = User;
    SetRequest->AccountName.Buffer = SetRequest->AccountRealm.Buffer + SetRequest->AccountRealm.Length / sizeof(WCHAR);

    RtlCopyMemory(
        SetRequest->AccountName.Buffer,
        User.Buffer,
        User.Length
        );


    SetRequest->Password = NewPass;
    SetRequest->Password.Buffer = SetRequest->AccountName.Buffer + SetRequest->AccountName.Length / sizeof(WCHAR);

    RtlCopyMemory(
        SetRequest->Password.Buffer,
        NewPass.Buffer,
        NewPass.Length
        );
    
    // Not yet implemented
    SetRequest->ClientRealm = ClientRealm;
    SetRequest->ClientRealm.Buffer = SetRequest->Password.Buffer + SetRequest->Password.Length / sizeof(WCHAR);
         
    RtlCopyMemory(
         SetRequest->ClientRealm.Buffer,
         ClientRealm.Buffer,
         ClientRealm.Length   
         );                  
                           
    SetRequest->ClientName  = ClientName;
    SetRequest->ClientName.Buffer = SetRequest->ClientRealm.Buffer + SetRequest->ClientRealm.Length / sizeof(WCHAR);
                                    
    RtlCopyMemory(                    
        SetRequest->ClientName.Buffer,    
        ClientName.Buffer,                      
        ClientName.Length                          
        );
    //      

    SetRequest->KdcAddress = KdcAddr;
    SetRequest->KdcAddress.Buffer = SetRequest->ClientRealm.Buffer + SetRequest->ClientRealm.Length / sizeof(WCHAR);

    RtlCopyMemory(
       SetRequest->KdcAddress.Buffer,
       KdcAddr.Buffer,
       KdcAddr.Length
       );

    if (ARGUMENT_PRESENT(CredentialsHandle))
    {
        SetRequest->CredentialsHandle = *CredentialsHandle;
        SetRequest->Flags |= KERB_SETPASS_USE_CREDHANDLE;
    }

    Status = LsaCallAuthenticationPackage(
                LogonHandle,
                PackageId,
                SetRequest,
                ChangeSize,
                &Response,
                &ResponseSize,
                &SubStatus
                );
    if (!NT_SUCCESS(Status) || !NT_SUCCESS(SubStatus))
    {
        if (NT_SUCCESS(Status))
        {
            Status = SubStatus;
        }
        goto Cleanup;
    }

Cleanup:

    if (LogonHandle != NULL)
    {
        LsaDeregisterLogonProcess(LogonHandle);
    }                  

    if (Response != NULL)
    {
        LsaFreeReturnBuffer(Response);
    }

    if (SetRequest != NULL)
    {
        LocalFree(SetRequest);
    }
    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbSetPasswordUser
//
//  Synopsis:   Sets a password for a user in the specified domain
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
KerbSetPasswordUser(
    IN LPWSTR DomainName,
    IN LPWSTR UserName,
    IN LPWSTR NewPassword,
    IN OPTIONAL PCredHandle CredentialsHandle
    )
{
    
   return(KerbSetPasswordUserEx(
                  DomainName,
                  UserName,
                  NewPassword,
                  CredentialsHandle,
                  NULL
                  ));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\kerbproxy\kpcommon.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation
//
// File:        kpcommon.h
//
// Contents:    shared resources and common headers for kproxy
//
// History:     10-Jul-2001     t-ryanj         Created
//
//------------------------------------------------------------------------
#ifndef __KPCOMMON_H__
#define __KPCOMMON_H__

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <tchar.h>
#include <httpext.h>
#include "kpdebug.h"
#include "kpmem.h"

#if 0
extern HANDLE KpGlobalIocp;

enum _KpCompKey {
    KPCK_TERMINATE,
    KPCK_HTTP_INITIAL,
    KPCK_CHECK_CONTEXT
};
#endif

#endif // __KPCOMMON_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\kerbproxy\kpcore.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation
//
// File:        kpcore.h
//
// Contents:    core routine for worker threads prototype
//
// History:     10-Jul-2001     t-ryanj         Created
//
//------------------------------------------------------------------------
#include "kpcommon.h"

#ifndef __KPCORE_H__
#define __KPCORE_H__

DWORD WINAPI
KpThreadCore(
    LPVOID ignore
    );

VOID CALLBACK
KpIoCompletionRoutine(
    DWORD dwErrorCode,
    DWORD dwBytes,
    LPOVERLAPPED lpOverlapped 
    );

#endif // __KPCORE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\kerbproxy\kpcontext.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation
//
// File:        kpcontext.h
//
// Contents:    Declarations for context structs, prototypes for context
// 		management routines.
//
// History:     10-Jul-2001     t-ryanj         Created
//
//------------------------------------------------------------------------
#include "kpcommon.h"
#include "winsock.h"

#ifndef __KPCONTEXT_H__
#define __KPCONTEXT_H__

//
// Defines the status codes for use in the context struct.
//

enum _KPSTATUS
{
    KP_HTTP_INITIAL,
    KP_HTTP_READ,
    KP_KDC_WRITE,
    KP_KDC_READ,
    KP_HTTP_WRITE
};

//
// The overlapped structure *must* be first in order for
// us to pass this and get it back to overlapped i/o calls.
//

typedef struct _KPCONTEXT
{
    OVERLAPPED ol;
    SOCKET KdcSock;
    DWORD bytesExpected;
    DWORD bytesReceived;

    ULONG PduValue;

    LPEXTENSION_CONTROL_BLOCK pECB;
    _KPSTATUS dwStatus;

    DWORD buflen;
    DWORD emptybytes;
    LPBYTE databuf;
} KPCONTEXT, *PKPCONTEXT;

#define KpGetContextFromOl( lpOverlapped ) CONTAINING_RECORD( lpOverlapped, KPCONTEXT, ol )

PKPCONTEXT
KpAcquireContext( 
    LPEXTENSION_CONTROL_BLOCK pECB
    );

VOID
KpReleaseContext(
    PKPCONTEXT pContext
    );

#endif // __KPCONTEXT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\kerbproxy\kpcontext.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation
//
// File:        kpcontext.cxx
//
// Contents:    Routines for managing contexts.
//
// History:     10-Jul-2001     t-ryanj         Created
//
//------------------------------------------------------------------------
#include "kpcontext.h"

//+-------------------------------------------------------------------------
//
//  Function:   KpAcquireContext
//
//  Synopsis:   Creates a context for the http session associated with 
//              pECB.  This context should be released with KpReleaseContext.
//
//  Effects:    
//
//  Arguments:  pECB - Extension control block provided by ISAPI
//
//  Requires:   
//
//  Returns:    The context.
//
//  Notes:      
//
//--------------------------------------------------------------------------
PKPCONTEXT
KpAcquireContext( 
    LPEXTENSION_CONTROL_BLOCK pECB
    )
{
    DebugLog( DEB_TRACE, "%s(%d): Acquiring context.\n", __FILE__, __LINE__ );

    //
    // Alloc memory for the context.
    //

    PKPCONTEXT pContext = (PKPCONTEXT)KpAlloc( sizeof( KPCONTEXT ) );

    ZeroMemory( pContext, sizeof( KPCONTEXT ) );

    if( pContext )
    {
        pContext->databuf = (LPBYTE)KpAlloc( pECB->cbTotalBytes );
        if( !pContext->databuf )
            goto Error;

	//
	// Populate with initial context settings.
	//

	pContext->pECB = pECB;
	pContext->buflen = pECB->cbTotalBytes;
	pContext->dwStatus = KP_HTTP_READ;

	//
	// Copy the data we have
	//

	memcpy( pContext->databuf, pECB->lpbData, pECB->cbAvailable );

	//
	// Remember how much more data we have.
	//
	
	pContext->emptybytes = pContext->buflen - pECB->cbAvailable;
    }

Cleanup:
    return pContext;

Error:
    if( pContext )
    {
	if( pContext->databuf )
	    KpFree( pContext->databuf );

	KpFree( pContext );

	pContext = NULL;
    }

    goto Cleanup;
}

//+-------------------------------------------------------------------------
//
//  Function:   KpReleaseContext
//
//  Synopsis:   Releases a context and frees its resources.
//
//  Effects:    
//
//  Arguments:  pContext
//
//  Requires:   
//
//  Returns:    
//
//  Notes:      
//
//--------------------------------------------------------------------------
VOID
KpReleaseContext(
    PKPCONTEXT pContext
    )
{
    DebugLog( DEB_TRACE, "%s(%d): Releasing context.\n", __FILE__, __LINE__  );

    if( pContext->KdcSock )
	closesocket(pContext->KdcSock);

    //
    // Release the HTTP connection.
    //

    if( pContext->pECB )
    {
	pContext->pECB->ServerSupportFunction( pContext->pECB->ConnID,
					       HSE_REQ_DONE_WITH_SESSION,
					       NULL,
					       NULL,
					       NULL );
	pContext->pECB = NULL;
    }

    if( pContext->databuf )
	KpFree( pContext->databuf );

    //
    // Free the memory.
    // 

    KpFree( pContext ); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\kerbproxy\kpdebug.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation
//
// File:        kpdebug.h
//
// Contents:    kproxy debugging routine prototypes
//
// History:     28-Jun-2001	t-ryanj		Created
//
//------------------------------------------------------------------------
#include <windows.h>
#include <dsysdbg.h>

#ifndef __KPDEBUG_H__
#define __KPDEBUG_H__

#define DEB_PEDANTIC 0x00000008

DECLARE_DEBUG2(KerbProxy);

#if DBG
VOID 
KpInitDebug(
    VOID
    );
#else // DBG
#define KpInitDebug()
#endif

#ifdef DBG
#define DebugLog KerbProxyDebugPrint
#else
#define DebugLog
#endif

#endif // __KPDEBUG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\kerbproxy\kpdebug.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation
//
// File:        kpdebug.cxx
//
// Contents:    debugging routines
//
// History:     10-Jul-2001	t-ryanj		Created
//
//------------------------------------------------------------------------
#include "kpdebug.h"

#ifdef DBG

DEBUG_KEY KerbProxyDebugKeys[] = { { DEB_ERROR, "Error" },
                                   { DEB_WARN,  "Warn"  },
				   { DEB_TRACE, "Trace" },
                                   { DEB_PEDANTIC, "Pedantic" },
				   { 0,         NULL    } };

DEFINE_DEBUG2(KerbProxy);

//+-------------------------------------------------------------------------
//
//  Function:   KpInitDebug
//
//  Synopsis:   Initializes debugging resources and sets the default debug
//              level.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
VOID
KpInitDebug(
    VOID
    )
{
    //
    // Set the default debug level.  
    // TODO: Eventually, this should be read from the registry somewhere.
    //

    KerbProxyInitDebug( KerbProxyDebugKeys );

    KerbProxyInfoLevel = DEB_TRACE | DEB_ERROR | DEB_WARN;
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\kerbproxy\kpcore.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation
//
// File:        kpcore.cxx
//
// Contents:    core routine for worker threads
//
// History:     10-Jul-2001     t-ryanj         Created
//
//------------------------------------------------------------------------
#include "kpcore.h"
#include "kphttp.h"
#include "kpkdc.h"

VOID
KpDispatchPerContext(
    PKPCONTEXT pContext,
    ULONG IocpBytes
    );

//+-------------------------------------------------------------------------
//
//  Function:   KpThreadCore
//
//  Synopsis:   core routine for worker threads.  handles requests as they
//              are posted to the completion port.
//
//  Effects:     
//
//  Arguments:  ignore - unused
//
//  Requires:
//
//  Returns:    always 0
//
//  Notes:
//
//
//--------------------------------------------------------------------------
DWORD WINAPI
KpThreadCore(
    LPVOID pvContext
    )
{
    KpDispatchPerContext((PKPCONTEXT)pvContext,
                         0 );

    return NO_ERROR;
#if 0
    BOOL Terminate = FALSE;
    BOOL IocpSuccess;
    ULONG IocpBytes;
    ULONG_PTR IocpCompKey;
    LPOVERLAPPED lpOverlapped;

    //
    // Do it til we're done.
    // 

    while( !Terminate )
    {
	// 
	// Grab a job off the completion queue.
	//
	IocpSuccess = GetQueuedCompletionStatus( KpGlobalIocp,
						 &IocpBytes,
						 &IocpCompKey,
						 &lpOverlapped,
						 INFINITE );
	if( !IocpSuccess )
	{
	    DebugLog( DEB_ERROR, "%s(%d): Error from GetQueuedCompletionStatus: 0x%x.\n", __FILE__, __LINE__, GetLastError() );
	    continue;
	}

	//
	// Based on the completion key, do the right thing.
	//
	switch( IocpCompKey )
	{
	case KPCK_TERMINATE:
	    Terminate = TRUE;
	    break;

        case KPCK_HTTP_INITIAL:
            DebugLog( DEB_TRACE, "----==== New connection accepted ====----\n" );
	    KpHttpRead( (LPEXTENSION_CONTROL_BLOCK)lpOverlapped );
	    break;

	case KPCK_CHECK_CONTEXT:
	    KpDispatchPerContext( KpGetContextFromOl( lpOverlapped ),
                                  IocpBytes );
	    break;

	default:
	    DebugLog( DEB_WARN, "%s(%d): Unhandled case: 0x%x.\n", __FILE__, __LINE__, IocpCompKey );
            DsysAssert( IocpCompKey == KPCK_TERMINATE ||
                        IocpCompKey == KPCK_HTTP_INITIAL ||
                        IocpCompKey == KPCK_CHECK_CONTEXT );
	    break;
	}
    }

    return 0;
#endif 
}

VOID CALLBACK
KpIoCompletionRoutine(
    DWORD dwErrorCode,
    DWORD dwBytes,
    LPOVERLAPPED lpOverlapped 
    )
{
    PKPCONTEXT pContext = NULL;

    if( lpOverlapped )
    {
        pContext = KpGetContextFromOl( lpOverlapped );
    }
    else
    {
        DebugLog( DEB_ERROR, "%s(%d): Null pointer for overlapped.\n", __FILE__, __LINE__ );
        goto Error;
    }

    if( dwErrorCode )
    {
        DebugLog( DEB_ERROR, "%s(%d): Error from I/O routine: 0x%x\n", __FILE__, __LINE__, dwErrorCode );
        goto Error;
    }

    KpDispatchPerContext( pContext,
                          dwBytes );

    return;

Error:
    if( pContext )
        KpReleaseContext( pContext );
}

//+-------------------------------------------------------------------------
//
//  Function:   KpDispatchPerContext
//
//  Synopsis:   Does the right things based on the status in the context.
//
//  Effects:     
//
//  Arguments:  pContext  
//              IocpBytes - bytes reported to the iocp
//
//  Requires:
//
//  Returns:    
//
//  Notes:
//
//
//--------------------------------------------------------------------------
VOID
KpDispatchPerContext(
    PKPCONTEXT pContext,
    ULONG IocpBytes
    )
{
    //
    // Status is going to tell us what we just finished doing,
    // so we can pass the context into the next step. 
    //

    switch( pContext->dwStatus )
    {
    case KP_HTTP_INITIAL:
        KpHttpRead(pContext);
        break;

    case KP_HTTP_READ:
	KpKdcWrite(pContext);
	break;

    case KP_KDC_WRITE:
	DebugLog( DEB_TRACE, "%s(%d): %d bytes written to KDC.\n", __FILE__, __LINE__, pContext->ol.InternalHigh );
	KpKdcRead(pContext);
	break;

    case KP_KDC_READ:
	DebugLog( DEB_PEDANTIC, "%s(%d): %d bytes read from KDC.\n", __FILE__, __LINE__, pContext->ol.InternalHigh );

        //
        // If we don't know how many bytes we're looking for yet,
        // figure it out.
        //

	if( pContext->bytesExpected == 0 &&
	    !KpCalcLength(pContext) )
	{
	    goto Error;
	}

        //
        // If we're done reading, start writing; otherwise, read some more.
        //

	if( KpKdcReadDone(pContext) )
	{
	    DebugLog( DEB_TRACE, "%s(%d): %d total bytes read from KDC.\n", __FILE__, __LINE__, pContext->bytesReceived );
	    KpHttpWrite(pContext);
	}
	else
	{
	    KpKdcRead(pContext);
	}
	break;
    
    case KP_HTTP_WRITE:
	DebugLog( DEB_TRACE, "%s(%d): %d bytes written to http.\n", __FILE__, __LINE__, pContext->bytesReceived );
	KpReleaseContext( pContext );
	break;

    default:
	DebugLog( DEB_WARN, "%s(%d): Unhandled case: 0x%x.\n", __FILE__, __LINE__, pContext->dwStatus );
        DsysAssert( pContext->dwStatus == KP_HTTP_READ ||
                    pContext->dwStatus == KP_KDC_WRITE ||
                    pContext->dwStatus == KP_KDC_READ ||
                    pContext->dwStatus == KP_HTTP_WRITE );
	goto Error;
	break;
    }

    return;

Error:
    //
    // This is where we get when we're not sure what to do with the connection next, so
    // we'll just close the connection.
    //

    KpReleaseContext( pContext );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\kerbproxy\kphttp.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation
//
// File:        kphttp.h
//
// Contents:    prototypes for routines to handle http communication
//
// History:     10-Jul-2001     t-ryanj         Created
//
//------------------------------------------------------------------------
#include "kpcommon.h"
#include "kpcontext.h"

#ifndef __KPHTTP_H__
#define __KPHTTP_H__

VOID
KpHttpRead(
    PKPCONTEXT pContext
    );

VOID
KpHttpWrite(
    PKPCONTEXT pContext 
    );

#endif // __KPHTTP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\kerbproxy\kphttp.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation
//
// File:        kphttp.cxx
//
// Contents:    routines to handle http communication
//
// History:     10-Jul-2001     t-ryanj         Created
//
//------------------------------------------------------------------------
#include "kphttp.h"
#include "kpcontext.h"
#include "kpkdc.h"
#include "kpcore.h"

//#define HTTP_STATUS_OK "200 OK"
//#define HTTP_CONTENT_HEADER "Content-type: text/plain\n\n"
CHAR HTTP_STATUS_OK[] = "200 OK";
CHAR HTTP_CONTENT_HEADER[] = "Content-type: text/plain\n\n";

VOID WINAPI
KpHttpAsyncCallback( LPEXTENSION_CONTROL_BLOCK pECB,
		     PVOID pContext,
		     DWORD cbIO,
		     DWORD dwError );

//+-------------------------------------------------------------------------
//
//  Function:   KpHttpRead
//
//  Synopsis:   Reads from the POST 
//
//  Effects:
//
//  Arguments:  pECB - contains all relevant info to the request
//
//  Requires:   
//
//  Returns:    
//
//  Notes:
//
//
//--------------------------------------------------------------------------
VOID
KpHttpRead(
    PKPCONTEXT pContext
    )
{
    LPEXTENSION_CONTROL_BLOCK pECB = pContext->pECB;
    HSE_SEND_HEADER_EX_INFO header;

    //
    // Check the type of request.
    //

    if( strcmp(pECB->lpszMethod, "POST") != 0 )
    {
	// 
	// If it isn't a POST, boot the connection
	//

	goto Error;
    }
    else
    {
	//
	// POST.  First of all, if they didn't send anything, we're done.
	// 

	if( pECB->cbTotalBytes == 0 )
        {
            DebugLog( DEB_ERROR, "%s(%d): No data.  Closing connection.\n", __FILE__, __LINE__ );
	    goto Error;
        }

	//
	// Secondly, we only accept Content-type: x-application/kerberosV5
	//

#if 0 /* mimetype not implemented on client side yet */
        if( strcmp( pECB->lpszContentType, KP_MIME_TYPE ) )
        {
            DebugLog( DEB_ERROR, "%s(%d): Wrong mimetype.  Closing connection.\n", __FILE__, __LINE__ );
            goto Error;
        }
#endif

	//
	// Check to see if we fit all the data in the lookahead, or if 
	// we need to issue another read.
	//
	
	if( pECB->cbAvailable != pECB->cbTotalBytes )
	{
            //
            // Register our async i/o callback with this context.
            //

            pECB->ServerSupportFunction( pECB->ConnID,
                                         HSE_REQ_IO_COMPLETION,
                                         KpHttpAsyncCallback,
                                         NULL,
                                         (LPDWORD)pContext );

	    // 
	    // More data to read.
	    // 

	    pECB->ServerSupportFunction( pECB->ConnID,
                                         HSE_REQ_ASYNC_READ_CLIENT,
					 (pContext->databuf + pECB->cbAvailable),
					 &(pContext->emptybytes),
					 (LPDWORD)HSE_IO_ASYNC );
	}
	else
	{
	    //
	    // All the data has been read.  Ready for KDC traffic.
	    //

	    KpKdcWrite(pContext);
	}
    }

    return;

Error:
    KpReleaseContext(pContext);
}

//+-------------------------------------------------------------------------
//
//  Function:   KpHttpWrite
//
//  Synopsis:   Writes as response what's in the context buffer.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
VOID
KpHttpWrite(
    PKPCONTEXT pContext
    )
{
    BOOL WriteSuccess;
    HSE_SEND_HEADER_EX_INFO header;

    header.pszStatus = HTTP_STATUS_OK;
    header.cchStatus = sizeof(HTTP_STATUS_OK);

    header.pszHeader = HTTP_CONTENT_HEADER;
    header.cchHeader = sizeof(HTTP_CONTENT_HEADER);

    header.fKeepConn = FALSE;

    //
    // Send back whatever is in the buffer.
    //

    pContext->dwStatus = KP_HTTP_WRITE;

    //
    // Register our async i/o callback with this context.
    //

    pContext->pECB->ServerSupportFunction( pContext->pECB->ConnID,
                                           HSE_REQ_IO_COMPLETION,
                                           KpHttpAsyncCallback,
                                           NULL,
                                           (LPDWORD)pContext );

    pContext->pECB->ServerSupportFunction( pContext->pECB->ConnID,
                                           HSE_REQ_SEND_RESPONSE_HEADER_EX,
					   &header,
					   NULL,
					   NULL );

    WriteSuccess = pContext->pECB->WriteClient( pContext->pECB->ConnID,
						pContext->databuf,
						&(pContext->bytesReceived),
						HSE_IO_ASYNC );
    if( !WriteSuccess )
    {
	DebugLog( DEB_ERROR, "%s(%d): Could not issue write: 0x%x.\n", __FILE__, __LINE__, GetLastError() );
	goto Error;
    }

    return;
Error:
    KpReleaseContext( pContext );
}


//+-------------------------------------------------------------------------
//
//  Function:   KpHttpAsyncCallback
//
//  Synopsis:   Callback for async isapi communication
//
//  Effects:
//
//  Arguments:  pECB - contains all relevant info to the request
//		pvContext - our context
//		cbIO - count of bytes that were transferred
//		dwError - error if appropriate.
//
//  Requires:   
//
//  Returns:    
//
//  Notes:
//
//
//--------------------------------------------------------------------------
VOID WINAPI
KpHttpAsyncCallback( LPEXTENSION_CONTROL_BLOCK pECB,
		     PVOID pvContext,
		     DWORD cbIO,
		     DWORD dwError )
{
    BOOL IocpSuccess;

    //
    // Check for error
    //
    
    if( dwError )
    {
	DebugLog( DEB_ERROR, "%s(%d): Error during async http operation: 0x%x.\n", __FILE__, __LINE__, dwError );
	goto Error;
    }

    //
    // Let a worker thread do the work
    //
    
    IocpSuccess = QueueUserWorkItem( KpThreadCore,
                                     pvContext,
                                     0 );

    if( !IocpSuccess )
    {
        DebugLog( DEB_ERROR, "%s(%d): Error posting to iocp: 0x%x\n", __FILE__, __LINE__, GetLastError() );
        goto Error;
    }

    return;

Error:
    KpReleaseContext( (PKPCONTEXT)pvContext );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\kerbproxy\kpinit.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation
//
// File:        kpinit.h
//
// Contents:    Prototypes relevent to starting/stopping the extension.
//
// History:     10-Jul-2001     t-ryanj         Created
//
//------------------------------------------------------------------------
#include "kpcommon.h"

#ifndef __KPINIT_H__
#define __KPINIT_H__

BOOL
KpStartup(
    VOID 
    );

VOID
KpShutdown(
    VOID
    );

#endif // __KPINIT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\kerbproxy\kpinit.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation
//
// File:        kpinit.cxx
//
// Contents:    Handles the startup and shutdown of the extension.
//
// History:     10-Jul-2001     t-ryanj         Created
//
//------------------------------------------------------------------------
#include "kpinit.h"
#include "kpkdc.h"

//+-------------------------------------------------------------------------
//
//  Function:   KpStartup
//
//  Synopsis:   Initializes resources
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:    Success value.  If startup is unsuccessful, FALSE is
//              returned, and no resources are allocated.
//
//  Notes:
//
//
//--------------------------------------------------------------------------
BOOL 
KpStartup(
    VOID
    )
{
    //
    // Initialize debug stuff
    //

    KpInitDebug();

    //
    // Initialize Memory
    //

    if( !KpInitMem() )
	goto Error;

    if( !KpInitWinsock() )
        goto Error;

    return TRUE;

Error:
    KpShutdown();

    return FALSE;
}

//+-------------------------------------------------------------------------
//
//  Function:   KpShutdown
//
//  Synopsis:   Cleans up resources
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:    
//
//  Notes:	No cleanup in this routine should assume that the resource
// 		being cleanup us was successfully allocated.
//
//
//--------------------------------------------------------------------------
VOID
KpShutdown(
    VOID
    )
{
    KpCleanupWinsock();

    KpCleanupMem();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\kerbproxy\kpkdc.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation
//
// File:        kpkdc.h
//
// Contents:    prototypes for routines for communicating with the kdc
//
// History:     10-Jul-2001     t-ryanj         Created
//
//------------------------------------------------------------------------
#include "kpcommon.h"
#include "kpcontext.h"

#ifndef __KPKDC_H__
#define __KPKDC_H__

BOOL 
KpInitWinsock(
    VOID
    );

VOID
KpCleanupWinsock(
    VOID
    );

VOID
KpKdcRead(
    PKPCONTEXT pContext
    );

VOID
KpKdcWrite(
    PKPCONTEXT pContext 
    );

BOOL
KpKdcReadDone(
    PKPCONTEXT pContext
    );

BOOL
KpCalcLength(
    PKPCONTEXT pContext 
    );

#endif // __KPKDC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\kerbproxy\kpexport.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation
//
// File:        kpexport.cxx
//
// Contents:    kproxy exported ISAPI entrypoints
//
// History:     10-Jul-2001     t-ryanj         Created
//
//------------------------------------------------------------------------
#include "kpcommon.h"
#include "kpinit.h"
#include "kphttp.h"
#include "kpcore.h"

//
// Exported Functions
//

extern "C"{

BOOL WINAPI GetExtensionVersion(
    HSE_VERSION_INFO* VerInfo  
    );
    
ULONG WINAPI HttpExtensionProc(
    LPEXTENSION_CONTROL_BLOCK pECB  
    );
    
BOOL WINAPI TerminateExtension(
    ULONG Flags  
    );  

}


//+-------------------------------------------------------------------------
//
//  Function:   GetExtensionVersion
//
//  Synopsis:   Called when IIS loads the extension.
//              Reports the ISAPI version used to build this dll, also
//              gives a chance to do startup initialization.
//
//  Effects:
//
//  Arguments:
//
//  Requires:   
//
//  Returns:    Indicates if startup was successful.  When startup fails, 
//              FALSE is returned, and IIS will refuse to use the extension.
//
//  Notes:
//
//
//--------------------------------------------------------------------------
BOOL WINAPI GetExtensionVersion(
    HSE_VERSION_INFO* pVer
    )
{
    BOOL result;

    // 
    // Report our ISAPI version and description.
    //

    pVer->dwExtensionVersion = MAKELONG(HSE_VERSION_MINOR, HSE_VERSION_MAJOR);
    lstrcpyA(pVer->lpszExtensionDesc, "Desc from resource file.");

    //
    // Do global initialization.
    //

    result = KpStartup();
 
    return result;
}
    
//+-------------------------------------------------------------------------
//
//  Function:   HttpExtensionProc
//
//  Synopsis:   Entrypoint called by IIS when a request is made for us. 
//
//  Effects:
//
//  Arguments:  pECB - contains all relevant info about the request
//
//  Requires:
//
//  Returns:    One of: 
//               HSE_STATUS_SUCCESS 
//               HSE_STATUS_SUCCESS_AND_KEEP_CONN
//               HSE_STATUS_PENDING 
//               HSE_STATUS_ERROR 
//
//  Notes:
//
//
//--------------------------------------------------------------------------
ULONG WINAPI HttpExtensionProc(
    LPEXTENSION_CONTROL_BLOCK pECB  
    )
{
    ULONG result = HSE_STATUS_PENDING;
    BOOL IocpSuccess;
    PKPCONTEXT pContext;

    //
    // Acquire a context.
    //

    pContext = KpAcquireContext( pECB );
    if( !pContext )
    {
        //
        // Allocation failed.  Ummm.  Bad.
        //

        DebugLog( DEB_ERROR, "%s(%d): Could not get context.  Punting connection 0x%x.\n", __FILE__, __LINE__, pECB->ConnID );
        goto Error;
    }

    //
    // Let's not waste our time handling this - post it to the completion port.
    //

    IocpSuccess = QueueUserWorkItem( KpThreadCore,
                                     (PVOID)pContext,
                                     0 );

    if( !IocpSuccess )
    {
	//
	// Posting to the iocp failed.  We're not going to be able to handle
	// this request.
	//

	DebugLog( DEB_ERROR, "%s(%d): Failed to post to completion port: 0x%x.\n",  __FILE__, __LINE__, GetLastError() );
        goto Error;
    }

Cleanup:    
    return result;

Error:
    result = HSE_STATUS_ERROR;
    goto Cleanup;
}

//+-------------------------------------------------------------------------
//
//  Function:   TerminateExtension
//
//  Synopsis:   IIS telling us to shut down.  We free our resources first.
//              Note that IIS will never call this until all pending requests
//              have been finished, so there is no need to check for and 
//              close/finish pending requests.
//
//  Effects:
//
//  Arguments:  Flags - this is always HSE_TERM_MUST_UNLOAD
//
//  Requires:   
//
//  Returns:    TRUE
//
//  Notes:
//
//
//--------------------------------------------------------------------------
BOOL WINAPI TerminateExtension(
    ULONG Flags  
    )
{
    KpShutdown();
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\kerbproxy\kpmem.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation
//
// File:        kpmem.cxx
//
// Contents:    Routines to wrap memory allocation, etc.
//
// History:     10-Jul-2001     t-ryanj         Created
//
//------------------------------------------------------------------------
#include "kpmem.h"

HANDLE KpHeap = NULL;
#ifdef DBG
LONG KpAllocs = 0;
#endif

//+-------------------------------------------------------------------------
//
//  Function:   KpInitMem
//
//  Synopsis:   Does any initialization required before allocating memory
// 		using KpAlloc/KpFree
//
//  Effects:
//
//  Arguments:  
//
//  Requires:   
//
//  Returns:    Success value.  If FALSE is returned, memory has not been
//		initialized, and KpAlloc/KpFree cannot be safely called.
//
//  Notes:
//
//
//--------------------------------------------------------------------------
BOOL
KpInitMem(
    VOID
    )
{
    //
    // Create a private, growable heap
    //

    DsysAssert( KpHeap == NULL );
    KpHeap = HeapCreate( 0, 0, 0 );
    if( !KpHeap )
    {
	DebugLog( DEB_ERROR, "%s(%d): Could not create heap: 0x%x.\n", __FILE__, __LINE__, GetLastError() );
	goto Error;
    }

    return TRUE;

Error:
    KpCleanupMem();

    return FALSE;
}

//+-------------------------------------------------------------------------
//
//  Function:   KpCleanupMem
//
//  Synopsis:   Undoes whatever initialization was done by KpInitMem
//
//  Effects:
//
//  Arguments:  
//
//  Requires:   
//
//  Returns:    
//
//  Notes:
//
//
//--------------------------------------------------------------------------
VOID
KpCleanupMem(
    VOID
    )
{
#if DBG
    //
    // Assert that we freed all our memory.
    //

    DsysAssert( KpAllocs == 0 );
#endif

    //
    // Destroy our private heap.
    //

    if( KpHeap )
    {
	HeapDestroy( KpHeap );
	KpHeap = NULL;
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   KpAlloc
//
//  Synopsis:   Wrapper to be used for all alloc calls.
//
//  Effects:
//
//  Arguments:  
//
//  Requires:   
//
//  Returns:    
//
//  Notes:
//
//
//--------------------------------------------------------------------------
LPVOID
KpAlloc( 
    SIZE_T size 
    )
{
    PVOID pv;

    pv = HeapAlloc( KpHeap, 0, size );
#ifdef DBG
    if( pv )
        InterlockedIncrement(&KpAllocs);
#endif
    return pv;
}

//+-------------------------------------------------------------------------
//
//  Function:   KpFree
//
//  Synopsis:   Wrapper to be used for all free calls.
//
//  Effects:
//
//  Arguments:  
//
//  Requires:   
//
//  Returns:    
//
//  Notes:
//
//
//--------------------------------------------------------------------------
BOOL
KpFree(
    LPVOID buffer
    )
{
#ifdef DBG
    InterlockedDecrement(&KpAllocs);
#endif
    return HeapFree( KpHeap, 0, buffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   KpReAlloc
//
//  Synopsis:   Wrapper to be used for realloc calls.
//
//  Effects:    
//
//  Arguments:  buffer - buffer to realloc
//              size   - new size
//
//  Requires:   
//
//  Returns:    New pointer to buffer.  
//
//  Notes:      
//
//--------------------------------------------------------------------------
LPVOID
KpReAlloc(
    LPVOID buffer,
    SIZE_T size
    )
{
    return HeapReAlloc( KpHeap, 0, buffer, size );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\kerbproxy\kpkdc.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation
//
// File:        kpkdc.h
//
// Contents:    routines for communicating with the kdc
//
// History:     10-Jul-2001     t-ryanj         Created
//
//------------------------------------------------------------------------
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#ifndef SECURITY_WIN32
#define SECURITY_WIN32
#endif
#include <kerbcomm.h> 
#include <dsgetdc.h>
#include <lm.h> /* for NetApiBufferFree */
#include "kpkdc.h"
#include "kpcontext.h"
#include "kpcore.h"

#define KDC_SERVICE_NAME "kerberos"
#define KDC_FALLBACK_PORT 88 

SHORT KpDefaultKdcPort;
BOOL KpWSAStarted = FALSE;

ULONG
KpGetPduValue(
    PKPCONTEXT pContext
    );

VOID
KpInitDefaultKdcPort(
    VOID
    );

//+-------------------------------------------------------------------------
//
//  Function:   KpInitWinsock
//
//  Synopsis:   Starts winsock
//
//  Effects:
//
//  Arguments:  
//
//  Requires:
//
//  Returns:    Success value.  If FALSE, GetLastError() for details.
//
//  Notes:
//
//
//--------------------------------------------------------------------------
BOOL
KpInitWinsock(
    VOID 
    )
{
    WORD wWinsockVersionRequested = MAKEWORD( 2,2 );
    WSADATA wsaData;
    DWORD WSAStartError;

    DsysAssert(!KpWSAStarted);
    WSAStartError = WSAStartup( wWinsockVersionRequested, &wsaData );
    if( WSAStartError == SOCKET_ERROR )
    {
	DebugLog( DEB_ERROR, "%s(%d): Error starting winsock: 0x%x.\n", __FILE__, __LINE__, WSAGetLastError() );
        SetLastError(WSAGetLastError());
	goto Cleanup;
    }

    KpWSAStarted = TRUE;

    KpInitDefaultKdcPort();

Cleanup:
    return KpWSAStarted;
}    

//+-------------------------------------------------------------------------
//
//  Function:   KpCleanupWinsock
//
//  Synopsis:   Cleans up winsock.
//
//  Effects:
//
//  Arguments:  
//
//  Requires:
//
//  Returns:    
//
//  Notes:
//
//
//--------------------------------------------------------------------------
VOID
KpCleanupWinsock(
    VOID
    )
{
    if( KpWSAStarted )
    {
	WSACleanup();
        KpWSAStarted = FALSE;
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   KpInitDefaultKdcPort
//
//  Synopsis:   Finds the appropriate port for talking to kdcs. 
//
//  Effects:
//
//  Arguments:  
//
//  Requires:
//
//  Returns:    
//
//  Notes:
//
//
//--------------------------------------------------------------------------
VOID
KpInitDefaultKdcPort(
    VOID
    )
{
    PSERVENT krb5;

    /* TODO: Read from registry. */

    //
    // Ask winsock what port kerberos works on.  This should be defined in 
    // %systemroot%\system32\drivers\etc\services 
    // Note that winsock manages the servent struct, we don't need to free it.
    //

    if( krb5 = getservbyname( KDC_SERVICE_NAME, NULL ) )
    {
        KpDefaultKdcPort = krb5->s_port;
    }
    else
    {
        DebugLog( DEB_WARN, "%s(%d): Could not determine kerberos port; falling back to port %d.\n", __FILE__, __LINE__, KDC_FALLBACK_PORT );
        KpDefaultKdcPort = htons( KDC_FALLBACK_PORT );
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   KpKdcWrite
//
//  Synopsis:   Writes the response to the KDC.
//
//  Effects:
//
//  Arguments:  pContext - the context
//
//  Requires:
//
//  Returns:
//
//  Notes:      
//
//
//--------------------------------------------------------------------------
VOID
KpKdcWrite(
    PKPCONTEXT pContext
    )
{
    PKERB_KDC_REQUEST pKdcReq = NULL;
    KERBERR KerbErr;
    ULONG PduValue = 0;  /* compiler stupid, insists on =0 */
    PDOMAIN_CONTROLLER_INFOA pKdcInfo = NULL;
    DWORD DsError;
    sockaddr_in KdcAddr;
    int connecterr;
    BOOL WriteSuccess;

    DebugLog( DEB_TRACE, "%s(%d): %d bytes read from http.\n", __FILE__, __LINE__, pContext->pECB->cbTotalBytes );

    //
    // First we need to find the PduValue for the request so we can unpack.
    //

    PduValue = KpGetPduValue(pContext);

    if( !PduValue )
        goto Error;

    //
    // Unpack the request.
    //

    KerbErr = KerbUnpackData( pContext->databuf + sizeof(DWORD),
			      pContext->buflen - sizeof(DWORD),
			      PduValue,
			      (PVOID*)&pKdcReq );

    if( !KERB_SUCCESS(KerbErr) )
    {
	DebugLog( DEB_ERROR, "%s(%d): Kerberos Error: 0x%x\n", __FILE__, __LINE__, KerbErr );
	goto Error;
    }

    //
    // Now we need to look for a KDC for the realm specified in the request.
    //

    DebugLog( DEB_TRACE, "%s(%d): Realm found to be %s.\n", __FILE__, __LINE__, pKdcReq->request_body.realm );

    DsError = DsGetDcNameA( NULL, /* Computer Name */
			    pKdcReq->request_body.realm,
			    NULL, /* Domain GUID */
			    NULL, /* Site Name */
			    DS_IP_REQUIRED | DS_KDC_REQUIRED,
			    &pKdcInfo );

    if( DsError != NO_ERROR )
    {
	DebugLog( DEB_ERROR, "%s(%d): Error from DsGetDcName: 0x%x\n", __FILE__, __LINE__, DsError );
	goto Error;
    }

    DebugLog( DEB_TRACE, "%s(%d): DC found.  %s\n", __FILE__, __LINE__, pKdcInfo->DomainControllerAddress );

    //
    // Construct the SOCKADDR_IN to connect to the kdc.
    //

    KdcAddr.sin_family = AF_INET;
    KdcAddr.sin_port = KpDefaultKdcPort;
    KdcAddr.sin_addr.s_addr = inet_addr(pKdcInfo->DomainControllerAddress+2 /* past the \\ */ );

    //
    // Create the socket.
    //

    pContext->KdcSock = socket( AF_INET, SOCK_STREAM, IPPROTO_TCP );

    if( !pContext->KdcSock )
    {
	DebugLog( DEB_ERROR, "%s(%d): Error creating socket: 0x%x\n", __FILE__, __LINE__, WSAGetLastError() );
	goto Error;
    }

    //
    // Connect the socket.
    //

    connecterr = connect( pContext->KdcSock, (sockaddr*)&KdcAddr, sizeof(sockaddr_in) );

    if( connecterr )
    {
	DebugLog( DEB_ERROR, "%s(%d): Error connecting to Kdc: 0x%x\n", __FILE__, __LINE__, WSAGetLastError() );
	goto Error;
    }

    //
    // Associate the socket with the iocp.
    //

/*    if( KpGlobalIocp != CreateIoCompletionPort( (HANDLE)pContext->KdcSock,
						KpGlobalIocp,
						KPCK_CHECK_CONTEXT,
						0 ) ) */
    if( !BindIoCompletionCallback( (HANDLE)pContext->KdcSock,
                                   KpIoCompletionRoutine,
                                   0 ) )
    {
	DebugLog( DEB_ERROR, "%s(%d): Error associating Iocp with Kdc socket: 0x%x.\n", __FILE__, __LINE__, GetLastError() );
	goto Error;
    }

    //
    // Write the request asynchronously.
    //

    ZeroMemory( &(pContext->ol), sizeof(OVERLAPPED) );
    pContext->dwStatus = KP_KDC_WRITE;

    WriteSuccess = WriteFile( (HANDLE)pContext->KdcSock,
			      pContext->databuf,
			      pContext->buflen,
			      NULL, /* bytes written - not used in async */
			      &(pContext->ol) );

    if( !WriteSuccess )
    {
	if( GetLastError() != ERROR_IO_PENDING )
	{
	    DebugLog( DEB_ERROR, "%s(%d): Error issuing socket write: 0x%x\n", __FILE__, __LINE__, GetLastError() );
	    goto Error;
	}
    }


Cleanup:
    if( pKdcInfo )
	NetApiBufferFree( pKdcInfo );
    if( pKdcReq )
	KerbFreeData( PduValue, pKdcReq );
    return;

Error:
    KpReleaseContext(pContext);
    goto Cleanup;
}

//+-------------------------------------------------------------------------
//
//  Function:   KpKdcRead
//
//  Synopsis:   Reads the response from the KDC.
//
//  Effects:
//
//  Arguments:  pContext
//
//  Requires:
//
//  Returns:
//
//  Notes:      Just a stub now.
//
//
//--------------------------------------------------------------------------
VOID
KpKdcRead(
    PKPCONTEXT pContext 
    )
{
    BOOL ReadSuccess;

    //
    // Read as much data as possible from the socket asynchronously.
    //

    ZeroMemory( &(pContext->ol), sizeof(OVERLAPPED) );

    pContext->dwStatus = KP_KDC_READ;

    DebugLog( DEB_PEDANTIC, "%s(%d): Reading up to %d bytes from Kdc socket.\n", __FILE__, __LINE__, pContext->buflen - pContext->bytesReceived );
    
    ReadSuccess = ReadFile( (HANDLE)pContext->KdcSock,
			    pContext->databuf + pContext->bytesReceived,
			    pContext->buflen - pContext->bytesReceived,
			    NULL, /* bytes read - not used in async */
			    &(pContext->ol) );

    if( !ReadSuccess )
    {
	if( GetLastError() != ERROR_IO_PENDING )
	{
	    DebugLog( DEB_ERROR, "%s(%d): Error issuing read: 0x%x\n", __FILE__, __LINE__, GetLastError() );
	    goto Error;
	}
    }

Cleanup:
    return;

Error:
    KpReleaseContext(pContext);
    goto Cleanup;
}

//+-------------------------------------------------------------------------
//
//  Function:   KpKdcReadDone
//
//  Synopsis:   Checks to see if enough data has been read.
//
//  Effects:    
//
//  Arguments:  pContext
//
//  Requires:   
//
//  Returns:    TRUE of reading is complete.
//
//  Notes:      
//
//--------------------------------------------------------------------------
BOOL
KpKdcReadDone(
    PKPCONTEXT pContext
    )
{
    InterlockedExchangeAdd( (LONG*)&(pContext->bytesReceived), (LONG)pContext->ol.InternalHigh );
    return pContext->bytesReceived == pContext->buflen;
}

//+-------------------------------------------------------------------------
//
//  Function:   KpCalcLength
//
//  Synopsis:   Calculates the length of the incoming request.
//
//  Effects:    
//
//  Arguments:  pContext
//
//  Requires:   
//
//  Returns:    Success value.
//
//  Notes:      
//
//--------------------------------------------------------------------------
BOOL
KpCalcLength(
    PKPCONTEXT pContext 
    )
{
    BOOL fRet = TRUE;
    DWORD cbContent;
    LPBYTE newbuf = NULL;

    //
    // Spec says that all requests that we recieve should be in TCP form,
    // meaning they are preceeded by at least 4 bytes in network byte order
    // indicating the length of the message.  So if we don't have at least
    // four bytes of data, we're toast.
    //

    if( pContext->ol.InternalHigh < sizeof(DWORD) )
    {
	DebugLog( DEB_TRACE, "%s(%d): Less than sizeof(DWORD) bytes received.  CalcLength failed.\n", __FILE__, __LINE__ );
	goto Error;
    }

    //
    // Convert the four bytes to host byte order.
    //

    cbContent = ntohl(*(u_long*)pContext->databuf);

    //
    // If the sign bit is set, that means that another four bytes are
    // needed for the length of the message.  That's too long, so
    // we'll just punt.
    //

    if( cbContent & 0x80000000 ) /* high bit set */
    {
	DebugLog( DEB_TRACE, "%s(%d): Length won't fit in DWORD.\n", __FILE__, __LINE__ );
	goto Error;
    }

    //
    // So we're expecting as a total length, the length of the length
    // plus the length of the content.
    //

    pContext->bytesExpected = sizeof(DWORD) + cbContent;

    //
    // Realloc our buffer to be large enough to hold the whole message.
    //

    pContext->buflen = sizeof(DWORD) + cbContent;
    newbuf = (LPBYTE)KpReAlloc( pContext->databuf, pContext->buflen );
    if( !newbuf )
    {
	DebugLog( DEB_TRACE, "%s(%d): Realloc failed.  CalcLength failed.\n", __FILE__, __LINE__ );
	goto Error;
    }
    pContext->databuf = newbuf;

    DebugLog( DEB_TRACE, "%s(%d): Looking for reply of length %d.\n", __FILE__, __LINE__, pContext->bytesExpected );

Cleanup:
    return fRet;

Error:
    fRet = FALSE;
    goto Cleanup;
}

//+-------------------------------------------------------------------------
//
//  Function:   KpGetPduValue
//
//  Synopsis:   Looks at the first byte of the request to determine the 
//              message type, and returns the appropriate PduValue for
//              unpacking.
//
//  Effects:    
//
//  Arguments:  pContext
//
//  Requires:   
//
//  Returns:    The appropriate PduValue, or 0 on failure.  Note that 0 
//              is a valid PduValue, but since we're only concerned with
//              AS-REQ and TGS-REQ, we can ignore it.
//
//  Notes:      
//
//--------------------------------------------------------------------------
ULONG
KpGetPduValue(
    PKPCONTEXT pContext
    )
{
    ULONG PduValue = 0;

    //
    // If we don't have the first byte, we can't exactly parse it.
    //

    if( pContext->buflen < 1 + sizeof(DWORD) )
        goto Cleanup;

    //
    // The last five bits of the first byte signify the message type.
    //

    switch( pContext->databuf[sizeof(DWORD)] & 0x1f ) /* last 5 bits */
    {
    case 0xa: /* AS-REQUEST */
        DebugLog( DEB_TRACE, "%s(%d): Processing AS-REQUEST.\n", __FILE__, __LINE__ );
	PduValue = KERB_AS_REQUEST_PDU;
	break;
		
    case 0xc: /* TGS-REQUEST */
        DebugLog( DEB_TRACE, "%s(%d): Processing TGS-REQUEST.\n", __FILE__, __LINE__ );
	PduValue = KERB_TGS_REQUEST_PDU;
	break;
	
    default:
	DebugLog( DEB_ERROR, "%s(%d): Not an AS or TGS request.\n", __FILE__, __LINE__ );
        goto Cleanup;
    }

Cleanup:
    return PduValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\kerbproxy\kppool.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation
//
// File:        kppool.cxx
//
// Contents:    Prototypes for thread pool management routines.
//
// History:     10-Jul-2001     t-ryanj         Created
//
//------------------------------------------------------------------------
#ifndef __KPPOOL_H__
#define __KPPOOL_H__

#include "kpcommon.h"

BOOL
KpInitThreadPool(
    VOID
    );

VOID
KpCleanupThreadPool(
    VOID
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\kerbproxy\kpmem.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation
//
// File:        kpmem.cxx
//
// Contents:    Prototypes for Routines to wrap memory allocation, etc.
//
// History:     10-Jul-2001     t-ryanj         Created
//
//------------------------------------------------------------------------
#include <windows.h>
#include "kpdebug.h"

#ifndef __KPMEM_H__
#define __KPMEM_H__

BOOL
KpInitMem(
    VOID
    );

VOID
KpCleanupMem(
    VOID
    );

LPVOID
KpAlloc( 
    SIZE_T size
    );

BOOL
KpFree(
    LPVOID buffer 
    );

LPVOID
KpReAlloc(
    LPVOID buffer,
    SIZE_T size 
    );

#endif __KPMEM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\kernel\cpgssutl.cxx ===
/*++                                                                        
                                                                            
Copyright (c) 1991  Microsoft Corporation                                   
                                                                            
Module Name:                                                                
                                                                            
    cpgssutl.c                                                                
                                                                            
Abstract:                                                                   
                                                                            
    include file for private\net\netlib\data.c                              
                                                                            
Author:                                                                     
                                                                            
    Chandana Surlu (ChandanS) 09-Apr-1998                                   
                                                                            
Environment:                                                                
                                                                            
    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)       
    Requires ANSI C extensions: slash-slash comments, long external names.  
                                                                            
Revision History:                                                           
                                                                            
    09-Apr-1998 ChandanS                                                    
        Created.                                                            
--*/                                                                        
                                                                            
#include "..\client2\gssutil.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\kerbproxy\kppool.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation
//
// File:        kppool.cxx
//
// Contents:    Routines to manage the thread pool
//
// History:     10-Jul-2001     t-ryanj         Created
//
//------------------------------------------------------------------------
#include "kppool.h"
#include "kpcore.h"

#define KP_THREAD_STACKSIZE 0
#define KP_THREAD_CPUFACTOR 10

HANDLE* KpThreadPool = NULL;
ULONG   KpThreadCount = 0;

//+-------------------------------------------------------------------------
//
//  Function:   KpInitThreadPool
//
//  Synopsis:   Creates the thread pool.
//
//  Effects:
//
//  Arguments:
//
//  Requires:   
//
//  Returns:    Success status.  On failure, no threads are running, no 
// 		memory is allocated.
//
//  Notes:      TODO: This is a bad way to do threadpools, apparently.
//                    Find a better one.
//
//--------------------------------------------------------------------------
BOOL
KpInitThreadPool(
    VOID
    )
{
    SYSTEM_INFO Sysinfo;
    ULONG TargetThreadCount;

    //
    // Get system info, so we can see how many procs we've got.
    //

    GetSystemInfo(&Sysinfo);

    // 
    // Let's make KP_THREAD_CPUFACTOR * numprocs threads.
    //

    TargetThreadCount = Sysinfo.dwNumberOfProcessors * KP_THREAD_CPUFACTOR;

    //
    // Make memory to keep track of all these threads.
    //

    DsysAssert( KpThreadPool == NULL );

    KpThreadPool = (HANDLE*)KpAlloc( TargetThreadCount * sizeof(HANDLE) );

    if( !KpThreadPool )
    {
	DebugLog( DEB_ERROR, "%s(%d): Could not allocate memory to keep track of threads.\n" __FILE__, __LINE__ );
	goto Error;
    }

    //
    // Zero the memory so we can easily check if a thread creation failed. 
    //
    
    RtlZeroMemory( KpThreadPool, TargetThreadCount * sizeof(HANDLE) );

    // 
    // Create the Threads
    //

    DsysAssert(KpThreadCount == 0);

    for( KpThreadCount = 0; KpThreadCount < TargetThreadCount; KpThreadCount++ )
    {
	KpThreadPool[KpThreadCount] = CreateThread( NULL,
						    KP_THREAD_STACKSIZE,
						    KpThreadCore,
						    NULL,
						    0,
						    NULL );
	if( !KpThreadPool[KpThreadCount] )
	{
	    DebugLog( DEB_ERROR, "%s(%d): Error creating thread: 0x%x.\n",  __FILE__, __LINE__, GetLastError() );
	    goto Error;
	}
    }

    return TRUE;

Error:
    KpCleanupThreadPool();

    return FALSE;
}

//+-------------------------------------------------------------------------
//
//  Function:   KpCleanupThreadPool
//
//  Synopsis:   Asks all threads to terminate, waits for them to do so, 
//		closes their handles, and frees the memory keeping track of
//		the threadpool. 
//
//  Effects:
//
//  Arguments:
//
//  Requires:   
//
//  Returns:    
//
//  Notes:
//
//
//--------------------------------------------------------------------------
VOID
KpCleanupThreadPool(
    VOID
    )
{
    DWORD dwWaitResult;
    BOOL fPostStatus;
    
    //
    // Post a terminate request for each thread.
    //
    
    for( ULONG i = KpThreadCount; i > 0; i-- )
    {
	fPostStatus = PostQueuedCompletionStatus(KpGlobalIocp,
						 0,
						 KPCK_TERMINATE,
						 NULL );

	if( !fPostStatus )
	{
	    DebugLog( DEB_ERROR, "%s(%d): Unable to post terminate request to the completion port: 0x%x.\n", __FILE__, __LINE__, GetLastError() );
	    // TODO: Consider if this fails.
	    // we'll probably want to wait for however many threads to terminate
	    // as we were able to post requests, then maybe try again or kill 
	    // the rest of the threads
	}
    }

    //
    // Wait for the threads to terminate
    //
    
    dwWaitResult = WaitForMultipleObjects(KpThreadCount,
					  KpThreadPool,
					  TRUE,
					  INFINITE );
    if( dwWaitResult == WAIT_FAILED )
    {
	DebugLog( DEB_ERROR, "%s(%d): Error waiting for thread terminations: 0x%x.", __FILE__, __LINE__, GetLastError() );
    }

    //
    // Close all the handles
    //

    while( KpThreadCount-- )
    {
	CloseHandle(KpThreadPool[KpThreadCount]);
    }

    // 
    // Free the memory
    //

    KpFree( KpThreadPool );
    KpThreadPool = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\kernel\ctxtmgr.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        ctxtmgr.h
//
// Contents:    Structures and prototyps for Kerberos context list
//
//
// History:     17-April-1996   Created         MikeSw
//
//------------------------------------------------------------------------

#ifndef __CTXTMGR_H__
#define __CTXTMGR_H__

//
// All global variables declared as EXTERN will be allocated in the file
// that defines CTXTMGR_ALLOCATE
//
#ifdef EXTERN
#undef EXTERN
#endif

#ifdef CTXTMGR_ALLOCATE
#define EXTERN
#else
#define EXTERN extern
#endif

EXTERN ERESOURCE KerbContextResource;
EXTERN KERBEROS_LIST KerbContextList;

#define KerbGetContextHandle(_Context_) ((ULONG_PTR)(_Context_))

//
// Context flags - these are attributes of a context and are stored in
// the ContextAttributes field of a KERB_KERNEL_CONTEXT.
//

#define KERB_CONTEXT_MAPPED       0x1
#define KERB_CONTEXT_OUTBOUND     0x2
#define KERB_CONTEXT_INBOUND      0x4
#define KERB_CONTEXT_USER_TO_USER 0x10
#define KERB_CONTEXT_IMPORTED     0x80
#define KERB_CONTEXT_EXPORTED     0x100

//
// NOTICE: The logon session resource, credential resource, and context
// resource must all be acquired carefully to prevent deadlock. They
// can only be acquired in this order:
//
// 1. Logon Sessions
// 2. Credentials
// 3. Contexts
//

#define KerbWriteLockContexts() \
{ \
    if ( KerbPoolType == PagedPool )                                    \
    {                                                                   \
        DebugLog((DEB_TRACE_LOCKS,"Write locking Contexts\n"));         \
        KeEnterCriticalRegion();                                        \
        ExAcquireResourceExclusiveLite(&KerbContextResource,TRUE);      \
    }                                                                   \
}
#define KerbReadLockContexts() \
{ \
    if ( KerbPoolType == PagedPool )                                    \
    {                                                                   \
        DebugLog((DEB_TRACE_LOCKS,"Read locking Contexts\n"));          \
        KeEnterCriticalRegion();                                        \
        ExAcquireSharedWaitForExclusive(&KerbContextResource, TRUE);    \
    }                                                                   \
}
#define KerbUnlockContexts() \
{ \
    if ( KerbPoolType == PagedPool )                                    \
    {                                                                   \
        DebugLog((DEB_TRACE_LOCKS,"Unlocking Contexts\n"));             \
        ExReleaseResourceLite(&KerbContextResource);                    \
        KeLeaveCriticalRegion();                                        \
    }                                                                   \
}

NTSTATUS
KerbInitContextList(
    VOID
    );

VOID
KerbFreeContextList(
    VOID
    );


NTSTATUS
KerbAllocateContext(
    PKERB_KERNEL_CONTEXT * NewContext
    );

NTSTATUS
KerbInsertContext(
    IN PKERB_KERNEL_CONTEXT Context
    );


PKERB_KERNEL_CONTEXT
KerbReferenceContext(
    IN LSA_SEC_HANDLE ContextHandle,
    IN BOOLEAN RemoveFromList
    );


VOID
KerbDereferenceContext(
    IN PKERB_KERNEL_CONTEXT Context
    );


VOID
KerbReferenceContextByPointer(
    IN PKERB_KERNEL_CONTEXT Context,
    IN BOOLEAN RemoveFromList
    );

PKERB_KERNEL_CONTEXT
KerbReferenceContextByLsaHandle(
    IN LSA_SEC_HANDLE ContextHandle,
    IN BOOLEAN RemoveFromList
    );



NTSTATUS
KerbCreateKernelModeContext(
    IN LSA_SEC_HANDLE ContextHandle,
    IN PSecBuffer MarshalledContext,
    OUT PKERB_KERNEL_CONTEXT * NewContext
    );



#endif // __CTXTMGR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\kernel\kerbkrnl.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        kerbp.h
//
// Contents:    global include file for Kerberos security package
//
//
// History:     16-April-1996       Created     MikeSw
//
//------------------------------------------------------------------------

#ifndef __KERBP_H__
#define __KERBP_H__

//
// All global variables declared as EXTERN will be allocated in the file
// that defines KERBP_ALLOCATE
//


#ifndef UNICODE
#define UNICODE
#endif // UNICODE

extern "C"
{
#include <ntosp.h>
#include <ntlsa.h>
#include <ntsam.h>
#include <winerror.h>
#ifndef SECURITY_WIN32
#define SECURITY_WIN32
#endif // SECURITY_WIN32
#define SECURITY_KERNEL
#define SECURITY_PACKAGE
#define SECURITY_KERBEROS
#include <security.h>
#include <secint.h>
#include <zwapi.h>
}
extern "C"
{
#include "kerblist.h"
#include "ctxtmgr.h"
}

//
// Macros for package information
//

#ifdef EXTERN
#undef EXTERN
#endif

#ifdef KERBKRNL_ALLOCATE
#define EXTERN
#else
#define EXTERN extern
#endif // KERBP_ALLOCATE


//
// Global state variables
//

EXTERN ULONG KerberosPackageId;
extern PSECPKG_KERNEL_FUNCTIONS KernelFunctions;

//
// Useful macros
//
#ifndef INVALID_HANDLE_VALUE
#define INVALID_HANDLE_VALUE ((HANDLE)-1)
#endif //ifndef INVALID_HANDLE_VALUE

//
// Macro to return the type field of a SecBuffer
//

#define BUFFERTYPE(_x_) ((_x_).BufferType & ~SECBUFFER_ATTRMASK)

extern PVOID KerbPagedList ;
extern PVOID KerbNonPagedList ;
extern PVOID KerbActiveList ;
extern POOL_TYPE KerbPoolType ;

#define KerbAllocate( _x_ ) ExAllocatePoolWithTag( KerbPoolType, (_x_) ,  'CbrK')
#define KerbFree( _x_ ) ExFreePool(_x_)


#if DBG


#define DEB_ERROR               0x00000001
#define DEB_WARN                0x00000002
#define DEB_TRACE               0x00000004
#define DEB_TRACE_LOCKS         0x00010000

extern "C"
{
void KsecDebugOut(ULONG, const char *, ...);
}

#define DebugLog(x) KsecDebugOut x

#else // DBG

#define DebugLog(x)

#endif // DBG

#endif // __KERBP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\kernel\ctxtmgr.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        ctxtmgr.cxx
//
// Contents:    Code for managing contexts list for the Kerberos package
//
//
// History:     17-April-1996   Created         MikeSw
//
//------------------------------------------------------------------------

#include "krbprgma.h"
#define CTXTMGR_ALLOCATE
#include <kerbkrnl.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, KerbInitContextList)
#pragma alloc_text(PAGE, KerbFreeContextList)
#pragma alloc_text(PAGEMSG, KerbAllocateContext)
#pragma alloc_text(PAGEMSG, KerbInsertContext)
#pragma alloc_text(PAGEMSG, KerbReferenceContext)
#pragma alloc_text(PAGEMSG, KerbDereferenceContext)
#pragma alloc_text(PAGEMSG, KerbCreateKernelModeContext)
#endif


#define MAYBE_PAGED_CODE()  \
    if ( KerbPoolType == PagedPool )    \
    {                                   \
        PAGED_CODE();                   \
    }

//+-------------------------------------------------------------------------
//
//  Function:   KerbInitContextList
//
//  Synopsis:   Initializes the contexts list
//
//  Effects:    allocates a resources
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS on success, other error codes
//              on failure
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
KerbInitContextList(
    VOID
    )
{
    NTSTATUS Status;

    PAGED_CODE();
    Status = ExInitializeResourceLite( &KerbContextResource );

    if (!NT_SUCCESS(Status))
    {
        return Status;
    }

    Status = KerbInitializeList( &KerbContextList );

    if (!NT_SUCCESS(Status))
    {
        ExDeleteResourceLite( &KerbContextResource );
    }

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbAllocateContext
//
//  Synopsis:   Allocates a Context structure
//
//  Effects:    Allocates a Context, but does not add it to the
//              list of Contexts
//
//  Arguments:  NewContext - receives a new Context allocated
//                  with KerbAllocate
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS on success
//              STATUS_INSUFFICIENT_RESOURCES if the allocation fails
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
KerbAllocateContext(
    PKERB_KERNEL_CONTEXT * NewContext
    )
{
    PKERB_KERNEL_CONTEXT Context;

    MAYBE_PAGED_CODE();

    //
    // Get the client process ID if we are running in the LSA
    //


    Context = (PKERB_KERNEL_CONTEXT) KerbAllocate(
                        sizeof(KERB_KERNEL_CONTEXT) );

    if (Context == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }
    RtlZeroMemory(
        Context,
        sizeof(KERB_KERNEL_CONTEXT)
        );

    KsecInitializeListEntry( &Context->List, KERB_CONTEXT_SIGNATURE );

    *NewContext = Context;

    return(STATUS_SUCCESS);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbInsertContext
//
//  Synopsis:   Inserts a logon session into the list of logon sessions
//
//  Effects:    bumps reference count on logon session
//
//  Arguments:  Context - Context to insert
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS always
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbInsertContext(
    IN PKERB_KERNEL_CONTEXT Context
    )
{
    MAYBE_PAGED_CODE();

    KSecInsertListEntry(
        KerbActiveList,
        (PKSEC_LIST_ENTRY) Context
        );

    return(STATUS_SUCCESS);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbReferenceContext
//
//  Synopsis:   Locates a context and references it
//
//  Effects:    Increments reference count and possible unlinks it from list
//
//  Arguments:  ContextHandle - Lsa Handle of context to reference.
//              RemoveFromList - If TRUE, context will be delinked.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


PKERB_KERNEL_CONTEXT
KerbReferenceContext(
    IN LSA_SEC_HANDLE ContextHandle,
    IN BOOLEAN RemoveFromList
    )
{
    PKERB_KERNEL_CONTEXT Context = NULL;
    NTSTATUS Status;

    MAYBE_PAGED_CODE();

    Status = KSecReferenceListEntry(
                    (PKSEC_LIST_ENTRY) ContextHandle,
                    KERB_CONTEXT_SIGNATURE,
                    RemoveFromList );

    if ( NT_SUCCESS( Status ) )
    {
        Context = (PKERB_KERNEL_CONTEXT) ContextHandle ;
    }

    //
    // In kernel mode we trust the caller to provide a valid pointer, but
    // make sure it is a kernel mode pointer.
    //


    return(Context);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbFreeContext
//
//  Synopsis:   Frees a context that is unlinked
//
//  Effects:    frees all storage associated with the context
//
//  Arguments:  Context - context to free
//
//  Requires:
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KerbFreeContext(
    IN PKERB_KERNEL_CONTEXT Context
    )
{
    PAGED_CODE();

    if (Context->TokenHandle != NULL)
    {
        NtClose(Context->TokenHandle);
    }
    if (Context->AccessToken != NULL)
    {
        ObDereferenceObject( Context->AccessToken );
    }

    if (Context->FullName.Buffer != NULL)
    {
        KerbFree(Context->FullName.Buffer);
    }
    if (Context->SessionKey.keyvalue.value != NULL)
    {
        KerbFree(Context->SessionKey.keyvalue.value);
    }

    if (Context->pbMarshalledTargetInfo != NULL)
    {
        KerbFree(Context->pbMarshalledTargetInfo);
    }
    KerbFree(Context);

}

//+-------------------------------------------------------------------------
//
//  Function:   KerbDereferenceContext
//
//  Synopsis:   Dereferences a logon session - if reference count goes
//              to zero it frees the logon session
//
//  Effects:    decrements reference count
//
//  Arguments:  Context - Logon session to dereference
//
//  Requires:
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KerbDereferenceContext(
    IN PKERB_KERNEL_CONTEXT Context
    )
{
    BOOLEAN Delete ;

    MAYBE_PAGED_CODE();

    KSecDereferenceListEntry(
        (PKSEC_LIST_ENTRY) Context,
        &Delete );

    if ( Delete )
    {
        KerbFreeContext( Context );
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbCreateKernelModeContext
//
//  Synopsis:   Creates a kernel-mode context to support impersonation and
//              message integrity and privacy
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbCreateKernelModeContext(
    IN LSA_SEC_HANDLE ContextHandle,
    IN PSecBuffer MarshalledContext,
    OUT PKERB_KERNEL_CONTEXT * NewContext
    )
{
    NTSTATUS Status;
    PKERB_KERNEL_CONTEXT Context = NULL;
    PKERB_PACKED_CONTEXT PackedContext ;
    PUCHAR Where;

    PAGED_CODE();

    if (MarshalledContext->cbBuffer < sizeof(KERB_PACKED_CONTEXT))
    {
        DebugLog((DEB_ERROR,"Invalid buffer size for marshalled context: was 0x%x, needed 0x%x\n",
            MarshalledContext->cbBuffer, sizeof(KERB_CONTEXT)));
        return(STATUS_INVALID_PARAMETER);
    }

    PackedContext = (PKERB_PACKED_CONTEXT) MarshalledContext->pvBuffer;

    Status = KerbAllocateContext( &Context );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    KsecInitializeListEntry( &Context->List, KERB_CONTEXT_SIGNATURE );

    Context->Lifetime = PackedContext->Lifetime;
    Context->RenewTime = PackedContext->RenewTime;
    Context->Nonce = PackedContext->Nonce;
    Context->ReceiveNonce = PackedContext->ReceiveNonce;
    Context->ContextFlags = PackedContext->ContextFlags;
    Context->ContextAttributes = PackedContext->ContextAttributes;
    Context->EncryptionType = PackedContext->EncryptionType;

    Context->LsaContextHandle = ContextHandle;
    Context->ReceiveNonce = Context->Nonce;
    Context->TokenHandle = (HANDLE) ULongToPtr(PackedContext->TokenHandle);

    //
    // Fill in the full name, which is the concatenation of the client name
    // and client realm with a '\\' separator
    //

    Context->FullName.MaximumLength = PackedContext->ClientName.Length +
                                PackedContext->ClientRealm.Length +
                                sizeof(WCHAR);
    Context->FullName.Buffer = (LPWSTR) KerbAllocate(Context->FullName.MaximumLength);
    if (Context->FullName.Buffer == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    Where = (PUCHAR) Context->FullName.Buffer;
    if (PackedContext->ClientRealm.Length != 0)
    {
        RtlCopyMemory(
            Where,
            (PUCHAR) PackedContext + (ULONG_PTR) PackedContext->ClientRealm.Buffer,
            PackedContext->ClientRealm.Length
            );
        Where += PackedContext->ClientRealm.Length;
        *(LPWSTR) Where = L'\\';
        Where += sizeof(WCHAR);
    }

    if (PackedContext->ClientName.Length != 0)
    {
        RtlCopyMemory(
            Where,
            (PUCHAR) PackedContext + (ULONG_PTR) PackedContext->ClientName.Buffer,
            PackedContext->ClientName.Length
            );
        Where += PackedContext->ClientName.Length;
    }

    Context->FullName.Length = (USHORT) (Where - (PUCHAR) Context->FullName.Buffer);

    //
    // Copy in the session key
    //



    Context->SessionKey.keytype = PackedContext->SessionKeyType;
    Context->SessionKey.keyvalue.length = PackedContext->SessionKeyLength;
    if (Context->SessionKey.keyvalue.length != 0)
    {
        Context->SessionKey.keyvalue.value = (PUCHAR) KerbAllocate( Context->SessionKey.keyvalue.length );
        if (Context->SessionKey.keyvalue.value == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        RtlCopyMemory(
            Context->SessionKey.keyvalue.value,
            (PUCHAR) PackedContext + PackedContext->SessionKeyOffset,
            Context->SessionKey.keyvalue.length
            );
    }


    //
    // copy in the marshalled target info.
    //

    Context->cbMarshalledTargetInfo = PackedContext->MarshalledTargetInfoLength;
    if (PackedContext->MarshalledTargetInfo)
    {
        Context->pbMarshalledTargetInfo = (PUCHAR) KerbAllocate( Context->cbMarshalledTargetInfo );
        if (Context->pbMarshalledTargetInfo == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        RtlCopyMemory(
            Context->pbMarshalledTargetInfo,
            (PUCHAR) PackedContext + PackedContext->MarshalledTargetInfo,
            Context->cbMarshalledTargetInfo
            );

    } else {
        Context->pbMarshalledTargetInfo = NULL;
    }

    Status = KerbInsertContext(
                Context
                );
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to insert context: 0x%x\n",Status));
        goto Cleanup;
    }


    *NewContext = Context;

Cleanup:
    if (!NT_SUCCESS(Status))
    {
        if (Context != NULL)
        {
            KerbFreeContext(Context);
        }
    }
    return(Status);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\kernel\kerblist.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        kerblist.h
//
// Contents:    types for Kerbers internal lists
//
//
// History:     16-Apr-1996     MikeSw          Created
//
//------------------------------------------------------------------------

#ifndef __KERBLIST_H__
#define __KERBLIST_H__


//
// Generic list entry structure allowing common code for inserting
// logon sessions, credentials, and contexts.
//

typedef struct _KERBEROS_LIST {
    LIST_ENTRY List;
    ERESOURCE Lock;
} KERBEROS_LIST, *PKERBEROS_LIST;

typedef struct _KERBEROS_LIST_ENTRY {
    LIST_ENTRY Next;
    ULONG ReferenceCount;
} KERBEROS_LIST_ENTRY, *PKERBEROS_LIST_ENTRY;




typedef enum _KERB_CONTEXT_STATE {
    IdleState,
    TgtRequestSentState,
    TgtReplySentState,
    ApRequestSentState,
    ApReplySentState,
    AuthenticatedState,
    ErrorMessageSentState,
    InvalidState
} KERB_CONTEXT_STATE, *PKERB_CONTEXT_STATE;

//
// Guards - this structure is defined in krb5.h
//

#ifndef OSS_krb5
typedef struct KERB_ENCRYPTION_KEY {
    int             keytype;
    struct {
        unsigned int    length;
        unsigned char   *value;
    } keyvalue;
} KERB_ENCRYPTION_KEY;
#endif

#define KERB_CONTEXT_SIGNATURE 'BREK'
#define KERB_CONTEXT_DELETED_SIGNATURE 'XBRK'

typedef struct _KERB_KERNEL_CONTEXT {
    KSEC_LIST_ENTRY List ;
    LARGE_INTEGER Lifetime;             // end time/expiration time
    LARGE_INTEGER RenewTime;            // time to renew until
    UNICODE_STRING FullName;
    LSA_SEC_HANDLE LsaContextHandle;
    PACCESS_TOKEN AccessToken;
    HANDLE TokenHandle;
    KERB_ENCRYPTION_KEY SessionKey;
    ULONG Nonce;
    ULONG ReceiveNonce;
    ULONG ContextFlags;
    ULONG ContextAttributes;
    ULONG EncryptionType;
    PUCHAR pbMarshalledTargetInfo;
    ULONG cbMarshalledTargetInfo;
} KERB_KERNEL_CONTEXT, *PKERB_KERNEL_CONTEXT;



typedef struct _KERB_CONTEXT {
    KERBEROS_LIST_ENTRY ListEntry;
    TimeStamp Lifetime;             // end time/expiration time
    TimeStamp RenewTime;            // time to renew until
    TimeStamp StartTime;
    UNICODE_STRING ClientName;
    UNICODE_STRING ClientRealm;
    union {
        ULONG ClientProcess;
        ULONG LsaContextHandle;
    };
    LUID LogonId;
    HANDLE TokenHandle;
    ULONG CredentialHandle;
    KERB_ENCRYPTION_KEY SessionKey;
    ULONG Nonce;
    ULONG ReceiveNonce;
    ULONG ContextFlags;
    ULONG ContextAttributes;
    ULONG EncryptionType;
    PSID UserSid;
    KERB_CONTEXT_STATE ContextState;
    ULONG Retries;
    KERB_ENCRYPTION_KEY TicketKey;
    PVOID TicketCacheEntry;
    //
    // marshalled target info for DFS/RDR.
    //

    PUCHAR pbMarshalledTargetInfo;
    ULONG cbMarshalledTargetInfo;
} KERB_CONTEXT, *PKERB_CONTEXT;

typedef struct _KERB_PACKED_CONTEXT {
    ULONG   ContextType ;               // Indicates the type of the context
    ULONG   Pad;                        // Pad data
    TimeStamp Lifetime;                 // Matches basic context above
    TimeStamp RenewTime ;
    TimeStamp StartTime;
    UNICODE_STRING32 ClientName ;
    UNICODE_STRING32 ClientRealm ;
    ULONG LsaContextHandle ;
    LUID LogonId ;
    ULONG TokenHandle ;
    ULONG CredentialHandle ;
    ULONG SessionKeyType ;
    ULONG SessionKeyOffset ;
    ULONG SessionKeyLength ;
    ULONG Nonce ;
    ULONG ReceiveNonce ;
    ULONG ContextFlags ;
    ULONG ContextAttributes ;
    ULONG EncryptionType ;
    KERB_CONTEXT_STATE ContextState ;
    ULONG Retries ;
    ULONG MarshalledTargetInfo; // offset
    ULONG MarshalledTargetInfoLength;
} KERB_PACKED_CONTEXT, * PKERB_PACKED_CONTEXT ;

#define KERB_PACKED_CONTEXT_MAP     0
#define KERB_PACKED_CONTEXT_EXPORT  1


//
// Functions for manipulating Kerberos lists
//


NTSTATUS
KerbInitializeList(
    IN PKERBEROS_LIST List
    );

VOID
KerbFreeList(
    IN PKERBEROS_LIST List
    );

VOID
KerbInsertListEntry(
    IN PKERBEROS_LIST_ENTRY ListEntry,
    IN PKERBEROS_LIST List
    );

VOID
KerbReferenceListEntry(
    IN PKERBEROS_LIST List,
    IN PKERBEROS_LIST_ENTRY ListEntry,
    IN BOOLEAN RemoveFromList
    );

BOOLEAN
KerbDereferenceListEntry(
    IN PKERBEROS_LIST_ENTRY ListEntry,
    IN PKERBEROS_LIST List
    );


VOID
KerbInitializeListEntry(
    IN OUT PKERBEROS_LIST_ENTRY ListEntry
    );

VOID
KerbValidateListEx(
    IN PKERBEROS_LIST List
    );

#if DBG
#define KerbValidateList(_List_) KerbValidateListEx(_List_)
#else
#define KerbValidateList(_List_)
#endif // DBG


#define KerbLockList(_List_)                                \
{                                                           \
    KeEnterCriticalRegion();                                \
    ExAcquireResourceExclusiveLite(&(_List_)->Lock, TRUE ); \
}

#define KerbUnlockList(_List_)                              \
{                                                           \
    ExReleaseResourceLite(&(_List_)->Lock);                 \
    KeLeaveCriticalRegion();                                \
}

#endif // __KERBLIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\kernel\kerblist.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        kerblist.cxx
//
// Contents:    Common list code for the Kerberos package
//
//
// History:     16-April-1996   Created         MikeSw
//
//------------------------------------------------------------------------

#include "krbprgma.h"
#include <kerbkrnl.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, KerbInitializeList)
#pragma alloc_text(PAGE, KerbFreeList)
#pragma alloc_text(PAGEMSG, KerbInitializeListEntry)
#pragma alloc_text(PAGEMSG, KerbInsertListEntry)
#pragma alloc_text(PAGEMSG, KerbReferenceListEntry)
#pragma alloc_text(PAGEMSG, KerbDereferenceListEntry)
#pragma alloc_text(PAGEMSG, KerbValidateListEx)
#endif

//+-------------------------------------------------------------------------
//
//  Function:   KerbInitializeList
//
//  Synopsis:   Initializes a kerberos list by initializing the lock
//              and the list entry.
//
//  Effects:
//
//  Arguments:  List - List to initialize
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS on success or errors from
//              RtlInitializeResources
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbInitializeList(
    IN PKERBEROS_LIST List
    )
{
    NTSTATUS Status;

    PAGED_CODE();
    InitializeListHead(&List->List);

    Status = ExInitializeResourceLite(
                &List->Lock
                );

    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbFreeList
//
//  Synopsis:   Frees a kerberos list by deleting the associated
//              critical section.
//
//  Effects:    List - the list to free.
//
//  Arguments:
//
//  Requires:
//
//  Returns:    none
//
//  Notes:      The list must be empty before freeing it.
//
//
//--------------------------------------------------------------------------



VOID
KerbFreeList(
    IN PKERBEROS_LIST List
    )
{
    PAGED_CODE();
    //
    // Make sure the list is empty first
    //

    ASSERT(List->List.Flink == List->List.Blink);
    ExDeleteResourceLite(&List->Lock);

}


//+-------------------------------------------------------------------------
//
//  Function:   KerbInitializeListEntry
//
//  Synopsis:   Initializes a newly created list entry for later
//              insertion onto the list.
//
//  Effects:    The reference count is set to one and the links are set
//              to NULL.
//
//  Arguments:  ListEntry - the list entry to initialize
//
//  Requires:
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbInitializeListEntry(
    IN OUT PKERBEROS_LIST_ENTRY ListEntry
    )
{
    PAGED_CODE();
    ListEntry->ReferenceCount = 1;
    ListEntry->Next.Flink = ListEntry->Next.Blink = NULL;
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbInsertListEntry
//
//  Synopsis:   Inserts an entry into a kerberos list
//
//  Effects:    increments the reference count on the entry - if the
//              list entry was formly referenced it remains referenced.
//
//  Arguments:  ListEntry - the entry to insert
//              List - the list in which to insert the ListEntry
//
//  Requires:
//
//  Returns:    nothing
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KerbInsertListEntry(
    IN PKERBEROS_LIST_ENTRY ListEntry,
    IN PKERBEROS_LIST List
    )
{
    PAGED_CODE();
    ListEntry->ReferenceCount++;

    KerbLockList(List);

    KerbValidateList(List);

    InsertHeadList(
        &List->List,
        &ListEntry->Next
        );

    KerbValidateList(List);


    KerbUnlockList(List);

}


//+-------------------------------------------------------------------------
//
//  Function:   KerbReferenceListEntry
//
//  Synopsis:   References a list entry. If the flag RemoveFromList
//              has been specified, the entry is unlinked from the
//              list.
//
//  Effects:    bumps the reference count on the entry (unless it is
//              being removed from the list)
//
//  Arguments:
//
//  Requires:   The list must be locked when calling this routine
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KerbReferenceListEntry(
    IN PKERBEROS_LIST List,
    IN PKERBEROS_LIST_ENTRY ListEntry,
    IN BOOLEAN RemoveFromList
    )
{
    PAGED_CODE();
    KerbValidateList(List);

    if (RemoveFromList)
    {
        RemoveEntryList(&ListEntry->Next);
        ListEntry->Next.Flink = NULL;
        ListEntry->Next.Blink = NULL;
    }
    else
    {
        ListEntry->ReferenceCount++;
    }

    KerbValidateList(List);

}


//+-------------------------------------------------------------------------
//
//  Function:   KerbDereferenceListEntry
//
//  Synopsis:   Dereferences a list entry and returns a flag indicating
//              whether the entry should be freed.
//
//  Effects:    decrements reference count on list entry
//
//  Arguments:  ListEntry - the list entry to dereference
//              List - the list containing the list entry
//
//  Requires:
//
//  Returns:    TRUE - the list entry should be freed
//              FALSE - the list entry is still referenced
//
//  Notes:
//
//
//--------------------------------------------------------------------------


BOOLEAN
KerbDereferenceListEntry(
    IN PKERBEROS_LIST_ENTRY ListEntry,
    IN PKERBEROS_LIST List
    )
{
    BOOLEAN DeleteEntry = FALSE;

    PAGED_CODE();
    KerbLockList(List);
    KerbValidateList(List);

    ListEntry->ReferenceCount -= 1;
    if (ListEntry->ReferenceCount == 0)
    {
        DeleteEntry = TRUE;
    }

    KerbValidateList(List);

    KerbUnlockList(List);
    return(DeleteEntry);
}


#if DBG
//+-------------------------------------------------------------------------
//
//  Function:   KerbValidateListEx
//
//  Synopsis:   Validates that a list is valid
//
//  Effects:    traverses a list to make sure it is has no loops
//
//  Arguments:  List - The list to validate
//
//  Requires:
//
//  Returns:    none
//
//  Notes:      This routine assumes there are less than 1000 entries
//              in the list.
//
//
//--------------------------------------------------------------------------

VOID
KerbValidateListEx(
    IN PKERBEROS_LIST List
    )
{
    ULONG Entries = 0;
    PLIST_ENTRY ListEntry;

    PAGED_CODE();
    for (ListEntry = List->List.Flink ;
         ListEntry != &List->List ;
         ListEntry = ListEntry->Flink )
    {
        if (++Entries > 1000) {
            DebugLog((DEB_ERROR,"List is looping - more than 1000 entries found\n"));
            DbgBreakPoint();
            break;
        }
    }

}
#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\kernel\krnlapi.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        userapi.cxx
//
// Contents:    User-mode APIs to Kerberos package
//
//
// History:     17-April-1996   Created         MikeSw
//
//------------------------------------------------------------------------

#include "krbprgma.h"
#include <kerbkrnl.h>
extern "C"
{
#include <cryptdll.h>
}
#include "krnlapi.h"

#define DONT_SUPPORT_OLD_TYPES_USER 1

//
// Make these extern "C" to allow them to be pageable.
//

extern "C"
{
KspInitPackageFn       KerbInitKernelPackage;
KspDeleteContextFn     KerbDeleteKernelContext;
KspInitContextFn       KerbInitKernelContext;
KspMapHandleFn         KerbMapKernelHandle;
KspMakeSignatureFn     KerbMakeSignature;
KspVerifySignatureFn   KerbVerifySignature;
KspSealMessageFn       KerbSealMessage;
KspUnsealMessageFn     KerbUnsealMessage;
KspGetTokenFn          KerbGetContextToken;
KspQueryAttributesFn   KerbQueryContextAttributes;
KspCompleteTokenFn     KerbCompleteToken;
SpExportSecurityContextFn      KerbExportContext;
SpImportSecurityContextFn      KerbImportContext;
KspSetPagingModeFn     KerbSetPageMode ;

NTSTATUS
KerbMakeSignatureToken(
    IN PKERB_KERNEL_CONTEXT Context,
    IN ULONG QualityOfProtection,
    IN PSecBuffer SignatureBuffer,
    IN ULONG TotalBufferSize,
    IN BOOLEAN Encrypt,
    IN ULONG SuppliedNonce,
    OUT PKERB_GSS_SIGNATURE * OutputSignature,
    OUT PLONG ChecksumType,
    OUT PLONG EncryptionType,
    OUT PULONG SequenceNumber
    );

NTSTATUS
KerbVerifySignatureToken(
    IN PKERB_KERNEL_CONTEXT Context,
    IN PSecBuffer SignatureBuffer,
    IN ULONG TotalBufferSize,
    IN BOOLEAN Decrypt,
    IN ULONG SuppliedNonce,
    OUT PKERB_GSS_SIGNATURE * OutputSignature,
    OUT PULONG QualityOfProtection,
    OUT PLONG ChecksumType,
    OUT PCRYPTO_SYSTEM * CryptSystem,
    OUT PULONG SequenceNumber
    );

NTSTATUS NTAPI
KerbInitDefaults();

}

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, KerbInitKernelPackage)
#pragma alloc_text(PAGE, KerbDeleteKernelContext)
#pragma alloc_text(PAGE, KerbInitKernelContext)
#pragma alloc_text(PAGE, KerbMapKernelHandle)
#pragma alloc_text(PAGEMSG, KerbMakeSignature)
#pragma alloc_text(PAGEMSG, KerbVerifySignature)
#pragma alloc_text(PAGEMSG, KerbSealMessage)
#pragma alloc_text(PAGEMSG, KerbUnsealMessage)
#pragma alloc_text(PAGEMSG, KerbGetContextToken)
#pragma alloc_text(PAGEMSG, KerbQueryContextAttributes)
#pragma alloc_text(PAGEMSG, KerbMakeSignatureToken)
#pragma alloc_text(PAGEMSG, KerbVerifySignatureToken)
#pragma alloc_text(PAGE, KerbCompleteToken)
#pragma alloc_text(PAGE, KerbExportContext)
#pragma alloc_text(PAGE, KerbImportContext)
#pragma alloc_text(PAGE, KerbInitDefaults)
#endif

SECPKG_KERNEL_FUNCTION_TABLE KerberosFunctionTable = {
    KerbInitKernelPackage,
    KerbDeleteKernelContext,
    KerbInitKernelContext,
    KerbMapKernelHandle,
    KerbMakeSignature,
    KerbVerifySignature,
    KerbSealMessage,
    KerbUnsealMessage,
    KerbGetContextToken,
    KerbQueryContextAttributes,
    KerbCompleteToken,
    KerbExportContext,
    KerbImportContext,
    KerbSetPageMode

};
POOL_TYPE KerbPoolType ;

#define MAYBE_PAGED_CODE()  \
    if ( KerbPoolType == PagedPool )    \
    {                                   \
        PAGED_CODE();                   \
    }

PVOID KerbPagedList ;
PVOID KerbNonPagedList ;
PVOID KerbActiveList ;
ERESOURCE KerbGlobalResource;
BOOLEAN KerbCryptInitialized;
ULONG KerbMaxTokenSize = KERBEROS_MAX_TOKEN;

extern "C"
{
int LibAttach(HANDLE, PVOID);
}

#define KerbWriteLockGlobals() \
{ \
    DebugLog((DEB_TRACE_LOCKS,"Write locking Globals\n"));      \
    KeEnterCriticalRegion();                                    \
    ExAcquireResourceExclusiveLite(&KerbGlobalResource,TRUE);       \
}
#define KerbReadLockGlobals() \
{ \
    DebugLog((DEB_TRACE_LOCKS,"Read locking Globals\n"));       \
    KeEnterCriticalRegion();                                    \
    ExAcquireSharedWaitForExclusive(&KerbGlobalResource, TRUE); \
}
#define KerbUnlockGlobals() \
{ \
    DebugLog((DEB_TRACE_LOCKS,"Unlocking Globals\n"));          \
    ExReleaseResourceLite(&KerbGlobalResource);                     \
    KeLeaveCriticalRegion();                                    \
}

//
// Common GSS object IDs, taken from MIT kerberos distribution.
//

gss_OID_desc oids[] = {
    {5, "\053\005\001\005\002"},                      // original mech id
    {9, "\052\206\110\206\367\022\001\002\002"},      // standard mech id
    {10, "\052\206\110\206\367\022\001\002\002\001"}, // krb5_name type
    {10, "\052\206\110\206\367\022\001\002\002\002"}, // krb5_principal type
    {10, "\052\206\110\206\367\022\001\002\002\003"}, // user2user mech id
};

gss_OID_desc * gss_mech_krb5 = oids;
gss_OID_desc * gss_mech_krb5_new = oids+1;
gss_OID_desc * gss_mech_krb5_u2u = oids+4;


#define KERB_MAX_CHECKSUM_LENGTH    24

//+-------------------------------------------------------------------------
//
//  Function:   KerbInitDefaults
//
//  Synopsis:   Opens registry key, and gets custom defaults
//
//  Effects:    Changes MaxTokenSize
//
//  Arguments:  None
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS on success
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS NTAPI
KerbInitDefaults()
{
   UNICODE_STRING       ParameterPath;
   UNICODE_STRING       MaxTokenValue;
   OBJECT_ATTRIBUTES    oa;
   ULONG                BytesRead;
   NTSTATUS             Status;
   HANDLE               hParamKey = INVALID_HANDLE_VALUE;
   
   KEY_VALUE_PARTIAL_INFORMATION KeyPartialInformation; 
   
   PAGED_CODE();
   
   RtlInitUnicodeString(&ParameterPath, KERB_PARAMETER_PATH);
   RtlInitUnicodeString(&MaxTokenValue, KERB_PARAMETER_MAX_TOKEN_SIZE);

   InitializeObjectAttributes(
               &oa,
               &ParameterPath,
               OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
               NULL,
               NULL
               );

   Status = ZwOpenKey(
               &hParamKey,
               KEY_READ,
               &oa
               );

   if (!NT_SUCCESS(Status))
   {
      DebugLog((DEB_WARN, "KerbInitDefault:OpenKey failed:0x%x\n",Status));
      goto Cleanup;
   }  

   Status = ZwQueryValueKey(
               hParamKey,
               &MaxTokenValue,
               KeyValuePartialInformation,
               (PVOID)&KeyPartialInformation,
               sizeof(KeyPartialInformation),
               &BytesRead
               );

   if (!NT_SUCCESS(Status) || KeyPartialInformation.Type != REG_DWORD)
   {
      DebugLog((DEB_WARN, "KerbInitDefault:QueryValueKey failed:0x%x\n",Status));
      goto Cleanup;
   } else {
      PULONG Value = (PULONG) &KeyPartialInformation.Data;
      KerbMaxTokenSize = *((PULONG)Value);
   }

Cleanup:

   if (INVALID_HANDLE_VALUE != hParamKey)
   {
      ZwClose(hParamKey);
   }

   return Status;
}
   
//+-------------------------------------------------------------------------
//
//  Function:   KerbInitKernelPackage
//
//  Synopsis:   Initialize an instance of the Kerberos package in the kernel
//
//  Effects:
//
//  Arguments:  Version - Version of the security dll loading the package
//              FunctionTable - Contains helper routines for use by Kerberos
//              UserFunctions - Receives a copy of Kerberos's user mode
//                  function table
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
KerbInitKernelPackage(
    PSECPKG_KERNEL_FUNCTIONS    FunctionTable
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PAGED_CODE();

    KerbPoolType = PagedPool ;

    KerbPagedList = KSecCreateContextList( KSecPaged );

    if ( !KerbPagedList )
    {
        return STATUS_NO_MEMORY ;
    }

    KerbActiveList = KerbPagedList ;

    Status = ExInitializeResourceLite(&KerbGlobalResource);

    if (!NT_SUCCESS(Status))
    {
        return Status;
    }

    Status = KerbInitContextList();

    if (!NT_SUCCESS(Status))
    {
        ExDeleteResourceLite(&KerbGlobalResource);
        return Status;
    }

    // Get registry values, ignore failures
    KerbInitDefaults();                    

    return STATUS_SUCCESS ;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbDeleteKernelContext
//
//  Synopsis:   Deletes a kernel mode context by unlinking it and then
//              dereferencing it.
//
//  Effects:
//
//  Arguments:  ContextHandle - Kernel context handle of the context to delete
//              LsaContextHandle - Receives LSA context handle of the context
//                      to delete
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS on success
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
KerbDeleteKernelContext(
    IN LSA_SEC_HANDLE ContextHandle,
    OUT PLSA_SEC_HANDLE LsaContextHandle
    )
{
    PKERB_KERNEL_CONTEXT Context = NULL;
    NTSTATUS SaveStatus = STATUS_SUCCESS;
    DebugLog((DEB_TRACE,"KerbDeleteUserModeContext called\n"));


    Context = KerbReferenceContext(
                ContextHandle,
                TRUE                // unlink it
                );
    if (Context == NULL)
    {
        DebugLog((DEB_WARN,"Failed to reference context 0x%x by lsa handle\n",
            ContextHandle ));
        *LsaContextHandle = ContextHandle;
        return(STATUS_INVALID_HANDLE);
    }

    KerbReadLockContexts();

    *LsaContextHandle = Context->LsaContextHandle;

    if ((Context->ContextAttributes & KERB_CONTEXT_EXPORTED) != 0)
    {
        SaveStatus = SEC_I_NO_LSA_CONTEXT;
    }

    KerbUnlockContexts();

    KerbDereferenceContext(
        Context
        );

    return((SaveStatus == SEC_I_NO_LSA_CONTEXT) ?
                          SEC_I_NO_LSA_CONTEXT :
                          STATUS_SUCCESS);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbInitKernelContext
//
//  Synopsis:   Creates a kernel-mode context from a packed LSA mode context
//
//  Effects:
//
//  Arguments:  ContextHandle - Lsa mode context handle for the context
//              PackedContext - A marshalled buffer containing the LSA
//                  mode context.
//              NewContextHandle - Receives kernel mode context handle
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS or STATUS_INSUFFICIENT_RESOURCES
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
KerbInitKernelContext(
    IN LSA_SEC_HANDLE LsaContextHandle,
    IN PSecBuffer PackedContext,
    OUT PLSA_SEC_HANDLE NewContextHandle
    )
{
    NTSTATUS Status;
    PKERB_KERNEL_CONTEXT Context = NULL;

    PAGED_CODE();
    DebugLog((DEB_TRACE,"KerbInitUserModeContex called\n"));

    Status = KerbCreateKernelModeContext(
                LsaContextHandle,
                PackedContext,
                &Context
                );
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to create kernel mode context: 0x%x\n",
            Status));
        goto Cleanup;
    }

    *NewContextHandle = KerbGetContextHandle(Context);

Cleanup:
    if (Context != NULL)
    {
        KerbDereferenceContext(Context);
    }
    if (PackedContext->pvBuffer != NULL)
    {
        KspKernelFunctions.FreeHeap(PackedContext->pvBuffer);
        PackedContext->pvBuffer = NULL;
    }


    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbMapKernelHandle
//
//  Synopsis:   Maps a kernel handle into an LSA handle
//
//  Effects:
//
//  Arguments:  ContextHandle - Kernel context handle of the context to map
//              LsaContextHandle - Receives LSA context handle of the context
//                      to map
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS on success
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
KerbMapKernelHandle(
    IN LSA_SEC_HANDLE ContextHandle,
    OUT PLSA_SEC_HANDLE LsaContextHandle
    )
{
    PKERB_KERNEL_CONTEXT Context = NULL;
    DebugLog((DEB_TRACE,"KerbMapKernelhandle called\n"));

    PAGED_CODE();
    Context = KerbReferenceContext(
                ContextHandle,
                FALSE                // don't it
                );
    if (Context == NULL)
    {
        DebugLog((DEB_WARN,"Failed to reference context 0x%x by lsa handle\n",
            ContextHandle ));
        *LsaContextHandle = ContextHandle;
    }
    else
    {
        *LsaContextHandle = Context->LsaContextHandle;
        KerbDereferenceContext(
            Context
            );
        //
        // If the lsa context handle is zero, this is an imported context
        // so there is no lsa context
        //

        if (*LsaContextHandle == 0)
        {
            return(SEC_E_UNSUPPORTED_FUNCTION);
        }

    }

    return(STATUS_SUCCESS);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbRandomFill
//
//  Synopsis:   Generates random data in the buffer.
//
//  Arguments:  [pbBuffer] --
//              [cbBuffer] --
//
//  History:    5-20-93   RichardW   Created
//
//  Notes:
//
//--------------------------------------------------------------------------

BOOLEAN
KerbRandomFill( PUCHAR      pbBuffer,
                ULONG       cbBuffer)
{
    return CDGenerateRandomBits(pbBuffer, cbBuffer);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbMakeSignatureToken
//
//  Synopsis:   Makes the signature token for a signed or sealed message
//
//  Effects:
//
//  Arguments:  Context - Context to use for signing
//              QualityOfProtection - flags indicating what kind of checksum
//                      to use
//              SignatureBuffer - Buffer in which to place signature
//              TotalBufferSize - Total size of all buffers to be signed
//              Encrypt - if TRUE, then prepare a header for an encrypted buffer
//              SuppliedNonce - Nonce supplied by caller, used for datagram
//              ChecksumType - Receives the type of checksum to use
//              EncryptionType - Receives the type of encryption to use
//
//  Requires:   The context must be write locked
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbMakeSignatureToken(
    IN PKERB_KERNEL_CONTEXT Context,
    IN ULONG QualityOfProtection,
    IN PSecBuffer SignatureBuffer,
    IN ULONG TotalBufferSize,
    IN BOOLEAN Encrypt,
    IN ULONG SuppliedNonce,
    OUT PKERB_GSS_SIGNATURE * OutputSignature,
    OUT PLONG ChecksumType,
    OUT PLONG EncryptionType,
    OUT PULONG SequenceNumber
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_GSS_SIGNATURE Signature;
    PKERB_GSS_SEAL_SIGNATURE SealSignature;
    ULONG MessageSize;
    ULONG SignatureSize = 0;
    PULONG Nonce;
    gss_OID MechUsed;
    BOOLEAN GssCompatible = TRUE;

    //
    // Make sure that cryptdll stuff is initialized.
    //

    MAYBE_PAGED_CODE();

    if (!KerbCryptInitialized)
    {
        KerbWriteLockGlobals();
        if ( !KerbCryptInitialized )
        {
            if (LibAttach(NULL, NULL))
            {
                KerbCryptInitialized = TRUE;
            }
        }
        KerbUnlockGlobals();
    }

    //
    // Compute the size of the header. For encryption headers, we need
    // to round up the size of the data & add 8 bytes for a confounder.
    //

    if (QualityOfProtection == GSS_KRB5_INTEG_C_QOP_DEFAULT)
    {
        GssCompatible = FALSE;
    }

    //
    // Since RPC doesn't carry around the size of the size of the
    // signature bufer, we use it in the header. This break rfc1964 compat.
    //

    if (!Encrypt || !GssCompatible)
    {
        TotalBufferSize = 0;
    }

    if ((Context->ContextAttributes & KERB_CONTEXT_USER_TO_USER) != 0)
    {
        MechUsed = gss_mech_krb5_u2u;
    }
    else
    {
        MechUsed = gss_mech_krb5_new;
    }
    if (Encrypt)
    {
        //
        // NOTE: according to rfc1964, buffers that are an even multiple of
        // 8 bytes have 8 bytes of zeros appended. Because we cannot modify
        // the input buffers, the caller will have to do this for us.
        //


        MessageSize = TotalBufferSize + sizeof(KERB_GSS_SEAL_SIGNATURE);
    }
    else
    {
        MessageSize = TotalBufferSize + sizeof(KERB_GSS_SIGNATURE);
    }

    SignatureSize = g_token_size(MechUsed, MessageSize) - TotalBufferSize;


    //
    // Make Dave happy (verify that the supplied signature buffer is large
    // enough for a signature):
    //

    if (SignatureBuffer->cbBuffer < SignatureSize)
    {
        Status = STATUS_BUFFER_TOO_SMALL;
        goto Cleanup;
    }


    //
    // create the header with the GSS oid
    //

    Signature = (PKERB_GSS_SIGNATURE) SignatureBuffer->pvBuffer;
    g_make_token_header(
        MechUsed,
        MessageSize,
        (PUCHAR *) &Signature,
        (Encrypt ? KG_TOK_WRAP_MSG : KG_TOK_MIC_MSG)
        );


    //
    // Fill in the header information according to RFC1964
    //



    Signature->SignatureAlgorithm[1] = KERB_GSS_SIG_SECOND;

    //
    // If the keytype is an MS keytype, we need to use an MS encryption
    // scheme.
    //

    if (!KERB_IS_DES_ENCRYPTION(Context->SessionKey.keytype))
    {

#ifndef DONT_SUPPORT_OLD_TYPES_USER
        if (Context->SessionKey.keytype == KERB_ETYPE_RC4_HMAC_OLD)
        {
            *ChecksumType = KERB_CHECKSUM_HMAC_MD5;
            *EncryptionType = KERB_ETYPE_RC4_PLAIN_OLD;
        Signature->SignatureAlgorithm[0] = KERB_GSS_SIG_HMAC;
            if (Encrypt)
            {
                Signature->SealAlgorithm[1] = KERB_GSS_SIG_SECOND;
                Signature->SealAlgorithm[0] = KERB_GSS_SEAL_RC4_OLD;

            }
        }
        else if (Context->SessionKey.keytype == KERB_ETYPE_RC4_HMAC_OLD_EXP)
        {
            *ChecksumType = KERB_CHECKSUM_HMAC_MD5;
            *EncryptionType = KERB_ETYPE_RC4_PLAIN_OLD_EXP;
        Signature->SignatureAlgorithm[0] = KERB_GSS_SIG_HMAC;
            if (Encrypt)
            {
                Signature->SealAlgorithm[1] = KERB_GSS_SIG_SECOND;
        Signature->SealAlgorithm[0] = KERB_GSS_SEAL_RC4_OLD;

            }
        }
        else
#endif
        if (Context->SessionKey.keytype == KERB_ETYPE_RC4_HMAC_NT)
        {
            *ChecksumType = KERB_CHECKSUM_HMAC_MD5;
            *EncryptionType = KERB_ETYPE_RC4_PLAIN;
            Signature->SignatureAlgorithm[0] = KERB_GSS_SIG_HMAC;
            if (Encrypt)
            {
                Signature->SealAlgorithm[1] = KERB_GSS_SIG_SECOND;
                Signature->SealAlgorithm[0] = KERB_GSS_SEAL_RC4;

            }
        }
        else
        {
            ASSERT (Context->SessionKey.keytype == KERB_ETYPE_RC4_HMAC_NT_EXP);
            *ChecksumType = KERB_CHECKSUM_HMAC_MD5;
            *EncryptionType = KERB_ETYPE_RC4_PLAIN_EXP;
            Signature->SignatureAlgorithm[0] = KERB_GSS_SIG_HMAC;
            if (Encrypt)
            {
                Signature->SealAlgorithm[1] = KERB_GSS_SIG_SECOND;
                Signature->SealAlgorithm[0] = KERB_GSS_SEAL_RC4;

            }
        }
    }
    else
    {
        if (Encrypt)
        {
            Signature->SealAlgorithm[1] = KERB_GSS_SIG_SECOND;
            Signature->SealAlgorithm[0] = KERB_GSS_SEAL_DES_CBC;

        }

        //
        // Use the exportable version if necessasry
        //

        *EncryptionType = KERB_ETYPE_DES_PLAIN;


        switch(QualityOfProtection)
        {
        case GSS_KRB5_INTEG_C_QOP_MD5:
            Signature->SignatureAlgorithm[0] = KERB_GSS_SIG_MD25;
            *ChecksumType = KERB_CHECKSUM_MD25;
            break;
        case GSS_KRB5_INTEG_C_QOP_DEFAULT:
        case GSS_KRB5_INTEG_C_QOP_DES_MD5:
            Signature->SignatureAlgorithm[0] = KERB_GSS_SIG_DES_MAC_MD5;
            *ChecksumType = KERB_CHECKSUM_DES_MAC_MD5;
            break;
        case GSS_KRB5_INTEG_C_QOP_DES_MAC:
            Signature->SignatureAlgorithm[0] = KERB_GSS_SIG_DES_MAC;
            *ChecksumType = KERB_CHECKSUM_DES_MAC;
            break;
        default:
            DebugLog((DEB_ERROR,"Invalid quality of protection sent to MakeSignature: %d.\n",
                QualityOfProtection ));
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

    }

    //
    // Put in the filler - it is different for signing & sealing
    //

    if (Encrypt)
    {
        memset(Signature->SealFiller,0xff,2);
    }
    else
    {
        memset(Signature->SignFiller,0xff,4);
    }

    //
    // Inbound contexts get a high dword of 0xffffffff, outbound gets
    // 0x00000000.
    //

    if (Context->ContextAttributes & KERB_CONTEXT_INBOUND)
    {
        *(PULONG)(&Signature->SequenceNumber[4]) = 0xffffffff;

        Nonce = &Context->ReceiveNonce;

    }
    else
    {
        ASSERT((Context->ContextAttributes & KERB_CONTEXT_OUTBOUND) != 0);
        *(PULONG)(&Signature->SequenceNumber[4]) = 0x00000000;
        Nonce = &Context->Nonce;
    }

    //
    // If this is datagram, or integrity without replay & sequence detection,
    // use the nonce from the caller
    //

    if (((Context->ContextFlags & ISC_RET_DATAGRAM) != 0) ||
        ((Context->ContextFlags & (ISC_RET_INTEGRITY | ISC_RET_SEQUENCE_DETECT | ISC_RET_REPLAY_DETECT)) == ISC_RET_INTEGRITY))

    {
        Nonce = &SuppliedNonce;
    }

    Signature->SequenceNumber[0] = (UCHAR) ((*Nonce & 0xff000000) >> 24);
    Signature->SequenceNumber[1] = (UCHAR) ((*Nonce & 0x00ff0000) >> 16);
    Signature->SequenceNumber[2] = (UCHAR) ((*Nonce & 0x0000ff00) >> 8);
    Signature->SequenceNumber[3] = (UCHAR)  (*Nonce & 0x000000ff);

    (*Nonce)++;


    *SequenceNumber = *(PULONG)Signature->SequenceNumber;

    //
    // If we are encrypting, add the confounder to the end of the signature
    //

    if (Encrypt)
    {
        SealSignature = (PKERB_GSS_SEAL_SIGNATURE) Signature;
        if (!KerbRandomFill(SealSignature->Confounder,KERB_GSS_SIG_CONFOUNDER_SIZE))
        {
            Status = STATUS_INTERNAL_ERROR;
            goto Cleanup;
        }
    }
    //
    // Set the size of the signature
    //

    SignatureBuffer->cbBuffer = SignatureSize;
    *OutputSignature = Signature;

Cleanup:
    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbVerifySignatureToken
//
//  Synopsis:   Verifies the header on a signed or sealed message
//
//  Effects:
//
//  Arguments:  Context - context to use for verification
//              SignatureBuffer - Buffer containing signature
//              TotalBufferSize - Size of all buffers signed/encrypted
//              Decrypt - TRUE if we are unsealing
//              SuppliedNonce - Nonce supplied by caller, used for datagram
//              QualityOfProtection - returns GSS quality of protection flags
//              ChecksumType - Type of checksum used in this signature
//              EncryptionType - Type of encryption used in this signature
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbVerifySignatureToken(
    IN PKERB_KERNEL_CONTEXT Context,
    IN PSecBuffer SignatureBuffer,
    IN ULONG TotalBufferSize,
    IN BOOLEAN Decrypt,
    IN ULONG SuppliedNonce,
    OUT PKERB_GSS_SIGNATURE * OutputSignature,
    OUT PULONG QualityOfProtection,
    OUT PLONG ChecksumType,
    OUT PCRYPTO_SYSTEM * CryptSystem,
    OUT PULONG SequenceNumber
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG SignatureSize = 0;
    UCHAR Nonce[8];
    PCRYPT_STATE_BUFFER CryptBuffer = NULL;
    ULONG OutputSize;
    LONG EncryptionType;
    PCRYPTO_SYSTEM LocalCryptSystem = NULL ;
    PKERB_GSS_SIGNATURE Signature;
    PULONG ContextNonce;
    gss_OID MechUsed;

    //
    // Make sure that cryptdll stuff is initialized.
    //

    MAYBE_PAGED_CODE();

    if (!KerbCryptInitialized)
    {
        KerbWriteLockGlobals();

        if ( !KerbCryptInitialized )
        {
            if (LibAttach(NULL, NULL))
            {
                KerbCryptInitialized = TRUE;
            }
        }
        KerbUnlockGlobals();
    }

    //
    // Since RPC doesn't carry around the size of the size of the
    // signature bufer, we use it in the header. This break rfc1964 compat.
    //

    if (!Decrypt ||
       ((Context->ContextFlags & ISC_RET_USED_DCE_STYLE) != 0) ||
       ((Context->ContextFlags & ISC_RET_DATAGRAM) != 0))
    {
        TotalBufferSize = 0;
    }


    //
    // Verify the signature header
    //

    if ((Context->ContextAttributes & KERB_CONTEXT_USER_TO_USER) != 0)
    {
        MechUsed = gss_mech_krb5_u2u;
    }
    else
    {
        MechUsed = gss_mech_krb5_new;
    }

    Signature = (PKERB_GSS_SIGNATURE) SignatureBuffer->pvBuffer;
    if (!g_verify_token_header(
            MechUsed,
            (int *) &SignatureSize,
            (PUCHAR *) &Signature,
            (Decrypt ? KG_TOK_WRAP_MSG : KG_TOK_MIC_MSG),
            SignatureBuffer->cbBuffer + TotalBufferSize))
    {
        Status = SEC_E_MESSAGE_ALTERED;
    }

    //
    // If that didn't work, try with the old mech. Need this is for DCE clients
    // for whom we can't tell what mech they use.
    //

    if (!NT_SUCCESS(Status) && ((Context->ContextFlags & ISC_RET_USED_DCE_STYLE) != 0))
    {
        Signature = (PKERB_GSS_SIGNATURE) SignatureBuffer->pvBuffer;
        if (!g_verify_token_header(
                gss_mech_krb5,
                (int *) &SignatureSize,
                (PUCHAR *) &Signature,
                (Decrypt ? KG_TOK_WRAP_MSG : KG_TOK_MIC_MSG),
                SignatureBuffer->cbBuffer + TotalBufferSize))
        {
            Status = SEC_E_MESSAGE_ALTERED;
        }
        else
        {
            Status = STATUS_SUCCESS;
        }
    }

    //
    // MS RPC clients don't send the size properly, so set the total size
    // to zero and try again.
    //

    if (Decrypt && !NT_SUCCESS(Status))
    {
        TotalBufferSize = 0;
        Signature = (PKERB_GSS_SIGNATURE) SignatureBuffer->pvBuffer;
        if (!g_verify_token_header(
                MechUsed,
                (int *) &SignatureSize,
                (PUCHAR *) &Signature,
                (Decrypt ? KG_TOK_WRAP_MSG : KG_TOK_MIC_MSG),
                SignatureBuffer->cbBuffer + TotalBufferSize))
        {
            Status = SEC_E_MESSAGE_ALTERED;
        }
        else
        {
            Status = STATUS_SUCCESS;
        }

        //
        // If that didn't work, try with the old mech. Need this is for DCE clients
        // for whom we can't tell what mech they use.
        //

        if (!NT_SUCCESS(Status) && ((Context->ContextFlags & ISC_RET_USED_DCE_STYLE) != 0))
        {
            Signature = (PKERB_GSS_SIGNATURE) SignatureBuffer->pvBuffer;
            if (!g_verify_token_header(
                    gss_mech_krb5,
                    (int *) &SignatureSize,
                    (PUCHAR *) &Signature,
                    (Decrypt ? KG_TOK_WRAP_MSG : KG_TOK_MIC_MSG),
                    SignatureBuffer->cbBuffer + TotalBufferSize))
            {
                Status = SEC_E_MESSAGE_ALTERED;
            }
            else
            {
                Status = STATUS_SUCCESS;
            }
        }
    }

    //
    // Protection from bad Signature Size
    //

    if (SignatureSize == 0)
    {
        Status = SEC_E_MESSAGE_ALTERED;
        goto Cleanup;
    }

    //
    // Subtract the total buffer size from Signature size to get the real
    // size of the signature.
    //

    SignatureSize -= TotalBufferSize;

    //
    // Make sure the signature is big enough. We can't enforce a strict
    // size because RPC will transmit the maximum number of bytes instead
    // of the actual number.
    //

    if ((Decrypt && (SignatureSize < sizeof(KERB_GSS_SEAL_SIGNATURE))) ||
        (!Decrypt && (SignatureSize < sizeof(KERB_GSS_SIGNATURE))))
    {
        Status = SEC_E_MESSAGE_ALTERED;
        goto Cleanup;
    }

    //
    // Verify the sequence number
    //

    if (Signature->SignatureAlgorithm[1] != KERB_GSS_SIG_SECOND)
    {
        Status = SEC_E_MESSAGE_ALTERED;
        goto Cleanup;
    }
    //
    // Figure out the algorithm
    //
    switch(Context->SessionKey.keytype) {
    case KERB_ETYPE_DES_CBC_MD5:
    case KERB_ETYPE_DES_CBC_CRC:
        EncryptionType = KERB_ETYPE_DES_PLAIN;
        break;
    case KERB_ETYPE_RC4_HMAC_OLD_EXP:
        EncryptionType = KERB_ETYPE_RC4_PLAIN_OLD_EXP;
        break;
    case KERB_ETYPE_RC4_HMAC_OLD:
        EncryptionType = KERB_ETYPE_RC4_PLAIN_OLD;
        break;
    case KERB_ETYPE_RC4_HMAC_NT_EXP:
        EncryptionType = KERB_ETYPE_RC4_PLAIN_EXP;
        break;
    case KERB_ETYPE_RC4_HMAC_NT:
        EncryptionType = KERB_ETYPE_RC4_PLAIN;
        break;
    default:
        DebugLog((DEB_ERROR,"Unknown key type: %d\n",
           Context->SessionKey.keytype ));
        Status = STATUS_INTERNAL_ERROR;
        goto Cleanup;
    }

    //
    // if the key is exportable, make sure to use the exportable plain
    // version.
    //


    switch(Signature->SignatureAlgorithm[0]) {
    case KERB_GSS_SIG_MD25:
        *QualityOfProtection = GSS_KRB5_INTEG_C_QOP_MD5;
        *ChecksumType = KERB_CHECKSUM_MD25;
        break;
    case KERB_GSS_SIG_DES_MAC_MD5:
        *QualityOfProtection = GSS_KRB5_INTEG_C_QOP_DES_MD5;
        *ChecksumType = KERB_CHECKSUM_DES_MAC_MD5;
        break;
    case KERB_GSS_SIG_DES_MAC:
        *QualityOfProtection = GSS_KRB5_INTEG_C_QOP_DES_MAC;
        *ChecksumType = KERB_CHECKSUM_DES_MAC;
        break;
    case KERB_GSS_SIG_HMAC:
        *QualityOfProtection = GSS_KRB5_INTEG_C_QOP_DEFAULT;
        *ChecksumType = KERB_CHECKSUM_HMAC_MD5;
        break;
    default:
        DebugLog((DEB_ERROR,"Invalid signature type to VerifySignature: %d\n",
                Signature->SignatureAlgorithm[0]));
        Status = SEC_E_MESSAGE_ALTERED;
        goto Cleanup;

    }

    if (Decrypt)
    {
        if (Signature->SealAlgorithm[1] != KERB_GSS_SIG_SECOND)
        {
            Status = SEC_E_MESSAGE_ALTERED;
            goto Cleanup;
        }

        //
        // Verify the seal algorithm
        //

        switch(EncryptionType) {
        case KERB_ETYPE_DES_PLAIN:
            if (Signature->SealAlgorithm[0] != KERB_GSS_SEAL_DES_CBC)
            {
                DebugLog((DEB_ERROR,"Trying to mix encryption types\n" ));
                Status = SEC_E_MESSAGE_ALTERED;
                goto Cleanup;
            }
            break;
        case KERB_ETYPE_RC4_PLAIN_OLD_EXP:
        case KERB_ETYPE_RC4_PLAIN_OLD:
            if (Signature->SealAlgorithm[0] != KERB_GSS_SEAL_RC4_OLD)
            {
                DebugLog((DEB_ERROR,"Trying to mix encryption types\n"));
                Status = SEC_E_MESSAGE_ALTERED;
                goto Cleanup;
            }
            break;
        case KERB_ETYPE_RC4_PLAIN_EXP:
        case KERB_ETYPE_RC4_PLAIN:
            if (Signature->SealAlgorithm[0] != KERB_GSS_SEAL_RC4)
            {
                DebugLog((DEB_ERROR,"Trying to mix encryption types\n"));
                Status = SEC_E_MESSAGE_ALTERED;
                goto Cleanup;
            }
            break;
        default:
            DebugLog((DEB_ERROR,"Invalid seal type to VerifySignature: %d, %d\n", Signature->SealAlgorithm[0], EncryptionType));
            Status = SEC_E_MESSAGE_ALTERED;
            goto Cleanup;
        }
    }

    //
    // Check the filler
    //

    if ((Decrypt && (*(PUSHORT) Signature->SealFiller != 0xffff)) ||
        (!Decrypt && (*(PULONG) Signature->SignFiller != 0xffffffff)))
    {
        Status = SEC_E_MESSAGE_ALTERED;
        goto Cleanup;
    }

    //
    // Verify the sequence number. To do this we need to decrypt it with
    // the session key with the checksum as the IV.
    //


    Status = CDLocateCSystem(EncryptionType, &LocalCryptSystem);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to load %d crypt system: 0x%x\n", EncryptionType,Status));
        goto Cleanup;
    }

    //
    // Now we need to Decrypt the sequence number, using the checksum as the
    // IV
    //

    Status = LocalCryptSystem->Initialize(
                Context->SessionKey.keyvalue.value,
                Context->SessionKey.keyvalue.length,
                0,                      // no flags
                &CryptBuffer
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Set the initial vector
    //

    Status = LocalCryptSystem->Control(
                CRYPT_CONTROL_SET_INIT_VECT,
                CryptBuffer,
                Signature->Checksum,
                8
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Now encrypt the sequence number
    //

    OutputSize = 8;

    Status = LocalCryptSystem->Decrypt(
                CryptBuffer,
                Signature->SequenceNumber,
                8,
                Signature->SequenceNumber,
                &OutputSize
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // For datagram or integrity only, we use just the supplied nonce.
    //

    if (((Context->ContextFlags & ISC_RET_DATAGRAM) != 0) ||
        ((Context->ContextFlags & (ISC_RET_INTEGRITY | ISC_RET_SEQUENCE_DETECT | ISC_RET_REPLAY_DETECT)) == ISC_RET_INTEGRITY))
    {
        ContextNonce = &SuppliedNonce;
    }
    else
    {
        if ((Context->ContextAttributes & KERB_CONTEXT_OUTBOUND) != 0)
        {
            ContextNonce = &Context->ReceiveNonce;
        }
        else
        {
            ContextNonce = &Context->Nonce;
        }
    }

    Nonce[0] = (UCHAR) ((*ContextNonce & 0xff000000) >> 24);
    Nonce[1] = (UCHAR) ((*ContextNonce & 0x00ff0000) >> 16);
    Nonce[2] = (UCHAR) ((*ContextNonce & 0x0000ff00) >> 8);
    Nonce[3] = (UCHAR)  (*ContextNonce & 0x000000ff);

    *SequenceNumber = *(PULONG) Nonce;

    if (!RtlEqualMemory(
            Nonce,
            Signature->SequenceNumber,
            4))
    {
        Status = SEC_E_OUT_OF_SEQUENCE;
        goto Cleanup;
    }

    (*ContextNonce)++;

    //
    // Inbound contexts send a high dword of 0xffffffff, outbound gets
    // 0x00000000.
    //

    if (Context->ContextAttributes & KERB_CONTEXT_OUTBOUND)
    {
        if (*(PULONG)(&Signature->SequenceNumber[4]) != 0xffffffff)
        {
            Status = SEC_E_MESSAGE_ALTERED;
            goto Cleanup;
        }
    }
    else
    {
        ASSERT((Context->ContextAttributes & KERB_CONTEXT_INBOUND) != 0);
        if (*(PULONG)(&Signature->SequenceNumber[4]) != 0)
        {
            Status = SEC_E_MESSAGE_ALTERED;
            goto Cleanup;
        }
    }

    if (ARGUMENT_PRESENT(CryptSystem))
    {
        *CryptSystem = LocalCryptSystem;
    }

    *OutputSignature = Signature;

Cleanup:
    if ( ( CryptBuffer != NULL) &&
         ( LocalCryptSystem != NULL ) )
    {
        LocalCryptSystem->Discard(&CryptBuffer);
    }
    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbMakeSignature
//
//  Synopsis:   Signs a message buffer by calculatinga checksum over all
//              the non-read only data buffers and encrypting the checksum
//              along with a nonce.
//
//  Effects:
//
//  Arguments:  ContextHandle - Handle of the context to use to sign the
//                      message.
//              QualityOfProtection - Unused flags.
//              MessageBuffers - Contains an array of buffers to sign and
//                      to store the signature.
//              MessageSequenceNumber - Sequence number for this message,
//                      only used in datagram cases.
//
//  Requires:   STATUS_INVALID_HANDLE - the context could not be found or
//                      was not configured for message integrity.
//              STATUS_INVALID_PARAMETER - the signature buffer could not
//                      be found.
//              STATUS_BUFFER_TOO_SMALL - the signature buffer is too small
//                      to hold the signature
//
//  Returns:
//
//  Notes: Cluster folks need to run this at dpc level (non paged)
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
KerbMakeSignature(
    IN LSA_SEC_HANDLE ContextHandle,
    IN ULONG QualityOfProtection,
    IN PSecBufferDesc MessageBuffers,
    IN ULONG MessageSequenceNumber
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_KERNEL_CONTEXT Context = NULL;
    PCHECKSUM_FUNCTION Check;
    PCRYPTO_SYSTEM CryptSystem = NULL ;
    PSecBuffer SignatureBuffer = NULL;
    ULONG Index;
    PCHECKSUM_BUFFER CheckBuffer = NULL;
    PCRYPT_STATE_BUFFER CryptBuffer = NULL;
    PKERB_GSS_SIGNATURE Signature;
    UCHAR LocalChecksum[KERB_MAX_CHECKSUM_LENGTH];
    BOOLEAN ContextsLocked = FALSE;
    LONG ChecksumType = 0;
    LONG EncryptType;
    ULONG TotalBufferSize = 0;
    ULONG OutputSize;
    ULONG SequenceNumber;


    MAYBE_PAGED_CODE();
    DebugLog((DEB_TRACE,"KerbMakeSignature Called\n"));

    Context = KerbReferenceContext(
                ContextHandle,
                FALSE           // don't unlink
                );

    if (Context == NULL)
    {
        DebugLog((DEB_ERROR, "Invalid handle supplied for MakeSignature(0x%x)\n",
            ContextHandle));
        Status = STATUS_INVALID_HANDLE;
        goto Cleanup;
    }


    //
    // Find the body and signature SecBuffers from pMessage
    //

    for (Index = 0; Index < MessageBuffers->cBuffers ; Index++ )
    {
        if (BUFFERTYPE(MessageBuffers->pBuffers[Index]) == SECBUFFER_TOKEN)
        {
            SignatureBuffer = &MessageBuffers->pBuffers[Index];
        }
        else if ((BUFFERTYPE(MessageBuffers->pBuffers[Index]) != SECBUFFER_TOKEN) &&
            (!(MessageBuffers->pBuffers[Index].BufferType & SECBUFFER_READONLY)))

        {
            TotalBufferSize += MessageBuffers->pBuffers[Index].cbBuffer;
        }
    }


    if (SignatureBuffer == NULL)
    {
        DebugLog((DEB_ERROR, "No signature buffer found\n"));
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    KerbWriteLockContexts();
    ContextsLocked = TRUE;

    //
    // Verify that the context was created with the integrity bit
    //

    if ((Context->ContextFlags & KERB_SIGN_FLAGS) == 0)
    {
        if (SignatureBuffer->cbBuffer < sizeof(KERB_NULL_SIGNATURE))
        {
            Status = SEC_E_BUFFER_TOO_SMALL;
            goto Cleanup;
        }
        SignatureBuffer->cbBuffer = sizeof(KERB_NULL_SIGNATURE);
        *(PKERB_NULL_SIGNATURE) SignatureBuffer->pvBuffer = 0;

        Status = STATUS_SUCCESS;
        goto Cleanup;

    }

    Status = KerbMakeSignatureToken(
                Context,
                QualityOfProtection,
                SignatureBuffer,
                TotalBufferSize,
                FALSE,                  // don't encrypt
                MessageSequenceNumber,
                &Signature,
                &ChecksumType,
                &EncryptType,
                &SequenceNumber
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Locate the checksum for the context, loading it if necessary from the
    // the crypto support DLL
    //

    Status = CDLocateCheckSum(ChecksumType, &Check);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to load %d checksum: 0x%x.\n ",ChecksumType,Status ));
        goto Cleanup;
    }

    ASSERT(Check->CheckSumSize <= sizeof(LocalChecksum));

    Status = CDLocateCSystem(EncryptType, &CryptSystem);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to load %d crypt system: 0x%x.\n",EncryptType,Status ));
        goto Cleanup;
    }

    //
    // Generate a check sum of the message, and store it into the signature
    // buffer.
    //

    if (NULL != Check->InitializeEx2)
    {
        Status = Check->InitializeEx2(
                    Context->SessionKey.keyvalue.value,
                    (ULONG) Context->SessionKey.keyvalue.length,
                    NULL,
                    KERB_SAFE_SALT,
                    &CheckBuffer
                    );
    }
    else
    {
        Status = Check->InitializeEx(
                    Context->SessionKey.keyvalue.value,
                    (ULONG) Context->SessionKey.keyvalue.length,
                    KERB_SAFE_SALT,
                    &CheckBuffer
                    );
    }

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    KerbUnlockContexts();
    ContextsLocked = FALSE;

    //
    // Sum in 8 bytes of the signature
    //

    Check->Sum(
        CheckBuffer,
        8,
        ((PUCHAR) Signature) -2
        );

    for (Index = 0; Index < MessageBuffers->cBuffers; Index++ )
    {
        if ((BUFFERTYPE(MessageBuffers->pBuffers[Index]) != SECBUFFER_TOKEN) &&
            (!(MessageBuffers->pBuffers[Index].BufferType & SECBUFFER_READONLY)) &&
            (MessageBuffers->pBuffers[Index].cbBuffer != 0))
        {

            Check->Sum(
                CheckBuffer,
                MessageBuffers->pBuffers[Index].cbBuffer,
                (PBYTE) MessageBuffers->pBuffers[Index].pvBuffer
                );
        }
    }

    (void) Check->Finalize(CheckBuffer, LocalChecksum);


    Status = Check->Finish(&CheckBuffer);

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    //
    // Copy in the first 8 bytes of the checksum
    //

    RtlCopyMemory(
        Signature->Checksum,
        LocalChecksum,
        8
        );


    //
    // Now we need to encrypt the sequence number, using the checksum as the
    // IV
    //

    Status = CryptSystem->Initialize(
                Context->SessionKey.keyvalue.value,
                Context->SessionKey.keyvalue.length,
                0,                                      // no options
                &CryptBuffer
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Set the initial vector
    //

    Status = CryptSystem->Control(
                CRYPT_CONTROL_SET_INIT_VECT,
                CryptBuffer,
                LocalChecksum,
                8
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Now encrypt the sequence number
    //

    Status = CryptSystem->Encrypt(
                CryptBuffer,
                Signature->SequenceNumber,
                8,
                Signature->SequenceNumber,
                &OutputSize
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


Cleanup:
    if ( ( CryptBuffer != NULL ) &&
         ( CryptSystem != NULL ) )
    {
        CryptSystem->Discard(&CryptBuffer);
    }

    if (ContextsLocked)
    {
        KerbUnlockContexts();
    }

    if (Context != NULL)
    {
        KerbDereferenceContext(Context);
    }

    return(Status);
}
//+-------------------------------------------------------------------------
//
//  Function:   KerbVerifySignature
//
//  Synopsis:   Verifies a signed message buffer by calculating a checksum over all
//              the non-read only data buffers and encrypting the checksum
//              along with a nonce.
//
//  Effects:
//
//  Arguments:  ContextHandle - Handle of the context to use to sign the
//                      message.
//              MessageBuffers - Contains an array of signed buffers  and
//                      a signature buffer.
//              MessageSequenceNumber - Sequence number for this message,
//                      only used in datagram cases.
//              QualityOfProtection - Unused flags.
//
//  Requires:   STATUS_INVALID_HANDLE - the context could not be found or
//                      was not configured for message integrity.
//              STATUS_INVALID_PARAMETER - the signature buffer could not
//                      be found or was too small.
//
//  Returns:
//
//  Notes: Cluster folks need to run this at dpc level (non paged)
//
//
//--------------------------------------------------------------------------



NTSTATUS NTAPI
KerbVerifySignature(
    IN LSA_SEC_HANDLE ContextHandle,
    IN PSecBufferDesc MessageBuffers,
    IN ULONG MessageSequenceNumber,
    OUT PULONG QualityOfProtection
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_KERNEL_CONTEXT Context = NULL;
    PCHECKSUM_FUNCTION Check;
    PSecBuffer SignatureBuffer = NULL;
    ULONG Index;
    PCHECKSUM_BUFFER CheckBuffer = NULL;
    PKERB_GSS_SIGNATURE Signature;
    LONG ChecksumType;
    BOOLEAN ContextsLocked = FALSE;
    UCHAR LocalChecksum[KERB_MAX_CHECKSUM_LENGTH];
    ULONG Protection;
    ULONG TotalBufferSize = 0;
    ULONG SequenceNumber;


    MAYBE_PAGED_CODE();
    DebugLog((DEB_TRACE,"KerbVerifySignature Called\n"));

    Context = KerbReferenceContext(
                ContextHandle,
                FALSE           // don't unlink
                );

    if (Context == NULL)
    {
        DebugLog((DEB_ERROR, "Invalid handle supplied for VerifySignature(0x%x)\n",
            ContextHandle));
        Status = STATUS_INVALID_HANDLE;
        goto Cleanup;
    }


    //
    // Find the body and signature SecBuffers from pMessage
    //

    for (Index = 0; Index < MessageBuffers->cBuffers ; Index++ )
    {
        if (BUFFERTYPE(MessageBuffers->pBuffers[Index]) == SECBUFFER_TOKEN)
        {
            SignatureBuffer = &MessageBuffers->pBuffers[Index];
        }
        else if ((BUFFERTYPE(MessageBuffers->pBuffers[Index]) != SECBUFFER_TOKEN) &&
            (!(MessageBuffers->pBuffers[Index].BufferType & SECBUFFER_READONLY)))

        {
            TotalBufferSize += MessageBuffers->pBuffers[Index].cbBuffer;
        }
    }


    if (SignatureBuffer == NULL)
    {
        DebugLog((DEB_ERROR, "No signature buffer found\n"));
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    KerbWriteLockContexts();
    ContextsLocked = TRUE;

    //
    // Also, verify that the context was created with the integrity bit
    //

    if ((Context->ContextFlags & KERB_SIGN_FLAGS) == 0)
    {
        PKERB_NULL_SIGNATURE NullSignature = (PKERB_NULL_SIGNATURE) SignatureBuffer->pvBuffer;

        if (SignatureBuffer->cbBuffer >= sizeof(KERB_NULL_SIGNATURE) &&
            (*NullSignature == 0))
        {
            Status = STATUS_SUCCESS;
        }
        else
        {
            Status = SEC_E_MESSAGE_ALTERED;
        }
        goto Cleanup;

    }

    //
    // Verify the signature header
    //

    Status = KerbVerifySignatureToken(
                 Context,
                 SignatureBuffer,
                 TotalBufferSize,
                 FALSE,                 // don't decrypt
                 MessageSequenceNumber,
                 &Signature,
                 &Protection,
                 &ChecksumType,
                 NULL,                   // don't need crypt system
                 &SequenceNumber
                 );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "Failed to verify signature token: 0x%x\n", Status));
        goto Cleanup;
    }

    //
    // Now compute the checksum and verify it
    //

    Status = CDLocateCheckSum(ChecksumType, &Check);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to load MD5 checksum: 0x%x\n", Status));
        goto Cleanup;
    }

    ASSERT(Check->CheckSumSize  <= sizeof(LocalChecksum));

    //
    // Generate a check sum of the message, and store it into the signature
    // buffer.
    //

    //
    // if available use the Ex2 version for keyed checksums where checksum
    // must be passed in on verification
    //
    if (NULL != Check->InitializeEx2)
    {
            Status = Check->InitializeEx2(
                Context->SessionKey.keyvalue.value,
                (ULONG) Context->SessionKey.keyvalue.length,
                Signature->Checksum,
                KERB_SAFE_SALT,
                &CheckBuffer
                );
    }
    else
    {
        Status = Check->InitializeEx(
                    Context->SessionKey.keyvalue.value,
                    (ULONG) Context->SessionKey.keyvalue.length,
                    KERB_SAFE_SALT,
                    &CheckBuffer
                    );
    }

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    KerbUnlockContexts();
    ContextsLocked = FALSE;

    //
    // Sum in 8 bytes of the signature
    //

    Check->Sum(
        CheckBuffer,
        8,
        ((PUCHAR) Signature) -2
        );

    for (Index = 0; Index < MessageBuffers->cBuffers; Index++ )
    {
        if ((BUFFERTYPE(MessageBuffers->pBuffers[Index]) != SECBUFFER_TOKEN) &&
            (!(MessageBuffers->pBuffers[Index].BufferType & SECBUFFER_READONLY)) &&
            (MessageBuffers->pBuffers[Index].cbBuffer != 0))
        {

            Check->Sum(
                CheckBuffer,
                MessageBuffers->pBuffers[Index].cbBuffer,
                (PBYTE) MessageBuffers->pBuffers[Index].pvBuffer
                );
        }
    }

    (void) Check->Finalize(CheckBuffer, LocalChecksum);


    Status = Check->Finish(&CheckBuffer);

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    if (!RtlEqualMemory(
            LocalChecksum,
            Signature->Checksum,
            8))
    {
        Status = SEC_E_MESSAGE_ALTERED;
        goto Cleanup;
    }
    if (ARGUMENT_PRESENT(QualityOfProtection))
    {
        *QualityOfProtection = Protection;
    }
Cleanup:
    if (ContextsLocked)
    {
        KerbUnlockContexts();
    }
    if (Context != NULL)
    {
        KerbDereferenceContext(Context);
    }

    DebugLog((DEB_TRACE, "SpVerifySignature returned 0x%x\n", Status));

    return(Status);
}

NTSTATUS NTAPI
KerbSealMessage(
    IN LSA_SEC_HANDLE ContextHandle,
    IN ULONG QualityOfProtection,
    IN PSecBufferDesc MessageBuffers,
    IN ULONG MessageSequenceNumber
    )
{
    MAYBE_PAGED_CODE();
    return(STATUS_NOT_SUPPORTED);
}

NTSTATUS NTAPI
KerbUnsealMessage(
    IN LSA_SEC_HANDLE ContextHandle,
    IN PSecBufferDesc MessageBuffers,
    IN ULONG MessageSequenceNumber,
    OUT PULONG QualityOfProtection
    )
{
    MAYBE_PAGED_CODE();
    return(STATUS_NOT_SUPPORTED);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbGetContextToken
//
//  Synopsis:   returns a pointer to the token for a server-side context
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
KerbGetContextToken(
    IN LSA_SEC_HANDLE ContextHandle,
    OUT OPTIONAL PHANDLE ImpersonationToken,
    OUT OPTIONAL PACCESS_TOKEN * RawToken
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_KERNEL_CONTEXT Context = NULL;

    PAGED_CODE();


    DebugLog((DEB_TRACE,"KerbGetContextToken Called\n"));


    Context = KerbReferenceContext(
                ContextHandle,
                FALSE           // don't unlink
                );

    if (Context == NULL)
    {
        DebugLog((DEB_ERROR, "Invalid handle supplied for GetContextToken(0x%x)\n",
            ContextHandle));
        return(STATUS_INVALID_HANDLE);
    }

    KerbReadLockContexts();

    if (Context->TokenHandle == NULL)
    {
        Status = SEC_E_NO_IMPERSONATION;
        KerbUnlockContexts();
        goto Cleanup;
    }
    if (ARGUMENT_PRESENT(ImpersonationToken))
    {
        *ImpersonationToken = Context->TokenHandle;
    }

    if (ARGUMENT_PRESENT(RawToken))
    {
        if (Context->TokenHandle != NULL)
        {
            if (Context->AccessToken == NULL)
            {
                Status = ObReferenceObjectByHandle(
                            Context->TokenHandle,
                            TOKEN_IMPERSONATE,
                            NULL,
                            ExGetPreviousMode(),
                            (PVOID *) &Context->AccessToken,
                            NULL                // no handle information
                            );

            }
        }

        if (NT_SUCCESS(Status))
        {
            *RawToken = Context->AccessToken;
        }
    }

    KerbUnlockContexts();

Cleanup:

    if (Context != NULL)
    {
        //
        // Note: once we dereference the context the handle we return
        // may go away or be re-used. That is the price we have to pay
        // to avoid duplicating it.
        //

        KerbDereferenceContext(Context);
    }
    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbQueryContextAttributes
//
//  Synopsis:   Querys attributes of the specified context
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
KerbQueryContextAttributes(
    IN LSA_SEC_HANDLE ContextHandle,
    IN ULONG ContextAttribute,
    IN OUT PVOID Buffer
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_KERNEL_CONTEXT Context = NULL;
    PSecPkgContext_Sizes SizeInfo;
    PSecPkgContext_Names NameInfo;
    PSecPkgContext_Lifespan LifespanInfo;
    PSecPkgContext_Flags FlagsInfo;
    PSecPkgContext_SessionKey SessionKeyInfo;
    PSecPkgContext_UserFlags UserFlagsInfo ;
    PSecPkgContext_PackageInfo PackageInfo = NULL;
    PSecPkgContext_TargetInformation TargetInformation = NULL;

    PAGED_CODE();

    DebugLog((DEB_TRACE,"SpQueryContextAttributes Called\n"));



    Context = KerbReferenceContext(
                ContextHandle,
                FALSE           // don't unlink
                );


    //
    // allow PACKAGE_INFO or NEGOTIATION_INFO to be queried against
    // incomplete contexts.
    //

    if( (Context == NULL) &&
        (ContextAttribute != SECPKG_ATTR_PACKAGE_INFO) &&
        (ContextAttribute != SECPKG_ATTR_NEGOTIATION_INFO)
        ) {

        DebugLog((DEB_ERROR, "Invalid handle supplied for QueryContextAttributes(0x%x)\n",
            ContextHandle));
        return(STATUS_INVALID_HANDLE);
    }


    //
    // Return the appropriate information
    //

    switch(ContextAttribute)
    {
    case SECPKG_ATTR_SIZES:
        //
        // The sizes returned are used by RPC to determine whether to call
        // MakeSignature or SealMessage. The signature size should be zero
        // if neither is to be called, and the block size and trailer size
        // should be zero if SignMessage is not to be called.
        //

        SizeInfo = (PSecPkgContext_Sizes) Buffer;
        SizeInfo->cbMaxToken = KerbMaxTokenSize;
//        if ((Context->ContextFlags & (ISC_RET_CONFIDENTIALITY | ISC_RET_SEQUENCE_DETECT)) != 0)
//        {
              SizeInfo->cbMaxSignature = KERB_SIGNATURE_SIZE;
//        }
//        else
//        {
//            SizeInfo->cbMaxSignature = 0;
//        }
        if ((Context->ContextFlags & ISC_RET_CONFIDENTIALITY) != 0)
        {
            SizeInfo->cbBlockSize = 1;
            SizeInfo->cbSecurityTrailer = KERB_SIGNATURE_SIZE;
        }
        else
        {
            SizeInfo->cbBlockSize = 0;
            SizeInfo->cbSecurityTrailer = 0;
        }
        break;
    case SECPKG_ATTR_NAMES:
        NameInfo = (PSecPkgContext_Names) Buffer;

        NameInfo->sUserName = (LPWSTR) KspKernelFunctions.AllocateHeap(Context->FullName.Length + sizeof(WCHAR));
        if (NameInfo->sUserName != NULL)
        {
            RtlCopyMemory(
                NameInfo->sUserName,
                Context->FullName.Buffer,
                Context->FullName.Length
                );
            NameInfo->sUserName[Context->FullName.Length/sizeof(WCHAR)] = L'\0';
        }
        else
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
        break;
    case SECPKG_ATTR_TARGET_INFORMATION:

        TargetInformation = (PSecPkgContext_TargetInformation) Buffer;

        if (TargetInformation == NULL)
        {
            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        TargetInformation->MarshalledTargetInfo = NULL;

        if (Context->pbMarshalledTargetInfo == NULL)
        {
            Status = STATUS_NOT_FOUND;
            break;
        }

        TargetInformation->MarshalledTargetInfo = (PUCHAR) KspKernelFunctions.AllocateHeap(
                                                                    Context->cbMarshalledTargetInfo
                                                                    );

        if (TargetInformation->MarshalledTargetInfo != NULL)
        {
            RtlCopyMemory(
                TargetInformation->MarshalledTargetInfo,
                Context->pbMarshalledTargetInfo,
                Context->cbMarshalledTargetInfo
                );

            TargetInformation->MarshalledTargetInfoLength = Context->cbMarshalledTargetInfo;
        }
        else
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }

        break;

    case SECPKG_ATTR_LIFESPAN:
        LifespanInfo = (PSecPkgContext_Lifespan) Buffer;
        //
        // BUG 454552: set start time properly.
        //
        LifespanInfo->tsStart.QuadPart = 0;
        LifespanInfo->tsExpiry = Context->Lifetime;
        break;
    case SECPKG_ATTR_FLAGS:
        FlagsInfo = (PSecPkgContext_Flags) Buffer;

        FlagsInfo->Flags = Context->ContextFlags;
        break;
    case SECPKG_ATTR_SESSION_KEY:
        SessionKeyInfo = (PSecPkgContext_SessionKey) Buffer;
        SessionKeyInfo->SessionKeyLength = Context->SessionKey.keyvalue.length;
        if (SessionKeyInfo->SessionKeyLength != 0)
        {
            SessionKeyInfo->SessionKey = (PUCHAR) KspKernelFunctions.AllocateHeap(SessionKeyInfo->SessionKeyLength);
            if (SessionKeyInfo->SessionKey != NULL)
            {
                RtlCopyMemory(
                    SessionKeyInfo->SessionKey,
                    Context->SessionKey.keyvalue.value,
                    Context->SessionKey.keyvalue.length
                    );
            }
            else
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }

        }
        else
        {
            SessionKeyInfo->SessionKey = (PUCHAR) KspKernelFunctions.AllocateHeap(1);
            if (SessionKeyInfo->SessionKey != NULL)
            {
                *(PUCHAR) SessionKeyInfo->SessionKey = 0;
            }
            else
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
        break;

    case SECPKG_ATTR_USER_FLAGS:
        UserFlagsInfo = (PSecPkgContext_UserFlags) Buffer ;
        UserFlagsInfo->UserFlags = 0 ;
        Status = STATUS_SUCCESS ;
        break;

    case SECPKG_ATTR_PACKAGE_INFO:
    case SECPKG_ATTR_NEGOTIATION_INFO:
        //
        // Return the information about this package. This is useful for
        // callers who used SPNEGO and don't know what package they got.
        //

        PackageInfo = (PSecPkgContext_PackageInfo) Buffer;
        PackageInfo->PackageInfo = (PSecPkgInfo) KspKernelFunctions.AllocateHeap(
                                                        sizeof(SecPkgInfo) +
                                                        sizeof(KERBEROS_PACKAGE_NAME) +
                                                        sizeof(KERBEROS_PACKAGE_COMMENT)
                                                        );
        if (PackageInfo->PackageInfo == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }
        PackageInfo->PackageInfo->Name = (LPTSTR) (PackageInfo->PackageInfo + 1);
        PackageInfo->PackageInfo->Comment = (LPTSTR) (((PBYTE) PackageInfo->PackageInfo->Name) + sizeof(KERBEROS_PACKAGE_NAME));
        wcscpy(
            PackageInfo->PackageInfo->Name,
            KERBEROS_PACKAGE_NAME
            );

        wcscpy(
            PackageInfo->PackageInfo->Comment,
            KERBEROS_PACKAGE_COMMENT
            );
        PackageInfo->PackageInfo->wVersion      = SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION;
        PackageInfo->PackageInfo->wRPCID        = KERBEROS_RPCID;
        PackageInfo->PackageInfo->fCapabilities = KERBEROS_CAPABILITIES;
        PackageInfo->PackageInfo->cbMaxToken    = KerbMaxTokenSize;
        if ( ContextAttribute == SECPKG_ATTR_NEGOTIATION_INFO )
        {
            PSecPkgContext_NegotiationInfo NegInfo ;

            NegInfo = (PSecPkgContext_NegotiationInfo) PackageInfo ;
            if( Context != NULL ) {
                NegInfo->NegotiationState = SECPKG_NEGOTIATION_COMPLETE ;
            } else {
                NegInfo->NegotiationState = 0;
            }
        }
        break;

    default:
        Status = STATUS_NOT_SUPPORTED;
        break;
    }

    if (Context != NULL)
    {
        KerbDereferenceContext(Context);
    }
    return(Status);
}



//+-------------------------------------------------------------------------
//
//  Function:   KerbCompleteToken
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS NTAPI
KerbCompleteToken(
    IN LSA_SEC_HANDLE ContextId,
    IN PSecBufferDesc Token
    )
{
    PAGED_CODE();
    return(SEC_E_UNSUPPORTED_FUNCTION);
}


//+-------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbExportContext(
    IN LSA_SEC_HANDLE Context,
    IN ULONG Flags,
    OUT PSecBuffer PackedContext,
    IN OUT PHANDLE TokenHandle
    )
{
    return(SEC_E_UNSUPPORTED_FUNCTION);
}


//+-------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbImportContext(
    IN PSecBuffer PackedContext,
    IN OPTIONAL HANDLE TokenHandle,
    OUT PLSA_SEC_HANDLE ContextHandle
    )
{
    NTSTATUS Status;
    PKERB_KERNEL_CONTEXT Context = NULL;

    PAGED_CODE();
    DebugLog((DEB_TRACE,"KerbInitUserModeContext called\n"));

    Status = KerbCreateKernelModeContext(
                0,              // LsaContextHandle not present
                PackedContext,
                &Context
                );
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to create kernel mode context: 0x%x\n",
            Status));
        goto Cleanup;
    }

    if (!KerbCryptInitialized)
    {
        KerbWriteLockGlobals();
        if ( !KerbCryptInitialized )
        {
            if (LibAttach(NULL, NULL))
            {
                KerbCryptInitialized = TRUE;
            }
        }
        KerbUnlockGlobals();
    }

    KerbWriteLockContexts();

    Context->TokenHandle = TokenHandle;
    *ContextHandle = KerbGetContextHandle(Context);
    Context->ContextAttributes |= KERB_CONTEXT_IMPORTED;

    KerbUnlockContexts();

Cleanup:
    if (Context != NULL)
    {
        KerbDereferenceContext(Context);
    }

    return(Status);
}

NTSTATUS
KerbSetPageMode(
    BOOLEAN Pagable
    )
{
    if ( Pagable )
    {
        KerbPoolType = PagedPool ;
        KerbActiveList = KerbPagedList ;
    }
    else
    {
        if ( KerbNonPagedList == NULL )
        {
            KerbNonPagedList = KSecCreateContextList( KSecNonPaged );
            if ( KerbNonPagedList == NULL )
            {
                return STATUS_NO_MEMORY ;
            }
        }

        KerbActiveList = KerbNonPagedList ;

        KerbPoolType = NonPagedPool ;
    }
    return STATUS_SUCCESS ;


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\kernel\krnlapi.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        krnlapi.h
//
// Contents:    Structures and prototypes for kernel mode Kerberos functions
//
//
// History:     3-May-1996      Created         MikeSw
//
//------------------------------------------------------------------------

#ifndef __KRNLAPI_H__
#define __KRNLAPI_H__

typedef unsigned char  BYTE, *PBYTE;

#define USERAPI_ALLOCATE
#include "..\client2\userapi.h"

#define KERB_SAFE_SALT                  15

#define KERB_SIGNATURE_SIZE 10

#define KERBEROS_CAPABILITIES ( SECPKG_FLAG_INTEGRITY | \
                                SECPKG_FLAG_PRIVACY | \
                                SECPKG_FLAG_TOKEN_ONLY | \
                                SECPKG_FLAG_DATAGRAM | \
                                SECPKG_FLAG_CONNECTION | \
                                SECPKG_FLAG_MULTI_REQUIRED | \
                                SECPKG_FLAG_EXTENDED_ERROR | \
                                SECPKG_FLAG_IMPERSONATION | \
                                SECPKG_FLAG_ACCEPT_WIN32_NAME | \
                                SECPKG_FLAG_NEGOTIABLE | \
                                SECPKG_FLAG_GSS_COMPATIBLE | \
                                SECPKG_FLAG_LOGON | \
                                SECPKG_FLAG_MUTUAL_AUTH | \
                                SECPKG_FLAG_DELEGATION )


#define KERBEROS_MAX_TOKEN 12000
#define KERBEROS_PACKAGE_NAME L"Kerberos"
#define KERBEROS_PACKAGE_COMMENT L"Microsoft Kerberos V1.0"
#define KERB_PARAMETER_PATH L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Lsa\\Kerberos\\Parameters"
#define KERB_PARAMETER_MAX_TOKEN_SIZE L"MaxTokenSize"                                          

#define KERBEROS_RPCID 0x10   // RPC_C_AUTHN_GSS_KERBEROS

#endif // __KRNLAPI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\ktunnel\ktcontext.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation
//
// File:        ktcontext.cxx
//
// Contents:    Kerberos Tunneller, context management routines
//
// History:     28-Jun-2001     t-ryanj         Created
//
//------------------------------------------------------------------------
#include "ktcontext.h"
#include "ktmem.h"

//
// We keep track of our contexts in a list, so that we 
// can shut down all our connections when we're asked to close.
//

PKTCONTEXT KtContextList = NULL;

//
// This critsec will guarantee mutual exclusion on the context list.
//

BOOL KtContextListCritSecInit = FALSE;
CRITICAL_SECTION KtContextListCritSec;

//+-------------------------------------------------------------------------
//
//  Function:   KtInitContexts
//
//  Synopsis:   Does anything necessary to make ready to acquire and 
//		release contexts
//
//  Effects:    
//
//  Arguments:  
//
//  Requires:
//
//  Returns:    Success value.  If FALSE, GetLastError() for more info.
//
//  Notes:      
//
//
//--------------------------------------------------------------------------
BOOL
KtInitContexts(
    VOID
    )
{
    BOOL fRet = TRUE;

    //
    // All we need to do is initialize our critsec
    //
    
    __try
    {
        InitializeCriticalSectionAndSpinCount( &KtContextListCritSec, 4000 );
        KtContextListCritSecInit = TRUE;
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        DebugLog( DEB_ERROR, "%s(%d): InitializeCriticalSectionAndSpinCount raised an exception.\n", __FILE__, __LINE__ );
        goto Error;
    }

Cleanup:
    return fRet;

Error:
    fRet = FALSE;
    goto Cleanup;
}

//+-------------------------------------------------------------------------
//
//  Function:   KtCleanupContexts
//
//  Synopsis:   Cleans up any trash left by the context routines.
//
//  Effects:    
//
//  Arguments:  
//
//  Requires:
//
//  Returns:    
//
//  Notes:
//
//
//--------------------------------------------------------------------------
VOID
KtCleanupContexts(
    VOID
    )
{
    //
    // As we release the context at the head of the list, it will remove
    // itself from the list.  Hence, we can free the head of the list until
    // the entire list is freed.
    //

    while( KtContextList )
	KtReleaseContext(KtContextList);

    if( KtContextListCritSecInit )
	DeleteCriticalSection(&KtContextListCritSec);
}

//+-------------------------------------------------------------------------
//
//  Function:   KtAcquireContext
//
//  Synopsis:   Returns a context for use with the session associated with
// 		the passed in socket.
//
//  Effects:    
//
//  Arguments:  sock - socket on which to communicate with the user
//              size - size of the initial buffer
//
//  Requires:
//
//  Returns:    The new context, or NULL on failure. 
//
//  Notes:      If fails, GetLastError() for more info.
//
//--------------------------------------------------------------------------
PKTCONTEXT 
KtAcquireContext( 
    IN SOCKET sock, 
    IN ULONG  size
    )
{
    PKTCONTEXT pContext = NULL;

    DebugLog( DEB_TRACE, "%s(%d): Creating new context.\n", __FILE__, __LINE__ );

    //
    // Alloc memory for the structure.
    //
    
    pContext = (PKTCONTEXT)KtAlloc(sizeof(KTCONTEXT));
    if( !pContext )
    {
	SetLastError(ERROR_NOT_ENOUGH_MEMORY);
	DebugLog( DEB_ERROR, "%s(%d): Error in KtAlloc while trying to alloc a KTCONTEXT.\n", __FILE__, __LINE__ );
	goto Error;
    }
    ZeroMemory( pContext, sizeof(KTCONTEXT) );
    
    //
    // Associate the socket
    //

    pContext->sock = sock;
    
    //
    // Make the first read buffer.
    // 
    
    pContext->buffers = (PKTBUFFER)KtAlloc( sizeof(KTBUFFER) + size );
    if( !pContext->buffers )
    {
	SetLastError(ERROR_NOT_ENOUGH_MEMORY);
	DebugLog( DEB_ERROR, "%s(%d): Error allocating memory for receive buffer.\n", __FILE__, __LINE__ );
	goto Error;
    }
    pContext->buffers->buflen = size;
    pContext->buffers->next = NULL;
    pContext->emptybuf = pContext->buffers;

    // 
    // Wait for mutual exclusion on the socket list
    //

    __try
    {
        EnterCriticalSection(&KtContextListCritSec);
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        DebugLog( DEB_ERROR, "%s(%d): EnterCriticalSection raised an exception.\n", __FILE__, __LINE__ );
        goto Error;
    }

    //
    // Add to KtContextList.
    //
    
    pContext->prev = NULL;
    pContext->next = KtContextList;
    if( KtContextList != NULL )
	KtContextList->prev = pContext;
    KtContextList = pContext;

    //
    // We're done.
    //

    LeaveCriticalSection(&KtContextListCritSec);

Cleanup:    
    return pContext;

Error:
    //
    // If something goes wrong, don't allocate any memory.
    //

    if( pContext )
    {
	if( pContext->buffers )
	    KtFree( pContext->buffers );
	
	KtFree( pContext );
        pContext = NULL;
    }
    goto Cleanup;
}

//+-------------------------------------------------------------------------
//
//  Function:   KtReleaseContext
//
//  Synopsis:   Releases a context, signalling the end of the session.  
//              All resources associated with the context are freed.
//
//  Effects:    
//
//  Arguments:  pContext - The context who's session is complete.
//
//  Requires:
//
//  Returns:    
//
//  Notes:      If pContext is NULL, the call quietly does nothing.
//
//--------------------------------------------------------------------------
VOID 
KtReleaseContext( 
    IN PKTCONTEXT pContext 
    )
{
    if( pContext )
    { 
	DebugLog( DEB_TRACE, "%s(%d): Releasing context.\n", __FILE__, __LINE__ );

	//
	// So first close any open connections.
	//

	if( pContext->sock )
	    closesocket( pContext->sock );
	
	if( pContext->hRequest )
	    InternetCloseHandle( pContext->hRequest );
	
	if( pContext->hConnect )
	    InternetCloseHandle( pContext->hConnect );
	
	//
	// Free any buffers
	//
	while( pContext->buffers )
	{
	    PKTBUFFER car = pContext->buffers;
	    pContext->buffers = car->next;
	    KtFree( car );
	}

	if( pContext->pbProxies )
	    KtFree( pContext->pbProxies );

	//
	// Wait for lock on the socklist.
	//

        __try
        {
            EnterCriticalSection(&KtContextListCritSec);
        }
        __except( EXCEPTION_EXECUTE_HANDLER )
        {
            DebugLog( DEB_ERROR, "%s(%d): EnterCriticalSection raised an exception.\n", __FILE__, __LINE__ );
            /* TODO: Something must be done, here. */
            return;
        }

	// 
	// Remove the structure from KtContextList.
	//
	
	if( pContext->prev == NULL )
	    KtContextList = pContext->next;
	else
	    pContext->prev->next = pContext->next;
	if( pContext->next != NULL )
	    pContext->next->prev = pContext->prev;

	//
	// Done with list.
	//

	LeaveCriticalSection(&KtContextListCritSec);

	//
	// Free the memory
	//
    
	KtFree( pContext );
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   KtCoalesceBuffers
//
//  Synopsis:   Coalesces all data buffers from a context into one.
//
//  Effects:    
//
//  Arguments:  pContext - The context that has buffers to coalesce.
//
//  Requires:
//
//  Returns:    Success value.  Failure indicates an allocation failure. 
//
//  Notes:      At the beginning of this call, there are 'x' buffers in the
// 		pContext->buffers list.  At the end of this call there is a 
//		sole buffer in this list, holding all the data from the 'x' 
//		buffers.  The pContext->emptybuffer member is also made to 
//		point at this new buffer, so that it will be reused as the 
//		first buffer in the next read transaction. 
//
//--------------------------------------------------------------------------
BOOL 
KtCoalesceBuffers( 
    IN PKTCONTEXT pContext 
    )
{
    PKTBUFFER blist = pContext->buffers;
    PKTBUFFER bigbuf = NULL;
    BOOL fSuccess = TRUE;
    
    //
    // If there's only one buffer, nothing to do.  
    //
    
    if( !pContext->buffers->next )
	return TRUE;
    
    //
    // Allocate a buffer of appropriate size to hold everything.
    //
    
    bigbuf = (PKTBUFFER)KtAlloc( sizeof(KTBUFFER) + pContext->TotalBytes );
    if( !bigbuf )
    {
	DebugLog( DEB_ERROR, "%s(%d): Unable to allocate enough memory to coalesce buffers.\n", __FILE__, __LINE__ );
        goto Error;
    }
    bigbuf->buflen = pContext->TotalBytes;
    bigbuf->bytesused = 0;
    bigbuf->next = NULL;
    
    //
    // Copy everything in.
    //
    
    while( blist = pContext->buffers )
    {
	pContext->buffers = blist->next;
	
	RtlCopyMemory( bigbuf->buffer + bigbuf->bytesused,
		       blist->buffer,
		       blist->bytesused );
	
	bigbuf->bytesused += blist->bytesused;
	KtFree( blist );
    }
    
    DsysAssert( bigbuf->bytesused == pContext->TotalBytes );
    
    //
    // This is now the sole buffer in the bufferlist.
    // 
    
    pContext->buffers = bigbuf;
    pContext->emptybuf = bigbuf;
    
Cleanup:
    return fSuccess;

Error:
    fSuccess = FALSE;
    goto Cleanup;
}

//+-------------------------------------------------------------------------
//
//  Function:   KtGetMoreSpace
//
//  Synopsis:   Adds a new buffer to the end of the pContext->buffers list,
//		and points the pContext->emptybuf member at it.
//
//  Effects:    
//
//  Arguments:  pContext - The context that needs more space.
//		size     - Amount of space needed. 
//
//  Requires:
//
//  Returns:    Success value.  Failure indicates an allocation failure. 
//
//  Notes:      As emptybuf is essentially a pointer to the tail of the
//		list, the new buffer is tacked onto the list after emptybuf,
//		then emptybuf is made to point to the new buffer. 
//
//--------------------------------------------------------------------------
BOOL
KtGetMoreSpace(
    IN PKTCONTEXT pContext,
    IN ULONG      size  
    )
{
    BOOL fRet = TRUE;
    PKTBUFFER newbuf = NULL;

    //
    // Allocate a new, empty buffer.
    //
    
    newbuf = (PKTBUFFER)KtAlloc( sizeof(KTBUFFER) + size );
    if( !newbuf )
    {
	DebugLog( DEB_ERROR, "%s(%d): Error allocating space for transmission buffer.\n", __FILE__, __LINE__ );
        goto Error;
    }
    newbuf->buflen = (ULONG)size;
    newbuf->bytesused = 0;
    newbuf->next = NULL;

    //
    // Add it to the buffer list.
    //
    
    DsysAssert( pContext->emptybuf );
    DsysAssert( !pContext->emptybuf->next );
    pContext->emptybuf->next = newbuf;
    pContext->emptybuf = newbuf;
    
Cleanup:
    return fRet;

Error:
    fRet = FALSE;
    goto Cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\ktunnel\ktconsole.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation
//
// File:        ktconsole.cxx
//
// Contents:    Kerberos Tunneller, console entrypoint
//
// History:     28-Jun-2001	t-ryanj		Created
//
//------------------------------------------------------------------------
#include <windows.h>
#include <tchar.h>
#include "ktdebug.h"
#include "ktcontrol.h"

//
// Import the servicename (defined in ktcontrol.cxx) so we can give good
// instructions on how to add/remove the service using sc.exe.
//

extern LPTSTR KtServiceName;

//+-------------------------------------------------------------------------
//
//  Function:   wmain
//
//  Synopsis:   Main console entry point.
//
//  Effects:
//
//  Arguments:  
//
//  Requires:
//
//  Returns:
//
//  Notes:      Use wmain rather than main to get an LPTSTR[] of args.
//
//--------------------------------------------------------------------------
int __cdecl 
wmain( 
    DWORD argc, 
    LPTSTR argv[] 
    )
{
    //
    // Initialize debugging routines.
    //

    KtInitDebug();

    // 
    // if we have no arguments, attempt to run as a service,
    // otherwise explain how to install and remove using sc.exe.
    //
    
    if( argc == 1 )
    {
	if( KtStartServiceCtrlDispatcher() )
	{
	    DebugLog( DEB_TRACE, "%s(%d): Started service control dispatcher.\n", __FILE__, __LINE__ );
	}
	else
	{
            /* TODO: Log Event */
	    DebugLog( DEB_ERROR, "%s(%d): Error starting service control dispatcher: 0x%x.\n", __FILE__, __LINE__, GetLastError() );
	}
    }
    else 
    {
	_tprintf( TEXT("Kerberos Http Tunneller Client Service\n")
		  TEXT("Installation: sc create %s binPath= [path to this file]\n")
		  TEXT("Removal: sc delete %s\n"), KtServiceName, KtServiceName );
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\ktunnel\ktcore.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation
//
// File:        ktcore.h
//
// Contents:    Kerberos Tunneller, core service thread prototype
//
// History:     28-Jun-2001	t-ryanj		Created
//
//------------------------------------------------------------------------
#ifndef __KTCORE_H__

#include <windows.h>

VOID
KtThreadCore(
    VOID
    );

#define __KTCORE_H__

#endif // __KTCORE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\ktunnel\ktcontrol.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation
//
// File:        ktcontrol.h
//
// Contents:    Kerberos Tunneller, service control infrastructure
//
// History:     28-Jun-2001	t-ryanj		Created
//
//------------------------------------------------------------------------
#ifndef __KTCONTROL_H__
#define __KTCONTROL_H__

#include <windows.h>
#include <tchar.h>

BOOL 
KtStartServiceCtrlDispatcher(
    VOID
    );

BOOL 
KtIsStopped(
    VOID
    );

VOID 
KtServiceControlEvent( 
    DWORD dwControl 
    );


extern HANDLE KtIocp;

//
// Completion keys for use with KtIocp
//

enum _COMPKEY {
    KTCK_SERVICE_CONTROL,
    KTCK_CHECK_CONTEXT
};

#endif __KTCONTROL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\ktunnel\ktcontext.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation
//
// File:        ktcontext.h
//
// Contents:    Kerberos Tunneller context management prototypes & 
//		definitions for the context structure.
//
// History:     28-Jun-2001     t-ryanj         Created
//
//------------------------------------------------------------------------
#ifndef __KTCONTEXT_H__
#define __KTCONTEXT_H__

#include <Winsock2.h>
#include <Mswsock.h>
#include <wininet.h>
#include "ktdebug.h"

//
// _KTSTATUS defines different phases in the lifecycle of a session
// 

enum _KTSTATUS {
    KT_SOCK_CONNECT,
    KT_SOCK_READ,
    KT_HTTP_WRITE,
    KT_HTTP_READ,
    KT_SOCK_WRITE,
};

//
// KTBUFFER provides a chain of buffers to be used in read operations, 
// then can be coalesced for a write operation.
//

typedef struct _KTBUFFER {
    struct _KTBUFFER *next;
    ULONG buflen;
    ULONG bytesused;
#pragma warning(disable:4200)
    BYTE buffer[];
#pragma warning(default:4200)
} KTBUFFER, *PKTBUFFER;

//
// Note that since the KTCONTEXT structure has an OVERLAPPED as its first
// member, it in effect extends OVERLAPPED, and a ptr can be passed as an 
// LPOVERLAPPED to various i/o functions.
//

#define KTCONTEXT_BUFFER_LENGTH 128

typedef struct _KTCONTEXT {
    //
    // Contexts are kept track of in a doubly linked list, so they can
    // be reliably destroyed
    //
    struct _KTCONTEXT *next;
    struct _KTCONTEXT *prev;

    //
    // this overlapped struct must be first
    //
    OVERLAPPED ol; 

    //
    // Keeps track of the status of this session
    //
    _KTSTATUS Status;
    
    //
    // Socket context
    // 
    SOCKET sock;
    DWORD ExpectedLength;
    ULONG TotalBytes;
    ULONG PduValue;

    //
    // Http context
    //
    LPBYTE pbProxies; /* in MULTI_SZ format */
    HINTERNET hConnect;
    HINTERNET hRequest;

    //
    //  Buffers
    //
    PKTBUFFER buffers;
    PKTBUFFER emptybuf;
} KTCONTEXT, *PKTCONTEXT;

BOOL
KtInitContexts(
    VOID
    );

VOID 
KtCleanupContexts(
    VOID
    );

PKTCONTEXT 
KtAcquireContext( 
    IN SOCKET sock,
    IN ULONG  size
    );

VOID 
KtReleaseContext( 
    IN PKTCONTEXT pContext 
    );

BOOL
KtCoalesceBuffers(
    IN PKTCONTEXT pContext
    );

BOOL
KtGetMoreSpace(
    IN PKTCONTEXT pContext,
    IN ULONG      size
    );

#endif // __KTCONTEXT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\ktunnel\ktdebug.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation
//
// File:        ktdebug.cxx
//
// Contents:    Kerberos Tunneller, debugging routines
//
// History:     28-Jun-2001	t-ryanj		Created
//
//------------------------------------------------------------------------
#include "ktdebug.h"

#if DBG

DEBUG_KEY KtunnelDebugKeys[] = { { DEB_ERROR, "Error" },
                                 { DEB_WARN,  "Warn"  },
				 { DEB_TRACE, "Trace" },
                                 { DEB_PEDANTIC, "Pedantic" },
				 { 0,         NULL    } };

DEFINE_DEBUG2(Ktunnel);

//+-------------------------------------------------------------------------
//
//  Function:   KtInitDebug
//
//  Synopsis:   Initializes debugging resources and sets the default debug
//              level.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
VOID
KtInitDebug(
    VOID
    )
{
    //
    // Set the default debug level.  
    // TODO: Eventually, this should be read from the registry somewhere.
    //

    KtunnelInitDebug( KtunnelDebugKeys );

    KtunnelInfoLevel = DEB_TRACE | DEB_ERROR | DEB_WARN;
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\ktunnel\ktcore.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation
//
// File:        ktcore.cxx
//
// Contents:    Kerberos Tunneller, core service thread routines
//
// History:     28-Jun-2001	t-ryanj		Created
//
//------------------------------------------------------------------------
#include "ktdebug.h"
#include "ktcore.h"
#include "ktcontrol.h"
#include "ktcontext.h"
#include "ktsock.h"
#include "kthttp.h"
#include "ktkerb.h"

VOID
KtDispatchPerContext(
    PKTCONTEXT pContext
    );

//+-------------------------------------------------------------------------
//
//  Function:   KtThreadCore
//
//  Synopsis:   Main loop for service threads.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:      
//
//--------------------------------------------------------------------------
VOID
KtThreadCore(
    VOID
    )
{
    ULONG_PTR CompKey;
    LPOVERLAPPED pOverlapped = NULL;
    PKTCONTEXT pContext = NULL;
    DWORD IocpBytes;
    BOOL IocpSuccess;
    DWORD IocpError;

    //
    // Here's the main service loop.  It ends when the service is stopped.
    //
    
    while( !KtIsStopped() )
    {
	//
	// Wait for a task to queue on the completion port.
	//

	IocpSuccess = GetQueuedCompletionStatus( KtIocp, 
						 &IocpBytes, 
						 &CompKey, 
						 &pOverlapped, 
						 INFINITE ); 

        //
        // Extrapolate the address of the context from the address of the 
        // overlapped struct.
        //

        if( pOverlapped )
        {
            pContext = CONTAINING_RECORD( pOverlapped,
                                          KTCONTEXT,
                                          ol );
        }

	//
	// If there's an error on the Iocp, release any associated context if possible.
	// 
	
	if( !IocpSuccess )
	{
            /* TODO: Event Log. */

	    DebugLog( DEB_ERROR, "%s(%d): Error from GetQueuedCompletionStatus: 0x%x.\n", __FILE__, __LINE__, GetLastError() );
	    
	    if( pContext )
	    {
		DebugLog( DEB_TRACE, "%s(%d): Releasing context due to GQCS error.\n", __FILE__, __LINE__ );
		KtReleaseContext( pContext );
	    }
	    else
	    {
		DebugLog( DEB_TRACE, "%s(%d): No completion packet dequeued.\n", __FILE__, __LINE__ );
	    }

	    //
	    // Any completion key we have is invalid, so skip back to top of loop. 
	    //

	    continue;
	}

	//
	// Dispatch the task to the appropriate routine.
	//

	switch( CompKey )
        {
	case KTCK_SERVICE_CONTROL:
	    // 
	    // The specific control event was passed on the bytes argument.
	    //

	    KtServiceControlEvent(IocpBytes);
	    break;
	
	case KTCK_CHECK_CONTEXT:
	    //
	    // The context may not exist.  If the service is shutting down, it closes
	    // all pending connections, which will cause completion to be posted, 
	    // but since the context has already been destroyed, there's nothing to do.
	    //

	    if( pContext )
		KtDispatchPerContext(pContext);
	    break;
	    
	default:
	    DebugLog( DEB_WARN, "%s(%d): Unhandled case: 0x%x.\n", __FILE__, __LINE__, CompKey );
	    break;
	}
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   KtDispatchPerContext
//
//  Synopsis:   This routine handles the sequence of events that happen 
//		over the lifetime of a connection.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:      
//
//--------------------------------------------------------------------------
VOID
KtDispatchPerContext(
    PKTCONTEXT pContext
    )
{
    switch( pContext->Status )
    {
    case KT_SOCK_CONNECT:
	// 
	// First we need to prepare to accept other connections.
	// If we can't accept more incoming connections, this will 
	// impact the entire service.  
	//

        DebugLog( DEB_TRACE, "----==== Preparing to accept new connection ====----\n" );

	if( !KtSockAccept() )
	    goto SvcError;

	//
	// Now we can complete the acceptance of the socket that 
	// connected, then issue a read on that socket.  If something 
	// goes wrong here, we'll close the session.
	//

	if( !KtSockCompleteAccept(pContext) )
	    goto SessError;

	if( !KtSockRead(pContext) )
	    goto SessError;
	break;

    case KT_SOCK_READ:
        //
        // pContext->ol.InternalHigh holds the bytes transferred after a
        // socket operation.  If it's zero, the other side has closed the
        // connection.
        //

	if( !pContext->ol.InternalHigh )
	    goto SessError;
	
	pContext->emptybuf->bytesused = (ULONG)pContext->ol.InternalHigh;
	DebugLog( DEB_PEDANTIC, "%s(%d): %d bytes read from loopback.\n", __FILE__, __LINE__, pContext->emptybuf->bytesused );
	
        //
        // If we don't know how many bytes to look for yet, figure it out.
        //  
	
        if( pContext->ExpectedLength == 0 )
	{
	    if( !KtParseExpectedLength( pContext ) )
		goto SessError;
	    
	    DebugLog( DEB_TRACE, "%s(%d): Expected message length: %d.\n", __FILE__, __LINE__, pContext->ExpectedLength );
	}
	
	pContext->TotalBytes += pContext->emptybuf->bytesused;
	
	// 
	// If there might be more to read, get more space and try to read more,
	// otherwise, coalesce everything we've read into one mammoth buffer,
	// then send that.
	// 
	
        if( pContext->ExpectedLength > pContext->TotalBytes )
	{
	    if( !KtGetMoreSpace( pContext, KTCONTEXT_BUFFER_LENGTH ) )
		goto SessError;
	    
	    if( !KtSockRead(pContext) )
		goto SessError;			    
	}
	else
	{
            DebugLog( DEB_TRACE, "%s(%d): %d bytes total read from loopback.\n", __FILE__, __LINE__, pContext->TotalBytes );
	    
            if( !KtCoalesceBuffers( pContext ) )
		goto SessError;

	    if( !KtFindProxy(pContext) )
		goto SessError;
	    
	    if( !KtHttpWrite(pContext) )
		goto SessError;
	}

	break;

    case KT_HTTP_WRITE:
	//
	// And now we read the response to our request.
	// 	
	
	pContext->ExpectedLength = 0;
	pContext->TotalBytes = 0;
	
	if( !KtHttpRead(pContext) )
	    goto SessError;
	break;

    case KT_HTTP_READ:
	DebugLog( DEB_PEDANTIC, "%s(%d): %d bytes read from http.\n", __FILE__, __LINE__, pContext->emptybuf->bytesused );

        if( pContext->emptybuf->bytesused == 0 )
        {
            DebugLog( DEB_TRACE, "%s(%d): Data incomplete.  Dropping connection.\n", __FILE__, __LINE__ );
            goto SessError;
        }
	
        //
        // If we don't know how many bytes to look for yet, figure it out.
        //  
	    
        if( pContext->ExpectedLength == 0 )
	{
	    if( !KtParseExpectedLength( pContext ) )
		goto SessError;
	    
	    DebugLog( DEB_TRACE, "%s(%d): Expected message length: %d.\n", __FILE__, __LINE__, pContext->ExpectedLength );
	}

        //
        // Update the byte count
        //
	
        pContext->TotalBytes += pContext->emptybuf->bytesused;
	
	// 
	// If we're expecting more, get more space and try to read more,
	// otherwise, coalesce everything we've read into one mammoth buffer,
	// relay that response back to our client. 
	// 
	
	if( pContext->ExpectedLength > pContext->TotalBytes )
	{
	    if( !KtGetMoreSpace( pContext, KTCONTEXT_BUFFER_LENGTH ) )
		goto SessError;
	    
	    if( !KtHttpRead(pContext) )
		goto SessError;
	}
	else
	{
            DebugLog( DEB_TRACE, "%s(%d): %d total bytes read from http.\n", __FILE__, __LINE__, pContext->TotalBytes );
	    
            if( !KtCoalesceBuffers(pContext) )
		goto SessError;

            //
            // If this is a debug build, let's generate some debug spew if 
            // we get a kerb-error as a reply to one of our requests.
            //

#if DBG
            KtParseKerbError(pContext);
#endif
	    
	    if( !KtSockWrite(pContext) )
		goto SessError;
	}

	break;

    case KT_SOCK_WRITE:
	//
	// Once we've finished relaying our whole request-reponse pair,
	// we're done with this session.
	// 

        DebugLog( DEB_TRACE, "%s(%d): %d bytes written to loopback.\n", __FILE__, __LINE__, pContext->ol.InternalHigh );

	KtReleaseContext(pContext);
	break;

    default:
	DebugLog( DEB_WARN, "%s(%d): Unhandled case: 0x%x.\n", __FILE__, __LINE__, pContext->Status );
        DsysAssert( pContext->Status == KT_SOCK_CONNECT ||
                    pContext->Status == KT_SOCK_READ ||
                    pContext->Status == KT_HTTP_WRITE ||
                    pContext->Status == KT_HTTP_READ ||
                    pContext->Status == KT_SOCK_WRITE );
	break;
    }

    return;

SessError:
    DebugLog( DEB_TRACE, "%s(%d): Dropping connection due to session error.\n", __FILE__, __LINE__ );
    KtReleaseContext(pContext);
    return;

SvcError:
    /* TODO: Event log.  Pause service??? */
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\ktunnel\ktdebug.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation
//
// File:        ktdebug.h
//
// Contents:    Kerberos Tunneller, debugging routine prototypes
//
// History:     28-Jun-2001	t-ryanj		Created
//
//------------------------------------------------------------------------
#ifndef __KTDEBUG_H__
#define __KTDEBUG_H__

#include <windows.h>
#include <tchar.h>
#include <dsysdbg.h>

#define DEB_PEDANTIC 0x00000008

DECLARE_DEBUG2(Ktunnel);

#ifdef DBG
VOID 
KtInitDebug(
    VOID
    );
#else // DBG
#define KtInitDebug()
#endif // DBG

#ifdef DBG
#define DebugLog KtunnelDebugPrint
#else // DBG
#define DebugLog
#endif // DBG

#endif // __KTDEBUG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\ktunnel\ktcontrol.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation
//
// File:        ktcontrol.cxx
//
// Contents:    Kerberos Tunneller, service infrastructure
//
// History:     28-Jun-2001	t-ryanj		Created
//
//------------------------------------------------------------------------
#include "ktdebug.h"
#include "ktcontrol.h"
#include "ktcore.h"
#include "ktmem.h"
#include "ktsock.h"
#include "kthttp.h"

VOID WINAPI 
KtMainServiceEntry( 
    IN DWORD argc, 
    IN LPTSTR argv[] 
    );

DWORD WINAPI 
KtControlHandlerEx( 
    DWORD dwControl, 
    DWORD dwEventType, 
    PVOID pvEventData, 
    PVOID pvContext 
    );

BOOL 
KtStartupInit(
    VOID
    );

VOID 
KtContinueService(
    VOID
    );

VOID 
KtPauseService(
    VOID
    );

VOID 
KtStopService( 
    IN DWORD dwWin32ErrorCode 
    );

BOOL 
KtBeginStateTransition( 
    IN DWORD dwUltimateState, 
    IN DWORD dwWaitHint 
    ); 

BOOL 
KtFinishStateTransition(
    VOID
    );

HANDLE KtIocp = NULL;
HANDLE KtStateTransitionLock = NULL;
LPTSTR KtServiceName = TEXT("kerbtunnel");
SERVICE_TABLE_ENTRY KtServiceTable[] = { { KtServiceName, KtMainServiceEntry }, 
                                         { NULL, NULL } };
SERVICE_STATUS KtServiceStatus = {0};
SERVICE_STATUS_HANDLE KtServiceStatusHandle = NULL;

//+-------------------------------------------------------------------------
//
//  Function:   KtStartServiceCtrlDispatcher
//
//  Synopsis:   Starts the Service Control Dispatcher.
//
//  Effects:    
//
//  Arguments:  
//
//  Requires:
//
//  Returns:    Success value.
//		If FALSE, GetLastError() for more info.
//
//  Notes:
//
//
//--------------------------------------------------------------------------
BOOL
KtStartServiceCtrlDispatcher(
    VOID
    )
{
    return StartServiceCtrlDispatcher( KtServiceTable );
}

//+-------------------------------------------------------------------------
//
//  Function:   KtFinishStateTransition
//
//  Synopsis:   Closes out a state transition, reporting the new state
//		to service control.
//
//  Effects:    Modifies KtServiceStatus, the global service state.
//
//              Signals KtStateTransitionLock, signifying the completion of 
//              a state transition.
//
//  Arguments:  
//
//  Requires:
//
//  Returns:    TRUE on success, FALSE on failure.
//		If FALSE, GetLastError() for details. 
//
//  Notes:
//
//
//--------------------------------------------------------------------------
BOOL 
KtFinishStateTransition(
    VOID
    )
{
    BOOL fSuccess = TRUE;
    DWORD dwUltimateState;

    //
    // First, we determine what state we want to be in at the end of the 
    // transition.
    //

    switch( KtServiceStatus.dwCurrentState )
    {
    case SERVICE_START_PENDING:
    case SERVICE_CONTINUE_PENDING:
	dwUltimateState = SERVICE_RUNNING;
	break;

    case SERVICE_STOP_PENDING:
	dwUltimateState = SERVICE_STOPPED;
	break;

    case SERVICE_PAUSE_PENDING:
	dwUltimateState = SERVICE_PAUSED;
	break;

    default:
	DebugLog( DEB_WARN, "%s(%d): Unhandled case: 0x%x.\n", __FILE__, __LINE__, KtServiceStatus.dwCurrentState );
	SetLastError( ERROR_INVALID_PARAMETER );
        DsysAssert( KtServiceStatus.dwCurrentState == SERVICE_START_PENDING ||
                    KtServiceStatus.dwCurrentState == SERVICE_CONTINUE_PENDING ||
                    KtServiceStatus.dwCurrentState == SERVICE_STOP_PENDING ||
                    KtServiceStatus.dwCurrentState == SERVICE_PAUSE_PENDING );
	goto Error;
    }

    //
    // Time to construct and set the new state.
    // 
    // Checkpoint and WaitHint are always 0 for non-pending states, 
    // and we only report errors when punting, which is handled by 
    // a different routine.
    // 

    KtServiceStatus.dwCheckPoint = KtServiceStatus.dwWaitHint = 0;
    KtServiceStatus.dwWin32ExitCode = NO_ERROR;
    KtServiceStatus.dwServiceSpecificExitCode = 0;
    KtServiceStatus.dwCurrentState = dwUltimateState;

    if( !SetServiceStatus( KtServiceStatusHandle, &KtServiceStatus ) )
    {
	DebugLog( DEB_ERROR, "%s(%d): Error from SetServiceStatus: 0x%x.\n", __FILE__, __LINE__, GetLastError() );
	goto Error;
    }

    //
    // Now we signal the StateTransition event, indicating that it's 
    // alright to begin a new state transition.
    //

    if( !SetEvent( KtStateTransitionLock ) )
    {
	DebugLog( DEB_ERROR, "%s(%d): Error from SetEvent: 0x%x.\n", __FILE__, __LINE__, GetLastError() );
	goto Error;
    }
    
    DebugLog( DEB_TRACE, "%s(%d): State transition completed.\n", __FILE__, __LINE__ );

Cleanup:
    return fSuccess;

Error:
    /* TODO: Event log, and maybe something drastic. */
    fSuccess = FALSE;
    goto Cleanup;
}

//+-------------------------------------------------------------------------
//
//  Function:   KtBeginStateTransition
//
//  Synopsis:   Enters a state transition, reporting an appropriate pending 
// 		state to Service Control and requesting dwWaitHint millisec
//		to complete the transition.
//
//  Effects:    Modifies KtServiceStatus, the global service status.
//              Waits for KtStateTransitionLock to begin state transition.
//
//  Arguments:  dwUltimateState - One of SERVICE_STOPPED, SERVICE_RUNNING, 
//              or SERVICE_PAUSED.
//
//              dwWaitHint - Estimated millisec before next state report.  
//              Service Control may kill the service if it does not 
//              report again within the time specified.  (See Notes.)
//
//  Requires:
//
//  Returns:    Success value.  If FALSE, GetLastError() for details.
//
//  Notes:      If 0 is supplied as dwWaitHint, this call will go directly
//              to the ultimate state rather than a pending state.
//
//--------------------------------------------------------------------------
BOOL 
KtBeginStateTransition( 
    IN DWORD dwUltimateState, 
    IN DWORD dwWaitHint 
    )
{
    BOOL fSuccess = TRUE;
    DWORD dwPendingState = 0;

    // 
    // dwUltimateState is our target state, so determine which pending
    // state to be in in the meantime.
    //

    switch( dwUltimateState )
    {
    case SERVICE_STOPPED:
	dwPendingState = SERVICE_STOP_PENDING;
	break;

    case SERVICE_RUNNING:
	dwPendingState = (KtServiceStatus.dwCurrentState == SERVICE_PAUSED) ? SERVICE_CONTINUE_PENDING : SERVICE_START_PENDING;
	break;

    case SERVICE_PAUSED:
	dwPendingState = SERVICE_PAUSE_PENDING;
	break;

    default:
	DebugLog( DEB_WARN, "%s(%d): Invalid parameter to KtBeginStateTransition: 0x%x.\n", dwUltimateState );
	SetLastError(ERROR_INVALID_PARAMETER);
        DsysAssert( dwUltimateState == SERVICE_STOPPED ||
                    dwUltimateState == SERVICE_RUNNING ||
                    dwUltimateState == SERVICE_PAUSED );
	goto Error;
    }

    // 
    // Wait for any pending state transitions to complete before 
    // starting a new one.
    //

    WaitForSingleObjectEx( KtStateTransitionLock, INFINITE, FALSE );
    DebugLog( DEB_TRACE, "%s(%d): Beginning State Transition.\n", __FILE__, __LINE__ );

    // 
    // If dwWaitHint was given as 0, we want to go right ahead 
    // and set the target state, otherwise we set the appropriate
    // pending state.
    //
	
    if( dwWaitHint == 0 )
    {
	if( !KtFinishStateTransition() )
	    goto Error;
    }
    else
    {
	// 
	// We're ready to initialize and set the state.
	//
	// Checkpoint is 1 since this will be the first checkpoint
	// in the new pending state, WaitHint as supplied, and 
	// no errors are reported except when stopping.
	// 

	KtServiceStatus.dwCheckPoint = 1;
	KtServiceStatus.dwWaitHint = dwWaitHint;
	KtServiceStatus.dwWin32ExitCode = NO_ERROR;
	KtServiceStatus.dwServiceSpecificExitCode = 0;
	KtServiceStatus.dwCurrentState = dwPendingState;

	if( !SetServiceStatus( KtServiceStatusHandle, &KtServiceStatus ) )
	{
	    DebugLog( DEB_ERROR, "%s(%d): Error from SetServiceStatus: 0x%x.\n", __FILE__, __LINE__, GetLastError() );
	    goto Error;
	}
    }

Cleanup:    
    return fSuccess;

Error:
    fSuccess = FALSE;
    goto Cleanup;
}

//+-------------------------------------------------------------------------
//
//  Function:   KtControlHandlerEx
//
//  Synopsis:   Service Control Handler, called by Service Control to 
//              process control events.  
//
//  Effects:    Posts to the i/o completion port to wake a service thread.
//
//  Arguments:  dwControl - The control to handle.
//		dwEventType - Extended info for certain control events.
//		pvEventData - Additional info for certain control events.
//		pvContext - User defined data. (Unused here.)
//
//  Requires:
//
//  Returns:    Winerror code, spec. NO_ERROR or ERROR_CALL_NOT_IMPLEMENTED.  
//
//  Notes:      
//
//--------------------------------------------------------------------------
DWORD WINAPI 
KtControlHandlerEx( 
    IN DWORD dwControl, 
    IN DWORD dwEventType, 
    IN PVOID pvEventData, 
    IN PVOID pvContext 
    )
{
    DWORD dwReturn = NO_ERROR;
    BOOL fPostControlToServiceThread = FALSE;

    //
    // If we're told to change state, initiate an appropriate state
    // transition.  To service an INTERROGATE request we merely report
    // our current status.  No other control events are implemented.
    //

    switch( dwControl )
    {
    case SERVICE_CONTROL_STOP:
    case SERVICE_CONTROL_SHUTDOWN:
	DebugLog( DEB_TRACE, "%s(%d): SERVICE_CONTROL_%s recieved.\n", __FILE__, __LINE__, (dwControl==SERVICE_CONTROL_STOP)?"STOP":"SHUTDOWN" );
	KtBeginStateTransition( SERVICE_STOPPED, 2000 );
	fPostControlToServiceThread = TRUE;
	break;

    case SERVICE_CONTROL_PAUSE:
	DebugLog( DEB_TRACE, "%s(%d): SERVICE_CONTROL_PAUSE recieved.\n", __FILE__, __LINE__ );
	KtBeginStateTransition( SERVICE_PAUSED, 2000 );
	fPostControlToServiceThread = TRUE;
	break;

    case SERVICE_CONTROL_CONTINUE:
	DebugLog( DEB_TRACE, "%s(%d): SERVICE_CONTROL_CONTINUE recieved.\n", __FILE__, __LINE__ );
	KtBeginStateTransition( SERVICE_RUNNING, 2000 );
	fPostControlToServiceThread = TRUE;
	break;

    case SERVICE_CONTROL_INTERROGATE:
	DebugLog( DEB_TRACE, "%s(%d): SERVICE_CONTROL_CONTINUE recieved.\n", __FILE__, __LINE__ );
	SetServiceStatus( KtServiceStatusHandle, &KtServiceStatus );
	dwReturn = NO_ERROR;
	break;

    case SERVICE_CONTROL_PARAMCHANGE:
    case SERVICE_CONTROL_NETBINDADD:
    case SERVICE_CONTROL_NETBINDREMOVE:
    case SERVICE_CONTROL_NETBINDENABLE:
    case SERVICE_CONTROL_NETBINDDISABLE:
    case SERVICE_CONTROL_DEVICEEVENT:
    case SERVICE_CONTROL_HARDWAREPROFILECHANGE:
    case SERVICE_CONTROL_POWEREVENT:
    case SERVICE_CONTROL_SESSIONCHANGE:
	DebugLog( DEB_WARN, "%s(%d): Unsupported control recieved.\n", __FILE__, __LINE__ );
        dwReturn = ERROR_CALL_NOT_IMPLEMENTED;
	break;

    default:
	DebugLog( DEB_WARN, "%s(%d): Unhandled case: 0x%x.\n", __FILE__, __LINE__, dwControl );
        dwReturn = ERROR_CALL_NOT_IMPLEMENTED;
        DsysAssert( dwControl == SERVICE_CONTROL_STOP ||
                    dwControl == SERVICE_CONTROL_SHUTDOWN ||
                    dwControl == SERVICE_CONTROL_PAUSE ||
                    dwControl == SERVICE_CONTROL_CONTINUE ||
                    dwControl == SERVICE_CONTROL_INTERROGATE ||
                    dwControl == SERVICE_CONTROL_DEVICEEVENT ||
                    dwControl == SERVICE_CONTROL_HARDWAREPROFILECHANGE ||
                    dwControl == SERVICE_CONTROL_POWEREVENT ||
                    dwControl == SERVICE_CONTROL_PARAMCHANGE ||
                    dwControl == SERVICE_CONTROL_NETBINDADD ||
                    dwControl == SERVICE_CONTROL_NETBINDREMOVE ||
                    dwControl == SERVICE_CONTROL_NETBINDENABLE ||
                    dwControl == SERVICE_CONTROL_NETBINDDISABLE ||
                    dwControl == SERVICE_CONTROL_DEVICEEVENT ||
                    dwControl == SERVICE_CONTROL_HARDWAREPROFILECHANGE ||
                    dwControl == SERVICE_CONTROL_POWEREVENT ||
                    dwControl == SERVICE_CONTROL_SESSIONCHANGE );
	break;
    }

    //
    // If we're changing state, we need to wake up a service thread
    // to do the actual work, so we post an event to the Completion 
    // port with the key KTCK_SERVICE_CONTROL.  Since no data transfer
    // actually took place, we can pass the control event in as the 
    // "number of bytes transferred" without ambiguity.
    //

    if( fPostControlToServiceThread )    
    {
	BOOL IocpSuccess;

	IocpSuccess = PostQueuedCompletionStatus( KtIocp, 
						  dwControl, 
						  KTCK_SERVICE_CONTROL, 
						  NULL );
	if( !IocpSuccess )
	{
	    DebugLog( DEB_ERROR, "%s(%d): Error posting completion status to I/O completion port: 0x%x.\n", __FILE__, __LINE__, GetLastError() );
            dwReturn = GetLastError();
	    /* TODO: Event log, possibly something drastic. */
	}
    }

    return dwReturn;
}

//+-------------------------------------------------------------------------
//
//  Function:   KtStartupInit
//
//  Synopsis:   Does the startup initialization for the service.
//
//  Effects:    
//
//  Arguments:  
//
//  Requires:
//
//  Returns:    Success value.
//		If initialization fails, KtServiceStatus.dwWin32ErrorCode is set
//              to an appropriate error code, and the service stops.
//
//  Notes:      
//
//--------------------------------------------------------------------------
BOOL
KtStartupInit(
    VOID
    )
{
    BOOL fRet = TRUE;

    //
    // Initialize the Service Status structure.
    //
    
    KtServiceStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    KtServiceStatus.dwCurrentState = SERVICE_START_PENDING;
    KtServiceStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_PAUSE_CONTINUE;
    KtServiceStatus.dwWin32ExitCode = NO_ERROR;
    KtServiceStatus.dwServiceSpecificExitCode = 0;
    KtServiceStatus.dwCheckPoint = 0;
    KtServiceStatus.dwWaitHint = 2000;

    //
    // First thing we need to do is get a handle on our status so we can 
    // tell Service Control what we're doing.
    // The SERVICE_STATUS_HANDLE returned by this call need not be closed.
    //
    
    DsysAssert(KtServiceStatusHandle == NULL);
    KtServiceStatusHandle = RegisterServiceCtrlHandlerEx( KtServiceName, 
							  KtControlHandlerEx, 
							  NULL );
    if( KtServiceStatusHandle == NULL )
    {
	DebugLog( DEB_ERROR, "%s(%d): Error from RegisterServiceCtrlHandlerEx: 0x%x.\n", __FILE__, __LINE__, GetLastError() );
	goto Error;
    }

    //
    // Next we create an event (auto reset, initially signalled) that we'll
    // use to make sure we aren't in multiple state transitions simultaneously.  
    //

    DsysAssert(KtStateTransitionLock == NULL );
    KtStateTransitionLock = CreateEvent( NULL, 
					 FALSE, // NOT manual reset
					 TRUE,  // initially signalled
					 NULL );
    if( KtStateTransitionLock == NULL )
    {
	DebugLog( DEB_ERROR, "%s(%d): Error from CreateEvent: 0x%x.\n", __FILE__, __LINE__, GetLastError() );
	goto Error;
    }

    // 
    // Now we can signal Service Control that we're starting.
    //

    if( !KtBeginStateTransition( SERVICE_RUNNING, 2000 ) )
	goto Error;

    //
    // Create an unassociated I/O Completion port that we'll use to queue 
    // events to be serviced.
    //

    DsysAssert(KtIocp == NULL);
    KtIocp = CreateIoCompletionPort( INVALID_HANDLE_VALUE, NULL, 0, 0 );
    if( KtIocp == NULL )
    {
	DebugLog( DEB_ERROR, "%s(%d): Error from CreateIoCompletionPort: 0x%x.\n", __FILE__, __LINE__, GetLastError() );
	goto Error;
    }

    //
    // Initialize memory routines
    //

    if( !KtInitMem() )
	goto Error;

    //
    // Initialize Winsock
    //
    
    if( !KtInitWinsock() )
	goto Error;

    //
    // Initialize WinInet
    // 

    if( !KtInitHttp() )
	goto Error;

    //
    // Initialize contexts
    //

    if( !KtInitContexts() )
	goto Error;

    //
    // Finish bringing up the service.
    //

    KtContinueService();

Cleanup:    
    return fRet;

Error:
    //
    // We couldn't get the resources we needed to start, so punt the service.
    // Note that KtStopService cleans up any resources we may have successfully
    // allocated in this routine.
    //

    /* TODO: Event log. */
    KtStopService( GetLastError() );
    fRet = FALSE;
    goto Cleanup;
}

//+-------------------------------------------------------------------------
//
//  Function:   KtContinueService
//
//  Synopsis:   Continues the service.  This is not only the opposite of 
//              pause, but the second half of the initialization necessary
//              to start the service in the first place.
//
//  Effects:    
//
//  Arguments:  
//
//  Requires:
//
//  Returns:    
//
//  Notes:      
//
//--------------------------------------------------------------------------
VOID 
KtContinueService(
    VOID
    )
{
    //
    // To continue the service we start listening for new connections.
    //

    if( !KtStartListening() )
	goto Error;

    KtFinishStateTransition();

    return;

Error:
    /* TODO: Event log. */
    DebugLog( DEB_ERROR, "%s(%d): Unable to bring up service.  Shutting down with error code 0x%x.\n", __FILE__, __LINE__, GetLastError() );
    KtStopService( GetLastError() );
}

//+-------------------------------------------------------------------------
//
//  Function:   KtPauseService
//
//  Synopsis:   Pauses the service.
//
//  Effects:    
//
//  Arguments:  
//
//  Requires:
//
//  Returns:    
//
//  Notes:       
//
//--------------------------------------------------------------------------
VOID 
KtPauseService(
    VOID
    )
{
    //
    // To pause the service, we stop making new connections, but we can 
    // leave any open connections open.  
    //

    KtStopListening();
    KtFinishStateTransition();
}

//+-------------------------------------------------------------------------
//
//  Function:   KtStopService
//
//  Synopsis:   Stops the service.
//
//  Effects:    
//
//  Arguments:  
//
//  Requires:
//
//  Returns:    
//
//  Notes:      
//
//--------------------------------------------------------------------------
VOID 
KtStopService(
    DWORD dwWin32ErrorCode
    )
{
    //
    // Release all our resources.
    //

    KtStopListening();
    KtCleanupContexts();
    KtCleanupHttp();
    KtCleanupWinsock();
    KtCleanupMem();
    if( KtStateTransitionLock )
	CloseHandle(KtStateTransitionLock);
    if( KtIocp )
	CloseHandle(KtIocp);

    //
    // Tell service control that we're done.
    //

    KtServiceStatus.dwCurrentState = SERVICE_STOPPED;
    KtServiceStatus.dwCheckPoint = 0;
    KtServiceStatus.dwWaitHint = 0;
    KtServiceStatus.dwWin32ExitCode = dwWin32ErrorCode;
    KtServiceStatus.dwServiceSpecificExitCode = 0;

    if( KtServiceStatusHandle )
	SetServiceStatus( KtServiceStatusHandle, &KtServiceStatus );
}

//+-------------------------------------------------------------------------
//
//  Function:   KtServiceControlEvent
//
//  Synopsis:   Dispatches control events to the appropriate routine to 
//		do the state change.
//
//  Effects:    
//
//  Arguments:  dwControl - Code of the control event.
//
//  Requires:
//
//  Returns:    
//
//  Notes:      
//
//--------------------------------------------------------------------------
VOID 
KtServiceControlEvent(
    DWORD dwControl
    )
{
    switch( dwControl )
    {
    case SERVICE_CONTROL_CONTINUE:
	KtContinueService();
	break;

    case SERVICE_CONTROL_PAUSE:
	KtPauseService();
	break;

    case SERVICE_CONTROL_STOP:
    case SERVICE_CONTROL_SHUTDOWN:
	KtStopService(NO_ERROR);
	break;

    default:
	DebugLog( DEB_WARN, "%s(%d): Unhandled case: 0x%x.", __FILE__, __LINE__, dwControl );
        DsysAssert( dwControl == SERVICE_CONTROL_CONTINUE ||
                    dwControl == SERVICE_CONTROL_PAUSE ||
                    dwControl == SERVICE_CONTROL_STOP ||
                    dwControl == SERVICE_CONTROL_SHUTDOWN );
	break;
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   KtMainServiceEntry
//
//  Synopsis:   This initializes the service, then acts as the main service
//		thread.
//
//  Effects:    
//
//  Arguments:  
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
VOID WINAPI 
KtMainServiceEntry( 
    IN DWORD argc, 
    IN LPTSTR argv[] 
    )
{
    //
    // Do startup initialization.
    //

    if( !KtStartupInit() )
	goto Cleanup;

    //
    // Do our thing.
    //

    KtThreadCore();

Cleanup:    
    ExitProcess( KtServiceStatus.dwWin32ExitCode );
}

//+-------------------------------------------------------------------------
//
//  Function:   KtIsStopped
//
//  Synopsis:   Determines whether the service is still running.
//
//  Effects:    
//
//  Arguments:  
//
//  Requires:
//
//  Returns:    TRUE if the service has stopped, FALSE otherwise.
//
//  Notes:
//
//--------------------------------------------------------------------------
BOOL 
KtIsStopped(
    VOID
    )
{
    return (KtServiceStatus.dwCurrentState == SERVICE_STOPPED);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\ktunnel\kthttp.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation
//
// File:        kthttp.cxx
//
// Contents:    Kerberos Tunneller, http communication prototypes
//
// History:     28-Jun-2001	t-ryanj		Created
//
//------------------------------------------------------------------------
#ifndef __KTHTTP_H__
#define __KTHTTP_H__

#include "ktcontext.h"

BOOL 
KtInitHttp(
    VOID
    );

VOID
KtCleanupHttp(
    VOID
    );

BOOL
KtHttpWrite(
    PKTCONTEXT pContext
    );

BOOL
KtHttpRead(
    PKTCONTEXT pContext
    );

#endif // __KTHTTP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\ktunnel\ktkerb.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation
//
// File:        ktkerb.h
//
// Contents:    Kerberos Tunneller, prototypes for routines that parse 
//              kerb messages
//
// History:     23-Jul-2001	t-ryanj		Created
//
//------------------------------------------------------------------------
#ifndef __KTKERB_H__
#define __KTKERB_H__

#include "ktcontext.h"

BOOL
KtSetPduValue(
    PKTCONTEXT pContext
    );

BOOL
KtParseExpectedLength(
    PKTCONTEXT pContext
    );

BOOL
KtFindProxy(
    PKTCONTEXT pContxet
    );

VOID
KtParseKerbError(
    PKTCONTEXT pContext
    );

BOOL
KtIsAsRequest(
    PKTCONTEXT pContext
    );

#endif // __KTKERB_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\ktunnel\ktmem.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation
//
// File:        ktmem.cxx
//
// Contents:    Routines to wrap memory allocation, etc.
//
// History:     10-Jul-2001     t-ryanj         Created
//
//------------------------------------------------------------------------
#include "ktmem.h"
#include "ktdebug.h"

HANDLE KtHeap = NULL;
#ifdef DBG
LONG KtAllocs = 0;
#endif

//+-------------------------------------------------------------------------
//
//  Function:   KtInitMem
//
//  Synopsis:   Does any initialization required before allocating memory
// 		using KtAlloc/KtFree
//
//  Effects:
//
//  Arguments:  
//
//  Requires:   
//
//  Returns:    Success value.  If FALSE is returned, memory has not been
//		initialized, and KtAlloc/KtFree cannot be safely called.
//
//  Notes:
//
//
//--------------------------------------------------------------------------
BOOL
KtInitMem(
    VOID
    )
{
    DsysAssert(KtHeap==NULL);
    KtHeap = GetProcessHeap();
    
    if( KtHeap == NULL )
    {
	DebugLog( DEB_ERROR, "%s(%d): Could not get process heap: 0x%x.\n", __FILE__, __LINE__, GetLastError() );
    }

    return (KtHeap != NULL);
}

//+-------------------------------------------------------------------------
//
//  Function:   KtCleanupMem
//
//  Synopsis:   Undoes whatever initialization was done by KtInitMem
//
//  Effects:
//
//  Arguments:  
//
//  Requires:   
//
//  Returns:    
//
//  Notes:
//
//
//--------------------------------------------------------------------------
VOID
KtCleanupMem(
    VOID
    )
{
#if DBG
    //
    // Assert that we freed all our memory.
    //

    DsysAssert( KtAllocs == 0 );
#endif

    KtHeap = NULL;
}

//+-------------------------------------------------------------------------
//
//  Function:   KtAlloc
//
//  Synopsis:   Wrapper to be used for all alloc calls.
//
//  Effects:
//
//  Arguments:  
//
//  Requires:   
//
//  Returns:    
//
//  Notes:
//
//
//--------------------------------------------------------------------------
PVOID
KtAlloc(
    SIZE_T size
    ) 
{
    PVOID pv;

    pv = HeapAlloc( KtHeap,
                    0,
                    size );

#ifdef DBG
    if( pv )
        InterlockedIncrement(&KtAllocs);
#endif
    return pv;
}

//+-------------------------------------------------------------------------
//
//  Function:   KtAlloc
//
//  Synopsis:   Wrapper to be used for all realloc calls.
//
//  Effects:
//
//  Arguments:  
//
//  Requires:   
//
//  Returns:    
//
//  Notes:
//
//
//--------------------------------------------------------------------------
PVOID
KtReAlloc(
    PVOID buf,
    SIZE_T size 
    )
{
    return HeapReAlloc( KtHeap,
			0,
			buf,
			size );
}

//+-------------------------------------------------------------------------
//
//  Function:   KtFree
//
//  Synopsis:   Wrapper to be used for all free calls.
//
//  Effects:
//
//  Arguments:  
//
//  Requires:   
//
//  Returns:    
//
//  Notes:
//
//
//--------------------------------------------------------------------------
VOID
KtFree(
    PVOID buf
    ) 
{
#ifdef DBG
    InterlockedDecrement(&KtAllocs);
#endif
    HeapFree( KtHeap, 
	      0, 
	      buf );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\ktunnel\ktkerb.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation
//
// File:        ktkerb.cxx
//
// Contents:    Kerberos Tunneller, routines that parse the kerb req/req
//
// History:     23-Jul-2001	t-ryanj		Created
//
//------------------------------------------------------------------------
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#ifndef SECURITY_WIN32
#define SECURITY_WIN32
#endif
#include <wincrypt.h>
#include <asn1util.h>
#include <kerbcomm.h>
#include "ktdebug.h"
#include "ktkerb.h"
#include "ktmem.h"

//#define KT_REGKEY_REALMS TEXT("System\\CurrentControlSet\\Services\\kerbtunnel\\Realms\\")
TCHAR KT_REGKEY_REALMS[] = TEXT("System\\CurrentControlSet\\Services\\kerbtunnel\\Realms\\");
#define KT_INITIAL_KDCBUFFER_SIZE 64

//+-------------------------------------------------------------------------
//
//  Function:   KtSetPduValue
//
//  Synopsis:   Parses the kerberos request and sets the PduValue memeber 
//              of pContext to the appropriate value to be passed to 
//              KerbUnpackData
//
//  Effects:    
//
//  Arguments:  pContext - context that has the coalesced request in 
//                         pContext->emptybuf->buffer
//
//  Requires:   
//
//  Returns:    Success value.
//
//  Notes:       
//
//--------------------------------------------------------------------------
BOOL
KtSetPduValue(
    PKTCONTEXT pContext
    )
{
    BOOL fRet = TRUE;
    BYTE AsnTag;

    //
    // If we don't have the first byte of the request, we can't parse it.
    //

    if( pContext->emptybuf->buflen < sizeof(DWORD) + 1 )
        goto Error;

    //
    // The last five bits of the first byte of the kerb message tell us 
    // what kind of message it is.  We set the pdu value accordingly.
    //

    switch( (AsnTag = pContext->emptybuf->buffer[sizeof(DWORD)] & 0x1f) ) /* last 5 bits */
    {
    case 0x0a: /* AS-REQUEST */
        DebugLog( DEB_TRACE, "%s(%d): Handing AS-REQUEST.\n", __FILE__, __LINE__ );
	pContext->PduValue = KERB_AS_REQUEST_PDU;
	break;

    case 0x0b: /* AS-REPLY */
        DebugLog( DEB_TRACE, "%s(%d): Handling AS-REPLY.\n", __FILE__, __LINE__ );
        pContext->PduValue = KERB_AS_REPLY_PDU;
        break;
		
    case 0x0c: /* TGS-REQUEST */
        DebugLog( DEB_TRACE, "%s(%d): Handling TGS-REQUEST.\n", __FILE__, __LINE__ );
	pContext->PduValue = KERB_TGS_REQUEST_PDU;
	break;

    case 0x0d: /* TGS-REPLY */
        DebugLog( DEB_TRACE, "%s(%d): Handing TGS-REPLY.\n", __FILE__, __LINE__ );
        pContext->PduValue = KERB_TGS_REPLY_PDU;
        break;

    case 0x1e: /* KERB_ERROR */
        DebugLog( DEB_TRACE, "%s(%d): Handling KERB-ERROR.\n", __FILE__, __LINE__ );
        pContext->PduValue = KERB_ERROR_PDU;
        break;
	
    default:	
	DebugLog( DEB_WARN, "%s(%d): Unhandled message type.  ASN tag: 0x%x.\n", __FILE__, __LINE__, AsnTag );
        DsysAssert( (AsnTag >= 0x0a && AsnTag <= 0x0d) ||
                    AsnTag == 0x1e );
	break;
    }

Cleanup:
    return fRet;

Error:
    fRet = FALSE;
    goto Cleanup;
}

//+-------------------------------------------------------------------------
//
//  Function:   KtParseExpectedLength
//
//  Synopsis:   Parses the expected length of the message.
//              When using TCP, the message is prepended by four bytes 
//              indicating its length in network byte order.
//              When using UDP, the ASN.1 encoded length in the message
//              must be parsed out.
//
//  Effects:    
//
//  Arguments:  pContext - context that has the beginning of the request in
//                         pContext->emptybuf->buffer
//
//  Requires:   
//
//  Returns:    Success value.
//
//  Notes:      
//
//--------------------------------------------------------------------------
BOOL
KtParseExpectedLength(
    PKTCONTEXT pContext
    )
{
    BOOL fRet = TRUE;
    DWORD cbContent;
#if 0 /* this is the udp way, not the tcp way */
    LONG cbLength;
#endif
    
    //
    // If we don't have the four bytes, we can't parse the length.
    //
    
    if( pContext->emptybuf->bytesused < sizeof(DWORD) )
    {
        DebugLog( DEB_ERROR, "%s(%d): Not enough data to parse length.\n", __FILE__, __LINE__ );
	goto Error;
    }
    
    //
    // Otherwise, we just take the first four bytes and convert them
    // to host byte order.
    //
    
    cbContent = ntohl( *(u_long*)pContext->emptybuf->buffer );

    //
    // If the most significant bit is set, this indicates that more 
    // bytes are needed for the length.  We're just going to discard
    // any messages that long.
    //

    if( cbContent & 0x80000000 )
    {
	DebugLog( DEB_ERROR, "%s(%d): Length won't fit in DWORD.\n", __FILE__, __LINE__ );
	goto Error;
    }

    //
    // Then the total length is the length of the length plus the length
    // of the content.
    //

    pContext->ExpectedLength = sizeof(DWORD) + cbContent;

    if( !KtSetPduValue(pContext) ) /* TODO: this call should be elsewhere */
        goto Error;

#if 0 /* this will need to be added back in for udp support */
    cbLength = Asn1UtilDecodeLength( &cbContent,
				     &(pContext->emptybuf->buffer[1]),
				     pContext->emptybuf->bytesused - 1 );
    
    if( cbLength < 0 )
    {
	goto Error;
    }
    
    pContext->ExpectedLength = 1 + cbLength + cbContent;
#endif

Cleanup:
    return fRet;

Error:
    fRet = FALSE;
    goto Cleanup;
}

//+-------------------------------------------------------------------------
//
//  Function:   KtFindProxy
//
//  Synopsis:   Unpacks the AS or TGS request, examines the realm, and 
//              attempts to find some way to contact that realm using http,
//              first by looking on the Realms registry key, then by doing a
//              DNS SRV lookup.
//
//  Effects:    
//
//  Arguments:  
//
//  Requires:   
//
//  Returns:    rets
//
//  Notes:      
//
//--------------------------------------------------------------------------
BOOL
KtFindProxy(
    PKTCONTEXT pContext 
    )
{
    BOOL fRet = TRUE;
    PKERB_KDC_REQUEST pKdcReq = NULL;
    KERBERR KerbErr;
    HKEY RealmKey = NULL;
    LONG RegError;
    LPBYTE pbKdcBuffer = NULL;
    DWORD cbKdcBuffer = KT_INITIAL_KDCBUFFER_SIZE;
    DWORD cbKdcBufferWritten;
    LPWSTR RealmKeyName = NULL;
    LPWSTR WideRealm = NULL;
    ULONG ccRealm;
    int WideCharSuccess;

    //
    // Lets attempt to unpack the data into a struct.  
    // This call will allocate pKdcReq if successful.
    //

    KerbErr = KerbUnpackData( pContext->buffers->buffer + sizeof(DWORD),
			      pContext->buffers->bytesused - sizeof(DWORD),
			      pContext->PduValue,
			      (PVOID*)&pKdcReq );

    if( !KERB_SUCCESS(KerbErr) )
    {
	DebugLog( DEB_ERROR, "%s(%d): Kerberos Error unpacking ticket: 0x%x\n", __FILE__, __LINE__, KerbErr );
        goto Error;
    }

    DebugLog( DEB_TRACE, "%s(%d): Realm found to be %s.\n", __FILE__, __LINE__, pKdcReq->request_body.realm );

    //
    // This call discovers the number of wchars needed to hold 
    // the converted realmname.
    //

    ccRealm = strlen(pKdcReq->request_body.realm)*sizeof(WCHAR);

    //
    // Allocate memory to hold the wchar converted realm name, and
    // allocate memory to hold the full name of the registry key to 
    // peek at.
    //
    
    WideRealm = (LPWSTR)KtAlloc((ccRealm + 1)*sizeof(WCHAR));
    RealmKeyName = (LPWSTR)KtAlloc( sizeof(KT_REGKEY_REALMS) + ccRealm*sizeof(WCHAR) );

    if( !WideRealm || !RealmKeyName )
    {
	DebugLog( DEB_ERROR, "%s(%d): Allocation error.", __FILE__, __LINE__ );
        goto Error;
    }

    //
    // Copy the beginning of the realmkey.
    //

    wcscpy( RealmKeyName, KT_REGKEY_REALMS );

    //
    // Convert the realm to unicode.
    //

    WideCharSuccess = MultiByteToWideChar( CP_ACP,
                                           0,
                                           pKdcReq->request_body.realm,
                                           -1,
                                           WideRealm,
                                           ccRealm );

    if( !WideCharSuccess )
    {
        DebugLog( DEB_ERROR, "%s(%d): Error converting realm to unicode: 0x%x\n", __FILE__, __LINE__, GetLastError() );
        goto Error;
    }

    //
    // Concat the realm to the regkey to get the full key.
    //

    wcscat( RealmKeyName, WideRealm );

    //
    // Now we look in the registry to see if a kproxy 
    // server is provided for this realm.
    //

    /* TODO: All registry access should be moved to another file,
             read on startup, and cached. */

    RegError = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
			     RealmKeyName,
			     NULL, /* reserved */
			     KEY_QUERY_VALUE,
			     &RealmKey );

    if( RegError != ERROR_SUCCESS &&
	RegError != ERROR_FILE_NOT_FOUND )
    {
	DebugLog( DEB_ERROR, "%s(%d): Error opening regkey HKLM\\%ws: 0x%x.\n", __FILE__, __LINE__, KT_REGKEY_REALMS, RegError );
	fRet = FALSE;
	goto Cleanup;
    }

    //
    // If the registry key was there, read it. 
    //

    if( RegError == ERROR_SUCCESS )
    {
        //
        // There's no way to determine how much data is in the 
        // key, so we'll just try with increasing buffer sizes
        // until we succeed.
        //

        do
        {
            //
            // If we've already allocated memory, it must not have been enough,
            // so we need to free it then allocate the new amount of memory.
            // This should be faster than realloc, because realloc would copy
            // the memory if relocation were necessary.
            //

            if( pbKdcBuffer )
            {
                KtFree( pbKdcBuffer );
            }

            pbKdcBuffer = (LPBYTE)KtAlloc( cbKdcBuffer );

            if( !pbKdcBuffer )
            {
                DebugLog( DEB_ERROR, "%s(%d): Error allocating memory for reg values.\n", __FILE__, __LINE__ );
                goto Error;
            }

            //
            // Since RegQueryValueEx clobbers the size of our buffer if it
            // fails, we need to make sure we keep a good copy.
            //

            cbKdcBufferWritten = cbKdcBuffer;
    
            RegError = RegQueryValueEx( RealmKey,
                                        TEXT("KdcNames"),
                                        NULL, /* reserved */
                                        NULL, /* type is known: REG_MULTI_SZ */
                                        pbKdcBuffer,
                                        &cbKdcBufferWritten );
    
            if( RegError == ERROR_FILE_NOT_FOUND )
            {
                DebugLog( DEB_TRACE, "%s(%d): KdcNames key not found.\n", __FILE__, __LINE__ );
                break;
            }
    
            if( RegError != ERROR_SUCCESS &&
                RegError != ERROR_MORE_DATA )
            {
                DebugLog( DEB_ERROR, "%s(%d): Error querying regkey HKLM\\%ws\\%ws: 0x%x.\n", __FILE__, __LINE__, KT_REGKEY_REALMS, WideRealm, RegError );
                goto Error;
            }

        } while( RegError == ERROR_MORE_DATA &&
                 (cbKdcBuffer *= 2) );
    }

    //
    // If either the realm key wasn't found or for some reason there was
    // no KdcNames value, we'll use DNS SRV lookup.
    //

    if( RegError == ERROR_FILE_NOT_FOUND )
    {
	DebugLog( DEB_ERROR, "%s(%d): Registry key not found, and DNS SRV not yet implemented.\n", __FILE__, __LINE__ );
        goto Error;
    }

    DebugLog( DEB_TRACE, "%s(%d): First proxy found to be %ws.\n", __FILE__, __LINE__, pbKdcBuffer );
    pContext->pbProxies = pbKdcBuffer;
    pbKdcBuffer = NULL;

Cleanup:
    if( RealmKeyName )
	KtFree( RealmKeyName );
    if( WideRealm )
	KtFree( WideRealm );
    if( pbKdcBuffer )
	KtFree( pbKdcBuffer );
    if( RealmKey )
	RegCloseKey( RealmKey );
    if( pKdcReq )
	KerbFreeData( pContext->PduValue, pKdcReq );
    return fRet;

Error:
    fRet = FALSE;
    goto Cleanup;
}

//+-------------------------------------------------------------------------
//
//  Function:   KtParseKerbError
//
//  Synopsis:   Since it's difficult to understand sniffs of tunnelled
//              traffic, this routine allows for the on-the-fly parsing
//              of KERB_ERROR codes.  
//
//  Effects:    
//
//  Arguments:  pContext - context that has the message
//
//  Requires:   
//
//  Returns:    
//
//  Notes:      
//
//--------------------------------------------------------------------------
VOID
KtParseKerbError(
    PKTCONTEXT pContext
    )
{
    PKERB_ERROR pKerbError = NULL;
    KERBERR KerbErr;

    if( !(pContext->PduValue == KERB_ERROR_PDU) )
        goto Cleanup;

    KerbErr = KerbUnpackKerbError( pContext->emptybuf->buffer + sizeof(DWORD),
                                   pContext->ExpectedLength,
                                   &pKerbError );

    if( !KERB_SUCCESS(KerbErr) )
    {
        DebugLog( DEB_ERROR, "%s(%d): Found KERB_ERROR, but couldn't unpack: 0x%x\n", __FILE__, __LINE__, KerbErr );
        goto Cleanup;
    }

    DebugLog( DEB_ERROR, "%s(%d): KERB_ERROR.  Error code = 0x%x\n", __FILE__, __LINE__, pKerbError->error_code );
    if( pKerbError->bit_mask && error_text_present )
        DebugLog( DEB_ERROR, "%s(%d): KERB_ERROR, Error text = %s.\n", __FILE__, __LINE__, pKerbError->error_text );
    if( pKerbError->bit_mask && error_data_present )
        DebugLog( DEB_ERROR, "%s(%d): KERB_ERROR, Error data is present.\n", __FILE__, __LINE__ );

Cleanup:
    if( pKerbError )
        KerbFreeData( pContext->PduValue,
                      pKerbError );
}

//+-------------------------------------------------------------------------
//
//  Function:   KtIsAsRequest
//
//  Synopsis:   Determines if the message is an AS-REQUEST.
//
//  Effects:    
//
//  Arguments:  pContext - context that has the message
//
//  Requires:   
//
//  Returns:    TRUE if AS-REQUEST, otherwise FALSE.
//
//  Notes:      
//
//--------------------------------------------------------------------------
BOOL
KtIsAsRequest(
    PKTCONTEXT pContext
    )
{
    return (pContext->PduValue == KERB_AS_REQUEST_PDU);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\ktunnel\kthttp.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation
//
// File:        kthttp.cxx
//
// Contents:    Kerberos Tunneller, http communication routines
//
// History:     28-Jun-2001	t-ryanj		Created
//
//------------------------------------------------------------------------
#include "ktdebug.h"
#include "kthttp.h"
#include "ktcontrol.h"
#include "ktkerb.h"

#if 0 /* Unneeded for now since http is running sync */
VOID CALLBACK KtHttpCallback( 
    IN HINTERNET hInternet,
    IN DWORD_PTR dwContext,
    IN DWORD dwInternetStatus,
    IN LPVOID lpvStatusInformation,
    IN DWORD dwStatusInformationLength
    );
#endif

//#define KT_HTTP_AGENT_STRING TEXT("Kerbtunnel")
//#define KT_KERBPROXY_LOCATION TEXT("/kerberos-KDC/kerbproxy.dll")
TCHAR KT_HTTP_AGENT_STRING[] = TEXT("Kerbtunnel");
TCHAR KT_KERBPROXY_LOCATION[] = TEXT("/kerberos-KDC/kerbproxy.dll");
LPCTSTR KT_MIMETYPES_ACCEPTED[] = { TEXT("*/*"), NULL };

HINTERNET KtInternet = NULL;

//+-------------------------------------------------------------------------
//
//  Function:   KtInitHttp
//
//  Synopsis:   Performs necessary initialization for use of http
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:    Success value.  If FALSE, GetLastError() for details.
//
//  Notes:      
//
//--------------------------------------------------------------------------
BOOL 
KtInitHttp(
    VOID
    )
{
    BOOL fSuccess = TRUE;

    DsysAssert(KtInternet == NULL );
    KtInternet = InternetOpen( KT_HTTP_AGENT_STRING,
			       INTERNET_OPEN_TYPE_PRECONFIG, 
			       NULL,
			       NULL,
			       0 );
    if( KtInternet == NULL )
    {
	DebugLog( DEB_ERROR, "%s(%d): Error initializing internet routines: 0x%x.\n", __FILE__, __LINE__, GetLastError() );
	goto Error;
    }

Cleanup:
    return fSuccess;

Error:
    KtCleanupHttp();
    fSuccess = FALSE;
    goto Cleanup;
}

//+-------------------------------------------------------------------------
//
//  Function:   KtCleanupHttp
//
//  Synopsis:   Performs necessary cleanup after use of http
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:    
//
//  Notes:      
//
//--------------------------------------------------------------------------
VOID
KtCleanupHttp(
    VOID
    )
{
    if( KtInternet )
    {
	InternetCloseHandle(KtInternet);
        KtInternet = NULL;
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   KtHttpWrite
//
//  Synopsis:   Opens a connection to the kerbproxy server, creates a POST
//		request, and writes the contents of the context buffer as
//		the request body.
//
//  Effects:
//
//  Arguments:  pContext - A context.
//
//  Requires:
//
//  Returns:    Success value.  If FALSE, GetLastError() for details.
//
//  Notes:      
//
//--------------------------------------------------------------------------
BOOL
KtHttpWrite(
    PKTCONTEXT pContext
    )
{
    HINTERNET hConnect = NULL;
    HINTERNET hRequest = NULL;
    BOOL SendSuccess;
    BOOL IocpSuccess;
    BOOL fRet = TRUE;
    INTERNET_PORT InternetPort = INTERNET_DEFAULT_HTTP_PORT;
    
    DebugLog( DEB_TRACE, "%s(%d): Sending %d bytes over http.\n", __FILE__, __LINE__, pContext->buffers->bytesused );

#if 0
    //
    // Use SSL for AS-REQUEST
    //
    
    if( KtIsAsRequest( pContext ) )
	InternetPort = INTERNET_DEFAULT_HTTPS_PORT;
#endif

    //
    // TODO: Add logic so that it tries all the servers in the list.
    //

    //
    // Open a connection to the kerbproxy server and store it in the context.
    // 

    hConnect = InternetConnect( KtInternet,
				(LPCWSTR)pContext->pbProxies,
				InternetPort,
				NULL,
				NULL,
				INTERNET_SERVICE_HTTP,
				0,
				INTERNET_FLAG_ASYNC );
    if( !hConnect )
    {
	DebugLog( DEB_ERROR, "%s(%d): Error connecting to server: 0x%x.\n", __FILE__, __LINE__, GetLastError() );
        goto Error;
    }
    pContext->hConnect = hConnect;
    hConnect = NULL;

    //
    // Open a POST request to the kerbproxy object and store it in the context.
    //

    hRequest = HttpOpenRequest( pContext->hConnect,
				TEXT("POST"),
				KT_KERBPROXY_LOCATION,
				NULL, /* version */
				NULL, /* referrer */
				KT_MIMETYPES_ACCEPTED,
				0,
				0 );
    if( !hRequest )
    {
	DebugLog(DEB_ERROR, "%s(%d): Error opening %ws%ws: 0x%x.\n", __FILE__, __LINE__, pContext->pbProxies, KT_KERBPROXY_LOCATION, GetLastError() );
        goto Error;
    }
    pContext->hRequest = hRequest;
    hRequest = NULL;
    
    //
    // Send the results from reading off the user socket as the request body.
    //

#if 0 /* unnecessary, as synchronous ops are being used now. */
    InternetSetStatusCallback( hConnect,
			       KtHttpCallback );
#endif

    pContext->Status = KT_HTTP_WRITE;
    SendSuccess = HttpSendRequest( pContext->hRequest,
                                   NULL,
                                   0,
				   pContext->buffers->buffer,
				   pContext->buffers->bytesused );
    if( !SendSuccess /*&& (GetLastError() != ERROR_IO_PENDING)*/ )
    {
	DebugLog(DEB_ERROR, "%s(%d): Error from sendrequest: 0x%x.\n", __FILE__, __LINE__, GetLastError() );
        goto Error;
    }

    //
    // Since this is being done synchronously right now, we need to post to 
    // the iocp in order to progress to the next step.
    //

    IocpSuccess = PostQueuedCompletionStatus( KtIocp,
					      0,
					      KTCK_CHECK_CONTEXT,
					      &(pContext->ol) );
    if( !IocpSuccess )
    {
	DebugLog(DEB_ERROR, "%s(%d): Error posting to completion port: 0x%x.\n", __FILE__, __LINE__, GetLastError() );
        goto Error;
    }

Cleanup:
    return fRet;

Error:
    fRet = FALSE;
    goto Cleanup;
}


//+-------------------------------------------------------------------------
//
//  Function:   KtHttpRead
//
//  Synopsis:   Reads the response to the request sent by KtHttpWrite into 
//		the context buffer. 
//
//  Effects:
//
//  Arguments:  pContext - A context.
//
//  Requires:
//
//  Returns:    Success value.  If FALSE, GetLastError() for details.
//
//  Notes:      
//
//--------------------------------------------------------------------------
BOOL
KtHttpRead(
    PKTCONTEXT pContext
    )
{
    BOOL EndSuccess;
    BOOL ReadSuccess;
    BOOL fRet = TRUE;
    BOOL IocpSuccess;
    
    DebugLog( DEB_PEDANTIC, "%s(%d): Reading up to %d bytes from http.\n", __FILE__, __LINE__, pContext->emptybuf->buflen );

    //
    // Read the response from the kerbproxy server.
    //

    pContext->Status = KT_HTTP_READ;
    ReadSuccess = InternetReadFile( pContext->hRequest,
				    pContext->emptybuf->buffer,
				    pContext->emptybuf->buflen,
				    &(pContext->emptybuf->bytesused) );

    if( !ReadSuccess )
    {
	DebugLog(DEB_ERROR, "%s(%d): Error from readfile: 0x%x.\n", __FILE__, __LINE__, GetLastError() );
	goto Error;
    }

    //
    // Since we're doing this synchronously, we need to post to the iocp 
    // manually to move on.
    //
    
    IocpSuccess = PostQueuedCompletionStatus( KtIocp,
                                              0,
                                              KTCK_CHECK_CONTEXT,
                                              &(pContext->ol) );
    if( !IocpSuccess )
    {
        DebugLog( DEB_ERROR, "%s(%d): Error for PQCS: 0x%x\n", __FILE__, __LINE__, GetLastError() );
        goto Error;
    }

Cleanup:    
    return fRet;

Error:
    fRet = FALSE;
    goto Cleanup;
}


#if 0 /* Unneccessary because using synchronous calls for now */
//+-------------------------------------------------------------------------
//
//  Function:   KtHttpCallback
//
//  Synopsis:   Callback function for asynchronous http functions.
//
//  Effects:
//
//  Arguments:  hInternet - connection appropriate to this callback
//		pContext - context supplied at the time of the async call
//		dwInternetStatus - why the callback was called
//		lpvStatusInformation - more detailed info
//		dwStatusInformationLength - length of *lpvStatusInformation
//
//  Requires:
//
//  Returns:    
//
//  Notes:      Not being used right now, as synchronous wininet calls are 
//		being used, since it is not entirely clear how to do the 
//		asynchronous calls in all cases.
//
//--------------------------------------------------------------------------
VOID CALLBACK KtHttpCallback( 
    IN HINTERNET hInternet,
    IN DWORD_PTR pContext,
    IN DWORD dwInternetStatus,
    IN LPVOID lpvStatusInformation,
    IN DWORD dwStatusInformationLength
    )
{
    BOOL IocpSuccess;

    if( dwInternetStatus == INTERNET_STATUS_REQUEST_COMPLETE )
    {
	IocpSuccess = PostQueuedCompletionStatus( KtIocp,
						  0,
						  KTCK_CHECK_CONTEXT,
						  &(((PKPCONTEXT)pContext)->ol) );
	if( !IocpSuccess )
        {
	    DebugLog( DEB_ERROR, "%s(%d): Error in PQCS: 0x%x.\n", __FILE__, __LINE__, GetLastError() );
	    KtReleaseContext( (PKTCONTEXT)pContext );
	}
    }
    else 
    {
	DebugLog( DEB_TRACE, "This httpcallback status: 0x%x.\n", dwInternetStatus );
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\parser\asn1abuffer.cxx ===
//=============================================================================
//
//  MODULE: ASN1ABuffer.cxx
//
//  Description:
//
//  Implementation of ASN.1 address buffer parsing logic
//
//  Modification History
//
//  Mark Pustilnik              Date: 06/08/02 - created
//
//=============================================================================

#include "ASN1Parser.hxx"
#include <stdio.h>

DWORD
ASN1ParserAddressBuffer::ParseBlob(
    IN OUT ASN1VALUE * Value
    )
{
    DWORD dw = ERROR_SUCCESS;
    ASN1VALUE * Modifier = QueryModifier();

    if ( Modifier == NULL )
    {
        return ERROR_INTERNAL_ERROR;
    }

    if ( Modifier->ut != utInteger )
    {
        return ERROR_INTERNAL_ERROR;
    }

    switch ( Modifier->dw )
    {
    case KERB_ADDRTYPE_NETBIOS:

        //
        // Nothing special, just make it obvious this is not a binary blob
        // but a real string we're dealing with
        //

        Value->ut = utGeneralString;
        break;

    case KERB_ADDRTYPE_INET:
    {
        if ( Value->string.l >= 4 )
        {
            ULPBYTE IPv4 = new BYTE[sizeof("255.255.255.255")];

            if ( IPv4 == NULL )
            {
                dw = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            _snprintf(
                (char *)IPv4,
                sizeof("255.255.255.255"),
                "%d.%d.%d.%d",
                (DWORD)Value->string.s[0],
                (DWORD)Value->string.s[1],
                (DWORD)Value->string.s[2],
                (DWORD)Value->string.s[3]
                );

            if ( Value->Allocated )
            {
                delete [] Value->string.s;
            }

            Value->ut = utGeneralString;
            Value->Allocated = TRUE;
            Value->string.s = IPv4;
            Value->string.l = strlen((const char *)IPv4);
        }

        break;
    }

    //
    // TODO: add parsers for more address types (x25, IPv6, etc.)
    //

    default:

        //
        // Leave as is
        //

        break;
    }

    return dw;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\ktunnel\ktsock.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation
//
// File:        ktsock.h
//
// Contents:    Kerberos Tunneller, socket operations
//		Entrypoint prototypes and shared struct/enum defs.
//
// History:     28-Jun-2001	t-ryanj		Created
//
//------------------------------------------------------------------------
#ifndef __KTSOCK_H__
#define __KTSOCK_H__

#include <windows.h>
#include <tchar.h>
#include "ktcontext.h"

BOOL 
KtInitWinsock(
    VOID
    );

VOID 
KtCleanupWinsock(
    VOID
    );

BOOL 
KtStartListening(
    VOID
    );

VOID 
KtStopListening(
    VOID
    );

BOOL 
KtSockAccept( 
    VOID 
    );

BOOL 
KtSockCompleteAccept( 
    IN PKTCONTEXT pContext 
    );

BOOL 
KtSockRead( 
    IN PKTCONTEXT pContext 
    );

BOOL 
KtSockWrite( 
    IN PKTCONTEXT pContext 
    ); 

#endif // __KTSOCK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\ktunnel\ktmem.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation
//
// File:        kpmem.cxx
//
// Contents:    Prototypes for Routines to wrap memory allocation, etc.
//
// History:     10-Jul-2001     t-ryanj         Created
//
//------------------------------------------------------------------------
#include <windows.h>
#include <rpc.h>

#ifndef __KTMEM_H__
#define __KTMEM_H__

BOOL
KtInitMem(
    VOID
    );

VOID
KtCleanupMem(
    VOID
    );

PVOID
KtAlloc(
    SIZE_T size
    );

VOID
KtFree(
    PVOID buf
    );

PVOID
KtReAlloc(
    PVOID buf,
    SIZE_T size 
    );

#endif // __KTMEM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\parser\asn1bitstring.cxx ===
//=============================================================================
//
//  MODULE: ASN1BitString.cxx
//
//  Description:
//
//  Implementation of ASN.1 bit string parsing logic
//
//  Modification History
//
//  Mark Pustilnik              Date: 06/08/02 - created
//
//=============================================================================

#include "ASN1Parser.hxx"

//
// Retrieve the value of an ASN.1-encoded bit string
//

DWORD
ASN1ParserBitString::GetValue(
    IN OUT ASN1FRAME * Frame,
    OUT ASN1VALUE * Value
    )
{
    DWORD dw;
    ASN1FRAME FrameIn = *Frame;
    DWORD DLength = DataLength( Frame );
    ULPBYTE Address = Frame->Address;

    if ( *Frame->Address != BuildDescriptor(
                                ctUniversal,
                                pcPrimitive,
                                (BYTE)utBitString ))
    {
        dw = ERROR_INVALID_USER_BUFFER;
        goto Cleanup;
    }

    //
    // Skip over the the descriptor
    //

    Address++;

    //
    // Skip over the length header
    //

    Address += HeaderLength( Address );

    Value->Address = Address;
    Value->Length = DLength;
    Value->ut = utBitString;
    Value->dw = 0;

    //
    // NOTE: Netmon bitstring display facility does not seem to handle anything
    //       longer than 4 bytes, but that's all we need in Kerberos anyway
    //

    for ( ULONG i = 0; i < DLength; i++ )
    {
        Value->dw <<= 8;
        Value->dw += *Address;
        Address++;
    }

    //
    // Mask off the bits we don't care about by making use of the bitmask
    //

    Value->dw &= m_BitMask;

    Frame->Address = Address;

    dw = ERROR_SUCCESS;

Cleanup:

    if ( dw != ERROR_SUCCESS )
    {
        *Frame = FrameIn;
    }

    return dw;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\parser\asn1boolean.cxx ===
//=============================================================================
//
//  MODULE: ASN1Boolean.cxx
//
//  Description:
//
//  Implementation of ASN.1 boolean parsing logic
//
//  Modification History
//
//  Mark Pustilnik              Date: 06/08/02 - created
//
//=============================================================================

#include "ASN1Parser.hxx"

//
// Retrieve the value of an ASN.1-encoded Boolean
//

DWORD
ASN1ParserBoolean::GetValue(
    IN OUT ASN1FRAME * Frame,
    OUT ASN1VALUE * Value
    )
{
    DWORD dw;
    ASN1FRAME FrameIn = *Frame;
    DWORD DLength = DataLength( Frame );
    ULPBYTE Address = Frame->Address;

    if ( *Frame->Address != BuildDescriptor(
                                ctUniversal,
                                pcPrimitive,
                                (BYTE)utBoolean ))
    {
        dw = ERROR_INVALID_USER_BUFFER;
        goto Cleanup;
    }

    //
    // Skip over the the descriptor
    //

    Address++;

    //
    // Skip over the length header
    //

    Address += HeaderLength( Address );

    Value->Address = Address;
    Value->Length = DLength;
    Value->ut = utBoolean;
    Value->dw = 0;

    for ( ULONG i = 0; i < DLength; i++ )
    {
        Value->dw <<= 8;
        Value->dw += *Address;
        Address++;
    }

    Value->b = ( Value->dw != 0 );

    Frame->Address = Address;

    dw = ERROR_SUCCESS;

Cleanup:

    if ( dw != ERROR_SUCCESS )
    {
        *Frame = FrameIn;
    }

    return dw;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\parser\asn1base.cxx ===
//=============================================================================
//
//  MODULE: ASN1Base.cxx
//
//  Description:
//
//  Implementation of the ASN1ParserBase class
//
//  Modification History
//
//  Mark Pustilnik              Date: 06/09/02 - created
//
//=============================================================================

#include "ASN1Parser.hxx"

//
// For a frame which starts with 6a 82 01 30 ... (long form)
//
//     82 (*(Frame+1)) indicates "long form" where Size is 2 (0x82 & 0x7F)
//     and the return value is ( 0x01 << 8 ) | 0x30 = 0x130
//
// For a frame which starts with 6a 30 ... (short form)
//
//     the return value is simply 0x30
//

DWORD
ASN1ParserBase::DataLength(
    IN ASN1FRAME * Frame
    )
{
    LPBYTE LengthPortion = Frame->Address + 1;

    if ( *LengthPortion & 0x80 ) // long form
    {
        USHORT i;
        DWORD Sum = 0;
        BYTE Size = *LengthPortion & 0x7F;

        for ( i = 1; i <= Size; i++ )
        {
            Sum <<= 8;
            Sum |= *(LengthPortion + i);
        }

        return Sum;
    }
    else // short form
    {
        return  *LengthPortion;
    }
}

//
// Calculates the length of the length header in either short or long form
// Returns '3' for "82 01 30"
// Returns '1' for "30"
//

ULONG
ASN1ParserBase::HeaderLength(
    IN ULPBYTE Address
    )
{
    if ( *Address & 0x80 )
    {
        //
        // If long form, assign size to value of bits 7-1
        //

        return ( 1 + *Address & 0x7F);
    }
    else
    {
        //
        // Short form only takes one octet
        //

        return 1;
    }
}

//
// Verifies that the frame is pointing at the type of item we expect by
// performing a descriptor comparison, then moves past the descriptor and
// the length header.  The caller uses this to point the frame at the next
// item to be parsed.
//

DWORD
ASN1ParserBase::VerifyAndSkipHeader(
    IN OUT ASN1FRAME * Frame
    )
{
    DWORD dw;

    //
    // Check both optional descriptors associated with this frame
    //

    BYTE Descriptors[2] = { m_Descriptor, m_AppDescriptor };

    for ( ULONG i = 0; i < ARRAY_COUNT( Descriptors ); i++ )
    {
        if ( Descriptors[i] != 0 )
        {
            //
            // Verify the descriptor and bail on mismatch
            //

            if ( *Frame->Address != Descriptors[i] )
            {
                dw = ERROR_INVALID_USER_BUFFER;
                goto Cleanup;
            }

            //
            // Skip over the descriptor
            //

            Frame->Address++;

            //
            // Skip over the length header
            //

            Frame->Address += HeaderLength( Frame->Address );
        }
    }

    dw = ERROR_SUCCESS;

Cleanup:

    return dw;
}

//
// Displays the value of the unit, mapping between the ASN.1 encoding and the
// actual parsed-out value as necessary
//

DWORD
ASN1ParserBase::Display(
    IN ASN1FRAME * Frame,
    IN ASN1VALUE * Value,
    IN HPROPERTY hProperty,
    IN DWORD IFlags
    )
{
    DWORD dw = ERROR_SUCCESS;
    DWORD Length;
    ULPVOID Address;

    switch( Value->ut )
    {
    case utGeneralizedTime:

        Length = sizeof( Value->st );
        Address = &Value->st;
        break;

    case utBoolean:

        Length = sizeof( Value->b );
        Address = &Value->b;
        break;

    case utInteger:
    case utBitString:

        //
        // ASN.1 integers are optimally encoded using the fewest number of bytes
        // This does not bode well with Netmon which insists on knowing how long
        // a value is before displaying it.  The mapping below will show both
        // the raw buffer and the corresponding value properly
        //

        Length = sizeof( Value->dw );
        Address = &Value->dw;
        break;

    case utGeneralString:
    case utOctetString:

        if ( Value->string.l == 0 )
        {
            Address = "<empty string>";
            Length = strlen(( const char * )Address );
        }
        else
        {
            Address = Value->string.s;
            Length = Value->string.l;
        }
        break;

    default:

        //
        // By default, display unadulterated raw data pointed to by 'Value'
        //

        Length = Value->Length;
        Address = Value->Address;
    }

    if ( FALSE == AttachPropertyInstanceEx(
                      Frame->hFrame,
                      hProperty,
                      Value->Length,
                      Value->Address,
                      Length,
                      Address,
                      0,
                      Frame->Level,
                      IFlags ))
    {
        dw = ERROR_CAN_NOT_COMPLETE;
    }

    return dw;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\ktunnel\ktsock.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation
//
// File:        ktsock.cxx
//
// Contents:    Kerberos Tunneller, socket operations
//
// History:     28-Jun-2001	t-ryanj		Created
//
//------------------------------------------------------------------------
#include <Winsock2.h>
#include <Mswsock.h>
#include "ktdebug.h"
#include "ktsock.h"
#include "ktcontrol.h"
#include "ktmem.h"
#include "ktkerb.h"

#define KDC_SERVICE_NAME "kerberos"
#define KDC_FALLBACK_PORT 88

SHORT KtListenPort;
SOCKET KtListenSocket = INVALID_SOCKET;
BOOL KtWSAStarted = FALSE;

VOID
KtInitListenPort(
    VOID
    )
{
    PSERVENT krb5;

    //
    // Ask winsock what port kerberos works on.  This should be defined in 
    // %systemroot%\system32\drivers\etc\services 
    // Note that winsock manages the servent struct, we don't need to free it.
    //

    if( krb5 = getservbyname( KDC_SERVICE_NAME, NULL ) )
    {
        KtListenPort = krb5->s_port;
    }
    else
    {
        DebugLog( DEB_WARN, "%s(%d): Could not determine kerberos port; falling back to port %d.\n", __FILE__, __LINE__, KDC_FALLBACK_PORT );
        KtListenPort = htons( KDC_FALLBACK_PORT );
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   KtInitWinsock
//
//  Synopsis:   Starts winsock
//
//  Effects:
//
//  Arguments:  
//
//  Requires:
//
//  Returns:    Success value.  If FALSE, GetLastError() for details.
//
//  Notes:
//
//
//--------------------------------------------------------------------------
BOOL
KtInitWinsock(
    VOID 
    )
{
    WORD wWinsockVersionRequested = MAKEWORD( 2,2 );
    WSADATA wsaData;
    DWORD WSAStartError;

    DsysAssert(!KtWSAStarted);
    WSAStartError = WSAStartup( wWinsockVersionRequested, &wsaData );
    if( WSAStartError == SOCKET_ERROR )
    {
	DebugLog( DEB_ERROR, "%s(%d): Error starting winsock: 0x%x.\n", __FILE__, __LINE__, WSAGetLastError() );
        SetLastError(WSAGetLastError());
	goto Cleanup;
    }

    KtInitListenPort();

    KtWSAStarted = TRUE;

Cleanup:
    return KtWSAStarted;
}

//+-------------------------------------------------------------------------
//
//  Function:   KtCleanupWinsock
//
//  Synopsis:   Call WSACleanup, but only if winsock has been started.
//
//  Effects:
//
//  Arguments:  
//
//  Requires:
//
//  Returns:    
//
//  Notes:      If WSA isn't started, quietly do nothing.
//
//
//--------------------------------------------------------------------------
VOID
KtCleanupWinsock(
    VOID
    )
{
    if( KtWSAStarted )
    {
	WSACleanup();
        KtWSAStarted = FALSE;
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   KtStartListening
//
//  Synopsis:   Starts listening for connections
//
//  Effects:    Initializes KtListenSocket.
//
//  Arguments:  
//
//  Requires:
//
//  Returns:    Success value, if FALSE GetLastError() for details.
//
//  Notes:
//
//
//--------------------------------------------------------------------------
BOOL
KtStartListening(
    VOID
    )
{
    BOOL fRet = TRUE;
    DWORD LastError;
    BOOL IocpSuccess;
    sockaddr_in sa;

    //
    // Initialize the address want to bind to.
    //

    sa.sin_family = AF_INET;
    sa.sin_port = KtListenPort; 
    sa.sin_addr.S_un.S_addr = 0x0100007f; /* 127.0.0.1 :: loopback */
    
    //
    // Create the socket
    //

    DsysAssert(KtListenSocket==INVALID_SOCKET);
    KtListenSocket = socket( AF_INET, SOCK_STREAM, IPPROTO_TCP );
    if( KtListenSocket == INVALID_SOCKET )
    {
	SetLastError(WSAGetLastError());
	DebugLog( DEB_ERROR, "%s(%d): Error creating listen socket: 0x%x.\n", __FILE__, __LINE__, GetLastError() );
	goto Error;
    }

    //
    // Bind it to the interface
    //

    LastError = bind( KtListenSocket, (sockaddr*)&sa, sizeof(sa) );
    if( LastError == SOCKET_ERROR ) 
    {
	SetLastError(WSAGetLastError());
	DebugLog( DEB_ERROR, "%s(%d): Error binding listen socket: 0x%x.\n", __FILE__, __LINE__, GetLastError() );
	goto Error;
    }

    //
    // Start Listening
    //

    LastError = listen( KtListenSocket, SOMAXCONN );
    if( LastError == SOCKET_ERROR )
    {
	SetLastError(WSAGetLastError());
	DebugLog( DEB_ERROR, "%s(%d): Error listening on listen socket: 0x%x.\n", __FILE__, __LINE__, GetLastError() );
	goto Error;
    }

    //
    // Associate the listen socket with the completion i/o port
    //
    
    IocpSuccess = (KtIocp == CreateIoCompletionPort( (HANDLE)KtListenSocket, 
						     KtIocp, 
						     KTCK_CHECK_CONTEXT, 
						     0 ));
    if( !IocpSuccess )
    {
	DebugLog( DEB_ERROR, "%s(%d): Could not associate listen socket with iocp: 0x%x.\n", __FILE__, __LINE__, GetLastError() );
	goto Error;
    }
    
    //
    // Issue an accept
    //
    
    if( !KtSockAccept() )
	goto Error;

Cleanup:    
    return fRet;

Error:
    fRet = FALSE;
    goto Cleanup;
}

//+-------------------------------------------------------------------------
//
//  Function:   KtStopListening
//
//  Synopsis:   Stops listening for new connections.
//
//  Effects:
//
//  Arguments:  
//
//  Requires:
//
//  Returns:    
//
//  Notes:      If the listen socket isn't valid, quietly do nothing. 
//
//
//--------------------------------------------------------------------------
VOID
KtStopListening(
    VOID
    )
{
    if( KtListenSocket != INVALID_SOCKET )
    {
	closesocket(KtListenSocket);
	KtListenSocket = INVALID_SOCKET;
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   KtSockAccept
//
//  Synopsis:   Issues a new AcceptEx on KtListenSocket.
//
//  Effects:    
//
//  Arguments:  
//
//  Requires:
//
//  Returns:    Success value.  If FALSE, GetLastError() for details.
//
//  Notes:
//
//--------------------------------------------------------------------------
BOOL
KtSockAccept(
    VOID
    )
{
    BOOL fRet = TRUE;
    BOOL AcceptSuccess;
    DWORD LastError;
    PKTCONTEXT pContext = NULL;
    SOCKET sock = INVALID_SOCKET;

    // 
    // Create a socket.
    //
    
    sock = socket( AF_INET, SOCK_STREAM, IPPROTO_TCP );
    if( sock == INVALID_SOCKET )
    {
	SetLastError(WSAGetLastError());
	DebugLog( DEB_ERROR, "%s(%d): Error creating client socket: 0x%x.\n", __FILE__, __LINE__, GetLastError() );
	goto Error;
    }

    // 
    // Create a new context
    //

    pContext = KtAcquireContext( sock, KTCONTEXT_BUFFER_LENGTH );
    if( !pContext )
	goto Error;

    sock = INVALID_SOCKET;

    //
    // Mark for a connect operation, and use AcceptEx to issue an overlapped
    // accept on the socket.
    //
    
    pContext->Status = KT_SOCK_CONNECT;
    
    AcceptSuccess = AcceptEx( KtListenSocket,
			      pContext->sock,
			      pContext->emptybuf->buffer, /* docbug: contrary to msdn, NULL here doesn't work */
			      0,
			      sizeof( sockaddr_in ) + 16, /* these addrs require 16 bytes   */
			      sizeof( sockaddr_in ) + 16, /* of padding - see AcceptEx msdn */
			      NULL,
			      &(pContext->ol) );
    if( !AcceptSuccess && (WSAGetLastError() != ERROR_IO_PENDING) )
    {
        SetLastError(WSAGetLastError());
	DebugLog( DEB_ERROR, "%s(%d): Error issuing accept: 0x%x.\n", __FILE__, __LINE__, GetLastError() );
	goto Error;
    }

Cleanup:    
    return fRet;

Error:
    if( sock != INVALID_SOCKET )
	closesocket(sock);

    if( pContext )
	KtReleaseContext( pContext );

    fRet = FALSE;
    goto Cleanup;
}

//+-------------------------------------------------------------------------
//
//  Function:   KtSockCompleteAccept
//
//  Synopsis:   Associates a new connection with the iocp.
//
//  Effects:
//
//  Arguments:  pContext - Contains the info on the connection.
//
//  Requires:
//
//  Returns:    Success value.  If FALSE, GetLastError() for details.
//
//  Notes:      
//
//
//--------------------------------------------------------------------------
BOOL
KtSockCompleteAccept(
    IN PKTCONTEXT pContext
    )
{
    DWORD LastError;
    BOOL IocpSuccess;

    //
    // Associate the newly accepted socket with the completion port.
    //

    IocpSuccess = (KtIocp == CreateIoCompletionPort( (HANDLE)pContext->sock, 
						     KtIocp, 
						     KTCK_CHECK_CONTEXT, 
						     0 ) );
    if( !IocpSuccess )
    {
	DebugLog( DEB_ERROR, "%s(%d): Error associating client socket with completion port: 0x%x.\n", __FILE__, __LINE__, GetLastError() );
	goto Cleanup;
    }

    DebugLog( DEB_TRACE, "%s(%d): Accepted new connection.\n", __FILE__, __LINE__ );

Cleanup:
    return IocpSuccess;
}

//+-------------------------------------------------------------------------
//
//  Function:   KtSockRead
//
//  Synopsis:   Issues a Read.
//
//  Effects:
//
//  Arguments:  pContext -
//
//  Requires:
//
//  Returns:    Success value.  If FALSE, GetLastError() for details.
//
//  Notes:
//
//
//--------------------------------------------------------------------------
BOOL
KtSockRead(
    IN PKTCONTEXT pContext
    )
{
    BOOL fRet = TRUE;
    BOOL ReadFileSuccess;
    
    // 
    // Zero the overlapped structure.
    //

    ZeroMemory( &(pContext->ol), sizeof(OVERLAPPED) );
    
    //
    // Mark for a read and use ReadFile to issue an overlapped read.
    //

    pContext->Status = KT_SOCK_READ;

    ReadFileSuccess = ReadFile( (HANDLE)pContext->sock,
				pContext->emptybuf->buffer,
				pContext->emptybuf->buflen,
				NULL,
				&(pContext->ol) );
    if( !ReadFileSuccess )
    {
	if( GetLastError() != ERROR_IO_PENDING )
	{
	    DebugLog( DEB_ERROR, "%s(%d): Error issuing read: 0x%x.\n", __FILE__, __LINE__, GetLastError() );
	    goto Error;
	}
    }

Cleanup:
    return fRet;

Error:
    fRet = FALSE;
    goto Cleanup;
}

//+-------------------------------------------------------------------------
//
//  Function:   KtSockWrite
//
//  Synopsis:   Issues a write.
//
//  Effects:
//
//  Arguments:  pContext - 
//
//  Requires:
//
//  Returns:    Success value.  If FALSE, GetLastError() for details.
//
//  Notes:
//
//
//--------------------------------------------------------------------------
BOOL
KtSockWrite(
    IN PKTCONTEXT pContext 
    )
{
    BOOL fRet = TRUE;
    BOOL WriteFileSuccess;
    ULONG cbNeeded;

    //
    // Zero the overlapped
    //

    ZeroMemory( &(pContext->ol), sizeof(OVERLAPPED) );
    
    //
    // Mark for Write and issue overlapped Write with WriteFile
    //

    pContext->Status = KT_SOCK_WRITE;

    WriteFileSuccess = WriteFile( (HANDLE)pContext->sock,
				  pContext->buffers->buffer,
				  pContext->buffers->buflen,
				  NULL, /* bytes written - not used in async */
				  &(pContext->ol) );
    if( !WriteFileSuccess )
    {
	if( GetLastError() != ERROR_IO_PENDING )
	{
	    DebugLog( DEB_ERROR, "%s(%d): Error issuing write: 0x%x.\n", __FILE__, __LINE__, GetLastError() );
	    goto Error;
	}
    }

Cleanup:
    return fRet;

Error:
    fRet = FALSE;
    goto Cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\parser\asn1edata.cxx ===
//=============================================================================
//
//  MODULE: ASN1EData.cxx
//
//  Description:
//
//  Implementation of ASN.1 address error data parsing logic
//
//  Modification History
//
//  Mark Pustilnik              Date: 06/18/02 - created
//
//=============================================================================

#include "ASN1Parser.hxx"

DWORD
ASN1ParserErrorData::ParseBlob(
    IN OUT ASN1VALUE * Value
    )
{
    DWORD dw = ERROR_SUCCESS;
    ASN1VALUE * Modifier = QueryModifier();

    if ( Modifier == NULL )
    {
        return ERROR_INTERNAL_ERROR;
    }

    if ( Modifier->ut != utInteger )
    {
        return ERROR_INTERNAL_ERROR;
    }

    switch ( Modifier->dw )
    {
    case KDC_ERR_ETYPE_NOTSUPP:
    case KDC_ERR_PREAUTH_REQUIRED:
    case KDC_ERR_PREAUTH_FAILED:

        Value->SubParser = new ASN1ParserPaDataSequence(
                                   FALSE,
                                   0,
                                   PROP( KERB_PREAUTH_DATA_LIST ));

        break;

    default:

        //
        // Leave as is
        //

        break;
    }

    return dw;
}


DWORD
ASN1ParserKerbEtypeInfoEntry::DisplayCollectedValues(
    IN ASN1FRAME * Frame,
    IN ULONG Length,
    IN ULPBYTE Address
    )
{
    DWORD dw;
    ASN1VALUE * EncryptionType;
    ASN1VALUE * Salt;
    ASN1VALUE * Integer;

    if ( QueryCollectedCount() != 3 )
    {
        dw = ERROR_INTERNAL_ERROR;
        goto Cleanup;
    }

    EncryptionType = QueryCollectedValue( 0 );
    Salt = QueryCollectedValue( 1 );
    Integer = QueryCollectedValue( 2 );

    if ( EncryptionType->ut != utInteger )
    {
        dw = ERROR_INTERNAL_ERROR;
        goto Cleanup;
    }

    if ( Salt &&
         Salt->ut != utOctetString &&
         Salt->ut != utGeneralString )
    {
        dw = ERROR_INTERNAL_ERROR;
        goto Cleanup;
    }

    dw = Display(
             Frame,
             EncryptionType,
             PROP( KERB_ETYPE_INFO_ENTRY_encryption_type ),
             0
             );

    if ( dw != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    if ( Salt || Integer )
    {
        Frame->Level += 1;

        if ( Salt )
        {
            dw = Display(
                     Frame,
                     Salt,
                     PROP( KERB_ETYPE_INFO_ENTRY_salt ),
                     0
                     );
        }

        if ( Integer &&
             dw == ERROR_SUCCESS )
        {
            dw = Display(
                     Frame,
                     Integer,
                     PROP( INTEGER_NOT_IN_ASN ),
                     0
                     );
        }

        Frame->Level -= 1;
    }

    if ( dw != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

Cleanup:

    return dw;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\parser\asn1haddress.cxx ===
//=============================================================================
//
//  MODULE: ASN1HAddress.cxx
//
//  Description:
//
//  Implementation of host address parsing logic
//
//  Modification History
//
//  Mark Pustilnik              Date: 06/16/02 - created
//
//=============================================================================

#include "ASN1Parser.hxx"

char g_UnknownAddressType[] = "Unknown address type";

char * g_AddressTypes[] =
{
    "Unspecified",
    "Local",
    "IPv4",
    "IMPLINK",
    "PUP",
    "CHAOS",
    "NS",
    "NBS",
    "ECMA",
    "DATAKIT",
    "CCITT",
    "SNA",
    "DECnet",
    "DLI",
    "LAT",
    "HYLINK",
    "AppleTalk",
    "BSC",
    "DSS",
    "OSI",
    "NetBIOS",
    "X25",
    g_UnknownAddressType,
    g_UnknownAddressType,
    "IPv6",
};

DWORD
ASN1ParserHostAddress::DisplayCollectedValues(
    IN ASN1FRAME * Frame,
    IN ULONG Length,
    IN ULPBYTE Address
    )
{
    DWORD dw;
    ASN1VALUE * AddrType;
    ASN1VALUE * AddrValue;
    ASN1VALUE Value;
    char * AddrTypeString = NULL;

    if ( QueryCollectedCount() != 2 )
    {
        dw = ERROR_INTERNAL_ERROR;
        goto Cleanup;
    }

    //
    // Create a new value to be displayed, of the format Type: Value
    // Type: Value
    //

    AddrType = QueryCollectedValue( 0 );
    AddrValue = QueryCollectedValue( 1 );

    if ( AddrType->ut != utInteger )
    {
        dw = ERROR_INTERNAL_ERROR;
        goto Cleanup;
    }

    if ( AddrValue->ut != utGeneralString &&
         AddrValue->ut != utOctetString )
    {
        dw = ERROR_INTERNAL_ERROR;
        goto Cleanup;
    }

    //
    // Create an address display value that looks like
    //    NetBIOS: HRUNDEL
    //    or
    //    IPv4: 192.15.98.126
    //

    if ( AddrType->dw <= ARRAY_COUNT( g_AddressTypes ))
    {
        AddrTypeString = g_AddressTypes[AddrType->dw];
    }
    else
    {
        AddrTypeString = g_UnknownAddressType;
    }

    ULONG l = strlen( AddrTypeString );

    Value.ut = utGeneralString;
    Value.string.l = l + strlen(": ") + AddrValue->string.l;
    Value.string.s = new BYTE[Value.string.l];

    if ( Value.string.s == NULL )
    {
        dw = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    Value.Allocated = TRUE;

    RtlCopyMemory(
        Value.string.s,
        AddrTypeString,
        l
        );

    Value.string.s[l++] = ':';
    Value.string.s[l++] = ' ';

    RtlCopyMemory(
        &Value.string.s[l],
        AddrValue->string.s,
        AddrValue->string.l
        );

    dw = Display(
             Frame,
             &Value,
             PROP( HostAddresses_HostAddress ),
             0
             );

    if ( dw != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

Cleanup:

    return dw;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\parser\asn1gtime.cxx ===
//=============================================================================
//
//  MODULE: ASN1GTime.cxx
//
//  Description:
//
//  Implementation of ASN.1 generalized time parsing logic
//
//  Modification History
//
//  Mark Pustilnik              Date: 06/12/02 - created
//
//=============================================================================

#include "ASN1Parser.hxx"
#include <stdio.h>

//
// Retrieve the value of an ASN.1-encoded generalized time
// Times are converted to 'SYSTEMTIME' format for ease of handling by Netmon
//

DWORD
ASN1ParserGeneralizedTime::GetValue(
    IN OUT ASN1FRAME * Frame,
    OUT ASN1VALUE * Value
    )
{
    DWORD dw;
    ASN1FRAME FrameIn = *Frame;
    DWORD DLength = DataLength( Frame );
    ULPBYTE Address = Frame->Address;

    if ( *Frame->Address != BuildDescriptor(
                                ctUniversal,
                                pcPrimitive,
                                (BYTE)utGeneralizedTime ))
    {
        dw = ERROR_INVALID_USER_BUFFER;
        goto Cleanup;
    }

    //
    // Skip over the the descriptor
    //

    Address++;

    //
    // Skip over the length header
    //

    Address += HeaderLength( Address );

    Value->Address = Address;
    Value->Length = DLength;
    Value->ut = utGeneralizedTime;
    RtlZeroMemory( &Value->st, sizeof( Value->st ));

    //
    // Length should be 0xF for regular ZULU time encoding
    //

    if ( DLength == 0xF )
    {
        //
        // Time is encoded as 20370913024805Z
        // where year   = 2037
        //       month  = 09
        //       day    = 13
        //       hour   = 02
        //       minute = 48
        //       second = 05
        //       Z = zulu time
        //

        if ( 6 != sscanf(
                      (const char * )Value->Address,
                      "%04d%02d%02d%02d%02d%02d",
                      &Value->st.wYear,
                      &Value->st.wMonth,
                      &Value->st.wDay,
                      &Value->st.wHour,
                      &Value->st.wMinute,
                      &Value->st.wSecond
                      ))
        {
            //
            // Expected to parse out 6 fields
            //

            dw = ERROR_INVALID_TIME;
            goto Cleanup;
        }

        Address += DLength;

        //
        // TODO: add handling for non-Zulu times
        //

        //
        // Cheap hack: convert to filetime and back in order to get the day of
        // week to display correctly
        //

        FILETIME ft;
        SystemTimeToFileTime( &Value->st, &ft );
        FileTimeToSystemTime( &ft, &Value->st );
    }
    else
    {
        dw = ERROR_INVALID_TIME;
        goto Cleanup;
    }

    Frame->Address = Address;

    dw = ERROR_SUCCESS;

Cleanup:

    if ( dw != ERROR_SUCCESS )
    {
        *Frame = FrameIn;
    }

    return dw;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\parser\asn1gstring.cxx ===
//=============================================================================
//
//  MODULE: ASN1GString.cxx
//
//  Description:
//
//  Implementation of ASN.1 general string parsing logic
//
//  Modification History
//
//  Mark Pustilnik              Date: 06/09/02 - created
//
//=============================================================================

#include "ASN1Parser.hxx"

//
// Retrieve the value of an ASN.1-encoded general string
//

DWORD
ASN1ParserGeneralString::GetValue(
    IN OUT ASN1FRAME * Frame,
    OUT ASN1VALUE * Value
    )
{
    DWORD dw;
    ASN1FRAME FrameIn = *Frame;
    DWORD DLength = DataLength( Frame );
    ULPBYTE Address = Frame->Address;

    if ( *Frame->Address != BuildDescriptor(
                                ctUniversal,
                                pcPrimitive,
                                (BYTE)utGeneralString ))
    {
        dw = ERROR_INVALID_USER_BUFFER;
        goto Cleanup;
    }

    //
    // Skip over the the descriptor
    //

    Address++;

    //
    // Skip over the length header
    //

    Address += HeaderLength( Address );

    Value->Address = Address;
    Value->Length = DLength;
    Value->ut = utGeneralString;
    Value->string.s = Address;
    Value->string.l = DLength;

    //
    // Move the frame beyond the octet string
    //

    Address += DLength;
    Frame->Address = Address;

    dw = ERROR_SUCCESS;

Cleanup:

    if ( dw != ERROR_SUCCESS )
    {
        *Frame = FrameIn;
    }

    return dw;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\parser\asn1octetstring.cxx ===
//=============================================================================
//
//  MODULE: ASN1OctetString.cxx
//
//  Description:
//
//  Implementation of ASN.1 octet string parsing logic
//
//  Modification History
//
//  Mark Pustilnik              Date: 06/09/02 - created
//
//=============================================================================

#include "ASN1Parser.hxx"

//
// Retrieve the value of an ASN.1-encoded octet string
//

DWORD
ASN1ParserOctetString::GetValue(
    IN OUT ASN1FRAME * Frame,
    OUT ASN1VALUE * Value
    )
{
    DWORD dw;
    ASN1FRAME FrameIn = *Frame;
    DWORD DLength = DataLength( Frame );
    ULPBYTE Address = Frame->Address;

    if ( *Frame->Address != BuildDescriptor(
                                ctUniversal,
                                pcPrimitive,
                                (BYTE)utOctetString ))
    {
        dw = ERROR_INVALID_USER_BUFFER;
        goto Cleanup;
    }

    //
    // Skip over the the descriptor
    //

    Address++;

    //
    // Skip over the length header
    //

    Address += HeaderLength( Address );

    Value->Address = Address;
    Value->Length = DLength;
    Value->ut = utOctetString;
    Value->string.s = Address;
    Value->string.l = DLength;

    //
    // Move the frame beyond the octet string
    //

    Address += DLength;
    Frame->Address = Address;

    //
    // Octet strings can be encoded other things, in highly situation-specific
    // context.
    //
    // Here we call into our derived class to get the value we just parsed out
    // interpreted as appropriate.
    //

    dw = ParseBlob( Value );

    if ( dw != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

Cleanup:

    if ( dw != ERROR_SUCCESS )
    {
        *Frame = FrameIn;
    }

    return dw;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\parser\asn1integerseq.cxx ===
//=============================================================================
//
//  MODULE: ASN1IntegerSeq.cxx
//
//  Description:
//
//  Implementation of integer sequence parsing logic
//
//  Modification History
//
//  Mark Pustilnik              Date: 07/09/02 - created
//
//=============================================================================

#include "ASN1Parser.hxx"

DWORD
ASN1ParserIntegerSequence::DisplayCollectedValues(
    IN ASN1FRAME * Frame,
    IN ULONG Length,
    IN ULPBYTE Address
    )
{
    DWORD dw = ERROR_SUCCESS;

    UNREFERENCED_PARAMETER( Length );
    UNREFERENCED_PARAMETER( Address );

    for ( ULONG i = 0; i < QueryCollectedCount(); i++ )
    {
        dw = Display(
                 Frame,
                 QueryCollectedValue( i ),
                 m_hPropertyInteger,
                 0
                 );

        if ( dw != ERROR_SUCCESS )
        {
            break;
        }
    }

    return dw;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\parser\asn1integer.cxx ===
//=============================================================================
//
//  MODULE: ASN1Integer.cxx
//
//  Description:
//
//  Implementation of ASN.1 integer parsing logic
//
//  Modification History
//
//  Mark Pustilnik              Date: 06/08/02 - created
//
//=============================================================================

#include "ASN1Parser.hxx"

//
// Retrieve the value of an ASN.1-encoded integer
//

DWORD
ASN1ParserInteger::GetValue(
    IN OUT ASN1FRAME * Frame,
    OUT ASN1VALUE * Value
    )
{
    DWORD dw;
    ASN1FRAME FrameIn = *Frame;
    DWORD DLength = DataLength( Frame );
    ULPBYTE Address = Frame->Address;

    if ( *Frame->Address != BuildDescriptor(
                                ctUniversal,
                                pcPrimitive,
                                (BYTE)utInteger ))
    {
        dw = ERROR_INVALID_USER_BUFFER;
        goto Cleanup;
    }

    //
    // Skip over the the descriptor
    //

    Address++;

    //
    // Skip over the length header
    //

    Address += HeaderLength( Address );

    Value->Address = Address;
    Value->Length = DLength;
    Value->ut = utInteger;
    Value->dw = 0;

    for ( ULONG i = 0; i < DLength; i++ )
    {
        Value->dw <<= 8;
        Value->dw += *Address;
        Address++;
    }

    //
    // Mask off the bits we don't care about by making use of the bitmask
    //

    Value->dw &= m_BitMask;

    Frame->Address = Address;

    dw = ERROR_SUCCESS;

Cleanup:

    if ( dw != ERROR_SUCCESS )
    {
        *Frame = FrameIn;
    }

    return dw;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\parser\asn1padata.cxx ===
//=============================================================================
//
//  MODULE: ASN1PaData.cxx
//
//  Description:
//
//  Implementation of pre-authentication data parsing logic
//
//  Modification History
//
//  Mark Pustilnik              Date: 06/16/02 - created
//
//=============================================================================

#include "ASN1Parser.hxx"

DWORD
ASN1ParserPaData::DisplayCollectedValues(
    IN ASN1FRAME * Frame,
    IN ULONG Length,
    IN ULPBYTE Address
    )
{
    DWORD dw;
    ASN1VALUE * PaDataType;
    ASN1VALUE * PaDataValue;
    ASN1FRAME FrameHere;

    if ( QueryCollectedCount() != 2 )
    {
        dw = ERROR_INTERNAL_ERROR;
        goto Cleanup;
    }

    //
    // First handle the first element - the padata-type
    //

    PaDataType = QueryCollectedValue( 0 );

    if ( PaDataType->ut != utInteger )
    {
        dw = ERROR_INTERNAL_ERROR;
        goto Cleanup;
    }

    dw = Display(
             Frame,
             PaDataType,
             PROP( PA_DATA_type ),
             0
             );

    if ( dw != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    //
    // Now display the padata-value in a type-specific fashion
    //

    PaDataValue = QueryCollectedValue( 1 );

    //
    // Sequences of length zero are valid in some cases
    //

    if ( PaDataValue->Length == 0 )
    {
        goto Cleanup;
    }

    Frame->Level += 1;

    //
    // NOTE: Must use the actual address within the frame (PaDataValue->Address)
    // rather than the (potentially dynamically allocated) address of the octet string
    // since Netmon cares that the addresses passed to it during display belong
    // within the frame being parsed
    //

    FrameHere.Address = PaDataValue->Address;
    FrameHere.hFrame = Frame->hFrame;
    FrameHere.Level = Frame->Level;

    switch ( PaDataType->dw )
    {
    case PA_APTGS_REQ:
    {
        if ( FrameHere.Address &&
             PaDataValue->Length > 0 &&
             *FrameHere.Address == BuildDescriptor(
                                       ctApplication,
                                       pcConstructed,
                                       ASN1_KRB_AP_REQ ))
        {
            ASN1ParserApReq
            ap_req( FALSE, 0, NULL );

            dw = ap_req.Parse( &FrameHere );
        }
        else
        {
            //
            // TODO: add other non-default parsers
            //

            dw = Display(
                     Frame,
                     PaDataValue,
                     PROP( PA_DATA_value ),
                     0
                     );
        }

        break;
    }

    case PA_ENC_TIMESTAMP:
    case PA_CLIENT_VERSION:
    case PA_XBOX_SERVICE_REQUEST:
    case PA_XBOX_SERVICE_ADDRESS:
    case PA_XBOX_ACCOUNT_CREATION:
    {
        ASN1ParserEncryptedData
        encrypted_data( FALSE, 0, NULL );

        dw = encrypted_data.Parse( &FrameHere );

        break;
    }

    case PA_PW_SALT:
    {
        dw = Display(
                 &FrameHere,
                 PaDataValue,
                 PROP( PA_PW_SALT_salt ),
                 0
                 );

        break;
    }

    case PA_ETYPE_INFO:
    {
        ASN1ParserKerbEtypeInfo
        etype_info( FALSE, 0, NULL );

        dw = etype_info.Parse( &FrameHere );

        break;
    }

    case PA_PAC_REQUEST:
    {
        ASN1ParserKerbPaPacRequest
        pa_pac_request( FALSE, 0, NULL );

        dw = pa_pac_request.Parse( &FrameHere );

        break;
    }

    case PA_FOR_USER:
    {
        ASN1ParserKerbPaForUser
        pa_for_user( FALSE, 0, NULL );

        dw = pa_for_user.Parse( &FrameHere );

        break;
    }

    case PA_PAC_REQUEST_EX:
    {
        ASN1ParserPaPacRequestEx
        pa_pac_request_ex(
            FALSE,
            0,
            NULL );

        dw = pa_pac_request_ex.Parse( &FrameHere );

        break;
    }

    case PA_COMPOUND_IDENTITY:
    {
        //
        // KERB-PA-COMPOUND-IDENTITY ::= SEQUENCE OF KERB-TICKET
        //

        ASN1ParserTicketSequence
        pa_compound_identity(
            FALSE,
            0,
            PROP( CompoundIdentity ),
            PROP( CompoundIdentityTicket ));

        dw = pa_compound_identity.Parse( &FrameHere );

        break;
    }

    default:

        dw = Display(
                 Frame,
                 PaDataValue,
                 PROP( PA_DATA_value ),
                 0
                 );
    }

    Frame->Level -= 1;

    if ( dw != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

Cleanup:

    return dw;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\parser\asn1unit.cxx ===
//=============================================================================
//
//  MODULE: ASN1Unit.cxx
//
//  Description:
//
//  Implementation of ASN.1 "unit" parsing logic
//
//  Modification History
//
//  Mark Pustilnik              Date: 06/08/02 - created
//
//=============================================================================

#include "ASN1Parser.hxx"

//
// Parses the unit through calling into the derived class' GetValue() method
// then uses Display() to show it in Netmon
//

DWORD
ASN1ParserUnit::Parse(
    IN OUT ASN1FRAME * Frame
    )
{
    DWORD dw;
    ASN1VALUE Value;
    ASN1FRAME FrameIn = *Frame;

    dw = VerifyAndSkipHeader( Frame );

    if ( dw != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    dw = GetValue(
             Frame,
             &Value
             );

    if ( dw != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    //
    // If a summary property is present, display it now
    // and indent the display for value property
    //

    if ( m_hPropertySummary != NULL )
    {
        dw = Display(
                 Frame,
                 &Value,
                 m_hPropertySummary,
                 0
                 );

        if ( dw != ERROR_SUCCESS )
        {
            goto Cleanup;
        }

        Frame->Level += 1;
    }

    //
    // If an object has a valid property value handle, it is displayable
    // Otherwise, it should have a value collector class
    //

    if ( m_hPropertyValue != NULL )
    {
        dw = Display(
                 Frame,
                 &Value,
                 m_hPropertyValue,
                 m_IFlags
                 );
    }

    //
    // Octet values might come out with a subparser attached, in which case
    // this subparser should be invoked right now
    //

    if ( dw == ERROR_SUCCESS && 
         Value.ut == utOctetString &&
         Value.SubParser != NULL )
    {
        ASN1FRAME FrameHere;

        FrameHere.Address = Value.Address;
        FrameHere.hFrame = Frame->hFrame;
        FrameHere.Level = Frame->Level + 1;

        dw = Value.SubParser->Parse( &FrameHere );
    }

    if ( m_hPropertySummary != NULL )
    {
        Frame->Level -= 1;
    }

    if ( dw != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    //
    // See if the value of this unit modifies the parsing done to some other
    // unit, and if so, inform the modifyee of the modifier value
    //

    if ( QueryModifyee() != NULL )
    {
        dw = QueryModifyee()->SetModifier( &Value );

        if ( dw != ERROR_SUCCESS )
        {
            goto Cleanup;
        }
    }

Cleanup:

    if ( QueryValueCollector() != NULL &&
         ( dw == ERROR_SUCCESS ||
           ( dw == ERROR_INVALID_USER_BUFFER && IsOptional())))
    {
        DWORD dw2;
        dw2 = QueryValueCollector()->CollectValue(( dw == ERROR_SUCCESS ) ? &Value : NULL );

        if ( dw == ERROR_SUCCESS &&
             dw2 != ERROR_SUCCESS )
        {
            dw = dw2;
        }
    }

    if ( dw != ERROR_SUCCESS )
    {
        *Frame = FrameIn;
    }

    return dw;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\parser\asn1sequence.cxx ===
//=============================================================================
//
//  MODULE: ASN1Sequence.cxx
//
//  Description:
//
//  Implementation of ASN.1 sequence parsing logic
//
//  Modification History
//
//  Mark Pustilnik              Date: 06/08/02 - created
//
//=============================================================================

#include "ASN1Parser.hxx"

//
// Parsing a sequence with optional elements entails invoking successive parsers
// and stepping over optional blocks which were not found in the sequence
//

DWORD
ASN1ParserSequence::Parse(
    IN OUT ASN1FRAME * Frame
    )
{
    DWORD dw;
    ASN1FRAME FrameIn = *Frame;
    DWORD Length = DataLength( Frame );
    BOOLEAN FrameLevelChanged = FALSE;
    ULPBYTE SequenceEnd;

    dw = VerifyAndSkipHeader( Frame );

    if ( dw != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    if ( *Frame->Address != BuildDescriptor(
                                ctUniversal,
                                pcConstructed,
                                utSequence ))
    {
        dw = ERROR_INVALID_DATA;
        goto Cleanup;
    }

    //
    // Remember the length of the sequence
    //

    Length = DataLength( Frame );

    //
    // Skip over the the descriptor
    //

    Frame->Address++;

    //
    // Skip over the length header
    //

    Frame->Address += HeaderLength( Frame->Address );

    //
    // Remember where the sequence ends so we know when to stop iterating
    //

    SequenceEnd = Frame->Address + Length;

    //
    // Display the sequence summary
    //

    if ( m_hPropertySummary )
    {
        if ( FALSE == AttachPropertyInstanceEx(
                          Frame->hFrame,
                          m_hPropertySummary,
                          (DWORD)(SequenceEnd - FrameIn.Address),
                          FrameIn.Address,
                          0,
                          NULL,
                          0,
                          Frame->Level,
                          0 ))
        {
            dw = ERROR_CAN_NOT_COMPLETE;
            goto Cleanup;
        }

        //
        // Anything from this point on is indented
        //

        Frame->Level += 1;
        FrameLevelChanged = TRUE;
    }

    while ( Frame->Address < SequenceEnd )
    {
        for ( ULONG i = 0; i < m_Count; i++ )
        {
            ASN1ParserBase * Parser = m_Parsers[i];

            dw = Parser->Parse( Frame );

            if ( dw == ERROR_INVALID_USER_BUFFER &&
                 Parser->IsOptional())
            {
                //
                // Failed to parse, but it was optional anyway
                // Clear the error code and proceed
                //

                dw = ERROR_SUCCESS;
                continue;
            }
            else if ( dw != ERROR_SUCCESS )
            {
                goto Cleanup;
            }

            //
            // Make sure the sequence is not overstepped
            //

            if ( Frame->Address > SequenceEnd )
            {
                dw = ERROR_INVALID_DATA;
                goto Cleanup;
            }
        }
    }

    if ( !m_Extensible )
    {
        //
        // Any ASN.1 encoding worth it salt is exact, so enforce that
        //

        if ( Frame->Address != SequenceEnd )
        {
            dw = ERROR_INVALID_DATA;
            goto Cleanup;
        }
    }
    else
    {
        //
        // Pretend we've parsed the rest successfully
        //

        Frame->Address = SequenceEnd;
    }

    //
    // If we are a value collector, display the collected values now
    //

    dw = DisplayCollectedValues(
             Frame,
             (DWORD)(SequenceEnd-FrameIn.Address),
             FrameIn.Address
             );

    PurgeCollectedValues();

    if ( dw != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

Cleanup:

    //
    // Restore the indent level
    //

    if ( dw != ERROR_SUCCESS )
    {
        *Frame = FrameIn;
    }
    else if ( FrameLevelChanged )
    {
        Frame->Level -= 1;
    }

    return dw;
}

DWORD
ASN1ParserSequence::CollectValue(
    IN ASN1VALUE * Value
    )
{
    ASN1VALUE * NewValue = Value ? Value->Clone() : NULL;
    PASN1VALUE * NewValuesCollected = new PASN1VALUE[m_ValueCount + 1];

    if (( Value != NULL && NewValue == NULL ) ||
         NewValuesCollected == NULL )
    {
        delete NewValue;
        delete [] NewValuesCollected;

        return ERROR_NOT_ENOUGH_MEMORY;
    }

    RtlCopyMemory(
        NewValuesCollected,
        m_ValuesCollected,
        m_ValueCount * sizeof( PASN1VALUE )
        );

    delete [] m_ValuesCollected;
    m_ValuesCollected = NewValuesCollected;
    m_ValuesCollected[m_ValueCount++] = NewValue;

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\parser\asn1pnameseq.cxx ===
//=============================================================================
//
//  MODULE: ASN1PNameSeq.cxx
//
//  Description:
//
//  Implementation of principal name sequence parsing logic
//
//  Modification History
//
//  Mark Pustilnik              Date: 06/13/02 - created
//
//=============================================================================

#include "ASN1Parser.hxx"

DWORD
ASN1ParserPrincipalNameSequence::DisplayCollectedValues(
    IN ASN1FRAME * Frame,
    IN ULONG Length,
    IN ULPBYTE Address
    )
{
    DWORD dw;
    ASN1VALUE Value;
    ULPBYTE s_address = NULL;
    ULONG s_length = 0;

    for ( ULONG i = 0; i < QueryCollectedCount(); i++ )
    {
        ASN1VALUE * String = QueryCollectedValue(i);

        if ( String->ut == utGeneralString )
        {
            ULPBYTE address = new BYTE[s_length + ( i ? 1 : 0 ) + String->string.l ];

            if ( address == NULL )
            {
                dw = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }

            if ( i > 0 )
            {
                RtlCopyMemory(
                    address,
                    s_address,
                    s_length
                    );

                address[s_length++] = '/';
            }

            RtlCopyMemory(
                &address[s_length],
                String->string.s,
                String->string.l
                );

            delete [] s_address;
            s_address = address;

            s_length += String->string.l;
        }
        else
        {
            //
            // TODO: add an assert
            //

            dw = ERROR_INTERNAL_ERROR;
            goto Cleanup;
        }
    }

    Value.Length = Length;
    Value.Address = Address;

    Value.ut = utGeneralString;
    Value.Allocated = TRUE;
    Value.string.l = s_length;
    Value.string.s = s_address;
    s_address = NULL;

    if ( m_hPropertySummary )
    {
        dw = Display(
                 Frame,
                 &Value,
                 m_hPropertySummary,
                 0
                 );

        if ( dw != ERROR_SUCCESS )
        {
            goto Cleanup;
        }
    }

    if ( QueryValueCollector())
    {
        dw = QueryValueCollector()->CollectValue( &Value );

        if ( dw != ERROR_SUCCESS )
        {
            goto Cleanup;
        }
    }

Cleanup:

    delete [] s_address;

    return dw;
};

DWORD
ASN1ParserPrincipalName::DisplayCollectedValues(
    IN ASN1FRAME * Frame,
    IN ULONG Length,
    IN ULPBYTE Address
    )
{
    DWORD dw;
    ASN1VALUE * NameType;
    ASN1VALUE * NameString;

    if ( QueryCollectedCount() != 2 )
    {
        dw = ERROR_INTERNAL_ERROR;
        goto Cleanup;
    }

    NameType = QueryCollectedValue( 0 );
    NameString = QueryCollectedValue( 1 );

    if ( NameType->ut != utInteger )
    {
        dw = ERROR_INTERNAL_ERROR;
        goto Cleanup;
    }

    if ( NameString->ut != utGeneralString )
    {
        dw = ERROR_INTERNAL_ERROR;
        goto Cleanup;
    }

    //
    // Display the top-level property
    //

    dw = Display(
             Frame,
             NameString,
             m_hPropertyTopLevel,
             0
             );

    if ( dw != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    //
    // Done displaying the top-level property; indent the rest to the right
    //

    Frame->Level += 1;

    dw = Display(
             Frame,
             NameType,
             PROP( PrincipalName_type ),
             0
             );

    if ( dw == ERROR_SUCCESS )
    {
        dw = Display(
                 Frame,
                 NameString,
                 PROP( PrincipalName_string ),
                 0
                 );
    }

    //
    // Do not forget to undo the indentation
    //

    Frame->Level -= 1;

    if ( dw != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

Cleanup:

    return dw;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\parser\asn1value.cxx ===
//=============================================================================
//
//  MODULE: ASN1Value.cxx
//
//  Description:
//
//  Implementation of ASN1VALUE methods
//
//  Modification History
//
//  Mark Pustilnik              Date: 06/12/02 - Created
//
//=============================================================================

#include "ASN1Parser.hxx"

ASN1VALUE::~ASN1VALUE()
{
    Purge();
    delete SubParser;
}

ASN1VALUE *
ASN1VALUE::Clone()
{
    DWORD dw;
    ASN1VALUE * Value = new ASN1VALUE;

    if ( Value )
    {
        RtlCopyMemory(
            Value,
            this,
            sizeof( ASN1VALUE )
            );

        if ( Value->ut == utOctetString ||
             Value->ut == utGeneralString )
        {
            Value->string.s = new BYTE[string.l];

            if ( Value->string.s )
            {
                RtlCopyMemory(
                    Value->string.s,
                    string.s,
                    string.l
                    );

                Value->Allocated = TRUE;
            }
            else
            {
                Value->Allocated = FALSE;
                delete Value;
                Value = NULL;
            }
        }

        //
        // Deep copy of subparser is not safe until parser objects are refcounted
        //

        Value->SubParser = NULL;
    }

    return Value;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\parser\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by kerbparser.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\parser\globals.cxx ===
//=============================================================================
//
//  MODULE: Globals.cxx
//
//  Description:
//
//  Globals used by the Kerberos parser
//
//  Modification History
//
//  Mark Pustilnik              Date: 06/08/02 - created
//
//=============================================================================

#include "ASN1Parser.hxx"

#define FORMAT_BUFFER_SIZE 132

//
// Kerberos message types
//

LABELED_DWORD g_PacketType[] =
{
    { 0xFFFFFFFF,       NULL                 },
    { ASN1_KRB_AS_REQ,  "KRB_AS_REQ (0x0A)"  },
    { ASN1_KRB_AS_REP,  "KRB_AS_REP (0x0B)"  },
    { ASN1_KRB_TGS_REQ, "KRB_TGS_REQ (0x0C)" },
    { ASN1_KRB_TGS_REP, "KRB_TGS_REP (0x0D)" },
    { ASN1_KRB_AP_REQ,  "KRB_AP_REQ (0x0E)"  },
    { ASN1_KRB_AP_REP,  "KRB_AP_REP (0x0F)"  },
    { ASN1_KRB_SAFE,    "KRB_SAFE (0x14)"    },
    { ASN1_KRB_PRIV,    "KRB_PRIV (0x15)"    },
    { ASN1_KRB_CRED,    "KRB_CRED (0x16)"    },
    { ASN1_KRB_ERROR,   "KRB_ERROR (0x1E)"   },
};

SET g_PacketTypeSet = SET_OF( g_PacketType );

//
// Boolean values
//

LABELED_DWORD g_Boolean[] =
{
    { 0xFFFFFFFF,           NULL            },
    { FALSE,                "False"         },
    { TRUE,                 "True"          },
};

SET g_BooleanSet = SET_OF( g_Boolean );

//
// Kerberos encryption types
//

LABELED_DWORD g_EncryptionType[] =
{
    { 0xFFFFFFFF,                                NULL                },
    { ( 0xFFFF & KERB_ETYPE_RC4_HMAC_OLD ),      "RC4-HMAC-OLD"      },
    { ( 0xFFFF & KERB_ETYPE_RC4_PLAIN_OLD ),     "RC4-PLAIN-OLD"     },
    { ( 0xFFFF & KERB_ETYPE_RC4_HMAC_OLD_EXP ),  "RC4-HMAC-OLD-EXP"  },
    { ( 0xFFFF & KERB_ETYPE_RC4_PLAIN_OLD_EXP ), "RC4-PLAIN-OLD-EXP" },
    { ( 0xFFFF & KERB_ETYPE_RC4_PLAIN ),         "RC4-PLAIN"         },
    { ( 0xFFFF & KERB_ETYPE_RC4_PLAIN_EXP ),     "RC4-PLAIN-EXP"     },
    { ( 0xFFFF & KERB_ETYPE_NULL ),              "NULL"              },
    { ( 0xFFFF & KERB_ETYPE_DES_CBC_CRC ),       "DES-CBC-CRC"       },
    { ( 0xFFFF & KERB_ETYPE_DES_CBC_MD4 ),       "DES-CBC-MD4"       },
    { ( 0xFFFF & KERB_ETYPE_DES_CBC_MD5 ),       "DES-CBC-MD5"       },
    { ( 0xFFFF & KERB_ETYPE_DES3_CBC_MD5 ),      "DES3-CBC-MD5"      },
    { ( 0xFFFF & KERB_ETYPE_DES3_CBC_SHA1 ),     "DES3-CBC-SHA1"     },
    { ( 0xFFFF & KERB_ETYPE_DSA_SHA1_CMS ),      "DSA-SHA1-CMS"      },
    { ( 0xFFFF & KERB_ETYPE_RSA_MD5_CMS ),       "RSA-MD5-CMS"       },
    { ( 0xFFFF & KERB_ETYPE_RSA_SHA1_CMS ),      "RSA-SHA1-CMS"      },
    { ( 0xFFFF & KERB_ETYPE_RC2_CBC_ENV ),       "RC2-CBC-ENV"       },
    { ( 0xFFFF & KERB_ETYPE_RSA_ENV ),           "RSA-ENV"           },
    { ( 0xFFFF & KERB_ETYPE_RSA_ES_OEAP_ENV ),   "RSA-ES-OEAP-ENV"   },
    { ( 0xFFFF & KERB_ETYPE_DES_EDE3_CBC_ENV ),  "DES-EDE3-CBC-ENV"  },
    { ( 0xFFFF & KERB_ETYPE_DES3_CBC_SHA1_KD ),  "DES3-CBC-SHA1-KD"  },
    { ( 0xFFFF & KERB_ETYPE_DES_CBC_MD5_NT ),    "DES-CBC-MD5-NT"    },
    { ( 0xFFFF & KERB_ETYPE_RC4_HMAC_NT ),       "RC4-HMAC-NT"       },
    { ( 0xFFFF & KERB_ETYPE_RC4_HMAC_NT_EXP ),   "RC4-HMAC-NT-EXP"   },
    { ( 0xFFFF & KERB_ETYPE_OLD_RC4_MD4 ),       "RC4-MD4-OLD"       },
    { ( 0xFFFF & KERB_ETYPE_OLD_RC4_PLAIN ),     "RC4-PLAIN-OLD"     },
    { ( 0xFFFF & KERB_ETYPE_OLD_RC4_LM ),        "RC4-LM-OLD"        },
    { ( 0xFFFF & KERB_ETYPE_OLD_RC4_SHA ),       "RC4-SHA-OLD"       },
    { ( 0xFFFF & KERB_ETYPE_OLD_DES_PLAIN ),     "DES-PLAIN-OLD"     },
    { ( 0xFFFF & KERB_ETYPE_RC4_MD4 ),           "RC4-MD4"           },
    { ( 0xFFFF & KERB_ETYPE_RC4_PLAIN2 ),        "RC4-PLAIN2"        },
    { ( 0xFFFF & KERB_ETYPE_RC4_LM ),            "RC4-LM"            },
    { ( 0xFFFF & KERB_ETYPE_RC4_SHA ),           "RC4-SHA"           },
    { ( 0xFFFF & KERB_ETYPE_DES_PLAIN ),         "DES-PLAIN"         },
    { ( 0xFFFF & KERB_ETYPE_RC4_HMAC_OLD ),      "RC4-HMAC-OLD"      },
    { ( 0xFFFF & KERB_ETYPE_RC4_PLAIN_OLD ),     "RC4-PLAIN-OLD"     },
    { ( 0xFFFF & KERB_ETYPE_RC4_HMAC_OLD_EXP ),  "RC4-HMAC-OLD-EXP"  },
    { ( 0xFFFF & KERB_ETYPE_RC4_PLAIN_OLD_EXP ), "RC4-PLAIN-OLD-EXP" },
    { ( 0xFFFF & KERB_ETYPE_RC4_PLAIN ),         "RC4-PLAIN"         },
    { ( 0xFFFF & KERB_ETYPE_RC4_PLAIN_EXP ),     "RC4-PLAIN-EXP"     },
};

SET g_EncryptionTypeSet = SET_OF( g_EncryptionType );

//
// Kerberos checksum types
//

LABELED_DWORD g_ChecksumType[] =
{
    { 0xFFFFFFFF,                               NULL                          },
    { ( 0xFFFF & KERB_CHECKSUM_NONE ),          "KERB-CHECKSUM-NONE"          },
    { ( 0xFFFF & KERB_CHECKSUM_CRC32 ),         "KERB-CHECKSUM-CRC32"         },
    { ( 0xFFFF & KERB_CHECKSUM_MD4 ),           "KERB-CHECKSUM-MD4"           },
    { ( 0xFFFF & KERB_CHECKSUM_KRB_DES_MAC ),   "KERB-CHECKSUM-KRB-DES-MAC"   },
    { ( 0xFFFF & KERB_CHECKSUM_KRB_DES_MAC_K ), "KERB-CHECKSUM-KRB-DES-MAC-K" },
    { ( 0xFFFF & KERB_CHECKSUM_MD5 ),           "KERB-CHECKSUM-MD5"           },
    { ( 0xFFFF & KERB_CHECKSUM_MD5_DES ),       "KERB-CHECKSUM-MD5-DES"       },
    { ( 0xFFFF & KERB_CHECKSUM_LM ),            "KERB-CHECKSUM-LM"            },
    { ( 0xFFFF & KERB_CHECKSUM_SHA1 ),          "KERB-CHECKSUM-SHA1"          },
    { ( 0xFFFF & KERB_CHECKSUM_REAL_CRC32 ),    "KERB-CHECKSUM-REAL-CRC32"    },
    { ( 0xFFFF & KERB_CHECKSUM_DES_MAC ),       "KERB-CHECKSUM-DES-MAC"       },
    { ( 0xFFFF & KERB_CHECKSUM_DES_MAC_MD5 ),   "KERB-CHECKSUM-DES-MAC-MD5"   },
    { ( 0xFFFF & KERB_CHECKSUM_MD25 ),          "KERB-CHECKSUM-MD25"          },
    { ( 0xFFFF & KERB_CHECKSUM_RC4_MD5 ),       "KERB-CHECKSUM-RC4-MD5"       },
    { ( 0xFFFF & KERB_CHECKSUM_MD5_HMAC ),      "KERB-CHECKSUM-MD5-HMAC"      },
    { ( 0xFFFF & KERB_CHECKSUM_HMAC_MD5 ),      "KERB-CHECKSUM-HMAC-MD5"      },
};

SET g_ChecksumTypeSet = SET_OF( g_ChecksumType );

//
// Kerberos pre-authentication data types
//

LABELED_DWORD g_PaDataType[] =
{
    { 0xFFFFFFFF,                 NULL                       },
    { PA_NONE,                    "None"                     },
    { PA_APTGS_REQ,               "PA-{AP|TGS}-REQ"          },
    { PA_ENC_TIMESTAMP,           "PA-ENC-TIMESTAMP"         },
    { PA_PW_SALT,                 "PA-PW-SALT"               },
    { PA_RESERVED,                "Reserved Value"           },
    { PA_ENC_UNIX_TIME,           "PA-END-UNIX-TIME"         },
    { PA_SANDIA_SECUREID,         "PA-SANDIA-SECUREID"       },
    { PA_SESAME,                  "PA-SESAME"                },
    { PA_OSF_DCE,                 "PA-OSF-DCE"               },
    { PA_CYBERSAFE_SECUREID,      "PA-CYBERSAFE-SECUREID"    },
    { PA_AFS3_SALT,               "PA-AFS3-SALT"             },
    { PA_ETYPE_INFO,              "PA-ETYPE-INFO"            },
    { SAM_CHALLENGE,              "SAM-CHALLENGE"            },
    { SAM_RESPONSE,               "SAM-RESPONSE"             },
    { PA_PK_AS_REQ,               "PA-PK-AS-REQ"             },
    { PA_PK_AS_REP,               "PA-PK-AS-REP"             },
    { PA_PK_AS_SIGN,              "PA-PK-AS-SIGN"            },
    { PA_PK_KEY_REQ,              "PA-PK-KEY-REQ"            },
    { PA_PK_KEY_REP,              "PA-PK-KEY-REP"            },
    { PA_USE_SPECIFIED_KVNO,      "PA-USE-SPECIFIED-KVNO"    },
    { SAM_REDIRECT,               "SAM-REDIRECT"             },
    { PA_GET_FROM_TYPED_DATA,     "PA-GET-FROM-TYPED-DATA"   },
    { PA_SAM_ETYPE_INFO,          "PA-SAM-ETYPE-INFO"        },
    { PA_ALT_PRINC,               "PA-ALT-PRINC"             },
    { PA_REFERRAL_INFO,           "PA-REFERRAL-INFO"         },
    { TD_PKINIT_CMS_CERTIFICATES, "TD-PKINIT-CMS-CERTIFICATES" },
    { TD_KRB_PRINCIPAL,           "TD-KRB-PRINCIPAL"         },
    { TD_KRB_REALM,               "TD-KRB-REALM"             },
    { TD_TRUSTED_CERTIFIERS,      "TD-TRUSTED-CERTIFIERS"    },
    { TD_CERTIFICATE_INDEX,       "TD-CERTIFICATE-INDEX"     },
    { TD_APP_DEFINED_ERROR,       "TD-APP-DEFINED-ERROR"     },
    { TD_REQ_NONCE,               "TD-REQ-NONCE"             },
    { TD_REQ_SEQ,                 "TD-REQ-SEQ"               },
    { PA_PAC_REQUEST,             "PA-PAC-REQUEST"           },
    { PA_FOR_USER,                "PA-FOR-USER"              },
    { PA_COMPOUND_IDENTITY,       "PA-COMPOUND-IDENTITY"     },
    { PA_PAC_REQUEST_EX,          "PA-PAC-REQUEST-EX"        },
    { PA_CLIENT_VERSION,          "PA-CLIENT-VERSION"        },
    { PA_XBOX_SERVICE_REQUEST,    "PA-XBOX-SERVICE-REQUEST"  },
    { PA_XBOX_SERVICE_ADDRESS,    "PA-XBOX-SERVICE-ADDRESS"  },
    { PA_XBOX_ACCOUNT_CREATION,   "PA-XBOX-ACCOUNT-CREATION" },
    { PA_XBOX_PPA,                "PA-XBOX-PPA"              },
    { PA_XBOX_ECHO,               "PA-XBOX-ECHO"             },
};

SET g_PadataTypeSet = SET_OF( g_PaDataType );

//
// Principal name type
//

#define KRB_NT_X500_PRINCIPAL 6 // not in kerbcon.w for instance

LABELED_DWORD g_PrincipalNameType[] =
{
    { 0xFFFFFFFF,                         NULL                                                          },
    { ( 0xFFFF & KRB_NT_UNKNOWN ),        "KRB_NT_UNKNOWN (Name Type not Known)"                        },
    { ( 0xFFFF & KRB_NT_PRINCIPAL ),      "KRB_NT_PRINCIPAL (Name of Principal)"                        },
    { ( 0xFFFF & KRB_NT_SRV_INST ),       "KRB_NT_SRV_INST (Service & other unique instance)"           },
    { ( 0xFFFF & KRB_NT_SRV_HST ),        "KRB_NT_SRV_HST (Serv with host name as instance)"            },
    { ( 0xFFFF & KRB_NT_SRV_XHST ),       "KRB_NT_SRV_XHST (Service with host as remaining components)" },
    { ( 0xFFFF & KRB_NT_UID ),            "KRB_NT_UID (Unique ID)"                                      },
    { ( 0xFFFF & KRB_NT_X500_PRINCIPAL ), "KRB_NT_X500_PRINCIPAL (Encoded X.509 Distinguished Name)"    },
    { ( 0xFFFF & KRB_NT_ENTERPRISE_PRINCIPAL ), "KRB_NT_ENTERPRISE_PRINCIPAL (UPN or SPN)"              },
    { ( 0xFFFF & KRB_NT_ENT_PRINCIPAL_AND_ID ), "KRB_NT_ENT_PRINCIPAL_AND_ID (UPN or SPN and its SID)"  },
    { ( 0xFFFF & KRB_NT_PRINCIPAL_AND_ID ),     "KRB_NT_PRINCIPAL_AND_ID (Name of principal and its SID)" },
    { ( 0xFFFF & KRB_NT_SRV_INST_AND_ID ),      "KRB_NT_SRV_INST_AND_ID (SPN and SID)"                  },
};

SET g_PrincipalNameTypeSet = SET_OF( g_PrincipalNameType );

//
// PAC section
//

LABELED_DWORD g_PACSection[] =
{
    { 0xFFFFFFFF,                         NULL                             },
    { PAC_LOGON_INFO,                     "Authorization data (1)"         },
    { PAC_CREDENTIAL_TYPE,                "Supplemental credentials (2)"   },
    { PAC_SERVER_CHECKSUM,                "Server checksum (6)"            },
    { PAC_PRIVSVR_CHECKSUM,               "Privsvr checksum (7)"           },
    { PAC_CLIENT_INFO_TYPE,               "Client name and ticket ID (10)" },
    { PAC_DELEGATION_INFO,                "S4U delegation info (11)"       },
    { PAC_CLIENT_IDENTITY,                "Client identity (13)"           },
    { PAC_COMPOUND_IDENTITY,              "Compound identity (14)"         },
};

SET g_PACSectionSet = SET_OF( g_PACSection );

//
// AP-Options
//

LABELED_BIT g_ApOptions[] =
{
    {   // Bit 0 - Reserved
        31,
        "Reserved (Bit 0) Not Set",
        "Reserved (Bit 0) Set" },

    {   // Bit 1 - use-session-key
        30,
        "Use-Session-Key (Bit 1) Not Set",
        "Use-Session-Key (Bit 1) Set" },

    {   // Bit 2 - mutual-required
        29,
        "Mutual-Required (Bit 2) Not Set",
        "Mutual-Required (Bit 2) Set" },
};

SET g_ApOptionsSet = SET_OF( g_ApOptions );

//
// KDC-Options
//

LABELED_BIT g_KdcOptionFlags[] =
{
//  {   // Bit 0 - Reserved
//      31,
//      "Reserved (Bit 0) Not Set",
//      "Reserved (Bit 0) Set" },

    {   // Bit 1 - Forwardable
        30,
        "Forwardable Bit Not Set (Bit 1)",
        "Forwardable Bit Set (Bit 1)" },

    {   // Bit 2 - Forwarded
        29,
        "Forwarded Bit Not Set (Bit 2)",
        "Fowarded Bit Set (Bit 2)" },

    {   // Bit 3 - Proxiable
        28,
        "Proxiable Bit Not Set (Bit 3)",
        "Proxiable Bit Set (Bit 3)" },

    {   // Bit 4 - Proxy
        27,
        "Proxy Bit Not Set (Bit 4)",
        "Proxy Bit Set (Bit 4)" },

    {   // Bit 5 - Allow-Postdate
        26,
        "Allow-PostDate Bit Not Set (Bit 5)",
        "May-Postdate Bit Set (Bit 5)" },

    {   // Bit 6 - Postdated
        25,
        "PostDated Bit Not Set (Bit 6)",
        "Postdated Bit Set (Bit 6)" },

    {   // Bit 7 - Unused
        24,
        "Unused Bit Not Set (Bit 7)",
        "Unused Bit Set (Bit 7)" },

    {   // Bit 8 - Renewable
        23,
        "Renewable Bit Not Set (Bit 8)",
        "Renewable Bit Set (Bit 8)" },

//  {   // Bit 9 - Reserved
//      22,
//      "Reserved (Bit 9) Not Set",
//      "Reserved (Bit 9) Set" },

//  {   // Bit 10 - Reserved
//      21,
//      "Reserved (Bit 10) Not Set",
//      "Reserved (Bit 10) Set" },

//  {   // Bit 11 - Reserved
//      20,
//      "Reserved (Bit 11) Not Set",
//      "Reserved (Bit 11) Set" },

//  {   // Bit 12 - Reserved
//      19,
//      "Reserved (Bit 12) Not Set",
//      "Reserved (Bit 12) Set" },

//  {   // Bit 13 - Reserved
//      18,
//      "Reserved (Bit 13) Not Set",
//      "Reserved (Bit 13) Set" },

//  {   // Bit 14 - Reserved
//      17,
//      "Reserved (Bit 14) Not Set",
//      "Reserved (Bit 14) Set" },

    {   // Bit 15 - Name-Canonicalize
        16,
        "Name-Canonicalize Bit Not Set (Bit 15)",
        "Name-Canonicalize Bit Set (Bit 15)" },

//  {   // Bit 16 - Reserved
//      15,
//      "Reserved (Bit 16) Not Set",
//      "Reserved (Bit 16) Set" },

//  {   // Bit 17 - Reserved
//      14,
//      "Reserved (Bit 17) Not Set",
//      "Reserved (Bit 17) Set" },

//  {   // Bit 18 - Reserved
//      13,
//      "Reserved (Bit 18) Not Set",
//      "Reserved (Bit 18)" },

//  {   // Bit 19 - Reserved
//      12,
//      "Reserved (Bit 19) Not Set",
//      "Reserved (Bit 19) Set" },

//  {   // Bit 20 - Reserved
//      11,
//      "Reserved (Bit 20) Not Set",
//      "Reserved (Bit 20) Set" },

//  {   // Bit 21 - Reserved
//      10,
//      "Reserved (Bit 21) Not Set",
//      "Reserved (Bit 21) Set" },

//  {   // Bit 22 - Reserved
//      9,
//      "Reserved (Bit 9) Not Set",
//      "Reserved (Bit 9) Set" },

//  {   // Bit 23 - Reserved
//      8,
//      "Reserved (Bit 8) Not Set",
//      "Reserved (Bit 8) Set" },

//  {   // Bit 24 - Reserved
//      7,
//      "Reserved (Bit 7) Not Set",
//      "Reserved (Bit 7) Set" },

//  {   // Bit 25 - Reserved
//      6,
//      "Reserved (Bit 6) Not Set",
//      "Reserved (Bit 6) Set" },

    {   // Bit 26 - Disable-Transited-Check
        5,
        "Disable-Transited-Check Bit Not Set (Bit 26)",
        "Disable-Transited-Check Bit Set (Bit 26)" },

    {   // Bit 27 - Renewable-OK
        4,
        "Renewable-OK Bit Not Set (Bit 27)",
        "Renewable-OK Bit Set (Bit 27)" },

    {   // Bit 28 - Enc-Tkt-In-Skey
        3,
        "Enc-Tkt-In-Skey Bit Not Set (Bit 28)",
        "Enc-Tkt-In-Skey Bit Not Set (Bit 28)" },

//  {   // Bit 29 - Reserved
//      2,
//      "Reserved (Bit 29) Not Set",
//      "Reserved (Bit 29) Set" },

    {   // Bit 30 - Renew
        1,
        "Renew Bit Not Set (Bit 30)",
        "Renew Bit Set (Bit 30)" },

    {   // Bit 31 - Validate
        0,
        "Validate Bit Not Set (Bit 31)",
        "Validate Bit Set (Bit 31)" }
};

SET g_KdcOptionFlagsSet = SET_OF( g_KdcOptionFlags );

//
// Error codes
//

LABELED_DWORD g_KrbErrCode[] =
{
    { 0xFFFFFFFF, NULL},
    { KDC_ERR_NONE,                          "No error"                                     },
    { KDC_ERR_NAME_EXP,                      "Client's entry in database has expired"       },
    { KDC_ERR_SERVICE_EXP,                   "Server's entry in database has expired"       },
    { KDC_ERR_BAD_PVNO,                      "Requested protocol ver. number not supported" },
    { KDC_ERR_C_OLD_MAST_KVNO,               "Client's key encrypted in old master key"     },
    { KDC_ERR_S_OLD_MAST_KVNO,               "Server's key encrypted in old master key"     },
    { KDC_ERR_C_PRINCIPAL_UNKNOWN,           "Client not found in Kerberos database"        },
    { KDC_ERR_S_PRINCIPAL_UNKNOWN,           "Server not found in Kerberos database"        },
    { KDC_ERR_PRINCIPAL_NOT_UNIQUE,          "Multiple principal entries in database"       },
    { KDC_ERR_NULL_KEY,                      "The client or server has a null key"          },
    { KDC_ERR_CANNOT_POSTDATE,               "Ticket not eligible for postdating"           },
    { KDC_ERR_NEVER_VALID,                   "Requested start time is later than end time"  },
    { KDC_ERR_POLICY,                        "KDC policy rejects request"                   },
    { KDC_ERR_BADOPTION,                     "KDC cannot accommodate requested option"      },
    { KDC_ERR_ETYPE_NOTSUPP,                 "KDC has no support for encryption type"       },
    { KDC_ERR_SUMTYPE_NOSUPP,                "KDC has no support for checksum type"         },
    { KDC_ERR_PADATA_TYPE_NOSUPP,            "KDC has no support for padata type"           },
    { KDC_ERR_TRTYPE_NO_SUPP,                "KDC has no support for transited type"        },
    { KDC_ERR_CLIENT_REVOKED,                "Clients credentials have been revoked"        },
    { KDC_ERR_SERVICE_REVOKED,               "Credentials for server have been revoked"     },
    { KDC_ERR_TGT_REVOKED,                   "TGT has been revoked"                         },
    { KDC_ERR_CLIENT_NOTYET,                 "Client not yet valid try again later"         },
    { KDC_ERR_SERVICE_NOTYET,                "Server not yet valid try again later"         },
    { KDC_ERR_KEY_EXPIRED,                   "Password has expired change password to reset"},
    { KDC_ERR_PREAUTH_FAILED,                "Pre-authentication information was invalid"   },
    { KDC_ERR_PREAUTH_REQUIRED,              "Additional preauthentication required"        },
    { KDC_ERR_SERVER_NOMATCH,                "Requested Server and ticket don't match"      },
    { KDC_ERR_MUST_USE_USER2USER,            "Server principal valid for user2user only"    },
    { KDC_ERR_PATH_NOT_ACCEPTED,             "KDC Policy rejects transited patth"           },
    { KDC_ERR_SVC_UNAVAILABLE,               "A service is not available"                   },
    { KRB_AP_ERR_BAD_INTEGRITY,              "Integrity check on decrypted field failed"    },
    { KRB_AP_ERR_TKT_EXPIRED,                "Ticket expired"                               },
    { KRB_AP_ERR_TKT_NYV,                    "Ticket not yet valid"                         },
    { KRB_AP_ERR_REPEAT,                     "Request is a replay"                          },
    { KRB_AP_ERR_NOT_US,                     "The ticket isn't for us"                      },
    { KRB_AP_ERR_BADMATCH,                   "Ticket and authenticator don't match"         },
    { KRB_AP_ERR_SKEW,                       "Clock skew too great"                         },
    { KRB_AP_ERR_BADADDR,                    "Incorrect net address"                        },
    { KRB_AP_ERR_BADVERSION,                 "Protocol version mismatch"                    },
    { KRB_AP_ERR_MSG_TYPE,                   "Invalid msg type"                             },
    { KRB_AP_ERR_MODIFIED,                   "Message stream modified"                      },
    { KRB_AP_ERR_BADORDER,                   "Message out of order"                         },
    { KRB_AP_ERR_BADKEYVER,                  "Specified version of key is not available"    },
    { KRB_AP_ERR_NOKEY,                      "Service key not available"                    },
    { KRB_AP_ERR_MUT_FAIL,                   "Mutual authentication failed"                 },
    { KRB_AP_ERR_BADDIRECTION,               "Incorrect message direction"                  },
    { KRB_AP_ERR_METHOD,                     "Alternative authentication method required"   },
    { KRB_AP_ERR_BADSEQ,                     "Incorrect sequence number in message"         },
    { KRB_AP_ERR_INAPP_CKSUM,                "Inappropriate type of checksum in message"    },
    { KRB_AP_PATH_NOT_ACCEPTED,              "Policy rejects transited path"                },
    { KRB_ERR_RESPONSE_TOO_BIG,              "Response too big for UDP, retry with TCP"     },
    { KRB_ERR_GENERIC,                       "Generic error"                                },
    { KRB_ERR_FIELD_TOOLONG,                 "Field is too long for this implementation"    },
    { KDC_ERR_CLIENT_NOT_TRUSTED,            "Client is not trusted"                        },
    { KDC_ERR_KDC_NOT_TRUSTED,               "KDC is not trusted"                           },
    { KDC_ERR_INVALID_SIG,                   "Invalid signature"                            },
    { KDC_ERR_KEY_TOO_WEAK,                  "Key is too weak"                              },
    { KDC_ERR_CERTIFICATE_MISMATCH,          "Certificate does not match"                   },
    { KRB_AP_ERR_NO_TGT,                     "No TGT"                                       },
    { KDC_ERR_WRONG_REALM,                   "Wrong realm"                                  },
    { KRB_AP_ERR_USER_TO_USER_REQUIRED,      "User to User required"                        },
    { KDC_ERR_CANT_VERIFY_CERTIFICATE,       "Can't verify certificate"                     },
    { KDC_ERR_INVALID_CERTIFICATE,           "Invalid certificate"                          },
    { KDC_ERR_REVOKED_CERTIFICATE,           "Revoked certificate"                          },
    { KDC_ERR_REVOCATION_STATUS_UNKNOWN,     "Revocation status unknown"                    },
    { KDC_ERR_REVOCATION_STATUS_UNAVAILABLE, "Revocation status unavailable"                },
    { KDC_ERR_CLIENT_NAME_MISMATCH,          "Client name mismatch"                         },
    { KDC_ERR_KDC_NAME_MISMATCH,             "KDC name mismatch"                            },
};

SET g_KrbErrCodeSet = SET_OF( g_KrbErrCode );

//
// MAKE_PROP is a shortcut macro for defining PROPERTYINFO structures
//
// l - Label
// c - Comment
// t - type
// q - qualifier
// v - value
//

#define MAKE_PROP( l,c,t,q,v ) { 0, 0, l, c, t, q, v, FORMAT_BUFFER_SIZE, FormatPropertyInstance }

#define MAKE_PROP_SIZE( l,c,t,q,v,s ) { 0, 0, l, c, t, q, v, s, FormatPropertyInstance }

//
// IMPORTANT!!!
// Contents of this array MUST be kept in sync with the enum in asn1parser.h
//

PROPERTYINFO g_KerberosDatabase[MAX_PROP_VALUE] =
{
    // KRB_AS_REQ
    MAKE_PROP(
        "KRB_AS_REQ",
        "Kerberos authentication service (AS) request",
        PROP_TYPE_SUMMARY,
        PROP_QUAL_NONE,
        0 ),

    // KRB_AS_REP
    MAKE_PROP(
        "KRB_AS_REP",
        "Kerberos authentication service (AS) reply",
        PROP_TYPE_SUMMARY,
        PROP_QUAL_NONE,
        0 ),

    // KRB_TGS_REQ
    MAKE_PROP(
        "KRB_TGS_REQ",
        "Kerberos ticket-granting service (TGS) request",
        PROP_TYPE_SUMMARY,
        PROP_QUAL_NONE,
        0 ),

    // KRB_TGS_REP
    MAKE_PROP(
        "KRB_TGS_REP",
        "Kerberos ticket-granting service (TGS) reply",
        PROP_TYPE_SUMMARY,
        PROP_QUAL_NONE,
        0 ),

    // KRB_AP_REQ
    MAKE_PROP(
        "KRB_AP_REQ",
        "Kerberos application (AP) request",
        PROP_TYPE_SUMMARY,
        PROP_QUAL_NONE,
        0 ),

    // KRB_AP_REP
    MAKE_PROP(
        "KRB_AP_REP",
        "Kerberos application (AP) reply",
        PROP_TYPE_SUMMARY,
        PROP_QUAL_NONE,
        0 ),
        
    // KRB_SAFE
    MAKE_PROP(
        "KRB_SAFE",
        "Kerberos data integrity (SAFE) message",
        PROP_TYPE_SUMMARY,
        PROP_QUAL_NONE,
        0 ),
        
    // KRB_PRIV
    MAKE_PROP(
        "KRB_PRIV",
        "Kerberos data privacy (PRIV) message",
        PROP_TYPE_SUMMARY,
        PROP_QUAL_NONE,
        0 ),

    // KRB_CRED
    MAKE_PROP(
        "KRB_CRED",
        "Kerberos credentials (CRED) message",
        PROP_TYPE_SUMMARY,
        PROP_QUAL_NONE,
        0 ),

    // KRB_ERROR
    MAKE_PROP(
        "KRB_ERROR",
        "Kerberos error message",
        PROP_TYPE_SUMMARY,
        PROP_QUAL_NONE,
        0 ),

    // HostAddresses_HostAddress
    MAKE_PROP(
        "Host address",
        "Individual host address",
        PROP_TYPE_STRING,
        PROP_QUAL_NONE,
        0 ),

    // EncryptedData_etype
    MAKE_PROP(
        "Encryption type (etype[0])",
        "Encryption type",
        PROP_TYPE_DWORD,
        PROP_QUAL_LABELED_SET,
        &g_EncryptionTypeSet ),

    // EncryptedData_kvno
    MAKE_PROP(
        "Key version number (kvno[1])",
        "Key version number",
        PROP_TYPE_DWORD,
        PROP_QUAL_NONE,
        0 ),

    // EncryptedData_cipher
    MAKE_PROP(
        "Ciphertext (cipher[2])",
        "Ciphertext",
        PROP_TYPE_COMMENT,
        PROP_QUAL_NONE,
        0 ),

    // PA_DATA_type
    MAKE_PROP(
        "Data type",
        "Pre-authentication data type (padata-type[1])",
        PROP_TYPE_DWORD,
        PROP_QUAL_LABELED_SET,
        &g_PadataTypeSet ),

    // PA_DATA_value
    MAKE_PROP(
        "Data value (parser not available yet)",
        "Pre-authentication data value (padata-value[2])",
        PROP_TYPE_COMMENT,
        PROP_QUAL_NONE,
        0 ),

    // PrincipalName_type
    MAKE_PROP(
        "Principal name type (name-type[0])",
        "Principal name type",
        PROP_TYPE_DWORD,
        PROP_QUAL_LABELED_SET,
        &g_PrincipalNameTypeSet ),

    // PrincipalName_string
    MAKE_PROP(
        "Principal name value (name-string[1])",
        "Principal name value",
        PROP_TYPE_STRING,
        PROP_QUAL_NONE,
        0 ),

    // Ticket_tkt_vno
    MAKE_PROP(
        "Ticket version number (tkt-vno[0])",
        "Ticket version number",
        PROP_TYPE_DWORD,
        PROP_QUAL_NONE,
        0 ),

    // Ticket_realm
    MAKE_PROP(
        "Realm (realm[1])",
        "Realm name",
        PROP_TYPE_STRING,
        PROP_QUAL_NONE,
        0 ),

    // Ticket_sname
    MAKE_PROP(
        "Server name (sname[2])",
        "Server name",
        PROP_TYPE_STRING,
        PROP_QUAL_NONE,
        0 ),

    // Ticket_enc_part
    MAKE_PROP(
        "Encrypted part (enc-part[3])",
        "Encrypted part of the ticket",
        PROP_TYPE_COMMENT,
        PROP_QUAL_NONE,
        0 ),

    // AP_REQ_pvno
    MAKE_PROP(
        "Protocol version numer (pvno[0])",
        "Protocol version number",
        PROP_TYPE_DWORD,
        PROP_QUAL_NONE,
        0 ),

    // AP_REQ_msg_type
    MAKE_PROP(
        "Message type (msg-type[1])",
        "Message type",
        PROP_TYPE_DWORD,
        PROP_QUAL_NONE,
        0 ),

    // AP_REQ_ap_options_summary
    MAKE_PROP(
        "AP options (ap-options[2])",
        "AP options",
        PROP_TYPE_SUMMARY,
        PROP_QUAL_NONE,
        0 ),

    // AP_REQ_ap_options_value
    MAKE_PROP_SIZE(
        "AP options (ap-options[2])",
        "AP options",
        PROP_TYPE_DWORD,
        PROP_QUAL_FLAGS,
        &g_ApOptionsSet,
        80 * 32 ),

    // AP_REQ_ticket
    MAKE_PROP(
        "Ticket (ticket[3])",
        "Ticket",
        PROP_TYPE_SUMMARY,
        PROP_QUAL_NONE,
        0 ),

    // AP_REQ_authenticator
    MAKE_PROP(
        "Authenticator (authenticator[4])",
        "Authenticator",
        PROP_TYPE_SUMMARY,
        PROP_QUAL_NONE,
        0 ),

    // KDC_REQ_BODY_kdc_options_summary
    MAKE_PROP(
        "KDC options (kdc-options[0])",
        "KDC options",
        PROP_TYPE_SUMMARY,
        PROP_QUAL_NONE,
        0 ),

    // KDC_REQ_BODY_kdc_options_value
    MAKE_PROP_SIZE(
        "KDC options (kdc-options[0])",
        "KDC options",
        PROP_TYPE_DWORD,
        PROP_QUAL_FLAGS,
        &g_KdcOptionFlagsSet,
        80 * 32 ),

    // KDC_REQ_BODY_cname
    MAKE_PROP(
        "Client name (cname[1])",
        "Client name",
        PROP_TYPE_STRING,
        PROP_QUAL_NONE,
        0 ),

    // KDC_REQ_BODY_realm
    MAKE_PROP(
        "Realm (realm[2])",
        "Realm name",
        PROP_TYPE_STRING,
        PROP_QUAL_NONE,
        0 ),

    // KDC_REQ_BODY_sname
    MAKE_PROP(
        "Server name (sname[3])",
        "Server name",
        PROP_TYPE_STRING,
        PROP_QUAL_NONE,
        0 ),

    // KDC_REQ_BODY_from
    MAKE_PROP(
        "Valid-from time (rtime[4])",
        "Valid-from time",
        PROP_TYPE_TIME,
        PROP_QUAL_NONE,
        0 ),

    // KDC_REQ_BODY_till
    MAKE_PROP(
        "Valid-till time (till[5])",
        "Valid-till time",
        PROP_TYPE_TIME,
        PROP_QUAL_NONE,
        0 ),

    // KDC_REQ_BODY_rtime
    MAKE_PROP(
        "Renew-until time (rtime[6])",
        "Renew-until time",
        PROP_TYPE_TIME,
        PROP_QUAL_NONE,
        0 ),

    // KDC_REQ_BODY_nonce
    MAKE_PROP(
        "Nonce (nonce[7])",
        "Nonce",
        PROP_TYPE_DWORD,
        PROP_QUAL_NONE,
        0 ),

    // KDC_REQ_BODY_etype
    MAKE_PROP(
        "Encryption types (etype[8])",
        "List of encryption types in preference order",
        PROP_TYPE_SUMMARY,
        PROP_QUAL_NONE,
        0 ),

    // KDC_REQ_BODY_addresses
    MAKE_PROP(
        "Host addresses (addresses[9])",
        "List of host addresses",
        PROP_TYPE_SUMMARY,
        PROP_QUAL_NONE,
        0 ),

     // KDC_REQ_BODY_enc_authorization_data
    MAKE_PROP(
        "Encrypted authorization data (enc-authorization-data[10])",
        "Encrypted authorization data",
        PROP_TYPE_SUMMARY,
        PROP_QUAL_NONE,
        0 ),

    // KDC_REQ_BODY_additional_tickets
    MAKE_PROP(
        "Additional tickets (additional-tickets[11])",
        "List of additional tickets",
        PROP_TYPE_SUMMARY,
        PROP_QUAL_NONE,
        0 ),

    // KDC_REQ
    MAKE_PROP(
        "KDC request (KDC-REQ)",
        "KDC request",
        PROP_TYPE_SUMMARY,
        PROP_QUAL_NONE,
        0 ),

    // KDC_REQ_pvno
    MAKE_PROP(
        "Protocol version number (pvno[1])",
        "Kerberos protocol version number",
        PROP_TYPE_DWORD,
        PROP_QUAL_NONE,
        0 ),

    // KDC_REQ_msg_type
    MAKE_PROP(
        "Message type (msg-type[2])",
        "Message type of the KDC request",
        PROP_TYPE_DWORD,
        PROP_QUAL_LABELED_SET,
        &g_PacketTypeSet ),

    // KDC_REQ_padata
    MAKE_PROP(
        "Pre-authentication Data (padata[3])",
        "Pre-authentication data inside a KDC request",
        PROP_TYPE_SUMMARY,
        PROP_QUAL_NONE,
        0 ),

    // KDC_REQ_req_body
    MAKE_PROP(
        "Request body (req-body[4])",
        "Request body inside a KDC request",
        PROP_TYPE_SUMMARY,
        PROP_QUAL_NONE,
        0 ),

    // KDC_REP_pvno
    MAKE_PROP(
        "Protocol version number (pvno[0])",
        "Kerberos protocol version number",
        PROP_TYPE_DWORD,
        PROP_QUAL_NONE,
        0 ),

    // KDC_REP_msg_type
    MAKE_PROP(
        "Message type (msg-type[1])",
        "Message type of the KDC reply",
        PROP_TYPE_DWORD,
        PROP_QUAL_LABELED_SET,
        &g_PacketTypeSet ),

    // KDC_REP_padata
    MAKE_PROP(
        "Pre-authentication Data (padata[2])",
        "Pre-authentication data inside a KDC reply",
        PROP_TYPE_SUMMARY,
        PROP_QUAL_NONE,
        0 ),

    // KDC_REP_crealm
    MAKE_PROP(
        "Client realm (crealm[3])",
        "Realm name",
        PROP_TYPE_STRING,
        PROP_QUAL_NONE,
        0 ),

    // KDC_REP_cname
    MAKE_PROP(
        "Client name (cname[4])",
        "Client name",
        PROP_TYPE_STRING,
        PROP_QUAL_NONE,
        0 ),

    // KDC_REP_ticket
    MAKE_PROP(
        "Ticket (ticket[5])",
        "Ticket inside a KDC reply",
        PROP_TYPE_SUMMARY,
        PROP_QUAL_NONE,
        0 ),

    // KDC_REP_enc_part
    MAKE_PROP(
        "Encrypted part (enc-part[6])",
        "Encrypted part of the KDC reply",
        PROP_TYPE_COMMENT,
        PROP_QUAL_NONE,
        0 ),

    // KRB_ERR_pvno
    MAKE_PROP(
        "Protocol version number (pvno[0])",
        "Kerberos protocol version number",
        PROP_TYPE_DWORD,
        PROP_QUAL_NONE,
        0 ),

    // KRB_ERR_msg_type
    MAKE_PROP(
        "Message type (msg-type[1])",
        "Message type of the Kerberos error",
        PROP_TYPE_DWORD,
        PROP_QUAL_LABELED_SET,
        &g_PacketTypeSet ),
    
    // KRB_ERR_ctime
    MAKE_PROP(
        "Client time (ctime[2])",
        "Current time on the client's host",
        PROP_TYPE_TIME,
        PROP_QUAL_NONE,
        0 ),

    // KRB_ERR_cusec
    MAKE_PROP(
        "Microseconds on client (cusec[3])",
        "Microsecond part of the client's timestamp",
        PROP_TYPE_DWORD,
        PROP_QUAL_NONE,
        0 ),

    // KRB_ERR_stime
    MAKE_PROP(
        "Server time (stime[4])",
        "Current time on server",
        PROP_TYPE_TIME,
        PROP_QUAL_NONE,
        0 ),

    // KRB_ERR_susec
    MAKE_PROP(
        "Microseconds on server (susec[5])",
        "Microsecond part of the server's timestamp",
        PROP_TYPE_DWORD,
        PROP_QUAL_NONE,
        0 ),

    // KRB_ERR_error_code
    MAKE_PROP(
        "Error code (error-code[6])",
        "Error code",
        PROP_TYPE_DWORD,
        PROP_QUAL_LABELED_SET,
        &g_KrbErrCodeSet),

    // KRB_ERR_crealm
    MAKE_PROP(
        "Client realm (crealm[7])",
        "Client realm",
        PROP_TYPE_STRING,
        PROP_QUAL_NONE,
        0 ),

    // KRB_ERR_cname
    MAKE_PROP(
        "Client name (cname[8])",
        "Client name",
        PROP_TYPE_STRING,
        PROP_QUAL_NONE,
        0 ),

    // KRB_ERR_realm
    MAKE_PROP(
        "Correct realm (realm[9])",
        "Correct realm",
        PROP_TYPE_STRING,
        PROP_QUAL_NONE,
        0 ),

    // KRB_ERR_sname
    MAKE_PROP(
        "Correct server name (sname[10])",
        "Correct server name",
        PROP_TYPE_STRING,
        PROP_QUAL_NONE,
        0 ),

    // KRB_ERR_e_text
    MAKE_PROP(
        "Additional text (e-text[11])",
        "Additional text to help explain the error code",
        PROP_TYPE_STRING,
        PROP_QUAL_NONE,
        0 ),

    // KRB_ERR_e_data
    MAKE_PROP(
        "Error data (e-data[12])",
        "Additional error data",
        PROP_TYPE_SUMMARY,
        PROP_QUAL_NONE,
        0 ),

    // KERB_PA_PAC_REQUEST_include_pac
    MAKE_PROP(
        "Include PAC (include-pac[0])",
        "Include PAC",
        PROP_TYPE_DWORD,
        PROP_QUAL_LABELED_SET,
        &g_BooleanSet ),

    // KERB_PA_PAC_REQUEST_EX_include_pac
    MAKE_PROP(
        "Include PAC (include-pac[0])",
        "Include PAC",
        PROP_TYPE_DWORD,
        PROP_QUAL_LABELED_SET,
        &g_BooleanSet ),

    // KERB_PA_PAC_REQUEST_EX_pac_sections
    MAKE_PROP(
        "PAC sections (pac-sections[1])",
        "PAC sections",
        PROP_TYPE_SUMMARY,
        PROP_QUAL_NONE,
        0 ),

    // KERB_PA_PAC_REQUEST_EX_pac_sections_desc
    MAKE_PROP(
        "PAC section",
        "PAC section",
        PROP_TYPE_DWORD,
        PROP_QUAL_LABELED_SET,
        &g_PACSectionSet ),

    // KERB_ETYPE_INFO_ENTRY_encryption_type
    MAKE_PROP(
        "Encryption type (encryption-type[0])",
        "Encryption type",
        PROP_TYPE_DWORD,
        PROP_QUAL_LABELED_SET,
        &g_EncryptionTypeSet ),

    // KERB_ETYPE_INFO_ENTRY_salt
    MAKE_PROP(
        "Salt (salt[1])",
        "Salt",
        PROP_TYPE_STRING,
        PROP_QUAL_NONE,
        0 ),

    // KERB_PREAUTH_DATA_LIST
    MAKE_PROP(
        "Preauth data list",
        "Preauth data list",
        PROP_TYPE_SUMMARY,
        PROP_QUAL_NONE,
        0 ),

    // TYPED_DATA_type
    MAKE_PROP(
        "Data type",
        "Typed data type (data-type[1])",
        PROP_TYPE_DWORD,
        PROP_QUAL_LABELED_SET,
        &g_PadataTypeSet ),

    // TYPED_DATA_value
    MAKE_PROP(
        "Data value (parser not available yet)",
        "Typed data value (data-value[2])",
        PROP_TYPE_COMMENT,
        PROP_QUAL_NONE,
        0 ),

    // PA_PW_SALT_salt
    MAKE_PROP(
        "Salt value",
        "Salt value",
        PROP_TYPE_STRING,
        PROP_QUAL_NONE,
        0 ),

    // PA_FOR_USER_userName
    MAKE_PROP(
        "User name (userName[0])",
        "User name",
        PROP_TYPE_STRING,
        PROP_QUAL_NONE,
        0 ),

    // PA_FOR_USER_userRealm
    MAKE_PROP(
        "User realm (userRealm[1])",
        "User realm",
        PROP_TYPE_STRING,
        PROP_QUAL_NONE,
        0 ),

    // PA_FOR_USER_cksum
    MAKE_PROP(
        "Checksum (cksum[2])",
        "Checksum",
        PROP_TYPE_COMMENT,
        PROP_QUAL_NONE,
        0 ),

    // PA_FOR_USER_authentication_package
    MAKE_PROP(
        "Authentication package (authentication-package[3])",
        "Authentication package",
        PROP_TYPE_STRING,
        PROP_QUAL_NONE,
        0 ),

    // PA_FOR_USER_authorization_data
    MAKE_PROP(
        "Authorization data (authorization-data[4])",
        "Authorization data",
        PROP_TYPE_COMMENT,
        PROP_QUAL_NONE,
        0 ),

    // KERB_CHECKSUM_type
    MAKE_PROP(
        "Checksum type (checksum-type[0])",
        "Checksum type",
        PROP_TYPE_DWORD,
        PROP_QUAL_LABELED_SET,
        &g_ChecksumTypeSet ),

    // KERB_CHECKSUM_checksum
    MAKE_PROP(
        "Checksum (checksum[1])",
        "Checksum",
        PROP_TYPE_COMMENT,
        PROP_QUAL_NONE,
        0 ),

    // AdditionalTicket
    MAKE_PROP(
        "Additional ticket",
        "Additional ticket",
        PROP_TYPE_SUMMARY,
        PROP_QUAL_NONE,
        0 ),

    // EncryptionType
    MAKE_PROP(
        "Encryption type",
        "Encryption type",
        PROP_TYPE_DWORD,
        PROP_QUAL_LABELED_SET,
        &g_EncryptionTypeSet ),

    // ContinuationPacket
    MAKE_PROP(
        "Kerberos Packet (Cont.) Use the Coalescer to view contents",
        "Display Kerberos Continuation Packets",
        PROP_TYPE_SUMMARY,
        PROP_QUAL_NONE,
        0 ),

    // INTEGER_NOT_IN_ASN
    MAKE_PROP(
        "Unexpected integer value",
        "Unexpected integer",
        PROP_TYPE_DWORD,
        PROP_QUAL_NONE,
        0 ),

    // CompoundIdentity
    MAKE_PROP(
        "Compound Identity",
        "List of compound identities",
        PROP_TYPE_SUMMARY,
        PROP_QUAL_NONE,
        0 ),

    // CompoundIdentityTicket
    MAKE_PROP(
        "Identity",
        "Identity ticket",
        PROP_TYPE_SUMMARY,
        PROP_QUAL_NONE,
        0 ),
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\parser\kerbparser.cxx ===
//=============================================================================
//
//  MODULE: Kerbparser.cxx
//
//  Description:
//
//  Bloodhound Parser DLL for Kerberos Authentication Protocol
//
//  Modification History
//
//  Michael Webb & Kris Frost   Date: 06/04/99
//  Mark Pustilnik              Date: 02/04/02 - Clean-up / rewrite
//
//=============================================================================

#include "ASN1Parser.hxx"

//
//  Protocol entry points.
//

VOID
WINAPI
KerberosRegister(
    IN HPROTOCOL hKerberosProtocol
    );

VOID
WINAPI
KerberosDeregister(
    IN HPROTOCOL hKerberosProtocol
    );

LPBYTE
WINAPI
KerberosRecognizeFrame(
    IN HFRAME hFrame,
    IN ULPBYTE MacFrame,
    IN ULPBYTE KerberosFrame,
    IN DWORD MacType,
    IN DWORD BytesLeft,
    IN HPROTOCOL hPreviousProtocol,
    IN DWORD nPreviousProtocolOffset,
    OUT LPDWORD ProtocolStatusCode,
    OUT LPHPROTOCOL hNextProtocol,
    OUT PDWORD_PTR InstData
    );

LPBYTE
WINAPI
KerberosAttachProperties(
    IN HFRAME hFrame,
    IN ULPBYTE MacFrame,
    IN ULPBYTE KerberosFrame,
    IN DWORD MacType,
    IN DWORD BytesLeft,
    IN HPROTOCOL hPreviousProtocol,
    IN DWORD nPreviousProtocolOffset,
    IN DWORD_PTR InstData
    );

DWORD
WINAPI
KerberosFormatProperties(
    IN HFRAME hFrame,
    IN ULPBYTE MacFrame,
    IN ULPBYTE FrameData,
    IN DWORD nPropertyInsts,
    IN LPPROPERTYINST p
    );

ENTRYPOINTS g_KerberosEntryPoints =
{
    KerberosRegister,
    KerberosDeregister,
    KerberosRecognizeFrame,
    KerberosAttachProperties,
    KerberosFormatProperties
};

//
// Protocol handle
//

HPROTOCOL g_hKerberos = NULL;

//
// Protocol status
//

DWORD g_Attached  = 0;

//
// Protocol handles used to check for continuation packets.
//

HPROTOCOL g_hTCP = NULL;
HPROTOCOL g_hUDP = NULL;

//
// Definitions of exported functions
//

//-----------------------------------------------------------------------------
//
//  Routine name:   ParserAutoInstallInfo
//
//  Routine description:
//
//      Sets up a parser information structure describing which ports are
//      being listened on, etc.
//
//  Arguments:
//
//      None
//
//  Returns:
//
//      Pointer to a PF_PARSERDLLINFO structure describing the protocol
//
//-----------------------------------------------------------------------------

PPF_PARSERDLLINFO
ParserAutoInstallInfo()
{
    PPF_PARSERDLLINFO pParserDllInfo = NULL;
    PPF_PARSERINFO pParserInfo = NULL;
    PPF_HANDOFFSET pHandoffSet = NULL;
    PPF_HANDOFFENTRY pHandoffEntry = NULL;
    DWORD NumProtocols, NumHandoffs;

    //
    // Allocate memory for parser info
    //

    NumProtocols = 1;
    pParserDllInfo = (PPF_PARSERDLLINFO)HeapAlloc(
                          GetProcessHeap(),
                          HEAP_ZERO_MEMORY,
                          sizeof( PF_PARSERDLLINFO ) +
                             NumProtocols * sizeof( PF_PARSERINFO )
                          );

    if ( pParserDllInfo == NULL )
    {
        goto Error;
    }

    //
    // Fill in the parser DLL info
    //

    pParserDllInfo->nParsers = NumProtocols;

    pParserInfo = &(pParserDllInfo->ParserInfo[0]);

    strncpy(
        pParserInfo->szProtocolName,
        "KERBEROS",
        sizeof( pParserInfo->szProtocolName )
        );

    strncpy(
        pParserInfo->szComment,
        "Kerberos Authentication Protocol",
        sizeof( pParserInfo->szComment )
        );

    strncpy(
        pParserInfo->szHelpFile,
        "",
        sizeof( pParserInfo->szHelpFile )
        );

    NumHandoffs = 2;
    pHandoffSet = (PPF_HANDOFFSET)HeapAlloc(
                       GetProcessHeap(),
                       HEAP_ZERO_MEMORY,
                       sizeof( PF_HANDOFFSET ) +
                          NumHandoffs * sizeof( PF_HANDOFFENTRY )
                       );


    if ( pHandoffSet == NULL )
    {
        goto Error;
    }

    pParserInfo->pWhoHandsOffToMe = pHandoffSet;
    pHandoffSet->nEntries = NumHandoffs;

    //
    // UDP port 88
    //

    pHandoffEntry = &(pHandoffSet->Entry[0]);

    strncpy(
        pHandoffEntry->szIniFile,
        "TCPIP.INI",
        sizeof( pHandoffEntry->szIniFile )
        );

    strncpy(
        pHandoffEntry->szIniSection,
        "UDP_HandoffSet",
        sizeof( pHandoffEntry->szIniSection )
        );

    strncpy(
        pHandoffEntry->szProtocol,
        "KERBEROS",
        sizeof( pHandoffEntry->szProtocol )
        );

    pHandoffEntry->dwHandOffValue = 88; // TODO: make configurable?
    pHandoffEntry->ValueFormatBase = HANDOFF_VALUE_FORMAT_BASE_DECIMAL;

    //
    // TCP port 88
    //

    pHandoffEntry = &(pHandoffSet->Entry[0]);

    strncpy(
        pHandoffEntry->szIniFile,
        "TCPIP.INI",
        sizeof( pHandoffEntry->szIniFile )
        );

    strncpy(
        pHandoffEntry->szIniSection,
        "TCP_HandoffSet",
        sizeof( pHandoffEntry->szIniSection )
        );

    strncpy(
        pHandoffEntry->szProtocol,
        "KERBEROS",
        sizeof( pHandoffEntry->szProtocol )
        );

    pHandoffEntry->dwHandOffValue = 88; // TODO: make configurable?
    pHandoffEntry->ValueFormatBase = HANDOFF_VALUE_FORMAT_BASE_DECIMAL;

Cleanup:

    return pParserDllInfo;

Error:

    HeapFree( GetProcessHeap(), 0, pHandoffSet );
    pHandoffSet = NULL;

    HeapFree( GetProcessHeap(), 0, pParserDllInfo );
    pParserDllInfo = NULL;

    goto Cleanup;
}


//-----------------------------------------------------------------------------
//
//  Routine name:   DllEntry
//
//  Routine description:
//
//      Mail DLL entrypoint
//
//  Arguments:
//
//      hInstance       process instance
//      Command         ATTACH/DETACH/etc.
//      Reserved        Reserved
//
//  Returns:
//
//      Standard DllEntry TRUE or FALSE
//
//-----------------------------------------------------------------------------

extern "C" {

BOOL
WINAPI
DLLEntry(
    IN HANDLE hInstance,
    IN ULONG Command,
    IN LPVOID Reserved
    )
{
    if ( Command == DLL_PROCESS_ATTACH )
    {
        if ( g_Attached++ == 0 )
        {
            g_hKerberos = CreateProtocol(
                              "KERBEROS",
                              &g_KerberosEntryPoints,
                              ENTRYPOINTS_SIZE
                              );
        }
    }
    else if ( Command == DLL_PROCESS_DETACH )
    {
        if ( --g_Attached == 0 )
        {
            DestroyProtocol( g_hKerberos );
            g_hKerberos = NULL;
        }
    }

    return TRUE;  //... Bloodhound parsers ALWAYS return TRUE.
}

} // extern "C"

//-----------------------------------------------------------------------------
//
//  Routine name:   KerberosRegister
//
//  Routine description:
//
//      Registers the Kerberos protocol with the parser
//
//  Arguments:
//
//      hKerberosProtocol   protocol handle
//
//  Returns:
//
//      Nothing
//
//-----------------------------------------------------------------------------

VOID
WINAPI
KerberosRegister(
    IN HPROTOCOL hKerberosProtocol
    )
{
    DWORD NmErr;

    //
    // Start by creating the property database
    //

    NmErr = CreatePropertyDatabase(
                hKerberosProtocol,
                ARRAY_COUNT( g_KerberosDatabase )
                );

    if ( NmErr != NMERR_SUCCESS )
    {
        SetLastError( NmErr );
        return;
    }

    for ( DWORD i = 0;
          i < ARRAY_COUNT( g_KerberosDatabase );
          i++ )
    {
        if ( NULL == AddProperty(
                         hKerberosProtocol,
                         &g_KerberosDatabase[i] ))
        {
            // TODO: find a better way to report this error
            SetLastError( ERROR_INTERNAL_ERROR );
            return;
        }
    }

    //
    // Check to see whether TCP or UDP are being used
    //

    g_hTCP = GetProtocolFromName( "TCP" );
    g_hUDP = GetProtocolFromName( "UDP" );

    return;
}


//-----------------------------------------------------------------------------
//
//  Routine name:   KerberosDeregister
//
//  Routine description:
//
//      Unregisters the Kerberos protocol from the parser
//
//  Arguments:
//
//      hKerberosProtocol   protocol handle
//
//  Returns:
//
//      Nothing
//
//-----------------------------------------------------------------------------

VOID
WINAPI
KerberosDeregister(
    IN HPROTOCOL hKerberosProtocol
    )
{
    DestroyPropertyDatabase( hKerberosProtocol );
}


//-----------------------------------------------------------------------------
//
//  Routine name:   KerberosRecognizeFrame
//
//  Routine description:
//
//      Looks at a frame with the purpose of "recognizing it".
//      Kerberos has no sub-protocols, so every frame is claimed.
//
//  Arguments:
//
//      hFrame                  frame handle
//      MacFrame                frame pointer
//      KerberosFrame           relative pointer
//      MacType                 MAC type
//      BytesLeft               bytes left
//      hPreviousProtocol       previous protocol or NULL if none
//      nPreviousProtocolOffset offset of previous protocols
//      ProtocolStatusCode      used to return the status code
//      hNextProtocol           next protocol to call (optional)
//      InstData                next protocol instance data
//
//  Returns:
//
//      Nothing
//
//-----------------------------------------------------------------------------

LPBYTE
WINAPI
KerberosRecognizeFrame(
    IN HFRAME hFrame,
    IN ULPBYTE MacFrame,
    IN ULPBYTE KerberosFrame,
    IN DWORD MacType,
    IN DWORD BytesLeft,
    IN HPROTOCOL hPreviousProtocol,
    IN DWORD nPreviousProtocolOffset,
    OUT LPDWORD ProtocolStatusCode,
    OUT LPHPROTOCOL hNextProtocol,
    OUT PDWORD_PTR InstData
    )
{
    //
    // There are no sub-protocols; claim every frame
    //

    *ProtocolStatusCode = PROTOCOL_STATUS_CLAIMED;
    return NULL;
}


//-----------------------------------------------------------------------------
//
//  Routine name:   KerberosAttachProperties
//
//  Routine description:
//
//      Parses out the frame given the request type
//
//  Arguments:
//
//      hFrame                  frame handle
//      MacFrame                frame pointer
//      KerberosFrame           relative pointer
//      MacType                 MAC type
//      BytesLeft               bytes left
//      hPreviousProtocol       previous protocol or NULL if none
//      nPreviousProtocolOffset offset of previous protocols
//      InstData                next protocol instance data
//
//  Returns:
//
//      Pointer to data just past whatever was consumed or NULL on error
//
//-----------------------------------------------------------------------------

LPBYTE
WINAPI
KerberosAttachProperties(
    IN HFRAME hFrame,
    IN ULPBYTE MacFrame,
    IN ULPBYTE KerberosFrame,
    IN DWORD MacType,
    IN DWORD BytesLeft,
    IN HPROTOCOL hPreviousProtocol,
    IN DWORD nPreviousProtocolOffset,
    IN DWORD_PTR InstData
    )
{
    LPBYTE pKerberosFrame; // pointer to a TCP or UDP frame
    LPBYTE Address;

    //
    // Check to see if first two octets of the frame are equal to 00 00 which
    // would be the case should the packet be the first of TCP
    //

    if( KerberosFrame[0] == 0x00 &&
        KerberosFrame[1] == 0x00 )
    {
        Address = KerberosFrame+4; // TODO: add frame length check?
        pKerberosFrame = Address;
    }
    else
    {
        Address = KerberosFrame;
        pKerberosFrame = Address;
    }

    //
    // Here we are going to do a check to see if the packet is TCP and
    // check to see if the first two octets of the packet don't have the
    // value of 00 00.  If not, then we mark the frame as a continuation
    // packet.  Reason for doing this is because, sometimes 0x1F of the
    // first packet can still match one of the case statements which
    // erroneously displays a continuation packet.
    //

    if( hPreviousProtocol == g_hTCP &&
        KerberosFrame[0] != 0 &&
        KerberosFrame[1] != 0 )
    {
        //
        // Treat this as a continutation packet
        //

        if ( FALSE == AttachPropertyInstance(
                          hFrame,
                          g_KerberosDatabase[ContinuationPacket].hProperty,
                          BytesLeft,
                          Address,
                          0,
                          0,
                          0 ))
        {
            return NULL;
        }
    }
    else
    {
        //
        // pKerberosFrame is a local variable and is used
        // to display TCP data as well.
        //

        switch (*(pKerberosFrame) & 0x1F)
        {
        case ASN1_KRB_AS_REQ:
        case ASN1_KRB_TGS_REQ:
        {
            //
            // AS-REQ ::=  [APPLICATION 10] KDC-REQ
            // TGS-REQ ::= [APPLICATION 12] KDC-REQ
            //

            DWORD dw;
            ASN1FRAME Frame;
            HPROPERTY hProp;

            Frame.Address = Address;
            Frame.hFrame = hFrame;
            Frame.Level = 0;

            if (( *(pKerberosFrame) & 0x1F )  == ASN1_KRB_AS_REQ )
            {
                hProp = PROP( KRB_AS_REQ );
            }
            else
            {
                hProp = PROP( KRB_TGS_REQ );
            }

            ASN1ParserKdcReq
            KdcReq(
                FALSE,
                BuildDescriptor( ctApplication, pcConstructed, (*(pKerberosFrame) & 0x1F)),
                hProp );

            dw = KdcReq.Parse( &Frame );

            //
            // TODO: display "data in error" if unhappy
            //

            break;
        }

        case ASN1_KRB_AS_REP:
        case ASN1_KRB_TGS_REP:
        {
            //
            // AS-REP ::=    [APPLICATION 11] KDC-REP
            // TGS-REP ::=   [APPLICATION 13] KDC-REP
            //

            DWORD dw;
            ASN1FRAME Frame;
            HPROPERTY hProp;

            Frame.Address = Address;
            Frame.hFrame = hFrame;
            Frame.Level = 0;

            if (( *(pKerberosFrame) & 0x1F )  == ASN1_KRB_AS_REP )
            {
                hProp = PROP( KRB_AS_REP );
            }
            else
            {
                hProp = PROP( KRB_TGS_REP );
            }

            ASN1ParserKdcRep
            KdcRep(
                FALSE,
                BuildDescriptor( ctApplication, pcConstructed, (*(pKerberosFrame) & 0x1F)),
                hProp );

            dw = KdcRep.Parse( &Frame );

            //
            // TODO: display "data in error" if unhappy
            //

            break;
        }

        case ASN1_KRB_ERROR:
        {
            DWORD dw;
            ASN1FRAME Frame;

            Frame.Address = Address;
            Frame.hFrame = hFrame;
            Frame.Level = 0;

            ASN1ParserKrbError
            KrbError(
                FALSE,
                BuildDescriptor( ctApplication, pcConstructed, (*(pKerberosFrame) & 0x1F)),
                PROP( KRB_ERROR ));

            dw = KrbError.Parse( &Frame );

            //
            // TODO: display "data in error" if unhappy
            //

            break;
        }

        case ASN1_KRB_AP_REQ:
        case ASN1_KRB_AP_REP:
        case ASN1_KRB_SAFE:
        case ASN1_KRB_PRIV:
        case ASN1_KRB_CRED:
        default:

            //
            // TODO: this is most certainly wrong; use a different property handle
            //

            if ( FALSE == AttachPropertyInstance(hFrame,
                              g_KerberosDatabase[ContinuationPacket].hProperty,
                              BytesLeft,
                              Address,
                              0,
                              0,
                              0 ))
            {
                return NULL;
            }

            break;
        }
    }

    return (LPBYTE) KerberosFrame + BytesLeft;
}


DWORD
WINAPI
KerberosFormatProperties(
    IN HFRAME hFrame,
    IN ULPBYTE MacFrame,
    IN ULPBYTE FrameData,
    IN DWORD nPropertyInsts,
    IN LPPROPERTYINST p
    )
{
    //=========================================================================
    //  Format each property in the property instance table.
    //
    //  The property-specific instance data was used to store the address of a
    //  property-specific formatting function so all we do here is call each
    //  function via the instance data pointer.
    //=========================================================================

    //
    // Doing a check here for TCP packets.  If it's the first packet,
    // we increment FrameData by 4 to get past the length header
    //

    if ( FrameData[0] == 0x00 &&
         FrameData[1] == 0x00 )
    {
        FrameData += 4;
    }

    while ( nPropertyInsts-- )
    {
        ((FORMAT) p->lpPropertyInfo->InstanceData)(p);

        p++;
    }

    return NMERR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\rtl\pacndr_c_stub.c ===
#include <krbprgma.h>
#include "pacndr_c.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\rtl\pacndr_s_stub.c ===
#include <krbprgma.h>
#include "pacndr_s.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\rtl\pac.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1996
//
// File:        pac.cxx
//
// Contents:    Implementation of routines to manipulate new PACs
//
// Description:
//
//
// History:     23-Jan-96   MikeSw      Created
//
//------------------------------------------------------------------------

#include "krbprgma.h"
#include <secpch2.hxx>
#pragma hdrstop

#include <pac.hxx>
#include <sectrace.hxx>
#include <ntlmsp.h>

extern "C"
{
#include <align.h>
#include <ntsam.h>
#include <lmaccess.h>
#include <midles.h>
#include <pacndr.h>
}


//+-------------------------------------------------------------------------
//
//  Function:   Helper Functions for NDR encoding data types
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


typedef struct _PAC_BUFFER_STATE {
    PBYTE   BufferPointer;
    ULONG   BufferSize;
} PAC_BUFFER_STATE, *PPAC_BUFFER_STATE;

VOID NTAPI
PacAllocFcn(
    IN OUT  PVOID pvState,
    OUT PCHAR * ppbOut,
    IN PUINT32 pulSize
    )
{
    PPAC_BUFFER_STATE state = (PPAC_BUFFER_STATE) pvState;

    //
    // MIDL pickling calls this routine with the size of the object
    // obtained by _GetSize(). This routine must return a buffer in
    // ppbOut with at least *pulSize bytes.
    //

    DsysAssert( state->BufferPointer != NULL );
    DsysAssert( state->BufferSize >= *pulSize );

    *ppbOut = (char*)state->BufferPointer;
    state->BufferPointer += *pulSize;
    state->BufferSize -= *pulSize;
}

VOID NTAPI
PacWriteFcn(
    IN OUT PVOID pvState,
    OUT PCHAR pbOut,
    IN UINT32 ulSize
    )
{
    //
    // Since the data was pickled directly to the target buffer, don't
    // do anything here.
    //
}

VOID NTAPI
PacReadFcn(
    IN OUT PVOID pvState,
    OUT PCHAR * ppbOut,
    IN OUT PUINT32 pulSize
    )
{
    PPAC_BUFFER_STATE state = (PPAC_BUFFER_STATE) pvState;

    //
    // MIDL pickling calls this routine with the size to read.
    // This routine must return a buffer in ppbOut which contains the
    // encoded data.
    //

    DsysAssert( state->BufferPointer != NULL );
    DsysAssert( state->BufferSize >= *pulSize );

    *ppbOut = (char*)state->BufferPointer;
    state->BufferPointer += *pulSize;
    state->BufferSize -= *pulSize;
}

//+-------------------------------------------------------------------------
//
//  Function:   PAC_EncodeValidationInformation
//
//  Synopsis:   NDR encodes the validation information
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
PAC_EncodeValidationInformation(
    IN PNETLOGON_VALIDATION_SAM_INFO3 ValidationInfo,
    OUT PBYTE * EncodedData,
    OUT PULONG DataSize
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    handle_t PickleHandle = 0;
    PAC_BUFFER_STATE BufferState = {0};
    ULONG EncodingStatus = 0;
    PUCHAR OutputBuffer = NULL;
    ULONG OutputSize = 0;


    EncodingStatus = MesEncodeIncrementalHandleCreate(
                        &BufferState,
                        PacAllocFcn,
                        PacWriteFcn,
                        &PickleHandle
                        );
    if (EncodingStatus != 0)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Calculate the size of the required buffer
    //

    OutputSize = (ULONG) PPAC_IDL_VALIDATION_INFO_AlignSize(
                                        PickleHandle,
                                        &ValidationInfo
                                        );

    OutputBuffer = (PBYTE) MIDL_user_allocate(OutputSize);
    if (OutputBuffer == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    BufferState.BufferSize = OutputSize;
    BufferState.BufferPointer = OutputBuffer;

    //
    // Now encode the structure
    //

    MesIncrementalHandleReset(
        PickleHandle,
        NULL,
        NULL,
        NULL,
        NULL,
        MES_ENCODE
        );

    PPAC_IDL_VALIDATION_INFO_Encode(
        PickleHandle,
        &ValidationInfo
        );

    *EncodedData = OutputBuffer;
    *DataSize = OutputSize;
    OutputBuffer = NULL;

Cleanup:

    if (OutputBuffer != NULL)
    {
        MIDL_user_free(OutputBuffer);
    }
    if (PickleHandle != NULL)
    {
        MesHandleFree(PickleHandle);
    }

    return(Status);
}



//+-------------------------------------------------------------------------
//
//  Function:   PAC_DecodeValidationInformation
//
//  Synopsis:   NDR decodes the validation information
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
PAC_DecodeValidationInformation(
    IN PBYTE EncodedData,
    IN ULONG DataSize,
    OUT PNETLOGON_VALIDATION_SAM_INFO3 * ValidationInfo
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    handle_t PickleHandle = 0;
    PAC_BUFFER_STATE BufferState = {0};
    ULONG EncodingStatus = 0;

    DsysAssert(ROUND_UP_POINTER(EncodedData,8) == (PVOID) EncodedData);

    EncodingStatus = MesDecodeIncrementalHandleCreate(
                        &BufferState,
                        PacReadFcn,
                        &PickleHandle
                        );
    if (EncodingStatus != 0)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    BufferState.BufferSize = DataSize;
    BufferState.BufferPointer = EncodedData;
    __try {
        PPAC_IDL_VALIDATION_INFO_Decode(
            PickleHandle,
            ValidationInfo
            );
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

Cleanup:
    if (PickleHandle != NULL)
    {
        MesHandleFree(PickleHandle);
    }

    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   PAC_EncodeCredentialData
//
//  Synopsis:   NDR encodes the credential data
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
PAC_EncodeCredentialData(
    IN PSECPKG_SUPPLEMENTAL_CRED_ARRAY CredentialData,
    OUT PBYTE * EncodedData,
    OUT PULONG DataSize
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    handle_t PickleHandle = 0;
    PAC_BUFFER_STATE BufferState = {0};
    ULONG EncodingStatus = 0;
    PUCHAR OutputBuffer = NULL;
    ULONG OutputSize = 0;


    EncodingStatus = MesEncodeIncrementalHandleCreate(
                        &BufferState,
                        PacAllocFcn,
                        PacWriteFcn,
                        &PickleHandle
                        );
    if (EncodingStatus != 0)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Calculate the size of the required buffer
    //

    OutputSize = (ULONG) PPAC_IDL_CREDENTIAL_DATA_AlignSize(
                                        PickleHandle,
                                        &CredentialData
                                        );

    OutputBuffer = (PBYTE) MIDL_user_allocate(OutputSize);
    if (OutputBuffer == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    BufferState.BufferSize = OutputSize;
    BufferState.BufferPointer = OutputBuffer;

    //
    // Now encode the structure
    //

    MesIncrementalHandleReset(
        PickleHandle,
        NULL,
        NULL,
        NULL,
        NULL,
        MES_ENCODE
        );

    PPAC_IDL_CREDENTIAL_DATA_Encode(
        PickleHandle,
        &CredentialData
        );

    *EncodedData = OutputBuffer;
    *DataSize = OutputSize;
    OutputBuffer = NULL;

Cleanup:
    if (OutputBuffer != NULL)
    {
        MIDL_user_free(OutputBuffer);
    }
    if (PickleHandle != NULL)
    {
        MesHandleFree(PickleHandle);
    }

    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   PAC_DecodeCredentialData
//
//  Synopsis:   NDR decodes the validation information
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
PAC_DecodeCredentialData(
    IN PBYTE EncodedData,
    IN ULONG DataSize,
    OUT PSECPKG_SUPPLEMENTAL_CRED_ARRAY * CredentialData
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    handle_t PickleHandle = 0;
    PAC_BUFFER_STATE BufferState = {0};
    ULONG EncodingStatus = 0;

    DsysAssert(ROUND_UP_POINTER(EncodedData,8) == (PVOID) EncodedData);

    EncodingStatus = MesDecodeIncrementalHandleCreate(
                        &BufferState,
                        PacReadFcn,
                        &PickleHandle
                        );
    if (EncodingStatus != 0)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    BufferState.BufferSize = DataSize;
    BufferState.BufferPointer = EncodedData;
    __try {
        PPAC_IDL_CREDENTIAL_DATA_Decode(
            PickleHandle,
            CredentialData
            );
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

Cleanup:
    if (PickleHandle != NULL)
    {
        MesHandleFree(PickleHandle);
    }

    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   PAC_EncodeTokenRestrictions
//
//  Synopsis:   NDR encodes the token restrictions
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

extern "C"
NTSTATUS
PAC_EncodeTokenRestrictions(
    IN PKERB_TOKEN_RESTRICTIONS TokenRestrictions,
    OUT PBYTE * EncodedData,
    OUT PULONG DataSize
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    handle_t PickleHandle = 0;
    PAC_BUFFER_STATE BufferState = {0};
    ULONG EncodingStatus = 0;
    PUCHAR OutputBuffer = NULL;
    ULONG OutputSize = 0;


    EncodingStatus = MesEncodeIncrementalHandleCreate(
                        &BufferState,
                        PacAllocFcn,
                        PacWriteFcn,
                        &PickleHandle
                        );
    if (EncodingStatus != 0)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Calculate the size of the required buffer
    //

    OutputSize = (ULONG) PKERB_TOKEN_RESTRICTIONS_AlignSize(
                                        PickleHandle,
                                        &TokenRestrictions
                                        );

    OutputBuffer = (PBYTE) MIDL_user_allocate(OutputSize);
    if (OutputBuffer == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    BufferState.BufferSize = OutputSize;
    BufferState.BufferPointer = OutputBuffer;

    //
    // Now encode the structure
    //

    MesIncrementalHandleReset(
        PickleHandle,
        NULL,
        NULL,
        NULL,
        NULL,
        MES_ENCODE
        );

    PKERB_TOKEN_RESTRICTIONS_Encode(
        PickleHandle,
        &TokenRestrictions
        );

    *EncodedData = OutputBuffer;
    *DataSize = OutputSize;
    OutputBuffer = NULL;

Cleanup:
    if (OutputBuffer != NULL)
    {
        MIDL_user_free(OutputBuffer);
    }
    if (PickleHandle != NULL)
    {
        MesHandleFree(PickleHandle);
    }

    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   PAC_DecodeTokenRestrictions
//
//  Synopsis:   NDR decodes the token restrictions
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
extern "C"
NTSTATUS
PAC_DecodeTokenRestrictions(
    IN PBYTE EncodedData,
    IN ULONG DataSize,
    OUT PKERB_TOKEN_RESTRICTIONS * TokenRestrictions
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    handle_t PickleHandle = 0;
    PAC_BUFFER_STATE BufferState = {0};
    ULONG EncodingStatus = 0;

    DsysAssert(ROUND_UP_POINTER(EncodedData,8) == (PVOID) EncodedData);

    EncodingStatus = MesDecodeIncrementalHandleCreate(
                        &BufferState,
                        PacReadFcn,
                        &PickleHandle
                        );
    if (EncodingStatus != 0)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    BufferState.BufferSize = DataSize;
    BufferState.BufferPointer = EncodedData;
    __try {
        PKERB_TOKEN_RESTRICTIONS_Decode(
            PickleHandle,
            TokenRestrictions
            );
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

Cleanup:
    if (PickleHandle != NULL)
    {
        MesHandleFree(PickleHandle);
    }

    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   PAC_EncodeS4UDelegationInformation
//
//  Synopsis:   NDR encodes the S4U delegation information
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
PAC_EncodeS4UDelegationInformation(
    IN PS4U_DELEGATION_INFO S4UDelegationInfo,
    OUT PBYTE * EncodedData,
    OUT PULONG DataSize
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    handle_t PickleHandle = 0;
    PAC_BUFFER_STATE BufferState = {0};
    ULONG EncodingStatus = 0;
    PUCHAR OutputBuffer = NULL;
    ULONG OutputSize = 0;

    EncodingStatus = MesEncodeIncrementalHandleCreate(
                        &BufferState,
                        PacAllocFcn,
                        PacWriteFcn,
                        &PickleHandle
                        );
    if (EncodingStatus != 0)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Calculate the size of the required buffer
    //

    OutputSize = (ULONG) PPAC_IDL_S4U_DELEGATION_INFO_AlignSize(
                                PickleHandle,
                                &S4UDelegationInfo
                                );

    OutputBuffer = (PBYTE) MIDL_user_allocate(OutputSize);
    if (OutputBuffer == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    BufferState.BufferSize = OutputSize;
    BufferState.BufferPointer = OutputBuffer;

    //
    // Now encode the structure
    //

    MesIncrementalHandleReset(
        PickleHandle,
        NULL,
        NULL,
        NULL,
        NULL,
        MES_ENCODE
        );

    PPAC_IDL_S4U_DELEGATION_INFO_Encode(
        PickleHandle,
        &S4UDelegationInfo
        );

    *EncodedData = OutputBuffer;
    *DataSize = OutputSize;
    OutputBuffer = NULL;

Cleanup:
    if (OutputBuffer != NULL)
    {
        MIDL_user_free(OutputBuffer);
    }
    if (PickleHandle != NULL)
    {
        MesHandleFree(PickleHandle);
    }

    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   PAC_DecodeS4UDelegationInformation
//
//  Synopsis:   NDR decodes the S4U delegation information
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
PAC_DecodeS4UDelegationInformation(
    IN PBYTE EncodedData,
    IN ULONG DataSize,
    OUT PS4U_DELEGATION_INFO * S4UDelegationInfo
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    handle_t PickleHandle = 0;
    PAC_BUFFER_STATE BufferState = {0};
    ULONG EncodingStatus = 0;

    DsysAssert(ROUND_UP_POINTER(EncodedData,8) == (PVOID) EncodedData);

    EncodingStatus = MesDecodeIncrementalHandleCreate(
                        &BufferState,
                        PacReadFcn,
                        &PickleHandle
                        );
    if (EncodingStatus != 0)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    BufferState.BufferSize = DataSize;
    BufferState.BufferPointer = EncodedData;
    __try {
        PPAC_IDL_S4U_DELEGATION_INFO_Decode(
            PickleHandle,
            S4UDelegationInfo
            );
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

Cleanup:
    if (PickleHandle != NULL)
    {
        MesHandleFree(PickleHandle);
    }

    return(Status);
}

//+---------------------------------------------------------------------------
//
//  Function:   PAC_GetSize
//
//  Synopsis:   Determines the number of bytes required to marshal the
//              given PAC.
//
//  Arguments:
//
//  History:    24-May-95   SuChang     Created
//
//  Notes:
//
//----------------------------------------------------------------------------
ULONG
PAC_GetSize( IN  PACTYPE  *pPac )
{
    ULONG cbSize = 0;

    if (pPac != NULL)
    {
        cbSize += sizeof( PACTYPE );
        cbSize += (pPac->cBuffers - ANYSIZE_ARRAY) * sizeof(PAC_INFO_BUFFER);
        cbSize = ROUND_UP_COUNT( cbSize, ALIGN_QUAD );
        for (ULONG i = 0; i < pPac->cBuffers; i++ )
        {
            cbSize += ROUND_UP_COUNT(pPac->Buffers[i].cbBufferSize, ALIGN_QUAD);
        }
    }

    return (cbSize);
}


//+---------------------------------------------------------------------------
//
//  Function:   PAC_Marshal
//
//  Synopsis:   Marshals the given PAC into the provided buffer.
//
//  Arguments:
//
//  History:    24-May-95   SuChang     Created
//
//  Notes:      This assumes the PAC is the same form as created
//              by PAC_Init. See header description of the PAC
//              structure.
//
//              Returns the number of bytes used or 0 if an error
//              occurred.
//
//----------------------------------------------------------------------------

ULONG
PAC_Marshal( IN  PACTYPE   *pPac,
             IN  ULONG      cbBuffer,
             OUT PBYTE      pBufferOut)
{
    DsysAssert( pPac != NULL && pBufferOut != NULL );

    ULONG PacLen = PAC_GetSize( pPac );

    if (cbBuffer < PacLen)
    {
        return 0;
    }

    //
    // Copy into pBufferOut and then change the pointers of each
    // PAC_INFO_BUFFER to be offsets from pPac.
    //

    CopyMemory( pBufferOut, pPac, PacLen );

    PPACTYPE pPacTemp = (PPACTYPE) pBufferOut;

    for (ULONG i = 0; i < pPacTemp->cBuffers; i++ )
    {
        pPacTemp->Buffers[i].Offset = (ULONG) (pPacTemp->Buffers[i].Data -
                                             (PBYTE)pPac);
    }

    return PacLen;
}


//+---------------------------------------------------------------------------
//
//  Function:   PAC_UnMarshal
//
//  Synopsis:   Does in place unmarshalling of the marshalled PAC.
//
//  Arguments:
//
//  History:    24-May-95   SuChang     Created
//
//  Notes:      Does in place unmarshalling. No new memory is allocated.
//
//              This assumes the PAC is the same form as created
//              by PAC_Init. See header description of the PAC
//              structure.
//
//----------------------------------------------------------------------------

ULONG
PAC_UnMarshal( IN PPACTYPE  pPac,
               IN ULONG cbSize )
{
    ULONG i;
    ULONG cbUnmarshalled = 0;
    PBYTE pEnd = (PBYTE)pPac + cbSize;
    PBYTE pBufferAddress;

    DsysAssert( pPac != NULL );


    //
    // Do a validation loop. Make sure that the offsets are
    // correct. We don't want to do this validation inside the modification
    // loop because it wouldn't be nice to change the buffer if it weren't
    // valid.
    //

    if ((pPac->cBuffers * sizeof(PAC_INFO_BUFFER) + sizeof(PACTYPE)) > cbSize)
    {
        return(0);
    }

    if (pPac->Version != PAC_VERSION)
    {
        return(0);
    }
    for (i = 0; i < pPac->cBuffers; i++)
    {
        pBufferAddress = (ULONG)pPac->Buffers[i].Offset + (PBYTE)pPac;

        if ( (pBufferAddress >= pEnd ) || (pBufferAddress < (PBYTE) pPac) ||
             (pBufferAddress + pPac->Buffers[i].cbBufferSize > pEnd))
        {
            //
            // Invalid offset or length
            //
            return (0);
        }
    }

    for (i = 0; i < pPac->cBuffers; i++ )
    {
        cbUnmarshalled += pPac->Buffers[i].cbBufferSize;
        pPac->Buffers[i].Data = pPac->Buffers[i].Offset +
                                    (PBYTE)pPac;
    }

    return (cbUnmarshalled);
}

//+---------------------------------------------------------------------------
//
//  Function:   PAC_ReMarshal
//
//  Synopsis:   Does in place re-marshalling of an un-marshalled PAC.
//
//  Arguments:
//
//  History:    24-May-95   SuChang     Created
//
//  Notes:      Does in place re-marshalling. No new memory is allocated.
//
//              This assumes the PAC is the same form as created
//              by PAC_UnMarshal. See header description of the PAC
//              structure.
//
//----------------------------------------------------------------------------

BOOLEAN
PAC_ReMarshal( IN PPACTYPE  pPac,
               IN ULONG cbSize )
{
    ULONG Offset;
    ULONG i;

    //
    // Do a validation loop. Make sure that the offsets are
    // correct. We don't want to do this validation inside the modification
    // loop because it wouldn't be nice to change the buffer if it weren't
    // valid.
    //

    for (i = 0; i < pPac->cBuffers; i++ )
    {
        Offset = (ULONG) (pPac->Buffers[i].Data - (PBYTE) pPac);
        if ( Offset >= cbSize )
        {
            //
            // Invalid offset or length
            //

            return (FALSE);
        }
        pPac->Buffers[i].Offset = Offset;
    }

    return (TRUE);
}


VOID
PAC_PutString(
    IN PVOID Base,
    IN PUNICODE_STRING OutString,
    IN PUNICODE_STRING InString,
    IN PUCHAR *Where
    )

/*++

Routine Description:

    This routine copies the InString string to the memory pointed to by
    the Where parameter, and fixes the OutString string to point to that
    new copy.

Parameters:

    OutString - A pointer to a destination NT string

    InString - A pointer to an NT string to be copied

    Where - A pointer to space to put the actual string for the
        OutString.  The pointer is adjusted to point to the first byte
        following the copied string.

Return Values:

    None.

--*/

{
    DsysAssert( OutString != NULL );
    DsysAssert( InString != NULL );
    DsysAssert( Where != NULL && *Where != NULL);
    DsysAssert( *Where == ROUND_UP_POINTER( *Where, sizeof(WCHAR) ) );

    if ( InString->Length > 0 ) {

        OutString->Buffer = (PWCH) *Where;
        OutString->MaximumLength = (USHORT)(InString->Length + sizeof(WCHAR));

        RtlCopyUnicodeString( OutString, InString );

        //
        // Rest the pointer to be an offset.
        //
        OutString->Buffer = (PWCH) (*Where - (PUCHAR) Base);

        *Where += InString->Length;
//        *((WCHAR *)(*Where)) = L'\0';
        *(*Where) = '\0';
        *(*Where + 1) = '\0';
        *Where += 2;

    } else {
        RtlInitUnicodeString(OutString, NULL);
    }

    return;
}


//+-------------------------------------------------------------------------
//
//  Function:   PAC_MarshallValidationInfo
//
//  Synopsis:   marshals a NETLOGON_VALIDATION_SAM_INFO2
//
//  Effects:    allocates memory with MIDL_user_allocate
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
PAC_MarshallValidationInfo
(
    IN PSAMPR_USER_ALL_INFORMATION UserAll,
    IN PSAMPR_GET_GROUPS_BUFFER GroupsBuffer,
    IN PSID_AND_ATTRIBUTES_LIST ExtraGroups,
    IN PSID LogonDomainId,
    IN PUNICODE_STRING LogonDomainName,
    IN PUNICODE_STRING LogonServer,
    IN BOOLEAN IncludeUserParms,
    IN BOOLEAN NetworkProfile,
    OUT PBYTE * ValidationInfo,
    OUT PULONG ValidationInfoSize
    )
{
    NETLOGON_VALIDATION_SAM_INFO3 ValidationSam = {0};
    PNETLOGON_SID_AND_ATTRIBUTES MarshalledSids = NULL;
    SID ServerSid =  {SID_REVISION, 1, SECURITY_NT_AUTHORITY, SECURITY_SERVER_LOGON_RID };
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG ExtraGroupCount = 0;
    ULONG Index;

    //
    // Allocate a return buffer for validation information.
    //  (Return less information for a network logon)
    //  (Return UserParameters for a MNS logon)
    //

    //
    // First calculate the space needed for the extra groups.
    //

    if (ARGUMENT_PRESENT(ExtraGroups))
    {
        ExtraGroupCount += ExtraGroups->Count;
    }

    //
    // Add the enterprise server's sids
    //

    if ((UserAll->UserAccountControl & USER_SERVER_TRUST_ACCOUNT) != 0)
    {
        ExtraGroupCount += 1;
    }

    //
    // Set the UF_SMARTCARD_REQUIRED flag
    //
    if ((UserAll->UserAccountControl & USER_SMARTCARD_REQUIRED) != 0)
    {
        ValidationSam.UserFlags |= UF_SMARTCARD_REQUIRED;
    }


    //
    // Copy the scalars to the validation buffer.
    //


    ValidationSam.LogonTime = UserAll->LastLogon;

    //
    // BUG 455821: need logoff time & kickoff time
    //
#ifdef notdef
    NEW_TO_OLD_LARGE_INTEGER( LogoffTime, ValidationSam.LogoffTime );
    NEW_TO_OLD_LARGE_INTEGER( KickoffTime, ValidationSam.KickOffTime );
#else
    ValidationSam.LogoffTime.LowPart = 0xffffffff;
    ValidationSam.LogoffTime.HighPart = 0x7fffffff;
    ValidationSam.KickOffTime.LowPart = 0xffffffff;
    ValidationSam.KickOffTime.HighPart = 0x7fffffff;
#endif

    ValidationSam.PasswordLastSet = UserAll->PasswordLastSet;
    ValidationSam.PasswordCanChange = UserAll->PasswordCanChange;
    ValidationSam.PasswordMustChange = UserAll->PasswordMustChange;

    ValidationSam.LogonCount = UserAll->LogonCount;
    ValidationSam.BadPasswordCount = UserAll->BadPasswordCount;
    ValidationSam.UserId = UserAll->UserId;
    ValidationSam.PrimaryGroupId = UserAll->PrimaryGroupId;
    if (ARGUMENT_PRESENT( GroupsBuffer) )
    {
        ValidationSam.GroupCount = GroupsBuffer->MembershipCount;
        ValidationSam.GroupIds = GroupsBuffer->Groups;
    }
    else
    {
        ValidationSam.GroupCount = 0;
        ValidationSam.GroupIds = NULL;
    }


    ValidationSam.ExpansionRoom[SAMINFO_USER_ACCOUNT_CONTROL] = UserAll->UserAccountControl;
    //
    // If the client asked for extra information, return that
    // we support it
    //

    ValidationSam.UserFlags |= LOGON_EXTRA_SIDS;

    //
    // Copy ULONG aligned data to the validation buffer.
    //

    if (ExtraGroupCount != 0)
    {

        ValidationSam.SidCount = ExtraGroupCount;
        MarshalledSids = (PNETLOGON_SID_AND_ATTRIBUTES) MIDL_user_allocate(ExtraGroupCount * sizeof(NETLOGON_SID_AND_ATTRIBUTES));
        if (MarshalledSids == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        ValidationSam.ExtraSids = MarshalledSids;
        Index = 0;

        if (ARGUMENT_PRESENT(ExtraGroups))
        {
            //
            // Now marshall each sid into the buffer
            //

            C_ASSERT(sizeof(SID_AND_ATTRIBUTES) == sizeof(NETLOGON_SID_AND_ATTRIBUTES));

            RtlCopyMemory(
                &MarshalledSids[Index],
                ExtraGroups->SidAndAttributes,
                ExtraGroups->Count * sizeof(SID_AND_ATTRIBUTES)
                );
            Index += ExtraGroups->Count;
        }

        //
        // Add in special sids for domain controllers
        //

        if ((UserAll->UserAccountControl & USER_SERVER_TRUST_ACCOUNT) != 0)
        {
            //
            // Add in the constant server logon sid
            //

            MarshalledSids[Index].Attributes = SE_GROUP_MANDATORY |
                                               SE_GROUP_ENABLED |
                                               SE_GROUP_ENABLED_BY_DEFAULT;


            MarshalledSids[Index].Sid = &ServerSid;
            Index++;


        }
    }


    ValidationSam.LogonDomainId = LogonDomainId;


    //
    // Copy WCHAR aligned data to the validation buffer.
    //  (Return less information for a network logon)
    //


    if ( ! NetworkProfile ) {

        ValidationSam.EffectiveName = *(PUNICODE_STRING)&UserAll->UserName;
        ValidationSam.FullName = *(PUNICODE_STRING)&UserAll->FullName;
        ValidationSam.LogonScript = *(PUNICODE_STRING)&UserAll->ScriptPath;

        ValidationSam.ProfilePath = *(PUNICODE_STRING)&UserAll->ProfilePath;

        ValidationSam.HomeDirectory = *(PUNICODE_STRING)&UserAll->HomeDirectory;

        ValidationSam.HomeDirectoryDrive = *(PUNICODE_STRING)&UserAll->HomeDirectoryDrive;

    }

    ValidationSam.LogonServer = *LogonServer;


    ValidationSam.LogonDomainName = *LogonDomainName;


    //
    // Kludge: Pass back UserParameters in HomeDirectoryDrive since we
    // can't change the NETLOGON_VALIDATION_SAM_INFO2 structure between
    // releases NT 1.0 and NT 1.0A. HomeDirectoryDrive was NULL for release 1.0A
    // so we'll use that field.
    //

    if ( IncludeUserParms && NetworkProfile ) {
        ValidationSam.HomeDirectoryDrive = *(PUNICODE_STRING)&UserAll->Parameters;
    }

    Status = PAC_EncodeValidationInformation(
                &ValidationSam,
                ValidationInfo,
                ValidationInfoSize
                );

Cleanup:

    if (MarshalledSids != NULL)
    {
        MIDL_user_free(MarshalledSids);
    }
    return(Status);

}

//+-------------------------------------------------------------------------
//
//  Function:   PAC_MarshallValidationInfoWithGroups
//
//  Synopsis:   marshals a NETLOGON_VALIDATION_SAM_INFO2
//
//  Effects:    allocates memory with MIDL_user_allocate
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
PAC_ReMarshallValidationInfoWithGroups(
    IN  PNETLOGON_VALIDATION_SAM_INFO3 OldValidationInfo,
    IN  PSAMPR_PSID_ARRAY ResourceGroups,
    OUT PBYTE * ValidationInfo,
    OUT PULONG ValidationInfoSize
    )
{
    NETLOGON_VALIDATION_SAM_INFO3 ValidationSam = {0};
    PNETLOGON_SID_AND_ATTRIBUTES ExtraSids = NULL;
    ULONG ExtraSidCount = 0;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG Index, Index2;

    //
    // Copy the original validation information
    //

    ValidationSam = *OldValidationInfo;
    ValidationSam.UserFlags &= ~LOGON_RESOURCE_GROUPS;

    //
    // Clear any old resource groups
    //

    ValidationSam.ResourceGroupDomainSid = NULL;
    ValidationSam.ResourceGroupIds = NULL;
    ValidationSam.ResourceGroupCount = 0;

    //
    // Set the flag indicating resource groups may be present
    //

    if (ResourceGroups->Count != 0)
    {
        ExtraSidCount = ValidationSam.SidCount + ResourceGroups->Count;
        ValidationSam.UserFlags |= LOGON_EXTRA_SIDS;
        ExtraSids = (PNETLOGON_SID_AND_ATTRIBUTES) MIDL_user_allocate(sizeof(NETLOGON_SID_AND_ATTRIBUTES) * ExtraSidCount);
        if (ExtraSids == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        //
        // Add in all the extra sids that are not resource groups
        //

        Index2 = 0;
        for (Index = 0; Index < OldValidationInfo->SidCount; Index++ )
        {
            if ((OldValidationInfo->ExtraSids[Index].Attributes & SE_GROUP_RESOURCE) == 0)
            {
                ExtraSids[Index2] = OldValidationInfo->ExtraSids[Index];
                Index2++;
            }
        }

        //
        // Copy all the resource group SIDs
        //


        for (Index = 0; Index < ResourceGroups->Count ; Index++ )
        {
            ExtraSids[Index2].Sid = ResourceGroups->Sids[Index].SidPointer;
            ExtraSids[Index2].Attributes =  SE_GROUP_MANDATORY |
                                            SE_GROUP_ENABLED |
                                            SE_GROUP_ENABLED_BY_DEFAULT |
                                            SE_GROUP_RESOURCE;
            Index2++;
        }
        ValidationSam.ExtraSids = ExtraSids;
        ValidationSam.SidCount = Index2;
    }

    Status = PAC_EncodeValidationInformation(
                &ValidationSam,
                ValidationInfo,
                ValidationInfoSize
                );

Cleanup:

    if (ExtraSids != NULL)
    {
        MIDL_user_free(ExtraSids);
    }
    return(Status);

}




//+-------------------------------------------------------------------------
//
//  Function:   PAC_UnmarshallValidationInfo
//
//  Synopsis:   un marshals a NETLOGON_VALIDATION_SAM_INFO3
//
//  Effects:    resets offset to be pointers
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
PAC_UnmarshallValidationInfo(
    OUT PNETLOGON_VALIDATION_SAM_INFO3 * ValidationInfo,
    IN PBYTE MarshalledInfo,
    IN ULONG ValidationInfoSize
    )
{
    NTSTATUS Status;

    *ValidationInfo = NULL;
    Status = PAC_DecodeValidationInformation(
                MarshalledInfo,
                ValidationInfoSize,
                ValidationInfo
                );
    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   PAC_BuildCredentials
//
//  Synopsis:   Builds the buffer containing supplemental credentials for
//              the pac.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
PAC_BuildCredentials(
    IN PSAMPR_USER_ALL_INFORMATION UserAll,
    OUT PBYTE * Credentials,
    OUT PULONG CredentialSize
    )
{
    PSECPKG_SUPPLEMENTAL_CRED_ARRAY PacCreds = NULL;
    PMSV1_0_SUPPLEMENTAL_CREDENTIAL MsvCredentials;
    PUCHAR Where;
    ULONG CredSize;
    NTSTATUS Status = STATUS_SUCCESS;

    *Credentials = NULL;

    //
    // The size of the credentials is the overhead for the structures
    // plus the name "msv1_0"
    //

    CredSize = sizeof(SECPKG_SUPPLEMENTAL_CRED_ARRAY) +
                     sizeof(SECPKG_SUPPLEMENTAL_CRED) +
                     sizeof(MSV1_0_SUPPLEMENTAL_CREDENTIAL) +
                     NTLMSP_NAME_SIZE;
    PacCreds = (PSECPKG_SUPPLEMENTAL_CRED_ARRAY) MIDL_user_allocate(CredSize);
    if (PacCreds == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }


    //
    // Build the PAC credential
    //

    Where = (PBYTE) PacCreds;

    PacCreds->CredentialCount = 1;

    Where += sizeof(SECPKG_SUPPLEMENTAL_CRED_ARRAY) + sizeof(SECPKG_SUPPLEMENTAL_CRED) - (ANYSIZE_ARRAY * sizeof(SECPKG_SUPPLEMENTAL_CRED));

    //
    // Build the secpkg creds
    //

    RtlCopyMemory(
        Where,
        NTLMSP_NAME,
        NTLMSP_NAME_SIZE
        );

    PacCreds->Credentials[0].PackageName.Buffer = (LPWSTR) Where;
    Where += ROUND_UP_COUNT(NTLMSP_NAME_SIZE,sizeof(ULONG));

    PacCreds->Credentials[0].PackageName.Length = (USHORT) NTLMSP_NAME_SIZE;
    PacCreds->Credentials[0].PackageName.MaximumLength = (USHORT) NTLMSP_NAME_SIZE;
    PacCreds->Credentials[0].CredentialSize = sizeof(MSV1_0_SUPPLEMENTAL_CREDENTIAL);
    PacCreds->Credentials[0].Credentials = Where;

    MsvCredentials = (PMSV1_0_SUPPLEMENTAL_CREDENTIAL) Where;
    Where += sizeof(MSV1_0_SUPPLEMENTAL_CREDENTIAL);

    RtlZeroMemory(
        MsvCredentials,
        sizeof(MSV1_0_SUPPLEMENTAL_CREDENTIAL)
        );

    MsvCredentials->Version = MSV1_0_CRED_VERSION;

    if (UserAll->NtPasswordPresent)
    {
        DsysAssert(UserAll->NtOwfPassword.Length == MSV1_0_OWF_PASSWORD_LENGTH);
        MsvCredentials->Flags |= MSV1_0_CRED_NT_PRESENT;
        RtlCopyMemory(
            MsvCredentials->NtPassword,
            UserAll->NtOwfPassword.Buffer,
            UserAll->NtOwfPassword.Length
            );
    }
    if (UserAll->LmPasswordPresent)
    {
        DsysAssert(UserAll->LmOwfPassword.Length == MSV1_0_OWF_PASSWORD_LENGTH);
        MsvCredentials->Flags |= MSV1_0_CRED_LM_PRESENT;
        RtlCopyMemory(
            MsvCredentials->LmPassword,
            UserAll->LmOwfPassword.Buffer,
            UserAll->LmOwfPassword.Length
            );
    }

    Status = PAC_EncodeCredentialData(
                PacCreds,
                Credentials,
                CredentialSize
                );

    if (PacCreds != NULL)
    {
        MIDL_user_free(PacCreds);
    }
    return(Status);

}


//+-------------------------------------------------------------------------
//
//  Function:   PAC_UnmarshallCredentials
//
//  Synopsis:   unmarshals a SECPKG_SUPPLEMENTAL_CRED_ARRAY
//
//  Effects:    resets offset to be pointers
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
PAC_UnmarshallCredentials(
    OUT PSECPKG_SUPPLEMENTAL_CRED_ARRAY * Credentials,
    IN PBYTE MarshalledInfo,
    IN ULONG CredentialInfoSize
    )
{
    NTSTATUS Status;

    *Credentials = NULL;
    Status = PAC_DecodeCredentialData(
                MarshalledInfo,
                CredentialInfoSize,
                Credentials
                );
    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   PAC_ReMarshallDelegationInfoWithTransitedService
//
//  Synopsis:   Updates an S4U_DELEGATION_INFO with a new
//              transited service name
//
//  Effects:    allocates memory with MIDL_user_allocate
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
PAC_ReMarshallDelegationInfoWithTransitedService(
    IN  PS4U_DELEGATION_INFO OldDelegationInfo,
    IN  OPTIONAL PUNICODE_STRING TransitedService,
    IN  OPTIONAL PUNICODE_STRING NewTargetName,
    OUT PBYTE * DelegationInfo,
    OUT PULONG DelegationInfoSize
    )
{
    S4U_DELEGATION_INFO Delegation = {0};
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG ListSize = OldDelegationInfo->TransitedListSize;

    DsysAssert( OldDelegationInfo );
    DsysAssert( DelegationInfo );
    DsysAssert( DelegationInfoSize );

    //
    // Copy the original validation information
    //

    Delegation = *OldDelegationInfo;

    if (ARGUMENT_PRESENT( NewTargetName ))
    {
        Delegation.S4U2proxyTarget.Buffer = NewTargetName->Buffer;
        Delegation.S4U2proxyTarget.Length = NewTargetName->Length;
        Delegation.S4U2proxyTarget.MaximumLength = NewTargetName->MaximumLength;
    }

    //
    // If we've transitted a service, add an entry.  Otherwise, just remarshall
    // w/ new data.
    //

    if (ARGUMENT_PRESENT( TransitedService ))
    {
        ListSize++;
    }

    Delegation.S4UTransitedServices = (PUNICODE_STRING)MIDL_user_allocate(ListSize * sizeof(UNICODE_STRING));

    if ( Delegation.S4UTransitedServices == NULL )
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    for ( ULONG i = 0 ; i < Delegation.TransitedListSize ; i++ )
    {
        Delegation.S4UTransitedServices[i] = (*OldDelegationInfo).S4UTransitedServices[i];
    }

    if (ARGUMENT_PRESENT( TransitedService ))
    {
        Delegation.S4UTransitedServices[Delegation.TransitedListSize] = *TransitedService;
    }

    Delegation.TransitedListSize = ListSize;

    Status = PAC_EncodeS4UDelegationInformation(
                &Delegation,
                DelegationInfo,
                DelegationInfoSize
                );

    MIDL_user_free( Delegation.S4UTransitedServices );

    return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   PAC_UnmarshallS4UDelegationInfo
//
//  Synopsis:   unmarshals an S4U_DELEGATION_INFO structure
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
PAC_UnmarshallS4UDelegationInfo(
    OUT PS4U_DELEGATION_INFO * S4UDelegationInfo,
    IN PBYTE MarshalledInfo,
    IN ULONG MarshalledInfoSize
    )
{
    NTSTATUS Status;

    *S4UDelegationInfo = NULL;

    Status = PAC_DecodeS4UDelegationInformation(
                MarshalledInfo,
                MarshalledInfoSize,
                S4UDelegationInfo
                );

    return Status;
}


//+---------------------------------------------------------------------------
//
//  Function:   PAC_Init
//
//  Synopsis:   Creates a new PAC with the provided info
//
//  Arguments:  UserAll - UserAllInformation for the user
//              GroupsBuffer - The buffer returned from a call to
//                      SamrGetGroupsForUser, contains all global groups
//              LogonDomainId - Domain SID for the domain of this DC
//              SignatureSize - Space to reserve for signatures. If zero,
//                      no signatures are added.
//              ppPac - Receives a pac, allocated with MIDL_user_allocate
//
//
//  History:    24-May-95   SuChang     Created
//
//  Notes:
//
//----------------------------------------------------------------------------

NTSTATUS
PAC_Init(
    IN  PSAMPR_USER_ALL_INFORMATION UserAll,
    IN  OPTIONAL PSAMPR_GET_GROUPS_BUFFER GroupsBuffer,
    IN  OPTIONAL PSID_AND_ATTRIBUTES_LIST ExtraGroups,
    IN  PSID LogonDomainId,
    IN  PUNICODE_STRING LogonDomainName,
    IN  PUNICODE_STRING LogonServer,
    IN  ULONG SignatureSize,
    IN  ULONG AdditionalDataCount,
    IN  PPAC_INFO_BUFFER * AdditionalData,
    OUT PPACTYPE * ppPac
    )
{
    ULONG cbBytes = 0;
    ULONG cPacBuffers = 0;
    PPACTYPE pNewPac = NULL;
    ULONG iBuffer = 0;
    PBYTE ValidationInfo = NULL;
    ULONG ValidationInfoSize = 0;
    NTSTATUS Status;
    PBYTE pDataStore;
    ULONG Index;

    *ppPac = NULL;

    //
    // We need to determine the number of bytes required to store the provided
    // information. For each type of info, determine the required number of
    // bytes to store that type of info. Then allocate a contiguous buffer
    // for the PAC and store all the info into the buffer.
    //

    //
    // First we will create the validation info buffer. We can copy it into
    // the PAC later.
    //

    Status = PAC_MarshallValidationInfo(
                UserAll,
                GroupsBuffer,
                ExtraGroups,
                LogonDomainId,
                LogonDomainName,
                LogonServer,
                FALSE,          // don't include user parms
                FALSE,          // not a network logon
                &ValidationInfo,
                &ValidationInfoSize
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    //
    // We need a PAC_INFO_BUFFER to store the validation info.
    //

    cbBytes += ROUND_UP_COUNT(ValidationInfoSize, ALIGN_QUAD);
    cPacBuffers += 1;

    for (Index = 0; Index < AdditionalDataCount ; Index++ )
    {
        cbBytes += ROUND_UP_COUNT(AdditionalData[Index]->cbBufferSize,ALIGN_QUAD);
        cPacBuffers++;
    }

    //
    // If signature size is non-zero, add in space for signatures.
    //

    if (SignatureSize != 0)
    {
        cPacBuffers += 2;
        cbBytes += 2 * (ROUND_UP_COUNT(PAC_SIGNATURE_SIZE(SignatureSize), ALIGN_QUAD));
    }

    //
    // We need space for the PAC structure itself. Because the PAC_INFO_BUFFER
    // is defined to be an array, a sizeof(PAC) already includes the
    // size of ANYSIZE_ARRAY PAC_INFO_BUFFERs so we can subtract some bytes off.
    //
    cbBytes += sizeof(PACTYPE) +
               (cPacBuffers - ANYSIZE_ARRAY) * sizeof(PAC_INFO_BUFFER);
    cbBytes = ROUND_UP_COUNT( cbBytes, ALIGN_QUAD );

    pNewPac = (PPACTYPE) MIDL_user_allocate( cbBytes );
    if (pNewPac == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    ZeroMemory( pNewPac, cbBytes );

    pNewPac->Version = PAC_VERSION;
    pNewPac->cBuffers = cPacBuffers;

    //
    // Store data in such a way that the variable length data of
    // PAC_INFO_BUFFER are at the end of all the PAC info buffers.
    //

    pDataStore = (PBYTE)&(pNewPac->Buffers[pNewPac->cBuffers]);
    pDataStore = (PBYTE) ROUND_UP_POINTER( pDataStore, ALIGN_QUAD );

    //
    // Save the PAC identity ...
    //

    pNewPac->Buffers[iBuffer].ulType = PAC_LOGON_INFO;
    pNewPac->Buffers[iBuffer].cbBufferSize = ValidationInfoSize;
    pNewPac->Buffers[iBuffer].Data = pDataStore;

    CopyMemory(
        pDataStore,
        ValidationInfo,
        ValidationInfoSize
        );


    pDataStore += pNewPac->Buffers[iBuffer].cbBufferSize;
    pDataStore = (PBYTE) ROUND_UP_POINTER( pDataStore, ALIGN_QUAD );
    iBuffer ++;

    //
    // Store the additional data
    //

    for (Index = 0; Index < AdditionalDataCount ; Index++ )
    {
        pNewPac->Buffers[iBuffer].ulType = AdditionalData[Index]->ulType;
        pNewPac->Buffers[iBuffer].cbBufferSize = AdditionalData[Index]->cbBufferSize;
        pNewPac->Buffers[iBuffer].Data = pDataStore;

        CopyMemory(
            pDataStore,
            AdditionalData[Index]->Data,
            AdditionalData[Index]->cbBufferSize
            );

        pDataStore += pNewPac->Buffers[iBuffer].cbBufferSize;
        pDataStore = (PBYTE) ROUND_UP_POINTER( pDataStore, ALIGN_QUAD );
        iBuffer ++;
    }

    //
    // Store the signatures
    //

    if (SignatureSize != 0)
    {
        pNewPac->Buffers[iBuffer].ulType = PAC_SERVER_CHECKSUM;
        pNewPac->Buffers[iBuffer].cbBufferSize = PAC_SIGNATURE_SIZE(SignatureSize);
        pNewPac->Buffers[iBuffer].Data = pDataStore;
        pDataStore += ROUND_UP_COUNT(PAC_SIGNATURE_SIZE(SignatureSize),ALIGN_QUAD);
        iBuffer ++;

        pNewPac->Buffers[iBuffer].ulType = PAC_PRIVSVR_CHECKSUM;
        pNewPac->Buffers[iBuffer].cbBufferSize = PAC_SIGNATURE_SIZE(SignatureSize);
        pNewPac->Buffers[iBuffer].Data = pDataStore;
        pDataStore += ROUND_UP_COUNT(PAC_SIGNATURE_SIZE(SignatureSize), ALIGN_QUAD);
        iBuffer ++;
    }

    *ppPac = pNewPac;
    pNewPac = NULL;

Cleanup:

    MIDL_user_free(ValidationInfo);
    MIDL_user_free(pNewPac);

    return(Status);
}

//+---------------------------------------------------------------------------
//
//  Function:   PAC_InitAndUpdateGroups
//
//  Synopsis:   Creates a new PAC from old validation info and a list of
//              resource groupss.
//
//  Arguments:  OldValidationInfo - Old info from a previous PAC
//              ResourceGroups - Resource groups in this domain
//              OldPac - OldPac to copy data from
//              ppPac - Receives a pac, allocated with MIDL_user_allocate
//
//
//  History:    24-May-95   SuChang     Created
//
//  Notes:
//
//----------------------------------------------------------------------------

NTSTATUS
PAC_InitAndUpdateGroups(
    IN  PNETLOGON_VALIDATION_SAM_INFO3 OldValidationInfo,
    IN  PSAMPR_PSID_ARRAY ResourceGroups,
    IN  PPACTYPE OldPac,
    OUT PPACTYPE * ppPac
    )
{
    ULONG cbBytes = 0;
    ULONG cPacBuffers = 0;
    PPACTYPE pNewPac = NULL;
    ULONG iBuffer = 0;
    PBYTE ValidationInfo = NULL;
    ULONG ValidationInfoSize;
    NTSTATUS Status;
    PBYTE pDataStore;
    ULONG Index;

    *ppPac = NULL;

    //
    // We need to determine the number of bytes required to store the provided
    // information. For each type of info, determine the required number of
    // bytes to store that type of info. Then allocate a contiguous buffer
    // for the PAC and store all the info into the buffer.
    //

    //
    // First we will create the validation info buffer. We can copy it into
    // the PAC later.
    //

    Status = PAC_ReMarshallValidationInfoWithGroups(
                OldValidationInfo,
                ResourceGroups,
                &ValidationInfo,
                &ValidationInfoSize
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // We need a PAC_INFO_BUFFER to store the PAC_IDENTITY which
    // contain the principal RID and the principal's domain GUID.
    //

    cbBytes += ROUND_UP_COUNT(ValidationInfoSize, ALIGN_QUAD);
    cPacBuffers += 1;

    for (Index = 0; Index < OldPac->cBuffers ; Index++ )
    {
        if (OldPac->Buffers[Index].ulType != PAC_LOGON_INFO)
        {
            cbBytes += ROUND_UP_COUNT(OldPac->Buffers[Index].cbBufferSize,ALIGN_QUAD);
            cPacBuffers++;
        }
    }


    //
    // We need space for the PAC structure itself. Because the PAC_INFO_BUFFER
    // is defined to be an array, a sizeof(PAC) already includes the
    // size of ANYSIZE_ARRAY PAC_INFO_BUFFERs so we can subtract some bytes off.
    //
    cbBytes += sizeof(PACTYPE) +
               (cPacBuffers - ANYSIZE_ARRAY) * sizeof(PAC_INFO_BUFFER);
    cbBytes = ROUND_UP_COUNT( cbBytes, ALIGN_QUAD );

    pNewPac = (PPACTYPE) MIDL_user_allocate( cbBytes );
    if (pNewPac == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // FESTER: overkill???
    //

    ZeroMemory( pNewPac, cbBytes );

    pNewPac->cBuffers = cPacBuffers;

    //
    // Store data in such a way that the variable length data of
    // PAC_INFO_BUFFER are at the end of all the PAC info buffers.
    //

    pDataStore = (PBYTE)&(pNewPac->Buffers[pNewPac->cBuffers]);
    pDataStore = (PBYTE) ROUND_UP_POINTER( pDataStore, ALIGN_QUAD );

    //
    // Save the PAC identity ...
    //
    pNewPac->Buffers[iBuffer].ulType = PAC_LOGON_INFO;
    pNewPac->Buffers[iBuffer].cbBufferSize = ValidationInfoSize;
    pNewPac->Buffers[iBuffer].Data = pDataStore;

    CopyMemory(
        pDataStore,
        ValidationInfo,
        ValidationInfoSize
        );


    pDataStore += pNewPac->Buffers[iBuffer].cbBufferSize;
    pDataStore = (PBYTE) ROUND_UP_POINTER( pDataStore, ALIGN_QUAD );
    iBuffer ++;

    //
    // Store the additional data
    //

    for (Index = 0; Index < OldPac->cBuffers ; Index++ )
    {
        if (OldPac->Buffers[Index].ulType != PAC_LOGON_INFO)
        {
            pNewPac->Buffers[iBuffer].ulType = OldPac->Buffers[Index].ulType;
            pNewPac->Buffers[iBuffer].cbBufferSize = OldPac->Buffers[Index].cbBufferSize;
            pNewPac->Buffers[iBuffer].Data = pDataStore;

            CopyMemory(
                pDataStore,
                OldPac->Buffers[Index].Data,
                OldPac->Buffers[Index].cbBufferSize
                );


            pDataStore += pNewPac->Buffers[iBuffer].cbBufferSize;
            pDataStore = (PBYTE) ROUND_UP_POINTER( pDataStore, ALIGN_QUAD );
            iBuffer ++;
        }

    }

    *ppPac = pNewPac;
    pNewPac = NULL;
Cleanup:
    if (ValidationInfo != NULL)
    {
        MIDL_user_free(ValidationInfo);
    }
    if (pNewPac != NULL)
    {
        MIDL_user_free(pNewPac);
    }

    return(Status);
}


//+---------------------------------------------------------------------------
//
//  Function:   PAC_RemoveSection
//
//  Synopsis:   Creates a new PAC from old validation info and a list of
//              resource groupss.
//
//  Arguments:  OldPac - OldPac to copy data from
//              InfoType - section type to remove
//              ppPac - Receives a pac, allocated with MIDL_user_allocate
//
//  History:    22-Aug-02   MarkPu     Created
//
//  Notes:
//
//----------------------------------------------------------------------------

NTSTATUS
PAC_RemoveSection(
    IN  PPACTYPE OldPac,
    IN  ULONG RemoveType,
    OUT PPACTYPE * ppPac
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG Index;
    ULONG iBuffer = 0;
    ULONG cbBytes = 0;
    ULONG cPacBuffers = 0;
    PPACTYPE pNewPac = NULL;
    PBYTE pDataStore;

    *ppPac = NULL;

    //
    // We need to determine the number of bytes required to store the PAC
    // information. For each type of info, determine the required number of
    // bytes to store that type of info. Then allocate a contiguous buffer
    // for the PAC and store all the info into the buffer.
    //

    for (Index = 0; Index < OldPac->cBuffers ; Index++ )
    {
        if (OldPac->Buffers[Index].ulType != RemoveType)
        {
            cbBytes += ROUND_UP_COUNT(OldPac->Buffers[Index].cbBufferSize,ALIGN_QUAD);
            cPacBuffers++;
        }
    }

    if ( cPacBuffers == OldPac->cBuffers )
    {
        //
        // Info type not found, thus not removed, thus nothing to do
        //

        Status = STATUS_NOT_FOUND;
        goto Cleanup;
    }
    else if ( cPacBuffers == 0 )
    {
        Status = STATUS_SUCCESS;
        goto Cleanup;
    }

    //
    // We need space for the PAC structure itself. Because the PAC_INFO_BUFFER
    // is defined to be an array, a sizeof(PAC) already includes the
    // size of ANYSIZE_ARRAY PAC_INFO_BUFFERs so we can subtract some bytes off.
    //

    cbBytes += sizeof(PACTYPE) +
               (cPacBuffers - ANYSIZE_ARRAY) * sizeof(PAC_INFO_BUFFER);
    cbBytes = ROUND_UP_COUNT( cbBytes, ALIGN_QUAD );

    pNewPac = (PPACTYPE) MIDL_user_allocate( cbBytes );
    if (pNewPac == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    pNewPac->cBuffers = cPacBuffers;

    //
    // Store data in such a way that the variable length data of
    // PAC_INFO_BUFFER are at the end of all the PAC info buffers.
    //

    pDataStore = (PBYTE)&(pNewPac->Buffers[pNewPac->cBuffers]);
    pDataStore = (PBYTE) ROUND_UP_POINTER( pDataStore, ALIGN_QUAD );

    //
    // Copy the data over
    //

    for (Index = 0; Index < OldPac->cBuffers ; Index++ )
    {
        if (OldPac->Buffers[Index].ulType != RemoveType)
        {
            pNewPac->Buffers[iBuffer].ulType = OldPac->Buffers[Index].ulType;
            pNewPac->Buffers[iBuffer].cbBufferSize = OldPac->Buffers[Index].cbBufferSize;
            pNewPac->Buffers[iBuffer].Data = pDataStore;

            CopyMemory(
                pDataStore,
                OldPac->Buffers[Index].Data,
                OldPac->Buffers[Index].cbBufferSize
                );

            pDataStore += pNewPac->Buffers[iBuffer].cbBufferSize;
            pDataStore = (PBYTE) ROUND_UP_POINTER( pDataStore, ALIGN_QUAD );
            iBuffer ++;
        }
    }

    *ppPac = pNewPac;
    pNewPac = NULL;

Cleanup:

    MIDL_user_free(pNewPac);

    return Status;
}



//+---------------------------------------------------------------------------
//
//  Function:   PAC_InitAndUpdateTransitedServices
//
//  Synopsis:   Creates a new PAC from old delegation info and a new transited
//              service name
//
//  Arguments:  OldDelegationInfo - Old delegation info from a previous PAC
//              TransitedService - Name of transited service to add
//              OldPac - OldPac to copy data from
//              ppPac - Receives a pac, allocated with MIDL_user_allocate
//
//
//  History:    09-May-01   MarkPu     Created
//
//  Notes:
//
//----------------------------------------------------------------------------

NTSTATUS
PAC_InitAndUpdateTransitedService(
    IN  PS4U_DELEGATION_INFO OldDelegationInfo,
    IN  OPTIONAL PUNICODE_STRING TransitedService,
    IN  OPTIONAL PUNICODE_STRING NewTargetName,
    IN  PPACTYPE OldPac,
    OUT  PPACTYPE * ppPac,
    OUT PULONG NewDelegationInfoMarshalledSize,
    OUT BYTE** NewDelegationInfoMarshalled
    )
{
    ULONG cbBytes = 0;
    ULONG cPacBuffers = 0;
    PPACTYPE pNewPac = NULL;
    ULONG iBuffer = 0;
    NTSTATUS Status;
    PBYTE pDataStore;
    ULONG Index;

    *ppPac = NULL;

    //
    // We need to determine the number of bytes required to store the provided
    // information. For each type of info, determine the required number of
    // bytes to store that type of info. Then allocate a contiguous buffer
    // for the PAC and store all the info into the buffer.
    //

    //
    // First we will create the S4UDelegation buffer. We can copy it into
    // the PAC later.
    //

    Status = PAC_ReMarshallDelegationInfoWithTransitedService(
                OldDelegationInfo,
                TransitedService,
                NewTargetName,
                NewDelegationInfoMarshalled,
                NewDelegationInfoMarshalledSize
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Get the sizes of the old pac buffers.  If there's delegation info in the
    // old pac, skip it, as we'll be substituing our new version from above.
    //

    cbBytes += ROUND_UP_COUNT(*NewDelegationInfoMarshalledSize, ALIGN_QUAD);
    cPacBuffers += 1;

    for ( Index = 0; Index < OldPac->cBuffers; Index++ )
    {
        if ( OldPac->Buffers[Index].ulType != PAC_DELEGATION_INFO )
        {
            cbBytes += ROUND_UP_COUNT(OldPac->Buffers[Index].cbBufferSize,ALIGN_QUAD);
            cPacBuffers++;
        }
    }

    //
    // We need space for the PAC structure itself. Because the PAC_INFO_BUFFER
    // is defined to be an array, a sizeof(PAC) already includes the
    // size of ANYSIZE_ARRAY PAC_INFO_BUFFERs so we can subtract some bytes off.
    //

    cbBytes += sizeof(PACTYPE) +
               (cPacBuffers - ANYSIZE_ARRAY) * sizeof(PAC_INFO_BUFFER);
    cbBytes = ROUND_UP_COUNT( cbBytes, ALIGN_QUAD );

    pNewPac = (PPACTYPE) MIDL_user_allocate( cbBytes );
    if (pNewPac == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    ZeroMemory( pNewPac, cbBytes );

    pNewPac->cBuffers = cPacBuffers;

    //
    // Store data in such a way that the variable length data of
    // PAC_INFO_BUFFER are at the end of all the PAC info buffers.
    //

    pDataStore = (PBYTE)&(pNewPac->Buffers[pNewPac->cBuffers]);
    pDataStore = (PBYTE) ROUND_UP_POINTER( pDataStore, ALIGN_QUAD );

    //
    // Save the S4U identity ...
    //
    pNewPac->Buffers[iBuffer].ulType = PAC_DELEGATION_INFO;
    pNewPac->Buffers[iBuffer].cbBufferSize = *NewDelegationInfoMarshalledSize;
    pNewPac->Buffers[iBuffer].Data = pDataStore;

    CopyMemory(
        pDataStore,
        *NewDelegationInfoMarshalled,
        *NewDelegationInfoMarshalledSize
        );

    pDataStore += pNewPac->Buffers[iBuffer].cbBufferSize;
    pDataStore = (PBYTE) ROUND_UP_POINTER( pDataStore, ALIGN_QUAD );
    iBuffer ++;

    //
    // Store the additional data
    //

    for (Index = 0; Index < OldPac->cBuffers ; Index++ )
    {
        if ( OldPac->Buffers[Index].ulType != PAC_DELEGATION_INFO )
        {
            pNewPac->Buffers[iBuffer].ulType = OldPac->Buffers[Index].ulType;
            pNewPac->Buffers[iBuffer].cbBufferSize = OldPac->Buffers[Index].cbBufferSize;
            pNewPac->Buffers[iBuffer].Data = pDataStore;

            CopyMemory(
                pDataStore,
                OldPac->Buffers[Index].Data,
                OldPac->Buffers[Index].cbBufferSize
                );

            pDataStore += pNewPac->Buffers[iBuffer].cbBufferSize;
            pDataStore = (PBYTE) ROUND_UP_POINTER( pDataStore, ALIGN_QUAD );
            iBuffer ++;
        }
    }

    *ppPac = pNewPac;
    pNewPac = NULL;

Cleanup:

    MIDL_user_free(pNewPac);

    return(Status);
}

//+---------------------------------------------------------------------------
//
//  Function:   PAC_Find
//
//  Synopsis:   Finds a type of PAC info buffer in the given PAC.
//              If pElem is NULL, the first buffer found matching the
//              specified type is returned. Otherwise, the next buffer
//              after pElem found matching that type is returned.
//
//  Arguments:
//
//  History:    01-June-95   SuChang     Created
//
//  Notes:
//
//----------------------------------------------------------------------------

PPAC_INFO_BUFFER
PAC_Find( IN  PPACTYPE     pPac,
          IN  ULONG        ulType,
          PPAC_INFO_BUFFER pElem)
{
    PAC_INFO_BUFFER *pTemp = NULL, *pEnd;

    if (pPac)
    {
        pEnd = &(pPac->Buffers[pPac->cBuffers]);
        if (pElem)
        {
            pTemp = pElem + 1;
        }
        else
        {
            pTemp = &(pPac->Buffers[0]);
        }

        while ( pTemp < pEnd && pTemp->ulType != ulType )
        {
            pTemp++;
        }

        if (pTemp >= pEnd)
        {
            // element not found in the PAC
            pTemp = NULL;
        }
    }

    return (pTemp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\server\getas.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       getas.cxx
//
//  Contents:   GetASTicket and support functions
//
//  Classes:
//
//  Functions:
//
//  History:    04-Mar-94   wader   Created
//
//----------------------------------------------------------------------------

#include "kdcsvr.hxx"
#include "kdctrace.h"
#include "krb5p.h"
#include <userall.h>
#include <utils.hxx>

extern "C"
{
#include <md5.h>
}

#include "fileno.h"
#define FILENO FILENO_GETAS

// Local prototypes

NTSTATUS
AsNegCacheCheck(
    IN PVOID Buffer,
    IN ULONG BufferLength,
    IN OPTIONAL PVOID OptionalBuffer,
    IN OPTIONAL ULONG OptionalBufferLength,
    OUT PBOOLEAN pfAvoidSendToPDC
    );

NTSTATUS
AsNegCacheUpdate(
    IN PVOID Buffer,
    IN ULONG BufferLength,
    IN OPTIONAL PVOID OptionalBuffer,
    IN OPTIONAL ULONG OptionalBufferLength,
    IN NTSTATUS StatusPdcAuth
    );

NTSTATUS
AsNegCacheDelete(
    IN PVOID Buffer,
    IN ULONG BufferLength,
    IN OPTIONAL PVOID OptionalBuffer,
    IN OPTIONAL ULONG OptionalBufferLength
    );

// Negative Cache data stucts
RTL_CRITICAL_SECTION l_ApNegCacheCritSect;
LIST_ENTRY l_ApNegCacheList;
BOOLEAN    g_fApNegCacheInitialized = FALSE;   // Simple variable to make sure that the package was initialize

#define KERB_AP_NEGATIVE_MAX_LOGON_COUNT 10     // number of failed auth attempts to PDC before imposing 5 minute waits
#define KERB_MAX_FAILED_LIST_ENTRIES     50     // max number of entries in the negative cache list table
#define KERB_5_MINUTES_100NANO    3000000000    // number of 100 Nanoseconds in 5 minutes


typedef struct _NEGATIVE_CACHE {
    LIST_ENTRY Next;
    ULONG lBadLogonCount;
    LARGE_INTEGER  TimeLastPDCContact;
    char digest[MD5DIGESTLEN];              // md5 signature of the AS request info
} NEGATIVE_CACHE, *PNEGATIVE_CACHE;


LARGE_INTEGER tsInfinity = {0xffffffff,0x7fffffff};
LONG lInfinity = 0x7fffffff;

enum {
    SubAuthUnknown,
    SubAuthNoFilter,
    SubAuthYesFilter
} KdcSubAuthFilterPresent = SubAuthUnknown;

extern "C"
NTSTATUS NTAPI
Msv1_0ExportSubAuthenticationRoutine(
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN PVOID LogonInformation,
    IN ULONG Flags,
    IN ULONG DllNumber,
    IN PUSER_ALL_INFORMATION UserAll,
    OUT PULONG WhichFields,
    OUT PULONG UserFlags,
    OUT PBOOLEAN Authoritative,
    OUT PLARGE_INTEGER LogoffTime,
    OUT PLARGE_INTEGER KickoffTime
);

extern "C"
BOOLEAN NTAPI
Msv1_0SubAuthenticationPresent(
    IN ULONG DllNumber
    );

ULONG
NetpDcElapsedTime(
    IN ULONG StartTime
)
/*++

Routine Description:

    Returns the time (in milliseconds) that has elapsed is StartTime.

Arguments:

    StartTime - A time stamp from GetTickCount()

Return Value:

    Returns the time (in milliseconds) that has elapsed is StartTime.

--*/
{
    ULONG CurrentTime;

    //
    // If time has has wrapped,
    //  account for it.
    //

    CurrentTime = GetTickCount();

    if ( CurrentTime >= StartTime ) {
        return CurrentTime - StartTime;
    } else {
        return (0xFFFFFFFF-StartTime) + CurrentTime;
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   KdcForwardLogonToPDC
//
//  Synopsis:   Forwards a failed-password logon to the PDC.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KdcForwardLogonToPDC(
    IN PKERB_MESSAGE_BUFFER InputMessage,
    IN PKERB_MESSAGE_BUFFER OutputMessage
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    NTSTATUS Status;
    BOOLEAN CalledPDC;
    KERB_MESSAGE_BUFFER Reply = {0};
    DOMAIN_SERVER_ROLE ServerRole;

    Status = SamIQueryServerRole(
                GlobalAccountDomainHandle,
                &ServerRole
                );

    if (!KdcGlobalAvoidPdcOnWan &&
        NT_SUCCESS(Status) &&
        (ServerRole == DomainServerRoleBackup))
    {
        Status = KerbMakeKdcCall(
                    SecData.KdcDnsRealmName(),
                    NULL,                           // no account name
                    TRUE,                           // call the PDC
                    TRUE,                           // use TCP/IP, not UDP
                    InputMessage,
                    &Reply,
                    0, // no additional flags
                    &CalledPDC
                    );
        if (!NT_SUCCESS(Status))
        {
            KerbErr = KRB_ERR_GENERIC;
        }
        else
        {
            OutputMessage->Buffer = (PBYTE) MIDL_user_allocate(Reply.BufferSize);
            if (OutputMessage->Buffer != NULL)
            {
                OutputMessage->BufferSize = Reply.BufferSize;

                RtlCopyMemory(
                    OutputMessage->Buffer,
                    Reply.Buffer,
                    OutputMessage->BufferSize
                    );
            }
            else
            {
                KerbErr = KRB_ERR_GENERIC;
            }
            KerbFree(Reply.Buffer);
        }
    }
    else
    {
        KerbErr = KRB_ERR_GENERIC;
    }
    return(KerbErr);
}

//+---------------------------------------------------------------------------
//
//  Function:   KdcVerifyKdcAsRep
//
//  Synopsis:   Verifies that our AS_REP came from a KDC, as opposed to a malicious
//              attacker by evaluating the TGT embedded in response
//
//  Arguments:  Reply   PKERB_KDC_REPLY
//
//  Returns:    Boolean to client.
//
//  History:    12-June-2000   Todds   Created
//
//----------------------------------------------------------------------------
BOOLEAN
KdcVerifyKdcAsRep(
   PKERB_KDC_REPLY Reply,
   PKERB_PRINCIPAL_NAME RequestBodyClientName
   )
{

   BOOLEAN                 fRet = FALSE;
   KERBERR                 KerbErr;
   KDC_TICKET_INFO         KrbtgtTicketInfo = {0};
   UNICODE_STRING          ServerNames[3];
   UNICODE_STRING          ClientName;
   ULONG                   NameType;
   PKERB_ENCRYPTION_KEY    EncryptionKey = NULL;
   PKERB_ENCRYPTED_TICKET  DecryptedTicket = NULL;
   KERB_REALM              LocalRealm;


   // Get the server key for krbtgt
   KerbErr = SecData.GetKrbtgtTicketInfo(&KrbtgtTicketInfo);

   if (!KERB_SUCCESS(KerbErr))
   {
      D_DebugLog((DEB_WARN, "SecData.Getkrbtgtticketinfo failed!\n"));
      goto Cleanup;
   }

   ServerNames[0] = *SecData.KdcFullServiceKdcName();
   ServerNames[1] = *SecData.KdcFullServiceDnsName();
   ServerNames[2] = *SecData.KdcFullServiceName();

   LocalRealm = SecData.KdcKerbDnsRealmName();
   //
   // Verify the realm of the ticket
   //
   if (!KerbCompareRealmNames(
         &LocalRealm,
         &Reply->ticket.realm
         ))
   {
      D_DebugLog((DEB_ERROR,"KLIN(%x) Tgt reply is not for our realm: %s instead of %s\n",
                KLIN(FILENO, __LINE__), Reply->ticket.realm, LocalRealm));
      KerbErr = KRB_AP_ERR_NOT_US;
      goto Cleanup;
   }

   EncryptionKey = KerbGetKeyFromList(
                     KrbtgtTicketInfo.Passwords,
                     Reply->ticket.encrypted_part.encryption_type
                     );

   if (EncryptionKey == NULL)
   {
      D_DebugLog((DEB_ERROR, "Couldn't get key for decrypting krbtgt\n"));
      KerbErr = KRB_AP_ERR_NOKEY;
      goto Cleanup;
   }

   KerbErr = KerbVerifyTicket(
               &Reply->ticket,
               3,                              // 3 names
               ServerNames,
               SecData.KdcDnsRealmName(),
               EncryptionKey,
               &SkewTime,
               &DecryptedTicket
               );

   if (!KERB_SUCCESS(KerbErr))
   {
      D_DebugLog((DEB_ERROR, "KLIN(%x) Failed to verify ticket - %x\n",
                  KLIN(FILENO, __LINE__),KerbErr));
      goto Cleanup;
   }

   //
   // Verify the realm of the client is the same as our realm
   //
   if (!KerbCompareRealmNames(
         &LocalRealm,
         &DecryptedTicket->client_realm
         ))
   {
      D_DebugLog((DEB_ERROR,"KLIN(%x) Verified ticket client realm is wrong: %s instead of %s\n",
                KLIN(FILENO, __LINE__),DecryptedTicket->client_realm, LocalRealm));
      KerbErr = KRB_AP_ERR_NOT_US;
      goto Cleanup;
   }

   fRet = TRUE;

Cleanup:

   if (DecryptedTicket != NULL)
   {
       KerbFreeTicket(DecryptedTicket);
   }

   if (!fRet && KerbErr == KRB_AP_ERR_MODIFIED)
   {
      ClientName.Buffer = NULL;
      KerbConvertPrincipalNameToString(
            &ClientName,
            &NameType,
            RequestBodyClientName
            );

      ReportServiceEvent(
             EVENTLOG_ERROR_TYPE,
             KDCEVENT_INVALID_FORWARDED_AS_REQ,
             sizeof(ULONG),
             &KerbErr,
             1,                              // number of strings
             ClientName.Buffer
             );

      if (ClientName.Buffer != NULL)
      {
         MIDL_user_free(ClientName.Buffer);
      }
   }

   return fRet;
}



//+---------------------------------------------------------------------------
//
//  Function:   FailedLogon
//
//  Synopsis:   Processes a failed logon. This is to be called on a failed auth
//     attempt on the BDC.  A series of rules will be applied to see if the request
//     should be forwarded to the PDC>
//
//  Effects:    May raise an exception, audit, event, lockout, etc.
//     Will increment the bad password count if Reason is KDC_ERR_PREAUTH_FAILED
//
//  Arguments:  [UserHandle] -- [in] Client who didn't log on.
//              [ClientAddress] -- Address of client making request
//              [Client] -- [in optional] Sid of the client requesting logon
//              [ClientSize] -- [in] Length of the sid
//              [Reason] -- [in] the reason this logon failed.
//              [UsedOldPassword] -- [in] caller used old password to log on;
//                                   do not increment the account lockout count
//
//  Requires:
//
//  Returns:    VOID - any message from PDC is sent in outputmessage
//
//  Algorithm:
//
//  History:    03-May-94   wader   Created
//
//  Notes:      This usually returns hrReason, but it may map it to
//              something else.
//
//----------------------------------------------------------------------------

VOID
FailedLogon( IN  SAMPR_HANDLE UserHandle,
             IN  OPTIONAL PSOCKADDR  ClientAddress,
             IN  PKERB_PRINCIPAL_NAME RequestBodyClientName,
             IN  OPTIONAL UCHAR *Client,
             IN  ULONG ClientSize,
             IN  PKDC_TICKET_INFO ClientTicketInfo,
             IN  PKERB_MESSAGE_BUFFER InputMessage,
             IN  PKERB_MESSAGE_BUFFER OutputMessage,
             IN  PUNICODE_STRING ClientNetbiosAddress,
             IN  KERBERR Reason,
             IN  NTSTATUS LogonStatus,
             IN  BOOLEAN UsedOldPassword
             )
{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS StatusTemp = STATUS_SUCCESS;
    SAM_LOGON_STATISTICS LogonStats;
    LARGE_INTEGER CurrentTime;
    PKERB_ERROR ErrorMessage = NULL;
    PKERB_KDC_REPLY Reply = NULL;
    BOOLEAN LockoutEnabled = FALSE;
    PKERB_EXT_ERROR pExtendedError = NULL;
    BOOLEAN fAvoidSend = FALSE;                 // Should be avoid sending to the PDC ?
    BOOLEAN fForwardedToPDC = FALSE;

    DOMAIN_SERVER_ROLE ServerRole;

    TRACE(KDC, FailedLogon, DEB_FUNCTION);

    // If we are the PDC, then goto cleanup - no need for negative cache processing
    Status = SamIQueryServerRole(
                GlobalAccountDomainHandle,
                &ServerRole
                );

    if (NT_SUCCESS(Status) &&
        (ServerRole == DomainServerRolePrimary))
    {
        goto Cleanup;
    }

    GetSystemTimeAsFileTime((PFILETIME)&CurrentTime);

    //
    // It's important to know why the logon can fail.  For each possible
    // reason, decide if that is a reason to lock out the account.
    //

    //
    // Check to see if we've seen this request before recently
    //

    if (KDC_ERR_NONE == ReplayDetect->Check(
                            InputMessage->Buffer,
                            InputMessage->BufferSize,
                            NULL,
                            0,
                            &CurrentTime,
                            TRUE,
                            FALSE,
                            TRUE))
    {
        KERBERR KerbErr;
        KERBERR ForwardKerbErr;

        //
        // If the password was bad then we want to update the sam information
        // Check w/ the PDC for account & pwd errors
        //

        if ((Reason == KDC_ERR_PREAUTH_FAILED) ||
            (LogonStatus == STATUS_PASSWORD_EXPIRED) ||
            (LogonStatus == STATUS_PASSWORD_MUST_CHANGE) ||
            (LogonStatus == STATUS_ACCOUNT_LOCKED_OUT))
        {

            // Check to see if we should forward the request to the PDC
            Status = AsNegCacheCheck(
                                    Client,
                                    ClientSize,
                                    ClientNetbiosAddress->Buffer,
                                    ClientNetbiosAddress->Length,
                                    &fAvoidSend);
            if (!NT_SUCCESS(Status) || (fAvoidSend == TRUE))
            {
                D_DebugLog((DEB_WARN, "<CACHE> NOT fwding to PDC r(0x%x) ls(0x%x)\n", Reason, LogonStatus));
                goto Cleanup;
            }

            //
            // Pass this request to the KDC
            //
            D_DebugLog((DEB_TRACE,"KLIN(%x) sending request to PDC for updated info\n",
                      KLIN(FILENO,__LINE__)));
            KerbErr = KdcForwardLogonToPDC(
                        InputMessage,
                        OutputMessage
                        );

            //
            // Return an better error if it wasn't generic.
            //

            if (KERB_SUCCESS(KerbErr))
            {
                ForwardKerbErr =  KerbUnpackKerbError(
                                        OutputMessage->Buffer,
                                        OutputMessage->BufferSize,
                                        &ErrorMessage
                                        );

                if (KERB_SUCCESS(ForwardKerbErr))
                {
                    NTSTATUS StatusPDC = STATUS_INTERNAL_ERROR;

                    if (ErrorMessage->bit_mask & error_data_present)
                    {
                       KerbErr = KerbUnpackErrorData(
                           ErrorMessage,
                           &pExtendedError
                           );

                       if (KERB_SUCCESS(KerbErr) && (EXT_CLIENT_INFO_PRESENT(pExtendedError)))
                       {
                          StatusPDC = pExtendedError->status;

                          D_DebugLog((DEB_TRACE,"KLIN(%x) info from PDC StatusPDC 0x%x\n",
                                    KLIN(FILENO,__LINE__), StatusPDC));
                       }
                    }

                    Reason = ErrorMessage->error_code;   // PDC kerb error takes priority
                    fForwardedToPDC = TRUE;

                    // Update the list of forwarded failed user auth
                    // If the lockout policy is enabled, we should continue to forward auth requests to
                    // the PDC (i.e. we should not cache this failure), to keep the right lockout count
                    // until the account becomes locked on the PDC
                    // We need to also increment if an older password is used.  This is because the negative
                    // cache logic is not incremented for use of an older password (1st or 2nd in history).

                    if (ClientTicketInfo->LockoutThreshold)
                    {
                        LockoutEnabled = TRUE;     // account can be locked out
                        D_DebugLog((DEB_TRACE, "FailedLogon:  Account lockout policy is enabled\n"));
                    }


                    if (!LockoutEnabled ||
                        (StatusPDC == STATUS_ACCOUNT_LOCKED_OUT) ||
                        UsedOldPassword)
                    {
                        StatusTemp = AsNegCacheUpdate(
                                        Client,
                                        ClientSize,
                                        ClientNetbiosAddress->Buffer,
                                        ClientNetbiosAddress->Length,
                                        StatusPDC
                                        );
                    }

                } else {

                   //
                   // This may have been a successful, forwarded AS_REQ.  If so,
                   // reset bad password count on this BDC...
                   //
                   ForwardKerbErr = KerbUnpackAsReply(
                                     OutputMessage->Buffer,
                                     OutputMessage->BufferSize,
                                     &Reply
                                     );

                   if (KERB_SUCCESS(ForwardKerbErr) &&
                       KdcVerifyKdcAsRep(
                           Reply,
                           RequestBodyClientName
                           ))
                   {
                       D_DebugLog((DEB_TRACE,"KLIN(%x) Successful AS-REP from PDC\n",
                                 KLIN(FILENO,__LINE__)));

                       Reason = KDC_ERR_NONE; // PDC kerb error takes priority
                       fForwardedToPDC = TRUE;
                       RtlZeroMemory(&LogonStats, sizeof(LogonStats));
                        LogonStats.StatisticsToApply =
                            USER_LOGON_INTER_SUCCESS_LOGON |
                            USER_LOGON_PDC_RETRY_SUCCESS |
                            USER_LOGON_TYPE_KERBEROS;
                        if ( (ClientAddress == NULL)
                             || (ClientAddress->sa_family == AF_INET) )
                        {
                            LogonStats.ClientInfo.Type = SamClientIpAddr;
                            LogonStats.ClientInfo.Data.IpAddr = *((ULONG*)GET_CLIENT_ADDRESS(ClientAddress));
                        }

                        Status = SamIUpdateLogonStatistics(
                                        UserHandle,
                                        &LogonStats
                                        );

                        if (!NT_SUCCESS(Status))
                        {
                            D_DebugLog((DEB_ERROR,"Could not reset user bad pwd count - %x\n", Status));
                        }

                        D_DebugLog((DEB_TRACE,"KLIN(%x) SamIUpdate successful forward to PDC  StatsApply 0x%x.\n",
                                    KLIN(FILENO,__LINE__), LogonStats.StatisticsToApply));

                      StatusTemp = AsNegCacheDelete(
                                    Client,
                                    ClientSize,
                                    ClientNetbiosAddress->Buffer,
                                    ClientNetbiosAddress->Length
                                    );

                      D_DebugLog((DEB_ERROR, "KLIN(%x) Purged entry due to valid fwd'd response\n",
                                KLIN(FILENO,__LINE__)));

                   } else {

                      DebugLog((DEB_ERROR, "KLIN(%x) Got reply from fwd'd request to PDC, but wasn't valid!\n",
                                KLIN(FILENO,__LINE__)));
                      if (KerbErr != KRB_ERR_GENERIC)
                      {
                          Reason = KerbErr;
                          fForwardedToPDC = TRUE;
                      }
                   }
                }
            }
        }
    }
Cleanup:
    if (NULL != ErrorMessage)
    {
        KerbFreeKerbError(ErrorMessage);
    }

    if (NULL != Reply)
    {
       KerbFreeAsReply(Reply);
    }

    if (NULL != pExtendedError)
    {
        MIDL_user_free(pExtendedError);
    }

    if (Reason == KDC_ERR_PREAUTH_FAILED)  // tests for LogonStatus == STATUS_WRONG_PASSWORD
    {
        RtlZeroMemory(&LogonStats, sizeof(LogonStats));

        LogonStats.StatisticsToApply =
            USER_LOGON_BAD_PASSWORD_WKSTA |
            USER_LOGON_TYPE_KERBEROS;

        // Indicate wrong password used but not if previous password matches
        if (!UsedOldPassword)
        {
            LogonStats.StatisticsToApply |= USER_LOGON_BAD_PASSWORD;
        }

        LogonStats.Workstation = *ClientNetbiosAddress;
        if ( (ClientAddress == NULL)
             || (ClientAddress->sa_family == AF_INET) )
        {
            LogonStats.ClientInfo.Type = SamClientIpAddr;
            LogonStats.ClientInfo.Data.IpAddr = *((ULONG*)GET_CLIENT_ADDRESS(ClientAddress));
        }

        Status = SamIUpdateLogonStatistics(
            UserHandle,
            &LogonStats
            );

        if (!NT_SUCCESS(Status))
        {
            D_DebugLog((DEB_ERROR, "SamIUpdateLogonStatistics failed - %x\n", Status ));
        }

        D_DebugLog((DEB_TRACE,"KLIN(%x) SamIUpdate Preauth failure StatsApply 0x%x.\n",
                    KLIN(FILENO,__LINE__), LogonStats.StatisticsToApply));
    }
    else if (Reason == KDC_ERR_KEY_EXPIRED)                // tests for  ((LogonStatus == STATUS_PASSWORD_MUST_CHANGE)  ||
    {                                                      //             (LogonStatus == STATUS_PASSWORD_EXPIRED))
        RtlZeroMemory(&LogonStats, sizeof(LogonStats));

        LogonStats.StatisticsToApply =
            USER_LOGON_STAT_BAD_PWD_COUNT |
            (fForwardedToPDC ? USER_LOGON_PDC_RETRY_SUCCESS : 0) |
            USER_LOGON_TYPE_KERBEROS;

        LogonStats.Workstation = *ClientNetbiosAddress;
        if ( (ClientAddress == NULL)
             || (ClientAddress->sa_family == AF_INET) )
        {
            LogonStats.ClientInfo.Type = SamClientIpAddr;
            LogonStats.ClientInfo.Data.IpAddr = *((ULONG*)GET_CLIENT_ADDRESS(ClientAddress));
        }

        Status = SamIUpdateLogonStatistics(
            UserHandle,
            &LogonStats
            );

        if (!NT_SUCCESS(Status))
        {
            D_DebugLog((DEB_ERROR, "SamIUpdateLogonStatistics failed - %x\n", Status ));
        }

        D_DebugLog((DEB_TRACE,"KLIN(%x) SamIUpdate KeyExpire failure StatsApply 0x%x.\n",
                    KLIN(FILENO,__LINE__), LogonStats.StatisticsToApply));
    }

}



//+---------------------------------------------------------------------------
//
//  Function:   KdcHandleNoLogonServers
//
//  Synopsis:   If a password has verified, and we've got no GCs against which
//              to validate logon restrictions, then go ahead and set the
//              sam info level to include the new USER_LOGON_NO_LOGON_SERVERS
//              flag
//
//  Effects:
//
//  Arguments:  [UserHandle] -- Client who logged on.
//              [ClientAddress] -- Address of client making request
//
//
//  Algorithm:
//
//  History:    24-Aug-2000   Todds   Created
//
//  Notes:      On successful logon w/ no GC, update SAM user flag
//
//----------------------------------------------------------------------------
KERBERR
KdcHandleNoLogonServers(
   SAMPR_HANDLE UserHandle,
   PSOCKADDR ClientAddress  OPTIONAL
   )
{
    SAM_LOGON_STATISTICS LogonStats;

    TRACE(KDC, KdcHandleNoLogonServers, DEB_FUNCTION);

    RtlZeroMemory(&LogonStats, sizeof(LogonStats));
    LogonStats.StatisticsToApply =
        USER_LOGON_NO_LOGON_SERVERS | USER_LOGON_TYPE_KERBEROS;
    if ( (ClientAddress == NULL)
      || (ClientAddress->sa_family == AF_INET) ) {
        // Set to local address (known to be 4 bytes) or IP address
        LogonStats.ClientInfo.Type = SamClientIpAddr;
        LogonStats.ClientInfo.Data.IpAddr = *((ULONG*)GET_CLIENT_ADDRESS(ClientAddress));
    }

    (VOID) SamIUpdateLogonStatistics(
            UserHandle,
            &LogonStats
            );

    return(KDC_ERR_NONE);
}

//+---------------------------------------------------------------------------
//
//  Function:   SuccessfulLogon
//
//  Synopsis:   Processes a successful logon.
//
//  Effects:    May raise an event, create an audit, throw a party.
//
//  Arguments:  [UserHandle] -- Client who logged on.
//
//
//  Algorithm:
//
//  History:    03-May-94   wader   Created
//
//  Notes:      On successful logon, we discard the history of failed logons
//              (as far as lockout is concerned).
//
//----------------------------------------------------------------------------

KERBERR
SuccessfulLogon(
    IN SAMPR_HANDLE UserHandle,
    IN OPTIONAL PSOCKADDR ClientAddress,
    IN UCHAR *Client,
    IN ULONG ClientSize,
    IN PKERB_MESSAGE_BUFFER Request,
    IN PUNICODE_STRING ClientNetbiosAddress,
    IN PUSER_INTERNAL6_INFORMATION UserInfo
    )
{
    SAM_LOGON_STATISTICS LogonStats;
    KERB_MESSAGE_BUFFER Reply = {0};
    NTSTATUS   Status = STATUS_UNKNOWN_REVISION;
    DOMAIN_SERVER_ROLE ServerRole;

    TRACE(KDC, SuccessfulLogon, DEB_FUNCTION);

    RtlZeroMemory(&LogonStats, sizeof(LogonStats));
    LogonStats.StatisticsToApply =
        USER_LOGON_INTER_SUCCESS_LOGON | USER_LOGON_TYPE_KERBEROS;

    if ( (ClientAddress == NULL)
      || (ClientAddress->sa_family == AF_INET) ) {
        // Set to local address (known to be 4 bytes) or IP address
        LogonStats.ClientInfo.Type = SamClientIpAddr;
        LogonStats.ClientInfo.Data.IpAddr =  *((ULONG*)GET_CLIENT_ADDRESS(ClientAddress));
    }

    (VOID) SamIUpdateLogonStatistics(
                UserHandle,
                &LogonStats
                );

    D_DebugLog((DEB_TRACE,"KLIN(%x) SamIUpdate Successfullogon StatsApply 0x%x.\n",
                KLIN(FILENO,__LINE__), LogonStats.StatisticsToApply));

    Status = SamIQueryServerRole(
                GlobalAccountDomainHandle,
                &ServerRole
                );

    if (NT_SUCCESS(Status) &&
        (ServerRole == DomainServerRoleBackup))
    {
        //
        // if this logon reset the bad password count, notify the PDC
        //

        if (UserInfo->I1.BadPasswordCount != 0)
        {
           Status = SamIResetBadPwdCountOnPdc(UserHandle);

           if (!NT_SUCCESS(Status))
           {
              if (Status == STATUS_UNKNOWN_REVISION)
              {
                 D_DebugLog((DEB_ERROR, "SamIResetBadPwdCount not implemented on pdc.\n"));

                 // W2k behavior, in case we have an old PDC
                 (VOID) KdcForwardLogonToPDC(
                             Request,
                             &Reply
                             );

                 if (Reply.Buffer != NULL)
                 {
                    MIDL_user_free(Reply.Buffer);
                 }
              }
              else
              {
                 D_DebugLog((DEB_ERROR, "SamIResetBadPwdCount failed - %x.\n", Status));
              }
           }

        }

        // Clear any negative cache entry (Forward to PDC)
        (void)AsNegCacheDelete(
                        Client,
                        ClientSize,
                        ClientNetbiosAddress->Buffer,
                        ClientNetbiosAddress->Length
                        );
    }

    return(KDC_ERR_NONE);
}


//+-------------------------------------------------------------------------
//
//  Function:   IsSubAuthFilterPresent
//
//  Synopsis:   Figures out whether the MSV1_0 subauthentication filter is present
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:    TRUE or FALSE
//
//  Notes:
//
//
//--------------------------------------------------------------------------


BOOLEAN
IsSubAuthFilterPresent()
{
    if ( KdcSubAuthFilterPresent == SubAuthUnknown ) {

        if ( Msv1_0SubAuthenticationPresent( KERB_SUBAUTHENTICATION_FLAG )) {

            KdcSubAuthFilterPresent = SubAuthYesFilter;

        } else {

            KdcSubAuthFilterPresent = SubAuthNoFilter;
        }
    }

    if ( KdcSubAuthFilterPresent == SubAuthNoFilter ) {

        return FALSE;
    }

    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Function:   KdcCallSubAuthRoutine
//
//  Synopsis:   Calls the MSV1_0 subauthentication filter, if it is present
//
//  Effects:    If the filter returns an error, returns that error
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KdcCallSubAuthRoutine(
    IN PKDC_TICKET_INFO TicketInfo,
    IN PUSER_INTERNAL6_INFORMATION UserInfo,
    IN PUNICODE_STRING ClientNetbiosAddress,
    OUT PLARGE_INTEGER LogoffTime,
    OUT PKERB_EXT_ERROR pExtendedError
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    KERBERR KerbErr = KDC_ERR_NONE;
    NETLOGON_INTERACTIVE_INFO LogonInfo = {0};
    //
    // Subauth parameters
    //
    ULONG WhichFields = 0;
    ULONG UserFlags = 0;
    BOOLEAN Authoritative = TRUE;
    LARGE_INTEGER KickoffTime;
    PUSER_ALL_INFORMATION UserAll = &UserInfo->I1;

    //
    // Check if Msv1_0 has a subauth filter loaded
    //

    if ( !IsSubAuthFilterPresent()) {

        return KDC_ERR_NONE;
    }

    LogonInfo.Identity.LogonDomainName = *SecData.KdcRealmName();
    LogonInfo.Identity.ParameterControl = 0; // this can be set to use a particular package
    LogonInfo.Identity.UserName = TicketInfo->AccountName;
    LogonInfo.Identity.Workstation = *ClientNetbiosAddress;

    //
    // Leave logon id field blank
    //

    if (UserAll->NtPassword.Length == NT_OWF_PASSWORD_LENGTH)
    {
        RtlCopyMemory(
            &LogonInfo.NtOwfPassword,
            UserAll->NtPassword.Buffer,
            NT_OWF_PASSWORD_LENGTH
            );
    }

    if (UserAll->LmPassword.Length == LM_OWF_PASSWORD_LENGTH)
    {
        RtlCopyMemory(
            &LogonInfo.LmOwfPassword,
            UserAll->LmPassword.Buffer,
            NT_OWF_PASSWORD_LENGTH
            );
    }

    //
    // Make sure logoff time is intialized to something interesting
    //

    *LogoffTime = KickoffTime = UserAll->AccountExpires;

    //
    // Make the call
    //

    Status = Msv1_0ExportSubAuthenticationRoutine(
                NetlogonInteractiveInformation,
                &LogonInfo,
                MSV1_0_PASSTHRU,
                KERB_SUBAUTHENTICATION_FLAG,
                UserAll,
                &WhichFields,
                &UserFlags,
                &Authoritative,
                LogoffTime,
                &KickoffTime
                );

    //
    // If the kickoff time is more restrictive, use it.
    //

    if (KickoffTime.QuadPart < LogoffTime->QuadPart)
    {
        LogoffTime->QuadPart = KickoffTime.QuadPart;
    }

    //
    // Map the error code
    //

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_WARN,
                  "(KLIN:%x) Subauth failed the logon: 0x%x\n",
                  KLIN(FILENO, __LINE__),
                  Status));
        FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__);
        KerbErr = KDC_ERR_POLICY;
    }

    return(KerbErr);
}


//+-------------------------------------------------------------------------
//
//  Function:   KdcBuildEtypeInfo
//
//  Synopsis:   Builds a list of supported etypes & salts
//
//  Effects:
//
//  Arguments:  TicketInfo - client's ticket info
//              OutputPreAuth - receives any preauth data to return to client
//
//  Requires:
//
//  Returns:    kerberr
//
//  Notes:
//
//
//--------------------------------------------------------------------------
KERBERR
KdcBuildEtypeInfo(
    IN PKDC_TICKET_INFO TicketInfo,
    IN PKERB_KDC_REQUEST_BODY RequestBody,
    OUT PKERB_PA_DATA_LIST * OutputPreAuth
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    BOOLEAN FoundEtype = FALSE;
    ULONG Index;
    PKERB_ETYPE_INFO NextEntry = NULL;
    PKERB_ETYPE_INFO EtypeInfo = NULL;
    PKERB_PA_DATA_LIST OutputList = NULL;
    UNICODE_STRING TempSalt = {0};
    STRING TempString = {0};

    *OutputPreAuth = NULL;
    //
    // Build the array of etypes, in reverse order because we are adding
    // to the front of the list
    //

    for ( Index = TicketInfo->Passwords->CredentialCount; Index > 0; Index-- )
    {
        //
        // Only return types that the client supports.
        //

        if (!KdcCheckForEtype(
                RequestBody->encryption_type,
                TicketInfo->Passwords->Credentials[Index-1].Key.keytype
                ))
        {
            continue;
        }
        FoundEtype = TRUE;
        NextEntry = (PKERB_ETYPE_INFO) MIDL_user_allocate(sizeof(KERB_ETYPE_INFO));
        if (NextEntry == NULL)
        {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }

        RtlZeroMemory(
            NextEntry,
            sizeof(KERB_ETYPE_INFO)
            );

        //
        // Copy in the etype
        //

        NextEntry->value.encryption_type =
            TicketInfo->Passwords->Credentials[Index-1].Key.keytype;

        //
        // add the salt - check the per-key salt and then the default salt.
        //

        if (TicketInfo->Passwords->Credentials[Index-1].Salt.Buffer != NULL)
        {
            TempSalt = TicketInfo->Passwords->Credentials[Index-1].Salt;
        }
        else if (TicketInfo->Passwords->DefaultSalt.Buffer != NULL)
        {
            TempSalt = TicketInfo->Passwords->DefaultSalt;
        }
        else
        {
            TempSalt.Buffer = NULL ;
            TempSalt.Length = 0 ;
            TempSalt.MaximumLength = 0 ;
        }

        //
        // If we have a salt, convert it to ansi & return it.
        //

        if (TempSalt.Buffer != NULL)
        {
            TempString.Buffer = NULL;
            TempString.Length = 0;
            TempString.MaximumLength = 0;

            KerbErr = KerbUnicodeStringToKerbString(
                        &TempString,
                        &TempSalt
                        );
            if (!KERB_SUCCESS(KerbErr))
            {
                MIDL_user_free(NextEntry);
                goto Cleanup;
            }

            NextEntry->value.bit_mask |= salt_present;
            NextEntry->value.salt.length = TempString.Length;
            NextEntry->value.salt.value = (PUCHAR) TempString.Buffer;
        }

        NextEntry->next = EtypeInfo;
        EtypeInfo = NextEntry;

    }

    //
    // If we can't find a matching etype, then we've got to return an error
    // to the client...
    if (FoundEtype)
    {
       OutputList = (PKERB_PA_DATA_LIST) MIDL_user_allocate(sizeof(KERB_PA_DATA_LIST));
       if (OutputList == NULL)
       {
          KerbErr = KRB_ERR_GENERIC;
          goto Cleanup;
       }

       RtlZeroMemory(
          OutputList,
          sizeof(KERB_PA_DATA_LIST)
          );

       OutputList->value.preauth_data_type = KRB5_PADATA_ETYPE_INFO;
       OutputList->next = NULL;

       KerbErr = KerbPackData(
                    &EtypeInfo,
                    PKERB_ETYPE_INFO_PDU,
                    (PULONG) &OutputList->value.preauth_data.length,
                    &OutputList->value.preauth_data.value
                    );

       if (!KERB_SUCCESS(KerbErr))
       {
          goto Cleanup;
       }

       *OutputPreAuth = OutputList;
       OutputList = NULL;

    }
    else // did not find etype from request that we support, warn the admin
    {
       KerbErr = KDC_ERR_ETYPE_NOTSUPP;
       DebugLog((DEB_ERROR, "KdcCheckForEtype no intersection between client and server Etypes!\n"));

       KdcReportKeyError(
           &(TicketInfo->AccountName),
           NULL,
           KDC_KEY_ID_AS_BUILD_ETYPE_INFO,
           KDCEVENT_NO_KEY_INTERSECTION_AS,
           RequestBody->encryption_type,
           TicketInfo
           );
    }


Cleanup:

    //
    // Cleanup the etype list, as it is returned in marshalled form.
    //

    while (EtypeInfo != NULL)
    {
        NextEntry = EtypeInfo->next;
        if (EtypeInfo->value.salt.value != NULL)
        {

            TempString.Buffer = (PCHAR) EtypeInfo->value.salt.value;
            TempString.Length = (USHORT) EtypeInfo->value.salt.length;
            KerbFreeString((PUNICODE_STRING) &TempString);
        }

        MIDL_user_free(EtypeInfo);
        EtypeInfo = NextEntry;
    }
    if (OutputList != NULL)
    {
        KerbFreePreAuthData( OutputList);
    }

    return KerbErr;
}



//+-------------------------------------------------------------------------
//
//  Function:   KdcBuildPreauthTypeList
//
//  Synopsis:   For returning with a PREAUTH-REQUIRED message
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KdcBuildPreauthTypeList(
    OUT PKERB_PA_DATA_LIST *  PreauthTypeList
    )
{
    PKERB_PA_DATA_LIST DataList = NULL;
    KERBERR KerbErr = KDC_ERR_NONE;

    //
    // Allocate and fill in the first item
    //

    DataList = (PKERB_PA_DATA_LIST) MIDL_user_allocate(sizeof(KERB_PA_DATA_LIST));
    if (DataList == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }
    RtlZeroMemory(
        DataList,
        sizeof(KERB_PA_DATA_LIST)
        );

    DataList->value.preauth_data_type = KRB5_PADATA_ENC_TIMESTAMP;

    //
    // Even if we fail the allocation, we can still return this value.
    //

    *PreauthTypeList = DataList;

    DataList->next = (PKERB_PA_DATA_LIST) MIDL_user_allocate(sizeof(KERB_PA_DATA_LIST));
    if (DataList->next == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }
    RtlZeroMemory(
        DataList->next,
        sizeof(KERB_PA_DATA_LIST)
        );
    DataList = DataList->next;

    DataList->value.preauth_data_type = KRB5_PADATA_PK_AS_REP;

Cleanup:

    return(KerbErr);
}



//+-------------------------------------------------------------------------
//
//  Function:   KdcBuildPwSalt
//
//  Synopsis:   builds the pw-salt pa data type
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KdcBuildPwSalt(
    IN PKERB_STORED_CREDENTIAL Passwords,
    IN PKERB_ENCRYPTION_KEY ReplyKey,
    IN OUT PKERB_PA_DATA_LIST * OutputPreAuthData
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    PKERB_PA_DATA_LIST DataList = NULL;
    PKERB_KEY_DATA KeyData = NULL;
    STRING Salt = {0};
    UNICODE_STRING SaltUsed = {0};
    ULONG Index;

    
    //
    // Find the key use for encryption.
    //

    for (Index = 0; Index < Passwords->CredentialCount ; Index++ )
    {
        if (Passwords->Credentials[Index].Key.keytype == (int) ReplyKey->keytype)
        {
            KeyData = &Passwords->Credentials[Index];
            break;
        }
    }

    if (KeyData == NULL)
    {
        goto Cleanup;
    }

    //
    // Locate the salt used
    //
    switch ( ReplyKey->keytype )
    {
    
    case KERB_ETYPE_RC4_HMAC_NT:
    case KERB_ETYPE_RC4_HMAC_NT_EXP:
    case KERB_ETYPE_RC4_HMAC_OLD:
    case KERB_ETYPE_RC4_MD4:
        //
        // These etypes don't use salt - don't send it.
        //
        goto Cleanup;
    case KERB_ETYPE_DES_CBC_MD5:
    case KERB_ETYPE_DES_CBC_CRC:
        if (KeyData->Salt.Buffer != NULL)
        {
            SaltUsed = KeyData->Salt;
        }
        else if (Passwords->DefaultSalt.Buffer != NULL)
        {
            SaltUsed = Passwords->DefaultSalt;
        }
        break;
    default:
        //
        // Don't fail on unknown etypes - just don't send papwsalt.
        //
        D_DebugLog(( DEB_WARN, "Trying to salt %x etype, which we don't know\n", ReplyKey->keytype ));
        goto Cleanup;
    }

    //
    // Convert the salt to a kerb string
    //
    KerbErr = KerbUnicodeStringToKerbString(
                &Salt,
                &SaltUsed
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    //
    // Allocate and fill in the first item
    //

    DataList = (PKERB_PA_DATA_LIST) MIDL_user_allocate(sizeof(KERB_PA_DATA_LIST));
    if (DataList == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }
    RtlZeroMemory(
        DataList,
        sizeof(KERB_PA_DATA_LIST)
        );

    DataList->value.preauth_data_type = KRB5_PADATA_PW_SALT;
    DataList->value.preauth_data.length = Salt.Length;
    DataList->value.preauth_data.value = (PUCHAR) Salt.Buffer;
    Salt.Buffer = NULL;

    DataList->next = *OutputPreAuthData;
    *OutputPreAuthData = DataList;
    DataList = NULL;
Cleanup:

    if (DataList != NULL)
    {
        KerbFreePreAuthData((PKERB_PA_DATA_LIST)DataList);
    }
    if (Salt.Buffer != NULL)
    {
        MIDL_user_free(Salt.Buffer);
    }
    return(KerbErr);

}

//+-------------------------------------------------------------------------
//
//  Function:   KdcVerifyEncryptedTimeStamp
//
//  Synopsis:   Verifies an encrypted time stamp pre-auth data
//
//  Effects:
//
//  Arguments:  PreAuthData - preauth data from client
//              TicketInfo - client's ticket info
//              UserHandle - handle to client's account
//              OutputPreAuth - receives any preauth data to return to client
//
//  Requires:
//
//  Returns:    KDC_ERR_PREAUTH_FAILED - the password was bad
//              Other errors - preauth failed but shouldn't trigger lockout
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KdcVerifyEncryptedTimeStamp(
    IN PKERB_PA_DATA_LIST PreAuthData,
    IN PKDC_TICKET_INFO TicketInfo,
    IN PKERB_KDC_REQUEST_BODY RequestBody,
    IN SAMPR_HANDLE UserHandle,
    OUT PKERB_PA_DATA_LIST * OutputPreAuth,
    OUT PBOOLEAN UsedOldPassword
    )
{
    KERBERR KerbErr;
    PKERB_ENCRYPTED_DATA EncryptedData = NULL;
    PKERB_ENCRYPTED_TIMESTAMP EncryptedTime = NULL;
    PKERB_ENCRYPTION_KEY UserKey = NULL;
    LARGE_INTEGER CurrentTime;
    LARGE_INTEGER ClientTime;

    if ((TicketInfo->UserAccountControl & USER_ACCOUNT_DISABLED))
    {
        KerbErr = KDC_ERR_CLIENT_REVOKED;
        goto Cleanup;
    }

    //
    // Unpack the pre-auth data into an encrypted data first.
    //

    KerbErr = KerbUnpackEncryptedData(
                PreAuthData->value.preauth_data.value,
                PreAuthData->value.preauth_data.length,
                &EncryptedData
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    //
    // Now decrypt the encrypted data (in place)
    //

    UserKey = KerbGetKeyFromList(
                TicketInfo->Passwords,
                EncryptedData->encryption_type
                );

    if (UserKey == NULL)
    {
        // fakeit
        KERB_CRYPT_LIST FakeList;

        DebugLog((DEB_ERROR, "KdcVerifyEncryptedTimeStamp found no key %#x for %wZ, account control %#x\n", 
            EncryptedData->encryption_type, &TicketInfo->AccountName, TicketInfo->UserAccountControl));

        FakeList.next = NULL;
        FakeList.value = EncryptedData->encryption_type ;

        //
        // do not report an error if this is an DES only user and the preauth 
        // etype is RC4_HMAC_NT: the client can remove this error by setting 
        // DefaultEncryptionType registry key and this is a common error 
        // (although invalid)
        //

        if ( !( (TicketInfo->UserAccountControl & USER_USE_DES_KEY_ONLY)
                 && (EncryptedData->encryption_type == KERB_ETYPE_RC4_HMAC_NT) ) ) 
        {            
            KdcReportKeyError(
                &(TicketInfo->AccountName),
                NULL,
                KDC_KEY_ID_AS_VERIFY_PREAUTH,
                KDCEVENT_NO_KEY_INTERSECTION_AS,
                &FakeList,
                TicketInfo
                );
        }
 
        KerbErr = KDC_ERR_ETYPE_NOTSUPP;
        goto Cleanup;
    }

    KerbErr = KerbDecryptDataEx(
                EncryptedData,
                UserKey,
                KERB_ENC_TIMESTAMP_SALT,
                (PULONG) &EncryptedData->cipher_text.length,
                EncryptedData->cipher_text.value
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        KERBERR KerbErr2;
        ULONG   ulIndex = 0;

        //
        // Bug #450148: Do not increment account lockout count when logging
        //              on with old password
        //
        // Attempt to decrypt the data using the old password to see if that
        // is what is going on
        // We will check the previous password and the one before that (second previous)
        // password should it exist.
        //

        //
        // Original EncryptedData has been trashed by in-proc decryption;
        // must re-generate
        //

        KerbFreeEncryptedData(EncryptedData);
        EncryptedData = NULL;
        UserKey = NULL;

        KerbErr2 = KerbUnpackEncryptedData(
                       PreAuthData->value.preauth_data.value,
                       PreAuthData->value.preauth_data.length,
                       &EncryptedData
                       );

        if ( KERB_SUCCESS( KerbErr2 ))
        {
            UserKey = KerbGetKeyFromListByIndex(
                          TicketInfo->OldPasswords,
                          EncryptedData->encryption_type,
                          &ulIndex
                          );
        }

        if (UserKey != NULL)
        {
            KerbErr2 = KerbDecryptDataEx(
                           EncryptedData,
                           UserKey,
                           KERB_ENC_TIMESTAMP_SALT,
                           (PULONG) &EncryptedData->cipher_text.length,
                           EncryptedData->cipher_text.value
                           );
        }
        else
        {
            KerbErr2 = KDC_ERR_ETYPE_NOTSUPP;
        }

        if ( KERB_SUCCESS( KerbErr2 ))
        {
            D_DebugLog((DEB_WARN,
                "KLIN(%x) Pre-auth data encrypted with old password\n",
                KLIN(FILENO,__LINE__)));

            *UsedOldPassword = TRUE;
        }
        else
        {
            D_DebugLog((DEB_WARN,
                "KLIN(%x) Failed to decrypt timestamp pre-auth data with previous old password: 0x%x\n",
                KLIN(FILENO,__LINE__),
                KerbErr2));

            // Now see if the password before that (second previous) password matches
            // This is necessary to hanlde the cases where an account is locked out and
            // then the password is reset and change password on next login is selected.
            // This requires a test of the previous 2 passwords in history


            //
            // Original EncryptedData has been trashed by in-proc decryption;
            // must re-generate
            //

            KerbFreeEncryptedData(EncryptedData);
            EncryptedData = NULL;
            UserKey = NULL;

            KerbErr2 = KerbUnpackEncryptedData(
                           PreAuthData->value.preauth_data.value,
                           PreAuthData->value.preauth_data.length,
                           &EncryptedData
                           );

            if ( KERB_SUCCESS( KerbErr2 ))
            {
                UserKey = KerbGetKeyFromListByIndex(
                              TicketInfo->OldPasswords,
                              EncryptedData->encryption_type,
                              &ulIndex
                              );
            }

            if (UserKey != NULL)
            {
                KerbErr2 = KerbDecryptDataEx(
                               EncryptedData,
                               UserKey,
                               KERB_ENC_TIMESTAMP_SALT,
                               (PULONG) &EncryptedData->cipher_text.length,
                               EncryptedData->cipher_text.value
                               );
            }
            else
            {
                KerbErr2 = KDC_ERR_ETYPE_NOTSUPP;
            }

            if ( KERB_SUCCESS( KerbErr2 ))
            {
                D_DebugLog((DEB_WARN,
                          "KLIN(%x) Pre-auth data encrypted with second old password\n",
                          KLIN(FILENO,__LINE__)));

                *UsedOldPassword = TRUE;
            }
            else
            {
                D_DebugLog((DEB_WARN,
                          "KLIN(%x) Failed to decrypt timestamp pre-auth data with second previous old password: 0x%x\n",
                          KLIN(FILENO,__LINE__),
                          KerbErr2));
            }
        }
        KerbErr = KDC_ERR_PREAUTH_FAILED;
        goto Cleanup;
    }

    //
    // unpack the decrypted data into a KERB_ENCRYPTED_TIMESTAMP
    //

    KerbErr = KerbUnpackData(
                EncryptedData->cipher_text.value,
                EncryptedData->cipher_text.length,
                KERB_ENCRYPTED_TIMESTAMP_PDU,
                (PVOID *) &EncryptedTime
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        D_DebugLog((DEB_WARN,"KLIN(%x) Failed to unpack preauth data to encrpyted_time\n",
                  KLIN(FILENO,__LINE__)));

        goto Cleanup;
    }

    //
    // Now verify the time.
    //

    KerbConvertGeneralizedTimeToLargeInt(
        &ClientTime,
        &EncryptedTime->timestamp,
        ((EncryptedTime->bit_mask & KERB_ENCRYPTED_TIMESTAMP_usec_present) != 0) ?
            EncryptedTime->KERB_ENCRYPTED_TIMESTAMP_usec : 0
        );

    GetSystemTimeAsFileTime(
        (PFILETIME) &CurrentTime
        );

    //
    // We don't want to check too closely, so allow for skew
    //

    if ((CurrentTime.QuadPart + SkewTime.QuadPart < ClientTime.QuadPart) ||
        (CurrentTime.QuadPart - SkewTime.QuadPart > ClientTime.QuadPart))
    {
        D_DebugLog((DEB_ERROR, "KLIN(%x) Client %wZ time is incorrect:\n",
            KLIN(FILENO,__LINE__),
            &TicketInfo->AccountName));
        PrintTime(DEB_ERROR, "Client Time is", &ClientTime );
        PrintTime(DEB_ERROR, "KDC Time is", &CurrentTime );

        //
        // We don't want to lockout the account if the time is off
        //

        KerbErr = KRB_AP_ERR_SKEW;
        goto Cleanup;
    }

    KerbErr = KDC_ERR_NONE;

Cleanup:
    //
    // Build an ETYPE_INFO structure to return
    //

    if ((KerbErr == KDC_ERR_PREAUTH_FAILED) || (KerbErr == KDC_ERR_ETYPE_NOTSUPP))
    {
       KERBERR TmpErr;

       TmpErr  = KdcBuildEtypeInfo(
                     TicketInfo,
                     RequestBody,
                     OutputPreAuth
                     );

       //
       // In this case, we can't find any ETypes that both the client and
       // server support, so we've got to bail w/ proper error
       // message...
       //
       if (TmpErr == KDC_ERR_ETYPE_NOTSUPP)
       {
          KerbErr = KDC_ERR_ETYPE_NOTSUPP;
       }
    }

    if (EncryptedData != NULL)
    {
        KerbFreeEncryptedData(EncryptedData);
    }
    if (EncryptedTime != NULL)
    {
        KerbFreeData(KERB_ENCRYPTED_TIMESTAMP_PDU, EncryptedTime);
    }

    return(KerbErr);


}


typedef enum _BUILD_PAC_OPTIONS {
    IncludePac,
    DontIncludePac,
    DontCare
} BUILD_PAC_OPTIONS, *PBUILD_PAC_OPTIONS;

//+-------------------------------------------------------------------------
//
//  Function:   KdcCheckPacRequestPreAuthData
//
//  Synopsis:   Gets the status of whether the client wants a PAC from the
//              pre-auth data
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


KERBERR
KdcCheckPacRequestPreAuthData(
    IN PKERB_PA_DATA_LIST PreAuthData,
    IN OUT PBUILD_PAC_OPTIONS BuildPac
    )
{
    PKERB_PA_PAC_REQUEST PacRequest = NULL;
    KERBERR KerbErr = KDC_ERR_NONE;

    DsysAssert(PreAuthData->value.preauth_data_type == KRB5_PADATA_PAC_REQUEST);

    KerbErr = KerbUnpackData(
                PreAuthData->value.preauth_data.value,
                PreAuthData->value.preauth_data.length,
                KERB_PA_PAC_REQUEST_PDU,
                (PVOID *) &PacRequest
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }
    if (PacRequest->include_pac)
    {
        *BuildPac = IncludePac;
    }
    else
    {
        *BuildPac = DontIncludePac;
    }

    D_DebugLog((DEB_T_TICKETS,"Setting BuildPac from pa-data to %d\n",*BuildPac));

Cleanup:
    if (PacRequest != NULL)
    {
        KerbFreeData(
            KERB_PA_PAC_REQUEST_PDU,
            PacRequest
            );
    }
    return(KerbErr);

}

//+-------------------------------------------------------------------------
//
//  Function:   KdcCheckPreAuthData
//
//  Synopsis:   Checks the pre-auth data in an AS request. This routine
//              may return pre-auth data to caller on both success and
//              failure.
//
//  Effects:
//
//  Arguments:  ClientTicketInfo - client account's ticket info
//              UserHandle - Handle to client's user object
//              PreAuthData - Pre-auth data supplied by client
//              PreAuthType - The type of pre-auth used
//              OutputPreAuthData - pre-auth data to return to client
//              BuildPac - TRUE if we should build a PAC for this client
//
//
//  Requires:
//
//  Returns:    KDC_ERR_PREAUTH_REQUIRED, KDC_ERR_PREAUTH_FAILED
//
//  Notes:      This routine should be more extensible - at some point
//              it should allow DLLs to be plugged in that implement
//              preauth.
//
//
//--------------------------------------------------------------------------

KERBERR
KdcCheckPreAuthData(
    IN PKDC_TICKET_INFO ClientTicketInfo,
    IN SAMPR_HANDLE UserHandle,
    IN PUSER_INTERNAL6_INFORMATION UserInfo,
    IN OPTIONAL PKERB_PA_DATA_LIST PreAuthData,
    IN PKERB_KDC_REQUEST_BODY RequestBody,
    OUT PULONG PreAuthType,
    OUT PKERB_PA_DATA_LIST * OutputPreAuthData,
    OUT PBOOLEAN BuildPac,
    OUT PULONG Nonce,
    OUT PKERB_ENCRYPTION_KEY EncryptionKey,
    OUT PUNICODE_STRING TransitedRealms,
    OUT PKDC_PKI_AUDIT_INFO PkiAuditInfo,
    OUT PKERB_MESSAGE_BUFFER ErrorData,
    OUT PKERB_EXT_ERROR pExtendedError,
    OUT PBOOLEAN UsedOldPassword
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    PKERB_PA_DATA_LIST OutputElement = NULL;
    PKERB_PA_DATA_LIST ListElement = NULL;
    BOOLEAN ValidPreauthPresent = FALSE;
    BUILD_PAC_OPTIONS PacOptions = DontCare;

    *OutputPreAuthData = NULL;
    *BuildPac = FALSE;
    *UsedOldPassword = FALSE;

    //
    // Loop through the supplied pre-auth data elements and handle each one
    //

    for (ListElement = PreAuthData;
         ListElement != NULL ;
         ListElement = ListElement->next )
    {
        switch(ListElement->value.preauth_data_type) {
        case KRB5_PADATA_ENC_TIMESTAMP:

            *PreAuthType = ListElement->value.preauth_data_type;

            KerbErr = KdcVerifyEncryptedTimeStamp(
                        ListElement,
                        ClientTicketInfo,
                        RequestBody,
                        UserHandle,
                        &OutputElement,
                        UsedOldPassword
                        );

            if (KERB_SUCCESS(KerbErr))
            {
                ValidPreauthPresent = TRUE;
            }

            break;
        case KRB5_PADATA_PK_AS_REP:
            *PreAuthType = ListElement->value.preauth_data_type;

            KerbErr = KdcCheckPkinitPreAuthData(
                        ClientTicketInfo,
                        UserHandle,
                        ListElement,
                        RequestBody,
                        &OutputElement,
                        Nonce,
                        EncryptionKey,
                        TransitedRealms,
                        PkiAuditInfo,
                        pExtendedError
                        );

            if (KERB_SUCCESS(KerbErr))
            {
                ValidPreauthPresent = TRUE;
            }

            break;
        case KRB5_PADATA_PAC_REQUEST:
            KerbErr = KdcCheckPacRequestPreAuthData(
                        ListElement,
                        &PacOptions
                        );
            break;
        default:
            break;


        } // switch
        if (OutputElement != NULL)
        {
            OutputElement->next = *OutputPreAuthData;
            *OutputPreAuthData = OutputElement;
            OutputElement = NULL;
        }
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }


    } // for

    // We need to check preauth data by default, unless, the account tells
    // us not to.
    //

    if (!(UserInfo->I1.UserAccountControl & USER_DONT_REQUIRE_PREAUTH) &&
        !ValidPreauthPresent &&
        KERB_SUCCESS(KerbErr))
    {
        KerbErr = KDC_ERR_PREAUTH_REQUIRED;

        //
        // Return the list of supported types, if we don't have other
        // data to return.
        //

        if (*OutputPreAuthData == NULL)
        {
            (VOID) KdcBuildPreauthTypeList(OutputPreAuthData);
            if (*OutputPreAuthData != NULL)
            {
                PKERB_PA_DATA_LIST EtypeInfo = NULL;
                KERBERR TmpErr;
                TmpErr = KdcBuildEtypeInfo(
                             ClientTicketInfo,
                             RequestBody,
                             &EtypeInfo
                             );
                //
                // In this case, we can't find any ETypes that both the client and
                // server support, so we've got to bail w/ proper error
                // message...
                //
                if (TmpErr == KDC_ERR_ETYPE_NOTSUPP)
                {
                   KerbErr = KDC_ERR_ETYPE_NOTSUPP;
                }

                if (EtypeInfo != NULL)
                {
                        EtypeInfo->next = *OutputPreAuthData;
                        *OutputPreAuthData = EtypeInfo;
                        EtypeInfo = NULL;
                }
            }

        }
    }

    //
    // Set the final option for including the pac- if the pac_request was
    // included, honor it. Otherwise build the pac if valid preauth
    // was supplied.
    //

    switch(PacOptions) {

    case DontCare:
        *BuildPac = ValidPreauthPresent;
        break;

    case IncludePac:
        *BuildPac = TRUE;
        break;

    case DontIncludePac:
        *BuildPac = FALSE;
        break;
    }

Cleanup:

    return(KerbErr);

}






//+---------------------------------------------------------------------------
//
//  Function:   BuildTicketAS
//
//  Synopsis:   Builds an AS ticket, including filling inthe name fields
//              and flag fields.
//
//  Arguments:  [ClientTicketInfo]      -- client asking for the ticket
//              [ClientName]  -- name of client
//              [ServiceTicketInfo]     -- service ticket is for
//              [ServerName] -- name of service
//              [RequestBody]   -- ticket request
//              [NewTicket]    -- (out) ticket
//
//  History:    24-May-93   WadeR   Created
//
//  Notes:      See 3.1.3, A.2 of the Kerberos V5 R5.2 spec
//
//----------------------------------------------------------------------------

KERBERR
BuildTicketAS(
    IN PKDC_TICKET_INFO ClientTicketInfo,
    IN PKERB_PRINCIPAL_NAME ClientName,
    IN PKDC_TICKET_INFO ServiceTicketInfo,
    IN PKERB_PRINCIPAL_NAME ServerName,
    IN OPTIONAL PKERB_HOST_ADDRESSES HostAddresses,
    IN PLARGE_INTEGER LogoffTime,
    IN PLARGE_INTEGER AccountExpiry,
    IN PKERB_KDC_REQUEST_BODY RequestBody,
    IN ULONG CommonEType,
    IN ULONG PreAuthType,
    IN PUNICODE_STRING TransitedRealm,
    OUT PKERB_TICKET NewTicket,
    OUT PKERB_EXT_ERROR pExtendedError
    )
{
    KERBERR Status = KDC_ERR_NONE;
    PKERB_ENCRYPTED_TICKET EncryptedTicket = NULL;
    LARGE_INTEGER TicketLifespan;
    LARGE_INTEGER TicketRenewspan;
    ULONG KdcOptions = 0;
    BOOLEAN fKpasswd = FALSE;

    TRACE(KDC, BuildTicketAS, DEB_FUNCTION);

    EncryptedTicket = (PKERB_ENCRYPTED_TICKET) NewTicket->encrypted_part.cipher_text.value;

    KdcOptions = KerbConvertFlagsToUlong(&RequestBody->kdc_options);

    NewTicket->ticket_version = KERBEROS_VERSION;

    D_DebugLog((DEB_T_TICKETS, "Building an AS ticket to cname %wZ for sname %wZ\n",
                &ClientTicketInfo->AccountName, &ServiceTicketInfo->AccountName));

    //
    // Since this is the AS ticket, we fake the TGTFlags parameter to be the
    // maximum the client is allowed to have.
    //
    // Check to see if the request is for kadmin/changepw service, in which
    // case, we only want the ticket to be good for 2 minutes
    //

    Status = KerbCompareKdcNameToPrincipalName(
                  ServerName,
                  GlobalKpasswdName,
                  &fKpasswd
                  );

    if (!KERB_SUCCESS(Status))
    {
        D_DebugLog((DEB_TRACE,"KLIN(%x) Failed to check server name against GlobalKpasswdName: 0x%x\n",
              KLIN(FILENO,__LINE__), Status));
        FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__);
        goto Cleanup;
    }

    if (fKpasswd)
    {
       D_DebugLog((DEB_TRACE, "Restricting service ticket life time for kadmin/changepw\n"));
       TicketLifespan.QuadPart = (LONGLONG) 10000000 * 60 * 2;
       TicketRenewspan.QuadPart = (LONGLONG) 10000000 * 60 * 2;
    }
    else
    {
       TicketLifespan = SecData.KdcTgtTicketLifespan();
       TicketRenewspan = SecData.KdcTicketRenewSpan();
    }

    Status = KdcBuildTicketTimesAndFlags(
                ClientTicketInfo->fTicketOpts,
                ServiceTicketInfo->fTicketOpts,
                &TicketLifespan,
                &TicketRenewspan,
                NULL,           // no s4u info
                LogoffTime,
                AccountExpiry,
                RequestBody,
                NULL,           // no source ticket
                EncryptedTicket,
                pExtendedError
                );

    if (!KERB_SUCCESS(Status))
    {
        D_DebugLog((DEB_TRACE,"KLIN(%x) Failed to build ticket times and flags: 0x%x\n",
                  KLIN(FILENO,__LINE__), Status));
        FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__);
        goto Cleanup;
    }


    *((PULONG)EncryptedTicket->flags.value) |= KerbConvertUlongToFlagUlong(KERB_TICKET_FLAGS_initial);

    //
    // Turn on preauth flag if necessary
    //

    if (PreAuthType != 0)
    {
        *((PULONG)EncryptedTicket->flags.value) |= KerbConvertUlongToFlagUlong(KERB_TICKET_FLAGS_pre_authent);
    }

    Status = KerbMakeKey(
                CommonEType,
                &EncryptedTicket->key
                );

    if (!KERB_SUCCESS(Status))
    {
       FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__);
       goto Cleanup;
    }

    //
    // Insert the service names. If the client requested canoncalization,
    // return our realm name & sam account name. Otherwise copy what the
    // client requested
    //
    if (((KdcOptions & KERB_KDC_OPTIONS_name_canonicalize) != 0) &&
        ((ServiceTicketInfo->UserAccountControl & USER_USE_DES_KEY_ONLY) == 0))
    {
        PKERB_INTERNAL_NAME TempServiceName = NULL;
        //
        // Build the service name for the ticket. For interdomain trust
        // accounts, this is "krbtgt / domain name"
        //

        if (ServiceTicketInfo->UserId == DOMAIN_USER_RID_KRBTGT)
        {

            Status = KerbBuildFullServiceKdcName(
                        SecData.KdcDnsRealmName(),
                        SecData.KdcServiceName(),
                        KRB_NT_SRV_INST,
                        &TempServiceName
                        );

            if (!KERB_SUCCESS(Status))
            {
                FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__);
                goto Cleanup;
            }

            Status = KerbConvertKdcNameToPrincipalName(
                        &NewTicket->server_name,
                        TempServiceName
                        );

            KerbFreeKdcName(&TempServiceName);

            if (!KERB_SUCCESS(Status))
            {
                goto Cleanup;
            }
        }
        else if ((ServiceTicketInfo->UserAccountControl & USER_INTERDOMAIN_TRUST_ACCOUNT) != 0)
        {

            Status = KerbBuildFullServiceKdcName(
                        &ServiceTicketInfo->AccountName,
                        SecData.KdcServiceName(),
                        KRB_NT_SRV_INST,
                        &TempServiceName
                        );

            if (!KERB_SUCCESS(Status))
            {
                FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__);
                goto Cleanup;
            }

            Status = KerbConvertKdcNameToPrincipalName(
                        &NewTicket->server_name,
                        TempServiceName
                        );

            KerbFreeKdcName(&TempServiceName);

            if (!KERB_SUCCESS(Status))
            {
               FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__);
               goto Cleanup;
            }
        }
        else
        {
            Status = KerbConvertStringToPrincipalName(
                        &NewTicket->server_name,
                        &ServiceTicketInfo->AccountName,
                        KRB_NT_PRINCIPAL
                        );
            if (!KERB_SUCCESS(Status))
            {
               FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__);
               goto Cleanup;
            }
        }
    }
    else
    {
        //
        // No canonicalzation, so copy in all the names as the client
        // requested them.
        //

        Status = KerbDuplicatePrincipalName(
                    &NewTicket->server_name,
                    ServerName
                    );
        if (!KERB_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }

    NewTicket->realm = SecData.KdcKerbDnsRealmName();

    //
    // Insert the client names. If the client requested canoncalization,
    // return our realm name & sam account name. Otherwise copy what the
    // client requested
    //

    if ((ClientName->name_type == KRB_NT_ENTERPRISE_PRINCIPAL) &&
        ((ClientTicketInfo->UserAccountControl & USER_USE_DES_KEY_ONLY) == 0))
    {
        Status = KerbConvertStringToPrincipalName(
                    &EncryptedTicket->client_name,
                    &ClientTicketInfo->AccountName,
                    KRB_NT_PRINCIPAL
                    );
        if (!KERB_SUCCESS(Status))
        {
           FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__);
           goto Cleanup;
        }

    }
    else
    {
        Status = KerbDuplicatePrincipalName(
                    &EncryptedTicket->client_name,
                    ClientName
                    );
        if (!KERB_SUCCESS(Status))
        {
            FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__);
            goto Cleanup;
        }
    }

    Status = KerbDuplicateRealm(
                    &EncryptedTicket->client_realm,
                    SecData.KdcKerbDnsRealmName()
                    );

    if (!KERB_SUCCESS(Status))
    {
        FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__);
        goto Cleanup;
    }

    if (HostAddresses != NULL)
    {
        EncryptedTicket->bit_mask |= KERB_ENCRYPTED_TICKET_client_addresses_present;
        EncryptedTicket->KERB_ENCRYPTED_TICKET_client_addresses = HostAddresses;
    }
    else
    {
        EncryptedTicket->bit_mask &= ~KERB_ENCRYPTED_TICKET_client_addresses_present;
        EncryptedTicket->KERB_ENCRYPTED_TICKET_client_addresses = NULL;
    }

    if (TransitedRealm->Length > 0)
    {
        STRING TempString;
        Status = KerbUnicodeStringToKerbString(
                    &TempString,
                    TransitedRealm
                    );
        if (!KERB_SUCCESS(Status))
        {
           FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__);
           goto Cleanup;
        }
        EncryptedTicket->transited.transited_type = DOMAIN_X500_COMPRESS;
        EncryptedTicket->transited.contents.value = (PUCHAR) TempString.Buffer;
        EncryptedTicket->transited.contents.length = (int) TempString.Length;

    }
    else
    {
        RtlZeroMemory(
            &EncryptedTicket->transited,
            sizeof(KERB_TRANSITED_ENCODING)
            );
    }

    EncryptedTicket->KERB_ENCRYPTED_TICKET_authorization_data = NULL;

#if DBG
    PrintTicket( DEB_T_TICKETS, "BuildTicketAS: Final ticket", NewTicket );
#endif

Cleanup:
    if (!KERB_SUCCESS(Status))
    {
        KdcFreeInternalTicket(NewTicket);
    }
    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbCheckIfSPNIsChangePW
//
//  Synopsis:   Check if the service name is kadmin/changepw.
//
//  Arguments:  pServerName - Contains the service name
//              pLogonRestrictionsFlags - Output flags value.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbCheckIfSPNIsChangePW(
    IN PKERB_INTERNAL_NAME ServerName,
    IN ULONG *pLogonRestrictionsFlags
    )
{
     if (KerbEqualKdcNames(
             ServerName,
             GlobalKpasswdName
             ))
     {
         *pLogonRestrictionsFlags |= KDC_RESTRICT_IGNORE_PW_EXPIRATION;
     }

     return;
}


//+-------------------------------------------------------------------------
//
//  Function:   I_GetASTicket
//
//  Synopsis:   Gets an authentication service ticket to the requested
//              service.
//
//  Effects:    Allocates and encrypts a KDC reply
//
//  Arguments:  RequestMessage - Contains the AS request message
//              InputMessage - buffer client sent, used for replay detection
//              OutputMessage - Contains the AS reply message
//              ErrorData - contains any error data for an error message
//
//  Requires:
//
//  Returns:    KDC_ERR_ or KRB_AP_ERR errors only
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
I_GetASTicket(
    IN OPTIONAL PSOCKADDR ClientAddress,
    IN PKERB_AS_REQUEST RequestMessage,
    IN PUNICODE_STRING RequestRealm,
    IN PKERB_MESSAGE_BUFFER InputMessage,
    OUT PKERB_MESSAGE_BUFFER OutputMessage,
    OUT PKERB_MESSAGE_BUFFER ErrorData,
    OUT PKERB_EXT_ERROR pExtendedError,
    OUT PUNICODE_STRING ClientRealm,
    OUT PUNICODE_STRING ClientStringName,
    OUT PUNICODE_STRING ServerStringName
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    NTSTATUS LogonStatus = STATUS_SUCCESS;

    KDC_TICKET_INFO ClientTicketInfo = {0};
    KDC_TICKET_INFO ServiceTicketInfo = {0};

    SAMPR_HANDLE UserHandle = NULL;
    PUSER_INTERNAL6_INFORMATION UserInfo = NULL;
    SID_AND_ATTRIBUTES_LIST GroupMembership = {0};

    KERB_ENCRYPTION_KEY EncryptionKey = {0};
    PKERB_ENCRYPTION_KEY ServerKey = NULL;
    PKERB_ENCRYPTION_KEY ClientKey = NULL;
    ULONG CommonEType = KERB_ETYPE_DEFAULT;

    KERB_TICKET Ticket = {0};
    KERB_ENCRYPTED_TICKET EncryptedTicket = {0};
    KERB_ENCRYPTED_KDC_REPLY ReplyBody = {0};
    KERB_KDC_REPLY Reply = {0};
    PKERB_KDC_REQUEST_BODY RequestBody = NULL;
    PKERB_AUTHORIZATION_DATA PacAuthData = NULL;
    PKERB_PA_DATA_LIST OutputPreAuthData = NULL;
    PPKERB_HOST_ADDRESSES EffectiveAddresses = NULL;
    KDC_PKI_AUDIT_INFO PkiAuditInfo = {0};
    
    PKERB_INTERNAL_NAME ClientName = NULL;
    PKERB_INTERNAL_NAME ServerName = NULL;

    UNICODE_STRING ClientNetbiosAddress = {0};
    UNICODE_STRING ServerRealm = {0};
    UNICODE_STRING MappedClientName = {0};
    UNICODE_STRING TransitedRealm = {0};

    LARGE_INTEGER LogoffTime;
    LARGE_INTEGER AccountExpiry;
    ULONG NameFlags = 0;
    ULONG PreAuthType = 0;
    ULONG KdcOptions = 0;
    ULONG TicketFlags = 0;
    ULONG ReplyTicketFlags = 0;
    ULONG Nonce = 0;
    ULONG LogonRestrictionsFlags = 0;
    ULONG WhichFields = 0;

    BOOLEAN AuditedFailure = FALSE;
    BOOLEAN BuildPac = FALSE;
    BOOLEAN ClientReferral = FALSE;
    BOOLEAN ServerReferral = FALSE;
    BOOLEAN LoggedFailure = FALSE;
    BOOLEAN ClientInfoPresent = FALSE;
    BOOLEAN UsedOldPassword = FALSE;
    BOOLEAN bRestrictUserAccounts = FALSE;

    KDC_AS_EVENT_INFO ASEventTraceInfo = {0};

    TRACE(KDC, I_GetASTicket, DEB_FUNCTION);

    //
    //  Initialize local variables
    //

    EncryptedTicket.flags.value = (PUCHAR) &TicketFlags;
    EncryptedTicket.flags.length = sizeof(ULONG) * 8;
    ReplyBody.flags.value = (PUCHAR) &ReplyTicketFlags;
    ReplyBody.flags.length = sizeof(ULONG) * 8;
    RtlInitUnicodeString( ClientRealm, NULL );
    Ticket.encrypted_part.cipher_text.value = (PUCHAR) &EncryptedTicket;

    //
    // Assume that this isn't a logon request.  If we manage to fail before
    // we've determined it's a logon attempt, we won't mark it as a failed
    // logon.
    //

    RequestBody = &RequestMessage->request_body;

    //
    // There are many options that are invalid for an AS ticket.
    //

    KdcOptions = KerbConvertFlagsToUlong(&RequestBody->kdc_options);

    //
    // Start event tracing (capture error cases too)
    //

    if (KdcEventTraceFlag){

        ASEventTraceInfo.EventTrace.Guid = KdcGetASTicketGuid;
        ASEventTraceInfo.EventTrace.Class.Type = EVENT_TRACE_TYPE_START;
        ASEventTraceInfo.EventTrace.Flags = WNODE_FLAG_TRACED_GUID;
        ASEventTraceInfo.EventTrace.Size = sizeof (EVENT_TRACE_HEADER) + sizeof (ULONG);
        ASEventTraceInfo.KdcOptions = KdcOptions;

        TraceEvent(
            KdcTraceLoggerHandle,
            (PEVENT_TRACE_HEADER)&ASEventTraceInfo
            );
    }

    if (KdcOptions &
        (KERB_KDC_OPTIONS_forwarded |
         KERB_KDC_OPTIONS_proxy |
         KERB_KDC_OPTIONS_unused7 |
         KERB_KDC_OPTIONS_unused9 |
         KERB_KDC_OPTIONS_renew |
         KERB_KDC_OPTIONS_validate |
         KERB_KDC_OPTIONS_reserved |
         KERB_KDC_OPTIONS_enc_tkt_in_skey ) )
    {
        KerbErr = KDC_ERR_BADOPTION;
        goto Cleanup;
    }

    if (( RequestBody->bit_mask & addresses_present ) &&
        ( RequestBody->addresses == NULL ))
    {
        KerbErr = KDC_ERR_BADOPTION;
        goto Cleanup;
    }

    //
    // Make sure a client name was supplied
    //

    if ((RequestBody->bit_mask & KERB_KDC_REQUEST_BODY_client_name_present) != 0)
    {
        KerbErr = KerbConvertPrincipalNameToKdcName(
                    &ClientName,
                    &RequestBody->KERB_KDC_REQUEST_BODY_client_name
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }
        KerbErr = KerbConvertKdcNameToString(
                    ClientStringName,
                    ClientName,
                    NULL
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }
    }
    else
    {
        D_DebugLog((DEB_ERROR,"KLIN(%x) No principal name supplied to AS request - not allowed\n", KLIN(FILENO,__LINE__)));
        KerbErr = KDC_ERR_C_PRINCIPAL_UNKNOWN;
        goto Cleanup;
    }


    //
    // Copy out the service name. This is not an optional field.
    //

    if ((RequestBody->bit_mask & KERB_KDC_REQUEST_BODY_server_name_present) == 0)
    {
        D_DebugLog((DEB_ERROR, "I_GetASTicket KLIN(%x) Client %wZ sent AS request with no server name\n",
                  KLIN(FILENO, __LINE__),
                  &ClientStringName));
        FILL_EXT_ERROR(pExtendedError, STATUS_KDC_INVALID_REQUEST, FILENO, __LINE__);
        KerbErr = KDC_ERR_BADOPTION;
        goto Cleanup;
    }

    KerbErr = KerbConvertPrincipalNameToKdcName(
                &ServerName,
                &RequestBody->KERB_KDC_REQUEST_BODY_server_name
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    KerbErr = KerbConvertKdcNameToString(
                ServerStringName,
                ServerName,
                NULL
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    //
    // Check if the client said to canonicalize the name -- this is
    // determined by the name type for AS_REQ.
    //
    if((KdcOptions & KERB_KDC_OPTIONS_name_canonicalize) != 0)
    {
        NameFlags |= KDC_NAME_CHECK_GC;
    }
    else
    {
        //
        // canonicalize bit is not set so we want to check if the service
        // name is kadmin/changepw, if it is we set the flag to indicate
        // that we will ignore password expiration checking
        //

        KerbCheckIfSPNIsChangePW(
            ServerName,
            &LogonRestrictionsFlags);
    }

    D_DebugLog((DEB_TRACE, "I_GetASTicket getting an AS ticket to server "));
    D_KerbPrintKdcName((DEB_TRACE, ServerName));
    D_DebugLog((DEB_TRACE, "I_GetASTicket for client "));
    D_KerbPrintKdcName((DEB_TRACE, ClientName));

    //
    // Get the client's NETBIOS address.
    //

    if ((RequestBody->bit_mask & addresses_present) != 0)
    {
        KerbErr = KerbGetClientNetbiosAddress(
                    &ClientNetbiosAddress,
                    RequestBody->addresses
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }
    }

    //
    // Normalize the client name.
    //

    if ( !IsSubAuthFilterPresent()) {

        WhichFields = USER_ALL_KERB_CHECK_LOGON_RESTRICTIONS |
                      USER_ALL_KDC_CHECK_PREAUTH_DATA |
                      USER_ALL_ACCOUNTEXPIRES |
                      USER_ALL_KDC_GET_PAC_AUTH_DATA |
                      USER_ALL_SUCCESSFUL_LOGON;

    } else {

        //
        // We do not know what the subauth routine needs, so get everything
        //

        WhichFields = 0xFFFFFFFF & ~USER_ALL_UNDEFINED_MASK;
    }
          

    //
    // If there's no pre-auth, this could be an S4u location call.
    // This will trigger alt_sec_id lookups.
    //
    if (KerbFindPreAuthDataEntry(
                KRB5_PADATA_ENC_TIMESTAMP,
                RequestMessage->KERB_KDC_REQUEST_preauth_data) == NULL)
    {   
        NameFlags  |= KDC_NAME_S4U_CLIENT;
    }

    KerbErr = KdcNormalize(
                  ClientName,
                  NULL,
                  RequestRealm,
                  NULL,           // no source ticket
                  NameFlags | KDC_NAME_CLIENT | KDC_NAME_FOLLOW_REFERRALS | KDC_NAME_CHECK_GC,
                  FALSE,          // do not restrict user accounts (user2user)
                  &ClientReferral,
                  ClientRealm,
                  &ClientTicketInfo,
                  pExtendedError,
                  &UserHandle,
                  WhichFields,
                  0L,
                  &UserInfo,
                  &GroupMembership
                  );

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR, "I_GetASTicket KLIN(%x) failed to normalize name %#x: ", KLIN(FILENO, __LINE__), KerbErr));
        KerbPrintKdcName(DEB_ERROR, ClientName);
        goto Cleanup;
    }

    if (ClientTicketInfo.Passwords != NULL)
    {
        ClientInfoPresent = TRUE;

        // If Credential count is zero and there was no error, we do not have
        // NT_OWF info so return Error since Kerb can not auth
        if (ClientTicketInfo.Passwords->CredentialCount <= CRED_ONLY_LM_OWF)
        {
            KerbErr = KDC_ERR_ETYPE_NOTSUPP;
            DebugLog((DEB_ERROR,"KLIN(%x) Failed to normalize name - no creds ", KLIN(FILENO, __LINE__)));
            KerbPrintKdcName(DEB_ERROR,ClientName);
            goto Cleanup;
        }

    }

    // If the UserHandle was NULL and there was no error, this must be
    // a cross realm trust account logon. Fail it, we have no account
    // to work with.

    if (!UserHandle || !UserInfo)
    {
        KerbErr = KDC_ERR_C_PRINCIPAL_UNKNOWN;
        D_DebugLog((DEB_ERROR,"KLIN(%x) Failed to normalize name", KLIN(FILENO,__LINE__)));
        D_KerbPrintKdcName((DEB_ERROR, ClientName));
        goto Cleanup;
    }

    //
    // If this is a referral, return an error and the true realm name
    // of the client
    //

    if (ClientReferral)
    {
        KerbErr = KDC_ERR_WRONG_REALM;
        D_DebugLog((DEB_WARN,
                  "KLIN(%x) Client tried to logon to account in another realm\n",
                  KLIN(FILENO,__LINE__)));
        goto Cleanup;
    }

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR, "KLIN(%x) Error getting client ticket info for %wZ: 0x%x \n",
                  KLIN(FILENO,__LINE__), &MappedClientName, KerbErr));
        goto Cleanup;
    }

    //
    // The below function will return true for pkinit
    //

    if (KerbFindPreAuthDataEntry(
                    KRB5_PADATA_PK_AS_REP,
                    RequestMessage->KERB_KDC_REQUEST_preauth_data) != NULL)
    {
        LogonRestrictionsFlags = KDC_RESTRICT_PKINIT_USED;
    }

    //
    // The order to check information on an account is:
    //     STATUS_ACCOUNT_LOCKED_OUT
    //     STATUS_WRONG_PASSWORD
    //         STATUS_PASSWORD_MUST_CHANGE/STATUS_PASSWORD_EXPIRED
    //  Note that you check for a bad password before the last two conditions
    //
    // Check logon restrictions before preauth data, so we don't accidentally
    // leak information about the password if account is locked out.
    // LogonStatus will have which Account restriction failed, KerbErr has the category of failure
    //

    KerbErr = KerbCheckLogonRestrictions(
                UserHandle,
                &ClientNetbiosAddress,
                &UserInfo->I1,
                LogonRestrictionsFlags,
                &LogoffTime,
                &LogonStatus
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_WARN , "LogonRestriction check failed: LogonStatus: 0x%x KRB: 0x%x\n",
                  LogonStatus, KerbErr));

        if ((LogonStatus == STATUS_ACCOUNT_LOCKED_OUT) ||        // Same as KerbErr == KDC_ERR_KEY_EXPIRED
            (LogonStatus == STATUS_PASSWORD_MUST_CHANGE)  ||
            (LogonStatus == STATUS_PASSWORD_EXPIRED)  ||
            (LogonStatus == STATUS_NO_LOGON_SERVERS))
        {
            KERBERR PreAuthKerbErr;
            BYTE ClientSid[MAX_SID_LEN];

            RtlZeroMemory(ClientSid, MAX_SID_LEN);
            KdcMakeAccountSid(ClientSid, ClientTicketInfo.UserId);

            //
            // Unpack the pre-auth data -- needed to check if wrong password and secondarily for auditing purposes
            //

            PreAuthKerbErr = KdcCheckPreAuthData(
                                 &ClientTicketInfo,
                                 UserHandle,
                                 UserInfo,
                                 RequestMessage->KERB_KDC_REQUEST_preauth_data,
                                 RequestBody,
                                 &PreAuthType,
                                 &OutputPreAuthData,
                                 &BuildPac,
                                 &Nonce,
                                 &EncryptionKey,
                                 &TransitedRealm,
                                 &PkiAuditInfo,
                                 ErrorData,
                                 pExtendedError,
                                 &UsedOldPassword
                                 );

            if (!KERB_SUCCESS(PreAuthKerbErr))
            {
                //
                // For account lockout, don't give the "attacker" extra info
                //   about bad password
                // For PASSWORD_MUST_CHANGE and PASSWORD_EXPIRE check for good password otherwise,
                //   replace with STATUS_WRONG_PASSWORD
                //
                //
                // We need to make sure we free up the error data
                // and pa data to be returned from the client,
                // but we really need to return the above error
                // as long as the account is not Locked out.
                //

                if (LogonStatus != STATUS_ACCOUNT_LOCKED_OUT)
                {
                    KerbErr = PreAuthKerbErr;
                }
                else if ( OutputPreAuthData != NULL )
                {
                    KerbFreePreAuthData( OutputPreAuthData );
                    OutputPreAuthData = NULL;
                }

                // Audit the Pre-auth failure

                D_DebugLog((DEB_WARN , "KLIN(%x) PreAuthData Check failed: LogonStatus: 0x%x KRB: 0x%x\n",
                          KLIN(FILENO,__LINE__), LogonStatus, KerbErr));

                if (SecData.AuditKdcEvent(KDC_AUDIT_AS_FAILURE))
                {
                    KdcLsaIAuditAsEvent(
                        SE_AUDITID_PREAUTH_FAILURE,
                        &ClientTicketInfo.AccountName,
                        NULL,                   // no domain name
                        ClientSid,
                        ServerStringName,
                        NULL,                   // no server sid
                        &PreAuthType,
                        (PULONG) &KerbErr,
                        NULL,
                        NULL,
                        GET_CLIENT_ADDRESS(ClientAddress),
                        &PkiAuditInfo.CertIssuerName,
                        &PkiAuditInfo.CertSerialNumber,
                        &PkiAuditInfo.CertThumbprint   
                        );

                    AuditedFailure = TRUE;
                }
            }

            //
            // Only handle failed logon if pre-auth fails. Otherwise the error
            // was something the client couldn't control, such as memory
            // allocation or clock skew.
            //

            if ((KerbErr == KDC_ERR_PREAUTH_FAILED) ||        // tests for STATUS_WRONG_PASSWORD
                (LogonStatus == STATUS_PASSWORD_MUST_CHANGE)  ||
                (LogonStatus == STATUS_PASSWORD_EXPIRED)  ||
                (LogonStatus == STATUS_ACCOUNT_LOCKED_OUT) )

            {
                D_DebugLog((DEB_WARN , "KLIN(%x) Calling Failedlogon: LogonStatus: 0x%x KRB: 0x%x PreAuthKRB: 0x%x\n",
                          KLIN(FILENO,__LINE__), LogonStatus, KerbErr, PreAuthKerbErr));

                FailedLogon(
                    UserHandle,
                    ClientAddress,
                    &RequestBody->KERB_KDC_REQUEST_BODY_client_name,
                    ClientSid,
                    MAX_SID_LEN,
                    &ClientTicketInfo,
                    InputMessage,
                    OutputMessage,
                    &ClientNetbiosAddress,
                    KerbErr,
                    LogonStatus,
                    UsedOldPassword
                    );

                LoggedFailure = TRUE;

                //
                // If there was a message form the PDC, then outputmessage will be non-NULL. This will always override any
                // value specified in KerbErr or LogonStatus
                // A NULL outputmessage indicates that we are on a PDC. And we create an error return based on LogonStatus
                // Fill the extended error w/ status from acct. restrictions.
                //
                if ((OutputMessage->Buffer == NULL) && !NT_SUCCESS(LogonStatus))
                {
                    FILL_EXT_ERROR_EX(pExtendedError, LogonStatus, FILENO, __LINE__);

                    D_DebugLog((DEB_TRACE, "KLIN(%x) setting error return based on logonstatus\n",
                          KLIN(FILENO,__LINE__)));
                }

                goto Cleanup;
            }
            else if (LogonStatus == STATUS_NO_LOGON_SERVERS)
            {
               D_DebugLog((DEB_WARN, "KLIN(%x) Logon Restriction check failed due to no logon servers\n",
                     KLIN(FILENO,__LINE__)));

               KdcHandleNoLogonServers(UserHandle,
                                       ClientAddress);
               goto Cleanup;
            }
            else
            {
                DebugLog((DEB_WARN,"KLIN(%x) Logon restriction check failed: LogonStatus: 0x%x KRB: 0x%x\n",
                    KLIN(FILENO,__LINE__), LogonStatus, KerbErr));
                FILL_EXT_ERROR_EX(pExtendedError, LogonStatus, FILENO, __LINE__);
                goto Cleanup;
            }
        }
        else
        {      // Catch all of the AccountRestrictions not possibly passed to PDC
           DebugLog((DEB_WARN,"KLIN(%x) Logon restriction check failed: LogonStatus: 0x%x KRB: 0x%x\n",
                     KLIN(FILENO,__LINE__),LogonStatus, KerbErr));
           // Here's one case where we want to return errors to the client, so use EX
           FILL_EXT_ERROR_EX(pExtendedError, LogonStatus, FILENO, __LINE__);
        }

        goto Cleanup;
    }    //  End Logon Restriction Processing

    //
    // There was no Account Restrictions so continue processing.  Check for correct password.
    // Unpack the pre-auth data.
    //

    KerbErr = KdcCheckPreAuthData(
                &ClientTicketInfo,
                UserHandle,
                UserInfo,
                RequestMessage->KERB_KDC_REQUEST_preauth_data,
                RequestBody,
                &PreAuthType,
                &OutputPreAuthData,
                &BuildPac,
                &Nonce,
                &EncryptionKey,
                &TransitedRealm,
                &PkiAuditInfo,
                ErrorData,
                pExtendedError,
                &UsedOldPassword
                );


    if (!KERB_SUCCESS(KerbErr))
    {
        BYTE ClientSid[MAX_SID_LEN];

        RtlZeroMemory(ClientSid, MAX_SID_LEN);
        KdcMakeAccountSid(ClientSid, ClientTicketInfo.UserId);

        if (SecData.AuditKdcEvent(KDC_AUDIT_AS_FAILURE))
        {
            KdcLsaIAuditAsEvent(
                SE_AUDITID_PREAUTH_FAILURE,
                &ClientTicketInfo.AccountName,
                NULL,                   // no domain name
                ClientSid,
                ServerStringName,
                NULL,                   // no server sid
                &PreAuthType,
                (PULONG) &KerbErr,
                NULL,
                NULL,
                GET_CLIENT_ADDRESS(ClientAddress),
                &PkiAuditInfo.CertIssuerName,
                &PkiAuditInfo.CertSerialNumber,
                &PkiAuditInfo.CertThumbprint
                );

            AuditedFailure = TRUE;
        }

        //
        // Only handle failed logon if pre-auth fails. Otherwise the error
        // was something the client couldn't control, such as memory
        // allocation or clock skew.
        //
        if (KerbErr == KDC_ERR_PREAUTH_FAILED)
        {
            D_DebugLog((DEB_WARN , "KLIN(%x) Calling Failedlogon: LogonStatus: 0x%x KRB: 0x%x\n",
                      KLIN(FILENO,__LINE__), LogonStatus, KerbErr));
            FailedLogon(
                UserHandle,
                ClientAddress,
                &RequestBody->KERB_KDC_REQUEST_BODY_client_name,
                ClientSid,
                MAX_SID_LEN,
                &ClientTicketInfo,
                InputMessage,
                OutputMessage,
                &ClientNetbiosAddress,
                KerbErr,
                LogonStatus,
                UsedOldPassword
                );
        }
        LoggedFailure = TRUE;
        DebugLog((DEB_ERROR,"KLIN(%x) Failed to check pre-auth data: 0x%x\n",
                  KLIN(FILENO,__LINE__), KerbErr));
        goto Cleanup;
    }

    //
    // Check for subauthentication
    //

    KerbErr = KdcCallSubAuthRoutine(
                &ClientTicketInfo,
                UserInfo,
                &ClientNetbiosAddress,
                &LogoffTime,
                pExtendedError
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_WARN,"KLIN(%x) Subuath  restriction check failed: 0x%x\n",
                  KLIN(FILENO,__LINE__), KerbErr));
        goto Cleanup;
    }

    //
    // do not restrict user accounts (user2user) if the first part of server
    // name is "krbtgt"
    //

    bRestrictUserAccounts = LsaINoMoreWin2KDomain()
        && !( (ServerName->NameCount >= 1)
            && RtlEqualUnicodeString(
                &ServerName->Names[0],
                SecData.KdcServiceName(),
                TRUE) );

    //
    // Figure out who the ticket is for. First break the name into
    // a local name and a referral realm
    //

    //
    //  Note:   We don't allow referrals here, because we should only get AS
    //          requests for our realm, and the krbtgt\server should always be
    //          in our realm.

    KerbErr = KdcNormalize(
                ServerName,
                NULL,
                NULL,                   // don't use requested realm for the server - use our realm
                NULL,                   
                NameFlags | KDC_NAME_SERVER,
                bRestrictUserAccounts,     // restrict user accounts (user2user)
                &ServerReferral,
                &ServerRealm,
                &ServiceTicketInfo,
                pExtendedError,
                NULL,                      // no user handle
                0L,                        // no additional fields to fetch
                bRestrictUserAccounts ? USER_EXTENDED_FIELD_SPN : 0,   // no extended fields
                NULL,                      // no user all
                NULL                       // no membership
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR, "I_GetASTicket KLIN(%x) failed to normalize name %#x: ", KLIN(FILENO, __LINE__), KerbErr ));
        KerbPrintKdcName(DEB_ERROR, ServerName);
        goto Cleanup;
    }

    //
    // find supported etype for session keys
    //

    KerbErr = KerbFindCommonCryptSystemForSKey(
                RequestBody->encryption_type,
                ServiceTicketInfo.UserAccountControl & USER_USE_DES_KEY_ONLY ?
                    kdc_pMitPrincipalPreferredCryptList : kdc_pPreferredCryptList,
                &CommonEType
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        if (KDC_ERR_ETYPE_NOTSUPP == KerbErr)
        {    
            KdcReportKeyError(
                ClientStringName,
                ServerStringName,
                KDC_KEY_ID_AS_SKEY,
                KDCEVENT_NO_KEY_INTERSECTION_AS,
                RequestBody->encryption_type,
                &ServiceTicketInfo
                );
        }

        DebugLog((DEB_ERROR, "I_GetASTicket KLIN(%x) Failed to find common ETYPE: 0x%x\n",
            KLIN(FILENO, __LINE__), KerbErr));
        goto Cleanup;
    }

    //
    // Find a common crypto system.  Do it now in case we need
    // to return the password for a service.
    //

    if (EncryptionKey.keyvalue.value == NULL)
    {
        KerbErr = KerbFindCommonCryptSystem(
                    RequestBody->encryption_type,
                    ClientTicketInfo.Passwords,
                    NULL,
                    &ClientKey
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            if (KDC_ERR_ETYPE_NOTSUPP == KerbErr)
            { 
                KdcReportKeyError(
                    ClientStringName,
                    ServerStringName,
                    KDC_KEY_ID_AS_KDC_REPLY,
                    KDCEVENT_NO_KEY_INTERSECTION_AS,
                    RequestBody->encryption_type,
                    &ClientTicketInfo
                    );
            }

            DebugLog((DEB_ERROR, "KLIN(%x) Failed to find common ETYPE: 0x%x\n",
                      KLIN(FILENO,__LINE__), KerbErr));
            goto Cleanup;
        }
    }

    //
    // Get the etype to use for the ticket itself from the server's
    // list of keys
    //

    KerbErr = KerbFindCommonCryptSystem(
                ServiceTicketInfo.UserAccountControl & USER_USE_DES_KEY_ONLY ?
                    kdc_pMitPrincipalPreferredCryptList : kdc_pPreferredCryptList,
                ServiceTicketInfo.Passwords,
                NULL,   // no additional passwords
                &ServerKey
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        if (KDC_ERR_ETYPE_NOTSUPP == KerbErr)
        {        
            KdcReportKeyError(
                ClientStringName,
                ServerStringName,
                KDC_KEY_ID_AS_TICKET,
                KDCEVENT_NO_KEY_INTERSECTION_AS,
                ServiceTicketInfo.UserAccountControl & USER_USE_DES_KEY_ONLY ?
                    kdc_pMitPrincipalPreferredCryptList : kdc_pPreferredCryptList,
                &ServiceTicketInfo
                );
        }

        DebugLog((DEB_ERROR, "KLIN(%x) Failed to find common ETYPE: 0x%x\n", KLIN(FILENO, __LINE__), KerbErr));
        goto Cleanup;
    }

    //
    // We need to save the full domain name of the service regardless
    // of whether it was provided or not. This is so name changes
    // can be detected. Instead of creating a mess of trying to figure out
    // which deallocator to use, allocate new memory and copy data.
    //

    AccountExpiry = UserInfo->I1.AccountExpires;

    //
    // Bug 460108: only propagate the addresses if there is an IPv4
    //             address in the list
    //

    if ( KdcUseClientAddresses ) {

        PKERB_HOST_ADDRESSES CurrentAddress = RequestBody->addresses;

        while ( CurrentAddress != NULL ) {

            if ( CurrentAddress->value.address_type == KERB_ADDRTYPE_INET ) {

                EffectiveAddresses = RequestBody->addresses;
                break;
            }

            CurrentAddress = CurrentAddress->next;
        }
    }

    KerbErr = BuildTicketAS(
                &ClientTicketInfo,
                &RequestBody->KERB_KDC_REQUEST_BODY_client_name,
                &ServiceTicketInfo,
                &RequestBody->KERB_KDC_REQUEST_BODY_server_name,
                EffectiveAddresses,
                &LogoffTime,
                &AccountExpiry,
                RequestBody,
                CommonEType,
                PreAuthType,
                &TransitedRealm,
                &Ticket,
                pExtendedError
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        D_DebugLog((DEB_WARN , "KLIN(%x) Failed to build AS ticket: 0x%x\n",
                  KLIN(FILENO,__LINE__), KerbErr));
        goto Cleanup;
    }

    //
    // If the user requested a PAC (via pre-auth data) build one now.
    //

    if (BuildPac)
    {
        //
        // Now build a PAC to stick in the authorization data
        //

        DebugLog((DEB_T_PAC, "I_GetASTicket KLIN(%x) build Pac\n", KLIN(FILENO, __LINE__)));

        KerbErr = KdcGetPacAuthData(
                    UserInfo,
                    &GroupMembership,
                    ServerKey,
                    &EncryptionKey,
                    ((ServiceTicketInfo.UserAccountControl & USER_INTERDOMAIN_TRUST_ACCOUNT) == 0) &&
                        (ServiceTicketInfo.UserId != DOMAIN_USER_RID_KRBTGT),
                        // add resource groups if server is not an interdomain trust account
                    &EncryptedTicket,
                    NULL, // no S4U info here...
                    &PacAuthData,
                    pExtendedError
                    );

        if (!KERB_SUCCESS(KerbErr))
        {
            D_DebugLog((DEB_ERROR, "KLIN(%x) Failed to get pac auth data for %wZ : 0x%x\n",
                      KLIN(FILENO, __LINE__), &ClientTicketInfo.AccountName, KerbErr));
            goto Cleanup;
        }

        //
        // Stick the auth data into the AS ticket
        //

        EncryptedTicket.KERB_ENCRYPTED_TICKET_authorization_data = PacAuthData;
        PacAuthData = NULL;
        EncryptedTicket.bit_mask |= KERB_ENCRYPTED_TICKET_authorization_data_present;
    }

    //
    // Now build the reply
    //

    KerbErr = BuildReply(
                &ClientTicketInfo,
                (Nonce != 0) ? Nonce : RequestBody->nonce,
                &Ticket.server_name,
                Ticket.realm,
                ((RequestBody->bit_mask & addresses_present) != 0) ? RequestBody->addresses : NULL,
                &Ticket,
                &ReplyBody
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    //
    // Now build the real reply and return it.
    //

    Reply.version = KERBEROS_VERSION;
    Reply.message_type = KRB_AS_REP;
    Reply.KERB_KDC_REPLY_preauth_data = NULL;
    Reply.bit_mask = 0;

    Reply.client_realm = EncryptedTicket.client_realm;

    //
    // Build pw-salt if we used a user's key
    //

    if (ClientKey != NULL)
    {
         KerbErr = KdcBuildPwSalt(
            ClientTicketInfo.Passwords,
            ClientKey,
            &OutputPreAuthData
            );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }
    }

    if (OutputPreAuthData != NULL)
    {
        Reply.bit_mask |= KERB_KDC_REPLY_preauth_data_present;
        Reply.KERB_KDC_REPLY_preauth_data = (PKERB_REPLY_PA_DATA_LIST) OutputPreAuthData;

        //
        // Zero this out so we don't free the preauth data twice
        //

        OutputPreAuthData = NULL;
    }

    //
    // Copy in the ticket
    //

    KerbErr = KerbPackTicket(
                &Ticket,
                ServerKey,
                ServiceTicketInfo.PasswordVersion,
                &Reply.ticket
                );
    D_DebugLog((DEB_T_KEY, "I_GetASTicket: KerbPackTicket ServiceKeyVersion 0x%x  CommonEType %#x, KerbErr %#x\n",
                ServiceTicketInfo.PasswordVersion, KerbErr));

    if (!KERB_SUCCESS(KerbErr))
    {
        D_DebugLog((DEB_ERROR, "KLIN(%x) Failed to pack ticket: 0x%x\n", KLIN(FILENO, __LINE__), KerbErr));
        goto Cleanup;
    }

    //
    // Note: these are freed elsewhere, so zero them out after
    // using them
    //

    Reply.client_name = EncryptedTicket.client_name;

    //
    // Copy in the client info & encrypt in client's key (or Encryption key if supplied in pre-auth data)
    //

    KerbErr = KerbPackKdcReplyBody(
                &ReplyBody,
                (EncryptionKey.keyvalue.value != NULL) ? &EncryptionKey : ClientKey,
                (EncryptionKey.keyvalue.value != NULL) ? KERB_NO_KEY_VERSION : ClientTicketInfo.PasswordVersion,
                KERB_TGS_REP_SALT,          // should be KERB_AS_REP_SALT  see raid 502476
                KERB_ENCRYPTED_AS_REPLY_PDU,     // was Pdu,
                &Reply.encrypted_part
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        D_DebugLog((DEB_ERROR, "KLIN(%x) Failed to pack KDC reply body: 0x%x\n", KLIN(FILENO, __LINE__), KerbErr));
        goto Cleanup;
    }

    //
    // Add in PW-SALT if we used a client key
    //

    if (SecData.AuditKdcEvent(KDC_AUDIT_AS_SUCCESS))
    {
        BYTE ClientSid[MAX_SID_LEN];
        BYTE ServerSid[MAX_SID_LEN];

        KdcMakeAccountSid(ClientSid, ClientTicketInfo.UserId);
        KdcMakeAccountSid(ServerSid, ServiceTicketInfo.UserId);

        KdcLsaIAuditAsEvent(
            SE_AUDITID_AS_TICKET,
            &ClientTicketInfo.AccountName,
            RequestRealm,
            ClientSid,
            &ServiceTicketInfo.AccountName,
            ServerSid,
            (PULONG) &KdcOptions,
            NULL,                    // success
            &CommonEType,
            &PreAuthType,
            GET_CLIENT_ADDRESS(ClientAddress),
            &PkiAuditInfo.CertIssuerName,
            &PkiAuditInfo.CertSerialNumber,
            &PkiAuditInfo.CertThumbprint
            );
    }

    //
    // Pack the reply
    //

    KerbErr = KerbPackData(
                &Reply,
                KERB_AS_REPLY_PDU,              // was ReplyPdu,
                &OutputMessage->BufferSize,
                &OutputMessage->Buffer
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

Cleanup:

    if (!KERB_SUCCESS(KerbErr))
    {
        DsysAssert(RequestBody != NULL);

        if (!AuditedFailure && SecData.AuditKdcEvent(KDC_AUDIT_AS_FAILURE))
        {
            if (ClientName != NULL)
            {
                KdcLsaIAuditAsEvent(
                    SE_AUDITID_AS_TICKET,
                    &ClientName->Names[0],
                    RequestRealm,
                    NULL,
                    ServerStringName,
                    NULL,
                    &KdcOptions,
                    (PULONG) &KerbErr,          // failure
                    NULL,                       // no common etype
                    NULL,                       // no preauth type
                    GET_CLIENT_ADDRESS(ClientAddress),
                    &PkiAuditInfo.CertIssuerName,
                    &PkiAuditInfo.CertSerialNumber,
                    &PkiAuditInfo.CertThumbprint   
                    );
            }
        }

        //
        // If there was any preath data to return, pack it for return now.
        //

        if (OutputPreAuthData != NULL)
        {
            if (ErrorData->Buffer != NULL)
            {
                D_DebugLog((DEB_ERROR,
                          "KLIN(%x) Freeing return error data to return preauth data\n",
                          KLIN(FILENO,__LINE__)));
                MIDL_user_free(ErrorData->Buffer);
                ErrorData->Buffer = NULL;
                ErrorData->BufferSize = 0;
            }

            (VOID) KerbPackData(
                    &OutputPreAuthData,
                    PKERB_PREAUTH_DATA_LIST_PDU,
                    &ErrorData->BufferSize,
                    &ErrorData->Buffer
                    );
        }
    }

    if (UserHandle != NULL)
    {
        if (!KERB_SUCCESS(KerbErr))
        {
            if (!LoggedFailure && ClientInfoPresent)
            {
                BYTE ClientSid[MAX_SID_LEN];

                RtlZeroMemory(ClientSid, MAX_SID_LEN);
                KdcMakeAccountSid(ClientSid, ClientTicketInfo.UserId);

                D_DebugLog((DEB_WARN , "KLIN(%x) Calling Failedlogon: LogonStatus: 0x%x KRB: 0x%x\n",
                          KLIN(FILENO,__LINE__), LogonStatus, KerbErr));
                FailedLogon(
                        UserHandle,
                        ClientAddress,
                        &RequestBody->KERB_KDC_REQUEST_BODY_client_name,
                        ClientSid,
                        MAX_SID_LEN,
                        &ClientTicketInfo,
                        InputMessage,
                        OutputMessage,
                        &ClientNetbiosAddress,
                        KerbErr,
                        LogonStatus,
                        UsedOldPassword
                        );
            }
        }
        else
        {
            BYTE ClientSid[MAX_SID_LEN];

            RtlZeroMemory(ClientSid, MAX_SID_LEN);
            KdcMakeAccountSid(ClientSid, ClientTicketInfo.UserId);

            D_DebugLog((DEB_TRACE, "I_GetASTicket calling SuccessfulLogon\n"));
            SuccessfulLogon(
                UserHandle,
                ClientAddress,
                ClientSid,
                MAX_SID_LEN,
                InputMessage,
                &ClientNetbiosAddress,
                UserInfo
                );
        }
        SamrCloseHandle(&UserHandle);
    }

    //
    // Complete the WMI event
    //

    if (KdcEventTraceFlag)
    {

        //These variables point to either a unicode string struct containing
        //the corresponding string or a pointer to KdcNullString

        PUNICODE_STRING pStringToCopy;
        WCHAR   UnicodeNullChar = 0;
        UNICODE_STRING UnicodeEmptyString = {sizeof(WCHAR),sizeof(WCHAR),&UnicodeNullChar};

        ASEventTraceInfo.EventTrace.Class.Type = EVENT_TRACE_TYPE_END;
        ASEventTraceInfo.EventTrace.Flags = WNODE_FLAG_USE_MOF_PTR |
                                            WNODE_FLAG_TRACED_GUID;

        // Always output error code.  KdcOptions was captured on the start event

        ASEventTraceInfo.eventInfo[0].DataPtr = (ULONGLONG) &KerbErr;
        ASEventTraceInfo.eventInfo[0].Length  = sizeof(ULONG);
        ASEventTraceInfo.EventTrace.Size =
            sizeof (EVENT_TRACE_HEADER) + sizeof(MOF_FIELD);

        // Build counted MOF strings from the unicode strings

        if (ClientStringName->Buffer != NULL &&
            ClientStringName->Length > 0)
        {
            pStringToCopy = ClientStringName;
        }
        else {
            pStringToCopy = &UnicodeEmptyString;
        }

        ASEventTraceInfo.eventInfo[1].DataPtr =
            (ULONGLONG) &pStringToCopy->Length;
        ASEventTraceInfo.eventInfo[1].Length  =
            sizeof(pStringToCopy->Length);
        ASEventTraceInfo.eventInfo[2].DataPtr =
            (ULONGLONG) pStringToCopy->Buffer;
        ASEventTraceInfo.eventInfo[2].Length =
            pStringToCopy->Length;
        ASEventTraceInfo.EventTrace.Size += sizeof(MOF_FIELD)*2;


        if (ServerStringName->Buffer != NULL &&
            ServerStringName->Length > 0)
        {
            pStringToCopy = ServerStringName;
        }
        else
        {
            pStringToCopy = &UnicodeEmptyString;
        }


        ASEventTraceInfo.eventInfo[3].DataPtr =
            (ULONGLONG) &pStringToCopy->Length;
        ASEventTraceInfo.eventInfo[3].Length  =
            sizeof(pStringToCopy->Length);
        ASEventTraceInfo.eventInfo[4].DataPtr =
            (ULONGLONG) pStringToCopy->Buffer;
        ASEventTraceInfo.eventInfo[4].Length =
            pStringToCopy->Length;
        ASEventTraceInfo.EventTrace.Size += sizeof(MOF_FIELD)*2;


        if (RequestRealm->Buffer != NULL &&
            RequestRealm->Length > 0)
        {
            pStringToCopy = RequestRealm;
        }
        else
        {
            pStringToCopy = &UnicodeEmptyString;
        }

        ASEventTraceInfo.eventInfo[5].DataPtr =
            (ULONGLONG) &(pStringToCopy->Length);
        ASEventTraceInfo.eventInfo[5].Length  =
            sizeof(pStringToCopy->Length);
        ASEventTraceInfo.eventInfo[6].DataPtr =
            (ULONGLONG) (pStringToCopy->Buffer);
        ASEventTraceInfo.eventInfo[6].Length =
            (pStringToCopy->Length);
        ASEventTraceInfo.EventTrace.Size += sizeof(MOF_FIELD)*2;


        TraceEvent(
            KdcTraceLoggerHandle,
            (PEVENT_TRACE_HEADER)&ASEventTraceInfo
            );
    }

    SamIFree_UserInternal6Information( UserInfo );
    SamIFreeSidAndAttributesList( &GroupMembership );
    KerbFreeAuthData( PacAuthData );
    FreeTicketInfo( &ClientTicketInfo );
    FreeTicketInfo( &ServiceTicketInfo );
    KdcFreePkiAuditInfo( &PkiAuditInfo );
    KdcFreeInternalTicket( &Ticket );
    KerbFreeKey( &EncryptionKey );
    KerbFreeKdcName( &ClientName );
    KerbFreeString( &TransitedRealm );
    KerbFreeString( &ServerRealm );
    KerbFreeKdcName( &ServerName );
    KerbFreeString( &ClientNetbiosAddress );
    KdcFreeKdcReplyBody( &ReplyBody );
    KdcFreeKdcReply( &Reply );
    KerbFreePreAuthData( OutputPreAuthData );

    D_DebugLog((DEB_T_PAPI, "I_GetASTicket returning %#x\n", KerbErr));

    return KerbErr;
}

//+-------------------------------------------------------------------------
//
//  Function:   KdcGetTicket
//
//  Synopsis:   Generic ticket getting entrypoint to get a ticket from the KDC
//
//  Effects:
//
//  Arguments:  Context - ATQ context - only present for TCP/IP callers
//              ClientAddress - Client's IP addresses. Only present for UDP & TPC callers
//              ServerAddress - address the client used to contact this KDC.
//                      Only present for UDP & TPC callers
//              InputMessage - the input KDC request message, in ASN.1 format
//              OutputMessage - Receives the KDC reply message, allocated by
//                  the KDC.
//
//  Requires:
//
//  Returns:
//
//  Notes:      This routine is exported from the DLL and called from the
//              client dll.
//
//
//--------------------------------------------------------------------------

extern "C"
KERBERR
KdcGetTicket(
    IN OPTIONAL PVOID Context,
    IN OPTIONAL PSOCKADDR ClientAddress,
    IN OPTIONAL PSOCKADDR ServerAddress,
    IN PKERB_MESSAGE_BUFFER InputMessage,
    OUT PKERB_MESSAGE_BUFFER OutputMessage
    )
{
    KERBERR KerbErr;
    KERB_EXT_ERROR  ExtendedError = {0,0};
    PKERB_EXT_ERROR pExtendedError = &ExtendedError; // needed for macro
    PKERB_KDC_REQUEST RequestMessage = NULL;
    KERB_KDC_REPLY ReplyMessage = {0};
    KERB_MESSAGE_BUFFER ErrorData = {0};
    ULONG InputPdu = KERB_TGS_REQUEST_PDU;
    UNICODE_STRING RequestRealm = {0};
    PKERB_INTERNAL_NAME RequestServer = NULL;
    UNICODE_STRING ClientRealm = {0};
    PUNICODE_STRING ExtendedErrorServerRealm = SecData.KdcDnsRealmName();
    PKERB_INTERNAL_NAME ExtendedErrorServerName = SecData.KdcInternalName();
    TYPED_DATA_Element* TypedDataList = NULL;
    KERB_MESSAGE_BUFFER PreApendedErrorData = {0};
    KERB_MESSAGE_BUFFER* ErrorDataToUse = NULL;
    UNICODE_STRING ClientStringName = {0};
    UNICODE_STRING ServerStringName = {0};

#if DBG
    DWORD StartTime = 0;
#endif

    TRACE(KDC, KdcGetTicket, DEB_FUNCTION );

    //
    // Make sure we are allowed to execute
    //

    if (!NT_SUCCESS(EnterApiCall()))
    {
        return(KDC_ERR_NOT_RUNNING);
    }

    RtlZeroMemory(
        &ReplyMessage,
        sizeof(KERB_KDC_REPLY)
        );

    //
    // First initialize the return parameters.
    //

    OutputMessage->Buffer = NULL;
    OutputMessage->BufferSize = 0;

    //
    // Check the first byte of the message to indicate the type of message
    //

    if ((InputMessage->BufferSize > 0) && (
        (InputMessage->Buffer[0] & KERB_BER_APPLICATION_TAG) != 0))
    {
        if ((InputMessage->Buffer[0] & KERB_BER_APPLICATION_MASK) == KERB_AS_REQ_TAG)
        {
            InputPdu = KERB_AS_REQUEST_PDU;
        }
        else if ((InputMessage->Buffer[0] & KERB_BER_APPLICATION_MASK) != KERB_TGS_REQ_TAG)
        {
            D_DebugLog((DEB_T_SOCK,
                      "KLIN(%x) Bad message sent to KDC - not AS or TGS request\n",
                      KLIN(FILENO,__LINE__)));

            KerbErr = KRB_ERR_FIELD_TOOLONG;
            goto NoMsgCleanup;
        }
    }
    else
    {
        D_DebugLog((DEB_T_SOCK,"KLIN(%x) Bad message sent to KDC - length to short or bad first byte\n",
                  KLIN(FILENO,__LINE__)));
        KerbErr = KRB_ERR_FIELD_TOOLONG;
        goto NoMsgCleanup;

    }

    //
    // First decode the input message
    //

    KerbErr = (KERBERR) KerbUnpackData(
                            InputMessage->Buffer,
                            InputMessage->BufferSize,
                            InputPdu,
                            (PVOID *) &RequestMessage
                            );

    if (KerbErr == KDC_ERR_MORE_DATA)
    {
        KerbErr = KRB_ERR_FIELD_TOOLONG;
        goto Cleanup;
    }

    if (!KERB_SUCCESS(KerbErr))
    {
        D_DebugLog((DEB_ERROR,"KLIN(%x) Failed to unpack KDC request: 0x%x\n",
                  KLIN(FILENO,__LINE__),KerbErr));

        //
        // We don't want to return an error on a badly formed
        // packet,as it can be used to set up a flood attack
        //

        goto NoMsgCleanup;
    }

    //
    // First check the version of the request.
    //

    if (RequestMessage->version != KERBEROS_VERSION)
    {
        D_DebugLog((DEB_ERROR,"KLIN(%x) Bad request version: 0x%x\n",
                  KLIN(FILENO,__LINE__), RequestMessage->version));
        KerbErr = KRB_AP_ERR_BADVERSION;
        goto Cleanup;
    }

    //
    // now call the internal version to do all the hard work
    //

    //
    // Verify the realm name in the request
    //

    KerbErr = KerbConvertRealmToUnicodeString(
                &RequestRealm,
                &RequestMessage->request_body.realm
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    KerbErr = KerbConvertPrincipalNameToKdcName(
                &RequestServer,
                &RequestMessage->request_body.server_name
                );

    if ( !KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    //
    // Now that we have the request realm and request server, any subsequent
    // error will result in those values being placed into the extended error
    //

    ExtendedErrorServerRealm = &RequestRealm;
    ExtendedErrorServerName = RequestServer;

    if (!SecData.IsOurRealm(
            &RequestRealm
            ))
    {
        D_DebugLog((DEB_ERROR,"KLIN(%x) Request sent for wrong realm: %wZ\n",
                  KLIN(FILENO,__LINE__), &RequestRealm));

        KerbErr = KDC_ERR_WRONG_REALM;
        goto Cleanup;
    }

    if (RequestMessage->message_type == KRB_AS_REQ)
    {
        if (InputPdu != KERB_AS_REQUEST_PDU) {
            KerbErr = KRB_ERR_FIELD_TOOLONG;
            FILL_EXT_ERROR(pExtendedError, STATUS_KDC_INVALID_REQUEST,FILENO,__LINE__);
            goto Cleanup;
        }

        SamIIncrementPerformanceCounter(
            KdcAsReqCounter
            );

        //
        // If WMI event tracing is enabled, notify it of the begin and end
        // of the ticket request
        //

#if DBG
        StartTime = GetTickCount();
#endif

        KerbErr = I_GetASTicket(
                    ClientAddress,
                    RequestMessage,
                    &RequestRealm,
                    InputMessage,
                    OutputMessage,
                    &ErrorData,
                    &ExtendedError,
                    &ClientRealm,
                    &ClientStringName,
                    &ServerStringName
                    );
#if DBG
        D_DebugLog((DEB_T_PERF_STATS, "I_GetASTicket took %d m seconds\n", NetpDcElapsedTime(StartTime)));
#endif

    }
    else if (RequestMessage->message_type == KRB_TGS_REQ)
    {

        SamIIncrementPerformanceCounter(
            KdcTgsReqCounter
            );

#if DBG
        StartTime = GetTickCount();
#endif

        KerbErr = HandleTGSRequest(
                    ClientAddress,
                    RequestMessage,
                    &RequestRealm,
                    OutputMessage,
                    &ExtendedError,
                    &ClientStringName,
                    &ServerStringName
                    );
#if DBG
        D_DebugLog((DEB_T_PERF_STATS, "HandleTGSRequest took %d m seconds\n", NetpDcElapsedTime(StartTime)));
#endif
    }
    else
    {
        D_DebugLog((DEB_ERROR,"KLIN(%x) Invalid message type: %d\n",
                  KLIN(FILENO,__LINE__),
                  RequestMessage->message_type));
        FILL_EXT_ERROR(pExtendedError, STATUS_KDC_INVALID_REQUEST,FILENO,__LINE__);
        KerbErr = KRB_AP_ERR_MSG_TYPE;
        goto Cleanup;
    }


    //
    // If the response is too big and we are using UDP, make the client
    // change transports. We can tell the caller is UDP because it doesn't
    // have an ATQ context but it does provide the client address.
    //
    if ((Context == NULL) && (ClientAddress != NULL))
    {
        if (OutputMessage->BufferSize >= KdcGlobalMaxDatagramReplySize)
        {
            LARGE_INTEGER CurrentTime;
            D_DebugLog((DEB_WARN,"KLIN(%x) KDC response too big for UDP datagram (max size %d): %d bytes in message\n",
                      KLIN(FILENO,__LINE__), KdcGlobalMaxDatagramReplySize, OutputMessage->BufferSize ));

            KerbErr = KRB_ERR_RESPONSE_TOO_BIG;
            MIDL_user_free(OutputMessage->Buffer);
            OutputMessage->Buffer = NULL;
            OutputMessage->BufferSize = 0;

            // purge the replay detection entry, otherwise when the client
            // retries with TCP we will fail because of replay detection

            GetSystemTimeAsFileTime((PFILETIME)&CurrentTime);

            ReplayDetect->Check(
                            InputMessage->Buffer,
                            InputMessage->BufferSize,
                            NULL,
                            0,
                            &CurrentTime,
                            FALSE,              // insert
                            TRUE,               // purge
                            TRUE );             // check replay cache

            DebugLog((DEB_WARN, "Purged replay detection cache entry for UDP failover to TCP\n" ));

            // we don't need to check if that failed (e.g. if the entry
            // didn't exist)
        }
    }

Cleanup:
    
    

    // TBD:  Put in extended error return goo here for client

    if (!KERB_SUCCESS(KerbErr) && (KDC_ERR_NO_RESPONSE != KerbErr))
    {
        //
        // We may have a message built by someone else - the PDC
        //

        if (OutputMessage->Buffer == NULL)
        {
            //
            // map KDC_ERR_MUST_USE_USER2USER to KDC_ERR_S_PRINCIPAL_UNKNOWN so
            // down-level clients won't chuck
            //

            if (KDC_ERR_MUST_USE_USER2USER == KerbErr)
            {
                KERB_TYPED_DATA Data = {0};

                DebugLog((DEB_T_U2U, "KLIN(%x) mapping KDC_ERR_MUST_USE_USER2USER to KDC_ERR_S_PRINCIPAL_UNKNOWN, ErrorData.Buffer %p\n",
                    KLIN(FILENO, __LINE__), ErrorData.Buffer));

                Data.data_type = TD_MUST_USE_USER2USER;

                if (ErrorData.Buffer && ErrorData.BufferSize)
                {
                    DebugLog((DEB_WARN, "KLIN(%x) KdcGetTicket received non-empty error data\n",
                        KLIN(FILENO, __LINE__)));

                    KerbErr = KerbUnpackData(
                        ErrorData.Buffer,
                        ErrorData.BufferSize,
                        TYPED_DATA_PDU,
                        (PVOID*)&TypedDataList
                        );
                    if (!KERB_SUCCESS(KerbErr))
                    {
                        DebugLog((DEB_ERROR, "KLIN(%x) KdcGetTicket failed to unpack typed data %#x\n",
                            KLIN(FILENO, __LINE__), KerbErr));
                        goto NoMsgCleanup;
                    }
                }

                KerbErr = TypedDataListPushFront(
                    TypedDataList,
                    &Data,
                    &PreApendedErrorData.BufferSize,
                    &PreApendedErrorData.Buffer
                    );

                if (!KERB_SUCCESS(KerbErr))
                {
                    DebugLog((DEB_ERROR, "KLIN(%x) KdcGetTicket failed to pushfront typed data %#x\n",
                        KLIN(FILENO, __LINE__), KerbErr));
                    goto NoMsgCleanup;
                }

                ErrorDataToUse = &PreApendedErrorData;
                KerbErr = KDC_ERR_S_PRINCIPAL_UNKNOWN;

                //
                // now report an event
                //

                KdcReportPolicyErrorEvent(
                    EVENTLOG_INFORMATION_TYPE,
                    KDCEVENT_POLICY_USER2USER_REQUIRED,
                    &ClientStringName,
                    &ServerStringName,
                    STATUS_USER2USER_REQUIRED,
                    0, //  raw data size
                    NULL // no raw data
                    );
            }
            else if ((ErrorData.Buffer == NULL)
                && !EXT_ERROR_SUCCESS((ExtendedError))) // if ((ErrorData.Buffer == NULL) && (KDC_ERR_PREAUTH_FAILED == KerbErr) && (EXT_CLIENT_INFO_PRESENT((&ExtendedError))))
            {
                KERB_ERROR_METHOD_DATA ErrorMethodData = {0};
                KERBERR KerbErrSaved = KerbErr;

                ErrorMethodData.data_type = KERB_ERR_TYPE_EXTENDED;
                ErrorMethodData.bit_mask |= data_value_present;
                ErrorMethodData.data_value.value = (PBYTE) &ExtendedError;
                ErrorMethodData.data_value.length = sizeof(KERB_EXT_ERROR);

                KerbErr = KerbPackData(
                    &ErrorMethodData,
                    KERB_ERROR_METHOD_DATA_PDU,
                    &ErrorData.BufferSize,
                    &ErrorData.Buffer
                    );
                if (!KERB_SUCCESS(KerbErr))
                {
                    DebugLog((DEB_ERROR, "KLIN(%x) KdcGetTicket failed to pack error data %#x\n",
                        KLIN(FILENO, __LINE__), KerbErr));
                    goto NoMsgCleanup;
                }
                ErrorDataToUse = &ErrorData;
                KerbErr = KerbErrSaved;
            }
            else
            {
                ErrorDataToUse = &ErrorData;
            }

            KerbBuildErrorMessageEx(
                KerbErr,
                &ExtendedError,
                ExtendedErrorServerRealm,
                ExtendedErrorServerName,
                &ClientRealm,
                ErrorDataToUse->Buffer,
                ErrorDataToUse->BufferSize,
                &OutputMessage->BufferSize,
                &OutputMessage->Buffer
                );
        }
   }

NoMsgCleanup:
    
    KerbFreeString(&ClientRealm);
    KerbFreeString(&RequestRealm);
    KerbFreeString(&ClientStringName);
    KerbFreeString(&ServerStringName);
    MIDL_user_free(RequestServer);

    if (RequestMessage != NULL)
    {
        KerbFreeData(InputPdu, RequestMessage);
    }

    if (ErrorData.Buffer != NULL)
    {
        MIDL_user_free(ErrorData.Buffer);
    }

    if (PreApendedErrorData.Buffer != NULL)
    {
        MIDL_user_free(PreApendedErrorData.Buffer);
    }

    if (TypedDataList)
    {
        KerbFreeData(TYPED_DATA_PDU, TypedDataList);
    }


    LeaveApiCall();

    return(KerbErr);
}

// Routines to handle the Negative Cache to PDC from BDC

//  Initialization routines - must be called in single threaded mode and only once
NTSTATUS
AsNegCacheInit()
{
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Initialize the Credential list to be empty.
    //

    if (g_fApNegCacheInitialized == TRUE)
    {
        goto CleanUp;   // already initialized
    }

    Status = RtlInitializeCriticalSection(&l_ApNegCacheCritSect);
    if (!NT_SUCCESS(Status))
    {
        goto CleanUp;
    }

    InitializeListHead( &l_ApNegCacheList );

    // Simple variable test to make sure all initialized;
    g_fApNegCacheInitialized = TRUE;

CleanUp:

    return Status;
}

// This function will check if we should send the failed auth request to the PDC
// The return value only indicates if the function worked properly.  The result of the function is
// is kept in pfAvoidSendToPDC (if True then do not send requst to PDC)
NTSTATUS
AsNegCacheCheck(
    IN PVOID Buffer,
    IN ULONG BufferLength,
    IN OPTIONAL PVOID OptionalBuffer,
    IN OPTIONAL ULONG OptionalBufferLength,
    OUT PBOOLEAN pfAvoidSendToPDC)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PLIST_ENTRY ListEntry = NULL;
    PNEGATIVE_CACHE pApNegEntry = NULL;
    MD5_CTX Md5Context;
    LARGE_INTEGER CurrentTime;
    LARGE_INTEGER Time5Minutes;

    ASSERT(pfAvoidSendToPDC);

    if (g_fApNegCacheInitialized == FALSE)
    {
        return STATUS_APP_INIT_FAILURE;
    }

    GetSystemTimeAsFileTime((PFILETIME)&CurrentTime);
    *pfAvoidSendToPDC = FALSE;

    Time5Minutes.QuadPart = (LONGLONG)KERB_5_MINUTES_100NANO;

    // Compute the md5 signature of the request
    MD5Init(
        &Md5Context
        );

    MD5Update(
        &Md5Context,
        (PBYTE) Buffer,
        BufferLength
        );
    if ((OptionalBuffer != NULL) && (OptionalBufferLength != 0))
    {
        MD5Update(
            &Md5Context,
            (PBYTE) OptionalBuffer,
            OptionalBufferLength
            );
    }
    MD5Final(
        &Md5Context
        );

    //
    // Acquire exclusive access to the Credential list
    //

    RtlEnterCriticalSection( &l_ApNegCacheCritSect );

    //
    // Now walk the list of Credentials looking for a match.
    //

    for ( ListEntry = l_ApNegCacheList.Flink;
        ListEntry != &l_ApNegCacheList;
        ListEntry = ListEntry->Flink )
    {

        pApNegEntry = CONTAINING_RECORD( ListEntry, NEGATIVE_CACHE, Next );

        // Check if the md5 signature matches
        // if this entry is for this user's request (on the workstation), check if it's time to forward
        // this logon to the PDC. In any case, remove this entry from the list and then insert it at the
        // front so that the list stays sorted by the entry access time.
        if (RtlEqualMemory(Md5Context.digest, pApNegEntry->digest, MD5DIGESTLEN))
        {
            if ((pApNegEntry->lBadLogonCount > KERB_AP_NEGATIVE_MAX_LOGON_COUNT) &&
                (CurrentTime.QuadPart < (pApNegEntry->TimeLastPDCContact.QuadPart + Time5Minutes.QuadPart)))
            {
                *pfAvoidSendToPDC = TRUE;
                DebugLog((DEB_TRACE , "getas:AsNegCacheCheck(%d) no send to PDC:  Entry 0x%x\n", __LINE__, Md5Context.digest));
            }

            RemoveEntryList(&(pApNegEntry->Next));
            break;
        }
        pApNegEntry = NULL;
    }

    if (pApNegEntry)
    {
        InsertHeadList(&l_ApNegCacheList, &(pApNegEntry->Next));
    }

    RtlLeaveCriticalSection( &l_ApNegCacheCritSect );

    return Status;
}


// This function will update an entry (or create a new one) in the negative cache
// Update the list of forwarded failed user logons
//
// If the lockout policy is enabled we should continue
//  to forward logons to PDC (i.e. we should not cache
//  this failure) to keep the right lockout count until
//  the account becomes locked on the PDC.
//
NTSTATUS
AsNegCacheUpdate(
    IN PVOID Buffer,
    IN ULONG BufferLength,
    IN OPTIONAL PVOID OptionalBuffer,
    IN OPTIONAL ULONG OptionalBufferLength,
    IN NTSTATUS StatusPdcAuth)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PLIST_ENTRY ListEntry = NULL;
    PNEGATIVE_CACHE pApNegEntry = NULL;
    MD5_CTX Md5Context;
    ULONG FailedUserCount = 0;

    if (g_fApNegCacheInitialized == FALSE)
    {
        return STATUS_APP_INIT_FAILURE;
    }

    // Compute the md5 signature of the request
    MD5Init(
        &Md5Context
        );

    MD5Update(
        &Md5Context,
        (PBYTE) Buffer,
        BufferLength
        );
    if ((OptionalBuffer != NULL) && (OptionalBufferLength != 0))
    {
        MD5Update(
            &Md5Context,
            (PBYTE) OptionalBuffer,
            OptionalBufferLength
            );
    }
    MD5Final(
        &Md5Context
        );

    //
    // Acquire exclusive access to the Credential list
    //

    RtlEnterCriticalSection( &l_ApNegCacheCritSect );

    //
    // Now walk the list of Credentials looking for a match.
    //

    for ( ListEntry = l_ApNegCacheList.Flink;
        ListEntry != &l_ApNegCacheList;
        ListEntry = ListEntry->Flink )
    {

        pApNegEntry = CONTAINING_RECORD( ListEntry, NEGATIVE_CACHE, Next );

        // Check if the md5 signature matches
        // if this entry is for this user's request (on the workstation), remove it from the list.
        // If it stays on the list, we will re-insert it at the front so that the list
        // stays sorted by the entry access time.
        if (RtlEqualMemory(Md5Context.digest, pApNegEntry->digest, MD5DIGESTLEN))
        {
            RemoveEntryList(&(pApNegEntry->Next));
            break;
        }
        pApNegEntry = NULL;
        FailedUserCount++;
    }

    // Process if PDC auth called failed
    if (!(NT_SUCCESS(StatusPdcAuth)))
    {
        // If there is no entry for this user, allocate one
        if (pApNegEntry == NULL)
        {
            pApNegEntry = (PNEGATIVE_CACHE) MIDL_user_allocate(sizeof(NEGATIVE_CACHE));
            if (pApNegEntry == NULL)
            {
                Status = STATUS_NO_MEMORY;
                goto CleanUp;
            }

            // Fill in data structure

            RtlCopyMemory(
                pApNegEntry->digest,
                Md5Context.digest,
                MD5DIGESTLEN
                );

            pApNegEntry->lBadLogonCount = 0;

            D_DebugLog((DEB_TRACE , "getas:AsNegCacheUpdate(%d) new cache:  Entry 0x%x\n", __LINE__, Md5Context.digest));

            // If we have too many entries, remove the least recently used one and free it
            if (FailedUserCount > KERB_MAX_FAILED_LIST_ENTRIES)
            {
                PLIST_ENTRY LastEntry = RemoveTailList(&l_ApNegCacheList);
                PNEGATIVE_CACHE pLastApNegEntry = CONTAINING_RECORD( LastEntry, NEGATIVE_CACHE, Next );
                if (pLastApNegEntry)
                {
                    MIDL_user_free(pLastApNegEntry);
                }
            }
        }

        // Update the last time we contacted the PDC
        GetSystemTimeAsFileTime((PFILETIME)&(pApNegEntry->TimeLastPDCContact));

        pApNegEntry->lBadLogonCount++;

        D_DebugLog((DEB_TRACE , "getas:AsNegCacheUpdate(%d) increment:  Entry 0x%x   Count %d\n",
                   __LINE__, Md5Context.digest, pApNegEntry->lBadLogonCount));

        // Place it back to the front of the list
        InsertHeadList(&l_ApNegCacheList, &(pApNegEntry->Next));
    }
    else
    {
        // we succeeded at the PDC so free unlinked neg cache entry if found
        if (pApNegEntry)
        {
            D_DebugLog((DEB_TRACE , "getas:AsNegCacheUpdate(%d) succeeded at PDC so remove:  Entry 0x%x\n", __LINE__, Md5Context.digest));
            MIDL_user_free(pApNegEntry);
        }
    }

CleanUp:

    RtlLeaveCriticalSection( &l_ApNegCacheCritSect );

    return Status;
}


// This function will remove an entry from the Negative Cache

NTSTATUS
AsNegCacheDelete(
    IN PVOID Buffer,
    IN ULONG BufferLength,
    IN OPTIONAL PVOID OptionalBuffer,
    IN OPTIONAL ULONG OptionalBufferLength)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PLIST_ENTRY ListEntry = NULL;
    PNEGATIVE_CACHE pApNegEntry = NULL;
    MD5_CTX Md5Context;

    if (g_fApNegCacheInitialized == FALSE)
    {
        return STATUS_APP_INIT_FAILURE;
    }

    // Compute the md5 signature of the request
    MD5Init(
        &Md5Context
        );

    MD5Update(
        &Md5Context,
        (PBYTE) Buffer,
        BufferLength
        );
    if ((OptionalBuffer != NULL) && (OptionalBufferLength != 0))
    {
        MD5Update(
            &Md5Context,
            (PBYTE) OptionalBuffer,
            OptionalBufferLength
            );
    }
    MD5Final(
        &Md5Context
        );

    //
    // Acquire exclusive access to the Credential list
    //

    RtlEnterCriticalSection( &l_ApNegCacheCritSect );

    //
    // Now walk the list of Credentials looking for a match.
    //

    for ( ListEntry = l_ApNegCacheList.Flink;
        ListEntry != &l_ApNegCacheList;
        ListEntry = ListEntry->Flink )
    {

        pApNegEntry = CONTAINING_RECORD( ListEntry, NEGATIVE_CACHE, Next );

        // Check if the md5 signature matches
        // if this entry is for this user's request (on the workstation), remove this entry from the list.
        if (RtlEqualMemory(Md5Context.digest, pApNegEntry->digest, MD5DIGESTLEN))
        {
            D_DebugLog((DEB_TRACE , "getas:AsNegCacheDelete(%d) remove cache:  Entry 0x%x\n", __LINE__, Md5Context.digest));
            RemoveEntryList(&(pApNegEntry->Next));
            break;
        }
        pApNegEntry = NULL;
    }

    if (pApNegEntry)
    {
        MIDL_user_free(pApNegEntry);
    }

    RtlLeaveCriticalSection( &l_ApNegCacheCritSect );

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\server\debug.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       debug.cxx
//
//  Contents:   Debug definitions that shouldn't be necessary
//              in the retail build.
//
//  History:    19-Nov-92 WadeR     Created
//
//  Notes:      If you change or add a debug level, also fix debug.hxx
//              This is only compiled if DBG > 0
//
//--------------------------------------------------------------------------


#include "kdcsvr.hxx"
#include <kdcdbg.h>
#include "debug.hxx"

//
// The "#pragma hdrstop" causes the preprocessor to forget any "#if"s
// is is processing.  Therefore you can't have it inside an "#if" block.
// So the includes will always compile, and the rest of this code becomes
// conditional.
//


#include <stddef.h>

#ifdef RETAIL_LOG_SUPPORT

//
// Variables for heap checking and used by sectrace.hxx:
//

// Set following to HEAP_CHECK_ON_ENTER | HEAP_CHECK_ON_EXIT for heap checking.
DWORD dwHeapChecking = 0;

// This keeps a registry key handle to the HKLM\System\CCSet\Control\LSA\
// Kerberoskey
HKEY hKerbParams = NULL;
HANDLE hKerbWait = NULL;

//
// Tons and tons of global data to get debugging params from the ini file.
//
// Note: For every trace bit, there must be a label in this array matching
//       that trace bit and only that trace bit.  There can be other labels
//       matching combinations of trace bits.
//

DEBUG_KEY   KdcDebugKeys[] = {  {DEB_ERROR,     "Error"},
                                {DEB_WARN,      "Warning"},
                                {DEB_TRACE,     "Trace"},
                                {DEB_T_KDC,     "Kdc"},
                                {DEB_T_TICKETS, "Tickets"},
                                {DEB_T_DOMAIN,  "Domain"},
                                {DEB_T_SOCK,    "Sock"},
                                {DEB_T_TIME,    "Time"},
                                {DEB_T_TRANSIT, "Transit"},
                                {DEB_T_PERF_STATS, "Perf"},
                                {DEB_T_PKI, "PKI"},
                                {DEB_T_PAPI, "PAPI"},
                                {DEB_T_U2U, "U2U"},
                                {DEB_T_PAC, "PAC"},
                                {DEB_T_KEY, "KEY"},
                                {DEB_T_S4U, "S4U"},
                                {0, NULL},
                            };



DEFINE_DEBUG2(KDC);        
 
VOID
FillExtendedError(
    IN NTSTATUS NtStatus,
    IN ULONG Flags,
    IN ULONG FileNum,
    IN ULONG LineNum,
    OUT PKERB_EXT_ERROR ExtendedError
    )
{
    ExtendedError->status = NtStatus;
    ExtendedError->klininfo = EXT_ERROR_ON(KDCInfoLevel) ? KLIN(FileNum, LineNum) : 0;
    ExtendedError->flags = Flags;
}




////////////////////////////////////////////////////////////////////
//
//  Name:       GetDebugParams
//
//  Synopsis:   Gets the debug paramaters from the ini file.
//
//  Arguments:  <none>
//
//  Notes:      .
//
void
GetDebugParams()
{
    KDCInitDebug(KdcDebugKeys);
}






#if DBG // moved here to utilize debug logging in free builds.


NTSTATUS
KDC_GetState(   handle_t    hBinding,
                DWORD *     KDCFlags,
                DWORD *     MaxLifespan,
                DWORD *     MaxRenewSpan,
                PTimeStamp  FudgeFactor)
{
    *FudgeFactor = SkewTime;

    TimeStamp tsLife, tsRenew;

    NTSTATUS hr = SecData.DebugGetState(KDCFlags, &tsLife, &tsRenew );
    tsLife.QuadPart = (tsLife.QuadPart / ulTsPerSecond);
    *MaxLifespan =tsLife.LowPart;
    tsRenew.QuadPart = (tsRenew.QuadPart / ulTsPerSecond);
    *MaxRenewSpan = tsRenew.LowPart;
    return(hr);
}

NTSTATUS
KDC_SetState(   handle_t    hBinding,
                DWORD       KdcFlags,
                DWORD       MaxLifespan,
                DWORD       MaxRenewSpan,
                TimeStamp  FudgeFactor)
{
    NTSTATUS hr;
    TimeStamp tsLife = {0,0};
    TimeStamp tsRenew = {0,0};

    if (FudgeFactor.QuadPart != 0)
    {
        SkewTime = FudgeFactor;
        Authenticators->SetMaxAge( SkewTime );
    }

    tsLife.QuadPart = (LONGLONG) MaxLifespan * 10000000;
    tsRenew.QuadPart = (LONGLONG) MaxRenewSpan * 10000000;

    if (KdcFlags == 0)
    {
        KdcFlags = SecData.KdcFlags();
    }
    if (MaxLifespan == 0)
    {
        tsLife = SecData.KdcTgtTicketLifespan();
    }

    if (MaxRenewSpan == 0)
    {
        tsLife = SecData.KdcTicketRenewSpan();
    }

    hr = SecData.DebugSetState(KdcFlags, tsLife, tsRenew);

    SecData.DebugShowState();

    return(hr);
}

void PrintIntervalTime (
        ULONG DebugFlag,
        LPSTR Message,
        PLARGE_INTEGER Interval )
{
    LONGLONG llTime = Interval->QuadPart;
    LONG lSeconds = (LONG) ( llTime / 10000000 );
    LONG lMinutes = ( lSeconds / 60 ) % 60;
    LONG lHours = ( lSeconds / 3600 );
    DebugLog(( DebugFlag, "%s %d:%2.2d:%2.2d \n", Message, lHours, lMinutes, lSeconds % 60 ));
}

void PrintTime (
        ULONG DebugFlag,
        LPSTR Message,
        PLARGE_INTEGER Time )
{
    SYSTEMTIME st;

    FileTimeToSystemTime ( (PFILETIME) Time, & st );
    DebugLog((DebugFlag, "%s %d-%d-%d %d:%2.2d:%2.2d\n", Message, st.wMonth, st.wDay, st.wYear,
                st.wHour, st.wMinute, st.wSecond ));
}

#else // DBG

NTSTATUS
KDC_GetState(   handle_t    hBinding,
                DWORD *     KDCFlags,
                DWORD *     MaxLifespan,
                DWORD *     MaxRenewSpan,
                PTimeStamp  FudgeFactor)
{
    return(STATUS_NOT_SUPPORTED);
}

NTSTATUS
KDC_SetState(   handle_t    hBinding,
                DWORD       KDCFlags,
                DWORD       MaxLifespan,
                DWORD       MaxRenewSpan,
                TimeStamp  FudgeFactor)
{
    return(STATUS_NOT_SUPPORTED);
}

#endif
#endif

BOOLEAN
KdcSetPassSupported(
    VOID
    )
{
    NET_API_STATUS NetStatus;
    ULONG SetPassUnsupported = 0;
    LPNET_CONFIG_HANDLE ConfigHandle = NULL;

    NetStatus = NetpOpenConfigData(
                    &ConfigHandle,
                    NULL,               // noserer name
                    L"kdc",
                    TRUE                // read only
                    );
    if (NetStatus != NO_ERROR)
    {
        return(TRUE);
    }
    NetStatus = NetpGetConfigDword(
                    ConfigHandle,
                    L"SetPassUnsupported",
                    0,
                    &SetPassUnsupported
                    );

    NetpCloseConfigData( ConfigHandle );
    if ((NetStatus == NO_ERROR) && (SetPassUnsupported == 1))
    {
        return(FALSE);
    }
    else
    {
        return(TRUE);
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   KDC_SetPassword
//
//  Synopsis:   Sets password for an account
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KDC_SetPassword(
    IN handle_t hBinding,
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING PrincipalName,
    IN PUNICODE_STRING Password,
    IN ULONG Flags
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    KERBERR KerbErr;
    SECPKG_SUPPLEMENTAL_CRED Credentials;
    KDC_TICKET_INFO TicketInfo;
    SAMPR_HANDLE UserHandle = NULL;
    KERB_EXT_ERROR ExtendedError; // dummy var.

    Credentials.Credentials = NULL;

    if (!KdcSetPassSupported())
    {
        Status = STATUS_NOT_SUPPORTED;
        goto Cleanup;
    }

    //
    // Make sure we can impersonate the caller.
    //

    if (RpcImpersonateClient(NULL) != ERROR_SUCCESS)
    {
        Status = STATUS_ACCESS_DENIED;
        goto Cleanup;
    }
    else
    {
        RpcRevertToSelf();
    }

    // According to bug 228139, rpc definition of unicode strings allow
    // for odd lengths. We will set them to even (1 less) so that we
    // don't av in the lsa.

    if (ARGUMENT_PRESENT(UserName) && UserName->Buffer)
    {
        UserName->Length = (UserName->Length/sizeof(WCHAR)) * sizeof(WCHAR);
    }
    else
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    KerbErr = KdcGetTicketInfo(
                    UserName,
                    0,          // no flags
                    FALSE,      // do not restrict user accounts (user2user)
                    NULL,
                    NULL,
                    &TicketInfo,
                    &ExtendedError,
                    &UserHandle,
                    0L,                 // no fields to fetch
                    0L,                 // no extended fields
                    NULL,               // no user all
                    NULL
                    );
    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR, "Failed to get ticket info for %wZ: 0x%x\n",
                UserName, KerbErr ));
        Status = STATUS_NO_SUCH_USER;
        goto Cleanup;
    }
    FreeTicketInfo(&TicketInfo);

    if (ARGUMENT_PRESENT(Password) && Password->Buffer)
    {
        Password->Length = (Password->Length/sizeof(WCHAR)) * sizeof(WCHAR);
    }
    else
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    if (ARGUMENT_PRESENT(PrincipalName) && PrincipalName->Buffer)
    {
        PrincipalName->Length = (PrincipalName->Length/sizeof(WCHAR)) * sizeof(WCHAR);
    }
    else
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    Status = KdcBuildPasswordList(
                Password,
                PrincipalName,
                SecData.KdcDnsRealmName(),
                UnknownAccount,
                NULL,               // no stored creds
                0,                  // no stored creds
                TRUE,               // marshall
                FALSE,              // don't include builtins
                Flags,
                Unknown,
                (PKERB_STORED_CREDENTIAL *) &Credentials.Credentials,
                &Credentials.CredentialSize
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    RtlInitUnicodeString(
        &Credentials.PackageName,
        MICROSOFT_KERBEROS_NAME_W
        );

    Status = SamIStorePrimaryCredentials(
                UserHandle,
                &Credentials
                );
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "Failed to store primary credentials: 0x%x\n",Status));
        goto Cleanup;
    }

Cleanup:
    if (UserHandle != NULL)
    {
        SamrCloseHandle(&UserHandle);
    }
    if (Credentials.Credentials != NULL)
    {
        MIDL_user_free(Credentials.Credentials);
    }
    return(Status);
}


NTSTATUS
KDC_GetDomainList(
    IN handle_t hBinding,
    OUT PKDC_DBG_DOMAIN_LIST * DomainList
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKDC_DBG_DOMAIN_LIST TempList;
    PKDC_DBG_DOMAIN_INFO DomainInfo = NULL;
    PKDC_DOMAIN_INFO Domain;
    ULONG DomainCount = 0;
    PLIST_ENTRY ListEntry;
    ULONG Index = 0;

    *DomainList = NULL;

    KdcLockDomainListFn();

    TempList = (PKDC_DBG_DOMAIN_LIST) MIDL_user_allocate(sizeof(KDC_DBG_DOMAIN_LIST));
    if (TempList == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    for (ListEntry = KdcDomainList.Flink;
         ListEntry != &KdcDomainList ;
         ListEntry = ListEntry->Flink )
    {
        DomainCount++;
    }

    DomainInfo = (PKDC_DBG_DOMAIN_INFO) MIDL_user_allocate(DomainCount * sizeof(KDC_DBG_DOMAIN_INFO));
    if (DomainInfo == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }
    RtlZeroMemory(
        DomainInfo,
        DomainCount * sizeof(KDC_DBG_DOMAIN_INFO)
        );

    Index = 0;
    for (ListEntry = KdcDomainList.Flink;
         ListEntry != &KdcDomainList ;
         ListEntry = ListEntry->Flink )
    {
        Domain = (PKDC_DOMAIN_INFO) CONTAINING_RECORD(ListEntry, KDC_DOMAIN_INFO, Next);
        KerbDuplicateString(
            &DomainInfo[Index].DnsName,
            &Domain->DnsName
            );
        KerbDuplicateString(
            &DomainInfo[Index].NetbiosName,
            &Domain->NetbiosName
            );
        if (Domain->ClosestRoute != NULL)
        {
            KerbDuplicateString(
                &DomainInfo[Index].ClosestRoute,
                &Domain->ClosestRoute->DnsName
                );
        }
        DomainInfo->Type = Domain->Type;
        DomainInfo->Attributes = Domain->Attributes;
        Index++;
    }

    TempList->Count = DomainCount;
    TempList->Domains = DomainInfo;
    *DomainList = TempList;
    TempList = NULL;
    DomainInfo = NULL;

Cleanup:
    KdcUnlockDomainListFn();

    if (TempList != NULL)
    {
        MIDL_user_free(TempList);
    }
    if (DomainInfo != NULL)
    {
        MIDL_user_free(DomainInfo);
    }

    return(Status);
}

VOID
KdcCopyKeyData(
    OUT PKERB_KEY_DATA NewKey,
    IN PKERB_KEY_DATA OldKey,
    IN OUT PBYTE * Where,
    IN LONG_PTR Offset
    )
{
    //
    // Copy the key
    //

    NewKey->Key.keytype = OldKey->Key.keytype;
    NewKey->Key.keyvalue.length = OldKey->Key.keyvalue.length;
    NewKey->Key.keyvalue.value = (*Where) - Offset;
    RtlCopyMemory(
        (*Where),
        OldKey->Key.keyvalue.value,
        OldKey->Key.keyvalue.length
        );
    (*Where) += OldKey->Key.keyvalue.length;

    //
    // Copy the salt
    //

    if (OldKey->Salt.Buffer != NULL)
    {
        NewKey->Salt.Length =
            NewKey->Salt.MaximumLength =
                OldKey->Salt.Length;
        NewKey->Salt.Buffer = (LPWSTR) ((*Where) - Offset);
        RtlCopyMemory(
            (*Where),
            OldKey->Salt.Buffer,
            OldKey->Salt.Length
            );
        (*Where) += OldKey->Salt.Length;
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   KDC_SetAccountKeys
//
//  Synopsis:   Set the keys for an account
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KDC_SetAccountKeys(
    IN handle_t hBinding,
    IN PUNICODE_STRING UserName,
    IN ULONG Flags,
    IN PKERB_STORED_CREDENTIAL Keys
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    KERBERR KerbErr;
    KERB_EXT_ERROR ExtendedError; // dummy var
    SECPKG_SUPPLEMENTAL_CRED Credentials = {0};
    KDC_TICKET_INFO TicketInfo= {0};
    SAMPR_HANDLE UserHandle = NULL;
    PKERB_STORED_CREDENTIAL StoredCreds = NULL;
    PKERB_STORED_CREDENTIAL Passwords = NULL;
    ULONG StoredCredSize = 0;
    ULONG CredentialCount = 0;
    ULONG CredentialIndex = 0;
    ULONG Index;
    PBYTE Where;
    UNICODE_STRING DefaultSalt;
    LONG_PTR Offset;

    if (!KdcSetPassSupported())
    {
        Status = STATUS_NOT_SUPPORTED;
        goto Cleanup;
    }

    //
    // Make sure we can impersonate the caller.
    //

    if (RpcImpersonateClient(NULL) != ERROR_SUCCESS)
    {
        Status = STATUS_ACCESS_DENIED;
        goto Cleanup;
    }
    else
    {
        RpcRevertToSelf();
    }

    // According to bug 228139, rpc definition of unicode strings allow
    // for odd lengths. We will set them to even (1 less) so that we
    // don't av in the lsa.

    if (ARGUMENT_PRESENT(UserName) && UserName->Buffer)
    {
        UserName->Length = (UserName->Length/sizeof(WCHAR)) * sizeof(WCHAR);
    }
    else
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    KerbErr = KdcGetTicketInfo(
                    UserName,
                    0,          // no flags
                    FALSE,      // do not restrict user accounts (user2user)
                    NULL,
                    NULL,
                    &TicketInfo,
                    &ExtendedError,
                    &UserHandle,
                    0L,                 // no fields to fetch
                    0L,                 // no extended fields
                    NULL,               // no user all
                    NULL
                    );
    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR, "Failed to get ticket info for %wZ: 0x%x\n",
                UserName, KerbErr ));
        Status = STATUS_NO_SUCH_USER;
        goto Cleanup;
    }

    //
    // If the caller asks us to replace keys, then clobber all supplemental
    // creds with the new ones. Otherwise, just replace the current ones
    // with the old ones
    //

    Passwords = TicketInfo.Passwords;

    if ((Flags & KERB_SET_KEYS_REPLACE) ||
        (Passwords == NULL))
    {
        KerbErr = KdcDuplicateCredentials(
                    &StoredCreds,
                    &StoredCredSize,
                    Keys,
                    TRUE                // marshall
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            Status = KerbMapKerbError(KerbErr);
            goto Cleanup;
        }
    }
    else
    {
        if (Keys->OldCredentialCount != 0)
        {
            DebugLog((DEB_ERROR,"OldCredentialCount supplied with merge-in keys - illegal\n"));
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

        //
        // Calculate the size of the stored creds.
        //

        StoredCredSize = FIELD_OFFSET(KERB_STORED_CREDENTIAL,Credentials) +
                            Keys->CredentialCount * sizeof(KERB_KEY_DATA) +
                            Keys->DefaultSalt.Length;

        for (Index = 0; Index < Keys->CredentialCount; Index++ )
        {
            StoredCredSize += Keys->Credentials[Index].Salt.Length +
                                Keys->Credentials[Index].Key.keyvalue.length;
            CredentialCount++;
        }

        //
        // Add in the keys that aren't in the supplied ones
        //

        if (Keys->DefaultSalt.Buffer == NULL)
        {
            StoredCredSize += Passwords->DefaultSalt.Length;
        }

        //
        // Add the size for all the keys in the passwords that weren't
        // in the passed in keys
        //

        for (Index = 0; Index < Passwords->CredentialCount ; Index++ )
        {
            if (KerbGetKeyFromList(Keys, Passwords->Credentials[Index].Key.keytype) == NULL)
            {
                //
                // Make sure it is not a builtin
                //

                if ((Passwords->Credentials[Index].Key.keytype == KERB_ETYPE_RC4_LM) ||
                    (Passwords->Credentials[Index].Key.keytype == KERB_ETYPE_RC4_MD4) ||
                    (Passwords->Credentials[Index].Key.keytype == KERB_ETYPE_RC4_HMAC_OLD) ||
                    (Passwords->Credentials[Index].Key.keytype == KERB_ETYPE_RC4_HMAC_OLD_EXP) ||
                    (Passwords->Credentials[Index].Key.keytype == KERB_ETYPE_RC4_HMAC_NT) ||
                    (Passwords->Credentials[Index].Key.keytype == KERB_ETYPE_RC4_HMAC_NT_EXP) ||
                    (Passwords->Credentials[Index].Key.keytype == KERB_ETYPE_NULL))
                {
                    continue;
                }
                StoredCredSize += Passwords->Credentials[Index].Salt.Length
                                + Passwords->Credentials[Index].Key.keyvalue.length
                                + sizeof(KERB_KEY_DATA);
                CredentialCount++;
            }
        }

        //
        // Add in the old keys
        //

        for (Index = 0; Index < Passwords->OldCredentialCount; Index++ )
        {
            StoredCredSize += sizeof(KERB_KEY_DATA) +
                        Passwords->Credentials[Index + Passwords->OldCredentialCount].Salt.Length +
                        Passwords->Credentials[Index + Passwords->OldCredentialCount].Key.keyvalue.length;
        }

        //
        // Allocate a new buffer to contain the marshalled keys
        //

        StoredCreds = (PKERB_STORED_CREDENTIAL) MIDL_user_allocate(StoredCredSize);
        if (StoredCreds == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        RtlZeroMemory(
            StoredCreds,
            StoredCredSize
            );

        //
        // Set the standard bits
        //

        StoredCreds->Revision = KERB_PRIMARY_CRED_REVISION;
        StoredCreds->Flags = 0;

        Offset = (LONG_PTR) StoredCreds;
        Where = (PBYTE) &(StoredCreds->Credentials[CredentialCount + Passwords->OldCredentialCount]);

        //
        // Copy in the default salt.
        //

        if (Keys->DefaultSalt.Buffer != NULL)
        {
            DefaultSalt = Keys->DefaultSalt;
        }
        else
        {
            DefaultSalt = Passwords->DefaultSalt;
        }
        if (DefaultSalt.Buffer != NULL)
        {
            StoredCreds->DefaultSalt.Length =
                StoredCreds->DefaultSalt.MaximumLength =  DefaultSalt.Length;
            StoredCreds->DefaultSalt.Buffer = (LPWSTR) (Where - Offset);
            RtlCopyMemory(
                Where,
                DefaultSalt.Buffer,
                DefaultSalt.Length
                );
            Where += DefaultSalt.Length;
        }

        //
        // Copy in all the new keys
        //

        for (Index = 0; Index < Keys->CredentialCount ; Index++ )
        {
            KdcCopyKeyData(
                &StoredCreds->Credentials[CredentialIndex],
                &Keys->Credentials[Index],
                &Where,
                Offset
                );
            CredentialIndex++;
        }

        //
        // Copy in the existing keys
        //

        for (Index = 0; Index < Passwords->CredentialCount ; Index++ )
        {
            if (KerbGetKeyFromList(Keys, Passwords->Credentials[Index].Key.keytype) == NULL)
            {
                if ((Passwords->Credentials[Index].Key.keytype == KERB_ETYPE_RC4_LM) ||
                    (Passwords->Credentials[Index].Key.keytype == KERB_ETYPE_RC4_MD4) ||
                    (Passwords->Credentials[Index].Key.keytype == KERB_ETYPE_RC4_HMAC_OLD) ||
                    (Passwords->Credentials[Index].Key.keytype == KERB_ETYPE_RC4_HMAC_OLD_EXP) ||
                    (Passwords->Credentials[Index].Key.keytype == KERB_ETYPE_RC4_HMAC_NT) ||
                    (Passwords->Credentials[Index].Key.keytype == KERB_ETYPE_RC4_HMAC_NT_EXP) ||
                    (Passwords->Credentials[Index].Key.keytype == KERB_ETYPE_NULL))
                {
                    continue;
                }

                KdcCopyKeyData(
                    &StoredCreds->Credentials[CredentialIndex],
                    &Passwords->Credentials[Index],
                    &Where,
                    Offset
                    );
                CredentialIndex++;
            }
        }
        StoredCreds->CredentialCount = (USHORT) CredentialIndex;

        //
        // Copy in the old keys from the existing keys
        //

        for (Index = 0; Index < Passwords->OldCredentialCount; Index++ )
        {
            KdcCopyKeyData(
                &StoredCreds->Credentials[CredentialIndex],
                &Passwords->Credentials[Index + Passwords->OldCredentialCount],
                &Where,
                Offset
                );
            CredentialIndex++;
        }

        StoredCreds->OldCredentialCount = Passwords->OldCredentialCount;
    }

    RtlInitUnicodeString(
        &Credentials.PackageName,
        MICROSOFT_KERBEROS_NAME_W
        );

    Credentials.Credentials = (PBYTE) StoredCreds;
    Credentials.CredentialSize = StoredCredSize;
    Status = SamIStorePrimaryCredentials(
                UserHandle,
                &Credentials
                );
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "Failed to store primary credentials: 0x%x\n",Status));
        goto Cleanup;
    }

Cleanup:
    FreeTicketInfo(&TicketInfo);

    if (UserHandle != NULL)
    {
        SamrCloseHandle(&UserHandle);
    }
    if (StoredCreds != NULL)
    {
        MIDL_user_free(StoredCreds);
    }
    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\server\gettgs.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       gettgs.cxx
//
//  Contents:   GetTGSTicket and support functions
//
//  Classes:
//
//  Functions:
//
//  History:    04-Mar-94   wader   Created
//
//----------------------------------------------------------------------------
#include "kdcsvr.hxx"
#include "kdctrace.h"
#include <userall.h>
#include <ntdef.h>

extern "C"
{
#include <md5.h>
}

#include "fileno.h"

#define FILENO  FILENO_GETTGS

extern LARGE_INTEGER tsInfinity;
extern LONG lInfinity;

UNICODE_STRING KdcNullString = {0,0,NULL};

GUID GUID_A_TOKEN_GROUPS_GLOBAL_AND_UNIVERSAL = {0x46a9b11d,0x60ae,0x405a,0xb7,0xe8,0xff,0x8a,0x58,0xd4,0x56,0xd2};
GUID GUID_A_SECURED_FOR_CROSS_ORGANIZATION = {0x68B1D179,0x0D15,0x4d4f,0xAB,0x71,0x46,0x15,0x2E,0x79,0xA7,0xBC};

//
// If defined, all trusts, not just MIT, will be namespace filtered
//

#define NAMESPACE_FILTER_EVERY_TRUST

//--------------------------------------------------------------------
//
//  Name:       KdcCheckGroupExpansionAccess
//
//  Synopsis:   Validate that S4U caller has access to expand groups
//
//  Effects:    Use Authz to check client context.
//
//  Arguments:  S4UClientName    - ClientName from S4U PA Data
//              TgtAccountInfo   - Information from the inbound tgt account,
//                                 derived from KdcVerfiyKdcRequest.
//              SD               - Security descriptor from the user object.
//
//  Requires:
//
//  Returns:    KDC_ERR_ or KRB_AP_ERR errors only
//
//  Notes:  Free client name and realm w/
//
//
//---
GUID GUID_PS_REMOTE_ACCESS_INFO = {0x037088f8,0x0ae1,0x11d2,0xb4,0x22,0x00,0xa0,0xc9,0x68,0xf9,0x39};
GUID GUID_C_COMPUTER            = {0xbf967a86,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
GUID GUID_C_USER                = {0xbf967aba,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};

NTSTATUS
KdcCheckGroupExpansionAccess(
    IN PKDC_S4U_TICKET_INFO S4UTicketInfo,
    IN PKDC_TICKET_INFO TgtAccountInfo,
    IN PUSER_INTERNAL6_INFORMATION UserInfo
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    KERBERR KerbErr;

    LUID                            ZeroLuid = {0,0};
    DWORD                           AccessMask[3];
    DWORD                           Error[3];
    AUTHZ_CLIENT_CONTEXT_HANDLE     hClientContext = NULL;
    AUTHZ_ACCESS_REQUEST            Request = {0};
    AUTHZ_ACCESS_REPLY              Reply = {0};
    KDC_AUTHZ_INFO                  AuthzInfo = {0};
    KDC_AUTHZ_GROUP_BUFFERS         InfoToFree = {0};
    ULONG                           i = 0;
    OBJECT_TYPE_LIST                TypeList[3] = {0};
 
    BOOLEAN ComputerAccount = (( UserInfo->I1.UserAccountControl & 
                               ( USER_WORKSTATION_TRUST_ACCOUNT | USER_SERVER_TRUST_ACCOUNT )) != 0);

    PSECURITY_DESCRIPTOR Sd = UserInfo->I1.SecurityDescriptor.SecurityDescriptor;
    
    //
    // Extract the netlogon validation info from
    // the TGT used in the S4UToSelf request.
    //

    KerbErr = KdcGetSidsFromTgt(
                  S4UTicketInfo->EvidenceTicket,
                  &S4UTicketInfo->EvidenceTicketKey,
                  0,            // no etype needed if we've got the evidence ticket key.
                  TgtAccountInfo,
                  &AuthzInfo,
                  &InfoToFree,
                  &Status
                  );

    if (!KERB_SUCCESS( KerbErr ))
    {
        goto Cleanup;
    }

    if (!AuthzInitializeContextFromSid(
            AUTHZ_SKIP_TOKEN_GROUPS,
            AuthzInfo.SidAndAttributes[0].Sid, // userid is first element in array
            KdcAuthzRM,
            NULL,
            ZeroLuid,
            &AuthzInfo,
            &hClientContext
            ))
    {
        DebugLog((DEB_ERROR, "AuthzInitializeContextFromSid() failed %x\n", GetLastError()));
        Status = STATUS_INTERNAL_ERROR;
        goto Cleanup;
    }

    //
    // Do access check.
    //

    TypeList[0].Level = ACCESS_OBJECT_GUID;
    TypeList[0].ObjectType = (ComputerAccount ? &GUID_C_COMPUTER : &GUID_C_USER );
    TypeList[0].Sbz = 0;

    TypeList[1].Level = ACCESS_PROPERTY_SET_GUID;
    TypeList[1].ObjectType = &GUID_PS_REMOTE_ACCESS_INFO;
    TypeList[1].Sbz = 0;

    TypeList[2].Level = ACCESS_PROPERTY_GUID;
    TypeList[2].ObjectType = &GUID_A_TOKEN_GROUPS_GLOBAL_AND_UNIVERSAL;
    TypeList[2].Sbz = 0;

    Request.DesiredAccess = ACTRL_DS_READ_PROP;
    Request.ObjectTypeList = TypeList;
    Request.ObjectTypeListLength = 3;
    Request.OptionalArguments = NULL;
    Request.PrincipalSelfSid = NULL;

    Reply.ResultListLength = 3;    
    Reply.GrantedAccessMask = AccessMask;
    Reply.Error = Error;
  
    if (!AuthzAccessCheck(
            0,
            hClientContext,
            &Request,
            NULL, // TBD:  add audit
            Sd,
            NULL,
            NULL,
            &Reply,
            NULL // don't cache result?  Check to see if optimal.
            ))
    {
        Error[0] = GetLastError();
        DebugLog((DEB_ERROR, "AuthzAccessCheck() failed %x\n", Error[0]));
        Status = STATUS_ACCESS_DENIED;
        goto Cleanup;
    }

    for ( i = 0; i < Reply.ResultListLength; i++)
    { 
        if ( Error[i] != ERROR_SUCCESS )
        {
            DebugLog((DEB_ERROR, "GroupExpansion AuthZAC failed %x, lvl %x",Error[i],i));
            Status = STATUS_ACCESS_DENIED;
            goto Cleanup;
        }
    }

    Status = STATUS_SUCCESS;

Cleanup:

    if ( Status == STATUS_ACCESS_DENIED ) 
    { 
        // catch unknown errors here.
        DsysAssert(Error[i] == ERROR_ACCESS_DENIED);

        KdcReportS4UGroupExpansionError(
                    UserInfo,
                    S4UTicketInfo,
                    Error[i]  // use whatever status was returned to us that caused failure.
                    );
    }
                      
    if ( hClientContext != NULL )
    {   
        AuthzFreeContext(hClientContext);
    }

    KdcFreeAuthzInfo( &InfoToFree );

    return Status;
}


//--------------------------------------------------------------------
//
//  Name:       KdcGetS4UTicketInfo
//
//  Synopsis:   Track down the user acct for PAC info.
//
//  Effects:    Get the PAC
//
//  Arguments:  S4UTicketInfo    - Information used in processing S4U
//              TgtAccountInfo   - Info on TGT used in request.
//              UserInfo         - Internal 6 info for S4USelf client
//              GroupMembership  - Group membership of S4USelf client
//
//  Requires:
//
//  Returns:    KDC_ERR_ or KRB_AP_ERR errors only
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KdcGetS4UTicketInfo(
    IN PKDC_S4U_TICKET_INFO S4UTicketInfo,
    IN PKDC_TICKET_INFO TgtAccountInfo,
    IN OUT PUSER_INTERNAL6_INFORMATION * UserInfo,
    IN OUT PSID_AND_ATTRIBUTES_LIST GroupMembership,
    IN OUT PKERB_EXT_ERROR ExtendedError
    )
{
    KERBERR KerbErr;
    UNICODE_STRING  ReferralRealm = {0};
    BOOLEAN Referral = FALSE;
    NTSTATUS Status = STATUS_SUCCESS;
    LARGE_INTEGER LogoffTime;

    *UserInfo = NULL;
    RtlZeroMemory(
        GroupMembership,
        sizeof(SID_AND_ATTRIBUTES_LIST)
        );

    PUSER_INTERNAL6_INFORMATION  LocalUserInfo = NULL;
    KDC_TICKET_INFO LocalTicketInfo = {0};
    SID_AND_ATTRIBUTES_LIST LocalGroupMembership ={0};

    KerbErr = KdcNormalize(
                S4UTicketInfo->PACCName,
                NULL,
                NULL,
                NULL,
                KDC_NAME_CLIENT | KDC_NAME_S4U_CLIENT | KDC_NAME_FOLLOW_REFERRALS | KDC_NAME_CHECK_GC,
                FALSE,          // do not restrict user accounts (user2user)
                &Referral,
                &ReferralRealm,
                &LocalTicketInfo,
                ExtendedError,
                NULL,
                USER_ALL_KDC_GET_PAC_AUTH_DATA | USER_ALL_SECURITYDESCRIPTOR,
                0L,
                &LocalUserInfo,
                &LocalGroupMembership
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR, "KdcGetS4UTicketInfo normalize in KdcGetS4uTicketInfo failed %x\n", KerbErr));
        goto cleanup;
    }
    else if (Referral)
    {
        DebugLog((DEB_ERROR, "KdcGetS4UTicketInfo normalize returned referral for S4U client\n"));
        KerbErr = KDC_ERR_C_PRINCIPAL_UNKNOWN;
        goto cleanup;
    }

    //
    // Some account restrictions apply to S4u
    //  1. Disabled accounts.
    //  2. Expired accounts.
    //
    KerbErr = KerbCheckLogonRestrictions(
                NULL,           // no user handle, since we're not doing sam check.
                NULL,           // No client address is available
                &LocalUserInfo->I1,
                KDC_RESTRICT_S4U_CHECKS, // Don't bother checking for password expiration, wkstation , account hours
                &LogoffTime,
                &Status
                );   

    if (!KERB_SUCCESS( KerbErr ))
    {
        DebugLog((DEB_ERROR, "S4USelf client restricted %x\n", Status));  
        FILL_EXT_ERROR_EX2( ExtendedError, Status, FILENO, __LINE__);
        goto cleanup;
    }  

    //
    //  Make sure S4U to self caller has access rights to user object.
    //
    Status = KdcCheckGroupExpansionAccess(
                S4UTicketInfo,
                TgtAccountInfo,
                LocalUserInfo
                );

    if (!NT_SUCCESS( Status ))
    {
        DebugLog((DEB_ERROR, "Failed Authz check \n"));
        KerbErr = KDC_ERR_C_PRINCIPAL_UNKNOWN;
        goto cleanup;
    }

    if (( LocalTicketInfo.fTicketOpts & AUTH_REQ_ALLOW_FORWARDABLE ) == 0)
    {
        S4UTicketInfo->Flags |= TI_SENSITIVE_CLIENT_ACCOUNT;
    }


    *UserInfo = LocalUserInfo;
    LocalUserInfo = NULL;

    *GroupMembership = LocalGroupMembership;
    RtlZeroMemory(
        &LocalGroupMembership,
        sizeof(SID_AND_ATTRIBUTES_LIST)
        );

cleanup:

    KerbFreeString(&ReferralRealm);
    FreeTicketInfo(&LocalTicketInfo);
    SamIFreeSidAndAttributesList(&LocalGroupMembership);
    if (LocalUserInfo != NULL)
    {
        SamIFree_UserInternal6Information( LocalUserInfo );
    }

    return KerbErr;

}



//+-------------------------------------------------------------------------
//
//  Function:   KdcAuditAccountMapping
//
//  Synopsis:   Generates, if necessary, a success/failure audit for name
//              mapping. The names are converted to a string before
//              being passed to the LSA.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KdcAuditAccountMapping(
    IN PKERB_INTERNAL_NAME ClientName,
    IN KERB_REALM ClientRealm,
    IN OPTIONAL PKDC_TICKET_INFO MappedTicketInfo
    )
{
    UNICODE_STRING ClientString = {0};
    PUNICODE_STRING MappedName = NULL;
    UNICODE_STRING UnicodeRealm = {0};
    UNICODE_STRING NullString = {0};
    KERBERR KerbErr;
    BOOLEAN Successful;
    UCHAR ClientSidBuffer[256]; // rtl functions also use hard-coded 256
    PSID ClientSid = (PSID) ClientSidBuffer;

    if (ARGUMENT_PRESENT(MappedTicketInfo))
    {
        if (!SecData.AuditKdcEvent(KDC_AUDIT_MAP_SUCCESS))
        {
            return;
        }

        Successful = TRUE;
        MappedName = &MappedTicketInfo->AccountName;
    }
    else
    {
        if (!SecData.AuditKdcEvent(KDC_AUDIT_MAP_FAILURE))
        {
            return;
        }

        MappedName = &NullString;
        Successful = FALSE;
    }

    KerbErr = KerbConvertRealmToUnicodeString(
                &UnicodeRealm,
                &ClientRealm
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        return;
    }

    if (KERB_SUCCESS(KerbConvertKdcNameToString(
            &ClientString,
            ClientName,
            &UnicodeRealm
            )))
    {
        if ( ARGUMENT_PRESENT( MappedTicketInfo ))
        {
            KdcMakeAccountSid(ClientSid, MappedTicketInfo->UserId);
        }
        else
        {
            ClientSid = NULL;
        }
        
        LsaIAuditAccountLogonEx(
            SE_AUDITID_ACCOUNT_MAPPED,
            Successful,
            &GlobalKdcName,
            &ClientString,
            MappedName,
            0,                   // no status
            ClientSid
            );

        KerbFreeString(
            &ClientString
            );

    }

    KerbFreeString(
        &UnicodeRealm
        );
}


//----------------------------------------------------------------
//
//  Name:       KdcInsertAuthorizationData
//
//  Synopsis:   Inserts auth data into a newly created ticket.
//
//  Arguments:  FinalTicket - Ticket to insert Auth data into
//              EncryptedAuthData - Auth data (optional)
//              SourceTicket - Source ticket
//
//  Notes:      This copies the authorization data from the source ticket
//              to the destiation ticket, and adds the authorization data
//              passed in.  It is called by GetTGSTicket.
//
//              This assumes that pedAuthData is an encrypted
//              KERB_AUTHORIZATION_DATA.
//              It will copy all the elements of that list to the new ticket.
//              If pedAuthData is not supplied (or is empty), and there is
//              auth data in the source ticket, it is copied to the new
//              ticket.  If no source ticket, and no auth data is passed
//              in, nothing is done.
//
//----------------------------------------------------------------

KERBERR
KdcInsertInitialS4UAuthorizationData(
    OUT PKERB_ENCRYPTED_TICKET FinalTicket,
    OUT PKERB_EXT_ERROR pExtendedError,
    IN PKDC_S4U_TICKET_INFO S4UTicketInfo,
    IN PUSER_INTERNAL6_INFORMATION S4UClientInternalInfo,
    IN PSID_AND_ATTRIBUTES_LIST S4UGroupMembership,
    IN BOOLEAN AddResourceGroups,
    IN PKERB_ENCRYPTION_KEY TargetServerKey
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    PKERB_AUTHORIZATION_DATA FinalAuthData = NULL;

    TRACE(KDC, InsertAuthorizationData, DEB_FUNCTION);

    D_DebugLog(( DEB_T_TICKETS, "Inserting S4U authorization data into ticket.\n" ));

    //
    // Use the PAC from the S4U data to return in the TGT / Service Ticket
    //
    KerbErr = KdcGetPacAuthData(
                    S4UClientInternalInfo,
                    S4UGroupMembership,
                    TargetServerKey,
                    NULL,                   // no credential key
                    AddResourceGroups,
                    FinalTicket,
                    S4UTicketInfo,
                    &FinalAuthData,
                    pExtendedError
                    );

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR, "Failed to get S4UPacAUthData\n"));
        goto Cleanup;
    }

    if (FinalAuthData != NULL)
    {
        FinalTicket->bit_mask |= KERB_ENCRYPTED_TICKET_authorization_data_present;
        FinalTicket->KERB_ENCRYPTED_TICKET_authorization_data = FinalAuthData;
        FinalAuthData = NULL;
    }

    KerbErr = KDC_ERR_NONE;

Cleanup:

    KerbFreeAuthData(FinalAuthData);

    return(KerbErr);
}


//----------------------------------------------------------------
//
//  Name:       KdcInsertAuthorizationData
//
//  Synopsis:   Inserts auth data into a newly created ticket.
//
//  Arguments:  FinalTicket - Ticket to insert Auth data into
//              EncryptedAuthData - Auth data (optional)
//              SourceTicket - Source ticket
//
//  Notes:      This copies the authorization data from the source ticket
//              to the destiation ticket, and adds the authorization data
//              passed in.  It is called by GetTGSTicket.
//
//              This assumes that pedAuthData is an encrypted
//              KERB_AUTHORIZATION_DATA.
//              It will copy all the elements of that list to the new ticket.
//              If pedAuthData is not supplied (or is empty), and there is
//              auth data in the source ticket, it is copied to the new
//              ticket.  If no source ticket, and no auth data is passed
//              in, nothing is done.
//
//----------------------------------------------------------------

KERBERR
KdcInsertAuthorizationData(
    OUT PKERB_ENCRYPTED_TICKET FinalTicket,
    OUT PKERB_EXT_ERROR pExtendedError,
    IN OPTIONAL PKERB_ENCRYPTED_DATA EncryptedAuthData,
    IN PKERB_ENCRYPTED_TICKET SourceTicket,
    IN OPTIONAL PKDC_TICKET_INFO TargetServiceTicketInfo,
    IN OPTIONAL PKDC_S4U_TICKET_INFO S4UTicketInfo,
    IN OPTIONAL PKDC_TICKET_INFO OriginalServerInfo,
    IN OPTIONAL PKERB_ENCRYPTION_KEY OriginalServerKey,
    IN OPTIONAL PKERB_ENCRYPTION_KEY TargetServerKey,
    IN OPTIONAL PKERB_ENCRYPTION_KEY Subkey,
    OUT OPTIONAL PS4U_DELEGATION_INFO* S4UDelegationInfo
    )
{
    PKERB_AUTHORIZATION_DATA SourceAuthData = NULL;
    PKERB_AUTHORIZATION_DATA FinalAuthData = NULL;
    PKERB_AUTHORIZATION_DATA PacAuthData = NULL;
    PKERB_AUTHORIZATION_DATA NewPacAuthData = NULL;
    KERBERR KerbErr = KDC_ERR_NONE;
    PKERB_AUTHORIZATION_DATA_LIST * TempAuthData = NULL;
    PKERB_INTERNAL_NAME ClientName = NULL;
    PKERB_IF_RELEVANT_AUTH_DATA * IfRelevantData = NULL;
    PKERB_AUTHORIZATION_DATA SuppliedAuthData = NULL;
    UNICODE_STRING DummyName = {0};
    NTSTATUS LogonStatus = STATUS_SUCCESS;
    TimeStamp LogoffTime;
    SAMPR_HANDLE UserHandle = NULL;
    BOOLEAN AddResourceGroups = FALSE;




    PKERB_ENCRYPTED_TICKET EvidenceTicket = NULL;

    TRACE(KDC, InsertAuthorizationData, DEB_FUNCTION);

    if (ARGUMENT_PRESENT(TargetServiceTicketInfo))
    {
        //
        // Only add resource groups for non-referals.
        //                                         
        AddResourceGroups = ((TargetServiceTicketInfo->UserId != DOMAIN_USER_RID_KRBTGT) &&
                        ((TargetServiceTicketInfo->UserAccountControl & USER_INTERDOMAIN_TRUST_ACCOUNT) == 0));


    }


    
    if (( ARGUMENT_PRESENT(S4UTicketInfo) ) &&
       (( S4UTicketInfo->Flags & TI_S4UPROXY_INFO ) != 0))
    {
        D_DebugLog((DEB_T_PAC, "KdcInsertAuthorizationData EvidenceTicket is S4UTicketInfo\n"));
        D_DebugLog((DEB_T_PAC, "S4UTicketInfo (%p)\n", S4UTicketInfo));
        D_DebugLog((DEB_T_PAC, "PAC CName "));
        D_KerbPrintKdcName((DEB_T_PAC, S4UTicketInfo->PACCName));
        D_DebugLog((DEB_T_PAC, "PAC CRealm %wZ\n", &S4UTicketInfo->PACCRealm));
        D_DebugLog((DEB_T_PAC, "Requestor : "));
        D_KerbPrintKdcName((DEB_T_PAC, S4UTicketInfo->RequestorServiceName ));
        D_DebugLog((DEB_T_PAC, "Realm %wZ\n", &S4UTicketInfo->RequestorServiceRealm ));

        //
        // 2 choices here - either we're grabbing the PAC from the accompanying
        // evidence ticket (if the S4Uprxy request is coming from our realm), or
        // we'll grab it out of the xrealm tgt.
        //
        // If we change the xrealm behavior, we'll need to modify this.
        //
        if ( S4UTicketInfo->Flags & TI_PRXY_REQUESTOR_THIS_REALM )
        {
            EvidenceTicket = S4UTicketInfo->EvidenceTicket;
            DebugLog((DEB_T_PAC, "Using evidence ticket PAC\n"));
        }
        else
        {
            EvidenceTicket = SourceTicket;
            DebugLog((DEB_T_PAC, "Using xrealm Tgt PAC\n"));
        }
    }
    else // traditional TGS
    {
        D_DebugLog((DEB_T_PAC, "KdcInsertAuthorizationData EvidenceTicket is SourceTicket (TGT in TGS AP request)\n"));

        EvidenceTicket = SourceTicket;
    }

    //
    // First try to decrypt the supplied authorization data
    //
    if (ARGUMENT_PRESENT(EncryptedAuthData))
    {
        //
        // The enc_authorization_data must be decrypted with the sub session
        // key from the authenticator if it is present (per the RFC)
        //

        PKERB_ENCRYPTION_KEY EncryptionKey;
        ULONG SaltType = KERB_NON_KERB_SALT;

        if ( ARGUMENT_PRESENT( Subkey ))
        {
            EncryptionKey = Subkey;
            SaltType = KERB_TGS_REQ_SUBKEY_SALT;
            D_DebugLog((DEB_TRACE, "KdcInsertAuthorizationData: using SUBsession key & salt\n"));

        } else {

            EncryptionKey = &EvidenceTicket->key;
            SaltType = KERB_TGS_REQ_SESSKEY_SALT;
            D_DebugLog((DEB_TRACE, "KdcInsertAuthorizationData: using Session key & salt\n"));
        }

        KerbErr = KerbDecryptDataEx(
                      EncryptedAuthData,
                      EncryptionKey,
                      SaltType,                  //  was KERB_NON_KERB_SALT
                      &EncryptedAuthData->cipher_text.length,
                      EncryptedAuthData->cipher_text.value
                      );

        if (!KERB_SUCCESS( KerbErr ))
        {
            DebugLog((DEB_ERROR,
                         "KdcInsertAuthorizationData KLIN(%x) Failed to decrypt encrypted auth data: 0x%x\n",
                          KLIN(FILENO, __LINE__),
                          KerbErr));
            goto Cleanup;
        }

        //
        // Now decode it
        //

        KerbErr = KerbUnpackData(
                      EncryptedAuthData->cipher_text.value,
                      EncryptedAuthData->cipher_text.length,
                      PKERB_AUTHORIZATION_DATA_LIST_PDU,
                      (PVOID *) &TempAuthData
                      );

        if (!KERB_SUCCESS(KerbErr))
        {
            DebugLog((DEB_ERROR,
                         "KdcInsertAuthorizationData KLIN(%x) Failed to unpack data: 0x%x\n",
                          KLIN(FILENO, __LINE__),
                          KerbErr));
            goto Cleanup;
        }

        if (TempAuthData != NULL)
        {
            SuppliedAuthData = *TempAuthData;
        }

        D_DebugLog((DEB_T_PAC, "KdcInsertAuthorizationData using supplied authorization data\n"));
    }

    if (EvidenceTicket->bit_mask & KERB_ENCRYPTED_TICKET_authorization_data_present)
    {
        DsysAssert(EvidenceTicket->KERB_ENCRYPTED_TICKET_authorization_data != NULL);
        SourceAuthData = EvidenceTicket->KERB_ENCRYPTED_TICKET_authorization_data;

        //
        // Get the AuthData from the source ticket
        //

        KerbErr = KerbGetPacFromAuthData(
                      SourceAuthData,
                      &IfRelevantData,
                      &PacAuthData
                      );

        if (!KERB_SUCCESS(KerbErr))
        {
            DebugLog((DEB_ERROR,"KLIN(%x) Failed to get pac from auth data: 0x%x\n",
                      KLIN(FILENO, __LINE__),
                      KerbErr));
            goto Cleanup;
        }

        D_DebugLog((DEB_T_PAC, "KdcInsertAuthorizationData extracted PAC from evidence ticket\n"));
    }

#ifdef NAMESPACE_FILTER_EVERY_TRUST // Enable once we decide that namespace filtering should be performed over all trusts

    //
    // Namespace filtering can not be done for S4U2self requests since the fundamental
    // premise of namespace filtering is not satisfied there by design
    //

    if ( !S4UTicketInfo ||
         !(S4UTicketInfo->Flags & TI_S4USELF_INFO))
    {
        //
        // Verify that the namespace presented via crealm is valid across this trust link
        //

        KerbErr = KdcFilterNamespace(
                      OriginalServerInfo,
                      SourceTicket->client_realm,
                      pExtendedError
                      );

        if ( !KERB_SUCCESS( KerbErr ))
        {
            DebugLog((DEB_ERROR, "Failed filtering namespaces\n"));
            goto Cleanup;
        }
    }

#endif

    //
    // The new auth data is the original auth data appended to the
    // supplied auth data. The new auth data goes first, followed by the
    // auth data from the original ticket.
    //

    //
    // Update the PAC, if it is present.
    //

    if (ARGUMENT_PRESENT(OriginalServerKey) && (PacAuthData != NULL))
    {
        D_DebugLog((DEB_T_PAC, "KdcInsertAuthorizationData OriginalServerInfo %wZ\\%wZ\n", &OriginalServerInfo->TrustedForest, &OriginalServerInfo->AccountName));

        KerbErr = KdcVerifyAndResignPac(
                      OriginalServerKey,
                      TargetServerKey,
                      OriginalServerInfo,
                      TargetServiceTicketInfo,
                      S4UTicketInfo,
                      FinalTicket,
                      AddResourceGroups,
                      pExtendedError,
                      PacAuthData,
                      S4UDelegationInfo
                      );

        if (!KERB_SUCCESS(KerbErr))
        {
            DebugLog((DEB_ERROR,"KLIN(%x) Failed to verify & resign pac: 0x%x\n",
                      KLIN(FILENO, __LINE__),
                      KerbErr));

            goto Cleanup;
        }

        //
        // Copy the old auth data & insert the PAC
        //

        KerbErr = KdcInsertPacIntoAuthData(
                      SourceAuthData,
                      (IfRelevantData != NULL) ? *IfRelevantData : NULL,
                      PacAuthData,
                      &FinalAuthData
                      );

        if (!KERB_SUCCESS(KerbErr))
        {
            DebugLog((DEB_ERROR,"KLIN(%x) Failed to insert pac into auth data: 0x%x\n",
                      KLIN(FILENO, __LINE__),
                      KerbErr));

            goto Cleanup;
        }
    }

    //
    // If there was no original PAC, try to insert one here. If the ticket
    // was issued from this realm we don't add a pac.
    //

    else if ((PacAuthData == NULL) && !SecData.IsOurRealm(&SourceTicket->client_realm))
    {
        KDC_TICKET_INFO ClientTicketInfo = {0};
        SID_AND_ATTRIBUTES_LIST GroupMembership = {0};
        PUSER_INTERNAL6_INFORMATION UserInfo = NULL;

        D_DebugLog((DEB_T_PAC, "KdcInsertAuthorizationData getting new PAC\n"));

        KerbErr = KerbConvertPrincipalNameToKdcName(
                      &ClientName,
                      &EvidenceTicket->client_name
                      );

        if (!KERB_SUCCESS(KerbErr))
        {
            DebugLog((DEB_WARN,
                         "KdcInsertAuthorizationData KLIN(%x) Convertname to kdc name failed: 0x%x\n",
                          KLIN(FILENO, __LINE__),
                          KerbErr));
            goto Cleanup;
        }

        //
        // S4UProxy
        // Our evidence ticket *must* have auth data.
        //

        if  (( ARGUMENT_PRESENT( S4UTicketInfo )) &&
            (( S4UTicketInfo->Flags & TI_S4UPROXY_INFO ) != 0))
        {
            DebugLog((DEB_ERROR, "Trying S4UProxy w/ no PAC\n"));
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }

#ifndef NAMESPACE_FILTER_EVERY_TRUST

        //
        // This will perform an AltSecId mapping so first we must verify that
        // the namespace presented via crealm is valid across this trust link
        //

        KerbErr = KdcFilterNamespace(
                      OriginalServerInfo,
                      SourceTicket->client_realm,
                      pExtendedError
                      );

        if ( !KERB_SUCCESS( KerbErr ))
        {
            // TODO: add logging/auditing
            goto Cleanup;
        }

#endif

        KerbErr = KdcGetTicketInfo(
                      &DummyName,
                      SAM_OPEN_BY_ALTERNATE_ID,
                      FALSE,      // do not restrict user accounts (user2user)
                      ClientName,
                      &SourceTicket->client_realm,
                      &ClientTicketInfo,
                      pExtendedError,
                      &UserHandle,                   // no handle
                      USER_ALL_KDC_GET_PAC_AUTH_DATA | USER_ALL_KERB_CHECK_LOGON_RESTRICTIONS,
                      0L,                     // no extended fields
                      &UserInfo,
                      &GroupMembership
                      );

        if (KERB_SUCCESS(KerbErr))
        {
            KdcAuditAccountMapping(
                ClientName,
                SourceTicket->client_realm,
                &ClientTicketInfo
                );

            //
            // Check for any interesting account restrictions.
            //

            KerbErr = KerbCheckLogonRestrictions(
                          UserHandle,
                          NULL,           // No client address is available
                          &UserInfo->I1,
                          KDC_RESTRICT_PKINIT_USED | KDC_RESTRICT_IGNORE_PW_EXPIRATION,
                          &LogoffTime,
                          &LogonStatus
                          );

            if (!KERB_SUCCESS( KerbErr ))
            {
                DebugLog((DEB_ERROR, "MIT PAC Client account restriction %x\n", LogonStatus));
                FILL_EXT_ERROR_EX2(pExtendedError, LogonStatus, FILENO,__LINE__); 
                goto Cleanup;
            }                

            FreeTicketInfo(&ClientTicketInfo);
            KerbFreeKdcName(&ClientName);

            KerbErr = KdcGetPacAuthData(
                          UserInfo,
                          &GroupMembership,
                          TargetServerKey,
                          NULL,                   // no credential key
                          AddResourceGroups,
                          FinalTicket,
                          NULL, // no S4U client
                          &NewPacAuthData,
                          pExtendedError
                          );

            SamIFreeSidAndAttributesList( &GroupMembership );
            SamIFree_UserInternal6Information( UserInfo );

            if (!KERB_SUCCESS(KerbErr))
            {
                goto Cleanup;
            }

        } else if ( KerbErr == KDC_ERR_C_PRINCIPAL_UNKNOWN ) {

            KdcAuditAccountMapping(
                ClientName,
                SourceTicket->client_realm,
                NULL
                );

            KerbFreeKdcName(&ClientName);

            DebugLog((DEB_WARN, "GetTicketInfo Client Principal Unknown\n"));

            KerbErr = KDC_ERR_NONE;
        }

        if (!KERB_SUCCESS(KerbErr))
        {
            DebugLog((DEB_WARN,
                         "KdcInsertAuthorizationData KLIN(%x) Failed to GetTicketInfo: 0x%x\n",
                          KLIN(FILENO, __LINE__),
                          KerbErr));
            goto Cleanup;
        }

        //
        // If we got a PAC, stick it in the list
        //

        if (NewPacAuthData != NULL)
        {
            //
            // Copy the old auth data & insert the PAC
            //

            KerbErr = KerbCopyAndAppendAuthData(
                          &NewPacAuthData,
                          SourceAuthData
                          );

            if (!KERB_SUCCESS(KerbErr))
            {
                DebugLog((DEB_ERROR,"KLIN(%x) Failed to insert pac into auth data: 0x%x\n",
                    KLIN(FILENO, __LINE__), KerbErr));
                goto Cleanup;
            }

            FinalAuthData = NewPacAuthData;
            NewPacAuthData = NULL;
        }
    }

    //
    // if there was any auth data and  we didn't copy it transfering the
    // PAC, do so now
    //

    if ((SourceAuthData != NULL) && (FinalAuthData == NULL))
    {
        KerbErr = KerbCopyAndAppendAuthData(
                      &FinalAuthData,
                      SourceAuthData
                      );

        if (!KERB_SUCCESS(KerbErr))
        {
            DebugLog((DEB_ERROR,"KLIN(%x) Failed to appened auth data: 0x%x\n",
                KLIN(FILENO, __LINE__), KerbErr));
            goto Cleanup;
        }
    }

    if (SuppliedAuthData != NULL)
    {
        KerbErr = KerbCopyAndAppendAuthData(
                      &FinalAuthData,
                      SuppliedAuthData
                      );

        if (!KERB_SUCCESS(KerbErr))
        {
            DebugLog((DEB_ERROR,"KLIN(%x) Failed to appened auth data with supplied authdata: 0x%x\n",
                KLIN(FILENO, __LINE__), KerbErr));
            goto Cleanup;
        }
    }
    if (FinalAuthData != NULL)
    {
        FinalTicket->bit_mask |= KERB_ENCRYPTED_TICKET_authorization_data_present;
        FinalTicket->KERB_ENCRYPTED_TICKET_authorization_data = FinalAuthData;
        FinalAuthData = NULL;
    }

    KerbErr = KDC_ERR_NONE;

Cleanup:

    KerbFreeAuthData(
        FinalAuthData
        );

    if (UserHandle != NULL)
    {
        SamrCloseHandle(&UserHandle);
    }

    if (TempAuthData != NULL)
    {
        KerbFreeData(
            PKERB_AUTHORIZATION_DATA_LIST_PDU,
            TempAuthData
            );
    }

    KerbFreeAuthData(NewPacAuthData);

    if (IfRelevantData != NULL)
    {
        KerbFreeData(
            PKERB_IF_RELEVANT_AUTH_DATA_PDU,
            IfRelevantData
            );
    }

    return(KerbErr);
}

//+---------------------------------------------------------------------------
//
//  Function:   BuildTicketTGS
//
//  Synopsis:   Builds (most of) a TGS ticket
//
//  Arguments:  ServiceTicketInfo - Ticket info for the requested service
//              ReferralRealm - Realm to build referral to
//              RequestBody - The request causing this ticket to be built
//              SourceTicket - The TGT used to make this request
//              Referral - TRUE if this is an inter-realm referral ticke
//              CommonEType - Contains the common encryption type between
//                      client and server
//              NewTicket - The new ticket built here.
//
//
//  History:    24-May-93   WadeR   Created
//
//  Notes:      see 3.3.3, A.6 of the Kerberos V5 R5.2 spec
//
//----------------------------------------------------------------------------

KERBERR
BuildTicketTGS(
    IN PKDC_TICKET_INFO ServiceTicketInfo,
    IN PKERB_KDC_REQUEST_BODY RequestBody,
    IN PKERB_TICKET SourceTicket,
    IN BOOLEAN Referral,
    IN OPTIONAL PKDC_S4U_TICKET_INFO S4UTicketInfo,
    IN ULONG CommonEType,
    OUT PKERB_TICKET NewTicket,
    IN OUT PKERB_EXT_ERROR ExtendedError
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    KERB_TICKET OutputTicket;
    PKERB_ENCRYPTED_TICKET EncryptedTicket;
    PKERB_ENCRYPTED_TICKET SourceEncryptPart;
    LARGE_INTEGER TicketLifespan;
    LARGE_INTEGER TicketRenewspan;
    UNICODE_STRING NewTransitedInfo = {0,0,NULL};
    UNICODE_STRING ClientRealm = {0,0,NULL};
    UNICODE_STRING TransitedRealm = {0,0,NULL};
    UNICODE_STRING OldTransitedInfo = {0,0,NULL};
    STRING OldTransitedString;
    ULONG KdcOptions = 0;
    ULONG TicketFlags = 0;
    ULONG SourceTicketFlags = 0;
    PKERB_HOST_ADDRESSES Addresses = NULL;
    BOOLEAN fKpasswd = FALSE;

    TRACE(KDC, BuildTicketTGS, DEB_FUNCTION);

    D_DebugLog((DEB_T_KEY, "BuildTicketTGS building a TGS ticket Referral ? %s, CommonEType %#x\n", Referral ? "true" : "false", CommonEType));

    SourceEncryptPart = (PKERB_ENCRYPTED_TICKET) SourceTicket->encrypted_part.cipher_text.value;
    OutputTicket = *NewTicket;
    EncryptedTicket = (PKERB_ENCRYPTED_TICKET) OutputTicket.encrypted_part.cipher_text.value;

    KdcOptions = KerbConvertFlagsToUlong( &RequestBody->kdc_options );

    //
    // Check to see if the request is for the kpasswd service, in
    // which case, we only want the ticket to be good for 2 minutes.
    //
    KerbErr = KerbCompareKdcNameToPrincipalName(
                  &RequestBody->server_name,
                  GlobalKpasswdName,
                  &fKpasswd
                  );

    if (fKpasswd)
    {
       TicketLifespan.QuadPart = (LONGLONG) 10000000 * 60 * 2;
       TicketRenewspan.QuadPart = (LONGLONG) 10000000 * 60 * 2;
    }
    else
    {
       TicketLifespan = SecData.KdcTgsTicketLifespan();
       TicketRenewspan = SecData.KdcTicketRenewSpan();
    }

    //
    // TBD:  We need to make the ticket 10 minutes if we're doing s4U
    //

    KerbErr = KdcBuildTicketTimesAndFlags(
                  0,
                  ServiceTicketInfo->fTicketOpts,
                  &TicketLifespan,
                  &TicketRenewspan,
                  S4UTicketInfo,
                  NULL,                   // no logoff time
                  NULL,                   // no acct expiry.
                  RequestBody,
                  SourceEncryptPart,
                  EncryptedTicket,
                  ExtendedError
                  );

    if (!KERB_SUCCESS(KerbErr))
    {
        D_DebugLog((DEB_ERROR, "KLIN(%x) Failed to build ticket times and flags: 0x%x\n",
            KLIN(FILENO, __LINE__), KerbErr));
        goto Cleanup;
    }

    TicketFlags = KerbConvertFlagsToUlong( &EncryptedTicket->flags );
    SourceTicketFlags = KerbConvertFlagsToUlong( &SourceEncryptPart->flags );

    KerbErr = KerbMakeKey(
                  CommonEType,
                  &EncryptedTicket->key
                  );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    OldTransitedString.Buffer = (PCHAR) SourceEncryptPart->transited.contents.value;
    OldTransitedString.Length = OldTransitedString.MaximumLength = (USHORT) SourceEncryptPart->transited.contents.length;

    //
    // Fill in the service names
    //

    if (Referral)
    {
        PKERB_INTERNAL_NAME TempServiceName;

        //
        // For referral tickets we put a the name "krbtgt/remoterealm@localrealm"
        //

        //
        // We should only be doing this when we didn't get a non-ms principal
        //

        KerbErr = KerbBuildFullServiceKdcName(
                      &ServiceTicketInfo->AccountName,
                      SecData.KdcServiceName(),
                      KRB_NT_SRV_INST,
                      &TempServiceName
                      );

        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }

        KerbErr = KerbConvertKdcNameToPrincipalName(
                      &OutputTicket.server_name,
                      TempServiceName
                      );

        KerbFreeKdcName(&TempServiceName);

        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }

        //
        // If we got here on a referral ticket and are generating one
        // and the referral ticket we received was not from the client's
        // realm, add in the transited information.
        //

        if (!KerbCompareRealmNames(
                &SourceEncryptPart->client_realm,
                &SourceTicket->realm))
        {
            KerbErr = KerbStringToUnicodeString(
                          &OldTransitedInfo,
                          &OldTransitedString
                          );

            if (!KERB_SUCCESS(KerbErr))
            {
                goto Cleanup;
            }

            KerbErr = KerbConvertRealmToUnicodeString(
                          &TransitedRealm,
                          &SourceTicket->realm
                          );

            if (!KERB_SUCCESS(KerbErr))
            {
                goto Cleanup;
            }

            KerbErr = KerbConvertRealmToUnicodeString(
                          &ClientRealm,
                          &SourceEncryptPart->client_realm
                          );

            if (!KERB_SUCCESS(KerbErr))
            {
                goto Cleanup;
            }

            KerbErr = KdcInsertTransitedRealm(
                          &NewTransitedInfo,
                          &OldTransitedInfo,
                          &ClientRealm,
                          &TransitedRealm,
                          SecData.KdcDnsRealmName()
                          );

            if (!KERB_SUCCESS(KerbErr))
            {
                goto Cleanup;
            }
        }
    }
    else
    {
        //
        // If the client didn't request name canonicalization, use the
        // name supplied by the client
        //

        if (((KdcOptions & KERB_KDC_OPTIONS_name_canonicalize) != 0) &&
            ((ServiceTicketInfo->UserAccountControl & USER_USE_DES_KEY_ONLY) == 0))
        {
            if (ServiceTicketInfo->UserId == DOMAIN_USER_RID_KRBTGT)
            {
                PKERB_INTERNAL_NAME TempServiceName = NULL;

                KerbErr = KerbBuildFullServiceKdcName(
                              SecData.KdcDnsRealmName(),
                              SecData.KdcServiceName(),
                              KRB_NT_SRV_INST,
                              &TempServiceName
                              );

                if (!KERB_SUCCESS(KerbErr))
                {
                    goto Cleanup;
                }

                KerbErr = KerbConvertKdcNameToPrincipalName(
                              &OutputTicket.server_name,
                              TempServiceName
                              );

                KerbFreeKdcName(&TempServiceName);
            }
            else
            //
            // We no longer use the NC bit to change the server name, so just
            // duplicate the non-NC case, and return the server name from
            // the TGS_REQ.  NC is still used for building PA DATA for referral
            // however. and we should keep it for TGT renewal.  TS 2001-4-03
            //

            {
                KerbErr = KerbDuplicatePrincipalName(
                              &OutputTicket.server_name,
                              &RequestBody->KERB_KDC_REQUEST_BODY_server_name
                              );
            }
        }
        else
        {
            KerbErr = KerbDuplicatePrincipalName(
                          &OutputTicket.server_name,
                          &RequestBody->KERB_KDC_REQUEST_BODY_server_name
                          );
        }

        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }
    }

    //
    // Get cname for service ticket ...
    //
    // S4UToSelf / S4UProxy - We're in our realm, so take the "client" name
    // (supplied as PA DATA, or, alternately, the name in a additional ticket),
    // and make that the server name.
    //
    // Otherwise, normal TGS_REQ - use source ticket (tgt)
    //

    if (( ARGUMENT_PRESENT( S4UTicketInfo ) ) &&
        ( (S4UTicketInfo->Flags & ( TI_S4UPROXY_INFO | TI_S4USELF_INFO ) ) != 0) &&
        ( !Referral ))
    {
        KerbErr = KerbConvertKdcNameToPrincipalName(
                      &EncryptedTicket->client_name,
                      S4UTicketInfo->PACCName
                      );

        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }

        KerbErr = KerbConvertUnicodeStringToRealm(
                      &EncryptedTicket->client_realm,
                      &S4UTicketInfo->PACCRealm
                      );

        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }
    }
    else
    {
        KerbErr = KerbDuplicatePrincipalName(
                      &EncryptedTicket->client_name,
                      &SourceEncryptPart->client_name
                      );

        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }

        KerbErr = KerbDuplicateRealm(
                      &EncryptedTicket->client_realm,
                      SourceEncryptPart->client_realm
                      );

        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }
    }

    //
    // If the client did not request canonicalization, return the same
    // realm as it sent. Otherwise, send our DNS realm name
    //

    OutputTicket.realm = SecData.KdcKerbDnsRealmName();

    //
    // Insert transited realms, if present
    //

    if (NewTransitedInfo.Length != 0)
    {
        STRING TempString;
        KerbErr = KerbUnicodeStringToKerbString(
                    &TempString,
                    &NewTransitedInfo
                    );

        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }

        EncryptedTicket->transited.transited_type = DOMAIN_X500_COMPRESS;
        EncryptedTicket->transited.contents.value = (PUCHAR) TempString.Buffer;
        EncryptedTicket->transited.contents.length = (int) TempString.Length;
    }
    else
    {
        EncryptedTicket->transited.transited_type = DOMAIN_X500_COMPRESS;
        EncryptedTicket->transited.contents.value = (PUCHAR) MIDL_user_allocate(OldTransitedString.Length);

        if (EncryptedTicket->transited.contents.value == NULL)
        {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }

        EncryptedTicket->transited.contents.length = (int) OldTransitedString.Length;
        RtlCopyMemory(
            EncryptedTicket->transited.contents.value,
            OldTransitedString.Buffer,
            OldTransitedString.Length
            );
    }

    //
    // Insert the client addresses. We only update them if the new ticket
    // is forwarded of proxied and the source ticket was forwardable or proxiable
    // - else we copy the old ones
    //

    if ((((TicketFlags & KERB_TICKET_FLAGS_forwarded) != 0) &&
         ((SourceTicketFlags & KERB_TICKET_FLAGS_forwardable) != 0)) ||
        (((TicketFlags & KERB_TICKET_FLAGS_proxy) != 0) &&
         ((SourceTicketFlags & KERB_TICKET_FLAGS_proxiable) != 0)))
    {
        if ((RequestBody->bit_mask & addresses_present) != 0)
        {
            Addresses = RequestBody->addresses;
        }
    }
    else
    {
        if ((SourceEncryptPart->bit_mask & KERB_ENCRYPTED_TICKET_client_addresses_present) != 0)
        {
            Addresses = SourceEncryptPart->KERB_ENCRYPTED_TICKET_client_addresses;
        }
    }

    if (Addresses != NULL)
    {
        EncryptedTicket->KERB_ENCRYPTED_TICKET_client_addresses = Addresses;
        EncryptedTicket->bit_mask |= KERB_ENCRYPTED_TICKET_client_addresses_present;
    }
    else
    {
        EncryptedTicket->KERB_ENCRYPTED_TICKET_client_addresses = NULL;
        EncryptedTicket->bit_mask &= ~KERB_ENCRYPTED_TICKET_client_addresses_present;
    }

    //
    // The authorization data will be added by the caller, so set it
    // to NULL here.
    //

    EncryptedTicket->KERB_ENCRYPTED_TICKET_authorization_data = NULL;

    OutputTicket.ticket_version = KERBEROS_VERSION;
    *NewTicket = OutputTicket;

Cleanup:

    if (!KERB_SUCCESS(KerbErr))
    {
        KdcFreeInternalTicket(&OutputTicket);
    }

    KerbFreeString(&NewTransitedInfo);
    KerbFreeString(&OldTransitedInfo);
    KerbFreeString(&ClientRealm);
    KerbFreeString(&TransitedRealm);

    return (KerbErr);
}

//+-------------------------------------------------------------------------
//
//  Function:   KdcVerifyTgsLogonRestrictions
//
//  Synopsis:   Verifies that a client is allowed to request a TGS ticket
//              by checking logon restrictions.
//
//  Effects:
//
//  Arguments:  ClientName - Name of client to check
//
//  Requires:
//
//  Returns:    KDC_ERR_NONE or a logon restriction error
//
//  Notes:
//
//
//--------------------------------------------------------------------------


KERBERR
KdcCheckTgsLogonRestrictions(
    IN PKERB_INTERNAL_NAME ClientName,
    IN PUNICODE_STRING ClientRealm,
    OUT PKERB_EXT_ERROR pExtendedError
    )
{
    KERBERR Status;
    UNICODE_STRING MappedClientRealm = {0};
    BOOLEAN ClientReferral;
    KDC_TICKET_INFO ClientInfo = {0};
    SAMPR_HANDLE UserHandle = NULL;
    PUSER_INTERNAL6_INFORMATION UserInfo = NULL;
    LARGE_INTEGER LogoffTime;
    NTSTATUS LogonStatus = STATUS_SUCCESS;
    SECPKG_CALL_INFO CallInfo ;

    //
    // If the client is from a different realm, don't bother looking
    // it up - the account won't be here.
    //

    if (!SecData.IsOurRealm(
            ClientRealm
            ))
    {
        return(KDC_ERR_NONE);
    }

    //
    // Normalize the client name
    //

    //
    // Note:  In some cases, attempts to normalize our own client name, e.g. the
    // KDC's name someRealm\FooDc$, will result in recursion as follows :
    //
    // 1. We may need to talk to a GC to normalize the DC's name.
    // 2. We try to get a ticket to a GC from this DC (aka the ClientName below)
    // 3. We check logon restrictions
    // 4. We try to normalize, recurse...
    //
    // We *should* in most cases be able to satisfy the DC lookup internally,
    // unless the DS is just starting up, and replication is firing up.  Assert,
    // so we can determine why the client name is causing recursion in the normalize
    // code path.
    //

    if ( LsaIGetCallInfo( &CallInfo ) )
    {
        if (( CallInfo.Attributes & SECPKG_CALL_RECURSIVE ) &&
            ( ClientName->NameCount == 1) &&
            ( SecData.IsOurMachineName(&ClientName->Names[0])))
        {
            D_DebugLog((DEB_ERROR, "Recursion detected during TGS logon restrictions\n"));
            return (KDC_ERR_NONE);
        }
    }

    Status = KdcNormalize(
                ClientName,
                NULL,
                ClientRealm,
                NULL,
                KDC_NAME_CLIENT,
                FALSE,          // do not restrict user accounts (user2user)
                &ClientReferral,
                &MappedClientRealm,
                &ClientInfo,
                pExtendedError,
                &UserHandle,
                USER_ALL_KERB_CHECK_LOGON_RESTRICTIONS,
                0L,
                &UserInfo,
                NULL            // no group memberships
                );

    if (!KERB_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "KdcCheckTgsLogonRestrictions KLIN(%x) failed to normalize name %#x: ", KLIN(FILENO, __LINE__), Status));
        KerbPrintKdcName(DEB_ERROR,ClientName);
        goto Cleanup;
    }

    Status = KerbCheckLogonRestrictions(
                UserHandle,
                NULL,           // No client address is available
                &UserInfo->I1,
                KDC_RESTRICT_PKINIT_USED | KDC_RESTRICT_IGNORE_PW_EXPIRATION,           // Don't bother checking for password expiration
                &LogoffTime,
                &LogonStatus
                );

    if (!KERB_SUCCESS(Status))
    {
        DebugLog((DEB_WARN,"KLIN (%x) Logon restriction check failed: 0x%x\n",
            KLIN(FILENO, __LINE__),Status));
        //
        //  This is a *very* important error to trickle back.  See 23456 in bug DB
        //
        FILL_EXT_ERROR(pExtendedError, LogonStatus, FILENO, __LINE__);
        goto Cleanup;
    }

Cleanup:

    KerbFreeString( &MappedClientRealm );
    FreeTicketInfo( &ClientInfo );
    SamIFree_UserInternal6Information( UserInfo );

    if (UserHandle != NULL)
    {
        SamrCloseHandle(&UserHandle);
    }

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   KdcBuildReferralInfo
//
//  Synopsis:   Builds the referral information to return to the client.
//              We only return the realm name and no server name
//
//  Effects:
//
//  Arguments:  ReferralRealm - realm to refer client to
//              ReferralInfo - recevies encoded referral info
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KdcBuildReferralInfo(
    IN PUNICODE_STRING ReferralRealm,
    OUT PKERB_PA_DATA_LIST *ReferralInfo
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    PKERB_PA_DATA_LIST ListElem = NULL;
    KERB_PA_SERV_REFERRAL ReferralData = {0};

    //
    // Fill in the unencoded structure.
    //

    KerbErr = KerbConvertUnicodeStringToRealm(
                &ReferralData.referred_server_realm,
                ReferralRealm
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    ListElem = (PKERB_PA_DATA_LIST) MIDL_user_allocate(sizeof(KERB_PA_DATA_LIST));
    if (ListElem == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }
    RtlZeroMemory(ListElem, sizeof(KERB_PA_DATA_LIST));

    ListElem->value.preauth_data_type = KRB5_PADATA_REFERRAL_INFO;

    KerbErr = KerbPackData(
                &ReferralData,
                KERB_PA_SERV_REFERRAL_PDU,
                (PULONG) &ListElem->value.preauth_data.length,
                &ListElem->value.preauth_data.value
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }
    *ReferralInfo = ListElem;
    ListElem = NULL;

Cleanup:

    if (ListElem != NULL)
    {
        if (ListElem->value.preauth_data.value != NULL)
        {
            KdcFreeEncodedData(ListElem->value.preauth_data.value);
        }
        MIDL_user_free(ListElem);
    }

    KerbFreeRealm(&ReferralData.referred_server_realm);
    return(KerbErr);
}


//--------------------------------------------------------------------
//
//  Name:       I_RenewTicket
//
//  Synopsis:   Renews an internal ticket.
//
//  Arguments:  SourceTicket - Source ticket for this request
//              ClientStringName - Client string name
//              ServerStringName - Service string name
//              ServiceName - Name of service for ticket
//              ClientRealm - Realm of client
//              ServiceTicketInfo - Ticket info from service account
//              RequestBody - Body of ticket request
//              NewTicket - Receives new ticket
//              pServerKey - the key to encrypt ticket
//              TicketKey - Receives key used to encrypt the ticket
//
//  Notes:      Validates the ticket, gets the service's current key,
//              and builds the reply.
//
//
//--------------------------------------------------------------------

KERBERR
I_RenewTicket(
    IN PKERB_TICKET SourceTicket,
    IN PUNICODE_STRING ClientStringName,
    IN PUNICODE_STRING ServerStringName,
    IN PKERB_INTERNAL_NAME ServiceName,
    IN PKDC_TICKET_INFO ServiceTicketInfo,
    IN PKERB_KDC_REQUEST_BODY RequestBody,
    IN OPTIONAL PKERB_ENCRYPTION_KEY Subkey,
    OUT PKERB_TICKET NewTicket,
    OUT PKERB_ENCRYPTION_KEY pServerKey,
    OUT PKERB_EXT_ERROR pExtendedError
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    PKERB_ENCRYPTED_TICKET SourceEncryptPart = (PKERB_ENCRYPTED_TICKET) SourceTicket->encrypted_part.cipher_text.value;
    PKERB_ENCRYPTED_TICKET NewEncryptPart = (PKERB_ENCRYPTED_TICKET) NewTicket->encrypted_part.cipher_text.value;
    BOOLEAN NamesEqual = FALSE;
    ULONG CommonEType = KERB_ETYPE_DEFAULT;
    PKERB_ENCRYPTION_KEY pLocalServerKey = NULL;

    TRACE(KDC, I_RenewTicket, DEB_FUNCTION);

    D_DebugLog((DEB_TRACE, "Trying to renew a ticket to "));
    D_KerbPrintKdcName((DEB_TRACE, ServiceName));

    //
    // Make sure the original is renewable.
    //

    if ((KerbConvertFlagsToUlong(&SourceEncryptPart->flags) & KERB_TICKET_FLAGS_renewable) == 0)
    {
        D_DebugLog((DEB_WARN, "KLIN(%x) Attempt made to renew non-renewable ticket\n",
            KLIN(FILENO, __LINE__)));
        KerbErr = KDC_ERR_BADOPTION;
        goto Cleanup;
    }

    //
    // Make sure the source ticket service equals the service from the ticket info
    //

    KerbErr = KerbCompareKdcNameToPrincipalName(
                &SourceTicket->server_name,
                ServiceName,
                &NamesEqual
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    if (!NamesEqual)
    {
        //
        // Make sure we the renewed ticket is for the same service as the original.
        //
        FILL_EXT_ERROR(pExtendedError, STATUS_KDC_INVALID_REQUEST, FILENO, __LINE__);
        KerbErr = KDC_ERR_BADOPTION;
        goto Cleanup;
    }

    //
    // Find the supported crypt system
    //

    KerbErr = KerbFindCommonCryptSystemForSKey(
                RequestBody->encryption_type,
                ServiceTicketInfo->UserAccountControl & USER_USE_DES_KEY_ONLY ?
                    kdc_pMitPrincipalPreferredCryptList : kdc_pPreferredCryptList,
                &CommonEType
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        if (KDC_ERR_ETYPE_NOTSUPP == KerbErr)
        {
            KdcReportKeyError(
                ClientStringName,
                ServerStringName,
                KDC_KEY_ID_RENEWAL_SKEY,
                KDCEVENT_NO_KEY_INTERSECTION_TGS,
                RequestBody->encryption_type,
                ServiceTicketInfo
                );
        }

        DebugLog((DEB_ERROR, "KLIN(%x) failed to find common ETYPE: %#x\n", KLIN(FILENO, __LINE__), KerbErr));
        goto Cleanup;
    }

    //
    // Find the common crypt system.
    //

    KerbErr = KerbFindCommonCryptSystem(
                ServiceTicketInfo->UserAccountControl & USER_USE_DES_KEY_ONLY ?
                    kdc_pMitPrincipalPreferredCryptList : kdc_pPreferredCryptList,
                ServiceTicketInfo->Passwords,
                NULL,
                &pLocalServerKey
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        if (KDC_ERR_ETYPE_NOTSUPP == KerbErr)
        {
            KdcReportKeyError(
                ClientStringName,
                ServerStringName,
                KDC_KEY_ID_RENEWAL_TICKET,
                KDCEVENT_NO_KEY_INTERSECTION_TGS,
                ServiceTicketInfo->UserAccountControl & USER_USE_DES_KEY_ONLY ?
                    kdc_pMitPrincipalPreferredCryptList : kdc_pPreferredCryptList,
                ServiceTicketInfo
                );
        }

        DebugLog((DEB_ERROR, "KLIN(%x) failed to find common ETYPE: %#x\n", KLIN(FILENO, __LINE__), KerbErr));
        goto Cleanup;
    }

    //
    // Build the renewal ticket
    //

    KerbErr = BuildTicketTGS(
                ServiceTicketInfo,
                RequestBody,
                SourceTicket,
                FALSE,          // not referral
                NULL,           // not doing s4u
                CommonEType,
                NewTicket,
                pExtendedError
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        D_DebugLog((DEB_ERROR,
            "KLIN(%x) Failed to build TGS ticket for renewal: 0x%x\n",
            KLIN(FILENO, __LINE__), KerbErr));
        goto Cleanup;
    }

    //
    // BuildTicket puts a random session key in the ticket,
    // so replace it with the one from the source ticket.
    //

    KerbFreeKey(
        &NewEncryptPart->key
        );

    KerbErr = KerbDuplicateKey(
                &NewEncryptPart->key,
                &SourceEncryptPart->key
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    //
    // Insert the auth data into the new ticket.
    //

    //
    // BUG 455049: if the service password changes, this will cause problems
    // because we don't resign the pac.
    //

    KerbErr = KdcInsertAuthorizationData(
                NewEncryptPart,
                pExtendedError,
                (RequestBody->bit_mask & enc_authorization_data_present) ?
                    &RequestBody->enc_authorization_data : NULL,
                SourceEncryptPart,
                NULL,                           // no server info
                NULL,
                NULL,
                NULL,
                NULL,
                Subkey,
                NULL
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR, "KLIN(%x) Failed to insert authorization data: 0x%x\n",
            KLIN(FILENO, __LINE__), KerbErr));
        goto Cleanup;
    }

    KerbErr = KerbDuplicateKey(pServerKey, pLocalServerKey);

Cleanup:

    if (!KERB_SUCCESS(KerbErr))
    {
        KdcFreeInternalTicket(
            NewTicket
            );
    }

    return(KerbErr);
}


//--------------------------------------------------------------------
//
//  Name:       I_Validate
//
//  Synopsis:   Validates a post-dated ticket so that it can be used.
//              This is not implemented.
//
//  Arguments:  pkitSourceTicket    - (in) ticket to be validated
//              pkiaAuthenticator   -
//              pService            - (in) service ticket is for
//              pRealm              - (in) realm service exists in
//              pktrRequest         - (in) holds nonce for new ticket
//              pkdPAData           - (in)
//              pkitTicket          - (out) new ticket
//
//  Notes:      See 3.3 of the Kerberos V5 R5.2 spec
//
//--------------------------------------------------------------------

KERBERR
I_Validate(
    IN PKERB_TICKET SourceTicket,
    IN PKERB_INTERNAL_NAME ServiceName,
    IN PUNICODE_STRING ClientRealm,
    IN PKERB_KDC_REQUEST_BODY RequestBody,
    OUT PKERB_ENCRYPTION_KEY pServerKey,
    OUT PKERB_TICKET NewTicket,
    OUT PKERB_EXT_ERROR pExtendedError
    )
{
    return(KDC_ERR_BADOPTION);
#ifdef notdef
    TRACE(KDC, I_Validate, DEB_FUNCTION);

    HRESULT hr;

    D_DebugLog(( DEB_TRACE, "Trying to validate a ticket to '%ws' for '%ws'...\n",
                pkitSourceTicket->ServerName.accsid.pwszDisplayName,
                pkitSourceTicket->kitEncryptPart.Principal.accsid.pwszDisplayName ));
    PrintRequest( DEB_T_TICKETS, pktrRequest );
    PrintTicket( DEB_T_TICKETS, "Ticket to validate:", pkitSourceTicket );


    if ( (pkitSourceTicket->kitEncryptPart.fTicketFlags &
            (KERBFLAG_POSTDATED | KERBFLAG_INVALID))
         != (KERBFLAG_POSTDATED | KERBFLAG_INVALID) )
    {
        hr = KDC_E_BADOPTION;
    }
    else if (_wcsicmp(pkitSourceTicket->ServerName.accsid.pwszDisplayName,
                     pasService->pwszDisplayName) != 0)
    {
        hr = KDC_E_BADOPTION;
    }
    else
    {
        TimeStamp tsNow, tsMinus, tsPlus;
        GetCurrentTimeStamp( &tsNow );
        tsMinus = tsNow - SkewTime;
        tsPlus = tsNow + SkewTime;
        PrintTime(DEB_TRACE, "Current time: ", tsNow );
        PrintTime(DEB_TRACE, "Past time: ", tsMinus );
        PrintTime(DEB_TRACE, "Future time: ", tsPlus );

        if (pkitSourceTicket->kitEncryptPart.tsStartTime > tsPlus )
            hr = KRB_E_TKT_NYV;
        else if (pkitSourceTicket->kitEncryptPart.tsEndTime < tsMinus )
            hr = KRB_E_TKT_EXPIRED;
        else
        {

            *pkitTicket = *pkitSourceTicket;
            pkitTicket->kitEncryptPart.fTicketFlags &= (~KERBFLAG_INVALID);
            hr = S_OK;
        }
    }
    return(hr);
#endif // notdef
}


//--------------------------------------------------------------------
//
//  Name:       KerbPerformTgsAccessCheck
//
//  Synopsis:   Access-checks the given ticket against the principal
//              the ticket is for.  Part of "this organization" vs.
//              "other organization" logic.
//
//  Arguments:  TicketInfo          ticket
//              SdCount             number of entries in the SecurityDescriptors
//                                  array
//              SecurityDescriptors security descriptors to check against
//              EncryptedTicket     ticket
//              EncryptionType      encryption type associated with ticket
//
//  Notes: A successful check against _any_ of the security descriptors
//         passed in causes the routine to succeed
//
//  Returns:
//
//      KDC_ERR_NONE                - access check succeeded
//      KDC_ERR_POLICY              - access check failed
//
//--------------------------------------------------------------------

KERBERR
KerbPerformTgsAccessCheck(
    IN PKDC_TICKET_INFO TicketInfo,
    IN PUCHAR SecurityDescriptor,
    IN PKERB_ENCRYPTED_TICKET EncryptedTicket,
    IN ULONG EncryptionType,
    OUT NTSTATUS * pStatus
    )
{
    KERBERR KerbErr;
    KDC_AUTHZ_INFO AuthzInfo = {0};
    KDC_AUTHZ_GROUP_BUFFERS InfoToFree = {0};
    AUTHZ_ACCESS_REPLY Reply = {0};
    OBJECT_TYPE_LIST TypeList ={0};
    AUTHZ_CLIENT_CONTEXT_HANDLE hClientContext = NULL;
    AUTHZ_ACCESS_REQUEST Request = {0};
    DWORD AccessMask = 0;
    LUID ZeroLuid = {0,0};
    DWORD Error = ERROR_ACCESS_DENIED;
    BOOLEAN OtherOrgSidFound = FALSE;

    *pStatus = STATUS_SUCCESS;

    KerbErr = KdcGetSidsFromTgt(
                  EncryptedTicket,
                  NULL,          // no key for encrypted tgt.
                  EncryptionType,
                  TicketInfo,
                  &AuthzInfo,
                  &InfoToFree,
                  pStatus
                  );

    if ( !KERB_SUCCESS( KerbErr ))
    {
        DebugLog((DEB_ERROR, "KdcGetSidsFromTgt in KerbPerformTgsAccessCheck failed %x\n", KerbErr));
        goto Cleanup;
    }

    //
    // Per the specification, the access check is only performed if the
    // "other org" SID is in the list
    //

    for ( ULONG i = 0 ; i < AuthzInfo.SidCount ; i++ )
    {
        if ( RtlEqualSid( AuthzInfo.SidAndAttributes[i].Sid, GlobalOtherOrganizationSid ))
        {
            OtherOrgSidFound = TRUE;
            break;
        }
    }

    if ( !OtherOrgSidFound )
    {
        KerbErr = KDC_ERR_NONE;
        goto Cleanup;
    }

    if (!AuthzInitializeContextFromSid(
             AUTHZ_SKIP_TOKEN_GROUPS, // take the SIDs as they are
             AuthzInfo.SidAndAttributes[0].Sid, // userid is first element in array
             KdcAuthzRM,
             NULL,
             ZeroLuid,
             &AuthzInfo,
             &hClientContext
             ))
    {
        DebugLog((DEB_ERROR, "AuthzInitializeContextFromSid() failed in KerbPerformTgsAccessCheck%x\n", GetLastError()));
        KerbErr = KDC_ERR_POLICY;
        *pStatus = STATUS_AUTHENTICATION_FIREWALL_FAILED;
        goto Cleanup;
    }

    //
    // Perform the access check
    //

    TypeList.Level = ACCESS_OBJECT_GUID;
    TypeList.ObjectType = &GUID_A_SECURED_FOR_CROSS_ORGANIZATION;
    TypeList.Sbz = 0;

    Request.DesiredAccess = ACTRL_DS_CONTROL_ACCESS;
    Request.ObjectTypeList = &TypeList;
    Request.ObjectTypeListLength = 1;
    Request.OptionalArguments = NULL;
    Request.PrincipalSelfSid = NULL;

    Reply.ResultListLength = 1;    // all or nothing w.r.t. access check.
    Reply.GrantedAccessMask = &AccessMask;
    Reply.Error = &Error;

    if (!AuthzAccessCheck(
             0,
             hClientContext,
             &Request,
             NULL, // TBD:  add audit
             SecurityDescriptor,
             NULL,
             NULL,
             &Reply,
             NULL // don't cache result?  Check to see if optimal.
             ))
    {
        DebugLog((DEB_ERROR, "AuthzAccessCheck() failed in KerbPerformTgsAccessCheck%x\n", GetLastError()));
        KerbErr = KDC_ERR_POLICY;
        *pStatus = STATUS_AUTHENTICATION_FIREWALL_FAILED;
    }
    else if ( (*Reply.Error) != ERROR_SUCCESS )
    {
        DebugLog((DEB_ERROR, "CrossOrg authz AC failed %x \n",(*Reply.Error)));
        KerbErr = KDC_ERR_POLICY;
        *pStatus = STATUS_AUTHENTICATION_FIREWALL_FAILED;
    }
    else
    {
        KerbErr = KDC_ERR_NONE;
    }

Cleanup:

    if ( hClientContext != NULL )
    {
        AuthzFreeContext(hClientContext);
    }

    KdcFreeAuthzInfo( &InfoToFree );

    return KerbErr;
}

#ifdef ROGUE_DC
KERBERR
KdcInstrumentRogueCrealm(
    IN OUT PKERB_ENCRYPTED_TICKET EncryptedTicket
    )
{
    KERBERR KerbErr;
    DWORD dwType;
    DWORD cbData = 0;
    PCHAR Buffer;
    PCHAR Value = NULL;
    ULONG NameType;

    UNICODE_STRING ClientName = {0};
    UNICODE_STRING DomainName = {0};
    UNICODE_STRING EmailNameU = {0};

    PCHAR EmailName = NULL;
    PCHAR NewCrealm = NULL;

    //
    // Optimization: no "rogue" key in registry - nothing for us to do
    //

    if ( hKdcRogueKey == NULL )
    {
        return KDC_ERR_NONE;
    }

    //
    // Build an e-mail name of the client to look up mapping for in the registry
    //

    KerbErr = KerbConvertPrincipalNameToString(
                  &ClientName,
                  &NameType,
                  &EncryptedTicket->client_name
                  );

    if ( !KERB_SUCCESS( KerbErr )) {

        DebugLog((DEB_ERROR, "ROGUE: KerbConvertPrincipalNameToString failed\n"));
        goto Cleanup;
    }

    KerbErr = KerbConvertRealmToUnicodeString(
                  &DomainName,
                  &EncryptedTicket->client_realm
                  );

    if ( !KERB_SUCCESS( KerbErr )) {

        DebugLog((DEB_ERROR, "ROGUE: KerbConvertRealmToUnicodeString failed\n"));
        goto Cleanup;
    }

    KerbErr = KerbBuildEmailName(
                  &DomainName,
                  &ClientName,
                  &EmailNameU
                  );

    if ( !KERB_SUCCESS( KerbErr )) {

        DebugLog((DEB_ERROR, "ROGUE: KerbBuildEmailName failed\n"));
        goto Cleanup;
    }

    EmailName = KerbAllocUtf8StrFromUnicodeString( &EmailNameU );

    if ( EmailName == NULL )
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    //
    // See if this realm is in the substitute list in the registry
    //

    if ( ERROR_SUCCESS != RegQueryValueExA(
                              hKdcRogueKey,
                              EmailName,
                              NULL,
                              &dwType,
                              (PBYTE)Value,
                              &cbData ) ||
         dwType != REG_MULTI_SZ ||
         cbData <= 1 )
    {
        DebugLog((DEB_ERROR, "ROGUE: Error reading from registry\n"));
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    SafeAllocaAllocate( Value, cbData );

    if ( Value == NULL )
    {
        DebugLog((DEB_ERROR, "ROGUE: Out of memory allocating substitution buffer\n" ));
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    if ( ERROR_SUCCESS != RegQueryValueExA(
                              hKdcRogueKey,
                              EmailName,
                              NULL,
                              &dwType,
                              (PBYTE)Value,
                              &cbData ) ||
         dwType != REG_MULTI_SZ ||
         cbData <= 1 )
    {
        DebugLog((DEB_ERROR, "ROGUE: Error reading from registry\n"));
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    DebugLog((DEB_ERROR, "ROGUE: Substituting the crealm for %wZ\n", &EmailName));

    Buffer = Value;

    while ( *Buffer != '\0' )
    {
        if ( 0 == _strnicmp( Buffer, "crealm:", sizeof( "crealm" ) - 1 ))
        {
            Buffer += strlen( "crealm:" );

            if ( *Buffer != '\0' )
            {
                DebugLog((DEB_ERROR, "ROGUE: Replacing crealm for %wZ with %s\n", &EmailName, Buffer ));
                NewCrealm = Buffer;
            }
        }

        //
        // Move to the next line
        //

        while (*Buffer++ != '\0');
    }

    if ( NewCrealm != NULL )
    {
        KERB_REALM NewCrealmCopy;

        KerbErr = KerbDuplicateRealm(
                      &NewCrealmCopy,
                      NewCrealm
                      );

        if ( !KERB_SUCCESS( KerbErr ))
        {
            DebugLog((DEB_ERROR, "ROGUE: Out of memory inside KdcInstrumentRogueCrealm\n" ));
            goto Cleanup;
        }

        KerbFreeRealm( &EncryptedTicket->client_realm );
        EncryptedTicket->client_realm = NewCrealmCopy;
    }

Cleanup:

    MIDL_user_free( EmailName );
    KerbFreeString( &ClientName );
    KerbFreeString( &DomainName );
    KerbFreeString( &EmailNameU );
    SafeAllocaFree( Value );

    return KerbErr;
}
#endif

//--------------------------------------------------------------------
//
//  Name:       I_GetTGSTicket
//
//  Synopsis:   Gets an internal ticket using a KDC ticket (TGT).
//
//  Arguments:  SourceTicket - TGT for the client
//              ClientStringName - Client string name
//              ServerStringName - Server string name
//              ServiceName - Service to get a ticket to
//              RequestBody - Body of KDC request message
//              ServiceTicketInfo - Ticket info for the service of the
//                      source ticket
//              TicketEncryptionKey - If present, then this is a
//                      enc_tkt_in_skey request and the PAC should be
//                      encrypted with this key.
//              NewTicket - Receives newly created ticket
//              pServerKey - Key to encrypt ticket
//              ReplyPaData - Contains any PA data to put in the reply
//
//  Notes:      See GetTGSTicket.
//
//
//--------------------------------------------------------------------

KERBERR
I_GetTGSTicket(
    IN PKERB_TICKET SourceTicket,
    IN PUNICODE_STRING ClientStringName,
    IN PUNICODE_STRING ServerStringName,
    IN PKERB_INTERNAL_NAME ServiceName,
    IN PUNICODE_STRING RequestRealm,
    IN PKERB_KDC_REQUEST_BODY RequestBody,
    IN PKDC_TICKET_INFO ServiceTicketInfo,
    IN OPTIONAL PKERB_ENCRYPTION_KEY TicketEncryptionKey,
    IN PKDC_S4U_TICKET_INFO S4UTicketInfo,
    IN OPTIONAL PKERB_ENCRYPTION_KEY Subkey,
    OUT PKERB_TICKET Ticket,
    OUT PKERB_ENCRYPTION_KEY pServerKey,
    OUT PKERB_PA_DATA_LIST * ReplyPaData,
    OUT PKERB_EXT_ERROR pExtendedError,
    OUT OPTIONAL PS4U_DELEGATION_INFO* S4UDelegationInfo
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    UNICODE_STRING LocalServiceName;
    UNICODE_STRING ServiceRealm = {0};
    UNICODE_STRING ClientRealm = {0};
    BOOLEAN Referral = FALSE;
    KERB_ENCRYPTED_TICKET EncryptedTicket = {0};
    PKERB_ENCRYPTED_TICKET OutputEncryptedTicket = NULL;
    PKERB_ENCRYPTED_TICKET SourceEncryptPart = NULL;
    PKERB_INTERNAL_NAME TargetPrincipal = ServiceName;
    KERB_TICKET NewTicket = {0};
    PKERB_ENCRYPTION_KEY pKeyToUse = NULL;
    PKERB_ENCRYPTION_KEY OldServerKey;
    KDC_TICKET_INFO OldServiceTicketInfo = {0};
    SID_AND_ATTRIBUTES_LIST S4UClientGroupMembership = {0};
    PUSER_INTERNAL6_INFORMATION S4UClientUserInfo = NULL;
    BOOLEAN bRestrictUserAccounts = LsaINoMoreWin2KDomain() && (TicketEncryptionKey ? FALSE : TRUE);
    PUSER_INTERNAL6_INFORMATION LocalUserInfo = NULL;
    ULONG NameFlags = KDC_NAME_FOLLOW_REFERRALS | KDC_NAME_CHECK_GC;

    ULONG KdcOptions = 0;
    BOOLEAN GetInitialS4UPac = FALSE;
    PKERB_ENCRYPTION_KEY pServerKeyLocal = NULL;
    ULONG CommonEType = KERB_ETYPE_DEFAULT;

    TRACE(KDC, I_GetTGSTicket, DEB_FUNCTION);

    //
    // Store away the encrypted ticket from the output ticket to
    // assign it at the end.
    //
    SourceEncryptPart = (PKERB_ENCRYPTED_TICKET) SourceTicket->encrypted_part.cipher_text.value;
    OutputEncryptedTicket = (PKERB_ENCRYPTED_TICKET) Ticket->encrypted_part.cipher_text.value;

    NewTicket.encrypted_part.cipher_text.value = (PUCHAR) &EncryptedTicket;



    KerbErr = KerbConvertRealmToUnicodeString(
                   &ClientRealm,
                   &SourceEncryptPart->client_realm
                   );

    if (!KERB_SUCCESS( KerbErr ))
    {
        goto Cleanup;
    }


    //
    // Copy the space for flags from the real destination.
    //

    EncryptedTicket.flags = OutputEncryptedTicket->flags;

    LocalServiceName.Buffer = NULL;

    D_DebugLog((DEB_T_PAPI, "I_GetTGSTicket [entering] trying to build a new ticket\n"));
    D_KerbPrintKdcName((DEB_T_PAPI, ServiceName));


    KdcOptions = KerbConvertFlagsToUlong( &RequestBody->kdc_options );
    if (KdcOptions & (KERB_KDC_OPTIONS_unused7 |
                        KERB_KDC_OPTIONS_reserved |
                        KERB_KDC_OPTIONS_unused9) )
    {
        DebugLog(( DEB_ERROR,"KLIN(%x) Bad options in TGS request: 0x%x\n",
            KLIN(FILENO, __LINE__), KdcOptions ));
        KerbErr = KDC_ERR_BADOPTION;
        goto Cleanup;
    }

    //
    // See if we're getting a service ticket to a UPN, and alter name flags accordingly.
    //
       
    //
    // KRB_NT_SRV_HST - This is a host/server name - 
    //
    // KRB_NT_ENTERPRISE_PRINCIPAL  - UPN, a user principal is calling s4uself, or using a UPN as a target.
    //

    NameFlags |= ((ServiceName->NameType == KRB_NT_ENTERPRISE_PRINCIPAL)  ? KDC_NAME_UPN_TARGET : KDC_NAME_SERVER);
    

    //
    // Verify this account is allowed to issue tickets.
    //

    if ((ServiceTicketInfo->UserId != DOMAIN_USER_RID_KRBTGT) &&
        ((ServiceTicketInfo->UserAccountControl & USER_INTERDOMAIN_TRUST_ACCOUNT) == 0))
    {
        D_DebugLog((DEB_ERROR,"Trying to make a TGS request with a ticket to %wZ\n",
            &ServiceTicketInfo->AccountName ));

        KerbErr = KRB_AP_ERR_NOT_US;
        goto Cleanup;
    }

    //
    // Copy the ticket info into the old structure. It will be replaced with
    // new info from Normalize.
    //

    OldServiceTicketInfo = *ServiceTicketInfo;
    RtlZeroMemory(
        ServiceTicketInfo,
        sizeof(KDC_TICKET_INFO)
        );

    D_DebugLog((DEB_T_U2U, "I_GetTGSTicket requesting u2u? %s\n", KdcOptions & KERB_KDC_OPTIONS_enc_tkt_in_skey ? "TRUE" : "FALSE"));

    KerbErr = KdcNormalize(
                TargetPrincipal,
                NULL,
                RequestRealm,
                &ClientRealm,   
                NameFlags,
                bRestrictUserAccounts,  // restrict user accounts (user2user)
                &Referral,
                &ServiceRealm,
                ServiceTicketInfo,
                pExtendedError,
                NULL,                   // no user handle
                USER_ALL_SECURITYDESCRIPTOR, // for KerbPerformTgsAccessCheck
                bRestrictUserAccounts ? USER_EXTENDED_FIELD_SPN : 0,
                &LocalUserInfo,
                NULL
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_WARN, "KLIN(%x) failed to normalize %#x, ServiceName ", KLIN(FILENO, __LINE__), KerbErr));
        KerbPrintKdcName(DEB_WARN, ServiceName);
        goto Cleanup;
    }

    if (ServiceTicketInfo != NULL)
    {
        //
        // If a service account is marked as disabled, try NTLM.  This
        // prevents a large number of problems where the presense of a disabled
        // computer account in our domain ends up hosing authentication to
        // the "moved" or identical computer account in another forest.
        //

        if ((ServiceTicketInfo->UserId != DOMAIN_USER_RID_KRBTGT) &&
            (ServiceTicketInfo->UserAccountControl & USER_ACCOUNT_DISABLED) != 0)
        {
            KerbErr = KDC_ERR_S_PRINCIPAL_UNKNOWN;
            D_DebugLog((DEB_WARN, "KLIN(%x) Failed to normalize, account is disabled ",
                KLIN(FILENO, __LINE__)));
            FILL_EXT_ERROR_EX(pExtendedError, STATUS_ACCOUNT_DISABLED, FILENO, __LINE__);
            goto Cleanup;
        }
    }

    //
    //  S4UToSelf
    //
    // If the client name is in our realm, verify client
    // identity and build the PAC for the client.  Also make sure
    // the requestor is actually asking for a service ticket to himself,
    // and not some other arbitrary service.
    //
    if (( S4UTicketInfo->Flags & TI_S4USELF_INFO ) != 0)
    {
        if (Referral)
        {
            if ((S4UTicketInfo->Flags & TI_REQUESTOR_THIS_REALM) != 0)
            {
                //
                // The TGT's client is from this realm, but we're referring.
                // The target's not in the same realm as the requesting service
                // indicating an attempt to bypass the protocol.
                //
                DebugLog((DEB_ERROR, "S4USelf requestor realm != service realm\n"));
                DebugLog((DEB_ERROR, "TGT - %wZ\n", S4UTicketInfo->RequestorServiceRealm));
                DebugLog((DEB_ERROR, "Service Realm - %wZ\n", &ServiceRealm));
                DsysAssert(FALSE);
                KerbErr = KRB_AP_ERR_BADMATCH;
                goto Cleanup;
            }
        }
        else
        {
            S4UTicketInfo->Flags |= TI_TARGET_OUR_REALM;

            //
            // The client of the TGT and the SPN are in the same realm.  Make
            // sure they're the same account.
            //
            if ((S4UTicketInfo->Flags & TI_REQUESTOR_THIS_REALM) != 0)
            {
                if (S4UTicketInfo->RequestorTicketInfo.UserId != ServiceTicketInfo->UserId)
                {
                    DebugLog((DEB_ERROR, "S4U requestor != target SPN\n"));
                    DebugLog((DEB_ERROR, "Requestor %p, Target %p\n", &S4UTicketInfo->RequestorTicketInfo, &ServiceTicketInfo));
                    DsysAssert(FALSE);
                    KerbErr = KRB_AP_ERR_BADMATCH;
                    goto Cleanup;
                }
            }
            else
            {
                //
                // The TGTs client is from another realm, but the SPN's in this one
                // fail - someone's tinkering w/ the protocol.
                //
                DebugLog((DEB_ERROR, "S4USelf requestor realm != service realm\n"));
                DebugLog((DEB_ERROR, "TGT - %wZ\n", S4UTicketInfo->RequestorServiceRealm));
                DebugLog((DEB_ERROR, "Service Realm - %wZ\n", &ServiceRealm));
                DsysAssert(FALSE);
                KerbErr = KRB_AP_ERR_BADMATCH;
                goto Cleanup;
            }
        }

        //
        // If we're requesting S4USelf at the client realm, then
        // we'll need to generate a PAC for that client.
        //
        if (SecData.IsOurRealm(&S4UTicketInfo->PACCRealm))
        {
            //
            // Normalize the client name, and get the info we need to
            // generate a PAC.
            //
            KerbErr =  KdcGetS4UTicketInfo(
                            S4UTicketInfo,
                            &OldServiceTicketInfo, // tgt's account info.
                            &S4UClientUserInfo,
                            &S4UClientGroupMembership,
                            pExtendedError
                            );

            if (!KERB_SUCCESS(KerbErr))
            {
                DebugLog((DEB_ERROR, "KdcGetS4UTicketINfo failed - %x\n", KerbErr));
                goto Cleanup;
            }

            GetInitialS4UPac = TRUE;
        }
    }

    //
    // We're doing S4UProxy.  Make sure the target service account is in 
    // our realm.  This is for .Net only, and we expect a xrealm sol'n
    // in the Longhorn release.
    //
    if ((S4UTicketInfo->Flags & TI_S4UPROXY_INFO ) != 0)
    {
        if ( Referral )
        {
            DebugLog((DEB_ERROR, "Trying to do S4UProxy to another realm %wZ\n", &ServiceRealm )); 
            FILL_EXT_ERROR_EX2(pExtendedError, STATUS_CROSSREALM_DELEGATION_FAILURE, FILENO, __LINE__);
            KerbErr = KDC_ERR_POLICY;
            goto Cleanup;
        }

        S4UTicketInfo->Flags |= TI_TARGET_OUR_REALM;
    }
    else if ( !Referral &&
         LocalUserInfo &&
         LocalUserInfo->I1.SecurityDescriptor.SecurityDescriptor &&
         LsaINoMoreWin2KDomain() &&
         ( ServiceTicketInfo->UserAccountControl & USER_INTERDOMAIN_TRUST_ACCOUNT ) == 0 )
    {
        KERB_ENCRYPTED_TICKET * ETicket = (PKERB_ENCRYPTED_TICKET)SourceTicket->encrypted_part.cipher_text.value;

        if ( ETicket->bit_mask & KERB_ENCRYPTED_TICKET_authorization_data_present )
        {
            NTSTATUS Status = STATUS_SUCCESS;

            //
            // If there is no authorization data, no access check is possible
            //

            KerbErr = KerbPerformTgsAccessCheck(
                          &OldServiceTicketInfo,
                          LocalUserInfo->I1.SecurityDescriptor.SecurityDescriptor,
                          ETicket,
                          SourceTicket->encrypted_part.encryption_type,
                          &Status
                          );

            if ( !KERB_SUCCESS( KerbErr ))
            {
                if ( KerbErr == KDC_ERR_POLICY &&
                     ( Status == STATUS_AUTHENTICATION_FIREWALL_FAILED ||
                       Status == STATUS_DOMAIN_TRUST_INCONSISTENT ))
                {
                    FILL_EXT_ERROR_EX2( pExtendedError, Status, FILENO, __LINE__ );
                }

                goto Cleanup;
            }
        }
    }

    //
    // Find the supported crypt system.
    //

    KerbErr = KerbFindCommonCryptSystemForSKey(
                RequestBody->encryption_type,
                ServiceTicketInfo->UserAccountControl & USER_USE_DES_KEY_ONLY ?
                    kdc_pMitPrincipalPreferredCryptList : kdc_pPreferredCryptList,
                &CommonEType
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        if (KDC_ERR_ETYPE_NOTSUPP == KerbErr)
        {
            KdcReportKeyError(
                ClientStringName,
                ServerStringName,
                KDC_KEY_ID_TGS_SKEY,
                KDCEVENT_NO_KEY_INTERSECTION_TGS,
                RequestBody->encryption_type,
                ServiceTicketInfo
                );
        }

        DebugLog((DEB_ERROR, "KLIN(%x) failed to find common ETYPE: %#x\n", KLIN(FILENO, __LINE__), KerbErr));

        goto Cleanup;
    }

    //
    // If this isn't an interdomain trust account, go ahead and issue a normal
    // ticket.
    //

    if ((ServiceTicketInfo->UserAccountControl & USER_INTERDOMAIN_TRUST_ACCOUNT) == 0)
    {
        //
        // Find the common crypt system.
        //

        KerbErr = KerbFindCommonCryptSystem(
                    ServiceTicketInfo->UserAccountControl & USER_USE_DES_KEY_ONLY ?
                        kdc_pMitPrincipalPreferredCryptList : kdc_pPreferredCryptList,
                    ServiceTicketInfo->Passwords,
                    NULL,
                    &pServerKeyLocal
                    );

        if (!KERB_SUCCESS(KerbErr))
        {
            if (KDC_ERR_ETYPE_NOTSUPP == KerbErr)
            {
                KdcReportKeyError(
                    ClientStringName,
                    ServerStringName,
                    KDC_KEY_ID_TGS_TICKET,
                    KDCEVENT_NO_KEY_INTERSECTION_TGS,
                    ServiceTicketInfo->UserAccountControl & USER_USE_DES_KEY_ONLY ?
                        kdc_pMitPrincipalPreferredCryptList : kdc_pPreferredCryptList,
                    ServiceTicketInfo
                    );
            }

            DebugLog((DEB_ERROR, "KLIN(%x) failed to find common ETYPE: %#x\n", KLIN(FILENO, __LINE__), KerbErr));
            goto Cleanup;
        }

        //
        // Check whether service is interactive, 'cause you can't
        // get a ticket to an interactive service.
        //
        KerbErr = BuildTicketTGS(
                    ServiceTicketInfo,
                    RequestBody,
                    SourceTicket,
                    Referral,
                    S4UTicketInfo,
                    CommonEType,
                    &NewTicket,
                    pExtendedError
                    );

        if (!KERB_SUCCESS(KerbErr))
        {
            D_DebugLog((DEB_ERROR,"KLIN(%x) Failed to build TGS ticket for %wZ : 0x%x\n",
                    KLIN(FILENO, __LINE__), &LocalServiceName, KerbErr ));
            goto Cleanup;
        }
    }
    else
    {
        //
        // Need to build a referal ticket.
        //

        D_DebugLog(( DEB_T_TICKETS, "GetTGSTicket: referring to domain '%wZ'\n",
                                        &ServiceTicketInfo->AccountName ));

        //
        // Verify that if the trust is not transitive, the client is from
        // this realm.  
        // Also verify that if we came in through a non - transitive trust,
        // we don't allow a referral.
        //

        SourceEncryptPart =(PKERB_ENCRYPTED_TICKET) SourceTicket->encrypted_part.cipher_text.value;

        if ((  ServiceTicketInfo->UserId != DOMAIN_USER_RID_KRBTGT ) &&
            (( ServiceTicketInfo->fTicketOpts & AUTH_REQ_TRANSITIVE_TRUST ) == 0))
        {
            if (!SecData.IsOurRealm(&SourceEncryptPart->client_realm))
            {
                //
                // One special case here, for S4U.  Allow the hop back to our
                // trusting realm.
                //
                if ((S4UTicketInfo->Flags & TI_S4USELF_INFO) != 0)
                { 
                    if (!RtlEqualUnicodeString(&ClientRealm, &ServiceTicketInfo->AccountName, TRUE ))
                    {
                        DebugLog((DEB_WARN,"S4U Client from realm %s attempted to access non transitve trust to %wZ : illegal\n",
                                    SourceEncryptPart->client_realm,
                                    &ServiceTicketInfo->AccountName
                                    ));
                                
                        KerbErr = KDC_ERR_PATH_NOT_ACCEPTED;
                    }                                       
                }
                else
                {
                    DebugLog((DEB_WARN,"Client from realm %s attempted to access non transitve trust to %wZ : illegal\n",
                        SourceEncryptPart->client_realm,
                        &ServiceTicketInfo->AccountName
                        ));
    
                    KerbErr = KDC_ERR_PATH_NOT_ACCEPTED;
                }
            }
        }

        //
        // Verify that the trust for the client is transitive as well, if it isn't
        // from this domain. This means that if the source ticket trust isn't
        // transitive, then this ticket can't be used to get further
        // tgt's, in any realm.
        //
        //  e.g. the TGT from client comes from a domain w/ which we don't
        //  have transitive trust.
        //

        if (((OldServiceTicketInfo.fTicketOpts & AUTH_REQ_TRANSITIVE_TRUST) == 0) &&
            (OldServiceTicketInfo.UserId != DOMAIN_USER_RID_KRBTGT))
        {
            if ((S4UTicketInfo->Flags & TI_S4USELF_INFO) != 0)
            { 
                if (!RtlEqualUnicodeString(&ClientRealm, &OldServiceTicketInfo.AccountName, TRUE ))
                {
                    DebugLog((DEB_WARN,"TGT S4U Client from realm %s attempted to access non transitve trust to %wZ : illegal\n",
                              SourceEncryptPart->client_realm,
                              &OldServiceTicketInfo.AccountName
                              ));

                    KerbErr = KDC_ERR_PATH_NOT_ACCEPTED;
                }                                       
            }
            else
            {
                DebugLog((DEB_WARN,"TGT Client from realm %s attempted to access non transitve trust to %wZ : illegal\n",
                          SourceEncryptPart->client_realm,
                          &OldServiceTicketInfo.AccountName
                          ));

                KerbErr = KDC_ERR_PATH_NOT_ACCEPTED;
            }
        }

        //
        //   This is probably not a common error, but could
        //   indicate a configuration problem, so log an explicit
        //   error.  See bug 87879.
        //
        if (KerbErr == KDC_ERR_PATH_NOT_ACCEPTED)
        {

           if (ClientRealm.Buffer != NULL )
           {
              ReportServiceEvent(
                 EVENTLOG_ERROR_TYPE,
                 KDCEVENT_FAILED_TRANSITIVE_TRUST,
                 0,                              // no raw data
                 NULL,                   // no raw data
                 2,                              // number of strings
                 ClientRealm.Buffer,
                 ServiceTicketInfo->AccountName.Buffer
                 );
           }

           KerbErr = KDC_ERR_PATH_NOT_ACCEPTED;
           goto Cleanup;
        }

        //
        // Find the preferred crypt system
        //

        KerbErr = KerbFindCommonCryptSystem(
                    ServiceTicketInfo->UserAccountControl & USER_USE_DES_KEY_ONLY ?
                        kdc_pMitPrincipalPreferredCryptList : kdc_pPreferredCryptList,
                    ServiceTicketInfo->Passwords,
                    NULL,
                    &pServerKeyLocal
                    );

        if (!KERB_SUCCESS(KerbErr))
        {
            if (KDC_ERR_ETYPE_NOTSUPP == KerbErr)
            {
                KdcReportKeyError(
                    ClientStringName,
                    ServerStringName,
                    KDC_KEY_ID_TGS_REFERAL_TICKET,
                    KDCEVENT_NO_KEY_INTERSECTION_TGS,
                    ServiceTicketInfo->UserAccountControl & USER_USE_DES_KEY_ONLY ?
                        kdc_pMitPrincipalPreferredCryptList : kdc_pPreferredCryptList,
                    ServiceTicketInfo
                    );
            }

            DebugLog((DEB_ERROR, "KLIN(%x) failed to find common ETYPE: 0x%x\n", KLIN(FILENO, __LINE__), KerbErr));
            goto Cleanup;
        }

        KerbErr = BuildTicketTGS(
                    ServiceTicketInfo,
                    RequestBody,
                    SourceTicket,
                    TRUE,
                    S4UTicketInfo,
                    CommonEType,
                    &NewTicket,
                    pExtendedError
                    );

        if (!KERB_SUCCESS(KerbErr))
        {
            D_DebugLog((DEB_ERROR, "KLIN(%x) Failed to build TGS ticket for %wZ : 0x%x\n", KLIN(FILENO, __LINE__), &ServiceTicketInfo->AccountName, KerbErr));
            goto Cleanup;
        }

        //
        // If this is a referral/canonicaliztion, return the target realm
        //

        if (Referral && ((KdcOptions & KERB_KDC_OPTIONS_name_canonicalize) != 0))
        {
            D_DebugLog((DEB_TRACE,"Building referral info for realm %wZ\n",
                        &ServiceRealm ));
            KerbErr = KdcBuildReferralInfo(
                        &ServiceRealm,
                        ReplyPaData
                        );
            if (!KERB_SUCCESS(KerbErr))
            {
                goto Cleanup;
            }
        }
    }

    //
    // Here we're selecting a key with which to validate the PAC checksum
    // before we copy it from the TGT (or evidence ticket) into the new
    // service ticket or cross realm tgt.
    //

    //
    // 3 choices -
    //
    // 1.   U2U uses the session key in the accompanying addt'l ticket.
    //
    // 2.   S4UProxy uses the requestor's key if we're the requestor's kdc (e.g.
    //      the first request of s4uproxy).  Otherwise, it's just the xrealm
    //      krbtgt key.
    //
    // 3.   Everything elses uses the krbtgt key, as the tgt's PAC is only
    //      signed w/ that key.
    //

    if (( S4UTicketInfo->Flags & TI_PRXY_REQUESTOR_THIS_REALM ) != 0)
    {
        D_DebugLog((DEB_T_KEY, "I_GetTGSTicket s4u prxy OldServerKey\n"));

        OldServerKey = &S4UTicketInfo->EvidenceTicketKey;
    }
    else
    {
        D_DebugLog((DEB_T_KEY, "I_GetTGSTicket OldServiceTicketInfo OldServerKey\n"));

        OldServerKey = KerbGetKeyFromList(
                        OldServiceTicketInfo.Passwords,
                        SourceTicket->encrypted_part.encryption_type
                        );
    }

    DsysAssert(OldServerKey != NULL);

    if (OldServerKey == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    if (ARGUMENT_PRESENT(TicketEncryptionKey))
    {
        pKeyToUse = TicketEncryptionKey;
        DebugLog((DEB_T_U2U, "I_GetTGSTicket signing PAC with u2u session key\n"));
    }
    else
    {
        DebugLog((DEB_T_KEY, "I_GetTGSTicket signing PAC with server key\n"));
        pKeyToUse = pServerKeyLocal;
    }

    //
    // Insert the auth data into the new ticket.
    //

    if ( GetInitialS4UPac )
    {
        KerbErr = KdcInsertInitialS4UAuthorizationData(
                        &EncryptedTicket,
                        pExtendedError,
                        S4UTicketInfo,
                        S4UClientUserInfo,
                        &S4UClientGroupMembership,
                        ((ServiceTicketInfo->UserId != DOMAIN_USER_RID_KRBTGT) &&
                            ((ServiceTicketInfo->UserAccountControl & USER_INTERDOMAIN_TRUST_ACCOUNT) == 0)),
                        pKeyToUse
                        );
    }
    else
    {
        KerbErr = KdcInsertAuthorizationData(
                    &EncryptedTicket,
                    pExtendedError,
                    (RequestBody->bit_mask & enc_authorization_data_present) ?
                        &RequestBody->enc_authorization_data : NULL,
                    (PKERB_ENCRYPTED_TICKET) SourceTicket->encrypted_part.cipher_text.value,
                    ServiceTicketInfo,     // Ticket info for the target service
                    S4UTicketInfo,
                    &OldServiceTicketInfo, // krbtgt account used in TGS_REQ (could be cross realm).
                    OldServerKey,
                    pKeyToUse,
                    Subkey,
                    S4UDelegationInfo
                    );
    }

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR, "KLIN(%x) Failed to insert authorization data: 0x%x\n", KLIN(FILENO, __LINE__), KerbErr));
        goto Cleanup;
    }

    KerbErr = KerbDuplicateKey(pServerKey, pKeyToUse);
    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR, "KLIN(%x) Failed to insert duplicate key: 0x%x\n", KLIN(FILENO, __LINE__), KerbErr));
        goto Cleanup;
    }

#ifdef ROGUE_DC
    KerbErr = KdcInstrumentRogueCrealm(
                  &EncryptedTicket
                  );
    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR, "KLIN(%x) Failed to instrument a rogue crealm: 0x%x\n", KLIN(FILENO, __LINE__), KerbErr));
        KerbErr = KDC_ERR_NONE;
    }
#endif

    *Ticket = NewTicket;
    *OutputEncryptedTicket = EncryptedTicket;
    Ticket->encrypted_part.cipher_text.value = (PUCHAR) OutputEncryptedTicket;

Cleanup:

    //
    // Now free the original service ticket info (which was for the KDC) so
    // we can get it for the real service
    //

    FreeTicketInfo(
        &OldServiceTicketInfo
        );

    SamIFreeSidAndAttributesList(&S4UClientGroupMembership);
    SamIFree_UserInternal6Information( S4UClientUserInfo );
    SamIFree_UserInternal6Information( LocalUserInfo );

    if (!KERB_SUCCESS(KerbErr))
    {
        KdcFreeInternalTicket(
            &NewTicket
            );
    }
    KerbFreeString(
        &ServiceRealm
        );

    KerbFreeString(
        &ClientRealm
        );

    D_DebugLog((DEB_T_PAPI, "I_GetTGSTicket returning %#x\n", KerbErr));

    return (KerbErr);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbCheckA2D2Attribute
//
//  Synopsis:   Helper to validate the info in the A2D2 list given
//              our target.
//
//  Effects:    allocate output ticket
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:      there can only be one additional ticket
//
//
//--------------------------------------------------------------------------
KERBERR
KerbCheckA2D2Attribute(
        IN PUSER_INTERNAL6_INFORMATION UserInternal6,
        IN PUNICODE_STRING TargetToMatch,
        IN PKERB_EXT_ERROR ExtendedError
        )
{
    KERBERR Kerberr = KDC_ERR_BADOPTION;

    if (( UserInternal6->A2D2List == NULL ) ||
        ( UserInternal6->A2D2List->NumSPNs == 0 ))
    {
        FILL_EXT_ERROR_EX2( ExtendedError, STATUS_NOT_SUPPORTED, FILENO, __LINE__ );
        return Kerberr;
    }

    for (ULONG i = 0; i < UserInternal6->A2D2List->NumSPNs; i++)
    {
        if (RtlEqualUnicodeString(
                &(UserInternal6->A2D2List->SPNList[i]),
                TargetToMatch,
                TRUE
                ))
        {
            Kerberr = KDC_ERR_NONE;
            break;
        }
    }

    //
    // We have a list, but this target name isn't in there.
    // Return error to indicate such, but server is still allowed S4U,
    // just not for this target.
    //
    if (!KERB_SUCCESS(Kerberr))
    {
        FILL_EXT_ERROR_EX2( ExtendedError, STATUS_NO_MATCH, FILENO, __LINE__ );
    }

    return Kerberr;
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbUnpackAdditionalTickets
//
//  Synopsis:   Unpacks the AdditionalTickets field of a KDC request
//              and (a) verifies that the ticket is TGT for this realm
//              and (b) the ticket is encrypted with the corret key and
//              (c) the ticket is valid
//
//              Also checks for s4uproxy requests, and validates them.
//
//  Effects:
//
//  Arguments:  TicketList - from addt'l tickets field of tgs_req
//              KdcOptions - request options.
//              TargetServer - spn being asked for.
//              SourceCName - client name from tgt
//              SourceCRealm - client realm from tgt
//              SourceKey - session key from tgt.
//              u2uticketinfo - out param for u2u options.
//              s4uticketinfo - out param for s4uproxy option.
//              ExtendedError - out param for returning e_data.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KdcUnpackAdditionalTickets(
    IN PKERB_TICKET_LIST TicketList,
    IN ULONG KdcOptions,
    IN PUNICODE_STRING TargetName,
    IN PKERB_INTERNAL_NAME SourceCName,
    IN PUNICODE_STRING SourceCRealm,
    IN PKERB_ENCRYPTION_KEY SourceKey,
    OUT PKDC_U2U_TICKET_INFO U2UTicketInfo,
    OUT PKDC_S4U_TICKET_INFO S4UTicketInfo,
    OUT PKERB_EXT_ERROR ExtendedError
    )
{
    KERBERR                 KerbErr = KDC_ERR_NONE;
    PKERB_ENCRYPTED_TICKET  EncryptedTicket = NULL;
    PKERB_ENCRYPTION_KEY    EncryptionKey = NULL;
    PKERB_TICKET            Ticket = NULL;
    UNICODE_STRING          CrackedRealm = {0};
    BOOLEAN                 Referral = FALSE;
    KDC_TICKET_INFO         KrbtgtTicketInfo = {0};
    KDC_TICKET_INFO         RequestorTicketInfo = {0};
    KERB_REALM              LocalRealm;
    ULONG                   OptionCount = 0;
    ULONG                   TicketCount = 1;
    ULONG                   TicketFlags;

    PUSER_INTERNAL6_INFORMATION RequesterUserInfo = NULL;

    if ( TicketList == NULL )
    {
        D_DebugLog((DEB_ERROR, "KdcUnpackAdditionalTickets KLIN(%x) Trying to unpack null ticket or more than one ticket\n", KLIN(FILENO, __LINE__)));
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }
    else if ((KdcOptions & (KERB_KDC_OPTIONS_cname_in_addl_tkt | KERB_KDC_OPTIONS_enc_tkt_in_skey)) == 0)
    {
        D_DebugLog((DEB_ERROR, "KdcUnpackAdditionalTickets additional tickets present, but no options\n"));
        KerbErr = KDC_ERR_BADOPTION;
        goto Cleanup;
    }

    Ticket = &TicketList->value;
    LocalRealm = SecData.KdcKerbDnsRealmName();

    //
    // U2U request - additional ticket contains TGT w/ session
    // key we want to encrypt the final ticket with.
    //
    if ((KdcOptions & KERB_KDC_OPTIONS_enc_tkt_in_skey) != 0)
    {
        D_DebugLog((DEB_T_U2U, "KdcUnpackAdditionalTickets unpacking u2u tgt ticket\n"));

        UNICODE_STRING ServerNames[3];
        OptionCount++;

        KerbErr = SecData.GetKrbtgtTicketInfo(&KrbtgtTicketInfo);
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }

        //
        // Verify the ticket, first with the normal password list
        //

        ServerNames[0] = *SecData.KdcFullServiceKdcName();
        ServerNames[1] = *SecData.KdcFullServiceDnsName();
        ServerNames[2] = *SecData.KdcFullServiceName();

        EncryptionKey = KerbGetKeyFromList(
                            KrbtgtTicketInfo.Passwords,
                            Ticket->encrypted_part.encryption_type
                            );
        if (EncryptionKey == NULL)
        {
            KerbErr = KDC_ERR_ETYPE_NOTSUPP;
            goto Cleanup;
        }

        KerbErr = KerbVerifyTicket(
                    Ticket,
                    3,                              // 3 names
                    ServerNames,
                    SecData.KdcDnsRealmName(),
                    EncryptionKey,
                    &SkewTime,
                    &EncryptedTicket
                    );

        //
        // if it failed due to wrong password, try again with older password
        //

        if ((KerbErr == KRB_AP_ERR_MODIFIED) && (KrbtgtTicketInfo.OldPasswords != NULL))
        {
            EncryptionKey = KerbGetKeyFromList(
                                KrbtgtTicketInfo.OldPasswords,
                                Ticket->encrypted_part.encryption_type
                                );
            if (EncryptionKey == NULL)
            {
                DebugLog((DEB_ERROR, "KdcUnpackAdditionalTickets no encryption key found in krbtgt's OldPassword\n"));
                KerbErr = KDC_ERR_ETYPE_NOTSUPP;
                goto Cleanup;
            }
            KerbErr = KerbVerifyTicket(
                        &TicketList->value,
                        2,                          // 2 names
                        ServerNames,
                        SecData.KdcDnsRealmName(),
                        EncryptionKey,
                        &SkewTime,
                        &EncryptedTicket
                        );
        }

        if (!KERB_SUCCESS(KerbErr))
        {
            DebugLog((DEB_ERROR, "KdcUnpackAdditionalTickets KLIN(%x) Failed to verify additional ticket: 0x%x\n", KLIN(FILENO, __LINE__),KerbErr));
            goto Cleanup;
        }

        //
        // Verify the realm of the ticket
        //

        if (!KerbCompareRealmNames(
                &LocalRealm,
                &Ticket->realm
                ))
        {
            D_DebugLog((DEB_ERROR, "KdcUnpackAdditionalTickets KLIN(%x) Additional ticket realm is wrong: %s instead of %s\n",
                      KLIN(FILENO, __LINE__), Ticket->realm, LocalRealm));
            KerbErr = KDC_ERR_POLICY;
            goto Cleanup;
        }

        //
        // Verify the realm of the client is the same as our realm
        //

        if (!KerbCompareRealmNames(
                &LocalRealm,
                &EncryptedTicket->client_realm
                ))
        {
            D_DebugLog((DEB_ERROR, "KdcUnpackAdditionalTickets KLIN(%x) Additional ticket client realm is wrong: %s instead of %s\n",
                KLIN(FILENO, __LINE__),EncryptedTicket->client_realm, LocalRealm));
            KerbErr = KDC_ERR_POLICY;
            goto Cleanup;
        }

        //
        // Crack the name in the supplied TGT.
        //
        KerbErr = KerbConvertPrincipalNameToKdcName(
                        &U2UTicketInfo->TgtCName,
                        &EncryptedTicket->client_name
                        );

        if (!KERB_SUCCESS( KerbErr ))
        {
           goto Cleanup;
        }

        KerbErr = KerbConvertRealmToUnicodeString(
                        &U2UTicketInfo->TgtCRealm,
                        &EncryptedTicket->client_realm
                        );

        if (!KERB_SUCCESS( KerbErr ))
        {
           goto Cleanup;
        }

        KerbErr = KdcNormalize(
                        U2UTicketInfo->TgtCName,
                        &U2UTicketInfo->TgtCRealm,
                        &U2UTicketInfo->TgtCRealm,
                        NULL,
                        KDC_NAME_CLIENT | KDC_NAME_INBOUND,
                        FALSE,          // do not restrict user accounts (user2user)
                        &Referral,
                        &CrackedRealm,
                        &U2UTicketInfo->TgtTicketInfo,
                        ExtendedError,
                        NULL,           // no user handle
                        0L,             // no fields to fetch
                        0L,             // no extended fields
                        NULL,           // no user all
                        NULL            // no group membership
                        );

        KerbFreeString( &CrackedRealm );

        if ( Referral )
        {
            KerbErr = KRB_AP_ERR_BADMATCH;
        }

        if (KERB_SUCCESS(KerbErr))
        {
            U2UTicketInfo->Flags |= TI_CHECK_RID;
        }
        else
        {
            DebugLog((DEB_ERROR, "KdcUnpackAdditionalTickets KLIN(%x) Failed to normalize client name from supplied ticket %#x\n",
                      KLIN(FILENO, __LINE__), KerbErr));

            KdcFreeU2UTicketInfo(U2UTicketInfo);
            RtlZeroMemory(
                U2UTicketInfo,
                sizeof(KDC_U2U_TICKET_INFO)
                );

            goto Cleanup;
        }


        U2UTicketInfo->Tgt = EncryptedTicket;
        EncryptedTicket = NULL;

        if (TicketList->next != NULL)
        {
            TicketCount++;
            Ticket = &TicketList->next->value;
        }

        U2UTicketInfo->Flags |= ( TI_INITIALIZED | TI_FREETICKET );
    }

    //
    // S4UProxy request
    // Now we've got to crack the additional ticket, find the server name,
    // and crack the account.
    //
    // NOTE:  The server must be in our realm to do this.  This implies that
    // other KDCs trust us to "do the right thing".
    //

    if ((KdcOptions & KERB_KDC_OPTIONS_cname_in_addl_tkt) != 0)
    {
        D_DebugLog((DEB_TRACE, "KdcUnpackAdditionalTickets unpacking evidence ticket\n"));

        if ( Ticket == NULL )
        {
            D_DebugLog((DEB_ERROR, "s4u set, but no ticket\n"));
            KerbErr = KDC_ERR_BADOPTION;
            goto Cleanup;
        }

        //
        //  Can't do this w/o target name..
        //
        if ( TargetName->Buffer == NULL )
        {
            KerbErr = KDC_ERR_BADOPTION;
            goto Cleanup;
        }

        OptionCount++;

        KerbErr = KerbConvertPrincipalNameToKdcName(
                        &S4UTicketInfo->RequestorServiceName,
                        &Ticket->server_name
                        );

        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }

        KerbErr = KerbConvertRealmToUnicodeString(
                        &S4UTicketInfo->RequestorServiceRealm,
                        &Ticket->realm
                        );

        if (!KERB_SUCCESS( KerbErr ))
        {
           goto Cleanup;
        }

        //
        // If the client of this S4UProxy request (e.g. a server running with
        // an impersonated client context, asking for S4U) has an account in this
        // realm (e.g. the crealm of the TGT == our realm), the accompanying
        // evidence ticket must:
        //
        // 1. Be encrypted in the S4UClient's account key
        // 2. Match the identity in the evidence ticket
        //
        if (SecData.IsOurRealm(SourceCRealm))
        {
            D_DebugLog((DEB_T_TICKETS, "S4U Request --  OUR REALM\n"));

            //
            // First get the TGT holder's userinfo.  This is used for checking
            // the A2D2 attribute.
            //
            KerbErr = KdcNormalize(
                        SourceCName,
                        SourceCRealm,
                        SourceCRealm,
                        NULL,
                        KDC_NAME_CLIENT,
                        FALSE,                  // do not restrict user accounts (user2user)
                        &Referral,
                        &CrackedRealm,
                        &RequestorTicketInfo,
                        ExtendedError,
                        0,
                        NULL,
                        USER_EXTENDED_FIELD_A2D2,
                        &RequesterUserInfo,
                        NULL
                        );

            KerbFreeString( &CrackedRealm );
            if (!KERB_SUCCESS(KerbErr) || Referral )
            {
                D_DebugLog((DEB_ERROR, "Unknown client dt PKERB_INTERNAL_NAME(%p)\n", SourceCName));

                if (KERB_SUCCESS(KerbErr) && Referral)
                {
                    KerbErr = KDC_ERR_BADOPTION;
                }

                FILL_EXT_ERROR_EX2( ExtendedError, STATUS_NO_MATCH, FILENO, __LINE__ );
                goto Cleanup;
            }


            //
            // Now get the information associated with the evidence ticket.
            //
            KerbErr = KdcNormalize(
                        S4UTicketInfo->RequestorServiceName,
                        &S4UTicketInfo->RequestorServiceRealm,
                        &S4UTicketInfo->RequestorServiceRealm,
                        NULL,
                        KDC_NAME_SERVER | KDC_NAME_CHECK_GC | KDC_NAME_FOLLOW_REFERRALS,
                        FALSE,                  // do not restrict user accounts (user2user)
                        &Referral,
                        &CrackedRealm,
                        &S4UTicketInfo->RequestorTicketInfo,
                        ExtendedError,
                        0,
                        NULL,
                        0,
                        NULL,
                        NULL
                        );

            KerbFreeString( &CrackedRealm );
            if ( !KERB_SUCCESS(KerbErr) || Referral )
            {
                D_DebugLog((DEB_ERROR, "Unknown evidence ticket sname (%p)\n", S4UTicketInfo));
                KerbErr = KDC_ERR_BADOPTION;
                FILL_EXT_ERROR_EX2( ExtendedError, STATUS_NO_MATCH, FILENO, __LINE__ );
                goto Cleanup;
            }

            //
            // The userids *must* match for the evidence ticket && the
            // TGT.  If not, log an event???
            //
            if ( S4UTicketInfo->RequestorTicketInfo.UserId != RequestorTicketInfo.UserId )
            {
                KerbErr = KDC_ERR_BADOPTION;
                D_DebugLog((DEB_ERROR, "User id's don't match (%p) (%p)!\n", &S4UTicketInfo->RequestorTicketInfo, RequestorTicketInfo));
                FILL_EXT_ERROR_EX2( ExtendedError, STATUS_NO_MATCH, FILENO, __LINE__ );
                goto Cleanup;
            }

            //
            // Validate the evidence ticket was encrypted w/ the proper key.
            //
            EncryptionKey = KerbGetKeyFromList(
                                  RequestorTicketInfo.Passwords,
                                  Ticket->encrypted_part.encryption_type
                                  );

            if (EncryptionKey == NULL)
            {
                KerbErr = KDC_ERR_ETYPE_NOTSUPP;
                goto Cleanup;
            }

            KerbErr = KerbVerifyTicket(
                            Ticket,
                            0,
                            NULL,
                            SecData.KdcDnsRealmName(),
                            EncryptionKey,
                            &SkewTime,
                            &EncryptedTicket
                            );

            if ((KerbErr == KRB_AP_ERR_MODIFIED) &&
                (RequestorTicketInfo.OldPasswords != NULL))
            {
                EncryptionKey = KerbGetKeyFromList(
                                    RequestorTicketInfo.OldPasswords,
                                    Ticket->encrypted_part.encryption_type
                                    );

                if (EncryptionKey == NULL)
                {
                    KerbErr = KDC_ERR_ETYPE_NOTSUPP;
                    goto Cleanup;
                }

                KerbErr = KerbVerifyTicket(
                                Ticket,
                                0,
                                NULL,
                                SecData.KdcDnsRealmName(),
                                EncryptionKey,
                                &SkewTime,
                                &EncryptedTicket
                                );
            }

            if (!KERB_SUCCESS(KerbErr))
            {
                D_DebugLog((DEB_ERROR, "Couldn't decrypt evidence ticket %x\n",KerbErr));
                KerbErr = KDC_ERR_BADOPTION;
                FILL_EXT_ERROR_EX2( ExtendedError, STATUS_NO_MATCH, FILENO, __LINE__ );
                goto Cleanup;
            }

            //
            // Check the A2D2 attribute for our name.  Also return hints to
            // the server w.r.t. whether they even support S4UProxy protocol
            // using extended errors.
            //
            KerbErr = KerbCheckA2D2Attribute(
                            RequesterUserInfo,
                            TargetName,
                            ExtendedError
                            );

            if (!KERB_SUCCESS(KerbErr))
            {
                DebugLog((DEB_ERROR, 
                    "KdcUnpackAdditionalTickets failed to match %wZ to user %wZ id %#x\n", 
                    TargetName, &RequesterUserInfo->I1.UserName, RequesterUserInfo->I1.UserId));
                goto Cleanup;
            }


            KerbErr = KerbDuplicateKey(
                        &S4UTicketInfo->EvidenceTicketKey,
                        EncryptionKey
                        );

            if (!KERB_SUCCESS(KerbErr))
            {
                goto Cleanup;
            }

            S4UTicketInfo->Flags |= TI_PRXY_REQUESTOR_THIS_REALM;

        }
        else
        {
            //
            // NOT OUR REALM!
            //
            // cname will == the info in the pac, as will crealm.
            //
            // The evidence ticket and the PAC signature will be generated using
            // the session key in the cross-realm tgt.
            //
            DebugLog((DEB_T_TICKETS, "S4U Request !!  NOT OUR REALM/n"));
            FILL_EXT_ERROR_EX2( ExtendedError, STATUS_CROSSREALM_DELEGATION_FAILURE, FILENO, __LINE__ );
            KerbErr = KDC_ERR_POLICY;
            goto Cleanup;
        }

        if (!NT_SUCCESS( KerbDuplicateStringEx(
                            &S4UTicketInfo->TargetName,
                            TargetName,
                            FALSE
                            )))
        {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }

        //
        // The ticket *must* be fwdable to be used in S4UProxy.
        //
        TicketFlags = KerbConvertFlagsToUlong( &EncryptedTicket->flags );

        if (( TicketFlags & KERB_TICKET_FLAGS_forwardable ) == 0)
        {
            D_DebugLog((DEB_ERROR, "Non fwdble service ticket presented as S4UPrxy evidence\n"));
            FILL_EXT_ERROR_EX2( ExtendedError, STATUS_NO_MATCH, FILENO, __LINE__ );
            KerbErr = KDC_ERR_BADOPTION;
            goto Cleanup;
        }

        //
        // Everything's looking good here.  Grab the client name
        // from the ticket, and the client realm.  These will be put in
        // the TGS_REP, when we need to.
        //
        KerbErr = KerbConvertPrincipalNameToKdcName(
                    &S4UTicketInfo->PACCName,
                    &EncryptedTicket->client_name
                    );

        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }

        KerbErr = KerbConvertRealmToUnicodeString(
                        &S4UTicketInfo->PACCRealm,
                        &EncryptedTicket->client_realm
                        );

        if (!KERB_SUCCESS( KerbErr ))
        {
           goto Cleanup;
        }

        //
        // Keep a copy of the ticket, so we can copy over the pac later.
        //

        S4UTicketInfo->EvidenceTicket = EncryptedTicket;
        EncryptedTicket = NULL;

        S4UTicketInfo->Flags |= ( TI_INITIALIZED | TI_S4UPROXY_INFO | TI_FREETICKET );
    }

    //
    // Validate that our options were matched w/ tickets.
    //

    if ( TicketCount != OptionCount )
    {
        D_DebugLog((DEB_ERROR, "Ticket count (%x) != option count (%x)\n", TicketCount, OptionCount));
        FILL_EXT_ERROR_EX2( ExtendedError, STATUS_NO_MATCH, FILENO, __LINE__ );
        KerbErr = KDC_ERR_BADOPTION;
        goto Cleanup;
    }

Cleanup:


    if (!KERB_SUCCESS( KerbErr ))
    {
        KdcFreeS4UTicketInfo( S4UTicketInfo );
        RtlZeroMemory(
            S4UTicketInfo,
            sizeof(KDC_S4U_TICKET_INFO)
            );

        KdcFreeU2UTicketInfo( U2UTicketInfo );
        RtlZeroMemory(
            U2UTicketInfo,
            sizeof(KDC_U2U_TICKET_INFO)
            );
    }

    SamIFree_UserInternal6Information( RequesterUserInfo );

    if (EncryptedTicket != NULL)
    {
        KerbFreeTicket( EncryptedTicket );
    }

    FreeTicketInfo( &KrbtgtTicketInfo );
    FreeTicketInfo( &RequestorTicketInfo );

    return(KerbErr);
}

//--------------------------------------------------------------------
//
//  Name:       KdcFindS4UClientAndRealm
//
//  Synopsis:   Decodes PA DATA to find PA_DATA_FOR_USER entry.
//
//  Effects:    Get a client name and realm for processing S4U request
//
//  Arguments:  PAList       - Preauth data list from TGS_REQ
//              ServerKey    - Key in authenticator, used to sign PA_DATA.
//              ClientRealm  - Target for client realm
//              ClientName   - Principal to get S4U ticket for
//
//  Requires:
//
//  Returns:    KDC_ERR_ or KRB_AP_ERR errors only
//
//  Notes:  Free client name and realm w/
//
//
//--------------------------------------------------------------------------
KERBERR
KdcFindS4UClientAndRealm(
    IN      PKERB_PA_DATA_LIST PaList,
    IN      PKERB_INTERNAL_NAME TargetName,
    IN      PKERB_ENCRYPTED_TICKET SourceTicket,
    IN      PKERB_ENCRYPTION_KEY SourceTicketKey,
    IN      PKERB_INTERNAL_NAME SourceCName,
    IN      PUNICODE_STRING SourceCRealm,
    IN OUT  PKDC_S4U_TICKET_INFO S4UTicketInfo,
    IN OUT  PKERB_EXT_ERROR ExtendedError
    )
{
    KERBERR Kerberr = KDC_ERR_NONE;
    PKERB_PA_DATA PaData = NULL;
    PKERB_PA_FOR_USER S4URequest = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    unsigned char  Hash[MD5DIGESTLEN];
    KERB_CHECKSUM Checksum;
    BOOLEAN Referral;
    UNICODE_STRING FakeRealm = {0};


    Checksum.checksum.value = Hash;

    PaData = KerbFindPreAuthDataEntry(
                KRB5_PADATA_FOR_USER,
                PaList
                );

    if (NULL == PaData)
    {
        goto Cleanup;
    }

    if (( S4UTicketInfo->Flags & TI_S4UPROXY_INFO ) != 0)
    {
        D_DebugLog((DEB_ERROR, "Trying to mix S4U  proxy and self requests\n"));
        Kerberr = KDC_ERR_BADOPTION;
        goto Cleanup;
    }

    Kerberr = KerbUnpackData(
                    PaData->preauth_data.value,
                    PaData->preauth_data.length,
                    KERB_PA_FOR_USER_PDU,
                    (PVOID* ) &S4URequest
                    );

    if (!KERB_SUCCESS(Kerberr))
    {
        D_DebugLog((DEB_ERROR, "Failed to unpack PA_FOR_USER\n"));
        goto Cleanup;
    }

    Status  = KerbHashS4UPreauth(
                    S4URequest,
                    &SourceTicket->key,
                    S4URequest->cksum.checksum_type,
                    &Checksum
                    );

    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR, "Failed to create S4U checksum\n"));
        Kerberr = KRB_AP_ERR_MODIFIED;
        goto Cleanup;
    }

    if (!RtlEqualMemory(
            Checksum.checksum.value,
            S4URequest->cksum.checksum.value,
            Checksum.checksum.length
            ))
    {
        DebugLog((DEB_ERROR, "S4U PA checksum doesn't match!\n"));
        Kerberr = KRB_AP_ERR_MODIFIED;
        goto Cleanup;
    }

    //
    // Get the information on the requestor of the S4UToSelf
    // if its from our realm.
    //
    if (SecData.IsOurRealm(SourceCRealm))
    {

        Kerberr = KdcNormalize(
                        SourceCName,
                        SourceCRealm,
                        SourceCRealm,
                        NULL,
                        KDC_NAME_CLIENT,
                        FALSE,
                        &Referral,
                        &FakeRealm,
                        &S4UTicketInfo->RequestorTicketInfo,
                        ExtendedError,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL
                        );

        if ( !KERB_SUCCESS( Kerberr) || Referral )
        {
            //
            // Something's wrong here - we don't know about the client
            // of this request, even though the TGTs from our realm.
            //
            D_DebugLog((DEB_ERROR, "Couldn't normalize S4UToSelf requestor\n"));
            Kerberr = KDC_ERR_WRONG_REALM;
            goto Cleanup;
        }

        S4UTicketInfo->Flags |= (TI_REQUESTOR_THIS_REALM | TI_CHECK_RID);

    }

    Kerberr = KerbConvertRealmToUnicodeString(
                    &S4UTicketInfo->PACCRealm,
                    &S4URequest->userRealm
                    );

    if (!KERB_SUCCESS(Kerberr))
    {
        goto Cleanup;
    }

    Kerberr = KerbConvertPrincipalNameToKdcName(
                    &S4UTicketInfo->PACCName,
                    &S4URequest->userName
                    );

    if (!KERB_SUCCESS(Kerberr))
    {
        goto Cleanup;
    }

    Status = KerbDuplicateString(
                    &S4UTicketInfo->RequestorServiceRealm,
                    SourceCRealm
                    );

    if (!NT_SUCCESS(Status))
    {
        Kerberr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    Status = KerbDuplicateKdcName(
                &S4UTicketInfo->RequestorServiceName,
                SourceCName
                );

    if (!NT_SUCCESS(Status))
    {
        Kerberr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    //
    // This is the requestor's tgt - save it off for
    // later authz checks.
    //
    S4UTicketInfo->EvidenceTicket = SourceTicket;
    Kerberr = KerbDuplicateKey(
                    &S4UTicketInfo->EvidenceTicketKey,
                    SourceTicketKey
                    );

    if (!KERB_SUCCESS( Kerberr ))
    {
        goto Cleanup;
    }    

    S4UTicketInfo->Flags |= ( TI_INITIALIZED | TI_S4USELF_INFO  );

Cleanup:

    if (S4URequest != NULL)
    {
        KerbFreeData(
            KERB_PA_FOR_USER_PDU,
            S4URequest
            );
    }

    return Kerberr;
}


//--------------------------------------------------------------------
//
//  Name:       HandleTGSRequest
//
//  Synopsis:   Gets a ticket using a KDC ticket (TGT).
//
//  Effects:    Allocates and encrypts a KDC reply
//
//  Arguments:  ClientAddress - Optionally contains client IP address
//              RequestMessage - contains the TGS request message
//              RequestRealm - The realm of the request, from the request
//                      message
//              OutputMessage - Contains the buffer to send back to the client
//  Requires:
//
//  Returns:    KDC_ERR_ or KRB_AP_ERR errors only
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
HandleTGSRequest(
    IN OPTIONAL SOCKADDR * ClientAddress,
    IN PKERB_TGS_REQUEST RequestMessage,
    IN PUNICODE_STRING RequestRealm,
    OUT PKERB_MESSAGE_BUFFER OutputMessage,
    OUT PKERB_EXT_ERROR pExtendedError,
    OUT PUNICODE_STRING ClientStringName,
    OUT PUNICODE_STRING ServerStringName
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;

    KDC_TICKET_INFO             ServerTicketInfo = {0};
    KDC_U2U_TICKET_INFO         U2UTicketInfo = {0};
    KDC_S4U_TICKET_INFO         S4UTicketInfo = {0};
    KERB_TICKET SourceTicket = {0};
    KERB_TICKET NewTicket = {0};
    KERB_ENCRYPTED_TICKET EncryptedTicket = {0};
    PKERB_ENCRYPTED_TICKET SourceEncryptPart = NULL;
    PKERB_KDC_REQUEST_BODY RequestBody = &RequestMessage->request_body;
    KERB_TGS_REPLY Reply = {0};
    KERB_ENCRYPTED_KDC_REPLY ReplyBody = {0};
    PKERB_AP_REQUEST UnmarshalledApRequest = NULL;
    PKERB_AUTHENTICATOR UnmarshalledAuthenticator = NULL;
    PKERB_PA_DATA ApRequest = NULL;
    PKERB_PA_DATA_LIST ReplyPaData = NULL;
    KERB_ENCRYPTION_KEY ReplyKey = {0};
    KERB_ENCRYPTION_KEY ServerKey = {0};
    KERB_ENCRYPTION_KEY SourceTicketKey ={0};

    PKERB_INTERNAL_NAME ServerName = NULL;
    PKERB_INTERNAL_NAME SourceClientName = NULL;
    UNICODE_STRING SourceClientRealm = {0};

    ULONG CommonEType = 0;
    ULONG KdcOptions = 0;
    ULONG TicketFlags = 0;
    ULONG ReplyTicketFlags = 0;
    ULONG TraceFlags = 0;
    ULONG KeySalt = KERB_TGS_REP_SALT;

    KERB_REALM TmpRealm = NULL;
    KERB_PRINCIPAL_NAME TmpName = {0};

    BOOLEAN Validating = FALSE;
    BOOLEAN UseSubKey = FALSE;
    BOOLEAN Renew = FALSE;
    PS4U_DELEGATION_INFO S4UDelegationInfo = NULL;
    KDC_TGS_EVENT_INFO TGSEventTraceInfo = {0};
    PLSA_ADT_STRING_LIST TransittedServices = NULL;

    TRACE(KDC, HandleTGSRequest, DEB_FUNCTION);

    //
    // Initialize [out] structures, so if we terminate early, they can
    // be correctly marshalled by the stub
    //

    NewTicket.encrypted_part.cipher_text.value = (PUCHAR) &EncryptedTicket;

    EncryptedTicket.flags.value = (PUCHAR) &TicketFlags;
    EncryptedTicket.flags.length = sizeof(ULONG) * 8;
    ReplyBody.flags.value = (PUCHAR) &ReplyTicketFlags;
    ReplyBody.flags.length = sizeof(ULONG) * 8;

    KdcOptions = KerbConvertFlagsToUlong( &RequestBody->kdc_options );

    //
    // Start event tracing
    //

    if (KdcEventTraceFlag){

        TraceFlags = GetTraceEnableFlags(KdcTraceLoggerHandle);

        TGSEventTraceInfo.EventTrace.Guid = KdcHandleTGSRequestGuid;
        TGSEventTraceInfo.EventTrace.Class.Type = EVENT_TRACE_TYPE_START;
        TGSEventTraceInfo.EventTrace.Flags = WNODE_FLAG_TRACED_GUID;
        TGSEventTraceInfo.EventTrace.Size = sizeof (EVENT_TRACE_HEADER) + sizeof (ULONG);
        TGSEventTraceInfo.KdcOptions = KdcOptions;

        TraceEvent(
            KdcTraceLoggerHandle,
            (PEVENT_TRACE_HEADER)&TGSEventTraceInfo
            );
    }

    //
    // The TGS and authenticator are in an AP request in the pre-auth data.
    // Find it and decode the AP request now.
    //

    if ((RequestMessage->bit_mask & KERB_KDC_REQUEST_preauth_data_present) == 0)
    {
        D_DebugLog((DEB_ERROR,
                  "KLIN(%x) No pre-auth data in TGS request - not allowed.\n",
                  KLIN(FILENO, __LINE__)));
        KerbErr = KDC_ERR_PADATA_TYPE_NOSUPP;
        goto Cleanup;
    }

    //
    // PA Data processing for TGS_REQ
    //

    //
    // Get the TGT from the PA data.
    //

    ApRequest = KerbFindPreAuthDataEntry(
                    KRB5_PADATA_TGS_REQ,
                    RequestMessage->KERB_KDC_REQUEST_preauth_data
                    );
    if (ApRequest == NULL)
    {
        D_DebugLog((DEB_ERROR,"KLIN(%x) No pre-auth data in TGS request - not allowed.\n",
                  KLIN(FILENO, __LINE__)));
        FILL_EXT_ERROR(pExtendedError, STATUS_NO_PA_DATA, FILENO, __LINE__);
        KerbErr = KDC_ERR_PADATA_TYPE_NOSUPP;
        goto Cleanup;
    }

    //
    // Verify the request. This includes decoding the AP request,
    // finding the appropriate key to decrypt the ticket, and checking
    // the ticket.
    //

    KerbErr = KdcVerifyKdcRequest(
                ApRequest->preauth_data.value,
                ApRequest->preauth_data.length,
                ClientAddress,
                TRUE,                           // this is a kdc request
                &UnmarshalledApRequest,
                &UnmarshalledAuthenticator,
                &SourceEncryptPart,
                &ReplyKey,
                &SourceTicketKey,
                &ServerTicketInfo,
                &UseSubKey,
                pExtendedError
                );

    //
    // If you want to validate a ticket, then it's OK if it isn't
    // currently valid.
    //

    if (KerbErr == KRB_AP_ERR_TKT_NYV && (KdcOptions & KERB_KDC_OPTIONS_validate))
    {
        D_DebugLog((DEB_TRACE, "HandleTGSRequest validating a not-yet-valid ticket\n"));
        KerbErr = KDC_ERR_NONE;
    }
    else if (KerbErr == KRB_AP_ERR_MODIFIED)
    {
        //
        // Bug 276943: When the authenticator is encrypted with something other
        //             than the session key, KRB_AP_ERR_BAD_INTEGRITY must be
        //             returned per RFC 1510
        //
        D_DebugLog((DEB_TRACE, "HandleTGSRequest could not decrypt the ticket\n"));
        KerbErr = KRB_AP_ERR_BAD_INTEGRITY;
    }

    //
    // Verify the checksum on the ticket, if present
    //

    if ( KERB_SUCCESS(KerbErr) &&
        (UnmarshalledAuthenticator != NULL) &&
        (UnmarshalledAuthenticator->bit_mask & checksum_present) != 0)
    {
        KerbErr = KdcVerifyTgsChecksum(
                    &RequestMessage->request_body,
                    &ReplyKey,
                    &UnmarshalledAuthenticator->checksum
                    );
    }

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR, "HandleTGSRequest KLIN(%x) Failed to verify TGS request: 0x%x\n", KLIN(FILENO, __LINE__), KerbErr));
        FILL_EXT_ERROR(pExtendedError, STATUS_KDC_INVALID_REQUEST, FILENO, __LINE__);
        goto Cleanup;
    }

    //
    // Check for additional tickets
    //

    //
    // The server name is optional, but only if you have enc_tkt_in_skey set..
    //

    if ((RequestBody->bit_mask & KERB_KDC_REQUEST_BODY_server_name_present) != 0)
    {
        KerbErr = KerbConvertPrincipalNameToKdcName(
                    &ServerName,
                    &RequestBody->KERB_KDC_REQUEST_BODY_server_name
                    );

        if (!KERB_SUCCESS( KerbErr ))
        {
            goto Cleanup;
        }

        //
        // Convert the server name to a string for auditing.
        //

        KerbErr = KerbConvertKdcNameToString(
                    ServerStringName,
                    ServerName,
                    NULL
                    );

        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }
    }

    //
    // Grab the cname and crealm from the TGT (aka the source ticket)
    //
    KerbErr = KerbConvertPrincipalNameToKdcName(
                    &SourceClientName,
                    &SourceEncryptPart->client_name
                    );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    KerbErr = KerbConvertRealmToUnicodeString(
                    &SourceClientRealm,
                    &SourceEncryptPart->client_realm
                    );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    //
    // Validate
    //

    if ((RequestBody->bit_mask & additional_tickets_present) != 0)
    {
        KerbErr = KdcUnpackAdditionalTickets(
                        RequestBody->additional_tickets,
                        KdcOptions,
                        ServerStringName,
                        SourceClientName,
                        &SourceClientRealm,
                        &ReplyKey,
                        &U2UTicketInfo,
                        &S4UTicketInfo,
                        pExtendedError
                        );

        if (!KERB_SUCCESS( KerbErr ))
        {
            DebugLog((DEB_ERROR, "KdcUnpackAdditionalTickets failed - %x\n", KerbErr));
            goto Cleanup;
        }
    }

    //
    // Gather & convert names for auditing.
    //
    if ((RequestBody->bit_mask & KERB_KDC_REQUEST_BODY_server_name_present) == 0)
    {
        //
        // There must be an additional ticket, and this *must* be U2U, right?.
        //

        if (( U2UTicketInfo.Flags & TI_INITIALIZED ) == 0)
        {
            KerbErr = KDC_ERR_S_PRINCIPAL_UNKNOWN;
            DsysAssert(FALSE);
            goto Cleanup;
        }

        KerbErr = KerbDuplicateKdcName(
                    &ServerName,
                    U2UTicketInfo.TgtCName
                    );

        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }

        //
        // Convert the server name to a string for auditing.
        //

        KerbErr = KerbConvertKdcNameToString(
                    ServerStringName,
                    ServerName,
                    NULL
                    );

        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }
    }

    KerbErr = KerbConvertKdcNameToString(
                ClientStringName,
                SourceClientName,
                &SourceClientRealm
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    //
    //  S4UToSelf PA data
    //  Note:  We can't do both S4U and S4UProxy requests at the same time..
    //

    KerbErr = KdcFindS4UClientAndRealm(
                RequestMessage->KERB_KDC_REQUEST_preauth_data,
                ServerName,
                SourceEncryptPart,
                &SourceTicketKey,
                SourceClientName,
                &SourceClientRealm,
                &S4UTicketInfo,
                pExtendedError
                );

    if (!KERB_SUCCESS( KerbErr ))
    {
        goto Cleanup;
    }

    //
    // If the client is in this domain and if we are supposed to
    // verify the client's account is still good,
    // do it now.
    //

    if ((SecData.KdcFlags() & AUTH_REQ_VALIDATE_CLIENT) != 0)
    {
        LARGE_INTEGER AuthTime;
        LARGE_INTEGER CurrentTime;

        NtQuerySystemTime(&CurrentTime);
        KerbConvertGeneralizedTimeToLargeInt(
            &AuthTime,
            &SourceEncryptPart->authtime,
            0
            );

        //
        // Only check if we haven't checked recently
        //

        if ((CurrentTime.QuadPart > AuthTime.QuadPart) &&
            ((CurrentTime.QuadPart - AuthTime.QuadPart) > SecData.KdcRestrictionLifetime().QuadPart))
        {

            KerbErr = KdcCheckTgsLogonRestrictions(
                        SourceClientName,
                        &SourceClientRealm,
                        pExtendedError
                        );
            if (!KERB_SUCCESS(KerbErr))
            {
                D_DebugLog((DEB_WARN, "HandleTGSRequest KLIN(%x) Client failed TGS logon restrictions: 0x%x : ",
                          KLIN(FILENO, __LINE__),KerbErr));
                D_KerbPrintKdcName((DEB_WARN, SourceClientName));
                goto Cleanup;
            }
        }
    }

    //
    // Build a ticket struture to pass to the worker functions
    //

    SourceTicket = UnmarshalledApRequest->ticket;
    SourceTicket.encrypted_part.cipher_text.value = (PUCHAR) SourceEncryptPart;

    //
    // Build the new ticket
    //

#if DBG

    if ( (S4UTicketInfo.Flags & TI_S4USELF_INFO) != 0)
    {
        D_DebugLog((DEB_T_S4U, "S4USelf request: requestor = %wZ, ", &SourceClientRealm));
        D_KerbPrintKdcName((DEB_T_S4U, SourceClientName));
        D_DebugLog((DEB_T_S4U, "S4USelf client realm %wZ\n", &S4UTicketInfo.PACCRealm));
        D_KerbPrintKdcName((DEB_T_S4U, S4UTicketInfo.PACCName));
        D_DebugLog((DEB_T_S4U, "HandleTGSRequest S4UTarget = %wZ, ", &S4UTicketInfo.TargetName));
        D_KerbPrintKdcName((DEB_T_S4U, ServerName));
    }
    else
    {
        D_DebugLog((DEB_TRACE, "HandleTGSRequest Service = "));
        D_KerbPrintKdcName((DEB_TRACE, ServerName));
        D_DebugLog((DEB_TRACE, "HandleTGSRequest: Client = %wZ, ", &SourceClientRealm));
        D_KerbPrintKdcName((DEB_TRACE, SourceClientName));
    }

#endif

    //
    // Pass off the work to the worker routines
    //

    if (KdcOptions & KERB_KDC_OPTIONS_renew)
    {
        D_DebugLog((DEB_T_KDC,"Renewing ticket ticket\n"));

        Renew = TRUE;
        KerbErr = I_RenewTicket(
                    &SourceTicket,
                    ClientStringName, // needed for auditing
                    ServerStringName, // needed for auditing
                    ServerName,
                    &ServerTicketInfo,
                    RequestBody,
                    ( UnmarshalledAuthenticator && ( UnmarshalledAuthenticator->bit_mask & KERB_AUTHENTICATOR_subkey_present )) ?
                        &UnmarshalledAuthenticator->subkey : NULL,
                    &NewTicket,
                    &ServerKey,
                    pExtendedError
                    );
    }
    else if (KdcOptions & KERB_KDC_OPTIONS_validate)
    {
        D_DebugLog((DEB_T_KDC, "HandleTGSRequest validating ticket\n"));

        KerbErr = I_Validate(
                    &SourceTicket,
                    ServerName,
                    &SourceClientRealm,
                    RequestBody,
                    &ServerKey,
                    &NewTicket,
                    pExtendedError
                    );

        Validating = TRUE;
    }
    else
    {
        D_DebugLog((DEB_T_KDC, "HandleTGSRequest getting new TGS ticket\n"));

        KerbErr = I_GetTGSTicket(
                    &SourceTicket,
                    ClientStringName,  // needed for auditing
                    ServerStringName,  // needed for auditing
                    ServerName,
                    RequestRealm,
                    RequestBody,
                    &ServerTicketInfo,
                    (( U2UTicketInfo.Flags & TI_INITIALIZED ) ?
                       &U2UTicketInfo.Tgt->key : NULL ),
                    &S4UTicketInfo,
                    ( UnmarshalledAuthenticator &&  ( UnmarshalledAuthenticator->bit_mask & KERB_AUTHENTICATOR_subkey_present )) ?
                        &UnmarshalledAuthenticator->subkey :
                        NULL,
                    &NewTicket,
                    &ServerKey,
                    &ReplyPaData,
                    pExtendedError,
                    &S4UDelegationInfo
                    );
    }

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    DsysAssert(ServerTicketInfo.Passwords != NULL);

    //
    // Check to see if the additional ticket supplied is the one for this
    // server, if necessary
    //

    if ( (U2UTicketInfo.Flags & TI_CHECK_RID)
         && (ServerTicketInfo.UserId != U2UTicketInfo.TgtTicketInfo.UserId) )
    {
        DebugLog((DEB_ERROR, "KLIN(%x) Supplied U2U ticket is not for server: %wZ (%#x) vs. %wZ (%#x)\n",
                  KLIN(FILENO, __LINE__), &(U2UTicketInfo.TgtTicketInfo.AccountName), ServerTicketInfo.UserId,
                  &(ServerTicketInfo.AccountName), U2UTicketInfo.TgtTicketInfo.UserId));
        KerbErr = KRB_AP_ERR_BADMATCH;
        goto Cleanup;
    }

    //
    // S4UToSelf check - the requestor's userid must == that of the final service.
    //
    if ((( S4UTicketInfo.Flags & ( TI_S4USELF_INFO | TI_CHECK_RID )) == ( TI_S4USELF_INFO | TI_CHECK_RID )) &&
         ( S4UTicketInfo.RequestorTicketInfo.UserId != ServerTicketInfo.UserId ))
    {
        DebugLog((DEB_ERROR, "KLIN(%x) Supplied S4U ticket is not for server: %wZ (%#x) vs. %wZ (%#x)\n",
                 KLIN(FILENO, __LINE__), &(S4UTicketInfo.RequestorTicketInfo.AccountName), ServerTicketInfo.UserId,
                 &(ServerTicketInfo.AccountName), S4UTicketInfo.RequestorTicketInfo.UserId));
        KerbErr = KRB_AP_ERR_BADMATCH;
        goto Cleanup;
    }


    KerbErr = BuildReply(
                NULL,
                RequestBody->nonce,
                &NewTicket.server_name,
                NewTicket.realm,
                ((EncryptedTicket.bit_mask & KERB_ENCRYPTED_TICKET_client_addresses_present) != 0) ?
                    EncryptedTicket.KERB_ENCRYPTED_TICKET_client_addresses : NULL,
                &NewTicket,
                &ReplyBody
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    //
    // Put in any PA data for the reply
    //

    if (ReplyPaData != NULL)
    {
        ReplyBody.encrypted_pa_data = (struct KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data_s *) ReplyPaData;
        ReplyBody.bit_mask |= encrypted_pa_data_present;
    }

    //
    // Now build the real reply and return it.
    //

    Reply.version = KERBEROS_VERSION;
    Reply.message_type = KRB_TGS_REP;
    Reply.KERB_KDC_REPLY_preauth_data = NULL;
    Reply.bit_mask = 0;

    //
    //  S4UToSelf.
    //  The client name in the reply is the client name from the
    //  PA Data.
    //

    if ((( S4UTicketInfo.Flags & ( TI_S4USELF_INFO | TI_S4UPROXY_INFO ) ) != 0)  &&
        (( S4UTicketInfo.Flags & TI_TARGET_OUR_REALM) != 0 ))
    {
        KerbErr = KerbConvertKdcNameToPrincipalName(
                        &TmpName,
                        S4UTicketInfo.PACCName
                        );

        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }

        KerbErr = KerbConvertUnicodeStringToRealm(
                    &TmpRealm,
                    &S4UTicketInfo.PACCRealm
                    );

        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }


        D_DebugLog((DEB_T_TICKETS, "S4U Reply client name\n"));
        D_KerbPrintKdcName((DEB_T_TICKETS, S4UTicketInfo.PACCName));
        D_DebugLog((DEB_T_TICKETS, "Realm %wZ\n", &S4UTicketInfo.PACCRealm));

        Reply.client_realm = TmpRealm;
        Reply.client_name = TmpName;
    }
    else
    {
        //
        // Default to information in the TGT
        //

        Reply.client_realm = SourceEncryptPart->client_realm;
        Reply.client_name = SourceEncryptPart->client_name;
    }

    //
    // Copy in the ticket
    //

    KerbErr = KerbPackTicket(
                &NewTicket,
                &ServerKey,
                ( U2UTicketInfo.Flags & TI_INITIALIZED ) ? KERB_NO_KEY_VERSION : ServerTicketInfo.PasswordVersion,
                &Reply.ticket
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        D_DebugLog((DEB_ERROR, "KLIN(%x) Failed to pack ticket: 0x%x\n", KLIN(FILENO, __LINE__), KerbErr));
        goto Cleanup;
    }

    //
    // Copy in the encrypted part (will encrypt the data first)
    //
    if (UseSubKey == TRUE)
    {
        KeySalt = KERB_TGS_REP_SUBKEY_SALT;     // otherwise keep  KERB_TGS_REP_SALT
    }

    KerbErr = KerbPackKdcReplyBody(
                &ReplyBody,
                &ReplyKey,
                KERB_NO_KEY_VERSION,
                KeySalt,
                KERB_ENCRYPTED_TGS_REPLY_PDU,
                &Reply.encrypted_part
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        D_DebugLog((DEB_ERROR, "KLIN(%x)Failed to pack KDC reply body: 0x%x\n", KLIN(FILENO, __LINE__), KerbErr));
        goto Cleanup;
    }

    //
    // Now build the real reply message
    //

    KerbErr = KerbPackData(
                &Reply,
                KERB_TGS_REPLY_PDU,
                &OutputMessage->BufferSize,
                &OutputMessage->Buffer
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    //
    // Audit the successful ticket generation
    //
    CommonEType = ServerKey.keytype;

    if (SecData.AuditKdcEvent(KDC_AUDIT_TGS_SUCCESS))
    {
        BYTE ServerSid[MAX_SID_LEN];
        GUID LogonGuid;
        NTSTATUS Status = STATUS_SUCCESS;
        PKERB_TIME pStartTime;

        pStartTime = &(((PKERB_ENCRYPTED_TICKET) NewTicket.encrypted_part.cipher_text.value)->KERB_ENCRYPTED_TICKET_starttime);

        Status = LsaIGetLogonGuid(
                     ClientStringName,
                     &SourceClientRealm,
                     (PBYTE) pStartTime,
                     sizeof(KERB_TIME),
                     &LogonGuid
                     );
        ASSERT(NT_SUCCESS( Status ));

        if (S4UDelegationInfo)
        {
            TransittedServices = (PLSA_ADT_STRING_LIST)MIDL_user_allocate(
                                    sizeof(LSA_ADT_STRING_LIST) +
                                    sizeof(LSA_ADT_STRING_LIST_ENTRY) * S4UDelegationInfo->TransitedListSize);

            if (TransittedServices)
            {
                PLSA_ADT_STRING_LIST_ENTRY Entry;

                Entry = (PLSA_ADT_STRING_LIST_ENTRY)&TransittedServices[1];

                TransittedServices->cStrings = S4UDelegationInfo->TransitedListSize;
                TransittedServices->Strings = Entry;

                for (ULONG i = 0; i < S4UDelegationInfo->TransitedListSize; i++)
                {
                    Entry->Flags = 0;
                    Entry->String.Length = S4UDelegationInfo->S4UTransitedServices[i].Length;
                    Entry->String.MaximumLength = S4UDelegationInfo->S4UTransitedServices[i].MaximumLength;
                    Entry->String.Buffer = S4UDelegationInfo->S4UTransitedServices[i].Buffer;
                    Entry++;
                }
            }
        }

        KdcMakeAccountSid(ServerSid, ServerTicketInfo.UserId);
        KdcLsaIAuditTgsEvent(
            Renew ? SE_AUDITID_TICKET_RENEW_SUCCESS : SE_AUDITID_TGS_TICKET_REQUEST,
            ClientStringName,
            &SourceClientRealm,
            NULL,                               // no client SID
            &ServerTicketInfo.AccountName,
            ServerSid,
            (PULONG) &KdcOptions,
            NULL,                               // success
            &CommonEType,
            NULL,                               // no preauth type
            GET_CLIENT_ADDRESS(ClientAddress),
            &LogonGuid,
            TransittedServices
            );
    }

Cleanup:

    //
    // Complete the event
    //

    if (KdcEventTraceFlag){

        //These variables point to either a unicode string struct containing
        //the corresponding string or a pointer to KdcNullString

        PUNICODE_STRING pStringToCopy;
        WCHAR   UnicodeNullChar = 0;
        UNICODE_STRING UnicodeEmptyString = {sizeof(WCHAR),sizeof(WCHAR),&UnicodeNullChar};

        TGSEventTraceInfo.EventTrace.Class.Type = EVENT_TRACE_TYPE_END;
        TGSEventTraceInfo.EventTrace.Flags = WNODE_FLAG_USE_MOF_PTR |
                                             WNODE_FLAG_TRACED_GUID;

        // Always output error code.  KdcOptions was captured on the start event

        TGSEventTraceInfo.eventInfo[0].DataPtr = (ULONGLONG) &KerbErr;
        TGSEventTraceInfo.eventInfo[0].Length  = sizeof(ULONG);
        TGSEventTraceInfo.EventTrace.Size =
            sizeof (EVENT_TRACE_HEADER) + sizeof(MOF_FIELD);

        // Build counted MOF strings from the unicode strings.
        // If data is unavailable then output a NULL string

        if (ClientStringName->Buffer != NULL &&
            ClientStringName->Length > 0)
        {
            pStringToCopy = ClientStringName;
        }
        else
        {
            pStringToCopy = &UnicodeEmptyString;
        }

        TGSEventTraceInfo.eventInfo[1].DataPtr =
            (ULONGLONG) &pStringToCopy->Length;
        TGSEventTraceInfo.eventInfo[1].Length  =
            sizeof(pStringToCopy->Length);
        TGSEventTraceInfo.eventInfo[2].DataPtr =
            (ULONGLONG) pStringToCopy->Buffer;
        TGSEventTraceInfo.eventInfo[2].Length =
            pStringToCopy->Length;
        TGSEventTraceInfo.EventTrace.Size += sizeof(MOF_FIELD)*2;

        if (ServerStringName->Buffer != NULL &&
            ServerStringName->Length > 0)
        {
            pStringToCopy = ServerStringName;

        }
        else
        {
            pStringToCopy = &UnicodeEmptyString;
        }

        TGSEventTraceInfo.eventInfo[3].DataPtr =
            (ULONGLONG) &pStringToCopy->Length;
        TGSEventTraceInfo.eventInfo[3].Length  =
            sizeof(pStringToCopy->Length);
        TGSEventTraceInfo.eventInfo[4].DataPtr =
            (ULONGLONG) pStringToCopy->Buffer;
        TGSEventTraceInfo.eventInfo[4].Length =
            pStringToCopy->Length;
        TGSEventTraceInfo.EventTrace.Size += sizeof(MOF_FIELD)*2;


        if (SourceClientRealm.Buffer != NULL &&
            SourceClientRealm.Length > 0)
        {
            pStringToCopy = &SourceClientRealm;
        }
        else
        {
            pStringToCopy = &UnicodeEmptyString;
        }

        TGSEventTraceInfo.eventInfo[5].DataPtr =
            (ULONGLONG) &pStringToCopy->Length;
        TGSEventTraceInfo.eventInfo[5].Length  =
            sizeof(pStringToCopy->Length);
        TGSEventTraceInfo.eventInfo[6].DataPtr =
            (ULONGLONG) pStringToCopy->Buffer;
        TGSEventTraceInfo.eventInfo[6].Length =
            pStringToCopy->Length;
        TGSEventTraceInfo.EventTrace.Size += sizeof(MOF_FIELD)*2;

        TraceEvent(
             KdcTraceLoggerHandle,
             (PEVENT_TRACE_HEADER)&TGSEventTraceInfo
             );
    }

    if (!KERB_SUCCESS(KerbErr) &&
        SecData.AuditKdcEvent(KDC_AUDIT_TGS_FAILURE))
    {
        if (( KerbErr != KDC_ERR_S_PRINCIPAL_UNKNOWN ) ||
            (( KdcExtraLogLevel & LOG_SPN_UNKNOWN) != 0))
        {
            KdcLsaIAuditTgsEvent(
                 SE_AUDITID_TGS_TICKET_REQUEST,
                 (ClientStringName->Buffer != NULL) ? ClientStringName : &KdcNullString,
                 &SourceClientRealm,                       // no domain name
                 NULL,
                 ServerStringName,
                 NULL,
                 &KdcOptions,
                 (PULONG) &KerbErr,
                 NULL,
                 NULL,
                 GET_CLIENT_ADDRESS(ClientAddress),
                 NULL,                                // no logon guid
                 NULL                                 // no transitted services
                 );
        }
    }

    KerbFreeKdcName(
        &SourceClientName
        );
    KerbFreeString(
        &SourceClientRealm
        );
    KerbFreeKdcName(
        &ServerName
        );
    KerbFreeKey(
        &ReplyKey
        );
    KerbFreeKey(
        &SourceTicketKey
        );
    KerbFreeKey(
        &ServerKey
        );

    KdcFreeKdcReplyBody(
        &ReplyBody
        );

    KerbFreePrincipalName( &TmpName );
    KerbFreeRealm( &TmpRealm );
    KdcFreeU2UTicketInfo(&U2UTicketInfo);
    KdcFreeS4UTicketInfo(&S4UTicketInfo);

    if (ReplyPaData != NULL)
    {
        KerbFreePreAuthData(ReplyPaData);
    }

    KerbFreeApRequest(UnmarshalledApRequest);
    KerbFreeAuthenticator(UnmarshalledAuthenticator);
    KerbFreeTicket(SourceEncryptPart);

    KdcFreeInternalTicket(&NewTicket);
    FreeTicketInfo(&ServerTicketInfo);

    KdcFreeKdcReply(
        &Reply
        );

    if (TransittedServices)
    {
        MIDL_user_free(TransittedServices);
    }

    if (S4UDelegationInfo)
    {
#if DBG
        D_DebugLog((DEB_T_PAC, "HandleTGSRequest target %wZ\n", &S4UDelegationInfo->S4U2proxyTarget)); 
        
        for ( ULONG i = 0; i < S4UDelegationInfo->TransitedListSize; i++ )
        {        
            D_DebugLog((DEB_T_PAC, "HandleTGSRequest ts %#x: %wZ\n", i, &S4UDelegationInfo->S4UTransitedServices[i]));   
        }
#endif // DBG

        MIDL_user_free(S4UDelegationInfo);
    }

    return(KerbErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\server\kdc.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        KDC.CXX
//
// Contents:    Base part of the KDC.  Global vars, main functions, init
//
//
// History:
//
//------------------------------------------------------------------------

#include "kdcsvr.hxx"

extern "C" {
#include <lmserver.h>
#include <srvann.h>
#include <nlrepl.h>
#include <dsgetdc.h>
}
#include "rpcif.h"
#include "sockutil.h"
#include "kdctrace.h"
#include "fileno.h"
#define  FILENO FILENO_KDC


VOID
KdcPolicyChangeCallBack(
    IN POLICY_NOTIFICATION_INFORMATION_CLASS MonitorInfoClass
    );

VOID
KdcMyStoreWaitHandler(
    PVOID pVoid,
    BOOLEAN fTimeout
    );

//
// Global data
//

KDC_STATE KdcState = Stopped;                   // used to signal when
                                                // authenticated RPC is
                                                // ready to use - e.g.
                                                // spmgr has found the
                                                // kdc
SERVICE_STATUS_HANDLE hService;
SERVICE_STATUS SStatus;
UNICODE_STRING GlobalDomainName;
UNICODE_STRING GlobalKerberosName;
UNICODE_STRING GlobalKdcName;
PKERB_INTERNAL_NAME GlobalKpasswdName = NULL;

//
// Sids used to build other sids quickly.
//
PSID         GlobalDomainSid;
PSID         GlobalBuiltInSid;
PSID         GlobalEveryoneSid;
PSID         GlobalAuthenticatedUserSid;
PSID         GlobalThisOrganizationSid;
PSID         GlobalOtherOrganizationSid;

LSAPR_HANDLE GlobalPolicyHandle = NULL;
SAMPR_HANDLE GlobalAccountDomainHandle = NULL;
SAMPR_HANDLE GlobalBuiltInDomainHandle = NULL;

BYTE GlobalLocalhostAddress[4];
HANDLE KdcGlobalDsPausedWaitHandle = NULL;
HANDLE KdcGlobalDsEventHandle = NULL;
BOOL KdcGlobalAvoidPdcOnWan = FALSE;
BOOL KdcGlobalGlobalSafeBoot = FALSE;
#if DBG
LARGE_INTEGER tsIn,tsOut;
#endif

// Global KDC values - can be overridden by registry vlaues
const DWORD KdcUseClientAddressesDefault = FALSE;
const DWORD KdcDontCheckAddressesDefault = TRUE;
const DWORD KdcNewConnectionTimeoutDefault = 10;
const DWORD KdcExistingConnectionTimeoutDefault = 50;
const DWORD KdcMaxDatagramReplySizeDefault = KERB_MAX_DATAGRAM_REPLY_SIZE;
const DWORD KdcExtraLogLevelDefault = LOG_DEFAULT;
const DWORD KdcIssueForwardedTicketsDefault = TRUE;

#if DBG
const ULONG KdcInfoLevelDefault = DEB_ERROR;
#else
const ULONG KdcInfoLevelDefault = 0;
#endif



DWORD KdcIssueForwardedTickets = KdcIssueForwardedTicketsDefault;
DWORD KdcUseClientAddresses = KdcUseClientAddressesDefault;
DWORD KdcDontCheckAddresses = KdcDontCheckAddressesDefault;
DWORD KdcNewConnectionTimeout = KdcNewConnectionTimeoutDefault;
DWORD KdcExistingConnectionTimeout = KdcExistingConnectionTimeoutDefault;
DWORD KdcGlobalMaxDatagramReplySize = KdcMaxDatagramReplySizeDefault;
DWORD KdcExtraLogLevel = KdcExtraLogLevelDefault;

HANDLE hKdcHandles[MAX_KDC_HANDLE] = {0};

// This keeps a registry key handle to the HKLM\System\CCSet\Services\Kdc key
HKEY hKdcParams = NULL; 

#ifdef ROGUE_DC
HKEY hKdcRogueKey = NULL;
#endif

HANDLE hKdcWait = NULL;

//
// Prototypes
//

CRITICAL_SECTION ApiCriticalSection;
ULONG CurrentApiCallers;

//
// MIDL_xxx wrappers to make safealloc happy
//

//
// kdc preferred crypt list
//

PKERB_CRYPT_LIST kdc_pPreferredCryptList = NULL;
PKERB_CRYPT_LIST kdc_pMitPrincipalPreferredCryptList = NULL;

PVOID
KdcAllocate(SIZE_T size)
{
    return MIDL_user_allocate(size);
}

VOID
KdcFree(PVOID buff)
{
    MIDL_user_free(buff);
}

AUTHZ_RESOURCE_MANAGER_HANDLE KdcAuthzRM = NULL;

//--------------------------------------------------------------------
//
//  Name:       KdcComputeAuthzGroups
//
//  Synopsis:   Authz callback for add groups to authz client context
//
//  Effects:
//
//  Arguments:
//
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//---

BOOL
KdcComputeAuthzGroups(
    IN AUTHZ_CLIENT_CONTEXT_HANDLE hAuthzClientContext,
    IN PVOID Args,
    OUT PSID_AND_ATTRIBUTES *pSidAttrArray,
    OUT PDWORD pSidCount,
    OUT PSID_AND_ATTRIBUTES *pRestrictedSidAttrArray,
    OUT PDWORD pRestrictedSidCount
    )
{

    PKDC_AUTHZ_INFO AuthzInfo = (PKDC_AUTHZ_INFO) Args;

    *pSidAttrArray = (PSID_AND_ATTRIBUTES) AuthzInfo->SidAndAttributes;
    *pSidCount = AuthzInfo->SidCount;
    *pRestrictedSidAttrArray = NULL;
    *pRestrictedSidCount = 0;

    return (TRUE);

}


//--------------------------------------------------------------------
//
//  Name:       KdcFreeAuthzGroups
//
//  Synopsis:   Basically a no-op, as we already have a copy of the
//              sids
//
//  Effects:
//
//  Arguments:
//
//
//  Requires:
//
//  Returns:
//
//---

VOID
KdcFreeAuthzGroups(IN PSID_AND_ATTRIBUTES pSidAttrArray)
{
    return;
}


//--------------------------------------------------------------------
//
//  Name:       KdcInitializeAuthzRM
//
//  Synopsis:   Validate that S4U caller has access to expand groups
//
//  Effects:    Use Authz to check client context.
//
//  Arguments:  S4UClientName    - ClientName from S4U PA Data
//              PAC              - Resultant PAC (signed w/? key)
//
//  Requires:
//
//  Returns:    KDC_ERR_ or KRB_AP_ERR errors only
//
//  Notes:  Free client name and realm w/
//
//
//---

NTSTATUS
KdcInitializeAuthzRM()
{

    if (!AuthzInitializeResourceManager(
            0,
            NULL,
            KdcComputeAuthzGroups,
            KdcFreeAuthzGroups,
            L"KDC",
            &KdcAuthzRM
            ))
    {
        DebugLog((DEB_ERROR, "AuthzInitializeRm failed %x\n", GetLastError()));
        return STATUS_UNSUCCESSFUL;
    }

    return STATUS_SUCCESS;
}


VOID
KdcFreeAuthzRm()
{
    if (!AuthzFreeResourceManager(KdcAuthzRM))
    {
        DebugLog((DEB_ERROR, "AuthzFreeResourceManager failed %x\n", GetLastError()));
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   UpdateStatus
//
//  Synopsis:   Updates the KDC's service status with the service controller
//
//  Effects:
//
//  Arguments:
//
//  History:
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOLEAN
UpdateStatus(DWORD   dwState)
{
    TRACE(KDC, UpdateStatus, DEB_FUNCTION);

    SStatus.dwCurrentState = dwState;
    if ((dwState == SERVICE_START_PENDING) || (dwState == SERVICE_STOP_PENDING))
    {
        SStatus.dwCheckPoint++;
        SStatus.dwWaitHint = 10000;
    }
    else
    {
        SStatus.dwCheckPoint = 0;
        SStatus.dwWaitHint = 0;
    }

    if (!SetServiceStatus(hService, &SStatus)) {
        DebugLog((DEB_ERROR,"(%x)Failed to set service status: %d\n",GetLastError()));
        return(FALSE);
    }

    return(TRUE);
}


//+---------------------------------------------------------------------------
//
//  Function:   Handler
//
//  Synopsis:   Process and respond to a control signal from the service
//              controller.
//
//  Effects:
//
//  Arguments:
//
//  History:
//
//  Notes:
//
//----------------------------------------------------------------------------

void
Handler(DWORD   dwControl)
{
    TRACE(KDC, Handler, DEB_FUNCTION);

    switch (dwControl)
    {

    case SERVICE_CONTROL_STOP:
        ShutDown( L"Service" );
        break;

    default:
        D_DebugLog((DEB_WARN, "Ignoring SC message %d\n",dwControl));
        break;

    }
}



BOOLEAN
KdcWaitForSamService(
    VOID
    )
/*++

Routine Description:

    This procedure waits for the SAM service to start and to complete
    all its initialization.

Arguments:


Return Value:

    TRUE : if the SAM service is successfully starts.

    FALSE : if the SAM service can't start.

--*/
{
    NTSTATUS Status;
    DWORD WaitStatus;
    UNICODE_STRING EventName;
    HANDLE EventHandle;
    OBJECT_ATTRIBUTES EventAttributes;

    //
    // open SAM event
    //

    RtlInitUnicodeString( &EventName, L"\\SAM_SERVICE_STARTED");
    InitializeObjectAttributes( &EventAttributes, &EventName, 0, 0, NULL );

    Status = NtOpenEvent( &EventHandle,
                            SYNCHRONIZE|EVENT_MODIFY_STATE,
                            &EventAttributes );

    if ( !NT_SUCCESS(Status)) {

        if( Status == STATUS_OBJECT_NAME_NOT_FOUND ) {

            //
            // SAM hasn't created this event yet, let us create it now.
            // SAM opens this event to set it.
            //

            Status = NtCreateEvent(
                           &EventHandle,
                           SYNCHRONIZE|EVENT_MODIFY_STATE,
                           &EventAttributes,
                           NotificationEvent,
                           FALSE // The event is initially not signaled
                           );

            if( Status == STATUS_OBJECT_NAME_EXISTS ||
                Status == STATUS_OBJECT_NAME_COLLISION ) {

                //
                // second chance, if the SAM created the event before we
                // do.
                //

                Status = NtOpenEvent( &EventHandle,
                                        SYNCHRONIZE|EVENT_MODIFY_STATE,
                                        &EventAttributes );
            }
        }

        if ( !NT_SUCCESS(Status)) {

            //
            // could not make the event handle
            //

            DebugLog((DEB_ERROR,
                "KdcWaitForSamService couldn't make the event handle : "
                "%lx\n", Status));

            return( FALSE );
        }
    }

    //
    // Loop waiting.
    //

    for (;;) {
        WaitStatus = WaitForSingleObject( EventHandle,
                                          5*1000 );  // 5 Seconds

        if ( WaitStatus == WAIT_TIMEOUT ) {
            DebugLog((DEB_WARN,
               "KdcWaitForSamService 5-second timeout (Rewaiting)\n" ));
            if (!UpdateStatus( SERVICE_START_PENDING )) {
                (VOID) NtClose( EventHandle );
                return FALSE;
            }
            continue;

        } else if ( WaitStatus == WAIT_OBJECT_0 ) {
            break;

        } else {
            DebugLog((DEB_ERROR,
                     "KdcWaitForSamService: error %ld %ld\n",
                     GetLastError(),
                     WaitStatus ));
            (VOID) NtClose( EventHandle );
            return FALSE;
        }
    }

    (VOID) NtClose( EventHandle );
    return TRUE;
}


VOID
KdcDsNotPaused(
    IN PVOID Context,
    IN BOOLEAN TimedOut
    )
/*++

Routine Description:

    Worker routine that gets called when the DS is no longer paused.

Arguments:

    None.

Return Value:

    None.

--*/
{
    NTSTATUS  NtStatus = STATUS_SUCCESS;

    //
    // Tell the kerberos client that we are a DC.
    //

    NtStatus = KerbKdcCallBack();
    if ( !NT_SUCCESS(NtStatus) )
    {
        D_DebugLog((DEB_ERROR,"Can't tell Kerberos that we're a DC 0x%x\n", NtStatus ));
        goto Cleanup;
    }

    NtStatus = I_NetLogonSetServiceBits( DS_KDC_FLAG, DS_KDC_FLAG );

    if ( !NT_SUCCESS(NtStatus) )
    {
        D_DebugLog((DEB_ERROR,"Can't tell netlogon we're started 0x%x\n", NtStatus ));
        goto Cleanup;
    }

    D_DebugLog((DEB_TRACE,"Ds is no longer paused\n"));

Cleanup:

    UNREFERENCED_PARAMETER( Context );
    UNREFERENCED_PARAMETER( TimedOut );
}



BOOLEAN
KdcRegisterToWaitForDS(
    VOID
    )
/*++

Routine Description:

    This procedure registers to wait for the DS to start and to complete
    all its initialization. The main reason we do this is because we don't
    want to start doing kerberos authentications because we don't know that
    the DS has the latest db. It needs to check with all the existing Dc's
    out there to see if there's any db merges to be done. When the
    DS_SYNCED_EVENT_NAME is set, we're ready.

Arguments:


Return Value:

    TRUE : if the register to wait succeeded

    FALSE : if the register to wait  didn't succeed.

--*/
{
    BOOLEAN fRet = FALSE;

    //
    // open the DS event
    //

    KdcGlobalDsEventHandle = OpenEvent( SYNCHRONIZE,
                             FALSE,
                             DS_SYNCED_EVENT_NAME_W);

    if ( KdcGlobalDsEventHandle == NULL)
    {
        //
        // could not open the event handle
        //

        D_DebugLog((DEB_ERROR,"KdcRegisterToWaitForDS couldn't open the event handle\n"));
        goto Cleanup;
    }

    if ( !RegisterWaitForSingleObject(
                    &KdcGlobalDsPausedWaitHandle,
                    KdcGlobalDsEventHandle,
                    KdcDsNotPaused, // Callback routine
                    NULL,           // No context
                    INFINITE,       // Wait forever
                    WT_EXECUTEINWAITTHREAD | WT_EXECUTEONLYONCE ) )
    {
        D_DebugLog((DEB_ERROR, "KdcRegisterToWaitForDS: Cannot register for DS Synced callback 0x%x\n", GetLastError()));
        goto Cleanup;
    }

    fRet = TRUE;

Cleanup:
    return fRet;

}


//+-------------------------------------------------------------------------
//
//  Function:   KdcOpenEvent
//
//  Synopsis:   Just like the Win32 function, except that it allows
//              for names at the root of the namespace.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:      The code was copied from private\windows\base\client\synch.c
//              and the base directory was changed to NULL
//
//--------------------------------------------------------------------------

HANDLE
APIENTRY
KdcOpenEvent(
    DWORD DesiredAccess,
    BOOL bInheritHandle,
    LPWSTR lpName
    )
{
    TRACE(KDC, KdcOpenEvent, DEB_FUNCTION);

    OBJECT_ATTRIBUTES   Obja;
    UNICODE_STRING      ObjectName;
    NTSTATUS            Status;
    HANDLE Object;

    if ( !lpName ) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
        }
    RtlInitUnicodeString(&ObjectName,lpName);

    InitializeObjectAttributes(
        &Obja,
        &ObjectName,
        (bInheritHandle ? OBJ_INHERIT : 0),
        NULL,
        NULL
        );

    Status = NtCreateEvent(
                   &Object,
                   DesiredAccess,
                   &Obja,
                   NotificationEvent,
                   (BOOLEAN) FALSE      // The event is initially not signaled
                   );

    if ( !NT_SUCCESS(Status)) {

        //
        // If the event already exists, the server beat us to creating it.
        // Just open it.
        //

        if( Status == STATUS_OBJECT_NAME_EXISTS ||
            Status == STATUS_OBJECT_NAME_COLLISION ) {

            Status = NtOpenEvent( &Object,
                                  DesiredAccess,
                                  &Obja );
        }
    }

    if ( !NT_SUCCESS(Status) ) {
        SetLastError(RtlNtStatusToDosError( Status ));
        return NULL;
    }

    return Object;
}


//+-------------------------------------------------------------------------
//
//  Function:   KdcStartEvent
//
//  Synopsis:   sets the KdcStartEvent
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:      The SPMgr must have created this event before this
//              is called
//
//
//--------------------------------------------------------------------------

void
SetKdcStartEvent()
{
    TRACE(KDC, SetKdcStartEvent, DEB_FUNCTION);

    HANDLE hEvent;
    hEvent = KdcOpenEvent(EVENT_MODIFY_STATE,FALSE,KDC_START_EVENT);
    if (hEvent != NULL)
    {
        SetEvent(hEvent);
        CloseHandle(hEvent);
        D_DebugLog((DEB_TRACE,"Set event %ws\n",KDC_START_EVENT));
    }
    else
    {
        DWORD dw = GetLastError();
        if (dw != ERROR_FILE_NOT_FOUND)
            DebugLog((DEB_ERROR,"Error opening %ws: %d\n",KDC_START_EVENT,dw));
        else
            D_DebugLog((DEB_TRACE,"Error opening %ws: %d\n",KDC_START_EVENT,dw));
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   KdcLoadParameters
//
//  Synopsis:   Loads random parameters from registry
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KdcLoadParameters(
    VOID
    )
{
    NET_API_STATUS NetStatus;
//  LPNET_CONFIG_HANDLE ConfigHandle = NULL;
    LPNET_CONFIG_HANDLE NetlogonInfo = NULL;

    int err = 0;
    HKEY Key ;

    //
    // Uncomment the below when there's something we need to read from this key
    //

//  NetStatus = NetpOpenConfigData(
//                  &ConfigHandle,
//                  NULL,               // noserer name
//                  SERVICE_KDC,
//                  TRUE                // read only
//                  );
//  if (NetStatus != NO_ERROR)
//  {
//      // we could return, but then we'd lose data
//      D_DebugLog((DEB_WARN, "Couldn't open KDC config data - %x\n", NetStatus));
//      // return;
//  }

    //
    //  Open Netlogon service key for AvoidPdcOnWan
    //
    NetStatus = NetpOpenConfigData(
                    &NetlogonInfo,
                    NULL,
                    SERVICE_NETLOGON,
                    TRUE
                    );

    if (NetStatus != NO_ERROR)
    {
        D_DebugLog((DEB_WARN, "Failed to open netlogon key - %x\n", NetStatus));
        return;
    }

    NetStatus = NetpGetConfigBool(
                    NetlogonInfo,
                    L"AvoidPdcOnWan",
                    FALSE,
                    &KdcGlobalAvoidPdcOnWan
                    );

    if (NetStatus != NO_ERROR)
    {
        D_DebugLog((DEB_WARN, "Failed to read netlogon config value KdcGlobalAvoidPdcOnWan - %x\n", NetStatus));
    }

//  NetpCloseConfigData( ConfigHandle );
    NetpCloseConfigData( NetlogonInfo );

    //
    // Check for safeboot mode
    //

    err = RegOpenKeyExW(
                HKEY_LOCAL_MACHINE,
                L"System\\CurrentControlSet\\Control\\SafeBoot\\Option",
                0,
                KEY_READ,
                &Key );

    if ( err == ERROR_SUCCESS )
    {
        ULONG Value = 0 ;
        ULONG Size = sizeof( ULONG );
        ULONG Type = 0;

        err = RegQueryValueExW(
                    Key,
                    L"OptionValue",
                    0,
                    &Type,
                    (PUCHAR) &Value,
                    &Size );

        RegCloseKey( Key );

        if ( err == ERROR_SUCCESS )
        {
            if (Value)
            {
                KdcGlobalGlobalSafeBoot = TRUE;
            }
        }
    }
}


typedef struct _KDC_REG_PARAMETER {

    WCHAR * Name;
    DWORD * Address;
    DWORD DefaultValue;
    BOOL ReverseSense; // 0 means TRUE
    BOOL Dynamic;

} KDC_REG_PARAMETER, *PKDC_REG_PARAMETER;


//+---------------------------------------------------------------------------
//
//  Function:   GetRegistryDwords
//
//  Synopsis:   Gets a set of DWORDs from the registry
//
//  Effects:
//
//  Arguments:  [hPrimaryKey] --    Key to start from
//              [pszKey] --         Name of the subkey
//              [Count] --          Number of values
//              [Values] --         returned values
//
//  Returns:    Nothing (Default values assumed on error)
//
//  History:    3-31-93   RichardW   Created
//              10-14-01  MarkPu     Enabled multiple values
//
//----------------------------------------------------------------------------

VOID
GetRegistryDwords(
    IN HKEY       hKey,
    IN ULONG      Count,
    IN PKDC_REG_PARAMETER Values
    )
{
    static BOOL ValuesInitialized = FALSE;

    while ( Count-- > 0 ) {

        LONG    err;
        DWORD   dwType;
        DWORD   dwValue;
        DWORD   cbDword = sizeof(DWORD);

        if ( Values[Count].Dynamic == FALSE &&
             ValuesInitialized )
        {
            //
            // Only initialize static values once!!!
            //

            continue;
        }

        err = RegQueryValueEx(
                  hKey,
                  Values[Count].Name,
                  NULL,
                  &dwType,
                  (PBYTE) &dwValue,
                  &cbDword
                  );

        if ( err || ( dwType != REG_DWORD )) {

            *Values[Count].Address = Values[Count].DefaultValue;

        } else if ( Values[Count].ReverseSense ) {

            *Values[Count].Address = !dwValue;

        } else {

            *Values[Count].Address = dwValue;
        }
    }

    ValuesInitialized = TRUE;
}


////////////////////////////////////////////////////////////////////
//
//  Name:       KerbGetKdcRegParams
//
//  Synopsis:   Gets the debug paramaters from the registry
//
//  Arguments:  HKEY to HKLM/System/CCS/Services/Kdc
//
//  Notes:      Sets KDCInfolevel for debug spew
//
void
KerbGetKdcRegParams(HKEY ParamKey)
{
    //
    // NOTE: UDP datagram size is NOT dynamic; changing it requires restaring
    // the KDC.  The reason is that this is the value that we initialize ATQ
    // with and ATQ can't be re-initialized underneath a running KDC.
    // See bug #645637 for details.
    //

    KDC_REG_PARAMETER Parameters[] =
    {
        { L"KdcUseClientAddresses", &KdcUseClientAddresses, KdcUseClientAddressesDefault,  FALSE, TRUE },
        { L"KdcDontCheckAddresses", &KdcDontCheckAddresses, KdcDontCheckAddressesDefault,  FALSE, TRUE },
        { L"NewConnectionTimeout",  &KdcNewConnectionTimeout, KdcNewConnectionTimeoutDefault, FALSE, TRUE },
        { L"ExistingConnectionTimeout", &KdcExistingConnectionTimeout, KdcExistingConnectionTimeoutDefault, FALSE, TRUE },
        { L"MaxDatagramReplySize", &KdcGlobalMaxDatagramReplySize, KdcMaxDatagramReplySizeDefault, FALSE, FALSE },
        { L"KdcExtraLogLevel", &KdcExtraLogLevel, KdcExtraLogLevelDefault, FALSE, TRUE },
        { L"KdcDebugLevel", &KDCInfoLevel, KdcInfoLevelDefault, FALSE, TRUE },
        { L"KdcIssueForwardedTickets", &KdcIssueForwardedTickets, KdcIssueForwardedTicketsDefault, FALSE, TRUE }
    };

    //
    // Get the DWORD parameters that can change during a boot.
    //

    GetRegistryDwords(
        ParamKey,
        sizeof( Parameters ) / sizeof( Parameters[0]),
        Parameters
        );

    //
    // BUG 676343
    // UDP packets have a 2-byte length field so under no
    // circumstances can they be bigger than 64K
    //

    KdcGlobalMaxDatagramReplySize = min( KdcGlobalMaxDatagramReplySize, 64 * 1024 );

    //
    // Fixup the common2 debug level.
    //

    KSuppInfoLevel = KDCInfoLevel;
}


////////////////////////////////////////////////////////////////////
//
//  Name:       KerbWatchKdcParamKey
//
//  Synopsis:   Sets RegNotifyChangeKeyValue() on param key, initializes
//              debug level, then utilizes thread pool to wait on
//              changes to this registry key.  Enables dynamic debug
//              level changes, as this function will also be callback
//              if registry key modified.
//
//  Arguments:  pCtxt is actually a HANDLE to an event.  This event
//              will be triggered when key is modified.
//
//  Notes:      .
//
VOID
KerbWatchKdcParamKey(PVOID    pCtxt,
                  BOOLEAN  fWaitStatus)
{

    NTSTATUS    Status;
    LONG        lRes = ERROR_SUCCESS;

    if (NULL == hKdcParams)  // first time we've been called.
    {
        lRes = RegOpenKeyExW(
                   HKEY_LOCAL_MACHINE,
                   L"System\\CurrentControlSet\\Services\\Kdc",
                   0,
                   KEY_READ,
                   &hKdcParams
                   );

        if (ERROR_SUCCESS != lRes)
        {
            DebugLog((DEB_WARN,"Failed to open kerberos key: 0x%x\n", lRes));
            goto Reregister;
        }
    }

    if (NULL != hKdcWait)
    {
        Status = RtlDeregisterWait(hKdcWait);
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_WARN, "Failed to Deregister wait on registry key: 0x%x\n", Status));
            goto Reregister;
        }

    }

    lRes = RegNotifyChangeKeyValue(
                hKdcParams,
                FALSE,
                REG_NOTIFY_CHANGE_LAST_SET,
                (HANDLE) pCtxt,
                TRUE);

    if (ERROR_SUCCESS != lRes)
    {
        DebugLog((DEB_ERROR,"Debug RegNotify setup failed: 0x%x\n", lRes));
        // we're tanked now. No further notifications, so get this one
    }

    KerbGetKdcRegParams(hKdcParams);

Reregister:

    Status = RtlRegisterWait(&hKdcWait,
                             (HANDLE) pCtxt,
                             KerbWatchKdcParamKey,
                             (HANDLE) pCtxt,
                             INFINITE,
                             WT_EXECUTEONLYONCE);

}

////////////////////////////////////////////////////////////////////
//
//  Name:       WaitKdcCleanup
//
//  Synopsis:   Cleans up for KerbWatchKdcParamKey
//
//  Arguments:  <none>
//
//  Notes:      .
//
VOID
WaitKdcCleanup(HANDLE hEvent)
{
    NTSTATUS    Status = STATUS_SUCCESS;

    if (NULL != hKdcWait) {
        Status = RtlDeregisterWait(hKdcWait);
        hKdcWait = NULL;
    }

    if (NT_SUCCESS(Status) && NULL != hEvent) {
        CloseHandle(hEvent);
        hEvent = NULL;
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   OpenAccountDomain
//
//  Synopsis:   Opens the account domain and stores a handle to it.
//
//  Effects:    Sets GlobalAccountDomainHandle and GlobalPolicyHandle on
//              success.
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
OpenAccountDomain()
{
    NTSTATUS Status;
    PLSAPR_POLICY_INFORMATION PolicyInformation = NULL;
    SAMPR_HANDLE ServerHandle = NULL;
    ULONG BuiltInSubAuthority = SECURITY_BUILTIN_DOMAIN_RID;
    ULONG AuthenticatedSubAuthority = SECURITY_AUTHENTICATED_USER_RID;
    ULONG ThisOrganizationSubAuthority = SECURITY_THIS_ORGANIZATION_RID;
    ULONG OtherOrganizationSubAuthority = SECURITY_OTHER_ORGANIZATION_RID;

    SID_IDENTIFIER_AUTHORITY SidAuthority = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY WorldAuthority = SECURITY_WORLD_SID_AUTHORITY;

    PSID TmpBuiltInSid = NULL;

    Status = LsaIOpenPolicyTrusted( & GlobalPolicyHandle );
    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"Failed to open policy trusted: 0x%x\n",Status));
        goto Cleanup;
    }

    Status = LsarQueryInformationPolicy(
                GlobalPolicyHandle,
                PolicyAccountDomainInformation,
                &PolicyInformation
                );
    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"Failed to query information policy: 0x%x\n",Status));
        goto Cleanup;
    }

    //
    // Get the name and SID out of the account domain information
    //

    Status = KerbDuplicateString(
                &GlobalDomainName,
                (PUNICODE_STRING) &PolicyInformation->PolicyAccountDomainInfo.DomainName
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    GlobalDomainSid = (PSID) LocalAlloc(0, RtlLengthSid(PolicyInformation->PolicyAccountDomainInfo.DomainSid));
    if (GlobalDomainSid == 0)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }
    RtlCopyMemory(
        GlobalDomainSid,
        PolicyInformation->PolicyAccountDomainInfo.DomainSid,
        RtlLengthSid(PolicyInformation->PolicyAccountDomainInfo.DomainSid)
        );

    //
    // Connect to SAM and open the account domain
    //

    Status = SamIConnect(
                NULL,           // no server name
                &ServerHandle,
                0,              // ignore desired access,
                TRUE            // trusted caller
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to connect to SAM: 0x%x\n",Status));
        goto Cleanup;
    }

    //
    // Finally open the account domain.
    //

    Status = SamrOpenDomain(
                ServerHandle,
                DOMAIN_ALL_ACCESS,
                (PRPC_SID) PolicyInformation->PolicyAccountDomainInfo.DomainSid,
                &GlobalAccountDomainHandle
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "Failed to open account domain: 0x%x\n",Status));
        goto Cleanup;
    }


    //
    // Create the built-in group sid, the everyone sid, and
    // the authenticated user sid.  These are used to build authz sid lists.
    //


    GlobalBuiltInSid = (PSID) LocalAlloc(LMEM_ZEROINIT, RtlLengthRequiredSid(2));
    if (NULL == GlobalBuiltInSid)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    RtlInitializeSid(
        GlobalBuiltInSid,
        &SidAuthority,
        2
        );

    RtlCopyMemory(
        RtlSubAuthoritySid(GlobalBuiltInSid,0),
        &BuiltInSubAuthority,
        sizeof(ULONG)
        );



    //
    // Everyone sid
    //
    GlobalEveryoneSid = (PSID) LocalAlloc(LMEM_ZEROINIT, RtlLengthRequiredSid(1));
    if (NULL == GlobalEveryoneSid)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    RtlInitializeSid(
        GlobalEveryoneSid,
        &WorldAuthority,
        1
        );


    //
    // Authenticated user sid
    //
    GlobalAuthenticatedUserSid = (PSID) LocalAlloc(LMEM_ZEROINIT, RtlLengthRequiredSid(1));
    if (NULL == GlobalAuthenticatedUserSid)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    RtlInitializeSid(
        GlobalAuthenticatedUserSid,
        &SidAuthority,
        1
        );

    RtlCopyMemory(
        RtlSubAuthoritySid(GlobalAuthenticatedUserSid,0),
        &AuthenticatedSubAuthority,
        sizeof(ULONG)
        );

    //
    // "This Organization" SID
    //
    GlobalThisOrganizationSid = (PSID) LocalAlloc(LMEM_ZEROINIT, RtlLengthRequiredSid(1));
    if (NULL == GlobalThisOrganizationSid)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    RtlInitializeSid(
        GlobalThisOrganizationSid, 
        &SidAuthority, 
        1
        );

    RtlCopyMemory(
        RtlSubAuthoritySid(GlobalThisOrganizationSid,0),
        &ThisOrganizationSubAuthority,
        sizeof(ULONG)
        );

    //
    // "Other Organization" SID
    //
    GlobalOtherOrganizationSid = (PSID) LocalAlloc(LMEM_ZEROINIT, RtlLengthRequiredSid(1));
    if (NULL == GlobalOtherOrganizationSid)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    RtlInitializeSid(
        GlobalOtherOrganizationSid, 
        &SidAuthority, 
        1
        );

    RtlCopyMemory(
        RtlSubAuthoritySid(GlobalOtherOrganizationSid,0),
        &OtherOrganizationSubAuthority,
        sizeof(ULONG)
        );

    //
    // Make a temporary sid, w/ only 1 sub authority.  The above "GlobalBuiltinSid"
    // is explicitly used to build other builtin sids for S4u checks.
    //
    TmpBuiltInSid = (PSID) LocalAlloc(LMEM_ZEROINIT, RtlLengthRequiredSid(1));
    if (NULL == TmpBuiltInSid)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    RtlInitializeSid(
        TmpBuiltInSid,
        &SidAuthority,
        1
        );

    RtlCopyMemory(
        RtlSubAuthoritySid(TmpBuiltInSid,0),
        &BuiltInSubAuthority,
        sizeof(ULONG)
        );

    Status = SamrOpenDomain(
               ServerHandle,
               DOMAIN_ALL_ACCESS,
               (PRPC_SID) TmpBuiltInSid,
               &GlobalBuiltInDomainHandle
               );

   if (!NT_SUCCESS(Status))
   {
       DebugLog((DEB_ERROR, "Failed to open builtin domain: 0x%x\n",Status));
       goto Cleanup;
   }


Cleanup:
    if (PolicyInformation != NULL)
    {
        LsaIFree_LSAPR_POLICY_INFORMATION(
                PolicyAccountDomainInformation,
                PolicyInformation
                );
    }
    if (ServerHandle != NULL)
    {
        SamrCloseHandle(&ServerHandle);
    }
    if (!NT_SUCCESS(Status))
    {
        if (GlobalPolicyHandle != NULL)
        {
            LsarClose(&GlobalPolicyHandle);
            GlobalPolicyHandle = NULL;
        }
        if (GlobalAccountDomainHandle != NULL)
        {
            SamrCloseHandle(&GlobalAccountDomainHandle);
            GlobalAccountDomainHandle = NULL;
        }

        if (GlobalBuiltInDomainHandle != NULL)
        {
            SamrCloseHandle(&GlobalBuiltInDomainHandle);
            GlobalBuiltInDomainHandle = NULL;
        }

        if (GlobalBuiltInSid != NULL)
        {
            LocalFree(GlobalBuiltInSid);
            GlobalBuiltInSid = NULL;
        }

        if (GlobalEveryoneSid != NULL)
        {
            LocalFree(GlobalEveryoneSid);
            GlobalEveryoneSid = NULL;
        }

        if (GlobalAuthenticatedUserSid != NULL)
        {
            LocalFree(GlobalAuthenticatedUserSid);
            GlobalAuthenticatedUserSid = NULL;
        }

        if (GlobalThisOrganizationSid != NULL)
        {
            LocalFree(GlobalThisOrganizationSid);
            GlobalThisOrganizationSid = NULL;
        }

        if (GlobalOtherOrganizationSid != NULL)
        {
            LocalFree(GlobalOtherOrganizationSid);
            GlobalOtherOrganizationSid = NULL;
        }
    }

    if (TmpBuiltInSid != NULL)
    {
        LocalFree(TmpBuiltInSid);
    }


    return(Status);


}


//+-------------------------------------------------------------------------
//
//  Function:   CleanupAccountDomain
//
//  Synopsis:   cleans up resources associated with SAM and LSA
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
CleanupAccountDomain()
{
    if (GlobalPolicyHandle != NULL)
    {
        LsarClose(&GlobalPolicyHandle);
        GlobalPolicyHandle = NULL;
    }

    if (GlobalAccountDomainHandle != NULL)
    {
        SamrCloseHandle(&GlobalAccountDomainHandle);
        GlobalAccountDomainHandle = NULL;
    }

    if ( GlobalBuiltInDomainHandle != NULL )
    {
        SamrCloseHandle(&GlobalBuiltInDomainHandle);
        GlobalBuiltInDomainHandle = NULL;
    }

    KerbFreeString(&GlobalDomainName);

    if (GlobalDomainSid != NULL)
    {
        LocalFree(GlobalDomainSid);
        GlobalDomainSid = NULL;
    }

    if (GlobalBuiltInSid != NULL)
    {
        LocalFree(GlobalBuiltInSid);
        GlobalBuiltInSid = NULL;
    }

    if (GlobalEveryoneSid != NULL)
    {
        LocalFree(GlobalEveryoneSid);
        GlobalEveryoneSid = NULL;
    }

    if (GlobalAuthenticatedUserSid != NULL)
    {
        LocalFree(GlobalAuthenticatedUserSid);
        GlobalAuthenticatedUserSid = NULL;
    } 

    if (GlobalThisOrganizationSid != NULL)
    {
        LocalFree(GlobalThisOrganizationSid);
        GlobalThisOrganizationSid = NULL;
    }

    if (GlobalOtherOrganizationSid != NULL)
    {
        LocalFree(GlobalOtherOrganizationSid);
        GlobalOtherOrganizationSid = NULL;
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbInitPreferredCryptList
//
//  Synopsis:   Build a crypt list, the strongest etype first, used to select
//              etype_for_key(server.key) per rfc 1510
//
//--------------------------------------------------------------------------

NTSTATUS
KerbInitPreferredCryptList(
    VOID
    )
{
    KERBERR KerbErr = KRB_ERR_GENERIC;

    ULONG CryptTypes[KERB_MAX_CRYPTO_SYSTEMS] = {0};
    ULONG CryptTypeCount = 0;

    CryptTypes[CryptTypeCount++] = KERB_ETYPE_RC4_HMAC_NT;
    CryptTypes[CryptTypeCount++] = KERB_ETYPE_RC4_HMAC_NT_EXP;
    CryptTypes[CryptTypeCount++] = KERB_ETYPE_DES_CBC_MD5_NT;
    CryptTypes[CryptTypeCount++] = KERB_ETYPE_DES_CBC_MD5;
    CryptTypes[CryptTypeCount++] = KERB_ETYPE_DES_CBC_CRC;

    KerbErr = KerbConvertArrayToCryptList(
                      &kdc_pPreferredCryptList,
                      CryptTypes,
                      CryptTypeCount,
                      FALSE
                      );
    if (KERB_SUCCESS(KerbErr))
    {
        CryptTypeCount = 0;
        CryptTypes[CryptTypeCount++] = KERB_ETYPE_DES_CBC_MD5;
        CryptTypes[CryptTypeCount++] = KERB_ETYPE_DES_CBC_CRC;
        KerbErr = KerbConvertArrayToCryptList(
                  &kdc_pMitPrincipalPreferredCryptList,
                  CryptTypes,
                  CryptTypeCount,
                  FALSE
                  );
    }

    return KerbMapKerbError(KerbErr);
}

//+-------------------------------------------------------------------------
//
//  Name:       KdcServiceMain
//
//  Synopsis:   This is the main KDC thread.
//
//  Arguments:  dwArgc   -
//              pszArgv  -
//
//  Notes:      This intializes everything, and starts the working threads.
//
//--------------------------------------------------------------------------

extern "C"
void
KdcServiceMain( DWORD   dwArgc,
                LPTSTR *pszArgv)
{
    UNREFERENCED_PARAMETER(dwArgc);
    UNREFERENCED_PARAMETER(pszArgv);

    TRACE(KDC, KdcServiceMain, DEB_FUNCTION);

    ULONG     RpcStatus;
    HANDLE    hKdcParamEvent = NULL;
    ULONG     ulStates = 0;
    NTSTATUS  NtStatus = STATUS_SUCCESS;
    NTSTATUS  TempStatus;
    NT_PRODUCT_TYPE NtProductType;

#define RPCDONE        0x1
#define LOCATORSTARTED 0x2
#define CRITSECSDONE   0x4

    KdcState = Starting;

    //
    // Get the debugging parameters
    //

    GetDebugParams();

    //
    // Get other parameters, register wait on registry keys
    //

    KdcLoadParameters();

#ifdef ROGUE_DC

    if ( ERROR_SUCCESS != RegOpenKeyExW(
                              HKEY_LOCAL_MACHINE,
                              L"System\\CurrentControlSet\\Services\\Kdc\\Rogue",
                              0,
                              KEY_READ,
                              &hKdcRogueKey ))
    {
        DebugLog((DEB_WARN,"Failed to open \"rogue\" kerberos key\n" ));
    }

#endif

    hKdcParamEvent = CreateEvent(
                        NULL,
                        FALSE,
                        FALSE,
                        NULL
                        );

    if (NULL == hKdcParamEvent)
    {
        D_DebugLog((DEB_WARN, "CreateEvent for KdcParamEvent failed - 0x%x\n", GetLastError()));
    }
    else
    {
        KerbWatchKdcParamKey( hKdcParamEvent, FALSE );
    }
   
    D_DebugLog((DEB_TRACE, "Start KdcServiceMain\n"));

    //
    // Notify the service controller that we are starting.
    //

    hService = RegisterServiceCtrlHandler(SERVICE_KDC, Handler);
    if (!hService)
    {
        D_DebugLog((DEB_ERROR, "Could not register handler, %d\n", GetLastError()));
    }

    SStatus.dwServiceType = SERVICE_WIN32_SHARE_PROCESS;
    SStatus.dwCurrentState = SERVICE_STOPPED;
    SStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP;
    SStatus.dwWin32ExitCode = 0;
    SStatus.dwServiceSpecificExitCode = 0;
    SStatus.dwCheckPoint = 0;
    SStatus.dwWaitHint = 0;

    if (!UpdateStatus(SERVICE_START_PENDING) )
    {
        goto Shutdown;
    }

    //
    // Set up the event log service
    //

    InitializeEvents();

    //
    // Check out product type
    //

    if ( !RtlGetNtProductType( &NtProductType ) || ( NtProductType != NtProductLanManNt ) ) {
        D_DebugLog((DEB_WARN, "Can't start KDC on non-lanmanNT systems\n"));
        NtStatus = STATUS_MUST_BE_KDC;
        goto Shutdown;
    }

    RtlInitUnicodeString(
        &GlobalKerberosName,
        MICROSOFT_KERBEROS_NAME_W
        );

    RtlInitUnicodeString(
        &GlobalKdcName,
        SERVICE_KDC
        );

    //
    // Turn on safealloca support
    //
    SafeAllocaInitialize(SAFEALLOCA_USE_DEFAULT, SAFEALLOCA_USE_DEFAULT, KdcAllocate, KdcFree);

    //
    // Build our Kpasswd name, so we don't have to alloc on
    // every TGS request.
    //
    NtStatus = KerbBuildKpasswdName(
                  &GlobalKpasswdName
                  );

    if (!NT_SUCCESS(NtStatus))
    {
        D_DebugLog((DEB_ERROR, "Failed to build KPASSWD name, error 0x%X\n", NtStatus));
        goto Shutdown;
    }

    GlobalLocalhostAddress[0] = 127;
    GlobalLocalhostAddress[1] = 0;
    GlobalLocalhostAddress[2] = 0;
    GlobalLocalhostAddress[3] = 1;

    //
    // Wait for SAM to start
    //

    if (!KdcWaitForSamService( ))
    {
        NtStatus = STATUS_INVALID_SERVER_STATE;
        goto Shutdown;
    }

    //
    // Initialize the AuthZ resource manager
    //

    NtStatus = KdcInitializeAuthzRM();
    if ( !NT_SUCCESS( NtStatus ))
    {
        D_DebugLog((DEB_ERROR, "Failed to intialize the AuthZ resource manager, error 0x%X\n", NtStatus));
        goto Shutdown;
    }

    if (!UpdateStatus(SERVICE_START_PENDING) )
    {
        goto Shutdown;
    }

    //
    // Can't proceed unless the kerb SSPI package has initialized
    // (KerbKdcCallback might get invoked and that requires kerb
    //  global resource being intialized)
    //

    if (!KerbIsInitialized())
    {
        NtStatus = STATUS_UNSUCCESSFUL;
        DebugLog((DEB_ERROR, "Kerb SSPI package not initialized: 0x%x\n",NtStatus));
        goto Shutdown;
    }

    NtStatus = KerbInitPreferredCryptList();
    if (!NT_SUCCESS(NtStatus))
    {
        DebugLog((DEB_ERROR, "KdcServiceMain could not initialized preferrred crypt list: 0x%x\n", NtStatus));
        goto Shutdown;
    }

    //
    // Register for the Ds callback
    //

    if (!KdcRegisterToWaitForDS( ))
    {
        NtStatus = STATUS_INVALID_SERVER_STATE;
        goto Shutdown;
    }

    if (!UpdateStatus(SERVICE_START_PENDING) )
    {
        goto Shutdown;
    }

    //
    // Get a handle to the SAM account domain
    //

    NtStatus = OpenAccountDomain();

    if (!NT_SUCCESS(NtStatus))
    {
        DebugLog((DEB_ERROR, "Failed to get domain handle: 0x%x\n",NtStatus));
        goto Shutdown;
    }

    if (!UpdateStatus(SERVICE_START_PENDING) )
    {
        goto Shutdown;
    }

    //
    // Initialize the PK infrastructure
    //

    NtStatus = KdcInitializeCerts();
    if (!NT_SUCCESS(NtStatus))
    {
        D_DebugLog((DEB_ERROR,"Failed to initialize certs: 0x%x\n",NtStatus));
        goto Shutdown;
    }

    if (!UpdateStatus(SERVICE_START_PENDING) )
    {
        goto Shutdown;
    }

    //
    // Start the RPC sequences
    //

    NtStatus = StartAllProtSeqs();

    if (!NT_SUCCESS(NtStatus))
    {
        D_DebugLog((DEB_ERROR, "Failed to start RPC, error 0x%X\n", NtStatus));
        goto Shutdown;
    }

    //
    // Start the socket listening code.
    //

    if (!UpdateStatus(SERVICE_START_PENDING) )
    {
        goto Shutdown;
    }

    //
    // Load all global data into the SecData structure.
    //

    NtStatus = SecData.Init();
    if (!NT_SUCCESS(NtStatus))
    {
        D_DebugLog((DEB_ERROR, "Failed to init SecData error 0x%X\n", NtStatus));
        goto Shutdown;
    }

    //
    // Set the flag to indicate this is a trust account
    //

    // KdcTicketInfo.UserAccountControl |= USER_INTERDOMAIN_TRUST_ACCOUNT;

    if (!UpdateStatus(SERVICE_START_PENDING) )
    {
        goto Shutdown;
    }

    //
    // Create the KDC shutdown event, set to FALSE
    //
    hKdcShutdownEvent = CreateEvent( NULL,      // no security attributes
                                     TRUE,      // manual reset
                                     FALSE,     // initial state
                                     NULL );    // unnamed event.
    if (hKdcShutdownEvent == NULL)
    {
        NtStatus = (NTSTATUS) GetLastError();

        D_DebugLog(( DEB_ERROR, "KDC can't create shutdown event: wincode=%d.\n",
                    NtStatus ));

        goto Shutdown;
    }

    if (!UpdateStatus(SERVICE_START_PENDING) )
    {
        goto Shutdown;
    }

#if DBG
    NtStatus = RegisterKdcEps();
    if (!NT_SUCCESS(NtStatus))
    {
        D_DebugLog((DEB_ERROR, "Ep register failed %x\n", NtStatus));
//        goto Shutdown;
    }
#endif // DBG

    ulStates |= RPCDONE;

    //
    // 1 is the minimum number of threads.
    // TRUE means the call will return, rather than waiting until the
    //     server shuts down.
    //

    NtStatus = KdcInitializeSockets();
    if (!NT_SUCCESS(NtStatus))
    {
        D_DebugLog((DEB_ERROR, "Failed to initailzie sockets\n"));
        goto Shutdown;
    }

    if (!UpdateStatus(SERVICE_START_PENDING) )
    {
        goto Shutdown;
    }

    InitializeListHead(&KdcDomainList);
    NtStatus = (NTSTATUS) KdcReloadDomainTree( NULL );
    if (!NT_SUCCESS(NtStatus))
    {
        D_DebugLog((DEB_ERROR, "Failed to build domain tree: 0x%x\n",NtStatus));
        goto Shutdown;
    }

    if (!UpdateStatus(SERVICE_START_PENDING) )
    {
        goto Shutdown;
    }

    //
    // Check to see if there is a CSP registered for replacing the StringToKey calculation
    //
    CheckForOutsideStringToKey();

    if (!UpdateStatus(SERVICE_START_PENDING) )
    {
        goto Shutdown;
    }

    NtStatus = LsaIKerberosRegisterTrustNotification( KdcTrustChangeCallback, LsaRegister );
    if (!NT_SUCCESS( NtStatus ))
    {
        D_DebugLog((DEB_ERROR, "Failed to register notification\n"));
    }


    RpcStatus = RpcServerListen(1, RPC_C_LISTEN_MAX_CALLS_DEFAULT, TRUE);

    if (RpcStatus != ERROR_SUCCESS)
    {
        if (RpcStatus != RPC_S_ALREADY_LISTENING)
        {
            D_DebugLog(( DEB_ERROR, "Error from RpcServerListen: %d\n", RpcStatus ));
            NtStatus = I_RpcMapWin32Status(RpcStatus);
            goto Shutdown;
        }
    }

    // Initialize the GlobalCert
    KdcMyStoreWaitHandler (NULL, TRUE);

    //
    // At this point the KDC is officially started.
    // 3 * ( 2*(hip) horray! )
    //

    if (!UpdateStatus(SERVICE_RUNNING) )
    {
        goto Shutdown;
    }

#if DBG
    GetSystemTimeAsFileTime((PFILETIME)&tsOut);
    D_DebugLog((DEB_TRACE, "Time required for KDC to start up: %d ms\n",
                         (tsOut.LowPart-tsIn.LowPart) / 10000));
#endif


    SetKdcStartEvent();

    KdcState = Running;

    KdcInitializeTrace();

    // This function will loop until the event is true.

    // WAS BUG: turn off cache manager for now.
    // This bug comment is a stale piece of code from
    // Cairo days - per MikeSw
    //

    WaitForSingleObject(hKdcShutdownEvent, INFINITE);

Shutdown:

    LsaIKerberosRegisterTrustNotification( KdcTrustChangeCallback, LsaUnregister );
    LsaIUnregisterAllPolicyChangeNotificationCallback(KdcPolicyChangeCallBack);

    //
    // Time to cleanup up all resources ...
    //

    TempStatus = I_NetLogonSetServiceBits( DS_KDC_FLAG, 0 );
    if ( !NT_SUCCESS(TempStatus) ) {
        D_DebugLog((DEB_TRACE,"Can't tell netlogon we're stopped 0x%lX\n", TempStatus ));
    }

    //
    // Remove the wait routine for the DS paused event
    //

    if ( KdcGlobalDsPausedWaitHandle != NULL ) {

        UnregisterWaitEx( KdcGlobalDsPausedWaitHandle,
                          INVALID_HANDLE_VALUE ); // Wait until routine finishes execution

        KdcGlobalDsPausedWaitHandle = NULL;
    }

    if (NULL != GlobalKpasswdName)
    {
       KerbFreeKdcName(&GlobalKpasswdName);
    }

    if (KdcGlobalDsEventHandle)
    {
        CloseHandle( KdcGlobalDsEventHandle );
        KdcGlobalDsEventHandle = NULL;
    }

    //
    // Shut down event log service.
    //
    ShutdownEvents();


    UpdateStatus(SERVICE_STOP_PENDING);


#if DBG
    if (ulStates & RPCDONE)
    {
       (VOID)UnRegisterKdcEps();
       UpdateStatus(SERVICE_STOP_PENDING);
    }
#endif // DBG

    KdcShutdownSockets();

    KdcFreeAuthzRm();

    KdcCleanupCerts(
        TRUE            // cleanup scavenger
        );

    UpdateStatus(SERVICE_STOP_PENDING);

    //
    // Close all of the events.
    //

    {
        PHANDLE ph = &hKdcHandles[0];

        for (;ph < &hKdcHandles[MAX_KDC_HANDLE]; ph++)
        {
            if (*ph)
            {
                CloseHandle(*ph);
                *ph = NULL;
            }
        }
    }

    if ( hKdcParamEvent ) {
        WaitKdcCleanup( hKdcParamEvent );
    }

    //
    // Cleanup handles to SAM & LSA and global variables
    //

    CleanupAccountDomain();

    UpdateStatus(SERVICE_STOP_PENDING);

    //
    // Cleanup the domain list
    //

    //
    // BUGBUG: need to make sure it is not being used.
    //

    KdcFreeDomainList(&KdcDomainList);
    KdcFreeReferralCache(&KdcReferralCache);

    if (kdc_pPreferredCryptList)
    {
        KerbFreeCryptList(kdc_pPreferredCryptList);
    }
    if (kdc_pMitPrincipalPreferredCryptList)
    {
        KerbFreeCryptList(kdc_pMitPrincipalPreferredCryptList);
    }

#ifdef ROGUE_DC
    if ( hKdcRogueKey )
    {
        RegCloseKey( hKdcRogueKey );
    }
#endif

    SStatus.dwWin32ExitCode = RtlNtStatusToDosError(NtStatus);
    SStatus.dwServiceSpecificExitCode = 0;

    D_DebugLog(( DEB_TRACE, "KDC shutting down.\n" ));
    UpdateStatus(SERVICE_STOPPED);
    D_DebugLog((DEB_TRACE, "End KdcServiceMain\n"));
}

////////////////////////////////////////////////////////////////////
//
//  Name:       ShutDown
//
//  Synopsis:   Shuts the KDC down.
//
//  Arguments:  pszMessage   - message to print to debug port
//
//  Notes:      Stops RPC from accepting new calls, waits for pending calls
//              to finish, and sets the global event "hKdcShutDownEvent".
//
NTSTATUS
ShutDown(LPWSTR pszMessage)
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    TRACE(KDC, ShutDown, DEB_FUNCTION);

    D_DebugLog((DEB_WARN, "Server Shutdown:  %ws\n", pszMessage));


    //
    // Notify the all threads that we are exiting.
    //


    //
    // First set the started flag to false so nobody will try any more
    // direct calls to the KDC.
    //

    KdcState = Stopped;

    //
    // If there are any outstanding calls, let them trigger the shutdown event.
    // Otherwise set the shutdown event ourselves.
    //

    EnterCriticalSection(&ApiCriticalSection);
    if (CurrentApiCallers == 0)
    {

        if (!SetEvent( hKdcShutdownEvent ) )
        {
            D_DebugLog(( DEB_ERROR, "Couldn't set KDC shutdown event.  winerr=%d.\n",
                        GetLastError() ));
            NtStatus = STATUS_UNSUCCESSFUL;
        }
        SecData.Cleanup();
        if (KdcTraceRegistrationHandle != (TRACEHANDLE)0)
        {
            UnregisterTraceGuids( KdcTraceRegistrationHandle );
            KdcTraceRegistrationHandle = (TRACEHANDLE)0;
        }
    }
    LeaveCriticalSection(&ApiCriticalSection);

    return(NtStatus);
}

//+-------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:   DLL initialization routine
//
//--------------------------------------------------------------------------

extern "C" BOOL WINAPI
DllMain (
    HINSTANCE hInstance,
    DWORD dwReason,
    PVOID lpReserved
    )
{
    BOOL bReturn = TRUE;

    if ( dwReason == DLL_PROCESS_ATTACH )
    {
        DisableThreadLibraryCalls ( hInstance );

        //
        // WAS BUG: call the Rtl version here because it returns an error
        // instead of throwing an exception.  Leave it here, as we don't
        // really need to put a try/except around InitCritSec.
        //

        bReturn = NT_SUCCESS(RtlInitializeCriticalSection( &ApiCriticalSection ));

        if (bReturn)
        {
            bReturn = NT_SUCCESS(SecData.InitLock());

            if (!bReturn)
            {
                RtlDeleteCriticalSection(&ApiCriticalSection);
            }
        }
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        DeleteCriticalSection(&ApiCriticalSection);
    }

    return bReturn;
    UNREFERENCED_PARAMETER(lpReserved);
    UNREFERENCED_PARAMETER(hInstance);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\server\kdcdbg_s_stub.c ===
#include "krbprgma.h"
#include "kdcdbg_s.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\server\dgutil.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1995
//
// File:        dgutil.cxx
//
// Contents:    Server support routines for datagram sockets
//
//
// History:     10-July-1996    MikeSw  Created
//
//------------------------------------------------------------------------


#include "kdcsvr.hxx"
#include "sockutil.h"
extern "C"
{
#include <atq.h>
#include <nlrepl.h>
}
#include <issched.hxx>
#include "fileno.h"
#define FILENO FILENO_DGUTIL

#define KDC_KEY                         "System\\CurrentControlSet\\Services\\kdc"
#define KDC_PARAMETERS_KEY KDC_KEY      "\\parameters"
#define KDC_MAX_ACCEPT_BUFFER           5000
#define KDC_MAX_ACCEPT_OUTSTANDING      5
#define KDC_ACCEPT_TIMEOUT              100
#define KDC_LISTEN_BACKLOG              10
#define KDC_CONTEXT_TIMEOUT             50

extern BOOLEAN KdcSocketsInitialized;

typedef struct _KDC_DATAGRAM_ENDPOINT {
    SOCKADDR LocalAddress;
    PKDC_GET_TICKET_ROUTINE EndpointFunction;
    PVOID Endpoint;
} KDC_DATAGRAM_ENDPOINT, *PKDC_DATAGRAM_ENDPOINT;

PKDC_DATAGRAM_ENDPOINT DatagramEndpoints = NULL;
ULONG DatagramEndpointCount = 0;
RTL_RESOURCE DatagramEndpointLock;
BOOL DatagramEndpointLockInitialized = FALSE;
SOCKET KdcWinsockPnpSocket = INVALID_SOCKET;
HANDLE KdcWinsockPnpEvent = NULL;
HANDLE KdcPnpEventChangeHandle = NULL;



//+-------------------------------------------------------------------------
//
//  Function:   KdcAtqDgIoCompletion
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KdcAtqDgIoCompletion(
    IN PVOID Context,
    IN DWORD BytesWritten,
    IN DWORD CompletionStatus,
    IN OVERLAPPED * lpo
    )
{

    PVOID Buffer;
    SOCKADDR * RemoteAddress = NULL;
    INT AddressSize;
    PATQ_CONTEXT AtqContext = (PATQ_CONTEXT) Context;
    SOCKET NewSocket = INVALID_SOCKET;
    KERB_MESSAGE_BUFFER InputMessage;
    KERB_MESSAGE_BUFFER OutputMessage;
    ULONG_PTR KdcContext;
    WSABUF SocketBuffer;
    PKDC_DATAGRAM_ENDPOINT Endpoint;

    TRACE(KDC,KdcAtqDgIoCompletion, DEB_FUNCTION);

    if (Context == NULL)
    {
        return;
    }

    KdcContext = AtqContextGetInfo(
                    AtqContext,
                    ATQ_INFO_COMPLETION_CONTEXT
                    );

    //
    // If the context is 1, then this is the completion from a write, so close
    // this down.
    //

    if (KdcContext == 1)
    {
        lpo = NULL;
    }

    //
    // If a client connects and then disconnects gracefully ,we will get a
    // completion with zero bytes and success status.
    //

    if ((BytesWritten == 0) && (CompletionStatus == NO_ERROR))
    {
        CompletionStatus = WSAECONNABORTED;
    }


    if ((CompletionStatus != NO_ERROR) || (lpo == NULL) || !KdcSocketsInitialized)
    {
        D_DebugLog((DEB_T_SOCK,"IoCompletion: CompletionStatus = 0x%x\n",CompletionStatus));
        D_DebugLog((DEB_T_SOCK,"IoCompletion: lpo = %p\n",lpo));
        D_DebugLog((DEB_T_SOCK, "Freeing context %p\n",AtqContext));

        if (CompletionStatus == ERROR_OPERATION_ABORTED)
        {
            AtqCloseSocket( AtqContext, TRUE );
            AtqFreeContext( (PATQ_CONTEXT) AtqContext, FALSE );
            return;
        }
        else if ( CompletionStatus != ERROR_MORE_DATA )
        {
            AtqFreeContext( (PATQ_CONTEXT) AtqContext, TRUE );
            return;
        }
    }

    //
    // Obtain shared access to the global endpoint list
    //

    RtlAcquireResourceShared( &DatagramEndpointLock , TRUE );

    //
    // Can not proceed unless there are endpoints registered
    //

    if ( DatagramEndpointCount == 0 )
    {
        AtqFreeContext( (PATQ_CONTEXT) AtqContext, TRUE );
        goto Cleanup;
    }

    AtqGetDatagramAddrs(
        AtqContext,
        &NewSocket,
        &Buffer,
        (PVOID *) &Endpoint,
        &RemoteAddress,
        &AddressSize
        );

    //
    // If the remote address is port 88, don't respond, as we don't
    // want to be vulnerable to a loopback attack.
    //

    if ((AddressSize >= sizeof(SOCKADDR_IN) &&
        ((((SOCKADDR_IN *) RemoteAddress)->sin_port ==  KERB_KDC_PORT) ||
        (((SOCKADDR_IN *) RemoteAddress)->sin_port ==  KERB_KPASSWD_PORT))))
    {
        //
        // Just free up the context so it can be reused.
        //

        AtqFreeContext( (PATQ_CONTEXT) AtqContext, TRUE );
        goto Cleanup;
    }

    //fester
    D_DebugLog((DEB_T_SOCK, "Bytes written - %x\n", BytesWritten));

    //
    // There is a buffer, so use it to do the KDC thang.
    //

    InputMessage.BufferSize = BytesWritten;
    InputMessage.Buffer = (PUCHAR) Buffer;
    OutputMessage.Buffer = NULL;

    if ( CompletionStatus != ERROR_MORE_DATA )
    {
        Endpoint->EndpointFunction(
            NULL,           // no atq context for retries
            RemoteAddress,
            &Endpoint->LocalAddress,
            &InputMessage,
            &OutputMessage
            );
    }
    else
    {
        //
        // For now, if client sends us more data over UDP than we can swallow
        // (indicated by a completion status of ERROR_MORE_DATA), just send
        // a response of "response too big" back to them, which will cause
        // the Windows client (and hopefully a future MIT client) to switch
        // over to TCP
        //
        // In a future release, ATQ should be less timid and give us all the
        // UDP data that was received, in which case this logic could be pulled
        //

        KERB_EXT_ERROR  ExtendedError = {0,0};

        KerbBuildErrorMessageEx(
            KRB_ERR_RESPONSE_TOO_BIG,
            &ExtendedError,
            SecData.KdcDnsRealmName(),
            SecData.KdcInternalName(),
            NULL,
            NULL,
            0,
            &OutputMessage.BufferSize,
            &OutputMessage.Buffer
            );
    }

    //
    // If there is a response, write it back to the sender.
    //

    if (OutputMessage.Buffer != NULL)
    {
        DsysAssert(OutputMessage.BufferSize < max( KdcGlobalMaxDatagramReplySize, KDC_MAX_ACCEPT_BUFFER));

        RtlCopyMemory(
            Buffer,
            OutputMessage.Buffer,
            OutputMessage.BufferSize
            );

        KdcFreeEncodedData(OutputMessage.Buffer);

        SocketBuffer.buf = (char *) Buffer;
        SocketBuffer.len = OutputMessage.BufferSize;

        AtqContextSetInfo(
            AtqContext,
            ATQ_INFO_COMPLETION_CONTEXT,
            1       
            );

        if (!AtqWriteDatagramSocket(
                (PATQ_CONTEXT) AtqContext,
                &SocketBuffer,
                1,              // 1 buffer
                NULL            // no OVERLAPPED
                ))
        {
            DebugLog((DEB_ERROR,"Datagram write failed for %d bytes: 0x%x\n",OutputMessage.BufferSize,GetLastError()));
            AtqCloseSocket( AtqContext, TRUE );
            AtqFreeContext( (PATQ_CONTEXT) AtqContext, TRUE );
        }
    }
    else
    {
        //
        // Just free up the context so it can be reused.
        //

        AtqFreeContext( (PATQ_CONTEXT) AtqContext, TRUE );
    }

Cleanup:

    RtlReleaseResource( &DatagramEndpointLock );
}


//+-------------------------------------------------------------------------
//
//  Function:   KdcCreateDgAtqEndpoint
//
//  Synopsis:   Sets up a datagram endpoint
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KdcCreateDgAtqEndpoint(
    IN USHORT Port,
    IN PVOID EndpointContext,
    IN ULONG IpAddress,
    OUT PVOID * Endpoint
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    ATQ_ENDPOINT_CONFIGURATION EndpointConfig;
    SOCKET EndpointSocket = INVALID_SOCKET;
    int RecvBufSize;

    //
    // Create the endpoint config
    //

    EndpointConfig.ListenPort = Port;
    EndpointConfig.IpAddress = IpAddress;
    EndpointConfig.cbAcceptExRecvBuffer = max( KdcGlobalMaxDatagramReplySize, KDC_MAX_ACCEPT_BUFFER);
    EndpointConfig.nAcceptExOutstanding = KDC_MAX_ACCEPT_OUTSTANDING;
    EndpointConfig.AcceptExTimeout = KDC_ACCEPT_TIMEOUT;

    EndpointConfig.pfnConnect = NULL;
    EndpointConfig.pfnConnectEx = KdcAtqDgIoCompletion;
    EndpointConfig.pfnIoCompletion = KdcAtqDgIoCompletion;

    EndpointConfig.fDatagram = TRUE;
    EndpointConfig.fLockDownPort = TRUE;

    EndpointConfig.fReverseQueuing = FALSE;
    EndpointConfig.cbDatagramWSBufSize = 0;  // means use the default.

    *Endpoint = AtqCreateEndpoint(
                    &EndpointConfig,
                    EndpointContext
                    );
    if (*Endpoint == NULL)
    {
        DebugLog((DEB_ERROR,"Failed to create ATQ endpoint\n"));
        Status = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }

    //
    // Get the socket so we can change the recieve buffer size
    //

    EndpointSocket = (SOCKET) AtqEndpointGetInfo(
                                *Endpoint,
                                EndpointInfoListenSocket
                                );


    RecvBufSize = 0x8000;       // 32 k buffers
    if (setsockopt(
            EndpointSocket,
            SOL_SOCKET,
            SO_RCVBUF,
            (const char *) &RecvBufSize,
            sizeof(int)
            ))
    {
        DebugLog((DEB_ERROR,"Failed to set recv buf size to 32k: 0x%x, %d\n",
        WSAGetLastError(),WSAGetLastError()));
    }

    //
    // Start the endpoint
    //

    if (!AtqStartEndpoint(*Endpoint))
    {
        DebugLog((DEB_ERROR, "Failed to add ATQ endpoint\n"));
        Status = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }
Cleanup:
    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KdcGetAddressListFromWinsock
//
//  Synopsis:   gets the list of addresses from a winsock ioctl
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KdcGetAddressListFromWinsock(
    OUT LPSOCKET_ADDRESS_LIST * SocketAddressList
    )
{
    ULONG BytesReturned = 150;
    LPSOCKET_ADDRESS_LIST AddressList = NULL;
    INT i,j;
    ULONG NetStatus = STATUS_SUCCESS;

    for (;;) {

        //
        // Allocate a buffer that should be big enough.
        //

        if ( AddressList != NULL ) {
            MIDL_user_free( AddressList );
        }

        AddressList = (LPSOCKET_ADDRESS_LIST) MIDL_user_allocate( BytesReturned );

        if ( AddressList == NULL ) {
            NetStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        //
        // Get the list of IP addresses
        //

        NetStatus = WSAIoctl( KdcWinsockPnpSocket,
                              SIO_ADDRESS_LIST_QUERY,
                              NULL, // No input buffer
                              0,    // No input buffer
                              (PVOID) AddressList,
                              BytesReturned,
                              &BytesReturned,
                              NULL, // No overlapped,
                              NULL );   // Not async

        if ( NetStatus != 0 ) {
            NetStatus = WSAGetLastError();
            //
            // If the buffer isn't big enough, try again.
            //
            if ( NetStatus == WSAEFAULT ) {
                continue;
            }

            DebugLog((DEB_ERROR,"LdapUdpPnpBind: Cannot WSAIoctl SIO_ADDRESS_LIST_QUERY %ld %ld\n",
                      NetStatus, BytesReturned));
            goto Cleanup;
        }

        break;
    }

    //
    // Weed out any zero IP addresses and other invalid addresses
    //

    for ( i = 0, j = 0; i < AddressList->iAddressCount; i++ ) {
        PSOCKET_ADDRESS SocketAddress;

        //
        // Copy this address to the front of the list.
        //
        AddressList->Address[j] = AddressList->Address[i];

        //
        // If the address isn't valid,
        //  skip it.
        //
        SocketAddress = &AddressList->Address[j];

        if ( SocketAddress->iSockaddrLength == 0 ||
             SocketAddress->lpSockaddr == NULL ||
             SocketAddress->lpSockaddr->sa_family != AF_INET ||
             ((PSOCKADDR_IN)(SocketAddress->lpSockaddr))->sin_addr.s_addr == 0 ) {


        } else {

            //
            // Otherwise keep it.
            //

            j++;
        }
    }
    AddressList->iAddressCount = j;
    *SocketAddressList = AddressList;
    AddressList = NULL;
Cleanup:
    if (AddressList != NULL)
    {
        MIDL_user_free(AddressList);
    }
    if (NetStatus != ERROR_SUCCESS)
    {
        return(STATUS_UNSUCCESSFUL);
    }
    else
    {
        return(STATUS_SUCCESS);
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   KdcUpdateAddressesWorker
//
//  Synopsis:   Updates the IP addresses used for datagram sockest by
//              stopping the endpoints and then starting them with the
//              new addresses
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


ULONG
KdcUpdateAddressesWorker(
    IN PVOID IgnoredParameter
    )
{
    ULONG Index;
    INT IntIndex;
    NTSTATUS Status = STATUS_SUCCESS;
    LPSOCKET_ADDRESS_LIST AddressList = NULL;
    DWORD NetStatus;
    DWORD BytesReturned ;
    BOOL DatagramEndpointsLocked = FALSE;

    D_DebugLog(( DEB_TRACE, "KdcUpdateAddressesWorker\n" ));

    //
    // Tell winsock we want address list changes on this socket:
    //
    if ( KdcWinsockPnpSocket != INVALID_SOCKET )
    {
        NetStatus = WSAIoctl(
                        KdcWinsockPnpSocket,
                        SIO_ADDRESS_LIST_CHANGE,
                        NULL,
                        0,
                        NULL,
                        0,
                        &BytesReturned,
                        NULL,
                        NULL );

        if ( NetStatus != 0 )
        {
            NetStatus = WSAGetLastError();
            if ( NetStatus != WSAEWOULDBLOCK )
            {
                DebugLog((DEB_ERROR,"WSASocket failed with %ld\n", NetStatus ));
                Status = STATUS_UNSUCCESSFUL;
                goto Cleanup;
            }
        }
    }

    //
    // Get the list of socket addresses
    //

    Status = KdcGetAddressListFromWinsock(
                 &AddressList
                 );

    if ( !NT_SUCCESS( Status ))
    {
        goto Cleanup;
    }

    //
    // Cleanup any old endpoints
    //

    if (DatagramEndpoints != NULL)
    {
        for (Index = 0; Index < DatagramEndpointCount ; Index++ )
        {
            if (DatagramEndpoints[Index].Endpoint != NULL)
            {
                //
                // Stopping the endpoint prevents future completions
                //

                while ( FALSE == AtqStopEndpoint( DatagramEndpoints[Index].Endpoint ))
                {
                    Sleep( 5000 );
                }

                //
                // The endpoint won't close until all outstanding operations on it
                // have completed
                //

                while ( FALSE == AtqCloseEndpoint( DatagramEndpoints[Index].Endpoint ))
                {
                    Sleep( 5000 );
                }
            }
        }
    }

    //
    // Must acquire the lock now since we're manipulating global variables
    // that this lock protects.
    //

    RtlAcquireResourceExclusive( &DatagramEndpointLock, TRUE );
    DatagramEndpointsLocked = TRUE;

    MIDL_user_free(DatagramEndpoints);
    DatagramEndpoints = NULL;
    DatagramEndpointCount = 0;

    //
    // Create new endpoints
    //

    DatagramEndpoints = (PKDC_DATAGRAM_ENDPOINT) MIDL_user_allocate(
                            sizeof(KDC_DATAGRAM_ENDPOINT) * AddressList->iAddressCount * 2
                            );

    if (DatagramEndpoints == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    RtlZeroMemory(
        DatagramEndpoints,
        sizeof(KDC_DATAGRAM_ENDPOINT) * AddressList->iAddressCount * 2
        );

    //
    // Create an endpoint for the KDC and for KPASSWD for each transport
    //

    for (IntIndex = 0; IntIndex < AddressList->iAddressCount ; IntIndex++ )
    {
        RtlCopyMemory(
            &DatagramEndpoints[DatagramEndpointCount].LocalAddress,
            AddressList->Address[IntIndex].lpSockaddr,
            sizeof(SOCKADDR_IN)
            );
        DatagramEndpoints[DatagramEndpointCount].EndpointFunction = KdcGetTicket;

        Status = KdcCreateDgAtqEndpoint(
                    KERB_KDC_PORT,
                    &DatagramEndpoints[DatagramEndpointCount],
                    ((PSOCKADDR_IN) &DatagramEndpoints[DatagramEndpointCount].LocalAddress)->sin_addr.s_addr,
                    &DatagramEndpoints[DatagramEndpointCount].Endpoint
                    );

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        DatagramEndpointCount++;

        //
        // Create the KPASSWD endpoint
        //

        RtlCopyMemory(
            &DatagramEndpoints[DatagramEndpointCount].LocalAddress,
            AddressList->Address[IntIndex].lpSockaddr,
            sizeof(SOCKADDR_IN)
            );
        DatagramEndpoints[DatagramEndpointCount].EndpointFunction = KdcChangePassword;

        Status = KdcCreateDgAtqEndpoint(
                    KERB_KPASSWD_PORT,
                    &DatagramEndpoints[DatagramEndpointCount],
                    ((PSOCKADDR_IN) &DatagramEndpoints[DatagramEndpointCount].LocalAddress)->sin_addr.s_addr,
                    &DatagramEndpoints[DatagramEndpointCount].Endpoint
                    );

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        DatagramEndpointCount++;

    }

Cleanup:

    if (!NT_SUCCESS(Status))
    {
        if (DatagramEndpoints != NULL)
        {
            //
            // Allow completion routines to fire while the endpoints are being closed
            // by releasing the lock for the duration of the 'stop' operation
            //

            if ( DatagramEndpointsLocked )
            {
                RtlReleaseResource( &DatagramEndpointLock );
                DatagramEndpointsLocked = FALSE;
            }

            for (Index = 0; Index < DatagramEndpointCount ; Index++ )
            {
                if (DatagramEndpoints[Index].Endpoint != NULL)
                {
                    while ( FALSE == AtqStopEndpoint( DatagramEndpoints[Index].Endpoint ))
                    {
                        Sleep( 5000 );
                    }

                    while ( FALSE == AtqCloseEndpoint( DatagramEndpoints[Index].Endpoint ))
                    {
                        Sleep( 5000 );
                    }
                }
            }

            //
            // Must re-acquire the lock now since we're manipulating global variables
            // that this lock protects.
            //

            RtlAcquireResourceExclusive( &DatagramEndpointLock, TRUE );
            DatagramEndpointsLocked = TRUE;

            MIDL_user_free(DatagramEndpoints);
            DatagramEndpoints = NULL;
            DatagramEndpointCount = 0;
        }
    }

    if ( DatagramEndpointsLocked )
    {
        RtlReleaseResource( &DatagramEndpointLock );
    }

    MIDL_user_free(AddressList);

    return((ULONG) Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   KdcInitializeSockets
//
//  Synopsis:   Initializes the KDCs socket handling code
//
//  Effects:
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KdcInitializeDatagramSockets(
    VOID
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    DWORD NetStatus;

    __try
    {
        RtlInitializeResource(&DatagramEndpointLock);
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        Status = GetExceptionCode();
    }

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
    else
    {
        DatagramEndpointLockInitialized = TRUE;
    }

    //
    // Initialize the asynchronous thread queue.
    
    //

    if (!AtqInitialize(0))
    {
        DebugLog((DEB_ERROR,"Failed to initialize ATQ\n"));
        Status = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }

    //
    // Open a socket to get winsock PNP notifications on.
    //

    KdcWinsockPnpSocket = WSASocket( AF_INET,
                           SOCK_DGRAM,
                           0, // PF_INET,
                           NULL,
                           0,
                           0 );

    if ( KdcWinsockPnpSocket == INVALID_SOCKET ) {

        NetStatus = WSAGetLastError();
        DebugLog((DEB_ERROR,"WSASocket failed with %ld\n", NetStatus ));
        Status = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }


    //
    // Open an event to wait on.
    //

    KdcWinsockPnpEvent = CreateEvent(
                                  NULL,     // No security ettibutes
                                  FALSE,    // Auto reset
                                  FALSE,    // Initially not signaled
                                  NULL);    // No Name

    if ( KdcWinsockPnpEvent == NULL ) {
        NetStatus = GetLastError();
        DebugLog((DEB_ERROR,"Cannot create Winsock PNP event %ld\n", NetStatus ));
        Status = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }

    //
    // Associate the event with new addresses becoming available on the socket.
    //

    NetStatus = WSAEventSelect( KdcWinsockPnpSocket, KdcWinsockPnpEvent, FD_ADDRESS_LIST_CHANGE );

    if ( NetStatus != 0 ) {
        NetStatus = WSAGetLastError();
        DebugLog((DEB_ERROR,"Can't WSAEventSelect %ld\n", NetStatus ));
        Status = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }


    Status = (NTSTATUS) KdcUpdateAddressesWorker( NULL );
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to udpate datagram addresses\n"));
        goto Cleanup;
    }

    D_DebugLog((DEB_TRACE, "Successfully started ATQ listening\n"));


    if ( KdcPnpEventChangeHandle == NULL ) {

        KdcPnpEventChangeHandle = LsaIRegisterNotification(
                                    KdcUpdateAddressesWorker,
                                    NULL,               // no parameter,
                                    NOTIFIER_TYPE_HANDLE_WAIT,
                                    0,                  // no class
                                    0,                  // no flags
                                    0,                  // no interval
                                    KdcWinsockPnpEvent
                                    );
        if (KdcPnpEventChangeHandle == NULL)
        {
            DebugLog((DEB_ERROR,"Failed to register KDC pnp event change handle.\n"));
        }
    }


Cleanup:

    if (!NT_SUCCESS(Status))
    {
        KdcShutdownSockets();
    }
    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KdcShutdownDatagramSockets
//
//  Synopsis:   Shuts down the KDC socket handling code
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KdcShutdownDatagramSockets(
    VOID
    )
{
    ULONG Index;

    TRACE(KDC,KdcShutdownSockets, DEB_FUNCTION);

    if ( KdcPnpEventChangeHandle != NULL )
    {
        LsaICancelNotification(KdcPnpEventChangeHandle);
        KdcPnpEventChangeHandle = NULL;
    }

    if ( KdcWinsockPnpEvent != NULL )
    {
        CloseHandle(KdcWinsockPnpEvent);
        KdcWinsockPnpEvent = NULL;
    }

    if ( KdcWinsockPnpSocket != INVALID_SOCKET ) {
        closesocket(KdcWinsockPnpSocket);
        KdcWinsockPnpSocket = INVALID_SOCKET;
    }

    //
    // Go through the list of contexts and close them all.
    //

    if (DatagramEndpoints != NULL)
    {
        for (Index = 0; Index < DatagramEndpointCount ; Index++ )
        {
            if (DatagramEndpoints[Index].Endpoint != NULL)
            {
                while ( FALSE == AtqStopEndpoint( DatagramEndpoints[Index].Endpoint ))
                {
                    Sleep( 5000 );
                }

                while ( FALSE == AtqCloseEndpoint( DatagramEndpoints[Index].Endpoint ))
                {
                    Sleep( 5000 );
                }
            }
        }

        RtlAcquireResourceExclusive( &DatagramEndpointLock, TRUE );

        MIDL_user_free(DatagramEndpoints);
        DatagramEndpoints = NULL;
        DatagramEndpointCount = 0;

        RtlReleaseResource( &DatagramEndpointLock );
    }

    if (!AtqTerminate())
    {
        DebugLog((DEB_ERROR, "Failed to terminate ATQ!!!\n"));
    }

    if ( DatagramEndpointLockInitialized )
    {
        RtlDeleteResource(&DatagramEndpointLock);
        DatagramEndpointLockInitialized = FALSE;
    }

    return(STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\server\events.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       events.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    1-03-95   RichardW   Created
//
//----------------------------------------------------------------------------

#include "kdcsvr.hxx"
#include <netlib.h>
extern "C" {
#include <lmserver.h>
#include <srvann.h>
}

HANDLE  hEventLog = (HANDLE)NULL;
DWORD   LoggingLevel = (1 << EVENTLOG_ERROR_TYPE) | (1 << EVENTLOG_WARNING_TYPE);
WCHAR   EventSourceName[] = TEXT("KDC");

#define MAX_EVENT_STRINGS 8
#define MAX_ETYPE_LONG   999
#define MIN_ETYPE_LONG  -999
#define MAX_ETYPE_STRING 16  // 4wchar + , + 2 space
#define WSZ_NO_KEYS L"< >"


//+---------------------------------------------------------------------------
//
//  Function:   InitializeEvents
//
//  Synopsis:   Connects to event log service
//
//  Arguments:  (none)
//
//  History:    1-03-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
InitializeEvents(void)
{
    TRACE(KDC, InitializeEvents, DEB_FUNCTION);
//
// Interval with which we'll log the same event twice
//

#define KDC_EVENT_LIFETIME (60*60*1000)

    hEventLog = NetpEventlogOpen(EventSourceName, KDC_EVENT_LIFETIME);
    if (hEventLog)
    {
        return(TRUE);
    }

    DebugLog((DEB_ERROR, "Could not open event log, error %d\n", GetLastError()));
    return(FALSE);
}


//+---------------------------------------------------------------------------
//
//  Function:   ReportServiceEvent
//
//  Synopsis:   Reports an event to the event log
//
//  Arguments:  [EventType]       -- EventType (ERROR, WARNING, etc.)
//              [EventId]         -- Event ID
//              [SizeOfRawData]   -- Size of raw data
//              [RawData]         -- Raw data
//              [NumberOfStrings] -- number of strings
//              ...               -- PWSTRs to string data
//
//  History:    1-03-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
ReportServiceEvent(
    IN WORD EventType,
    IN DWORD EventId,
    IN DWORD SizeOfRawData,
    IN PVOID RawData,
    IN DWORD NumberOfStrings,
    ...
    )
{
    TRACE(KDC, ReportServiceEvent, DEB_FUNCTION);

    va_list arglist;
    ULONG i;
    PWSTR Strings[ MAX_EVENT_STRINGS ];
    DWORD rv;

    if (!hEventLog)
    {
        DebugLog((DEB_ERROR, "Cannot log event, no handle!\n"));
        return((DWORD)-1);
    }

    //
    // Look at the strings, if they were provided
    //
    va_start( arglist, NumberOfStrings );

    if (NumberOfStrings > MAX_EVENT_STRINGS) {

        NumberOfStrings = MAX_EVENT_STRINGS;
    }

    for (i = 0; i<NumberOfStrings; i++) {

        Strings[ i ] = va_arg( arglist, PWSTR );
    }

    //
    // Report the event to the eventlog service
    //

    if ((rv = NetpEventlogWrite(
                hEventLog,
                EventId,
                EventType,
                (PBYTE) RawData,
                SizeOfRawData,
                (LPWSTR *) Strings,
                NumberOfStrings
                )) != ERROR_SUCCESS)
    {
        DebugLog((DEB_ERROR,  "NetpEventlogWrite( 0x%x ) failed - %u\n", EventId, rv ));
    }

    return rv;
}


BOOL
ShutdownEvents(void)
{
    TRACE(KDC, ShutdownEvents, DEB_FUNCTION);

    NetpEventlogClose(hEventLog);

    return TRUE;
}


NTSTATUS
KdcBuildEtypeStringFromStoredCredential(
    IN OPTIONAL PKERB_STORED_CREDENTIAL Cred,
    IN OUT PWSTR* EtypeString
    )
{
    ULONG BuffSize;
    PWSTR Ret = NULL;
    SIZE_T Len = 0;
    WCHAR Buff[12];

    *EtypeString = NULL;


    if (Cred == NULL
         || ((Cred->CredentialCount + Cred->OldCredentialCount) == 0))
    {
        BuffSize = (ULONG) sizeof(WCHAR) * (ULONG) (wcslen(WSZ_NO_KEYS)+1);
        *EtypeString = (LPWSTR)MIDL_user_allocate(BuffSize);

        if (NULL == *EtypeString)
        {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        wcscpy(*EtypeString, WSZ_NO_KEYS);

        return STATUS_SUCCESS;
    }

    // Guess maximum buffer... Etypes are 4 chars at most
    BuffSize = ((Cred->CredentialCount + Cred->OldCredentialCount ) * MAX_ETYPE_STRING);
    Ret = (LPWSTR)MIDL_user_allocate(BuffSize + sizeof(WCHAR));
    if (NULL == Ret)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    for (LONG Index = 0; Index < (Cred->CredentialCount + Cred->OldCredentialCount ); Index++)
    {
        if (Cred->Credentials[Index].Key.keytype > MAX_ETYPE_LONG ||
            Cred->Credentials[Index].Key.keytype < MIN_ETYPE_LONG)
        {
            DebugLog((DEB_ERROR, "Keytype too large for string conversion\n"));
            DsysAssert(FALSE);
        }
        else
        {
            _itow(Cred->Credentials[Index].Key.keytype, Buff, 10);
            wcscat(Ret, Buff);
            wcscat(Ret, L"  ");
        }
    }
     
    //
    // stripping out trailing white spaces
    //

    Len = wcslen(Ret);

    while (Len && iswspace(Ret[Len - 1])) 
    {
        Ret[(Len--) - 1] = L'\0';
    }

    *EtypeString = Ret;
    return STATUS_SUCCESS;
}

NTSTATUS
KdcBuildEtypeStringFromCryptList(
    IN OPTIONAL PKERB_CRYPT_LIST CryptList,
    IN OUT LPWSTR * EtypeString
    )
{
    SIZE_T Len = 0;
    ULONG BuffSize = 0;
    PWSTR Ret = NULL;
    WCHAR Buff[30];

    PKERB_CRYPT_LIST ListPointer = CryptList;

    *EtypeString = NULL;


    if (CryptList == NULL)
    {
        BuffSize = (ULONG) sizeof(WCHAR) * (ULONG) (wcslen(WSZ_NO_KEYS)+1);
        *EtypeString = (LPWSTR)MIDL_user_allocate(BuffSize);

        if (NULL == *EtypeString)
        {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        wcscpy(*EtypeString, WSZ_NO_KEYS);

        return STATUS_SUCCESS;
    }

    while (TRUE)
    {
        if (ListPointer->value > MAX_ETYPE_LONG || ListPointer->value < MIN_ETYPE_LONG)
        {
           DebugLog((DEB_ERROR, "Maximum etype exceeded\n"));
           return STATUS_INVALID_PARAMETER;
        }

        BuffSize += MAX_ETYPE_STRING;
        if (NULL == ListPointer->next)
        {
            break;
        }
        ListPointer = ListPointer->next;

    }

    Ret = (LPWSTR) MIDL_user_allocate(BuffSize + sizeof(WCHAR));
    if (NULL == Ret)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    while (TRUE)
    {
        _itow(CryptList->value, Buff, 10);
        wcscat(Ret, Buff);
        wcscat(Ret, L"  ");
        if (NULL == CryptList->next)
        {
            break;
        }

        CryptList = CryptList->next;

    }

    //
    // stripping out trailing white spaces
    //

    Len = wcslen(Ret);

    while (Len && iswspace(Ret[Len - 1])) 
    {
        Ret[(Len--) - 1] = L'\0';
    }

    *EtypeString = Ret;

    return STATUS_SUCCESS;
}

void
KdcReportKeyError(
    IN PUNICODE_STRING AccountName,
    IN OPTIONAL PUNICODE_STRING ServerName,
    IN ULONG DescriptionID, // uniquely descibe the location of key error
    IN ULONG EventId,
    IN OPTIONAL PKERB_CRYPT_LIST RequestEtypes,
    IN PKDC_TICKET_INFO AccountTicketInfo
    )
{
    ULONG NumberOfStrings;
    NTSTATUS Status;
    PWSTR Strings[ MAX_EVENT_STRINGS ];
    PWSTR RequestEtypeString = NULL;
    PWSTR StoredEtypeString = NULL;
    DWORD rv;
    ULONG KdcEtypes[KERB_MAX_CRYPTO_SYSTEMS];
    ULONG KdcEtypeCount = 0;
    BOOL IsEtypeSupported = FALSE;
    WCHAR Description[16] = {0};

    if (!hEventLog)
    {
        DebugLog((DEB_ERROR, "Cannot log event, no handle!\n"));
        return;
    }

    _snwprintf(Description, RTL_NUMBER_OF(Description) - 1, L"%d", DescriptionID);

    Status = CDBuildIntegrityVect(
                &KdcEtypeCount,
                KdcEtypes
                );
    if (!NT_SUCCESS(Status)) 
    {
        return;
    }

    //
    // is there at least one etype in RequestEtypes supported?
    //

    for (ULONG i = 0; i < KdcEtypeCount; i++) 
    {
        if ((AccountTicketInfo->UserAccountControl & USER_USE_DES_KEY_ONLY) 
             && ((KdcEtypes[i] == KERB_ETYPE_RC4_LM) 
                 || (KdcEtypes[i]== KERB_ETYPE_RC4_MD4) 
                 || (KdcEtypes[i] == KERB_ETYPE_RC4_HMAC_OLD) 
                 || (KdcEtypes[i] == KERB_ETYPE_RC4_HMAC_OLD_EXP) 
                 || (KdcEtypes[i] == KERB_ETYPE_RC4_HMAC_NT) 
                 || (KdcEtypes[i] == KERB_ETYPE_RC4_HMAC_NT_EXP) 
                 || (KdcEtypes[i] == KERB_ETYPE_NULL)) )
        {
           continue;
        }

        for (PKERB_CRYPT_LIST cur = RequestEtypes; cur != NULL; cur = cur->next)
        {
            if ((LONG) KdcEtypes[i] == cur->value)
            {
                IsEtypeSupported = TRUE;
                break;
            }        
        }
    }

    Status = KdcBuildEtypeStringFromCryptList(
                RequestEtypes,
                &RequestEtypeString
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "KdcBuildEtypeFromCryptList failed\n"));
        goto cleanup;
    }

    Status = KdcBuildEtypeStringFromStoredCredential(
                AccountTicketInfo->Passwords,
                &StoredEtypeString
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "KdcBuildEtypeFromStoredCredential failed\n"));
        goto cleanup;
    }

    if (EventId == KDCEVENT_NO_KEY_INTERSECTION_TGS)
    {
        if (!ARGUMENT_PRESENT(ServerName))
        {
            DebugLog((DEB_ERROR, "Invalid arg to KdcReportKeyError: missing ServerName!\n"));
            DsysAssert(FALSE);
            goto cleanup;
        }
    }
    else if (EventId != KDCEVENT_NO_KEY_INTERSECTION_AS)
    {
        DebugLog((DEB_ERROR, "Invalid arg to KdcReportKeyError: unexpected event id %#x!\n", EventId));
        DsysAssert(FALSE);
        goto cleanup;
    }

    Strings[0] = ServerName ? ServerName->Buffer : KDC_PRINCIPAL_NAME;
    Strings[1] = AccountName->Buffer;
    Strings[2] = Description;
    Strings[3] = RequestEtypeString;
    Strings[4] = StoredEtypeString;

    if (IsEtypeSupported) 
    {
        //
        // these can be corrected by resetting/changing the passwords
        //

        Strings[5] = AccountTicketInfo->AccountName.Buffer;
        NumberOfStrings = 6;
    }
    else
    {
        //
        // these can not be corrected by resetting/changing the password
        //

        DebugLog((DEB_ERROR, "KdcReportKeyError etype not supported %ws\n", RequestEtypeString));

        if (EventId == KDCEVENT_NO_KEY_INTERSECTION_TGS)
        {
            EventId = KDCEVENT_UNSUPPORTED_ETYPE_REQUEST_TGS;
        }
        else if (EventId == KDCEVENT_NO_KEY_INTERSECTION_AS)
        {
            EventId = KDCEVENT_UNSUPPORTED_ETYPE_REQUEST_AS;
        }

        NumberOfStrings = 5;
    }

    if ((rv = NetpEventlogWrite(
                hEventLog,
                EventId,
                EVENTLOG_ERROR_TYPE,
                NULL,
                0, // no raw data
                (LPWSTR *) Strings,
                NumberOfStrings
                )) != ERROR_SUCCESS)

    {
        DebugLog((DEB_ERROR, "KdcReportKeyError NetpEventlogWrite( 0x%x ) failed - %u\n", EventId, rv));
    }

cleanup:

    if (NULL != RequestEtypeString)
    {
        MIDL_user_free(RequestEtypeString);
    }

    if (NULL != StoredEtypeString)
    {
        MIDL_user_free(StoredEtypeString);
    }
}

void
KdcReportInvalidMessage(
    IN ULONG EventId,
    IN PCWSTR pMesageDescription
    )
{
    ULONG NumberOfStrings;
    PWSTR Strings[ MAX_EVENT_STRINGS ] = {0};
    DWORD rv;

    if (!hEventLog)
    {
        DebugLog((DEB_ERROR, "KdcReportInvalidMessage cannot log event, no handle!\n"));
        return;
    }

    Strings[0] = (PWSTR) pMesageDescription;
    NumberOfStrings = 1;

    if ((rv = NetpEventlogWrite(
                hEventLog,
                EventId,
                EVENTLOG_ERROR_TYPE,
                NULL,
                0, // no raw data
                (LPWSTR *) Strings,
                NumberOfStrings
                )) != ERROR_SUCCESS)

    {
        DebugLog((DEB_ERROR, "KdcReportInvalidMessage NetpEventlogWrite( 0x%x ) failed - %u\n", EventId, rv));
    }
}

void
KdcReportBadClientCertificate(
    IN PUNICODE_STRING CName,
    IN PVOID ChainStatus,
    IN ULONG ChainStatusSize,
    IN DWORD Error
    )
{

    LPWSTR UCName = NULL;
    LPWSTR UCRealm = NULL;
    PUNICODE_STRING Realm = SecData.KdcRealmName();
    LPWSTR  MessageBuffer = NULL;
    DWORD   MessageSize = 0;

    //
    // May not want this logged.
    //
    if (( KdcExtraLogLevel & LOG_PKI_ERRORS ) == 0)
    {
        return;
    }          

    //
    // Put the strings together - Null terminate the buffers...
    //
    SafeAllocaAllocate(UCName,  (CName->MaximumLength + sizeof(WCHAR)) );
    
    if (UCName == NULL)
    {
        goto Cleanup;
    }

    RtlZeroMemory(
        UCName,
        (CName->MaximumLength + sizeof(WCHAR))
        ); 

    RtlCopyMemory(
        UCName,
        CName->Buffer,
        CName->Length
        );   
    
    SafeAllocaAllocate(UCRealm,(Realm->MaximumLength + sizeof(WCHAR)) );

    if (UCRealm == NULL)
    {
        goto Cleanup;
    } 

    RtlZeroMemory(
        UCRealm,
        (Realm->MaximumLength + sizeof(WCHAR))
        ); 

    RtlCopyMemory(
        UCRealm,
        Realm->Buffer,
        Realm->Length
        );


    MessageSize = FormatMessageW(
                   FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                   NULL,
                   Error,
                   0,
                   (WCHAR*) &MessageBuffer,
                   MessageSize,
                   NULL
                   );

    if ( MessageSize == 0)
    {
        goto Cleanup;
    }

    ReportServiceEvent(
            EVENTLOG_WARNING_TYPE,
            KDCEVENT_INVALID_CLIENT_CERTIFICATE,
            ChainStatusSize,  
            ChainStatus,
            3,
            UCRealm,
            UCName,
            MessageBuffer
            );
Cleanup:

    SafeAllocaFree(UCName);
    SafeAllocaFree(UCRealm);

    if ( MessageBuffer )
    {
        LocalFree(MessageBuffer);
    }
}

VOID
KdcReportPolicyErrorEvent(
    IN ULONG EventType,
    IN ULONG EventId,
    IN PUNICODE_STRING CName,
    IN PUNICODE_STRING SName,
    IN NTSTATUS NtStatus,
    IN ULONG RawDataSize,
    IN OPTIONAL PBYTE RawDataBuffer
    )
{
    ULONG NumberOfStrings = 0;
    PWSTR Strings[ MAX_EVENT_STRINGS ] = {0};
    ULONG rv = 0;

    if (!hEventLog)
    {
        DebugLog((DEB_ERROR, "KdcReportPolicyEvent cannot log event, no handle!\n"));
        return;
    }

    //
    // may not want this logged
    //

    if (( KdcExtraLogLevel & LOG_POLICY_ERROR ) == 0)
    {
        return;
    }    

    if ((EventId == KDCEVENT_POLICY_USER2USER_REQUIRED) && (NtStatus == STATUS_USER2USER_REQUIRED)) 
    {
        NumberOfStrings = 2;

        //
        // this is in the error path, validate buffers
        //

        if ((CName->Buffer == NULL) || (SName->Buffer == NULL)) 
        {
            goto Cleanup;
        }

        //
        // Put the strings together - Null terminate the buffers...
        //
        
        SafeAllocaAllocate(Strings[0],  (CName->Length + sizeof(WCHAR)));
        
        if (Strings[0] == NULL)
        {
            goto Cleanup;
        }
    
        RtlZeroMemory(
            Strings[0],
            (CName->Length + sizeof(WCHAR))
            ); 
    
        RtlCopyMemory(
            Strings[0],
            CName->Buffer,
            CName->Length
            );   
        
        SafeAllocaAllocate(Strings[1], (SName->Length + sizeof(WCHAR)));
    
        if (Strings[1] == NULL)
        {
            goto Cleanup;
        } 
    
        RtlZeroMemory(
            Strings[1],
            (SName->Length + sizeof(WCHAR))
            ); 
    
        RtlCopyMemory(
            Strings[1],
            SName->Buffer,
            SName->Length
            );
    }
    else
    {
        D_DebugLog((DEB_ERROR, "KdcReportPolicyEvent unsupported event id %#x\n", EventId));
        goto Cleanup;
    }

    if ((rv = NetpEventlogWrite(
                hEventLog,
                EventId,
                EventType,
                NULL, // RawDataBuffer
                0,    // RawDataSize
                (PWSTR *) Strings,
                NumberOfStrings
                )) != ERROR_SUCCESS)

    {
        DebugLog((DEB_ERROR, "KdcReportPolicyEvent NetpEventlogWrite( event id %#x ) failed with %#x\n", EventId, rv));
    }

Cleanup:

    for (ULONG i = 0; i <= NumberOfStrings; i++) 
    {
        SafeAllocaFree(Strings[i]);
    }
}




#define S4U_EVENT_STRING_COUNT 3


VOID
KdcReportS4UGroupExpansionError(
    IN PUSER_INTERNAL6_INFORMATION UserInfo,
    IN PKDC_S4U_TICKET_INFO CallerInfo,
    IN DWORD Error
    )
{
    KERBERR KerbErr;
    ULONG rv = 0;
    PWSTR CallerSName = NULL;
    PWSTR Client = NULL;
    PWSTR Strings[S4U_EVENT_STRING_COUNT];
    UNICODE_STRING CallerName ={0};   

    if (!hEventLog)
    {
        DebugLog((DEB_ERROR, "KdcReportPolicyEvent cannot log event, no handle!\n"));
        return;
    }

    //
    // may not want this logged
    //  
    if (( KdcExtraLogLevel & LOG_S4USELF_ACCESS_ERROR ) == 0)
    {
        return;
    }
        
    KerbErr = KerbConvertKdcNameToString(
                    &CallerName,
                    CallerInfo->RequestorServiceName,
                    NULL
                    );

    if (!KERB_SUCCESS( KerbErr ))
    {
        return;
    }                                                                 
    
    CallerSName = CallerName.Buffer; 
    
    //
    // Verify that the user info string is null terminated.
    //
    SafeAllocaAllocate(Client, (UserInfo->I1.UserName.Length + sizeof(WCHAR)));
    if (Client == NULL)
    {
       goto Cleanup;
    }

    RtlZeroMemory(
        Client,
        (UserInfo->I1.UserName.Length + sizeof(WCHAR))
        ); 

    RtlCopyMemory(
        Client,
        UserInfo->I1.UserName.Buffer,
        UserInfo->I1.UserName.Length
        );   

    Strings[0] = CallerSName;
    Strings[1] = CallerInfo->RequestorServiceRealm.Buffer;
    Strings[2] = Client;


    if ((rv = NetpEventlogWrite(
                hEventLog,
                KDCEVENT_S4USELF_ACCESS_FAILED,
                EVENTLOG_WARNING_TYPE,
                (LPBYTE)&Error,
                sizeof(DWORD),    // RawDataSize
                (PWSTR *) Strings,
                S4U_EVENT_STRING_COUNT
                )) != ERROR_SUCCESS)

    {
        D_DebugLog((DEB_ERROR, "KdcReportPolicyEvent NetpEventlogWrite( event id %#x ) failed with %#x\n", KDCEVENT_S4USELF_ACCESS_FAILED, rv));
    } 

Cleanup:

    KerbFreeString( &CallerName );
    if ( Client )
    {
        SafeAllocaFree( Client );
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\server\kdctrace.cxx ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    kdctrace.c

Abstract:

    Include file to contain variables required for event tracing of kerberos
    server

Author:

    07-May-1998  JeePang

Revision History:

--*/

//
//
//
#include <kdcsvr.hxx>
#include <wmistr.h>
#define INITGUID
#include "kdctrace.h"
#include "debug.hxx"

#define RESOURCE_NAME       __TEXT("MofResource")
#define IMAGE_PATH          __TEXT("kdcsvc.dll")

unsigned long    KdcEventTraceFlag = FALSE;
TRACEHANDLE      KdcTraceRegistrationHandle = (TRACEHANDLE) 0;
TRACEHANDLE      KdcTraceLoggerHandle = (TRACEHANDLE) 0;


ULONG
KdcTraceControlCallback(
    IN WMIDPREQUESTCODE RequestCode,
    IN PVOID RequestContext,
    IN OUT ULONG *InOutBufferSize,
    IN OUT PVOID Buffer
    );

TRACE_GUID_REGISTRATION KdcTraceGuids[] =
{
    { &KdcGetASTicketGuid, NULL },
    { &KdcHandleTGSRequestGuid, NULL },
    { &KdcChangePassGuid, NULL }
};

#define KdcGuidCount (sizeof(KdcTraceGuids) / sizeof(TRACE_GUID_REGISTRATION))

ULONG
KdcInitializeTrace(
    VOID
    )
{
    ULONG status;
    HMODULE hModule;
    TCHAR FileName[MAX_PATH+1];
    DWORD nLen = 0;

    hModule = GetModuleHandle(IMAGE_PATH);
    if (hModule != NULL) {
        nLen = GetModuleFileName(hModule, FileName, MAX_PATH);
    }
    if (nLen == 0) {
        lstrcpy(FileName, IMAGE_PATH);
    }

    status = RegisterTraceGuids(
                KdcTraceControlCallback,
                NULL,
                &KdcControlGuid,
                KdcGuidCount,
                KdcTraceGuids,
                (LPCWSTR) FileName,
                (LPCWSTR) RESOURCE_NAME,
                &KdcTraceRegistrationHandle);


    if (status != ERROR_SUCCESS) {
        DebugLog((DEB_TRACE,"Trace registration failed with %x\n",status));
    }
    return status;
}


ULONG
KdcTraceControlCallback(
    IN WMIDPREQUESTCODE RequestCode,
    IN PVOID RequestContext,
    IN OUT ULONG *InOutBufferSize,
    IN OUT PVOID Buffer
    )
{
    ULONG Status;
    ULONG RetSize;

    Status = ERROR_SUCCESS;

    switch (RequestCode)
    {
        case WMI_ENABLE_EVENTS:
        {
            KdcTraceLoggerHandle =
                GetTraceLoggerHandle(Buffer);
            KdcEventTraceFlag = 1;
            RetSize = 0;
            break;
        }

        case WMI_DISABLE_EVENTS:
        {
            KdcEventTraceFlag = 0;
            RetSize = 0;
            KdcTraceLoggerHandle = (TRACEHANDLE) 0;
            break;
        }
        default:
        {
            RetSize = 0;
            Status = ERROR_INVALID_PARAMETER;
            break;
        }

    }

    *InOutBufferSize = RetSize;
    return Status;
} // KdcTraceControlCallback
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\server\kdctrace.h ===
#ifndef _KDCTRACE_H
#define _KDCTRACE_H
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    kdctrace.h

Abstract:

    Include file to contain variables required for event tracing of kerberos
    server

Author:

    07-May-1998  JeePang

Revision History:

--*/

//
//
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <wtypes.h>

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus

#include <wmistr.h>
#include <evntrace.h>

#ifdef __cplusplus
}
#endif // __cplusplus

EXTERN_C unsigned long    KdcEventTraceFlag;
EXTERN_C TRACEHANDLE      KdcTraceRegistrationHandle;
EXTERN_C TRACEHANDLE      KdcTraceLoggerHandle;

EXTERN_C
ULONG
KdcInitializeTrace();

// The current limit is 8 MOF fields.
// Each UNICODE strings needs two MOF fields.
// The ClientRealm is available and should be added to the AS
// if the MOF field limit is increased

typedef struct _KDC_AS_EVENT_INFO
{
    EVENT_TRACE_HEADER EventTrace;
    union {
        ULONG KdcOptions;
        MOF_FIELD eventInfo[7];
    };
} KDC_AS_EVENT_INFO, *PKDC_AS_EVENT_INFO;

// SID info is used in audit log, could be added to TGS event
// if MOF limited increased.

typedef struct _KDC_TGS_EVENT_INFO
{
    EVENT_TRACE_HEADER EventTrace;
    union {
        ULONG KdcOptions;
        MOF_FIELD eventInfo[7];
    };
        
} KDC_TGS_EVENT_INFO, *PKDC_TGS_EVENT_INFO;

typedef struct _KDC_CHANGEPASS_INFO
{
    EVENT_TRACE_HEADER EventTrace;
    MOF_FIELD MofData[7];
} KDC_CHANGEPASS_INFO, *PKDC_CHANGEPASSINFO;

#define KDC_TRACE_VERSION            1

// be careful with INSERT_ULONG_INTO_MOF; it evaluates its arguments more than once 
#define INSERT_ULONG_INTO_MOF( x, MOF, Start )       \
         (MOF)[(Start)].DataPtr   = (ULONGLONG)&(x); \
	 (MOF)[(Start)].Length    = sizeof(ULONG);
	 
// be careful with INSERT_UNICODE_STRING_INTO_MOF; it evaluates its arguments more than once
#define INSERT_UNICODE_STRING_INTO_MOF( USTRING, MOF, Start )       \
         (MOF)[(Start)].DataPtr   = (ULONGLONG)&((USTRING).Length); \
	 (MOF)[(Start)].Length    = sizeof      ((USTRING).Length); \
	 (MOF)[(Start)+1].DataPtr = (ULONGLONG)  (USTRING).Buffer;  \
	 (MOF)[(Start)+1].Length  =              (USTRING).Length;

//
// This is the control Guid for the group of Guids traced below
//
DEFINE_GUID ( /* 24db8964-e6bc-11d1-916a-0000f8045b04 */
    KdcControlGuid,
    0x24db8964,
    0xe6bc,
    0x11d1,
    0x91, 0x6a, 0x00, 0x00, 0xf8, 0x04, 0x5b, 0x04
  );

//
// This is the Get AS Ticket transaction guid
//
DEFINE_GUID ( /* 50af5304-e6bc-11d1-916a-0000f8045b04 */
    KdcGetASTicketGuid,
    0x50af5304,
    0xe6bc,
    0x11d1,
    0x91, 0x6a, 0x00, 0x00, 0xf8, 0x04, 0x5b, 0x04
  );

//
// This is the Handle TGS Request transaction guid
//
DEFINE_GUID ( /* c11cf384-e6bd-11d1-916a-0000f8045b04 */
    KdcHandleTGSRequestGuid,
    0xc11cf384,
    0xe6bd,
    0x11d1,
    0x91, 0x6a, 0x00, 0x00, 0xf8, 0x04, 0x5b, 0x04
  );

DEFINE_GUID ( /* a34d7f52-1dd0-434e-88a1-423e2a199946 */
    KdcChangePassGuid,
    0xa34d7f52,
    0x1dd0,
    0x434e,
    0x88, 0xa1, 0x42, 0x3e, 0x2a, 0x19, 0x99, 0x46
  );


#endif /* _KDCTRACE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\server\kpasswd.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       kpasswd.cxx
//
//  Contents:   Functions for the kpasswd protocol
//
//  History:    30-Sep-97   MikeSw      Created
//
//----------------------------------------------------------------------------


#include "kdcsvr.hxx"
#include "kpasswd.h"
#include "kdctrace.h"
extern "C"
{
#include <nlrepl.h>
}

#define FILENO FILENO_KPASSWD

//+-------------------------------------------------------------------------
//
//  Function:   KdcbMarshallApReply
//
//  Synopsis:   Takes a reply and reply body and encrypts and marshalls them
//              into a return message
//
//  Effects:    Allocates output buffer
//
//  Arguments:  Reply - The outer reply to marshall
//              ReplyBody - The reply body to marshall
//              SessionKey - Session key to encrypt reply
//              PackedReply - Recives marshalled reply buffer
//              PackedReplySize - Receives size in bytes of marshalled reply
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS or STATUS_INSUFFICIENT_RESOURCES
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KdcMarshallApReply(
    IN PKERB_AP_REPLY Reply,
    IN PKERB_ENCRYPTED_AP_REPLY ReplyBody,
    IN PKERB_ENCRYPTION_KEY SessionKey,
    OUT PUCHAR * PackedReply,
    OUT PULONG PackedReplySize
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    ULONG PackedApReplySize;
    PUCHAR PackedApReply = NULL;

    KerbErr = KerbPackApReplyBody(
                ReplyBody,
                &PackedApReplySize,
                &PackedApReply
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    //
    // Now encrypt the response
    //

    KerbErr = KerbAllocateEncryptionBufferWrapper(
                SessionKey->keytype,
                PackedApReplySize,
                &Reply->encrypted_part.cipher_text.length,
                &Reply->encrypted_part.cipher_text.value
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    KerbErr = KerbEncryptDataEx(
                        &Reply->encrypted_part,
                        PackedApReplySize,
                        PackedApReply,
                        KERB_NO_KEY_VERSION,
                        KERB_AP_REP_SALT,
                        SessionKey
                        );
    if (!KERB_SUCCESS(KerbErr))
    {
        D_DebugLog((DEB_ERROR,"Failed to encrypt AP Reply.%d\n", KerbErr));
        goto Cleanup;
    }

    //
    // Now pack the reply into the output buffer
    //

    KerbErr = KerbPackApReply(
                        Reply,
                        PackedReplySize,
                        PackedReply
                        );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }


Cleanup:
    if (Reply->encrypted_part.cipher_text.value != NULL)
    {
        MIDL_user_free(Reply->encrypted_part.cipher_text.value);
        Reply->encrypted_part.cipher_text.value = NULL;
    }
    if (PackedApReply != NULL)
    {
        MIDL_user_free(PackedApReply);
    }

    return (KerbErr);

}


//+-------------------------------------------------------------------------
//
//  Function:   KdcBuildKpasswdResponse
//
//  Synopsis:   builds the response to a kpasswd request
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KdcBuildKpasswdResponse(
    IN OPTIONAL PKERB_ENCRYPTED_TICKET EncryptedTicket,
    IN OPTIONAL PKERB_AUTHENTICATOR Authenticator,
    IN OPTIONAL PKERB_ENCRYPTION_KEY SessionKey,
    IN OPTIONAL PSOCKADDR ServerAddress,
    IN NTSTATUS ChangeResult,
    IN KERBERR ProtocolResult,
    IN PKERB_EXT_ERROR pExtendedError,
    OUT PKERB_MESSAGE_BUFFER Response
    )
{
    KERB_PRIV_MESSAGE PrivMessage = {0};
    KERB_ENCRYPTED_PRIV PrivBody = {0};
    USHORT ReplySize = 0;
    PBYTE PackedApReply = NULL;
    ULONG PackedApReplySize = 0;
    BYTE ResultData[2] = {0};
    PBYTE PackedPrivBody = NULL;
    ULONG PackedPrivBodySize = 0;
    KERBERR KerbErr = KRB_ERR_GENERIC;
    PBYTE ReplyData = NULL;
    ULONG ReplyDataSize = 0;
    PSOCKET_ADDRESS IpAddresses = NULL;
    BOOLEAN ReturningError = TRUE;

    if (!NT_SUCCESS(ChangeResult))
    {
        switch(ChangeResult)
        {
        case STATUS_PASSWORD_RESTRICTION:
            SET_SHORT(ResultData,KERB_KPASSWD_POLICY);
            ProtocolResult = KDC_ERR_POLICY;
            break;
        case STATUS_ACCOUNT_RESTRICTION:
            SET_SHORT(ResultData, KERB_KPASSWD_AUTHENTICATION);
            ProtocolResult = KDC_ERR_CLIENT_REVOKED;
            break;
        case STATUS_INVALID_PARAMETER:
            SET_SHORT(ResultData, KERB_KPASSWD_MALFORMED);
            ProtocolResult = KRB_ERR_GENERIC;
            break;
        case STATUS_ACCESS_DENIED:
            SET_SHORT(ResultData, KERB_KPASSWD_AUTHORIZATION);
            ProtocolResult = KRB_ERR_GENERIC;
            break;
        default:
            SET_SHORT(ResultData, KERB_KPASSWD_ERROR);
            ProtocolResult = KRB_ERR_GENERIC;
            break;
        }
    }
    else if (!KERB_SUCCESS(ProtocolResult))
    {
        switch(ProtocolResult)
        {
        case KRB_ERR_GENERIC:
            //
            // BUG 453652: how does this distinguish between random hard errors
            // and malformed data?
            //
            SET_SHORT(ResultData, KERB_KPASSWD_MALFORMED);
            break;
        default:
            //
            // The other errors come from the call to verify the
            // AP request
            //

            SET_SHORT(ResultData, KERB_KPASSWD_AUTHENTICATION);
            break;
        }
    }

    //
    // Now build the AP reply, if possible.
    //

    if (ARGUMENT_PRESENT(EncryptedTicket))
    {
        KERB_AP_REPLY Reply = {0};
        KERB_ENCRYPTED_AP_REPLY ReplyBody = {0};


        Reply.version = KERBEROS_VERSION;
        Reply.message_type = KRB_AP_REP;



        ReplyBody.client_time = Authenticator->client_time;
        ReplyBody.client_usec = Authenticator->client_usec;


        KerbErr = KdcMarshallApReply(
                    &Reply,
                    &ReplyBody,
                    &EncryptedTicket->key,
                    &PackedApReply,
                    &PackedApReplySize
                    );

        if (!KERB_SUCCESS(KerbErr))
        {
            goto BuildError;
        }

        PrivBody.sender_address.addr_type = KERB_ADDRTYPE_INET;

        if (ARGUMENT_PRESENT(ServerAddress))
        {
            PrivBody.sender_address.address.length = 4;
            PrivBody.sender_address.address.value =
                        (PUCHAR) &((PSOCKADDR_IN)ServerAddress)->sin_addr.S_un.S_addr;

        }
        else
        {
            PrivBody.sender_address.address.length = 0;
            PrivBody.sender_address.address.value = NULL;
        }

        PrivBody.user_data.length = sizeof(ResultData);
        PrivBody.user_data.value = ResultData;

        KerbErr = KerbPackData(
                    &PrivBody,
                    KERB_ENCRYPTED_PRIV_PDU,
                    &PackedPrivBodySize,
                    &PackedPrivBody
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto BuildError;
        }

        //
        // Now encrypt it with the session key
        //


        KerbErr = KerbAllocateEncryptionBufferWrapper(
                    SessionKey->keytype,
                    PackedPrivBodySize,
                    &PrivMessage.encrypted_part.cipher_text.length,
                    &PrivMessage.encrypted_part.cipher_text.value
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto BuildError;
        }

        KerbErr = KerbEncryptDataEx(
                    &PrivMessage.encrypted_part,
                    PackedPrivBodySize,
                    PackedPrivBody,
                    KERB_NO_KEY_VERSION,
                    KERB_PRIV_SALT,
                    SessionKey
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto BuildError;
        }

        PrivMessage.version = KERBEROS_VERSION;
        PrivMessage.message_type = KRB_PRIV;

        //
        // Now pack the KERB_PRIV
        //

        KerbErr = KerbPackData(
                    &PrivMessage,
                    KERB_PRIV_MESSAGE_PDU,
                    &ReplyDataSize,
                    &ReplyData
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto BuildError;
        }
        ReturningError = FALSE;
    }

BuildError:

    //
    // If we have an error of one of the three error codes, build the
    // appropriate result code & error code for the KERB_ERROR
    //

    if (!KERB_SUCCESS(KerbErr) || (ReplyData == NULL))
    {
        UNICODE_STRING TempString;
        RtlInitUnicodeString(
            &TempString,
            KERB_KPASSWD_NAME
            );

        KerbErr = KerbBuildErrorMessageEx(
                    ProtocolResult,
                    pExtendedError, // note:  probably won't get used
                    SecData.KdcDnsRealmName(),
                    SecData.KpasswdInternalName(),
                    NULL,               // no client realm,
                    ResultData,
                    sizeof(ResultData),
                    &ReplyDataSize,
                    &ReplyData
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }
    }

    //
    // Now, if we have an AP reply, build a kpasswd response. Otherwise
    // return the kerb_error message
    //

    if (ReturningError)
    {
        Response->Buffer = ReplyData;
        ReplyData = NULL;
        Response->BufferSize = ReplyDataSize;
        goto Cleanup;
    }
    else
    {
        PKERB_KPASSWD_REP Reply = NULL;
        if ((FIELD_OFFSET(KERB_KPASSWD_REP,Data) +
                    PackedApReplySize +
                    ReplyDataSize) > SHRT_MAX)
        {
            D_DebugLog((DEB_ERROR, "Kpasswd reply too long!\n"));
            KerbErr = KRB_ERR_FIELD_TOOLONG;
            goto Cleanup;
        }
        ReplySize = (USHORT) (FIELD_OFFSET(KERB_KPASSWD_REP,Data) +
                                PackedApReplySize +
                                ReplyDataSize);

        Reply = (PKERB_KPASSWD_REP) MIDL_user_allocate(ReplySize);

        if (Reply == NULL)
        {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }

        SET_SHORT(Reply->MessageLength,ReplySize);
        SET_SHORT(Reply->Version, KERB_KPASSWD_VERSION);
        SET_SHORT(Reply->ApRepLength, (USHORT) PackedApReplySize);
        RtlCopyMemory(
            Reply->Data,
            PackedApReply,
            PackedApReplySize
            );
        RtlCopyMemory(
            Reply->Data + PackedApReplySize,
            ReplyData,
            ReplyDataSize
            );
        Response->Buffer = (PBYTE) Reply;
        Response->BufferSize = ReplySize;
    }

Cleanup:

    if (IpAddresses != NULL)
    {
        I_NetLogonFree(IpAddresses);
    }

    if (PackedApReply != NULL)
    {
        MIDL_user_free(PackedApReply);
    }
    if (PackedPrivBody !=NULL)
    {
        MIDL_user_free(PackedPrivBody);
    }
    if (ReplyData != NULL)
    {
        MIDL_user_free(ReplyData);
    }
    if (PrivMessage.encrypted_part.cipher_text.value != NULL)
    {
        MIDL_user_free(PrivMessage.encrypted_part.cipher_text.value);
    }

    return (KerbErr);
}

//+-------------------------------------------------------------------------
//
//  Function:   KdcChangePassword
//
//  Synopsis:   receives a kerb-change-password buffer and attempts the
//              password change
//
//  Effects:
//
//  Arguments:  Context - ATQ context, used for requesting more data if the
//                      buffer isn't complete
//              ClientAddress - Address of client, from the socket
//              ServerAddress - address client used to contact this server.
//              InputMessage - Receives data sent by client
//              OutputMessage - Contains data to be sent to client & freed
//                      using KdcFreeEncodedData
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

extern "C"
KERBERR
KdcChangePassword(
    IN OPTIONAL PVOID Context,
    IN OPTIONAL PSOCKADDR ClientAddress,
    IN OPTIONAL PSOCKADDR ServerAddress,
    IN PKERB_MESSAGE_BUFFER InputMessage,
    OUT PKERB_MESSAGE_BUFFER OutputMessage
    )
{
    PKERB_KPASSWD_REQ Request = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    KERBERR KerbErr = KDC_ERR_NONE;
    KERB_EXT_ERROR ExtendedError = {0,0};
    PKERB_EXT_ERROR pExtendedError = &ExtendedError;
    USHORT ProtocolVersion;
    USHORT MessageLength;
    USHORT ApReqLength;
    ULONG PrivLength;
    PKERB_AUTHENTICATOR Authenticator = NULL;
    PKERB_ENCRYPTED_TICKET EncryptedTicket = NULL;
    KERB_ENCRYPTION_KEY SessionKey = {0};
    KERB_ENCRYPTION_KEY ServerKey = {0};
    KDC_TICKET_INFO ServerTicketInfo = {0};
    KDC_TICKET_INFO ClientTicketInfo = {0};
    UNICODE_STRING Password = {0};
    ANSI_STRING AnsiPassword = {0};
    PKERB_PRIV_MESSAGE PrivMessage = NULL;
    PKERB_ENCRYPTED_PRIV PrivBody = NULL;
    BOOLEAN UseSubKey = FALSE;
    ULONG TicketFlags;
    BOOLEAN DoPasswordSet = FALSE;
    PKERB_CHANGE_PASSWORD_DATA ChangeData = NULL;

    PKERB_INTERNAL_NAME ClientName = NULL;
    UNICODE_STRING ClientRealm = {0};
    UNICODE_STRING ReferralRealm = {0};
    BOOLEAN ClientReferral = FALSE;
    HANDLE TokenHandle = NULL;
    PSID UserSid = NULL;
    UNICODE_STRING UClientName = {0};
    UNICODE_STRING UClientDomain = {0};
    UNICODE_STRING UClientNetBiosDomain = {0};

    SAM_CLIENT_INFO SamClientInfoBuffer;
    PSAM_CLIENT_INFO SamClientInfo = NULL;

    KDC_CHANGEPASS_INFO ChangePassTraceInfo;
    if( KdcEventTraceFlag ) // Event Trace: KerbChangePasswordStart {No Data}
    {
        ChangePassTraceInfo.EventTrace.Guid       = KdcChangePassGuid;
        ChangePassTraceInfo.EventTrace.Class.Type = EVENT_TRACE_TYPE_START;
        ChangePassTraceInfo.EventTrace.Flags      = WNODE_FLAG_TRACED_GUID;
        ChangePassTraceInfo.EventTrace.Size       = sizeof(EVENT_TRACE_HEADER);

        TraceEvent( KdcTraceLoggerHandle, (PEVENT_TRACE_HEADER)&ChangePassTraceInfo );
    }

    Status = EnterApiCall();

    if (!NT_SUCCESS(Status))
    {
        return(Status);
    }

    if (InputMessage->BufferSize < sizeof(KERB_KPASSWD_REQ))
    {
        D_DebugLog((DEB_ERROR,"Bad message size to KdcChangePassword: %d\n",InputMessage->BufferSize));
        FILL_EXT_ERROR(pExtendedError, STATUS_KDC_INVALID_REQUEST, FILENO, __LINE__);
        KerbErr = KDC_ERR_NO_RESPONSE;
        goto NoMsgResponse;
    }

    Request = (PKERB_KPASSWD_REQ) InputMessage->Buffer;
    //
    // Verify the length & protocol version
    //

    GET_SHORT(MessageLength, Request->MessageLength);
    GET_SHORT(ProtocolVersion, Request->Version);

    if (ProtocolVersion == KERB_KPASSWD_SET_VERSION)
    {
        //
        // This is the advanced protocol
        //

        DoPasswordSet = TRUE;
    }
    else if (ProtocolVersion != KERB_KPASSWD_VERSION)
    {
        D_DebugLog((DEB_ERROR,"Bad version passed to KdcChangePassword: %d\n",
            ProtocolVersion ));
        FILL_EXT_ERROR(pExtendedError, STATUS_KDC_INVALID_REQUEST, FILENO, __LINE__);
        KerbErr = KDC_ERR_NO_RESPONSE;
        goto NoMsgResponse;
    }

    if ((ULONG)MessageLength != InputMessage->BufferSize)
    {
        D_DebugLog((DEB_ERROR,"Bad length passed to KdcChangePassword: %d instead of %d\n",
            MessageLength, InputMessage->BufferSize ));
        FILL_EXT_ERROR(pExtendedError, STATUS_KDC_INVALID_REQUEST, FILENO, __LINE__);
        KerbErr = KDC_ERR_NO_RESPONSE;
        goto NoMsgResponse;
    }

    //
    // Unpack the AP request
    //

    GET_SHORT(ApReqLength, Request->ApReqLength);

    if (FIELD_OFFSET(KERB_KPASSWD_REQ, ApReqLength) + ApReqLength > MessageLength)
    {
        D_DebugLog((DEB_ERROR,"ApReqLength in kpasswd request bad: %d\n",ApReqLength));
        FILL_EXT_ERROR(pExtendedError, STATUS_KDC_INVALID_REQUEST, FILENO, __LINE__);
        KerbErr = KDC_ERR_NO_RESPONSE;
        goto NoMsgResponse;
    }

    //
    // Verify the AP request
    //

    KerbErr = KdcVerifyKdcRequest(
                Request->Data,
                ApReqLength,
                ClientAddress,
                FALSE,                  // this is not a kdc request
                NULL,
                &Authenticator,
                &EncryptedTicket,
                &SessionKey,
                &ServerKey,
                &ServerTicketInfo,
                &UseSubKey,
                pExtendedError
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        if (KerbErr == KDC_ERR_NO_RESPONSE)
        {
            goto NoMsgResponse;
        }

        DebugLog((DEB_WARN,"Failed to unpack AP req in kpasswd request: 0x%x\n",
            KerbErr ));
        goto Cleanup;
    }

    //
    // The spec says the client has to ask for a sub key.
    //

    if (!UseSubKey)
    {
        D_DebugLog((DEB_ERROR,"The client of kpasswd did not ask for a sub key.\n"));
        FILL_EXT_ERROR(pExtendedError, STATUS_KDC_INVALID_REQUEST, FILENO, __LINE__);
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }


    //
    // The name of the principal must be correct.
    //
    // WAS BUG: check by RID
    //

    if (ServerTicketInfo.UserId != DOMAIN_USER_RID_KRBTGT)
    {
        D_DebugLog((DEB_ERROR,"Wrong principal for kpasswd: %wZ\n",
            &ServerTicketInfo.AccountName ));
        FILL_EXT_ERROR(pExtendedError, STATUS_KDC_INVALID_REQUEST, FILENO, __LINE__);
        KerbErr = KRB_AP_ERR_NOT_US;
        goto Cleanup;
    }

    //
    // Now try to unpack the KERB_PRIV
    //

    PrivLength = MessageLength - (ApReqLength + FIELD_OFFSET(KERB_KPASSWD_REQ, Data));
    KerbErr = KerbUnpackData(
                Request->Data + ApReqLength,
                PrivLength,
                KERB_PRIV_MESSAGE_PDU,
                (PVOID *) &PrivMessage
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        D_DebugLog((DEB_ERROR,"Failed to decode priv message in kpasswd req: 0x%x\n",KerbErr));
        FILL_EXT_ERROR(pExtendedError, STATUS_KDC_INVALID_REQUEST, FILENO, __LINE__);
        goto Cleanup;
    }

    //
    // Now decrypt the KERB_PRIV message
    //

    if (PrivMessage->version != KERBEROS_VERSION)
    {
        D_DebugLog((DEB_ERROR,"Bad version in kpasswd priv message: %d\n",
            PrivMessage->version ));
        KerbErr = KRB_AP_ERR_BADVERSION;
        goto Cleanup;
    }

    if (PrivMessage->message_type != KRB_PRIV)
    {
        D_DebugLog((DEB_ERROR,"Bad message type in kpasswd priv message: %d\n",
            PrivMessage->message_type ));
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    KerbErr = KerbDecryptDataEx(
                &PrivMessage->encrypted_part,
                &SessionKey,
                KERB_PRIV_SALT,
                (PULONG) &PrivMessage->encrypted_part.cipher_text.length,
                PrivMessage->encrypted_part.cipher_text.value
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        D_DebugLog((DEB_ERROR,"Failed to decrypt priv message from kpasswd: 0x%x\n",
            KerbErr));
        goto Cleanup;
    }

    //
    // Now decode the kerb priv body
    //

    KerbErr = KerbUnpackData(
                PrivMessage->encrypted_part.cipher_text.value,
                (ULONG) PrivMessage->encrypted_part.cipher_text.length,
                KERB_ENCRYPTED_PRIV_PDU,
                (PVOID *) &PrivBody
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        D_DebugLog((DEB_ERROR,"Failed to unpack priv body from kpasswd: 0x%x\n",
            KerbErr));
        goto Cleanup;
    }

    //
    // Verify the client's address
    //
    // NOTE: the check mandated by RFC1510 can be thwarted by a registry setting
    //       (KdcDontCheckAddresses) to allow seamless operation through NATs
    //

    if (ARGUMENT_PRESENT(ClientAddress) &&
        !KdcDontCheckAddresses)
    {
        KERB_HOST_ADDRESSES Addresses;
        //
        // Build a host_addresses structure because the caller sent a single
        // address.
        //

        Addresses.next = NULL;
        Addresses.value.address_type = PrivBody->sender_address.addr_type;
        Addresses.value.address.value = PrivBody->sender_address.address.value;
        Addresses.value.address.length = PrivBody->sender_address.address.length;

        if ( !KerbVerifyClientAddress(
                  ClientAddress,
                  &Addresses
                  ))
        {
            KerbErr = KRB_AP_ERR_BADADDR;
            D_DebugLog((DEB_ERROR,"Client sent kpasswd request with wrong address\n"));
            goto Cleanup;
        }
    }

    //
    // Now, we should have a password
    //

    if (DoPasswordSet)
    {
        //
        // Unpack the chaneg password data in the priv body.
        //

        KerbErr = KerbUnpackData(
                    PrivBody->user_data.value,
                    PrivBody->user_data.length,
                    KERB_CHANGE_PASSWORD_DATA_PDU,
                    (PVOID *) &ChangeData
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            D_DebugLog((DEB_ERROR,"Failed to unpack password change data from kpasswd: 0x%x\n",
                KerbErr));
            goto Cleanup;
        }

        if (ChangeData->new_password.length > SHRT_MAX / 2)
        {
            D_DebugLog((DEB_ERROR,"Password length too long: %d\n",
                ChangeData->new_password.length ));
            KerbErr = KRB_ERR_FIELD_TOOLONG;
            goto Cleanup;
        }
        AnsiPassword.Length = (USHORT)ChangeData->new_password.length;
        AnsiPassword.MaximumLength = AnsiPassword.Length;
        AnsiPassword.Buffer = (PCHAR) ChangeData->new_password.value;

        KerbErr = KerbStringToUnicodeString(
                    &Password,
                    &AnsiPassword
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }

        //
        // if the target name and realm aren't present, this is a
        // change password
        //

        if ((ChangeData->bit_mask & (target_name_present | target_realm_present)) !=
                (target_name_present | target_realm_present))
        {
            DoPasswordSet = FALSE;
        }
        else
        {
            //
            // Get the names from the change data
            //

            KerbErr = KerbConvertPrincipalNameToKdcName(
                        &ClientName,
                        &ChangeData->target_name
                        );
            if (!NT_SUCCESS(KerbErr))
            {
                goto Cleanup;
            }

            KerbErr = KerbConvertRealmToUnicodeString(
                        &ClientRealm,
                        &ChangeData->target_realm
                        );
            if (!KERB_SUCCESS(KerbErr))
            {
                goto Cleanup;
            }
        }

    }

    if (!DoPasswordSet)
    {
        //
        // The spec says the ticket must be an initial ticket for a
        // change.
        //

        TicketFlags = KerbConvertFlagsToUlong(&EncryptedTicket->flags);
        if ((TicketFlags & KERB_TICKET_FLAGS_initial) == 0)
        {
            D_DebugLog((DEB_ERROR,"Ticket to kpasswd was not initial\n"));
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }

        //
        // NOTE: verify other kerb-priv fields here
        // Current ID doesn't require other kerb priv fields, so
        // this is a no-op.  If things change, however, we'll need
        // to add code here.
        //
        //
        // If we didn't get a password from the change password data,
        // get it directly from the data
        //

        if (Password.Buffer == NULL)
        {

            //
            // The password has to fit in a unicode string, so it can't be longer
            // than half a ushort.
            //

            if (PrivBody->user_data.length > SHRT_MAX / 2)
            {
                D_DebugLog((DEB_ERROR,"Password length too long: %d\n",
                    PrivBody->user_data.length ));
                KerbErr = KRB_ERR_FIELD_TOOLONG;
                goto Cleanup;
            }
            AnsiPassword.Length = (USHORT)PrivBody->user_data.length;
            AnsiPassword.MaximumLength = AnsiPassword.Length;
            AnsiPassword.Buffer = (PCHAR) PrivBody->user_data.value;

            KerbErr = KerbStringToUnicodeString(
                        &Password,
                        &AnsiPassword
                        );
            if (!KERB_SUCCESS(KerbErr))
            {
                goto Cleanup;
            }

        }

        KerbErr = KerbConvertPrincipalNameToKdcName(
                    &ClientName,
                    &EncryptedTicket->client_name
                    );
        if (!NT_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }

        KerbErr = KerbConvertRealmToUnicodeString(
                    &ClientRealm,
                    &EncryptedTicket->client_realm
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }
    }

    //
    // Get the client ticket info so we can do a set pass
    //

    KerbErr = KdcNormalize(
                ClientName,
                NULL,
                &ClientRealm,
                NULL,
                KDC_NAME_CLIENT,
                FALSE,                // do not restrict user accounts (user2user)
                &ClientReferral,
                &ReferralRealm,
                &ClientTicketInfo,
                pExtendedError,
                NULL,                   // no UserHandle
                0L,                     // no fields to fetch
                0L,                     // no extended fields
                NULL,                   // no fields to fetch
                NULL                    // no GroupMembership
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"Failed to normalize name "));
        KerbPrintKdcName(DEB_ERROR,ClientName);
        goto Cleanup;
    }

    {
        LUID LogonId = LOCALSERVICE_LUID; // not usable by S4uProxy

        Status = KerbCreateTokenFromTicket(
                    &LogonId,
                    NULL,
                    EncryptedTicket,
                    Authenticator,
                    0,                  // no flags
                    &ServerKey,
                    SecData.KdcDnsRealmName(),
                    &SessionKey,
                    &LogonId,
                    &UserSid,
                    &TokenHandle,
                    &UClientName,
                    &UClientDomain,
                    &UClientNetBiosDomain,
                    NULL // not interested s4u delegation info
                    );
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR,"Failed to create token from ticket: 0x%x\n",Status));
            FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__);
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }

        //
        // Setup the client info
        //

        if ( (ClientAddress == NULL)
          || (ClientAddress->sa_family == AF_INET) ) {
            // Set to local address (known to be 4 bytes) or IP address
            RtlZeroMemory(&SamClientInfoBuffer, sizeof(SamClientInfoBuffer));
            SamClientInfoBuffer.Type = SamClientIpAddr;
            SamClientInfoBuffer.Data.IpAddr = *((ULONG*)GET_CLIENT_ADDRESS(ClientAddress));
            SamClientInfo = &SamClientInfoBuffer;
        }

        //
        // Store the password on the user's account
        //

        //
        //  We shouldn't enforce password policy restrictions if we do a password SET
        //

        if (!DoPasswordSet)
        {
           Status = SamIChangePasswordForeignUser2(
                     SamClientInfo,
                     &ClientTicketInfo.AccountName,
                     &Password,
                     TokenHandle,
                     USER_CHANGE_PASSWORD
                     );

        } else {

           Status = SamISetPasswordForeignUser2(
                        SamClientInfo,
                        &ClientTicketInfo.AccountName,
                        &Password,
                        TokenHandle
                        );

        }

        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR,"Failed to change password for user %wZ: 0x%x\n",
                &ClientTicketInfo.AccountName, Status ));
            FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__);
            KerbErr = KDC_ERR_POLICY;
            goto Cleanup;
        }
    }

Cleanup:

    //
    // Free all the memory returned
    //

    KerbFree(UClientName.Buffer);
    KerbFree(UClientDomain.Buffer);
    KerbFreeString(&UClientNetBiosDomain);

    if (UserSid) 
    {
        KerbFree(UserSid);
    }

    KerbErr = KdcBuildKpasswdResponse(
                EncryptedTicket,
                Authenticator,
                &SessionKey,
                ServerAddress,
                Status,
                KerbErr,
                pExtendedError,
                OutputMessage
                );

NoMsgResponse:


    if ( KdcEventTraceFlag ) // Event Trace: KdcChangePasswordEnd {KerbErr, ExtErr, Klininfo, (ClientRealm), (AccountName)}
    {
        INSERT_ULONG_INTO_MOF( KerbErr, ChangePassTraceInfo.MofData, 0 );
        INSERT_ULONG_INTO_MOF( ExtendedError.status, ChangePassTraceInfo.MofData, 1 );
        INSERT_ULONG_INTO_MOF( ExtendedError.klininfo, ChangePassTraceInfo.MofData, 2 );

        // Protect against uninitialized UNICODE_STRINGs

        WCHAR   UnicodeNullChar = 0;
        UNICODE_STRING UnicodeEmptyString = {sizeof(WCHAR),sizeof(WCHAR),&UnicodeNullChar};
        PUNICODE_STRING pClientRealmTraceString = &ClientRealm;
        PUNICODE_STRING pAccountNameTraceString = &ClientTicketInfo.AccountName;

        if( ClientRealm.Buffer == NULL || ClientRealm.Length <= 0 )
            pClientRealmTraceString = &UnicodeEmptyString;

        if( ClientTicketInfo.AccountName.Buffer == NULL || ClientTicketInfo.AccountName.Length <= 0 )
            pAccountNameTraceString = &UnicodeEmptyString;

        //

        INSERT_UNICODE_STRING_INTO_MOF( *pClientRealmTraceString, ChangePassTraceInfo.MofData, 3 );
        INSERT_UNICODE_STRING_INTO_MOF( *pAccountNameTraceString, ChangePassTraceInfo.MofData, 5 );

        ChangePassTraceInfo.EventTrace.Size       = sizeof(EVENT_TRACE_HEADER) + 7*sizeof(MOF_FIELD);

        ChangePassTraceInfo.EventTrace.Guid       = KdcChangePassGuid;
        ChangePassTraceInfo.EventTrace.Class.Type = EVENT_TRACE_TYPE_END;
        ChangePassTraceInfo.EventTrace.Flags      = WNODE_FLAG_TRACED_GUID | WNODE_FLAG_USE_MOF_PTR;

        TraceEvent( KdcTraceLoggerHandle, (PEVENT_TRACE_HEADER)&ChangePassTraceInfo );
    }

    if (KerbErr == KDC_ERR_NO_RESPONSE)
    {
        KdcReportInvalidMessage(KDCEVENT_MALFORMED_MESSAGE, L"changepassword");
    }

    KerbFreeKey( &SessionKey );
    KerbFreeKey( &ServerKey );
    KerbFreeTicket(EncryptedTicket);
    FreeTicketInfo(&ServerTicketInfo);
    FreeTicketInfo(&ClientTicketInfo);
    KerbFreeData(KERB_PRIV_MESSAGE_PDU, PrivMessage);
    KerbFreeData(KERB_ENCRYPTED_PRIV_PDU, PrivBody);
    KerbFreeData(KERB_CHANGE_PASSWORD_DATA_PDU, ChangeData);
    KerbFreeString(&Password);
    KerbFreeAuthenticator(Authenticator);

    KerbFreeKdcName(&ClientName);
    KerbFreeString(&ClientRealm);
    KerbFreeString(&ReferralRealm);

    if (TokenHandle != NULL)
    {
        NtClose(TokenHandle);
    }

    LeaveApiCall();

    return(KerbErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\server\refer.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        refer.cxx
//
// Contents:    Routines for interdomain referrals
//
//
// History:     26-Nov-1996     MikeSw          Created
//
// Notes:       The list of domains could be kept as a splay tree for faster
//              searches & inserts.
//
//------------------------------------------------------------------------

#include "kdcsvr.hxx"
#include <lsarpc.h>
extern "C"
{
#include <dns.h>                // DNS_MAX_NAME_LENGTH
#include <ntdsa.h>              // CrackSingleName
}

LIST_ENTRY KdcDomainList = {0};
RTL_CRITICAL_SECTION KdcDomainListLock;
BOOLEAN KdcDomainListInitialized = FALSE;

LIST_ENTRY KdcReferralCache = {0};
RTL_CRITICAL_SECTION KdcReferralCacheLock;
BOOLEAN KdcReferralCacheInitialized = FALSE;
UNICODE_STRING KdcForestRootDomainName = {0};

#define KdcLockReferralCache() (RtlEnterCriticalSection(&KdcReferralCacheLock))
#define KdcUnlockReferralCache() (RtlLeaveCriticalSection(&KdcReferralCacheLock))

#define KdcReferenceDomainInfo(_x_) \
    InterlockedIncrement(&(_x_)->References)

#define KdcReferenceReferralCacheEntry(_x_) \
    InterlockedIncrement(&(_x_)->References)

static TCHAR THIS_FILE[]=TEXT(__FILE__);
#define FILENO FILENO_REFER
//+-------------------------------------------------------------------------
//
//  Function:   KdcDereferenceReferralCacheEntry
//
//  Synopsis:   Derefernce a domain info structure. If the reference
//              count goes to zero the structure is freed.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KdcDereferenceReferralCacheEntry(
    IN PREFERRAL_CACHE_ENTRY CacheEntry
    )
{
    if (InterlockedDecrement(&CacheEntry->References) == 0)
    {
       KdcLockReferralCache();
       CacheEntry->ListEntry.Blink->Flink = CacheEntry->ListEntry.Flink;
       CacheEntry->ListEntry.Flink->Blink = CacheEntry->ListEntry.Blink;
       KdcUnlockReferralCache();

       KerbFreeString(&CacheEntry->RealmName);
       MIDL_user_free(CacheEntry);
    }

}






//+-------------------------------------------------------------------------
//
//  Function:   KdcDereferenceReferralCacheEntry
//
//  Synopsis:   Derefernce a domain info structure. If the reference
//              count goes to zero the structure is freed.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


KERBERR
KdcAddReferralCacheEntry(
    IN PUNICODE_STRING RealmName,
    IN ULONG CacheFlags
    )
{

    PREFERRAL_CACHE_ENTRY CacheEntry = NULL;
    KERBERR KerbErr;
    TimeStamp CurrentTime;


    CacheEntry = (PREFERRAL_CACHE_ENTRY) MIDL_user_allocate(sizeof(REFERRAL_CACHE_ENTRY));
    if (NULL == CacheEntry)
    {
        // We're low on memory, non-fatal
        return KRB_ERR_GENERIC;
    }

    KerbErr = KerbDuplicateString(
                &(CacheEntry->RealmName),
                RealmName
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        MIDL_user_free(CacheEntry);
        return KerbErr;
    }

    CacheEntry->CacheFlags = CacheFlags;

    // Set cache timeout == 10 minutes
    GetSystemTimeAsFileTime((PFILETIME)&CurrentTime);
    CacheEntry->EndTime.QuadPart = CurrentTime.QuadPart + (LONGLONG) 60*10*10000000;


    InterlockedIncrement(&CacheEntry->References);


    KdcLockReferralCache();
    InsertHeadList(
        &KdcReferralCache,
        &(CacheEntry->ListEntry)
        );

    KdcUnlockReferralCache();

    DebugLog((DEB_TRACE, "Added referal cache entry - %wZ State: %x\n",
              RealmName, CacheFlags));


    return KerbErr;

}



//+-------------------------------------------------------------------------
//
//  Function:   KdcLookupReferralCacheEntry
//
//  Synopsis:   Derefernce a domain info structure. If the reference
//              count goes to zero the structure is freed.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
KERBERR
KdcLocateReferralCacheEntry(
    IN PUNICODE_STRING RealmName,
    IN ULONG NewFlags,
    OUT PULONG CacheState
    )
{

    KERBERR KerbErr = KDC_ERR_NONE;
    PLIST_ENTRY ListEntry;
    PREFERRAL_CACHE_ENTRY CacheEntry = NULL;
    BOOLEAN ListLocked = FALSE;
    BOOLEAN Found = FALSE;

    *CacheState = KDC_NO_ENTRY;
    KdcLockReferralCache();
    ListLocked = TRUE;

    //
    // Go through the binding cache looking for the correct entry
    //

    for (ListEntry = KdcReferralCache.Flink ;
         ListEntry !=  KdcReferralCache.Blink ;
         ListEntry = ListEntry->Flink )
   {
        CacheEntry = CONTAINING_RECORD(ListEntry, REFERRAL_CACHE_ENTRY, ListEntry.Flink);

        if (RtlEqualUnicodeString(
            &CacheEntry->RealmName,
            RealmName,
            TRUE // case insensitive
            ))
        {
            TimeStamp CurrentTime;
            GetSystemTimeAsFileTime((PFILETIME)  &CurrentTime );

            //
            // Update the flags & time on this cache entry
            //
            if (NewFlags != KDC_NO_ENTRY)
            {
                CacheEntry->CacheFlags = NewFlags;
                CacheEntry->EndTime.QuadPart = CurrentTime.QuadPart + (LONGLONG) 10*60*10000000;
                Found = TRUE;
            }
            else  // just a lookup
            {
                if (KdcGetTime(CacheEntry->EndTime) < KdcGetTime(CurrentTime))
                {
                    DebugLog((DEB_TRACE, "Time:  Purging KDC Referral cache entry (%x : refcount %x) for %wZ \n",
                              CacheEntry,CacheEntry->References, RealmName));
                    KdcDereferenceReferralCacheEntry(CacheEntry);

                }
                else // got our flags
                {
                    *CacheState = CacheEntry->CacheFlags;
                    DebugLog((DEB_TRACE, "Found entry for %wZ, flags - %x\n",
                              RealmName, *CacheState));

                    Found = TRUE;
                }
            }
            break;


        }
    }

    // If it wasn't found, but if we asked for any new flags
    // we want a new cache entry
    if (!Found && (NewFlags != KDC_NO_ENTRY))
    {
        DebugLog((DEB_TRACE, "Adding referral cache entry - %wZ State: %x\n",
                  RealmName, NewFlags));

        KerbErr = KdcAddReferralCacheEntry(
                        RealmName,
                        NewFlags
                        );
    }


    if (ListLocked)
    {
        KdcUnlockReferralCache();
    }

    return KerbErr;
}






//+-------------------------------------------------------------------------
//
//  Function:   KdcFreeDomainInfo
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
VOID
KdcFreeDomainInfo(
    IN PKDC_DOMAIN_INFO DomainInfo
    )
{
    if (ARGUMENT_PRESENT(DomainInfo))
    {
        KerbFreeString(&DomainInfo->NetbiosName);
        KerbFreeString(&DomainInfo->DnsName);
        if (NULL != DomainInfo->Sid)
        {
            MIDL_user_free(DomainInfo->Sid);
        }
        MIDL_user_free(DomainInfo);
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   KdcDereferenceDomainInfo
//
//  Synopsis:   Derefernce a domain info structure. If the reference
//              count goes to zero the structure is freed.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KdcDereferenceDomainInfo(
    IN PKDC_DOMAIN_INFO DomainInfo
    )
{
     if (InterlockedDecrement(&DomainInfo->References) == 0)
     {
         KdcFreeDomainInfo(DomainInfo);
     }
}




//+-------------------------------------------------------------------------
//
//  Function:   KdcCheckForInterdomainReferral
//
//  Synopsis:   This function makes a determination that an interdomain referral
//              that we're processing is destined for an external forest.  This
//              is important because we won't have any referral information about
//              the destination forest, so we've got to target the root of our
//              enterprise instead.
//
//
//  Effects:
//
//  Arguments:  ReferralTarget - Receives ticket info for target domain
//              ReferralRealm - Receives realm name of referral realm, if present
//              DestinationDomain - Target domain name
//              ExactMatch - The target domain has to be trusted by this domain
//
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------

KERBERR
KdcCheckForCrossForestReferral(
    OUT PKDC_TICKET_INFO ReferralTarget,
    OUT OPTIONAL PUNICODE_STRING ReferralRealm,
    OUT PKERB_EXT_ERROR pExtendedError,
    IN PUNICODE_STRING DestinationDomain,
    IN ULONG NameFlags
    )
{

    KERBERR KerbErr = KDC_ERR_NONE;
    
    NTSTATUS Status;
    LPWSTR KrbtgtSpn = NULL;
    UNICODE_STRING ServiceName = {0 , 0, NULL };
    WCHAR CrackedDnsDomain [DNS_MAX_NAME_LENGTH + 1];
    ULONG CrackedDomainLength = sizeof( CrackedDnsDomain ) / sizeof( WCHAR );
    WCHAR CrackedName[UNLEN+DNS_MAX_NAME_LENGTH + 2];
    ULONG CrackedNameLength = sizeof( CrackedName ) / sizeof( WCHAR );
    ULONG CrackError = 0;
    BOOLEAN RootDomain = SecData.IsForestRoot();
    UNICODE_STRING  Target = {0};     

    //
    // Compose an SPN related to our KRBTGT account
    //

    KerbErr = KerbBuildUnicodeSpn(
                  DestinationDomain,
                  SecData.KdcServiceName(),
                  &ServiceName
                  );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    KrbtgtSpn = KerbBuildNullTerminatedString(&ServiceName);

    if (NULL == KrbtgtSpn)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    //
    // Look it up
    //

    Status = CrackSingleName(
                 DS_SERVICE_PRINCIPAL_NAME, // we know its an SPN
                 DS_NAME_FLAG_TRUST_REFERRAL | DS_NAME_FLAG_GCVERIFY,
                 KrbtgtSpn,
                 DS_UNIQUE_ID_NAME,
                 &CrackedDomainLength,
                 CrackedDnsDomain,
                 &CrackedNameLength,
                 CrackedName,
                 &CrackError
                 );

    //
    // Any error, or CrackError other than xforest result
    // means we don't know where this referral is headed.
    //
    if (!NT_SUCCESS(Status) || (CrackError != DS_NAME_ERROR_TRUST_REFERRAL))
    {
        D_DebugLog((DEB_T_TICKETS,
                    "KDC presented w/ a unknown Xrealm TGT (%wZ)\n",
                    DestinationDomain));

        D_DebugLog((DEB_T_TICKETS, "Crack Error %x, Status %x\n", CrackError, Status));
        KerbErr = KDC_ERR_PATH_NOT_ACCEPTED;
        goto Cleanup;
    }
    
    D_DebugLog((DEB_T_TICKETS, "TGT Cracked realm (FOREST) %S\n", CrackedDnsDomain));

    //
    // Now, we're pretty sure we're going to hit this other forest,
    // somewhere.   For SPNs, we've got to find the root domain of our forest
    // to finish off the x realm transaction.  For UPNs, just
    // return the cracked domain.
    //

    if ((NameFlags & ( KDC_NAME_SERVER | KDC_NAME_UPN_TARGET )) != 0)
    {
        UNICODE_STRING  TmpName = {0};

        //
        // Default behavior is to refer to the root - otherwise, simply
        // utilize the cross forest link.
        //

        if ( !RootDomain )
        {
            Status = SecData.GetKdcForestRoot(&Target);
    
            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }
        }
        else
        {
            RtlInitUnicodeString(
                &Target,
                CrackedDnsDomain
                );
        } 

        KerbErr = KdcFindReferralTarget(
                    ReferralTarget,
                    ReferralRealm,
                    pExtendedError,
                    &Target,
                    FALSE, // we'll accept closest
                    NameFlags
                    );

        if (!KERB_SUCCESS(KerbErr))
        {  
            //
            // Hack for broken trust recursion.
            //
            if (KerbErr == KDC_ERR_NO_TRUST_PATH)
            {
                KerbErr = KDC_ERR_S_PRINCIPAL_UNKNOWN;
            }
            D_DebugLog((DEB_ERROR, "No referral info for %wZ\n", &Target));
            goto Cleanup;   
        }

        //
        // swap w/ our dns domain for referral realm, unless we're
        // processing a UPN, or we're in the root of the forest.
        //

        if (!RootDomain)
        {   
            KerbFreeString(ReferralRealm);

            RtlInitUnicodeString(
                &TmpName,
                CrackedDnsDomain
                );
    
            if (!NT_SUCCESS(KerbDuplicateString(ReferralRealm, &TmpName)))
            {
               KerbErr = KRB_ERR_GENERIC;
               goto Cleanup;
            } 
        }

        D_DebugLog((DEB_T_TICKETS, "Found Xforest referral to %wZ\n", ReferralRealm));
    }
    else
    {   
        //
        // UPN referral... 
        //

        UNICODE_STRING TmpString = {0};
        
        RtlInitUnicodeString(
            &TmpString,
            CrackedDnsDomain
            );

        if (!NT_SUCCESS(KerbDuplicateString(ReferralRealm, &TmpString)))
        {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }

        D_DebugLog((DEB_T_TICKETS, "Found Xforest UPN referral to %wZ\n", ReferralRealm));
    }

Cleanup:       

    KerbFreeString(&ServiceName);
    
    //
    // !rootdomain == we allocated the target from the GetKdcForestRoot...
    //
    if (!RootDomain && Target.Buffer != NULL)
    {
        KerbFreeString(&Target);
    }

    if (KrbtgtSpn != NULL)
    {
        MIDL_user_free(KrbtgtSpn);
    }       

    return ( KerbErr );
}


//+-------------------------------------------------------------------------
//
//  Function:   KdcFindReferralTarget
//
//  Synopsis:   Takes a domain name as a parameter and returns information
//              in the closest available domain. For heirarchical links,
//              this would be a parent or child. If a cross link is available,
//              this might be the other side of a cross link. For inter-
//              organization links, this might be a whole different tree
//
//  Effects:
//
//  Arguments:  ReferralTarget - Receives ticket info for target domain
//              ReferralRealm - Receives realm name of referral realm, if present
//              DestinationDomain - Target domain name
//              ExactMatch - The target domain has to be trusted by this domain
//
//
//  Requires:
//
//  Returns:
//
//  Notes:  !!! IMPORTANT !!! Any KDC_ERR_NO_TRUST_PATH returns **MUST**
//          be converted to an on-the-wire protocol..
//
//--------------------------------------------------------------------------

KERBERR
KdcFindReferralTarget(
    OUT PKDC_TICKET_INFO ReferralTarget,
    OUT OPTIONAL PUNICODE_STRING ReferralRealm,
    OUT PKERB_EXT_ERROR pExtendedError,
    IN PUNICODE_STRING DestinationDomain,
    IN BOOLEAN ExactMatch,
    IN ULONG NameFlags
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    PKDC_DOMAIN_INFO DomainInfo = NULL;
    PKDC_DOMAIN_INFO ClosestRoute = NULL;
    BOOLEAN fListLocked = FALSE;
    KDC_DOMAIN_INFO_DIRECTION TrustDirection = Outbound;

    TRACE(KDC, KdcFindReferralTarget, DEB_FUNCTION);

    RtlInitUnicodeString(
        ReferralRealm,
        NULL
        );
    D_DebugLog((DEB_TRACE, "KdcFindReferralTarget [entering] generating referral for target %wZ\n",DestinationDomain));

    if ((NameFlags & KDC_NAME_INBOUND) != 0)
    {
        KdcLockDomainList();

        KerbErr = KdcLookupDomainName(
                    &DomainInfo,
                    DestinationDomain,
                    &KdcDomainList
                    );

        if (!KERB_SUCCESS(KerbErr) || ((DomainInfo->Flags & KDC_TRUST_INBOUND) == 0))
        {
            DebugLog((DEB_WARN, "Failed to find inbound referral target %wZ\n",DestinationDomain));
            FILL_EXT_ERROR(pExtendedError, STATUS_KDC_UNABLE_TO_REFER, FILENO, __LINE__);
            KerbErr = KDC_ERR_S_PRINCIPAL_UNKNOWN;
            fListLocked = TRUE;
            goto Cleanup;
        }

        TrustDirection = Inbound;

        //
        // Set the closest route to be this domain & add a reference for
        // the extra pointer
        //

        KdcReferenceDomainInfo(DomainInfo);
        ClosestRoute = DomainInfo;
        KdcUnlockDomainList();

    }
    else
    {
        //
        // Check the list of domains for the target
        //

        KdcLockDomainList();

        KerbErr = KdcLookupDomainRoute(
                    &DomainInfo,
                    &ClosestRoute,
                    DestinationDomain,
                    &KdcDomainList
                    );

        KdcUnlockDomainList();

        if (!KERB_SUCCESS(KerbErr))
        {
            DebugLog((DEB_WARN, "KdcFindReferralTarget KLIN(%x) Failed to find referral target %wZ\n", KLIN(FILENO, __LINE__), DestinationDomain));
            FILL_EXT_ERROR(pExtendedError, STATUS_KDC_UNABLE_TO_REFER, FILENO, __LINE__);
            goto Cleanup;
        }

        //
        // Check to see if we needed & got an exact match
        //

        if (ExactMatch &&
            (DomainInfo != ClosestRoute))
        {
            DebugLog((DEB_ERROR, "KdcFindReferralTarget KLIN(%x) Needed exact match and got a transitively-trusted domain.\n", KLIN(FILENO, __LINE__)));
            FILL_EXT_ERROR(pExtendedError, STATUS_KDC_UNABLE_TO_REFER, FILENO, __LINE__);
            KerbErr = KDC_ERR_S_PRINCIPAL_UNKNOWN;
            goto Cleanup;
        }

    }


    //
    // Return the referral realm, if present
    //

    if (ARGUMENT_PRESENT(ReferralRealm))
    {
        if (!NT_SUCCESS(KerbDuplicateString(
                ReferralRealm,
                &DomainInfo->DnsName
                )))
        {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }
    }


    //
    // For UPN logons, we don't need the ticket info.
    // We're just generating a referral realm.
    //
    if ((NameFlags & KDC_NAME_CLIENT) == 0)
    {
        //
        // Now get the ticket info for the domain
        //

        KerbErr = KdcGetTicketInfoForDomain(
                        ReferralTarget,
                        pExtendedError,
                        ClosestRoute,
                        TrustDirection
                        );

        if (!KERB_SUCCESS(KerbErr))
        {
            DebugLog((DEB_ERROR,"Failed to get ticket info for domain %wZ: 0x%x. %ws, line %d\n",
                DestinationDomain, KerbErr , __FILE__, __LINE__ ));
            goto Cleanup;
        }
    }

Cleanup:
    if (DomainInfo != NULL)
    {
        KdcDereferenceDomainInfo(DomainInfo);
    }
    if (ClosestRoute != NULL)
    {
        KdcDereferenceDomainInfo(ClosestRoute);
    }
    if (fListLocked)
    {
        KdcUnlockDomainList();
    }
    if (!KERB_SUCCESS(KerbErr) && ARGUMENT_PRESENT(ReferralRealm))
    {
        KerbFreeString(ReferralRealm);
    }
    //
    // Remap the error
    //

    if (KerbErr == KDC_ERR_S_PRINCIPAL_UNKNOWN)
    {
        KerbErr = KDC_ERR_C_PRINCIPAL_UNKNOWN;
    }

    return(KerbErr);
}

//+-------------------------------------------------------------------------
//
//  Function:   KdcPickAuthInfo
//
//  Synopsis:   Pick password authinfo
//
//  Effects:
//
//  Arguments:  AuthInfoCount - Number of AuthInfo
//              AuthInfo      - An array of authinfo
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

PLSAPR_AUTH_INFORMATION
KdcPickAuthInfo(
    IN ULONG AuthInfoCount,
    IN PLSAPR_AUTH_INFORMATION AuthInfo
    )
{
    PLSAPR_AUTH_INFORMATION Nt4OwfAuthInfo = NULL;

    //
    // Loop through the various auth infos looking for the password
    //
    
    for ( ULONG i = 0; i < AuthInfoCount; i++ ) 
    {       
        if (AuthInfo[i].AuthType == TRUST_AUTH_TYPE_CLEAR) 
        {
            return AuthInfo + i; // prefer clear text authinfo    
        }
        else if (!Nt4OwfAuthInfo && (AuthInfo[i].AuthType == TRUST_AUTH_TYPE_NT4OWF)) // prefer the first NT4OWF
        {        
            Nt4OwfAuthInfo = AuthInfo + i;
        }
    }

    return Nt4OwfAuthInfo; 
}

//+-------------------------------------------------------------------------
//
//  Function:   KdcGetTicketInfoForDomain
//
//  Synopsis:   Retrieves the ticket information for a domain
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KdcGetTicketInfoForDomain(
    OUT PKDC_TICKET_INFO TicketInfo,
    OUT PKERB_EXT_ERROR pExtendedError,
    IN PKDC_DOMAIN_INFO DomainInfo,
    IN KDC_DOMAIN_INFO_DIRECTION Direction
    )
{
    PLSAPR_TRUSTED_DOMAIN_INFO TrustInfo = NULL;
    PLSAPR_AUTH_INFORMATION AuthInfo = NULL;
    PLSAPR_AUTH_INFORMATION OldAuthInfo = NULL;

    KERBERR KerbErr = KDC_ERR_NONE;
    NTSTATUS Status = STATUS_SUCCESS;

    UNICODE_STRING Password;
    ULONG PasswordLength = 0;
    LARGE_INTEGER CurrentTime;
    ULONG cbSid;


    TRACE(KDC, KdcGetTicketInfoForDomain, DEB_FUNCTION);

    //
    // Get information about the domain. Note that we use the dns name
    // field. For NT5 domains in the enterprise this will contain the
    // real DNS name. For non- tree domains it will contain the name from
    // the trusted domain object, so this call should always succeed.
    //

    Status = LsarQueryTrustedDomainInfoByName(
                GlobalPolicyHandle,
                (PLSAPR_UNICODE_STRING) &DomainInfo->DnsName,
                TrustedDomainAuthInformation,
                &TrustInfo
                );
    if (!NT_SUCCESS(Status))
    {
        //
        // If the domain didn't exist, we have a problem because our
        // cache is out of date. Or, we're loooking for our domain.. this
        // is always going to return STATUS_OBJECT_NAME_NOT_FOUND
        //

        //
        // WAS BUG: reload the cache -- this is handled in the call to
        // LSAIKerberosRegisterTrustNotification(), which will then
        // reload the cache using KdcTrustChangeCallback().  As long
        // as this callback is solid (?), we should never fail the
        // above.  If needed, we can revisit. -TS
        //

        if (Status == STATUS_OBJECT_NAME_NOT_FOUND)
        {
            DebugLog((DEB_ERROR,"Domain %wZ in cache but object doesn't exist. %ws, line %d\n",
                &DomainInfo->DnsName, THIS_FILE, __LINE__ ));
            KerbErr = KDC_ERR_S_PRINCIPAL_UNKNOWN;
        }
        else
        {
            DebugLog((DEB_ERROR,"Failed to query domain info for %wZ: 0x%x. %ws, line %d\n",
                &DomainInfo->DnsName, Status, THIS_FILE, __LINE__ ));
                KerbErr = KRB_ERR_GENERIC;
        }

        FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__);
        goto Cleanup;
    }

    //
    // Note: Kerberos direction is opposite normal direction
    //

    if (Direction == Outbound)
    {         
        AuthInfo = KdcPickAuthInfo(
                        TrustInfo->TrustedAuthInfo.IncomingAuthInfos, 
                        TrustInfo->TrustedAuthInfo.IncomingAuthenticationInformation
                        );

        OldAuthInfo = KdcPickAuthInfo(
                            TrustInfo->TrustedAuthInfo.IncomingAuthInfos,
                            TrustInfo->TrustedAuthInfo.IncomingPreviousAuthenticationInformation
                            );
    }
    else
    {
        AuthInfo = KdcPickAuthInfo(
                        TrustInfo->TrustedAuthInfo.OutgoingAuthInfos, 
                        TrustInfo->TrustedAuthInfo.OutgoingAuthenticationInformation
                        );

        OldAuthInfo = KdcPickAuthInfo(
                            TrustInfo->TrustedAuthInfo.OutgoingAuthInfos,
                            TrustInfo->TrustedAuthInfo.OutgoingPreviousAuthenticationInformation
                            );
    }

    if (AuthInfo == NULL)
    {
        DebugLog((DEB_ERROR, "No auth info for this trust: %wZ. %ws, line %d\n",
            &DomainInfo->DnsName, THIS_FILE, __LINE__));
        FILL_EXT_ERROR(pExtendedError, STATUS_TRUSTED_DOMAIN_FAILURE, FILENO, __LINE__);
        KerbErr = KDC_ERR_S_PRINCIPAL_UNKNOWN;
        goto Cleanup;
    }

    //
    // Check the last update time. If the new auth info is too new, we want
    // to keep using the old one.
    //
    if (OldAuthInfo != NULL)
    {
        GetSystemTimeAsFileTime((PFILETIME)&CurrentTime);
            
        if (CurrentTime.QuadPart - AuthInfo->LastUpdateTime.QuadPart < SecData.KdcDomainPasswordReplSkew().QuadPart)
        {
            PLSAPR_AUTH_INFORMATION TempAuthInfo;

            //
            // Swap current & old auth info to encrypt tickets with old password
            //

            TempAuthInfo = AuthInfo;
            AuthInfo = OldAuthInfo;
            OldAuthInfo = TempAuthInfo;

            //DebugLog((DEB_ERROR, "Using old auth info\n"));

        }
    }

    //
    // So now that we have the auth info we need to build a ticket info
    //

    Password.Length = Password.MaximumLength = (USHORT) AuthInfo->AuthInfoLength;
    Password.Buffer = (LPWSTR) AuthInfo->AuthInfo;

    DsysAssert((AuthInfo->AuthType == TRUST_AUTH_TYPE_CLEAR) || (AuthInfo->AuthType == TRUST_AUTH_TYPE_NT4OWF)); 

    Status = KdcBuildPasswordList(
                &Password,
                &DomainInfo->DnsName,
                SecData.KdcDnsRealmName(),
                DomainTrustAccount,
                NULL,           // no stored creds
                0,              // no stored creds
                FALSE,          // don't marshall
                DomainInfo->Type != TRUST_TYPE_MIT,           // don;t include builtin crypt types for mit trusts,
                (AuthInfo->AuthType == TRUST_AUTH_TYPE_NT4OWF) ? KERB_PRIMARY_CRED_OWF_ONLY : 0,
                Direction,
                &TicketInfo->Passwords,
                &PasswordLength
                );


    if (!NT_SUCCESS(Status))
    {
        FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__);
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;

    }

    //
    // Build the old password list as well
    //

    if (OldAuthInfo != NULL)
    {
        Password.Length = Password.MaximumLength = (USHORT) OldAuthInfo->AuthInfoLength;
        Password.Buffer = (LPWSTR) OldAuthInfo->AuthInfo;

        DsysAssert((OldAuthInfo->AuthType == TRUST_AUTH_TYPE_CLEAR) || (OldAuthInfo->AuthType == TRUST_AUTH_TYPE_NT4OWF));

        Status = KdcBuildPasswordList(
                    &Password,
                    &DomainInfo->DnsName,
                    SecData.KdcDnsRealmName(),
                    DomainTrustAccount,
                    NULL,
                    0,
                    FALSE,          // don't marshall
                    DomainInfo->Type != TRUST_TYPE_MIT,           // don;t include builtin crypt types for mit trusts,
                    (OldAuthInfo->AuthType == TRUST_AUTH_TYPE_NT4OWF) ? KERB_PRIMARY_CRED_OWF_ONLY : 0,
                    Direction,
                    &TicketInfo->OldPasswords,
                    &PasswordLength
                    );

        if (!NT_SUCCESS(Status))
        {
           FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__);
           KerbErr = KRB_ERR_GENERIC;
           goto Cleanup;

        }
    }

    if (!NT_SUCCESS(KerbDuplicateString(
                        &TicketInfo->AccountName,
                        &DomainInfo->DnsName
                        )))
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    TicketInfo->PasswordExpires = tsInfinity;
    TicketInfo->UserAccountControl = USER_INTERDOMAIN_TRUST_ACCOUNT;

    //
    // BUG 73479: need to get ticket options
    //

    TicketInfo->fTicketOpts = AUTH_REQ_PER_USER_FLAGS |
                                AUTH_REQ_ALLOW_NOADDRESS |
                                AUTH_REQ_ALLOW_ENC_TKT_IN_SKEY |
                                AUTH_REQ_ALLOW_VALIDATE |
                                AUTH_REQ_OK_AS_DELEGATE;
    //
    // buggy buggy buggy LSA
    //
    // The TRUST_ATTRIBUTE_NON_TRANSITIVE is not defined on NT trusts, so 
    // assume its an external trust- if its to a domain outside of our forest
    // then its non-transitive.
    //
    if ( DomainInfo->Type == TRUST_TYPE_MIT ) 
    {
        if ((DomainInfo->Attributes & TRUST_ATTRIBUTE_NON_TRANSITIVE) == 0)
        {
            TicketInfo->fTicketOpts |= AUTH_REQ_TRANSITIVE_TRUST;
        }                                          

        //
        // we select the session key type based on DES_KEY_ONLY flag, set it 
        // here so we won't use rc4 session keys for the referral TGTs to MIT
        // trusts
        //

        TicketInfo->UserAccountControl |= USER_USE_DES_KEY_ONLY;
    }
    else
    {
        //
        // not an MIT trust - all external trusts within forest are transitive
        // xforest trusts are transitive...
        // external trusts outside of forest are not transitive
        //
        if ((DomainInfo->Attributes & ( TRUST_ATTRIBUTE_FOREST_TRANSITIVE | TRUST_ATTRIBUTE_WITHIN_FOREST)) != 0)
        {
            TicketInfo->fTicketOpts |= AUTH_REQ_TRANSITIVE_TRUST;
        } 
    }

    if (DomainInfo->Sid)
    {
        cbSid = RtlLengthSid(DomainInfo->Sid);
        TicketInfo->TrustSid = (PSID) MIDL_user_allocate(cbSid);
        if (TicketInfo->TrustSid == NULL)
        {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }
        Status = RtlCopySid (
                    cbSid,
                    TicketInfo->TrustSid,
                    DomainInfo->Sid
                    );
        if (!NT_SUCCESS(Status))
        {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }
    }

    TicketInfo->TrustAttributes = DomainInfo->Attributes;
    TicketInfo->TrustType = DomainInfo->Type;

    //
    // Add trusted forest UNICODE STRING onto ticket info
    // if its Xforest
    //
    if ((DomainInfo->Attributes & TRUST_ATTRIBUTE_FOREST_TRANSITIVE ) != 0)
    {
        KerbErr = KerbDuplicateString(
                    &(TicketInfo->TrustedForest),
                    &DomainInfo->DnsName
                    );

        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }
    }

Cleanup:


    if (TrustInfo != NULL)
    {
        LsaIFree_LSAPR_TRUSTED_DOMAIN_INFO(
            TrustedDomainAuthInformation,
            TrustInfo
            );
    }


    if (!KERB_SUCCESS(KerbErr))
    {
        FreeTicketInfo(TicketInfo);
    }
    return(KerbErr);

}

//+-------------------------------------------------------------------------
//
//  Function:   KdcLookupDomainName
//
//  Synopsis:   Looks up a domain name in the list of domains and returns
//              the domain info
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KdcLookupDomainName(
    OUT PKDC_DOMAIN_INFO * DomainInfo,
    IN PUNICODE_STRING DomainName,
    IN PLIST_ENTRY DomainList
    )
{
    PLIST_ENTRY ListEntry;
    PKDC_DOMAIN_INFO Domain;

    TRACE(KDC, KdcLookupDomainName, DEB_FUNCTION);

    for (ListEntry = DomainList->Flink;
         ListEntry != DomainList ;
         ListEntry = ListEntry->Flink )
    {
        Domain = (PKDC_DOMAIN_INFO) CONTAINING_RECORD(ListEntry, KDC_DOMAIN_INFO, Next);
        if (KerbCompareUnicodeRealmNames(
                DomainName,
                &Domain->DnsName
                ) ||                // case insensitive
             RtlEqualUnicodeString(
                DomainName,
                &Domain->NetbiosName,
                TRUE))                  // case insensitive
        {

            KdcReferenceDomainInfo(Domain);
            *DomainInfo = Domain;
            return(KDC_ERR_NONE);
        }
    }
    return(KDC_ERR_S_PRINCIPAL_UNKNOWN);
}

//+-------------------------------------------------------------------------
//
//  Function:   KdcLookupDomainRoute
//
//  Synopsis:   Looks up a domain name in the list of domains and returns
//              the domain info for the closest domain.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KdcLookupDomainRoute(
    OUT PKDC_DOMAIN_INFO * DomainInfo,
    OUT PKDC_DOMAIN_INFO * ClosestRoute,
    IN PUNICODE_STRING DomainName,
    IN PLIST_ENTRY DomainList
    )
{
    KERBERR KerbErr;
    PKDC_DOMAIN_INFO Domain;

    TRACE(KDC, KdcLookupDomainRoute, DEB_FUNCTION);


    KerbErr = KdcLookupDomainName(
                &Domain,
                DomainName,
                DomainList
                );

    if (KERB_SUCCESS(KerbErr))
    {
        if (Domain->ClosestRoute != NULL)
        {
            *DomainInfo = Domain;

            // If the closest route is this domain, then cheat and send back
            // the closest domain as the domain requested.

            if (KerbCompareUnicodeRealmNames(&(Domain->ClosestRoute->DnsName), SecData.KdcDnsRealmName()))

            {
                *ClosestRoute = Domain;
            }
            else
            {
                *ClosestRoute = Domain->ClosestRoute;
            }
            KdcReferenceDomainInfo(*ClosestRoute);
            return(KDC_ERR_NONE);
        }
        else
        {
            KdcDereferenceDomainInfo(Domain);
            DebugLog((DEB_WARN,"Asked for referral to %wZ domain, in organization but unreachable\n",
                DomainName ));
            KerbErr = KDC_ERR_NO_TRUST_PATH;

        }
    }


    return(KerbErr);
}




//+-------------------------------------------------------------------------
//
//  Function:   KdcLookupDomainByDnsName
//
//  Synopsis:   Looks up a domain name in the list of domains and returns
//              the domain info
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

PKDC_DOMAIN_INFO
KdcLookupDomainByDnsName(
    IN PUNICODE_STRING DnsDomainName,
    IN PLIST_ENTRY DomainList
    )
{
    PLIST_ENTRY ListEntry;
    PKDC_DOMAIN_INFO Domain;

    TRACE(KDC, KdcLookupDomainName, DEB_FUNCTION);

    for (ListEntry = DomainList->Flink;
         ListEntry != DomainList ;
         ListEntry = ListEntry->Flink )
    {
        Domain = (PKDC_DOMAIN_INFO) CONTAINING_RECORD(ListEntry, KDC_DOMAIN_INFO, Next);
        if (KerbCompareUnicodeRealmNames(
                DnsDomainName,
                &Domain->DnsName
                ))
        {

            return(Domain);
        }
    }
    return(NULL);
}

#if DBG

VOID
DebugDumpDomainList(
    IN PLIST_ENTRY DomainList
    )
{
    PLIST_ENTRY ListEntry;
    PKDC_DOMAIN_INFO Domain;

    TRACE(KDC, KdcLookupDomainName, DEB_FUNCTION);

    for (ListEntry = DomainList->Flink;
         ListEntry != DomainList ;
         ListEntry = ListEntry->Flink )
    {
        Domain = (PKDC_DOMAIN_INFO) CONTAINING_RECORD(ListEntry, KDC_DOMAIN_INFO, Next);

        DebugLog((DEB_TRACE,"Domain %wZ:\n",&Domain->DnsName));
        if (Domain->ClosestRoute == NULL)
        {
            D_DebugLog((DEB_TRACE,"\t no closest route\n"));
        }
        else
        {
            D_DebugLog((DEB_TRACE,"\t closest route = %wZ\n",&Domain->ClosestRoute->DnsName));
        }

        if (Domain->Parent == NULL)
        {
            D_DebugLog((DEB_TRACE,"\t no parent\n"));
        }
        else
        {
            D_DebugLog((DEB_TRACE,"\t parent = %wZ\n",&Domain->Parent->DnsName));
        }
    }
}

#endif // DBG


//+-------------------------------------------------------------------------
//
//  Function:   KdcRecurseAddTreeTrust
//
//  Synopsis:   Recursively adds a tree trust - adds it and then all its
//              children.
//
//  Effects:    Adds children depth-first
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KdcRecurseAddTreeTrust(
    IN PLIST_ENTRY DomainList,
    IN PLSAPR_TREE_TRUST_INFO TreeTrust,
    IN OPTIONAL PKDC_DOMAIN_INFO DomainInfo
    )
{
    PKDC_DOMAIN_INFO NewDomainInfo = NULL;
    BOOLEAN Linked = FALSE;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG Index;

    //
    // Create new root trust
    //

    NewDomainInfo = (PKDC_DOMAIN_INFO) MIDL_user_allocate(sizeof(KDC_DOMAIN_INFO));
    if (NewDomainInfo == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    RtlZeroMemory(
        NewDomainInfo,
        sizeof(KDC_DOMAIN_INFO)
        );

    Status = KerbDuplicateString(
                &NewDomainInfo->DnsName,
                (PUNICODE_STRING) &TreeTrust->DnsDomainName
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    //
    // Uppercase the domain name here, as everything in the forest
    // is uplevel.
    //

    Status = RtlUpcaseUnicodeString(
                &NewDomainInfo->DnsName,
                &NewDomainInfo->DnsName,
                FALSE                   // don't allocate
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = KerbDuplicateString(
                &NewDomainInfo->NetbiosName,
                (PUNICODE_STRING)&TreeTrust->FlatName
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    NewDomainInfo->Parent = DomainInfo;
    NewDomainInfo->Attributes |= TRUST_ATTRIBUTE_WITHIN_FOREST; // we know from the xref that we're w/i the forest 

    //
    // Insert into list
    //

    NewDomainInfo->References = 1;

    InsertTailList(
        DomainList,
        &NewDomainInfo->Next
        );
    Linked = TRUE;


    //
    // Now recursively add all children
    //

    for (Index = 0; Index < TreeTrust->Children ; Index++ )
    {
        Status = KdcRecurseAddTreeTrust(
                    DomainList,
                    &TreeTrust->ChildDomains[Index],
                    NewDomainInfo
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

    }

Cleanup:
    if (!Linked && (NewDomainInfo != NULL))
    {
        KdcFreeDomainInfo(NewDomainInfo);
    }
    return(Status);

}


//+-------------------------------------------------------------------------
//
//  Function:   KdcInsertDomainTrustIntoTree
//
//  Synopsis:   Adds trust information to the tree of domains. For domains
//              which are in the tree, trust direction
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KdcInsertDomainTrustIntoForest(
    IN OUT PLIST_ENTRY DomainList,
    IN PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX NewTrust
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKDC_DOMAIN_INFO DomainInfo = NULL;
    PKDC_DOMAIN_INFO NewDomainInfo = NULL;
    ULONG cbSid;

    TRACE(KDC, KdcInsertDomainTrustIntoForest, DEB_FUNCTION);


    D_DebugLog((DEB_T_DOMAIN, "Inserting trusted domain into domain list: %wZ\n",&NewTrust->Name));

    //
    // Check to see if the domain is already in the tree
    //

    DomainInfo = KdcLookupDomainByDnsName(
                    (PUNICODE_STRING) &NewTrust->Name,
                    DomainList
                    );
    if (DomainInfo == NULL)
    {

        //
        // Allocate and fill in a new domain structure for this domain.
        // It is not part of the tree so the GUID will be zero.
        //

        NewDomainInfo = (PKDC_DOMAIN_INFO) MIDL_user_allocate(sizeof(KDC_DOMAIN_INFO));
        if (NewDomainInfo == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }


        RtlZeroMemory(
            NewDomainInfo,
            sizeof(KDC_DOMAIN_INFO)
            );

        //
        // Copy in the names of the domain
        //

        Status = KerbDuplicateString(
                    &NewDomainInfo->DnsName,
                    (PUNICODE_STRING) &NewTrust->Name
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        //
        // If the trust is uplevel, then uppercase
        //

        if (NewTrust->TrustType == TRUST_TYPE_UPLEVEL)
        {
            Status = RtlUpcaseUnicodeString(
                        &NewDomainInfo->DnsName,
                        &NewDomainInfo->DnsName,
                        FALSE                   // don't allocate
                        );
            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }
        }

        Status = KerbDuplicateString(
                    &NewDomainInfo->NetbiosName,
                    (PUNICODE_STRING) &NewTrust->FlatName
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        NewDomainInfo->References = 1;

        InsertTailList(DomainList, &NewDomainInfo->Next);
        DomainInfo = NewDomainInfo;
        NewDomainInfo = NULL;

    }

    DomainInfo->Attributes |= NewTrust->TrustAttributes;
    DomainInfo->Type = NewTrust->TrustType;

    //
    // If this is not an inbound-only trust, the closest route to get here
    // is to go directly here.
    //

    if ((NewTrust->TrustDirection & TRUST_DIRECTION_INBOUND) != 0)
    {
        DomainInfo->ClosestRoute = DomainInfo;
    }

    //
    // Note the confusion of inbound and outbound. For Kerberos inbound is
    // the opposite of for trust objects.
    //

    if ((NewTrust->TrustDirection & TRUST_DIRECTION_OUTBOUND) != 0)
    {
        DomainInfo->Flags |= KDC_TRUST_INBOUND;
        if (NewTrust->Sid != NULL)
        {
            cbSid = RtlLengthSid(NewTrust->Sid);
            DomainInfo->Sid = (PSID) MIDL_user_allocate(cbSid);
            if (DomainInfo->Sid == NULL)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }
            Status = RtlCopySid (
                        cbSid,
                        DomainInfo->Sid,
                        NewTrust->Sid
                        );
            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }

            if ((DomainInfo->Attributes & TRUST_ATTRIBUTE_FOREST_TRANSITIVE) != 0)
            {
                SecData.SetCrossForestEnabled(TRUE);
            }
        }
    }

Cleanup:

    if (NewDomainInfo != NULL)
    {
        KdcFreeDomainInfo(NewDomainInfo);
    }

    return(Status);

}


//+-------------------------------------------------------------------------
//
//  Function:   KdcComputeShortestDomainPaths
//
//  Synopsis:   Compute the shortest path for each domain in the tree
//              by traversing up until either the local domain or
//              a parent of it is located, and then traverse down.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KdcComputeShortestDomainPaths(
    IN PLIST_ENTRY DomainList
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKDC_DOMAIN_INFO * ParentList = NULL;
    ULONG CountOfParents = 0, Index;
    PKDC_DOMAIN_INFO LocalDomain;
    PKDC_DOMAIN_INFO WorkingDomain;
    PKDC_DOMAIN_INFO ParentDomain;
    PLIST_ENTRY ListEntry;
    BOOLEAN FoundParent;
    ULONG TouchedIndex = 1;

    TRACE(KDC, KdcComputeShortestDomainPaths, DEB_FUNCTION);

    //
    // If the tree is empty, then there are no shortest paths to compute.
    //

    if (IsListEmpty(DomainList))
    {
        return(STATUS_SUCCESS);
    }

    //
    // Calculate the number of parents & grandparents of the local domain.
    //

    LocalDomain = KdcLookupDomainByDnsName(
                    SecData.KdcDnsRealmName(),
                    DomainList
                    );

    if (LocalDomain == NULL)
    {
        DebugLog((DEB_ERROR,"No forest info for local domain - no transitive trust. %ws, line %d\n", THIS_FILE, __LINE__));
        return(STATUS_SUCCESS);
    }
    LocalDomain->ClosestRoute = LocalDomain;

    WorkingDomain = LocalDomain->Parent;


    while (WorkingDomain != NULL)
    {
        //
        // Stop if we've come to this domain before.
        //
        if (WorkingDomain->Touched == TouchedIndex)
        {

            ReportServiceEvent(
                EVENTLOG_ERROR_TYPE,
                KDCEVENT_TRUST_LOOP,
                sizeof(NTSTATUS),
                &Status,
                1,
                WorkingDomain->DnsName.Buffer
                );

            DebugLog((DEB_ERROR,"Loop in trust list! %ws, line %d\n", THIS_FILE, __LINE__));
            break;
        }

        WorkingDomain->Touched = TouchedIndex;
        CountOfParents++;
        WorkingDomain = WorkingDomain->Parent;
    }

    //
    // If we had any parents, build an array of all our parents.
    //

    if (CountOfParents != 0)
    {
        ParentList = (PKDC_DOMAIN_INFO *) MIDL_user_allocate(CountOfParents * sizeof(PKDC_DOMAIN_INFO));
        if (ParentList == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        //
        // Store each parent in the list.
        //
        Index = 0;
        TouchedIndex++;
        WorkingDomain = LocalDomain->Parent;
        while (WorkingDomain != NULL)
        {

            //
            // Stop if we've come to this domain before.
            //

            if (WorkingDomain->Touched == TouchedIndex)
            {
                DebugLog((DEB_ERROR,"Loop in trust list! %ws, line %d\n", THIS_FILE, __LINE__));
                break;
            }

            //
            // Skip domains that have no domain info. They have probably been
            // deleted.
            //
            WorkingDomain->Touched = TouchedIndex;

            ParentList[Index++] = WorkingDomain;
            WorkingDomain = WorkingDomain->Parent;
        }

    }

    //
    // Now loop through every domain in the tree. For each domain, if it
    // is not trusted, check it against the list of parents. If it is a
    // parent, walk down the list until a trusted domain is found.
    //


    for (ListEntry = DomainList->Flink;
         ListEntry != DomainList;
         ListEntry = ListEntry->Flink )
    {
        WorkingDomain = (PKDC_DOMAIN_INFO) CONTAINING_RECORD(ListEntry, KDC_DOMAIN_INFO, Next);

        ParentDomain = WorkingDomain;

        //
        // Walk up from this domain until we find a common ancestor with
        // the local domain
        //
        TouchedIndex++;
        while (ParentDomain != NULL)
        {

            //
            // Stop if we've come to this domain before.
            //

            if (ParentDomain->Touched == TouchedIndex)
            {
                DebugLog((DEB_ERROR,"Loop in trust list! %ws, line %d\n", THIS_FILE, __LINE__));
                break;
            }

            //
            // Skip domains that have no domain info. They have probably been
            // deleted.
            //

            ParentDomain->Touched = TouchedIndex;


            //
            // If the parent has a closest route, use it
            //

            if (ParentDomain->ClosestRoute != NULL)
            {
                WorkingDomain->ClosestRoute = ParentDomain->ClosestRoute;
                D_DebugLog((DEB_T_DOMAIN, "Shortest route for domain %wZ is %wZ\n",
                    &WorkingDomain->DnsName,
                    &WorkingDomain->ClosestRoute->DnsName
                    ));

                break;
            }


            //
            // Look through the list of parents for this domain to see if it
            // is trusted
            //

            Index = CountOfParents;
            FoundParent = FALSE;
            while (Index > 0)
            {
                Index--;
                if (ParentList[Index] == ParentDomain)
                {
                    //
                    // We found a domain that is a parent of
                    // ours
                    //

                    FoundParent = TRUE;

                }
                if (FoundParent && (ParentList[Index]->ClosestRoute != NULL))
                {
                    WorkingDomain->ClosestRoute = ParentList[Index]->ClosestRoute;
                    break;
                }
            }

            if (WorkingDomain->ClosestRoute != NULL)
            {
                D_DebugLog((DEB_T_DOMAIN, "Shortest route for domain %wZ is %wZ\n",
                    &WorkingDomain->DnsName,
                    &WorkingDomain->ClosestRoute->DnsName
                    ));
                break;

            }
            ParentDomain = ParentDomain->Parent;
        }
    }


Cleanup:
    if (ParentList != NULL)
    {
        MIDL_user_free(ParentList);
    }
    return(Status);

}

//+-------------------------------------------------------------------------
//
//  Function:   KerbFreeDomainList
//
//  Synopsis:   Frees a domain list element by element.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KdcFreeReferralCache(
    IN PLIST_ENTRY ReferralCache
    )
{
    PREFERRAL_CACHE_ENTRY CacheEntry;

    TRACE(KDC, KdcFreeReferralCache, DEB_FUNCTION);

    if (ReferralCache->Flink != NULL)
    {
        while (!IsListEmpty(ReferralCache))
        {
            CacheEntry = CONTAINING_RECORD(ReferralCache->Flink, REFERRAL_CACHE_ENTRY, ListEntry );

            RemoveEntryList(&CacheEntry->ListEntry);
            InitializeListHead(&CacheEntry->ListEntry);
            KdcDereferenceReferralCacheEntry(CacheEntry);
        }
    }

}



//+-------------------------------------------------------------------------
//
//  Function:   KerbFreeDomainList
//
//  Synopsis:   Frees a domain list element by element.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KdcFreeDomainList(
    IN PLIST_ENTRY DomainList
    )
{
    PKDC_DOMAIN_INFO DomainInfo;

    TRACE(KDC, KdcFreeDomainList, DEB_FUNCTION);

    if (DomainList->Flink != NULL)
    {
        while (!IsListEmpty(DomainList))
        {
            DomainInfo = CONTAINING_RECORD(DomainList->Flink, KDC_DOMAIN_INFO, Next );

            RemoveEntryList(&DomainInfo->Next);
            InitializeListHead(&DomainInfo->Next);
            KdcDereferenceDomainInfo(DomainInfo);
        }
    }

}

#ifdef DBG_BUILD_FOREST

VOID
DebugBuildDomainForest(
    OUT PLSAPR_FOREST_TRUST_INFO * ForestInfo
    )
{
    PLSAPR_FOREST_TRUST_INFO ForestTrustInfo = NULL;
    PLSAPR_TREE_TRUST_INFO ChildDomains = NULL;
    PLSAPR_TREE_TRUST_INFO ChildRoot = NULL;
        UNICODE_STRING TempString;
    ULONG Index;
    LPWSTR  MsNames[4] = {L"ntdev.microsoft.com",L"alpamayo.ntdev.microsoft.com",L"annapurna.alpamayo.ntdev.microsoft.com",L"lhotse.annapurna.alpamayo.ntdev.microsoft.com" };

    ForestTrustInfo = (PLSAPR_FOREST_TRUST_INFO) MIDL_user_allocate(sizeof(LSAPR_FOREST_TRUST_INFO));

    RtlInitUnicodeString(
        &TempString,
        MsNames[0]
        );
    KerbDuplicateString( (PUNICODE_STRING)
        &ForestTrustInfo->RootTrust.DnsDomainName,
        &TempString
        );
    KerbDuplicateString( (PUNICODE_STRING)
        &ForestTrustInfo->RootTrust.FlatName,
        &TempString
        );

    ChildRoot = &ForestTrustInfo->RootTrust;

    for (Index = 1; Index < 4 ; Index++ )
    {
        ChildRoot->Children = 1;
        ChildRoot->ChildDomains = (PLSAPR_TREE_TRUST_INFO) MIDL_user_allocate(sizeof(LSAPR_TREE_TRUST_INFO));
        RtlZeroMemory(
            ChildRoot->ChildDomains,
            sizeof(LSAPR_TREE_TRUST_INFO)
            );

        RtlInitUnicodeString(
            &TempString,
            MsNames[Index]
            );
        KerbDuplicateString( (PUNICODE_STRING)
            &ChildRoot->ChildDomains[0].DnsDomainName,
            &TempString
            );
        KerbDuplicateString( (PUNICODE_STRING)
            &ChildRoot->ChildDomains[0].FlatName,
            &TempString
            );

        ChildRoot = &ChildRoot->ChildDomains[0];
    }


    //
    // Should be all done now
    //


    *ForestInfo = ForestTrustInfo;
}

#endif // DBG_BUILD_FOREST


//+-------------------------------------------------------------------------
//
//  Function:   KdcBuildDomainTree
//
//  Synopsis:   Enumerates the list of domains and inserts them
//              all into a tree
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KdcBuildDomainTree(
    IN OUT PLIST_ENTRY DomainList
    )
{
    NTSTATUS Status;
    ULONG Index;
    PLSAPR_FOREST_TRUST_INFO ForestInfo = NULL;
    LSAPR_TRUSTED_ENUM_BUFFER_EX TrustedBuffer;
    LSA_ENUMERATION_HANDLE EnumContext = 0;
    ULONG CountReturned;

    TRACE(KDC, KdcBuildDomainList, DEB_FUNCTION);

    InitializeListHead(DomainList);

    RtlZeroMemory(
        &TrustedBuffer,
        sizeof(LSAPR_TRUSTED_ENUM_BUFFER_EX)
        );

    //
    // Call the LSA to enumerate all the trees in the enterprise and insert
    // them into the tree
    //

#ifndef DBG_BUILD_FOREST
    Status = LsaIQueryForestTrustInfo(
                GlobalPolicyHandle,
                &ForestInfo
                );

    //
    // If we aren't part of a tree, we may get back STATUS_OBJECT_NAME_NOT_FOUND
    // so this is o.k.
    //

    if (!NT_SUCCESS(Status))
    {
        if (Status == STATUS_OBJECT_NAME_NOT_FOUND)
        {
            DebugLog((DEB_WARN,"No trust info (0x%x) continuing\n",Status));
            Status = STATUS_SUCCESS;
        }
        else
        {
            goto Cleanup;
        }
    }
#else
    DebugBuildDomainForest(&ForestInfo);
#endif

    //
    // Only use this if the information is usable - it is present
    //


    if (ForestInfo != NULL)
    {
        Status = KdcRecurseAddTreeTrust(
                    DomainList,
                    &ForestInfo->RootTrust,
                    NULL
                    );


        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }


        Status = SecData.SetForestRoot(&(ForestInfo->RootTrust.DnsDomainName));

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

    }
    //
    // Now add all the trusts in.
    //
    SecData.SetCrossForestEnabled(FALSE); // set this to FALSE for now

    do
    {
        CountReturned = 0;

        Status = LsarEnumerateTrustedDomainsEx(
                    GlobalPolicyHandle,
                    &EnumContext,
                    &TrustedBuffer,
                    0xffffff           // preferred maximum length
                    );

        if (!NT_ERROR(Status))
        {
            //
            // Call the LSA to enumerate all the trust relationships and integrate
            // them into the tree
            //

            for (Index = 0; (Index < TrustedBuffer.EntriesRead) && NT_SUCCESS(Status) ; Index++ )
            {
                if (TrustedBuffer.EnumerationBuffer[Index].TrustType != TRUST_TYPE_DOWNLEVEL)
                {
                    Status = KdcInsertDomainTrustIntoForest(
                                DomainList,
                                &TrustedBuffer.EnumerationBuffer[Index]
                                );
                }
            }
        }


        LsaIFree_LSAPR_TRUSTED_ENUM_BUFFER_EX(&TrustedBuffer);
        RtlZeroMemory(
            &TrustedBuffer,
            sizeof(LSAPR_TRUSTED_ENUM_BUFFER_EX)
            );


    } while (NT_SUCCESS(Status) && (CountReturned != 0));

    if (NT_ERROR(Status))
    {
        if (Status != STATUS_OBJECT_NAME_NOT_FOUND)
        {
            DebugLog((DEB_ERROR,"Failed to enumerate trusted domains: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
            goto Cleanup;
        }
        Status = STATUS_SUCCESS;
    }

    //
    // Now compute the shortest path from each domain in the tree.
    //

    Status = KdcComputeShortestDomainPaths(
                DomainList
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

#if DBG
    DebugDumpDomainList(DomainList);
#endif

Cleanup:

    if (ForestInfo != NULL)
    {
        LsaIFreeForestTrustInfo(ForestInfo);
    }

    if (!NT_SUCCESS(Status))
    {
        KdcFreeDomainList(DomainList);
    }
    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KdcReloadDomainTree
//
//  Synopsis:   Reloads the domain tree when it has changed
//
//  Effects:
//
//  Arguments:  Dummy - dummy argument requred for CreateThread calls
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


ULONG
KdcReloadDomainTree(
    PVOID Dummy
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    LIST_ENTRY DomainList;

    TRACE(KDC, KdcBuildDomainList, DEB_FUNCTION);

    InitializeListHead(&DomainList);


    Status = EnterApiCall();

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    if (!KdcReferralCacheInitialized)
    {

        Status = RtlInitializeCriticalSection(&KdcReferralCacheLock);
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
        InitializeListHead(&KdcReferralCache);
        KdcReferralCacheInitialized = TRUE;
    }




    D_DebugLog((DEB_TRACE,"About to reload domain tree\n"));

    if (!KdcDomainListInitialized)
    {
        Status = RtlInitializeCriticalSection(&KdcDomainListLock);
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
        InitializeListHead(&KdcDomainList);
        KdcDomainListInitialized = TRUE;
    }

    Status = KdcBuildDomainTree(&DomainList);

    if (NT_SUCCESS(Status))
    {
        KdcLockDomainList();

        KdcFreeDomainList(&KdcDomainList);

        KdcDomainList = DomainList;

        DomainList.Flink->Blink = &KdcDomainList;
        DomainList.Blink->Flink = &KdcDomainList;

        KdcUnlockDomainList();
    }
    else
    {
        ReportServiceEvent(
            EVENTLOG_ERROR_TYPE,
            KDCEVENT_DOMAIN_LIST_UPDATE_FAILED,
            sizeof(NTSTATUS),
            &Status,
            0,
            NULL
            );

    }
Cleanup:
    LeaveApiCall();
    return((ULONG)Status);
}



//+-------------------------------------------------------------------------
//
//  Function:   KdcTrustChangeCallback
//
//  Synopsis:   This is the callback that gets invoked with the Lsa has determined
//              that the trust tree has changed.  The call is made asynchronously.
//
//  Effects:    Potentially causes the trust tree to be rebuilt
//
//  Arguments:  DeltaType - Type of change to the trust tree
//
//  Requires:   Nothing
//
//  Returns:    VOID
//
//  Notes:
//
//
//--------------------------------------------------------------------------
VOID
KdcTrustChangeCallback (
    SECURITY_DB_DELTA_TYPE DeltaType
    )
{
    NTSTATUS Status;

    TRACE(KDC, KdcTrustChangeCallback, DEB_FUNCTION);

    if ( DeltaType == SecurityDbNew || DeltaType == SecurityDbDelete  ||
         DeltaType == SecurityDbChange) {

        Status = KdcReloadDomainTree( NULL );

        if (!NT_SUCCESS(Status)) {

            DebugLog((DEB_ERROR,"KdcReloadDomainTree from callback failed with 0x%lx. %ws, line %d\n",
                      Status, THIS_FILE, __LINE__));
        }
    }
}


VOID
KdcLockDomainListFn(
   )
{
    KdcLockDomainList();
}

VOID
KdcUnlockDomainListFn(
   )
{
    KdcUnlockDomainList();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\server\pkserv.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1997
//
// File:        pkserv.h
//
// Contents:    types and prototypes for pk authentication
//
//
// History:     1-Dec-1997      MikeSw          Created
//
//------------------------------------------------------------------------

#ifndef __PKSERV_H__
#define __PKSERV_H__


KERBERR
KdcCheckPkinitPreAuthData(
    IN PKDC_TICKET_INFO ClientTicketInfo,
    IN SAMPR_HANDLE UserHandle,
    IN OPTIONAL PKERB_PA_DATA_LIST PreAuthData,
    IN PKERB_KDC_REQUEST_BODY ClientRequest,
    OUT PKERB_PA_DATA_LIST * OutputPreAuthData,
    OUT PULONG Nonce,
    OUT PKERB_ENCRYPTION_KEY EncryptionKey,
    OUT PUNICODE_STRING TransitedRealm,
    OUT PKDC_PKI_AUDIT_INFO PkiAuditInfo,
    OUT PKERB_EXT_ERROR pExtendedError
    );

BOOLEAN
KdcCheckForEtype(
    IN PKERB_CRYPT_LIST CryptList,
    IN ULONG Etype
    );

NTSTATUS
KdcInitializeCerts(
    VOID
    );

VOID
KdcCleanupCerts(
    IN BOOLEAN CleanupScavenger
    );

VOID
KdcFreePkiAuditInfo(
    IN PKDC_PKI_AUDIT_INFO AuditInfo
    );



#endif // __PKSERV_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\server\pac.cxx ===
//+-----------------------------------------------------------------------
//
// File:        pac.cxx
//
// Contents:    KDC Pac generation code.
//
//
// History:     16-Jan-93   WadeR   Created.
//
//------------------------------------------------------------------------

#include "kdcsvr.hxx"
#include <pac.hxx>
#include "kdctrace.h"
#include "fileno.h"
#include <userall.h>
#include <sddl.h>
#include <utils.hxx>

#define FILENO FILENO_GETAS
SECURITY_DESCRIPTOR AuthenticationSD;

#ifndef DONT_SUPPORT_OLD_TYPES
#define KDC_PAC_KEYTYPE         KERB_ETYPE_RC4_HMAC_OLD
#define KDC_PAC_CHECKSUM        KERB_CHECKSUM_HMAC_MD5
#else
#define KDC_PAC_KEYTYPE         KERB_ETYPE_RC4_HMAC
#define KDC_PAC_CHECKSUM        KERB_CHECKSUM_HMAC_MD5
#endif


//+-------------------------------------------------------------------------
//
//  Function:   EnterApiCall
//
//  Synopsis:   Makes sure that the KDC service is initialized and running
//              and won't terminate during the call.
//
//  Effects:    increments the CurrentApiCallers count.
//
//  Arguments:
//
//  Requires:
//
//  Returns:    STATUS_INVALID_SERVER_STATE - the KDC service is not
//                      running
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
EnterApiCall(
    VOID
    )
{
    NTSTATUS hrRet = STATUS_SUCCESS;
    EnterCriticalSection(&ApiCriticalSection);
    if (KdcState != Stopped)
    {
        CurrentApiCallers++;
    }
    else
    {
        hrRet = STATUS_INVALID_SERVER_STATE;
    }
    LeaveCriticalSection(&ApiCriticalSection);
    return(hrRet);
}


//+-------------------------------------------------------------------------
//
//  Function:   LeaveApiCall
//
//  Synopsis:   Decrements the count of active calls and if the KDC is
//              shutting down sets an event to let it continue.
//
//  Effects:    Deccrements the CurrentApiCallers count.
//
//  Arguments:
//
//  Requires:
//
//  Returns:    Nothing
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
LeaveApiCall(
    VOID
    )
{
    EnterCriticalSection(&ApiCriticalSection);
    CurrentApiCallers--;

    if (KdcState == Stopped)
    {
        if (CurrentApiCallers == 0)
        {
            if (!SetEvent(hKdcShutdownEvent))
            {
                D_DebugLog((DEB_ERROR,"Failed to set shutdown event from LeaveApiCall: 0x%d\n",GetLastError()));
            }
            else
            {
                UpdateStatus(SERVICE_STOP_PENDING);
            }

            //
            // Free any DS libraries in use
            //

            SecData.Cleanup();

            if (KdcTraceRegistrationHandle != (TRACEHANDLE)0)
            {
                UnregisterTraceGuids( KdcTraceRegistrationHandle );
                KdcTraceRegistrationHandle = (TRACEHANDLE)0;
            }
        }
    }

    LeaveCriticalSection(&ApiCriticalSection);
}


//+-------------------------------------------------------------------------
//
//  Function:   KdcInsertPacIntoAuthData
//
//  Synopsis:   Inserts the PAC into the auth data in the two places
//              it lives - in the IF_RELEVANT portion & in the outer body
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KdcInsertPacIntoAuthData(
    IN PKERB_AUTHORIZATION_DATA AuthData,
    IN PKERB_IF_RELEVANT_AUTH_DATA IfRelevantData,
    IN PKERB_AUTHORIZATION_DATA PacAuthData,
    OUT PKERB_AUTHORIZATION_DATA * UpdatedAuthData
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    PKERB_AUTHORIZATION_DATA LocalAuthData = NULL;
    PKERB_AUTHORIZATION_DATA LocalIfRelevantData = NULL;
    PKERB_AUTHORIZATION_DATA NewIfRelevantData = NULL;
    PKERB_AUTHORIZATION_DATA NewPacData = NULL;
    KERB_AUTHORIZATION_DATA TempPacData = {0};
    PKERB_AUTHORIZATION_DATA NewAuthData = NULL;
    KERB_AUTHORIZATION_DATA TempOldPac = {0};
    PKERB_AUTHORIZATION_DATA TempNextPointer,NextPointer;

    NewPacData = (PKERB_AUTHORIZATION_DATA) MIDL_user_allocate(sizeof(KERB_AUTHORIZATION_DATA));
    NewIfRelevantData = (PKERB_AUTHORIZATION_DATA) MIDL_user_allocate(sizeof(KERB_AUTHORIZATION_DATA));

    if ((NewPacData == NULL) || (NewIfRelevantData == NULL))
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    RtlZeroMemory(
        NewPacData,
        sizeof(KERB_AUTHORIZATION_DATA)
        );

    RtlZeroMemory(
        NewIfRelevantData,
        sizeof(KERB_AUTHORIZATION_DATA)
        );

    //
    // First build the IfRelevantData
    //
    // The general idea is to replace, in line, the relevant authorization
    // data. This means (a) putting it into the IfRelevantData or making
    // the IfRelevantData be PacAuthData, and (b) putting it into AuthData
    // as well as changing the IfRelevant portions of that data
    //

    if (IfRelevantData != NULL)
    {
        LocalAuthData = KerbFindAuthDataEntry(
                            KERB_AUTH_DATA_PAC,
                            IfRelevantData
                            );

        if (LocalAuthData == NULL)
        {
            LocalIfRelevantData = PacAuthData;
            PacAuthData->next = IfRelevantData;
        }
        else
        {
            //
            // Replace the pac in the if-relevant list with the
            // new one.
            //

            TempOldPac = *LocalAuthData;
            LocalAuthData->value.auth_data.value = PacAuthData->value.auth_data.value;
            LocalAuthData->value.auth_data.length = PacAuthData->value.auth_data.length;

            LocalIfRelevantData = IfRelevantData;
        }
    }
    else
    {
        //
        // build a new if-relevant data
        //

        TempPacData = *PacAuthData;
        TempPacData.next = NULL;
        LocalIfRelevantData = &TempPacData;
    }

    //
    // Build a local if-relevant auth data
    //

    KerbErr = KerbPackData(
                &LocalIfRelevantData,
                PKERB_IF_RELEVANT_AUTH_DATA_PDU,
                (PULONG) &NewIfRelevantData->value.auth_data.length,
                &NewIfRelevantData->value.auth_data.value
                );

    //
    // fixup the old if-relevant list, if necessary
    //

    if (TempOldPac.value.auth_data.value != NULL)
    {
        *LocalAuthData = TempOldPac;
    }

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    NewIfRelevantData->value.auth_data_type = KERB_AUTH_DATA_IF_RELEVANT;

    *NewPacData = *PacAuthData;

    //
    // Zero this out so the old data doesn't get used
    //

    PacAuthData->value.auth_data.value = NULL;
    PacAuthData->value.auth_data.length = 0;

    //
    // Now we have a new if_relevant & a new pac for the outer auth-data list.
    //

    NewAuthData = NewIfRelevantData;
    NewIfRelevantData->next = NULL;
    NewIfRelevantData = NULL;

    //
    // Start building the list, first putting the non-pac entries at the end
    //

    NextPointer = AuthData;
    while (NextPointer != NULL)
    {
        if ((NextPointer->value.auth_data_type != KERB_AUTH_DATA_IF_RELEVANT) &&
            (NextPointer->value.auth_data_type != KERB_AUTH_DATA_PAC))
        {
            TempNextPointer = NextPointer->next;
            NextPointer->next = NULL;

            KerbErr = KerbCopyAndAppendAuthData(
                        &NewAuthData,
                        NextPointer
                        );

            NextPointer->next = TempNextPointer;

            if (!KERB_SUCCESS(KerbErr))
            {
                goto Cleanup;
            }
        }

        NextPointer = NextPointer->next;
    }

    *UpdatedAuthData = NewAuthData;
    NewAuthData = NULL;

Cleanup:

    if (NewPacData != NULL)
    {
        KerbFreeAuthData(NewPacData);
    }

    if (NewIfRelevantData != NULL)
    {
        KerbFreeAuthData(NewIfRelevantData);
    }

    if (NewAuthData != NULL)
    {
        KerbFreeAuthData(NewAuthData);
    }

    return(KerbErr);
}

//+-------------------------------------------------------------------------
//
//  Function:   KdcBuildPacSidList
//
//  Synopsis:   Builds a list of SIDs in the PAC
//
//  Effects:
//
//  Arguments:  UserInfo       - validation information
//              AddEveryone    - add "Everyone" and "Authenticated User" SIDs?
//              CrossOrganization - add "Other Org" SID?
//              Sids           - used to return the resulting SIDs
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KdcBuildPacSidList(
    IN  PNETLOGON_VALIDATION_SAM_INFO3 UserInfo,
    IN  BOOLEAN AddEveryone,
    IN  BOOLEAN CrossOrganization,
    OUT PSAMPR_PSID_ARRAY Sids
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    ULONG Size = 0, i;

    Sids->Count = 0;
    Sids->Sids = NULL;

    if (UserInfo->UserId != 0)
    {
        Size += sizeof(SAMPR_SID_INFORMATION);
    }

    if (AddEveryone)
    {
        Size += (sizeof(SAMPR_SID_INFORMATION) * 2);
    }

    if (CrossOrganization)
    {
        Size += sizeof(SAMPR_SID_INFORMATION);
    }

    Size += UserInfo->GroupCount * (ULONG)sizeof(SAMPR_SID_INFORMATION);

    //
    // If there are extra SIDs, add space for them
    //

    if (UserInfo->UserFlags & LOGON_EXTRA_SIDS) {
        Size += UserInfo->SidCount * (ULONG)sizeof(SAMPR_SID_INFORMATION);
    }

    Sids->Sids = (PSAMPR_SID_INFORMATION) MIDL_user_allocate( Size );

    if ( Sids->Sids == NULL ) {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    RtlZeroMemory(
        Sids->Sids,
        Size
        );

    //
    // Start copying SIDs into the structure
    //

    i = 0;

    //
    // If the UserId is non-zero, then it contians the users RID.
    //

    if ( UserInfo->UserId ) {

        Sids->Sids[0].SidPointer = (PRPC_SID)
                KerbMakeDomainRelativeSid( UserInfo->LogonDomainId,
                                           UserInfo->UserId );

        if( Sids->Sids[0].SidPointer == NULL ) {

            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }

        Sids->Count++;
    }

    //
    // Copy over all the groups passed as RIDs
    //

    for ( i=0; i < UserInfo->GroupCount; i++ ) {

        Sids->Sids[Sids->Count].SidPointer = (PRPC_SID)
                                    KerbMakeDomainRelativeSid(
                                         UserInfo->LogonDomainId,
                                         UserInfo->GroupIds[i].RelativeId );

        if( Sids->Sids[Sids->Count].SidPointer == NULL ) {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }

        Sids->Count++;
    }

    //
    // Add in the extra SIDs
    //

    //
    // No need to allocate these, but...
    //

    if (UserInfo->UserFlags & LOGON_EXTRA_SIDS) {

        for ( i = 0; i < UserInfo->SidCount; i++ ) {

            if (!NT_SUCCESS(KerbDuplicateSid(
                                (PSID *) &Sids->Sids[Sids->Count].SidPointer,
                                UserInfo->ExtraSids[i].Sid
                                )))
            {
                KerbErr = KRB_ERR_GENERIC;
                goto Cleanup;
            }

            Sids->Count++;
        }
    }

    //
    // Add in everyone, and authenticated users.
    //

    if ( AddEveryone )
    {
        if (!NT_SUCCESS(KerbDuplicateSid(
                    (PSID*) &Sids->Sids[Sids->Count].SidPointer,
                    GlobalEveryoneSid
                    )))
        {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }

        Sids->Count++;

        if (!NT_SUCCESS(KerbDuplicateSid(
                    (PSID*) &Sids->Sids[Sids->Count].SidPointer,
                    GlobalAuthenticatedUserSid
                    )))
        {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }

        Sids->Count++;
    }

    //
    // Add in the "Other Organization" SID
    //

    if ( CrossOrganization )
    {
        if (!NT_SUCCESS(KerbDuplicateSid(
                    (PSID*) &Sids->Sids[Sids->Count].SidPointer,
                    GlobalOtherOrganizationSid )))
        {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }

        Sids->Count++;
    }

Cleanup:

    if (!KERB_SUCCESS(KerbErr))
    {
        if (Sids->Sids != NULL)
        {
            for (i = 0; i < Sids->Count ;i++ )
            {
                if (Sids->Sids[i].SidPointer != NULL)
                {
                    MIDL_user_free(Sids->Sids[i].SidPointer);
                }
            }

            MIDL_user_free(Sids->Sids);
            Sids->Sids = NULL;
            Sids->Count = 0;
        }
    }

    return KerbErr;
}


//+-------------------------------------------------------------------------
//
//  Function:   KdcAddResourceGroupsToPac
//
//  Synopsis:   Queries SAM for resources groups and builds a new PAC with
//              those groups
//
//  Effects:    Adds Domain Local and Universal groups **IN NATIVE MODE ONLY**
//              Only called when you reach domain of target service.
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KdcAddResourceGroupsToPac(
    IN PPACTYPE OldPac,
    IN BOOLEAN DcTarget,
    IN ULONG ChecksumSize,
    OUT PPACTYPE * NewPac
    )
{
    NTSTATUS Status;
    KERBERR KerbErr = KDC_ERR_NONE;
    PPAC_INFO_BUFFER LogonInfo;
    ULONG Index;
    PNETLOGON_VALIDATION_SAM_INFO3 ValidationInfo = NULL;
    SAMPR_PSID_ARRAY SidList = {0};
    PSAMPR_PSID_ARRAY ResourceGroups = NULL;

    //
    // First, find the logon information
    //

    LogonInfo = PAC_Find(
                    OldPac,
                    PAC_LOGON_INFO,
                    NULL
                    );

    if (LogonInfo == NULL)
    {
        D_DebugLog((DEB_WARN,"No logon info for PAC - not adding resource groups\n"));
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    //
    // Now unmarshall the validation information and build a list of sids
    //

    if (!NT_SUCCESS(PAC_UnmarshallValidationInfo(
                        &ValidationInfo,
                        LogonInfo->Data,
                        LogonInfo->cbBufferSize)))
    {
        D_DebugLog((DEB_ERROR,"Failed to unmarshall validation info!\n"));
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    KerbErr = KdcBuildPacSidList(
                ValidationInfo,
                FALSE,
                FALSE,
                &SidList
                );




    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    //
    // Call SAM to get the sids
    //

    Status = SamIGetResourceGroupMembershipsTransitive(
                 GlobalAccountDomainHandle,
                 &SidList,
                 (DcTarget ? SAM_SERVICE_TARGET_IS_DC : 0),
                 &ResourceGroups
                 );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to get resource groups: 0x%x\n",Status));
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    //
    // Now build a new pac
    //

    Status = PAC_InitAndUpdateGroups(
                 ValidationInfo,
                 ResourceGroups,
                 OldPac,
                 NewPac
                 );

    if (!NT_SUCCESS(Status))
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

Cleanup:

    if (ValidationInfo != NULL)
    {
        MIDL_user_free(ValidationInfo);
    }

    if (SidList.Sids != NULL)
    {
        for (Index = 0; Index < SidList.Count ;Index++ )
        {
            if (SidList.Sids[Index].SidPointer != NULL)
            {
                MIDL_user_free(SidList.Sids[Index].SidPointer);
            }
        }

        MIDL_user_free(SidList.Sids);
    }

    SamIFreeSidArray(
        ResourceGroups
        );

    return(KerbErr);
}


//+-------------------------------------------------------------------------
//
//  Function:   KdcSignPac
//
//  Synopsis:   Signs a PAC by first checksumming it with the
//              server's key and then signing that with the KDC key.
//
//  Effects:    Modifies the server sig & privsvr sig fields of the PAC
//
//  Arguments:  ServerInfo - Ticket info for the server, used
//                      for the initial signature
//              PacData - An marshalled PAC.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KdcSignPac(
    IN PKERB_ENCRYPTION_KEY ServerKey,
    IN BOOLEAN AddResourceGroups,
    IN BOOLEAN DCTarget,
    IN OUT PUCHAR * PacData,
    IN PULONG PacSize
    )
{
    NTSTATUS Status;
    KERBERR KerbErr = KDC_ERR_NONE;
    PCHECKSUM_FUNCTION Check = NULL ;
    PCHECKSUM_BUFFER CheckBuffer = NULL;
    PPAC_INFO_BUFFER ServerBuffer;
    PPAC_INFO_BUFFER PrivSvrBuffer;
    PPAC_SIGNATURE_DATA ServerSignature;
    PPAC_SIGNATURE_DATA PrivSvrSignature;
    PKERB_ENCRYPTION_KEY EncryptionKey;
    PPACTYPE Pac = NULL, NewPac = NULL;
    ULONG LocalPacSize = 0;
    KDC_TICKET_INFO KdcTicketInfo = {0};
    BOOL PacUnmarshalled = FALSE;

    TRACE(KDC, KdcSignPac, DEB_FUNCTION);

    KerbErr = SecData.GetKrbtgtTicketInfo(&KdcTicketInfo);
    if (!KERB_SUCCESS(KerbErr))
    {
        Status = KerbMapKerbError(KerbErr);
        goto Cleanup;
    }

    //
    // Locate the checksum used to sign the PAC.
    //

    Status = CDLocateCheckSum(
                 (ULONG) KDC_PAC_CHECKSUM,
                 &Check
                 );

    if (!NT_SUCCESS(Status))
    {
        KerbErr = KDC_ERR_SUMTYPE_NOSUPP;
        goto Cleanup;
    }

    //
    // Unmarshal the PAC in place so we can locate the signatuer buffers
    //

    Pac = (PPACTYPE) *PacData;
    LocalPacSize = *PacSize;

    if (PAC_UnMarshal(Pac, LocalPacSize) == 0)
    {
        D_DebugLog((DEB_ERROR,"Failed to unmarshal pac\n"));
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    PacUnmarshalled = TRUE;
    //
    // If we are to add local groups, do so now
    //

    if (AddResourceGroups)
    {
        KerbErr = KdcAddResourceGroupsToPac(
                      Pac,
                      DCTarget,
                      Check->CheckSumSize,
                      &NewPac
                      );

        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }

        Pac = NewPac;
        LocalPacSize = PAC_GetSize(Pac);
    }

    //
    // Locate the signature buffers so the signature fields can be zeroed out
    // before computing the checksum.
    //

    ServerBuffer = PAC_Find(Pac, PAC_SERVER_CHECKSUM, NULL );
    DsysAssert(ServerBuffer != NULL);
    if (ServerBuffer == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    ServerSignature = (PPAC_SIGNATURE_DATA) ServerBuffer->Data;
    ServerSignature->SignatureType = (ULONG) KDC_PAC_CHECKSUM;

    RtlZeroMemory(
        ServerSignature->Signature,
        PAC_CHECKSUM_SIZE(ServerBuffer->cbBufferSize)
        );

    PrivSvrBuffer = PAC_Find(Pac, PAC_PRIVSVR_CHECKSUM, NULL );
    DsysAssert(PrivSvrBuffer != NULL);
    if (PrivSvrBuffer == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    PrivSvrSignature = (PPAC_SIGNATURE_DATA) PrivSvrBuffer->Data;
    PrivSvrSignature->SignatureType = (ULONG) KDC_PAC_CHECKSUM;

    RtlZeroMemory(
        PrivSvrSignature->Signature,
        PAC_CHECKSUM_SIZE(PrivSvrBuffer->cbBufferSize)
        );

    //
    // Now remarshall the PAC to compute the checksum.
    //

    if (!PAC_ReMarshal(Pac, LocalPacSize))
    {
        DsysAssert(!"PAC_Remarshal Failed");
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    PacUnmarshalled = FALSE;
    //
    // Now compute the signatures on the PAC. First we compute the checksum
    // of the whole PAC.
    //

    if (NULL != Check->InitializeEx2)
    {
        Status = Check->InitializeEx2(
                    ServerKey->keyvalue.value,
                    ServerKey->keyvalue.length,
                    NULL,
                    KERB_NON_KERB_CKSUM_SALT,
                    &CheckBuffer
                    );
    }
    else
    {
        Status = Check->InitializeEx(
                    ServerKey->keyvalue.value,
                    ServerKey->keyvalue.length,
                    KERB_NON_KERB_CKSUM_SALT,
                    &CheckBuffer
                    );
    }

    if (!NT_SUCCESS(Status))
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    Check->Sum(
        CheckBuffer,
        LocalPacSize,
        (PUCHAR) Pac
        );
    Check->Finalize(
        CheckBuffer,
        ServerSignature->Signature
        );
    Check->Finish(
        &CheckBuffer
        );

    //
    // Now we've compute the server checksum - next compute the checksum
    // of the server checksum using the KDC account.
    //

    //
    // Get the key used to sign pacs.
    //

    EncryptionKey = KerbGetKeyFromList(
                        KdcTicketInfo.Passwords,
                        (ULONG) KDC_PAC_KEYTYPE
                        );

    if (EncryptionKey == NULL)
    {
        Status = SEC_E_ETYPE_NOT_SUPP;
        goto Cleanup;
    }

    if (NULL != Check->InitializeEx2)
    {
        Status = Check->InitializeEx2(
                    EncryptionKey->keyvalue.value,
                    EncryptionKey->keyvalue.length,
                    NULL,
                    KERB_NON_KERB_CKSUM_SALT,
                    &CheckBuffer
                    );
    }
    else
    {
        Status = Check->InitializeEx(
                    EncryptionKey->keyvalue.value,
                    EncryptionKey->keyvalue.length,
                    KERB_NON_KERB_CKSUM_SALT,
                    &CheckBuffer
                    );
    }

    if (!NT_SUCCESS(Status))
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    Check->Sum(
        CheckBuffer,
        Check->CheckSumSize,
        ServerSignature->Signature
        );
    Check->Finalize(
        CheckBuffer,
        PrivSvrSignature->Signature
        );
    Check->Finish(
        &CheckBuffer
        );

    if (*PacData != (PBYTE) Pac)
    {
        MIDL_user_free(*PacData);
        *PacData = (PBYTE) Pac;
        *PacSize = LocalPacSize;
    }

Cleanup:

    if ( PacUnmarshalled )
    {
        if (!PAC_ReMarshal(Pac, LocalPacSize))
        {
            DsysAssert(!"PAC_Remarshal Failed");
            KerbErr = KRB_ERR_GENERIC;
        }
    }

    if ( ( CheckBuffer != NULL ) &&
         ( Check != NULL ) )
    {
        Check->Finish(&CheckBuffer);
    }

    if (!KERB_SUCCESS(KerbErr) && (NewPac != NULL))
    {
        MIDL_user_free(NewPac);
    }

    FreeTicketInfo(&KdcTicketInfo);

    return(KerbErr);
}

//+-------------------------------------------------------------------------
//
//  Function:   KdcVerifyPacSignature
//
//  Synopsis:   Verifies a PAC by checksumming it and comparing the result
//              with the server checksum. In addition, if the pac wasn't
//              created by another realm (server ticket info is not
//              an interdomain account) verify the KDC signature on the
//              pac.
//
//  Effects:
//
//  Arguments:  ServerInfo - Ticket info for the server, used
//                      for the initial signature
//              Pac - An unmarshalled PAC.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KdcVerifyPacSignature(
    IN PKERB_ENCRYPTION_KEY ServerKey,
    IN PKDC_TICKET_INFO ServerInfo,
    IN ULONG PacSize,
    IN PUCHAR PacData
    )
{
    NTSTATUS Status;
    KERBERR KerbErr = KDC_ERR_NONE;
    PCHECKSUM_FUNCTION Check = NULL ;
    PCHECKSUM_BUFFER CheckBuffer = NULL;
    PKERB_ENCRYPTION_KEY EncryptionKey = NULL;
    PPAC_INFO_BUFFER ServerBuffer;
    PPAC_INFO_BUFFER PrivSvrBuffer;
    PPAC_SIGNATURE_DATA ServerSignature;
    PPAC_SIGNATURE_DATA PrivSvrSignature;
    UCHAR LocalChecksum[20];
    UCHAR LocalServerChecksum[20];
    UCHAR LocalPrivSvrChecksum[20];
    PPACTYPE Pac;
    KDC_TICKET_INFO KdcTicketInfo = {0};
    BOOL PacUnmarshalled = FALSE;

    TRACE(KDC, KdcVerifyPacSignature, DEB_FUNCTION);

    Pac = (PPACTYPE) PacData;

    if (PAC_UnMarshal(Pac, PacSize) == 0)
    {
        D_DebugLog((DEB_ERROR,"Failed to unmarshal pac\n"));
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    PacUnmarshalled = TRUE;
    KerbErr = SecData.GetKrbtgtTicketInfo(&KdcTicketInfo);
    if (!KERB_SUCCESS(KerbErr))
    {
        Status = KerbMapKerbError(KerbErr);
        goto Cleanup;
    }

    //
    // Locate the two signatures, copy the checksum, and zero the value
    // so the checksum won't include the old checksums.
    //

    ServerBuffer = PAC_Find(Pac, PAC_SERVER_CHECKSUM, NULL );
    DsysAssert(ServerBuffer != NULL);
    if ((ServerBuffer == NULL) || (ServerBuffer->cbBufferSize < PAC_SIGNATURE_SIZE(0)))
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    ServerSignature = (PPAC_SIGNATURE_DATA) ServerBuffer->Data;

    RtlCopyMemory(
        LocalServerChecksum,
        ServerSignature->Signature,
        PAC_CHECKSUM_SIZE(ServerBuffer->cbBufferSize)
        );

    RtlZeroMemory(
        ServerSignature->Signature,
        PAC_CHECKSUM_SIZE(ServerBuffer->cbBufferSize)
        );

    PrivSvrBuffer = PAC_Find(Pac, PAC_PRIVSVR_CHECKSUM, NULL );
    DsysAssert(PrivSvrBuffer != NULL);
    if ((PrivSvrBuffer == NULL) || (PrivSvrBuffer->cbBufferSize < PAC_SIGNATURE_SIZE(0)))
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    PrivSvrSignature = (PPAC_SIGNATURE_DATA) PrivSvrBuffer->Data;

    RtlCopyMemory(
        LocalPrivSvrChecksum,
        PrivSvrSignature->Signature,
        PAC_CHECKSUM_SIZE(PrivSvrBuffer->cbBufferSize)
        );

    RtlZeroMemory(
        PrivSvrSignature->Signature,
        PAC_CHECKSUM_SIZE(PrivSvrBuffer->cbBufferSize)
        );

    //
    // Remarshal the pac so we can checksum it.
    //

    if (!PAC_ReMarshal(Pac, PacSize))
    {
        DsysAssert(!"PAC_Remarshal Failed");
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    PacUnmarshalled = FALSE;
    //
    // Now compute the signatures on the PAC. First we compute the checksum
    // of the validation information using the server's key.
    //

    //
    // Locate the checksum used to sign the PAC.
    //

    Status = CDLocateCheckSum(
                ServerSignature->SignatureType,
                &Check
                );

    if (!NT_SUCCESS(Status))
    {
        KerbErr = KDC_ERR_SUMTYPE_NOSUPP;
        goto Cleanup;
    }

    if (Check->CheckSumSize > sizeof(LocalChecksum)) {
        DsysAssert(Check->CheckSumSize <= sizeof(LocalChecksum));
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    //
    // if available use the Ex2 version for keyed checksums where checksum
    // must be passed in on verification
    //
    if (NULL != Check->InitializeEx2)
    {
        Status = Check->InitializeEx2(
                    ServerKey->keyvalue.value,
                    ServerKey->keyvalue.length,
                    LocalServerChecksum,
                    KERB_NON_KERB_CKSUM_SALT,
                    &CheckBuffer
                    );
    }
    else
    {
        Status = Check->InitializeEx(
                    ServerKey->keyvalue.value,
                    ServerKey->keyvalue.length,
                    KERB_NON_KERB_CKSUM_SALT,
                    &CheckBuffer
                    );
    }

    if (!NT_SUCCESS(Status))
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    Check->Sum(
        CheckBuffer,
        PacSize,
        PacData
        );
    Check->Finalize(
        CheckBuffer,
        LocalChecksum
        );
    Check->Finish(
        &CheckBuffer
        );

    if (Check->CheckSumSize != PAC_CHECKSUM_SIZE(ServerBuffer->cbBufferSize) ||
        !RtlEqualMemory(
            LocalChecksum,
            LocalServerChecksum,
            Check->CheckSumSize))
    {
        DebugLog((DEB_ERROR, "Pac was modified - server checksum doesn't match\n"));
        KerbErr = KRB_AP_ERR_MODIFIED;
        goto Cleanup;
    }

    //
    // If the service wasn't the KDC and it wasn't an interdomain account
    // verify the KDC checksum.
    //

    if ((ServerInfo->UserId == DOMAIN_USER_RID_KRBTGT) ||
        ((ServerInfo->UserAccountControl & USER_INTERDOMAIN_TRUST_ACCOUNT) != 0))
    {
        goto Cleanup;
    }

    //
    // Get the key used to sign pacs.
    //

    EncryptionKey = KerbGetKeyFromList(
                        KdcTicketInfo.Passwords,
                        (ULONG) KDC_PAC_KEYTYPE
                        );

    if (EncryptionKey == NULL)
    {
        Status = SEC_E_ETYPE_NOT_SUPP;
        goto Cleanup;
    }

    //
    // Locate the checksum used to sign the PAC.
    //

    Status = CDLocateCheckSum(
                PrivSvrSignature->SignatureType,
                &Check
                );

    if (!NT_SUCCESS(Status))
    {
        KerbErr = KDC_ERR_SUMTYPE_NOSUPP;
        goto Cleanup;
    }

    //
    // if available use the Ex2 version for keyed checksums where checksum
    // must be passed in on verification
    //

    if (NULL != Check->InitializeEx2)
    {
        Status = Check->InitializeEx2(
                    EncryptionKey->keyvalue.value,
                    EncryptionKey->keyvalue.length,
                    LocalPrivSvrChecksum,
                    KERB_NON_KERB_CKSUM_SALT,
                    &CheckBuffer
                    );
    }
    else
    {
        Status = Check->InitializeEx(
                    EncryptionKey->keyvalue.value,
                    EncryptionKey->keyvalue.length,
                    KERB_NON_KERB_CKSUM_SALT,
                    &CheckBuffer
                    );
    }

    if (!NT_SUCCESS(Status))
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    Check->Sum(
        CheckBuffer,
        Check->CheckSumSize,
        LocalServerChecksum
        );
    Check->Finalize(
        CheckBuffer,
        LocalChecksum
        );
    Check->Finish(
        &CheckBuffer
        );

    if ((Check->CheckSumSize != PAC_CHECKSUM_SIZE(PrivSvrBuffer->cbBufferSize)) ||
        !RtlEqualMemory(
            LocalChecksum,
            LocalPrivSvrChecksum,
            Check->CheckSumSize))
    {
        DebugLog((DEB_ERROR, "Pac was modified - privsvr checksum doesn't match\n"));
        KerbErr = KRB_AP_ERR_MODIFIED;
        goto Cleanup;
    }

Cleanup:

    if ( PacUnmarshalled )
    {
        if (!PAC_ReMarshal(Pac, PacSize))
        {
            DsysAssert(!"PAC_Remarshal Failed");
            KerbErr = KRB_ERR_GENERIC;
        }
    }

    if (KerbErr == KRB_AP_ERR_MODIFIED)
    {
        LPWSTR AccountName = NULL;
        AccountName = (LPWSTR) MIDL_user_allocate(ServerInfo->AccountName.Length + sizeof(WCHAR));
        //
        // if the allocation fails don't log the name (leave it NULL)
        //
        if (NULL != AccountName)
        {
            RtlCopyMemory(
                AccountName,
                ServerInfo->AccountName.Buffer,
                ServerInfo->AccountName.Length
                );
        }

        ReportServiceEvent(
            EVENTLOG_ERROR_TYPE,
            KDCEVENT_PAC_VERIFICATION_FAILURE,
            sizeof(ULONG),
            &KerbErr,
            1,
            AccountName
            );

        if (NULL != AccountName)
        {
            MIDL_user_free(AccountName);
        }
    }

    if ( ( CheckBuffer != NULL ) &&
         ( Check != NULL ) )
    {
        Check->Finish(&CheckBuffer);
    }

    FreeTicketInfo(&KdcTicketInfo);

    return(KerbErr);
}


//+---------------------------------------------------------------------------
//
//  Name:       KdcGetPacAuthData
//
//  Synopsis:   Creates a PAC for the specified client, encrypts it with the
//              server's key, and packs it into a KERB_AUTHORIZATON_DATA
//
//  Arguments:  UserInfo - Information about user
//              GroupMembership - Users group memberships
//              ServerKey - Key of server, used for signing
//              CredentialKey - if present & valid, used to encrypt supp. creds
//              AddResourceGroups - if TRUE, resources groups will be included
//              EncryptedTicket - Optional ticke to tie PAC to
//              S4UTicketInfo - used only when inserting initial S4U2self auth
//                              data into the ticket.  causes the S4U2self
//                              target to be stored inside the PAC
//              PacAuthData - Receives a KERB_AUTHORIZATION_DATA of type
//                      KERB_AUTH_DATA_PAC, containing a PAC.
//
//  Notes:      PacAuthData should be freed with KerbFreeAuthorizationData.
//
//+---------------------------------------------------------------------------

KERBERR
KdcGetPacAuthData(
    IN PUSER_INTERNAL6_INFORMATION UserInfo,
    IN PSID_AND_ATTRIBUTES_LIST GroupMembership,
    IN PKERB_ENCRYPTION_KEY ServerKey,
    IN PKERB_ENCRYPTION_KEY CredentialKey,
    IN BOOLEAN AddResourceGroups,
    IN PKERB_ENCRYPTED_TICKET EncryptedTicket,
    IN OPTIONAL PKDC_S4U_TICKET_INFO S4UClientInfo,
    OUT PKERB_AUTHORIZATION_DATA * PacAuthData,
    OUT PKERB_EXT_ERROR pExtendedError
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    PACTYPE *pNewPac = NULL;
    KERB_AUTHORIZATION_DATA AuthorizationData = {0};
    ULONG PacSize, NameType;
    PCHECKSUM_FUNCTION Check;
    NTSTATUS Status;
    UNICODE_STRING ClientName = {0};
    PKERB_INTERNAL_NAME KdcName = NULL;
    TimeStamp ClientId;

    TRACE(KDC, KdcGetPacAuthData, DEB_FUNCTION);

    Status = CDLocateCheckSum(
                (ULONG) KDC_PAC_CHECKSUM,
                &Check
                );

    if (!NT_SUCCESS(Status))
    {
        KerbErr = KDC_ERR_SUMTYPE_NOSUPP;
        FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__);
        goto Cleanup;
    }

    KerbConvertGeneralizedTimeToLargeInt(
        &ClientId,
        &EncryptedTicket->authtime,
        0                               // no usec
        );

    //
    // Put the S4U client in the pac verifier.  For S4USelf, we use
    // user@domain to keep W2K servers / kdcs from allowing xrealm tgts
    // w/ s4u pacs
    //
    if (ARGUMENT_PRESENT(S4UClientInfo))
    { 
        KerbErr = KerbConvertKdcNameToString(
                        &ClientName,
                        S4UClientInfo->PACCName,
                        (((S4UClientInfo->Flags & TI_REQUESTOR_THIS_REALM) != 0) ? NULL : &S4UClientInfo->PACCRealm )
                        );
        
    }
    else // use the ticket
    {
        KerbErr = KerbConvertPrincipalNameToString(
                            &ClientName,
                            &NameType,
                            &EncryptedTicket->client_name
                            );
    }

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    KerbErr = GetPacAndSuppCred(
                UserInfo,
                GroupMembership,
                Check->CheckSumSize,            // leave space for signature
                CredentialKey,
                &ClientId,
                &ClientName,
                &pNewPac,
                pExtendedError
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        D_DebugLog(( DEB_WARN,
            "GetPAC: Can't get PAC or supp creds: 0x%x \n", KerbErr ));
        goto Cleanup;
    }

    //
    //  The PAC is going to be double-encrypted.  This is done by having the
    //  PAC in an EncryptedData, and having that EncryptedData in a AuthData
    //  as part of an AuthDataList (along with the rest of the supp creds).
    //  Finally, the entire list is encrypted.
    //
    //      KERB_AUTHORIZATION_DATA containing {
    //              PAC
    //
    //      }
    //

    //
    // First build inner encrypted data
    //

    PacSize = PAC_GetSize( pNewPac );

    AuthorizationData.value.auth_data_type = KERB_AUTH_DATA_PAC;
    AuthorizationData.value.auth_data.length = PacSize;
    AuthorizationData.value.auth_data.value = (PUCHAR) MIDL_user_allocate(PacSize);
    if (AuthorizationData.value.auth_data.value == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    PAC_Marshal( pNewPac, PacSize, AuthorizationData.value.auth_data.value );

    //
    // Compute the signatures
    //

    KerbErr = KdcSignPac(
                ServerKey,
                AddResourceGroups,
                FALSE, // this is a TGT...
                &AuthorizationData.value.auth_data.value,
                (PULONG) &AuthorizationData.value.auth_data.length
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    //
    // Create the auth data to return
    //

    KerbErr = KdcInsertPacIntoAuthData(
                    NULL,               // no original auth data
                    NULL,               // no if-relevant auth data
                    &AuthorizationData,
                    PacAuthData
                    );

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"Failed to insert pac into new auth data: 0x%x\n",
            KerbErr));
        goto Cleanup;
    }

Cleanup:

    if (AuthorizationData.value.auth_data.value != NULL)
    {
        MIDL_user_free(AuthorizationData.value.auth_data.value);
    }

    if (pNewPac != NULL)
    {
        MIDL_user_free(pNewPac);
    }

    KerbFreeString(&ClientName);
    KerbFreeKdcName(&KdcName);
    return(KerbErr);

}


//+-------------------------------------------------------------------------
//
//  Function:   KdcGetUserPac
//
//  Synopsis:   Function for external users to get the PAC for a user
//
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

extern "C"
NTSTATUS
KdcGetUserPac(
    IN PUNICODE_STRING UserName,
    OUT PPACTYPE * Pac,
    OUT PUCHAR * SupplementalCredentials,
    OUT PULONG SupplementalCredSize,
    OUT PKERB_EXT_ERROR pExtendedError
    )
{
    KDC_TICKET_INFO TicketInfo;
    PUSER_INTERNAL6_INFORMATION UserInfo = NULL;
    SID_AND_ATTRIBUTES_LIST GroupMembership;
    NTSTATUS Status;
    KERBERR KerbErr;

    TRACE(KDC, KdcGetUserPac, DEB_FUNCTION);

    *SupplementalCredentials = NULL;
    *SupplementalCredSize = 0;

    RtlZeroMemory(
        &TicketInfo,
        sizeof(KDC_TICKET_INFO)
        );

    RtlZeroMemory(
        &GroupMembership,
        sizeof(SID_AND_ATTRIBUTES_LIST)
        );

    Status = EnterApiCall();

    if (!NT_SUCCESS(Status))
    {
        return(Status);
    }

    //
    // Get the account information
    //

    KerbErr = KdcGetTicketInfo(
                UserName,
                0,                      // no flags
                FALSE,                  // do not restrict user accounts (user2user)
                NULL,                   // no principal name
                NULL,                   // no realm
                &TicketInfo,
                pExtendedError,
                NULL,                   // no user handle
                USER_ALL_GET_PAC_AND_SUPP_CRED,
                0L,                     // no extended fields
                &UserInfo,
                &GroupMembership
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_WARN,"Failed to get ticket info for user %wZ: 0x%x\n",
                  UserName->Buffer, KerbErr));
        Status = KerbMapKerbError(KerbErr);

        goto Cleanup;
    }

    //
    // Now get the PAC and supplemental credentials
    //

    KerbErr = GetPacAndSuppCred(
                UserInfo,
                &GroupMembership,
                0,              // no signature space
                NULL,           // no credential key
                NULL,           // no client ID
                NULL,           // no client name
                Pac,
                pExtendedError
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"Failed to get PAC for user %wZ : 0x%x\n",
                  UserName->Buffer,KerbErr));

        Status = KerbMapKerbError(KerbErr);
        goto Cleanup;
    }

Cleanup:

    SamIFree_UserInternal6Information( UserInfo );
    SamIFreeSidAndAttributesList(&GroupMembership);
    FreeTicketInfo(&TicketInfo);

    LeaveApiCall();

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   KdcVerifyPac
//
//  Synopsis:   Function for kerberos to pass through a pac signature
//              to be verified.
//
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

extern "C"
NTSTATUS
KdcVerifyPac(
    IN ULONG ChecksumSize,
    IN PUCHAR Checksum,
    IN ULONG SignatureType,
    IN ULONG SignatureSize,
    IN PUCHAR Signature
    )
{
    NTSTATUS Status;
    KERBERR KerbErr;
    PCHECKSUM_FUNCTION Check;
    PCHECKSUM_BUFFER CheckBuffer = NULL;
    UCHAR LocalChecksum[20];
    PKERB_ENCRYPTION_KEY EncryptionKey = NULL;
    KDC_TICKET_INFO KdcTicketInfo = {0};

    TRACE(KDC, KdcVerifyPac, DEB_FUNCTION);

    Status = EnterApiCall();

    if (!NT_SUCCESS(Status))
    {
        return(Status);
    }

    KerbErr = SecData.GetKrbtgtTicketInfo(&KdcTicketInfo);

    if (!KERB_SUCCESS(KerbErr))
    {
        Status = KerbMapKerbError(KerbErr);
        goto Cleanup;
    }

    //
    // Get the key used to sign pacs.
    //

    EncryptionKey = KerbGetKeyFromList(
                        KdcTicketInfo.Passwords,
                        (ULONG) KDC_PAC_KEYTYPE
                        );

    if (EncryptionKey == NULL)
    {
        Status = SEC_E_ETYPE_NOT_SUPP;
        goto Cleanup;
    }

    Status = CDLocateCheckSum(
                SignatureType,
                &Check
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    if (Check->CheckSumSize > sizeof(LocalChecksum)) {
        DsysAssert(Check->CheckSumSize <= sizeof(LocalChecksum));
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // if available use the Ex2 version for keyed checksums where checksum
    // must be passed in on verification
    //

    if (NULL != Check->InitializeEx2)
    {
        Status = Check->InitializeEx2(
                    EncryptionKey->keyvalue.value,
                    EncryptionKey->keyvalue.length,
                    Signature,
                    KERB_NON_KERB_CKSUM_SALT,
                    &CheckBuffer
                    );
    }
    else
    {
        Status = Check->InitializeEx(
                    EncryptionKey->keyvalue.value,
                    EncryptionKey->keyvalue.length,
                    KERB_NON_KERB_CKSUM_SALT,
                    &CheckBuffer
                    );
    }

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;

    }

    Check->Sum(
        CheckBuffer,
        ChecksumSize,
        Checksum
        );

    Check->Finalize(
        CheckBuffer,
        LocalChecksum
        );

    Check->Finish(&CheckBuffer);

    //
    // Now compare the local checksum to the supplied checksum.
    //

    if (Check->CheckSumSize != SignatureSize)
    {
        Status = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }

    if (!RtlEqualMemory(
            LocalChecksum,
            Signature,
            Check->CheckSumSize
            ))
    {
        DebugLog((DEB_ERROR,"Checksum on the PAC does not match!\n"));
        Status = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }

Cleanup:

    if (Status == STATUS_LOGON_FAILURE)
    {
        PUNICODE_STRING OwnName = NULL;
        //
        // since this call should only be made by pass through callback
        // this signature should be our own
        //
        OwnName = SecData.KdcFullServiceDnsName();

        ReportServiceEvent(
            EVENTLOG_ERROR_TYPE,
            KDCEVENT_PAC_VERIFICATION_FAILURE,
            0,
            NULL,
            1,                              // number of strings
            OwnName->Buffer
            );
    }

    FreeTicketInfo(&KdcTicketInfo);
    LeaveApiCall();

    return(Status);
}





//+-------------------------------------------------------------------------
//
//  Function:   KdcUpdateAndValidateS4UProxyPAC
//
//  Synopsis:   Validates your target name from original pac, and updates
//              existing info.
//
//  Effects:
//
//  Arguments: 
//              CLientId - Auth time of ticket.
//              CName - Client name to put into verifier.
//              Pac   - **UNMARSHALLED** PAC, freed in this function, and 
//                      rebuilt.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KdcReplacePacVerifier(
    PTimeStamp ClientId,
    PUNICODE_STRING CName,
    IN PPACTYPE OldPac,
    OUT PPACTYPE *NewPac
    )
{


    ULONG cbBytes = 0;
    ULONG cPacBuffers = 0;
    PPAC_INFO_BUFFER Verifier = NULL;
    PPACTYPE pNewPac = NULL;
    PBYTE pDataStore;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG Index, iBuffer = 0;


    *NewPac = NULL;


    for (Index = 0; Index < OldPac->cBuffers ; Index++ )
    {
        if (OldPac->Buffers[Index].ulType != PAC_CLIENT_INFO_TYPE)
        {
            cbBytes += ROUND_UP_COUNT(OldPac->Buffers[Index].cbBufferSize,ALIGN_QUAD);
            cPacBuffers++;
        }
    }


    Status = KdcBuildPacVerifier(
                ClientId,
                CName,
                &Verifier
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "BuildPacVerifier failed\n"));
        goto Cleanup;
    }

    cPacBuffers++;
    cbBytes += ROUND_UP_COUNT(Verifier->cbBufferSize, ALIGN_QUAD);

    //
    // We need space for the PAC structure itself. Because the PAC_INFO_BUFFER
    // is defined to be an array, a sizeof(PAC) already includes the
    // size of ANYSIZE_ARRAY PAC_INFO_BUFFERs so we can subtract some bytes off.
    //

    cbBytes += sizeof(PACTYPE) +
               (cPacBuffers - ANYSIZE_ARRAY) * sizeof(PAC_INFO_BUFFER);

    cbBytes = ROUND_UP_COUNT( cbBytes, ALIGN_QUAD );

    pNewPac = (PPACTYPE) MIDL_user_allocate( cbBytes );
    if (pNewPac == NULL)
    {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }
    
    pNewPac->cBuffers = cPacBuffers;

    pDataStore = (PBYTE)&(pNewPac->Buffers[pNewPac->cBuffers]);
    pDataStore = (PBYTE) ROUND_UP_POINTER( pDataStore, ALIGN_QUAD );

    //      
    // Copy the data over
    //              

    for (Index = 0; Index < OldPac->cBuffers ; Index++ )
    {
        if (OldPac->Buffers[Index].ulType != PAC_CLIENT_INFO_TYPE)
        {
            pNewPac->Buffers[iBuffer].ulType = OldPac->Buffers[Index].ulType;
            pNewPac->Buffers[iBuffer].cbBufferSize = OldPac->Buffers[Index].cbBufferSize;
            pNewPac->Buffers[iBuffer].Data = pDataStore;

            RtlCopyMemory(
                pDataStore,
                OldPac->Buffers[Index].Data,
                OldPac->Buffers[Index].cbBufferSize
                );

            pDataStore += pNewPac->Buffers[iBuffer].cbBufferSize;
            pDataStore = (PBYTE) ROUND_UP_POINTER( pDataStore, ALIGN_QUAD );
            iBuffer ++;
        }
    }


    // 
    // Finally copy over the pac verifier.
    //
    pNewPac->Buffers[iBuffer].ulType = PAC_CLIENT_INFO_TYPE;
    pNewPac->Buffers[iBuffer].cbBufferSize = Verifier->cbBufferSize;
    pNewPac->Buffers[iBuffer].Data = pDataStore;

    RtlCopyMemory(
            pDataStore,
            Verifier->Data,
            Verifier->cbBufferSize
            ); 

    *NewPac = pNewPac;
    pNewPac = NULL;
    
    
Cleanup:

    if ( pNewPac )
    {
        MIDL_user_free( pNewPac);
    }                            


    return Status;

}




//+-------------------------------------------------------------------------
//
//  Function:   KdcUpdateAndValidateS4UProxyPAC
//
//  Synopsis:   Validates your target name from original pac, and updates
//              existing info.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

#define DEB_TEST_CODE 0xff000000
#define DEB_TEST_CODE2 0x00ff0000


KERBERR
KdcUpdateAndVerifyS4UPacVerifier(
    IN PKDC_S4U_TICKET_INFO S4UTicketInfo,
    IN OUT PUCHAR *PacData,
    IN OUT PULONG PacSize
    )
{

    PPAC_INFO_BUFFER        Verifier = NULL;
    PPACTYPE                OldPac;
    ULONG                   OldPacSize;
    PPACTYPE                NewPac = NULL;
    NTSTATUS                Status;
    KERBERR                 KerbErr = KDC_ERR_NONE;

    PPAC_CLIENT_INFO    ClientInfo = NULL;
    TimeStamp           ClientId;
    
    
    
    UNICODE_STRING                  VerifierNames = {0};
    UNICODE_STRING                  VerifierCName = {0};
    UNICODE_STRING                  PreauthCName = {0};
    UNICODE_STRING                  VerifierCRealm = {0};
    PWSTR                           Realm = NULL;
    PWSTR                           CName = NULL;
    PPACTYPE                        RemarshalPac = NULL;
    ULONG                           RemarshalPacSize = 0;

    
    LONG i;

    OldPac = (PPACTYPE) *PacData;
    OldPacSize = *PacSize;
    
    if (PAC_UnMarshal(OldPac, OldPacSize) == 0)
    {
        D_DebugLog((DEB_ERROR,"Failed to unmarshal pac\n"));
        KerbErr = KDC_ERR_POLICY;
        goto Cleanup;
    }
    
    //
    // Must remember to remarshal the PAC prior to returning
    //
    
    RemarshalPac = OldPac;
    RemarshalPacSize = OldPacSize;

    Verifier = PAC_Find(
                    OldPac,
                    PAC_CLIENT_INFO_TYPE,
                    NULL
                    );

    if ( Verifier == NULL )
    {
        DebugLog((DEB_ERROR, "Missing PAC verifier in S4U Tickets\n"));
        DsysAssert(FALSE);
        KerbErr = KDC_ERR_POLICY;
        goto Cleanup;
    }   

    if ( Verifier->cbBufferSize < sizeof(PAC_CLIENT_INFO) )
    {
        D_DebugLog((DEB_ERROR, "Clientinfo is too small: %d instead of %d\n", Verifier->cbBufferSize, sizeof(PAC_CLIENT_INFO)));
        KerbErr = KDC_ERR_POLICY;
        goto Cleanup;
    } 

    ClientInfo = (PPAC_CLIENT_INFO) Verifier->Data;
    if ((ClientInfo->NameLength - ANYSIZE_ARRAY * sizeof(WCHAR) + sizeof(PPAC_CLIENT_INFO))  > Verifier->cbBufferSize)
    {
        KerbErr = KDC_ERR_POLICY;
        goto Cleanup;
    }


    KerbConvertGeneralizedTimeToLargeInt(
        &ClientId,
        &S4UTicketInfo->EvidenceTicket->authtime,
        0                           // no usec
        ); 

    if (!RtlEqualMemory(
            &ClientId,
            &ClientInfo->ClientId,
            sizeof(TimeStamp)
            ))
    {
        D_DebugLog((DEB_ERROR, "Client IDs don't match.\n"));
        KerbErr = KDC_ERR_POLICY;
        goto Cleanup;
    }


    //                                              
    // Check the name now - for s4uself requests, the name is going
    // to be cname@crealm.  This was inserted by the KDC of crealm during
    // the initial processing of the pa-for-user.
    //
    // Now, we have to substite in the "w2k" version of the pac verifier,
    // as we're granting a service ticket to a s4uself request from our realm.
    // So, there are a couple of checks to be done here:
    //
    //
    // 1. Does the PA-FOR-USER cname match that in the verifier?
    // 2. Does the PA-FOR-USER crealm match that in the verifier?
    // 3. Does the validation info (PAC) cname match that in the verifier?
    // 
    // If so, add in a W2K pac verfier.
    //                                                      
    VerifierNames.Length = ClientInfo->NameLength;
    VerifierNames.MaximumLength = ClientInfo->NameLength + sizeof(WCHAR);

    
    
    SafeAllocaAllocate( VerifierNames.Buffer, VerifierNames.MaximumLength);
    if ( VerifierNames.Buffer == NULL )
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }         

    RtlCopyMemory(
            VerifierNames.Buffer,
            ClientInfo->Name,
            VerifierNames.Length
            );


    VerifierNames.Buffer[(VerifierNames.Length / sizeof(WCHAR))] = L'\0';

    //
    // Find the @ sign, and split.  Search from the end of the string.
    //
    i = VerifierNames.Length / sizeof(WCHAR); 

    while (i > 0)
    {
        if (VerifierNames.Buffer[i] == L'@')
        {  
            VerifierNames.Buffer[i] = L'\0';
            
            if ( i < (LONG) (VerifierNames.Length / sizeof(WCHAR)) )
            {
                Realm = &VerifierNames.Buffer[i + 1];
                CName = VerifierNames.Buffer;
                break;
            }
        }             

        i--;
    }
   
    if ( Realm == NULL )
    {
        DebugLog((DEB_ERROR, "S4U Pac verifier missing @ sign\n"));
        DsysAssert(FALSE);
        KerbErr = KDC_ERR_POLICY;
        goto Cleanup;
    }




    RtlInitUnicodeString(
            &VerifierCRealm,
            Realm
            );

    RtlInitUnicodeString(
            &VerifierCName,
            CName
            );

    if (!RtlEqualUnicodeString(
                    &VerifierCRealm,
                    &S4UTicketInfo->PACCRealm,
                    TRUE
                    ))
    {
        DebugLog((DEB_ERROR, "pa-for-user != pac verfier realm\n"));
        DsysAssert(FALSE);
        KerbErr = KDC_ERR_POLICY;
        goto Cleanup;            
    }


    KerbErr = KerbConvertKdcNameToString(
                &PreauthCName,        
                S4UTicketInfo->PACCName,
                NULL
                );

    if (!KERB_SUCCESS( KerbErr ))
    {
        goto Cleanup;
    }


    if (!RtlEqualUnicodeString(
                    &PreauthCName,
                    &VerifierCName,
                    TRUE
                    ))
    {
        DebugLog((DEB_ERROR, "pa-for-user != pac verifier cname\n"));
        DsysAssert(FALSE);
        KerbErr = KDC_ERR_POLICY;
        goto Cleanup;            
    }


    //
    // Now check the validation information.  Fester - netbios and dns names preclude this from
    // working...
    //
    /*LogonInfo = PAC_Find(
                OldPac,
                PAC_LOGON_INFO,
                NULL
                );

    if ( LogonInfo == NULL )
    {
        KerbErr = KRB_ERR_GENERIC;
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }
    
    Status = PAC_UnmarshallValidationInfo(
                 &LocalValidationInfo,
                 LogonInfo->Data,
                 LogonInfo->cbBufferSize
                 );
    
    if ( !NT_SUCCESS( Status ))
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    if (!RtlEqualUnicodeString(
                &LocalValidationInfo->EffectiveName,
                &VerifierCName,
                TRUE
                ))
    {
        DebugLog((DEB_ERROR, "pa-for-user != logon info cname\n"));
        DsysAssert(FALSE);
        KerbErr = KDC_ERR_POLICY;
        goto Cleanup;  
    }

    

    //
    // Fester - how do we use the Netbios domain name in Validation info
    // to validate S4U Pac verifier?
    // */



    //
    // Cool - everything looks good.  Now remove the S4U pac verifier, and
    // add in the W2K style verfier.
    //
    Status = KdcReplacePacVerifier(
                    &ClientId,
                    &VerifierCName,
                    OldPac,
                    &NewPac
                    );

    if (!KERB_SUCCESS( KerbErr ))
    {
        DebugLog((DEB_ERROR, "KdcAddPacVerifier failed\n"));
        DsysAssert(FALSE);
        goto Cleanup;
    }

    MIDL_user_free( OldPac );

    RemarshalPacSize = PAC_GetSize(NewPac);
    RemarshalPac = NewPac;
    NewPac = NULL;
    

Cleanup:

    if ( RemarshalPac != NULL )
    {
        if (!PAC_ReMarshal(RemarshalPac, RemarshalPacSize))
        {
            DsysAssert(!"PAC_Remarshal Failed");
            KerbErr = KRB_ERR_GENERIC;
        }    

        *PacData = (PBYTE) RemarshalPac;
        *PacSize = RemarshalPacSize;
    }

    SafeAllocaFree( VerifierNames.Buffer );
    
    if (NewPac != NULL)
    {
        MIDL_user_free(NewPac);
    }   

    KerbFreeString(&PreauthCName);

    return KerbErr;


}




//+-------------------------------------------------------------------------
//
//  Function:   KdcUpdateAndValidateS4UProxyPAC
//
//  Synopsis:   Validates your target name from original pac, and updates
//              existing info.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
KERBERR
KdcUpdateAndValidateS4UProxyPAC(
    IN PKDC_S4U_TICKET_INFO S4UTicketInfo,
    IN OUT PUCHAR *PacData,
    IN OUT PULONG PacSize,
    OUT OPTIONAL PS4U_DELEGATION_INFO* S4UDelegationInfo
    )
{
    PPAC_INFO_BUFFER        MarshalledDelegationInfo;
    PS4U_DELEGATION_INFO    DelegationInfo = NULL;
    S4U_DELEGATION_INFO     NewDelegInfo = {0};
    BYTE*                   FinalDelegInfoMarshalled = NULL;
    ULONG                   FinalDelegInfoMarshalledSize = 0;
    PPACTYPE                OldPac;
    ULONG                   OldPacSize;
    PPACTYPE                NewPac = NULL;
    ULONG                   NewPacSize = NULL;
    PUNICODE_STRING         TransittedService = NULL;
    UNICODE_STRING          tmpstring = {0};
    PUNICODE_STRING         NewTargetName = NULL;
    NTSTATUS                Status;
    KERBERR                 KerbErr = KDC_ERR_NONE;

    OldPac = (PPACTYPE) *PacData;
    OldPacSize = *PacSize;

    if (PAC_UnMarshal(OldPac, OldPacSize) == 0)
    {
        D_DebugLog((DEB_ERROR,"Failed to unmarshal pac\n"));
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    MarshalledDelegationInfo = PAC_Find(
                                   OldPac,
                                   PAC_DELEGATION_INFO,
                                   NULL
                                   );

    if ( MarshalledDelegationInfo == NULL )
    {
        //
        // If this is using S4U, and we don't have delegation info, bomb out
        // here - someone's ripped out the delegation info while we were transiting.
        //

        if (( S4UTicketInfo->Flags & TI_PRXY_REQUESTOR_THIS_REALM) == 0 )
        {
            DebugLog((DEB_ERROR, "Missing delegation info while transitting %p\n", S4UTicketInfo));
            DsysAssert(FALSE);
            KerbErr = KDC_ERR_PATH_NOT_ACCEPTED;
            goto Cleanup;
        }  
        
        //
        // Time to create one.
        //

        if (!NT_SUCCESS(KerbDuplicateString(
                        &NewDelegInfo.S4U2proxyTarget,
                        &S4UTicketInfo->TargetName
                        )))
        {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }

        DelegationInfo = &NewDelegInfo;

        D_DebugLog((DEB_T_PAC, "KdcUpdateAndValidateS4UProxyPAC create new S4uDelegateInfo: target %wZ\n", &NewDelegInfo.S4U2proxyTarget)); 
    }
    else
    {
        if (!NT_SUCCESS( PAC_UnmarshallS4UDelegationInfo(
                            &DelegationInfo,
                            MarshalledDelegationInfo->Data,
                            MarshalledDelegationInfo->cbBufferSize
                            )))
        {
            D_DebugLog((DEB_ERROR, "Failed to unmarshall S4U delgation info\n"));
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }

        //
        // If the target's in our realm, we need to verify that the target name
        // in the PAC == the target name being requested.
        //
        // However, this only applies to validating the PAC in xrealm TGTs.
        // If the requestor is in our realm, we need to create a targetname entry.
        //

        if (( S4UTicketInfo->Flags & TI_PRXY_REQUESTOR_THIS_REALM ) != 0 )
        {
            NewTargetName = &S4UTicketInfo->TargetName;
        }
        else if (( S4UTicketInfo->Flags & TI_TARGET_OUR_REALM ) != 0 )
        {
            if (!RtlEqualUnicodeString(
                        &S4UTicketInfo->TargetName,
                        &DelegationInfo->S4U2proxyTarget,
                        TRUE
                        ))
            {
                D_DebugLog((DEB_ERROR, "Wrong S4UProxytarget %wZ %wZ\n", &S4UTicketInfo->TargetName, &DelegationInfo->S4U2proxyTarget));
                KerbErr = KDC_ERR_S_PRINCIPAL_UNKNOWN;
                goto Cleanup;
            }
        }

        D_DebugLog((DEB_T_PAC, "KdcUpdateAndValidateS4UProxyPAC add S4uDelegateInfo: target %wZ, flags %#x\n", NewTargetName, S4UTicketInfo->Flags)); 
    }

    //
    // We're in the S4U requestor's realm - add in requestor's name into
    // PAC.
    //

    if (( S4UTicketInfo->Flags & TI_PRXY_REQUESTOR_THIS_REALM) != 0 )
    {
        KerbErr = KerbConvertKdcNameToString(
                    &tmpstring,
                    S4UTicketInfo->RequestorServiceName,
                    ((S4UTicketInfo->RequestorServiceName->NameType == KRB_NT_ENTERPRISE_PRINCIPAL) && (S4UTicketInfo->RequestorServiceName->NameCount == 1)) 
                        ? NULL : &S4UTicketInfo->RequestorServiceRealm
                    );

        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }

        TransittedService = &tmpstring;

        D_DebugLog((DEB_T_PAC, "KdcUpdateAndValidateS4UProxyPAC add ts %wZ\n", TransittedService));   
    }

#if DBG

    if (DelegationInfo) 
    {
        D_DebugLog((DEB_T_PAC, "KdcUpdateAndValidateS4UProxyPAC target %wZ\n", &DelegationInfo->S4U2proxyTarget)); 
        
        for ( ULONG i = 0; i < DelegationInfo->TransitedListSize; i++ )
        {        
            D_DebugLog((DEB_T_PAC, "KdcUpdateAndValidateS4UProxyPAC existing ts %#x: %wZ\n", i, &DelegationInfo->S4UTransitedServices[i]));   
        }                
    }

#endif // DBG

    Status = PAC_InitAndUpdateTransitedService(
                DelegationInfo,
                TransittedService,
                NewTargetName,
                OldPac,
                &NewPac,
                &FinalDelegInfoMarshalledSize,
                &FinalDelegInfoMarshalled
                );

    if (!NT_SUCCESS( Status ))
    {
        KerbErr = KRB_ERR_GENERIC;
        D_DebugLog((DEB_ERROR, "PacInit&UPdatedTransitedService fail - %x\n", Status));
        goto Cleanup;
    }

    NewPacSize = PAC_GetSize(NewPac);

    if (!PAC_ReMarshal(NewPac, NewPacSize))
    {
        DsysAssert(!"PAC_Remarshal Failed");
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    if (S4UDelegationInfo)
    {
        Status = UnmarshalS4UDelegationInformation(
            FinalDelegInfoMarshalledSize,
            FinalDelegInfoMarshalled,
            S4UDelegationInfo
            );

        if (!NT_SUCCESS(Status))
        {
            KerbErr = KRB_ERR_GENERIC;
            DebugLog((DEB_ERROR, "KdcUpdateAndValidateS4UProxyPAC failed to unmarshall S4U delgation info %#x\n", Status));
            goto Cleanup;
        }
    }

    if (*PacData != (PBYTE)NewPac)
    {
        MIDL_user_free(*PacData);
        *PacData = (PBYTE) NewPac;
        NewPac = NULL;
        *PacSize = NewPacSize;
    }

Cleanup:

    KerbFreeString(&NewDelegInfo.S4U2proxyTarget);

    if (( DelegationInfo != NULL ) &&
        ( DelegationInfo != &NewDelegInfo ))
    {
        MIDL_user_free( DelegationInfo );
    }

    if (FinalDelegInfoMarshalled != NULL)
    {
        MIDL_user_free(FinalDelegInfoMarshalled);
    }

    KerbFreeString( &tmpstring );

    if (NewPac != NULL)
    {
        MIDL_user_free(NewPac);
    }

    return (KerbErr);
}

//+-------------------------------------------------------------------------
//
//  Function:   KdcFilterSids
//
//  Synopsis:   Function that just call LsaIFilterSids.  Pulled into this function
//              for more widespread use than KdcCheckPacForSidFiltering.
//
//  Effects:
//
//  Arguments:  ServerInfo      structure containing attributes of the trust
//              ValidationInfo  authorization information to filter
//
//  Requires:
//
//  Returns:    See LsaIFilterSids
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KdcFilterSids(
    IN PKDC_TICKET_INFO ServerInfo,
    IN PNETLOGON_VALIDATION_SAM_INFO3 ValidationInfo
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PUNICODE_STRING TrustedForest = NULL;

    if ((ServerInfo->TrustAttributes & TRUST_ATTRIBUTE_FOREST_TRANSITIVE) != 0)
    {
        TrustedForest = &(ServerInfo->TrustedForest);
        D_DebugLog((DEB_TRACE, "Filtering Sids for forest %wZ\n", TrustedForest));
    }

    if ( ServerInfo->TrustSid != NULL ||
         ServerInfo->TrustType == TRUST_TYPE_MIT ||
         ( ServerInfo->TrustAttributes & TRUST_ATTRIBUTE_CROSS_ORGANIZATION ) != 0 )
    {
        Status = LsaIFilterSids(
                     TrustedForest,           // Pass domain name here
                     TRUST_DIRECTION_OUTBOUND,
                     ServerInfo->TrustType,
                     ServerInfo->TrustAttributes,
                     ServerInfo->TrustSid,
                     NetlogonValidationSamInfo2,
                     ValidationInfo,
                     NULL,
                     NULL,
                     NULL
                     );

        if (!NT_SUCCESS(Status))
        {
            //
            // Create an audit log if it looks like the SID has been tampered with
            //

            if ((STATUS_DOMAIN_TRUST_INCONSISTENT == Status) &&
                SecData.AuditKdcEvent(KDC_AUDIT_TGS_FAILURE))
            {
                DWORD Dummy = 0;

                KdcLsaIAuditTgsEvent(
                    SE_AUDITID_TGS_TICKET_REQUEST,
                    &ValidationInfo->EffectiveName,
                    &ValidationInfo->LogonDomainName,
                    NULL,
                    &ServerInfo->AccountName,
                    NULL,
                    &Dummy,
                    (PULONG) &Status,
                    NULL,
                    NULL,                               // no preauth type
                    GET_CLIENT_ADDRESS(NULL),
                    NULL,                                // no logon guid
                    NULL
                    );
            }

            DebugLog((DEB_ERROR,"Failed to filter SIDS (LsaIFilterSids): 0x%x\n",Status));
        }
    }

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   KdcFilterNamespace
//
//  Synopsis:   Function that just call lsaifiltersids.  Pulled into this function
//              for more widespread use than KdcCheckPacForSidFiltering.
//
//  Effects:
//
//  Arguments:  ServerInfo      structure containing attributes of the trust
//              ClientRealm     namespace to filter
//
//  Requires:
//
//  Returns:    KDC_ERR_NONE    namespace is good to go
//              KDC_ERR_POLICY  filtering policy rejects this namespace
//              KDC_ERR_GENERIC unexpected error (out of memory, etc)
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KdcFilterNamespace(
    IN PKDC_TICKET_INFO ServerInfo,
    IN KERB_REALM ClientRealm,
    OUT PKERB_EXT_ERROR pExtendedError
    )
{
    NTSTATUS Status;
    KERBERR KerbErr;
    UNICODE_STRING ClientRealmU = {0};

    if ( ServerInfo == NULL ||
         ServerInfo->TrustType == 0 ||
         ( ServerInfo->TrustSid == NULL && ServerInfo->TrustType != TRUST_TYPE_MIT ))
    {
        //
        // Not going over a trust, simply succeed
        //

        return KDC_ERR_NONE;
    }

    //
    // We can only digest Unicode strings below
    //

    KerbErr = KerbConvertRealmToUnicodeString(
                  &ClientRealmU,
                  &ClientRealm
                  );

    if ( !KERB_SUCCESS( KerbErr ))
    {
        return KerbErr;
    }

    //
    // Let LSA policy logic decide what's kosher
    //

    Status = LsaIFilterNamespace(
                 &ServerInfo->AccountName, // misnomer - contains DNS domain name
                 TRUST_DIRECTION_OUTBOUND,
                 ServerInfo->TrustType,
                 ServerInfo->TrustAttributes,
                 &ClientRealmU
                 );

    KerbFreeString( &ClientRealmU );

    switch ( Status )
    {
    case STATUS_SUCCESS:
        return KDC_ERR_NONE;

    case STATUS_DOMAIN_TRUST_INCONSISTENT:
        FILL_EXT_ERROR_EX2( pExtendedError, STATUS_DOMAIN_TRUST_INCONSISTENT, FILENO, __LINE__ );
        return KDC_ERR_POLICY;

    case STATUS_INSUFFICIENT_RESOURCES:           
    default:
        FILL_EXT_ERROR( pExtendedError, Status, FILENO, __LINE__ );
        return KRB_ERR_GENERIC;
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   KdcCheckPacForSidFiltering
//
//  Synopsis:   If the server ticket info has a TDOSid then the function
//              makes a check to make sure the SID from the TDO matches
//              the client's home domain SID.  A call to LsaIFilterSids
//              is made to do the check.  If this function fails with
//              STATUS_TRUST_FAILURE then an audit log is generated.
//              Otherwise the function succeeds but SIDs are filtered
//              from the PAC.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KdcCheckPacForSidFiltering(
    IN PKDC_TICKET_INFO ServerInfo,
    IN OUT PUCHAR *PacData,
    IN OUT PULONG PacSize
    )
{
    NTSTATUS Status;
    KERBERR KerbErr = KDC_ERR_NONE;
    PPAC_INFO_BUFFER LogonInfo;
    PPACTYPE OldPac;
    ULONG OldPacSize;
    PPACTYPE NewPac = NULL;
    PNETLOGON_VALIDATION_SAM_INFO3 ValidationInfo = NULL;
    SAMPR_PSID_ARRAY ZeroResourceGroups;
    ULONG OldExtraSidCount;
    PNETLOGON_SID_AND_ATTRIBUTES SavedExtraSids = NULL;
    PPACTYPE RemarshalPac = NULL;
    ULONG RemarshalPacSize = 0;

    OldPac = (PPACTYPE) *PacData;
    OldPacSize = *PacSize;
    if (PAC_UnMarshal(OldPac, OldPacSize) == 0)
    {
        D_DebugLog((DEB_ERROR,"Failed to unmarshal pac\n"));
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    //
    // Must remember to remarshal the PAC prior to returning
    //

    RemarshalPac = OldPac;
    RemarshalPacSize = OldPacSize;

    RtlZeroMemory(
        &ZeroResourceGroups,
        sizeof(ZeroResourceGroups));  // allows us to use PAC_InitAndUpdateGroups to remarshal the PAC

    //
    // First, find the logon information
    //

    LogonInfo = PAC_Find(
                    OldPac,
                    PAC_LOGON_INFO,
                    NULL
                    );

    if (LogonInfo == NULL)
    {
        D_DebugLog((DEB_WARN,"No logon info for PAC - not making SID filtering check\n"));
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    //
    // Now unmarshall the validation information and build a list of sids
    //

    if (!NT_SUCCESS(PAC_UnmarshallValidationInfo(
                        &ValidationInfo,
                        LogonInfo->Data,
                        LogonInfo->cbBufferSize)))
    {
        D_DebugLog((DEB_ERROR,"Failed to unmarshall validation info!\n"));
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    //
    // Save the old extra SID count (so that if KdcFilterSids compresses
    // the SID array, we can avoid allocating memory for the other-org SID later)
    //

    OldExtraSidCount = ValidationInfo->SidCount;

    //
    // Call lsaifiltersids().
    //

    Status = KdcFilterSids(
                 ServerInfo,
                 ValidationInfo
                 );

    if (!NT_SUCCESS(Status))
    {
        KerbErr = KDC_ERR_POLICY;
        goto Cleanup;
    }

    //
    // If we're crossing an organization boundary, add the "other organization"
    // SID to the PAC.
    //
    // NOTE: for efficiency reasons, no check is made for whether the
    //       SID is already in the PAC.  The hope is that adding a duplicate
    //       SID will not cause problems.
    //

    if ( ServerInfo->TrustAttributes & TRUST_ATTRIBUTE_CROSS_ORGANIZATION )
    {
        if ( ValidationInfo->SidCount >= OldExtraSidCount )
        {
            SavedExtraSids = ValidationInfo->ExtraSids;

            SafeAllocaAllocate(
                ValidationInfo->ExtraSids,
                sizeof( SID_AND_ATTRIBUTES ) * ( ValidationInfo->SidCount + 1 )
                );

            if ( ValidationInfo->ExtraSids == NULL )
            {
                ValidationInfo->ExtraSids = SavedExtraSids;
                SavedExtraSids = NULL;
                KerbErr = KRB_ERR_GENERIC;
                goto Cleanup;
            }

            RtlCopyMemory(
                ValidationInfo->ExtraSids,
                SavedExtraSids,
                sizeof( SID_AND_ATTRIBUTES ) * ValidationInfo->SidCount
                );
        }

        ValidationInfo->ExtraSids[ValidationInfo->SidCount].Sid =
            GlobalOtherOrganizationSid;

        ValidationInfo->ExtraSids[ValidationInfo->SidCount].Attributes =
            SE_GROUP_MANDATORY |
            SE_GROUP_ENABLED_BY_DEFAULT |
            SE_GROUP_ENABLED;

        ValidationInfo->SidCount += 1;
    }

    //
    // Now build a new pac
    //

    Status = PAC_InitAndUpdateGroups(
                ValidationInfo,
                &ZeroResourceGroups,
                OldPac,
                &NewPac
                );

    if (!NT_SUCCESS(Status))
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    RemarshalPacSize = PAC_GetSize(NewPac);
    RemarshalPac = NewPac;

Cleanup:

    if ( RemarshalPac != NULL )
    {
        if (!PAC_ReMarshal(RemarshalPac, RemarshalPacSize))
        {
            DsysAssert(!"PAC_Remarshal Failed");
            KerbErr = KRB_ERR_GENERIC;
        }
        else if ( NewPac != NULL &&
                  *PacData != (PBYTE)NewPac )
        {
            MIDL_user_free(*PacData);
            *PacData = (PBYTE) NewPac;
            NewPac = NULL;
            *PacSize = RemarshalPacSize;
        }
    }

    if (NewPac != NULL)
    {
        MIDL_user_free(NewPac);
    }

    if ( SavedExtraSids != NULL )
    {
        SafeAllocaFree( ValidationInfo->ExtraSids );
        ValidationInfo->ExtraSids = SavedExtraSids;
        ValidationInfo->SidCount -= 1;
    }

    if (ValidationInfo != NULL)
    {
        MIDL_user_free(ValidationInfo);
    }

    return(KerbErr);
}


#ifdef ROGUE_DC

#pragma message( "COMPILING A ROGUE DC!!!" )
#pragma message( "MUST NOT SHIP THIS BUILD!!!" )

extern HKEY hKdcRogueKey;

KERBERR
KdcInstrumentRoguePac(
    IN OUT PKERB_AUTHORIZATION_DATA PacAuthData
    )
{
    KERBERR KerbErr;
    NTSTATUS Status;
    PNETLOGON_VALIDATION_SAM_INFO3 OldValidationInfo = NULL;
    NETLOGON_VALIDATION_SAM_INFO3 NewValidationInfo = {0};
    SAMPR_PSID_ARRAY ZeroResourceGroups = {0};
    PPACTYPE NewPac = NULL;
    ULONG NewPacSize;
    PPAC_INFO_BUFFER LogonInfo;

    PSID LogonDomainId = NULL;
    PSID ResourceGroupDomainSid = NULL;
    PGROUP_MEMBERSHIP GroupIds = NULL;
    PGROUP_MEMBERSHIP ResourceGroupIds = NULL;
    PNETLOGON_SID_AND_ATTRIBUTES ExtraSids = NULL;
    BYTE FullUserSidBuffer[MAX_SID_LEN];
    SID * FullUserSid = ( SID * )FullUserSidBuffer;
    CHAR * FullUserSidText = NULL;

    DWORD dwType;
    DWORD cbData = 0;
    PCHAR Buffer;
    PCHAR Value = NULL;

    BOOLEAN PacChanged = FALSE;

    //
    // Optimization: no "rogue" key in registry - nothing for us to do
    //

    if ( hKdcRogueKey == NULL )
    {
        return STATUS_SUCCESS;
    }

    //
    // Unmarshall the old PAC
    //

    if ( PAC_UnMarshal(
             (PPACTYPE)PacAuthData->value.auth_data.value,
             PacAuthData->value.auth_data.length) == 0 )
    {
        DebugLog((DEB_ERROR, "ROGUE: Unable to unmarshal the PAC\n"));

        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    //
    // First, find the logon information
    //

    LogonInfo = PAC_Find(
                    (PPACTYPE)PacAuthData->value.auth_data.value,
                    PAC_LOGON_INFO,
                    NULL
                    );

    if ( LogonInfo == NULL )
    {
        DebugLog((DEB_ERROR, "ROGUE: No logon info on PAC - not performing substitution\n"));
        KerbErr = KDC_ERR_NONE;
        goto Error;
    }

    //
    // Now unmarshall the validation information and build a list of sids
    //

    if ( !NT_SUCCESS(PAC_UnmarshallValidationInfo(
                         &OldValidationInfo,
                         LogonInfo->Data,
                         LogonInfo->cbBufferSize )))
    {
        DebugLog((DEB_ERROR, "ROGUE: Unable to unmarshal validation info\n"));
        KerbErr = KRB_ERR_GENERIC;
        goto Error;
    }

    //
    // Construct the text form of the full user's SID (logon domain ID + user ID)
    //

    DsysAssert( sizeof( FullUserSidBuffer ) >= MAX_SID_LEN );

    RtlCopySid(
        sizeof( FullUserSidBuffer ),
        FullUserSid,
        OldValidationInfo->LogonDomainId
        );

    FullUserSid->SubAuthority[FullUserSid->SubAuthorityCount] = OldValidationInfo->UserId;
    FullUserSid->SubAuthorityCount += 1;

    if ( FALSE == ConvertSidToStringSidA(
                      FullUserSid,
                      &FullUserSidText ))
    {
        DebugLog((DEB_ERROR, "ROGUE: Unable to convert user's SID\n"));
        KerbErr = KRB_ERR_GENERIC;
        goto Error;
    }

    //
    // Now look in the registry for the SID matching the validation info
    //

    if ( ERROR_SUCCESS != RegQueryValueExA(
                              hKdcRogueKey,
                              FullUserSidText,
                              NULL,
                              &dwType,
                              NULL,
                              &cbData ) ||
         dwType != REG_MULTI_SZ ||
         cbData <= 1 )
    {
        DebugLog((DEB_ERROR, "ROGUE: No substitution info available for %s\n", FullUserSidText));
        KerbErr = KDC_ERR_NONE;
        goto Error;
    }

    SafeAllocaAllocate( Value, cbData );

    if ( Value == NULL )
    {
        DebugLog((DEB_ERROR, "ROGUE: Out of memory allocating substitution buffer\n", FullUserSidText));
        KerbErr = KRB_ERR_GENERIC;
        goto Error;
    }

    if ( ERROR_SUCCESS != RegQueryValueExA(
                              hKdcRogueKey,
                              FullUserSidText,
                              NULL,
                              &dwType,
                              (PBYTE)Value,
                              &cbData ) ||
         dwType != REG_MULTI_SZ ||
         cbData <= 1 )
    {
        DebugLog((DEB_ERROR, "ROGUE: Error reading from registry\n"));
        KerbErr = KRB_ERR_GENERIC;
        goto Error;
    }

    DebugLog((DEB_ERROR, "ROGUE: Substituting the PAC for %s\n", FullUserSidText));

    if ( _stricmp( Value, "xPAC" ) == 0 )
    {
        //
        // This means that the logon info should be stripped from the PAC
        //

        Status = PAC_RemoveSection(
                     (PPACTYPE)PacAuthData->value.auth_data.value,
                     PAC_LOGON_INFO,
                     &NewPac
                     );

        if ( NT_SUCCESS( Status ))
        {
            NewPacSize = PAC_GetSize( NewPac );

            if (!PAC_ReMarshal(NewPac, NewPacSize))
            {
                DsysAssert(!"PAC_Remarshal Failed");
                KerbErr = KRB_ERR_GENERIC;
                goto Error;
            }

            MIDL_user_free( PacAuthData->value.auth_data.value );
            PacAuthData->value.auth_data.value = (PBYTE) NewPac;
            NewPac = NULL;
            PacAuthData->value.auth_data.length = NewPacSize;
        }
        else
        {
            DebugLog((DEB_ERROR, "ROGUE: Unable to strip PAC_LOGON_INFO\n"));
        }

        KerbErr = KDC_ERR_NONE;

        goto Cleanup;
    }

    Buffer = Value;

    //
    // New validation info will be overloaded with stuff from the file
    //

    NewValidationInfo = *OldValidationInfo;

    //
    // Read the input file one line at a time
    //

    while ( *Buffer != '\0' )
    {
        switch( Buffer[0] )
        {
        case 'l':
        case 'L': // logon domain ID

            if ( LogonDomainId != NULL )
            {
                DebugLog((DEB_ERROR, "ROGUE: Logon domain ID specified more than once - only first one kept\n"));
                break;
            }

            DebugLog((DEB_ERROR, "ROGUE: Substituting logon domain ID by %s\n", &Buffer[1]));

            if ( FALSE == ConvertStringSidToSidA(
                              &Buffer[1],
                              &LogonDomainId ))
            {
                DebugLog((DEB_ERROR, "ROGUE: Unable to convert SID\n"));
                KerbErr = KRB_ERR_GENERIC;
                goto Error;
            }

            if ( LogonDomainId == NULL )
            {
                DebugLog((DEB_ERROR, "ROGUE: Out of memory allocating LogonDomainId\n"));
                KerbErr = KRB_ERR_GENERIC;
                goto Error;
            }

            NewValidationInfo.LogonDomainId = LogonDomainId;
            LogonDomainId = NULL;
            PacChanged = TRUE;

            break;

        case 'd':
        case 'D': // resource group domain SID

            if ( ResourceGroupDomainSid != NULL )
            {
                DebugLog((DEB_ERROR, "ROGUE: Resource group domain SID specified more than once - only first one kept\n"));
                break;
            }

            DebugLog((DEB_ERROR, "ROGUE: Substituting resource group domain SID by %s\n", &Buffer[1]));

            if ( FALSE == ConvertStringSidToSidA(
                              &Buffer[1],
                              &ResourceGroupDomainSid ))
            {
                DebugLog((DEB_ERROR, "ROGUE: Unable to convert SID\n"));
                KerbErr = KRB_ERR_GENERIC;
                goto Error;
            }

            if ( ResourceGroupDomainSid == NULL )
            {
                DebugLog((DEB_ERROR, "ROGUE: Out of memory allocating ResourceGroupDomainSid\n"));
                KerbErr = KRB_ERR_GENERIC;
                goto Error;
            }

            NewValidationInfo.ResourceGroupDomainSid = ResourceGroupDomainSid;
            ResourceGroupDomainSid = NULL;
            PacChanged = TRUE;

            break;

        case 'p':
        case 'P': // primary group ID

            DebugLog((DEB_ERROR, "ROGUE: Substituting primary group ID by %s\n", &Buffer[1]));

            NewValidationInfo.PrimaryGroupId = atoi(&Buffer[1]);
            PacChanged = TRUE;

            break;

        case 'u':
        case 'U': // User ID

            DebugLog((DEB_ERROR, "ROGUE: Substituting user ID by %s\n", &Buffer[1]));

            NewValidationInfo.UserId = atoi(&Buffer[1]);
            PacChanged = TRUE;

            break;

        case 'e':
        case 'E': // Extra SID

            DebugLog((DEB_ERROR, "ROGUE: Adding an ExtraSid: %s\n", &Buffer[1]));

            if ( ExtraSids == NULL )
            {
                NewValidationInfo.ExtraSids = NULL;
                NewValidationInfo.SidCount = 0;

                ExtraSids = ( PNETLOGON_SID_AND_ATTRIBUTES )HeapAlloc(
                                GetProcessHeap(),
                                0,
                                sizeof( NETLOGON_SID_AND_ATTRIBUTES )
                                );
            }
            else
            {
                ExtraSids = ( PNETLOGON_SID_AND_ATTRIBUTES )HeapReAlloc(
                                GetProcessHeap(),
                                0,
                                NewValidationInfo.ExtraSids,
                                ( NewValidationInfo.SidCount + 1 ) * sizeof( NETLOGON_SID_AND_ATTRIBUTES )
                                );
            }

            if ( ExtraSids == NULL )
            {
                DebugLog((DEB_ERROR, "ROGUE: Out of memory allocating ExtraSids\n"));
                ExtraSids = NewValidationInfo.ExtraSids;
                KerbErr = KRB_ERR_GENERIC;
                goto Error;
            }

            //
            // Read the actual SID
            //

            NewValidationInfo.ExtraSids = ExtraSids;

            if ( FALSE == ConvertStringSidToSidA(
                              &Buffer[1],
                              &NewValidationInfo.ExtraSids[NewValidationInfo.SidCount].Sid ))
            {
                DebugLog((DEB_ERROR, "ROGUE: Unable to convert SID\n"));
                KerbErr = KRB_ERR_GENERIC;
                goto Error;
            }

            if ( NewValidationInfo.ExtraSids[NewValidationInfo.SidCount].Sid == NULL )
            {
                DebugLog((DEB_ERROR, "ROGUE: Out of memory allocating an extra SID\n"));
                KerbErr = KRB_ERR_GENERIC;
                goto Error;
            }

            NewValidationInfo.ExtraSids[NewValidationInfo.SidCount].Attributes =
                SE_GROUP_MANDATORY |
                SE_GROUP_ENABLED_BY_DEFAULT |
                SE_GROUP_ENABLED;

            NewValidationInfo.SidCount += 1;
            PacChanged = TRUE;

            break;

        case 'g':
        case 'G': // Group ID

            DebugLog((DEB_ERROR, "ROGUE: Adding a GroupId: %s\n", &Buffer[1]));

            if ( GroupIds == NULL )
            {
                NewValidationInfo.GroupIds = NULL;
                NewValidationInfo.GroupCount = 0;

                GroupIds = ( PGROUP_MEMBERSHIP )HeapAlloc(
                               GetProcessHeap(),
                               0,
                               sizeof( GROUP_MEMBERSHIP )
                               );
            }
            else
            {
                GroupIds = ( PGROUP_MEMBERSHIP )HeapReAlloc(
                               GetProcessHeap(),
                               0,
                               NewValidationInfo.GroupIds,
                               ( NewValidationInfo.GroupCount + 1 ) * sizeof( GROUP_MEMBERSHIP )
                               );
            }

            if ( GroupIds == NULL )
            {
                DebugLog((DEB_ERROR, "ROGUE: Out of memory allocating Group IDs\n"));
                GroupIds = NewValidationInfo.GroupIds;
                KerbErr = KRB_ERR_GENERIC;
                goto Error;
            }

            //
            // Read the actual ID
            //

            NewValidationInfo.GroupIds = GroupIds;
            NewValidationInfo.GroupIds[NewValidationInfo.GroupCount].RelativeId = atoi(&Buffer[1]);
            NewValidationInfo.GroupIds[NewValidationInfo.GroupCount].Attributes =
                SE_GROUP_MANDATORY |
                SE_GROUP_ENABLED_BY_DEFAULT |
                SE_GROUP_ENABLED;
            NewValidationInfo.GroupCount += 1;
            PacChanged = TRUE;

            break;

        case 'r':
        case 'R': // Resource groups

            DebugLog((DEB_ERROR, "ROGUE: Adding a ResourceGroupId: %s\n", &Buffer[1]));

            if ( ResourceGroupIds == NULL )
            {
                NewValidationInfo.ResourceGroupIds = NULL;
                NewValidationInfo.ResourceGroupCount = 0;

                ResourceGroupIds = ( PGROUP_MEMBERSHIP )HeapAlloc(
                                       GetProcessHeap(),
                                       0,
                                       sizeof( GROUP_MEMBERSHIP )
                                       );
            }
            else
            {
                ResourceGroupIds = ( PGROUP_MEMBERSHIP )HeapReAlloc(
                                       GetProcessHeap(),
                                       0,
                                       NewValidationInfo.ResourceGroupIds,
                                       ( NewValidationInfo.ResourceGroupCount + 1 ) * sizeof( GROUP_MEMBERSHIP )
                                       );
            }

            if ( ResourceGroupIds == NULL )
            {
                DebugLog((DEB_ERROR, "ROGUE: Out of memory allocating Resource Group IDs\n"));
                ResourceGroupIds = NewValidationInfo.ResourceGroupIds;
                KerbErr = KRB_ERR_GENERIC;
                goto Error;
            }

            //
            // Read the actual ID
            //

            NewValidationInfo.ResourceGroupIds = ResourceGroupIds;
            NewValidationInfo.ResourceGroupIds[NewValidationInfo.ResourceGroupCount].RelativeId = atoi(&Buffer[1]);
            NewValidationInfo.ResourceGroupIds[NewValidationInfo.ResourceGroupCount].Attributes =
                SE_GROUP_MANDATORY |
                SE_GROUP_ENABLED_BY_DEFAULT |
                SE_GROUP_ENABLED;
            NewValidationInfo.ResourceGroupCount += 1;
            PacChanged = TRUE;

            break;

        default:   // unrecognized

            DebugLog((DEB_ERROR, "ROGUE: Entry \'%c\' unrecognized\n", Buffer[0]));

            break;
        }

        //
        // Move to the next line
        //

        while (*Buffer++ != '\0');
    }

    if ( !PacChanged )
    {
        DebugLog((DEB_ERROR, "ROGUE: Nothing to substitute for %s\n", FullUserSidText));
        KerbErr = KDC_ERR_NONE;
        goto Error;
    }

    //
    // If resource group IDs were added, indicate that by setting the corresponding flag
    //

    if ( ResourceGroupIds )
    {
        NewValidationInfo.UserFlags |= LOGON_RESOURCE_GROUPS;
    }

    //
    // If extra SIDs were added, indicate that by setting the corresponding flag
    //

    if ( ExtraSids )
    {
        NewValidationInfo.UserFlags |= LOGON_EXTRA_SIDS;
    }

    //
    // Now build a new pac
    //

    Status = PAC_InitAndUpdateGroups(
                 &NewValidationInfo,
                 &ZeroResourceGroups,
                 (PPACTYPE)PacAuthData->value.auth_data.value,
                 &NewPac
                 );

    if ( !NT_SUCCESS( Status ))
    {
        DebugLog((DEB_ERROR, "ROGUE: Error 0x%x from PAC_InitAndUpdateGroups\n"));
        KerbErr = KRB_ERR_GENERIC;
        goto Error;
    }

    NewPacSize = PAC_GetSize( NewPac );

    if (!PAC_ReMarshal(NewPac, NewPacSize))
    {
        DsysAssert(!"PAC_Remarshal Failed");
        KerbErr = KRB_ERR_GENERIC;
        goto Error;
    }

    MIDL_user_free( PacAuthData->value.auth_data.value );
    PacAuthData->value.auth_data.value = (PBYTE) NewPac;
    NewPac = NULL;
    PacAuthData->value.auth_data.length = NewPacSize;

    KerbErr = KDC_ERR_NONE;

Cleanup:

    MIDL_user_free( OldValidationInfo );
    LocalFree( FullUserSidText );
    LocalFree( ResourceGroupDomainSid );
    LocalFree( LogonDomainId );
    HeapFree( GetProcessHeap(), 0, ResourceGroupIds );
    HeapFree( GetProcessHeap(), 0, GroupIds );

    if ( ExtraSids )
    {
        for ( ULONG i = 0; i < NewValidationInfo.SidCount; i++ )
        {
            HeapFree( GetProcessHeap(), 0, ExtraSids[i].Sid );
        }

        HeapFree( GetProcessHeap(), 0, ExtraSids );
    }

    MIDL_user_free( NewPac );

    SafeAllocaFree( Value );

    return KerbErr;

Error:

    if ( !KERB_SUCCESS( KerbErr ))
    {
        DebugLog((DEB_ERROR, "ROGUE: Substitution encountered an error, not performed\n"));
    }

    if ( !PAC_ReMarshal(
              (PPACTYPE)PacAuthData->value.auth_data.value,
              PacAuthData->value.auth_data.length ))
    {
        DsysAssert(!"PAC_Remarshal Failed");
        KerbErr = KRB_ERR_GENERIC;
    }

    goto Cleanup;
}

#endif


//+-------------------------------------------------------------------------
//
//  Function:   KdcVerifyAndResignPac
//
//  Synopsis:   Verifies the signature on a PAC and re-signs it with the
//              new servers & kdc's key
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KdcCheckForDelegationInfo(
    IN OUT PUCHAR PacData,
    IN OUT ULONG PacSize,
    IN OUT PBOOLEAN InfoPresent
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    PPAC_INFO_BUFFER DelegationInfo = NULL;
    PPACTYPE Pac;
    ULONG Size;

    *InfoPresent = FALSE;  
    
    Pac = (PPACTYPE) PacData;
    Size = PacSize;

    if (PAC_UnMarshal(Pac, Size) == 0)
    {
        D_DebugLog((DEB_ERROR,"Failed to unmarshal pac\n"));
        return KRB_ERR_GENERIC;
    }                       

    DelegationInfo = PAC_Find(
                        Pac,
                        PAC_DELEGATION_INFO,
                        NULL
                        ); 

    if (!PAC_ReMarshal(Pac, Size))
    {
        DsysAssert(!"PAC_Remarshal Failed");
        return KRB_ERR_GENERIC;
    }

    *InfoPresent = (DelegationInfo != NULL);

    return KerbErr;
}


//+-------------------------------------------------------------------------
//
//  Function:   KdcVerifyAndResignPac
//
//  Synopsis:   Verifies the signature on a PAC and re-signs it with the
//              new servers & kdc's key
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KdcVerifyAndResignPac(
    IN PKERB_ENCRYPTION_KEY OldKey,
    IN PKERB_ENCRYPTION_KEY NewKey,
    IN PKDC_TICKET_INFO OldServerInfo,
    IN OPTIONAL PKDC_TICKET_INFO TargetServiceInfo,
    IN OPTIONAL PKDC_S4U_TICKET_INFO S4UTicketInfo,
    IN OPTIONAL PKERB_ENCRYPTED_TICKET FinalTicket,
    IN BOOLEAN AddResourceGroups,
    IN PKERB_EXT_ERROR ExtendedError,
    IN OUT PKERB_AUTHORIZATION_DATA PacAuthData,
    OUT OPTIONAL PS4U_DELEGATION_INFO* S4UDelegationInfo
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    BOOLEAN InfoPresent = FALSE;
    BOOLEAN DCTarget = FALSE;
    
    TRACE(KDC, KdcVerifyAndResignPac, DEB_FUNCTION);

    PKDC_TICKET_INFO LocalServerInfo = OldServerInfo;

    //
    // If the TI_PRXY_REQUESTOR_THIS_REALM bit is set, then
    // the evidence ticket is encrypted in the requestor's key.
    //

    if (( ARGUMENT_PRESENT( S4UTicketInfo ) ) &&
        ( S4UTicketInfo->Flags & TI_S4UPROXY_INFO ))
    {
        LocalServerInfo = &S4UTicketInfo->RequestorTicketInfo;
    }

    if (ARGUMENT_PRESENT( TargetServiceInfo ))
    {
        DCTarget = ((TargetServiceInfo->UserAccountControl & USER_SERVER_TRUST_ACCOUNT ) != 0);
    }    


    //
    // Delegation info in PAC?  Then it better not be interdomain, as 
    // constrained delegation (S4UProxy) only works in a single
    // domain.  Reject the request.
    //

    if ( OldServerInfo->UserId == DOMAIN_USER_RID_KRBTGT &&
       ( OldServerInfo->UserAccountControl & USER_INTERDOMAIN_TRUST_ACCOUNT ))
    {
        KerbErr = KdcCheckForDelegationInfo( 
                        PacAuthData->value.auth_data.value, 
                        PacAuthData->value.auth_data.length,
                        &InfoPresent
                        );

        if ( InfoPresent )
        {
            DebugLog((DEB_ERROR, "Attempting XRealm S4UProxy Inbound\n"));
            KerbErr = KDC_ERR_POLICY;
            FILL_EXT_ERROR_EX2( ExtendedError, STATUS_CROSSREALM_DELEGATION_FAILURE, FILENO, __LINE__ );
            goto Cleanup;
        }
        else if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }
    }

    //
    // Now verify the existing signature
    //

    KerbErr = KdcVerifyPacSignature(
                  OldKey,
                  LocalServerInfo,
                  PacAuthData->value.auth_data.length,
                  PacAuthData->value.auth_data.value
                  );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    //
    // Perform SID filtering if necessary
    //

    KerbErr = KdcCheckPacForSidFiltering(
                  OldServerInfo,
                  &PacAuthData->value.auth_data.value,
                  (PULONG) &PacAuthData->value.auth_data.length
                  );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    
    //
    // See if this is an S4U variant, and fill in the interesting pac sections.
    //
    if (ARGUMENT_PRESENT( S4UTicketInfo ))
    {   
        if (( S4UTicketInfo->Flags & TI_S4UPROXY_INFO ) != 0)
        {
            //
            // S4UProxy
            // 2 courses of action here.
            // 1. If this is for a server in our realm, then we need to insert the
            //    target into the S4U_DELEGATION_INFO.
            // 2. If we're transitting, validate the target name vs. what's in the PAC,
            //    and continue on.
            //

            KerbErr = KdcUpdateAndValidateS4UProxyPAC(
                            S4UTicketInfo,
                            &PacAuthData->value.auth_data.value,
                            (PULONG) &PacAuthData->value.auth_data.length,
                            S4UDelegationInfo
                            );

            if (!KERB_SUCCESS(KerbErr))
            {
                DebugLog((DEB_ERROR, "KdcUpdateAndValidateS4UProxyInfo failed - %x\n", KerbErr));
                goto Cleanup;
            }
        }
        else if (( S4UTicketInfo->Flags & TI_REQUESTOR_THIS_REALM ) != 0)
        {
            //
            // S4USelf - replace the pac verifier w/ one that is acceptable to the 
            // destination server.
            //
            KerbErr = KdcUpdateAndVerifyS4UPacVerifier(
                            S4UTicketInfo,
                            &PacAuthData->value.auth_data.value,
                            (PULONG) &PacAuthData->value.auth_data.length
                            );

            if (!KERB_SUCCESS(KerbErr))
            {
                DebugLog((DEB_ERROR, "KdcVerifyS4UPacVerifier failed - %x\n", KerbErr));
                goto Cleanup;
            }  

        }

    }


#ifdef ROGUE_DC
    KerbErr = KdcInstrumentRoguePac( PacAuthData );

    if ( !KERB_SUCCESS( KerbErr ))
    {
        DebugLog((DEB_ERROR, "KdcInstrumentRoguePac failed\n"));
    }
#endif

    //
    // Now resign the PAC. If we add new sig algs, then we may need to
    // address growing sigs, but for now, its all KDC_PAC_CHECKSUM
    //

    KerbErr = KdcSignPac(
                NewKey,
                AddResourceGroups,
                DCTarget,
                &PacAuthData->value.auth_data.value,
                (PULONG) &PacAuthData->value.auth_data.length
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

Cleanup:

    return(KerbErr);
}

//+-------------------------------------------------------------------------
//
//  Function:   KdcFreeAuthzInfo
//
//  Synopsis:   Used to free buffers / handles from KdcGetValidationInfoFromTgt.
//              Allows us to use allocated buffers w/o copy overhead.
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KdcFreeAuthzInfo(
    IN PKDC_AUTHZ_GROUP_BUFFERS InfoToFree
    )
{
    if (InfoToFree->BuiltInSids)
    {
        MIDL_user_free(InfoToFree->BuiltInSids);
    }

    if (InfoToFree->PacGroups.Sids != NULL)
    {
       for (ULONG Index = 0; Index < InfoToFree->PacGroups.Count ;Index++ )
       {
           if (InfoToFree->PacGroups.Sids[Index].SidPointer != NULL)
           {
               MIDL_user_free(InfoToFree->PacGroups.Sids[Index].SidPointer);
           }
       }

       MIDL_user_free(InfoToFree->PacGroups.Sids);
    }

    SamIFree_SAMPR_ULONG_ARRAY( &InfoToFree->AliasGroups );
    SamIFreeSidArray( InfoToFree->ResourceGroups );

    if ( InfoToFree->SidAndAttributes )
    {
        MIDL_user_free(InfoToFree->SidAndAttributes);
    }

    if ( InfoToFree->ValidationInfo )
    {
        MIDL_user_free( InfoToFree->ValidationInfo );
    }                                                

    RtlZeroMemory(
        InfoToFree,
        sizeof(KDC_AUTHZ_GROUP_BUFFERS)
        );
}

//+-------------------------------------------------------------------------
//
//  Function:   KdcGetSidsFromTgt
//
//  Synopsis:   Takes a TGT, grabs the PAC from the authorization data, and
//              extracts the validation info, builds groups up.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KdcGetSidsFromTgt(
    IN PKERB_ENCRYPTED_TICKET EncryptedTicket,
    IN OPTIONAL PKERB_ENCRYPTION_KEY EncryptedTicketKey,
    IN ULONG EncryptionType,
    IN PKDC_TICKET_INFO TgtAccountInfo,
    IN OUT PKDC_AUTHZ_INFO AuthzInfo,
    IN OUT PKDC_AUTHZ_GROUP_BUFFERS InfoToFree,
    OUT NTSTATUS * pStatus
    )
{
    KERBERR  KerbErr;
    NTSTATUS Status = STATUS_SUCCESS;

    PKERB_AUTHORIZATION_DATA        SourceAuthData = NULL;
    PKERB_IF_RELEVANT_AUTH_DATA *   IfRelevantData = NULL;
    PKERB_AUTHORIZATION_DATA        PacAuthData = NULL;
    PKERB_ENCRYPTION_KEY            KdcKey = EncryptedTicketKey;
    PPAC_INFO_BUFFER                LogonInfo;
    PPACTYPE                        Pac;
    ULONG                           PacSize;
    PNETLOGON_VALIDATION_SAM_INFO3  LocalValidationInfo = NULL;
    SAMPR_PSID_ARRAY                SidList = {0};
    PSAMPR_PSID_ARRAY               ResourceGroups = NULL;
    SAMPR_ULONG_ARRAY               BuiltinGroups = {0, NULL};
    PSID                            SidBuffer = NULL;
    PNETLOGON_SID_AND_ATTRIBUTES    SidAndAttributes = NULL;
    ULONG Index, Index2, GroupCount = 0, SidSize = 0;

    RtlZeroMemory(
        InfoToFree,
        sizeof(KDC_AUTHZ_GROUP_BUFFERS)
        );

    if (EncryptedTicket->bit_mask & KERB_ENCRYPTED_TICKET_authorization_data_present)
    {
        DsysAssert(EncryptedTicket->KERB_ENCRYPTED_TICKET_authorization_data != NULL);
        SourceAuthData = EncryptedTicket->KERB_ENCRYPTED_TICKET_authorization_data;
    }
    else
    {
        DsysAssert(FALSE);
        *pStatus = STATUS_INVALID_PARAMETER;
        return KRB_ERR_GENERIC;
    }

    KerbErr = KerbGetPacFromAuthData(
                  SourceAuthData,
                  &IfRelevantData,
                  &PacAuthData
                  );

    if ( PacAuthData == NULL )
    {
        KerbErr = KRB_ERR_GENERIC;
    }

    if (!KERB_SUCCESS(KerbErr))
    {                             
        Status = STATUS_NO_MEMORY; // difficult to figure out exactly what it was
        goto Cleanup;
    }

    //
    // Verify the signature, using Krbtgt key.
    //

    if ( KdcKey == NULL )
    {
        KdcKey = KerbGetKeyFromList(
                     TgtAccountInfo->Passwords,
                     EncryptionType
                     );
    
        if ( KdcKey == NULL )
        {
            DebugLog((DEB_ERROR, "Can't find key for PAC (%x)\n", EncryptionType ));
            KerbErr = KRB_ERR_GENERIC;
            Status = STATUS_NO_KERB_KEY;
            goto Cleanup;
        }
    }

    KerbErr = KdcVerifyPacSignature(
                  KdcKey,
                  TgtAccountInfo,
                  PacAuthData->value.auth_data.length,
                  PacAuthData->value.auth_data.value
                  );

    if (!KERB_SUCCESS( KerbErr ))
    {
        DebugLog((DEB_ERROR,"PAC signature didn't verify\n"));
        Status = KerbMapKerbError( KerbErr );
        goto Cleanup;
    }

    Pac = (PPACTYPE) PacAuthData->value.auth_data.value;
    PacSize = PacAuthData->value.auth_data.length;

    if (PAC_UnMarshal(Pac, PacSize) == 0)
    {
        D_DebugLog((DEB_ERROR,"Failed to unmarshal pac\n"));
        KerbErr = KRB_ERR_GENERIC;
        Status = STATUS_INVALID_PARAMETER; // better error code?
        goto Cleanup;
    }

    LogonInfo = PAC_Find(
                    Pac,
                    PAC_LOGON_INFO,
                    NULL
                    );

    if ( LogonInfo == NULL )
    {
        KerbErr = KRB_ERR_GENERIC;
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    Status = PAC_UnmarshallValidationInfo(
                 &LocalValidationInfo,
                 LogonInfo->Data,
                 LogonInfo->cbBufferSize
                 );

    if ( !NT_SUCCESS( Status ))
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    //
    // Filter the sids.  If trust sid is present, this is an inbound TGT.  We
    // don't do this for TGTs from our own domain.
    //

    if (NULL != TgtAccountInfo->TrustSid)
    {
        Status = KdcFilterSids(
                     TgtAccountInfo,
                     LocalValidationInfo
                     );

        if ( !NT_SUCCESS( Status ))
        {
            KerbErr = KDC_ERR_POLICY;
            goto Cleanup;
        }
    }

    //
    // Make a sid list from the validation info
    //

    KerbErr = KdcBuildPacSidList(
                  LocalValidationInfo,
                  TRUE,       // Add everyone and authenticated user sids.
                  (( TgtAccountInfo->TrustAttributes & TRUST_ATTRIBUTE_CROSS_ORGANIZATION ) != 0 ),
                  &SidList
                  );

    if (!KERB_SUCCESS(KerbErr))
    {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    RtlCopyMemory(
        &InfoToFree->PacGroups,
        &SidList,
        sizeof(SAMPR_PSID_ARRAY)
        );

    //
    // Call SAM to get the sids for resource groups and built-in groups
    //

    Status = SamIGetResourceGroupMembershipsTransitive(
                 GlobalAccountDomainHandle,
                 &SidList,
                 0,              // no flags
                 &ResourceGroups
                 );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to get resource groups: 0x%x\n",Status));
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    InfoToFree->ResourceGroups = ResourceGroups;

    Status = SamIGetAliasMembership(
                 GlobalBuiltInDomainHandle,
                 &SidList,
                 &BuiltinGroups
                 );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to get ALIAS MEMBERSHIP groups: 0x%x\n",Status));
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    RtlCopyMemory(
        &InfoToFree->AliasGroups,
        &BuiltinGroups,
        sizeof(SAMPR_ULONG_ARRAY)
        );

    GroupCount = BuiltinGroups.Count + ResourceGroups->Count + SidList.Count;

    //
    // Enumerate and allocate the groups sids...
    //

    if (GroupCount != 0)
    {
        SidAndAttributes = (PNETLOGON_SID_AND_ATTRIBUTES) MIDL_user_allocate(sizeof(NETLOGON_SID_AND_ATTRIBUTES) * GroupCount);
        if (SidAndAttributes == NULL)
        {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }

        InfoToFree->SidAndAttributes = SidAndAttributes;

        //
        // Add in all the extra sids that are not resource groups
        //

        Index2 = 0;
        for (Index = 0; Index < SidList.Count; Index++ )
        {
            SidAndAttributes[Index2].Sid = SidList.Sids[Index].SidPointer;
            SidAndAttributes[Index2].Attributes =  SE_GROUP_MANDATORY |
                                                    SE_GROUP_ENABLED |
                                                    SE_GROUP_ENABLED_BY_DEFAULT;
            Index2++;
        }

        //
        // Copy all the resource group SIDs
        //

        for (Index = 0; Index < ResourceGroups->Count ; Index++ )
        {
            SidAndAttributes[Index2].Sid = ResourceGroups->Sids[Index].SidPointer;
            SidAndAttributes[Index2].Attributes =  SE_GROUP_MANDATORY |
                                                    SE_GROUP_ENABLED |
                                                    SE_GROUP_ENABLED_BY_DEFAULT |
                                                    SE_GROUP_RESOURCE;
            Index2++;
        }

        //
        // Copy in the builtin group sids.
        //

        SidSize = RtlLengthSid(GlobalBuiltInSid) + sizeof(ULONG);
        SidBuffer = (PSID) MIDL_user_allocate(SidSize * BuiltinGroups.Count);

        if (SidBuffer == NULL)
        {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }

        InfoToFree->BuiltInSids = SidBuffer;
        PBYTE Current = (PBYTE) SidBuffer;

        for (Index = 0; Index < BuiltinGroups.Count ; Index++ )
        {
            RtlCopySid(
                RtlLengthSid(GlobalBuiltInSid),
                Current,
                GlobalBuiltInSid
                );

            //
            // The final value is just a ULONG - appended to the right place.
            //

            (*RtlSubAuthoritySid(
                Current,
                ((ULONG) (*RtlSubAuthorityCountSid(GlobalBuiltInSid)) - 1)
                                )) = BuiltinGroups.Element[Index];

            SidAndAttributes[Index2].Sid = Current;
            SidAndAttributes[Index2].Attributes =  SE_GROUP_MANDATORY |
                                                    SE_GROUP_ENABLED |
                                                    SE_GROUP_ENABLED_BY_DEFAULT;
            Index2++;
            Current += SidSize;
        }
    }

    InfoToFree->ValidationInfo = LocalValidationInfo;
    LocalValidationInfo = NULL;

    AuthzInfo->SidCount = GroupCount;
    AuthzInfo->SidAndAttributes = SidAndAttributes;
    SidAndAttributes = NULL;

Cleanup:

    if (LocalValidationInfo)
    {
        MIDL_user_free(LocalValidationInfo);
    }

    if (!KERB_SUCCESS(KerbErr))
    {
        KdcFreeAuthzInfo(InfoToFree);
    }

    if (IfRelevantData)
    {
        KerbFreeData(PKERB_IF_RELEVANT_AUTH_DATA_PDU, IfRelevantData);
    }

    *pStatus = Status;

    return KerbErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\server\notify2.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        notify.cxx
//
// Contents:    KDC password change notification code
//
//
// History:     19-Aug-1996     MikeSw          Created
//
//------------------------------------------------------------------------

#include "kdcsvr.hxx"
extern "C"
{
#include <dns.h>                // DNS_MAX_NAME_LENGTH
#include <ntdsa.h>              // CrackSingleName
}

UNICODE_STRING KdcNotifyDnsDomainName = {0};
UNICODE_STRING KdcNotifyDomainName = {0};


//+-------------------------------------------------------------------------
//
//  Function:   KdcNotifyOpenAccountDomain
//
//  Synopsis:   Opens the account domain and stores a handle to it.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
KdcNotifyOpenAccountDomain(
    OUT SAMPR_HANDLE * AccountDomainHandle
    )
{
    NTSTATUS Status;
    PLSAPR_POLICY_INFORMATION PolicyInformation = NULL;
    SAMPR_HANDLE ServerHandle = NULL;


    Status = LsaIQueryInformationPolicyTrusted(
                PolicyDnsDomainInformation,
                &PolicyInformation
                );
    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"Failed to query information policy: 0x%x\n",Status));
        goto Cleanup;
    }

    Status = KerbDuplicateString(
                &KdcNotifyDomainName,
                (PUNICODE_STRING) &PolicyInformation->PolicyDnsDomainInfo.Name
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = KerbDuplicateString(
                &KdcNotifyDnsDomainName,
                (PUNICODE_STRING) &PolicyInformation->PolicyDnsDomainInfo.DnsDomainName
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
    Status = RtlUpcaseUnicodeString(
                &KdcNotifyDnsDomainName,
                &KdcNotifyDnsDomainName,
                FALSE   // don't allocate
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
    //
    // Connect to SAM and open the account domain
    //

    Status = SamIConnect(
                NULL,           // no server name
                &ServerHandle,
                0,              // ignore desired access,
                TRUE            // trusted caller
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to connect to SAM: 0x%x\n",Status));
        goto Cleanup;
    }

    //
    // Finally open the account domain.
    //

    Status = SamrOpenDomain(
                ServerHandle,
                DOMAIN_ALL_ACCESS,
                (PRPC_SID) PolicyInformation->PolicyDnsDomainInfo.Sid,
                AccountDomainHandle
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "Failed to open account domain: 0x%x\n",Status));
        goto Cleanup;
    }


Cleanup:
    if (PolicyInformation != NULL)
    {
        LsaIFree_LSAPR_POLICY_INFORMATION(
                PolicyDnsDomainInformation,
                PolicyInformation
                );
    }

    if (ServerHandle != NULL)
    {
        SamrCloseHandle(&ServerHandle);
    }

    return(Status);


}

//+-------------------------------------------------------------------------
//
//  Function:   KdcBuildPasswordList
//
//  Synopsis:   Builds a list of passwords for a user that just changed
//              their password.
//
//  Effects:    allocates memory
//
//  Arguments:  Password - clear or OWF password
//              PrincipalName - Name of principal
//              MarshallKeys - if TRUE, the keys will be marshalled
//              IncludeBuiltinTypes - if TRUE, include MD4 & LM hashes
//              PasswordList - Receives new password list
//              PasswordListSize - Size of list in bytes.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KdcBuildPasswordList(
    IN PUNICODE_STRING Password,
    IN PUNICODE_STRING PrincipalName,
    IN PUNICODE_STRING DomainName,
    IN KERB_ACCOUNT_TYPE AccountType,
    IN PKERB_STORED_CREDENTIAL StoredCreds,
    IN ULONG StoredCredSize,
    IN BOOLEAN MarshallKeys,
    IN BOOLEAN IncludeBuiltinTypes,
    IN ULONG Flags,
    IN KDC_DOMAIN_INFO_DIRECTION Direction,
    OUT PKERB_STORED_CREDENTIAL * PasswordList,
    OUT PULONG PasswordListSize
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG CryptTypes[KERB_MAX_CRYPTO_SYSTEMS];
    ULONG CryptCount = 0;
    PKERB_STORED_CREDENTIAL Credentials = NULL;
    ULONG CredentialSize = 0;
    ULONG KerbEncryptionKeyCount = 0;
    ULONG KerbKeyDataCount = 0;
    PCRYPTO_SYSTEM CryptoSystem;
    ULONG Index, CredentialIndex = 0;
    PUCHAR Base, KeyBase;
    ULONG Offset;
    ULONG OldCredCount = 0;
    KERB_ENCRYPTION_KEY TempKey;
    UNICODE_STRING KeySalt = {0};
    UNICODE_STRING EmptySalt = {0};
    USHORT OldFlags = 0;


    *PasswordList = NULL;
    *PasswordListSize = 0;

    //
    // If we had passed in an OWF, then there is just one password.
    //

    if ((Flags & KERB_PRIMARY_CRED_OWF_ONLY) != 0)
    {
        CredentialSize += Password->Length + sizeof(KERB_ENCRYPTION_KEY);
        KerbEncryptionKeyCount++;
#ifndef DONT_SUPPORT_OLD_TYPES
        CredentialSize += Password->Length + sizeof(KERB_ENCRYPTION_KEY);
        KerbEncryptionKeyCount++;
#endif
    }
    else
    {
        //
        // The salt is the realm name concatenated with the principal name
        //

        if (AccountType != UnknownAccount)
        {
            //
            // For inbound trust, swap the domain names
            //

            if ((AccountType == DomainTrustAccount) &&
                (Direction == Inbound))
            {
                if (!KERB_SUCCESS(KerbBuildKeySalt(
                        PrincipalName,
                        DomainName,
                        AccountType,
                        &KeySalt
                        )))
                {
                    return(STATUS_INSUFFICIENT_RESOURCES);
                }
            }
            else
            {
                if (!KERB_SUCCESS(KerbBuildKeySalt(
                                    DomainName,
                                    PrincipalName,
                                    AccountType,
                                    &KeySalt
                                    )))
                {
                    return(STATUS_INSUFFICIENT_RESOURCES);
                }
            }
        }
        else
        {
            KeySalt = *PrincipalName;
        }
        D_DebugLog((DEB_TRACE,"Building key list with salt %wZ\n",&KeySalt));

        //
        // For a cleartext password, build a list of encryption types and
        // create a key for each one
        //

        Status = CDBuildIntegrityVect(
                    &CryptCount,
                    CryptTypes
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
        DsysAssert(CryptCount <= KERB_MAX_CRYPTO_SYSTEMS);

        //
        // Now find the size of the key for each crypto system
        //

        for (Index = 0; Index < CryptCount; Index++ )
        {
            //
            // Skip etypes stored as normal passwords
            //

            if (!IncludeBuiltinTypes &&
                ((CryptTypes[Index] == KERB_ETYPE_RC4_LM) ||
                 (CryptTypes[Index] == KERB_ETYPE_RC4_MD4) ||
                 (CryptTypes[Index] == KERB_ETYPE_RC4_HMAC_OLD) ||
                 (CryptTypes[Index] == KERB_ETYPE_RC4_HMAC_OLD_EXP) ||
                 (CryptTypes[Index] == KERB_ETYPE_RC4_HMAC_NT) ||
                 (CryptTypes[Index] == KERB_ETYPE_RC4_HMAC_NT_EXP) ||
                 (CryptTypes[Index] == KERB_ETYPE_NULL)))
            {
                continue;
            }

            Status = CDLocateCSystem(
                        CryptTypes[Index],
                        &CryptoSystem
                        );

            if (!NT_SUCCESS(Status) || NULL == CryptoSystem)
            {
               D_DebugLog((DEB_ERROR, "CDLocateCSystem failed for etype: %d\n", CryptTypes[Index]));
               continue;
            }

            CredentialSize += sizeof(KERB_ENCRYPTION_KEY) + CryptoSystem->KeySize;
            KerbEncryptionKeyCount++;
        }
    }

    //
    // For a cleartext password, build a list of encryption types and
    // create a key for each one
    //

    Status = CDBuildIntegrityVect(
                &CryptCount,
                CryptTypes
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
    DsysAssert(CryptCount <= KERB_MAX_CRYPTO_SYSTEMS);

    //
    // Add the space for the salt
    //

    CredentialSize += KeySalt.Length;

    //
    // Now find the size of the key for each crypto system
    //

    for (Index = 0; Index < CryptCount; Index++ )
    {
        //
        // Skip etypes stored as normal passwords
        //

        if (!IncludeBuiltinTypes &&
            ((CryptTypes[Index] == KERB_ETYPE_RC4_LM) ||
             (CryptTypes[Index] == KERB_ETYPE_RC4_MD4) ||
             (CryptTypes[Index] == KERB_ETYPE_RC4_HMAC_OLD) ||
             (CryptTypes[Index] == KERB_ETYPE_RC4_HMAC_OLD_EXP) ||
             (CryptTypes[Index] == KERB_ETYPE_RC4_HMAC_NT) ||
             (CryptTypes[Index] == KERB_ETYPE_RC4_HMAC_NT_EXP) ||
             (CryptTypes[Index] == KERB_ETYPE_NULL)))
        {
            continue;
        }

        Status = CDLocateCSystem(
                    CryptTypes[Index],
                    &CryptoSystem
                    );

        if (!NT_SUCCESS(Status) || NULL == CryptoSystem)
        {
           D_DebugLog((DEB_ERROR, "CDLocateCSystem failed for etype: %d\n", CryptTypes[Index]));
           continue;
        }
        CredentialSize += sizeof(KERB_KEY_DATA) + CryptoSystem->KeySize;
        KerbKeyDataCount++;
    }

    //
    // Add in space for oldcreds
    //

    if (ARGUMENT_PRESENT(StoredCreds))
    {
        if ((StoredCreds->Revision == KERB_PRIMARY_CRED_REVISION) &&
            (StoredCreds->CredentialCount != 0))
        {
            OldFlags = StoredCreds->Flags;
            for (Index = 0; Index < StoredCreds->CredentialCount ; Index++ )
            {
                CredentialSize += sizeof(KERB_KEY_DATA) + StoredCreds->Credentials[Index].Key.keyvalue.length +
                                    StoredCreds->Credentials[Index].Salt.Length;
                KerbKeyDataCount++;
            }
            OldCredCount = StoredCreds->CredentialCount;

        }
    }

    //
    // Add in the size of the base structure
    //

    CredentialSize += sizeof(KERB_STORED_CREDENTIAL) - (ANYSIZE_ARRAY * sizeof(KERB_KEY_DATA));
    Credentials = (PKERB_STORED_CREDENTIAL) MIDL_user_allocate(CredentialSize);
    if (Credentials == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Fill in the base structure
    //

    Credentials->Revision = KERB_PRIMARY_CRED_REVISION;
    Credentials->Flags = OldFlags | (USHORT) Flags ;

    //
    // Now fill in the individual keys
    //

    Base = (PUCHAR) Credentials;
    if (MarshallKeys)
    {
        KeyBase = 0;
    }
    else
    {
        KeyBase = Base;
    }
    Offset = sizeof(KERB_STORED_CREDENTIAL) - (ANYSIZE_ARRAY * sizeof(KERB_KEY_DATA)) +
                (KerbEncryptionKeyCount * sizeof(KERB_ENCRYPTION_KEY)) +
                (KerbKeyDataCount * sizeof(KERB_KEY_DATA));


    //
    // Add the default salt
    //

    Credentials->DefaultSalt.Length =
        Credentials->DefaultSalt.MaximumLength = KeySalt.Length;
    Credentials->DefaultSalt.Buffer = (LPWSTR) (KeyBase+Offset);

    RtlCopyMemory(
        Base + Offset,
        KeySalt.Buffer,
        KeySalt.Length
        );
    Offset += Credentials->DefaultSalt.Length;



    if ((Flags & KERB_PRIMARY_CRED_OWF_ONLY) != 0)
    {
        RtlCopyMemory(
            Base + Offset,
            Password->Buffer,
            Password->Length
            );

        if (!KERB_SUCCESS(KerbCreateKeyFromBuffer(
                            &Credentials->Credentials[CredentialIndex].Key,
                            Base + Offset,
                            Password->Length,
                            KERB_ETYPE_RC4_HMAC_NT
                            )))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        Credentials->Credentials[CredentialIndex].Key.keyvalue.value =
            Credentials->Credentials[CredentialIndex].Key.keyvalue.value - Base + KeyBase;

        Offset += Password->Length;
        CredentialIndex++;

#ifndef DONT_SUPPORT_OLD_TYPES
        RtlCopyMemory(
            Base + Offset,
            Password->Buffer,
            Password->Length
            );

        if (!KERB_SUCCESS(KerbCreateKeyFromBuffer(
                            &Credentials->Credentials[CredentialIndex].Key,
                            Base + Offset,
                            Password->Length,
                            (ULONG) KERB_ETYPE_RC4_HMAC_OLD
                            )))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        Credentials->Credentials[CredentialIndex].Key.keyvalue.value =
            Credentials->Credentials[CredentialIndex].Key.keyvalue.value - Base + KeyBase;

        Offset += Password->Length;
        CredentialIndex++;
#endif
    }
    else // assume it's clear
    {
        //
        // Now find the size of the key for each crypto system
        //

        for (Index = 0; Index < CryptCount; Index++ )
        {
            if (!IncludeBuiltinTypes &&
                ((CryptTypes[Index] == KERB_ETYPE_RC4_LM) ||
                 (CryptTypes[Index] == KERB_ETYPE_RC4_MD4) ||
                 (CryptTypes[Index] == KERB_ETYPE_RC4_HMAC_OLD) ||
                 (CryptTypes[Index] == KERB_ETYPE_RC4_HMAC_OLD_EXP) ||
                 (CryptTypes[Index] == KERB_ETYPE_RC4_HMAC_NT) ||
                 (CryptTypes[Index] == KERB_ETYPE_RC4_HMAC_NT_EXP) ||
                 (CryptTypes[Index] == KERB_ETYPE_NULL)))
            {
                continue;
            }

            if (!KERB_SUCCESS(KerbHashPasswordEx(
                    Password,
                    &KeySalt,
                    CryptTypes[Index],
                    &TempKey)))
            {
                //
                // It is possible that the password can't be used for every
                // encryption scheme, so skip failures
                //

                D_DebugLog((DEB_WARN, "Failed to hash pasword %wZ with type 0x%x\n",
                    Password,CryptTypes[Index] ));
                continue;
            }

#if DBG
            CDLocateCSystem(
                CryptTypes[Index],
                &CryptoSystem
                );
            DsysAssert(CryptoSystem->KeySize >= TempKey.keyvalue.length);

#endif

            Credentials->Credentials[CredentialIndex].Key = TempKey;
            Credentials->Credentials[CredentialIndex].Key.keyvalue.value = KeyBase + Offset;
            RtlCopyMemory(
                Base + Offset,
                TempKey.keyvalue.value,
                TempKey.keyvalue.length
                );
            Offset += TempKey.keyvalue.length;
            KerbFreeKey(
                &TempKey
                );
            Credentials->Credentials[CredentialIndex].Salt = EmptySalt;
            CredentialIndex++;

        }
    }
    Credentials->CredentialCount = (USHORT) CredentialIndex;

    //
    // Now add in the old creds, if there were any
    //

    if (OldCredCount != 0)
    {
        for (Index = 0; Index < OldCredCount ; Index++ )
        {

            Credentials->Credentials[CredentialIndex] = StoredCreds->Credentials[Index];
            Credentials->Credentials[CredentialIndex].Key.keyvalue.value = KeyBase + Offset;
            RtlCopyMemory(
                Base + Offset,
                StoredCreds->Credentials[Index].Key.keyvalue.value + (ULONG_PTR) StoredCreds,
                StoredCreds->Credentials[Index].Key.keyvalue.length
                );
            Offset += StoredCreds->Credentials[Index].Key.keyvalue.length;

            //
            // Copy the salt
            //

            if (Credentials->Credentials[CredentialIndex].Salt.Buffer != NULL)
            {
                Credentials->Credentials[CredentialIndex].Salt.Buffer = (LPWSTR) Base+Offset;

                RtlCopyMemory(
                    Base + Offset,
                    (PBYTE) StoredCreds->Credentials[Index].Salt.Buffer + (ULONG_PTR) StoredCreds,
                    StoredCreds->Credentials[Index].Salt.Length
                    );
                Offset += StoredCreds->Credentials[Index].Salt.Length;
            }
            else
            {
                Credentials->Credentials[CredentialIndex].Salt = EmptySalt;
            }

            CredentialIndex++;
        }
        Credentials->OldCredentialCount = (USHORT) OldCredCount;
    }
    else
    {
        Credentials->OldCredentialCount = 0;
    }
    *PasswordList = Credentials;
    *PasswordListSize = CredentialSize;
    Credentials = NULL;

Cleanup:
    if (Credentials != NULL)
    {
         MIDL_user_free(Credentials);
    }
    if (AccountType != UnknownAccount)
    {
        KerbFreeString(&KeySalt);
    }
    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KdcBuildKeySaltFromUpn
//
//  Synopsis:   Builds the salt by parsing the UPN, stripping out "@" & "/"
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KdcBuildKeySaltFromUpn(
    IN PUNICODE_STRING Upn,
    IN PUNICODE_STRING DomainName,
    OUT PUNICODE_STRING Salt
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING RealUpn;
    UNICODE_STRING LocalSalt = {0};
    ULONG Index;

    //
    // If there is an "@" in UPN, strip it out & use the dns domain name
    //

    RealUpn = *Upn;

    // Verify that the length is not 0  SWI
    for ( Index = ((RealUpn.Length / sizeof(WCHAR)) - 1); Index-- > 0; )
    {
        if (RealUpn.Buffer[Index] == L'@')
        {
            RealUpn.Length = (USHORT) (Index * sizeof(WCHAR));
            break;
        }
    }

    //
    // Create the salt. It starts off with the domain name & then has the
    // UPN without any of the / pieces
    //

    // ULONG test the length before allocation SWI
    LocalSalt.MaximumLength = DomainName->Length + RealUpn.Length;
    LocalSalt.Length = 0;
    LocalSalt.Buffer = (LPWSTR) MIDL_user_allocate(LocalSalt.MaximumLength);
    if (LocalSalt.Buffer == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    RtlCopyMemory(
        LocalSalt.Buffer,
        DomainName->Buffer,
        DomainName->Length
        );
    LocalSalt.Length = LocalSalt.Length + DomainName->Length;

    //
    // We have to uppercase the realmname for users
    //

    (VOID) RtlUpcaseUnicodeString( &LocalSalt,
                                   &LocalSalt,
                                   FALSE);

    //
    // Add in the real upn but leave out any "/" marks
    //

    for (Index = 0; Index < RealUpn.Length/sizeof(WCHAR) ; Index++ )
    {
        if (RealUpn.Buffer[Index] != L'/')
        {
            LocalSalt.Buffer[LocalSalt.Length / sizeof(WCHAR)] = RealUpn.Buffer[Index];
            LocalSalt.Length += sizeof(WCHAR);
        }
    }

    *Salt = LocalSalt;
Cleanup:
    return(Status);


}

//+-------------------------------------------------------------------------
//
//  Function:   PasswordChangeNotify
//
//  Synopsis:   Notifies KDC of a password change, allowing it to update
//              its credentials
//
//  Effects:    Stores Kerberos credentials on user object
//
//  Arguments:  UserName - Name of user whose password changed
//              RelativeId - RID of changed user
//              Passsword - New password of user
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS on success
//
//  Notes:
//
//
//--------------------------------------------------------------------------

extern "C"
NTSTATUS
PasswordChangeNotify(
    IN PUNICODE_STRING UserName,
    IN ULONG RelativeId,
    IN PUNICODE_STRING Password
    )
{

    //
    // Password change notify routine in kdcsvc was used to compute the
    // "DES" keys for the user upon a password change.
    // Subsequently this logic was inlined in samsrv.dll
    //

    return(STATUS_SUCCESS);
}

extern "C"


NTSTATUS
KdcBuildKerbCredentialsFromPassword(
    IN PUNICODE_STRING ClearPassword,
    IN PVOID KerbCredentials,
    IN ULONG KerbCredentialLength,
    IN ULONG UserAccountControl,
    IN PUNICODE_STRING UPN,
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING DnsDomainName,
    OUT PVOID * NewKerbCredentials,
    OUT PULONG NewKerbCredentialLength
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    KERB_ACCOUNT_TYPE AccountType = UnknownAccount;
    UNICODE_STRING KeySalt = {0};
    BOOLEAN        FreeSalt = FALSE;

    PKERB_STORED_CREDENTIAL   Cred64 = NULL;

#ifdef _WIN64
    PKERB_STORED_CREDENTIAL32 Cred32 = NULL;
    ULONG CredLength = KerbCredentialLength;
#endif


    //
    // Compute the correct account type
    //

    if ((UserAccountControl &
        (USER_WORKSTATION_TRUST_ACCOUNT | USER_SERVER_TRUST_ACCOUNT)) != 0)
    {
        AccountType = MachineAccount;
        KeySalt = *UserName;
    }
    else if ((UserAccountControl &
         (USER_INTERDOMAIN_TRUST_ACCOUNT)) != 0)
    {
        AccountType = DomainTrustAccount;
        KeySalt = *UserName;
    }
    else
    {
        if (ARGUMENT_PRESENT(UPN))
        {
            Status = KdcBuildKeySaltFromUpn(
                        UPN,
                        DnsDomainName,
                        &KeySalt
                        );
            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }

            FreeSalt = TRUE;
        }
        else
        {
            AccountType = UserAccount;
            KeySalt = *UserName;
        }
    }



#ifdef _WIN64

    Status = KdcUnpack32BitStoredCredential(
                  (PKERB_STORED_CREDENTIAL32) KerbCredentials,
                  &Cred64,
                  &CredLength
                  );

    if (!NT_SUCCESS(Status))
    {
       goto Cleanup;
    }

    KerbCredentials = (PVOID) Cred64;
    KerbCredentialLength = CredLength;

#endif

    //
    // Compute the kerb credentials
    //

    if ((ClearPassword != NULL))
    {
        UNICODE_STRING UpcaseDomainName = {0};

        Status = RtlUpcaseUnicodeString(
                    &UpcaseDomainName,
                    DnsDomainName,
                    TRUE
                    );
        if (NT_SUCCESS(Status))
        {
            Status = KdcBuildPasswordList(
                        ClearPassword,
                        &KeySalt,
                        &UpcaseDomainName,
                        AccountType,
                        (PKERB_STORED_CREDENTIAL )KerbCredentials,
                        KerbCredentialLength,
                        TRUE,               // marshall
                        FALSE,              // don't include builtins
                        0,                  // no flags
                        Unknown,
                        (PKERB_STORED_CREDENTIAL *) NewKerbCredentials,
                        NewKerbCredentialLength
                        );
            RtlFreeUnicodeString(&UpcaseDomainName);
            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }
        }
    }

#ifdef _WIN64

    // for 64 - 32 bit compat, we pack the struct in 32bit compliant form


    Status = KdcPack32BitStoredCredential(
                (PKERB_STORED_CREDENTIAL)(*NewKerbCredentials),
                &Cred32,
                NewKerbCredentialLength
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    if ((*NewKerbCredentials) != NULL)
    {
        MIDL_user_free(*NewKerbCredentials);
        *NewKerbCredentials = Cred32;
    }

#endif

Cleanup:

    if (FreeSalt)
    {
        KerbFreeString(&KeySalt);
    }

    if (Cred64 != NULL)
    {
       MIDL_user_free(Cred64);
    }


    return(Status);
}

extern "C"
VOID
KdcFreeCredentials(
    IN PVOID Credentials
    )
{
    MIDL_user_free(Credentials);
}




//+-------------------------------------------------------------------------
//
//  Function:   InitializeChangeNotify
//
//  Synopsis:   KDC code for initializing password change notification
//              code.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


extern "C"
BOOLEAN
InitializeChangeNotify(
    )
{
    return(TRUE);
}




//+-------------------------------------------------------------------------
//
//  Function:   KdcTimeHasElapsed
//
//  Synopsis:   Returns TRUE if the specified amount of time has
//              elapsed since the specified start time
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

BOOLEAN
KdcTimeHasElapsed(
    IN LARGE_INTEGER StartTime,
    IN PLARGE_INTEGER Delta
    )
{
    LARGE_INTEGER CurrentTime;
    LARGE_INTEGER ElapsedTime;

    //
    // Check the password expiration time.
    //

    NtQuerySystemTime(&CurrentTime);
    ElapsedTime.QuadPart = CurrentTime.QuadPart - StartTime.QuadPart;

    //
    // If the window hasn't elapsed, we are done.
    //

    if ((ElapsedTime.QuadPart > 0) && (ElapsedTime.QuadPart < Delta->QuadPart))
    {
        return(FALSE);
    }
    return(TRUE);
}


//+-------------------------------------------------------------------------
//
//  Function:   KdcUpdateKrbtgtPassword
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

extern "C"
BOOLEAN
KdcUpdateKrbtgtPassword(
    IN PUNICODE_STRING DnsDomainName,
    IN PLARGE_INTEGER MaxPasswordAge
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    WCHAR PasswordBuffer[LM20_PWLEN];
    UNICODE_STRING PasswordString;
    ULONG Index;

    BOOLEAN Result = FALSE;


    if (KdcState != Running)
    {
        goto Cleanup;
    }

    //
    // Check the password expiration time.
    //

    if (!KdcTimeHasElapsed(
            SecData.KrbtgtPasswordLastSet(),
            MaxPasswordAge
            ))
    {
        goto Cleanup;
    }


    //
    // Build a random password
    //

    if (!CDGenerateRandomBits(
                (PBYTE) PasswordBuffer,
                sizeof(PasswordBuffer)
                ))
    {
        Status = STATUS_INTERNAL_ERROR;
        goto Cleanup;
    }

    //
    // Make sure there are no zero characters
    //

    for (Index = 0; Index < LM20_PWLEN ; Index++ )
    {
        if (PasswordBuffer[Index] == 0)
        {
            PasswordBuffer[Index] = (WCHAR) Index;
        }
    }
    PasswordString.Length = sizeof(PasswordBuffer);
    PasswordString.MaximumLength = PasswordString.Length;
    PasswordString.Buffer = PasswordBuffer;

    Status = SamIChangePasswordForeignUser(
                SecData.KdcServiceName(),
                &PasswordString,
                NULL,
                0                       // no desired access
                );

    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"Failed to set KRBTGT password: 0x%x\n", Status));
        Result = FALSE;
        goto Cleanup;
    }

    ReportServiceEvent(
        EVENTLOG_SUCCESS,
        KDCEVENT_KRBTGT_PASSWORD_CHANGED,
        0,                      // no data
        NULL,                   // no data
        0,                      // no strings
        NULL                    // no strings
        );

    Result = TRUE;

Cleanup:

    if (!Result && !NT_SUCCESS(Status))
    {

        ReportServiceEvent(
            EVENTLOG_ERROR_TYPE,
            KDCEVENT_KRBTGT_PASSWORD_CHANGE_FAILED,
            sizeof(NTSTATUS),
            &Status,
            0,                          // no strings
            NULL                        // no strings
            );


    }

    return(Result);
}


//+-------------------------------------------------------------------------
//
//  Function:   CredentialUpdateNotify
//
//  Synopsis:   This routine is called from SAMSRV in order to obtain
//              new kerberos credentials to be stored as supplemental
//              credentials when ever a user's password is set/changed.
//
//  Effects:    no global effect.
//
//  Arguments:
//
//  IN   ClearPassword      -- the clear text password
//  IN   OldCredentials     -- the previous kerberos credentials
//  IN   OldCredentialsSize -- size of OldCredentials
//  IN   UserAccountControl -- info about the user
//  IN   UPN                -- user principal name of the account
//  IN   UserName           -- the SAM account name of the account
//  IN   DnsDomainName      -- DNS domain name of the account
//  OUT  NewCredentials     -- space allocated for SAM containing
//                             the credentials based on the input parameters
//                             to be freed by CredentialUpdateFree
//  OUT  NewCredentialSize  -- size of NewCredentials
//
//
//  Requires:   no global requirements
//
//  Returns:    STATUS_SUCCESS, or resource error
//
//  Notes:      KDCSVC.DLL needs to be registered (in the registry) as a
//              package that SAM calls out to in order for this routine
//              to be involked.
//
//
//--------------------------------------------------------------------------
NTSTATUS
CredentialUpdateNotify (
    IN PUNICODE_STRING ClearPassword,
    IN PVOID OldCredentials,
    IN ULONG OldCredentialsSize,
    IN ULONG UserAccountControl,
    IN PUNICODE_STRING UPN,
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING NetbiosDomainName,
    IN PUNICODE_STRING DnsDomainName,
    OUT PVOID *NewCredentials,
    OUT ULONG *NewCredentialsSize
    )
{
    UNREFERENCED_PARAMETER( NetbiosDomainName );

    return KdcBuildKerbCredentialsFromPassword(ClearPassword,
                                               OldCredentials,
                                               OldCredentialsSize,
                                               UserAccountControl,
                                               UPN,
                                               UserName,
                                               DnsDomainName,
                                               NewCredentials,
                                               NewCredentialsSize);

}

VOID
CredentialUpdateFree(
    PVOID p
    )
//
// Free's the memory allocated by CredentialUpdateNotify
//
{
    if (p) {
        KdcFreeCredentials(p);
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   CredentialUpdateRegister
//
//  Synopsis:   This routine is called from SAMSRV in order to obtain
//              the name of the supplemental credentials pass into this package
//              when a password is changed or set.
//
//  Effects:    no global effect.
//
//  Arguments:
//
//  OUT CredentialName -- the name of credential tag in the supplemental
//                        credentials.  Note this memory is never freed
//                        by SAM, but must remain valid for the lifetime
//                        of the process.
//
//  Requires:   no global requirements
//
//  Returns:    TRUE
//
//  Notes:      KDCSVC.DLL needs to be registered (in the registry) as a
//              package that SAM calls out to in order for this routine
//              to be involked.
//
//
//--------------------------------------------------------------------------
BOOLEAN
CredentialUpdateRegister(
    OUT UNICODE_STRING *CredentialName
    )
{
    ASSERT(CredentialName);

    RtlInitUnicodeString(CredentialName, MICROSOFT_KERBEROS_NAME_W);

    return TRUE;
}


//
// This compile-time test verifies that CredentialUpdateNotify and
// CredentialUpdateRegister have the correct signature
//
#if DBG
PSAM_CREDENTIAL_UPDATE_NOTIFY_ROUTINE _TestCredentialUpdateNotify
                                                       = CredentialUpdateNotify;
PSAM_CREDENTIAL_UPDATE_FREE_ROUTINE _TestCredentialFreeRegister
                                                     = CredentialUpdateFree;
PSAM_CREDENTIAL_UPDATE_REGISTER_ROUTINE _TestCredentialUpdateRegister
                                                     = CredentialUpdateRegister;

#endif


#ifdef _WIN64
//
// Routines for packing and unpacking KERB_STORED_CREDENTIAL from DS
//






//+-------------------------------------------------------------------------
//
//  Function:  KdcUnpack32BitStoredCredential
//
//  Synopsis:  This function converts a 32 bit KERB_STORED_CREDENTIAL (read
//             from DS, likely) to a 64 bit KERB_STORED_CREDENTIAL
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
KdcUnpack32BitStoredCredential(
    IN PKERB_STORED_CREDENTIAL32 Cred32,
    IN OUT PKERB_STORED_CREDENTIAL * ppCred64,
    IN OUT PULONG pCredLength
    )
{

    PKERB_STORED_CREDENTIAL Cred64 = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG CredSize = sizeof(KERB_STORED_CREDENTIAL);
    ULONG CredCount = 0, Cred = 0, Offset = 0;
    PCHAR Where, Base;
    CHAR UNALIGNED * From;

    *pCredLength = 0;
    *ppCred64 = NULL;

    if (NULL == Cred32)
    {
       return STATUS_SUCCESS;
    }

    // Calculate Allocation size
    CredSize += ROUND_UP_COUNT(Cred32->DefaultSalt.MaximumLength, ALIGN_LPTSTR);

    CredSize += ((Cred32->CredentialCount + Cred32->OldCredentialCount) * sizeof(KERB_KEY_DATA));

    for (CredCount = 0; CredCount < (ULONG)(Cred32->CredentialCount + Cred32->OldCredentialCount); CredCount++)
    {
        CredSize += ROUND_UP_COUNT(Cred32->Credentials[CredCount].Key.keyvaluelength, ALIGN_LPTSTR);
        CredSize += ROUND_UP_COUNT(Cred32->Credentials[CredCount].Salt.MaximumLength, ALIGN_LPTSTR);
    }

    Cred64 = (PKERB_STORED_CREDENTIAL) MIDL_user_allocate(CredSize);

    if (NULL == Cred64)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // copy over data, remember, buffers packed in self-relative format
    Cred64->CredentialCount = Cred32->CredentialCount;
    Cred64->OldCredentialCount = Cred32->OldCredentialCount;
    Cred64->DefaultSalt.Length = Cred32->DefaultSalt.Length;
    Cred64->DefaultSalt.MaximumLength = Cred32->DefaultSalt.MaximumLength;
    Cred64->Flags = Cred32->Flags;
    Cred64->Revision = Cred32->Revision;

    Base = (PCHAR)Cred64;

    From = (CHAR UNALIGNED *) RtlOffsetToPointer(Cred32,Cred32->DefaultSalt.Buffer);

    // Note:  1 KERB_KEY_DATA struct is already calculated in
    //        the sizeof(KERB_STORED_CREDENTIAL)
    Offset = sizeof(KERB_STORED_CREDENTIAL) + ((CredCount) * sizeof(KERB_KEY_DATA));

    Where = RtlOffsetToPointer(Cred64, Offset);

    Cred64->DefaultSalt.Buffer = (PWSTR) (ULONG_PTR) Offset;
    RtlCopyMemory(
        Where,
        From,
        Cred32->DefaultSalt.Length
        );

    Where += ROUND_UP_COUNT(Cred64->DefaultSalt.Length, ALIGN_LPTSTR);

    // copy credentials
    for (Cred = 0; Cred < CredCount; Cred++)
    {
        Cred64->Credentials[Cred].Salt.Length = Cred32->Credentials[Cred].Salt.Length;
        Cred64->Credentials[Cred].Salt.MaximumLength = Cred32->Credentials[Cred].Salt.MaximumLength;

        From = (CHAR UNALIGNED *) RtlOffsetToPointer(Cred32, Cred32->Credentials[Cred].Salt.Buffer);
        if (Cred32->Credentials[Cred].Salt.Length != 0)
        {
           Cred64->Credentials[Cred].Salt.Buffer = (PWSTR) (ULONG_PTR) RtlPointerToOffset(Base,Where);
        }

        RtlCopyMemory(
            Where,
            From,
            Cred32->Credentials[Cred].Salt.Length
            );

        Where += ROUND_UP_COUNT(Cred64->Credentials[Cred].Salt.Length, ALIGN_LPTSTR);

        Cred64->Credentials[Cred].Key.keytype = Cred32->Credentials[Cred].Key.keytype;
        Cred64->Credentials[Cred].Key.keyvalue.length = Cred32->Credentials[Cred].Key.keyvaluelength;

        From = RtlOffsetToPointer(Cred32,Cred32->Credentials[Cred].Key.keyvaluevalue);
        Cred64->Credentials[Cred].Key.keyvalue.value = (PUCHAR) (ULONG_PTR) RtlPointerToOffset(Base,Where);

        RtlCopyMemory(
            Where,
            From,
            Cred32->Credentials[Cred].Key.keyvaluelength
            );

        Where += ROUND_UP_COUNT(Cred32->Credentials[Cred].Key.keyvaluelength, ALIGN_LPTSTR);
    }


    // TBD:  Validation code ?

   *ppCred64 = Cred64;
   *pCredLength = CredSize;

   return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:  KdcPack32BitStoredCredential
//
//  Synopsis:  This function converts a 64 bit KERB_STORED_CREDENTIAL
//             to a 32 bit KERB_STORED_CREDENTIAL
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes: Free the return value using MIDL_user_free()
//
//
//--------------------------------------------------------------------------
NTSTATUS
KdcPack32BitStoredCredential(
   IN PKERB_STORED_CREDENTIAL Cred64,
   OUT PKERB_STORED_CREDENTIAL32 * ppCred32,
   OUT PULONG pCredSize
   )
{

   ULONG Offset, CredSize = sizeof(KERB_STORED_CREDENTIAL32);
   ULONG CredCount, Cred;
   PKERB_STORED_CREDENTIAL32 Cred32 = NULL;
   PCHAR Where, From, Base;

   *ppCred32 = NULL;
   *pCredSize = 0;

   if (Cred64 == NULL)
   {
       return STATUS_SUCCESS;
   }

   // Get the expected size of the resultant blob
   CredSize += ((Cred64->CredentialCount + Cred64->OldCredentialCount) *
                  KERB_KEY_DATA32_SIZE);


   CredSize += Cred64->DefaultSalt.MaximumLength;
   for (CredCount = 0;
        CredCount < (ULONG) (Cred64->CredentialCount+Cred64->OldCredentialCount);
        CredCount++)
   {
      CredSize += Cred64->Credentials[CredCount].Salt.MaximumLength;
      CredSize += Cred64->Credentials[CredCount].Key.keyvalue.length;
   }

   Cred32 = (PKERB_STORED_CREDENTIAL32) MIDL_user_allocate(CredSize);

   if (NULL == Cred32)
   {
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   Base = (PCHAR) Cred32;

   // Copy over USHORTS
   Cred32->Revision = Cred64->Revision;
   Cred32->Flags = Cred64->Flags;
   Cred32->CredentialCount = Cred64->CredentialCount;
   Cred32->OldCredentialCount = Cred64->OldCredentialCount;

   // Copy over salt
   Cred32->DefaultSalt.Length = Cred64->DefaultSalt.Length;
   Cred32->DefaultSalt.MaximumLength = Cred64->DefaultSalt.MaximumLength;

   Offset = KERB_STORED_CREDENTIAL32_SIZE + ((CredCount+1) * KERB_KEY_DATA32_SIZE);

   Where = RtlOffsetToPointer(Base,Offset);
   From = RtlOffsetToPointer(Cred64, Cred64->DefaultSalt.Buffer);
   Cred32->DefaultSalt.Buffer = RtlPointerToOffset(Base,Where);

   RtlCopyMemory(
         Where,
         From,
         Cred64->DefaultSalt.Length
         );

   Where += Cred64->DefaultSalt.Length;

   // Copy over creds (KERB_KEY_DATA)
   for (Cred = 0; Cred < CredCount;Cred++)
   {
      Cred32->Credentials[Cred].Salt.Length = Cred64->Credentials[Cred].Salt.Length;
      Cred32->Credentials[Cred].Salt.MaximumLength = Cred64->Credentials[Cred].Salt.MaximumLength;
      From = RtlOffsetToPointer(Cred64, Cred64->Credentials[Cred].Salt.Buffer);

      // Only add in buffer pointer if there's data to copy.
      if (Cred32->Credentials[Cred].Salt.Length != 0)
      {
         Cred32->Credentials[Cred].Salt.Buffer = RtlPointerToOffset(Base,Where);
      }

      RtlCopyMemory(
            Where,
            From,
            Cred64->Credentials[Cred].Salt.Length
            );

      Where += Cred64->Credentials[Cred].Salt.Length;

      // Keys
      Cred32->Credentials[Cred].Key.keytype = Cred64->Credentials[Cred].Key.keytype ;
      Cred32->Credentials[Cred].Key.keyvaluelength = Cred64->Credentials[Cred].Key.keyvalue.length;
      From = RtlOffsetToPointer(Cred64, Cred64->Credentials[Cred].Key.keyvalue.value);

      RtlCopyMemory(
            Where,
            From,
            Cred64->Credentials[Cred].Key.keyvalue.length
            );

      Cred32->Credentials[Cred].Key.keyvaluevalue = RtlPointerToOffset(Base,Where);
      Where += Cred64->Credentials[Cred].Key.keyvalue.length;
   }

   *ppCred32 = Cred32;
   *pCredSize = CredSize;

   return STATUS_SUCCESS;

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\server\refer.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        refer.h
//
// Contents:    Structurs and prototypes for interdomain referrals
//
//
// History:     26-Mar-1997     MikeSw          Created
//
//------------------------------------------------------------------------

#ifndef __REFER_H__
#define __REFER_H__

extern LIST_ENTRY KdcDomainList;
extern LIST_ENTRY KdcReferralCache;
extern RTL_CRITICAL_SECTION KdcDomainListLock;

#define KdcLockDomainList() (RtlEnterCriticalSection(&KdcDomainListLock))
#define KdcUnlockDomainList() (RtlLeaveCriticalSection(&KdcDomainListLock))

//
// For NT5 domains in the enterprise the dns name will contain the
// real DNS name. For non- tree domains it will contain the name from
// the trusted domain object
//

#define KDC_DOMAIN_US           0x0001
#define KDC_DOMAIN_TREE_ROOT    0x0002
#define KDC_TRUST_INBOUND       0x0004

// cache flags
#define KDC_NO_ENTRY            0x0000
#define KDC_UNTRUSTED_REALM     0x0001
#define KDC_TRUSTED_REALM       0x0002

typedef struct _KDC_DOMAIN_INFO {
    LIST_ENTRY Next;
    UNICODE_STRING DnsName;
    UNICODE_STRING NetbiosName;
    struct _KDC_DOMAIN_INFO * ClosestRoute;     // Points to referral target for this domain or NULL if unreachable
    ULONG Flags;
    ULONG Attributes;
    ULONG Type;
    LONG References;

    //
    // Types used during building the tree
    //

    struct _KDC_DOMAIN_INFO * Parent;
    ULONG Touched;
    PSID Sid;
} KDC_DOMAIN_INFO, *PKDC_DOMAIN_INFO;


typedef struct _REFERRAL_CACHE_ENTRY {
    LIST_ENTRY ListEntry;
    LONG References;
    TimeStamp EndTime;
    UNICODE_STRING RealmName;
    ULONG CacheFlags;
} REFERRAL_CACHE_ENTRY, *PREFERRAL_CACHE_ENTRY;


VOID
KdcFreeReferralCache(
    IN PLIST_ENTRY ReferralCache
    );

KERBERR
KdcCheckForCrossForestReferral(
    OUT PKDC_TICKET_INFO ReferralTarget,
    OUT OPTIONAL PUNICODE_STRING ReferralRealm,
    OUT PKERB_EXT_ERROR pExtendedError,
    IN PUNICODE_STRING DestinationDomain,
    IN ULONG NameFlags
    );

KERBERR
KdcFindReferralTarget(
    OUT PKDC_TICKET_INFO ReferralTarget,
    OUT OPTIONAL PUNICODE_STRING ReferralRealm,
    OUT PKERB_EXT_ERROR pExtendedError,
    IN PUNICODE_STRING DestinationDomain,
    IN BOOLEAN ExactMatch,
    IN ULONG   NameFlags
    );

KERBERR
KdcGetTicketInfoForDomain(
    OUT PKDC_TICKET_INFO TicketInfo,
    OUT PKERB_EXT_ERROR pExtendedError,
    IN PKDC_DOMAIN_INFO DomainInfo,
    IN KDC_DOMAIN_INFO_DIRECTION Direction
    );

KERBERR
KdcLookupDomainName(
    OUT PKDC_DOMAIN_INFO * DomainInfo,
    IN PUNICODE_STRING DomainName,
    IN PLIST_ENTRY DomainList
    );

KERBERR
KdcLookupDomainRoute(
    OUT PKDC_DOMAIN_INFO * DomainInfo,
    OUT PKDC_DOMAIN_INFO * ClosestRoute,
    IN PUNICODE_STRING DomainName,
    IN PLIST_ENTRY DomainList
    );

NTSTATUS
KdcBuildDomainTree(
    );

ULONG __stdcall
KdcReloadDomainTree(
    PVOID Dummy
    );

fLsaTrustChangeNotificationCallback KdcTrustChangeCallback;

VOID
KdcFreeDomainList(
    IN PLIST_ENTRY DomainList
    );

VOID
KdcDereferenceDomainInfo(
    IN PKDC_DOMAIN_INFO DomainInfo
    );

VOID
KdcLockDomainListFn(
   );

VOID
KdcUnlockDomainListFn(
   );

#endif // __REFER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\server\pkserv.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1997
//
// File:        pkserv.cxx
//
// Contents:    Server side public key support for Kerberos
//
//
// History:     24-Nov-1997     MikeSw          Created
//
//------------------------------------------------------------------------

#include "kdcsvr.hxx"
#include <wininet.h>    // for SECURITY_FLAG_xxx
#include <sclogon.h>    // ScHelperXXX
#include <cryptui.h>    // for CryptUiXXX
#include <certca.h>     // for CA*XXX

#define FILENO FILENO_PKSERV
//
// This is the cert store containing the CTL used to verify client certificates
//

HCERTSTORE KdcCertStore = NULL;
HCRYPTPROV KdcClientProvider = NULL;

PCCERT_CONTEXT GlobalKdcCert = NULL;
HANDLE   KdcCertStoreChangeEvent = NULL;
TimeStamp KdcLastChangeEventTime;

RTL_CRITICAL_SECTION KdcGlobalCertCritSect;
BOOLEAN              KdcGlobalCertCritSectInitialized = FALSE;

HANDLE KdcCertStoreWait = NULL;
BOOLEAN KdcPKIInitialized = FALSE;

BOOLEAN Kdc3DesSupported = TRUE;
HANDLE KdcCaNotificationHandle = NULL;
#define KDC_ROOT_STORE L"ROOT"
#define KDC_PRIVATE_MY_STORE L"MY"

#define MAX_TEMPLATE_NAME_VALUE_SIZE             80 // sizeof (CERT_NAME_VALUE) + wcslen(SmartcardLogon)

KERB_OBJECT_ID KdcSignatureAlg[10];


NTSTATUS
KdcGetKdcCertificate(PCCERT_CONTEXT *KdcCert);


//+-------------------------------------------------------------------------
//
//  Function:   VerifyScLogonEku
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  IN: A certificate context
//
//  Requires:   TRUE is the certificate has a smart card logon EKU; or its template
//              name is DomainController
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

BOOL 
VerifyScLogonEku(
            IN PCCERT_CONTEXT pCertContext,
            IN BOOLEAN        KdcCertificate
            )
{
    BOOL                fDCCert=FALSE;
    CERT_EXTENSION      *pExtension = NULL;
    DWORD               cbSize = 0;
    DWORD               dwIndex = 0;

    PCERT_NAME_VALUE    pTemplateName = NULL;
    CERT_ENHKEY_USAGE   *pEnhKeyUsage=NULL;

    if(NULL == (pCertContext->pCertInfo))
        goto Cleanup;


    //find the EKU extension
    pExtension =CertFindExtension(szOID_ENHANCED_KEY_USAGE,
                                  pCertContext->pCertInfo->cExtension,
                                  pCertContext->pCertInfo->rgExtension);

    if(pExtension)
    {
        if(CryptDecodeObject(X509_ASN_ENCODING,
                          X509_ENHANCED_KEY_USAGE,
                          pExtension->Value.pbData,
                          pExtension->Value.cbData,
                          0,
                          NULL,
                          &cbSize))

        {
            pEnhKeyUsage=(CERT_ENHKEY_USAGE *)MIDL_user_allocate(cbSize);

            if(pEnhKeyUsage)
            {
                if(CryptDecodeObject(X509_ASN_ENCODING,
                                  X509_ENHANCED_KEY_USAGE,
                                  pExtension->Value.pbData,
                                  pExtension->Value.cbData,
                                  0,
                                  pEnhKeyUsage,
                                  &cbSize))
                {
                    for(dwIndex=0; dwIndex < pEnhKeyUsage->cUsageIdentifier; dwIndex++)
                    {
                        if(0 == strcmp(szOID_KP_SMARTCARD_LOGON,
                                       (pEnhKeyUsage->rgpszUsageIdentifier)[dwIndex]))
                        {
                            //we find it
                            fDCCert=TRUE;
                            break;
                        }
                    }
                }
            }
        }
    }

    //
    //check if we have found it via the enhanced key usage extension
    //
    if (( fDCCert ) ||
        (!KdcCertificate && !fDCCert))
    {   
        goto Cleanup;
    }                                 


    //
    // For DC certificates, its also OK to have the W2K certtype extension in
    // place of the sclogon oid - this doesn't apply to client certificates,
    // however.
    //


    //find the V1 template extension
    pExtension =CertFindExtension(szOID_ENROLL_CERTTYPE_EXTENSION,
                                  pCertContext->pCertInfo->cExtension,
                                  pCertContext->pCertInfo->rgExtension);
    if(pExtension == NULL)
        goto Cleanup;


    cbSize=0;

    if(!CryptDecodeObject(X509_ASN_ENCODING,
                          X509_UNICODE_ANY_STRING,
                          pExtension->Value.pbData,
                          pExtension->Value.cbData,
                          0,
                          NULL,
                          &cbSize))

        goto Cleanup;

    pTemplateName = (CERT_NAME_VALUE *)MIDL_user_allocate(cbSize);

    if(NULL == pTemplateName)
        goto Cleanup;

    if(!CryptDecodeObject(X509_ASN_ENCODING,
                          X509_UNICODE_ANY_STRING,
                          pExtension->Value.pbData,
                          pExtension->Value.cbData,
                          0,
                          pTemplateName,
                          &cbSize))

        goto Cleanup;

    if(wcscmp((LPWSTR)  pTemplateName->Value.pbData, wszCERTTYPE_DC) != 0)
        goto Cleanup;

    fDCCert=TRUE;


Cleanup:

    if(pEnhKeyUsage)
        MIDL_user_free(pEnhKeyUsage);

    if(pTemplateName)
        MIDL_user_free(pTemplateName);

    return fDCCert;

}


//+-------------------------------------------------------------------------
//
//  Function:   KdcCheckCertificate
//
//  Synopsis:   a helper routine to verify the certificate. It will check
//              CRLs, CTLs
//
//  Effects:
//
//  Arguments:
//          CertContext - the certificate to check
//          EmbeddedUPNOk - returns TRUE if the certificate can
//                           be translated to a user by looking at the
//                           subject name.
//                           returns FALSE if the certificate must be
//                           mapped by looking in the user's mapped certificate
//                           ds attribute.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KdcCheckCertificate(
    IN PCCERT_CONTEXT  CertContext,
    IN OUT PKERB_EXT_ERROR pExtendedError,
    IN OUT OPTIONAL PCERT_CHAIN_POLICY_STATUS FinalChainStatus,
    IN BOOLEAN KdcCert
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    CERT_CHAIN_PARA ChainParameters = {0};
    LPSTR Usage = (KdcCert ? KERB_PKINIT_KDC_CERT_TYPE : KERB_PKINIT_CLIENT_CERT_TYPE);
    PCCERT_CHAIN_CONTEXT ChainContext = NULL;
    CERT_CHAIN_POLICY_STATUS PolicyStatus ={0};

    ChainParameters.cbSize = sizeof(CERT_CHAIN_PARA);
    ChainParameters.RequestedUsage.dwType = USAGE_MATCH_TYPE_AND;
    ChainParameters.RequestedUsage.Usage.cUsageIdentifier = 1;
    ChainParameters.RequestedUsage.Usage.rgpszUsageIdentifier = &Usage;

    
    if (!CertGetCertificateChain(
                          HCCE_LOCAL_MACHINE,
                          CertContext,
                          NULL,                 // evaluate at current time
                          NULL,                 // no additional stores
                          &ChainParameters,
                          CERT_CHAIN_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT,
                          NULL,                 // reserved
                          &ChainContext
                          ))
    {
        D_DebugLog((DEB_WARN,"Failed to verify certificate chain: %0x%x\n",GetLastError()));
        KerbErr = KDC_ERR_CLIENT_NOT_TRUSTED;
        goto Cleanup;

    }
    else
    {
        CERT_CHAIN_POLICY_PARA ChainPolicy;
        ZeroMemory(&ChainPolicy, sizeof(ChainPolicy));

        ChainPolicy.cbSize = sizeof(ChainPolicy);

        ZeroMemory(&PolicyStatus, sizeof(PolicyStatus));
        PolicyStatus.cbSize = sizeof(PolicyStatus);
        PolicyStatus.lChainIndex = -1;
        PolicyStatus.lElementIndex = -1;


        if (!CertVerifyCertificateChainPolicy(
                                        CERT_CHAIN_POLICY_NT_AUTH,
                                        ChainContext,
                                        &ChainPolicy,
                                        &PolicyStatus))
        {
           D_DebugLog((DEB_WARN,"CertVerifyCertificateChainPolicy failure: %0x%x\n", GetLastError()));
           KerbErr = KDC_ERR_CLIENT_NOT_TRUSTED;
           goto Cleanup;
        }

        if( PolicyStatus.dwError != S_OK )
        {
            D_DebugLog((DEB_WARN,"CertVerifyCertificateChainPolicy - Chain Status failure: %0x%x\n",PolicyStatus.dwError));
            KerbErr = KDC_ERR_CLIENT_NOT_TRUSTED;
            goto Cleanup;
        }

        //
        // Verify that the sclogon oid is in the client certificate, alternately
        // that the sclogon oid or template name are in kdc certificates.
        //
        if (!VerifyScLogonEku( CertContext, KdcCert))
        { 
           DebugLog((DEB_ERROR, "Cert missing SCLogon EKU\n"));
           PolicyStatus.dwError = (DWORD) CERT_E_WRONG_USAGE;
           KerbErr = KDC_ERR_CLIENT_NOT_TRUSTED;
           goto Cleanup;

        }  

    }

Cleanup:
    if (PolicyStatus.dwError != S_OK)
    {
       FILL_EXT_ERROR_EX(pExtendedError, PolicyStatus.dwError,FILENO,__LINE__);
       if (ARGUMENT_PRESENT(FinalChainStatus))
       {
           RtlCopyMemory(
               FinalChainStatus,
               &PolicyStatus,
               sizeof(CERT_CHAIN_POLICY_STATUS)
               );
       }
    }

    if (ChainContext != NULL)
    {
        CertFreeCertificateChain(ChainContext);
    }

    return(KerbErr);
}

//+-------------------------------------------------------------------------
//
//  Function:   KdcVerifyClientCertName
//
//  Synopsis:   Verifies that the mapping of a client's cert name matches
//              the mapping of the client name from the AS request
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------



KERBERR
KdcVerifyClientCertName(
    IN PCCERT_CONTEXT ClientCert,
    IN PKDC_TICKET_INFO ClientTicketInfo
    )
{
    UNICODE_STRING NameString = {0};
    UNICODE_STRING ClientRealm = {0};
    PKERB_INTERNAL_NAME ClientName = NULL;
    KDC_TICKET_INFO TicketInfo = {0};
    BOOLEAN ClientReferral = FALSE;
    KERBERR KerbErr = KDC_ERR_NONE;
    KERB_EXT_ERROR   ExtendedError;

    //
    // Get the client name from the cert
    //
    if(STATUS_SUCCESS != KerbGetPrincipalNameFromCertificate(ClientCert, &NameString))
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    D_DebugLog((DEB_TRACE,"Email name from certificate is %wZ\n",&NameString));

    KerbErr = KerbConvertStringToKdcName(
                &ClientName,
                &NameString
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    ClientName->NameType = KRB_NT_ENTERPRISE_PRINCIPAL;

    //
    // Now crack the name & see if it refers to us
    //

    //
    // Normalize the client name.
    //

    KerbErr = KdcNormalize(
                ClientName,
                NULL,
                NULL,
                NULL,
                KDC_NAME_CLIENT | KDC_NAME_FOLLOW_REFERRALS | KDC_NAME_CHECK_GC,
                FALSE,                 // do not restrict user accounts (user2user)
                &ClientReferral,
                &ClientRealm,
                &TicketInfo,
                &ExtendedError,
                NULL,                   // no user handle
                0L,                     // no fields to fetch
                0L,                     // no extended fields
                NULL,                   // no user all
                NULL                    // no group membership
                );
    if (!KERB_SUCCESS(KerbErr) )
    {
        DebugLog((DEB_ERROR,"Failed to normalize name "));
        KerbPrintKdcName(DEB_ERROR,ClientName);
        goto Cleanup;
    }

    //
    // If this is a referral, return an error and the true realm name
    // of the client
    //

    if (ClientReferral)
    {
        KerbErr = KDC_ERR_WRONG_REALM;
        DebugLog((DEB_WARN,"Client tried to logon to account in another realm\n"));
        goto Cleanup;
    }

    //
    // Verify the client cert matches the client
    //

    if (TicketInfo.UserId != ClientTicketInfo->UserId)
    {
        DebugLog((DEB_ERROR,"Cert name doesn't match user name: %wZ, %wZ\n",
            &NameString, &ClientTicketInfo->AccountName));
        KerbErr = KDC_ERR_CLIENT_NAME_MISMATCH;
        goto Cleanup;
    }

Cleanup:

    KerbFreeString( &NameString);
    KerbFreeKdcName( &ClientName );
    FreeTicketInfo( &TicketInfo );
    return(KerbErr);


}


//+-------------------------------------------------------------------------
//
//  Function:   KdcConvertNameString
//
//  Synopsis:   Converts the cr-lf to , in a dn
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


void
KdcConvertNameString(
    IN PUNICODE_STRING Name,
    IN WCHAR ReplacementChar
    )
{
    PWCHAR Comma1, Comma2;

    //
    // Scan through the name, converting "\r\n" to the replacement char.  This
    // should be done by the CertNameToStr APIs, but that won't happen for
    // a while.
    //

    Comma1 = Comma2 = Name->Buffer ;
    while ( *Comma2 )
    {
        *Comma1 = *Comma2 ;

        if ( *Comma2 == L'\r' )
        {
            if ( *(Comma2 + 1) == L'\n' )
            {
                *Comma1 = ReplacementChar;
                Comma2++ ;
            }
        }

        Comma1++;
        Comma2++;
    }

    *Comma1 = L'\0';

    Name->Length = (USHORT) wcslen( Name->Buffer ) * sizeof( WCHAR );
}


//+-------------------------------------------------------------------------
//
//  Function:   KdcFreePkiAuditInfo
//
//  Synopsis:   Free KDC_PKI_AUDIT_INFO
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:    
//
//  Notes:      
//
//
//---------------------------------------------------------------------------

VOID
KdcFreePkiAuditInfo(
    IN PKDC_PKI_AUDIT_INFO AuditInfo
    )
{
    KerbFreeString( &AuditInfo->CertIssuerName );
    KerbFreeString( &AuditInfo->CertSerialNumber );
    KerbFreeString( &AuditInfo->CertThumbprint );  
}



//+-------------------------------------------------------------------------
//
//  Function:   KdcFillPkiAuditInfo
//
//  Synopsis:   Gets the cert hash, issuer, etc for a cert.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:    TRUE if it does, false if it doesn't
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
KdcFillPkiAuditInfo(
        IN PCCERT_CONTEXT Cert,
        IN OUT PKDC_PKI_AUDIT_INFO AuditInfo
        )
{

    NTSTATUS Status = STATUS_SUCCESS;    

    Status = KerbCreateUnicodeStringFromBlob(
                    Cert->pCertInfo->SerialNumber.pbData,
                    Cert->pCertInfo->SerialNumber.cbData,
                    &AuditInfo->CertSerialNumber,
                    FALSE
                    );

    if (!NT_SUCCESS( Status ))
    {
        DebugLog((DEB_ERROR, "KerbCreateUnicodeStringFromBlob failed\n"));
        goto Cleanup;
    }       

    Status = KerbGetCertificateHashString(
                    Cert,
                    &AuditInfo->CertThumbprint
                    );

    if (!NT_SUCCESS( Status ))
    {
        DebugLog((DEB_ERROR, "KerbGetCertificateHashString failed\n"));
        goto Cleanup;
    }

    Status = KerbGetCertificateIssuer(
                Cert,
                &AuditInfo->CertIssuerName
                );

    if (!NT_SUCCESS( Status ))
    {
        DebugLog((DEB_ERROR, "KerbGetCertificateIssuer failed\n"));
        goto Cleanup;
    }

Cleanup:

    if (!NT_SUCCESS( Status ))
    {
        KdcFreePkiAuditInfo( AuditInfo );
    }
    
    return Status;
}
                  


//+-------------------------------------------------------------------------
//
//  Function:   KdcCheckForEtype
//
//  Synopsis:   Checks if a client supports a particular etype
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:    TRUE if it does, false if it doesn't
//
//  Notes:
//
//
//--------------------------------------------------------------------------

BOOLEAN
KdcCheckForEtype(
    IN PKERB_CRYPT_LIST CryptList,
    IN ULONG Etype
    )
{
    PKERB_CRYPT_LIST List = CryptList;

    while (List != NULL)
    {
        if ((ULONG) List->value == Etype)
        {
            return(TRUE);
        }
        List=List->next;
    }

    return(FALSE);
}


//+-------------------------------------------------------------------------
//
//  Function:   KdcCheckPkinitPreAuthData
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBERR
KdcCheckPkinitPreAuthData(
    IN PKDC_TICKET_INFO ClientTicketInfo,
    IN SAMPR_HANDLE UserHandle,
    IN OPTIONAL PKERB_PA_DATA_LIST PreAuthData,
    IN PKERB_KDC_REQUEST_BODY ClientRequest,
    OUT PKERB_PA_DATA_LIST * OutputPreAuthData,
    OUT PULONG Nonce,
    OUT PKERB_ENCRYPTION_KEY EncryptionKey,
    OUT PUNICODE_STRING TransitedRealm,
    OUT PKDC_PKI_AUDIT_INFO PkiAuditInfo,
    OUT PKERB_EXT_ERROR pExtendedError
    )
{
    NTSTATUS Status;
    KERBERR KerbErr = KDC_ERR_NONE;
    PKERB_PA_PK_AS_REQ PkAsReq = NULL;
    PKERB_PA_PK_AS_REQ2 PkAsReq2 = NULL;
    PKERB_CERTIFICATE UserCert = NULL;
    PCCERT_CONTEXT CertContext = NULL;
    PCCERT_CONTEXT KdcCert = NULL;
    HCRYPTKEY ClientKey = NULL;
    PBYTE PackedAuthenticator = NULL;
    ULONG PackedAuthenticatorSize;
    PBYTE PackedKeyPack = NULL;
    ULONG PackedKeyPackSize;
    PBYTE SignedKeyPack = NULL;
    ULONG SignedKeyPackSize;
    PKERB_SIGNATURE Signature = NULL;
    PKERB_PK_AUTHENTICATOR PkAuthenticator = NULL;
    CERT_CHAIN_POLICY_STATUS FinalChainStatus = {0};
    UNICODE_STRING ClientKdcName = {0};
    ULONG ClientKdcNameType;
    LARGE_INTEGER ClientTime;
    LARGE_INTEGER CurrentTime;
    PULONG EtypeArray = NULL;
    ULONG EtypeCount = 0;
    ULONG CommonEtype;
    KERB_SIGNED_REPLY_KEY_PACKAGE KeyPack = {0};
    KERB_REPLY_KEY_PACKAGE ReplyKey = {0};
    HCRYPTPROV KdcProvider = NULL;
    BOOL FreeProvider = FALSE;
#define KERB_PK_MAX_SIGNATURE_SIZE 128
    BYTE PkSignature[KERB_PK_MAX_SIGNATURE_SIZE];
    ULONG PkSignatureLength = KERB_PK_MAX_SIGNATURE_SIZE;
    ULONG RequiredSize = 0;
    PBYTE EncryptedKeyPack = NULL;
    PKERB_PA_DATA_LIST PackedPkAsRep = NULL;
    PBYTE PackedKey = NULL;
    ULONG PackedKeySize = 0;
    KERB_ENCRYPTION_KEY TempKey = {0};
    PKERB_CERTIFICATE_LIST CertList = NULL;
    CRYPT_ALGORITHM_IDENTIFIER CryptAlg = {0};
    PKERB_AUTH_PACKAGE AuthPack = NULL;
    BOOLEAN Used3Des = FALSE;

    //
    // Prepare the output variables
    //

    *OutputPreAuthData = NULL;
    RtlZeroMemory(
        EncryptionKey,
        sizeof(KERB_ENCRYPTION_KEY)
        );
    *Nonce = 0;

    //
    // If we don't do this preauth, return such
    //

    Status = KdcGetKdcCertificate(&KdcCert);
    if (!NT_SUCCESS(Status))
    {

       //
       // Log an event
       //
       ReportServiceEvent(
               EVENTLOG_ERROR_TYPE,
               KDCEVENT_NO_KDC_CERTIFICATE,
               0,
               NULL,
               0
               );

       FILL_EXT_ERROR_EX(pExtendedError, STATUS_PKINIT_FAILURE, FILENO, __LINE__);
       return(KDC_ERR_PADATA_TYPE_NOSUPP);
    }


    GetSystemTimeAsFileTime((PFILETIME) &CurrentTime );

    //
    // First, unpack the outer KRB-PA-PK-AS-REQ
    //


    KerbErr = KerbUnpackData(
                PreAuthData->value.preauth_data.value,
                PreAuthData->value.preauth_data.length,
                KERB_PA_PK_AS_REQ_PDU,
                (PVOID *) &PkAsReq
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        //
        // Try the older variation
        //

        KerbErr = KerbUnpackData(
                    PreAuthData->value.preauth_data.value,
                    PreAuthData->value.preauth_data.length,
                    KERB_PA_PK_AS_REQ2_PDU,
                    (PVOID *) &PkAsReq2
                    );

        if (!KERB_SUCCESS(KerbErr))
        {
            DebugLog((DEB_ERROR,"Failed to unpack PA-PK-AS-REQ(2): 0x%x\n",KerbErr));
            goto Cleanup;
        }

    }

    if (PkAsReq != NULL)
    {
        //
        // Verify the signature
        //

        Status = ScHelperVerifyPkcsMessage(
                    NULL,
                    KdcClientProvider,
                    PkAsReq->signed_auth_pack.value,
                    PkAsReq->signed_auth_pack.length,
                    PackedAuthenticator,
                    &PackedAuthenticatorSize,
                    NULL        // don't return certificate context
                    );
        if ((Status != ERROR_MORE_DATA) && (Status != STATUS_SUCCESS))
        {
            DebugLog((DEB_ERROR,"Failed to verify message: %x\n",Status));
            FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__);
            KerbErr = KRB_AP_ERR_MODIFIED;
            goto Cleanup;
        }

        PackedAuthenticator = (PBYTE) MIDL_user_allocate(PackedAuthenticatorSize);
        if (PackedAuthenticator == NULL)
        {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }

        Status = ScHelperVerifyPkcsMessage(
                    NULL,
                    KdcClientProvider,
                    PkAsReq->signed_auth_pack.value,
                    PkAsReq->signed_auth_pack.length,
                    PackedAuthenticator,
                    &PackedAuthenticatorSize,
                    &CertContext
                    );
        if (Status != STATUS_SUCCESS)
        {
            DebugLog((DEB_ERROR,"Failed to verify message: %x\n",Status));
            FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__);
            KerbErr = KRB_AP_ERR_MODIFIED;
            goto Cleanup;
        }

        //
        // Unpack the auth package
        //

        KerbErr = KerbUnpackData(
                    PackedAuthenticator,
                    PackedAuthenticatorSize,
                    KERB_AUTH_PACKAGE_PDU,
                    (PVOID *)&AuthPack
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }

        PkAuthenticator = &AuthPack->pk_authenticator;

    }
    else
    {
        DsysAssert(PkAsReq2 != NULL);

        //
        // Get the user certificate & verify
        //

        if ((PkAsReq2->bit_mask & user_certs_present) == 0)
        {
            DebugLog((DEB_ERROR,"Client tried to use pkinit w/o client cert\n"));
            KerbErr = KDC_ERR_BADOPTION;
            goto Cleanup;
        }

        //
        // Just use the first of the certificates
        //

        UserCert = &PkAsReq2->user_certs->value;

        //
        // We only handle x509 certificates
        //

        if (UserCert->cert_type != KERB_CERTIFICATE_TYPE_X509)
        {
            DebugLog((DEB_ERROR,"User supplied bad cert type: %d\n",UserCert->cert_type));
            KerbErr = KDC_ERR_BADOPTION;
            goto Cleanup;
        }

        //
        // Decode the certificate.
        //

        CertContext = CertCreateCertificateContext(
                        X509_ASN_ENCODING,
                        UserCert->cert_data.value,
                        UserCert->cert_data.length
                        );
        if (CertContext == NULL)
        {
            Status = GetLastError();
            DebugLog((DEB_ERROR,"Failed to create certificate context: 0x%x\n",Status));
            FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__);
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }



        //
        // Verify the authenticator
        //

        Signature = &PkAsReq2->signed_auth_pack.auth_package_signature;

        //
        // Now import the key from the certificate
        //

        if (!CryptImportPublicKeyInfo(
                KdcClientProvider,
                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                &CertContext->pCertInfo->SubjectPublicKeyInfo,
                &ClientKey
                ))
        {
            DebugLog((DEB_ERROR,"Failed to import public key: 0x%x\n",GetLastError()));
            FILL_EXT_ERROR(pExtendedError, GetLastError(), FILENO, __LINE__);
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }

        //
        // Encode the data to be verified
        //

        KerbErr = KerbPackData(
                    &PkAsReq2->signed_auth_pack.auth_package,
                    KERB_AUTH_PACKAGE_PDU,
                    &PackedAuthenticatorSize,
                    &PackedAuthenticator
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }

        //
        // Verify the signature on the message
        //

        if (!KerbCompareObjectIds(
                Signature->signature_algorithm.algorithm,
                KdcSignatureAlg
                ))
        {
            DebugLog((DEB_ERROR,"Unsupported signature algorithm (not MD5)\n"));
            KerbErr = KDC_ERR_SUMTYPE_NOSUPP;
            goto Cleanup;
        }

        Status = ScHelperVerifyMessage(
                    NULL,                           // no logon info
                    KdcClientProvider,
                    CertContext,
                    KERB_PKINIT_SIGNATURE_ALG,
                    PackedAuthenticator,
                    PackedAuthenticatorSize,
                    Signature->pkcs_signature.value,
                    Signature->pkcs_signature.length / 8            // because it is a bit string
                    );
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR,"Failed to verify message: 0x%x\n",Status));
            FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__);
            KerbErr = KDC_ERR_INVALID_SIG;
            goto Cleanup;
        }

        //
        // Now check the information in the authenticator itself.
        //

        PkAuthenticator = &PkAsReq2->signed_auth_pack.auth_package.pk_authenticator;

    }


    //
    // Fill in the audit information for the certificate - this is non-fatal, though...
    //
    KerbErr = KdcFillPkiAuditInfo(
                CertContext,
                PkiAuditInfo
                );


    if (!KERB_SUCCESS( KerbErr ))
    {
        DebugLog((DEB_ERROR, "Failed to build audit information %x\n", KerbErr));
        DsysAssert(FALSE);
    }

    

    //
    // Call a helper routine to verify the certificate. It will check
    // CRLs, CTLs,
    //

    KerbErr = KdcCheckCertificate(
                CertContext,
                pExtendedError,
                &FinalChainStatus,
                FALSE // not a kdc certificate
                );


    if (!KERB_SUCCESS(KerbErr))
    {
        //
        // Dumb this down for release?  
        //
        KdcReportBadClientCertificate(
            &ClientTicketInfo->AccountName,
            &FinalChainStatus,
            sizeof(FinalChainStatus) - sizeof(void*),
            pExtendedError->status
            );
        
        DebugLog((DEB_ERROR,"Failed to check CLIENT certificate: 0x%x\n",KerbErr));
        goto Cleanup;
    }

    //
    // Verify the cert is for the right client
    //
    KerbErr = KdcVerifyClientCertName(
                    CertContext,
                    ClientTicketInfo
                    );

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"KDC failed to verify client's identity from cert\n"));
        goto Cleanup;
    }

#ifdef later
    //
    // BUG 455112: this code breaks MIT KDCs, which can't handle a strange
    // x.500 name in the transited field. So, for NT5, disable the code
    //

    //
    // Put the issuer name in as a transited realm, as it is invovled in
    // the authentication decision.
    //

    TransitedLength = CertNameToStr( CertContext->dwCertEncodingType,
                                   &CertContext->pCertInfo->Issuer,
                                   dwNameToStrFlags,
                                   NULL,
                                   0 );


    if ( TransitedLength == 0 )
    {
        D_DebugLog((DEB_ERROR,"Failed to get issuer name: 0x%x\n",GetLastError()));
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }


    TransitedRealm->MaximumLength = (USHORT) TransitedLength * sizeof(WCHAR) + sizeof(WCHAR);
    TransitedRealm->Length = (USHORT) TransitedLength * sizeof(WCHAR);
    TransitedRealm->Buffer = (LPWSTR) MIDL_user_allocate( TransitedRealm->MaximumLength );

    if ( TransitedRealm->Buffer == NULL )
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }


    TransitedLength = CertNameToStr( CertContext->dwCertEncodingType,
                               &CertContext->pCertInfo->Issuer,
                               dwNameToStrFlags,
                               TransitedRealm->Buffer,
                               TransitedLength );

    if ( TransitedLength == 0 )
    {
        D_DebugLog((DEB_ERROR,"Failed to get issuer name: 0x%x\n",GetLastError()));
        FILL_EXT_ERROR(pExtendedError, GetLastError(), FILENO, __LINE__);
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    //
    // Convert the "." to "/"
    //


    KdcConvertNameString(
        TransitedRealm,
        L'/'
        );

#endif // later

    //
    // Verify the realm name is correct
    //

    if (!SecData.IsOurRealm(
            &PkAuthenticator->kdc_realm
            ))
    {
        DebugLog((DEB_ERROR,"Client used wrong realm in PK authenticator: %s\n",
            PkAuthenticator->kdc_realm
            ));

        KerbErr = KDC_ERR_S_PRINCIPAL_UNKNOWN;
        goto Cleanup;

    }

    //
    // Verify the service realm and kdc name is correct
    //

    KerbErr = KerbConvertPrincipalNameToString(
                &ClientKdcName,
                &ClientKdcNameType,
                &PkAuthenticator->kdc_name
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    if (!RtlEqualUnicodeString(
            SecData.KdcFullServiceKdcName(),
            &ClientKdcName,
            TRUE))
    {
        if (!RtlEqualUnicodeString(
                SecData.KdcFullServiceDnsName(),
                &ClientKdcName,
                TRUE))
        {
            if (!RtlEqualUnicodeString(
                    SecData.KdcFullServiceName(),
                    &ClientKdcName,
                    TRUE))
            {
                DebugLog((DEB_ERROR,"Client provided KDC name is wrong: %wZ\n",
                    &ClientKdcName));

                KerbErr = KDC_ERR_KDC_NAME_MISMATCH;
                goto Cleanup;
            }

        }
    }

    //
    // Now verify the time
    //

    KerbConvertGeneralizedTimeToLargeInt(
        &ClientTime,
        &PkAuthenticator->client_time,
        PkAuthenticator->cusec
        );

    if (!KerbCheckTimeSkew(
            &CurrentTime,
            &ClientTime,
            &SkewTime))
    {
        KerbErr = KRB_AP_ERR_SKEW;
        goto Cleanup;
    }

    *Nonce = PkAuthenticator->nonce;

    //
    // Generate a temporary key. First find a good encryption type
    //

    KerbErr = KerbConvertCryptListToArray(
                &EtypeArray,
                &EtypeCount,
                ClientRequest->encryption_type
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    Status = CDFindCommonCSystem(
                EtypeCount,
                EtypeArray,
                &CommonEtype
                );
    if (!NT_SUCCESS(Status))
    {
        KerbErr = KDC_ERR_ETYPE_NOTSUPP;
        goto Cleanup;
    }

    KerbErr = KerbMakeKey(
                CommonEtype,
                EncryptionKey
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    //
    // Build the return structure
    //

    PackedPkAsRep = (PKERB_PA_DATA_LIST) MIDL_user_allocate(sizeof(KERB_PA_DATA_LIST));
    if (PackedPkAsRep == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

    RtlZeroMemory(
        PackedPkAsRep,
        sizeof(KERB_PA_DATA_LIST)
        );

    PackedPkAsRep->next = NULL;
    PackedPkAsRep->value.preauth_data_type = KRB5_PADATA_PK_AS_REP;

    //
    // Success. Now build the reply
    //

    if (PkAsReq2 != NULL)
    {
        KERB_PA_PK_AS_REP2 Reply = {0};

        //
        // Create the reply key package
        //

        //
        // Create the reply key package, which contains the key used to encrypt
        // the AS_REPLY.
        //

        KeyPack.reply_key_package.nonce = *Nonce;
        KeyPack.reply_key_package.reply_key = *EncryptionKey;

        KerbErr = KerbPackData(
                    &KeyPack.reply_key_package,
                    KERB_REPLY_KEY_PACKAGE2_PDU,
                    &PackedKeyPackSize,
                    &PackedKeyPack
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }

        //
        // Acquire a crypt context for the private key of the certificate
        //

        if (!CryptAcquireCertificatePrivateKey(
                    KdcCert,
                    0,              // no flags
                    NULL,           // reserved
                    &KdcProvider,
                    NULL,           // no key spec
                    &FreeProvider
                    ))
        {
            DebugLog((DEB_ERROR,"Failed to acquire KDC certificate private key: 0x%x\n",GetLastError()));
            FILL_EXT_ERROR(pExtendedError, GetLastError(), FILENO, __LINE__);
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }

        //
        // Now, to sign the reply key package
        //

        Status = ScHelperSignMessage(
                    NULL,                       // no pin
                    NULL,                       // no logon info
                    KdcProvider,
                    KERB_PKINIT_SIGNATURE_ALG,
                    PackedKeyPack,
                    PackedKeyPackSize,
                    PkSignature,
                    &PkSignatureLength
                    );
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR,"Failed to sign keypack: 0x%x\n",Status));
            FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__);
            KerbErr = KRB_AP_ERR_MODIFIED;
            goto Cleanup;
        }

        //
        // Copy the temporary signature into the return structure
        //

        KeyPack.reply_key_signature.pkcs_signature.length = PkSignatureLength * 8;  // because it is a bit string
        KeyPack.reply_key_signature.pkcs_signature.value = PkSignature;
        KeyPack.reply_key_signature.signature_algorithm.algorithm = KdcSignatureAlg;

        //
        // Now marshall the signed key package
        //

        KerbErr = KerbPackData(
                    &KeyPack,
                    KERB_SIGNED_REPLY_KEY_PACKAGE_PDU,
                    &SignedKeyPackSize,
                    &SignedKeyPack
                    );

        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }

        //
        // Just encrypt the key package
        //

        PackedKey = SignedKeyPack;
        PackedKeySize = SignedKeyPackSize;

        //
        // Zero these out so we don't free them twice
        //

        SignedKeyPack = NULL;
        SignedKeyPackSize = 0;


        //
        // Compute the size of the encrypted temp key
        //
        //


ChangeCryptAlg2:

        if (Kdc3DesSupported && KdcCheckForEtype(ClientRequest->encryption_type, KERB_PKINIT_SEAL_ETYPE))
        {
            Used3Des = TRUE;
            CryptAlg.pszObjId = KERB_PKINIT_SEAL_OID;
        }
        else
        {
            CryptAlg.pszObjId = KERB_PKINIT_EXPORT_SEAL_OID;
            if (!KdcCheckForEtype(ClientRequest->encryption_type, KERB_PKINIT_EXPORT_SEAL_ETYPE))
            {
                DebugLog((DEB_WARN,"Client doesn't claim to support exportable pkinit encryption type %d\n",
                    KERB_PKINIT_EXPORT_SEAL_ETYPE));
            }
        }

        RequiredSize = 0;
        Status = ScHelperEncryptMessage(
                    NULL,
                    KdcClientProvider,
                    CertContext,
                    &CryptAlg,
                    PackedKey,
                    PackedKeySize,
                    NULL,
                    (PULONG) &RequiredSize
                    );
        if ((Status != ERROR_MORE_DATA) && (Status != STATUS_SUCCESS))
        {
            //
            // 3des is only supported on domestic builds with the
            // strong cryptography pack installed.
            //

            if ((Status == NTE_BAD_ALGID) && (Used3Des))
            {
                Kdc3DesSupported = FALSE;
                goto ChangeCryptAlg2;
            }
            DebugLog((DEB_ERROR,"Failed to encrypt message: %x\n",Status));
            FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__);
            KerbErr = KRB_AP_ERR_MODIFIED;
            goto Cleanup;
        }


        //
        // Allocate the output size
        //

        EncryptedKeyPack  = (PBYTE) MIDL_user_allocate(RequiredSize);
        if (EncryptedKeyPack == NULL)
        {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }

        //
        // Really do the encryption
        //


        Status = ScHelperEncryptMessage(
                    NULL,
                    KdcClientProvider,
                    CertContext,
                    &CryptAlg,
                    PackedKey,
                    PackedKeySize,
                    EncryptedKeyPack,
                    &RequiredSize
                    );
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR,"Failed to encrypt message: %x\n",Status));
            FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__);
            KerbErr = KRB_AP_ERR_MODIFIED;
            goto Cleanup;
        }

        //
        // Create the cert list for the reply
        //

        KerbErr = KerbCreateCertificateList(
                    &CertList,
                    KdcCert
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }


        //
        // We will be returning the KDC cert as well as a package containing
        // a temporary key
        //

        Reply.bit_mask |= KERB_PA_PK_AS_REP2_kdc_cert_present;


        //
        // Now, to finish the reply, we need a handle to the KDCs certificate
        //

        Reply.kdc_cert = (KERB_PA_PK_AS_REP2_kdc_cert) CertList;

        Reply.temp_key_package.choice = pkinit_enveloped_data_chosen;
        Reply.temp_key_package.u.pkinit_enveloped_data.length = (int) RequiredSize;
        Reply.temp_key_package.u.pkinit_enveloped_data.value = EncryptedKeyPack;

        KerbErr = KerbPackData(
                    &Reply,
                    KERB_PA_PK_AS_REP2_PDU,
                    (PULONG) &PackedPkAsRep->value.preauth_data.length,
                    &PackedPkAsRep->value.preauth_data.value
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }
    }
    else
    {
        KERB_PA_PK_AS_REP Reply = {0};

        //
        // Create the reply key package
        //

        //
        // Create the reply key package, which contains the key used to encrypt
        // the AS_REPLY.
        //

        ReplyKey.nonce = *Nonce;
        ReplyKey.reply_key = *EncryptionKey;

        KerbErr = KerbPackData(
                    &ReplyKey,
                    KERB_REPLY_KEY_PACKAGE_PDU,
                    &PackedKeyPackSize,
                    &PackedKeyPack
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }

        //
        // Acquire a crypt context for the private key of the certificate
        //

        if (!CryptAcquireCertificatePrivateKey(
                    KdcCert,
                    0,              // no flags
                    NULL,           // reserved
                    &KdcProvider,
                    NULL,           // no key spec
                    &FreeProvider
                    ))
        {
            DebugLog((DEB_ERROR,"Failed to acquire KDC certificate private key: 0x%x\n",GetLastError()));
            FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__);
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }

        //
        // Now, to sign the reply key package
        //

        CryptAlg.pszObjId = KERB_PKINIT_SIGNATURE_OID;

        Status = ScHelperSignPkcsMessage(
                    NULL,                       // no pin
                    NULL,                       // no logon info
                    KdcProvider,
                    KdcCert,
                    &CryptAlg,
                    CRYPT_MESSAGE_SILENT_KEYSET_FLAG, // dwSignMessageFlags
                    PackedKeyPack,
                    PackedKeyPackSize,
                    SignedKeyPack,
                    &SignedKeyPackSize
                    );



        if ((Status != ERROR_MORE_DATA) && (Status != STATUS_SUCCESS))
        {
            DebugLog((DEB_ERROR,"Failed to encrypt message: %x\n",Status));
            FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__);
            KerbErr = KRB_AP_ERR_MODIFIED;
            goto Cleanup;
        }

        SignedKeyPack = (PBYTE) MIDL_user_allocate(SignedKeyPackSize);
        if (SignedKeyPack == NULL)
        {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }
        Status = ScHelperSignPkcsMessage(
                    NULL,                       // no pin
                    NULL,                       // no logon info
                    KdcProvider,
                    KdcCert,
                    &CryptAlg,
                    CRYPT_MESSAGE_SILENT_KEYSET_FLAG, // dwSignMessageFlags
                    PackedKeyPack,
                    PackedKeyPackSize,
                    SignedKeyPack,
                    &SignedKeyPackSize
                    );

        if (Status != STATUS_SUCCESS)
        {
            DebugLog((DEB_ERROR,"Failed to sign pkcs message: 0x%x\n",Status));
            FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__);
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }

        //
        // Now encrypt the content
        //

        //
        // Compute the size of the encrypted temp key
        //
        //


ChangeCryptAlg:
        if (Kdc3DesSupported && KdcCheckForEtype(ClientRequest->encryption_type, KERB_PKINIT_SEAL_ETYPE))
        {
            Used3Des = TRUE;
            CryptAlg.pszObjId = KERB_PKINIT_SEAL_OID;
        }
        else
        {
            CryptAlg.pszObjId = KERB_PKINIT_EXPORT_SEAL_OID;
            if (!KdcCheckForEtype(ClientRequest->encryption_type, KERB_PKINIT_EXPORT_SEAL_ETYPE))
            {
                DebugLog((DEB_WARN,"Client doesn't claim to support exportable pkinit encryption type %d\n",
                    KERB_PKINIT_EXPORT_SEAL_ETYPE));
            }
        }

        RequiredSize = 0;
        Status = ScHelperEncryptMessage(
                    NULL,
                    KdcClientProvider,
                    CertContext,
                    &CryptAlg,
                    SignedKeyPack,
                    SignedKeyPackSize,
                    NULL,
                    (PULONG) &RequiredSize
                    );
        if ((Status != ERROR_MORE_DATA) && (Status != STATUS_SUCCESS))
        {
            //
            // 3des is only supported on domestic builds with the
            // strong cryptography pack installed.
            //

            if ((Status == NTE_BAD_ALGID) && (Used3Des))
            {
                Kdc3DesSupported = FALSE;
                goto ChangeCryptAlg;
            }

            DebugLog((DEB_ERROR,"Failed to encrypt message (crypto mismatch?): %x\n",Status));
            FILL_EXT_ERROR_EX(pExtendedError, Status, FILENO, __LINE__);
            KerbErr = KRB_AP_ERR_MODIFIED;
            goto Cleanup;
        }


        //
        // Allocate the output size
        //

        EncryptedKeyPack  = (PBYTE) MIDL_user_allocate(RequiredSize);
        if (EncryptedKeyPack == NULL)
        {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }

        //
        // Really do the encryption
        //


        Status = ScHelperEncryptMessage(
                    NULL,
                    KdcClientProvider,
                    CertContext,
                    &CryptAlg,
                    SignedKeyPack,
                    SignedKeyPackSize,
                    EncryptedKeyPack,
                    &RequiredSize
                    );
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR,"Failed to encrypt message: %x\n",Status));
            FILL_EXT_ERROR(pExtendedError, Status, FILENO, __LINE__);
            KerbErr = KRB_AP_ERR_MODIFIED;
            goto Cleanup;
        }

        Reply.u.key_package.value = EncryptedKeyPack;
        Reply.u.key_package.length = RequiredSize;
        Reply.choice = pkinit_enveloped_data_chosen;

        KerbErr = KerbPackData(
                    &Reply,
                    KERB_PA_PK_AS_REP_PDU,
                    (PULONG) &PackedPkAsRep->value.preauth_data.length,
                    &PackedPkAsRep->value.preauth_data.value
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }

    }

    *OutputPreAuthData = PackedPkAsRep;
    PackedPkAsRep = NULL;

Cleanup:

    if (FreeProvider)
    {
        CryptReleaseContext(
            KdcProvider,
            0
            );
    }
    if (PkAsReq != NULL)
    {
        KerbFreeData(
            KERB_PA_PK_AS_REQ_PDU,
            PkAsReq
            );
    }
    if (PkAsReq2 != NULL)
    {
        KerbFreeData(
            KERB_PA_PK_AS_REQ2_PDU,
            PkAsReq2
            );
    }
    if (SignedKeyPack != NULL)
    {
        KdcFreeEncodedData(SignedKeyPack);
    }
    i